<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="2fd647ad9469bb58fc1688a31c856ba421945ca2" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;&lt;code&gt;WITH&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 목록의 모든 쿼리 가 계산됩니다. 이들은 효과적으로 &lt;code&gt;FROM&lt;/code&gt; 목록 에서 참조 할 수있는 임시 테이블 역할을 합니다. &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 로 달리 지정하지 않으면 &lt;code&gt;FROM&lt;/code&gt; 에서 두 번 이상 참조 되는 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 한 번만 계산됩니다 . (아래 &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt; &lt;code&gt;WITH&lt;/code&gt; &lt;/a&gt; 절 참조)</target>
        </trans-unit>
        <trans-unit id="d5d88441c9f02c86f8bfc47e2413965c87d4afdf" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;WITH Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 목록의 모든 쿼리 가 계산됩니다. 이들은 &lt;code&gt;FROM&lt;/code&gt; 목록 에서 참조 할 수있는 임시 테이블 역할을 효과적으로 수행 합니다. &lt;code&gt;FROM&lt;/code&gt; 에서 두 번 이상 참조 되는 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 로 달리 지정되지 않는 한 한 번만 계산됩니다 . (아래의 &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;WITH 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="f087ce49a12f5467c1e1d2b10a821f36bb151962" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit.</source>
          <target state="translated">임시 테이블의 모든 행은 각 트랜잭션 블록의 끝에서 삭제됩니다. 기본적으로 자동 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE는&lt;/a&gt; 각 커밋에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2033a72b30b992b55fdec7e008bb0316322a754e" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit. When used on a partitioned table, this is not cascaded to its partitions.</source>
          <target state="translated">임시 테이블의 모든 행은 각 트랜잭션 블록의 끝에서 삭제됩니다. 기본적으로 자동 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE는&lt;/a&gt; 각 커밋에서 수행됩니다. 파티션 된 테이블에서 사용될 때는 파티션에 계단식으로 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dcf0dcfbfdd9c5f88b82f71ae9c913b23c0891e" translate="yes" xml:space="preserve">
          <source>All rows inserted into a partitioned table will be routed to one of the &lt;em&gt;partitions&lt;/em&gt; based on the value of the partition key. Each partition has a subset of the data defined by its &lt;em&gt;partition bounds&lt;/em&gt;. The currently supported partitioning methods are range, list, and hash.</source>
          <target state="translated">파티션 테이블에 삽입 된 모든 행은 하나에 라우팅 될 것이다 &lt;em&gt;파티션&lt;/em&gt; 분할 키의 값에 기초하여. 각 파티션에는 &lt;em&gt;파티션 경계에&lt;/em&gt; 의해 정의 된 데이터의 하위 집합이 있습니다. 현재 지원되는 분할 방법은 범위, 목록 및 해시입니다.</target>
        </trans-unit>
        <trans-unit id="4513787ec30b4d30ebbb9895538f30d98e3df810" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="translated">모든 표준 및 미리 정의 된 데이터 정렬은 결정적이며 모든 사용자 정의 데이터 정렬은 기본적으로 결정적입니다. 비 결정적 데이터 정렬은 특히 유니 코드의 강력한 기능과 많은 특수한 경우를 고려할 때보다 &quot;올바른&quot;동작을 제공하지만 몇 가지 단점이 있습니다. 무엇보다 성능이 저하됩니다. 또한 패턴 일치 작업과 같은 비 결정적 데이터 정렬에서는 특정 작업을 수행 할 수 없습니다. 따라서 이들은 특별히 원하는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="25b4cbd01fbf767d95283abe0881812c05362a17" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Note, in particular, that B-tree cannot use deduplication with indexes that use a nondeterministic collation. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="translated">모든 표준 및 미리 정의 된 데이터 정렬은 결정적이며 모든 사용자 정의 데이터 정렬은 기본적으로 결정적입니다. 비 결정적 데이터 정렬은 특히 유니 코드의 모든 기능과 많은 특수한 경우를 고려할 때보다 &quot;올바른&quot;동작을 제공하지만 몇 가지 단점도 있습니다. 무엇보다도 이들을 사용하면 성능이 저하됩니다. 특히 B- 트리는 비 결정적 데이터 정렬을 사용하는 인덱스에서 중복 제거를 사용할 수 없습니다. 또한 패턴 일치 작업과 같은 비 결정적 데이터 정렬에서는 특정 작업이 불가능합니다. 따라서 특별히 원하는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="33701db90942013a1dfc5834530a8ecffe185cf9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction.</source>
          <target state="translated">현재 트랜잭션의 모든 명령문은이 트랜잭션에서 첫 번째 쿼리 또는 데이터 수정 명령문이 실행되기 전에 커밋 된 행만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e14dc15c0e8ebe018dfe9b3ade39c8f85c910d9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction. If a pattern of reads and writes among concurrent serializable transactions would create a situation which could not have occurred for any serial (one-at-a-time) execution of those transactions, one of them will be rolled back with a &lt;code&gt;serialization_failure&lt;/code&gt; error.</source>
          <target state="translated">현재 트랜잭션의 모든 명령문은이 트랜잭션에서 첫 번째 쿼리 또는 데이터 수정 명령문이 실행되기 전에 커밋 된 행만 볼 수 있습니다. 동시 직렬화 가능 트랜잭션 간의 읽기 및 쓰기 패턴이 해당 트랜잭션의 직렬 (한 번에 한 번) 실행에 대해 발생할 수없는 상황을 작성하는 경우 그 중 하나가 &lt;code&gt;serialization_failure&lt;/code&gt; 오류 와 함께 롤백됩니다 .</target>
        </trans-unit>
        <trans-unit id="333b8b7d294d7e593e47c576e136baad90efa83c" translate="yes" xml:space="preserve">
          <source>All system-defined SQL objects reside in schema &lt;code&gt;pg_catalog&lt;/code&gt;.</source>
          <target state="translated">모든 시스템 정의 SQL 객체는 스키마 &lt;code&gt;pg_catalog&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd69152cf9c28ea6bdb8489a69a762ca6be86225" translate="yes" xml:space="preserve">
          <source>All systems would have the same &lt;code&gt;shared.conf&lt;/code&gt;. Each server with a particular amount of memory could share the same &lt;code&gt;memory.conf&lt;/code&gt;; you might have one for all servers with 8GB of RAM, another for those having 16GB. And finally &lt;code&gt;server.conf&lt;/code&gt; could have truly server-specific configuration information in it.</source>
          <target state="translated">모든 시스템에는 동일한 &lt;code&gt;shared.conf&lt;/code&gt; 가 있습니다. 특정 양의 메모리를 가진 각 서버는 동일한 &lt;code&gt;memory.conf&lt;/code&gt; 를 공유 할 수 있습니다 . RAM이 8GB 인 모든 서버에 대해 하나, 16GB가있는 서버에 대해 하나를 가질 수 있습니다. 마지막으로 &lt;code&gt;server.conf&lt;/code&gt; 에는 서버 별 구성 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdb84efbad86954ba5aa82c861c3c65c57c671dd" translate="yes" xml:space="preserve">
          <source>All table rows are structured in the same way. There is a fixed-size header (occupying 23 bytes on most machines), followed by an optional null bitmap, an optional object ID field, and the user data. The header is detailed in &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;Table 68.4&lt;/a&gt;. The actual user data (columns of the row) begins at the offset indicated by &lt;code&gt;t_hoff&lt;/code&gt;, which must always be a multiple of the MAXALIGN distance for the platform. The null bitmap is only present if the &lt;em&gt;HEAP_HASNULL&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If it is present it begins just after the fixed header and occupies enough bytes to have one bit per data column (that is, the number of bits that equals the attribute count in &lt;code&gt;t_infomask2&lt;/code&gt;). In this list of bits, a 1 bit indicates not-null, a 0 bit is a null. When the bitmap is not present, all columns are assumed not-null. The object ID is only present if the &lt;em&gt;HEAP_HASOID_OLD&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If present, it appears just before the &lt;code&gt;t_hoff&lt;/code&gt; boundary. Any padding needed to make &lt;code&gt;t_hoff&lt;/code&gt; a MAXALIGN multiple will appear between the null bitmap and the object ID. (This in turn ensures that the object ID is suitably aligned.)</source>
          <target state="translated">모든 테이블 행은 동일한 방식으로 구성됩니다. 고정 크기 헤더 (대부분의 컴퓨터에서 23 바이트를 차지함)와 선택적 널 비트 맵, 선택적 오브젝트 ID 필드 및 사용자 데이터가 있습니다. 헤더는 &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;표 68.4에&lt;/a&gt; 자세히 설명되어 있습니다. 실제 사용자 데이터 (행 열)는 &lt;code&gt;t_hoff&lt;/code&gt; 로 표시되는 오프셋에서 시작하며 , 플랫폼에 대한 MAXALIGN 거리의 배수 여야합니다. 경우 생성 널 비트 맵은 존재 &lt;em&gt;HEAP_HASNULL의&lt;/em&gt; 비트가 설정된다 &lt;code&gt;t_infomask&lt;/code&gt; . 존재하는 경우 고정 헤더 바로 다음부터 시작하여 데이터 &lt;code&gt;t_infomask2&lt;/code&gt; 하나의 비트 (즉, t_infomask2 의 속성 수와 동일한 비트 수)를 갖기에 충분한 바이트를 차지합니다.). 이 비트 목록에서 1 비트는 널이 아님을 나타내고 0 비트는 널입니다. 비트 맵이 없으면 모든 열이 널이 아닌 것으로 간주됩니다. 경우 생성 오브젝트 ID 만 존재 &lt;em&gt;HEAP_HASOID_OLD의&lt;/em&gt; 비트가 설정된다 &lt;code&gt;t_infomask&lt;/code&gt; . 있는 경우 &lt;code&gt;t_hoff&lt;/code&gt; 경계 바로 앞에 나타납니다 . &lt;code&gt;t_hoff&lt;/code&gt; 를 MAXALIGN 배수로 만드는 데 필요한 패딩 은 널 비트 맵과 객체 ID 사이에 나타납니다. (이는 차례로 객체 ID가 적절하게 정렬되도록합니다.)</target>
        </trans-unit>
        <trans-unit id="07e8311d5ee709346fa3f96903022cdc35bc8edc" translate="yes" xml:space="preserve">
          <source>All tables in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all tables to be moved first and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move tables owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command; use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER TABLE&lt;/code&gt; invocations instead if desired. The &lt;code&gt;information_schema&lt;/code&gt; relations are not considered part of the system catalogs and will be moved. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; 양식 을 사용하여 테이블 스페이스에있는 현재 데이터베이스의 모든 테이블을 이동할 수 있습니다.이 테이블은 모든 테이블을 먼저 이동시킨 다음 각 테이블을 이동시킵니다. 이 양식은 또한 지정된 역할이 소유 한 테이블 만 이동하는 &lt;code&gt;OWNED BY&lt;/code&gt; 를 지원 합니다. 는 IF &lt;code&gt;NOWAIT&lt;/code&gt; 의 옵션이 지정되는 즉시 필요한 잠금을 모두 취득 할 수없는 경우 명령이 실패합니다. 시스템 카탈로그는이 명령으로 이동되지 않습니다. 사용 &lt;code&gt;ALTER DATABASE&lt;/code&gt; 또는 명시 적 &lt;code&gt;ALTER TABLE&lt;/code&gt; 호출하는 대신 원하는 경우. &lt;code&gt;information_schema&lt;/code&gt; 관계는 시스템 카탈로그의 일부로 간주되지 않으며 이동합니다. &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fba1b0761d495deac6051791b1b8f0b77af030f7" translate="yes" xml:space="preserve">
          <source>All the GiST support methods are normally called in short-lived memory contexts; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will get reset after each tuple is processed. It is therefore not very important to worry about pfree'ing everything you palloc. However, in some cases it's useful for a support method to cache data across repeated calls. To do that, allocate the longer-lived data in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt;, and keep a pointer to it in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt;. Such data will survive for the life of the index operation (e.g., a single GiST index scan, index build, or index tuple insertion). Be careful to pfree the previous value when replacing a &lt;code&gt;fn_extra&lt;/code&gt; value, or the leak will accumulate for the duration of the operation.</source>
          <target state="translated">모든 GiST 지원 방법은 일반적으로 수명이 짧은 메모리 컨텍스트에서 호출됩니다. 즉, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; 는 각 튜플이 처리 된 후에 재설정됩니다. 그러므로 당신이 palloc하는 모든 것을 pfree'ing하는 것에 대해 걱정하는 것은 그리 중요하지 않습니다. 그러나 어떤 경우에는 지원 메소드가 반복 호출을 통해 데이터를 캐시하는 것이 유용합니다. 이를 위해에서 더 이상 수명이 데이터 할당 &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt; 을 , 그리고에 대한 포인터를 유지 &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt; . 이러한 데이터는 인덱스 작업 수명 동안 유지됩니다 (예 : 단일 GiST 인덱스 스캔, 인덱스 빌드 또는 인덱스 튜플 삽입). &lt;code&gt;fn_extra&lt;/code&gt; 값을 교체 할 때 이전 값을 고정 시키십시오. 그렇지 않으면 작동 시간 동안 누수가 누적됩니다.</target>
        </trans-unit>
        <trans-unit id="1775f572f652b9b020df7dce36fbde055a9f9549" translate="yes" xml:space="preserve">
          <source>All the SP-GiST support methods are normally called in a short-lived memory context; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will be reset after processing of each tuple. It is therefore not very important to worry about pfree'ing everything you palloc. (The &lt;code&gt;config&lt;/code&gt; method is an exception: it should try to avoid leaking memory. But usually the &lt;code&gt;config&lt;/code&gt; method need do nothing but assign constants into the passed parameter struct.)</source>
          <target state="translated">모든 SP-GiST 지원 방법은 일반적으로 수명이 짧은 메모리 컨텍스트에서 호출됩니다. 즉, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; 는 각 튜플을 처리 한 후에 재설정됩니다. 그러므로 당신이 palloc하는 모든 것을 pfree'ing하는 것에 대해 걱정하는 것은 그리 중요하지 않습니다. ( &lt;code&gt;config&lt;/code&gt; 메소드는 예외입니다 : 메모리 누수를 피하려고 노력해야합니다. 그러나 일반적으로 &lt;code&gt;config&lt;/code&gt; 메소드는 전달 된 매개 변수 struct에 상수를 지정할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="45bde084b879a44097ffbb7f22a89ae3a6f15f28" translate="yes" xml:space="preserve">
          <source>All the actions except &lt;code&gt;RENAME&lt;/code&gt; and &lt;code&gt;SET SCHEMA&lt;/code&gt; can be combined into a list of multiple alterations to apply in parallel. For example, it is possible to add several columns and/or alter the type of several columns in a single command.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 및 &lt;code&gt;SET SCHEMA&lt;/code&gt; 를 제외한 모든 조치 를 여러 변경 사항 목록으로 결합하여 동시에 적용 할 수 있습니다. 예를 들어, 단일 명령으로 여러 열을 추가하거나 여러 열의 유형을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="510081c46bee5d125d10e16db44ba6aa06aa8209" translate="yes" xml:space="preserve">
          <source>All the aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;Table 9.57&lt;/a&gt; ignore null values in their sorted input. For those that take a &lt;code&gt;fraction&lt;/code&gt; parameter, the fraction value must be between 0 and 1; an error is thrown if not. However, a null fraction value simply produces a null result.</source>
          <target state="translated">&lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;표 9.57에&lt;/a&gt; 나열된 모든 집계 는 정렬 된 입력에서 널값을 무시합니다. 테이크 그들을 위해 &lt;code&gt;fraction&lt;/code&gt; 파라미터를, 분수 값은 0과 1 사이 여야; 그렇지 않은 경우 오류가 발생합니다. 그러나 널 분수 값은 단순히 널 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="51ab62b62647a9e48b750694e717b8b41fe65f92" translate="yes" xml:space="preserve">
          <source>All the backslash commands of a given conditional block must appear in the same source file. If EOF is reached on the main input file or an &lt;code&gt;\include&lt;/code&gt;-ed file before all local &lt;code&gt;\if&lt;/code&gt;-blocks have been closed, then psql will raise an error.</source>
          <target state="translated">주어진 조건부 블록의 모든 백 슬래시 명령은 동일한 소스 파일에 나타나야합니다. 모든 로컬 &lt;code&gt;\if&lt;/code&gt; -block을 닫기 전에 기본 입력 파일 또는 &lt;code&gt;\include&lt;/code&gt; -ed 파일 에서 EOF에 도달 하면 psql에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c3df3ceb9c111c6a03e79138ef843c3f5502324f" translate="yes" xml:space="preserve">
          <source>All the constraints that refer to the index are changed to refer to the new index definition, and the names of the indexes are changed. At this point, &lt;code&gt;pg_index.indisvalid&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; for the new index and to &amp;ldquo;false&amp;rdquo; for the old, and a cache invalidation is done causing all sessions that referenced the old index to be invalidated.</source>
          <target state="translated">색인을 참조하는 모든 제한 조건이 새 색인 정의를 참조하도록 변경되고 색인 이름이 변경됩니다. 이 시점에서 &lt;code&gt;pg_index.indisvalid&lt;/code&gt; 는 새 인덱스의 경우 &quot;true&quot;로, 이전 인덱스의 경우 &quot;false&quot;로 전환되고 캐시 무효화가 수행되어 이전 인덱스를 참조한 모든 세션이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="58e9eb20e27c19e1e0424c58bd8a9c7b575ba760" translate="yes" xml:space="preserve">
          <source>All the date/time data types also accept the special literal value &lt;code&gt;now&lt;/code&gt; to specify the current date and time (again, interpreted as the transaction start time). Thus, the following three all return the same result:</source>
          <target state="translated">모든 날짜 / 시간 데이터 유형은 &lt;code&gt;now&lt;/code&gt; 특수한 리터럴 값을 수락 하여 현재 날짜 및 시간을 지정합니다 (다시 말해 트랜잭션 시작 시간으로 해석 됨). 따라서 다음 세 가지 모두 동일한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04a9db0f3580dacac057df2d96a2b53bd9011eea" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt;.</source>
          <target state="translated">모든 세부 사항은 &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7055165401c8e4a16f7e52ca1e39b100c0c219f9" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt;.</source>
          <target state="translated">모든 세부 사항은 &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f6c8098d40647f8499682bcc9a9b6ba89c0f7d" translate="yes" xml:space="preserve">
          <source>All the forms of ALTER TABLE that act on a single table, except &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;SET SCHEMA&lt;/code&gt;, &lt;code&gt;ATTACH PARTITION&lt;/code&gt;, and &lt;code&gt;DETACH PARTITION&lt;/code&gt; can be combined into a list of multiple alterations to be applied together. For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; , &lt;code&gt;SET SCHEMA&lt;/code&gt; , &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 및 &lt;code&gt;DETACH PARTITION&lt;/code&gt; 을 제외한 단일 테이블에서 작동하는 ALTER TABLE의 모든 양식을 여러 변경 사항 목록으로 결합하여 함께 적용 할 수 있습니다. 예를 들어, 단일 명령으로 여러 열을 추가하거나 여러 열의 유형을 변경할 수 있습니다. 테이블을 한 번만 통과하면되므로 큰 테이블에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f31e857d83f608bd0b8b4018bcb4f55f12705482" translate="yes" xml:space="preserve">
          <source>All the functions and operators described below that take &lt;code&gt;time&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt; inputs actually come in two variants: one that takes &lt;code&gt;time with time zone&lt;/code&gt; or &lt;code&gt;timestamp with time zone&lt;/code&gt;, and one that takes &lt;code&gt;time without time zone&lt;/code&gt; or &lt;code&gt;timestamp without time zone&lt;/code&gt;. For brevity, these variants are not shown separately. Also, the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators come in commutative pairs (for example both date + integer and integer + date); we show only one of each such pair.</source>
          <target state="translated">아래에 설명 된 &lt;code&gt;time&lt;/code&gt; 또는 &lt;code&gt;timestamp&lt;/code&gt; 입력 을받는 모든 함수와 연산자는 실제로 두 가지 변형이 있습니다. 하나는 &lt;code&gt;time with time zone&lt;/code&gt; 이 걸리 거나 &lt;code&gt;timestamp with time zone&lt;/code&gt; 이 걸리고 다른 하나는 &lt;code&gt;time without time zone&lt;/code&gt; 또는 &lt;code&gt;timestamp without time zone&lt;/code&gt; 입니다. 간결하게하기 위해 이러한 변형은 별도로 표시되지 않습니다. 또한 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; 연산자는 교환 쌍으로 제공됩니다 (예 : 날짜 + 정수 및 정수 + 날짜). 각 쌍 중 하나만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="782a3c585f1fd27c2deebeab5aeef9142292fec9" translate="yes" xml:space="preserve">
          <source>All the items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; as well as &lt;code&gt;jsonb_insert&lt;/code&gt; except the last item must be present in the &lt;code&gt;target&lt;/code&gt;. If &lt;code&gt;create_missing&lt;/code&gt; is false, all items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; must be present. If these conditions are not met the &lt;code&gt;target&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">의 모든 항목 &lt;code&gt;path&lt;/code&gt; 의 매개 변수 &lt;code&gt;jsonb_set&lt;/code&gt; 뿐만 아니라 &lt;code&gt;jsonb_insert&lt;/code&gt; 마지막 항목을 제외하고는에 있어야합니다 &lt;code&gt;target&lt;/code&gt; . 경우 &lt;code&gt;create_missing&lt;/code&gt; 은 거짓,의 모든 항목 &lt;code&gt;path&lt;/code&gt; 의 매개 변수 &lt;code&gt;jsonb_set&lt;/code&gt; 이 있어야합니다. 이러한 조건이 충족되지 않으면 &lt;code&gt;target&lt;/code&gt; 이 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16b021d730b6ad62e07cfcc798d60a9ae4e55f2d" translate="yes" xml:space="preserve">
          <source>All the other details are the same as explained in the previous item.</source>
          <target state="translated">다른 모든 세부 사항은 이전 항목에서 설명한 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="58d1929aa1a1a6a3046413da0a4c92627889c5ff" translate="yes" xml:space="preserve">
          <source>All the text search functions that accept an optional &lt;code&gt;regconfig&lt;/code&gt; argument will use the configuration specified by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; when that argument is omitted.</source>
          <target state="translated">선택적 &lt;code&gt;regconfig&lt;/code&gt; 인수 를 허용하는 모든 텍스트 검색 함수는 해당 인수가 생략 될 때 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config에&lt;/a&gt; 의해 지정된 구성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5fd8eaf630761d65327b4b1a07fcbae46e8425a5" translate="yes" xml:space="preserve">
          <source>All these actions are performed using the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command, whose reference page contains details beyond those given here.</source>
          <target state="translated">이 모든 조치는 참조 페이지에 여기에 제공된 것 이외의 세부 사항이 포함 된 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령을 사용하여 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="b94dc0adfca08e05341c41a7517a1ba1c57ee9cc" translate="yes" xml:space="preserve">
          <source>All these functions are intended to be used to lock application-defined resources, which can be identified either by a single 64-bit key value or two 32-bit key values (note that these two key spaces do not overlap). If another session already holds a conflicting lock on the same resource identifier, the functions will either wait until the resource becomes available, or return a &lt;code&gt;false&lt;/code&gt; result, as appropriate for the function. Locks can be either shared or exclusive: a shared lock does not conflict with other shared locks on the same resource, only with exclusive locks. Locks can be taken at session level (so that they are held until released or the session ends) or at transaction level (so that they are held until the current transaction ends; there is no provision for manual release). Multiple session-level lock requests stack, so that if the same resource identifier is locked three times there must then be three unlock requests to release the resource in advance of session end.</source>
          <target state="translated">이러한 모든 함수는 단일 64 비트 키 값 또는 두 개의 32 비트 키 값으로 식별 할 수있는 애플리케이션 정의 리소스를 잠그는 데 사용됩니다 (이 두 키 공간은 겹치지 않음). 다른 세션이 이미 동일한 리소스 식별자에 대해 충돌하는 잠금을 보유하고있는 경우 함수는 리소스를 사용할 수있을 때까지 기다리거나 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.결과, 기능에 적합합니다. 잠금은 공유 또는 배타적 일 수 있습니다. 공유 잠금은 동일한 리소스의 다른 공유 잠금과 충돌하지 않고 배타적 잠금 만 사용합니다. 잠금은 세션 수준 (해제 또는 세션이 종료 될 때까지 유지됨) 또는 트랜잭션 수준 (현재 트랜잭션이 끝날 때까지 유지됨, 수동 해제에 대한 규정 없음)에서 취할 수 있습니다. 여러 세션 수준 잠금 요청이 스택되므로 동일한 리소스 식별자가 세 번 잠긴 경우 세션 종료 전에 리소스를 해제하기위한 잠금 해제 요청이 세 번 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fddab2dff735a90badf611e7a98983fea7c65273" translate="yes" xml:space="preserve">
          <source>All these functions require object OIDs to identify the object to be checked. If you want to test an object by name, it is convenient to use the OID alias types (&lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, or &lt;code&gt;regdictionary&lt;/code&gt;), for example:</source>
          <target state="translated">이러한 모든 기능에는 검사 할 개체를 식별하기 위해 개체 OID가 필요합니다. 이름으로 객체를 테스트하려면 다음과 같이 OID 별명 유형 ( &lt;code&gt;regclass&lt;/code&gt; , &lt;code&gt;regtype&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; , &lt;code&gt;regconfig&lt;/code&gt; 또는 &lt;code&gt;regdictionary&lt;/code&gt; ) 을 사용하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="5eb86c80e753870bd74e864dca4813e41a9bf81c" translate="yes" xml:space="preserve">
          <source>All this is encrypted with the session key and placed in the data packet.</source>
          <target state="translated">이 모든 것이 세션 키로 암호화되어 데이터 패킷에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="79ae9218d6216a25f546357f769737d4eb8e6a9b" translate="yes" xml:space="preserve">
          <source>All this is happening within the transaction block, so none of it is visible to other database sessions. When and if you commit the transaction block, the committed actions become visible as a unit to other sessions, while the rolled-back actions never become visible at all.</source>
          <target state="translated">이 모든 것은 트랜잭션 블록 내에서 일어나므로 다른 데이터베이스 세션에서는 볼 수 없습니다. 트랜잭션 블록을 커밋 할 때 커밋 된 작업은 다른 세션에 대한 단위로 표시되지만 롤백 된 작업은 전혀 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5fad09671c41f98ab40f3e4d5ed6015e3ae8fcb" translate="yes" xml:space="preserve">
          <source>All timezone-aware dates and times are stored internally in UTC. They are converted to local time in the zone specified by the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; configuration parameter before being displayed to the client.</source>
          <target state="translated">모든 시간대 인식 날짜 및 시간은 내부적으로 UTC로 저장됩니다. 클라이언트에 표시되기 전에 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 구성 매개 변수로 지정된 영역에서 현지 시간으로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="d5322b3927e2a3af2ef8b19f81ff10045b29cd91" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfrozenxid&lt;/code&gt; values.</source>
          <target state="translated">이 데이터베이스 이전의 모든 트랜잭션 ID는이 데이터베이스에서 영구 ( &quot;동결 된&quot;) 트랜잭션 ID로 대체되었습니다. 트랜잭션 ID 랩 어라운드를 방지하거나 &lt;code&gt;pg_xact&lt;/code&gt; 를 축소 하기 위해 데이터베이스를 정리해야하는지 여부를 추적하는 데 사용됩니다 . 테이블 당 &lt;code&gt;pg_class&lt;/code&gt; 의 최소값입니다 . &lt;code&gt;relfrozenxid&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="086e1ad2933d663306e6cec529b31029a01389df" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidTransactionId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">이 테이블 이전의 모든 트랜잭션 ID는이 테이블에서 영구 ( &quot;동결 된&quot;) 트랜잭션 ID로 대체되었습니다. 트랜잭션 ID 랩 어라운드를 방지하거나 &lt;code&gt;pg_xact&lt;/code&gt; 를 축소 하기 위해 테이블을 정리해야하는지 여부를 추적하는 데 사용됩니다 . 관계가 테이블이 아닌 경우 0 ( &lt;code&gt;InvalidTransactionId&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="f420391c504d54ccc175474041008eed502760b8" translate="yes" xml:space="preserve">
          <source>All type conversion rules are designed with several principles in mind:</source>
          <target state="translated">모든 유형 변환 규칙은 몇 가지 원칙을 염두에두고 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="109d3489123ca72cb87beebd6d4f929a800626a1" translate="yes" xml:space="preserve">
          <source>All values must be single-quoted. Escape single quotes used within a value with a backslash. Backslashes meant as data can, but need not, be doubled; this follows Perl's rules for simple quoted literals. Note that backslashes appearing as data will be treated as escapes by the bootstrap scanner, according to the same rules as for escape string constants (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;); for example &lt;code&gt;\t&lt;/code&gt; converts to a tab character. If you actually want a backslash in the final value, you will need to write four of them: Perl strips two, leaving &lt;code&gt;\\&lt;/code&gt; for the bootstrap scanner to see.</source>
          <target state="translated">모든 값은 작은 따옴표로 묶어야합니다. 백 슬래시로 값 내에 사용 된 작은 따옴표를 이스케이프 처리하십시오. 데이터가 의미하는 백 슬래시는 두 배가 될 수 있지만 반드시 그럴 필요는 없습니다. 이것은 간단한 인용 리터럴에 대한 Perl의 규칙을 따릅니다. 데이터로 나타나는 백 슬래시는 이스케이프 문자열 상수와 동일한 규칙에 따라 부트 스트랩 스캐너에 의해 이스케이프 처리됩니다 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;섹션 4.1.2.2&lt;/a&gt; 참조 ). 예를 들어 &lt;code&gt;\t&lt;/code&gt; 는 탭 문자로 변환됩니다. 실제로 최종 값에 백 슬래시를 원하면 4 개를 작성해야합니다. Perl은 2를 제거 하고 부트 스트랩 스캐너는 &lt;code&gt;\\&lt;/code&gt; 를 남겨 둡니다 .</target>
        </trans-unit>
        <trans-unit id="b86517f687c2cdb1c2c9f1b4d883ebc3f627ec3f" translate="yes" xml:space="preserve">
          <source>All weather records belonging to Hayward are removed.</source>
          <target state="translated">Hayward에 속하는 모든 날씨 기록이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ad7019350bb4e8cf04fe867a5271fe82db68f450" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Andrey Oktyabrski did a great work on adding new functions and operations.</source>
          <target state="translated">모든 작업은 Teodor Sigaev ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; )와 Oleg Bartunov ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; )가 수행했습니다. 자세한 내용은 &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; 를 참조 하십시오 . Andrey Oktyabrski는 새로운 기능과 작업을 추가하는 데 많은 노력을 기울였습니다.</target>
        </trans-unit>
        <trans-unit id="4288707b0efed23059331a4d938505610024687d" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Authors would like to thank Eugeny Rodichev for helpful discussions. Comments and bug reports are welcome.</source>
          <target state="translated">모든 작업은 Teodor Sigaev ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt; )와 Oleg Bartunov ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; )가 수행했습니다. 자세한 내용은 &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; 를 참조 하십시오 . 도움을 주신 토론에 대해 Eugeny Rodichev에게 감사의 말씀을 전합니다. 의견 및 버그 리포트를 환영합니다.</target>
        </trans-unit>
        <trans-unit id="f34719d5f269658e4173abae81da05904e2f90b4" translate="yes" xml:space="preserve">
          <source>Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.</source>
          <target state="translated">데이터베이스 사용자가 서버 측 프로그램을 실행할 수있는 COPY 및 기타 기능과 마찬가지로 데이터베이스 서버에서 프로그램을 실행하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="cb7c466538ce28419fa5a720e552c9faf281f480" translate="yes" xml:space="preserve">
          <source>Allow question mark as placeholder for compatibility reasons. This used to be the default long ago.</source>
          <target state="translated">호환성을 위해 물음표를 자리 표시 자로 허용하십시오. 이것은 오래 전의 기본값이었습니다.</target>
        </trans-unit>
        <trans-unit id="45c4206b6f2ee2080c8508868577dbea292b358b" translate="yes" xml:space="preserve">
          <source>Allow reading files from any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">COPY 및 기타 파일 액세스 기능을 사용하여 데이터베이스가 서버에서 액세스 할 수있는 모든 위치에서 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f03ae30c79df36f9c350de6f69bb0b74ebd9a17" translate="yes" xml:space="preserve">
          <source>Allow the connection unconditionally. This method allows anyone that can connect to the PostgreSQL database server to login as any PostgreSQL user they wish, without the need for a password or any other authentication. See &lt;a href=&quot;auth-trust&quot;&gt;Section 20.4&lt;/a&gt; for details.</source>
          <target state="translated">무조건 연결을 허용하십시오. 이 방법을 사용하면 PostgreSQL 데이터베이스 서버에 연결할 수있는 누구나 암호 나 다른 인증 없이도 원하는 PostgreSQL 사용자로 로그인 할 수 있습니다. 자세한 내용 &lt;a href=&quot;auth-trust&quot;&gt;은 20.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="015b98532a3fe432082ea0986c77ac2b5c3dbd03" translate="yes" xml:space="preserve">
          <source>Allow writing to files in any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">COPY 및 기타 파일 액세스 기능을 사용하여 데이터베이스가 서버에서 액세스 할 수있는 모든 위치의 파일에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8d71f61a1ee50e974ca597aaf1819fc96625f9e" translate="yes" xml:space="preserve">
          <source>Allowed Access</source>
          <target state="translated">허용 된 액세스</target>
        </trans-unit>
        <trans-unit id="76b9c247fd0d4d88ff31bffe6ae1c77fef7baa54" translate="yes" xml:space="preserve">
          <source>Allowed values of an enum parameter (null for non-enum values)</source>
          <target state="translated">열거 형 매개 변수의 허용 된 값 (비 열거 형 값의 경우 널)</target>
        </trans-unit>
        <trans-unit id="52773c9887de8a80602d4df5e04153e486ddd9ba" translate="yes" xml:space="preserve">
          <source>Allowed, but not in PG</source>
          <target state="translated">PG에서는 허용되지 않지만 허용됨</target>
        </trans-unit>
        <trans-unit id="70154177253445e1612a606653b6fcdbcd216626" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; of a row from a table, view, etc. (In practice, any nontrivial &lt;code&gt;DELETE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to delete.)</source>
          <target state="translated">테이블, 뷰 등에서 행의 &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; 를 허용합니다 . 실제로 중요한 &lt;code&gt;DELETE&lt;/code&gt; 명령은 삭제할 행을 결정하기 위해 테이블 ​​열을 참조해야 하므로 &lt;code&gt;SELECT&lt;/code&gt; 권한도 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="892a331d54a97c6a90c5cbe15f359d1d4e9d66bd" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; of a new row into a table, view, etc. Can be granted on specific column(s), in which case only those columns may be assigned to in the &lt;code&gt;INSERT&lt;/code&gt; command (other columns will therefore receive default values). Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM.</source>
          <target state="translated">수 있습니다 &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; 새로운 행의 등 테이블, 뷰에는 만 열이에 할당 할 수있는 경우에 특정 컬럼 (들)에 부여 할 수 있습니다 &lt;code&gt;INSERT&lt;/code&gt; 명령 (다른 컬럼은 기본 값을 따라서을 받게됩니다). 또한 &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91a5de46959e59448d7fbb7e22418ff9bdc9f1e0" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; from any column, or specific column(s), of a table, view, materialized view, or other table-like object. Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO. This privilege is also needed to reference existing column values in &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;. For sequences, this privilege also allows use of the &lt;code&gt;currval&lt;/code&gt; function. For large objects, this privilege allows the object to be read.</source>
          <target state="translated">테이블, 뷰, 구체화 된 뷰 또는 기타 테이블과 같은 객체의 열 또는 특정 열에서 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 를 허용 합니다. 또한 &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO를 사용할 수 있습니다 . 이 권한은 또한 &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;sql-delete&quot;&gt;DELETE의&lt;/a&gt; 기존 열 값을 참조하는 데 필요합니다 . 시퀀스의 경우이 권한으로 &lt;code&gt;currval&lt;/code&gt; 함수를 사용할 수도 있습니다 . 큰 객체의 경우이 권한을 통해 객체를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="504fe161b61ac15d1f6a3f6705ae69c3e419baf8" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; on a table, view, etc.</source>
          <target state="translated">테이블, 뷰 등에서 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; 를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="82bfc74ea2d5fe544ab86144ec140977da660bfb" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; of any column, or specific column(s), of a table, view, etc. (In practice, any nontrivial &lt;code&gt;UPDATE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to update, and/or to compute new values for columns.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; also require this privilege on at least one column, in addition to the &lt;code&gt;SELECT&lt;/code&gt; privilege. For sequences, this privilege allows use of the &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; functions. For large objects, this privilege allows writing or truncating the object.</source>
          <target state="translated">테이블, 뷰 등의 모든 열 또는 특정 열에 대한 &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; 를 허용합니다 . (실제로, 중요하지 않은 &lt;code&gt;UPDATE&lt;/code&gt; 명령은 업데이트 할 행을 결정하기 위해 테이블 ​​열을 참조해야하기 때문에 &lt;code&gt;SELECT&lt;/code&gt; 권한도 필요 합니다. 또는 열에 대한 새 값을 계산합니다.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; 에는 &lt;code&gt;SELECT&lt;/code&gt; 권한 외에 하나 이상의 열에 대해이 권한이 필요합니다 . 시퀀스의 경우이 권한으로 &lt;code&gt;nextval&lt;/code&gt; 및 &lt;code&gt;setval&lt;/code&gt; 함수를 사용할 수 있습니다 . 큰 개체의 경우이 권한으로 개체를 쓰거나자를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7544659291101bf531ad89a7c0f68e28dd25e9" translate="yes" xml:space="preserve">
          <source>Allows calling a function or procedure, including use of any operators that are implemented on top of the function. This is the only type of privilege that is applicable to functions and procedures.</source>
          <target state="translated">함수 위에 구현 된 연산자 사용을 포함하여 함수 또는 프로 시저를 호출 할 수 있습니다. 기능과 절차에 적용 할 수있는 유일한 권한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="572f9c4ee818f964a8f341a7ab3b49d87de0de38" translate="yes" xml:space="preserve">
          <source>Allows creation of a foreign key constraint referencing a table, or specific column(s) of a table.</source>
          <target state="translated">테이블 또는 테이블의 특정 열을 참조하는 외래 키 제약 조건을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1fc4350d1383af032d326e29b30797181bb0ee" translate="yes" xml:space="preserve">
          <source>Allows creation of a trigger on a table, view, etc.</source>
          <target state="translated">테이블, 뷰 등에서 트리거를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d221a1c104e0d63607ae68533525fac6cb3d90ab" translate="yes" xml:space="preserve">
          <source>Allows definition of user-visible parameters that control operator class behavior.</source>
          <target state="translated">운영자 클래스 동작을 제어하는 ​​사용자가 볼 수있는 매개 변수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cd1d90a2a8e348dc3397a5abdad6812b9706afc" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details.</source>
          <target state="translated">시스템과 데이터베이스 사용자 이름을 매핑 할 수 있습니다. 자세한 내용 &lt;a href=&quot;auth-username-maps&quot;&gt;은 20.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="62730a57186fa6b4b57c86a98eed1f6819a0f0da" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a GSSAPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">시스템과 데이터베이스 사용자 이름을 매핑 할 수 있습니다. 자세한 내용 &lt;a href=&quot;auth-username-maps&quot;&gt;은 20.2 절&lt;/a&gt; 을 참조하십시오. &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (또는 덜 일반적으로 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; ) 과 같은 GSSAPI / Kerberos 프린시 펄의 경우 맵핑에 사용되는 사용자 이름은 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (또는 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )입니다. &lt;code&gt;include_realm&lt;/code&gt; 이 0으로 설정 되지 않은 경우, &lt;code&gt;username&lt;/code&gt; (또는 &lt;code&gt;username/hostbased&lt;/code&gt; )은 맵핑시 시스템 사용자 이름으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a8e3ba433eb210e869a35f227d0944a825933f7" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a SSPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">시스템과 데이터베이스 사용자 이름을 매핑 할 수 있습니다. 자세한 내용 &lt;a href=&quot;auth-username-maps&quot;&gt;은 20.2 절&lt;/a&gt; 을 참조하십시오. &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (또는 덜 일반적으로 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; ) 과 같은 SSPI / Kerberos 프린시 펄의 경우 맵핑에 사용되는 사용자 이름은 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (또는 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )입니다. &lt;code&gt;include_realm&lt;/code&gt; 이 0으로 설정 되지 않은 경우, &lt;code&gt;username&lt;/code&gt; (또는 &lt;code&gt;username/hostbased&lt;/code&gt; )은 맵핑시 시스템 사용자 이름으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="20552df65c50fc0052b6d2499b3762b86d6eff44" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables as well as certain other risky actions on system tables. This is otherwise not allowed even for superusers. Ill-advised use of this setting can cause irretrievable data loss or seriously corrupt the database system. Only superusers can change this setting.</source>
          <target state="translated">시스템 테이블의 구조를 수정할 수있을뿐만 아니라 시스템 테이블에 대한 특정 기타 위험한 작업을 허용합니다. 그렇지 않으면 수퍼 유저에게도 허용되지 않습니다. 이 설정을 부당하게 사용하면 복구 할 수없는 데이터 손실이 발생하거나 데이터베이스 시스템이 심각하게 손상 될 수 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64278e6ff1ecca0c4404ebfb33c1f4ece933ea1" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables. This is used by &lt;code&gt;initdb&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">시스템 테이블의 구조를 수정할 수 있습니다. 이것은 &lt;code&gt;initdb&lt;/code&gt; 에 의해 사용 됩니다 . 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71053472aff6714ed79ad6bf71416990ec41156" translate="yes" xml:space="preserve">
          <source>Allows multiple master servers</source>
          <target state="translated">여러 마스터 서버를 허용</target>
        </trans-unit>
        <trans-unit id="7e9d5d5ab57892df439ee070a4596c150e6f73e7" translate="yes" xml:space="preserve">
          <source>Allows remote clients to connect via TCP/IP (Internet domain) connections. Without this option, only local connections are accepted. This option is equivalent to setting &lt;code&gt;listen_addresses&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; or via &lt;code&gt;-h&lt;/code&gt;.</source>
          <target state="translated">원격 클라이언트가 TCP / IP (인터넷 도메인) 연결을 통해 연결할 수 있도록합니다. 이 옵션이 없으면 로컬 연결 만 허용됩니다. 이 옵션을 설정하는 것과 같습니다 &lt;code&gt;listen_addresses&lt;/code&gt; 을 에 &lt;code&gt;*&lt;/code&gt; 에 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 또는를 통해 &lt;code&gt;-h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="003e89305b8189195bfe70e6a4f7ecd0e58a566e" translate="yes" xml:space="preserve">
          <source>Allows sampling the duration of completed statements that ran for at least the specified amount of time. This produces the same kind of log entries as &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt;, but only for a subset of the executed statements, with sample rate controlled by &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT-SAMPLE-RATE&quot;&gt;log_statement_sample_rate&lt;/a&gt;. For example, if you set it to &lt;code&gt;100ms&lt;/code&gt; then all SQL statements that run 100ms or longer will be considered for sampling. Enabling this parameter can be helpful when the traffic is too high to log all queries. If this value is specified without units, it is taken as milliseconds. Setting this to zero samples all statement durations. &lt;code&gt;-1&lt;/code&gt; (the default) disables sampling statement durations. Only superusers can change this setting.</source>
          <target state="translated">최소한 지정된 시간 동안 실행 된 완료된 문의 기간을 샘플링 할 수 있습니다. 이렇게하면 &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt; 와 동일한 종류의 로그 항목이 생성 되지만 실행 된 문의 하위 집합에 대해서만 &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT-SAMPLE-RATE&quot;&gt;log_statement_sample_rate에&lt;/a&gt; 의해 제어되는 샘플 속도가 있습니다 . 예를 들어 &lt;code&gt;100ms&lt;/code&gt; 로 설정하면 100ms 이상 실행되는 모든 SQL 문이 샘플링에 고려됩니다. 이 매개 변수를 활성화하면 트래픽이 너무 많아 모든 쿼리를 기록 할 수 없을 때 유용 할 수 있습니다. 이 값이 단위없이 지정되면 밀리 초로 간주됩니다. 0으로 설정하면 모든 문 기간을 샘플링합니다. &lt;code&gt;-1&lt;/code&gt; (기본값)은 샘플링 문 기간을 비활성화합니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63eeac10a55f83f249e5c5462559d1f7da0f93f8" translate="yes" xml:space="preserve">
          <source>Allows temporary tables to be created while using the database.</source>
          <target state="translated">데이터베이스를 사용하는 동안 임시 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e9a64b986b6e59ae70cdec6ed43f46a0d1ac74" translate="yes" xml:space="preserve">
          <source>Allows the grantee to connect to the database. This privilege is checked at connection startup (in addition to checking any restrictions imposed by &lt;code&gt;pg_hba.conf&lt;/code&gt;).</source>
          <target state="translated">피부 여자가 데이터베이스에 연결할 수 있도록합니다. 이 권한은 연결 시작시 ( &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 의해 부과 된 제한 사항을 확인하는 것 외에) 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="755cae42faeb86185341cbd11d37dba18dac7fda" translate="yes" xml:space="preserve">
          <source>Allows the leader process to execute the query plan under &lt;code&gt;Gather&lt;/code&gt; and &lt;code&gt;Gather Merge&lt;/code&gt; nodes instead of waiting for worker processes. The default is &lt;code&gt;on&lt;/code&gt;. Setting this value to &lt;code&gt;off&lt;/code&gt; reduces the likelihood that workers will become blocked because the leader is not reading tuples fast enough, but requires the leader process to wait for worker processes to start up before the first tuples can be produced. The degree to which the leader can help or hinder performance depends on the plan type, number of workers and query duration.</source>
          <target state="translated">리더 프로세스가 작업자 프로세스를 기다리지 않고 &lt;code&gt;Gather&lt;/code&gt; 및 &lt;code&gt;Gather Merge&lt;/code&gt; 노드 에서 쿼리 계획을 실행할 수 있습니다 . 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다. 이 값을 &lt;code&gt;off&lt;/code&gt; 로 설정 하면 리더가 충분히 빨리 튜플을 읽지 않기 때문에 작업자가 차단 될 가능성이 줄어들지 만 첫 번째 튜플이 생성되기 전에 작업자 프로세스가 시작될 때까지 리더 프로세스가 대기해야합니다. 리더가 성과를 돕거나 방해 할 수있는 정도는 계획 유형, 작업자 수 및 쿼리 기간에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="65de6c1d93f488d023688afb5ecd9e64a2816fb2" translate="yes" xml:space="preserve">
          <source>Allows the structure of system tables to be modified. This is used by &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">시스템 테이블의 구조를 수정할 수 있습니다. 이것은 &lt;code&gt;initdb&lt;/code&gt; 에 의해 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb3d21c22361245b017a84ef20398543e1812a86" translate="yes" xml:space="preserve">
          <source>Allows the use of parallel queries for testing purposes even in cases where no performance benefit is expected. The allowed values of &lt;code&gt;force_parallel_mode&lt;/code&gt; are &lt;code&gt;off&lt;/code&gt; (use parallel mode only when it is expected to improve performance), &lt;code&gt;on&lt;/code&gt; (force parallel query for all queries for which it is thought to be safe), and &lt;code&gt;regress&lt;/code&gt; (like &lt;code&gt;on&lt;/code&gt;, but with additional behavior changes as explained below).</source>
          <target state="translated">성능상의 이점이없는 경우에도 테스트 목적으로 병렬 쿼리를 사용할 수 있습니다. &lt;code&gt;force_parallel_mode&lt;/code&gt; 의 허용 된 값 이 &lt;code&gt;off&lt;/code&gt; (성능을 향상시킬 것으로 예상되는 경우에만 병렬 모드 사용), &lt;code&gt;on&lt;/code&gt; (안전하다고 생각되는 모든 쿼리에 대해 병렬 쿼리 강제 실행) 및 &lt;code&gt;regress&lt;/code&gt; ( &lt;code&gt;on&lt;/code&gt; 과 같지만 추가 동작 변경) 아래에 설명).</target>
        </trans-unit>
        <trans-unit id="8f83e0d9b7de16d5d69bb100f20671e8c51dd641" translate="yes" xml:space="preserve">
          <source>Allows users in the same group as the cluster owner to read all cluster files created by &lt;code&gt;initdb&lt;/code&gt;. This option is ignored on Windows as it does not support POSIX-style group permissions.</source>
          <target state="translated">클러스터 소유자와 동일한 그룹의 사용자가 &lt;code&gt;initdb&lt;/code&gt; 로 작성된 모든 클러스터 파일을 읽을 수 있도록합니다 . 이 옵션은 POSIX 스타일 그룹 권한을 지원하지 않으므로 Windows에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc45bc94d25b1e0d694fb6d8a93df9410ca68c9" translate="yes" xml:space="preserve">
          <source>Almost all &lt;code&gt;DROP&lt;/code&gt; commands in PostgreSQL support specifying &lt;code&gt;CASCADE&lt;/code&gt;. Of course, the nature of the possible dependencies varies with the type of the object. You can also write &lt;code&gt;RESTRICT&lt;/code&gt; instead of &lt;code&gt;CASCADE&lt;/code&gt; to get the default behavior, which is to prevent dropping objects that any other objects depend on.</source>
          <target state="translated">PostgreSQL의 거의 모든 &lt;code&gt;DROP&lt;/code&gt; 명령은 &lt;code&gt;CASCADE&lt;/code&gt; 지정을 지원 합니다. 물론, 가능한 종속성의 특성은 객체의 유형에 따라 다릅니다. &lt;code&gt;CASCADE&lt;/code&gt; 대신 &lt;code&gt;RESTRICT&lt;/code&gt; 를 작성 하여 기본 동작을 얻을 수 있습니다. 이는 다른 객체가 의존하는 객체의 삭제를 방지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="328cfccc1cde2a65060e2ec7ece0e64b0b2e4b32" translate="yes" xml:space="preserve">
          <source>Also be careful when making up test data, which is often unavoidable when the application is not yet in production. Values that are very similar, completely random, or inserted in sorted order will skew the statistics away from the distribution that real data would have.</source>
          <target state="translated">또한 테스트 데이터를 구성 할 때는 응용 프로그램이 아직 프로덕션 환경에 있지 않은 경우 피할 수없는 경우가 있으므로주의하십시오. 매우 유사하거나 완전히 임의적이거나 정렬 된 순서로 삽입 된 값은 실제 데이터의 분포에서 통계를 왜곡합니다.</target>
        </trans-unit>
        <trans-unit id="1e6eb3c256a63ce7e1a4b490a67bfd7124a09fa5" translate="yes" xml:space="preserve">
          <source>Also calculate statistics for use by the optimizer.</source>
          <target state="translated">또한 옵티마이 저가 사용할 통계를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="1310f648148c138c431f0390dd1598c9ea4cf18b" translate="yes" xml:space="preserve">
          <source>Also known as &lt;em&gt;WAL segment&lt;/em&gt; or &lt;em&gt;WAL segment file&lt;/em&gt;. Each of the sequentially-numbered files that provide storage space for &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. The files are all of the same predefined size and are written in sequential order, interspersing changes as they occur in multiple simultaneous sessions. If the system crashes, the files are read in order, and each of the changes is replayed to restore the system to the state it was in before the crash.</source>
          <target state="translated">&lt;em&gt;WAL 세그먼트&lt;/em&gt; 또는 &lt;em&gt;WAL 세그먼트 파일&lt;/em&gt; 이라고도 &lt;em&gt;합니다&lt;/em&gt; . &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL에&lt;/a&gt; 대한 저장 공간을 제공하는 순차적으로 번호가 매겨진 각 파일 . 파일은 모두 미리 정의 된 크기가 같고 순차적으로 기록되어 여러 동시 세션에서 발생하는 변경 사항을 산재합니다. 시스템이 충돌하면 파일을 순서대로 읽고 각 변경 사항을 재생하여 시스템을 충돌 이전 상태로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="7f5b262e2738c5ae943ae295de4ef09eb42b98a8" translate="yes" xml:space="preserve">
          <source>Also note that some element types, such as &lt;code&gt;timestamp&lt;/code&gt;, have a notion of &quot;infinity&quot;, which is just another value that can be stored. This is different from &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt;, which are not real values that can be stored, but rather they are ways of saying that the value is unbounded. &lt;code&gt;MAXVALUE&lt;/code&gt; can be thought of as being greater than any other value, including &quot;infinity&quot; and &lt;code&gt;MINVALUE&lt;/code&gt; as being less than any other value, including &quot;minus infinity&quot;. Thus the range &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; is not an empty range; it allows precisely one value to be stored &amp;mdash; &quot;infinity&quot;.</source>
          <target state="translated">또한 &lt;code&gt;timestamp&lt;/code&gt; 와 같은 일부 요소 유형 에는 &quot;무한대&quot;라는 개념이 있으며 이는 저장 될 수있는 또 다른 값일뿐입니다. 이것은 저장 될 수있는 실제 값이 아니라 &lt;code&gt;MINVALUE&lt;/code&gt; 및 &lt;code&gt;MAXVALUE&lt;/code&gt; 와 다르며 , 값이 제한되지 않는다고 말하는 방법입니다. &lt;code&gt;MAXVALUE&lt;/code&gt; 는 &quot;무한대&quot;를 포함하여 다른 값보다 큰 것으로 생각할 수 있으며 &quot; &lt;code&gt;MINVALUE&lt;/code&gt; 무한대&quot;를 포함하여 MINVALUE 는 다른 값보다 작은 것으로 생각할 수 있습니다 . 따라서 &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; 범위는 빈 범위가 아닙니다. &quot;무한대&quot;라는 정확히 하나의 값을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7722ff63b95d490d6107aefdee57299789fdc839" translate="yes" xml:space="preserve">
          <source>Also of note to those converting from other environments is the fact that &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; does not ensure that a concurrent transaction will not update or delete a selected row. To do that in PostgreSQL you must actually update the row, even if no values need to be changed. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;&lt;em&gt;temporarily blocks&lt;/em&gt; other transactions from acquiring the same lock or executing an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; which would affect the locked row, but once the transaction holding this lock commits or rolls back, a blocked transaction will proceed with the conflicting operation unless an actual &lt;code&gt;UPDATE&lt;/code&gt; of the row was performed while the lock was held.</source>
          <target state="translated">다른 환경에서 변환하는 사람들에게는 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 가 동시 트랜잭션이 선택된 행을 업데이트하거나 삭제하지 않을 것이라는 사실에 유의 해야합니다. PostgreSQL에서 변경하려면 값을 변경할 필요가 없더라도 실제로 행을 업데이트해야합니다. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 는 다른 트랜잭션이 동일한 잠금을 획득하거나 잠긴 행에 영향을 줄 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 를 실행하는 것을 &lt;em&gt;일시적으로 차단&lt;/em&gt; 하지만,이 잠금을 보유한 트랜잭션이 커밋 또는 롤백되면 실제 &lt;code&gt;UPDATE&lt;/code&gt; 가 아닌 한 차단 된 트랜잭션이 충돌 작업을 진행 잠금이 유지되는 동안 행 중 하나가 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="89140b7833f6956c6f82e686c2158ff1b251e443" translate="yes" xml:space="preserve">
          <source>Also see the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function, which are useful in cases where simply matching the beginning of a string is needed.</source>
          <target state="translated">또한 접두사 연산자 &lt;code&gt;^@&lt;/code&gt; 및 해당하는 &lt;code&gt;starts_with&lt;/code&gt; 함수를 참조하십시오. 이는 단순히 문자열의 시작과 일치해야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="43ae5053feb0121ca9119b68bf8c270c3a3bfe40" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;INHERITS&lt;/code&gt;, columns and constraints copied by &lt;code&gt;LIKE&lt;/code&gt; are not merged with similarly named columns and constraints. If the same name is specified explicitly or in another &lt;code&gt;LIKE&lt;/code&gt; clause, an error is signaled.</source>
          <target state="translated">또한 &lt;code&gt;INHERITS&lt;/code&gt; 와 달리 &lt;code&gt;LIKE&lt;/code&gt; 에서 복사 한 열 및 제약 조건 은 비슷한 이름의 열 및 제약 조건과 병합되지 않습니다. 동일한 이름이 명시 적으로 또는 다른 &lt;code&gt;LIKE&lt;/code&gt; 절에 지정되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bd7db918c0ec048fb1da60e94aef9f53bffd77b" translate="yes" xml:space="preserve">
          <source>Also you can use an index on the &lt;code&gt;t&lt;/code&gt; column for word similarity or strict word similarity. Typical queries are:</source>
          <target state="translated">또한 단어 유사성 또는 엄격한 단어 유사성을 위해 &lt;code&gt;t&lt;/code&gt; 열의 색인을 사용할 수 있습니다 . 일반적인 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4ce61ad95c8576f718ac10e1c2327127884475a" translate="yes" xml:space="preserve">
          <source>Also you can use the standard SQL syntax &lt;code&gt;SET NAMES&lt;/code&gt; for this purpose:</source>
          <target state="translated">또한 이 목적으로 표준 SQL 구문 &lt;code&gt;SET NAMES&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6c555a30398b57943351e6fa4960aad56c86fc4" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;*&lt;/code&gt; can be attached to a lexeme to specify prefix matching:</source>
          <target state="translated">또한 접두사 일치를 지정하기 위해 &lt;code&gt;*&lt;/code&gt; 를 lexeme에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a92606f5ea158e9240f422542ed2e1cf20e61fc" translate="yes" xml:space="preserve">
          <source>Also, GIN index supports &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, which perform &lt;code&gt;jsonpath&lt;/code&gt; matching.</source>
          <target state="translated">또한 GIN 인덱스는 &lt;code&gt;@@&lt;/code&gt; 및 &lt;code&gt;@?&lt;/code&gt; &lt;code&gt;jsonpath&lt;/code&gt; 일치 를 수행 하는 연산자 .</target>
        </trans-unit>
        <trans-unit id="33ec741b0c71e2493174674607bdd7cee851a3f4" translate="yes" xml:space="preserve">
          <source>Also, a reverse lookup is necessary to implement the suffix matching feature, because the actual client host name needs to be known in order to match it against the pattern.</source>
          <target state="translated">또한 접미사 일치 기능을 구현하려면 역방향 조회가 필요합니다. 실제 클라이언트 호스트 이름을 패턴과 일치시키기 위해서는 알 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dbee7ce8bd2c9aaff2ced252585c86f91ebda134" translate="yes" xml:space="preserve">
          <source>Also, a trigger definition can specify a Boolean &lt;code&gt;WHEN&lt;/code&gt; condition, which will be tested to see whether the trigger should be fired. In row-level triggers the &lt;code&gt;WHEN&lt;/code&gt; condition can examine the old and/or new values of columns of the row. Statement-level triggers can also have &lt;code&gt;WHEN&lt;/code&gt; conditions, although the feature is not so useful for them since the condition cannot refer to any values in the table.</source>
          <target state="translated">또한 트리거 정의는 부울 &lt;code&gt;WHEN&lt;/code&gt; 조건을 지정 하여 트리거가 발생해야하는지 여부를 테스트합니다. 행 수준 트리거에서 &lt;code&gt;WHEN&lt;/code&gt; 조건은 행 열의 이전 및 / 또는 새 값을 검사 할 수 있습니다. 명령문 레벨 트리거는 &lt;code&gt;WHEN&lt;/code&gt; 조건을 가질 수도 있지만, 조건이 테이블의 값을 참조 할 수 없으므로이 기능은 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51c091c0aef22b8b4cc2fa3614299c508ab0362c" translate="yes" xml:space="preserve">
          <source>Also, by default there is limited information available about the selectivity of functions. However, if you create an expression index that uses a function call, useful statistics will be gathered about the function, which can greatly improve query plans that use the expression index.</source>
          <target state="translated">또한 기본적으로 기능 선택에 대한 정보는 제한되어 있습니다. 그러나 함수 호출을 사용하는 표현식 인덱스를 작성하면 함수에 대한 유용한 통계가 수집되어 표현식 인덱스를 사용하는 쿼리 계획을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918098440d0526280449d26ec531d4e4ea959670" translate="yes" xml:space="preserve">
          <source>Also, for B-tree indexes, a freshly-constructed index is slightly faster to access than one that has been updated many times because logically adjacent pages are usually also physically adjacent in a newly built index. (This consideration does not apply to non-B-tree indexes.) It might be worthwhile to reindex periodically just to improve access speed.</source>
          <target state="translated">또한 B- 트리 인덱스의 경우 새로 생성 된 인덱스는 논리적으로 인접한 페이지가 일반적으로 새로 작성된 인덱스에 물리적으로 인접하기 때문에 여러 번 업데이트 된 인덱스보다 액세스하는 데 약간 빠릅니다. B- 트리가 아닌 인덱스에는이 고려 사항이 적용되지 않습니다. 액세스 속도를 향상시키기 위해 정기적으로 인덱스를 다시 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="be3a3382ab5cfef83a6b9ee1e118c05d47eb696d" translate="yes" xml:space="preserve">
          <source>Also, for data types for which there is a natural distance metric, &lt;code&gt;btree_gist&lt;/code&gt; defines a distance operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and provides GiST index support for nearest-neighbor searches using this operator. Distance operators are provided for &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, &lt;code&gt;timestamp with time zone&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, &lt;code&gt;time without time zone&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, and &lt;code&gt;money&lt;/code&gt;.</source>
          <target state="translated">또한, 자연 거리 메트릭이있는 데이터 유형의 경우 &lt;code&gt;btree_gist&lt;/code&gt; 는 거리 연산자 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 를 정의 하고이 연산자를 사용하여 가장 가까운 이웃 검색에 대한 GiST 인덱스 지원을 제공합니다. 거리 연산자는 &lt;code&gt;int2&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;float4&lt;/code&gt; , &lt;code&gt;float8&lt;/code&gt; , &lt;code&gt;timestamp with time zone&lt;/code&gt; 가있는 &lt;code&gt;timestamp without time zone&lt;/code&gt; , &lt;code&gt;time without time zone&lt;/code&gt; 타임 스탬프 , 시간대가없는 시간 , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;oid&lt;/code&gt; 및 &lt;code&gt;money&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf0cd04ab9ab1bc3d1ec06d42e614cb3d497974a" translate="yes" xml:space="preserve">
          <source>Also, if you are using prepared transactions, the &lt;code&gt;virtualtransaction&lt;/code&gt; column can be joined to the &lt;code&gt;transaction&lt;/code&gt; column of the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; view to get more information on prepared transactions that hold locks. (A prepared transaction can never be waiting for a lock, but it continues to hold the locks it acquired while running.) For example:</source>
          <target state="translated">또한 준비된 트랜잭션을 사용하는 경우 &lt;code&gt;virtualtransaction&lt;/code&gt; &lt;code&gt;transaction&lt;/code&gt; 열을 &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt; 뷰 의 트랜잭션 열에 조인하여 잠금을 보유한 준비된 트랜잭션에 대한 자세한 정보를 얻을 수 있습니다. 준비된 트랜잭션은 잠금을 기다릴 수 없지만 실행 중에 획득 한 잠금을 계속 보유합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2258b90b04fd050fcb19ba25fa34dc828faad6f7" translate="yes" xml:space="preserve">
          <source>Also, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with &lt;code&gt;*&lt;/code&gt; to specify prefix matching:</source>
          <target state="translated">또한 &lt;code&gt;tsquery&lt;/code&gt; 의 lexemes에 접두사 일치를 지정하기 위해 &lt;code&gt;*&lt;/code&gt; 로 레이블 을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1e5125c3a43842c6c788a2be18af72f0169e16b" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;myschema&lt;/code&gt; is the first element in the path, new objects would by default be created in it.</source>
          <target state="translated">또한 &lt;code&gt;myschema&lt;/code&gt; 가 경로의 첫 번째 요소이므로 기본적으로 새 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="706af9f63feb30c802747e00ad8bdfe7aa3a186c" translate="yes" xml:space="preserve">
          <source>Also, some element types have a notion of &amp;ldquo;infinity&amp;rdquo;, but that is just another value so far as the range type mechanisms are concerned. For example, in timestamp ranges, &lt;code&gt;[today,]&lt;/code&gt; means the same thing as &lt;code&gt;[today,)&lt;/code&gt;. But &lt;code&gt;[today,infinity]&lt;/code&gt; means something different from &lt;code&gt;[today,infinity)&lt;/code&gt; &amp;mdash; the latter excludes the special &lt;code&gt;timestamp&lt;/code&gt; value &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">또한 일부 요소 유형에는 &quot;무한대&quot;라는 개념이 있지만 범위 유형 메커니즘에 관한 한 다른 값일뿐입니다. 예를 들어 타임 스탬프 범위에서 &lt;code&gt;[today,]&lt;/code&gt; 는 &lt;code&gt;[today,)&lt;/code&gt; 와 동일한 것을 의미합니다 . 그러나 &lt;code&gt;[today,infinity]&lt;/code&gt; 는 &lt;code&gt;[today,infinity)&lt;/code&gt; 와 다른 것을 의미 합니다. 후자는 특수 &lt;code&gt;timestamp&lt;/code&gt; 값 &lt;code&gt;infinity&lt;/code&gt; 를 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="00fb5de01709ab2f402939d3439d7bfb11e30b51" translate="yes" xml:space="preserve">
          <source>Also, system catalogs may contain rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1), indicating that they were inserted during the first phase of initdb. Like &lt;code&gt;FrozenTransactionId&lt;/code&gt;, this special XID is treated as older than every normal XID.</source>
          <target state="translated">또한 시스템 카탈로그에는 &lt;code&gt;xmin&lt;/code&gt; 이 &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1) 인 행이 포함될 수 있으며 이는 initdb의 첫 번째 단계에서 삽입되었음을 나타냅니다. &lt;code&gt;FrozenTransactionId&lt;/code&gt; 와 마찬가지로이 특수 XID는 모든 일반 XID보다 오래된 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="93ed94df22ab24f81f04b111c95a216ff81d38c0" translate="yes" xml:space="preserve">
          <source>Also, the Unicode escape syntax for string constants only works when the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is turned on. This is because otherwise this syntax could confuse clients that parse the SQL statements to the point that it could lead to SQL injections and similar security issues. If the parameter is set to off, this syntax will be rejected with an error message.</source>
          <target state="translated">또한 문자열 상수에 대한 유니 코드 이스케이프 구문은 구성 매개 변수 &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; 가 설정된 경우에만 작동 합니다. 그렇지 않으면이 구문은 SQL 문을 구문 분석하는 클라이언트가 SQL 삽입 및 유사한 보안 문제로 이어질 수있는 지점을 혼동시킬 수 있기 때문입니다. 매개 변수가 off로 설정되면이 구문은 오류 메시지와 함께 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="58147b7f84be2ece7907815ce52ec7ae85d6c7bf" translate="yes" xml:space="preserve">
          <source>Also, there is no concept of a &lt;code&gt;public&lt;/code&gt; schema in the SQL standard. For maximum conformance to the standard, you should not use the &lt;code&gt;public&lt;/code&gt; schema.</source>
          <target state="translated">또한 SQL 표준 에는 &lt;code&gt;public&lt;/code&gt; 스키마 개념이 없습니다 . 표준을 최대한 준수하려면 &lt;code&gt;public&lt;/code&gt; 스키마를 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="e584a70e0fd9b688e02349b1f5470dd3aa568b45" translate="yes" xml:space="preserve">
          <source>Also, these output format options can be set for just one query by using &lt;code&gt;\g&lt;/code&gt;:</source>
          <target state="translated">또한 이러한 출력 형식 옵션은 &lt;code&gt;\g&lt;/code&gt; 를 사용하여 하나의 쿼리에 대해서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cae58275d441413bb378869b203fcfca0525ccf0" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can be only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="translated">또한 병렬 계획 내에서 사용될 때 부분 하위 만 가질 수 있는 일반 &lt;code&gt;Append&lt;/code&gt; 노드 와 달리 &lt;code&gt;Parallel Append&lt;/code&gt; 노드는 부분 및 하위가 아닌 하위 계획을 모두 가질 수 있습니다. 비 일부 하위 항목은 단일 프로세스로만 스캔됩니다. 두 번 이상 스캔하면 중복 결과가 생성되기 때문입니다. 따라서 여러 결과 집합을 추가하는 계획은 효율적인 부분 계획을 사용할 수없는 경우에도 대략적인 병렬 처리를 달성 할 수 있습니다. 예를 들어, 병렬 스캔을 지원하지 않는 인덱스를 사용하여 효율적으로 구현할 수있는 파티션 된 테이블에 대한 쿼리를 고려하십시오. 플래너 는 정기적 인 &lt;code&gt;Index Scan&lt;/code&gt; 의 &lt;code&gt;Parallel Append&lt;/code&gt; 를 선택할 수 있습니다계획; 각 개별 인덱스 스캔은 단일 프로세스에 의해 완료 될 때까지 실행되어야하지만, 다른 프로세스에 의해 다른 스캔이 동시에 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84c371dd525a0259c19e76190985b0466e52c07" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="translated">또한 병렬 계획 내에서 사용될 때 부분 하위 만 가질 수 있는 일반 &lt;code&gt;Append&lt;/code&gt; 노드 와 달리 &lt;code&gt;Parallel Append&lt;/code&gt; 노드는 부분 및 비 부분 하위 계획을 모두 가질 수 있습니다. 부분적이지 않은 하위 항목은 두 번 이상 스캔하면 중복 결과가 생성되므로 단일 프로세스로만 스캔됩니다. 따라서 여러 결과 집합을 추가하는 계획은 효율적인 부분 계획을 사용할 수없는 경우에도 대략적인 병렬 처리를 달성 할 수 있습니다. 예를 들어 병렬 스캔을 지원하지 않는 인덱스를 사용해야 만 효율적으로 구현할 수있는 분할 된 테이블에 대한 쿼리를 생각해보십시오. 플래너 는 일반 &lt;code&gt;Index Scan&lt;/code&gt; 의 &lt;code&gt;Parallel Append&lt;/code&gt; 를 선택할 수 있습니다.계획; 각 개별 인덱스 스캔은 단일 프로세스에 의해 완료 될 때까지 실행되어야하지만 다른 프로세스에 의해 동시에 다른 스캔이 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e805152c6a1ae1d9757b9c8152236b48ab4b4867" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt;.</source>
          <target state="translated">또한 방금 완료된 트랜잭션이 가능한 빨리 아카이브되도록하려면 &lt;code&gt;pg_switch_wal&lt;/code&gt; 을 사용하여 세그먼트 스위치를 수동으로 강제 설정할 수 있습니다. WAL 관리와 관련된 기타 유틸리티 기능은 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;표 9.84에&lt;/a&gt; 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="68eb2f93808c112d45a946f93f2d0964eca95823" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt;.</source>
          <target state="translated">또한 방금 완료된 트랜잭션이 가능한 한 빨리 보관되도록하려면 &lt;code&gt;pg_switch_wal&lt;/code&gt; 을 사용 하여 수동으로 세그먼트 전환을 강제 할 수 있습니다. WAL 관리와 관련된 기타 유틸리티 기능은 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;표 9.85에&lt;/a&gt; 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfbace446db7c85291e8910dc869f82f6687c559" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified labels separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those labels, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start to match any label that doesn't match any of the alternatives.</source>
          <target state="translated">또한 가능한 여러 수정 된 레이블을 &lt;code&gt;|&lt;/code&gt; (또는) 해당 레이블 중 하나와 일치하면 &lt;code&gt;!&lt;/code&gt; (아니요) 다른 대안과 일치하지 않는 모든 라벨과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="71f210fdceeda15fb7f9067d7b92e4afb40e583b" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified non-star items separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those items, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start of a non-star group to match any label that doesn't match any of the alternatives. A quantifier, if any, goes at the end of the group; it means some number of matches for the group as a whole (that is, some number of labels matching or not matching any of the alternatives).</source>
          <target state="translated">또한 &lt;code&gt;|&lt;/code&gt; 로 구분 된 별표가 아닌 여러 항목을 수정할 수 있습니다. (또는) 해당 항목 중 하나와 일치시키고 &lt;code&gt;!&lt;/code&gt; (NOT) 별표가 아닌 그룹의 시작 부분에서 대체 항목과 일치하지 않는 모든 레이블과 일치합니다. 수량 자 (있는 경우)는 그룹의 끝에갑니다. 이는 그룹 전체에 대한 일부 일치 수를 의미합니다 (즉, 대체 항목과 일치하거나 일치하지 않는 일부 레이블 수).</target>
        </trans-unit>
        <trans-unit id="8b36099e7952ab489f13b56454238da5e639dbc6" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, add connection options:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 서버를 변경하고 연결 옵션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a729ebcf94a23a3c93f6e08f02b494c47b57ffb8" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, change version, change &lt;code&gt;host&lt;/code&gt; option:</source>
          <target state="translated">서버 &lt;code&gt;foo&lt;/code&gt; 변경, 버전 변경, &lt;code&gt;host&lt;/code&gt; 옵션 변경 :</target>
        </trans-unit>
        <trans-unit id="530e5f9a6ec30da1a641c6dc46a96ff1039a1901" translate="yes" xml:space="preserve">
          <source>Alter the current session user instead of an explicitly identified role.</source>
          <target state="translated">명시 적으로 식별 된 역할 대신 현재 세션 사용자를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="7d634d2fd0bd3ab5f5b0921201011f77ef8d5f96" translate="yes" xml:space="preserve">
          <source>Alter the current user instead of an explicitly identified role.</source>
          <target state="translated">명시 적으로 식별 된 역할 대신 현재 사용자를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="2e8aee10a5d127f616d1a417fe30c8e06fd3852f" translate="yes" xml:space="preserve">
          <source>Alternative Method for Log Shipping</source>
          <target state="translated">로그 전달을위한 대체 방법</target>
        </trans-unit>
        <trans-unit id="8cd965c3bba9ba8b09a134d95e9a1fe544bc4537" translate="yes" xml:space="preserve">
          <source>Alternative location for the command history file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">명령 히스토리 파일의 대체 위치 틸드 ( &lt;code&gt;~&lt;/code&gt; ) 확장이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3a5aa0af507c3b23d9de2d04bd2190286c2e39" translate="yes" xml:space="preserve">
          <source>Alternative location of the user's &lt;code&gt;.psqlrc&lt;/code&gt; file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">사용자의 &lt;code&gt;.psqlrc&lt;/code&gt; 파일 의 대체 위치입니다 . 틸드 ( &lt;code&gt;~&lt;/code&gt; ) 확장이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2541ab725e8ecd177759c1c8be6f800623e60558" translate="yes" xml:space="preserve">
          <source>Alternative spelling for &lt;code&gt;TEMPORARY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TEMPORARY&lt;/code&gt; 의 대체 철자입니다 .</target>
        </trans-unit>
        <trans-unit id="af1d73d4699e1562f8a1d0921440facf6a0e5f14" translate="yes" xml:space="preserve">
          <source>Alternative syntaxes for referencing ordered-set aggregates are described under &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt;.</source>
          <target state="translated">순서 집합 집계를 참조하기위한 대체 구문은 &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt; 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e53579bffe248a96cd7c7da0e62e9be194d4f8" translate="yes" xml:space="preserve">
          <source>Alternatively, C-style block comments can be used:</source>
          <target state="translated">또는 C 스타일 블록 주석을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ff9d2f8aa56be6c9fb839910a0ca959de998790" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;time_zone_name&lt;/code&gt; can be given, referencing a zone name defined in the IANA timezone database. The zone's definition is consulted to see whether the abbreviation is or has been in use in that zone, and if so, the appropriate meaning is used &amp;mdash; that is, the meaning that was currently in use at the timestamp whose value is being determined, or the meaning in use immediately before that if it wasn't current at that time, or the oldest meaning if it was used only after that time. This behavior is essential for dealing with abbreviations whose meaning has historically varied. It is also allowed to define an abbreviation in terms of a zone name in which that abbreviation does not appear; then using the abbreviation is just equivalent to writing out the zone name.</source>
          <target state="translated">또는 IANA 시간대 데이터베이스에 정의 된 영역 이름을 참조 하여 &lt;code&gt;time_zone_name&lt;/code&gt; 을 지정할 수 있습니다. 해당 영역에서 약어가 사용 중인지 또는 사용 중인지 여부를 확인하기 위해 영역의 정의를 참조합니다. 해당되는 경우 적절한 의미가 사용됩니다. 즉, 값이 결정되는 타임 스탬프에서 현재 사용중인 의미 또는 그 당시에 최신 상태가 아니었다면 그 직전에 사용 된 의미이거나 그 이후에만 사용 된 경우 가장 오래된 의미입니다. 이 동작은 역사적으로 의미가 다른 약어를 처리하는 데 필수적입니다. 해당 약어가 나타나지 않는 영역 이름으로 약어를 정의 할 수도 있습니다. 약어를 사용하는 것은 구역 이름을 쓰는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15a06f8c724e47a1d8815847200662f59207ad21" translate="yes" xml:space="preserve">
          <source>Alternatively, a regular server session can be started with &lt;code&gt;-P&lt;/code&gt; included in its command line options. The method for doing this varies across clients, but in all libpq-based clients, it is possible to set the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable to &lt;code&gt;-P&lt;/code&gt; before starting the client. Note that while this method does not require locking out other clients, it might still be wise to prevent other users from connecting to the damaged database until repairs have been completed.</source>
          <target state="translated">또는 명령 행 옵션에 &lt;code&gt;-P&lt;/code&gt; 가 포함 된 일반 서버 세션을 시작할 수 있습니다. 이를 수행하는 방법은 클라이언트마다 다르지만 모든 libpq 기반 클라이언트 에서 클라이언트를 시작하기 전에 &lt;code&gt;PGOPTIONS&lt;/code&gt; 환경 변수를 &lt;code&gt;-P&lt;/code&gt; 로 설정할 수 있습니다 . 이 방법으로 다른 클라이언트를 잠글 필요는 없지만 복구가 완료 될 때까지 다른 사용자가 손상된 데이터베이스에 연결하지 못하게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d114129fd255b4feb38503a136823f1a3243ffae" translate="yes" xml:space="preserve">
          <source>Alternatively, an arbitrary expression can determine what rows are to be considered distinct:</source>
          <target state="translated">또는 임의의 식으로 구별 할 행을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a31da7f4a4f7c70e9c7e0520f23700364a2f38f8" translate="yes" xml:space="preserve">
          <source>Alternatively, any of the following forms can be used for input:</source>
          <target state="translated">또는 다음 형식 중 하나를 입력에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33e9e4beffd0551e6388808105bbbc2dfb18bd73" translate="yes" xml:space="preserve">
          <source>Alternatively, bit-string constants can be specified in hexadecimal notation, using a leading &lt;code&gt;X&lt;/code&gt; (upper or lower case), e.g., &lt;code&gt;X'1FF'&lt;/code&gt;. This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit.</source>
          <target state="translated">또는 선행 &lt;code&gt;X&lt;/code&gt; (대문자 또는 소문자) (예 : &lt;code&gt;X'1FF'&lt;/code&gt; )를 사용하여 비트 열 상수를 16 진수 표기법으로 지정할 수 있습니다 . 이 표기법은 각 16 진수에 4 개의 2 진수가있는 비트 열 상수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="251d43a6c1d9b6a2f5aefc3ac8e6be39b17e09eb" translate="yes" xml:space="preserve">
          <source>Alternatively, if only one character is given on a line, instances of that character are deleted; this is useful in languages where accents are represented by separate characters.</source>
          <target state="translated">또는 한 줄에 한 문자 만 주면 해당 문자의 인스턴스가 삭제됩니다. 이것은 악센트가 별도의 문자로 표시되는 언어에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d591ed10c7ebb943dc2bac83e217250069a02625" translate="yes" xml:space="preserve">
          <source>Alternatively, if the operator class does not provide a &lt;code&gt;compare&lt;/code&gt; method, GIN will look up the default btree operator class for the index key data type, and use its comparison function. It is recommended to specify the comparison function in a GIN operator class that is meant for just one data type, as looking up the btree operator class costs a few cycles. However, polymorphic GIN operator classes (such as &lt;code&gt;array_ops&lt;/code&gt;) typically cannot specify a single comparison function.</source>
          <target state="translated">또는 연산자 클래스가 &lt;code&gt;compare&lt;/code&gt; 메소드를 제공하지 않으면 GIN은 인덱스 키 데이터 유형에 대한 기본 btree 연산자 클래스를 찾고 해당 비교 함수를 사용합니다. btree 연산자 클래스를 찾는 데 몇 사이클이 걸리므로 하나의 데이터 유형만을위한 GIN 연산자 클래스에서 비교 함수를 지정하는 것이 좋습니다. 그러나 다형성 GIN 연산자 클래스 (예 : &lt;code&gt;array_ops&lt;/code&gt; )는 일반적으로 단일 비교 함수를 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="72ceaece99de5916dec6956aa5625927bc2fa200" translate="yes" xml:space="preserve">
          <source>Alternatively, if the user account was created incorrectly or cannot be changed, it is recommended to set</source>
          <target state="translated">또는 사용자 계정이 잘못 작성되었거나 변경할 수없는 경우 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60d8933bc73d549d63a859713e0214c4534a9558" translate="yes" xml:space="preserve">
          <source>Alternatively, one may want to create and populate the new child table before adding it to the table hierarchy. This could allow data to be loaded, checked, and transformed before being made visible to queries on the parent table.</source>
          <target state="translated">또는 새 하위 테이블을 테이블 계층 구조에 추가하기 전에 작성하고 채울 수 있습니다. 이를 통해 부모 테이블의 쿼리에 표시되기 전에 데이터를로드, 확인 및 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ff1004e1f07326010cba19c9e266164c058052f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; command can be used to reassign ownership of all objects owned by the role-to-be-dropped to a single other role. Because &lt;code&gt;REASSIGN OWNED&lt;/code&gt; cannot access objects in other databases, it is necessary to run it in each database that contains objects owned by the role. (Note that the first such &lt;code&gt;REASSIGN OWNED&lt;/code&gt; will change the ownership of any shared-across-databases objects, that is databases or tablespaces, that are owned by the role-to-be-dropped.)</source>
          <target state="translated">또는 &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; 명령을 사용하여 제거 할 역할이 소유 한 모든 오브젝트의 소유권을 다른 단일 역할에 재 할당 할 수 있습니다. 때문에 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; 다른 데이터베이스에없는 액세스 개체 수, 역할이 소유 객체가 포함 된 각 데이터베이스에서 실행하는 것이 필요하다. (이러한 첫 번째 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; 는 삭제 될 역할이 소유 한 데이터베이스 또는 테이블 스페이스 인 공유 데이터베이스 간 오브젝트의 소유권을 변경합니다.)</target>
        </trans-unit>
        <trans-unit id="0e1e66b725216c8606cc4bf9032cf0c74ece07f1" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;generate_subscripts&lt;/code&gt; function can be used. For example:</source>
          <target state="translated">또는 &lt;code&gt;generate_subscripts&lt;/code&gt; 함수를 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15fba016cd90434c268101e2e3dcfba0bf0a2532" translate="yes" xml:space="preserve">
          <source>Alternatively, use the &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; parameter:</source>
          <target state="translated">또는 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 매개 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f4a86811d0aa22382b5cf9bd26c67192af09d76" translate="yes" xml:space="preserve">
          <source>Alternatively, use the short commands:</source>
          <target state="translated">또는 짧은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="65a8f599c00acf998716acc089534f17921d2aa4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can run &lt;code&gt;initdb&lt;/code&gt; via the &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; program like so:</source>
          <target state="translated">또는 다음 과 같이 &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; 프로그램을 통해 &lt;code&gt;initdb&lt;/code&gt; 를 실행할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="98a5c461c82a79025a521674df6f9b47d5588e09" translate="yes" xml:space="preserve">
          <source>Alternatively, you could modify &lt;code&gt;passwordcheck&lt;/code&gt; to reject pre-encrypted passwords, but forcing users to set their passwords in clear text carries its own security risks.</source>
          <target state="translated">또는 &lt;code&gt;passwordcheck&lt;/code&gt; 를 수정 하여 사전 암호화 된 비밀번호 를 거부 할 수 있지만 사용자가 비밀번호를 일반 텍스트로 설정하도록 강요하면 자체 보안 위험이 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5a5bc9685c86de23aa2f7e6abe79e2df58ea2f24" translate="yes" xml:space="preserve">
          <source>Alternatively, you might prefer to use an external log rotation program if you have one that you are already using with other server software. For example, the rotatelogs tool included in the Apache distribution can be used with PostgreSQL. One way to do this is to pipe the server's stderr output to the desired program. If you start the server with &lt;code&gt;pg_ctl&lt;/code&gt;, then stderr is already redirected to stdout, so you just need a pipe command, for example:</source>
          <target state="translated">또는 이미 다른 서버 소프트웨어와 함께 사용중인 외부 로그 순환 프로그램이있는 경우 외부 로그 회전 프로그램을 사용하는 것이 좋습니다. 예를 들어 Apache 배포에 포함 된 rotatelogs 도구는 PostgreSQL과 함께 사용할 수 있습니다. 이를 수행하는 한 가지 방법은 서버의 stderr 출력을 원하는 프로그램으로 파이프하는 것입니다. &lt;code&gt;pg_ctl&lt;/code&gt; 로 서버를 시작하면 stderr이 이미 stdout으로 리디렉션되므로 파이프 명령이 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4473ced05716c4f54d00426c2fe62cbfc81eb98" translate="yes" xml:space="preserve">
          <source>Alternatively, you'll get this when attempting Unix-domain socket communication to a local server:</source>
          <target state="translated">또는 로컬 서버와의 유닉스 도메인 소켓 통신을 시도 할 때 이것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3070b53c6b7161861f801a0276cbe1623e985387" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; attempts to verify that existing stored data satisfies the new constraint, this check is not bulletproof, because the command cannot &amp;ldquo;see&amp;rdquo; table rows that are newly inserted or updated and not yet committed. If there is a hazard that concurrent operations might insert bad data, the way to proceed is to add the constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option, commit that command, wait until all transactions started before that commit have finished, and then issue &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; to search for data violating the constraint. This method is reliable because once the constraint is committed, all new transactions are guaranteed to enforce it against new values of the domain type.</source>
          <target state="translated">&lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; 는 기존의 저장된 데이터가 새로운 제한 조건을 만족하는지 검증하려고 시도 하지만 명령이 새로 삽입되거나 갱신되어 아직 커미트되지 않은 테이블 행을 &quot;볼 수&quot;없으므로이 검사는 방탄하지 않습니다. 동시 작업에 잘못된 데이터가 삽입 될 수있는 위험이있는 경우 진행 방법은 &lt;code&gt;NOT VALID&lt;/code&gt; 옵션을 사용하여 제한 조건을 추가하고 해당 명령을 커밋하고 커밋이 완료되기 전에 모든 트랜잭션이 시작될 때까지 기다린 후 &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; 를 발행하는 것입니다. 제약 조건을 위반하는 데이터를 검색합니다. 이 방법은 제약 조건이 커밋되면 모든 새로운 트랜잭션이 도메인 유형의 새로운 값에 대해 적용되도록 보장하기 때문에 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4d5c62b36bd1bff5096ffffc66d8713544d380" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;COALESCE&lt;/code&gt;, &lt;code&gt;GREATEST&lt;/code&gt;, and &lt;code&gt;LEAST&lt;/code&gt; are syntactically similar to functions, they are not ordinary functions, and thus cannot be used with explicit &lt;code&gt;VARIADIC&lt;/code&gt; array arguments.</source>
          <target state="translated">하지만 &lt;code&gt;COALESCE&lt;/code&gt; 는 , &lt;code&gt;GREATEST&lt;/code&gt; 및 &lt;code&gt;LEAST&lt;/code&gt; 이 기능에 대한 구문과 유사하다, 그들은 일반적인 기능하지 않고, 따라서 명시 적으로 사용할 수 없습니다 &lt;code&gt;VARIADIC&lt;/code&gt; 의 배열 인수.</target>
        </trans-unit>
        <trans-unit id="757c32acfdc3edc5e4ae1b7ef733e95e7cd6d851" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;FOR UPDATE&lt;/code&gt; appears in the SQL standard, the standard allows it only as an option of &lt;code&gt;DECLARE CURSOR&lt;/code&gt;. PostgreSQL allows it in any &lt;code&gt;SELECT&lt;/code&gt; query as well as in sub-&lt;code&gt;SELECT&lt;/code&gt;s, but this is an extension. The &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; and &lt;code&gt;FOR KEY SHARE&lt;/code&gt; variants, as well as the &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; options, do not appear in the standard.</source>
          <target state="translated">&lt;code&gt;FOR UPDATE&lt;/code&gt; 는 SQL 표준에 표시 되지만 &lt;code&gt;DECLARE CURSOR&lt;/code&gt; 옵션으로 만 허용됩니다 . PostgreSQL은 하위 &lt;code&gt;SELECT&lt;/code&gt; 뿐만 아니라 모든 &lt;code&gt;SELECT&lt;/code&gt; 쿼리 에서도이를 허용 하지만 이것은 확장입니다. &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;FOR SHARE&lt;/code&gt; 및 &lt;code&gt;FOR KEY SHARE&lt;/code&gt; 는 뿐만 아니라, 변형 &lt;code&gt;NOWAIT&lt;/code&gt; 및 &lt;code&gt;SKIP LOCKED&lt;/code&gt; 표준에 표시되지 않습니다, 옵션을.</target>
        </trans-unit>
        <trans-unit id="53588eb1af9a260bf16537d83fb7f9095237ab92" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;initdb&lt;/code&gt; will attempt to create the specified data directory, it might not have permission if the parent directory of the desired data directory is root-owned. To initialize in such a setup, create an empty data directory as root, then use &lt;code&gt;chown&lt;/code&gt; to assign ownership of that directory to the database user account, then &lt;code&gt;su&lt;/code&gt; to become the database user to run &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 가 지정된 데이터 디렉토리를 작성하려고 시도 하지만 원하는 데이터 디렉토리의 상위 디렉토리가 루트 소유인 경우 권한이 없을 수 있습니다. 이러한 설정에서 초기화하려면 root로 빈 데이터 디렉토리를 작성한 다음 &lt;code&gt;chown&lt;/code&gt; 을 사용 하여 해당 디렉토리의 소유권을 데이터베이스 사용자 계정에 지정하고 &lt;code&gt;su&lt;/code&gt; 를 사용하여 &lt;code&gt;initdb&lt;/code&gt; 를 실행하는 데이터베이스 사용자가되도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c9e9e73d67adcca66915f7f142192b4fd5640e0" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL does not attempt to enforce constraints on foreign tables, it does assume that they are correct for purposes of query optimization. If there are rows visible in the foreign table that do not satisfy a declared constraint, queries on the table might produce incorrect answers. It is the user's responsibility to ensure that the constraint definition matches reality.</source>
          <target state="translated">PostgreSQL은 외부 테이블에 제약 조건을 적용하려고 시도하지 않지만 쿼리 최적화 목적으로 올바른 것으로 가정합니다. 외부 테이블에 선언 된 제한 조건을 만족하지 않는 행이 표시되면 테이블에 대한 쿼리가 잘못된 응답을 생성 할 수 있습니다. 구속 조건 정의가 현실과 일치하는지 확인하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="d1a0d48f05bfdc6cec6860f8c1c04ca18ef39017" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL supports Julian Date notation for input and output of dates (and also uses Julian dates for some internal datetime calculations), it does not observe the nicety of having dates run from noon to noon. PostgreSQL treats a Julian Date as running from midnight to midnight.</source>
          <target state="translated">PostgreSQL은 날짜 입력 및 출력을 위해 Julian Date 표기법을 지원하지만 일부 내부 날짜 시간 계산에는 Julian 날짜를 사용하지만 정오부터 정오까지 날짜를 실행하는 것이 멋지지는 않습니다. PostgreSQL은 Julian Date를 자정부터 자정까지 실행하는 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="aa5958132d1510aabee9c8eff036ee687a13c3b5" translate="yes" xml:space="preserve">
          <source>Although all built-in WAL-logged modules have their own types of WAL records, there is also a generic WAL record type, which describes changes to pages in a generic way. This is useful for extensions that provide custom access methods, because they cannot register their own WAL redo routines.</source>
          <target state="translated">모든 내장 WAL 로깅 모듈에는 고유 한 유형의 WAL 레코드가 있지만 일반적인 WAL 레코드 유형도 있습니다.이 유형은 일반적인 방식으로 페이지 변경 사항을 설명합니다. 이는 고유 한 WAL 리두 ​​루틴을 등록 할 수 없으므로 사용자 정의 액세스 방법을 제공하는 확장에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d6ab224f94330d8699a9bed333303bd23f1e0345" translate="yes" xml:space="preserve">
          <source>Although enum types are primarily intended for static sets of values, there is support for adding new values to an existing enum type, and for renaming values (see &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;). Existing values cannot be removed from an enum type, nor can the sort ordering of such values be changed, short of dropping and re-creating the enum type.</source>
          <target state="translated">열거 형은 주로 정적 값 집합을위한 것이지만 기존 열거 형에 새 값을 추가하고 값의 이름을 바꾸는 기능이 지원됩니다 ( &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt; 참조 ). 열거 형에서 기존 값을 제거 할 수 없으며 열거 형을 삭제하고 다시 만들지 않고도 이러한 값의 정렬 순서를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="94ec3fef4f0a92e5c738b8e891b93184d80ce08d" translate="yes" xml:space="preserve">
          <source>Although indexes in PostgreSQL do not need maintenance or tuning, it is still important to check which indexes are actually used by the real-life query workload. Examining index usage for an individual query is done with the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command; its application for this purpose is illustrated in &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt;. It is also possible to gather overall statistics about index usage in a running server, as described in &lt;a href=&quot;monitoring-stats&quot;&gt;Section 27.2&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL의 인덱스는 유지 관리 또는 조정이 필요하지 않지만 실제 쿼리 워크로드에서 실제로 사용되는 인덱스를 확인하는 것이 중요합니다. 개별 쿼리에 대한 인덱스 사용량 검사는 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 명령으로 수행됩니다 . 이 목적에 대한 적용은 &lt;a href=&quot;using-explain&quot;&gt;14.1 절에&lt;/a&gt; 설명되어있다 . &lt;a href=&quot;monitoring-stats&quot;&gt;27.2 절에&lt;/a&gt; 설명 된대로 실행중인 서버에서 인덱스 사용에 대한 전체 통계를 수집 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b565c24300a11b353aca42f1a3c2fd6f15be280e" translate="yes" xml:space="preserve">
          <source>Although inheritance is frequently useful, it has not been integrated with unique constraints or foreign keys, which limits its usefulness. See &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; for more detail.</source>
          <target state="translated">상속은 종종 유용하지만 고유 제한 조건이나 외래 키와 통합되지 않아 유용성이 제한됩니다. 자세한 내용 &lt;a href=&quot;ddl-inherit&quot;&gt;은 5.10 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3850ba882b09b2bdad99e045dd0ac52d33bb527" translate="yes" xml:space="preserve">
          <source>Although it is possible to copy a database other than &lt;code&gt;template1&lt;/code&gt; by specifying its name as the template, this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the template database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; otherwise, new connections to the template database are locked out until &lt;code&gt;CREATE DATABASE&lt;/code&gt; completes. See &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt; for more information.</source>
          <target state="translated">이름을 &lt;code&gt;template1&lt;/code&gt; 로 지정하여 template1 이외의 데이터베이스를 복사 할 수는 있지만 , 이는 범용 &quot; &lt;code&gt;COPY DATABASE&lt;/code&gt; &quot;기능 으로 의도 된 것은 아닙니다 . 주된 제한 사항은 복사되는 동안 템플릿 데이터베이스에 다른 세션을 연결할 수 없다는 것입니다. 시작할 때 다른 연결이 존재하면 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 가 실패합니다. 그렇지 않으면 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 가 완료 될 때까지 템플리트 데이터베이스에 대한 새 연결이 잠 깁니다 . 자세한 정보는 &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;22.3 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f2cb95ff60fc4e9f012557faa268bb5d908ed75" translate="yes" xml:space="preserve">
          <source>Although most forms of &lt;code&gt;ADD table_constraint&lt;/code&gt; require an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock, &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; requires only a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock. Note that &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; also acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table on which the constraint is declared.</source>
          <target state="translated">대부분의 &lt;code&gt;ADD table_constraint&lt;/code&gt; 형식 에는 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금이 필요 하지만 &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; 에는 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 잠금 만 필요합니다 . 참고 &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; 는 또한 획득 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 제약이 선언 된 테이블에 잠금 외에도, 참조 된 테이블에 잠금을.</target>
        </trans-unit>
        <trans-unit id="1f7a4620dd953ee89678c8af93ba6b1281ecf21b" translate="yes" xml:space="preserve">
          <source>Although per-column tweaking of &lt;code&gt;ANALYZE&lt;/code&gt; frequency might not be very productive, you might find it worthwhile to do per-column adjustment of the level of detail of the statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;. Columns that are heavily used in &lt;code&gt;WHERE&lt;/code&gt; clauses and have highly irregular data distributions might require a finer-grain data histogram than other columns. See &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;, or change the database-wide default using the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 빈도 의 열 단위 조정은 생산적이지 않을 수 있지만 &lt;code&gt;ANALYZE&lt;/code&gt; 가 수집 한 통계의 세부 사항 레벨을 열 단위로 조정하는 것이 좋습니다 . &lt;code&gt;WHERE&lt;/code&gt; 절에 많이 사용되고 열 분포가 매우 불규칙한 열은 다른 열보다 세밀한 데이터 히스토그램이 필요할 수 있습니다. &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 를 참조 하거나 &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; 구성 매개 변수를 사용하여 데이터베이스 전체 기본값을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="072197dff3ba1069a6848a4f3fc276518f8dd8e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;date&lt;/code&gt; type cannot have an associated time zone, the &lt;code&gt;time&lt;/code&gt; type can. Time zones in the real world have little meaning unless associated with a date as well as a time, since the offset can vary through the year with daylight-saving time boundaries.</source>
          <target state="translated">있지만 &lt;code&gt;date&lt;/code&gt; 유형이 관련된 시간대를 가질 수는 &lt;code&gt;time&lt;/code&gt; 유형이 있습니다. 현실 세계의 시간대는 날짜 및 시간과 관련되지 않는 한 의미가 거의 없습니다. 오프셋은 일광 절약 시간제 경계에 따라 연중 내내 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28fdae260b7b429ca2fc81de6c0ad8518d3a56e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;jsonb_path_ops&lt;/code&gt; operator class supports only queries with the &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, it has notable performance advantages over the default operator class &lt;code&gt;jsonb_ops&lt;/code&gt;. A &lt;code&gt;jsonb_path_ops&lt;/code&gt; index is usually much smaller than a &lt;code&gt;jsonb_ops&lt;/code&gt; index over the same data, and the specificity of searches is better, particularly when queries contain keys that appear frequently in the data. Therefore search operations typically perform better than with the default operator class.</source>
          <target state="translated">있지만 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 의 연산자 클래스의 지원 만에 쿼리 &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;@@&lt;/code&gt; 와 &lt;code&gt;@?&lt;/code&gt; 연산자 인 경우 기본 연산자 클래스 &lt;code&gt;jsonb_ops&lt;/code&gt; 보다 뛰어난 성능 이점이 있습니다. &lt;code&gt;jsonb_path_ops&lt;/code&gt; 의 인덱스는 보통보다 훨씬 작은 &lt;code&gt;jsonb_ops&lt;/code&gt; 의 동일한 데이터에 대한 인덱스 및 검색의 특이도는 쿼리가 데이터에 자주 나타납니다 키를 포함 할 때 특히 좋다. 따라서 검색 조작은 일반적으로 기본 연산자 클래스보다 성능이 우수합니다.</target>
        </trans-unit>
        <trans-unit id="b3909c49c0f3069cf4fdb831ccd03572195110f1" translate="yes" xml:space="preserve">
          <source>Although the error conditions possible on the client side are quite varied and application-dependent, a few of them might be directly related to how the server was started. Conditions other than those shown below should be documented with the respective client application.</source>
          <target state="translated">클라이언트 측에서 가능한 오류 조건은 상당히 다양하고 응용 프로그램에 따라 다르지만 그 중 일부는 서버 시작 방법과 직접 관련이있을 수 있습니다. 아래에 표시된 조건 이외의 조건은 해당 클라이언트 응용 프로그램에 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="707d4aa12dd0762aad5c962d956cb0615faa21aa" translate="yes" xml:space="preserve">
          <source>Although the main point of a prepared statement is to avoid repeated parse analysis and planning of the statement, PostgreSQL will force re-analysis and re-planning of the statement before using it whenever database objects used in the statement have undergone definitional (DDL) changes since the previous use of the prepared statement. Also, if the value of &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; changes from one use to the next, the statement will be re-parsed using the new &lt;code&gt;search_path&lt;/code&gt;. (This latter behavior is new as of PostgreSQL 9.3.) These rules make use of a prepared statement semantically almost equivalent to re-submitting the same query text over and over, but with a performance benefit if no object definitions are changed, especially if the best plan remains the same across uses. An example of a case where the semantic equivalence is not perfect is that if the statement refers to a table by an unqualified name, and then a new table of the same name is created in a schema appearing earlier in the &lt;code&gt;search_path&lt;/code&gt;, no automatic re-parse will occur since no object used in the statement changed. However, if some other change forces a re-parse, the new table will be referenced in subsequent uses.</source>
          <target state="translated">준비된 명령문의 주요 요점은 구문 분석의 반복 된 구문 분석 및 계획을 피하는 것이지만, PostgreSQL은 명령문에 사용 된 데이터베이스 오브젝트가 정의 (DDL) 변경을 겪을 때마다 명령문을 사용하기 전에 명령문을 재분석 및 재 계획합니다. 준비된 진술의 이전 사용 이후. 또한 &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; 의 값이 한 사용에서 다음 사용으로 변경되면 새 &lt;code&gt;search_path&lt;/code&gt; 를 사용하여 명령문이 다시 구문 분석됩니다.. (이 후자의 동작은 PostgreSQL 9.3부터 새로 도입되었습니다.)이 규칙은 준비된 명령문을 의미 적으로 동일한 쿼리 텍스트를 반복해서 다시 제출하는 것과 거의 동일하지만 객체 정의가 변경되지 않은 경우, 특히 최상의 계획은 여러 용도에서 동일하게 유지됩니다. 의미 론적 동등성이 완벽하지 않은 경우의 예는 명령문이 규정되지 않은 이름으로 테이블을 참조하는 경우 동일한 이름의 새 테이블이 &lt;code&gt;search_path&lt;/code&gt; 에서 이전에 나타나는 스키마에 작성되고 자동으로 다시 정의되지 않는 경우입니다. 명령문에 사용 된 오브젝트가 변경되지 않았으므로 구문 분석이 발생합니다. 그러나 일부 다른 변경으로 인해 재분석이 필요한 경우 이후 사용시 새 테이블이 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="7b64c47c816d918ee8eceb31b5a14f4992da7fb7" translate="yes" xml:space="preserve">
          <source>Although the syntax of &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; resembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. PostgreSQL instead requires each session to issue its own &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure.</source>
          <target state="translated">&lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; 의 구문은 SQL 표준 의 구문 과 유사하지만 그 효과는 동일하지 않습니다. 표준에서 임시 테이블은 한 번만 정의되며 필요한 모든 세션에 자동으로 존재합니다 (빈 내용으로 시작). PostgreSQL은 대신 각 세션에서 사용할 각 임시 테이블에 대해 고유 한 &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; 명령을 실행해야합니다. 이것은 다른 세션이 다른 목적으로 동일한 임시 테이블 이름을 사용할 수 있도록하는 반면, 표준의 접근 방식은 주어진 임시 테이블 이름의 모든 인스턴스가 동일한 테이블 구조를 갖도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="9eb832cbf2f7969f569f8af2de92f22dbf429240" translate="yes" xml:space="preserve">
          <source>Although the system will let you set &lt;code&gt;random_page_cost&lt;/code&gt; to less than &lt;code&gt;seq_page_cost&lt;/code&gt;, it is not physically sensible to do so. However, setting them equal makes sense if the database is entirely cached in RAM, since in that case there is no penalty for touching pages out of sequence. Also, in a heavily-cached database you should lower both values relative to the CPU parameters, since the cost of fetching a page already in RAM is much smaller than it would normally be.</source>
          <target state="translated">시스템에서 &lt;code&gt;random_page_cost&lt;/code&gt; 를 &lt;code&gt;seq_page_cost&lt;/code&gt; 보다 작게 설정할 수는 있지만 실제로 그렇게하는 것은 합리적이지 않습니다. 그러나 데이터베이스가 RAM에 완전히 캐시되어 있으면 동일하게 설정하는 것이 합리적입니다.이 경우 순서가 맞지 않는 페이지를 건 드리는 데 대한 페널티가 없기 때문입니다. 또한 캐시가 많은 데이터베이스에서는 이미 RAM에있는 페이지를 가져 오는 데 드는 비용이 평소보다 훨씬 작기 때문에 CPU 매개 변수에 비해 두 값을 모두 낮추어야합니다.</target>
        </trans-unit>
        <trans-unit id="f375eb3005a104e4e3133bc9460b959aca6d956c" translate="yes" xml:space="preserve">
          <source>Although these queries will work without an index, most applications will find this approach too slow, except perhaps for occasional ad-hoc searches. Practical use of text searching usually requires creating an index.</source>
          <target state="translated">이러한 쿼리는 색인없이 작동하지만 대부분의 응용 프로그램은 가끔씩 임시 검색을 제외하고는이 방법이 너무 느리다는 것을 알게됩니다. 텍스트 검색을 실제로 사용하려면 일반적으로 색인을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a53bc14c2fd9a760550de48fb80767bf99cae5" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a large penalty in index size. Each of the single-column btree indexes occupies 214 MB, so the total space needed is over 1.2GB, more than 8 times the space used by the bloom index.</source>
          <target state="translated">이 쿼리는 단일 인덱스 중 하나를 사용하는 것보다 훨씬 빠르게 실행되지만 인덱스 크기가 큰 페널티를받습니다. 각 단일 열 btree 인덱스는 214MB를 차지하므로 필요한 총 공간은 블룸 인덱스에 사용 된 공간의 8 배보다 1.2GB가 넘습니다.</target>
        </trans-unit>
        <trans-unit id="a490262673b6e67e6cc0b4de26fba601b493618f" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a penalty in index size. Each of the single-column btree indexes occupies 2 MB, so the total space needed is 12 MB, eight times the space used by the bloom index.</source>
          <target state="translated">이 쿼리는 단일 인덱스 중 하나보다 훨씬 빠르게 실행되지만 인덱스 크기에 대한 패널티를 지불합니다. 각 단일 열 btree 인덱스는 2MB를 차지하므로 필요한 총 공간은 블룸 인덱스에서 사용하는 공간의 8 배인 12MB입니다.</target>
        </trans-unit>
        <trans-unit id="1200f8928e7bfeba98e8bc2cff21bdd8b6159a1f" translate="yes" xml:space="preserve">
          <source>Although this query's restrictions are superficially similar to the previous example, the semantics are different because a row must be emitted for each row of A that has no matching row in the join of B and C. Therefore the planner has no choice of join order here: it must join B to C and then join A to that result. Accordingly, this query takes less time to plan than the previous query. In other cases, the planner might be able to determine that more than one join order is safe. For example, given:</source>
          <target state="translated">이 쿼리의 제한 사항은 이전 예제와 피상적으로 비슷하지만 B와 C의 조인에서 일치하는 행이없는 A의 각 행에 대해 행을 생성해야하기 때문에 시맨틱이 다릅니다. 따라서 플래너는 여기서 조인 순서를 선택할 수 없습니다. : B를 C에 결합한 다음 A를 해당 결과에 결합해야합니다. 따라서이 쿼리는 이전 쿼리보다 계획 시간이 덜 걸립니다. 다른 경우, 플래너는 둘 이상의 결합 순서가 안전하다고 판단 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ef8d68c90c214bb77efeec7b9a407cfbeffef4b" translate="yes" xml:space="preserve">
          <source>Although tuples are a lockable type of object, information about row-level locks is stored on disk, not in memory, and therefore row-level locks normally do not appear in this view. If a process is waiting for a row-level lock, it will usually appear in the view as waiting for the permanent transaction ID of the current holder of that row lock.</source>
          <target state="translated">튜플은 잠금 가능한 객체 유형이지만 행 수준 잠금에 대한 정보는 메모리가 아닌 디스크에 저장되므로 일반적으로이 수준에는 행 수준 잠금이 나타나지 않습니다. 프로세스가 행 레벨 잠금을 대기중인 경우 일반적으로 해당 행 잠금의 현재 보유자의 영구 트랜잭션 ID를 기다리는 것으로보기에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="72059384cd793d17d014692386f1a5b268fab6d4" translate="yes" xml:space="preserve">
          <source>Although you can use any output format with this feature, the default &lt;code&gt;aligned&lt;/code&gt; format tends to look bad because each group of &lt;code&gt;FETCH_COUNT&lt;/code&gt; rows will be formatted separately, leading to varying column widths across the row groups. The other output formats work better.</source>
          <target state="translated">이 기능으로 모든 출력 형식을 사용할 수 있지만 &lt;code&gt;FETCH_COUNT&lt;/code&gt; 행 의 각 그룹이 개별적으로 형식화되어 행 그룹에 따라 열 너비가 다양해 지므로 기본 &lt;code&gt;aligned&lt;/code&gt; 형식이 좋지 않은 것처럼 보입니다 . 다른 출력 형식이 더 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="29489a7d34435843e1ff1804b48da3fef28fc6ed" translate="yes" xml:space="preserve">
          <source>Although you cannot update a sequence directly, you can use a query like:</source>
          <target state="translated">시퀀스를 직접 업데이트 할 수는 없지만 다음과 같은 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d408d29d181fe5f178e0df0934db0a473f3e4b2d" translate="yes" xml:space="preserve">
          <source>Always -1 in storage, but when loaded into a row descriptor in memory this might be updated to cache the offset of the attribute within the row</source>
          <target state="translated">항상 스토리지에서 -1이지만 메모리의 행 디스크립터에로드되면 행 내 속성의 오프셋을 캐시하도록 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dadde15ce0973a00fe9eb264f6b51766c085e93" translate="yes" xml:space="preserve">
          <source>Always run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; first. This command collects statistics about the distribution of the values in the table. This information is required to estimate the number of rows returned by a query, which is needed by the planner to assign realistic costs to each possible query plan. In absence of any real statistics, some default values are assumed, which are almost certain to be inaccurate. Examining an application's index usage without having run &lt;code&gt;ANALYZE&lt;/code&gt; is therefore a lost cause. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">항상 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE를&lt;/a&gt; 먼저 실행하십시오 . 이 명령은 테이블의 값 분포에 대한 통계를 수집합니다. 이 정보는 쿼리가 리턴 한 행 수를 추정하는 데 필요하며, 계획자가 각 가능한 쿼리 계획에 현실적인 비용을 지정하는 데 필요합니다. 실제 통계가 없으면 일부 기본값이 가정되며 이는 거의 부정확합니다. 따라서 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하지 않고 응용 프로그램의 인덱스 사용량을 검사하는 것은 유실 된 원인입니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;24.1.3 절&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;24.1.6 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fee90b9468a8f0a4929baba6bf4b3942f402f50f" translate="yes" xml:space="preserve">
          <source>Always run the pg_upgrade binary of the new server, not the old one. pg_upgrade requires the specification of the old and new cluster's data and executable (&lt;code&gt;bin&lt;/code&gt;) directories. You can also specify user and port values, and whether you want the data files linked or cloned instead of the default copy behavior.</source>
          <target state="translated">항상 이전 서버가 아니라 새 서버의 pg_upgrade 바이너리를 실행하십시오. pg_upgrade에는 이전 및 새 클러스터의 데이터 및 실행 파일 ( &lt;code&gt;bin&lt;/code&gt; ) 디렉토리 의 사양이 필요합니다 . 또한 사용자 및 포트 값을 지정하고 기본 복사 동작 대신 데이터 파일을 링크 또는 복제할지 여부를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed314eaaeb4f7d7933efa77539bb6dd24179fb4e" translate="yes" xml:space="preserve">
          <source>American National Standards Institute</source>
          <target state="translated">미국 국가 표준 협회</target>
        </trans-unit>
        <trans-unit id="9b0f6aa450d937f102baa99a591a10b175502ace" translate="yes" xml:space="preserve">
          <source>American Standard Code for Information Interchange</source>
          <target state="translated">정보 교환을위한 미국 표준 코드</target>
        </trans-unit>
        <trans-unit id="f772502aac0c6acdc4a93caa9a6a863fee25bd39" translate="yes" xml:space="preserve">
          <source>Among all relational operators the most difficult one to process and optimize is the &lt;em&gt;join&lt;/em&gt;. The number of possible query plans grows exponentially with the number of joins in the query. Further optimization effort is caused by the support of a variety of &lt;em&gt;join methods&lt;/em&gt; (e.g., nested loop, hash join, merge join in PostgreSQL) to process individual joins and a diversity of &lt;em&gt;indexes&lt;/em&gt; (e.g., B-tree, hash, GiST and GIN in PostgreSQL) as access paths for relations.</source>
          <target state="translated">모든 관계 연산자 중에서 처리하고 최적화하기 가장 어려운 것은 &lt;em&gt;조인&lt;/em&gt; 입니다. 가능한 쿼리 계획의 수는 쿼리의 조인 수에 따라 기하 급수적으로 증가합니다. 추가 &lt;em&gt;조인&lt;/em&gt; 노력은 개별 조인 및 다양한 &lt;em&gt;인덱스&lt;/em&gt; (예 : B- 트리, 해시, GiST 및 GIN )를 처리하기 위해 다양한 &lt;em&gt;조인 방법&lt;/em&gt; (예 : 중첩 루프, 해시 조인, PostgreSQL의 병합 조인)을 지원하기 때문에 발생 합니다 . 관계에 대한 액세스 경로로 PostgreSQL).</target>
        </trans-unit>
        <trans-unit id="a06f60f435b117a486b4b9306faa4f936e74dfd4" translate="yes" xml:space="preserve">
          <source>Amount of data streamed. This counter only advances when the phase is &lt;code&gt;streaming database files&lt;/code&gt; or &lt;code&gt;transferring wal files&lt;/code&gt;.</source>
          <target state="translated">스트리밍 된 데이터의 양. 이 카운터는 단계가 &lt;code&gt;streaming database files&lt;/code&gt; 하거나 &lt;code&gt;transferring wal files&lt;/code&gt; 하는 경우에만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb98c34253bd6741e222de32790839f4b0bbf938" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;ordering&amp;rdquo; operator entry indicates that an index of this operator family can be scanned to return rows in the order represented by &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Such an operator could return any sortable data type, though again its left-hand input type must match the index's column data type. The exact semantics of the &lt;code&gt;ORDER BY&lt;/code&gt; are specified by the &lt;code&gt;amopsortfamily&lt;/code&gt; column, which must reference a B-tree operator family for the operator's result type.</source>
          <target state="translated">&quot;순서&quot;연산자 항목은 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 로 표시되는 순서대로 행을 리턴하기 위해이 연산자 제품군의 인덱스를 스캔 할 수 있음을 나타냅니다 . 이러한 연산자는 정렬 가능한 데이터 형식을 반환 할 수 있지만 왼쪽 입력 형식은 인덱스의 열 데이터 형식과 일치해야합니다. &lt;code&gt;ORDER BY&lt;/code&gt; 의 정확한 의미는 &lt;code&gt;amopsortfamily&lt;/code&gt; 열에 의해 지정되며 연산자의 결과 유형에 대한 B- 트리 연산자 패밀리를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d377056771f89a3a21b9faebc41fe3335e17744" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attribute&lt;/a&gt; found in a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 또는 &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;보기&lt;/a&gt; 에 있는 &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;속성&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef1279b86476578e5585aff75989181f73dcffd4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=&lt;/code&gt; operator must be an equivalence relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; of the data type:</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 연산자 동치 관계이어야; 즉 , 데이터 유형의 널이 아닌 모든 값 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 의 경우 :</target>
        </trans-unit>
        <trans-unit id="c4237e342da22e5fcef0feed597ee14805fa3aa4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;equalimage&lt;/code&gt; function must have the signature</source>
          <target state="translated">&lt;code&gt;equalimage&lt;/code&gt; 의 기능은 서명이 있어야합니다</target>
        </trans-unit>
        <trans-unit id="009a293231558c68203740163c433bc30d08defc" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;in_range&lt;/code&gt; function must have the signature</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 의 기능은 서명이 있어야합니다</target>
        </trans-unit>
        <trans-unit id="89039523af081d32fe0dcce5afd61336bd5c01d2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;options&lt;/code&gt; support function must have the signature</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 지원 기능은 서명이 있어야합니다</target>
        </trans-unit>
        <trans-unit id="857fc13a44d4059f0989bb54c261a11965498b57" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;unaccent&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 사전은 다음과 같은 옵션을 적용합니다</target>
        </trans-unit>
        <trans-unit id="044945d1a76181f7c4bcb8b32669d47c02d34474" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;aggregate expression&lt;/em&gt; represents the application of an aggregate function across the rows selected by a query. An aggregate function reduces multiple inputs to a single output value, such as the sum or average of the inputs. The syntax of an aggregate expression is one of the following:</source>
          <target state="translated">&lt;em&gt;집계 식은&lt;/em&gt; 쿼리에 의해 선택된 행에 걸쳐 집계 함수의 적용을 나타낸다. 집계 함수는 여러 입력을 합 또는 평균과 같은 단일 출력 값으로 줄입니다. 집계 표현식의 구문은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9cf57ce9f4c43bfd5a2501334071928e81cfc082" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;연산자 클래스&lt;/em&gt; 색인의 각 열에 대해 지정 될 수있다. 연산자 클래스는 해당 열의 색인에서 사용할 연산자를 식별합니다. 예를 들어, 4 바이트 정수의 B- 트리 인덱스는 &lt;code&gt;int4_ops&lt;/code&gt; 클래스를 사용합니다 . 이 연산자 클래스에는 4 바이트 정수에 대한 비교 함수가 포함됩니다. 실제로는 열의 데이터 유형에 대한 기본 연산자 클래스로 충분합니다. 연산자 클래스를 갖는 주요 요점은 일부 데이터 유형의 경우 의미있는 순서가 둘 이상있을 수 있다는 것입니다. 예를 들어 복소수 데이터 유형을 절대 값 또는 실수로 정렬 할 수 있습니다. 데이터 형식에 대해 두 개의 연산자 클래스를 정의한 다음 인덱스를 만들 때 적절한 클래스를 선택하면됩니다. 연산자 클래스에 대한 자세한 정보는&lt;a href=&quot;indexes-opclass&quot;&gt;11.10 항&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;37.16 항&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cd3ddc4485e8a07b58b1b313130fa7a0d1e8729" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; with optional parameters can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">인덱스의 각 열에 대해 선택적 매개 변수가 있는 &lt;em&gt;연산자 클래스&lt;/em&gt; 를 지정할 수 있습니다. 연산자 클래스는 해당 열의 인덱스에서 사용할 연산자를 식별합니다. 예를 들어, 4 바이트 정수의 B- 트리 인덱스는 &lt;code&gt;int4_ops&lt;/code&gt; 를 사용합니다 .수업; 이 연산자 클래스에는 4 바이트 정수에 대한 비교 함수가 포함되어 있습니다. 실제로 열의 데이터 유형에 대한 기본 연산자 클래스는 일반적으로 충분합니다. 연산자 클래스를 갖는 요점은 일부 데이터 유형의 경우 하나 이상의 의미있는 순서가있을 수 있다는 것입니다. 예를 들어, 절대 값이나 실수로 복소수 데이터 유형을 정렬 할 수 있습니다. 데이터 유형에 대해 두 개의 연산자 클래스를 정의한 다음 인덱스를 만들 때 적절한 클래스를 선택하여이를 수행 할 수 있습니다. 연산자 클래스에 대한 자세한 내용은 &lt;a href=&quot;indexes-opclass&quot;&gt;섹션 11.10&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;섹션 37.16에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d61fa80ff015b13be4db7ffab694d479aec5c7" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="translated">ARE는 &lt;em&gt;임베디드 옵션으로&lt;/em&gt; 시작할 수 &lt;em&gt;있습니다&lt;/em&gt; . 시퀀스 &lt;code&gt;(?&lt;/code&gt; &lt;code&gt;xyz&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; (여기서 &lt;code&gt;xyz&lt;/code&gt; 는 하나 이상의 알파벳 문자 임)는 나머지 RE에 영향을주는 옵션을 지정합니다. 이러한 옵션은 이전에 결정된 옵션보다 우선합니다. 특히 정규식 연산자에 의해 암시 된 대 / 소문자 구분 동작이나 정규식 함수에 대한 &lt;code&gt;flags&lt;/code&gt; 매개 변수를 재정의 할 수 있습니다 . 사용 가능한 옵션 문자가 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23&lt;/a&gt; 에 나와 있습니다. 이 같은 옵션 문자는 정규식 함수 의 &lt;code&gt;flags&lt;/code&gt; 매개 변수에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="451a7edefd1d33d9d12316f5963ee8b77dc6c002" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="translated">ARE는 &lt;em&gt;포함 된 옵션으로&lt;/em&gt; 시작할 수 &lt;em&gt;있습니다&lt;/em&gt; . 시퀀스 &lt;code&gt;(?&lt;/code&gt; &lt;code&gt;xyz&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; (여기서 &lt;code&gt;xyz&lt;/code&gt; 는 하나 이상의 알파벳 문자)는 나머지 RE에 영향을주는 옵션을 지정합니다. 이러한 옵션은 이전에 결정된 옵션을 재정의합니다. 특히 정규 표현식 연산자가 암시하는 대 / 소문자 구분 동작 또는 정규식 함수에 대한 &lt;code&gt;flags&lt;/code&gt; 매개 변수를 재정의 할 수 있습니다 . 사용 가능한 옵션 문자는 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.24&lt;/a&gt; 에 나와 있습니다. 이러한 동일한 옵션 문자가 정규식 함수 의 &lt;code&gt;flags&lt;/code&gt; 매개 변수에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8303919571de789ee40617113cb585782a02b887" translate="yes" xml:space="preserve">
          <source>An IP address range is specified using standard numeric notation for the range's starting address, then a slash (&lt;code&gt;/&lt;/code&gt;) and a CIDR mask length. The mask length indicates the number of high-order bits of the client IP address that must match. Bits to the right of this should be zero in the given IP address. There must not be any white space between the IP address, the &lt;code&gt;/&lt;/code&gt;, and the CIDR mask length.</source>
          <target state="translated">IP 주소 범위는 범위의 시작 주소에 대한 표준 숫자 표기법, 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 및 CIDR 마스크 길이를 사용하여 지정됩니다. 마스크 길이는 일치해야하는 클라이언트 IP 주소의 상위 비트 수를 나타냅니다. 주어진 IP 주소에서 오른쪽의 비트는 0이어야합니다. IP 주소, &lt;code&gt;/&lt;/code&gt; 및 CIDR 마스크 길이 사이에 공백이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4d44878e850b43c3405e5eb1f7f363ec736fdcdb" translate="yes" xml:space="preserve">
          <source>An RE can begin with one of two special &lt;em&gt;director&lt;/em&gt; prefixes. If an RE begins with &lt;code&gt;***:&lt;/code&gt;, the rest of the RE is taken as an ARE. (This normally has no effect in PostgreSQL, since REs are assumed to be AREs; but it does have an effect if ERE or BRE mode had been specified by the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function.) If an RE begins with &lt;code&gt;***=&lt;/code&gt;, the rest of the RE is taken to be a literal string, with all characters considered ordinary characters.</source>
          <target state="translated">RE는 두 가지 특수 &lt;em&gt;디렉터&lt;/em&gt; 접두사 중 하나로 시작할 수 있습니다 . RE가 &lt;code&gt;***:&lt;/code&gt; 로 시작 하면 나머지 RE는 ARE로 간주됩니다. RE는 ARE로 가정되기 때문에 PostgreSQL에는 일반적으로 영향을 미치지 않지만 reg 매개 변수로 &lt;code&gt;flags&lt;/code&gt; 매개 변수에 의해 ERE 또는 BRE 모드가 지정된 경우에는 영향을 미칩니다 . RE가 &lt;code&gt;***=&lt;/code&gt; 로 시작하는 경우 나머지 RE는 리터럴 문자열로 간주되며 모든 문자는 일반 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f92f9e66ed8af2bcc3cdde26f5c0bbb45e8250e2" translate="yes" xml:space="preserve">
          <source>An RE cannot end with a backslash (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">RE는 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )로 끝날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="081369b9016058fa6fc78b0eda53f1fad864ebdf" translate="yes" xml:space="preserve">
          <source>An RE consisting of two or more branches connected by the &lt;code&gt;|&lt;/code&gt; operator is always greedy.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 으로 연결된 둘 이상의 분기로 구성된 RE | 연산자는 항상 욕심입니다.</target>
        </trans-unit>
        <trans-unit id="d49fecf670a244dc0b1f819b231bb69a34573ff1" translate="yes" xml:space="preserve">
          <source>An RFC 4516 LDAP URL. This is an alternative way to write some of the other LDAP options in a more compact and standard form. The format is</source>
          <target state="translated">RFC 4516 LDAP URL입니다. 이것은 다른 LDAP 옵션 중 일부를보다 간결하고 표준 형식으로 작성하는 대체 방법입니다. 형식은</target>
        </trans-unit>
        <trans-unit id="f7312c64a5fb73a6994e92da5b12fd76cc61e03e" translate="yes" xml:space="preserve">
          <source>An SHA1 hash of the random prefix and data is appended.</source>
          <target state="translated">임의 접두사 및 데이터의 SHA1 해시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a965fc350f5f7dc5c4c1f8d246e2c0ef7db3f8" translate="yes" xml:space="preserve">
          <source>An SQL command that is used to allow a &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;user&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; to access specific objects within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;사용자&lt;/a&gt; 또는 &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;역할&lt;/a&gt; 이 &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;데이터베이스&lt;/a&gt; 내의 특정 개체에 액세스 할 수 있도록 허용하는 데 사용되는 SQL 명령입니다 .</target>
        </trans-unit>
        <trans-unit id="b6dc35165836f5ddf8c81146786e84d00be18739" translate="yes" xml:space="preserve">
          <source>An SQL command used to add new data into a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블에&lt;/a&gt; 새 데이터를 추가하는 데 사용되는 SQL 명령 .</target>
        </trans-unit>
        <trans-unit id="8802fb5ebf1fb183b8afc9517e0fb8a334aaa1ec" translate="yes" xml:space="preserve">
          <source>An SQL command used to modify &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; that may already exist in a specified &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;. It cannot create or remove rows.</source>
          <target state="translated">지정된 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 에 이미있을 수있는 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;행&lt;/a&gt; 을 수정하는 데 사용되는 SQL 명령 입니다. 행을 만들거나 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2cced83fa51a6d9077bcc4256624ffa5277885e" translate="yes" xml:space="preserve">
          <source>An SQL command which removes &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; from a given &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 또는 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 에서 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;행&lt;/a&gt; 을 제거하는 SQL 명령 .</target>
        </trans-unit>
        <trans-unit id="f0fe55953856dbcea542a9b75d2a05e987bd7029" translate="yes" xml:space="preserve">
          <source>An SQL statement defining an object to be created within the schema. Currently, only &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE VIEW&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE SEQUENCE&lt;/code&gt;, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and &lt;code&gt;GRANT&lt;/code&gt; are accepted as clauses within &lt;code&gt;CREATE SCHEMA&lt;/code&gt;. Other kinds of objects may be created in separate commands after the schema is created.</source>
          <target state="translated">스키마 내에 작성 될 오브젝트를 정의하는 SQL 문. 현재 &lt;code&gt;CREATE TABLE&lt;/code&gt; , &lt;code&gt;CREATE VIEW&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; , &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; , &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 및 &lt;code&gt;GRANT&lt;/code&gt; 만 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 내 절로 허용됩니다 . 다른 종류의 객체는 스키마가 생성 된 후 별도의 명령으로 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48fae02660a1ba4984826c61b82cac7e0aec9ce9" translate="yes" xml:space="preserve">
          <source>An SQL/JSON path expression is typically written in an SQL query as an SQL character string literal, so it must be enclosed in single quotes, and any single quotes desired within the value must be doubled (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;). Some forms of path expressions require string literals within them. These embedded string literals follow JavaScript/ECMAScript conventions: they must be surrounded by double quotes, and backslash escapes may be used within them to represent otherwise-hard-to-type characters. In particular, the way to write a double quote within an embedded string literal is &lt;code&gt;\&quot;&lt;/code&gt;, and to write a backslash itself, you must write &lt;code&gt;\\&lt;/code&gt;. Other special backslash sequences include those recognized in JSON strings: &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\v&lt;/code&gt; for various ASCII control characters, and &lt;code&gt;\uNNNN&lt;/code&gt; for a Unicode character identified by its 4-hex-digit code point. The backslash syntax also includes two cases not allowed by JSON: &lt;code&gt;\xNN&lt;/code&gt; for a character code written with only two hex digits, and &lt;code&gt;\u{N...}&lt;/code&gt; for a character code written with 1 to 6 hex digits.</source>
          <target state="translated">SQL / JSON 경로 표현식은 일반적으로 SQL 쿼리에서 SQL 문자열 리터럴로 작성되므로 작은 따옴표로 묶어야하며 값 내에서 원하는 작은 따옴표는 두 배가되어야합니다 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;4.1.2.1&lt;/a&gt; 참조 ). 일부 경로 표현식 형식에는 문자열 리터럴이 필요합니다. 이 포함 된 문자열 리터럴은 JavaScript / ECMAScript 규칙을 따릅니다. 큰 따옴표로 묶어야하며 역 슬래시 이스케이프를 사용하여 형식이 어려운 문자를 나타낼 수 있습니다. 특히, 포함 된 문자열 리터럴 내에 큰 따옴표를 쓰는 방법은 &lt;code&gt;\&quot;&lt;/code&gt; 이며 백 슬래시 자체를 쓰려면 &lt;code&gt;\\&lt;/code&gt; 를 써야합니다 . 다른 특수 백 슬래시 시퀀스에는 JSON 문자열에서 인식되는 것들이 있습니다 : &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; 다양한 ASCII 제어 문자의 경우 , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , &lt;code&gt;\v&lt;/code&gt; 및 4 진수 코드 포인트로 식별되는 유니 코드 문자의 경우 &lt;code&gt;\uNNNN&lt;/code&gt; 백 슬래시 구문에는 JSON에서 허용하지 않는 두 가지 경우도 포함됩니다. 두 개의 16 진수로만 작성된 문자 코드의 경우 &lt;code&gt;\xNN&lt;/code&gt; , 1에서 6 개의 16 진수로 작성된 문자 코드의 경우 &lt;code&gt;\u{N...}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a47144dcc7f07df67a82e2f341e637ce0d341143" translate="yes" xml:space="preserve">
          <source>An additional caveat, if the goal is to avoid recalculating &lt;code&gt;f(x)&lt;/code&gt;, is that the planner won't necessarily match uses of &lt;code&gt;f(x)&lt;/code&gt; that aren't in indexable &lt;code&gt;WHERE&lt;/code&gt; clauses to the index column. It will usually get this right in simple queries such as shown above, but not in queries that involve joins. These deficiencies may be remedied in future versions of PostgreSQL.</source>
          <target state="translated">&lt;code&gt;f(x)&lt;/code&gt; 재 계산을 피하는 것이 목표 인 경우 추가 경고 는 플래너가 색인 가능한 &lt;code&gt;WHERE&lt;/code&gt; 절에 없는 &lt;code&gt;f(x)&lt;/code&gt; 사용을 색인 열과 반드시 일치시킬 필요 는 없다는 것입니다 . 일반적으로 위와 같은 간단한 쿼리에서는이 권한을 얻지 만 조인이 포함 된 쿼리에서는 그렇지 않습니다. 이러한 결함은 이후 버전의 PostgreSQL에서 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7407a4adf6d27ef60782fee33abc21dda639d1bb" translate="yes" xml:space="preserve">
          <source>An additional expectation is that &lt;code&gt;in_range&lt;/code&gt; functions should, if practical, avoid throwing an error if &lt;code&gt;base&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;base&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; would overflow. The correct comparison result can be determined even if that value would be out of the data type's range. Note that if the data type includes concepts such as &amp;ldquo;infinity&amp;rdquo; or &amp;ldquo;NaN&amp;rdquo;, extra care may be needed to ensure that &lt;code&gt;in_range&lt;/code&gt;'s results agree with the normal sort order of the operator family.</source>
          <target state="translated">또 다른 기대는 &lt;code&gt;in_range&lt;/code&gt; 함수가 실제적인 경우 &lt;code&gt;base&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 또는 &lt;code&gt;base&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 이 오버플로 될 경우 오류를 발생시키지 않아야한다는 것입니다. 해당 값이 데이터 유형의 범위를 벗어난 경우에도 정확한 비교 결과를 확인할 수 있습니다. 데이터 유형에 &quot;무한대&quot;또는 &quot;NaN&quot;과 같은 개념이 포함 된 경우 &lt;code&gt;in_range&lt;/code&gt; 의 결과가 연산자 제품군의 일반적인 정렬 순서와 일치 하도록 추가주의가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb253cb4aa708d5943b4ee75823919dac326e149" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.63&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="translated">파서에서 제공하는 추가 휴리스틱을 사용하면 암시 적 캐스트가있는 유형 그룹간에 적절한 캐스트 동작을보다 잘 결정할 수 있습니다. 데이터 유형은 &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;bitstring&lt;/code&gt; , &lt;code&gt;datetime&lt;/code&gt; , &lt;code&gt;timespan&lt;/code&gt; , &lt;code&gt;geometric&lt;/code&gt; , &lt;code&gt;network&lt;/code&gt; 및 사용자 정의를 포함하여 몇 가지 기본 &lt;em&gt;유형 범주&lt;/em&gt; 로 나뉩니다 . (목록은 &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;표 51.63을&lt;/a&gt; 참조하십시오 . 그러나 사용자 정의 유형 카테고리를 생성 할 수도 있습니다.) 각 카테고리 내에 하나 이상의 &lt;em&gt;선호 유형&lt;/em&gt; 이있을 수 있습니다.&lt;em&gt;&lt;/em&gt;, 가능한 유형을 선택할 수있을 때 선호됩니다. 선호하는 유형과 사용 가능한 암시 적 캐스트를 신중하게 선택하면 모호한 표현식 (여러 후보 구문 분석 솔루션이있는 표현식)을 유용한 방식으로 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="534defd7e745925ed14ebff65872ea3017b9134a" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="translated">파서가 제공하는 추가 휴리스틱을 사용하면 암시 적 캐스트가있는 유형 그룹간에 적절한 캐스트 동작을보다 정확하게 결정할 수 있습니다. 데이터 유형은 &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;bitstring&lt;/code&gt; , &lt;code&gt;datetime&lt;/code&gt; , &lt;code&gt;timespan&lt;/code&gt; , &lt;code&gt;geometric&lt;/code&gt; , &lt;code&gt;network&lt;/code&gt; 및 사용자 정의를 포함하여 몇 가지 기본 &lt;em&gt;유형 카테고리&lt;/em&gt; 로 나뉩니다 . (목록은 &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;표 51.64를&lt;/a&gt; 참조하십시오 ; 그러나 사용자 정의 유형 카테고리를 작성할 수도 있습니다.) 각 카테고리 내에 하나 이상의 &lt;em&gt;선호 유형&lt;/em&gt; 이있을 수 있습니다.&lt;em&gt;&lt;/em&gt;가능한 유형을 선택할 때 선호됩니다. 선호하는 유형과 사용 가능한 암시 적 캐스트를 신중하게 선택하면 모호한 표현 (여러 후보 구문 분석 솔루션이있는 표현)을 유용한 방식으로 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc0f4d6b418b13b44c7318de707eba4cc69a20d" translate="yes" xml:space="preserve">
          <source>An additional property of most of the OID alias types is the creation of dependencies. If a constant of one of these types appears in a stored expression (such as a column default expression or view), it creates a dependency on the referenced object. For example, if a column has a default expression &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt;, PostgreSQL understands that the default expression depends on the sequence &lt;code&gt;my_seq&lt;/code&gt;; the system will not let the sequence be dropped without first removing the default expression. &lt;code&gt;regrole&lt;/code&gt; is the only exception for the property. Constants of this type are not allowed in such expressions.</source>
          <target state="translated">대부분의 OID 별명 유형의 추가 특성은 종속성 작성입니다. 이러한 유형 중 하나의 상수가 저장된 표현식 (예 : 열 기본 표현식 또는 뷰)에 표시되면 참조 된 오브젝트에 대한 종속성을 작성합니다. 예를 들어, 열에 기본 표현식 &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt; 가있는 경우 PostgreSQL은 기본 표현식이 &lt;code&gt;my_seq&lt;/code&gt; 시퀀스에 의존한다는 것을 이해합니다 . 시스템은 기본 표현식을 먼저 제거하지 않으면 시퀀스가 ​​삭제되지 않습니다. &lt;code&gt;regrole&lt;/code&gt; 은 본 호텔의 유일한 예외입니다. 이러한 유형의 상수는 이러한 표현식에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="458e50f0c0fe0a599acde7428114320c8fb97644" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;섹션 37.12.1에&lt;/a&gt; 설명 된대로 집계는 선택적으로 &lt;em&gt;이동 집계 모드를&lt;/em&gt; 지원할 수 있습니다 . 이를 위해서는 &lt;code&gt;MSFUNC&lt;/code&gt; , &lt;code&gt;MINVFUNC&lt;/code&gt; 및 &lt;code&gt;MSTYPE&lt;/code&gt; 매개 변수 및 선택적으로 &lt;code&gt;MSSPACE&lt;/code&gt; , &lt;code&gt;MFINALFUNC&lt;/code&gt; , &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; , &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; 및 &lt;code&gt;MINITCOND&lt;/code&gt; 매개 변수를 지정해야합니다. &lt;code&gt;MINVFUNC&lt;/code&gt; 를 제외하고 이러한 매개 변수는 &lt;code&gt;M&lt;/code&gt; 이 없는 해당 단순 집계 매개 변수처럼 작동합니다 . 역 전이 함수를 포함하는 집계의 개별 구현을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="29fb09a88b1e0b362734b37fcd73ac91f7b1c450" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="translated">집계는 &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;섹션 37.12.1에&lt;/a&gt; 설명 된대로 &lt;em&gt;이동 집계 모드를&lt;/em&gt; 선택적으로 지원할 수 있습니다 . 이를 위해서는 &lt;code&gt;MSFUNC&lt;/code&gt; , &lt;code&gt;MINVFUNC&lt;/code&gt; 및 &lt;code&gt;MSTYPE&lt;/code&gt; 매개 변수와 선택적으로 &lt;code&gt;MSSPACE&lt;/code&gt; , &lt;code&gt;MFINALFUNC&lt;/code&gt; , &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; , &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; 및 &lt;code&gt;MINITCOND&lt;/code&gt; 매개 변수를 지정해야합니다. &lt;code&gt;MINVFUNC&lt;/code&gt; 를 제외하고 이러한 매개 변수는 &lt;code&gt;M&lt;/code&gt; 이 없는 해당 단순 집계 매개 변수처럼 작동합니다 . 역전이 함수를 포함하는 집계의 별도 구현을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4d679ad2d9aaa3f73ccadb1adf16347c9d1df070" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;37.12.4 절에&lt;/a&gt; 설명 된 것처럼 집계는 선택적으로 &lt;em&gt;부분 집계를&lt;/em&gt; 지원할 수 있습니다 . &lt;code&gt;COMBINEFUNC&lt;/code&gt; 매개 변수를 지정해야합니다 . 경우] &lt;code&gt;state_data_type&lt;/code&gt; 가 인 &lt;code&gt;internal&lt;/code&gt; , 일반적으로도 제공 할 수있어 적절한 &lt;code&gt;SERIALFUNC&lt;/code&gt; 및 &lt;code&gt;DESERIALFUNC&lt;/code&gt; 그 병렬 통합이 가능하므로 파라미터. 병렬 집계를 사용 가능하게 하려면 집계에도 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; 가 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f7e84609c5356ef9572b92f634b5a8669d5cf54b" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="translated">집계는 &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;섹션 37.12.4에&lt;/a&gt; 설명 된대로 &lt;em&gt;부분 집계를&lt;/em&gt; 선택적으로 지원할 수 있습니다 . 이를 위해서는 &lt;code&gt;COMBINEFUNC&lt;/code&gt; 매개 변수를 지정해야합니다 . 경우] &lt;code&gt;state_data_type&lt;/code&gt; 가 인 &lt;code&gt;internal&lt;/code&gt; , 일반적으로도 제공 할 수있어 적절한 &lt;code&gt;SERIALFUNC&lt;/code&gt; 및 &lt;code&gt;DESERIALFUNC&lt;/code&gt; 그 병렬 통합이 가능하므로 파라미터. 병렬 집계를 사용 하려면 집계도 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; 로 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2dfc7ac5613e772bc99452f1945c3b220614eb51" translate="yes" xml:space="preserve">
          <source>An aggregate expression</source>
          <target state="translated">집계 식</target>
        </trans-unit>
        <trans-unit id="e0807075b6b78aa07561f78a847dd6293e2860ad" translate="yes" xml:space="preserve">
          <source>An aggregate expression can only appear in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; command. It is forbidden in other clauses, such as &lt;code&gt;WHERE&lt;/code&gt;, because those clauses are logically evaluated before the results of aggregates are formed.</source>
          <target state="translated">집계 표현식은 &lt;code&gt;SELECT&lt;/code&gt; 명령 의 결과 목록 또는 &lt;code&gt;HAVING&lt;/code&gt; 절 에만 나타날 수 있습니다 . &lt;code&gt;WHERE&lt;/code&gt; 와 같은 다른 절에서는 이러한 절이 집계 결과가 형성되기 전에 논리적으로 평가되므로 금지됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5cc6417758e002213e0379735846ccb8b7a9410" translate="yes" xml:space="preserve">
          <source>An aggregate function can provide an initial condition, that is, an initial value for the internal state value. This is specified and stored in the database as a value of type &lt;code&gt;text&lt;/code&gt;, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out null.</source>
          <target state="translated">집계 함수는 초기 조건, 즉 내부 상태 값의 초기 값을 제공 할 수 있습니다. 이것은 &lt;code&gt;text&lt;/code&gt; 유형의 값으로 데이터베이스에 지정되고 저장 되지만 상태 값 데이터 유형의 상수에 대한 유효한 외부 표현이어야합니다. 제공되지 않으면 상태 값은 null로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4c0a9d3ddcc76a8af6ce90bf3fe2aed9cae7fe77" translate="yes" xml:space="preserve">
          <source>An aggregate function is identified by its name and input data type(s). Two aggregates in the same schema can have the same name if they operate on different input types. The name and input data type(s) of an aggregate must also be distinct from the name and input data type(s) of every ordinary function in the same schema. This behavior is identical to overloading of ordinary function names (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;).</source>
          <target state="translated">집계 함수는 이름 및 입력 데이터 유형으로 식별됩니다. 동일한 스키마의 두 집계는 서로 다른 입력 유형에서 작동하는 경우 동일한 이름을 가질 수 있습니다. 집계의 이름 및 입력 데이터 유형은 동일한 스키마에있는 모든 일반 함수의 이름 및 입력 데이터 유형과도 달라야합니다. 이 동작은 일반 함수 이름 오버로드와 동일합니다 ( &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2b3e0e3a20d60ad454bd8cd7d186466b528e1274" translate="yes" xml:space="preserve">
          <source>An aggregate function whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt; can participate in parallel aggregation only if it has a &lt;code&gt;serialfunc&lt;/code&gt; function, which must serialize the aggregate state into a &lt;code&gt;bytea&lt;/code&gt; value for transmission to another process. This function must take a single argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;bytea&lt;/code&gt;. A corresponding &lt;code&gt;deserialfunc&lt;/code&gt; is also required.</source>
          <target state="translated">&lt;code&gt;state_data_type&lt;/code&gt; 이 &lt;code&gt;internal&lt;/code&gt; 의 집계 함수 는 &lt;code&gt;serialfunc&lt;/code&gt; 함수 가있는 경우에만 병렬 집계에 참여할 수 있습니다. 이 함수는 다른 프로세스로 전송하기 위해 집계 상태를 &lt;code&gt;bytea&lt;/code&gt; 값 으로 직렬화해야합니다 . 이 함수는 &lt;code&gt;internal&lt;/code&gt; 유형 및 return 유형 &lt;code&gt;bytea&lt;/code&gt; 의 단일 인수를 가져와야 합니다. 해당 &lt;code&gt;deserialfunc&lt;/code&gt; 도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="df00344c6606cf49c7be60428adf4c46220a9708" translate="yes" xml:space="preserve">
          <source>An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by &lt;code&gt;ORDINALITY&lt;/code&gt; if present.</source>
          <target state="translated">별명은 테이블과 동일한 방식으로 제공 될 수 있습니다. 별명이 작성되면 &lt;code&gt;ORDINALITY&lt;/code&gt; 가있는 경우 추가 된 열을 포함하여 함수 복합 리턴 유형의 하나 이상의 속성에 대한 대체 이름을 제공하기 위해 열 별명 목록을 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0250a12b43f45cb324a618ef9cdbd68812da4e5" translate="yes" xml:space="preserve">
          <source>An alternative backup strategy is to directly copy the files that PostgreSQL uses to store the data in the database; &lt;a href=&quot;creating-cluster&quot;&gt;Section 18.2&lt;/a&gt; explains where these files are located. You can use whatever method you prefer for doing file system backups; for example:</source>
          <target state="translated">다른 백업 전략은 PostgreSQL이 데이터베이스에 데이터를 저장하는 데 사용하는 파일을 직접 복사하는 것입니다. &lt;a href=&quot;creating-cluster&quot;&gt;18.2 절&lt;/a&gt; 에이 파일들의 위치가 설명되어 있습니다. 파일 시스템 백업을 위해 선호하는 방법을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b61de693c26d02887a03f9b9c2b1cd2f4c796982" translate="yes" xml:space="preserve">
          <source>An alternative file-system backup approach is to make a &amp;ldquo;consistent snapshot&amp;rdquo; of the data directory, if the file system supports that functionality (and you are willing to trust that it is implemented correctly). The typical procedure is to make a &amp;ldquo;frozen snapshot&amp;rdquo; of the volume containing the database, then copy the whole data directory (not just parts, see above) from the snapshot to a backup device, then release the frozen snapshot. This will work even while the database server is running. However, a backup created in this way saves the database files in a state as if the database server was not properly shut down; therefore, when you start the database server on the backed-up data, it will think the previous server instance crashed and will replay the WAL log. This is not a problem; just be aware of it (and be sure to include the WAL files in your backup). You can perform a &lt;code&gt;CHECKPOINT&lt;/code&gt; before taking the snapshot to reduce recovery time.</source>
          <target state="translated">다른 파일 시스템 백업 방법은 파일 시스템이 해당 기능을 지원하고 올바르게 구현되었다고 믿을 경우 데이터 디렉토리의 &quot;일관된 스냅 샷&quot;을 만드는 것입니다. 일반적인 절차는 데이터베이스가 포함 된 볼륨의 &quot;고정 된 스냅 샷&quot;을 만든 다음 스냅 샷에서 백업 장치로 전체 데이터 디렉토리 (부분 만이 아니라 위 참조)를 복사 한 다음 고정 된 스냅 샷을 해제하는 것입니다. 데이터베이스 서버가 실행되는 동안에도 작동합니다. 그러나이 방법으로 작성된 백업은 데이터베이스 서버가 제대로 종료되지 않은 것처럼 데이터베이스 파일을 저장합니다. 따라서 백업 된 데이터에서 데이터베이스 서버를 시작하면 이전 서버 인스턴스가 충돌 한 것으로 간주하여 WAL 로그를 재생합니다. 이것은 문제가되지 않습니다.이를 알고 있어야하며 백업에 WAL 파일을 포함시켜야합니다. 당신은 수행 할 수 있습니다 &lt;code&gt;CHECKPOINT&lt;/code&gt; 복구 시간을 줄이기 위해 스냅 샷을 복용하기 전에.</target>
        </trans-unit>
        <trans-unit id="c3c3283b5d81a417bf78d55aa00de334b32f532e" translate="yes" xml:space="preserve">
          <source>An alternative syntax, which conforms to the SQL standard by using the keyword &lt;code&gt;ARRAY&lt;/code&gt;, can be used for one-dimensional arrays. &lt;code&gt;pay_by_quarter&lt;/code&gt; could have been defined as:</source>
          <target state="translated">&lt;code&gt;ARRAY&lt;/code&gt; 키워드를 사용하여 SQL 표준을 따르는 대체 구문 을 1 차원 배열에 사용할 수 있습니다. &lt;code&gt;pay_by_quarter&lt;/code&gt; 는 다음과 같이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="638c7c832e5e9b62d5fb5f6d733b2905e931d645" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="translated">이전 섹션에서 설명한 내장 대기 모드에 대한 대안 은 아카이브 위치를 폴링 하는 &lt;code&gt;restore_command&lt;/code&gt; 를 사용하는 것 입니다. 버전 8.4 이하에서만 사용 가능한 옵션이었습니다. 이에 대한 참조 구현은 &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a8b7165adb636504ac5f79579ceffb000f734741" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="translated">이전 섹션에서 설명한 내장 대기 모드의 대안 은 아카이브 위치를 폴링 하는 &lt;code&gt;restore_command&lt;/code&gt; 를 사용하는 것 입니다. 이것은 버전 8.4 이하에서 사용할 수있는 유일한 옵션이었습니다. 이에 대한 참조 구현은 &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fa59772716d4044140c10df2d8b7a5924c081417" translate="yes" xml:space="preserve">
          <source>An alternative way to specify connection parameters is in a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string or a URI, which is used instead of a database name. This mechanism give you very wide control over the connection. For example:</source>
          <target state="translated">연결 매개 변수를 지정하는 대체 방법 은 데이터베이스 이름 대신 사용되는 &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; 문자열 또는 URI에 있습니다. 이 메커니즘은 연결을 매우 광범위하게 제어합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ec33e5bc23fcb877ba4c42aa95a3a9f21f59a6d" translate="yes" xml:space="preserve">
          <source>An arbitrary identifier that later identifies this transaction for &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. The identifier must be written as a string literal, and must be less than 200 bytes long. It must not be the same as the identifier used for any currently prepared transaction.</source>
          <target state="translated">나중에 &lt;code&gt;COMMIT PREPARED&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 에 대한이 트랜잭션을 식별하는 임의의 식별자입니다 . 식별자는 문자열 리터럴로 작성되어야하며 길이는 200 바이트보다 작아야합니다. 현재 준비된 거래에 사용 된 식별자와 동일해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="154d8a4c4e542e35a1befe68e1484bcdb9bfce9b" translate="yes" xml:space="preserve">
          <source>An arbitrary name given to this particular prepared statement. It must be unique within a single session and is subsequently used to execute or deallocate a previously prepared statement.</source>
          <target state="translated">이 특정한 준비된 진술에 주어진 임의의 이름. 단일 세션 내에서 고유해야하며 이전에 준비된 명령문을 실행하거나 할당 해제하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8cfd518cee734d4e6e12ef304061cfa2c5efcc5d" translate="yes" xml:space="preserve">
          <source>An array can also be constructed by using the functions &lt;code&gt;array_prepend&lt;/code&gt;, &lt;code&gt;array_append&lt;/code&gt;, or &lt;code&gt;array_cat&lt;/code&gt;. The first two only support one-dimensional arrays, but &lt;code&gt;array_cat&lt;/code&gt; supports multidimensional arrays. Some examples:</source>
          <target state="translated">&lt;code&gt;array_prepend&lt;/code&gt; , &lt;code&gt;array_append&lt;/code&gt; 또는 &lt;code&gt;array_cat&lt;/code&gt; 함수를 사용하여 배열을 구성 할 수도 있습니다 . 처음 두 개는 1 차원 배열 만 지원하지만 &lt;code&gt;array_cat&lt;/code&gt; 은 다차원 배열을 지원합니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="b9253fad046b597c92ebf100d62457d49600956f" translate="yes" xml:space="preserve">
          <source>An array can also be updated at a single element:</source>
          <target state="translated">단일 요소에서 배열을 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="207ba5c2689d9a2decbdf9a201e85765c620f79a" translate="yes" xml:space="preserve">
          <source>An array constructor</source>
          <target state="translated">배열 생성자</target>
        </trans-unit>
        <trans-unit id="22dde08afcbb8b9d32ea23d688400ce811c7d712" translate="yes" xml:space="preserve">
          <source>An array constructor is an expression that builds an array value using values for its member elements. A simple array constructor consists of the key word &lt;code&gt;ARRAY&lt;/code&gt;, a left square bracket &lt;code&gt;[&lt;/code&gt;, a list of expressions (separated by commas) for the array element values, and finally a right square bracket &lt;code&gt;]&lt;/code&gt;. For example:</source>
          <target state="translated">배열 생성자는 멤버 요소의 값을 사용하여 배열 값을 작성하는 표현식입니다. 간단한 배열 생성자는 키워드 &lt;code&gt;ARRAY&lt;/code&gt; , 왼쪽 대괄호 &lt;code&gt;[&lt;/code&gt; , 배열 요소 값에 대한 표현식 목록 (쉼표로 구분) 및 오른쪽 대괄호 &lt;code&gt;]&lt;/code&gt; 로 구성 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7dbcd90a7826ddce4d84f03c4037551f65cc619b" translate="yes" xml:space="preserve">
          <source>An array containing codes for the enabled statistic kinds; valid values are: &lt;code&gt;d&lt;/code&gt; for n-distinct statistics, &lt;code&gt;f&lt;/code&gt; for functional dependency statistics, and &lt;code&gt;m&lt;/code&gt; for most common values (MCV) list statistics</source>
          <target state="translated">사용 가능한 통계 종류에 대한 코드가 포함 된 배열입니다. 유효한 값은 다음과 같습니다. n 고유 통계의 경우 &lt;code&gt;d&lt;/code&gt; , 기능 종속성 통계의 경우 &lt;code&gt;f&lt;/code&gt; , 가장 일반적인 값 (MCV) 목록 통계의 경우 &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27ac7c03cbb87eb7b9fd6d5d5942fb204a13357b" translate="yes" xml:space="preserve">
          <source>An array containing the IDs of the roles in this group</source>
          <target state="translated">이 그룹의 역할 ID를 포함하는 배열</target>
        </trans-unit>
        <trans-unit id="96036220e810514b07282609308d02f0cce74ab2" translate="yes" xml:space="preserve">
          <source>An array of attribute numbers, indicating which table columns are covered by this statistics object; for example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns are covered</source>
          <target state="translated">이 통계 개체가 다루는 테이블 열을 나타내는 특성 번호의 배열입니다. 예를 들어 값 &lt;code&gt;1 3&lt;/code&gt; 은 첫 번째 및 세 번째 테이블 열이 포함됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b19c35ad447cc03eaa08f8712bc2b7258decc833" translate="yes" xml:space="preserve">
          <source>An array slice expression likewise yields null if the array itself or any of the subscript expressions are null. However, in other cases such as selecting an array slice that is completely outside the current array bounds, a slice expression yields an empty (zero-dimensional) array instead of null. (This does not match non-slice behavior and is done for historical reasons.) If the requested slice partially overlaps the array bounds, then it is silently reduced to just the overlapping region instead of returning null.</source>
          <target state="translated">배열 자체 또는 아래 첨자식이 null 인 경우 배열 슬라이스 식도 마찬가지로 null을 생성합니다. 그러나 현재 배열 범위를 완전히 벗어난 배열 슬라이스를 선택하는 것과 같은 다른 경우 슬라이스 식은 null 대신 빈 (0 차원) 배열을 생성합니다. 요청 된 슬라이스가 배열 경계와 부분적으로 겹치는 경우 null을 반환하는 대신 겹치는 영역으로 자동 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="1acc2bad9c714dff64f3a38358f5e30f839c8b6c" translate="yes" xml:space="preserve">
          <source>An array subscript expression will return null if either the array itself or any of the subscript expressions are null. Also, null is returned if a subscript is outside the array bounds (this case does not raise an error). For example, if &lt;code&gt;schedule&lt;/code&gt; currently has the dimensions &lt;code&gt;[1:3][1:2]&lt;/code&gt; then referencing &lt;code&gt;schedule[3][3]&lt;/code&gt; yields NULL. Similarly, an array reference with the wrong number of subscripts yields a null rather than an error.</source>
          <target state="translated">배열 자체 또는 아래 첨자 식 중 하나가 null 인 경우 배열 첨자 식은 null을 반환합니다. 또한 첨자가 배열 범위를 벗어나면 null이 반환됩니다 (이 경우 오류가 발생하지 않음). 예를 들어, &lt;code&gt;schedule&lt;/code&gt; 의 크기가 &lt;code&gt;[1:3][1:2]&lt;/code&gt; 인 경우 &lt;code&gt;schedule[3][3]&lt;/code&gt; 을 참조 하면 NULL이됩니다. 마찬가지로 잘못된 수의 첨자를 가진 배열 참조는 오류가 아닌 null을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0832096d10a386e248df7b28cfa12adfe25aab94" translate="yes" xml:space="preserve">
          <source>An array value can be replaced completely:</source>
          <target state="translated">배열 값을 완전히 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4fc25fcb8b1fcdab019c9c24576221478e42a1" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes all arguments (including &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments); however, if all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripting is 1-based, whereas for historical reasons &lt;code&gt;proargtypes&lt;/code&gt; is subscripted from 0.</source>
          <target state="translated">함수 인자의 데이터 타입을 가진 배열. 여기에는 모든 인수 ( &lt;code&gt;OUT&lt;/code&gt; 및 &lt;code&gt;INOUT&lt;/code&gt; 인수 포함)가 포함됩니다. 그러나 모든 인수가 &lt;code&gt;IN&lt;/code&gt; 인수이면이 필드는 널이됩니다. 첨자 화는 1을 기반으로하는 반면 역사적 이유로 &lt;code&gt;proargtypes&lt;/code&gt; 은 0부터 첨자 화됩니다.</target>
        </trans-unit>
        <trans-unit id="b1056fb2643af14679cc3ecd97ee8851fd6939a7" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes only input arguments (including &lt;code&gt;INOUT&lt;/code&gt; and &lt;code&gt;VARIADIC&lt;/code&gt; arguments), and thus represents the call signature of the function.</source>
          <target state="translated">함수 인자의 데이터 타입을 가진 배열. 여기에는 입력 인수 ( &lt;code&gt;INOUT&lt;/code&gt; 및 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 포함) 만 포함 되므로 함수의 호출 서명을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="56e64d796da368f4732fec1eac245d18f34b8c2b" translate="yes" xml:space="preserve">
          <source>An array with the modes of the function arguments, encoded as &lt;code&gt;i&lt;/code&gt; for &lt;code&gt;IN&lt;/code&gt; arguments, &lt;code&gt;o&lt;/code&gt; for &lt;code&gt;OUT&lt;/code&gt; arguments, &lt;code&gt;b&lt;/code&gt; for &lt;code&gt;INOUT&lt;/code&gt; arguments, &lt;code&gt;v&lt;/code&gt; for &lt;code&gt;VARIADIC&lt;/code&gt; arguments, &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;TABLE&lt;/code&gt; arguments. If all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">엔코딩 함수 인수의 형태와 배열 &lt;code&gt;i&lt;/code&gt; 위한 &lt;code&gt;IN&lt;/code&gt; 의 인자 &lt;code&gt;o&lt;/code&gt; 에 대한 &lt;code&gt;OUT&lt;/code&gt; 인수 &lt;code&gt;b&lt;/code&gt; 용 &lt;code&gt;INOUT&lt;/code&gt; 의 인자 &lt;code&gt;v&lt;/code&gt; 대 &lt;code&gt;VARIADIC&lt;/code&gt; 의 인자, &lt;code&gt;t&lt;/code&gt; 에 대한 &lt;code&gt;TABLE&lt;/code&gt; 인자. 모든 인수가 &lt;code&gt;IN&lt;/code&gt; 인수이면이 필드는 널이됩니다. 아래 첨자는 &lt;code&gt;proallargtypes&lt;/code&gt; 아닌 &lt;code&gt;proargtypes&lt;/code&gt; 위치에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="19750404179dcfe4198dc9453208db71584c69d3" translate="yes" xml:space="preserve">
          <source>An array with the names of the function arguments. Arguments without a name are set to empty strings in the array. If none of the arguments have a name, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">함수 인수의 이름을 가진 배열입니다. 이름이없는 인수는 배열에서 빈 문자열로 설정됩니다. 이름을 가진 인수가 없으면이 필드는 널이됩니다. 아래 첨자는 &lt;code&gt;proallargtypes&lt;/code&gt; 아닌 &lt;code&gt;proargtypes&lt;/code&gt; 위치에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="f01a907c7341c3e9fdd4bc077438737e13efc650" translate="yes" xml:space="preserve">
          <source>An asterisk (&lt;code&gt;*&lt;/code&gt;) can be placed at the end of a synonym in the configuration file. This indicates that the synonym is a prefix. The asterisk is ignored when the entry is used in &lt;code&gt;to_tsvector()&lt;/code&gt;, but when it is used in &lt;code&gt;to_tsquery()&lt;/code&gt;, the result will be a query item with the prefix match marker (see &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;Section 12.3.2&lt;/a&gt;). For example, suppose we have these entries in &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt;:</source>
          <target state="translated">구성 파일의 동의어 끝에 별표 ( &lt;code&gt;*&lt;/code&gt; )를 넣을 수 있습니다. 이것은 동의어가 접두사임을 나타냅니다. 별표는 항목이 사용될 때 무시됩니다 &lt;code&gt;to_tsvector()&lt;/code&gt; 하지만이 사용되는 경우 &lt;code&gt;to_tsquery()&lt;/code&gt; , 결과는 접두사 일치 마커 (참조와 쿼리 항목 될 것입니다 &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;섹션 12.3.2&lt;/a&gt; ). 예를 들어 &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt; 에 다음과 같은 항목이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c86af8f966441072cea93666c92eea93103579c8" translate="yes" xml:space="preserve">
          <source>An automatically updatable view may contain a mix of updatable and non-updatable columns. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read-only, and an error will be raised if an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; statement attempts to assign a value to it.</source>
          <target state="translated">자동으로 업데이트 가능한보기에는 업데이트 가능한 열과 업데이트 불가능한 열이 혼합되어있을 수 있습니다. 기본 기본 관계의 업데이트 가능한 열에 대한 간단한 참조 인 경우 열을 업데이트 할 수 있습니다. 그렇지 않으면 열이 읽기 전용이며 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 문이 값을 지정하려고 하면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e72cb7e6b41938a2b612c62d6738c18d8f8e1034" translate="yes" xml:space="preserve">
          <source>An element with a certain name and data type found within a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;튜플&lt;/a&gt; 내에서 발견 된 특정 이름 및 데이터 유형을 가진 요소 .</target>
        </trans-unit>
        <trans-unit id="13229daa72676e5cc65b4f01d9a20d25d5a2a7d0" translate="yes" xml:space="preserve">
          <source>An encrypted PGP message consists of 2 parts, or &lt;em&gt;packets&lt;/em&gt;:</source>
          <target state="translated">암호화 된 PGP 메시지는 두 부분 또는 &lt;em&gt;패킷으로&lt;/em&gt; 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="09f724c84938e490e8dc9343f32211856b8b0d2e" translate="yes" xml:space="preserve">
          <source>An entry given in IPv4 format will match only IPv4 connections, and an entry given in IPv6 format will match only IPv6 connections, even if the represented address is in the IPv4-in-IPv6 range. Note that entries in IPv6 format will be rejected if the system's C library does not have support for IPv6 addresses.</source>
          <target state="translated">표시된 주소가 IPv4-in-IPv6 범위에 있더라도 IPv4 형식으로 제공된 항목은 IPv4 연결 만 일치하고 IPv6 형식으로 제공된 항목은 IPv6 연결 만 일치합니다. 시스템의 C 라이브러리가 IPv6 주소를 지원하지 않으면 IPv6 형식의 항목이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="938494e5885c658c095719a63c4ba845fac9421d" translate="yes" xml:space="preserve">
          <source>An entry's &lt;code&gt;amopmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family (including &lt;code&gt;amopmethod&lt;/code&gt; here is an intentional denormalization of the catalog structure for performance reasons). Also, &lt;code&gt;amoplefttype&lt;/code&gt; and &lt;code&gt;amoprighttype&lt;/code&gt; must match the &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields of the referenced &lt;code&gt;pg_operator&lt;/code&gt; entry.</source>
          <target state="translated">엔트리의 &lt;code&gt;amopmethod&lt;/code&gt; 이 일치해야한다 &lt;code&gt;opfmethod&lt;/code&gt; 의 포함 작업자의 가족을 (를 포함하여 &lt;code&gt;amopmethod&lt;/code&gt; 여기하는 것은 성능상의 이유로 카탈로그 구조의 의도적 인 비정규입니다). 또한 &lt;code&gt;amoplefttype&lt;/code&gt; 및 &lt;code&gt;amoprighttype&lt;/code&gt; 은 참조 된 &lt;code&gt;pg_operator&lt;/code&gt; 항목 의 &lt;code&gt;oprleft&lt;/code&gt; 및 &lt;code&gt;oprright&lt;/code&gt; 필드 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d1086ba8d92dc57d5ff412fcf067dd0fa10959" translate="yes" xml:space="preserve">
          <source>An enum value occupies four bytes on disk. The length of an enum value's textual label is limited by the &lt;code&gt;NAMEDATALEN&lt;/code&gt; setting compiled into PostgreSQL; in standard builds this means at most 63 bytes.</source>
          <target state="translated">열거 형 값은 디스크에서 4 바이트를 차지합니다. 열거 형 값의 텍스트 레이블 길이는 PostgreSQL로 컴파일 된 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 설정에 의해 제한됩니다 . 표준 빌드에서는 최대 63 바이트를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7d926b20cea28dde9ab53148cbd01bb72e3b71c1" translate="yes" xml:space="preserve">
          <source>An error like:</source>
          <target state="translated">다음과 같은 오류 :</target>
        </trans-unit>
        <trans-unit id="1642e5d8f757211902e7fce377a379427b2967a5" translate="yes" xml:space="preserve">
          <source>An established line of communication between a client process and a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt; process, usually over a network, supporting a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;session&lt;/a&gt;. This term is sometimes used as a synonym for session.</source>
          <target state="translated">일반적으로 네트워크를 통해 &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;세션을&lt;/a&gt; 지원하는 클라이언트 프로세스와 &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;백엔드&lt;/a&gt; 프로세스 간에 설정된 통신 회선입니다 . 이 용어는 때때로 세션의 동의어로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73f7ed75cabe931d593b5e23922ed970c7f9a2c6" translate="yes" xml:space="preserve">
          <source>An event trigger function is declared to return &lt;code&gt;event_trigger.&lt;/code&gt;</source>
          <target state="translated">이벤트 트리거 함수는 &lt;code&gt;event_trigger.&lt;/code&gt; 를 리턴 하도록 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5d03b1b3e9330df5ef72cedfa521226e3904563" translate="yes" xml:space="preserve">
          <source>An example command to insert a row would be:</source>
          <target state="translated">행을 삽입하는 명령 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3e47d13cc2aa85cb2cac79171bd5ba58c06a033" translate="yes" xml:space="preserve">
          <source>An example implementation of my_options() and parameters use from other support functions are given below:</source>
          <target state="translated">my_options () 및 다른 지원 함수에서 사용하는 매개 변수의 구현 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="77db1d337bb2340f6b1a45dac50171d5552245cf" translate="yes" xml:space="preserve">
          <source>An example is:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab2ae23169c6ecf2d8724ae3dd48f5aec7d41be5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a priority-based multiple synchronous standbys is:</source>
          <target state="translated">우선 순위 기반 다중 동기 대기에 대한 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a98fc82d0f241f92e10ef779f12a66f98cdb0af5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a quorum-based multiple synchronous standbys is:</source>
          <target state="translated">쿼럼 기반 다중 동기 대기에 대한 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd7d7ba1d423d1278de206e487f072bf081d0594" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are rows in the table that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER TABLE&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.</source>
          <target state="translated">이 가정을 어기는 일반적인 방법의 예는 &lt;code&gt;CHECK&lt;/code&gt; 표현식 에서 사용자 정의 함수를 참조한 다음 해당 함수의 동작을 변경하는 것입니다. PostgreSQL은이를 허용하지 않지만 테이블에 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 위반하는 행이 있는지 알 수 없습니다 . 이로 인해 후속 데이터베이스 덤프 및 재로드가 실패합니다. 이러한 변경을 처리하기 위해 권장되는 방법은 &lt;code&gt;ALTER TABLE&lt;/code&gt; 을 사용하여 제한 조건을 삭제 하고 함수 정의를 조정 한 후 제한 조건을 다시 추가하여 모든 테이블 행에 대해 다시 점검하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0fc2dcac68631535509b1c9851983c8f16591ded" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are stored values of the domain type that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER DOMAIN&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against stored data.</source>
          <target state="translated">이 가정을 어기는 일반적인 방법의 예는 &lt;code&gt;CHECK&lt;/code&gt; 표현식 에서 사용자 정의 함수를 참조한 다음 해당 함수의 동작을 변경하는 것입니다. PostgreSQL은이를 허용하지 않지만 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 위반하는 도메인 유형의 저장된 값이 있는지 알 수 없습니다 . 이로 인해 후속 데이터베이스 덤프 및 재로드가 실패합니다. 이러한 변경을 처리하기 위해 권장되는 방법은 &lt;code&gt;ALTER DOMAIN&lt;/code&gt; 을 사용하여 제한 조건을 삭제 하고 함수 정의를 조정 한 후 제한 조건을 다시 추가하여 저장된 데이터와 비교하여 다시 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f4d8042a8aacf4dd946a6de3a479fedbae68b9bb" translate="yes" xml:space="preserve">
          <source>An example of an ordered-set aggregate call is:</source>
          <target state="translated">순서 집합 집계 호출의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b9fd9076643bacdf456e68d66e8b722bd4cc414" translate="yes" xml:space="preserve">
          <source>An example of the problem situation is an administrator on the primary server running &lt;code&gt;DROP TABLE&lt;/code&gt; on a table that is currently being queried on the standby server. Clearly the standby query cannot continue if the &lt;code&gt;DROP TABLE&lt;/code&gt; is applied on the standby. If this situation occurred on the primary, the &lt;code&gt;DROP TABLE&lt;/code&gt; would wait until the other query had finished. But when &lt;code&gt;DROP TABLE&lt;/code&gt; is run on the primary, the primary doesn't have information about what queries are running on the standby, so it will not wait for any such standby queries. The WAL change records come through to the standby while the standby query is still running, causing a conflict. The standby server must either delay application of the WAL records (and everything after them, too) or else cancel the conflicting query so that the &lt;code&gt;DROP TABLE&lt;/code&gt; can be applied.</source>
          <target state="translated">문제점 상황의 예로 는 현재 대기 서버에서 조회중인 테이블 에서 &lt;code&gt;DROP TABLE&lt;/code&gt; 을 실행하는 기본 서버의 관리자 가 있습니다. &lt;code&gt;DROP TABLE&lt;/code&gt; 이 대기에 적용된 경우 대기 쿼리를 계속 진행할 수 없습니다 . 이 상황이 기본에서 발생한 경우 &lt;code&gt;DROP TABLE&lt;/code&gt; 은 다른 쿼리가 완료 될 때까지 기다립니다. 그러나 &lt;code&gt;DROP TABLE&lt;/code&gt; 기본에서 실행되며 기본에는 대기에서 실행중인 쿼리에 대한 정보가 없으므로 이러한 대기 쿼리를 기다리지 않습니다. 대기 쿼리가 계속 실행되는 동안 WAL 변경 레코드가 대기로 전달되어 충돌이 발생합니다. 대기 서버는 WAL 레코드의 적용을 지연 시키거나 그 이후의 모든 항목을 지연 시키거나 충돌 쿼리를 취소하여 &lt;code&gt;DROP TABLE&lt;/code&gt; 을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0584ea6554a34671913f19351974da1f1774aa3" translate="yes" xml:space="preserve">
          <source>An example of what this means:</source>
          <target state="translated">이것이 의미하는 예 :</target>
        </trans-unit>
        <trans-unit id="24ac5f040ccbfd7714847e1bf2aa5f6494899ae9" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; could be undesirable is</source>
          <target state="translated">예 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 바람직하지 않다 수</target>
        </trans-unit>
        <trans-unit id="17447c2100c81f31ba62252077dc9a9361cd71f9" translate="yes" xml:space="preserve">
          <source>An example with one unspecified argument:</source>
          <target state="translated">하나의 지정되지 않은 인수가있는 예 :</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="79f0ca45e1236a1cb1c9feb4290eadf0487b4ef6" translate="yes" xml:space="preserve">
          <source>An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">단, 신호 (데이터베이스 서버 종료의 일부로 사용되는 SIGTERM 이외) 또는 쉘 오류 (예 : 명령을 찾을 수 없음)로 명령이 종료 된 경우 복구가 중단되고 서버가 중단됩니다. 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcd7932740e5471bcd0a087d5b26ec1edd628fbb" translate="yes" xml:space="preserve">
          <source>An explicit attribute name need not be specified if the attribute value is a column reference, in which case the column's name will be used as the attribute name by default. In other cases, the attribute must be given an explicit name. So this example is valid:</source>
          <target state="translated">속성 값이 열 참조 인 경우 명시 적 속성 이름을 지정할 필요가 없습니다.이 경우 열 이름이 기본적으로 속성 이름으로 사용됩니다. 다른 경우에는 속성에 명시적인 이름을 지정해야합니다. 따라서이 예제는 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="a0537d02ca5df21a5cff0228c3c1f8c6cfa4f59b" translate="yes" xml:space="preserve">
          <source>An explicit type cast can usually be omitted if there is no ambiguity as to the type that a value expression must produce (for example, when it is assigned to a table column); the system will automatically apply a type cast in such cases. However, automatic casting is only done for casts that are marked &amp;ldquo;OK to apply implicitly&amp;rdquo; in the system catalogs. Other casts must be invoked with explicit casting syntax. This restriction is intended to prevent surprising conversions from being applied silently.</source>
          <target state="translated">값 표현식이 생성해야하는 유형 (예 : 테이블 열에 지정된 경우)에 대한 모호성이없는 경우 명시 적 유형 캐스트는 일반적으로 생략 할 수 있습니다. 이 경우 시스템은 자동으로 유형 캐스트를 적용합니다. 그러나 자동 캐스트는 시스템 카탈로그에서 &quot;암시 적으로 적용 가능&quot;으로 표시된 캐스트에 대해서만 수행됩니다. 다른 캐스트는 명시 적 캐스트 구문으로 호출해야합니다. 이 제한은 놀라운 전환이 자동으로 적용되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8eb162f28e2597cd06bef15cc6b421aa23ae9738" translate="yes" xml:space="preserve">
          <source>An expression based on one or more columns of the table. The expression usually must be written with surrounding parentheses, as shown in the syntax. However, the parentheses can be omitted if the expression has the form of a function call.</source>
          <target state="translated">테이블의 하나 이상의 열을 기반으로하는 표현식입니다. 표현식은 일반적으로 구문에 표시된대로 괄호로 묶어야합니다. 그러나 식에 함수 호출 형식이 있으면 괄호를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfb3ba678ed8043b837cdccde74a8dfa30c47a0d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">결과 행을 정렬하는 방법을 나타내는 표현식 또는 정수 상수. 이 표현식은 &lt;code&gt;VALUES&lt;/code&gt; 결과 의 열을 &lt;code&gt;column1&lt;/code&gt; , &lt;code&gt;column2&lt;/code&gt; 등 으로 참조 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f105d127b4d4c78a65c31c4341d9a688ca047d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="translated">결과 행을 정렬하는 방법을 나타내는 표현식 또는 정수 상수입니다. 이 표현식은 &lt;code&gt;VALUES&lt;/code&gt; 결과 의 열을 &lt;code&gt;column1&lt;/code&gt; , &lt;code&gt;column2&lt;/code&gt; 등 으로 참조 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 문서 의 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY 절&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf2a060cd8aff34f17e0e2630c016f3f2cecf035" translate="yes" xml:space="preserve">
          <source>An expression or value to assign to the corresponding column.</source>
          <target state="translated">해당 열에 할당 할 표현식 또는 값입니다.</target>
        </trans-unit>
        <trans-unit id="346258a0cd22cd6472088d2210ee4c5f296cc7a7" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be deleted.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형의 값을 리턴하는 표현식입니다 . 이 표현식이 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 행만 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3b5a1cfe641c92cec7cffaf0f485f58266a8e8c9" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated, although all rows will be locked when the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; action is taken. Note that &lt;code&gt;condition&lt;/code&gt; is evaluated last, after a conflict has been identified as a candidate to update.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형의 값을 리턴하는 표현식입니다 . &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 조치가 수행 될 때 모든 행이 잠기는하지만 이 표현식이 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 행만 갱신됩니다 . 참고 &lt;code&gt;condition&lt;/code&gt; 충돌이 갱신에 후보로 식별 한 후, 마지막으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="51d351d5b4985c09126cf102d05f81d64ae9d961" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형의 값을 리턴하는 표현식입니다 . 이 표현식이 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 행만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6469ea06c0d7a0f1185226a5a8416487a9a270db" translate="yes" xml:space="preserve">
          <source>An expression to assign to the column. The expression can use the old values of this and other columns in the table.</source>
          <target state="translated">열에 할당 할 표현식입니다. 표현식은 테이블에서이 열과 다른 열의 이전 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8157c1c94fdd707dcc3e7f541c66bda5c99059b6" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;DELETE&lt;/code&gt; command after each row is deleted. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;USING&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">각 행이 삭제 된 후 &lt;code&gt;DELETE&lt;/code&gt; 명령에 의해 계산되고 리턴되는 표현식 입니다. 표현식은 &lt;code&gt;table_name&lt;/code&gt; 또는 &lt;code&gt;USING&lt;/code&gt; 에 나열된 테이블로 명명 된 테이블의 모든 열 이름을 사용할 수 있습니다 . 모든 열을 반환하려면 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="05948f44935d2d1795c3b150edf4c95d54d4a6f0" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;INSERT&lt;/code&gt; command after each row is inserted or updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns of the inserted or updated row(s).</source>
          <target state="translated">각 행을 삽입하거나 업데이트 한 후 &lt;code&gt;INSERT&lt;/code&gt; 명령 으로 계산하고 반환 할 식 입니다. 표현식은 &lt;code&gt;table_name&lt;/code&gt; 으로 명명 된 테이블의 모든 열 이름을 사용할 수 있습니다 . 삽입되거나 업데이트 된 행의 모든 ​​열을 반환하려면 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="711a38c8f40969b059c836aa598a46d28bd6408a" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;UPDATE&lt;/code&gt; command after each row is updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;FROM&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">각 행이 업데이트 된 후 &lt;code&gt;UPDATE&lt;/code&gt; 명령에 의해 계산되고 리턴되는 표현식 입니다. 표현식은 &lt;code&gt;table_name&lt;/code&gt; 또는 &lt;code&gt;FROM&lt;/code&gt; 에 나열된 테이블로 명명 된 테이블의 모든 열 이름을 사용할 수 있습니다 . 모든 열을 반환하려면 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="1a2196f96cc62fad9b61f7b17e09f3003661a8d1" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">매개 변수가 지정되지 않은 경우 기본값으로 사용될 표현식입니다. 표현식은 매개 변수의 인수 유형에 강제적이어야합니다. 기본값이있는 매개 변수 뒤에 오는 모든 입력 매개 변수에도 기본값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="33129ed19c1151cbd1e641d74c28498304306825" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. Only input (including &lt;code&gt;INOUT&lt;/code&gt;) parameters can have a default value. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">매개 변수가 지정되지 않은 경우 기본값으로 사용될 표현식입니다. 표현식은 매개 변수의 인수 유형에 강제적이어야합니다. 입력 ( &lt;code&gt;INOUT&lt;/code&gt; 포함 ) 매개 변수 만 기본값을 가질 수 있습니다. 기본값이있는 매개 변수 뒤에 오는 모든 입력 매개 변수에도 기본값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e3cc897e9290dc3056730f190eeba85a57f89dca" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="translated">외부 프로그램은 &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; 함수 ( &lt;a href=&quot;functions-admin&quot;&gt;섹션 9.26&lt;/a&gt; 참조 )를 호출하여 파일 이름과 WAL의 현재 끝에서 정확한 바이트 오프셋을 찾을 수 있습니다. 그런 다음 WAL 파일에 직접 액세스하여 WAL의 마지막 알려진 끝에서 현재 끝을 통해 대기 서버로 데이터를 복사 할 수 있습니다. 이 방법을 사용하면 데이터 손실의 창은 복사 프로그램의 폴링주기 시간으로 매우 작을 수 있으며 부분적으로 사용되는 세그먼트 파일을 강제로 저장하는 데 낭비되는 대역폭이 없습니다. 대기 서버의 &lt;code&gt;restore_command&lt;/code&gt; 스크립트는 전체 WAL 파일 만 처리 할 수 ​​있으므로 증분 복사 된 데이터는 일반적으로 대기 서버에서 사용할 수 없습니다. 1 차 다이가 종료 된 경우에만 사용되며 마지막 부분 WAL 파일은 대기 상태가되며 대기합니다. 이 프로세스를 올바르게 구현하려면 데이터 복사 프로그램과 &lt;code&gt;restore_command&lt;/code&gt; 스크립트의 협력이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e349b01fb7be05aa32f87d20348ac32cf9165b0a" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="translated">외부 프로그램은 &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; 함수 ( &lt;a href=&quot;functions-admin&quot;&gt;9.27 절&lt;/a&gt; 참조 )를 호출 하여 현재 WAL 끝의 파일 이름과 그 안에있는 정확한 바이트 오프셋을 찾을 수 있습니다. 그런 다음 WAL 파일에 직접 액세스하고 WAL의 마지막으로 알려진 끝에서 현재 끝까지의 데이터를 대기 서버로 복사 할 수 있습니다. 이 접근 방식을 사용하면 데이터 손실 창은 복사 프로그램의 폴링주기 시간입니다.이 시간은 매우 작을 수 있으며 부분적으로 사용 된 세그먼트 파일을 아카이브해야하는데 낭비되는 대역폭이 없습니다. 대기 서버의 &lt;code&gt;restore_command&lt;/code&gt; 스크립트는 전체 WAL 파일 만 처리 할 수 ​​있으므로 증분 복사 된 데이터는 일반적으로 대기 서버에서 사용할 수 없습니다. 기본이 죽을 때만 사용됩니다. 마지막 부분 WAL 파일이 대기 상태로 공급되기 전에 대기합니다. 이 프로세스를 올바르게 구현하려면 데이터 복사 프로그램과 &lt;code&gt;restore_command&lt;/code&gt; 스크립트의 협력이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="94b6e6917365cf5b071c6d2030b18320b138edde" translate="yes" xml:space="preserve">
          <source>An immediate-mode shutdown is equivalent to a server crash, and will therefore cause loss of any unflushed asynchronous commits.</source>
          <target state="translated">즉시 모드 종료는 서버 충돌과 동일하므로 플러시되지 않은 비동기 커밋이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="40eea77fc7125e69a1e10d852d75c5913c0b8a4f" translate="yes" xml:space="preserve">
          <source>An important advantage of pg_dump over the other backup methods described later is that pg_dump's output can generally be re-loaded into newer versions of PostgreSQL, whereas file-level backups and continuous archiving are both extremely server-version-specific. pg_dump is also the only method that will work when transferring a database to a different machine architecture, such as going from a 32-bit to a 64-bit server.</source>
          <target state="translated">나중에 설명 할 다른 백업 방법에 비해 pg_dump의 중요한 장점은 pg_dump의 출력을 일반적으로 최신 버전의 PostgreSQL로 다시로드 할 수 있다는 점입니다. 반면 파일 수준 백업과 지속적인 아카이빙은 서버 버전에 따라 다릅니다. pg_dump는 또한 데이터베이스를 32 비트에서 64 비트 서버로 전환하는 등 다른 머신 아키텍처로 데이터베이스를 전송할 때 작동하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="779e5fbc91351efe2bbe3fc71a519dfce1b2cb29" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="translated">스트리밍 복제의 중요한 상태 표시기는 기본에서는 생성되었지만 아직 대기에는 적용되지 않은 WAL 레코드의 양입니다. 기본의 현재 WAL 쓰기 위치와 대기에서 수신 한 마지막 WAL 위치를 비교하여이 지연을 계산할 수 있습니다. 이 위치는 기본에서 &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; 및 대기에서 각각 &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; 을 사용하여 검색 할 수 있습니다 (자세한 내용은 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;표 9.84&lt;/a&gt; 및 &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;표 9.85&lt;/a&gt; 참조). 대기의 마지막 WAL 수신 위치도 &lt;code&gt;ps&lt;/code&gt; 명령을 사용하여 표시되는 WAL 수신자 프로세스의 프로세스 상태에 표시됩니다 (자세한 내용 &lt;a href=&quot;monitoring-ps&quot;&gt;은 27.1 절&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="5e354ee44c574fe1a74c62c071de207a2e99bd9d" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="translated">스트리밍 복제의 중요한 상태 표시기는 기본에서 생성되었지만 아직 대기에서 적용되지 않은 WAL 레코드의 양입니다. 기본의 현재 WAL 쓰기 위치를 대기에서 수신 한 마지막 WAL 위치와 비교하여이 지연을 계산할 수 있습니다. 이러한 위치는 기본에서 &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; 을 사용 하고 대기에서 각각 &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; 을 사용하여 검색 할 수 있습니다 (자세한 내용은 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;표 9.85&lt;/a&gt; 및 &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;표 9.86&lt;/a&gt; 참조). 대기의 마지막 WAL 수신 위치는 &lt;code&gt;ps&lt;/code&gt; 명령을 사용하여 표시되는 WAL 수신자 프로세스의 프로세스 상태에도 표시됩니다 (자세한 내용은 &lt;a href=&quot;monitoring-ps&quot;&gt;섹션 27.1&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="8738ccf906ae7704aa616ed666eef87dd66384c2" translate="yes" xml:space="preserve">
          <source>An important restriction, however, is that each database's character set must be compatible with the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; (character classification) and &lt;code&gt;LC_COLLATE&lt;/code&gt; (string sort order) locale settings. For &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; locale, any character set is allowed, but for other libc-provided locales there is only one character set that will work correctly. (On Windows, however, UTF-8 encoding can be used with any locale.) If you have ICU support configured, ICU-provided locales can be used with most but not all server-side encodings.</source>
          <target state="translated">그러나 중요한 제한 사항은 각 데이터베이스의 문자 집합이 데이터베이스의 &lt;code&gt;LC_CTYPE&lt;/code&gt; (문자 분류) 및 &lt;code&gt;LC_COLLATE&lt;/code&gt; (문자열 정렬 순서) 로캘 설정 과 호환되어야한다는 것 입니다. 들어 &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;POSIX&lt;/code&gt; 로케일, 어떤 문자 세트가 허용되지만 다른 libc의 제공 로케일에 대해 제대로 작동 하나의 문자 집합이 있습니다. 그러나 Windows에서는 UTF-8 인코딩을 모든 로캘과 함께 사용할 수 있습니다. ICU 지원을 구성한 경우 ICU 제공 로캘을 대부분의 서버 측 인코딩과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5ae435c6587408d50bbebe9d66abc0ceb67394" translate="yes" xml:space="preserve">
          <source>An index access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;index_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a palloc'd struct of type &lt;code&gt;IndexAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the index access method. The &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, includes fields specifying assorted fixed properties of the access method, such as whether it can support multicolumn indexes. More importantly, it contains pointers to support functions for the access method, which do all of the real work to access indexes. These support functions are plain C functions and are not visible or callable at the SQL level. The support functions are described in &lt;a href=&quot;index-functions&quot;&gt;Section 61.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 유형의 단일 인수를 승인 하고 의사 유형 &lt;code&gt;index_am_handler&lt;/code&gt; 를 리턴하려면 색인 액세스 메소드 핸들러 함수를 선언해야합니다 . 인수는 단순히 핸들러 함수가 SQL 명령에서 직접 호출되지 않도록하는 더미 값입니다. 함수의 결과는 유형의 palloc 한 구조체해야 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 핵심 코드 요구 인덱스 액세스 방법을 사용하기 위해 알아야 할 모든 것이 포함되어 있습니다. &lt;code&gt;IndexAmRoutine&lt;/code&gt; 의 구조체, 또한 액세스 메소드의 호출 &lt;em&gt;API 구조체&lt;/em&gt;은 여러 열 인덱스를 지원할 수 있는지 여부와 같은 액세스 방법의 여러 고정 속성을 지정하는 필드를 포함합니다. 더 중요한 것은 인덱스에 액세스하는 모든 실제 작업을 수행하는 액세스 방법에 대한 기능을 지원하는 포인터가 포함되어 있습니다. 이 지원 함수는 일반 C 함수이며 SQL 레벨에서 보거나 호출 할 수 없습니다. 지원 기능은 &lt;a href=&quot;index-functions&quot;&gt;61.2 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb532d7978fa5df32b453f561220dfbe06086e40" translate="yes" xml:space="preserve">
          <source>An index access method handler is declared to return &lt;code&gt;index_am_handler&lt;/code&gt;.</source>
          <target state="translated">인덱스 액세스 메소드 핸들러는 &lt;code&gt;index_am_handler&lt;/code&gt; 를 리턴 하도록 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b07d3910aeda52b29f538101381247d79d370d4" translate="yes" xml:space="preserve">
          <source>An index can be defined on more than one column of a table. For example, if you have a table of this form:</source>
          <target state="translated">인덱스는 테이블의 둘 이상의 열에 정의 될 수 있습니다. 예를 들어,이 형식의 테이블이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="c6cedebd8f5962a85979ac8b01f76ed8117fa855" translate="yes" xml:space="preserve">
          <source>An index can support only one collation per index column. If multiple collations are of interest, multiple indexes may be needed.</source>
          <target state="translated">인덱스는 인덱스 열당 하나의 데이터 정렬 만 지원할 수 있습니다. 여러 데이터 정렬이 필요한 경우 여러 인덱스가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af32b6cb0c87ebb15770ca088fe87a22f82c7725" translate="yes" xml:space="preserve">
          <source>An index column need not be just a column of the underlying table, but can be a function or scalar expression computed from one or more columns of the table. This feature is useful to obtain fast access to tables based on the results of computations.</source>
          <target state="translated">인덱스 열은 기본 테이블의 열일 필요는 없지만 테이블의 하나 이상의 열에서 계산 된 함수 또는 스칼라 식일 수 있습니다. 이 기능은 계산 결과를 기반으로 테이블에 빠르게 액세스하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="38f15f32a54b60a4d97bf16f8c60ceef26c5914e" translate="yes" xml:space="preserve">
          <source>An index definition can specify an &lt;em&gt;operator class&lt;/em&gt; for each column of an index.</source>
          <target state="translated">인덱스 정의는 인덱스의 각 열에 대해 &lt;em&gt;연산자 클래스&lt;/em&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ef2323f17ff30aac9494d8039a3c3612271c42a" translate="yes" xml:space="preserve">
          <source>An index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed on &lt;code&gt;upper(col)&lt;/code&gt; would allow the clause &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; to use an index.</source>
          <target state="translated">인덱스 필드는 테이블 행의 하나 이상의 열 값에서 계산 된 표현식 일 수 있습니다. 이 기능을 사용하면 기본 데이터의 일부 변환을 기반으로 데이터에 빠르게 액세스 할 수 있습니다. 예를 들어, &lt;code&gt;upper(col)&lt;/code&gt; 에서 계산 된 인덱스 는 &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; 절이 인덱스를 사용 하도록 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="3aeae44b3c790fd037b93e2535adf3aedad79c0a" translate="yes" xml:space="preserve">
          <source>An index has become &amp;ldquo;bloated&amp;rdquo;, that is it contains many empty or nearly-empty pages. This can occur with B-tree indexes in PostgreSQL under certain uncommon access patterns. &lt;code&gt;REINDEX&lt;/code&gt; provides a way to reduce the space consumption of the index by writing a new version of the index without the dead pages. See &lt;a href=&quot;routine-reindex&quot;&gt;Section 24.2&lt;/a&gt; for more information.</source>
          <target state="translated">색인이 &quot;부풀어졌습니다&quot;, 즉 비어 있거나 거의 비어있는 페이지가 많이 있습니다. 이는 특정 드문 액세스 패턴으로 PostgreSQL의 B- 트리 인덱스에서 발생할 수 있습니다. &lt;code&gt;REINDEX&lt;/code&gt; 는 데드 페이지없이 새 버전의 인덱스를 작성하여 인덱스의 공간 소비를 줄이는 방법을 제공합니다. 자세한 정보는 &lt;a href=&quot;routine-reindex&quot;&gt;24.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="121b8423d6baa50b53be4c3d49a8a3b7e064ae7d" translate="yes" xml:space="preserve">
          <source>An index has become corrupted, and no longer contains valid data. Although in theory this should never happen, in practice indexes can become corrupted due to software bugs or hardware failures. &lt;code&gt;REINDEX&lt;/code&gt; provides a recovery method.</source>
          <target state="translated">색인이 손상되었으며 더 이상 유효한 데이터가 없습니다. 이론 상으로는 이런 일이 발생하지 않아야하지만 실제로 소프트웨어 버그 나 하드웨어 오류로 인해 색인이 손상 될 수 있습니다. &lt;code&gt;REINDEX&lt;/code&gt; 는 복구 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd114c1d6538ba92c251db5881779687c2ba09a7" translate="yes" xml:space="preserve">
          <source>An index scan must maintain a pin on the index page holding the item last returned by &lt;code&gt;amgettuple&lt;/code&gt;, and &lt;code&gt;ambulkdelete&lt;/code&gt; cannot delete entries from pages that are pinned by other backends. The need for this rule is explained below.</source>
          <target state="translated">인덱스 스캔은 마지막에 의해 반환 된 항목을 유지하는 인덱스 페이지에 핀 유지해야 &lt;code&gt;amgettuple&lt;/code&gt; 을 , 그리고 &lt;code&gt;ambulkdelete&lt;/code&gt; 는 다른 백엔드에 의해 페이지에서하지 삭제 항목이 고정되어있다 할 수 있습니다. 이 규칙의 필요성은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="091f10c301d94d87ecd9a27b3366c6d6b064df7e" translate="yes" xml:space="preserve">
          <source>An index stored in ascending order with nulls first can satisfy either &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; or &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; depending on which direction it is scanned in.</source>
          <target state="translated">널이 오름차순으로 저장된 색인은 먼저 스캔되는 방향에 따라 &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; 또는 &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; 를 만족시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b9a05a65dbb6edc07d784a35f9d93afabbd7c69" translate="yes" xml:space="preserve">
          <source>An individual index is defined by a &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt; entry that describes it as a physical relation, plus a &lt;a href=&quot;catalog-pg-index&quot;&gt;&lt;code&gt;pg_index&lt;/code&gt;&lt;/a&gt; entry that shows the logical content of the index &amp;mdash; that is, the set of index columns it has and the semantics of those columns, as captured by the associated operator classes. The index columns (key values) can be either simple columns of the underlying table or expressions over the table rows. The index access method normally has no interest in where the index key values come from (it is always handed precomputed key values) but it will be very interested in the operator class information in &lt;code&gt;pg_index&lt;/code&gt;. Both of these catalog entries can be accessed as part of the &lt;code&gt;Relation&lt;/code&gt; data structure that is passed to all operations on the index.</source>
          <target state="translated">개별 색인은 색인을 물리적 관계로 설명 하는 &lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt; 항목과 색인의 논리적 내용 (즉, 색인 열 세트 및 해당 열의 의미)을 표시 하는 &lt;a href=&quot;catalog-pg-index&quot;&gt; &lt;code&gt;pg_index&lt;/code&gt; &lt;/a&gt; 항목으로 정의됩니다. 관련 연산자 클래스 인덱스 열 (키 값)은 기본 테이블의 간단한 열이거나 테이블 행에 대한 표현식 일 수 있습니다. 인덱스 액세스 방법은 일반적으로 인덱스 키 값의 출처 (항상 사전 계산 된 키 값으로 &lt;code&gt;pg_index&lt;/code&gt; 관심이 없지만 pg_index 의 연산자 클래스 정보에 매우 관심이 있습니다 . 이러한 카탈로그 항목 모두 &lt;code&gt;Relation&lt;/code&gt; 일부로 액세스 할 수 있습니다. 인덱스의 모든 작업에 전달되는 데이터 구조</target>
        </trans-unit>
        <trans-unit id="c51c50438ea0481d3519a43885b20aa32e128cb3" translate="yes" xml:space="preserve">
          <source>An input argument for the procedure call. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for the full details on function and procedure call syntax, including use of named parameters.</source>
          <target state="translated">프로 시저 호출의 입력 인수입니다. 명명 된 매개 변수 사용을 포함한 함수 및 프로 시저 호출 구문에 대한 자세한 내용 &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;은 4.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="73ddb8fe436cada6d2cfbe35b934979d06f7b361" translate="yes" xml:space="preserve">
          <source>An input data type on which the aggregate function operates. To reference a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. To reference an ordered-set aggregate function, write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications.</source>
          <target state="translated">집계 함수가 작동하는 입력 데이터 유형입니다. 인수가 0 인 집계 함수를 참조하려면 인수 스펙 목록 대신 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 . 정렬 된 집합 집계 함수를 참조하려면 직접 인수 집계 집계 사양 사이에 &lt;code&gt;ORDER BY&lt;/code&gt; 를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8a9fa698ac8ae654cf211647b74f7c8723ee0347" translate="yes" xml:space="preserve">
          <source>An input data type on which this aggregate function operates. To create a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. (An example of such an aggregate is &lt;code&gt;count(*)&lt;/code&gt;.)</source>
          <target state="translated">이 집계 함수가 작동하는 입력 데이터 유형입니다. 인수가없는 집계 함수를 작성하려면 인수 스펙 목록 대신 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 . (이러한 집계의 예는 &lt;code&gt;count(*)&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="2c437a292efa6b573c836047b51a1cf9f32df694" translate="yes" xml:space="preserve">
          <source>An introduction to the btree index implementation can be found in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt;.</source>
          <target state="translated">btree 인덱스 구현에 대한 소개는 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43d220b2360555baed12a7c95e72685b6f39b9dd" translate="yes" xml:space="preserve">
          <source>An n-dimensional cube represented by a pair of its diagonally opposite corners</source>
          <target state="translated">대각선으로 마주 보는 모서리 쌍으로 표현되는 n 차원 큐브</target>
        </trans-unit>
        <trans-unit id="49b0e219e8853ca29533ecae37f9efd990522911" translate="yes" xml:space="preserve">
          <source>An object can be assigned to a new owner with an &lt;code&gt;ALTER&lt;/code&gt; command of the appropriate kind for the object, for example</source>
          <target state="translated">예를 들어 객체에 적절한 종류 의 &lt;code&gt;ALTER&lt;/code&gt; 명령을 사용하여 객체를 새 소유자에게 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="261a27538e7f1d6cc0124e706ea14d5684e6fe5c" translate="yes" xml:space="preserve">
          <source>An object's owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others. But owners are always treated as holding all grant options, so they can always re-grant their own privileges.</source>
          <target state="translated">객체의 소유자는 자신의 일반 권한을 취소하도록 선택할 수 있습니다. 예를 들어 테이블을 자신과 다른 사람에 대해 읽기 전용으로 만들 수 있습니다. 그러나 소유자는 항상 모든 부여 옵션을 보유한 것으로 취급되므로 언제든지 자신의 권한을 다시 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd7347c4e72d5111690a2e6b553a4bb95eecefbe" translate="yes" xml:space="preserve">
          <source>An obsolete type name that formerly served many of the above purposes.</source>
          <target state="translated">이전의 많은 목적을 위해 사용되었던 더 이상 사용되지 않는 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e67e0cc488404bddd9185d257d8376a78bb5f89d" translate="yes" xml:space="preserve">
          <source>An older syntax based on &quot;:=&quot; is supported for backward compatibility:</source>
          <target state="translated">&quot;: =&quot;에 기반한 이전 구문은 이전 버전과의 호환성을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ec14d06c6e5e0d12a30237502776f169012b3d" translate="yes" xml:space="preserve">
          <source>An open cursor's name.</source>
          <target state="translated">열린 커서의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fdaf617bcf458038608559aa52135b2d0fb280c4" translate="yes" xml:space="preserve">
          <source>An operation and SQL keyword used in &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt; for combining data from multiple &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt;.</source>
          <target state="translated">여러 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계의&lt;/a&gt; 데이터를 결합하기위한 &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;쿼리&lt;/a&gt; 에 사용되는 연산 및 SQL 키워드 입니다.</target>
        </trans-unit>
        <trans-unit id="907b1845a90ba08c2bd64d8aae44246179e07fc0" translate="yes" xml:space="preserve">
          <source>An operator class for BRIN can optionally specify the following method:</source>
          <target state="translated">BRIN의 연산자 클래스는 선택적으로 다음 메소드를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a82dcbae2eb28872acc9a82bc62d7f28fc52dc06" translate="yes" xml:space="preserve">
          <source>An operator class for GIN can optionally supply the following methods:</source>
          <target state="translated">GIN의 연산자 클래스는 선택적으로 다음 메소드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d15480825e451d724a77515f8cbd596240aa64" translate="yes" xml:space="preserve">
          <source>An operator class for bloom indexes requires only a hash function for the indexed data type and an equality operator for searching. This example shows the operator class definition for the &lt;code&gt;text&lt;/code&gt; data type:</source>
          <target state="translated">bloom 인덱스의 연산자 클래스는 인덱스 데이터 유형에 대한 해시 함수와 검색을위한 등호 연산자 만 필요합니다. 이 예는 &lt;code&gt;text&lt;/code&gt; 데이터 유형에 대한 연산자 클래스 정의를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6eb7653b3723c58c344a731c25071cc3711f5e86" translate="yes" xml:space="preserve">
          <source>An operator class is actually just a subset of a larger structure called an &lt;em&gt;operator family&lt;/em&gt;. In cases where several data types have similar behaviors, it is frequently useful to define cross-data-type operators and allow these to work with indexes. To do this, the operator classes for each of the types must be grouped into the same operator family. The cross-type operators are members of the family, but are not associated with any single class within the family.</source>
          <target state="translated">연산자 클래스는 실제로 &lt;em&gt;연산자 패밀리&lt;/em&gt; 라고하는 더 큰 구조의 하위 집합 &lt;em&gt;입니다&lt;/em&gt; . 여러 데이터 유형이 유사한 동작을 갖는 경우 교차 데이터 유형 연산자를 정의하고 인덱스와 함께 작동하도록하는 것이 종종 유용합니다. 이렇게하려면 각 유형에 대한 연산자 클래스를 동일한 연산자 제품군으로 그룹화해야합니다. 교차 유형 연산자는 패밀리의 구성원이지만 패밀리 내의 단일 클래스와 연관되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7d235f30c792ff196a94c50c4549a98a2d7a764" translate="yes" xml:space="preserve">
          <source>An operator class must also provide a function to check if an indexed item matches the query. It comes in two flavors, a Boolean &lt;code&gt;consistent&lt;/code&gt; function, and a ternary &lt;code&gt;triConsistent&lt;/code&gt; function. &lt;code&gt;triConsistent&lt;/code&gt; covers the functionality of both, so providing &lt;code&gt;triConsistent&lt;/code&gt; alone is sufficient. However, if the Boolean variant is significantly cheaper to calculate, it can be advantageous to provide both. If only the Boolean variant is provided, some optimizations that depend on refuting index items before fetching all the keys are disabled.</source>
          <target state="translated">또한 연산자 클래스는 인덱스 된 항목이 쿼리와 일치하는지 확인하는 함수를 제공해야합니다. 그것은 두 가지 종류, 부울로 제공 &lt;code&gt;consistent&lt;/code&gt; 기능, 원계 &lt;code&gt;triConsistent&lt;/code&gt; 의 기능. &lt;code&gt;triConsistent&lt;/code&gt; 는 두 기능을 모두 &lt;code&gt;triConsistent&lt;/code&gt; 므로 triConsistent 만 제공 하면 충분합니다. 그러나 부울 변형이 계산 비용이 상당히 저렴하면 둘 다 제공하는 것이 유리할 수 있습니다. 부울 변형 만 제공되는 경우 모든 키를 가져 오기 전에 반품 인덱스 항목에 의존하는 일부 최적화가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6e523c5f9d2c574da0fb6483337cb467c258e68f" translate="yes" xml:space="preserve">
          <source>An operator class's &lt;code&gt;opcmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family. Also, there must be no more than one &lt;code&gt;pg_opclass&lt;/code&gt; row having &lt;code&gt;opcdefault&lt;/code&gt; true for any given combination of &lt;code&gt;opcmethod&lt;/code&gt; and &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">연산자 클래스의 &lt;code&gt;opcmethod&lt;/code&gt; 는 일치해야한다 &lt;code&gt;opfmethod&lt;/code&gt; 의 포함 작업자의 가족을. 또한, 더 이상이 없어야합니다 &lt;code&gt;pg_opclass&lt;/code&gt; 을 가진 행 &lt;code&gt;opcdefault&lt;/code&gt; 의 특정 조합에 대한 진정한 &lt;code&gt;opcmethod&lt;/code&gt; 및 &lt;code&gt;opcintype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6550b54250a9ead01f2b3553646b2303a4a1ed" translate="yes" xml:space="preserve">
          <source>An operator invocation</source>
          <target state="translated">연산자 호출</target>
        </trans-unit>
        <trans-unit id="61b072351eb6c6fa27b9ae84a318cc236116df90" translate="yes" xml:space="preserve">
          <source>An operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">연산자 이름은 다음 목록에서 최대 &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1 (기본적으로 63) 문자입니다.</target>
        </trans-unit>
        <trans-unit id="d3a80b67bf09fd16cb2674622b6e5dcf9a0716b6" translate="yes" xml:space="preserve">
          <source>An operator used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot would show the &lt;code&gt;&amp;lt;&lt;/code&gt; operator that defines the sort order of the data.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 번째 &quot;슬롯&quot;에 저장된 통계를 도출하는 데 사용되는 연산자 . 예를 들어, 히스토그램 슬롯 에는 데이터의 정렬 순서를 정의하는 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="36745dfcd4a31015998a201702d690d18fcba0c2" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;+&lt;/code&gt; produces more details.</source>
          <target state="translated">선택적인 &lt;code&gt;+&lt;/code&gt; 는 자세한 내용을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="15280e346b927d3a2d54ca3d61b3ae948a862eb2" translate="yes" xml:space="preserve">
          <source>An optional collation for the domain. If no collation is specified, the underlying data type's default collation is used. The underlying type must be collatable if &lt;code&gt;COLLATE&lt;/code&gt; is specified.</source>
          <target state="translated">도메인에 대한 선택적 데이터 정렬입니다. 데이터 정렬을 지정하지 않으면 기본 데이터 형식의 기본 데이터 정렬이 사용됩니다. &lt;code&gt;COLLATE&lt;/code&gt; 가 지정된 경우 기본 유형은 축소 가능해야 합니다.</target>
        </trans-unit>
        <trans-unit id="60e65907bee0f7f6070fd34b3f416cb8bb6f6e36" translate="yes" xml:space="preserve">
          <source>An optional comma-separated list of arguments to be provided to the function when the trigger is executed. The arguments are literal string constants. Simple names and numeric constants can be written here, too, but they will all be converted to strings. Please check the description of the implementation language of the trigger function to find out how these arguments can be accessed within the function; it might be different from normal function arguments.</source>
          <target state="translated">트리거가 실행될 때 함수에 제공 할 선택적 쉼표로 구분 된 인수 목록입니다. 인수는 리터럴 문자열 상수입니다. 간단한 이름과 숫자 상수도 여기에 쓸 수 있지만 모두 문자열로 변환됩니다. 함수 내에서 이러한 인수에 액세스하는 방법을 찾으려면 트리거 함수의 구현 언어 설명을 확인하십시오. 일반 함수 인수와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4ca636c20fca55bda068decba0ca12e4c60f9d3" translate="yes" xml:space="preserve">
          <source>An optional list of columns to be copied. If no column list is specified, all columns of the table except generated columns will be copied.</source>
          <target state="translated">복사 할 선택적 열 목록입니다. 열 목록을 지정하지 않으면 생성 된 열을 제외한 테이블의 모든 열이 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="f37b6dea6bba7854fbb2a25222ccbd3742c1fd86" translate="yes" xml:space="preserve">
          <source>An optional list of names to be used for columns of the view. If not given, the column names are deduced from the query.</source>
          <target state="translated">보기의 열에 사용되는 선택적 이름 목록입니다. 지정하지 않으면 열 이름이 쿼리에서 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="a1745e8f3d8a818bb59434a30224b4bc70bd52ef" translate="yes" xml:space="preserve">
          <source>An optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names like &lt;code&gt;col must be positive&lt;/code&gt; can be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.</source>
          <target state="translated">열 또는 테이블 제약 조건의 선택적 이름입니다. 제한 조건을 위반하면 제한 조건 이름이 오류 메시지에 존재하므로 &lt;code&gt;col must be positive&lt;/code&gt; 과 같은 제한 조건 이름은 양수 여야하며 유용한 제한 조건 정보를 클라이언트 애플리케이션에 전달할 수 있습니다. 공백이 포함 된 제약 조건 이름을 지정하려면 큰 따옴표가 필요합니다. 제약 조건 이름을 지정하지 않으면 시스템에서 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f3ae3fadcc76fcc5b9297de7bc96718990dc996d" translate="yes" xml:space="preserve">
          <source>An optional name for a constraint. If not specified, the system generates a name.</source>
          <target state="translated">제약 조건의 선택적 이름입니다. 지정하지 않으면 시스템이 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bd6568613ce7c67d34419866e38138da4ce733d2" translate="yes" xml:space="preserve">
          <source>An output column's name can be used to refer to the column's value in &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;GROUP BY&lt;/code&gt; clauses, but not in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;HAVING&lt;/code&gt; clauses; there you must write out the expression instead.</source>
          <target state="translated">출력 컬럼의 이름은 &lt;code&gt;ORDER BY&lt;/code&gt; 및 &lt;code&gt;GROUP BY&lt;/code&gt; 절 에서 컬럼 값을 참조하는 데 사용될 수 있지만 &lt;code&gt;WHERE&lt;/code&gt; 또는 &lt;code&gt;HAVING&lt;/code&gt; 절 에서는 그렇지 않습니다 . 거기에서 대신 표현식을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b29ad290e8bd770fdebcb84bad7370f20ace4e23" translate="yes" xml:space="preserve">
          <source>Analogous statements with inverted conditions hold when &lt;code&gt;less&lt;/code&gt; = false.</source>
          <target state="translated">반전 된 조건이있는 유사한 명령문은 = 가 &lt;code&gt;less&lt;/code&gt; 때 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="602ef0777e13fcee9897969f97ef1e867cdf140e" translate="yes" xml:space="preserve">
          <source>Analogous to &lt;code&gt;ON DELETE&lt;/code&gt; there is also &lt;code&gt;ON UPDATE&lt;/code&gt; which is invoked when a referenced column is changed (updated). The possible actions are the same. In this case, &lt;code&gt;CASCADE&lt;/code&gt; means that the updated values of the referenced column(s) should be copied into the referencing row(s).</source>
          <target state="translated">&lt;code&gt;ON DELETE&lt;/code&gt; 와 유사하게 참조 열이 변경 (업데이트) 될 때 호출되는 &lt;code&gt;ON UPDATE&lt;/code&gt; 도 있습니다 . 가능한 조치는 동일합니다. 이 경우 &lt;code&gt;CASCADE&lt;/code&gt; 는 참조 된 열의 업데이트 된 값이 참조 행에 복사되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e26143bf38a350af73fba34493a3e7479767511" translate="yes" xml:space="preserve">
          <source>Analytic function</source>
          <target state="translated">분석 기능</target>
        </trans-unit>
        <trans-unit id="4f0e68d1e2fd04310f44d64aff40ca304bd44245" translate="yes" xml:space="preserve">
          <source>Analyze (operation)</source>
          <target state="translated">분석 (작업)</target>
        </trans-unit>
        <trans-unit id="5c83db21cadbb2756e96e53b9c14b7e7a2b514a6" translate="yes" xml:space="preserve">
          <source>Ancient distributions might not have the &lt;code&gt;sysctl&lt;/code&gt; program, but equivalent changes can be made by manipulating the &lt;code&gt;/proc&lt;/code&gt; file system:</source>
          <target state="translated">고대 배포판에는 &lt;code&gt;sysctl&lt;/code&gt; 프로그램 이 없을 수 있지만 &lt;code&gt;/proc&lt;/code&gt; 파일 시스템 을 조작하여 동등한 변경을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d93beb44d205136520d673b54b56936f6980aa2" translate="yes" xml:space="preserve">
          <source>And finally create the transform to connect them all together:</source>
          <target state="translated">마지막으로 변환을 만들어 서로 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="43c2b85844ed32a3fb79c6e1b9f3ea8d1ebdd551" translate="yes" xml:space="preserve">
          <source>And finally, most disk drives have caches. Some are write-through while some are write-back, and the same concerns about data loss exist for write-back drive caches as for disk controller caches. Consumer-grade IDE and SATA drives are particularly likely to have write-back caches that will not survive a power failure. Many solid-state drives (SSD) also have volatile write-back caches.</source>
          <target state="translated">마지막으로 대부분의 디스크 드라이브에는 캐시가 있습니다. 일부는 후기 입 (write-through)이고 일부는 후기 입 (write-back)이며, 데이터 손실에 대한 우려는 디스크 컨트롤러 캐시와 마찬가지로 후기 입 드라이브 캐시에도 동일하게 존재합니다. 소비자 급 IDE 및 SATA 드라이브는 특히 전원 장애시에도 지속되지 않는 후기 입 캐시가있을 가능성이 높습니다. 많은 SSD (Solid-State Drive)에도 휘발성 쓰기 저장 캐시가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5abe4b1cbcb838f669f793ea91def6b18bb7e30" translate="yes" xml:space="preserve">
          <source>And on the subscriber database:</source>
          <target state="translated">그리고 구독자 데이터베이스에서 :</target>
        </trans-unit>
        <trans-unit id="e24853104ecb700e47b83196c8cd650b56525c5b" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;.dict&lt;/code&gt; file has the following structure:</source>
          <target state="translated">그리고 &lt;code&gt;.dict&lt;/code&gt; 의 파일은 다음과 같은 구조를 가지고 :</target>
        </trans-unit>
        <trans-unit id="588ca16f318d70344d76b4537a5c7291a5cee916" translate="yes" xml:space="preserve">
          <source>And the matching code in the C module could then follow this skeleton:</source>
          <target state="translated">그리고 C 모듈의 일치하는 코드는 다음 골격을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="680044bb057f2caf79b08b39f3f6077a48b66315" translate="yes" xml:space="preserve">
          <source>And to get 2-D cubes ordered by the first coordinate of the upper right corner descending:</source>
          <target state="translated">오른쪽 위 모서리의 첫 번째 좌표에서 내림차순으로 2 차원 큐브를 정렬하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6871b449d2c079d96e59fe6f124b014ba15535f8" translate="yes" xml:space="preserve">
          <source>And we can specify subfields as targets for &lt;code&gt;INSERT&lt;/code&gt;, too:</source>
          <target state="translated">그리고 서브 필드를 &lt;code&gt;INSERT&lt;/code&gt; 의 대상으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a145997c5dd507c46627dcb8aa745e601bfd3eab" translate="yes" xml:space="preserve">
          <source>And, if the function is called with an argument of type &lt;code&gt;integer&lt;/code&gt;, the parser will try to convert that to &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">그리고 함수가 &lt;code&gt;integer&lt;/code&gt; 유형의 인수와 함께 호출 되면 파서는이를 &lt;code&gt;text&lt;/code&gt; 로 변환하려고 시도 합니다 .</target>
        </trans-unit>
        <trans-unit id="7848b33d4bfc790590d465569216a9f6ae690895" translate="yes" xml:space="preserve">
          <source>Anonymous allocations are allocations that have been made with &lt;code&gt;ShmemAlloc()&lt;/code&gt; directly, rather than via &lt;code&gt;ShmemInitStruct()&lt;/code&gt; or &lt;code&gt;ShmemInitHash()&lt;/code&gt;.</source>
          <target state="translated">익명 할당은 &lt;code&gt;ShmemInitStruct()&lt;/code&gt; 또는 &lt;code&gt;ShmemInitHash()&lt;/code&gt; 를 통하지 않고 &lt;code&gt;ShmemAlloc()&lt;/code&gt; 직접 할당 된 할당입니다 .</target>
        </trans-unit>
        <trans-unit id="20ab5b725ed73e7635d9823c37915d8903343a0f" translate="yes" xml:space="preserve">
          <source>Another alternative worth considering is to use &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers (see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;) in place of rules.</source>
          <target state="translated">고려해야 할 또 다른 대안 은 규칙 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거 ( &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 참조 )를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e823a73742793d80b913d4d208ddb3ca9056df81" translate="yes" xml:space="preserve">
          <source>Another approach is to create a separate &lt;code&gt;tsvector&lt;/code&gt; column to hold the output of &lt;code&gt;to_tsvector&lt;/code&gt;. To keep this column automatically up to date with its source data, use a stored generated column. This example is a concatenation of &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;, using &lt;code&gt;coalesce&lt;/code&gt; to ensure that one field will still be indexed when the other is &lt;code&gt;NULL&lt;/code&gt;:</source>
          <target state="translated">또 다른 접근법은 별도의 &lt;code&gt;tsvector&lt;/code&gt; 열 을 만들어 to_tsvector 의 출력을 유지하는 &lt;code&gt;to_tsvector&lt;/code&gt; 입니다. 소스 데이터를 사용하여이 열을 자동으로 최신 상태로 유지하려면 저장된 생성 열을 사용하십시오. 이 예제는 &lt;code&gt;title&lt;/code&gt; 과 &lt;code&gt;body&lt;/code&gt; 연결 한 것으로 , &lt;code&gt;coalesce&lt;/code&gt; 을 사용하여 한 필드가 다른 필드가 &lt;code&gt;NULL&lt;/code&gt; 일 때 색인을 생성하도록 합니다 .</target>
        </trans-unit>
        <trans-unit id="c88aeeb193209d03f36ea4052749971eef461a5a" translate="yes" xml:space="preserve">
          <source>Another approach to querying is to exploit containment, for example:</source>
          <target state="translated">쿼리에 대한 또 다른 접근 방식은 다음과 같이 포함을 이용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f6657768acd9084b11e644584f044a4fc45d8af" translate="yes" xml:space="preserve">
          <source>Another approach, which can be used with or without altering &lt;code&gt;vm.overcommit_memory&lt;/code&gt;, is to set the process-specific &lt;em&gt;OOM score adjustment&lt;/em&gt; value for the postmaster process to &lt;code&gt;-1000&lt;/code&gt;, thereby guaranteeing it will not be targeted by the OOM killer. The simplest way to do this is to execute</source>
          <target state="translated">&lt;code&gt;vm.overcommit_memory&lt;/code&gt; 를 변경하거나 사용하지 않고 사용할 수있는 또 다른 방법 은 포스트 마스터 프로세스 의 프로세스 별 &lt;em&gt;OOM 점수 조정&lt;/em&gt; 값을 &lt;code&gt;-1000&lt;/code&gt; 으로 설정하여 OOM 킬러가이를 대상으로하지 않도록하는 것입니다. 이를 수행하는 가장 간단한 방법은 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0157777d67f21431cd43979bf17bb15a2c6fa069" translate="yes" xml:space="preserve">
          <source>Another caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails. Also, if a failure does occur in the second scan, the &amp;ldquo;invalid&amp;rdquo; index continues to enforce its uniqueness constraint afterwards.</source>
          <target state="translated">고유 인덱스를 동시에 빌드 할 때의 또 다른 경고는 두 번째 테이블 스캔이 시작될 때 고유성 제한 조건이 다른 트랜잭션에 대해 이미 시행되고 있다는 것입니다. 즉, 인덱스를 사용할 수있게되기 전에 또는 인덱스 작성이 실패한 경우에도 다른 쿼리에서 제약 조건 위반이보고 될 수 있습니다. 또한 두 번째 스캔에서 오류가 발생하면 &quot;유효하지 않은&quot;인덱스는 계속해서 고유성 제한 조건을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="8366e5720bf81785c8af920367ca1956fa9f6126" translate="yes" xml:space="preserve">
          <source>Another common reason for copying &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt; is that new encoding and locale settings can be specified when copying &lt;code&gt;template0&lt;/code&gt;, whereas a copy of &lt;code&gt;template1&lt;/code&gt; must use the same settings it does. This is because &lt;code&gt;template1&lt;/code&gt; might contain encoding-specific or locale-specific data, while &lt;code&gt;template0&lt;/code&gt; is known not to.</source>
          <target state="translated">복사에 대한 또 다른 일반적인 이유 &lt;code&gt;template0&lt;/code&gt; 대신 &lt;code&gt;template1&lt;/code&gt; 를가 복사 할 때 새로운 인코딩 및 로케일 설정을 지정할 수 있다는 것입니다 &lt;code&gt;template0&lt;/code&gt; 를 사본 반면, &lt;code&gt;template1&lt;/code&gt; 를이 는 않습니다 동일한 설정을 사용해야합니다. 때문이다 &lt;code&gt;template1&lt;/code&gt; 를이 인코딩 특정 또는 로케일 고유의 데이터를 포함하는 반면, &lt;code&gt;template0&lt;/code&gt; 는 하지 않는 것으로 알려져있다.</target>
        </trans-unit>
        <trans-unit id="fbb209aa36c1a4990c8b7ddd6d829419598146fa" translate="yes" xml:space="preserve">
          <source>Another consideration is that a &lt;code&gt;setval&lt;/code&gt; executed on such a sequence will not be noticed by other sessions until they have used up any preallocated values they have cached.</source>
          <target state="translated">또 다른 고려는 점이다 &lt;code&gt;setval&lt;/code&gt; 에 그들이 캐시 한 모든 할당 된 값을 사용 할 때까지 이러한 시퀀스에서 실행이 다른 세션에 의해 발견되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dd197e47ceae278b1382e01aa4231fc834370d4" translate="yes" xml:space="preserve">
          <source>Another disadvantage of the rule approach is that there is no simple way to force an error if the set of rules doesn't cover the insertion date; the data will silently go into the master table instead.</source>
          <target state="translated">규칙 접근의 또 다른 단점은 규칙 집합이 삽입 날짜를 다루지 않는 경우 오류를 발생시키는 간단한 방법이 없다는 것입니다. 데이터가 자동으로 마스터 테이블로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b74b279225b01a4f9a49098a715c0c2cd2860bb8" translate="yes" xml:space="preserve">
          <source>Another effect of &lt;code&gt;RECURSIVE&lt;/code&gt; is that &lt;code&gt;WITH&lt;/code&gt; queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without &lt;code&gt;RECURSIVE&lt;/code&gt;, &lt;code&gt;WITH&lt;/code&gt; queries can only reference sibling &lt;code&gt;WITH&lt;/code&gt; queries that are earlier in the &lt;code&gt;WITH&lt;/code&gt; list.</source>
          <target state="translated">또 다른 효과 &lt;code&gt;RECURSIVE&lt;/code&gt; 는 것입니다 &lt;code&gt;WITH&lt;/code&gt; 쿼리가 나중에 목록에 또 다른 하나를 참조 할 수 있습니다 : 쿼리 정렬 할 필요는 없다. (단, 순환 참조 또는 상호 재귀 구현되지 않는다.)없이 &lt;code&gt;RECURSIVE&lt;/code&gt; , &lt;code&gt;WITH&lt;/code&gt; 쿼리 만 형제를 참조 할 수 &lt;code&gt;WITH&lt;/code&gt; 이전에 질의 &lt;code&gt;WITH&lt;/code&gt; 리스트.</target>
        </trans-unit>
        <trans-unit id="f949f8323c537df82042ad10748a3400dd5e3c94" translate="yes" xml:space="preserve">
          <source>Another example &amp;mdash; the PostgreSQL mailing list archives contained 910,989 unique words with 57,491,343 lexemes in 461,020 messages.</source>
          <target state="translated">또 다른 예 &amp;mdash; PostgreSQL 메일 링리스트 아카이브에는 461,020 개의 메시지에 57,491,343 개의 어휘와 함께 910,989 개의 고유 한 단어가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e840dc5efd9dcea852680d04861f5d19522482d9" translate="yes" xml:space="preserve">
          <source>Another example demonstrating these concepts is that all these queries mean the same thing:</source>
          <target state="translated">이러한 개념을 보여주는 또 다른 예는 이러한 모든 쿼리가 동일한 것을 의미한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="448793ead43f5a4696dde796c384f50ddecfec35" translate="yes" xml:space="preserve">
          <source>Another example with &lt;code&gt;--rate=100&lt;/code&gt; and &lt;code&gt;--latency-limit=5&lt;/code&gt; (note the additional &lt;code&gt;schedule_lag&lt;/code&gt; column):</source>
          <target state="translated">&lt;code&gt;--rate=100&lt;/code&gt; 및 &lt;code&gt;--latency-limit=5&lt;/code&gt; 의 다른 예 (추가 &lt;code&gt;schedule_lag&lt;/code&gt; 열 참조) :</target>
        </trans-unit>
        <trans-unit id="1eb54ef0acd3e1a10201fcaabd71c9780026708a" translate="yes" xml:space="preserve">
          <source>Another form of table aliasing gives temporary names to the columns of the table, as well as the table itself:</source>
          <target state="translated">테이블 별칭의 또 다른 형식은 테이블 자체뿐만 아니라 테이블의 열에 임시 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="52020177212290ca0e1ac022789f990b2cddb766" translate="yes" xml:space="preserve">
          <source>Another identifier type used by the system is &lt;code&gt;xid&lt;/code&gt;, or transaction (abbreviated</source>
          <target state="translated">시스템에서 사용하는 다른 식별자 유형은 &lt;code&gt;xid&lt;/code&gt; 또는 transaction (약어)</target>
        </trans-unit>
        <trans-unit id="aed7ef2e15652a392b1a6ed9c8e4d99caec1a67e" translate="yes" xml:space="preserve">
          <source>Another important point is that when a server process is asked to display any of these statistics, it first fetches the most recent report emitted by the collector process and then continues to use this snapshot for all statistical views and functions until the end of its current transaction. So the statistics will show static information as long as you continue the current transaction. Similarly, information about the current queries of all sessions is collected when any such information is first requested within a transaction, and the same information will be displayed throughout the transaction. This is a feature, not a bug, because it allows you to perform several queries on the statistics and correlate the results without worrying that the numbers are changing underneath you. But if you want to see new results with each query, be sure to do the queries outside any transaction block. Alternatively, you can invoke &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt;(), which will discard the current transaction's statistics snapshot (if any). The next use of statistical information will cause a new snapshot to be fetched.</source>
          <target state="translated">또 다른 중요한 점은 서버 프로세스에 이러한 통계를 표시하도록 요청하면 먼저 콜렉터 프로세스에서 생성 한 최신 보고서를 가져온 다음 현재 트랜잭션이 끝날 때까지 모든 통계 뷰 및 기능에 대해이 스냅 샷을 계속 사용한다는 것입니다 . 따라서 통계는 현재 트랜잭션을 계속하는 한 정적 정보를 표시합니다. 마찬가지로 모든 세션의 현재 쿼리에 대한 정보는 해당 정보가 트랜잭션 내에서 처음 요청 될 때 수집되며 동일한 정보가 트랜잭션 전체에 표시됩니다. 이것은 통계가 아닌 여러 쿼리를 수행하고 숫자가 변경 될 염려없이 결과를 상관시킬 수 있기 때문에 버그가 아닌 기능입니다. 그러나 각 검색어에 대해 새로운 결과를 보려면트랜잭션 블록 외부에서 쿼리를 수행하십시오. 또는 호출 할 수 있습니다 &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt; () : 현재 트랜잭션의 통계 스냅 샷 (있는 경우)을 삭제합니다. 다음에 통계 정보를 사용하면 새 스냅 샷을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b8503372565f5e8246e4f400f8ddf376d816116a" translate="yes" xml:space="preserve">
          <source>Another important property of transactional databases is closely related to the notion of atomic updates: when multiple transactions are running concurrently, each one should not be able to see the incomplete changes made by others. For example, if one transaction is busy totalling all the branch balances, it would not do for it to include the debit from Alice's branch but not the credit to Bob's branch, nor vice versa. So transactions must be all-or-nothing not only in terms of their permanent effect on the database, but also in terms of their visibility as they happen. The updates made so far by an open transaction are invisible to other transactions until the transaction completes, whereupon all the updates become visible simultaneously.</source>
          <target state="translated">트랜잭션 데이터베이스의 또 다른 중요한 속성은 원자 업데이트 개념과 밀접한 관련이 있습니다. 여러 트랜잭션이 동시에 실행되는 경우 각 트랜잭션이 다른 트랜잭션의 불완전한 변경을 볼 수 없어야합니다. 예를 들어, 한 거래가 모든 지점 잔액을 합산하는 데 바쁘면 Alice의 지점에서 차변을 포함하지 않고 Bob의 지점으로의 신용은 포함하지 않으며 그 반대도 마찬가지입니다. 따라서 트랜잭션은 데이터베이스에 대한 영구적 인 영향뿐만 아니라 발생시 가시성 측면에서도 전혀 또는 전혀 없어야합니다. 공개 트랜잭션이 수행 한 업데이트는 트랜잭션이 완료 될 때까지 다른 트랜잭션에서 볼 수 없으므로 모든 업데이트가 동시에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="23097e202fa3204d32b939bd963d1f1a19f9bc71" translate="yes" xml:space="preserve">
          <source>Another limitation is that when an inner tuple's node points to a set of leaf tuples, those tuples must all be in the same index page. (This is a design decision to reduce seeking and save space in the links that chain such tuples together.) If the set of leaf tuples grows too large for a page, a split is performed and an intermediate inner tuple is inserted. For this to fix the problem, the new inner tuple &lt;em&gt;must&lt;/em&gt; divide the set of leaf values into more than one node group. If the operator class's &lt;code&gt;picksplit&lt;/code&gt; function fails to do that, the SP-GiST core resorts to extraordinary measures described in &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;.</source>
          <target state="translated">또 다른 제한은 내부 튜플의 노드가 리프 튜플 세트를 가리킬 때 해당 튜플이 모두 동일한 색인 페이지에 있어야한다는 것입니다. (이러한 튜플을 연결하는 링크에서 탐색을 줄이고 공간을 절약하기위한 디자인 결정입니다.) 리프 튜플 세트가 페이지에 비해 너무 커지면 분할이 수행되고 중간 내부 튜플이 삽입됩니다. 이 문제를 해결하기 위해, 새로운 내부 튜플 &lt;em&gt;해야&lt;/em&gt; 하나 개 이상의 노드 그룹에 리프 값들의 세트를 나눈다. 오퍼레이터 클래스의 &lt;code&gt;picksplit&lt;/code&gt; 기능이이를 수행하지 못하면 SP-GiST 코어는 &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;섹션 65.4.3에&lt;/a&gt; 설명 된 특별 조치에 의지 합니다.</target>
        </trans-unit>
        <trans-unit id="3c5682b61a20f627d46e59c868bdcce430ea3716" translate="yes" xml:space="preserve">
          <source>Another limitation of the same kind is that a &lt;code&gt;CASE&lt;/code&gt; cannot prevent evaluation of an aggregate expression contained within it, because aggregate expressions are computed before other expressions in a &lt;code&gt;SELECT&lt;/code&gt; list or &lt;code&gt;HAVING&lt;/code&gt; clause are considered. For example, the following query can cause a division-by-zero error despite seemingly having protected against it:</source>
          <target state="translated">동일한 유형의 또 다른 제한 사항은 &lt;code&gt;CASE&lt;/code&gt; 가 &lt;code&gt;SELECT&lt;/code&gt; 목록 또는 &lt;code&gt;HAVING&lt;/code&gt; 절의 다른 표현식을 고려 하기 전에 집계 표현식이 계산되기 때문에 CASE에 포함 된 집계 표현식의 평가를 막을 수 없다는 것 입니다. 예를 들어 다음 쿼리는 겉보기에 대해 보호 된 것처럼 보이지만 0으로 나누기 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e130eb29a636a2e4db63836c537e80b5eb47453" translate="yes" xml:space="preserve">
          <source>Another nonstandard extension is that following the escape character with a letter or digit provides access to the escape sequences defined for POSIX regular expressions; see &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;, &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;, and &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt; below.</source>
          <target state="translated">또 다른 비표준 확장은 문자 나 숫자가있는 이스케이프 문자 다음에 POSIX 정규식에 대해 정의 된 이스케이프 시퀀스에 대한 액세스를 제공한다는 것입니다. 아래 &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;표 9.20&lt;/a&gt; , &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;표 9.21&lt;/a&gt; 및 &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;표 9.22를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7a59e6837fb64d2b0ae7bbcb08e5b72fd153fb2c" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 연결의 또 다른 옵션 은 클라이언트가 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt; &lt;code&gt;requirepeer&lt;/code&gt; &lt;/a&gt; 를 사용하여 소켓에 연결된 서버 프로세스의 필수 소유자를 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="306459cbdd31101692b05f06a566b18b0bdf0e20" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 연결을위한 또 다른 옵션 은 클라이언트가 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt; &lt;code&gt;requirepeer&lt;/code&gt; &lt;/a&gt; 를 사용하여 소켓에 연결된 서버 프로세스의 필수 소유자를 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb5714af00c74e15b8a5da4136ed86aaafa447c5" translate="yes" xml:space="preserve">
          <source>Another option is to increase &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; on the primary server, so that dead rows will not be cleaned up as quickly as they normally would be. This will allow more time for queries to execute before they are canceled on the standby, without having to set a high &lt;code&gt;max_standby_streaming_delay&lt;/code&gt;. However it is difficult to guarantee any specific execution-time window with this approach, since &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; is measured in transactions executed on the primary server.</source>
          <target state="translated">또 다른 옵션은 기본 서버에서 &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; 를 증가시켜 데드 행이 평소처럼 빨리 정리되지 않도록하는 것입니다. 이것은 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 를 높게 설정할 필요없이 대기에서 취소되기 전에 쿼리를 실행하는 데 더 많은 시간을 허용 합니다. 그러나 &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; 는 기본 서버에서 실행되는 트랜잭션에서 측정 되므로이 방법으로 특정 실행 시간 창을 보장하는 것은 어렵습니다 .</target>
        </trans-unit>
        <trans-unit id="7e21e953eee19c97f61f831dca8e524d5dd57839" translate="yes" xml:space="preserve">
          <source>Another option is to use rsync to perform a file system backup. This is done by first running rsync while the database server is running, then shutting down the database server long enough to do an &lt;code&gt;rsync --checksum&lt;/code&gt;. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) The second rsync will be quicker than the first, because it has relatively little data to transfer, and the end result will be consistent because the server was down. This method allows a file system backup to be performed with minimal downtime.</source>
          <target state="translated">또 다른 옵션은 rsync를 사용하여 파일 시스템 백업을 수행하는 것입니다. 데이터베이스 서버가 실행되는 동안 rsync를 먼저 실행 한 다음 &lt;code&gt;rsync --checksum&lt;/code&gt; 을 수행 할 수있을만큼 데이터베이스 서버를 종료하면됩니다 . ( &lt;code&gt;--checksum&lt;/code&gt; 가 있으므로 필요 &lt;code&gt;rsync&lt;/code&gt; 그것을 전송할 비교적 적은 데이터를 가지고 있기 때문에, 제 rsync를 처음보다 빠를 것이다 단지 1 초의 파일 수정 시간 단위가있다.) 서버가 없기 때문에 결과적으로 일관 될 것이다 하위. 이 방법을 사용하면 최소한의 중단 시간으로 파일 시스템 백업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c34c9f74979196480818c068869e2f214816a27" translate="yes" xml:space="preserve">
          <source>Another option that is often preferable is to remove the partition from the partitioned table but retain access to it as a table in its own right:</source>
          <target state="translated">종종 선호되는 또 다른 옵션은 파티션 된 테이블에서 파티션을 제거하고 자체 권한으로 테이블로 액세스를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2a69438b1163aac867f43267272d34d1c58b2559" translate="yes" xml:space="preserve">
          <source>Another point to keep in mind is that by default, execute privilege is granted to &lt;code&gt;PUBLIC&lt;/code&gt; for newly created functions (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for more information). Frequently you will wish to restrict use of a security definer function to only some users. To do that, you must revoke the default &lt;code&gt;PUBLIC&lt;/code&gt; privileges and then grant execute privilege selectively. To avoid having a window where the new function is accessible to all, create it and set the privileges within a single transaction. For example:</source>
          <target state="translated">명심해야 할 또 다른 점은 기본적으로 새로 생성 된 함수에 대해 실행 권한이 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여된다는 것 입니다 (자세한 내용 은 &lt;a href=&quot;ddl-priv&quot;&gt;섹션 5.7&lt;/a&gt; 참조 ). 보안 정의 자 기능의 사용을 일부 사용자로 제한하려는 경우가 종종 있습니다. 그렇게하려면 기본 &lt;code&gt;PUBLIC&lt;/code&gt; 권한을 취소 한 다음 실행 권한을 선택적으로 부여해야합니다. 모든 사람이 새 기능에 액세스 할 수있는 창을 피하려면 기능을 작성하고 단일 트랜잭션 내에서 권한을 설정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c64ca403c18f38074dbf9506c7423e6c0d47b0ca" translate="yes" xml:space="preserve">
          <source>Another possibility is to create a configuration file directory and put this information into files there. For example, a &lt;code&gt;conf.d&lt;/code&gt; directory could be referenced at the end of &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">또 다른 가능성은 구성 파일 디렉토리를 작성하고이 정보를 파일에 넣는 것입니다. 예를 들어, &lt;code&gt;conf.d&lt;/code&gt; 디렉토리는 &lt;code&gt;postgresql.conf&lt;/code&gt; 끝에서 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e15bc878f1b5a7c697e8423bcee242bc5167d6a2" translate="yes" xml:space="preserve">
          <source>Another possibility is to store the documents as simple text files in the file system. In this case, the database can be used to store the full text index and to execute searches, and some unique identifier can be used to retrieve the document from the file system. However, retrieving files from outside the database requires superuser permissions or special function support, so this is usually less convenient than keeping all the data inside PostgreSQL. Also, keeping everything inside the database allows easy access to document metadata to assist in indexing and display.</source>
          <target state="translated">또 다른 가능성은 문서를 파일 시스템에 간단한 텍스트 파일로 저장하는 것입니다. 이 경우 데이터베이스를 사용하여 전체 텍스트 인덱스를 저장하고 검색을 실행할 수 있으며 일부 고유 식별자를 사용하여 파일 시스템에서 문서를 검색 할 수 있습니다. 그러나 데이터베이스 외부에서 파일을 검색하려면 수퍼 유저 권한 또는 특수 기능 지원이 필요하므로 모든 데이터를 PostgreSQL 내부에 유지하는 것보다 편리하지 않습니다. 또한 모든 것을 데이터베이스에 보관하면 문서 메타 데이터에 쉽게 액세스하여 색인 및 표시를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fbada3201971de13171c32bf7cda835bc3fd1af" translate="yes" xml:space="preserve">
          <source>Another possible type of join is a merge join, illustrated here:</source>
          <target state="translated">다른 가능한 조인 유형은 다음과 같이 병합 조인입니다.</target>
        </trans-unit>
        <trans-unit id="19829ac1739436800f592d8b7c21c52fef4c33d8" translate="yes" xml:space="preserve">
          <source>Another possible use for a partial index is to exclude values from the index that the typical query workload is not interested in; this is shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;Example 11.2&lt;/a&gt;. This results in the same advantages as listed above, but it prevents the &amp;ldquo;uninteresting&amp;rdquo; values from being accessed via that index, even if an index scan might be profitable in that case. Obviously, setting up partial indexes for this kind of scenario will require a lot of care and experimentation.</source>
          <target state="translated">부분 인덱스의 또 다른 가능한 용도는 일반적인 쿼리 워크로드에 관심이없는 인덱스에서 값을 제외하는 것입니다. 이것은 &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;예제 11.2에 나와&lt;/a&gt; 있습니다. 결과적으로 위에서 설명한 것과 동일한 장점이 있지만,이 경우 인덱스 스캔이 수익성이 있더라도 해당 인덱스를 통해 &quot;관심없는&quot;값에 액세스 할 수 없습니다. 분명히 이런 종류의 시나리오에 대해 부분 인덱스를 설정하려면 많은주의와 실험이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f28a354a8ba88184cb3beacb89675afbd6c03d21" translate="yes" xml:space="preserve">
          <source>Another production-grade approach to managing log output is to send it to syslog and let syslog deal with file rotation. To do this, set the configuration parameter &lt;code&gt;log_destination&lt;/code&gt; to &lt;code&gt;syslog&lt;/code&gt; (to log to syslog only) in &lt;code&gt;postgresql.conf&lt;/code&gt;. Then you can send a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the syslog daemon whenever you want to force it to start writing a new log file. If you want to automate log rotation, the logrotate program can be configured to work with log files from syslog.</source>
          <target state="translated">로그 출력을 관리하는 또 다른 프로덕션 급 접근 방식은 로그 출력을 syslog로 보내고 syslog가 파일 회전을 처리하도록하는 것입니다. 이렇게하려면 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 구성 매개 변수 &lt;code&gt;log_destination&lt;/code&gt; 을 &lt;code&gt;syslog&lt;/code&gt; (syslog에만 기록)로 설정하십시오 . 그런 다음 새 로그 파일을 작성하도록 강제 할 때마다 &lt;code&gt;SIGHUP&lt;/code&gt; 신호를 syslog 디먼에 보낼 수 있습니다 . 로그 회전을 자동화하려면 syslog의 로그 파일에 대해 작업하도록 logrotate 프로그램을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d7e78b3e262e81affaac44d4c64dc15d4edfbba" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;FOR UPDATE&lt;/code&gt; is that without it, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; might fail if the cursor query does not meet the SQL standard's rules for being &amp;ldquo;simply updatable&amp;rdquo; (in particular, the cursor must reference just one table and not use grouping or &lt;code&gt;ORDER BY&lt;/code&gt;). Cursors that are not simply updatable might work, or might not, depending on plan choice details; so in the worst case, an application might work in testing and then fail in production. If &lt;code&gt;FOR UPDATE&lt;/code&gt; is specified, the cursor is guaranteed to be updatable.</source>
          <target state="translated">&lt;code&gt;FOR UPDATE&lt;/code&gt; 를 사용해야하는 또 다른 이유 는 커서 쿼리가 &quot;단순히 업데이트 가능&quot;하기위한 SQL 표준 규칙을 충족하지 않으면 후속 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 가 실패 할 수 있기 때문입니다 (특히 커서는 하나의 테이블 만 참조하고 그룹화를 사용하지 않아야 함) 또는 &lt;code&gt;ORDER BY&lt;/code&gt; ). 단순히 업데이트 할 수없는 커서는 계획 선택 세부 사항에 따라 작동하거나 작동하지 않을 수 있습니다. 최악의 경우 응용 프로그램이 테스트에서 작동 한 다음 프로덕션에서 실패 할 수 있습니다. 경우 &lt;code&gt;FOR UPDATE&lt;/code&gt; 가 지정되면, 커서는 갱신이 보장된다.</target>
        </trans-unit>
        <trans-unit id="6f33d845713febc0898090d451e4ee3ef8ebffb5" translate="yes" xml:space="preserve">
          <source>Another requirement for a multiple-data-type family is that any implicit or binary-coercion casts that are defined between data types included in the operator family must not change the associated sort ordering.</source>
          <target state="translated">다중 데이터 유형 제품군에 대한 또 다른 요구 사항은 운영자 제품군에 포함 된 데이터 유형간에 정의 된 암시 적 또는 이진 강제 변환은 연관된 정렬 순서를 변경하지 않아야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9114df95c9c9d6782e38dbaee1edab69dd63ee66" translate="yes" xml:space="preserve">
          <source>Another response could be this:</source>
          <target state="translated">또 다른 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67c38a78e448cde09317f71b64feae68f30e256d" translate="yes" xml:space="preserve">
          <source>Another risk of data loss is posed by the disk platter write operations themselves. Disk platters are divided into sectors, commonly 512 bytes each. Every physical read or write operation processes a whole sector. When a write request arrives at the drive, it might be for some multiple of 512 bytes (PostgreSQL typically writes 8192 bytes, or 16 sectors, at a time), and the process of writing could fail due to power loss at any time, meaning some of the 512-byte sectors were written while others were not. To guard against such failures, PostgreSQL periodically writes full page images to permanent WAL storage &lt;em&gt;before&lt;/em&gt; modifying the actual page on disk. By doing this, during crash recovery PostgreSQL can restore partially-written pages from WAL. If you have file-system software that prevents partial page writes (e.g., ZFS), you can turn off this page imaging by turning off the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. Battery-Backed Unit (BBU) disk controllers do not prevent partial page writes unless they guarantee that data is written to the BBU as full (8kB) pages.</source>
          <target state="translated">디스크 플래터 쓰기 작업 자체에 의해 데이터 손실의 또 다른 위험이 발생합니다. 디스크 플래터는 섹터 (일반적으로 각각 512 바이트)로 나뉩니다. 모든 물리적 읽기 또는 쓰기 작업은 전체 섹터를 처리합니다. 쓰기 요청이 드라이브에 도착하면 512 바이트의 배수 (PostgreSQL은 일반적으로 한 번에 8192 바이트 또는 16 섹터를 씁니다) 일 수 있으며 언제든지 전원 손실로 인해 쓰기 프로세스가 실패 할 수 있습니다. 512 바이트 섹터 중 일부는 작성되었지만 나머지는 그렇지 않았습니다. 이러한 실패를 방지하기 위해 PostgreSQL은 정기적으로 전체 페이지 이미지를 영구 WAL 스토리지 &lt;em&gt;에 기록합니다.&lt;/em&gt;디스크의 실제 페이지 수정 이렇게하면 응급 복구 중에 PostgreSQL이 WAL에서 부분적으로 작성된 페이지를 복원 할 수 있습니다. ZFS와 같은 부분 페이지 쓰기를 방지하는 파일 시스템 소프트웨어가있는 경우 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 매개 변수를 해제하여이 페이지 이미징을 해제 할 수 있습니다 . BBU (Battery-Backed Unit) 디스크 컨트롤러는 데이터가 BBU에 전체 (8kB) 페이지로 기록되도록 보장하지 않는 한 부분 페이지 쓰기를 방지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a64140ba6c591322306ded2e563c831d5063eb12" translate="yes" xml:space="preserve">
          <source>Another special feature is that during input, you can write &lt;code&gt;?&lt;/code&gt; in place of the check digit, and the correct check digit will be inserted automatically.</source>
          <target state="translated">또 다른 특별한 기능은 입력하는 동안 &lt;code&gt;?&lt;/code&gt; 확인 숫자 대신 올바른 확인 숫자가 자동으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a7029d22a4fea1aec3f6a0a7967d7366ab11c8" translate="yes" xml:space="preserve">
          <source>Another special syntactical behavior associated with composite values is that we can use &lt;em&gt;functional notation&lt;/em&gt; for extracting a field of a composite value. The simple way to explain this is that the notations &lt;code&gt;field(table)&lt;/code&gt; and &lt;code&gt;table.field&lt;/code&gt; are interchangeable. For example, these queries are equivalent:</source>
          <target state="translated">복합 값과 관련된 또 다른 특수한 구문 동작은 복합 값 의 필드를 추출하기 위해 &lt;em&gt;기능 표기법&lt;/em&gt; 을 사용할 수 있다는 것 입니다. 이를 설명하는 간단한 방법은 &lt;code&gt;field(table)&lt;/code&gt; 및 &lt;code&gt;table.field&lt;/code&gt; 표기법 을 서로 바꿔 사용할 수 있다는 것입니다. 예를 들어 다음 쿼리는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2d14ebbe44cc336bb06782ca5c2e2a5afdbf5d04" translate="yes" xml:space="preserve">
          <source>Another type of extra information is the number of rows removed by a filter condition:</source>
          <target state="translated">다른 유형의 추가 정보는 필터 조건에 의해 제거 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="de04ff7f29beb7d9f803262abe6fbc7f7a247ce7" translate="yes" xml:space="preserve">
          <source>Another type of statistics stored for each column are most-common value lists. This allows very accurate estimates for individual columns, but may result in significant misestimates for queries with conditions on multiple columns.</source>
          <target state="translated">각 열에 대해 저장된 또 다른 유형의 통계는 가장 일반적인 값 목록입니다. 이렇게하면 개별 열에 대한 매우 정확한 추정이 가능하지만 여러 열에 대한 조건이있는 쿼리의 경우 상당한 오해가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef386cf940d64dd2d0246974eb986d99db04233" translate="yes" xml:space="preserve">
          <source>Another useful tool for monitoring database activity is the &lt;code&gt;pg_locks&lt;/code&gt; system table. It allows the database administrator to view information about the outstanding locks in the lock manager. For example, this capability can be used to:</source>
          <target state="translated">데이터베이스 활동을 모니터링하는 또 다른 유용한 도구는 &lt;code&gt;pg_locks&lt;/code&gt; 시스템 테이블입니다. 데이터베이스 관리자는 잠금 관리자에서 미해결 잠금에 대한 정보를 볼 수 있습니다. 예를 들어이 기능을 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="973de1b89f5a19d8493a281c676145e3c2762491" translate="yes" xml:space="preserve">
          <source>Another value expression in parentheses (used to group subexpressions and override precedence)</source>
          <target state="translated">괄호 안의 다른 값 표현식 (하위 표현식을 그룹화하고 우선 순위를 대체하는 데 사용됨)</target>
        </trans-unit>
        <trans-unit id="6edaee98c73d284626179be9ad3ba0277589e38b" translate="yes" xml:space="preserve">
          <source>Another way to accomplish the same thing:</source>
          <target state="translated">동일한 작업을 수행하는 또 다른 방법 :</target>
        </trans-unit>
        <trans-unit id="7a50bf5d6a0c79646db228f587b35fc8dbea931f" translate="yes" xml:space="preserve">
          <source>Another way to do it is:</source>
          <target state="translated">다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09b69091260be1fa872b4a938337bcecea2b0096" translate="yes" xml:space="preserve">
          <source>Another way to get the same effect is to use the &lt;code&gt;regclass&lt;/code&gt; alias type, which will print the table OID symbolically:</source>
          <target state="translated">동일한 효과를 얻는 또 다른 방법은 &lt;code&gt;regclass&lt;/code&gt; 별칭 유형 을 사용 하여 테이블 OID를 기호로 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="77f482e38cebbd37d2bd4865436228573a9f332c" translate="yes" xml:space="preserve">
          <source>Another way to obtain the same result as &lt;code&gt;\copy ... to&lt;/code&gt; is to use the SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; command and terminate it with &lt;code&gt;\g filename&lt;/code&gt; or &lt;code&gt;\g |program&lt;/code&gt;. Unlike &lt;code&gt;\copy&lt;/code&gt;, this method allows the command to span multiple lines; also, variable interpolation and backquote expansion can be used.</source>
          <target state="translated">&lt;code&gt;\copy ... to&lt;/code&gt; 와 동일한 결과를 얻는 다른 방법 은 SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; 명령을 사용하고이를 &lt;code&gt;\g filename&lt;/code&gt; 또는 &lt;code&gt;\g |program&lt;/code&gt; 종료하는 것입니다 . &lt;code&gt;\copy&lt;/code&gt; 와 달리이 방법을 사용하면 명령이 여러 줄에 걸쳐있을 수 있습니다. 또한 가변 보간 및 역 따옴표 확장을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af0ee54bbb9066194d74463e9d95fe7b567d2abb" translate="yes" xml:space="preserve">
          <source>Another way to return multiple columns is to use a &lt;code&gt;TABLE&lt;/code&gt; function:</source>
          <target state="translated">여러 열을 반환하는 또 다른 방법은 &lt;code&gt;TABLE&lt;/code&gt; 함수 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="886fca6d2b20a157de482df72d3dea2c336eadc6" translate="yes" xml:space="preserve">
          <source>Another way to think about a discrete range type is that there is a clear idea of a &amp;ldquo;next&amp;rdquo; or &amp;ldquo;previous&amp;rdquo; value for each element value. Knowing that, it is possible to convert between inclusive and exclusive representations of a range's bounds, by choosing the next or previous element value instead of the one originally given. For example, in an integer range type &lt;code&gt;[4,8]&lt;/code&gt; and &lt;code&gt;(3,9)&lt;/code&gt; denote the same set of values; but this would not be so for a range over numeric.</source>
          <target state="translated">불연속 범위 유형을 생각하는 또 다른 방법은 각 요소 값에 대해 &quot;다음&quot;또는 &quot;이전&quot;값에 대한 명확한 아이디어가 있다는 것입니다. 이를 알면 원래 제공된 값 대신 다음 또는 이전 요소 값을 선택하여 범위 범위의 포괄적 인 표현과 독점적 표현간에 변환 할 수 있습니다. 예를 들어, 정수 범위 유형 &lt;code&gt;[4,8]&lt;/code&gt; 및 &lt;code&gt;(3,9)&lt;/code&gt; 는 동일한 값 세트를 나타냅니다. 그러나 이것은 숫자 이상의 범위에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d84849349152ff8e618adbfaeb1704c4dc99ecf7" translate="yes" xml:space="preserve">
          <source>Another way to work with angles measured in degrees is to use the unit transformation functions &lt;code&gt;radians()&lt;/code&gt; and &lt;code&gt;degrees()&lt;/code&gt; shown earlier. However, using the degree-based trigonometric functions is preferred, as that way avoids round-off error for special cases such as &lt;code&gt;sind(30)&lt;/code&gt;.</source>
          <target state="translated">각도로 각도를 측정하는 또 다른 방법은 앞에서 설명한 단위 변환 함수 &lt;code&gt;radians()&lt;/code&gt; 및 &lt;code&gt;degrees()&lt;/code&gt; 하는 것입니다. 그러나 &lt;code&gt;sind(30)&lt;/code&gt; 과 같은 특수한 경우 반올림 오차를 피할 수 있으므로 정도 기반 삼각 함수를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="efdd30de2aea5b5d5befd3533f098d92f63380ab" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DECLARE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; statement, whose execution plan you wish to see.</source>
          <target state="translated">모든 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 는 , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;VALUES&lt;/code&gt; 는 , &lt;code&gt;EXECUTE&lt;/code&gt; , &lt;code&gt;DECLARE&lt;/code&gt; 을 , &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 거나 &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; 그 실행 계획을보고 싶은 문을.</target>
        </trans-unit>
        <trans-unit id="386ffc8dd49c3fb7f2ddd349b2b9b4201e8b40ad" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; statement.</source>
          <target state="translated">모든 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 는 , &lt;code&gt;DELETE&lt;/code&gt; , 또는 &lt;code&gt;VALUES&lt;/code&gt; 의 문.</target>
        </trans-unit>
        <trans-unit id="450e11982aec06ef4f3dbb171ba6a8eb1e20a7be" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly or explicitly; therefore, the functions shown above as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value. In addition, you can cast a text value to &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; using normal casting syntax: for example, &lt;code&gt;inet(expression)&lt;/code&gt; or &lt;code&gt;colname::cidr&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;cidr&lt;/code&gt; 값은 암시 적으로 또는 명시 적으로 &lt;code&gt;inet&lt;/code&gt; 으로 캐스트 될 수 있습니다 . 따라서 위의 &lt;code&gt;inet&lt;/code&gt; 에서 작동하는 것으로 표시된 기능 은 &lt;code&gt;cidr&lt;/code&gt; 값 에서도 작동 합니다. ( &lt;code&gt;inet&lt;/code&gt; 및 &lt;code&gt;cidr&lt;/code&gt; 에 대해 별도의 함수 가있는 경우 두 경우에 대해 동작이 달라야하기 때문입니다.) 또한 &lt;code&gt;inet&lt;/code&gt; 값을 &lt;code&gt;cidr&lt;/code&gt; 에 캐스트 할 수 있습니다. 이 작업이 완료되면 유효한 &lt;code&gt;cidr&lt;/code&gt; 값 을 생성하기 위해 넷 마스크 오른쪽의 비트가 자동으로 0으로 설정됩니다 . 또한 일반 캐스트 구문을 사용하여 텍스트 값을 &lt;code&gt;inet&lt;/code&gt; 또는 &lt;code&gt;cidr&lt;/code&gt; 로 캐스트 할 수 있습니다 &lt;code&gt;inet(expression)&lt;/code&gt; 예 : inet (expression)). 또는 &lt;code&gt;colname::cidr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8208175702ffb5cdd4ede5051892cf19b0e69014" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly; therefore, the operators and functions shown below as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value.</source>
          <target state="translated">모든 &lt;code&gt;cidr&lt;/code&gt; 값은 암시 적 으로 &lt;code&gt;inet&lt;/code&gt; 으로 캐스트 될 수 있습니다 . 따라서 &lt;code&gt;inet&lt;/code&gt; 에서 작동하는 아래 표시된 연산자와 함수 는 &lt;code&gt;cidr&lt;/code&gt; 값 에서도 작동 합니다. ( &lt;code&gt;inet&lt;/code&gt; 과 &lt;code&gt;cidr&lt;/code&gt; 에 대한 별도의 함수 가있는 경우 두 경우의 동작이 달라야하기 때문입니다.) 또한 &lt;code&gt;inet&lt;/code&gt; 값을 &lt;code&gt;cidr&lt;/code&gt; 로 캐스트 할 수 있습니다. 이 작업이 완료되면 넷 마스크 오른쪽의 모든 비트가 자동으로 0이되어 유효한 &lt;code&gt;cidr&lt;/code&gt; 값 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="97a5e9f25fdf2d6789317985300af494edaa42f6" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The condition expression cannot refer to any tables except &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt;, and cannot contain aggregate functions.</source>
          <target state="translated">모든 SQL 조건식 ( &lt;code&gt;boolean&lt;/code&gt; 반환 ) 조건 표현식은 &lt;code&gt;NEW&lt;/code&gt; 및 &lt;code&gt;OLD&lt;/code&gt; 이외의 테이블을 참조 할 수 없으며 집계 함수를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f04645af195b0769f156d1c9178d5413d13947d" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be added to queries that refer to the table if row level security is enabled. Rows for which the expression returns true will be visible. Any rows for which the expression returns false or null will not be visible to the user (in a &lt;code&gt;SELECT&lt;/code&gt;), and will not be available for modification (in an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;). Such rows are silently suppressed; no error is reported.</source>
          <target state="translated">모든 SQL 조건식 ( &lt;code&gt;boolean&lt;/code&gt; 반환 ) 조건식에는 집계 또는 창 함수가 포함될 수 없습니다. 이 표현식은 행 레벨 보안이 사용 가능한 경우 테이블을 참조하는 쿼리에 추가됩니다. 표현식이 true를 리턴하는 행이 표시됩니다. 표현식이 false 또는 null을 반환하는 행은 사용자에게 표시되지 않으며 ( &lt;code&gt;SELECT&lt;/code&gt; 에서 ) 수정할 수 없습니다 ( &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 에서) ). 이러한 행은 자동으로 억제됩니다. 오류가보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d0a8e5978d0613618d7d621bf1cd5c083979c7e" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be used in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; queries against the table if row level security is enabled. Only rows for which the expression evaluates to true will be allowed. An error will be thrown if the expression evaluates to false or null for any of the records inserted or any of the records that result from the update. Note that the &lt;code&gt;check_expression&lt;/code&gt; is evaluated against the proposed new contents of the row, not the original contents.</source>
          <target state="translated">모든 SQL 조건식 ( &lt;code&gt;boolean&lt;/code&gt; 반환 ) 조건식에는 집계 또는 창 함수가 포함될 수 없습니다. 이 표현식은 행 레벨 보안이 사용 가능한 경우 테이블에 대한 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 조회에서 사용됩니다. 표현식이 true로 평가되는 행만 허용됩니다. 삽입 된 레코드 나 업데이트로 인해 발생한 레코드에 대해식이 false 또는 null로 평가되면 오류가 발생합니다. 있습니다 &lt;code&gt;check_expression&lt;/code&gt; 은 행의 제안 된 새로운 내용이 아니라 원래 내용에 대해 평가한다.</target>
        </trans-unit>
        <trans-unit id="3e356ac9cfe76e1d8f07ddb1a43d7eac6d271ea2" translate="yes" xml:space="preserve">
          <source>Any character in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; that matches a character in the &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; set is replaced by the corresponding character in the &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt; set. If &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; is longer than &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;, occurrences of the extra characters in &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; are removed.</source>
          <target state="translated">의 모든 문자 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 문자와 일치 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 세트는에서 해당 문자로 대체됩니다 &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; 설정. 경우 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 보다 더 이상 &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; ,에 추가 문자의 발생 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="12f81b0886507c6c81c137ed43e36901064a888a" translate="yes" xml:space="preserve">
          <source>Any developer of a new &lt;code&gt;table access method&lt;/code&gt; can refer to the existing &lt;code&gt;heap&lt;/code&gt; implementation present in &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; for details of its implementation.</source>
          <target state="translated">새로운 &lt;code&gt;table access method&lt;/code&gt; 개발자는 구현에 대한 세부 사항을 위해 &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; 에 있는 기존 &lt;code&gt;heap&lt;/code&gt; 구현을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="144550beabeed185659254b872d28c678638c93a" translate="yes" xml:space="preserve">
          <source>Any digest algorithm OpenSSL supports is automatically picked up. This is not possible with ciphers, which need to be supported explicitly.</source>
          <target state="translated">OpenSSL이 지원하는 모든 다이제스트 알고리즘이 자동으로 선택됩니다. 명시 적으로 지원해야하는 암호로는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c4c8c401fe264a209ebccf99c5f886fc113da7d7" translate="yes" xml:space="preserve">
          <source>Any file or directory beginning with &lt;code&gt;pgsql_tmp&lt;/code&gt; can be omitted from the backup. These files are removed on postmaster start and the directories will be recreated as needed.</source>
          <target state="translated">&lt;code&gt;pgsql_tmp&lt;/code&gt; 로 시작하는 파일 또는 디렉토리 는 백업에서 생략 할 수 있습니다. 이러한 파일은 포스트 마스터 시작시 제거되며 필요에 따라 디렉토리가 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a836141ba30a8aa1360f43439d3c24535024a80a" translate="yes" xml:space="preserve">
          <source>Any generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns.</source>
          <target state="translated">복사 된 열 정의의 모든 생성 표현식이 복사됩니다. 기본적으로 새 열은 일반 기본 열입니다.</target>
        </trans-unit>
        <trans-unit id="5e18734ff6a37a9bb9fd3457eedcb31fb70163d6" translate="yes" xml:space="preserve">
          <source>Any identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table.</source>
          <target state="translated">복사 된 열 정의의 모든 ID 스펙이 복사됩니다. 이전 테이블과 연관된 시퀀스와 별도로 새 테이블의 각 ID 열에 대해 새 시퀀스가 ​​작성됩니다.</target>
        </trans-unit>
        <trans-unit id="feba919d6ac95ebb1703749287894bc69e982374" translate="yes" xml:space="preserve">
          <source>Any memberships in the group role are automatically revoked (but the member roles are not otherwise affected).</source>
          <target state="translated">그룹 역할의 모든 멤버십은 자동으로 취소되지만 멤버 역할은 다른 방식으로 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13a56d22fdbd5ea4aa4d99bf869d62836d2a9dbc" translate="yes" xml:space="preserve">
          <source>Any object that can be created with a &lt;code&gt;CREATE&lt;/code&gt; command. Most objects are specific to one database, and are commonly known as &lt;em&gt;local objects&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE&lt;/code&gt; 명령 으로 만들 수있는 모든 개체입니다 . 대부분의 개체는 하나의 데이터베이스에만 해당되며 일반적으로 &lt;em&gt;로컬 개체&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f42a74d5d4ceddfdc2731676cd56c9941e931e10" translate="yes" xml:space="preserve">
          <source>Any other backslashed character that is not mentioned in the above table will be taken to represent itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end-of-data marker (&lt;code&gt;\.&lt;/code&gt;) or the null string (&lt;code&gt;\N&lt;/code&gt; by default). These strings will be recognized before any other backslash processing is done.</source>
          <target state="translated">위 표에 언급되지 않은 다른 백 슬래시 문자는 자체를 나타내는 것으로 간주됩니다. 그러나 백 슬래시를 불필요하게 추가하면 실수로 데이터 끝 표시 ( &lt;code&gt;\.&lt;/code&gt; ) 또는 null 문자열 ( 기본적으로 &lt;code&gt;\N&lt;/code&gt; )과 일치하는 문자열이 생성 될 수 있으므로 백 슬래시를 추가하지 않아도 됩니다. 이 문자열은 다른 백 슬래시 처리가 수행되기 전에 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="59556037a647190d9808748d3940223c9b60fa38" translate="yes" xml:space="preserve">
          <source>Any other character following a backslash is taken literally. Thus, to include a backslash character, write two backslashes (&lt;code&gt;\\&lt;/code&gt;). Also, a single quote can be included in an escape string by writing &lt;code&gt;\'&lt;/code&gt;, in addition to the normal way of &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">백 슬래시 뒤의 다른 문자는 그대로 사용됩니다. 따라서 백 슬래시 문자를 포함 시키려면 두 개의 백 슬래시 ( &lt;code&gt;\\&lt;/code&gt; )를 작성하십시오. 또한 &lt;code&gt;''&lt;/code&gt; 의 일반적인 방법 외에도 &lt;code&gt;\'&lt;/code&gt; 을 쓰면 이스케이프 문자열에 작은 따옴표를 포함시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="deecfecd8837d0982d5dc84b37df7cbf1f0b77cf" translate="yes" xml:space="preserve">
          <source>Any process, possibly remote, that establishes a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;session&lt;/a&gt; by &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connecting&lt;/a&gt; to an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to interact with a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;데이터베이스&lt;/a&gt; 와 상호 작용 하기 위해 &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;인스턴스&lt;/a&gt; 에 &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;연결&lt;/a&gt; 하여 &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;세션&lt;/a&gt; 을 설정하는 모든 프로세스 (원격 일 수 있음) .</target>
        </trans-unit>
        <trans-unit id="6176992a355fd17e3c78216ef8246e171f7a7f5d" translate="yes" xml:space="preserve">
          <source>Any rows whose updated values do not pass the &lt;code&gt;WITH CHECK&lt;/code&gt; expression will cause an error, and the entire command will be aborted. If only a &lt;code&gt;USING&lt;/code&gt; clause is specified, then that clause will be used for both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; cases.</source>
          <target state="translated">업데이트 된 값이 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식을 통과하지 않은 행 은 오류를 발생시키고 전체 명령이 중단됩니다. 단지 경우 &lt;code&gt;USING&lt;/code&gt; 절이 지정되어, 그 절은 모두에 사용됩니다 &lt;code&gt;USING&lt;/code&gt; 및 &lt;code&gt;WITH CHECK&lt;/code&gt; 경우.</target>
        </trans-unit>
        <trans-unit id="e53b9947d34df736f27a314411d8d097ccb99c38" translate="yes" xml:space="preserve">
          <source>Any two opposite corners can be supplied on input, but the values will be reordered as needed to store the upper right and lower left corners, in that order.</source>
          <target state="translated">입력시 두 개의 반대쪽 모서리를 제공 할 수 있지만 값은 오른쪽 상단과 왼쪽 하단을 순서대로 저장하는 데 필요한 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="9cd48f92d0048ad74a4b2a1c77759555487aa4a5" translate="yes" xml:space="preserve">
          <source>Any value of &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; greater than 0 selects the shortest-precise format.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; 가 0보다 큰 값은 가장 짧은 형식을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6e1092ad7e1aa0d329dcf1a1dc88a2fd1167428b" translate="yes" xml:space="preserve">
          <source>Anything you enter in psql that begins with an unquoted backslash is a psql meta-command that is processed by psql itself. These commands make psql more useful for administration or scripting. Meta-commands are often called slash or backslash commands.</source>
          <target state="translated">인용 부호없는 백 슬래시로 시작하는 psql에 입력 한 것은 psql 자체에서 처리되는 psql 메타 명령입니다. 이 명령은 psql을 관리 또는 스크립팅에 더 유용하게 만듭니다. 메타 명령은 종종 슬래시 또는 백 슬래시 명령이라고합니다.</target>
        </trans-unit>
        <trans-unit id="ca34db883b90f5136d142c2d8962aac808f06344" translate="yes" xml:space="preserve">
          <source>Append the server log output to &lt;code&gt;filename&lt;/code&gt;. If the file does not exist, it is created. The umask is set to 077, so access to the log file is disallowed to other users by default.</source>
          <target state="translated">서버 로그 출력을 &lt;code&gt;filename&lt;/code&gt; 에 추가하십시오 . 파일이 없으면 작성됩니다. umask는 077로 설정되므로 기본적으로 다른 사용자가 로그 파일에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8837d91fde54bfbd4c7276bc104dbd7eb57e326a" translate="yes" xml:space="preserve">
          <source>Appendix A. PostgreSQL Error Codes</source>
          <target state="translated">부록 A. PostgreSQL 오류 코드</target>
        </trans-unit>
        <trans-unit id="8f525f98762ab18cc61fb77a68f4661a9eaa0966" translate="yes" xml:space="preserve">
          <source>Appendix B. Date/Time Support</source>
          <target state="translated">부록 B. 날짜 / 시간 지원</target>
        </trans-unit>
        <trans-unit id="0a4fd0d75b5e8cb67c2577d915d2f158e36d619c" translate="yes" xml:space="preserve">
          <source>Appendix C. SQL Key Words</source>
          <target state="translated">부록 C. SQL 키워드</target>
        </trans-unit>
        <trans-unit id="2d3d6ce5d75b048ec4b4bfd56085229d360ae080" translate="yes" xml:space="preserve">
          <source>Appendix D. SQL Conformance</source>
          <target state="translated">부록 D. SQL 적합성</target>
        </trans-unit>
        <trans-unit id="1c760d4057771bdbd912b1a26d17b99309626b19" translate="yes" xml:space="preserve">
          <source>Appendix E. Release Notes</source>
          <target state="translated">부록 E. 릴리스 정보</target>
        </trans-unit>
        <trans-unit id="3cc083a7e98cb9a510c3b8e9fe828f669dae8eb2" translate="yes" xml:space="preserve">
          <source>Appendix F. Additional Supplied Modules</source>
          <target state="translated">부록 F. 추가 제공 모듈</target>
        </trans-unit>
        <trans-unit id="0a757b9f46902730f7dbc09c2b987bcc9b1402c2" translate="yes" xml:space="preserve">
          <source>Appendix G. Additional Supplied Programs</source>
          <target state="translated">부록 G. 추가 제공 프로그램</target>
        </trans-unit>
        <trans-unit id="f731ac7aad79287ad6a9d70b29b7d9f22f9d74ad" translate="yes" xml:space="preserve">
          <source>Appendix K. PostgreSQL Limits</source>
          <target state="translated">부록 K. PostgreSQL 제한</target>
        </trans-unit>
        <trans-unit id="6b2f6b4afe56f03c3636cff98cc090e912a2978a" translate="yes" xml:space="preserve">
          <source>Appendix L. Acronyms</source>
          <target state="translated">부록 L. 약어</target>
        </trans-unit>
        <trans-unit id="f60b3f6b35cf4c13bfaa5fa9f25882503add453a" translate="yes" xml:space="preserve">
          <source>Appendix M. Glossary</source>
          <target state="translated">부록 M. 용어집</target>
        </trans-unit>
        <trans-unit id="ea37fd5c2add8dc11cd4eac4e99886acbe263edc" translate="yes" xml:space="preserve">
          <source>Appendix N. Color Support</source>
          <target state="translated">부록 N. 색상 지원</target>
        </trans-unit>
        <trans-unit id="5e2daf479a3e3b6ca8645aabab30691c459271fc" translate="yes" xml:space="preserve">
          <source>Appendix: Additional Supplied Modules</source>
          <target state="translated">부록 : 추가 공급 모듈</target>
        </trans-unit>
        <trans-unit id="212a37d7af38255a5010be41cf96e1919f1f65fe" translate="yes" xml:space="preserve">
          <source>Appendix: Color Support</source>
          <target state="translated">부록 : 색상 지원</target>
        </trans-unit>
        <trans-unit id="5fe175a1da37b9c50cabd865124df334aa3597f0" translate="yes" xml:space="preserve">
          <source>Appendix: Date/Time Support</source>
          <target state="translated">부록 : 날짜 / 시간 지원</target>
        </trans-unit>
        <trans-unit id="a8d8b25f2c37eff5457e8db6ccb6dece99f46eb0" translate="yes" xml:space="preserve">
          <source>Appendix: SQL Conformance</source>
          <target state="translated">부록 : SQL 적합성</target>
        </trans-unit>
        <trans-unit id="1f6da0679b0bcee42966e5109a37944191c26ca8" translate="yes" xml:space="preserve">
          <source>Appendixes</source>
          <target state="translated">Appendixes</target>
        </trans-unit>
        <trans-unit id="2fc28e50f7d7e95a87ebbb410bfe469fb51248d4" translate="yes" xml:space="preserve">
          <source>Appends an element to the end of an array (same as the &lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;anyelement&lt;/code&gt; operator).</source>
          <target state="translated">배열 끝에 요소를 추가합니다 ( &lt;code&gt;anyarray&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;anyelement&lt;/code&gt; 연산자 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="99005fc867cd3e54c80bd91ee175bcce277708d9" translate="yes" xml:space="preserve">
          <source>Applicable Object Types</source>
          <target state="translated">적용 가능한 객체 유형</target>
        </trans-unit>
        <trans-unit id="a63f73a380e6bb14bdd2ad6b10a8f68e5d42a5ad" translate="yes" xml:space="preserve">
          <source>Application Programming Interface</source>
          <target state="translated">응용 프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="2f16f8fd5e0553e004d0e86eda56a845aa102673" translate="yes" xml:space="preserve">
          <source>Application name</source>
          <target state="translated">응용 프로그램 이름</target>
        </trans-unit>
        <trans-unit id="b03ebc2274f172652f6125e87dba0dd896ad4421" translate="yes" xml:space="preserve">
          <source>Application of Multiple Policies</source>
          <target state="translated">여러 정책 적용</target>
        </trans-unit>
        <trans-unit id="00135b8aa11b060725023cffb44e0b589a9f25a0" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with queries accessing the target page on the standby, whether or not the data to be removed is visible.</source>
          <target state="translated">WAL에서 진공 정리 레코드를 적용하면 제거 할 데이터의 표시 여부에 관계없이 대기의 대상 페이지에 액세스하는 쿼리와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="3256ed72d4783ec493be93406d6bd97d0d7b90f1" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with standby transactions whose snapshots can still &amp;ldquo;see&amp;rdquo; any of the rows to be removed.</source>
          <target state="translated">WAL에서 진공 정리 레코드를 적용하면 스냅 샷이 제거 할 행을 &quot;인식&quot;할 수있는 대기 트랜잭션과 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="76c74bd071dd73f01696fddbbffc77712a479faf" translate="yes" xml:space="preserve">
          <source>Applications</source>
          <target state="translated">Applications</target>
        </trans-unit>
        <trans-unit id="6b5428213daf1d5aba6d1295a6bbb19c08864fc0" translate="yes" xml:space="preserve">
          <source>Applications that wanted precise values have historically had to set &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.</source>
          <target state="translated">정확한 값을 원했던 애플리케이션은 역사적으로 &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; 를 3으로 설정하여 값 을 얻었습니다. 버전 간 호환성을 극대화하려면 계속 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed624d6999cad953cb5b1bedd94e985196972ebd" translate="yes" xml:space="preserve">
          <source>Applications that wish to use backslash as escape should be modified to use escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;), because the default behavior of ordinary strings is now to treat backslash as an ordinary character, per SQL standard. This variable can be enabled to help locate code that needs to be changed.</source>
          <target state="translated">백 슬래시를 이스케이프로 사용하려는 응용 프로그램은 이스케이프 문자열 구문 ( &lt;code&gt;E'...'&lt;/code&gt; ) 을 사용하도록 수정해야합니다. 일반 문자열의 기본 동작은 이제 SQL 표준에 따라 백 슬래시를 일반 문자로 취급하기 때문입니다. 이 변수를 사용하면 변경해야하는 코드를 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85980229b9ae48d13b46796fb33f530f87d73b8b" translate="yes" xml:space="preserve">
          <source>Applications using this level must be prepared to retry transactions due to serialization failures.</source>
          <target state="translated">이 레벨을 사용하는 응용 프로그램은 직렬화 실패로 인해 트랜잭션을 재 시도 할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="55278f2bfbaabfad19c2fee75ec3133e8897d48a" translate="yes" xml:space="preserve">
          <source>Apply modifications to the page images obtained in the previous step.</source>
          <target state="translated">이전 단계에서 얻은 페이지 이미지에 수정 사항을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="068d74cbbe7303d0ad643d8aa0d60cbff0956278" translate="yes" xml:space="preserve">
          <source>Apply the WAL from the source cluster, starting from the checkpoint created at failover. (Strictly speaking, pg_rewind doesn't apply the WAL, it just creates a backup label file that makes PostgreSQL start by replaying all WAL from that checkpoint forward.)</source>
          <target state="translated">장애 조치시 작성된 검사 점에서 시작하여 소스 클러스터에서 WAL을 적용하십시오. 엄밀히 말하면, pg_rewind는 WAL을 적용하지 않고 PostgreSQL을 해당 체크 포인트에서 모든 WAL을 다시 재생하여 시작하게하는 백업 레이블 파일 만 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e486b3d6c0bcfe71e975768cf7354a58fa17fa9a" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data for moving-aggregate mode, or zero to use a default estimate</source>
          <target state="translated">이동 집계 모드에 대한 전이 상태 데이터의 대략적인 평균 크기 (바이트) 또는 기본 추정값을 사용하는 경우 0</target>
        </trans-unit>
        <trans-unit id="caafece427e1163ffa963b4dffa3cc2b00260a07" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data, or zero to use a default estimate</source>
          <target state="translated">전이 상태 데이터의 대략적인 평균 크기 (바이트) 또는 기본 추정값을 사용하려면 0</target>
        </trans-unit>
        <trans-unit id="753bf6e471b3480498401484488505d0888a0767" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from a JSON number or string</source>
          <target state="translated">JSON 숫자 또는 문자열에서 변환 된 대략적인 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="d737059a7023272b67d00f7bdeb9dfcc94048eda" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from an SQL/JSON number or a string</source>
          <target state="translated">SQL / JSON 숫자 또는 문자열에서 변환 된 대략적인 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="c0b0f0e736e61c866d8d2ac574b894e925e89613" translate="yes" xml:space="preserve">
          <source>Approximate value of &amp;pi;</source>
          <target state="translated">&amp;pi;의 대략적인 값</target>
        </trans-unit>
        <trans-unit id="befde54a108cb9dc6ad6e0ebd28720531a6855e6" translate="yes" xml:space="preserve">
          <source>Apr</source>
          <target state="translated">Apr</target>
        </trans-unit>
        <trans-unit id="a0393902db1f516ef5f95f6830938558a88fb23c" translate="yes" xml:space="preserve">
          <source>April</source>
          <target state="translated">April</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="2e6a8c2f54eea95c918815af873f318c8b75d1ee" translate="yes" xml:space="preserve">
          <source>Arbitrary text that serves as the description of this object</source>
          <target state="translated">이 객체의 설명 역할을하는 임의의 텍스트</target>
        </trans-unit>
        <trans-unit id="a4183b8dc44cf7f7f1da3bacb0f01f6cc6331a8b" translate="yes" xml:space="preserve">
          <source>Archaic term for a &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL record&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL 레코드의&lt;/a&gt; 구식 용어입니다 .</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="c2745399d3dc1caef67349072200fb056fc4129e" translate="yes" xml:space="preserve">
          <source>Architecture: Initial Snapshot</source>
          <target state="translated">아키텍처 : 초기 스냅 샷</target>
        </trans-unit>
        <trans-unit id="a57a286a92ae143de1dc965b902d9ecc2dfd66af" translate="yes" xml:space="preserve">
          <source>Are &lt;code&gt;aclitem&lt;/code&gt;s equal? (Notice that type &lt;code&gt;aclitem&lt;/code&gt; lacks the usual set of comparison operators; it has only equality. In turn, &lt;code&gt;aclitem&lt;/code&gt; arrays can only be compared for equality.)</source>
          <target state="translated">&lt;code&gt;aclitem&lt;/code&gt; 은 동일합니까? (유형 &lt;code&gt;aclitem&lt;/code&gt; 에는 일반적인 비교 연산자 세트가 없습니다. 동일성 만 있습니다. 차례로 &lt;code&gt;aclitem&lt;/code&gt; 배열은 동일성에 대해서만 비교할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="67a9118149c6042fe6daa560647e16f79a2d3d97" translate="yes" xml:space="preserve">
          <source>Are horizontally aligned?</source>
          <target state="translated">가로로 정렬되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="0277a553173b27be90f022d132a83d4b3aaf7ebc" translate="yes" xml:space="preserve">
          <source>Are lines parallel?</source>
          <target state="translated">선이 평행합니까?</target>
        </trans-unit>
        <trans-unit id="ae62863d19a1f09ae83d96496ecb5be1da1e9570" translate="yes" xml:space="preserve">
          <source>Are lines perpendicular?</source>
          <target state="translated">선이 수직입니까?</target>
        </trans-unit>
        <trans-unit id="8897c493ba700783f2c64a4d0f20f14b01d7b1e3" translate="yes" xml:space="preserve">
          <source>Are parallel?</source>
          <target state="translated">평행합니까?</target>
        </trans-unit>
        <trans-unit id="b0f274d71a2fb179ee895325d1f8e8eba6d7eaf4" translate="yes" xml:space="preserve">
          <source>Are points horizontally aligned (that is, have same y coordinate)?</source>
          <target state="translated">점이 수평으로 정렬되어 있습니까 (즉, 동일한 y 좌표를 가짐)?</target>
        </trans-unit>
        <trans-unit id="4fd10598c5b40d1cb91d9f056ebf89eb9d7aa121" translate="yes" xml:space="preserve">
          <source>Are points vertically aligned (that is, have same x coordinate)?</source>
          <target state="translated">점이 수직으로 정렬되어 있습니까 (즉, 동일한 x 좌표를 가짐)?</target>
        </trans-unit>
        <trans-unit id="5cba229ff1c565c58441b7f5908ac5643aeb85b7" translate="yes" xml:space="preserve">
          <source>Are the left JSON path/value entries contained at the top level within the right JSON value?</source>
          <target state="translated">왼쪽 JSON 경로 / 값 항목이 오른쪽 JSON 값의 최상위 레벨에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="7f5f796f9f81b0556b03d7a49d7711d325d01584" translate="yes" xml:space="preserve">
          <source>Are the ranges adjacent?</source>
          <target state="translated">범위가 인접 해 있습니까?</target>
        </trans-unit>
        <trans-unit id="95ac96b9bb2b90c235c16c3c150acca2ceb1786a" translate="yes" xml:space="preserve">
          <source>Are the two &lt;code&gt;seg&lt;/code&gt;s equal?</source>
          <target state="translated">두 &lt;code&gt;seg&lt;/code&gt; 가 같습니까?</target>
        </trans-unit>
        <trans-unit id="fdbf4786edf9f977d2039f0d91270c27aa5a8043" translate="yes" xml:space="preserve">
          <source>Are these objects the same? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">이러한 개체는 동일합니까? 가능 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea55540eda7f3ae150bdf50ff88e357b0470bd4" translate="yes" xml:space="preserve">
          <source>Are vertically aligned?</source>
          <target state="translated">세로로 정렬되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="227b299c7388311800207bda7f4dca4cbfe39510" translate="yes" xml:space="preserve">
          <source>Argument Type(s)</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="a051df2e8379a7a94517621abf96e2d1c250d0c1" translate="yes" xml:space="preserve">
          <source>Argument strings to pass to trigger, each NULL-terminated</source>
          <target state="translated">트리거로 전달할 인수 문자열 (각 NULL로 종료 됨)</target>
        </trans-unit>
        <trans-unit id="3106eca9fcc5b17fbc0ab862b2b3e2e5d8ec1882" translate="yes" xml:space="preserve">
          <source>Arranges to save future query results to the file &lt;code&gt;filename&lt;/code&gt; or pipe future results to the shell command &lt;code&gt;command&lt;/code&gt;. If no argument is specified, the query output is reset to the standard output.</source>
          <target state="translated">향후 쿼리 결과를 파일 파일 &lt;code&gt;filename&lt;/code&gt; 으로 저장 하거나 향후 결과를 셸 명령 &lt;code&gt;command&lt;/code&gt; 파이프 하도록 정렬합니다 . 인수를 지정하지 않으면 조회 출력이 표준 출력으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7a061ed91f80bf08d4b0e706de1a73a36b812215" translate="yes" xml:space="preserve">
          <source>Array Comparisons</source>
          <target state="translated">배열 비교</target>
        </trans-unit>
        <trans-unit id="2cce75772b9783560b7ecdf1a652525e088ff999" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ALL (array)</source>
          <target state="translated">배열 비교 : ALL (배열)</target>
        </trans-unit>
        <trans-unit id="ebbce493c47b875446149a16fbeabd59af95b506" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ANY/SOME (array)</source>
          <target state="translated">배열 비교 : ANY / SOME (배열)</target>
        </trans-unit>
        <trans-unit id="266d7d8ad9ef21fb1cf43acafe88df1627794e31" translate="yes" xml:space="preserve">
          <source>Array Comparisons: IN</source>
          <target state="translated">배열 비교 : IN</target>
        </trans-unit>
        <trans-unit id="cb5525261d1827b03403d3e1f7d54e339ee3bdc7" translate="yes" xml:space="preserve">
          <source>Array Comparisons: NOT IN</source>
          <target state="translated">배열 비교 : NOT IN</target>
        </trans-unit>
        <trans-unit id="378bd5c012fe9a2d09b80c0502903a9f1a4e46ef" translate="yes" xml:space="preserve">
          <source>Array Functions and Operators</source>
          <target state="translated">배열 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="989d38553686cf9420b0efeacfb98e0cb0491104" translate="yes" xml:space="preserve">
          <source>Array element accessor. &lt;code&gt;subscript&lt;/code&gt; can be given in two forms: &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;start_index to end_index&lt;/code&gt;. The first form returns a single array element by its index. The second form returns an array slice by the range of indexes, including the elements that correspond to the provided &lt;code&gt;start_index&lt;/code&gt; and &lt;code&gt;end_index&lt;/code&gt;.</source>
          <target state="translated">배열 요소 접근 자. &lt;code&gt;subscript&lt;/code&gt; 는 &lt;code&gt;index&lt;/code&gt; 또는 &lt;code&gt;start_index to end_index&lt;/code&gt; 두 가지 형식으로 제공 될 수 있습니다 . 첫 번째 형식은 인덱스별로 단일 배열 요소를 반환합니다. 두 번째 형식은 제공된 &lt;code&gt;start_index&lt;/code&gt; 및 &lt;code&gt;end_index&lt;/code&gt; 에 해당하는 요소를 포함하여 인덱스 범위별로 배열 슬라이스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="88048034955012a6a9f12b6c23a529e19a83c1b1" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;WHERE&lt;/code&gt;-clause filter conditions for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">확장의 구성 테이블에 대한 &lt;code&gt;WHERE&lt;/code&gt; -clause 필터 조건의 배열. 없는 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01ffa4580cea8a6c482fb4eea9629be04c79e61e" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;regclass&lt;/code&gt; OIDs for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">확장의 구성 테이블에 대한 &lt;code&gt;regclass&lt;/code&gt; OID 배열. 없는 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24c2e81a77c22cd6c4b27ed6a767d8a3da693d5f" translate="yes" xml:space="preserve">
          <source>Array of item identifiers pointing to the actual items. Each entry is an (offset,length) pair. 4 bytes per item.</source>
          <target state="translated">실제 항목을 가리키는 항목 식별자의 배열입니다. 각 항목은 (오프셋, 길이) 쌍입니다. 항목 당 4 바이트</target>
        </trans-unit>
        <trans-unit id="be15b795f8a08c896c323efe48ed797caf42d6d4" translate="yes" xml:space="preserve">
          <source>Array of subscribed publication names. These reference the publications on the publisher server. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">구독 된 발행물 이름의 배열입니다. 이들은 발행자 서버의 발행물을 참조합니다. 출판물에 대한 자세한 내용 &lt;a href=&quot;logical-replication-publication&quot;&gt;은 30.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="31177effc11eb7035c25f786c3b9f262ea8dee25" translate="yes" xml:space="preserve">
          <source>Array: &amp;amp;&amp;amp;</source>
          <target state="translated">배열 : &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="24e29718edd609d75b45a77aa875138df131bbd7" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;</source>
          <target state="translated">배열 :&amp;gt;</target>
        </trans-unit>
        <trans-unit id="811842a370e6ca7314ad3ee641887ae43eed6200" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;=</source>
          <target state="translated">배열 :&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="736b98ce8f814e8462d7673c06a73e5d2921d61d" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;</source>
          <target state="translated">배열 : &amp;lt;</target>
        </trans-unit>
        <trans-unit id="72683d381cd2860b3b1a8eab0a2c5eedfb795924" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;&amp;gt;</source>
          <target state="translated">배열 : &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="397f0e2a9b9f910336a8ea8c6c32ba6704d652eb" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;=</source>
          <target state="translated">배열 : &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="5df64d9374ce5e9d00462533f6beea8afb43679c" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;@</source>
          <target state="translated">배열 : &amp;lt;@</target>
        </trans-unit>
        <trans-unit id="3fe38b2f63794530437e3485d0c38785ad75e487" translate="yes" xml:space="preserve">
          <source>Array: 1</source>
          <target state="translated">어레이 : 1</target>
        </trans-unit>
        <trans-unit id="d7d17f1eb33a5388e6bfb317a245a8c37e5b460a" translate="yes" xml:space="preserve">
          <source>Array: =</source>
          <target state="translated">배열 : =</target>
        </trans-unit>
        <trans-unit id="db0f2c477d3b5e5a1ea32beab72408f0ff3b2f71" translate="yes" xml:space="preserve">
          <source>Array: @&amp;gt;</source>
          <target state="translated">배열 : @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="150a65359d97d4ee8b8c087554e227e4e463443a" translate="yes" xml:space="preserve">
          <source>Array: ARRAY</source>
          <target state="translated">배열 : ARRAY</target>
        </trans-unit>
        <trans-unit id="4dcd3d1ce93d0ca2cb3e60332e931604f93cc026" translate="yes" xml:space="preserve">
          <source>Array: ARRAY &amp;amp;&amp;amp; ARRAY</source>
          <target state="translated">배열 : ARRAY &amp;amp;&amp;amp; ARRAY</target>
        </trans-unit>
        <trans-unit id="64b37c182a6bd42ba7b5eb841ce25916a3a3c807" translate="yes" xml:space="preserve">
          <source>Array: ARRAY &amp;lt;@ ARRAY</source>
          <target state="translated">배열 : ARRAY &amp;lt;@ ARRAY</target>
        </trans-unit>
        <trans-unit id="78d1bb5bc6001f266e8878cdac676402e49a8545" translate="yes" xml:space="preserve">
          <source>Array: ARRAY @&amp;gt; ARRAY</source>
          <target state="translated">배열 : ARRAY @&amp;gt; ARRAY</target>
        </trans-unit>
        <trans-unit id="5c09f59eadf2bb3b4328b3f453d0a6c85ef136cb" translate="yes" xml:space="preserve">
          <source>Array: IS NOT DISTINCT FROM</source>
          <target state="translated">배열 :에서 구별되지 않음</target>
        </trans-unit>
        <trans-unit id="4bc80d05bcc1cb0f4e5e941af2a29b9db0657f22" translate="yes" xml:space="preserve">
          <source>Array: NULL</source>
          <target state="translated">배열 : NULL</target>
        </trans-unit>
        <trans-unit id="d9bbda7ebf850fa729d9606dbdfd7d1f3599ec47" translate="yes" xml:space="preserve">
          <source>Array: array_append</source>
          <target state="translated">배열 : array_append</target>
        </trans-unit>
        <trans-unit id="af82c1377e93f02d0993b9aadeb7d8e17521a1bc" translate="yes" xml:space="preserve">
          <source>Array: array_cat</source>
          <target state="translated">배열 : array_cat</target>
        </trans-unit>
        <trans-unit id="243f29a4a2e10d2646f7903c1f4a2d39c2a3d0a4" translate="yes" xml:space="preserve">
          <source>Array: array_dims</source>
          <target state="translated">배열 : array_dims</target>
        </trans-unit>
        <trans-unit id="5beacc0ab51ffbcd3c4683bef89fb252cd5ecd4f" translate="yes" xml:space="preserve">
          <source>Array: array_fill</source>
          <target state="translated">배열 : array_fill</target>
        </trans-unit>
        <trans-unit id="0a700d1340312f7d432d241fb96c7d69e0d7cbc8" translate="yes" xml:space="preserve">
          <source>Array: array_length</source>
          <target state="translated">배열 : array_length</target>
        </trans-unit>
        <trans-unit id="e39f07efeb19c70308a1b05104d42f13e6750589" translate="yes" xml:space="preserve">
          <source>Array: array_lower</source>
          <target state="translated">배열 : array_lower</target>
        </trans-unit>
        <trans-unit id="55bec9b1ab2dd7b5615b888955aa1685d7d9176c" translate="yes" xml:space="preserve">
          <source>Array: array_ndims</source>
          <target state="translated">배열 : array_ndims</target>
        </trans-unit>
        <trans-unit id="6abfbc8e90ab3825fd22a987883a8130d8647c22" translate="yes" xml:space="preserve">
          <source>Array: array_position</source>
          <target state="translated">배열 : array_position</target>
        </trans-unit>
        <trans-unit id="dc8f46967ae5b46ce3023fe830845635cbddc3a2" translate="yes" xml:space="preserve">
          <source>Array: array_positions</source>
          <target state="translated">배열 : array_positions</target>
        </trans-unit>
        <trans-unit id="170bb418b8b592fa19a657e9b3372281a737a509" translate="yes" xml:space="preserve">
          <source>Array: array_prepend</source>
          <target state="translated">배열 : array_prepend</target>
        </trans-unit>
        <trans-unit id="23c081b8640d7683a9a9eb917682404db2a9d9cf" translate="yes" xml:space="preserve">
          <source>Array: array_remove</source>
          <target state="translated">배열 : array_remove</target>
        </trans-unit>
        <trans-unit id="0bb70da04daab39f1a179be9e60eceee76a3242d" translate="yes" xml:space="preserve">
          <source>Array: array_replace</source>
          <target state="translated">배열 : array_replace</target>
        </trans-unit>
        <trans-unit id="d1576bf750554857f928eff64376711410524f13" translate="yes" xml:space="preserve">
          <source>Array: array_to_string</source>
          <target state="translated">배열 : array_to_string</target>
        </trans-unit>
        <trans-unit id="f1d1655c390920a19930233b2ba0cbcc608406ea" translate="yes" xml:space="preserve">
          <source>Array: array_upper</source>
          <target state="translated">배열 : array_upper</target>
        </trans-unit>
        <trans-unit id="f07fdded6b4337ac290721bed8d559d25ce497d7" translate="yes" xml:space="preserve">
          <source>Array: cardinality</source>
          <target state="translated">배열 : 카디널리티</target>
        </trans-unit>
        <trans-unit id="4d56c61f6754af386d1ad55522ee718a6d173e5b" translate="yes" xml:space="preserve">
          <source>Array: select * from unnest as x</source>
          <target state="translated">배열 : unnest에서 *를 x로 선택</target>
        </trans-unit>
        <trans-unit id="b45177789238b533ec64ce75c721f78be3e3490d" translate="yes" xml:space="preserve">
          <source>Array: string_to_array</source>
          <target state="translated">배열 : string_to_array</target>
        </trans-unit>
        <trans-unit id="1b1aca770dcf002c23a04ca801aee9819ce75321" translate="yes" xml:space="preserve">
          <source>Array: unnest</source>
          <target state="translated">배열 : unnest</target>
        </trans-unit>
        <trans-unit id="8cbda94f98fa6831a0fab631dfd36cfb855d6147" translate="yes" xml:space="preserve">
          <source>Array: ||</source>
          <target state="translated">배열 : ||</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7ff0d6e651880818d49ef5a4d284aa7441e9760b" translate="yes" xml:space="preserve">
          <source>Arrays are not sets; searching for specific array elements can be a sign of database misdesign. Consider using a separate table with a row for each item that would be an array element. This will be easier to search, and is likely to scale better for a large number of elements.</source>
          <target state="translated">배열은 설정되지 않습니다. 특정 배열 요소를 검색하면 데이터베이스 디자인이 잘못 될 수 있습니다. 배열 요소가 될 각 항목에 대해 행이있는 별도의 테이블을 사용하십시오. 이것은 검색하기 쉬울 것이며 많은 요소에 대해 더 잘 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86a798d810f86ee1f57761b0f4f378302a450ab0" translate="yes" xml:space="preserve">
          <source>As PostgreSQL stands, this doesn't occur. Large objects are treated as objects in their own right; a table entry can reference a large object by OID, but there can be multiple table entries referencing the same large object OID, so the system doesn't delete the large object just because you change or remove one such entry.</source>
          <target state="translated">PostgreSQL이 의미하는 것처럼 이것은 일어나지 않습니다. 큰 물체는 그 자체로 물체로 취급됩니다. 테이블 항목은 OID로 큰 개체를 참조 할 수 있지만 동일한 큰 개체 OID를 참조하는 여러 테이블 항목이있을 수 있으므로 시스템은 그러한 항목 중 하나를 변경하거나 제거하더라도 큰 개체를 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96ee90014e2be91ae6a2c0ff19bfbdac86380915" translate="yes" xml:space="preserve">
          <source>As a consequence, it is unwise to use functions with side effects as part of complex expressions. It is particularly dangerous to rely on side effects or evaluation order in &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses, since those clauses are extensively reprocessed as part of developing an execution plan. Boolean expressions (&lt;code&gt;AND&lt;/code&gt;/&lt;code&gt;OR&lt;/code&gt;/&lt;code&gt;NOT&lt;/code&gt; combinations) in those clauses can be reorganized in any manner allowed by the laws of Boolean algebra.</source>
          <target state="translated">결과적으로 부작용이있는 함수를 복잡한 표현의 일부로 사용하는 것은 현명하지 않습니다. &lt;code&gt;WHERE&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절 에서 부작용 또는 평가 순서에 의존하는 것이 특히 위험합니다. 이러한 절은 실행 계획 개발의 일부로 광범위하게 재 처리되기 때문입니다. 해당 절의 부울 표현식 ( &lt;code&gt;AND&lt;/code&gt; / &lt;code&gt;OR&lt;/code&gt; / &lt;code&gt;NOT&lt;/code&gt; 조합)은 부울 대 수법에 의해 허용되는 방식으로 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00aa4eef1a46e7541eb69499cd40ccfaa63754a" translate="yes" xml:space="preserve">
          <source>As a convenience, there is a program you can execute from the shell to create new databases, &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">편의상 쉘에서 실행하여 새 데이터베이스 &lt;code&gt;createdb&lt;/code&gt; 을 실행할 수있는 프로그램이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d25ac520ed3e5e990af0f244faf971c940fd4e71" translate="yes" xml:space="preserve">
          <source>As a general rule, if you get spurious parser errors for commands that contain any of the listed key words as an identifier you should try to quote the identifier to see if the problem goes away.</source>
          <target state="translated">일반적으로 나열된 키워드를 식별자로 포함하는 명령에 대해 가짜 파서 오류가 발생하면 식별자를 인용하여 문제가 해결되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="95a9f6ed53fa85650318ffc030c2493caa298423" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed.</source>
          <target state="translated">이러한 유형의 오류에 대한 부분적인 보호로 가변 길이 또는 널 입력 가능 필드를 C 컴파일러에 직접 표시해서는 안됩니다. 이는 &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (여기서 &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; 은 정의되지 않은 기호 임) 로 래핑하여 수행됩니다 . 이것은 C 코드가 존재하지 않거나 다른 오프셋에있을 수있는 필드에 부주의하게 액세스하는 것을 방지합니다. 잘못된 행 생성을 방지하기 위해 &lt;code&gt;pg_attribute&lt;/code&gt; 에서 Null이 불가능해야하는 모든 열을 표시해야합니다 . 부트 스트랩 코드는 자동으로 카탈로그 열을 &lt;code&gt;NOT NULL&lt;/code&gt; 로 표시 합니다.고정 너비이고 앞에 널 입력 가능 열이없는 경우. 이 규칙이 적절하지 않은 경우 필요에 따라 &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; 및 &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; 주석을 사용하여 올바른 표시를 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a80a71669f88eae465ab66545f1b21816ccdfcd" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed. But note that &lt;code&gt;NOT NULL&lt;/code&gt; constraints are only enforced in the executor, not against tuples that are generated by random C code, so care is still needed when manually creating or updating catalog rows.</source>
          <target state="translated">이러한 유형의 오류에 대한 부분 보호 수단으로 가변 길이 또는 널 입력 가능 필드는 C 컴파일러에 직접 표시되지 않아야합니다. 이것은 &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; ( &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; 은 정의되지 않은 기호) 로 랩핑하여 수행됩니다 . 이렇게하면 C 코드가 존재하지 않거나 다른 오프셋에있을 수있는 필드에 부주의하게 액세스하지 못합니다. 잘못된 행을 만들지 않도록 독립적 인 보호를 위해 null이 아닌 모든 열을 &lt;code&gt;pg_attribute&lt;/code&gt; 에 표시해야 합니다. 부트 스트랩 코드는 카탈로그 열을 &lt;code&gt;NOT NULL&lt;/code&gt; 로 자동 표시 합니다.너비가 고정되어 있고 널 입력 가능 열이 앞에 있지 않은 경우 이 규칙이 적절하지 않은 경우 필요에 따라 &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; 및 &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; 주석을 사용하여 올바른 표시를 강제 할 수 있습니다 . 그러나 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건은 임의의 C 코드로 생성 된 튜플에 대한 것이 아니라 실행 프로그램에서만 시행되므로 카탈로그 행을 수동으로 만들거나 업데이트 할 때는 여전히주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="47b0b4c39b5ede77f7f7daa11745dc4255dd8757" translate="yes" xml:space="preserve">
          <source>As a partitioned table does not have any data directly, attempts to use &lt;code&gt;TRUNCATE&lt;/code&gt;&lt;code&gt;ONLY&lt;/code&gt; on a partitioned table will always return an error.</source>
          <target state="translated">파티션 된 테이블에 직접 데이터가 없으므로 파티션 된 테이블에서 &lt;code&gt;TRUNCATE&lt;/code&gt; &lt;code&gt;ONLY&lt;/code&gt; 만 사용 하면 항상 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ff2aae32fe6bdd83d73023e8256b2cd3508deffa" translate="yes" xml:space="preserve">
          <source>As a result, you cannot create additional indexes that exist solely on the standby, nor statistics that exist solely on the standby. If these administration commands are needed, they should be executed on the primary, and eventually those changes will propagate to the standby.</source>
          <target state="translated">결과적으로 대기에만 존재하는 추가 인덱스 나 대기에만 존재하는 통계를 작성할 수 없습니다. 이러한 관리 명령이 필요한 경우 기본 명령을 실행해야하며 결국 이러한 변경 사항이 대기로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="94f064aeef44b2237a7b84960c6af3e282dc0f3d" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, &lt;code&gt;queryid&lt;/code&gt; values can be assumed to be stable and comparable only so long as the underlying server version and catalog metadata details stay exactly the same. Two servers participating in replication based on physical WAL replay can be expected to have identical &lt;code&gt;queryid&lt;/code&gt; values for the same query. However, logical replication schemes do not promise to keep replicas identical in all relevant details, so &lt;code&gt;queryid&lt;/code&gt; will not be a useful identifier for accumulating costs across a set of logical replicas. If in doubt, direct testing is recommended.</source>
          <target state="translated">일반적으로 &lt;code&gt;queryid&lt;/code&gt; 값은 기본 서버 버전과 카탈로그 메타 데이터 세부 사항이 동일하게 유지되는 한 안정적이고 비교 가능한 것으로 가정 할 수 있습니다. 물리적 WAL 재생을 기반으로 복제에 참여하는 두 서버 는 동일한 쿼리에 대해 동일한 &lt;code&gt;queryid&lt;/code&gt; 값 을 가질 것으로 예상 할 수 있습니다 . 그러나 논리적 복제 체계는 모든 관련 세부 사항에서 복제본을 동일하게 유지한다고 약속하지 않으므로 &lt;code&gt;queryid&lt;/code&gt; 는 일련의 논리적 복제본에서 비용을 축적하는 데 유용한 식별자가 아닙니다. 의심스러운 경우 직접 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="84cdd8b719c9d8f34c7f1d4c72b4f9ce0fe4768b" translate="yes" xml:space="preserve">
          <source>As a safety device, an aggressive vacuum scan will occur for any table whose multixact-age is greater than &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;. Aggressive vacuum scans will also occur progressively for all tables, starting with those that have the oldest multixact-age, if the amount of used member storage space exceeds the amount 50% of the addressable storage space. Both of these kinds of aggressive scans will occur even if autovacuum is nominally disabled.</source>
          <target state="translated">안전 장치로서 multixact-age가 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; 보다 큰 테이블에 대해 적극적인 진공 스캔이 발생합니다 . 사용 된 멤버 스토리지 공간의 양이 주소 지정 가능한 스토리지 공간의 50 %를 초과하는 경우 가장 오래된 멀티 랙스 연령을 가진 테이블부터 시작하여 모든 테이블에 대해 점진적 진공 스캔이 점진적으로 발생합니다. autovacuum이 명목상 비활성화되어 있어도 이러한 종류의 공격적인 스캔이 모두 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2b18e01bd003b97bb977c2d73b7cfc8923da784c" translate="yes" xml:space="preserve">
          <source>As a sanity check, &lt;code&gt;seg&lt;/code&gt; rejects intervals with the lower bound greater than the upper, for example &lt;code&gt;5 .. 2&lt;/code&gt;.</source>
          <target state="translated">온 전성 검사로서 &lt;code&gt;seg&lt;/code&gt; 는 하한이 상한보다 큰 구간을 거부합니다 (예 : &lt;code&gt;5 .. 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e65f5f3343ba0b45af614f4022a156a7c42809b5" translate="yes" xml:space="preserve">
          <source>As a simple example, here is how to create a policy on the &lt;code&gt;account&lt;/code&gt; relation to allow only members of the &lt;code&gt;managers&lt;/code&gt; role to access rows, and only rows of their accounts:</source>
          <target state="translated">간단한 예로, &lt;code&gt;managers&lt;/code&gt; 역할의 구성원 만 자신의 계정 행에만 액세스 할 수 있도록 &lt;code&gt;account&lt;/code&gt; 관계 에 대한 정책을 만드는 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05f66f343edd96e743819d53bcce1284f5be3d29" translate="yes" xml:space="preserve">
          <source>As a special exception to the general principle that the structures must match, an array may contain a primitive value:</source>
          <target state="translated">구조가 일치해야한다는 일반적인 원칙에 대한 특별한 예외로 배열은 기본 값을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dafe6722800c895e7fb824e24cdc22785e38231" translate="yes" xml:space="preserve">
          <source>As a workaround to allow PostgreSQL to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses under a non-C locale, several custom operator classes exist. These allow the creation of an index that performs a strict character-by-character comparison, ignoring locale comparison rules. Refer to &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; for more information. Another approach is to create indexes using the &lt;code&gt;C&lt;/code&gt; collation, as discussed in &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL이 C가 아닌 로케일에서 &lt;code&gt;LIKE&lt;/code&gt; 절 과 함께 색인을 사용할 수있게하는 임시 해결책으로 여러 사용자 정의 연산자 클래스가 있습니다. 로케일 비교 규칙을 무시하고 엄격한 문자 별 비교를 수행하는 색인을 작성할 수 있습니다. 자세한 정보는 &lt;a href=&quot;indexes-opclass&quot;&gt;11.10 절&lt;/a&gt; 을 참조하십시오. 다른 접근법은 &lt;a href=&quot;collation&quot;&gt;23.2 절&lt;/a&gt; 에서 논의 된 바와 같이 &lt;code&gt;C&lt;/code&gt; 데이터 정렬을 사용하여 인덱스를 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="38727bf2878bdfdd88e444d27be405dc29a205b6" translate="yes" xml:space="preserve">
          <source>As above, but import only the two tables &lt;code&gt;actors&lt;/code&gt; and &lt;code&gt;directors&lt;/code&gt; (if they exist):</source>
          <target state="translated">위와 같이 두 테이블 &lt;code&gt;actors&lt;/code&gt; 와 &lt;code&gt;directors&lt;/code&gt; 만 가져옵니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="fc0ab2ce564629da1cade53f45b45700cfa6ba3f" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-D&lt;/code&gt; option, you can set the environment variable &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-D&lt;/code&gt; 옵션 의 대안으로 환경 변수 &lt;code&gt;PGDATA&lt;/code&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="431e9cdc01712eabff181abecb6b83e3af47f9a9" translate="yes" xml:space="preserve">
          <source>As an alternative, it is sometimes more convenient to create the new table outside the partition structure, and make it a proper partition later. This allows the data to be loaded, checked, and transformed prior to it appearing in the partitioned table:</source>
          <target state="translated">대안으로 파티션 구조 외부에 새 테이블을 작성하고 나중에 적절한 파티션으로 만드는 것이 더 편리한 경우가 있습니다. 이를 통해 분할 된 테이블에 데이터가 나타나기 전에 데이터를로드, 확인 및 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbbe816df8235daf5a726cf6177c485cd14e8ef4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Example 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="translated">이러한 함수에 의해 생성 된 출력을 사용하는 예로서 &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Example 9.1&lt;/a&gt; 은 &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; 의 출력을 테이블 데이터의 표 형식 변환이 포함 된 HTML 문서 로 변환하는 XSLT 스타일 시트를 보여줍니다 . 유사한 방식으로 이러한 함수의 결과를 다른 XML 기반 형식으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e3b2ce01a4421ab4c72defc488724bdaa1c1a4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Figure 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="translated">이러한 함수에 의해 생성 된 출력을 사용하는 예로서, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;그림 9.1&lt;/a&gt; 은 &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; 의 출력을 테이블 데이터의 테이블 형식 변환을 포함하는 HTML 문서 로 변환하는 XSLT 스타일 시트를 보여줍니다 . 비슷한 방식으로 이러한 함수의 결과를 다른 XML 기반 형식으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1f3783f0bee859f0f7fd07d8117b96c39c5dbf" translate="yes" xml:space="preserve">
          <source>As an example we will create a configuration &lt;code&gt;pg&lt;/code&gt;, starting by duplicating the built-in &lt;code&gt;english&lt;/code&gt; configuration:</source>
          <target state="translated">예를 들어 내장 &lt;code&gt;english&lt;/code&gt; 구성 을 복제하여 구성 &lt;code&gt;pg&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="faf1ed368ea36c292232738719a6fc50ce56d002" translate="yes" xml:space="preserve">
          <source>As an example, &lt;code&gt;CET-1CEST,M3.5.0,M10.5.0/3&lt;/code&gt; describes current (as of 2020) timekeeping practice in Paris. This specification says that standard time has the abbreviation &lt;code&gt;CET&lt;/code&gt; and is one hour ahead (east) of UTC; daylight savings time has the abbreviation &lt;code&gt;CEST&lt;/code&gt; and is implicitly two hours ahead of UTC; daylight savings time begins on the last Sunday in March at 2AM CET and ends on the last Sunday in October at 3AM CEST.</source>
          <target state="translated">예를 들어, &lt;code&gt;CET-1CEST,M3.5.0,M10.5.0/3&lt;/code&gt; 은 파리의 현재 (2020 년 현재) 시간 관리 관행을 설명합니다. 이 사양은 표준 시간에 약어 &lt;code&gt;CET&lt;/code&gt; 가 있고 UTC보다 한 시간 빠릅니다 (동쪽). 일광 절약 시간은 약어 &lt;code&gt;CEST&lt;/code&gt; 를 가지며 암시 적으로 UTC보다 2 시간 빠릅니다. 일광 절약 시간은 3 월 마지막 일요일 오전 2시 (CET)에 시작하여 10 월 마지막 일요일 오전 3시 (CEST)에 끝납니다.</target>
        </trans-unit>
        <trans-unit id="75dd3c213ab262bc0285b838849480821b38de49" translate="yes" xml:space="preserve">
          <source>As an example, consider a table &lt;code&gt;mytab&lt;/code&gt;, initially containing:</source>
          <target state="translated">예를 들어 , 초기에 다음을 포함하는 &lt;code&gt;mytab&lt;/code&gt; 테이블을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="90c5a9e56ec693f6e6129ec5a5d9bccec6f61c69" translate="yes" xml:space="preserve">
          <source>As an example, if an &lt;code&gt;UPDATE&lt;/code&gt; is issued, then the &lt;code&gt;ALL&lt;/code&gt; policy will be applicable both to what the &lt;code&gt;UPDATE&lt;/code&gt; will be able to select as rows to be updated (applying the &lt;code&gt;USING&lt;/code&gt; expression), and to the resulting updated rows, to check if they are permitted to be added to the table (applying the &lt;code&gt;WITH CHECK&lt;/code&gt; expression, if defined, and the &lt;code&gt;USING&lt;/code&gt; expression otherwise). If an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command attempts to add rows to the table that do not pass the &lt;code&gt;ALL&lt;/code&gt; policy's &lt;code&gt;WITH CHECK&lt;/code&gt; expression, the entire command will be aborted.</source>
          <target state="translated">예를 들어, &lt;code&gt;UPDATE&lt;/code&gt; 가 발행되면 &lt;code&gt;ALL&lt;/code&gt; 정책은 &lt;code&gt;UPDATE&lt;/code&gt; 가 업데이트 할 행 ( &lt;code&gt;USING&lt;/code&gt; 표현식 적용)으로 선택할 수있는 항목 과 결과로 업데이트 된 행에 모두 적용 가능한지 여부에 적용됩니다. 정의 된 경우 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식을 적용하고 그렇지 않으면 &lt;code&gt;USING&lt;/code&gt; 표현식을 적용하여 테이블에 추가 할 수 있습니다 . 경우 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 의 명령 시도가 통과하지 않는 테이블에 행을 추가 &lt;code&gt;ALL&lt;/code&gt; 의 정책의 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현, 전체 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="939804fcee1e20d77d25bd0bcffade6b732e6187" translate="yes" xml:space="preserve">
          <source>As an example, suppose that user &lt;code&gt;miriam&lt;/code&gt; creates table &lt;code&gt;mytable&lt;/code&gt; and does:</source>
          <target state="translated">예를 들어, &lt;code&gt;miriam&lt;/code&gt; 사용자 가 &lt;code&gt;mytable&lt;/code&gt; 테이블을 작성 하고 다음을 수행 한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dea5d7bb31aa71940b0966bc7e8fd7ee8f021dd" translate="yes" xml:space="preserve">
          <source>As an example, the full definition of the built-in TPC-B-like transaction is:</source>
          <target state="translated">예를 들어, 내장 된 TPC-B와 유사한 트랜잭션의 전체 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfc78f7c719c6f7419eadd4a007ca5004840837d" translate="yes" xml:space="preserve">
          <source>As an example, we can find the highest low-temperature reading anywhere with:</source>
          <target state="translated">예를 들어, 다음을 통해 어디에서나 가장 높은 저온 판독 값을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">예로서:</target>
        </trans-unit>
        <trans-unit id="b50a75f7dfe3aa7965ef5d4e176cb3485c343ba0" translate="yes" xml:space="preserve">
          <source>As an extension to the SQL standard, PostgreSQL allows there to be just one escape-double-quote separator, in which case the third regular expression is taken as empty; or no separators, in which case the first and third regular expressions are taken as empty.</source>
          <target state="translated">SQL 표준의 확장으로 PostgreSQL은 단 하나의 이스케이프-큰 따옴표 구분 기호를 사용할 수 있으며,이 경우 세 번째 정규식은 비어 있습니다. 또는 구분 기호가없는 경우 첫 번째 및 세 번째 정규식이 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fa9c14e462aa9732a24d51e00bd5d77bf7a81cc2" translate="yes" xml:space="preserve">
          <source>As another example, if one often does queries like:</source>
          <target state="translated">다른 예로, 다음과 같은 쿼리를 자주하는 경우 :</target>
        </trans-unit>
        <trans-unit id="a99c411c58f58d7e7474741b999e04e5e53fd82b" translate="yes" xml:space="preserve">
          <source>As before, however, PostgreSQL does not enforce the size restriction in any case.</source>
          <target state="translated">그러나 이전과 마찬가지로 PostgreSQL은 어떤 경우에도 크기 제한을 시행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c4c55629e9060b4cdfbd0fb1ea96b264210b4b6" translate="yes" xml:space="preserve">
          <source>As before, the estimated number of rows is just the product of this with the cardinality of &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">이전과 마찬가지로, 예상 행 수는 카디널리티 &lt;code&gt;tenk1&lt;/code&gt; 의 곱 에 불과합니다 .</target>
        </trans-unit>
        <trans-unit id="7a87fbf380bd12f56579ba8b09d2dfca1e87a7aa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;, there are various situations in which subexpressions of an expression are evaluated at different times, so that the principle that &amp;ldquo;&lt;code&gt;CASE&lt;/code&gt; evaluates only necessary subexpressions&amp;rdquo; is not ironclad. For example a constant &lt;code&gt;1/0&lt;/code&gt; subexpression will usually result in a division-by-zero failure at planning time, even if it's within a &lt;code&gt;CASE&lt;/code&gt; arm that would never be entered at run time.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;4.2.14 절&lt;/a&gt; 에서 설명 된 것처럼 , 표현의 부분 발현이 서로 다른 시간에 평가되는 다양한 상황이 있기 때문에&amp;ldquo; &lt;code&gt;CASE&lt;/code&gt; 는 필요한 부분 발현 만 평가한다&amp;rdquo;는 원칙 은 철폐되지 않는다. 예를 들어, 상수 &lt;code&gt;1/0&lt;/code&gt; 하위 표현식은 실행시 절대 입력되지 않는 &lt;code&gt;CASE&lt;/code&gt; 암 내에 있더라도 계획시 0으로 나누기 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="518e3cc29b2ad22029595abb39bdf434ee471900" translate="yes" xml:space="preserve">
          <source>As described in the previous section, transaction commit is normally &lt;em&gt;synchronous&lt;/em&gt;: the server waits for the transaction's WAL records to be flushed to permanent storage before returning a success indication to the client. The client is therefore guaranteed that a transaction reported to be committed will be preserved, even in the event of a server crash immediately after. However, for short transactions this delay is a major component of the total transaction time. Selecting asynchronous commit mode means that the server returns success as soon as the transaction is logically completed, before the WAL records it generated have actually made their way to disk. This can provide a significant boost in throughput for small transactions.</source>
          <target state="translated">이전 섹션에서 설명한 것처럼 트랜잭션 커밋은 일반적으로 &lt;em&gt;동 기적입니다&lt;/em&gt; . 서버는 트랜잭션의 WAL 레코드가 영구 저장소로 비워 질 때까지 기다렸다가 성공 표시를 클라이언트에 반환합니다. 따라서 클라이언트는 커밋 된 것으로보고 된 트랜잭션이 서버 충돌 직후에도 보존되도록 보장합니다. 그러나 짧은 트랜잭션의 경우이 지연은 총 트랜잭션 시간의 주요 구성 요소입니다. 비동기 커밋 모드를 선택하면 트랜잭션이 논리적으로 완료 되 자마자 생성 된 WAL 레코드가 실제로 디스크로 이동하기 전에 서버가 성공을 반환합니다. 이는 소규모 트랜잭션의 처리량을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64a53cc76e5b39051f25182477eec0422ea4a682" translate="yes" xml:space="preserve">
          <source>As explained above, it is possible to create indexes on partitioned tables and they are applied automatically to the entire hierarchy. This is very convenient, as not only the existing partitions will become indexed, but also any partitions that are created in the future will. One limitation is that it's not possible to use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; qualifier when creating such a partitioned index. To overcome long lock times, it is possible to use &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; the partitioned table; such an index is marked invalid, and the partitions do not get the index applied automatically. The indexes on partitions can be created separately using &lt;code&gt;CONCURRENTLY&lt;/code&gt;, and later &lt;em&gt;attached&lt;/em&gt; to the index on the parent using &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt;. Once indexes for all partitions are attached to the parent index, the parent index is marked valid automatically. Example:</source>
          <target state="translated">위에서 설명한 것처럼 분할 된 테이블에 인덱스를 만들 수 있으며 전체 계층에 자동으로 적용됩니다. 기존 파티션뿐만 아니라 향후에 생성 될 파티션도 색인화되므로 매우 편리합니다. 한 가지 제한 사항은 파티션 된 인덱스를 작성할 때 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 규정 자를 사용할 수 없다는 것 입니다. 긴 잠금 시간을 극복하기 위해 파티션 된 테이블 &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; 을 사용할 수 있습니다 . 이러한 인덱스는 유효하지 않은 것으로 표시되며 파티션은 인덱스가 자동으로 적용되지 않습니다. 파티션의 인덱스를 별도로 사용하여 만들 수 &lt;code&gt;CONCURRENTLY&lt;/code&gt; , 나중에 &lt;em&gt;부착&lt;/em&gt; 하여 상위의 인덱스 &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt; . 모든 파티션의 인덱스가 상위 인덱스에 연결되면 상위 인덱스가 자동으로 유효하게 표시됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="fb2dc582124a2fe2747429c6ba796f17d561c7c2" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;, the default privileges for any object type normally grant all grantable permissions to the object owner, and may grant some privileges to &lt;code&gt;PUBLIC&lt;/code&gt; as well. However, this behavior can be changed by altering the global default privileges with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;ddl-priv&quot;&gt;5.7 절&lt;/a&gt; 에서 설명한 것처럼 , 모든 객체 유형에 대한 기본 권한은 일반적으로 객체 소유자에게 부여 가능한 모든 권한을 부여하며 &lt;code&gt;PUBLIC&lt;/code&gt; 에도 일부 권한을 부여 할 수 있습니다. 그러나 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 로 전역 기본 권한을 변경하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cfc29a245774c7f93be3cd482cd2720e2efb253" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt;, functional dependencies are very cheap and efficient type of statistics, but their main limitation is their global nature (only tracking dependencies at the column level, not between individual column values).</source>
          <target state="translated">&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;70.2.1 절&lt;/a&gt; 에서 설명 했듯이 , 기능적 종속성은 매우 저렴하고 효율적인 통계 유형이지만 주요 제한 사항은 전역 적 특성입니다 (개별 열 값이 아닌 열 수준에서 종속성 만 추적).</target>
        </trans-unit>
        <trans-unit id="c5ba1476be535d17f697ff078bc8840ec5998688" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, the planner can determine cardinality of &lt;code&gt;t&lt;/code&gt; using the number of pages and rows obtained from &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;planner-stats&quot;&gt;14.2 절&lt;/a&gt; 에서 설명한대로 플래너는 &lt;code&gt;pg_class&lt;/code&gt; 에서 얻은 페이지 및 행 수를 사용하여 &lt;code&gt;t&lt;/code&gt; 의 카디널리티를 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39801241473f144107571af31829d77f27364c9d" translate="yes" xml:space="preserve">
          <source>As far as the operator class is concerned, returning &lt;code&gt;true&lt;/code&gt; indicates that deduplication is safe (or safe for the collation whose OID was passed to its &lt;code&gt;equalimage&lt;/code&gt; function). However, the core code will only deem deduplication safe for an index when &lt;em&gt;every&lt;/em&gt; indexed column uses an operator class that registers an &lt;code&gt;equalimage&lt;/code&gt; function, and each function actually returns &lt;code&gt;true&lt;/code&gt; when called.</source>
          <target state="translated">연산자 클래스와 관련하여 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 중복 제거가 안전함을 나타냅니다 (또는 OID가 &lt;code&gt;equalimage&lt;/code&gt; 함수 에 전달 된 데이터 정렬에 대해 안전함 ). 그러나 핵심 코드는 &lt;em&gt;모든&lt;/em&gt; 인덱싱 된 열이 &lt;code&gt;equalimage&lt;/code&gt; 함수 를 등록하는 연산자 클래스를 사용 하고 각 함수가 호출 될 때 실제로 &lt;code&gt;true&lt;/code&gt; 를 반환하는 경우 에만 인덱스에 대해 중복 제거가 안전한 것으로 간주 합니다 .</target>
        </trans-unit>
        <trans-unit id="149ce91ff7ffadae424c16cab2b4c0512100eae4" translate="yes" xml:space="preserve">
          <source>As in basic &lt;code&gt;tsquery&lt;/code&gt; input, weight(s) can be attached to each lexeme to restrict it to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes of those weight(s). For example:</source>
          <target state="translated">기본 &lt;code&gt;tsquery&lt;/code&gt; 입력에서와 같이 가중치는 각 가중치에 연결되어 해당 가중치의 &lt;code&gt;tsvector&lt;/code&gt; 텍스쳐 만 일치하도록 제한 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c139aca10977b17d5102cc7674b71010f5c568f" translate="yes" xml:space="preserve">
          <source>As is standard in SQL, all functions return NULL, if any of the arguments are NULL. This may create security risks on careless usage.</source>
          <target state="translated">SQL의 표준과 같이 모든 함수는 인수가 NULL 인 경우 NULL을 리턴합니다. 부주의하게 사용하면 보안 위험이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="585d0521870959cf15a89091a2347acd4003a598" translate="yes" xml:space="preserve">
          <source>As is typical of client/server applications, the client and the server can be on different hosts. In that case they communicate over a TCP/IP network connection. You should keep this in mind, because the files that can be accessed on a client machine might not be accessible (or might only be accessible using a different file name) on the database server machine.</source>
          <target state="translated">일반적인 클라이언트 / 서버 응용 프로그램과 마찬가지로 클라이언트와 서버는 다른 호스트에있을 수 있습니다. 이 경우 TCP / IP 네트워크 연결을 통해 통신합니다. 클라이언트 시스템에서 액세스 할 수있는 파일은 데이터베이스 서버 시스템에서 액세스 할 수 없거나 다른 파일 이름으로 만 액세스 할 수 있으므로이 점을 명심해야합니다.</target>
        </trans-unit>
        <trans-unit id="29fce103d97e5fc966f97584895b606dc9b97769" translate="yes" xml:space="preserve">
          <source>As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. If this value is specified without units, it is taken as megabytes. The default is 80 MB. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WAL 디스크 사용량이이 설정 아래로 유지되는 한, 이전 WAL 파일은 제거되지 않고 체크 포인트에서 나중에 사용하기 위해 항상 재활용됩니다. 이는 대량 배치 작업을 실행할 때와 같이 WAL 사용량의 급증을 처리 할 수 ​​있도록 충분한 WAL 공간을 확보하기 위해 사용할 수 있습니다. 이 값을 단위없이 지정하면 메가 바이트로 간주됩니다. 기본값은 80MB입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="935b68a13a63015aa5e693b61464b2a9c3100546" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, each (active) subscription receives changes from a replication slot on the remote (publishing) side. Normally, the remote replication slot is created automatically when the subscription is created using &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; and it is dropped automatically when the subscription is dropped using &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt;. In some situations, however, it can be useful or necessary to manipulate the subscription and the underlying replication slot separately. Here are some scenarios:</source>
          <target state="translated">앞에서 언급했듯이 각 (활성) 구독은 원격 (게시) 쪽의 복제 슬롯에서 변경 사항을 수신합니다. 일반적으로 원격 복제 슬롯은 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 을 사용하여 구독을 만들면 자동으로 생성 되고 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 을 사용하여 구독을 삭제하면 자동으로 삭제됩니다 . 그러나 일부 상황에서는 구독과 기본 복제 슬롯을 개별적으로 조작하는 것이 유용하거나 필요할 수 있습니다. 몇 가지 시나리오는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d35d01797be09599719c5fbe0e98e1d8b777874" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;, Serializable transactions are just Repeatable Read transactions which add nonblocking monitoring for dangerous patterns of read/write conflicts. When a pattern is detected which could cause a cycle in the apparent order of execution, one of the transactions involved is rolled back to break the cycle.</source>
          <target state="translated">&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;13.2.3 절&lt;/a&gt; 에서 언급했듯이 , 직렬화 가능 트랜잭션은 위험한 읽기 / 쓰기 충돌 패턴에 대한 비 차단 모니터링을 추가하는 반복 가능한 읽기 트랜잭션입니다. 명백한 실행 순서로주기를 유발할 수있는 패턴이 감지되면 관련된 트랜잭션 중 하나가 롤백되어주기를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="820f9f6df5cbde09a17525e7847d0d2dfe09b2c4" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/common/toast_internals.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="translated">언급했듯이 여러 유형의 TOAST 포인터 데이텀이 있습니다. 가장 오래되고 가장 일반적인 유형은 TOAST 포인터 데이텀 자체를 포함하는 테이블과는 별개이지만 연관된 &lt;em&gt;TOAST 테이블에&lt;/em&gt; 저장된 라인 외부 데이터에 대한 포인터입니다. 이러한 &lt;em&gt;온 디스크&lt;/em&gt; 포인터 데이텀은 디스크에 저장할 튜플이 너무 커서있는 그대로 저장할 수 없을 때 TOAST 관리 코드 ( &lt;code&gt;access/common/toast_internals.c&lt;/code&gt; )에 의해 생성됩니다 . 자세한 내용은 &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;섹션 68.2.1에 나와 있습니다.&lt;/a&gt;. 또는 TOAST 포인터 데이텀에는 메모리의 다른 곳에 나타나는 라인 외부 데이터에 대한 포인터가 포함될 수 있습니다. 이러한 데이터는 반드시 수명이 짧고 디스크에 나타나지 않지만 대용량 데이터 값의 복사 및 중복 처리를 방지하는 데 매우 유용합니다. 자세한 내용은 &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;섹션 68.2.2에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7967f9ae1b2dfb5df2376dc5e14f007c840b5d2" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="translated">언급 한 바와 같이 여러 유형의 TOAST 포인터 데이텀이 있습니다. 가장 오래되고 가장 일반적인 유형은 TOAST 포인터 데이텀 자체를 포함하는 테이블과는 별개이지만 &lt;em&gt;TOAST 테이블에&lt;/em&gt; 저장된 외부 데이터에 대한 포인터입니다. 이러한 &lt;em&gt;온 디스크&lt;/em&gt; 포인터 데이텀은 디스크에 저장 될 튜플이 너무 커서 그대로 저장 될 수없는 TOAST 관리 코드 ( &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt; )에 의해 작성됩니다 . 자세한 내용 &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;은 68.2.1 절에 나와 있습니다.&lt;/a&gt;. 또는 TOAST 포인터 데이텀에는 메모리의 다른 곳에 나타나는 라인 외부 데이터에 대한 포인터가 포함될 수 있습니다. 이러한 데이텀은 반드시 수명이 짧고 디스크에 표시되지 않지만 대용량 데이터 값의 복사 및 중복 처리를 피하는 데 매우 유용합니다. 자세한 내용 &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;은 68.2.2 절에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e83c3b33db2892f30f5c07aab1da708113577a83" translate="yes" xml:space="preserve">
          <source>As noted above, if the server crashes during the backup it may not be possible to restart until the &lt;code&gt;backup_label&lt;/code&gt; file has been manually deleted from the &lt;code&gt;PGDATA&lt;/code&gt; directory. Note that it is very important to never remove the &lt;code&gt;backup_label&lt;/code&gt; file when restoring a backup, because this will result in corruption. Confusion about when it is appropriate to remove this file is a common cause of data corruption when using this method; be very certain that you remove the file only on an existing master and never when building a standby or restoring a backup, even if you are building a standby that will subsequently be promoted to a new master.</source>
          <target state="translated">위에서 언급 한 바와 같이 백업 중에 서버가 충돌하면 &lt;code&gt;backup_label&lt;/code&gt; 파일이 &lt;code&gt;PGDATA&lt;/code&gt; 디렉토리 에서 수동으로 삭제 될 때까지 다시 시작하지 못할 수 있습니다 . 백업을 복원 할 때 &lt;code&gt;backup_label&lt;/code&gt; 파일 을 절대로 제거하지 마십시오 . 이로 인해 손상이 발생할 수 있습니다. 이 파일을 제거하는 것이 적절한시기에 대한 혼동은이 방법을 사용할 때 데이터가 손상되는 일반적인 원인입니다. 나중에 새 마스터로 승격 될 대기를 작성하더라도 대기를 구축하거나 백업을 복원 할 때는 기존 마스터에서만 파일을 제거하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b565015dcc8ef588510a75b03d00c798591daa60" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, &lt;code&gt;amvacuumcleanup&lt;/code&gt; will also be called at completion of an &lt;code&gt;ANALYZE&lt;/code&gt; operation. In this case &lt;code&gt;stats&lt;/code&gt; is always NULL and any return value will be ignored. This case can be distinguished by checking &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt;. It is recommended that the access method do nothing except post-insert cleanup in such a call, and that only in an autovacuum worker process.</source>
          <target state="translated">PostgreSQL 8.4부터 &lt;code&gt;ANALYZE&lt;/code&gt; 작업이 완료되면 &lt;code&gt;amvacuumcleanup&lt;/code&gt; 도 호출 됩니다. 이 경우 &lt;code&gt;stats&lt;/code&gt; 는 항상 NULL이며 모든 반환 값은 무시됩니다. 이 경우는 &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt; 를 확인하여 구별 할 수 있습니다 . 액세스 방법은 이러한 호출에서 사후 삽입 정리 외에 autovacuum 작업자 프로세스에서만 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41cf08ef1ae95fce9351d2775b5ca30eb5967a1b" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, this advice is less necessary since delayed indexing is used (see &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details). But for very large updates it may still be best to drop and recreate the index.</source>
          <target state="translated">PostgreSQL 8.4부터는 지연 인덱싱이 사용 &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;되므로이&lt;/a&gt; 조언이 덜 필요합니다 (자세한 내용은 섹션 66.4.1 참조). 그러나 매우 큰 업데이트의 경우 인덱스를 삭제하고 다시 작성하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fd60ea8bf7dbb2005dc3edad9e036817a4cf429d" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.0, &lt;code&gt;hstore&lt;/code&gt; uses a different internal representation than previous versions. This presents no obstacle for dump/restore upgrades since the text representation (used in the dump) is unchanged.</source>
          <target state="translated">PostgreSQL 9.0부터 &lt;code&gt;hstore&lt;/code&gt; 는 이전 버전과 다른 내부 표현을 사용합니다. 이는 덤프에서 사용 된 텍스트 표현이 변경되지 않기 때문에 덤프 / 복원 업그레이드에 장애가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="280a05cda72f4f22e9db55fedf9a21987eec509c" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be installed with &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt; not &lt;code&gt;CREATE LANGUAGE&lt;/code&gt;. Direct use of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; should now be confined to extension installation scripts. If you have a &amp;ldquo;bare&amp;rdquo; language in your database, perhaps as a result of an upgrade, you can convert it to an extension using &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 9.1부터 대부분의 절차 언어는 &quot;확장&quot;으로 만들어 졌으므로 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 가 아닌 CREATE &lt;a href=&quot;sql-createextension&quot;&gt;EXTENSION&lt;/a&gt; 으로 설치해야합니다 . &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 의 직접 사용 은 이제 확장 설치 스크립트에 국한되어야합니다. 업그레이드 결과 데이터베이스에 &quot;베어&quot;언어가있는 경우 &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt; 를 사용하여 언어를 확장으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad6c1afacf960c00b0b43cc22652add17660a754" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be removed with &lt;a href=&quot;sql-dropextension&quot;&gt;DROP EXTENSION&lt;/a&gt; not &lt;code&gt;DROP LANGUAGE&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 9.1부터 대부분의 절차 언어는 &quot;확장자&quot;로 만들어 졌으므로 &lt;code&gt;DROP LANGUAGE&lt;/code&gt; 가 아닌 DROP &lt;a href=&quot;sql-dropextension&quot;&gt;EXTENSION&lt;/a&gt; 으로 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9efc7bda1a790af9716120cc8586743f8662e379" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, null key values can be included in the index. Also, placeholder nulls are included in the index for indexed items that are null or contain no keys according to &lt;code&gt;extractValue&lt;/code&gt;. This allows searches that should find empty items to do so.</source>
          <target state="translated">PostgreSQL 9.1부터는 인덱스에 null 키 값이 포함될 수 있습니다. 또한 null 값이거나 &lt;code&gt;extractValue&lt;/code&gt; 에 따라 키가없는 색인화 된 항목의 색인에 자리 표시 자 널이 포함됩니다 . 이를 통해 빈 항목을 찾아야하는 검색이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="41a7562cb3e64fe55b5aa379cb00b42fdb0e1138" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, you can attach a &lt;code&gt;COLLATE&lt;/code&gt; specification to &lt;code&gt;citext&lt;/code&gt; columns or data values. Currently, &lt;code&gt;citext&lt;/code&gt; operators will honor a non-default &lt;code&gt;COLLATE&lt;/code&gt; specification while comparing case-folded strings, but the initial folding to lower case is always done according to the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting (that is, as though &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; were given). This may be changed in a future release so that both steps follow the input &lt;code&gt;COLLATE&lt;/code&gt; specification.</source>
          <target state="translated">PostgreSQL 9.1부터 &lt;code&gt;COLLATE&lt;/code&gt; 사양을 &lt;code&gt;citext&lt;/code&gt; 열 또는 데이터 값에 첨부 할 수 있습니다 . 현재 &lt;code&gt;citext&lt;/code&gt; 연산자는 대소 문자를 구분하는 문자열을 비교하는 동안 기본이 아닌 &lt;code&gt;COLLATE&lt;/code&gt; 사양을 준수 하지만 데이터베이스의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정 에 따라 (즉, &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; 가 지정된 것처럼) 소문자로의 초기 접기는 항상 수행됩니다 . 이후 릴리스에서는 두 단계 모두 입력 &lt;code&gt;COLLATE&lt;/code&gt; 사양을 따르도록 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9cdab33dd907fd023cacb62f21aa10cc62e305ca" translate="yes" xml:space="preserve">
          <source>As pg_rewind copies configuration files entirely from the source, it may be required to correct the configuration used for recovery before restarting the target server, especially if the target is reintroduced as a standby of the source. If you restart the server after the rewind operation has finished but without configuring recovery, the target may again diverge from the primary.</source>
          <target state="translated">pg_rewind는 소스에서 구성 파일 전체를 복사하므로, 특히 대상이 소스의 대기로 다시 도입 된 경우 대상 서버를 다시 시작하기 전에 복구에 사용 된 구성을 수정해야 할 수 있습니다. 되감기 작업이 완료된 후 복구를 구성하지 않고 서버를 다시 시작하면 대상이 다시 기본 서버에서 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df8c2a751dfbd5be0d7c157dabee58d14e6c8985" translate="yes" xml:space="preserve">
          <source>As previously stated, when a JSON value is input and then printed without any additional processing, &lt;code&gt;json&lt;/code&gt; outputs the same text that was input, while &lt;code&gt;jsonb&lt;/code&gt; does not preserve semantically-insignificant details such as whitespace. For example, note the differences here:</source>
          <target state="translated">앞에서 언급했듯이 JSON 값을 입력 한 후 추가 처리없이 인쇄하면 &lt;code&gt;json&lt;/code&gt; 은 입력 된 것과 동일한 텍스트를 출력하지만 &lt;code&gt;jsonb&lt;/code&gt; 는 공백과 같이 의미가 중요하지 않은 세부 정보를 유지하지 않습니다. 예를 들어 여기에 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1442483656b1d2da488c86cbbe647b9c3925f511" translate="yes" xml:space="preserve">
          <source>As seen in the second example, the element name can be omitted if the content value is a column reference, in which case the column name is used by default. Otherwise, a name must be specified.</source>
          <target state="translated">두 번째 예에서 볼 수 있듯이 내용 값이 열 참조 인 경우 요소 이름을 생략 할 수 있으며이 경우 기본적으로 열 이름이 사용됩니다. 그렇지 않으면 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbfde401bab7c53809229a3d8a380b7c73d7b56a" translate="yes" xml:space="preserve">
          <source>As seen in this example, when the query is an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command, the actual work of applying the table changes is done by a top-level Insert, Update, or Delete plan node. The plan nodes underneath this node perform the work of locating the old rows and/or computing the new data. So above, we see the same sort of bitmap table scan we've seen already, and its output is fed to an Update node that stores the updated rows. It's worth noting that although the data-modifying node can take a considerable amount of run time (here, it's consuming the lion's share of the time), the planner does not currently add anything to the cost estimates to account for that work. That's because the work to be done is the same for every correct query plan, so it doesn't affect planning decisions.</source>
          <target state="translated">이 예에서 볼 수 있듯이 쿼리가 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 인 경우명령에서 테이블 변경 사항을 적용하는 실제 작업은 최상위 수준의 삽입, 업데이트 또는 삭제 계획 노드에 의해 수행됩니다. 이 노드 아래의 계획 노드는 이전 행을 찾고 새 데이터를 계산하는 작업을 수행합니다. 위와 같이, 우리는 이미 본 것과 같은 종류의 비트 맵 테이블 스캔을 보았으며 출력은 업데이트 된 행을 저장하는 업데이트 노드로 공급됩니다. 데이터 수정 노드가 상당한 양의 런타임을 소비 할 수 있지만 (여기서 시간을 엄청나게 소비하고 있음) 플래너는 현재 해당 작업을 설명하기 위해 비용 추정치에 아무것도 추가하지 않습니다. 수행 할 작업은 모든 올바른 쿼리 계획에 대해 동일하기 때문에 계획 결정에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1072787f6d22b0aaf6039c0a8fa7f37aca0290a" translate="yes" xml:space="preserve">
          <source>As shown above, all comparison operators are binary operators that return values of type &lt;code&gt;boolean&lt;/code&gt;. Thus, expressions like &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; are not valid (because there is no &lt;code&gt;&amp;lt;&lt;/code&gt; operator to compare a Boolean value with &lt;code&gt;3&lt;/code&gt;). Use the &lt;code&gt;BETWEEN&lt;/code&gt; predicates shown below to perform range tests.</source>
          <target state="translated">위에 표시된대로 모든 비교 연산자는 &lt;code&gt;boolean&lt;/code&gt; 유형의 값을 반환하는 이항 연산자입니다 . 따라서 &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; 과 같은 표현식 은 유효하지 않습니다 ( 부울 값을 &lt;code&gt;3&lt;/code&gt; 과 비교할 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 없기 때문입니다 ). 범위 테스트를 수행하려면 아래 표시된 &lt;code&gt;BETWEEN&lt;/code&gt; 술어를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="299b9141677294c0e2aa3b93c3483b8a98e2f995" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;code&gt;union&lt;/code&gt; function's first &lt;code&gt;internal&lt;/code&gt; argument is actually a &lt;code&gt;GistEntryVector&lt;/code&gt; pointer. The second argument is a pointer to an integer variable, which can be ignored. (It used to be required that the &lt;code&gt;union&lt;/code&gt; function store the size of its result value into that variable, but this is no longer necessary.)</source>
          <target state="translated">위에 표시된 것처럼 &lt;code&gt;union&lt;/code&gt; 함수의 첫 번째 &lt;code&gt;internal&lt;/code&gt; 인수는 실제로 &lt;code&gt;GistEntryVector&lt;/code&gt; 포인터입니다. 두 번째 인수는 정수 변수에 대한 포인터이며 무시할 수 있습니다. 이전에는 &lt;code&gt;union&lt;/code&gt; 함수가 결과 값의 크기를 해당 변수에 저장해야했지만 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e49718fcf44bf904fec83a97285f69086516abb8" translate="yes" xml:space="preserve">
          <source>As shown here, the &lt;code&gt;rank&lt;/code&gt; function produces a numerical rank for each distinct &lt;code&gt;ORDER BY&lt;/code&gt; value in the current row's partition, using the order defined by the &lt;code&gt;ORDER BY&lt;/code&gt; clause. &lt;code&gt;rank&lt;/code&gt; needs no explicit parameter, because its behavior is entirely determined by the &lt;code&gt;OVER&lt;/code&gt; clause.</source>
          <target state="translated">여기에 표시된대로 &lt;code&gt;rank&lt;/code&gt; 함수는 &lt;code&gt;ORDER BY&lt;/code&gt; 절에 의해 정의 된 순서를 사용하여 현재 행의 파티션에서 각각의 고유 한 &lt;code&gt;ORDER BY&lt;/code&gt; 값에 대한 숫자 순위를 생성합니다 . &lt;code&gt;rank&lt;/code&gt; 는 동작이 &lt;code&gt;OVER&lt;/code&gt; 절에 의해 완전히 결정되므로 명시적인 매개 변수가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7278da1d6766bb19352b261eabd292dd18fce4c5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.2&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;표 37.2에&lt;/a&gt; 표시된 것처럼 btree 연산자 클래스는 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 의 5 가지 비교 연산자를 제공해야합니다 . &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 도 연산자 클래스의 일부 여야한다고 기대할 수 있지만 인덱스 검색에서 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE 절 을 사용하는 것은 거의 유용하지 않기 때문에 그렇지 않습니다 . (계획자는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 를 btree 연산자 클래스와 관련된 것으로 취급 하지만 &lt;code&gt;pg_amop&lt;/code&gt; 대신 &lt;code&gt;=&lt;/code&gt; 연산자의 부정 자 링크 를 통해 해당 연산자를 찾습니다 .)</target>
        </trans-unit>
        <trans-unit id="2b7658bd4634c80bfa02d903fd89d9f89cfdf0c3" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.8&lt;/a&gt;, btree defines one required and two optional support functions.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;표 37.8에&lt;/a&gt; 표시된 것처럼 btree는 하나의 필수 및 두 개의 선택적 지원 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e2e2d713a7e1c4b73e9dae4d9b294d20af0dfdbd" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.3&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.3&lt;/a&gt; 에서 볼 수 있듯이 btree 연산자 클래스는 5 개의 비교 연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 제공해야합니다 . &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 도 연산자 클래스의 일부 여야한다고 예상 할 수 있지만 인덱스 검색에서 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE 절 을 사용하는 것이 거의 유용하지 않기 때문에 그렇지 않습니다 . (어떤 목적을 위해 플래너는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 를 btree 연산자 클래스와 관련된 것으로 취급 하지만 &lt;code&gt;pg_amop&lt;/code&gt; 이 아닌 &lt;code&gt;=&lt;/code&gt; 연산자의 부정 자 링크 를 통해 해당 연산자를 찾습니다 .)</target>
        </trans-unit>
        <trans-unit id="fd9a67840a67dabf7761754a18fc846d1c2e26f5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.9&lt;/a&gt;, btree defines one required and four optional support functions. The five user-defined methods are:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;표 37.9&lt;/a&gt; 에서 볼 수 있듯이 btree는 필수 지원 기능 1 개와 선택적 지원 기능 4 개를 정의합니다. 5 가지 사용자 정의 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01827ef18402ec5bd4e9a302a910b59d06b2ca2b" translate="yes" xml:space="preserve">
          <source>As shown in the previous section, the table expression in the &lt;code&gt;SELECT&lt;/code&gt; command constructs an intermediate virtual table by possibly combining tables, views, eliminating rows, grouping, etc. This table is finally passed on to processing by the &lt;em&gt;select list&lt;/em&gt;. The select list determines which &lt;em&gt;columns&lt;/em&gt; of the intermediate table are actually output.</source>
          <target state="translated">이전 섹션에서 볼 수 있듯이 &lt;code&gt;SELECT&lt;/code&gt; 명령 의 테이블 표현식 은 테이블, 뷰, 행 제거, 그룹화 등을 가능하게하여 중간 가상 테이블을 구성합니다.이 테이블은 최종적으로 &lt;em&gt;select list에&lt;/em&gt; 의해 처리로 전달됩니다 . 선택 목록 은 실제로 출력되는 중간 테이블의 &lt;em&gt;열&lt;/em&gt; 을 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="a1a6ed6a1882593d5ac926bd03fffe04913abef7" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing a composite value you can write double quotes around any individual field value. You &lt;em&gt;must&lt;/em&gt; do so if the field value would otherwise confuse the composite-value parser. In particular, fields containing parentheses, commas, double quotes, or backslashes must be double-quoted. To put a double quote or backslash in a quoted composite field value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted field value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as composite syntax.</source>
          <target state="translated">이전에 표시된 것처럼 복합 값을 쓸 때 개별 필드 값 주위에 큰 따옴표를 쓸 수 있습니다. 당신은 &lt;em&gt;해야한다&lt;/em&gt; 필드 값이 다른 복합 값 파서를 혼동한다면 그렇게. 특히 괄호, 쉼표, 큰 따옴표 또는 백 슬래시가 포함 된 필드는 큰 따옴표로 묶어야합니다. 인용 된 복합 필드 값에 큰 따옴표 또는 백 슬래시를 넣으려면 백 슬래시를 앞에 추가하십시오. 또한 큰 따옴표로 묶인 필드 값 내의 큰 따옴표 쌍은 SQL 리터럴 문자열의 작은 따옴표 규칙과 마찬가지로 큰 따옴표 문자를 나타 내기 위해 사용됩니다. 또는 인용 부호를 피하고 백 슬래시 이스케이프를 사용하여 보호 할 수 있습니다. 그렇지 않으면 복합 구문으로 간주되는 모든 데이터 문자</target>
        </trans-unit>
        <trans-unit id="bf6c49e3bf726dc38d17652f47395db71e4e4fbd" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing an array value you can use double quotes around any individual array element. You &lt;em&gt;must&lt;/em&gt; do so if the element value would otherwise confuse the array-value parser. For example, elements containing curly braces, commas (or the data type's delimiter character), double quotes, backslashes, or leading or trailing whitespace must be double-quoted. Empty strings and strings matching the word &lt;code&gt;NULL&lt;/code&gt; must be quoted, too. To put a double quote or backslash in a quoted array element value, precede it with a backslash. Alternatively, you can avoid quotes and use backslash-escaping to protect all data characters that would otherwise be taken as array syntax.</source>
          <target state="translated">이전에 표시된 것처럼 배열 값을 쓸 때 개별 배열 요소 주위에 큰 따옴표를 사용할 수 있습니다. 당신은 &lt;em&gt;해야한다&lt;/em&gt; 요소 값이 다른 배열 값 파서를 혼동한다면 그렇게. 예를 들어 중괄호, 쉼표 (또는 데이터 형식의 구분 문자), 큰 따옴표, 백 슬래시 또는 선행 또는 후행 공백이 포함 된 요소는 큰 따옴표로 묶어야합니다. &lt;code&gt;NULL&lt;/code&gt; 이라는 단어와 일치하는 빈 문자열과 문자열 도 인용해야합니다. 큰 따옴표 또는 백 슬래시를 인용 배열 요소 값에 넣으려면 백 슬래시를 앞에옵니다. 또는 따옴표를 피하고 백 슬래시 이스케이프를 사용하여 배열 구문으로 간주되는 모든 데이터 문자를 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a1775eb12b1097993052bc9db7c32cd0419a0ce" translate="yes" xml:space="preserve">
          <source>As shown, an array data type is named by appending square brackets (&lt;code&gt;[]&lt;/code&gt;) to the data type name of the array elements. The above command will create a table named &lt;code&gt;sal_emp&lt;/code&gt; with a column of type &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;name&lt;/code&gt;), a one-dimensional array of type &lt;code&gt;integer&lt;/code&gt; (&lt;code&gt;pay_by_quarter&lt;/code&gt;), which represents the employee's salary by quarter, and a two-dimensional array of &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;schedule&lt;/code&gt;), which represents the employee's weekly schedule.</source>
          <target state="translated">표시된 것처럼 배열 데이터 유형은 배열 요소의 데이터 유형 이름에 대괄호 ( &lt;code&gt;[]&lt;/code&gt; )를 추가하여 이름이 지정됩니다 . 위의 명령은 &lt;code&gt;text&lt;/code&gt; 유형의 열 ( &lt;code&gt;name&lt;/code&gt; ), &lt;code&gt;integer&lt;/code&gt; 유형의 1 차원 배열 ( &lt;code&gt;pay_by_quarter&lt;/code&gt; ), 분기 별 직원의 급여를 나타내는 2 차원 &lt;code&gt;text&lt;/code&gt; 배열 ( &lt;code&gt;schedule&lt;/code&gt; )을 가진 &lt;code&gt;sal_emp&lt;/code&gt; 라는 테이블을 작성 합니다. 직원의 주간 일정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0b46ae37bd20da5e49ea599dd897a3ac9299776" translate="yes" xml:space="preserve">
          <source>As the above example suggests, a &lt;code&gt;tsquery&lt;/code&gt; is not just raw text, any more than a &lt;code&gt;tsvector&lt;/code&gt; is. A &lt;code&gt;tsquery&lt;/code&gt; contains search terms, which must be already-normalized lexemes, and may combine multiple terms using AND, OR, NOT, and FOLLOWED BY operators. (For syntax details see &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;Section 8.11.2&lt;/a&gt;.) There are functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, and &lt;code&gt;phraseto_tsquery&lt;/code&gt; that are helpful in converting user-written text into a proper &lt;code&gt;tsquery&lt;/code&gt;, primarily by normalizing words appearing in the text. Similarly, &lt;code&gt;to_tsvector&lt;/code&gt; is used to parse and normalize a document string. So in practice a text search match would look more like this:</source>
          <target state="translated">위의 예에서 알 수 있듯이 &lt;code&gt;tsquery&lt;/code&gt; 는 단순한 텍스트가 아니라 &lt;code&gt;tsvector&lt;/code&gt; 이상 입니다. &lt;code&gt;tsquery&lt;/code&gt; 는 이미 정규화 어휘이어야하며, 여러 용어, NOT 사용하여 AND, OR 결합 할 수 및 연산자 다음에 검색어가 포함되어 있습니다. 구문에 대한 자세한 내용 &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;은 8.11.2 절을&lt;/a&gt; 참조하십시오 . &lt;code&gt;to_tsquery&lt;/code&gt; , &lt;code&gt;plainto_tsquery&lt;/code&gt; 및 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 함수 는 주로 텍스트에 나타나는 단어를 정규화 하여 사용자 작성 텍스트를 적절한 &lt;code&gt;tsquery&lt;/code&gt; 로 변환하는 데 도움 이됩니다. 마찬가지로 &lt;code&gt;to_tsvector&lt;/code&gt; 문서 문자열을 구문 분석하고 정규화하는 데 사용됩니다. 실제로 텍스트 검색 일치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b22935fd06acdc1c0f8d1431b124c6c0f7b088d" translate="yes" xml:space="preserve">
          <source>As the last example demonstrates, the regexp split functions ignore zero-length matches that occur at the start or end of the string or immediately after a previous match. This is contrary to the strict definition of regexp matching that is implemented by &lt;code&gt;regexp_match&lt;/code&gt; and &lt;code&gt;regexp_matches&lt;/code&gt;, but is usually the most convenient behavior in practice. Other software systems such as Perl use similar definitions.</source>
          <target state="translated">마지막 예에서 알 수 있듯이 regexp split 함수는 문자열의 시작 또는 끝에서 또는 이전 일치 직후에 발생하는 길이가 0 인 일치를 무시합니다. 이는 &lt;code&gt;regexp_match&lt;/code&gt; 및 &lt;code&gt;regexp_matches&lt;/code&gt; 에 의해 구현되는 regexp 일치의 엄격한 정의와는 상반 되지만 일반적으로 실제로 가장 편리한 동작입니다. Perl과 같은 다른 소프트웨어 시스템은 유사한 정의를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0378825838c0e066e87e6d5b0be89bee2dd5620d" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;IN&lt;/code&gt; is null.</source>
          <target state="translated">일반적으로 행의 널값은 SQL 부울 표현식의 일반 규칙에 따라 결합됩니다. 해당하는 모든 멤버가 널이 아니고 같으면 두 행이 동일한 것으로 간주됩니다. 대응하는 멤버가 널이 아니거나 같으면 행이 동일하지 않습니다. 그렇지 않으면 해당 행 비교 결과를 알 수 없습니다 (널). 모든 행당 결과가 동일하지 않거나 널이며, 하나 이상의 널이있는 경우 &lt;code&gt;IN&lt;/code&gt; 의 결과 는 널입니다.</target>
        </trans-unit>
        <trans-unit id="0b8508c03666af11ade2c1725a303ade508dcc57" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;NOT IN&lt;/code&gt; is null.</source>
          <target state="translated">일반적으로 행의 널값은 SQL 부울 표현식의 일반 규칙에 따라 결합됩니다. 해당하는 모든 멤버가 널이 아니고 같으면 두 행이 동일한 것으로 간주됩니다. 대응하는 멤버가 널이 아니거나 같으면 행이 동일하지 않습니다. 그렇지 않으면 해당 행 비교 결과를 알 수 없습니다 (널). 모든 행당 결과가 동일하지 않거나 널 (null 이상) 인 경우 &lt;code&gt;NOT IN&lt;/code&gt; 의 결과 는 널입니다.</target>
        </trans-unit>
        <trans-unit id="00f8ed65d004834d267f75de424eb5e9aec68c8b" translate="yes" xml:space="preserve">
          <source>As visible here, JIT was used, but inlining and expensive optimization were not. If &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; were also lowered, that would change.</source>
          <target state="translated">여기에서 볼 수 있듯이 JIT가 사용되었지만 인라인 및 고가의 최적화는 사용되지 않았습니다. 경우 &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost이&lt;/a&gt; 또한 감소되었다, 그 변경합니다.</target>
        </trans-unit>
        <trans-unit id="e991d7170113bfec3a30551fcd7b4c1810192115" translate="yes" xml:space="preserve">
          <source>As we can see, a complex table hierarchy could require a substantial amount of DDL. In the above example we would be creating a new child table each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">보시다시피 복잡한 테이블 계층에는 상당한 양의 DDL이 필요할 수 있습니다. 위의 예에서 우리는 매달 새로운 자식 테이블을 만들 것이므로 필요한 DDL을 자동으로 생성하는 스크립트를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="13f137c0044f99ee6629a214a80858091639b3df" translate="yes" xml:space="preserve">
          <source>As we saw in the previous section, the query planner needs to estimate the number of rows retrieved by a query in order to make good choices of query plans. This section provides a quick look at the statistics that the system uses for these estimates.</source>
          <target state="translated">이전 섹션에서 보았 듯이 쿼리 계획자는 쿼리 계획을 적절히 선택하기 위해 쿼리에서 검색 한 행 수를 추정해야합니다. 이 섹션에서는 시스템이 이러한 추정에 사용하는 통계를 간략하게 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="6a378a5df8689a29e440cf7e593b2b7b017debb3" translate="yes" xml:space="preserve">
          <source>As well as tables, this option can be used to dump the definition of matching views, materialized views, foreign tables, and sequences. It will not dump the contents of views or materialized views, and the contents of foreign tables will only be dumped if the corresponding foreign server is specified with &lt;code&gt;--include-foreign-data&lt;/code&gt;.</source>
          <target state="translated">테이블뿐만 아니라이 옵션을 사용하여 일치하는 뷰, 구체화 된 뷰, 외부 테이블 및 시퀀스의 정의를 덤프 할 수 있습니다. 뷰 또는 구체화 된 뷰의 내용을 덤프하지 않으며 해당 외부 서버가 &lt;code&gt;--include-foreign-data&lt;/code&gt; 로 지정된 경우에만 외부 테이블의 내용이 덤프됩니다 .</target>
        </trans-unit>
        <trans-unit id="e28715fe2eadf5afacb168abae8c272e3eef5af1" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;EXISTS&lt;/code&gt;, it's unwise to assume that the subquery will be evaluated completely.</source>
          <target state="translated">&lt;code&gt;EXISTS&lt;/code&gt; 와 마찬가지로 하위 쿼리가 완전히 평가된다고 가정하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22733a70e9587403334559bc9fffe583566e0a7a" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters. A different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;, or the escape capability can be disabled by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 와 마찬가지로 백 슬래시는 이러한 메타 문자의 특별한 의미를 비활성화합니다. &lt;code&gt;ESCAPE&lt;/code&gt; 로 다른 이스케이프 문자를 지정 하거나 &lt;code&gt;ESCAPE ''&lt;/code&gt; 를 작성하여 이스케이프 기능을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="181bd891b583b10919f382d152707212af1347e4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters; or a different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 와 마찬가지로 백 슬래시는 이러한 메타 문자의 특수한 의미를 비활성화합니다. 또는 &lt;code&gt;ESCAPE&lt;/code&gt; 로 다른 이스케이프 문자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c360e616acbe7a6ddce202d4edfd50d452f4ba5" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;SIMILAR TO&lt;/code&gt;, the specified pattern must match the entire data string, or else the function fails and returns null. To indicate the part of the pattern for which the matching data sub-string is of interest, the pattern should contain two occurrences of the escape character followed by a double quote (&lt;code&gt;&quot;&lt;/code&gt;). The text matching the portion of the pattern between these separators is returned when the match is successful.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;SIMILAR TO&lt;/code&gt; , 지정된 패턴은 전체 데이터 문자열과 일치해야하며, 그렇지 않으면 함수가 실패하고 반환 널 (null). 일치하는 데이터 서브 스트링이 관심있는 패턴의 부분을 표시하려면 패턴에 두 개의 이스케이프 문자와 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 가 포함되어야합니다 . 이러한 구분 기호 사이의 패턴 부분과 일치하는 텍스트는 다음과 같습니다. 일치하면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2f915404c792b4b375081401e8be4799b6fdf5c9" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;pgstattuple&lt;/code&gt;, the results are accumulated page-by-page, and should not be expected to represent an instantaneous snapshot of the whole index.</source>
          <target state="translated">처럼 &lt;code&gt;pgstattuple&lt;/code&gt; 결과는 페이지별로 누적하며, 전체 인덱스의 순간 스냅 샷을 나타내는 예상되지 않아야한다.</target>
        </trans-unit>
        <trans-unit id="fd70faee0fe9a1b62ee5a071b1f7e464081b1189" translate="yes" xml:space="preserve">
          <source>As with any security settings, it's important to test and ensure that the system is behaving as expected. Using the example above, this demonstrates that the permission system is working properly.</source>
          <target state="translated">보안 설정과 마찬가지로 시스템이 예상대로 작동하는지 테스트하고 확인하는 것이 중요합니다. 위의 예를 사용하면 권한 시스템이 올바르게 작동하고 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f8169958f7a4429a1d75d6cb1d9f2e4af52ed1d2" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) In particular, it is advisable that this user account not own the PostgreSQL executable files, to ensure that a compromised server process could not modify those executables.</source>
          <target state="translated">외부에서 액세스 할 수있는 모든 서버 데몬과 마찬가지로 별도의 사용자 계정으로 PostgreSQL을 실행하는 것이 좋습니다. 이 사용자 계정은 서버에서 관리하는 데이터 만 소유해야하며 다른 데몬과 공유해서는 안됩니다. (예를 들어 &lt;code&gt;nobody&lt;/code&gt; 라는 사용자를 사용 하는 것은 나쁜 생각입니다.) 특히 손상된 서버 프로세스가 해당 실행 파일을 수정할 수 없도록이 사용자 계정이 PostgreSQL 실행 파일을 소유하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f9153f6ce7772c623a80d637e2a8064efd48ff4" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) It is not advisable to install executables owned by this user because compromised systems could then modify their own binaries.</source>
          <target state="translated">외부에서 액세스 할 수있는 서버 데몬과 마찬가지로 별도의 사용자 계정으로 PostgreSQL을 실행하는 것이 좋습니다. 이 사용자 계정은 서버에서 관리하는 데이터 만 소유해야하며 다른 데몬과 공유해서는 안됩니다. 예를 들어, &lt;code&gt;nobody&lt;/code&gt; 사용자를 사용 하는 것은 나쁜 생각입니다. 손상된 시스템은 자체 바이너리를 수정할 수 있으므로이 사용자가 소유 한 실행 파일을 설치하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c718a2b52c9e3b6c8aed088c8f0e6614024fc446" translate="yes" xml:space="preserve">
          <source>As with base backups, the easiest way to produce a standalone hot backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. If you include the &lt;code&gt;-X&lt;/code&gt; parameter when calling it, all the write-ahead log required to use the backup will be included in the backup automatically, and no special action is required to restore the backup.</source>
          <target state="translated">기본 백업과 마찬가지로 독립형 핫 백업을 생성하는 가장 쉬운 방법은 &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; 도구 를 사용하는 것 입니다. 호출 할 때 &lt;code&gt;-X&lt;/code&gt; 매개 변수 를 포함하면 백업을 사용하는 데 필요한 모든 미리 쓰기 로그가 자동으로 백업에 포함되며 백업을 복원하기 위해 특별한 조치가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="478aba2ebcc8faa95902624459b6a85534e22480" translate="yes" xml:space="preserve">
          <source>As with dropping a column, you need to add &lt;code&gt;CASCADE&lt;/code&gt; if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s).</source>
          <target state="translated">열을 삭제하는 것과 마찬가지로 다른 항목이 의존하는 제약 조건을 삭제하려면 &lt;code&gt;CASCADE&lt;/code&gt; 를 추가해야합니다 . 외래 키 제약 조건은 참조 된 열의 고유 또는 기본 키 제약 조건에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="f3f0c2f615e83e516256da21365a0381f69d219d" translate="yes" xml:space="preserve">
          <source>As with other PostgreSQL text search configuration files, the rules file must be stored in UTF-8 encoding. The data is automatically translated into the current database's encoding when loaded. Any lines containing untranslatable characters are silently ignored, so that rules files can contain rules that are not applicable in the current encoding.</source>
          <target state="translated">다른 PostgreSQL 텍스트 검색 구성 파일과 마찬가지로 규칙 파일은 UTF-8 인코딩으로 저장해야합니다. 데이터는로드 될 때 현재 데이터베이스의 인코딩으로 자동 변환됩니다. 변환 할 수없는 문자를 포함하는 모든 행은 자동으로 무시되므로 규칙 파일에 현재 인코딩에 적용 할 수없는 규칙이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10502eec64e33ad71eb02c8495b055a53abfa416" translate="yes" xml:space="preserve">
          <source>As with the plain file-system-backup technique, this method can only support restoration of an entire database cluster, not a subset. Also, it requires a lot of archival storage: the base backup might be bulky, and a busy system will generate many megabytes of WAL traffic that have to be archived. Still, it is the preferred backup technique in many situations where high reliability is needed.</source>
          <target state="translated">일반 파일 시스템 백업 기술과 마찬가지로이 방법은 서브 세트가 아닌 전체 데이터베이스 클러스터의 복원 만 지원할 수 있습니다. 또한, 많은 아카이브 스토리지가 필요합니다. 기본 백업은 부피가 클 수 있으며 사용량이 많은 시스템은 아카이브해야하는 많은 메가 바이트의 WAL 트래픽을 생성합니다. 그러나 높은 안정성이 필요한 여러 상황에서 선호되는 백업 기술입니다.</target>
        </trans-unit>
        <trans-unit id="41912914d23f57d6b4964446c4839bcd6bf6e2ec" translate="yes" xml:space="preserve">
          <source>As with vacuuming for space recovery, frequent updates of statistics are more useful for heavily-updated tables than for seldom-updated ones. But even for a heavily-updated table, there might be no need for statistics updates if the statistical distribution of the data is not changing much. A simple rule of thumb is to think about how much the minimum and maximum values of the columns in the table change. For example, a &lt;code&gt;timestamp&lt;/code&gt; column that contains the time of row update will have a constantly-increasing maximum value as rows are added and updated; such a column will probably need more frequent statistics updates than, say, a column containing URLs for pages accessed on a website. The URL column might receive changes just as often, but the statistical distribution of its values probably changes relatively slowly.</source>
          <target state="translated">공간 복구를 진공 청소기로 청소하는 경우와 같이 자주 업데이트되는 테이블보다 자주 업데이트되는 테이블에 통계를 자주 업데이트하는 것이 더 유용합니다. 그러나 과도하게 업데이트 된 테이블의 경우에도 데이터의 통계적 분포가 크게 변하지 않으면 통계 업데이트가 필요하지 않을 수 있습니다. 간단한 경험 법칙은 테이블에서 열의 최소값과 최대 값이 얼마나 많이 변경되는지 생각하는 것입니다. 예를 들어 &lt;code&gt;timestamp&lt;/code&gt; 행 업데이트 시간이 포함 된 열은 행이 추가 및 업데이트 될 때 지속적으로 증가하는 최대 값을 갖습니다. 이러한 항목은 웹 사이트에서 액세스하는 페이지의 URL이 포함 된 항목보다 통계 업데이트가 더 자주 필요할 수 있습니다. URL 열은 자주 변경 사항을 수신 할 수 있지만 해당 값의 통계적 분포는 상대적으로 느리게 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d8d489832d7110fbb67ed9e2a0a908cb5a5e5d" translate="yes" xml:space="preserve">
          <source>As you can see, in this skeleton we're dealing with a data type where &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt;. It's easy enough to support data types where this is not the case, by implementing the proper union algorithm in this GiST support method.</source>
          <target state="translated">보시다시피이 골격에서 &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt; 데이터 유형을 처리 합니다. 이 GiST 지원 방법에 적절한 통합 알고리즘을 구현하여 그렇지 않은 경우 데이터 유형을 지원하기가 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="bf9aec8aa0de7661a07d98a75f47c3b69757e7a1" translate="yes" xml:space="preserve">
          <source>As you see, pg_dump writes its result to the standard output. We will see below how this can be useful. While the above command creates a text file, pg_dump can create files in other formats that allow for parallelism and more fine-grained control of object restoration.</source>
          <target state="translated">보시다시피 pg_dump는 결과를 표준 출력에 씁니다. 우리는 이것이 어떻게 유용한 지 아래에서 볼 것입니다. 위 명령이 텍스트 파일을 생성하는 동안 pg_dump는 다른 형식으로 파일을 생성하여 병렬 및보다 세밀한 객체 복원 제어를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="21e1923806603d461ddac0e0413cc2a388550aac" translate="yes" xml:space="preserve">
          <source>As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word &lt;code&gt;CHECK&lt;/code&gt; followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense.</source>
          <target state="translated">보시다시피 제약 조건 정의는 기본값 정의와 마찬가지로 데이터 유형 뒤에옵니다. 기본값 및 제약 조건은 임의의 순서로 나열 될 수 있습니다. 점검 제한 조건은 키워드 &lt;code&gt;CHECK&lt;/code&gt; 와 괄호 안의 표현식으로 구성됩니다. 점검 제한 조건 표현식은 이와 같이 제한된 열을 포함해야합니다. 그렇지 않으면 제한 조건이 너무 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1b9d2baec69327019075ccf63fb47f3a04b6635" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="translated">보시다시피, 새로운 값에 대한 표현식은 행의 기존 값을 참조 할 수 있습니다. 우리는 또한 &lt;code&gt;WHERE&lt;/code&gt; 절을 생략했습니다 . 생략하면 테이블의 모든 행이 업데이트됨을 의미합니다. 존재하는 경우 &lt;code&gt;WHERE&lt;/code&gt; 조건 과 일치하는 행만 업데이트됩니다. &lt;code&gt;SET&lt;/code&gt; 절의 등호 는 할당이지만 &lt;code&gt;WHERE&lt;/code&gt; 절의 등호 는 비교이지만 모호성을 생성하지는 않습니다. 물론 &lt;code&gt;WHERE&lt;/code&gt; 조건은 평등 테스트 일 필요는 없습니다. 다른 많은 연산자도 사용할 수 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장&lt;/a&gt; 참조 ). 그러나 표현식은 부울 결과로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="439358cf5e5d4c690518e4e11abfb19b1e44a30e" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="translated">보시다시피 새 값에 대한 표현식은 행의 기존 값을 참조 할 수 있습니다. &lt;code&gt;WHERE&lt;/code&gt; 절도 생략했습니다 . 생략하면 테이블의 모든 행이 업데이트됨을 의미합니다. 존재하는 경우 &lt;code&gt;WHERE&lt;/code&gt; 조건 과 일치하는 행만 업데이트됩니다. &lt;code&gt;SET&lt;/code&gt; 절의 등호 기호 는 할당이고 &lt;code&gt;WHERE&lt;/code&gt; 절의 등호 기호 는 비교이지만 이것은 모호성을 만들지 않습니다. 물론 &lt;code&gt;WHERE&lt;/code&gt; 조건이 동등성 테스트 일 필요는 없습니다. 다른 많은 연산자를 사용할 수 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;9 장&lt;/a&gt; 참조 ). 그러나 표현식은 부울 결과로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="313a697ffb23a7210631919b2999246578e93b67" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they are designed not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt;. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.) This applies to the following commands:</source>
          <target state="translated">아카이버 또는 WAL 발신자가 WAL 데이터를 처리하는 시간을 피하는 것 외에도 &lt;code&gt;wal_level&lt;/code&gt; 이 &lt;code&gt;minimal&lt;/code&gt; 경우 WAL을 전혀 쓰지 않도록 설계되어 있기 때문에 실제로는 특정 명령이 더 빨라 집니다. ( WAL을 작성하는 것보다 끝에 &lt;code&gt;fsync&lt;/code&gt; 를 수행하면 충돌 안전을보다 저렴하게 보장 할 수 있습니다 .) 이는 다음 명령에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1744fb0dcc66faea0f0e11e29ee96bb68e2530a" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they do not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and the current subtransaction (or top-level transaction) created or truncated the table or index they change. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.)</source>
          <target state="translated">아카이버 또는 WAL 발신자가 WAL 데이터를 처리하는 시간을 피하는 것 외에도, 이렇게하면 실제로 특정 명령이 더 빨라집니다. &lt;code&gt;wal_level&lt;/code&gt; 이 &lt;code&gt;minimal&lt;/code&gt; 이고 현재 서브 트랜잭션 (또는 최상위 트랜잭션) 인 경우 WAL을 전혀 작성하지 않기 때문입니다. 변경된 테이블 또는 인덱스를 만들거나 자릅니다. ( WAL을 작성하는 것보다 마지막에 &lt;code&gt;fsync&lt;/code&gt; 를 수행하면 더 저렴하게 충돌 안전을 보장 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="ba62da50a0cd807fd06ac3427894951fdffc554f" translate="yes" xml:space="preserve">
          <source>Aside from preventing cycles, the array value is often useful in its own right as representing the &amp;ldquo;path&amp;rdquo; taken to reach any particular row.</source>
          <target state="translated">사이클을 방지하는 것 외에도 배열 값은 특정 행에 도달하기 위해 &quot;경로&quot;를 나타내는 것으로 종종 그 자체로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f08bd4c872560fdf37016b1456326d2f1f83a30c" translate="yes" xml:space="preserve">
          <source>Aside from the index's own internal consistency requirements, concurrent updates create issues about consistency between the parent table (the &lt;em&gt;heap&lt;/em&gt;) and the index. Because PostgreSQL separates accesses and updates of the heap from those of the index, there are windows in which the index might be inconsistent with the heap. We handle this problem with the following rules:</source>
          <target state="translated">인덱스 자체의 내부 일관성 요구 사항 외에도 동시 업데이트는 상위 테이블 ( &lt;em&gt;heap&lt;/em&gt; )과 인덱스 간의 일관성에 대한 문제를 만듭니다 . PostgreSQL은 힙 액세스 및 업데이트를 인덱스의 액세스 및 업데이트와 분리하므로 인덱스가 힙과 일치하지 않는 창이 있습니다. 우리는이 규칙을 다음 규칙으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="66acedea6ec5e6c71ffc128f764e1116af5e0326" translate="yes" xml:space="preserve">
          <source>Assign a literal constant default value for the column &lt;code&gt;name&lt;/code&gt;, arrange for the default value of column &lt;code&gt;did&lt;/code&gt; to be generated by selecting the next value of a sequence object, and make the default value of &lt;code&gt;modtime&lt;/code&gt; be the time at which the row is inserted:</source>
          <target state="translated">열 리터럴 상수 기본값 할당 &lt;code&gt;name&lt;/code&gt; 칼럼의 기본값을 준비하는 단계, &lt;code&gt;did&lt;/code&gt; 시퀀스 오브젝트의 다음 값을 선택함으로써 생성하고, 디폴트 값을 확인 &lt;code&gt;modtime&lt;/code&gt; 가 로우가 삽입되는 시점 일 :</target>
        </trans-unit>
        <trans-unit id="1bfbe2935df02c420c8e520ec3e42a7fba80f23c" translate="yes" xml:space="preserve">
          <source>Assigns the specified &lt;em&gt;&lt;code&gt;weight&lt;/code&gt;&lt;/em&gt; to each element of the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;vector&lt;/code&gt; &lt;/em&gt; 각 요소에 지정된 &lt;em&gt; &lt;code&gt;weight&lt;/code&gt; &lt;/em&gt; 를 할당합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="75a4d3134c8b9723881f294a52dd576fc9852c4b" translate="yes" xml:space="preserve">
          <source>Assigns the specified &lt;em&gt;&lt;code&gt;weight&lt;/code&gt;&lt;/em&gt; to elements of the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt; that are listed in &lt;em&gt;&lt;code&gt;lexemes&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;lexemes&lt;/code&gt; 에&lt;/em&gt; 나열된 &lt;em&gt; &lt;code&gt;vector&lt;/code&gt; &lt;/em&gt; 요소에 지정된 &lt;em&gt; &lt;code&gt;weight&lt;/code&gt; &lt;/em&gt; 를 할당합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f079970016568a6988faea4629841a26d4520b05" translate="yes" xml:space="preserve">
          <source>Associated sort operator (zero if none)</source>
          <target state="translated">연관된 정렬 연산자 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="d530f867f7438d52f3d933c2185ee58e5795fb55" translate="yes" xml:space="preserve">
          <source>Assume a table like this:</source>
          <target state="translated">다음과 같은 테이블을 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="d62cfe7fee7bb0995d8fe897df02204b5ae94b18" translate="yes" xml:space="preserve">
          <source>Assume we have dumped a database called &lt;code&gt;mydb&lt;/code&gt; into a custom-format dump file:</source>
          <target state="translated">&lt;code&gt;mydb&lt;/code&gt; 라는 데이터베이스를 사용자 정의 형식 덤프 파일로 덤프했다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="00714db2b04e92390b518c92e4ea170b71450adc" translate="yes" xml:space="preserve">
          <source>Assuming that there is a table called &lt;code&gt;table1&lt;/code&gt;, this command would retrieve all rows and all user-defined columns from &lt;code&gt;table1&lt;/code&gt;. (The method of retrieval depends on the client application. For example, the psql program will display an ASCII-art table on the screen, while client libraries will offer functions to extract individual values from the query result.) The select list specification &lt;code&gt;*&lt;/code&gt; means all columns that the table expression happens to provide. A select list can also select a subset of the available columns or make calculations using the columns. For example, if &lt;code&gt;table1&lt;/code&gt; has columns named &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; (and perhaps others) you can make the following query:</source>
          <target state="translated">테이블 불리는이 있다고 가정하면 &lt;code&gt;table1&lt;/code&gt; ,이 명령은 모든 행과 모든 사용자 정의 열을 검색 할 &lt;code&gt;table1&lt;/code&gt; . (검색 방법은 클라이언트 응용 프로그램에 따라 다릅니다. 예를 들어, psql 프로그램은 화면에 ASCII 아트 테이블을 표시하고 클라이언트 라이브러리는 조회 결과에서 개별 값을 추출하는 기능을 제공합니다.) 선택 목록 스펙 &lt;code&gt;*&lt;/code&gt; 은 테이블 표현식이 제공하는 모든 열. 선택 목록은 사용 가능한 열의 서브 세트를 선택하거나 열을 사용하여 계산할 수도 있습니다. 예를 들어 &lt;code&gt;table1&lt;/code&gt; 에 이름이 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 인 열이 있는 경우 (그리고 아마도 다른 사람들) 다음 쿼리를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89e7e252c06bfdf34cb9f5a168b455ee141acee7" translate="yes" xml:space="preserve">
          <source>Async. MM Repl.</source>
          <target state="translated">비동기. MM Repl.</target>
        </trans-unit>
        <trans-unit id="a6a8e2732fbce126a0a797cdd1e90b4272d9f93c" translate="yes" xml:space="preserve">
          <source>Asynchronous Commit</source>
          <target state="translated">비동기 커밋</target>
        </trans-unit>
        <trans-unit id="1d15a4a3147c0af21cd5fba27008e02e7487f287" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O depends on an effective &lt;code&gt;posix_fadvise&lt;/code&gt; function, which some operating systems lack. If the function is not present then setting this parameter to anything but zero will result in an error. On some operating systems (e.g., Solaris), the function is present but does not actually do anything.</source>
          <target state="translated">비동기 I / O는 일부 운영 체제에없는 효과적인 &lt;code&gt;posix_fadvise&lt;/code&gt; 기능 에 의존합니다 . 기능이 없으면이 매개 변수를 0 이외의 값으로 설정하면 오류가 발생합니다. 일부 운영 체제 (예 : Solaris)에서는 기능이 있지만 실제로는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abb97da8205f09a691f99d2fcdea6f23dc61d65e" translate="yes" xml:space="preserve">
          <source>Asynchronous Multimaster Replication</source>
          <target state="translated">비동기 멀티 마스터 복제</target>
        </trans-unit>
        <trans-unit id="00b2ec7d525c7895ab7759ef95defc6c17d534cd" translate="yes" xml:space="preserve">
          <source>Asynchronous commit introduces the risk of data loss. There is a short time window between the report of transaction completion to the client and the time that the transaction is truly committed (that is, it is guaranteed not to be lost if the server crashes). Thus asynchronous commit should not be used if the client will take external actions relying on the assumption that the transaction will be remembered. As an example, a bank would certainly not use asynchronous commit for a transaction recording an ATM's dispensing of cash. But in many scenarios, such as event logging, there is no need for a strong guarantee of this kind.</source>
          <target state="translated">비동기 커밋은 데이터 손실의 위험이 있습니다. 클라이언트에 대한 트랜잭션 완료 보고서와 트랜잭션이 실제로 커밋 된 시간 사이에 짧은 시간 창이 있습니다 (즉, 서버가 충돌해도 손실되지 않음). 따라서 클라이언트가 트랜잭션이 기억 될 것이라는 가정에 의존하여 외부 조치를 취할 경우 비동기 커밋을 사용해서는 안됩니다. 예를 들어, 은행은 ATM의 현금 분배를 기록하는 트랜잭션에 대해 비동기 커밋을 사용하지 않을 것입니다. 그러나 이벤트 로깅과 같은 많은 시나리오에서는 이러한 종류의 강력한 보장이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d90c24d882782b103f7c8579885000885b06b013" translate="yes" xml:space="preserve">
          <source>Asynchronous commit provides behavior different from setting &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off. &lt;code&gt;fsync&lt;/code&gt; is a server-wide setting that will alter the behavior of all transactions. It disables all logic within PostgreSQL that attempts to synchronize writes to different portions of the database, and therefore a system crash (that is, a hardware or operating system crash, not a failure of PostgreSQL itself) could result in arbitrarily bad corruption of the database state. In many scenarios, asynchronous commit provides most of the performance improvement that could be obtained by turning off &lt;code&gt;fsync&lt;/code&gt;, but without the risk of data corruption.</source>
          <target state="translated">비동기 커밋은 &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off 설정과 다른 동작을 제공합니다 . &lt;code&gt;fsync&lt;/code&gt; 는 모든 트랜잭션의 동작을 변경하는 서버 전체 설정입니다. PostgreSQL 내에서 데이터베이스의 다른 부분에 대한 쓰기 동기화를 시도하는 모든 논리를 비활성화하므로 시스템 충돌 (PostgreSQL 자체의 장애가 아닌 하드웨어 또는 운영 체제 충돌)으로 인해 데이터베이스가 임의로 손상 될 수 있습니다. 상태. 많은 시나리오에서 비동기 커밋은 &lt;code&gt;fsync&lt;/code&gt; 를 해제하여 얻을 수 있지만 데이터 손상의 위험없이 얻을 수있는 대부분의 성능 향상을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="38108f139265527283b18b5d33c78a6ddd380598" translate="yes" xml:space="preserve">
          <source>At a more basic level, it is not clear that solving query optimization with a GA algorithm designed for TSP is appropriate. In the TSP case, the cost associated with any substring (partial tour) is independent of the rest of the tour, but this is certainly not true for query optimization. Thus it is questionable whether edge recombination crossover is the most effective mutation procedure.</source>
          <target state="translated">좀 더 기본적으로 TSP를 위해 설계된 GA 알고리즘으로 쿼리 최적화를 해결하는 것이 적절한 지 확실하지 않습니다. TSP의 경우 하위 문자열 (부분 둘러보기)과 관련된 비용은 나머지 둘러보기와 무관하지만 쿼리 최적화에는 해당되지 않습니다. 따라서, 엣지 재조합 크로스 오버가 가장 효과적인 돌연변이 절차인지는 의문의 여지가있다.</target>
        </trans-unit>
        <trans-unit id="4d29cf5673a23d613acb6f0d1c22f5f4b6b78fcf" translate="yes" xml:space="preserve">
          <source>At all times, PostgreSQL maintains a &lt;em&gt;write ahead log&lt;/em&gt; (WAL) in the &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory of the cluster's data directory. The log records every change made to the database's data files. This log exists primarily for crash-safety purposes: if the system crashes, the database can be restored to consistency by &amp;ldquo;replaying&amp;rdquo; the log entries made since the last checkpoint. However, the existence of the log makes it possible to use a third strategy for backing up databases: we can combine a file-system-level backup with backup of the WAL files. If recovery is needed, we restore the file system backup and then replay from the backed-up WAL files to bring the system to a current state. This approach is more complex to administer than either of the previous approaches, but it has some significant benefits:</source>
          <target state="translated">PostgreSQL 은 &lt;code&gt;pg_wal/&lt;/code&gt; 에 &lt;em&gt;미리 쓰기 로그&lt;/em&gt; (WAL)를 유지합니다클러스터 데이터 디렉토리의 서브 디렉토리. 로그는 데이터베이스의 데이터 파일에 대한 모든 변경 사항을 기록합니다. 이 로그는 주로 충돌 안전을 위해 존재합니다. 시스템이 충돌하면 마지막 체크 포인트 이후에 작성된 로그 항목을 &quot;재생&quot;하여 데이터베이스를 일관성있게 복원 할 수 있습니다. 그러나 로그가 있으면 데이터베이스 백업을위한 세 번째 전략을 사용할 수 있습니다. 파일 시스템 수준 백업을 WAL 파일 백업과 결합 할 수 있습니다. 복구가 필요한 경우 파일 시스템 백업을 복원 한 다음 백업 된 WAL 파일에서 재생하여 시스템을 현재 상태로 만듭니다. 이 방법은 이전 방법 중 하나보다 관리하기가 더 복잡하지만 몇 가지 중요한 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0aa9f0f7a8b54305272b705ab4c8ce4332faa1e" translate="yes" xml:space="preserve">
          <source>At compile time, &lt;code&gt;transaction__start&lt;/code&gt; is converted to a macro called &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; (notice the underscores are single here), which is available by including &lt;code&gt;pg_trace.h&lt;/code&gt;. Add the macro call to the appropriate location in the source code. In this case, it looks like the following:</source>
          <target state="translated">컴파일시에, &lt;code&gt;transaction__start&lt;/code&gt; 은 매크로라고으로 변환됩니다 &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; 포함하여 볼 수 있습니다 (밑줄은 여기에 단 하나 통지), &lt;code&gt;pg_trace.h&lt;/code&gt; 을 . 소스 코드에서 적절한 위치에 매크로 호출을 추가하십시오. 이 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c05bc819458daf00162775e69bb6f11e3009ae1" translate="yes" xml:space="preserve">
          <source>At least as of version 5.1, it should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="translated">버전 5.1 이상에서는 &lt;code&gt;SHMMAX&lt;/code&gt; 와 같은 매개 변수에 대해 특별한 구성을 수행 할 필요가 없습니다. 이는 모든 메모리를 공유 메모리로 사용할 수 있도록 구성된 것으로 보입니다. 이것이 DB / 2와 같은 다른 데이터베이스에 일반적으로 사용되는 일종의 구성입니다.</target>
        </trans-unit>
        <trans-unit id="df036c0dc6f1685c583f36a683953e72b19d8691" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;LEFTARG&lt;/code&gt; and &lt;code&gt;RIGHTARG&lt;/code&gt; must be defined. For binary operators, both must be defined. For right unary operators, only &lt;code&gt;LEFTARG&lt;/code&gt; should be defined, while for left unary operators only &lt;code&gt;RIGHTARG&lt;/code&gt; should be defined.</source>
          <target state="translated">&lt;code&gt;LEFTARG&lt;/code&gt; 및 &lt;code&gt;RIGHTARG&lt;/code&gt; 중 하나 이상을 정의해야합니다. 이진 연산자의 경우 둘 다 정의해야합니다. 오른쪽 단항 연산자의 경우 &lt;code&gt;LEFTARG&lt;/code&gt; 만 정의하고 왼쪽 단항 연산자의 경우 &lt;code&gt;RIGHTARG&lt;/code&gt; 만 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="81523154b2540393f2eb08b2e64447cb44f3b4fa" translate="yes" xml:space="preserve">
          <source>At least one of the following options must be specified to select an action:</source>
          <target state="translated">조치를 선택하려면 다음 옵션 중 하나 이상을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b72121826b7e4651c5d94f2436d0c7ffe3e3c260" translate="yes" xml:space="preserve">
          <source>At least one of these two things has to be ensured, or the PostgreSQL server will be very unreliable.</source>
          <target state="translated">이 두 가지 중 하나 이상이 보장되어야합니다. 그렇지 않으면 PostgreSQL 서버는 매우 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1571c46302d3bf43b10096af00c294a218c61c85" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">구독 당 하나 이상의 행으로 구독 작업자에 대한 정보를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8eaf93cff7d6986839d33f973b6b2eb6f3e3612" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt; for details.</source>
          <target state="translated">구독 작업자에 대한 정보를 표시하는 구독 당 하나 이상의 행. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d5c8007175669495e5c5ec2b3f06db9f4615159" translate="yes" xml:space="preserve">
          <source>At present, any table used as the target of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; must not have a conditional rule, nor an &lt;code&gt;ALSO&lt;/code&gt; rule, nor an &lt;code&gt;INSTEAD&lt;/code&gt; rule that expands to multiple statements.</source>
          <target state="translated">현재 &lt;code&gt;WITH&lt;/code&gt; 에서 데이터 수정 명령문의 대상으로 사용되는 테이블 에는 조건문, &lt;code&gt;ALSO&lt;/code&gt; 규칙 또는 여러 명령문으로 확장 되는 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff0acb0e759b914c8ac0d92fbd4b06b6c52abe9f" translate="yes" xml:space="preserve">
          <source>At present, it's assumed that the sort order for an ordering operator is the default for the referenced operator family, i.e., &lt;code&gt;ASC NULLS LAST&lt;/code&gt;. This might someday be relaxed by adding additional columns to specify sort options explicitly.</source>
          <target state="translated">현재, 정렬 연산자의 정렬 순서는 참조 된 연산자 제품군의 기본값 인 것으로 가정합니다 (예 : &lt;code&gt;ASC NULLS LAST&lt;/code&gt; ) . 정렬 옵션을 명시 적으로 지정하기 위해 추가 열을 추가하여 언젠가 완화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0da87b74c1c3af23d284a826d817211a0d50dbca" translate="yes" xml:space="preserve">
          <source>At present, the &lt;code&gt;soundex&lt;/code&gt;, &lt;code&gt;metaphone&lt;/code&gt;, &lt;code&gt;dmetaphone&lt;/code&gt;, and &lt;code&gt;dmetaphone_alt&lt;/code&gt; functions do not work well with multibyte encodings (such as UTF-8).</source>
          <target state="translated">현재 &lt;code&gt;soundex&lt;/code&gt; , &lt;code&gt;metaphone&lt;/code&gt; , &lt;code&gt;dmetaphone&lt;/code&gt; 및 &lt;code&gt;dmetaphone_alt&lt;/code&gt; 함수는 멀티 바이트 인코딩 (예 : UTF-8)에서 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a78a49f80284f34a995726cc4689e41d04fb4798" translate="yes" xml:space="preserve">
          <source>At present, this setting is supported only on Linux and Windows. The setting is ignored on other systems when set to &lt;code&gt;try&lt;/code&gt;.</source>
          <target state="translated">현재이 설정은 Linux 및 Windows에서만 지원됩니다. &lt;code&gt;try&lt;/code&gt; 로 설정하면 다른 시스템에서 설정이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="965d1f5ec334a9d95d86fe2f92675d08806b41f2" translate="yes" xml:space="preserve">
          <source>At startup, the standby begins by restoring all WAL available in the archive location, calling &lt;code&gt;restore_command&lt;/code&gt;. Once it reaches the end of WAL available there and &lt;code&gt;restore_command&lt;/code&gt; fails, it tries to restore any WAL available in the &lt;code&gt;pg_wal&lt;/code&gt; directory. If that fails, and streaming replication has been configured, the standby tries to connect to the primary server and start streaming WAL from the last valid record found in archive or &lt;code&gt;pg_wal&lt;/code&gt;. If that fails or streaming replication is not configured, or if the connection is later disconnected, the standby goes back to step 1 and tries to restore the file from the archive again. This loop of retries from the archive, &lt;code&gt;pg_wal&lt;/code&gt;, and via streaming replication goes on until the server is stopped or failover is triggered by a trigger file.</source>
          <target state="translated">시작시 대기는 아카이브 위치에서 사용 가능한 모든 WAL을 복원하여 &lt;code&gt;restore_command&lt;/code&gt; 를 호출하여 시작합니다 . 사용 가능한 WAL의 끝에 도달하고 &lt;code&gt;restore_command&lt;/code&gt; 가 실패하면 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리 에서 사용 가능한 WAL을 복원하려고 시도합니다 . 실패하고 스트리밍 복제가 구성된 경우 대기는 기본 서버에 연결을 시도하고 archive 또는 &lt;code&gt;pg_wal&lt;/code&gt; 에있는 마지막 유효한 레코드에서 스트리밍 WAL을 시작합니다 . 실패하거나 스트리밍 복제가 구성되지 않았거나 나중에 연결이 끊어지면 대기는 1 단계로 돌아가서 아카이브에서 파일을 다시 복원하려고합니다. 아카이브 &lt;code&gt;pg_wal&lt;/code&gt; 에서이 재시도 루프, 스트리밍 복제를 통해 서버가 중지되거나 장애 조치가 트리거 파일에 의해 트리거 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="55d8465dd064f760adc6de27f3c71c491c82a460" translate="yes" xml:space="preserve">
          <source>At the &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction isolation level this would cause a serialization failure (with a &lt;code&gt;SQLSTATE&lt;/code&gt; of &lt;code&gt;'40001'&lt;/code&gt;), so there is no possibility of receiving rows out of order under these isolation levels.</source>
          <target state="translated">상기 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 또는 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 트랜잭션 격리 수준이 (A와 직렬화 실패 원인이 &lt;code&gt;SQLSTATE&lt;/code&gt; 의 &lt;code&gt;'40001'&lt;/code&gt; 때문에 이러한 격리 수준에 따라 순서가 열을받을 가능성은 없다).</target>
        </trans-unit>
        <trans-unit id="f4f71998c9c0aa9a84a8100c70ee8a9266c4e5a9" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be performed on the source server. This can take some time (especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used), during which pg_basebackup will appear to be idle.</source>
          <target state="translated">백업을 시작할 때 원본 서버에서 체크 포인트를 수행해야합니다. 이 작업은 시간이 좀 걸릴 수 있으며 (특히 &lt;code&gt;--checkpoint=fast&lt;/code&gt; 옵션을 사용하지 않는 경우) pg_basebackup이 유휴 상태로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d9934a1c03bcddc43aaddd8a50e8957f0b10bf33" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be written on the server the backup is taken from. Especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used, this can take some time during which pg_basebackup will be appear to be idle.</source>
          <target state="translated">백업 시작시 백업을 수행 한 서버에 체크 포인트를 작성해야합니다. 특히 &lt;code&gt;--checkpoint=fast&lt;/code&gt; 옵션을 사용하지 않으면 pg_basebackup이 유휴 상태 인 것으로 표시되는 데 다소 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a42b715d6522241c83704ed30aede2b52fb0a06" translate="yes" xml:space="preserve">
          <source>At the default &amp;ldquo;scale factor&amp;rdquo; of 1, the tables initially contain this many rows:</source>
          <target state="translated">기본 &quot;스케일 팩터&quot;1 인 테이블에는 처음에 다음과 같은 많은 행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1c903746f8f0e8094ed1c641f98efb9a635313ed" translate="yes" xml:space="preserve">
          <source>At the end of each session, &lt;code&gt;UNLISTEN *&lt;/code&gt; is automatically executed.</source>
          <target state="translated">각 세션이 끝나면 &lt;code&gt;UNLISTEN *&lt;/code&gt; 가 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd262012c4caf6374bfb34cbb6a915df644c90b" translate="yes" xml:space="preserve">
          <source>At the end of recovery, &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; held by prepared transactions will require twice the normal number of lock table entries. If you plan on running either a large number of concurrent prepared transactions that normally take &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, or you plan on having one large transaction that takes many &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, you are advised to select a larger value of &lt;code&gt;max_locks_per_transaction&lt;/code&gt;, perhaps as much as twice the value of the parameter on the primary server. You need not consider this at all if your setting of &lt;code&gt;max_prepared_transactions&lt;/code&gt; is 0.</source>
          <target state="translated">복구가 완료되면 준비된 트랜잭션이 보유한 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 에는 일반 잠금 테이블 항목 수의 두 배가 필요합니다. 당신이 일반적으로 가지고 동시 준비 많은 트랜잭션 중 하나를 실행하려는 경우 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 을 많이 필요 하나의 큰 거래가있는에, 또는 당신이 계획 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 을 , 당신의 더 큰 값을 선택하는 것이 좋다 &lt;code&gt;max_locks_per_transaction&lt;/code&gt; 를 두 배의 값으로 아마만큼, 기본 서버의 매개 변수 &lt;code&gt;max_prepared_transactions&lt;/code&gt; 의 설정 이 0 인 경우이를 고려할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="14547baffec9c8ba5963d60806059645bd69fca9" translate="yes" xml:space="preserve">
          <source>At the prompt, the user can type in SQL commands. Ordinarily, input lines are sent to the server when a command-terminating semicolon is reached. An end of line does not terminate a command. Thus commands can be spread over several lines for clarity. If the command was sent and executed without error, the results of the command are displayed on the screen.</source>
          <target state="translated">프롬프트에서 사용자는 SQL 명령을 입력 할 수 있습니다. 일반적으로 명령 종료 세미콜론에 도달하면 입력 라인이 서버로 전송됩니다. 줄의 끝은 명령을 종료하지 않습니다. 따라서 명령을 명확하게하기 위해 여러 줄로 분산시킬 수 있습니다. 명령이 오류없이 전송되고 실행 된 경우 명령 결과가 화면에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a73b24b0f045657de48b1ab740f05e1e597825d0" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="translated">동시에 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; 는 두 번째 문자열에서 단어의 범위를 선택합니다. 위의 예에서 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; 는 단일 단어 &lt;code&gt;'words'&lt;/code&gt; 의 범위를 선택합니다.이 단어 의 트라이 그램은 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1227060ad6250b9807827bf5fbb82f644935b87" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="translated">동시에 &lt;code&gt;strict_word_similarity&lt;/code&gt; 는 두 번째 문자열에서 단어의 범위를 선택합니다. 위의 예에서 &lt;code&gt;strict_word_similarity&lt;/code&gt; 는 트라이 그램 집합이 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; 인 단일 단어 &lt;code&gt;'words'&lt;/code&gt; 의 범위를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="416a07de78793e22bb0ac6ecdc4a78f4b476ae54" translate="yes" xml:space="preserve">
          <source>At the time of creation, all existing heap pages are scanned and a summary index tuple is created for each range, including the possibly-incomplete range at the end. As new pages are filled with data, page ranges that are already summarized will cause the summary information to be updated with data from the new tuples. When a new page is created that does not fall within the last summarized range, that range does not automatically acquire a summary tuple; those tuples remain unsummarized until a summarization run is invoked later, creating initial summaries. This process can be invoked manually using the &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; or &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; functions; automatically when &lt;code&gt;VACUUM&lt;/code&gt; processes the table; or by automatic summarization executed by autovacuum, as insertions occur. (This last trigger is disabled by default and can be enabled with the &lt;code&gt;autosummarize&lt;/code&gt; parameter.) Conversely, a range can be de-summarized using the &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; function, which is useful when the index tuple is no longer a very good representation because the existing values have changed.</source>
          <target state="translated">작성시, 기존의 모든 힙 페이지가 스캔되고 끝에 불완전한 범위를 포함하여 각 범위에 대한 요약 색인 튜플이 작성됩니다. 새 페이지에 데이터가 채워지면 이미 요약 된 페이지 범위로 인해 요약 정보가 새 튜플의 데이터로 업데이트됩니다. 마지막 요약 된 범위에 속하지 않는 새 페이지가 작성되면 해당 범위는 자동으로 요약 튜플을 얻지 않습니다. 이러한 튜플은 나중에 요약 실행을 호출하여 초기 요약을 생성 할 때까지 요약되지 않은 상태로 유지됩니다. 이 프로세스는 &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; 또는 &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; 함수를 사용하여 수동으로 호출 할 수 있습니다 . &lt;code&gt;VACUUM&lt;/code&gt; 일 때 자동테이블을 처리합니다. 또는 삽입이 발생할 때 autovacuum에 의해 실행되는 자동 요약에 의해. (이 마지막 트리거는 기본적으로 비활성화되어 있으며 &lt;code&gt;autosummarize&lt;/code&gt; 매개 변수를 사용하여 활성화 할 수 있습니다 .) 반대로, &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; 함수를 사용하여 범위를 요약 해제 할 수 있습니다 . 이는 인덱스 튜플이 더 이상 좋지 않을 때 유용합니다. 기존 값이 변경 되었기 때문에 표현.</target>
        </trans-unit>
        <trans-unit id="570ab49c8c4979d8f2b45f71407d683f61c768c4" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;pg_proc.dat&lt;/code&gt; has all three columns, &lt;code&gt;prokind&lt;/code&gt;, &lt;code&gt;proisagg&lt;/code&gt;, and &lt;code&gt;proiswindow&lt;/code&gt;, though they will appear only in rows where they have non-default values.</source>
          <target state="translated">이 시점에서 &lt;code&gt;pg_proc.dat&lt;/code&gt; 에는 기본값이 아닌 행에만 표시되지만 &lt;code&gt;prokind&lt;/code&gt; , &lt;code&gt;proisagg&lt;/code&gt; 및 &lt;code&gt;proiswindow&lt;/code&gt; 의 세 열이 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="394da4678018ab888c36788be82e3560af3396a8" translate="yes" xml:space="preserve">
          <source>At this point, you will have an index on the &lt;code&gt;t&lt;/code&gt; column that you can use for similarity searching. A typical query is</source>
          <target state="translated">이 시점에서 유사도 검색에 사용할 수 있는 &lt;code&gt;t&lt;/code&gt; 열에 인덱스가 있습니다 . 일반적인 검색어는</target>
        </trans-unit>
        <trans-unit id="2a3a5c5f47d6770989533a4fd46849cfebf7e2e9" translate="yes" xml:space="preserve">
          <source>At this writing, there are several limitations of the continuous archiving technique. These will probably be fixed in future releases:</source>
          <target state="translated">이 글을 작성할 때 연속 보관 기술에는 몇 가지 제한 사항이 있습니다. 다음 릴리스에서 수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="f3023cb8188912c321e51f84008e15af7ab75428" translate="yes" xml:space="preserve">
          <source>Atomic</source>
          <target state="translated">Atomic</target>
        </trans-unit>
        <trans-unit id="7dfdf2c7a48eb8aa0595b9fdbbeea1555b65d328" translate="yes" xml:space="preserve">
          <source>Atomicity</source>
          <target state="translated">Atomicity</target>
        </trans-unit>
        <trans-unit id="cfaa3dc03c49871e78cddda27fc42c3f092dc0c4" translate="yes" xml:space="preserve">
          <source>Attach a comment to the table &lt;code&gt;mytable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mytable&lt;/code&gt; 테이블에 주석을 첨부하십시오 .</target>
        </trans-unit>
        <trans-unit id="b30d15695b4486ee3edc48c2da787bd31caa82e5" translate="yes" xml:space="preserve">
          <source>Attaching a partition acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table, in addition to &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; locks on the table to be attached and on the default partition (if any).</source>
          <target state="translated">파티션을 연결하면 연결될 테이블 및 기본 파티션 (있는 경우)의 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금 외에 상위 테이블에서 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금이 획득 됩니다.</target>
        </trans-unit>
        <trans-unit id="d4f51e4421d7c33f901d2846a5f5963016f01207" translate="yes" xml:space="preserve">
          <source>Attempt to allow server crashes to produce core files, on platforms where this is possible, by lifting any soft resource limit placed on core files. This is useful in debugging or diagnosing problems by allowing a stack trace to be obtained from a failed server process.</source>
          <target state="translated">코어 파일에 대한 소프트 자원 제한을 해제하여 서버 크래쉬가 가능한 경우 플랫폼에서 코어 파일을 생성하도록 시도하십시오. 이는 실패한 서버 프로세스에서 스택 추적을 확보하여 문제점을 디버깅하거나 진단하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="22d313995c5aa4824bbbe6a43fa47548d5dd9981" translate="yes" xml:space="preserve">
          <source>Attempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. To do this without failing the entire transaction, use savepoints:</source>
          <target state="translated">재고 수량과 함께 새로운 재고 품목을 삽입하십시오. 품목이 이미 존재하는 경우 기존 품목의 재고 수를 업데이트하십시오. 전체 트랜잭션에 실패하지 않고이를 수행하려면 저장 점을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="77a267ab017550f3c7b55ed8bceaa27e998a453f" translate="yes" xml:space="preserve">
          <source>Attempt to terminate all existing connections to the target database before dropping it. See &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; for more information on this option.</source>
          <target state="translated">삭제하기 전에 대상 데이터베이스에 대한 모든 기존 연결을 종료하십시오. 이 옵션에 대한 자세한 정보는 &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="918622fae6a483ce282b6f622cf8bcadbed1c7e1" translate="yes" xml:space="preserve">
          <source>Attempt to terminate all existing connections to the target database. It doesn't terminate if prepared transactions, active logical replication slots or subscriptions are present in the target database.</source>
          <target state="translated">대상 데이터베이스에 대한 모든 기존 연결을 종료하십시오. 준비된 트랜잭션, 활성 논리적 복제 슬롯 또는 구독이 대상 데이터베이스에있는 경우 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76eb27398e988091546915b412edd431f3061249" translate="yes" xml:space="preserve">
          <source>Attempting to drop a table that does not exist is an error. Nevertheless, it is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. (If you like, you can use the &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; variant to avoid the error messages, but this is not standard SQL.)</source>
          <target state="translated">존재하지 않는 테이블을 삭제하려고하면 오류가 발생합니다. 그럼에도 불구하고 SQL 스크립트 파일에서는 테이블을 생성하기 전에 각 테이블을 무조건 삭제 (drop)하여 오류 메시지를 무시하는 것이 일반적이므로 테이블 존재 여부에 관계없이 스크립트가 작동합니다. 원하는 경우 &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; 변형을 사용하여 오류 메시지를 피할 수 있지만 이는 표준 SQL이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a0d00292b426c90d6f3e1dbff7f81bbe2e552240" translate="yes" xml:space="preserve">
          <source>Attempting to enter a date using a mixture of ISO 8601 week-numbering fields and Gregorian date fields is nonsensical, and will cause an error. In the context of an ISO 8601 week-numbering year, the concept of a &amp;ldquo;month&amp;rdquo; or &amp;ldquo;day of month&amp;rdquo; has no meaning. In the context of a Gregorian year, the ISO week has no meaning.</source>
          <target state="translated">ISO 8601 주 번호 매기기 필드와 그레고리력 날짜 필드를 혼합하여 날짜를 입력하려고하면 의미가 없으므로 오류가 발생합니다. ISO 8601 주 번호 연도의 맥락에서 &quot;달&quot;또는 &quot;달의 날&quot;이라는 개념은 의미가 없습니다. 그레고리력 연도의 맥락에서 ISO 주간은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="c85e1c86ef58d9df3e2aa30f481d2a46d06ccc08" translate="yes" xml:space="preserve">
          <source>Attribute to match against the user name in the search when doing search+bind authentication. If no attribute is specified, the &lt;code&gt;uid&lt;/code&gt; attribute will be used.</source>
          <target state="translated">검색 + 바인드 인증을 수행 할 때 검색의 사용자 이름과 일치하는 속성입니다. 속성이 지정되지 않으면 &lt;code&gt;uid&lt;/code&gt; 속성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="666a0c222579ebcb139d2bf4bc0c9f0b94222439" translate="yes" xml:space="preserve">
          <source>Attribute-level foreign data wrapper options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 속성 수준 외부 데이터 래퍼 옵션</target>
        </trans-unit>
        <trans-unit id="81543c9a145dd6869d89d4e634466bddb425f66f" translate="yes" xml:space="preserve">
          <source>Attribute-level options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&quot;keyword = value&quot;문자열과 같은 속성 수준 옵션</target>
        </trans-unit>
        <trans-unit id="75629af51d7c7f120dbb5b462013bfa48af33285" translate="yes" xml:space="preserve">
          <source>Aug</source>
          <target state="translated">Aug</target>
        </trans-unit>
        <trans-unit id="69d97c5797dc7d211aaa4e9229db5c8466d4edef" translate="yes" xml:space="preserve">
          <source>August</source>
          <target state="translated">August</target>
        </trans-unit>
        <trans-unit id="9ac07ce6cd52d678fbe1229a683f5eafa07e3b6a" translate="yes" xml:space="preserve">
          <source>Authenticate using SSL client certificates. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details.</source>
          <target state="translated">SSL 클라이언트 인증서를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-cert&quot;&gt;은 20.12 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b62091287fb724791ca34488a0ab2a9fac4a1e4d" translate="yes" xml:space="preserve">
          <source>Authenticate using a RADIUS server. See &lt;a href=&quot;auth-radius&quot;&gt;Section 20.11&lt;/a&gt; for details.</source>
          <target state="translated">RADIUS 서버를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-radius&quot;&gt;은 20.11 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="82054cdf870e919ceb8345be400ef8ccd343353b" translate="yes" xml:space="preserve">
          <source>Authenticate using an LDAP server. See &lt;a href=&quot;auth-ldap&quot;&gt;Section 20.10&lt;/a&gt; for details.</source>
          <target state="translated">LDAP 서버를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-ldap&quot;&gt;은 20.10 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55d3191d61e9daf8a3de6d8c5454a6099b6e7e03" translate="yes" xml:space="preserve">
          <source>Authenticate using the BSD Authentication service provided by the operating system. See &lt;a href=&quot;auth-bsd&quot;&gt;Section 20.14&lt;/a&gt; for details.</source>
          <target state="translated">운영 체제에서 제공하는 BSD 인증 서비스를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-bsd&quot;&gt;은 20.14 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99ad70b6f56fd0c0d9729bfab969bd959ae5fb53" translate="yes" xml:space="preserve">
          <source>Authenticate using the Pluggable Authentication Modules (PAM) service provided by the operating system. See &lt;a href=&quot;auth-pam&quot;&gt;Section 20.13&lt;/a&gt; for details.</source>
          <target state="translated">운영 체제에서 제공하는 PAM (Pluggable Authentication Modules) 서비스를 사용하여 인증하십시오. 자세한 내용 &lt;a href=&quot;auth-pam&quot;&gt;은 20.13 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ad4053a30971cdd0eca5d90cab892f9f383ba3e" translate="yes" xml:space="preserve">
          <source>Authentication Methods</source>
          <target state="translated">인증 방법</target>
        </trans-unit>
        <trans-unit id="98fb3925f64e0642987c3e7beb38bbfbcaa16576" translate="yes" xml:space="preserve">
          <source>Authentication Problems</source>
          <target state="translated">인증 문제</target>
        </trans-unit>
        <trans-unit id="bcf5b4f7c9dc716b472b6e8b3f05c043e93a5b63" translate="yes" xml:space="preserve">
          <source>Authentication failures and related problems generally manifest themselves through error messages like the following:</source>
          <target state="translated">인증 실패 및 관련 문제는 일반적으로 다음과 같은 오류 메시지를 통해 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4a2641463bda57c970dcaba44cead46536e41155" translate="yes" xml:space="preserve">
          <source>Authentication method</source>
          <target state="translated">인증 방법</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="ae017ff45a4a035cd29d47f616f68029f16fd0e1" translate="yes" xml:space="preserve">
          <source>Automatic Vacuuming</source>
          <target state="translated">자동 진공 청소</target>
        </trans-unit>
        <trans-unit id="7c977c91d67cb7d94506d78b8621aa22f728f9df" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="translated">인덱스의 구조적 무결성에 대한 자동 검증은 논리적으로 불일치를 도입 할 수있는 새로운 또는 제안 된 PostgreSQL 기능의 일반적인 테스트에서 중요한 역할을합니다. 테이블 구조 확인 및 관련 가시성 및 트랜잭션 상태 정보도 비슷한 역할을합니다. 명백한 테스트 전략 중 하나 는 표준 회귀 테스트를 실행할 때 &lt;code&gt;amcheck&lt;/code&gt; 함수를 계속 호출 하는 것입니다. 테스트 실행에 대한 자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;섹션 32.1&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd9a137c5bedfde09ac590ac67aee8327d8ab3c7" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/13/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="translated">인덱스의 구조적 무결성에 대한 자동 확인은 논리적 불일치를 도입 할 수있는 새로운 또는 제안 된 PostgreSQL 기능의 일반적인 테스트에서 역할을합니다. 테이블 구조 및 관련 가시성 및 트랜잭션 상태 정보의 확인도 비슷한 역할을합니다. 한 가지 확실한 테스트 전략은 표준 회귀 테스트를 실행할 때 &lt;code&gt;amcheck&lt;/code&gt; 함수를 지속적으로 호출 하는 것입니다. 테스트 실행에 대한 자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/13/regress-run.html&quot;&gt;섹션 32.1&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="820a99cec2958e050680c6f99db97b790304fa53" translate="yes" xml:space="preserve">
          <source>Automatically drop objects (tables, functions, etc.) that are contained in the schema, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">스키마에 포함 된 객체 (테이블, 함수 등)를 자동으로 삭제하고 해당 객체에 종속 된 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7996658087a343e0aa2b3cf4b1db038fe35de48f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the access method (such as operator classes, operator families, and indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">액세스 방법에 의존하는 객체 (예 : 연산자 클래스, 운영자 패밀리 및 색인)를 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;5.14 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="baccb8c23deca0c76a8a79a9c5f9953c38de8bc4" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the affected objects, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">영향을받는 객체에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="38e895c6814216f5b3e9484010061f8b91dc249f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the aggregate function (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">집계 함수 (예 : 함수를 사용하는 뷰)에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="abc0b1d37273a9737a10dc3892acfa6c92fe5d93" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the collation, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">데이터 정렬에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="745a5a5b00e94aac1eab4bd026b0c3eb4c8c446e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the constraint, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">구속 조건에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e6ef4a74296e736f065e1732a22c73d138658014" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the domain (such as table columns), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">도메인에 의존하는 객체 (예 : 테이블 열)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="660862c86777512d4fcfc8d0ae2ba2705d79fc1b" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">삭제 된 열 또는 제약 조건 (예 : 열을 참조하는 뷰)에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 차례로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ce7ac7937862e4e4126fdf7e2c5724e3de1e23e6" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the extension, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">확장에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6bd522b5b8653034eb0b6145f2ce2e5dacb2cba0" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">외부 테이블 (예 : 뷰)에 의존하는 오브젝트를 자동으로 삭제하고 해당 오브젝트에 의존하는 모든 오브젝트를 차례로 삭제하십시오 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a988e483f220bf7f0532dd68b502a2b7076edf0a" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign-data wrapper (such as foreign tables and servers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">외부 데이터 랩퍼 (예 : 외부 테이블 및 서버)에 의존하는 오브젝트를 자동으로 삭제하고 해당 오브젝트에 종속 된 모든 오브젝트를 차례로 삭제하십시오 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e27007381181e414122b1ae56cdfd1a6d1dab2ad" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the function (such as operators or triggers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">기능에 의존하는 객체 (예 : 연산자 또는 트리거)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1b9c92f0f554dcfb206e40bfd135fab8fe00e7e2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the index, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">색인에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bcb27d2712f35ddb733c1f98ff51f21d7d424aaa" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the language (such as functions in the language), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">언어에 의존하는 객체 (예 : 언어 기능)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2f6d0323ae070e0fb6a9170cf88c29d107b33c44" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the materialized view (such as other materialized views, or regular views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">구체화 된 뷰 (예 : 다른 구체화 된 뷰 또는 일반 뷰)에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 차례로 놓습니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bf9e6848c526fa45713feaa1a3f98743157a4884" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">연산자에 의존하는 객체 (예 : 뷰를 사용하는 뷰)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cbbaf53e6f678b4c8cf5eec8a71b6a7c2ee4f9ea" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator class (such as indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">연산자 클래스 (예 : 인덱스)에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eb5de09991d91e56b807fa44deb753015952ad1e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator family, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">운영자 제품군에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e459a28af6e31c3e35e65f3a6c2487c577b6fa29" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the procedure, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">절차에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b0c32bf11160fbc2a809f14fb04d0b4471ad9003" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the rule, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">규칙에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="de054c43bd92a23004c72d1888e8a17d538b0b78" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the sequence, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">시퀀스에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bb69e1d5d516109b91608eb01c14e7c1738edbdf" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the server (such as user mappings), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">서버에 의존하는 객체 (예 : 사용자 매핑)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="40e6c61745089f774dd3e41d1dc840b568fe3b30" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">테이블에 의존하는 객체 (예 : 뷰)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="53f104557d2e3eaa82997c5ded39fd7f6ba0b2a2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search configuration, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">텍스트 검색 구성에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c790e11a342e191d26db4cfa94c2202262cf7507" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search dictionary, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">텍스트 검색 사전에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5ce0aa99a0b061d5935384944655cf0dc2b98983" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search parser, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">텍스트 검색 파서에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="24a3aa8af1a85db5b902e0817649894b200120f5" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search template, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">텍스트 검색 템플릿에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="52e34eb24e551596b0414271aef19a7a92f41187" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the transform, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">변환에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5430ece32ada38350ecf74986f0bbc942e6e3cfc" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the trigger, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">트리거에 의존하는 객체를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 자동으로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="946c18a9096115a846e5ed6451faa1e38fe8c835" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the type (such as table columns, functions, and operators), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">유형에 의존하는 객체 (예 : 테이블 열, 함수 및 연산자)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 차례로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3d1c86e5f361718e066619a34ceb6e0c61659055" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the view (such as other views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">뷰에 의존하는 객체 (예 : 다른 뷰)를 자동으로 삭제하고 해당 객체에 의존하는 모든 객체를 차례로 삭제합니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3b54adcbf7578fd1e32a97c6d995480099f4e4ee" translate="yes" xml:space="preserve">
          <source>Automatically generate certain C code from SQL code. Currently, this works for &lt;code&gt;EXEC SQL TYPE&lt;/code&gt;.</source>
          <target state="translated">SQL 코드에서 특정 C 코드를 자동으로 생성합니다. 현재 이것은 &lt;code&gt;EXEC SQL TYPE&lt;/code&gt; 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="02a28684ac310395befcd622074bd92c8287b214" translate="yes" xml:space="preserve">
          <source>Automatically install any extensions that this extension depends on that are not already installed. Their dependencies are likewise automatically installed, recursively. The &lt;code&gt;SCHEMA&lt;/code&gt; clause, if given, applies to all extensions that get installed this way. Other options of the statement are not applied to automatically-installed extensions; in particular, their default versions are always selected.</source>
          <target state="translated">이 확장이 종속되지 않은 확장을 아직 설치하지 않은 경우 자동으로 설치하십시오. 그들의 의존성은 마찬가지로 자동적으로 재귀 적으로 설치됩니다. &lt;code&gt;SCHEMA&lt;/code&gt; 가 주어진다면 절은, 이런 식으로 설치 얻을 모든 확장에 적용됩니다. 명령문의 다른 옵션은 자동으로 설치된 확장에 적용되지 않습니다. 특히 기본 버전이 항상 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="82114421ee75a29b216b45460b9e22d194a04f14" translate="yes" xml:space="preserve">
          <source>Automatically propagate the operation to typed tables of the type being altered, and their descendants.</source>
          <target state="translated">조작을 변경중인 유형의 유형이 지정된 테이블 및 해당 하위 항목으로 자동 전파합니다.</target>
        </trans-unit>
        <trans-unit id="8cbbea802a2969bf6986433c47646c8510fbfd3b" translate="yes" xml:space="preserve">
          <source>Automatically restart sequences owned by columns of the truncated table(s).</source>
          <target state="translated">잘린 테이블의 열이 소유 한 시퀀스를 자동으로 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5642bfdf85a2050b70397bd1e7d1e3fa447f8560" translate="yes" xml:space="preserve">
          <source>Automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN.</source>
          <target state="translated">수신이 지정된 LSN에 도달하면 복제를 자동으로 중지하고 정상 종료 상태 0으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="39275b6e09e38bef3ed571db2ef1da8d2f155a4e" translate="yes" xml:space="preserve">
          <source>Automatically truncate all tables that have foreign-key references to any of the named tables, or to any tables added to the group due to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="translated">이름 지정된 테이블 또는 &lt;code&gt;CASCADE&lt;/code&gt; 로 인해 그룹에 추가 된 테이블에 대한 외래 키 참조가있는 모든 테이블을 자동으로 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="1e085180a439697544c8e28954b594a79f078a9d" translate="yes" xml:space="preserve">
          <source>Autovacuum (process)</source>
          <target state="translated">Autovacuum (프로세스)</target>
        </trans-unit>
        <trans-unit id="63b02d90144047f7b0ae09ab6bb39285e944deab" translate="yes" xml:space="preserve">
          <source>Autovacuum is not active during recovery. It will start normally at the end of recovery.</source>
          <target state="translated">Autovacuum은 복구 중에 활성화되지 않습니다. 복구가 끝나면 정상적으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d7773c835487baf5b5c0ec83d176517e017c8f8a" translate="yes" xml:space="preserve">
          <source>Autovacuum worker or launcher waiting to update or read the current state of autovacuum workers.</source>
          <target state="translated">Autovacuum Worker 또는 Launcher가 Autovacuum Worker의 현재 상태를 업데이트하거나 읽기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aa1cd4d844c5afaaef04eccf35c0da21524cd29" translate="yes" xml:space="preserve">
          <source>Autovacuum workers generally don't block other commands. If a process attempts to acquire a lock that conflicts with the &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock held by autovacuum, lock acquisition will interrupt the autovacuum. For conflicting lock modes, see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;. However, if the autovacuum is running to prevent transaction ID wraparound (i.e., the autovacuum query name in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view ends with &lt;code&gt;(to prevent wraparound)&lt;/code&gt;), the autovacuum is not automatically interrupted.</source>
          <target state="translated">Autovacuum 작업자는 일반적으로 다른 명령을 차단하지 않습니다. 프로세스가 autovacuum이 보유한 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금 과 충돌하는 잠금을 획득하려고 시도하면 잠금 획득이 자동 진공을 중단시킵니다. 충돌하는 잠금 모드는 &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;표 13.2를&lt;/a&gt; 참조하십시오 . 그러나 트랜잭션 ID 랩 어라운드를 방지하기 위해 autovacuum이 실행중인 경우 (즉, &lt;code&gt;pg_stat_activity&lt;/code&gt; 보기 의 autovacuum 쿼리 이름 이 &lt;code&gt;(to prevent wraparound)&lt;/code&gt; 끝남 ) autovacuum은 자동으로 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0edc11f659c78d515f96650dad0f6708f4c07fcc" translate="yes" xml:space="preserve">
          <source>Availability of WAL files claimed by this slot. Possible values are:</source>
          <target state="translated">이 슬롯에서 요청한 WAL 파일의 가용성. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df5a7bec123e69676856b9a816b4c6aef10e3a78" translate="yes" xml:space="preserve">
          <source>Available Client Character Sets</source>
          <target state="translated">사용 가능한 클라이언트 문자 세트</target>
        </trans-unit>
        <trans-unit id="820b74a0a5297b8b6e88df74e84d5e81e977acf2" translate="yes" xml:space="preserve">
          <source>Available cipher suite details will vary across OpenSSL versions. Use the command &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; to see actual details for the currently installed OpenSSL version. Note that this list is filtered at run time based on the server key type.</source>
          <target state="translated">사용 가능한 암호 제품군 세부 사항은 OpenSSL 버전에 따라 다릅니다. &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; 명령을 사용하여 현재 설치된 OpenSSL 버전에 대한 실제 세부 사항을보십시오. 이 목록은 서버 키 유형을 기반으로 런타임에 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="ba149cade6a0a4e50af1ecb3e25946c72c71094e" translate="yes" xml:space="preserve">
          <source>Average density of leaf pages</source>
          <target state="translated">리프 페이지의 평균 밀도</target>
        </trans-unit>
        <trans-unit id="f099162f6d15d176bb9a41f82a80ea2cb1d18cf4" translate="yes" xml:space="preserve">
          <source>Average number of transactions that are executed per second, totaled across all sessions active for a measured run. This is used as a measure of the performance characteristics of an instance.</source>
          <target state="translated">측정 된 실행에 대해 활성 상태 인 모든 세션에서 합계 된 초당 실행되는 평균 트랜잭션 수입니다. 이는 인스턴스의 성능 특성을 측정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4903dacf2f00d069a2643728e3f02486ff810d77" translate="yes" xml:space="preserve">
          <source>Average width in bytes of column's entries</source>
          <target state="translated">열 항목의 평균 너비 (바이트)</target>
        </trans-unit>
        <trans-unit id="3e9553fca4b719e6a36df1dda8f90b143771ffd9" translate="yes" xml:space="preserve">
          <source>B-Tree Indexes</source>
          <target state="translated">B- 트리 인덱스</target>
        </trans-unit>
        <trans-unit id="68486e8aa60ef6bf0ca374b07c2662a92ae24f27" translate="yes" xml:space="preserve">
          <source>B-Tree Support Functions</source>
          <target state="translated">B- 트리 지원 기능</target>
        </trans-unit>
        <trans-unit id="717b6f33b42cc7559340881ecec59b687e47a41c" translate="yes" xml:space="preserve">
          <source>B-Tree deduplication is just as effective with &amp;ldquo;duplicates&amp;rdquo; that contain a NULL value, even though NULL values are never equal to each other according to the &lt;code&gt;=&lt;/code&gt; member of any B-Tree operator class. As far as any part of the implementation that understands the on-disk B-Tree structure is concerned, NULL is just another value from the domain of indexed values.</source>
          <target state="translated">B- 트리 중복 제거는 NULL 값이 B- 트리 연산자 클래스 의 &lt;code&gt;=&lt;/code&gt; 멤버 에 따라 서로 동일하지 않더라도 NULL 값을 포함하는 &quot;중복&quot;과 마찬가지로 효과적입니다 . 온 디스크 B- 트리 구조를 이해하는 구현 부분에 관한 한 NULL은 인덱싱 된 값 도메인의 또 다른 값일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="1bea9fad8fb62f91da10ba766f66a246a745ab74" translate="yes" xml:space="preserve">
          <source>B-Tree indexes are not directly aware that under MVCC, there might be multiple extant versions of the same logical table row; to an index, each tuple is an independent object that needs its own index entry. &amp;ldquo;Version duplicates&amp;rdquo; may sometimes accumulate and adversely affect query latency and throughput. This typically occurs with &lt;code&gt;UPDATE&lt;/code&gt;-heavy workloads where most individual updates cannot apply the HOT optimization (often because at least one indexed column gets modified, necessitating a new set of index tuple versions &amp;mdash; one new tuple for &lt;em&gt;each and every&lt;/em&gt; index). In effect, B-Tree deduplication ameliorates index bloat caused by version churn. Note that even the tuples from a unique index are not necessarily &lt;em&gt;physically&lt;/em&gt; unique when stored on disk due to version churn. The deduplication optimization is selectively applied within unique indexes. It targets those pages that appear to have version duplicates. The high level goal is to give &lt;code&gt;VACUUM&lt;/code&gt; more time to run before an &amp;ldquo;unnecessary&amp;rdquo; page split caused by version churn can take place.</source>
          <target state="translated">B- 트리 인덱스는 MVCC에서 동일한 논리적 테이블 행의 기존 버전이 여러 개있을 수 있음을 직접 인식하지 못합니다. 인덱스에 대해 각 튜플은 자체 인덱스 항목이 필요한 독립적 인 개체입니다. &quot;버전 중복&quot;은 때때로 누적되어 쿼리 대기 시간 및 처리량에 부정적인 영향을 미칠 수 있습니다. 이는 일반적으로 대부분의 개별 업데이트가 HOT 최적화를 적용 할 수없는 &lt;code&gt;UPDATE&lt;/code&gt; 가 많은 워크로드에서 발생합니다 (종종 하나 이상의 인덱싱 된 열이 수정되어 새로운 인덱스 튜플 버전 집합 ( &lt;em&gt;각&lt;/em&gt; 인덱스 에 &lt;em&gt;대해&lt;/em&gt; 하나의 새 튜플)이 필요하기 때문에 ). 실제로 B-Tree 중복 제거는 버전 변동으로 인한 인덱스 팽창을 개선합니다. 고유 인덱스의 튜플도 &lt;em&gt;물리적으로&lt;/em&gt; 반드시 필요한 것은 아닙니다.&lt;em&gt;&lt;/em&gt;버전 변동으로 인해 디스크에 저장 될 때 고유합니다. 중복 제거 최적화는 고유 인덱스 내에서 선택적으로 적용됩니다. 버전이 중복 된 것으로 보이는 페이지를 대상으로합니다. 높은 수준의 목표는 버전 변동으로 인한 &quot;불필요한&quot;페이지 분할이 발생하기 전에 &lt;code&gt;VACUUM&lt;/code&gt; 을 실행하는 데 더 많은 시간 을 제공 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9504ad9e3e7718bba2e8ff2d49bd5578d047ea98" translate="yes" xml:space="preserve">
          <source>B-tree equivalent functionality for several data types</source>
          <target state="translated">여러 데이터 유형에 대한 B- 트리 동등한 기능</target>
        </trans-unit>
        <trans-unit id="905661856e09f20be385c26d6a37cee5d0959557" translate="yes" xml:space="preserve">
          <source>B-tree index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 를 통한 B- 트리 인덱스 : &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdeef32a168111374c1be4cd04224fef89dc4b4b" translate="yes" xml:space="preserve">
          <source>B-tree index pages that have become completely empty are reclaimed for re-use. However, there is still a possibility of inefficient use of space: if all but a few index keys on a page have been deleted, the page remains allocated. Therefore, a usage pattern in which most, but not all, keys in each range are eventually deleted will see poor use of space. For such usage patterns, periodic reindexing is recommended.</source>
          <target state="translated">완전히 비워진 B- 트리 인덱스 페이지는 재사용을 위해 회수됩니다. 그러나 여전히 공간을 비효율적으로 사용할 가능성이 있습니다. 페이지에서 몇 개의 인덱스 키를 제외한 모든 키가 삭제 된 경우 페이지는 할당 된 상태로 유지됩니다. 따라서 각 범위에있는 대부분의 키가 결국 삭제되는 사용 패턴은 공간을 제대로 사용하지 않습니다. 이러한 사용 패턴의 경우 주기적 재색 인화가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="065de2528617033a42220233cd1c35a251757908" translate="yes" xml:space="preserve">
          <source>B-tree indexes additionally accept this parameter:</source>
          <target state="translated">B- 트리 색인은이 매개 변수를 추가로 승인합니다.</target>
        </trans-unit>
        <trans-unit id="4e65573a03a3b33fe194962539e298b25562884c" translate="yes" xml:space="preserve">
          <source>B-tree indexes also accept these parameters:</source>
          <target state="translated">B- 트리 인덱스는 다음 매개 변수도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b33f3c038c507d02cde94014e083413eba3062f2" translate="yes" xml:space="preserve">
          <source>B-tree indexes can also be used to retrieve data in sorted order. This is not always faster than a simple scan and sort, but it is often helpful.</source>
          <target state="translated">B- 트리 인덱스를 사용하여 정렬 된 순서로 데이터를 검색 할 수도 있습니다. 이것은 간단한 스캔 및 정렬보다 항상 빠르지는 않지만 종종 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c1aa64fe8a588b4b8c3bb44a5ae5f195209958ec" translate="yes" xml:space="preserve">
          <source>B-tree version number</source>
          <target state="translated">B- 트리 버전 번호</target>
        </trans-unit>
        <trans-unit id="ee82358aad15ad2f88908ab7225b36322cd1065a" translate="yes" xml:space="preserve">
          <source>B-tree, GiST and SP-GiST indexes</source>
          <target state="translated">B- 트리, GiST 및 SP-GiST 인덱스</target>
        </trans-unit>
        <trans-unit id="16921be12274c9c7c84517bda5d89a5ff3df5941" translate="yes" xml:space="preserve">
          <source>B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators:</source>
          <target state="translated">B- 트리는 일부 순서로 정렬 할 수있는 데이터에 대해 동등 및 범위 쿼리를 처리 할 수 ​​있습니다. 특히 PostgreSQL 쿼리 플래너는 인덱싱 된 열이 다음 연산자 중 하나를 사용하여 비교할 때마다 B- 트리 인덱스 사용을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="90fe59b25bb93f64682a57a1af270b45d31afdca" translate="yes" xml:space="preserve">
          <source>B.1. Date/Time Input Interpretation</source>
          <target state="translated">B.1. 날짜 / 시간 입력 해석</target>
        </trans-unit>
        <trans-unit id="9899d2230f4a93f14e01b57b593ac9983fb8a83d" translate="yes" xml:space="preserve">
          <source>B.2. Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">B.2. 유효하지 않거나 모호한 타임 스탬프 처리</target>
        </trans-unit>
        <trans-unit id="3840db4e415d986c6609f0316669636755ab2262" translate="yes" xml:space="preserve">
          <source>B.3. Date/Time Key Words</source>
          <target state="translated">B.3. 날짜 / 시간 키워드</target>
        </trans-unit>
        <trans-unit id="922ab4c02bf090b11d909a4d188dbe702c610716" translate="yes" xml:space="preserve">
          <source>B.4. Date/Time Configuration Files</source>
          <target state="translated">B.4. 날짜 / 시간 구성 파일</target>
        </trans-unit>
        <trans-unit id="58922b284be009208c01702b42070c1a181d5b29" translate="yes" xml:space="preserve">
          <source>B.5. History of Units</source>
          <target state="translated">B.5. 단위의 역사</target>
        </trans-unit>
        <trans-unit id="9355cc4eed5770d5dfbba1271ff86061632e7258" translate="yes" xml:space="preserve">
          <source>B.5. POSIX Time Zone Specifications</source>
          <target state="translated">B.5. POSIX 시간대 사양</target>
        </trans-unit>
        <trans-unit id="ebc2d5b79639788bc98e2a3a622f6560e3933f91" translate="yes" xml:space="preserve">
          <source>B.6. History of Units</source>
          <target state="translated">B.6. 단위의 역사</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="e87cf2c2aaae478fefafcf671d30d2bd91ab190c" translate="yes" xml:space="preserve">
          <source>BEGIN &amp;mdash; start a transaction block</source>
          <target state="translated">BEGIN &amp;mdash; 거래 블록을 시작합니다</target>
        </trans-unit>
        <trans-unit id="e3b1705472dc241e491b245a0698901129b83705" translate="yes" xml:space="preserve">
          <source>BIGNUM math</source>
          <target state="translated">큰 수학</target>
        </trans-unit>
        <trans-unit id="c7854587bf0a26f0dd0236c46e64d140a0d9aa2a" translate="yes" xml:space="preserve">
          <source>BKI</source>
          <target state="translated">BKI</target>
        </trans-unit>
        <trans-unit id="a8e02c60c1fbe70ac08216f4d50adb47cd1b1f47" translate="yes" xml:space="preserve">
          <source>BREs differ from EREs in several respects. In BREs, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;?&lt;/code&gt; are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are &lt;code&gt;\{&lt;/code&gt; and &lt;code&gt;\}&lt;/code&gt;, with &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; by themselves ordinary characters. The parentheses for nested subexpressions are &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt;, with &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; by themselves ordinary characters. &lt;code&gt;^&lt;/code&gt; is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, &lt;code&gt;$&lt;/code&gt; is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and &lt;code&gt;*&lt;/code&gt; is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading &lt;code&gt;^&lt;/code&gt;). Finally, single-digit back references are available, and &lt;code&gt;\&amp;lt;&lt;/code&gt; and &lt;code&gt;\&amp;gt;&lt;/code&gt; are synonyms for &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; respectively; no other escapes are available in BREs.</source>
          <target state="translated">BRE는 여러 측면에서 ERE와 다릅니다. BRE에서 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; 일반 문자이며 해당 기능에 해당하는 문자가 없습니다. 범위의 구분 기호는 &lt;code&gt;\{&lt;/code&gt; 및 &lt;code&gt;\}&lt;/code&gt; 이며 &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 자체는 일반 문자입니다. 중첩 된 하위 표현식의 괄호는 &lt;code&gt;\(&lt;/code&gt; 및 &lt;code&gt;\)&lt;/code&gt; 이며, 그 자체로 일반 문자 가 &lt;code&gt;(&lt;/code&gt; 및 &lt;code&gt;)&lt;/code&gt; 입니다. &lt;code&gt;^&lt;/code&gt; 는 RE의 시작 또는 괄호로 묶인 하위 표현식의 시작 ( &lt;code&gt;$&lt;/code&gt; )을 제외한 일반 문자입니다.RE의 끝 또는 괄호로 묶인 하위 표현식의 끝을 제외하고는 일반 문자이며 &lt;code&gt;*&lt;/code&gt; 는 RE의 시작 또는 괄호로 묶인 하위 표현식의 시작 부분에 나타날 수있는 경우 일반 문자입니다 (가능한 선행 &lt;code&gt;^&lt;/code&gt; 후 ). 마지막으로 한 자리 역 참조가 가능하며 &lt;code&gt;\&amp;lt;&lt;/code&gt; 및 &lt;code&gt;\&amp;gt;&lt;/code&gt; 는 각각 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; 및 &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; 의 동의어입니다 . BRE에는 다른 탈출구가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b45363f80402fee41de7af6a2bc3803bd8fcc804" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Built-in Operator Classes</source>
          <target state="translated">BRIN 색인 : 내장 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="610805949da9a921d5d35ddef0174271633dc849" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Extensibility</source>
          <target state="translated">BRIN 지수 : 확장 성</target>
        </trans-unit>
        <trans-unit id="e9ea37807ed02774eb4219265e764033548569ae" translate="yes" xml:space="preserve">
          <source>BRIN indexes (a shorthand for Block Range INdexes) store summaries about the values stored in consecutive physical block ranges of a table. Like GiST, SP-GiST and GIN, BRIN can support many different indexing strategies, and the particular operators with which a BRIN index can be used vary depending on the indexing strategy. For data types that have a linear sort order, the indexed data corresponds to the minimum and maximum values of the values in the column for each block range. This supports indexed queries using these operators:</source>
          <target state="translated">BRIN 인덱스 (블록 범위 INdexe의 약어)는 테이블의 연속적인 물리적 블록 범위에 저장된 값에 대한 요약을 저장합니다. GiST, SP-GiST 및 GIN과 같이 BRIN은 다양한 인덱싱 전략을 지원할 수 있으며 BRIN 인덱스를 사용할 수있는 특정 연산자는 인덱싱 전략에 따라 다릅니다. 선형 정렬 순서가있는 데이터 형식의 경우 인덱스 된 데이터는 각 블록 범위에 대한 열 값의 최소값과 최대 값에 해당합니다. 이는 다음 연산자를 사용하여 인덱스 된 쿼리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="192104c1f501554301510ea5a728a13a08ab43a4" translate="yes" xml:space="preserve">
          <source>BRIN indexes accept different parameters:</source>
          <target state="translated">BRIN 색인은 다른 매개 변수를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="b838c564f224f8b8543683d11eed0d0437e44e11" translate="yes" xml:space="preserve">
          <source>BRIN indexes can satisfy queries via regular bitmap index scans, and will return all tuples in all pages within each range if the summary info stored by the index is &lt;em&gt;consistent&lt;/em&gt; with the query conditions. The query executor is in charge of rechecking these tuples and discarding those that do not match the query conditions &amp;mdash; in other words, these indexes are lossy. Because a BRIN index is very small, scanning the index adds little overhead compared to a sequential scan, but may avoid scanning large parts of the table that are known not to contain matching tuples.</source>
          <target state="translated">BRIN 인덱스는 정기적 인 비트 맵 인덱스 스캔을 통해 쿼리를 만족시킬 수 있으며 인덱스에 저장된 요약 정보 가 쿼리 조건과 &lt;em&gt;일치&lt;/em&gt; 하면 각 범위 내의 모든 페이지에있는 모든 튜플을 반환합니다 . 쿼리 실행자는 이러한 튜플을 다시 확인하고 쿼리 조건과 일치하지 않는 튜플을 삭제해야합니다. 즉, 이러한 인덱스는 손실됩니다. BRIN 색인이 매우 작기 때문에 색인을 스캔하면 순차 스캔에 비해 오버 헤드가 거의 발생하지 않지만 일치하는 튜플을 포함하지 않는 것으로 알려진 테이블의 많은 부분을 스캔하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="55b3c9c4efac0d4d71eaa3d4c8cc93a475582a37" translate="yes" xml:space="preserve">
          <source>BRIN stands for Block Range Index. BRIN is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table. A &lt;em&gt;block range&lt;/em&gt; is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index. For example, a table storing a store's sale orders might have a date column on which each order was placed, and most of the time the entries for earlier orders will appear earlier in the table as well; a table storing a ZIP code column might have all codes for a city grouped together naturally.</source>
          <target state="translated">BRIN은 블록 범위 색인을 나타냅니다. BRIN은 특정 열이 테이블 내의 실제 위치와 자연적으로 상관되는 매우 큰 테이블을 처리하도록 설계되었습니다. &lt;em&gt;블록 범위는&lt;/em&gt; 표에서 물리적으로 인접하는 페이지의 그룹이고; 각 블록 범위에 대해 일부 요약 정보가 색인에 의해 저장됩니다. 예를 들어, 상점의 판매 주문을 저장하는 테이블에는 각 주문이 작성된 날짜 열이있을 수 있으며 대부분의 경우 이전 주문에 대한 항목도 테이블에서 더 일찍 나타납니다. 우편 번호 열을 저장하는 테이블은 도시에 대한 모든 코드를 자연스럽게 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bca0a807cb4e3535b6c51a06c3bccf47631d7c" translate="yes" xml:space="preserve">
          <source>BSD Authentication</source>
          <target state="translated">BSD 인증</target>
        </trans-unit>
        <trans-unit id="f1a97c299183923139e5920b8bda3da33aa50cdf" translate="yes" xml:space="preserve">
          <source>BSD Authentication in PostgreSQL uses the &lt;code&gt;auth-postgresql&lt;/code&gt; login type and authenticates with the &lt;code&gt;postgresql&lt;/code&gt; login class if that's defined in &lt;code&gt;login.conf&lt;/code&gt;. By default that login class does not exist, and PostgreSQL will use the default login class.</source>
          <target state="translated">PostgreSQL의 BSD 인증은 &lt;code&gt;auth-postgresql&lt;/code&gt; 로그인 유형을 사용하고 &lt;code&gt;login.conf&lt;/code&gt; 에 정의 된 경우 &lt;code&gt;postgresql&lt;/code&gt; 로그인 클래스로 인증합니다 . 기본적으로 로그인 클래스는 존재하지 않으며 PostgreSQL은 기본 로그인 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eebf5442eb861b0130ab1dbae1411845a2d52d61" translate="yes" xml:space="preserve">
          <source>Backend (process)</source>
          <target state="translated">백엔드 (프로세스)</target>
        </trans-unit>
        <trans-unit id="99affebb8bc98ca77c8c04882ebec0dea90a3114" translate="yes" xml:space="preserve">
          <source>Backend Interface</source>
          <target state="translated">백엔드 인터페이스</target>
        </trans-unit>
        <trans-unit id="328769872d8232ec584540b9757369093134e160" translate="yes" xml:space="preserve">
          <source>Backend type</source>
          <target state="translated">백엔드 유형</target>
        </trans-unit>
        <trans-unit id="dc32da7c82d0789e65952daa2c9def14b3058549" translate="yes" xml:space="preserve">
          <source>Background worker (process)</source>
          <target state="translated">백그라운드 작업자 (프로세스)</target>
        </trans-unit>
        <trans-unit id="b848315d26f8ea5458744e8623f2ff6b2080f8c1" translate="yes" xml:space="preserve">
          <source>Background writer (process)</source>
          <target state="translated">백그라운드 작성자 (프로세스)</target>
        </trans-unit>
        <trans-unit id="60f8490b7625580e80d17d5a1df23b1d4de6ebc4" translate="yes" xml:space="preserve">
          <source>Backslash &lt;code&gt;x&lt;/code&gt; followed by one or two hex digits specifies the character with that numeric code</source>
          <target state="translated">백 슬래시 &lt;code&gt;x&lt;/code&gt; 뒤에 1 ~ 2 개의 16 진 숫자가 표시되어 해당 숫자 코드로 문자를 지정합니다</target>
        </trans-unit>
        <trans-unit id="f71436b4e34992baf3c146d9f7bcd610fe7bd64e" translate="yes" xml:space="preserve">
          <source>Backslash Escape Sequence</source>
          <target state="translated">백 슬래시 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="08da95faebff9b822ea5284de54543cc7bd092f0" translate="yes" xml:space="preserve">
          <source>Backslash characters (&lt;code&gt;\&lt;/code&gt;) can be used in the &lt;code&gt;COPY&lt;/code&gt; data to quote data characters that might otherwise be taken as row or column delimiters. In particular, the following characters &lt;em&gt;must&lt;/em&gt; be preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 데이터 에서 백 슬래시 문자 ( &lt;code&gt;\&lt;/code&gt; )를 사용하여 행 또는 열 구분 기호 로 사용할 수있는 데이터 문자를 인용 할 수 있습니다. 특히, 백 슬래시 자체, 개행 문자, 캐리지 리턴 및 현재 구분 기호 문자와 같이 열 값의 일부로 표시되는 문자 &lt;em&gt;는&lt;/em&gt; 백 슬래시 앞에 와야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79f7f8eb79d3eb20be7d5f2fdb2c6cb1e00c749f" translate="yes" xml:space="preserve">
          <source>Backslash followed by one to three octal digits specifies the character with that numeric code</source>
          <target state="translated">백 슬래시 다음에 1 ~ 3 개의 8 진수가 해당 숫자 코드로 문자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7b77925a9192b55418069493a221c26ff154c448" translate="yes" xml:space="preserve">
          <source>Backslash-semicolon is not a meta-command in the same way as the preceding commands; rather, it simply causes a semicolon to be added to the query buffer without any further processing.</source>
          <target state="translated">백 슬래시-세미콜론은 이전 명령과 같은 방식으로 메타 명령이 아닙니다. 오히려 추가 처리없이 쿼리 버퍼에 세미콜론이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3415ee42fbdf165d3ab63673dafeffa9121924ae" translate="yes" xml:space="preserve">
          <source>Backspace (ASCII 8)</source>
          <target state="translated">백 스페이스 (ASCII 8)</target>
        </trans-unit>
        <trans-unit id="ee100250b3b61b298848fb969f8f888fd07a7761" translate="yes" xml:space="preserve">
          <source>Backtrace support is not available on all platforms, and the quality of the backtraces depends on compilation options.</source>
          <target state="translated">역 추적 지원은 일부 플랫폼에서 사용할 수 없으며 역 추적 품질은 컴파일 옵션에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d331ac3f1a6cac9c6991fe1fa25efc25e1bcefe8" translate="yes" xml:space="preserve">
          <source>Backup Manifest File Object</source>
          <target state="translated">백업 매니페스트 파일 개체</target>
        </trans-unit>
        <trans-unit id="379196baf790f4b6fa0825b0de670c43e08df23a" translate="yes" xml:space="preserve">
          <source>Backup Manifest Format</source>
          <target state="translated">백업 매니페스트 형식</target>
        </trans-unit>
        <trans-unit id="22c6cad75143d38691a0caaf6de1d84dce170459" translate="yes" xml:space="preserve">
          <source>Backup Manifest Top-level Object</source>
          <target state="translated">백업 매니페스트 최상위 개체</target>
        </trans-unit>
        <trans-unit id="e141d2d8691eaa6fba3c4489c0fc0d8b0d463b66" translate="yes" xml:space="preserve">
          <source>Backup Manifest WAL Range Object</source>
          <target state="translated">백업 매니페스트 WAL 범위 개체</target>
        </trans-unit>
        <trans-unit id="a5932464fe7ee7685cdde1f28a54e89455da1784" translate="yes" xml:space="preserve">
          <source>Backup and Restore</source>
          <target state="translated">백업 및 복원</target>
        </trans-unit>
        <trans-unit id="171ec47bee8f29611873a226142872b637cc0954" translate="yes" xml:space="preserve">
          <source>Backup verification proceeds in four stages. First, &lt;code&gt;pg_verifybackup&lt;/code&gt; reads the &lt;code&gt;backup_manifest&lt;/code&gt; file. If that file does not exist, cannot be read, is malformed, or fails verification against its own internal checksum, &lt;code&gt;pg_verifybackup&lt;/code&gt; will terminate with a fatal error.</source>
          <target state="translated">백업 확인은 4 단계로 진행됩니다. 먼저 &lt;code&gt;pg_verifybackup&lt;/code&gt; 은 &lt;code&gt;backup_manifest&lt;/code&gt; 파일을 읽습니다 . 해당 파일이 없거나 읽을 수 없거나 형식이 잘못되었거나 자체 내부 체크섬에 대한 확인에 실패하면 &lt;code&gt;pg_verifybackup&lt;/code&gt; 이 치명적인 오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="86e2f1a9ee8c86cb8243f522b50b65e6423c34d6" translate="yes" xml:space="preserve">
          <source>Backward compatibility syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 시스템 컬럼 을 제거하기위한 이전 버전과의 호환성 구문 으로 &lt;code&gt;oid&lt;/code&gt; 시스템 열을 더 이상 추가 할 수 없습니다, 이것은 효과가 없다.</target>
        </trans-unit>
        <trans-unit id="3ea614d7d0d66375e7b59ad1603ddbf9c6954a56" translate="yes" xml:space="preserve">
          <source>Backward fetches are also disallowed when the query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;; therefore &lt;code&gt;SCROLL&lt;/code&gt; may not be specified in this case.</source>
          <target state="translated">쿼리에 &lt;code&gt;FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;FOR SHARE&lt;/code&gt; 가 포함되어 있으면 뒤로 가져 오기도 허용되지 않습니다 . 따라서이 경우 &lt;code&gt;SCROLL&lt;/code&gt; 을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92077d51292270928790f0d07fb2a1301d60ee31" translate="yes" xml:space="preserve">
          <source>Backward-compatible syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 시스템 컬럼 을 제거하기위한 이전 버전과 호환되는 구문 . 으로 &lt;code&gt;oid&lt;/code&gt; 시스템 열을 더 이상 추가 할 수 없습니다, 이것은 효과가 없다.</target>
        </trans-unit>
        <trans-unit id="044409ea2cd85fda028f96eed9a84a9fcc920931" translate="yes" xml:space="preserve">
          <source>Baltic</source>
          <target state="translated">Baltic</target>
        </trans-unit>
        <trans-unit id="485c014f257e394c215c16b50018b7e0c80f4130" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm</source>
          <target state="translated">밑이 10 인 로그</target>
        </trans-unit>
        <trans-unit id="3b9f28dd05a6a2df955f43acccdc39e58fea4d0c" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm (same as &lt;code&gt;log&lt;/code&gt;)</source>
          <target state="translated">밑이 10 인 로그 ( &lt;code&gt;log&lt;/code&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="7d67a1e0565652b8a1f39922bf439ec06adfe28a" translate="yes" xml:space="preserve">
          <source>Basically a thesaurus dictionary replaces all non-preferred terms by one preferred term and, optionally, preserves the original terms for indexing as well. PostgreSQL's current implementation of the thesaurus dictionary is an extension of the synonym dictionary with added &lt;em&gt;phrase&lt;/em&gt; support. A thesaurus dictionary requires a configuration file of the following format:</source>
          <target state="translated">기본적으로 동의어 사전은 모든 비선호 용어를 하나의 선호 용어로 대체하고 선택적으로 색인을 위해 원래 용어도 보존합니다. PostgreSQL의 현재 시소러스 사전의 구현은 &lt;em&gt;구문&lt;/em&gt; 지원 이 추가 된 동의어 사전의 확장입니다 . 동의어 사전에는 다음 형식의 구성 파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e1ddc988e6d784f9a638904386d7cd96020404d0" translate="yes" xml:space="preserve">
          <source>Batching WAL files so that they are transferred every three hours, rather than one at a time</source>
          <target state="translated">한 번에 하나씩이 아니라 3 시간마다 전송되도록 WAL 파일 배치</target>
        </trans-unit>
        <trans-unit id="56ac908a2429c8b6f57e6b53eb261c2b37853b9f" translate="yes" xml:space="preserve">
          <source>Be aware however that such a query will be very inefficient.</source>
          <target state="translated">그러나 이러한 쿼리는 매우 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dd8576c5e404ad1333289b223aeb849843ea4d63" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;COPY&lt;/code&gt; ignores rules. If you want to use &lt;code&gt;COPY&lt;/code&gt; to insert data, you'll need to copy into the correct child table rather than directly into the master. &lt;code&gt;COPY&lt;/code&gt; does fire triggers, so you can use it normally if you use the trigger approach.</source>
          <target state="translated">주의하십시오 &lt;code&gt;COPY&lt;/code&gt; 이 규칙을 무시합니다. &lt;code&gt;COPY&lt;/code&gt; 를 사용 하여 데이터를 삽입하려면 마스터에 직접 저장하지 않고 올바른 하위 테이블에 복사해야합니다. &lt;code&gt;COPY&lt;/code&gt; 는 방아쇠를 사용하므로 방아쇠 접근 방식을 사용하면 정상적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec6516cf2acdacef6ec02909f23a042de655757" translate="yes" xml:space="preserve">
          <source>Be careful that the names and types of the view's columns will be assigned the way you want. For example:</source>
          <target state="translated">보기 열의 이름과 유형이 원하는 방식으로 할당되도록주의하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ecd0bd78d58da0c631755bb828f27e267549d1c" translate="yes" xml:space="preserve">
          <source>Be careful to specify the schema in which you installed the existing &lt;code&gt;hstore&lt;/code&gt; objects.</source>
          <target state="translated">기존 &lt;code&gt;hstore&lt;/code&gt; 오브젝트 를 설치 한 스키마를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3286148c08a1b92253bcb1e687624659972203da" translate="yes" xml:space="preserve">
          <source>Be careful with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. There is no concept of inheritance for the privileges of a &lt;code&gt;CREATEROLE&lt;/code&gt;-role. That means that even if a role does not have a certain privilege but is allowed to create other roles, it can easily create another role with different privileges than its own (except for creating roles with superuser privileges). For example, if the role &amp;ldquo;user&amp;rdquo; has the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege but not the &lt;code&gt;CREATEDB&lt;/code&gt; privilege, nonetheless it can create a new role with the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. Therefore, regard roles that have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege as almost-superuser-roles.</source>
          <target state="translated">&lt;code&gt;CREATEROLE&lt;/code&gt; 권한에 주의하십시오 . &lt;code&gt;CREATEROLE&lt;/code&gt; 역할의 권한에 대한 상속 개념은 없습니다 . 즉, 역할에 특정 권한이 없지만 다른 역할을 만들 수있는 경우에도 자신과 다른 권한으로 다른 역할을 쉽게 만들 수 있습니다 (수퍼 유저 권한으로 역할을 만드는 경우 제외). 역할 &quot;사용자&quot;가있는 경우 예를 들어, &lt;code&gt;CREATEROLE&lt;/code&gt; 의 특권이 아니라 &lt;code&gt;CREATEDB&lt;/code&gt; 의 권한을, 그럼에도 불구하고 그것은을 가진 새로운 역할을 만들 수 있습니다 &lt;code&gt;CREATEDB&lt;/code&gt; 의 권한을. 따라서 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한 이있는 역할을 거의 수퍼 유저 역할로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="e9a084e06d49f90e432ff228c5d493ff5d910d84" translate="yes" xml:space="preserve">
          <source>Be certain that your backup includes all of the files under the database cluster directory (e.g., &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;). If you are using tablespaces that do not reside underneath this directory, be careful to include them as well (and be sure that your backup archives symbolic links as links, otherwise the restore will corrupt your tablespaces).</source>
          <target state="translated">백업에 데이터베이스 클러스터 디렉토리 아래의 모든 파일이 포함되어 있는지 확인하십시오 (예 : &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; ). 이 디렉토리 아래에 있지 않은 테이블 공간을 사용하는 경우 테이블 공간도 포함 시키십시오 (백업이 기호 링크를 링크로 아카이브하는지 확인하십시오. 그렇지 않으면 복원이 테이블 공간을 손상시킵니다).</target>
        </trans-unit>
        <trans-unit id="1cca2cb275ffb0ac1d90a9275a182dd9576c7cb7" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null values&lt;/a&gt; are not considered equal to each other, multiple rows with null values are allowed to exist without violating the unique constraint.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null 값&lt;/a&gt; 은 서로 같지 않은 것으로 간주 되기 때문에 고유 제약 조건을 위반하지 않고 null 값이있는 여러 행이 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8050bf055d69a2c17aebfa6f23142af8cc972e31" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;...&lt;/code&gt; is widely used in data sources, it is allowed as an alternative spelling of &lt;code&gt;..&lt;/code&gt;. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="translated">왜냐하면 &lt;code&gt;...&lt;/code&gt; 널리 데이터 소스로 사용되는, 그것의 다른 철자로 허용된다 &lt;code&gt;..&lt;/code&gt; . 불행히도, 이것은 파싱 모호성을 생성합니다 &lt;code&gt;0...23&lt;/code&gt; 의 상한 이 &lt;code&gt;23&lt;/code&gt; 또는 &lt;code&gt;0.23&lt;/code&gt; 인지 여부는 확실하지 않습니다 . 이것은 &lt;code&gt;seg&lt;/code&gt; 입력의 모든 숫자에서 소수점 앞에 적어도 하나의 숫자를 요구함으로써 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="786d48aa791887748b32e63ec202e2ae60a5fb6e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;CLUSTER&lt;/code&gt; remembers which indexes are clustered, one can cluster the tables one wants clustered manually the first time, then set up a periodic maintenance script that executes &lt;code&gt;CLUSTER&lt;/code&gt; without any parameters, so that the desired tables are periodically reclustered.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; 는 어떤 인덱스가 클러스터링되는지 기억 하기 때문에 처음 수동으로 클러스터링하려는 테이블을 클러스터링 한 다음 매개 변수없이 &lt;code&gt;CLUSTER&lt;/code&gt; 를 실행하는 주기적 유지 보수 스크립트를 설정 하여 원하는 테이블이 주기적으로 재 클러스터됩니다.</target>
        </trans-unit>
        <trans-unit id="483573a468db7932cd30d693208c560bce934759" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;float8&lt;/code&gt; has no meaningful &amp;ldquo;step&amp;rdquo;, we do not define a canonicalization function in this example.</source>
          <target state="translated">때문에 &lt;code&gt;float8&lt;/code&gt; 가 의미있는 &quot;단계&quot;가없는, 우리는이 예에서 정규화 함수를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c58240b228b0ae5aff4efd20c01cc67a3bd5a52" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; calls are never rolled back, sequence objects cannot be used if &amp;ldquo;gapless&amp;rdquo; assignment of sequence numbers is needed. It is possible to build gapless assignment by using exclusive locking of a table containing a counter; but this solution is much more expensive than sequence objects, especially if many transactions need sequence numbers concurrently.</source>
          <target state="translated">때문에 &lt;code&gt;nextval&lt;/code&gt; 및 &lt;code&gt;setval&lt;/code&gt; 에 통화가 롤백되지 않습니다 시퀀스 번호의 &quot;끊김없는&quot;할당이 필요한 경우, 시퀀스 객체는 사용할 수 없습니다. 카운터를 포함하는 테이블의 배타적 잠금을 사용하여 공백없는 할당을 구축 할 수 있습니다. 그러나이 솔루션은 특히 많은 트랜잭션이 시퀀스 번호를 동시에 필요로하는 경우 시퀀스 오브젝트보다 훨씬 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="57fa06eff5bff23d9975c881fe012eee591895a8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt; for details.</source>
          <target state="translated">때문에 &lt;code&gt;smallserial&lt;/code&gt; , &lt;code&gt;serial&lt;/code&gt; 및 &lt;code&gt;bigserial&lt;/code&gt; 시퀀스를 사용하여 구현되며, 어떤 행이 이제까지 삭제되지 않은 경우에도, 열에 표시 값들의 시퀀스에서 &quot;홀&quot;또는 갭이있을 수있다. 해당 값을 포함하는 행이 테이블 열에 성공적으로 삽입되지 않은 경우에도 시퀀스에서 할당 된 값은 여전히 ​​&quot;사용&quot;됩니다. 예를 들어 삽입 트랜잭션이 롤백되는 경우에 발생할 수 있습니다. 참조 &lt;code&gt;nextval()&lt;/code&gt; 에서 &lt;a href=&quot;functions-sequence&quot;&gt;제 9.16&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="3bffe320d485976bda24d70a1ca1896c9923ad97" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;smallserial&lt;/code&gt; , &lt;code&gt;serial&lt;/code&gt; 및 &lt;code&gt;bigserial&lt;/code&gt; 은 시퀀스를 사용하여 구현 되기 때문에 행이 삭제되지 않더라도 열에 나타나는 값 시퀀스에 &quot;구멍&quot;이나 간격이있을 수 있습니다. 시퀀스에서 할당 된 값은 해당 값을 포함하는 행이 테이블 열에 성공적으로 삽입되지 않더라도 여전히 &quot;사용&quot;됩니다. 예를 들어 삽입 트랜잭션이 롤백되는 경우 이러한 상황이 발생할 수 있습니다. 자세한 내용 은 &lt;a href=&quot;functions-sequence&quot;&gt;섹션 9.17의 &lt;/a&gt; &lt;code&gt;nextval()&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2055271ae8273a98d1c3120c9ad69e5bbb4dabd7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;to_tsvector&lt;/code&gt;(&lt;code&gt;NULL&lt;/code&gt;) will return &lt;code&gt;NULL&lt;/code&gt;, it is recommended to use &lt;code&gt;coalesce&lt;/code&gt; whenever a field might be null. Here is the recommended method for creating a &lt;code&gt;tsvector&lt;/code&gt; from a structured document:</source>
          <target state="translated">때문에 &lt;code&gt;to_tsvector&lt;/code&gt; ( &lt;code&gt;NULL&lt;/code&gt; 가 ) 반환 &lt;code&gt;NULL&lt;/code&gt; 을 , 사용하는 것이 좋습니다 &lt;code&gt;coalesce&lt;/code&gt; 필드가 null 수 있습니다 때마다. 구조화 된 문서에서 &lt;code&gt;tsvector&lt;/code&gt; 를 작성하기 위해 권장되는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e67190c3b34212fbd9608f10ce1643e97f3b598d" translate="yes" xml:space="preserve">
          <source>Because JSON containment is nested, an appropriate query can skip explicit selection of sub-objects. As an example, suppose that we have a &lt;code&gt;doc&lt;/code&gt; column containing objects at the top level, with most objects containing &lt;code&gt;tags&lt;/code&gt; fields that contain arrays of sub-objects. This query finds entries in which sub-objects containing both &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; and &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; appear, while ignoring any such keys outside the &lt;code&gt;tags&lt;/code&gt; array:</source>
          <target state="translated">JSON 포함이 중첩되어 있으므로 적절한 쿼리에서 하위 오브젝트의 명시적인 선택을 건너 뛸 수 있습니다. 예를 들어 최상위 수준에 객체가 포함 된 &lt;code&gt;doc&lt;/code&gt; 열이 있고 대부분의 객체 에 하위 객체 배열이 포함 된 &lt;code&gt;tags&lt;/code&gt; 필드가 포함되어 있다고 가정 합니다. 이 쿼리는 &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; 를 모두 포함하는 하위 오브젝트가 나타나는 반면, &lt;code&gt;tags&lt;/code&gt; 배열 외부의 이러한 키는 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="9a6a9b9301894dfb915e7f65b2cfd52739126757" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL does not require constraint names to be unique within a schema (but only per-table), it is possible that there is more than one match for a specified constraint name. In this case &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; will act on all matches. For a non-schema-qualified name, once a match or matches have been found in some schema in the search path, schemas appearing later in the path are not searched.</source>
          <target state="translated">PostgreSQL은 제약 조건 이름이 스키마 내에서 고유해야 할 필요는 없지만 (테이블 당), 지정된 제약 조건 이름과 일치하는 항목이 두 개 이상있을 수 있습니다. 이 경우 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 는 모든 경기에서 작동합니다. 스키마 한정이 아닌 이름의 경우 검색 경로의 일부 스키마에서 일치하는 항목이 발견되면 해당 경로의 후반에 나타나는 스키마는 검색되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1054531abd84ea6ab456598b0cbf13df62bd8f3f" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities.</source>
          <target state="translated">PostgreSQL은 오픈 소스이고 쉽게 확장되므로 많은 회사에서 PostgreSQL을 채택하여 고유 한 장애 조치, 복제 및로드 밸런싱 기능을 갖춘 상용 폐쇄 소스 솔루션을 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="7c927394e6733d9a2cd5092ccd59b8f1d233eaee" translate="yes" xml:space="preserve">
          <source>Because Read Committed mode starts each command with a new snapshot that includes all transactions committed up to that instant, subsequent commands in the same transaction will see the effects of the committed concurrent transaction in any case. The point at issue above is whether or not a &lt;em&gt;single&lt;/em&gt; command sees an absolutely consistent view of the database.</source>
          <target state="translated">커밋 된 읽기 모드는 해당 순간까지 커밋 된 모든 트랜잭션을 포함하는 새 스냅 샷으로 각 명령을 시작하므로 동일한 트랜잭션의 후속 명령은 어떤 경우에도 커밋 된 동시 트랜잭션의 영향을 보게됩니다. 위의 문제는 &lt;em&gt;단일&lt;/em&gt; 명령이 데이터베이스에 대해 일관된 뷰를 보는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="cb5cad886e41acd11550eebbf5881fb1ea7474ee" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g. &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="translated">WAL은 충돌 후 데이터베이스 파일 내용을 복원하므로 데이터 파일 또는 WAL 파일을 안정적으로 저장하기 위해 저널 파일 시스템이 필요하지 않습니다. 실제로 저널링 오버 헤드로 인해 특히 저널링으로 인해 파일 시스템 &lt;em&gt;데이터&lt;/em&gt; 가 디스크로 플러시되는 경우 성능이 저하 될 수 있습니다. 다행히 저널링 중 데이터 플러싱은 파일 시스템 마운트 옵션 (예 : Linux ext3 파일 시스템의 &lt;code&gt;data=writeback&lt;/code&gt; ) 을 사용하여 비활성화 할 수 있습니다 . 저널 파일 시스템은 충돌 후 부팅 속도를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="8e8b8c9914b76b9dd74e86a1ad52e4f86cc8bc3d" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g., &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="translated">WAL은 충돌 후 데이터베이스 파일 내용을 복원하므로 데이터 파일 또는 WAL 파일의 안정적인 저장을 위해 저널 파일 시스템이 필요하지 않습니다. 실제로 저널링 오버 헤드는 특히 저널링으로 인해 파일 시스템 &lt;em&gt;데이터&lt;/em&gt; 가 디스크로 플러시되는 경우 성능을 저하시킬 수 있습니다 . 다행히도 저널링 중 데이터 비우기는 파일 시스템 마운트 옵션 (예 : Linux ext3 파일 시스템의 &lt;code&gt;data=writeback&lt;/code&gt; ) 을 사용하여 비활성화 할 수 있습니다 . 저널링 된 파일 시스템은 충돌 후 부팅 속도를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="af002f2ced30c87d8ca2cfc786b9d6c148a8b054" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;SECURITY DEFINER&lt;/code&gt; function is executed with the privileges of the user that owns it, care is needed to ensure that the function cannot be misused. For security, &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; should be set to exclude any schemas writable by untrusted users. This prevents malicious users from creating objects (e.g., tables, functions, and operators) that mask objects intended to be used by the function. Particularly important in this regard is the temporary-table schema, which is searched first by default, and is normally writable by anyone. A secure arrangement can be obtained by forcing the temporary schema to be searched last. To do this, write &lt;code&gt;pg_temp&lt;/code&gt; as the last entry in &lt;code&gt;search_path&lt;/code&gt;. This function illustrates safe usage:</source>
          <target state="translated">때문에 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 의 기능을 소유하는 사용자의 권한으로 실행, 관리는 기능이 오용되지 않도록 필요합니다. 보안을 위해 신뢰할 수없는 사용자가 쓸 수있는 스키마를 제외하도록 &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; 를 설정해야합니다. 이렇게하면 악의적 인 사용자가 함수에서 사용하려는 개체를 마스크하는 개체 (예 : 테이블, 함수 및 연산자)를 만들 수 없습니다. 이와 관련하여 특히 중요한 임시 테이블 스키마는 기본적으로 먼저 검색되며 일반적으로 누구나 쓸 수 있습니다. 임시 스키마를 마지막으로 검색하도록하여 보안 배열을 확보 할 수 있습니다. 이렇게하려면 &lt;code&gt;search_path&lt;/code&gt; 의 마지막 항목으로 &lt;code&gt;pg_temp&lt;/code&gt; 를 작성 하십시오 . 이 기능은 안전한 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7ccf103cb4c217d06785a0ccdc57267c861dec31" translate="yes" xml:space="preserve">
          <source>Because backslash is not a special character in the &lt;code&gt;CSV&lt;/code&gt; format, &lt;code&gt;\.&lt;/code&gt;, the end-of-data marker, could also appear as a data value. To avoid any misinterpretation, a &lt;code&gt;\.&lt;/code&gt; data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data marker. If you are loading a file created by another application that has a single unquoted column and might have a value of &lt;code&gt;\.&lt;/code&gt;, you might need to quote that value in the input file.</source>
          <target state="translated">백 슬래시는 &lt;code&gt;CSV&lt;/code&gt; 형식 의 특수 문자가 아니기 때문에 &lt;code&gt;\.&lt;/code&gt; 데이터 끝 마커 인 데이터 값으로 표시 될 수도 있습니다. 잘못된 해석을 피하려면 &lt;code&gt;\.&lt;/code&gt; 행에서 고독 항목으로 나타나는 데이터 값은 출력시 자동으로 인용되며 입력시 인용시 데이터 끝 마커로 해석되지 않습니다. 인용되지 않은 단일 열이 있고 값이 &lt;code&gt;\.&lt;/code&gt; 다른 응용 프로그램에서 만든 파일을로드하는 경우 입력 파일에서 해당 값을 인용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8837df7b2c1fb8da3ce2a114226b6b81d22d5575" translate="yes" xml:space="preserve">
          <source>Because column &lt;code&gt;y&lt;/code&gt; is not part of the index's search key, it does not have to be of a data type that the index can handle; it's merely stored in the index and is not interpreted by the index machinery. Also, if the index is a unique index, that is</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 열 은 인덱스 검색 키의 일부가 아니므로 인덱스가 처리 할 수있는 데이터 형식 일 필요는 없습니다. 단지 색인에 저장되며 색인 기계 장치에 의해 해석되지 않습니다. 또한 인덱스가 고유 인덱스 인 경우</target>
        </trans-unit>
        <trans-unit id="3d96d2addf447433c224777bf906ab67b3fda87a" translate="yes" xml:space="preserve">
          <source>Because custom options may need to be set in processes that have not loaded the relevant extension module, PostgreSQL will accept a setting for any two-part parameter name. Such variables are treated as placeholders and have no function until the module that defines them is loaded. When an extension module is loaded, it will add its variable definitions, convert any placeholder values according to those definitions, and issue warnings for any unrecognized placeholders that begin with its extension name.</source>
          <target state="translated">관련 확장 모듈을로드하지 않은 프로세스에서 사용자 지정 옵션을 설정해야 할 수 있으므로 PostgreSQL은 두 부분으로 된 매개 변수 이름에 대한 설정을 허용합니다. 이러한 변수는 자리 표시 자로 취급되며이를 정의하는 모듈이로드 될 때까지 기능이 없습니다. 확장 모듈이로드되면 변수 정의를 추가하고 해당 정의에 따라 자리 표시 자 값을 변환하며 확장 이름으로 시작하는 인식 할 수없는 자리 표시 자에 대한 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="501d8e61189d0ec14bdd409d7b3e2083ee96580b" translate="yes" xml:space="preserve">
          <source>Because each btree operator class imposes a sort order on its data type, btree operator classes (or, really, operator families) have come to be used as PostgreSQL's general representation and understanding of sorting semantics. Therefore, they've acquired some features that go beyond what would be needed just to support btree indexes, and parts of the system that are quite distant from the btree AM make use of them.</source>
          <target state="translated">각 btree 연산자 클래스는 데이터 유형에 정렬 순서를 부과하기 때문에 btree 연산자 클래스 (또는 실제로 연산자 패밀리)는 PostgreSQL의 정렬 의미에 대한 일반적인 표현 및 이해로 사용되었습니다. 따라서, 그들은 btree 인덱스를 지원하는 데 필요한 것 이상의 기능을 얻었으며, btree AM과 거리가 먼 시스템의 일부를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1cf84fc42fc11690b4a8d7c72f78d6f59379bbaa" translate="yes" xml:space="preserve">
          <source>Because each worker executes the parallel portion of the plan to completion, it is not possible to simply take an ordinary query plan and run it using multiple workers. Each worker would produce a full copy of the output result set, so the query would not run any faster than normal but would produce incorrect results. Instead, the parallel portion of the plan must be what is known internally to the query optimizer as a &lt;em&gt;partial plan&lt;/em&gt;; that is, it must be constructed so that each process which executes the plan will generate only a subset of the output rows in such a way that each required output row is guaranteed to be generated by exactly one of the cooperating processes. Generally, this means that the scan on the driving table of the query must be a parallel-aware scan.</source>
          <target state="translated">각 작업자는 계획의 병렬 부분을 완료하기 위해 실행하기 때문에 일반적인 쿼리 계획을 여러 작업자를 사용하여 실행할 수는 없습니다. 각 작업자는 출력 결과 집합의 전체 복사본을 생성하므로 쿼리가 정상보다 빠르게 실행되지는 않지만 잘못된 결과가 생성됩니다. 대신 계획의 병렬 부분은 쿼리 최적화 프로그램에 내부적으로 &lt;em&gt;부분 계획&lt;/em&gt; 으로 알려진 것이어야합니다 . 즉, 계획을 실행하는 각 프로세스가 협력 프로세스 중 하나에 의해 각 필수 출력 행이 생성되도록 보장하는 방식으로 출력 행의 서브 세트 만 생성하도록 구성되어야합니다. 일반적으로 이는 쿼리의 구동 테이블에 대한 스캔이 병렬 인식 스캔이어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f7c3975c53757320af8c077a7aa386b120a149d9" translate="yes" xml:space="preserve">
          <source>Because logical replication is based on a similar architecture as &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;physical streaming replication&lt;/a&gt;, the monitoring on a publication node is similar to monitoring of a physical replication master (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;Section 26.2.5.2&lt;/a&gt;).</source>
          <target state="translated">논리적 복제는 &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;물리적 스트리밍 복제&lt;/a&gt; 와 유사한 아키텍처를 기반으로하기 때문에 게시 노드에서의 모니터링은 물리적 복제 마스터의 모니터링과 유사합니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;섹션 26.2.5.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a2196adb2d7ec23f760e34a49d8237be649fa41e" translate="yes" xml:space="preserve">
          <source>Because of MVCC, it is always necessary to allow duplicate entries to exist physically in an index: the entries might refer to successive versions of a single logical row. The behavior we actually want to enforce is that no MVCC snapshot could include two rows with equal index keys. This breaks down into the following cases that must be checked when inserting a new row into a unique index:</source>
          <target state="translated">MVCC로 인해 중복 항목이 인덱스에 실제로 존재하도록해야합니다. 항목은 단일 논리 행의 연속 버전을 참조 할 수 있습니다. 실제로 적용하려는 동작은 동일한 인덱스 키를 가진 두 개의 행을 MVCC 스냅 샷에 포함시킬 수 없다는 것입니다. 이것은 고유 인덱스에 새 행을 삽입 할 때 확인해야하는 다음과 같은 경우로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="92df70087fcf249f647fdf27a084f1becf03071e" translate="yes" xml:space="preserve">
          <source>Because of limited &lt;code&gt;maintenance_work_mem&lt;/code&gt;, &lt;code&gt;ambulkdelete&lt;/code&gt; might need to be called more than once when many tuples are to be deleted. The &lt;code&gt;stats&lt;/code&gt; argument is the result of the previous call for this index (it is NULL for the first call within a &lt;code&gt;VACUUM&lt;/code&gt; operation). This allows the AM to accumulate statistics across the whole operation. Typically, &lt;code&gt;ambulkdelete&lt;/code&gt; will modify and return the same struct if the passed &lt;code&gt;stats&lt;/code&gt; is not null.</source>
          <target state="translated">때문에 제한의 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 로 , &lt;code&gt;ambulkdelete&lt;/code&gt; 힘의 필요가 많은 튜플이 삭제 될 때 한 번 이상 호출합니다. &lt;code&gt;stats&lt;/code&gt; 인수가이 인덱스에 대한 이전 호출의 결과이다 (이것은 내 첫 번째 통화 NULL이다 &lt;code&gt;VACUUM&lt;/code&gt; 의 동작). 이를 통해 AM은 전체 작업에서 통계를 축적 할 수 있습니다. 일반적으로 &lt;code&gt;ambulkdelete&lt;/code&gt; 는 전달 된 &lt;code&gt;stats&lt;/code&gt; 가 null이 아닌 경우 동일한 구조체를 수정하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="af06227e43627d5f9e3c80ba9b58e41dee4f1bd3" translate="yes" xml:space="preserve">
          <source>Because of the above rules, it is possible for an updating command to see an inconsistent snapshot: it can see the effects of concurrent updating commands on the same rows it is trying to update, but it does not see effects of those commands on other rows in the database. This behavior makes Read Committed mode unsuitable for commands that involve complex search conditions; however, it is just right for simpler cases. For example, consider updating bank balances with transactions like:</source>
          <target state="translated">위의 규칙으로 인해 업데이트 명령이 일치하지 않는 스냅 샷을 볼 수 있습니다. 업데이트하려는 동일한 행에서 동시 업데이트 명령의 영향을 볼 수 있지만 다른 행에서 해당 명령의 영향을 볼 수는 없습니다. 데이터베이스에서. 이 동작으로 인해 커밋 된 읽기 모드는 복잡한 검색 조건이 포함 된 명령에 적합하지 않습니다. 그러나 더 간단한 경우에 적합합니다. 예를 들어 은행 잔고를 다음과 같은 거래로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="094a085e303baa417739feb6622a057e4139e4ba" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it's unwise to give a function that takes a single composite-type argument the same name as any of the fields of that composite type. If there is ambiguity, the field-name interpretation will be chosen if field-name syntax is used, while the function will be chosen if function-call syntax is used. However, PostgreSQL versions before 11 always chose the field-name interpretation, unless the syntax of the call required it to be a function call. One way to force the function interpretation in older versions is to schema-qualify the function name, that is, write &lt;code&gt;schema.func(compositevalue)&lt;/code&gt;.</source>
          <target state="translated">이 동작으로 인해 단일 복합 유형 인수를 사용하여 해당 복합 유형의 필드와 동일한 이름을 갖는 함수를 제공하는 것은 현명하지 않습니다. 모호성이있는 경우 field-name 구문을 사용하면 field-name 해석이 선택되고 function-call 구문을 사용하면 함수가 선택됩니다. 그러나 11 이전의 PostgreSQL 버전은 호출 구문에서 함수 호출이 필요하지 않은 한 항상 필드 이름 해석을 선택했습니다. 이전 버전에서 함수 해석을 강제하는 한 가지 방법은 함수 이름을 스키마로 &lt;code&gt;schema.func(compositevalue)&lt;/code&gt; 즉, schema.func (compositevalue) 작성) .</target>
        </trans-unit>
        <trans-unit id="f6916a8fbcc68029c3a341e8400e967ac545c917" translate="yes" xml:space="preserve">
          <source>Because of this behavior, putting more than one SQL command in a single &lt;code&gt;-c&lt;/code&gt; string often has unexpected results. It's better to use repeated &lt;code&gt;-c&lt;/code&gt; commands or feed multiple commands to psql's standard input, either using echo as illustrated above, or via a shell here-document, for example:</source>
          <target state="translated">이 동작으로 인해 단일 &lt;code&gt;-c&lt;/code&gt; 문자열 에 둘 이상의 SQL 명령을 넣는 경우 종종 예기치 않은 결과가 발생합니다. 반복 된 &lt;code&gt;-c&lt;/code&gt; 명령 을 사용 하거나 위의 그림과 같이 echo를 사용하거나 여기에있는 문서를 통해 psql의 표준 입력에 여러 명령을 공급하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1e30503a8aa4dc4dd17e2394f194dfc73877aea7" translate="yes" xml:space="preserve">
          <source>Because of this convention of possibly renumbering OIDs assigned by patches, the OIDs assigned by a patch should not be considered stable until the patch has been included in an official release. We do not change manually-assigned object OIDs once released, however, as that would create assorted compatibility problems.</source>
          <target state="translated">패치에 의해 할당 된 OID의 번호를 다시 매길 가능성이 있기 때문에 패치에 의해 할당 된 OID는 패치가 공식 릴리스에 포함될 때까지 안정적인 것으로 간주되어서는 안됩니다. 그러나 릴리스 된 후 수동으로 할당 된 개체 OID는 변경되지 않으므로 여러 호환성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="167e13b17a2cb4d9e247d60e890e572062fe98da" translate="yes" xml:space="preserve">
          <source>Because of this indeterminacy, referencing other tables only within sub-selects is safer, though often harder to read and slower than using a join.</source>
          <target state="translated">이러한 불확실성으로 인해 하위 선택 내에서만 다른 테이블을 참조하는 것이 더 안전하지만 조인을 사용하는 것보다 읽기가 어렵고 속도가 느립니다.</target>
        </trans-unit>
        <trans-unit id="71a8fc6262b2555f78a8d5aeb3468844fc9b3fb8" translate="yes" xml:space="preserve">
          <source>Because optimizer statistics are not transferred by &lt;code&gt;pg_upgrade&lt;/code&gt;, you will be instructed to run a command to regenerate that information at the end of the upgrade. You might need to set connection parameters to match your new cluster.</source>
          <target state="translated">옵티 마이저 통계는 &lt;code&gt;pg_upgrade&lt;/code&gt; 에 의해 전송되지 않기 때문에 업그레이드가 끝날 때 해당 정보를 재생성하는 명령을 실행하도록 지시됩니다. 새 클러스터와 일치하도록 연결 매개 변수를 설정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35cef2d44681e7faa9cdda9938f800f990d4dc8" translate="yes" xml:space="preserve">
          <source>Because pg_dump is used to transfer data to newer versions of PostgreSQL, the output of pg_dump can be expected to load into PostgreSQL server versions newer than pg_dump's version. pg_dump can also dump from PostgreSQL servers older than its own version. (Currently, servers back to version 8.0 are supported.) However, pg_dump cannot dump from PostgreSQL servers newer than its own major version; it will refuse to even try, rather than risk making an invalid dump. Also, it is not guaranteed that pg_dump's output can be loaded into a server of an older major version &amp;mdash; not even if the dump was taken from a server of that version. Loading a dump file into an older server may require manual editing of the dump file to remove syntax not understood by the older server. Use of the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option is recommended in cross-version cases, as it can prevent problems arising from varying reserved-word lists in different PostgreSQL versions.</source>
          <target state="translated">pg_dump는 최신 버전의 PostgreSQL로 데이터를 전송하는 데 사용되므로 pg_dump의 출력은 pg_dump 버전보다 최신 PostgreSQL 서버 버전으로로드 될 것으로 예상 할 수 있습니다. pg_dump는 자체 버전보다 오래된 PostgreSQL 서버에서도 덤프 할 수 있습니다. (현재 버전 8.0으로 돌아가는 서버가 지원됩니다.) 그러나 pg_dump는 자체 주요 버전보다 최신 PostgreSQL 서버에서 덤프 할 수 없습니다. 유효하지 않은 덤프를 만들 위험보다는 시도조차 거부합니다. 또한 덤프가 해당 버전의 서버에서 가져온 경우에도 pg_dump의 출력을 이전 주요 버전의 서버로로드 할 수 있다는 보장은 없습니다. 이전 서버로 덤프 파일을로드하면 이전 서버에서 이해하지 못하는 구문을 제거하기 위해 덤프 파일을 수동으로 편집해야 할 수 있습니다. 의 사용 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 이 옵션은 다른 PostgreSQL 버전에서 예약어 목록을 변경하여 발생하는 문제를 방지 할 수 있으므로 버전 간 경우에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="74ecae8ce7298adddc06312de549cde5a1f05bfd" translate="yes" xml:space="preserve">
          <source>Because roles can own database objects and can hold privileges to access other objects, dropping a role is often not just a matter of a quick &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. Any objects owned by the role must first be dropped or reassigned to other owners; and any permissions granted to the role must be revoked.</source>
          <target state="translated">역할은 데이터베이스 객체를 소유 할 수 있고 다른 객체에 액세스 할 수있는 권한을 보유 할 수 있으므로 역할을 삭제하는 것은 종종 빠른 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; 의 문제가 아닙니다 . 역할이 소유 한 모든 객체는 먼저 다른 소유자에게 삭제하거나 다시 할당해야합니다. 역할에 부여 된 모든 권한을 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c6bd276df7f7795dcf1ec012b5fa318dae1fa92" translate="yes" xml:space="preserve">
          <source>Because sequences are non-transactional, changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="translated">시퀀스는 비 트랜잭션이므로 트랜잭션이 롤백되면 &lt;code&gt;setval&lt;/code&gt; 에 의한 변경 사항은 취소되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="045cb510a11b664aff1ae0f9d4a4e6bf852e98a6" translate="yes" xml:space="preserve">
          <source>Because that day was a spring-forward transition date in that time zone, there was no civil time instant 2:30AM; clocks jumped forward from 2AM EST to 3AM EDT. PostgreSQL interprets the given time as if it were standard time (UTC-5), which then renders as 3:30AM EDT (UTC-4).</source>
          <target state="translated">그 날은 그 시간대의 봄을 향한 전이 날짜 였으므로, 오전 2시 30 분의 시민 시간은 없었습니다. 시계는 오전 2시 (EST)에서 오전 3시 (EST)로 전진했습니다. PostgreSQL은 주어진 시간을 표준 시간 (UTC-5) 인 것처럼 해석 한 다음 3:30 AM EDT (UTC-4)로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="f0a1c41a7fd794b4e227af5602d5ab126f9a65b2" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;...&lt;/code&gt; operator is widely used in data sources, it is allowed as an alternative spelling of the &lt;code&gt;..&lt;/code&gt; operator. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="translated">때문에 &lt;code&gt;...&lt;/code&gt; 운영자 널리 데이터 소스로 사용되는, 그것의 다른 철자로 허용된다 &lt;code&gt;..&lt;/code&gt; 연산자. 불행히도 이것은 구문 분석의 모호성을 만듭니다. &lt;code&gt;0...23&lt;/code&gt; 의 상한 이 &lt;code&gt;23&lt;/code&gt; 인지 &lt;code&gt;0.23&lt;/code&gt; 인지는 명확하지 않습니다 . 이 문제는 &lt;code&gt;seg&lt;/code&gt; 입력의 모든 숫자에서 소수점 앞에 하나 이상의 숫자를 요구하여 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4c15eb3326253a984503903ababbb5a012e0e63" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node runs on the leader process, queries which produce a relatively large number of groups in comparison to the number of input rows will appear less favorable to the query planner. For example, in the worst-case scenario the number of groups seen by the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node could be as many as the number of input rows which were seen by all worker processes in the &lt;code&gt;Partial Aggregate&lt;/code&gt; stage. For such cases, there is clearly going to be no performance benefit to using parallel aggregation. The query planner takes this into account during the planning process and is unlikely to choose parallel aggregate in this scenario.</source>
          <target state="translated">&lt;code&gt;Finalize Aggregate&lt;/code&gt; 노드는 리더 프로세스에서 실행 되므로 입력 행 수와 비교하여 비교적 많은 수의 그룹을 생성하는 쿼리는 쿼리 플래너에 덜 적합합니다. 예를 들어 최악의 시나리오에서 &lt;code&gt;Finalize Aggregate&lt;/code&gt; 노드에 표시되는 그룹 수 는 &lt;code&gt;Partial Aggregate&lt;/code&gt; 단계 에서 모든 작업자 프로세스에 표시되는 입력 행 수만큼 될 수 있습니다 . 이러한 경우 병렬 집계를 사용하면 성능상의 이점이 없습니다. 쿼리 플래너는 계획 프로세스 중에이를 고려하여이 시나리오에서 병렬 집계를 선택하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c37bfc8193816ef9726582311c95eb690d59a5d3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;json&lt;/code&gt; type stores an exact copy of the input text, it will preserve semantically-insignificant white space between tokens, as well as the order of keys within JSON objects. Also, if a JSON object within the value contains the same key more than once, all the key/value pairs are kept. (The processing functions consider the last value as the operative one.) By contrast, &lt;code&gt;jsonb&lt;/code&gt; does not preserve white space, does not preserve the order of object keys, and does not keep duplicate object keys. If duplicate keys are specified in the input, only the last value is kept.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; 유형은 입력 텍스트의 정확한 사본을 저장 하기 때문에 JSON 오브젝트 내에서 키 순서뿐만 아니라 토큰 사이의 의미 상 미미한 공백도 보존합니다. 또한 값 내의 JSON 오브젝트에 동일한 키가 두 번 이상 포함되어 있으면 모든 키 / 값 쌍이 유지됩니다. (처리 함수는 마지막 값을 작동 값으로 간주합니다.) 대조적으로, &lt;code&gt;jsonb&lt;/code&gt; 는 공백을 보존하지 않고 오브젝트 키의 순서를 보존하지 않으며 중복 오브젝트 키를 유지하지 않습니다. 입력에 중복 키가 지정되면 마지막 값만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a2b58f4e608829c960ebd5345ab5c69ff0a6f48c" translate="yes" xml:space="preserve">
          <source>Because the cache is shared by all the databases, there will normally be pages from relations not belonging to the current database. This means that there may not be matching join rows in &lt;code&gt;pg_class&lt;/code&gt; for some rows, or that there could even be incorrect joins. If you are trying to join against &lt;code&gt;pg_class&lt;/code&gt;, it's a good idea to restrict the join to rows having &lt;code&gt;reldatabase&lt;/code&gt; equal to the current database's OID or zero.</source>
          <target state="translated">캐시는 모든 데이터베이스에서 공유되므로 일반적으로 현재 데이터베이스에 속하지 않은 관계의 페이지가 있습니다. 이는 일부 행에 대해 &lt;code&gt;pg_class&lt;/code&gt; 에 일치하는 조인 행이 없거나 잘못된 조인이있을 수도 있음을 의미합니다. &lt;code&gt;pg_class&lt;/code&gt; 에 대해 조인하려는 경우 &lt;code&gt;reldatabase&lt;/code&gt; 가 현재 데이터베이스의 OID와 같거나 0 인 행으로 조인을 제한하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="db3d427c20974c56be935e79b307fe146f033de0" translate="yes" xml:space="preserve">
          <source>Because the data directory contains all the data stored in the database, it is essential that it be secured from unauthorized access. &lt;code&gt;initdb&lt;/code&gt; therefore revokes access permissions from everyone but the PostgreSQL user, and optionally, group. Group access, when enabled, is read-only. This allows an unprivileged user in the same group as the cluster owner to take a backup of the cluster data or perform other operations that only require read access.</source>
          <target state="translated">데이터 디렉토리에는 데이터베이스에 저장된 모든 데이터가 포함되므로 무단 액세스로부터 보호해야합니다. 따라서 &lt;code&gt;initdb&lt;/code&gt; 는 PostgreSQL 사용자 및 선택적으로 그룹을 제외한 모든 사용자의 액세스 권한을 취소합니다. 사용 가능한 경우 그룹 액세스는 읽기 전용입니다. 이를 통해 클러스터 소유자와 동일한 그룹의 권한이없는 사용자가 클러스터 데이터의 백업을 수행하거나 읽기 액세스 만 필요한 다른 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1433bfc602856fd35d38e930969e2b25fd0ae1" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator class is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator class.</source>
          <target state="translated">인덱스 메커니즘은 함수를 사용하기 전에 함수에 대한 액세스 권한을 검사하지 않기 때문에 연산자 클래스의 함수 또는 연산자를 포함하여 공용 실행 권한을 부여하는 것이 가장 중요합니다. 이것은 일반적으로 연산자 클래스에 유용한 일종의 함수에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12e05e286bda0df5f833a009aa68ad96a2c3e153" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator family is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator family.</source>
          <target state="translated">인덱스 시스템은 기능을 사용하기 전에 기능에 대한 액세스 권한을 점검하지 않기 때문에 운영자 제품군의 기능 또는 운영자를 포함하여 공개 실행 권한을 부여하는 것이 중요합니다. 이것은 일반적으로 연산자 제품군에 유용한 기능 종류에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05ce34a0d540aca4ce52a5f0344a9da290661688" translate="yes" xml:space="preserve">
          <source>Because the number of possible column combinations is very large, it's impractical to compute multivariate statistics automatically. Instead, &lt;em&gt;extended statistics objects&lt;/em&gt;, more often called just &lt;em&gt;statistics objects&lt;/em&gt;, can be created to instruct the server to obtain statistics across interesting sets of columns.</source>
          <target state="translated">가능한 열 조합의 수가 매우 많으므로 다변량 통계를 자동으로 계산하는 것은 비현실적입니다. 대신, &lt;em&gt;확장 통계 개체는&lt;/em&gt; 더 자주 방금 전화 &lt;em&gt;통계 오브젝트&lt;/em&gt; , 열 흥미로운 세트에서 통계를 얻기 위해 서버를 지시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d0acad31e5ac16c376a00a683ae533e823a54c5" translate="yes" xml:space="preserve">
          <source>Because the planner records statistics about the ordering of tables, it is advisable to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the newly clustered table. Otherwise, the planner might make poor choices of query plans.</source>
          <target state="translated">플래너는 테이블 순서에 대한 통계를 기록 하므로 새로 클러스터 된 테이블 에서 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행하는 것이 좋습니다 . 그렇지 않으면 플래너가 쿼리 계획을 잘못 선택했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d35897de153aa519a54a8b8fb6f5606c68e7ee1" translate="yes" xml:space="preserve">
          <source>Because the two-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; was used in the index above, only a query reference that uses the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; with the same configuration name will use that index. That is, &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; can use the index, but &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; cannot. This ensures that an index will be used only with the same configuration used to create the index entries.</source>
          <target state="translated">위의 색인에서 두 인수 버전의 &lt;code&gt;to_tsvector&lt;/code&gt; 가 사용 &lt;code&gt;to_tsvector&lt;/code&gt; 구성 이름이 동일한 두 인수 버전의 to_tsvector 를 사용하는 쿼리 참조 만 해당 색인을 사용합니다. 즉, &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; 는 색인을 사용할 수 있지만 &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; 는 사용할 수 없습니다. 이렇게하면 인덱스 항목을 작성하는 데 사용 된 것과 동일한 구성으로 만 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3db556aa68ed6f557f519e10166a776c7f49e136" translate="yes" xml:space="preserve">
          <source>Because there are no restrictions on use of a data type once it's been created, creating a base type or range type is tantamount to granting public execute permission on the functions mentioned in the type definition. This is usually not an issue for the sorts of functions that are useful in a type definition. But you might want to think twice before designing a type in a way that would require &amp;ldquo;secret&amp;rdquo; information to be used while converting it to or from external form.</source>
          <target state="translated">데이터 유형이 작성된 후에는 사용에 대한 제한이 없으므로 기본 유형 또는 범위 유형을 작성하는 것이 유형 정의에 언급 된 함수에 대한 공용 실행 권한을 부여하는 데 가장 중요합니다. 이것은 일반적으로 유형 정의에 유용한 함수 종류에는 문제가되지 않습니다. 그러나 &quot;비밀&quot;정보를 외부 형식으로 변환하거나 외부 형식으로 변환하는 데 필요한 방식으로 형식을 디자인하기 전에 두 번 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ceed46db3017cd5cd38ced3fddd77a8ce650db" translate="yes" xml:space="preserve">
          <source>Because these functions return detailed page-level information, access is restricted by default. By default, only the role &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; has &lt;code&gt;EXECUTE&lt;/code&gt; privilege. Superusers of course bypass this restriction. After the extension has been installed, users may issue &lt;code&gt;GRANT&lt;/code&gt; commands to change the privileges on the functions to allow others to execute them. However, it might be preferable to add those users to the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role instead.</source>
          <target state="translated">이러한 기능은 자세한 페이지 수준 정보를 반환하므로 기본적으로 액세스가 제한됩니다. 기본적으로 만 역할 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 는 이 &lt;code&gt;EXECUTE&lt;/code&gt; 특권을. 물론 수퍼 유저는이 제한을 무시합니다. 확장이 설치되면 &lt;code&gt;GRANT&lt;/code&gt; 명령을 실행하여 다른 사용자가 실행할 수 있도록 기능에 대한 권한을 변경할 수 있습니다. 그러나 해당 사용자를 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 역할에 대신 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cab3b5bbab6ef84f87ff0c28b63da48ab8adbf53" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_auth_members&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_auth_members&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">사용자 아이덴티티는 클러스터 전체에서 사용 &lt;code&gt;pg_auth_members&lt;/code&gt; 는 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_auth_members&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9b4bf1d549fcf042c9f5eb8f3493cb9cfe27e7" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_authid&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_authid&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">사용자 ID는 클러스터 전체에 적용 &lt;code&gt;pg_authid&lt;/code&gt; 는 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_authid&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7824c0664ad3fb70745076ae899f66946c9584d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.1, the arguments of the sequence functions were of type &lt;code&gt;text&lt;/code&gt;, not &lt;code&gt;regclass&lt;/code&gt;, and the above-described conversion from a text string to an OID value would happen at run time during each call. For backward compatibility, this facility still exists, but internally it is now handled as an implicit coercion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;regclass&lt;/code&gt; before the function is invoked.</source>
          <target state="translated">PostgreSQL 8.1 이전에는 시퀀스 함수의 인수는 &lt;code&gt;regclass&lt;/code&gt; 가 아닌 &lt;code&gt;text&lt;/code&gt; 유형이었으며 위에서 설명한 텍스트 문자열에서 OID 값으로의 변환은 각 호출 중에 런타임에 발생했습니다. 이전 버전과의 호환성을 위해이 기능은 여전히 ​​존재하지만 내부적으로는 함수가 호출되기 전에 &lt;code&gt;text&lt;/code&gt; 에서 &lt;code&gt;regclass&lt;/code&gt; 로의 암시 적 강제로 처리 됩니다.</target>
        </trans-unit>
        <trans-unit id="5fe2f878504da2e1db73277f0e33ea8b96b5ad9c" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the &lt;code&gt;.*&lt;/code&gt; syntax was not expanded in row constructors, so that writing &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; created a two-field row whose first field was another row value. The new behavior is usually more useful. If you need the old behavior of nested row values, write the inner row value without &lt;code&gt;.*&lt;/code&gt;, for instance &lt;code&gt;ROW(t, 42)&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 8.2 이전에는 &lt;code&gt;.*&lt;/code&gt; 구문이 행 생성자에서 확장되지 않았으므로 &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; 작성하면 첫 번째 필드가 다른 행 값인 2 필드 행이 작성되었습니다. 새로운 행동이 일반적으로 더 유용합니다. 중첩 행 값의 이전 동작이 필요한 경우 &lt;code&gt;.*&lt;/code&gt; 없이 내부 행 값을 작성하십시오 &lt;code&gt;ROW(t, 42)&lt;/code&gt; 예 : ROW (t, 42)) .</target>
        </trans-unit>
        <trans-unit id="e8d01c186f775230385d810745e30ede0c0292d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were respectively called &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;. These names are still available, but are deprecated and will eventually be removed.</source>
          <target state="translated">PostgreSQL 8.2 이전에는 포함 연산자 &lt;code&gt;@&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;@&lt;/code&gt; 을 각각 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 라고했습니다 . 이 이름은 여전히 ​​사용 가능하지만 더 이상 사용되지 않으며 결국 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c036ccc0fef09aace79d8f72b4bc4956e2e6b969" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.3, these functions would silently accept values of several non-string data types as well, due to the presence of implicit coercions from those data types to &lt;code&gt;text&lt;/code&gt;. Those coercions have been removed because they frequently caused surprising behaviors. However, the string concatenation operator (&lt;code&gt;||&lt;/code&gt;) still accepts non-string input, so long as at least one input is of a string type, as shown in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;. For other cases, insert an explicit coercion to &lt;code&gt;text&lt;/code&gt; if you need to duplicate the previous behavior.</source>
          <target state="translated">PostgreSQL 8.3 이전에는 이러한 데이터 유형에서 &lt;code&gt;text&lt;/code&gt; 로 암시적인 강제 변환이 있기 때문에 이러한 함수는 문자열이 아닌 여러 데이터 유형의 값을 자동으로 허용합니다 . 이러한 강압은 종종 놀라운 행동을 유발했기 때문에 제거되었습니다. 그러나 문자열 연결 연산자 ( &lt;code&gt;||&lt;/code&gt; )는 &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;표 9.9에&lt;/a&gt; 표시된 것처럼 하나 이상의 입력이 문자열 유형 인 경우에도 문자열이 아닌 입력을 허용 합니다. 다른 경우 에는 이전 동작을 복제해야하는 경우 명시 적 강제 변환을 &lt;code&gt;text&lt;/code&gt; 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b8019c3d24fcdf13fb68d8305a1528d20dff010" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, psql allowed the first argument of a single-letter backslash command to start directly after the command, without intervening whitespace. Now, some whitespace is required.</source>
          <target state="translated">PostgreSQL 8.4 이전에 psql은 공백없이 중간에 단일 문자 백 슬래시 명령의 첫 번째 인수가 명령 바로 다음에 시작되도록 허용했습니다. 이제 약간의 공백이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="95fbf31e963d4b484912ba157149b28d1649f2d4" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, the &lt;code&gt;OPERATOR&lt;/code&gt; clause could include a &lt;code&gt;RECHECK&lt;/code&gt; option. This is no longer supported because whether an index operator is &amp;ldquo;lossy&amp;rdquo; is now determined on-the-fly at run time. This allows efficient handling of cases where an operator might or might not be lossy.</source>
          <target state="translated">PostgreSQL 8.4 이전에는 &lt;code&gt;OPERATOR&lt;/code&gt; 절에 &lt;code&gt;RECHECK&lt;/code&gt; 옵션 이 포함될 수있었습니다 . 인덱스 연산자의 &quot;손실&quot;여부가 런타임시 즉석에서 결정되므로 더 이상 지원되지 않습니다. 이를 통해 작업자가 손실되거나 손실되지 않는 경우를 효율적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5824a92b6b2740af57b007a3a86225a310d091b7" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, &lt;code&gt;pg_am&lt;/code&gt; contained many additional columns representing properties of index access methods. That data is now only directly visible at the C code level. However, &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; and related functions have been added to allow SQL queries to inspect index access method properties; see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;Table 9.68&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 9.6 이전에는 &lt;code&gt;pg_am&lt;/code&gt; 에 인덱스 액세스 방법의 속성을 나타내는 많은 추가 열이 포함되었습니다. 이 데이터는 이제 C 코드 레벨에서만 직접 볼 수 있습니다. 그러나 &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; 및 관련 함수가 추가되어 SQL 쿼리가 인덱스 액세스 방법 속성을 검사 할 수 있습니다. &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;표 9.68&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="a4765a073d10eb89d73b00161ddb8dddb0be1ef8" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, SQL commands in script files were terminated by newlines, and so they could not be continued across lines. Now a semicolon is &lt;em&gt;required&lt;/em&gt; to separate consecutive SQL commands (though a SQL command does not need one if it is followed by a meta command). If you need to create a script file that works with both old and new versions of pgbench, be sure to write each SQL command on a single line ending with a semicolon.</source>
          <target state="translated">PostgreSQL 9.6 이전에는 스크립트 파일의 SQL 명령이 줄 바꿈으로 종료되었으므로 여러 줄에서 계속할 수 없었습니다. 이제 연속 SQL 명령을 분리 &lt;em&gt;하려면&lt;/em&gt; 세미콜론이 &lt;em&gt;필요&lt;/em&gt; 합니다 (SQL 명령 뒤에 메타 명령이있는 경우 SQL 명령이 필요하지 않음). pgbench의 이전 버전과 새 버전 모두에서 작동하는 스크립트 파일을 작성해야하는 경우 세미콜론으로 끝나는 단일 행에 각 SQL 명령을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="25a91312b02bab209e6a6f9a691f6a084f05d75d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, the &lt;code&gt;-c&lt;/code&gt; option implied &lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--no-psqlrc&lt;/code&gt;); this is no longer the case.</source>
          <target state="translated">PostgreSQL 9.6 이전에는 &lt;code&gt;-c&lt;/code&gt; 옵션에 &lt;code&gt;-X&lt;/code&gt; ( &lt;code&gt;--no-psqlrc&lt;/code&gt; )가 포함되었습니다. 이것은 더 이상 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e88cb3afc9e7c5edbb82c8ba3662818b28a3aaef" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL had the &lt;code&gt;INCLUDE&lt;/code&gt; feature, people sometimes made covering indexes by writing the payload columns as ordinary index columns, that is writing</source>
          <target state="translated">PostgreSQL에 &lt;code&gt;INCLUDE&lt;/code&gt; 기능 이 있기 전에 사람들은 때때로 페이로드 열을 일반 인덱스 열로 작성하여 인덱스를 덮었습니다.</target>
        </trans-unit>
        <trans-unit id="b6ecfe47fb55ef8a0352cf146e2122df69c11049" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.2, the shell-type creation syntax &lt;code&gt;CREATE TYPE name&lt;/code&gt; did not exist. The way to create a new base type was to create its input function first. In this approach, PostgreSQL will first see the name of the new data type as the return type of the input function. The shell type is implicitly created in this situation, and then it can be referenced in the definitions of the remaining I/O functions. This approach still works, but is deprecated and might be disallowed in some future release. Also, to avoid accidentally cluttering the catalogs with shell types as a result of simple typos in function definitions, a shell type will only be made this way when the input function is written in C.</source>
          <target state="translated">PostgreSQL 버전 8.2 이전에는 쉘 유형 작성 구문 &lt;code&gt;CREATE TYPE name&lt;/code&gt; 이 없었습니다. 새로운 기본 유형을 작성하는 방법은 먼저 입력 기능을 작성하는 것입니다. 이 접근법에서 PostgreSQL은 먼저 새로운 데이터 유형의 이름을 입력 함수의 반환 유형으로 인식합니다. 이 상황에서 쉘 유형이 내재적으로 작성된 후 나머지 I / O 기능의 정의에서 참조 될 수 있습니다. 이 방법은 여전히 ​​작동하지만 더 이상 사용되지 않으며 향후 릴리스에서 허용되지 않을 수 있습니다. 또한 함수 정의의 간단한 오타로 인해 실수로 쉘 유형으로 카탈로그를 복잡하게 만들지 않도록 입력 유형이 C로 작성된 경우에만 쉘 유형이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="133cff6a54d531aaca5754e3dd9245f0764b14c3" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the &lt;code&gt;SET&lt;/code&gt; clause was not available, and so older functions may contain rather complicated logic to save, set, and restore &lt;code&gt;search_path&lt;/code&gt;. The &lt;code&gt;SET&lt;/code&gt; clause is far easier to use for this purpose.</source>
          <target state="translated">PostgreSQL 버전 8.3 이전에는 &lt;code&gt;SET&lt;/code&gt; 절을 사용할 수 없었으므로 이전 함수에는 &lt;code&gt;search_path&lt;/code&gt; 를 저장, 설정 및 복원하기위한 복잡한 논리가 포함될 수 있습니다 . &lt;code&gt;SET&lt;/code&gt; 의 절은이 목적을 위해 사용하기에 훨씬 쉽다.</target>
        </trans-unit>
        <trans-unit id="d40dc4e81bdd5f6ad72cddc10364e0a47323f2d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the name of a generated array type was always exactly the element type's name with one underscore character (&lt;code&gt;_&lt;/code&gt;) prepended. (Type names were therefore restricted in length to one less character than other names.) While this is still usually the case, the array type name may vary from this in case of maximum-length names or collisions with user type names that begin with underscore. Writing code that depends on this convention is therefore deprecated. Instead, use &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typarray&lt;/code&gt; to locate the array type associated with a given type.</source>
          <target state="translated">PostgreSQL 버전 8.3 이전에는 생성 된 배열 유형의 이름이 항상 밑줄 문자 ( &lt;code&gt;_&lt;/code&gt; )가 앞에 붙은 요소 유형의 이름 이었습니다. (따라서 유형 이름의 길이는 다른 이름보다 하나 적은 문자로 제한되었습니다.) 이것은 여전히 ​​그렇지만 최대 길이 이름이나 밑줄로 시작하는 사용자 유형 이름과 충돌하는 경우 배열 유형 이름은이 이름과 다를 수 있습니다. . 따라서이 규칙에 따른 코드 작성은 더 이상 사용되지 않습니다. 대신 &lt;code&gt;pg_type&lt;/code&gt; 을 사용하십시오 . 주어진 유형과 연관된 배열 유형을 찾기위한 &lt;code&gt;typarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cde500737c3794e75266509d120c3f451ce96fd" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">누구나 데이터베이스에 액세스하려면 먼저 데이터베이스 서버를 시작해야합니다. 데이터베이스 서버 프로그램을 &lt;code&gt;postgres&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="96a33375376d06d4d560a6a1c1041e7d31e19935" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;. The &lt;code&gt;postgres&lt;/code&gt; program must know where to find the data it is supposed to use. This is done with the &lt;code&gt;-D&lt;/code&gt; option. Thus, the simplest way to start the server is:</source>
          <target state="translated">누구나 데이터베이스에 액세스하려면 데이터베이스 서버를 시작해야합니다. 데이터베이스 서버 프로그램을 &lt;code&gt;postgres&lt;/code&gt; 라고 합니다. &lt;code&gt;postgres&lt;/code&gt; 프로그램은 어디에가 사용하도록되어 데이터를 찾을 수 알고 있어야합니다. 이것은 &lt;code&gt;-D&lt;/code&gt; 옵션으로 수행됩니다 . 따라서 서버를 시작하는 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="222bfa6cd0afdad9a2e9f50eb2cacfa866429974" translate="yes" xml:space="preserve">
          <source>Before doing so, the function should check the sign of &lt;code&gt;offset&lt;/code&gt;: if it is less than zero, raise error &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013) with error text like &amp;ldquo;invalid preceding or following size in window function&amp;rdquo;. (This is required by the SQL standard, although nonstandard operator families might perhaps choose to ignore this restriction, since there seems to be little semantic necessity for it.) This requirement is delegated to the &lt;code&gt;in_range&lt;/code&gt; function so that the core code needn't understand what &amp;ldquo;less than zero&amp;rdquo; means for a particular data type.</source>
          <target state="translated">그렇게하기 전에 함수는 &lt;code&gt;offset&lt;/code&gt; 의 부호를 확인해야합니다 . 0보다 작 으면 &quot;창 함수에서 유효하지 않은 선행 또는 후속 크기&quot;와 같은 오류 텍스트로 오류 &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013)를 발생시킵니다. (비표준 연산자 패밀리는 의미 상 필요성이 거의 없기 때문에이 제한을 무시하도록 선택할 수도 있지만 이는 SQL 표준에 필요합니다.)이 요구 사항은 코어 코드를 이해할 필요가 없도록 &lt;code&gt;in_range&lt;/code&gt; 함수에 위임됩니다. 특정 데이터 유형에 대해 &quot;0보다 작은&quot;의 의미</target>
        </trans-unit>
        <trans-unit id="9433a751fdf2c9c611a9f86077418abf326bf14a" translate="yes" xml:space="preserve">
          <source>Before restoring an SQL dump, all the users who own objects or were granted permissions on objects in the dumped database must already exist. If they do not, the restore will fail to recreate the objects with the original ownership and/or permissions. (Sometimes this is what you want, but usually it is not.)</source>
          <target state="translated">SQL 덤프를 복원하기 전에 오브젝트를 소유하거나 덤프 된 데이터베이스의 오브젝트에 대한 권한이 부여 된 모든 사용자가 이미 존재해야합니다. 그렇지 않은 경우 복원은 원래 소유권 및 / 또는 권한으로 오브젝트를 다시 작성하지 못합니다. (때로는 이것이 원하는 것이지만 일반적으로 그렇지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="5350218eee7862579014da56e03f9c4a8c7df37f" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="translated">&lt;code&gt;ATTACH PARTITION&lt;/code&gt; 명령을 실행하기 전에 테이블에서 원하는 파티션 제한 조건과 일치하도록 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건 을 작성하는 것이 좋습니다 . 이렇게하면 시스템이 암시 적 파티션 제약 조건의 유효성을 검사하기 위해 검색을 건너 뛸 수 있습니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건이 없으면 해당 파티션에서 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금 을 유지 하고 부모 테이블에서 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금 을 유지하면서 파티션 제약 조건을 확인하기 위해 테이블을 스캔 합니다. &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 이 완료된 후 중복 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 을 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0534112e08b3f377dcff7dae34fa42dedf03836d" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan which is otherwise needed to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="translated">&lt;code&gt;ATTACH PARTITION&lt;/code&gt; 명령을 실행하기 전에 원하는 파티션 제약 조건과 일치하는 첨부 할 테이블에 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 을 만드는 것이 좋습니다 . 이렇게하면 시스템은 암시 적 파티션 제약 조건의 유효성을 검사하는 데 필요한 스캔을 건너 뛸 수 있습니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건이 없으면 해당 파티션에 대한 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금과 상위 테이블에 대한 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금 을 유지하면서 파티션 제약 조건의 유효성을 검사하기 위해 테이블을 스캔 합니다. &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 이 완료된 후 중복 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 을 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6cd8ecaf3b3090d8469e126e6ec0aadfd531ece9" translate="yes" xml:space="preserve">
          <source>Before we proceed, you should understand the basic PostgreSQL system architecture. Understanding how the parts of PostgreSQL interact will make this chapter somewhat clearer.</source>
          <target state="translated">계속 진행하기 전에 기본 PostgreSQL 시스템 아키텍처를 이해해야합니다. PostgreSQL의 일부가 상호 작용하는 방식을 이해하면이 장이 다소 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="2bd6b34f5ab63eba4552e311eedb5465ee67a88a" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="translated">어떤 작업을 수행하기 전에 디스크의 데이터베이스 저장 영역을 초기화해야합니다. 이것을 &lt;em&gt;데이터베이스 클러스터&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . SQL 표준은 카탈로그 클러스터라는 용어를 사용합니다. 데이터베이스 클러스터는 실행중인 데이터베이스 서버의 단일 인스턴스로 관리되는 데이터베이스의 모음입니다. 초기화 후 데이터베이스 클러스터에는 &lt;code&gt;postgres&lt;/code&gt; 라는 데이터베이스가 포함되며 이는 유틸리티, 사용자 및 타사 응용 프로그램에서 사용하기위한 기본 데이터베이스로 사용됩니다. 데이터베이스 서버 자체에는 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 필요하지 않지만 많은 외부 유틸리티 프로그램이 존재한다고 가정합니다. 초기화 중에 각 클러스터 내에 생성 된 다른 데이터베이스를 &lt;code&gt;template1&lt;/code&gt; 이라고합니다.. 이름에서 알 수 있듯이 이것은 나중에 생성 된 데이터베이스의 템플릿으로 사용됩니다. 실제 작업에 사용해서는 안됩니다. 클러스터 내에서 새 데이터베이스를 작성하는 방법에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;22 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80b6d48dacb8cea98d5f49fb8a5fb0ff5e17a88f" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="translated">작업을 수행하기 전에 디스크에서 데이터베이스 저장 영역을 초기화해야합니다. 이것을 &lt;em&gt;데이터베이스 클러스터&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . (SQL 표준에서는 카탈로그 클러스터라는 용어를 사용합니다.) 데이터베이스 클러스터는 실행중인 데이터베이스 서버의 단일 인스턴스에서 관리하는 데이터베이스 모음입니다. 초기화 후 데이터베이스 클러스터에는 유틸리티, 사용자 및 타사 응용 프로그램에서 사용하는 기본 데이터베이스 인 &lt;code&gt;postgres&lt;/code&gt; 라는 데이터베이스가 포함 됩니다. 데이터베이스 서버 자체에는 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 필요하지 않지만 많은 외부 유틸리티 프로그램이 존재한다고 가정합니다. 초기화 중에 각 클러스터 내에 생성 된 또 다른 데이터베이스를 &lt;code&gt;template1&lt;/code&gt; 이라고합니다.. 이름에서 알 수 있듯이 이는 이후에 생성되는 데이터베이스의 템플릿으로 사용됩니다. 실제 작업에 사용해서는 안됩니다. ( 클러스터 내에서 새 데이터베이스를 만드는 방법에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;22 장을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="c5021e6ec2c149bc593346cdbced55fdf083dae8" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE EXTENSION&lt;/code&gt; 을 사용하여 확장을 데이터베이스에로드 하기 전에 확장의 지원 파일을 설치해야합니다. PostgreSQL과 함께 제공되는 확장 설치에 ​​대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;추가 제공 모듈&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="083511ee8f3db20d9fdeeef0f34879a74ab033ad" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하기 전에 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 데이터베이스로 확장을로드, 확장의 지원 파일을 설치해야합니다. PostgreSQL과 함께 제공되는 확장 설치에 ​​대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;추가 제공 모듈&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b42b034c7e4f7289aaf07ce4a58233afbf01dc95" translate="yes" xml:space="preserve">
          <source>Before you can use PostgreSQL you need to install it, of course. It is possible that PostgreSQL is already installed at your site, either because it was included in your operating system distribution or because the system administrator already installed it. If that is the case, you should obtain information from the operating system documentation or your system administrator about how to access PostgreSQL.</source>
          <target state="translated">물론 PostgreSQL을 사용하려면 먼저 설치해야합니다. 운영 체제 배포에 포함되어 있거나 시스템 관리자가 이미 설치했기 때문에 PostgreSQL이 이미 사이트에 설치되었을 수 있습니다. 이 경우 운영 체제 설명서 또는 시스템 관리자로부터 PostgreSQL 액세스 방법에 대한 정보를 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="b26dbac1aa32ad5c0e931ef76f5f13b493f4cca5" translate="yes" xml:space="preserve">
          <source>Begin recovery on the standby server from the local WAL archive, using &lt;code&gt;restore_command&lt;/code&gt; that waits as described previously (see &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">앞에서 설명한대로 대기 하는 &lt;code&gt;restore_command&lt;/code&gt; 를 사용하여 로컬 WAL 아카이브에서 대기 서버에서 복구를 시작 하십시오 ( &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;25.3.4 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b089abb1b8e490f01578f107a306004e919d4fa6" translate="yes" xml:space="preserve">
          <source>Begin streaming changes from the logical replication slot specified by &lt;code&gt;--slot&lt;/code&gt;, continuing until terminated by a signal. If the server side change stream ends with a server shutdown or disconnect, retry in a loop unless &lt;code&gt;--no-loop&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--slot&lt;/code&gt; 에 의해 지정된 논리적 복제 슬롯 에서 신호 변경이있을 때까지 계속 변경 사항을 스트리밍하십시오 . 서버 측 변경 스트림이 서버 종료 또는 연결 끊기로 끝나는 경우 &lt;code&gt;--no-loop&lt;/code&gt; 를 지정 하지 않으면 루프에서 다시 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="5723f3fda46717e1c7feda49b72b28e567ff2c36" translate="yes" xml:space="preserve">
          <source>Begin the output with a command to create the database itself and reconnect to the created database. (With a script of this form, it doesn't matter which database in the destination installation you connect to before running the script.) If &lt;code&gt;--clean&lt;/code&gt; is also specified, the script drops and recreates the target database before reconnecting to it.</source>
          <target state="translated">데이터베이스 자체를 작성하고 작성된 데이터베이스에 다시 연결하는 명령으로 출력을 시작하십시오. 이 형식의 스크립트를 사용하면 스크립트를 실행하기 전에 대상 설치에서 어떤 데이터베이스를 연결하든 상관 없습니다. &lt;code&gt;--clean&lt;/code&gt; 도 지정하면 스크립트는 대상 데이터베이스를 다시 연결하기 전에 삭제하고 다시 만듭니다.</target>
        </trans-unit>
        <trans-unit id="039cd3e67eb5290833876444452a3461967b021e" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.1, these index types also support index searches for &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;ILIKE&lt;/code&gt;, for example</source>
          <target state="translated">PostgreSQL 9.1부터이 인덱스 유형은 &lt;code&gt;LIKE&lt;/code&gt; 및 &lt;code&gt;ILIKE&lt;/code&gt; 에 대한 인덱스 검색도 지원 합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="50f6ae535e6d21e272577a4aeb90ccdf9bd1fc99" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.3, these index types also support index searches for regular-expression matches (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; operators), for example</source>
          <target state="translated">PostgreSQL 9.3부터 이러한 인덱스 유형은 정규 표현식 일치 ( &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~*&lt;/code&gt; 연산자)에 대한 인덱스 검색도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e18ae86eb6dacc56f3e992def21c4e72f662c365" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">단지처럼 행동 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 그 변경을 제외하고 기능은 소비되지 않는다; 즉, 향후 통화시 다시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2cc29d4604bab2d23897cf42e9aa658714f98b76" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt; and that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">변경 사항이 &lt;code&gt;bytea&lt;/code&gt; 로 리턴되고 변경 사항이 소비되지 않는다는 점을 제외하고 는 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 함수와 동일하게 작동합니다 . 즉, 향후 통화시 다시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0d8b3d76c539629fdd464e88d07fda0a141c2719" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">변경 사항이 &lt;code&gt;bytea&lt;/code&gt; 로 리턴된다는 점을 제외하고 는 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 함수와 동일하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="52757979ec3d8a6995e55b22d0069c2c9da4e33a" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_peek_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">변경 사항이 &lt;code&gt;bytea&lt;/code&gt; 로 반환된다는 점을 제외 하면 &lt;code&gt;pg_logical_slot_peek_changes()&lt;/code&gt; 함수와 동일하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="10e28951f118886fb1db9aad1518cc8230f657d1" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, except that it acquires a shared lock rather than exclusive lock on each retrieved row. A shared lock blocks other transactions from performing &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; or &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; on these rows, but it does not prevent them from performing &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">검색된 각 행에서 독점 잠금이 아닌 공유 잠금을 획득한다는 점을 제외하고 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; 와 유사하게 작동 합니다. 공유 잠금은 다른 트랜잭션 이이 행에서 &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; 를 수행하지 못하도록하지만 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 또는 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; 를 수행하는 것을 막지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4166e40468956f25d587c502c88de582346f3e60" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR SHARE&lt;/code&gt;, except that the lock is weaker: &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; is blocked, but not &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;. A key-shared lock blocks other transactions from performing &lt;code&gt;DELETE&lt;/code&gt; or any &lt;code&gt;UPDATE&lt;/code&gt; that changes the key values, but not other &lt;code&gt;UPDATE&lt;/code&gt;, and neither does it prevent &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">잠금이 약하다는 점을 제외하고 &lt;code&gt;FOR SHARE&lt;/code&gt; 와 유사하게 작동합니다 . &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 는 차단되지만 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; 는 차단 됩니다. 키 공유 로크 수행하는 블록 다른 트랜잭션 &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 다른 키 값을 변경하지만 &lt;code&gt;UPDATE&lt;/code&gt; 를 하고, 어느 쪽이 방지하지 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 또는 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3975839e55e061601c3038a505012e75c26cc40" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR UPDATE&lt;/code&gt;, except that the lock acquired is weaker: this lock will not block &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; commands that attempt to acquire a lock on the same rows. This lock mode is also acquired by any &lt;code&gt;UPDATE&lt;/code&gt; that does not acquire a &lt;code&gt;FOR UPDATE&lt;/code&gt; lock.</source>
          <target state="translated">획득 된 잠금이 약하다는 점을 제외하고 &lt;code&gt;FOR UPDATE&lt;/code&gt; 와 유사하게 작동합니다 .이 잠금은 동일한 행에서 잠금을 획득하려고 시도하는 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; 명령을 차단하지 않습니다 . 이 잠금 모드는 &lt;code&gt;FOR UPDATE&lt;/code&gt; 잠금을 획득하지 않은 &lt;code&gt;UPDATE&lt;/code&gt; 에서도 획득됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfbd41304878c2d772d5d897e0245d1caed66504" translate="yes" xml:space="preserve">
          <source>Behavior of B-Tree Operator Classes</source>
          <target state="translated">B- 트리 운영자 클래스의 동작</target>
        </trans-unit>
        <trans-unit id="126af5216968b8a395d1e58cbc6d82b4d656f6fb" translate="yes" xml:space="preserve">
          <source>Below is a larger example of how this feature can be used in production environments. The table &lt;code&gt;passwd&lt;/code&gt; emulates a Unix password file:</source>
          <target state="translated">다음은 프로덕션 환경에서이 기능을 사용하는 방법에 대한 더 큰 예입니다. &lt;code&gt;passwd&lt;/code&gt; 테이블 은 Unix 비밀번호 파일을 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="7fca4fa390ed5f3e5c9eff1ebae50bc1ae5a07f1" translate="yes" xml:space="preserve">
          <source>Below we create a dictionary and bind some token types to an astronomical thesaurus and English stemmer:</source>
          <target state="translated">아래에서는 사전을 만들고 일부 토큰 유형을 천문학적 동의어 사전 및 영어 형태소 분석기에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="870f5d9661b7407b932b1598182f5f2d810cf9fe" translate="yes" xml:space="preserve">
          <source>Benchmarking Options</source>
          <target state="translated">벤치마킹 옵션</target>
        </trans-unit>
        <trans-unit id="2fb7c98fc75cb4f79b347af89afb1652e417df34" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 설명 된 구성 매개 변수 외에도 &lt;code&gt;SET&lt;/code&gt; 명령을 통해서만 조정할 수 있거나 특수 구문 이있는 몇 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef6d7a0bd27a4a7a7898b15686b3e50c0c08dc1a" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 설명 된 구성 매개 변수 외에도 &lt;code&gt;SET&lt;/code&gt; 명령을 사용해서 만 조정할 수 있거나 특수 구문 이있는 몇 가지 매개 변수 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcdcdb56c299825a17bc63b94d508dafd4fc2a95" translate="yes" xml:space="preserve">
          <source>Between (inclusive of the range endpoints).</source>
          <target state="translated">사이 (범위 끝점 포함).</target>
        </trans-unit>
        <trans-unit id="e6c66d70ecd66ce14264e1d077f56c53c9c3ae8a" translate="yes" xml:space="preserve">
          <source>Between, after sorting the two endpoint values.</source>
          <target state="translated">두 끝점 값을 정렬 한 후 사이.</target>
        </trans-unit>
        <trans-unit id="60abe3d5ae299760f0dd57db1ab7b6b69b7cc66b" translate="yes" xml:space="preserve">
          <source>Beware that recent releases of macOS ignore attempts to set &lt;code&gt;SHMMAX&lt;/code&gt; to a value that isn't an exact multiple of 4096.</source>
          <target state="translated">macOS의 최신 릴리스는 &lt;code&gt;SHMMAX&lt;/code&gt; 를 정확히 4096의 배수가 아닌 값 으로 설정하려는 시도를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="b80b5f7ca59611a24bc9604afc3876b56110cee0" translate="yes" xml:space="preserve">
          <source>Beware that the &lt;code&gt;ROWS&lt;/code&gt; mode can produce unpredictable results if the &lt;code&gt;ORDER BY&lt;/code&gt; ordering does not order the rows uniquely. The &lt;code&gt;RANGE&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; modes are designed to ensure that rows that are peers in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.</source>
          <target state="translated">것을주의 &lt;code&gt;ROWS&lt;/code&gt; 의 경우 생성 모드가 예측할 수없는 결과를 생성 할 수 &lt;code&gt;ORDER BY&lt;/code&gt; 주문 고유 행을 주문하지 않습니다. &lt;code&gt;RANGE&lt;/code&gt; 및 &lt;code&gt;GROUPS&lt;/code&gt; 모드가에 피어 것을 행하기 위해 설계 &lt;code&gt;ORDER BY&lt;/code&gt; 프레임의 수 또는에서 제외됩니다 주어진 피어 그룹의 모든 행 : 모두 처리되는 순서를.</target>
        </trans-unit>
        <trans-unit id="774be1cf4f3a522f1a25f2b6316b0d501136298e" translate="yes" xml:space="preserve">
          <source>Beware that this approach can fail if the outer query level contains additional processing, such as a join, because that might cause the subquery's output to be reordered before the aggregate is computed.</source>
          <target state="translated">외부 쿼리 수준에 조인과 같은 추가 처리가 포함되어 있으면 집계가 계산되기 전에 하위 쿼리의 출력이 다시 정렬 될 수 있으므로이 방법이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="4afac498b0186c05ae272a50fdfb777d86f83f5a" translate="yes" xml:space="preserve">
          <source>Big Five</source>
          <target state="translated">빅 파이브</target>
        </trans-unit>
        <trans-unit id="05792c2e47b633979450a4d3fdc731bebb67e917" translate="yes" xml:space="preserve">
          <source>Binary Data Types</source>
          <target state="translated">이진 데이터 형식</target>
        </trans-unit>
        <trans-unit id="d978fc265919867464402ead8b5aa5056e5fbd19" translate="yes" xml:space="preserve">
          <source>Binary Data Types: bytea</source>
          <target state="translated">이진 데이터 형식 : bytea</target>
        </trans-unit>
        <trans-unit id="be10328dd5eb2024df80c19f0915f781f57e2ed4" translate="yes" xml:space="preserve">
          <source>Binary Format</source>
          <target state="translated">이진 형식</target>
        </trans-unit>
        <trans-unit id="eea185b10ff34a7d0730fbc39d8d1573222be81b" translate="yes" xml:space="preserve">
          <source>Binary String Functions and Operators</source>
          <target state="translated">이진 문자열 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="cbcfd399e3b6e28f48b32806c48d9294b5084ef2" translate="yes" xml:space="preserve">
          <source>Binary String: bit_length</source>
          <target state="translated">이진 문자열 : bit_length</target>
        </trans-unit>
        <trans-unit id="b8dff4368de0e3c40124e448acd2ca6783cd44df" translate="yes" xml:space="preserve">
          <source>Binary String: btrim</source>
          <target state="translated">이진 문자열 : btrim</target>
        </trans-unit>
        <trans-unit id="3d3110a88c097ff95d0ceb59cb2d12b59b1aeb9f" translate="yes" xml:space="preserve">
          <source>Binary String: convert</source>
          <target state="translated">이진 문자열 : 변환</target>
        </trans-unit>
        <trans-unit id="af8938914c9b70ca934924b934ba9839025c7024" translate="yes" xml:space="preserve">
          <source>Binary String: convert_from</source>
          <target state="translated">이진 문자열 : convert_from</target>
        </trans-unit>
        <trans-unit id="e921f5d76c05cb18ae66971b494afa6830c1fe08" translate="yes" xml:space="preserve">
          <source>Binary String: convert_to</source>
          <target state="translated">이진 문자열 : convert_to</target>
        </trans-unit>
        <trans-unit id="dab4683aaea619005a4200cd9a5215872f4f193a" translate="yes" xml:space="preserve">
          <source>Binary String: decode</source>
          <target state="translated">이진 문자열 : 디코드</target>
        </trans-unit>
        <trans-unit id="1bb599e86584900c656608c4be089126932fb4ca" translate="yes" xml:space="preserve">
          <source>Binary String: encode</source>
          <target state="translated">이진 문자열 : encode</target>
        </trans-unit>
        <trans-unit id="ed9e62f8973e5d6bffd91187c9e478de6423b5ec" translate="yes" xml:space="preserve">
          <source>Binary String: get_bit</source>
          <target state="translated">이진 문자열 : get_bit</target>
        </trans-unit>
        <trans-unit id="a7dc78314758d39820bb026c008feb884ce531ff" translate="yes" xml:space="preserve">
          <source>Binary String: get_byte</source>
          <target state="translated">이진 문자열 : get_byte</target>
        </trans-unit>
        <trans-unit id="3b3dfd58346ed838c2d28b9b46ab8febf746666b" translate="yes" xml:space="preserve">
          <source>Binary String: length</source>
          <target state="translated">이진 문자열 : 길이</target>
        </trans-unit>
        <trans-unit id="3d6bb6f2a913f2fe4e19cd19b79eb492e8027877" translate="yes" xml:space="preserve">
          <source>Binary String: md5</source>
          <target state="translated">이진 문자열 : md5</target>
        </trans-unit>
        <trans-unit id="2b6e00319f3a8699a801221f672b9e6fae165f94" translate="yes" xml:space="preserve">
          <source>Binary String: octet_length</source>
          <target state="translated">이진 문자열 : octet_length</target>
        </trans-unit>
        <trans-unit id="549d7f8bb245593c2f0ec51b5eecfcb99bfc4c36" translate="yes" xml:space="preserve">
          <source>Binary String: overlay</source>
          <target state="translated">이진 문자열 : 오버레이</target>
        </trans-unit>
        <trans-unit id="317470b7465e50bb01ea0ed9d647db9aa1569cbc" translate="yes" xml:space="preserve">
          <source>Binary String: position</source>
          <target state="translated">이진 문자열 : 위치</target>
        </trans-unit>
        <trans-unit id="9434d0dc118c447e4ee164199720303685e8f31a" translate="yes" xml:space="preserve">
          <source>Binary String: set_bit</source>
          <target state="translated">이진 문자열 : set_bit</target>
        </trans-unit>
        <trans-unit id="f39a20b22ec73f10ccf2ff12ede513b3bf197e16" translate="yes" xml:space="preserve">
          <source>Binary String: set_byte</source>
          <target state="translated">이진 문자열 : set_byte</target>
        </trans-unit>
        <trans-unit id="edd1f7f5db831e55c4404df9e415cec21d97ca8d" translate="yes" xml:space="preserve">
          <source>Binary String: sha224</source>
          <target state="translated">이진 문자열 : sha224</target>
        </trans-unit>
        <trans-unit id="a4e5fd05bd7c2057fbb588451d73bc8e364bcd00" translate="yes" xml:space="preserve">
          <source>Binary String: sha256</source>
          <target state="translated">이진 문자열 : sha256</target>
        </trans-unit>
        <trans-unit id="199ba90dac671366fc2d30018bc9cc60da6d8112" translate="yes" xml:space="preserve">
          <source>Binary String: sha384</source>
          <target state="translated">이진 문자열 : sha384</target>
        </trans-unit>
        <trans-unit id="b17b7742692d6cc8900d5a09fbba1ba2dcf79e2d" translate="yes" xml:space="preserve">
          <source>Binary String: sha512</source>
          <target state="translated">이진 문자열 : sha512</target>
        </trans-unit>
        <trans-unit id="138398c9ed1548fd9d09e373d02441ec780c3dba" translate="yes" xml:space="preserve">
          <source>Binary String: substr</source>
          <target state="translated">이진 문자열 : substr</target>
        </trans-unit>
        <trans-unit id="eb754287eb3b8d22b0752ef54dea23d275538097" translate="yes" xml:space="preserve">
          <source>Binary String: substring</source>
          <target state="translated">이진 문자열 : 부분 문자열</target>
        </trans-unit>
        <trans-unit id="0880194133ad39b402dac81c879f4881bf8922df" translate="yes" xml:space="preserve">
          <source>Binary String: trim</source>
          <target state="translated">이진 문자열 : 트림</target>
        </trans-unit>
        <trans-unit id="4b19a17003e3a215c61a3139f7843b960e175e71" translate="yes" xml:space="preserve">
          <source>Binary String: ||</source>
          <target state="translated">이진 문자열 : ||</target>
        </trans-unit>
        <trans-unit id="c41bc309d8cd529592e339f0c36e8e967a2fed13" translate="yes" xml:space="preserve">
          <source>Binary cursors are a PostgreSQL extension.</source>
          <target state="translated">이진 커서는 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="6b44f09a82f5b765933694a9db3f15e511f15291" translate="yes" xml:space="preserve">
          <source>Binary cursors should be used carefully. Many applications, including psql, are not prepared to handle binary cursors and expect data to come back in the text format.</source>
          <target state="translated">이진 커서는주의해서 사용해야합니다. psql을 포함한 많은 응용 프로그램은 이진 커서를 처리 할 준비가되지 않았으며 데이터가 텍스트 형식으로 다시 나타날 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="253c59e522f194890c38a49fa034c56d5597e5ce" translate="yes" xml:space="preserve">
          <source>Bit 16</source>
          <target state="translated">비트 16</target>
        </trans-unit>
        <trans-unit id="b304e502a60fe2721a2acc2ea86477e058a5fc18" translate="yes" xml:space="preserve">
          <source>Bit String Functions and Operators</source>
          <target state="translated">비트 문자열 함수 및 연산자</target>
        </trans-unit>
        <trans-unit id="e1ec8af5ed0ac3706706e7ca0257fb8472997bd9" translate="yes" xml:space="preserve">
          <source>Bit String Types</source>
          <target state="translated">비트 문자열 타입</target>
        </trans-unit>
        <trans-unit id="26d5338edfde42da5636b07f3a1f7b3b99348954" translate="yes" xml:space="preserve">
          <source>Bit String: #</source>
          <target state="translated">비트 문자열 : #</target>
        </trans-unit>
        <trans-unit id="54a89e1d14e86ab43af7735b61c206ac06fd6632" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;amp;</source>
          <target state="translated">비트 문자열 : &amp;amp;</target>
        </trans-unit>
        <trans-unit id="25bf3896db23b3430dc3419d701ee4519f795bf6" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;gt;&amp;gt;</source>
          <target state="translated">비트 문자열 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d52a6739aec041222c397e3ab3508452bbdace4c" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;lt;&amp;lt;</source>
          <target state="translated">비트 문자열 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="698c5053f7fb4235a075904b83c81d0e7f75e767" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; # B&amp;#x27;01101&amp;#x27;</source>
          <target state="translated">비트 문자열 : B'10001 '# B'01101'</target>
        </trans-unit>
        <trans-unit id="4fec3321c838e2393b12b6d782dae5847bd67b84" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;amp; B&amp;#x27;01101&amp;#x27;</source>
          <target state="translated">비트 문자열 : B'10001 '&amp;amp; B'01101'</target>
        </trans-unit>
        <trans-unit id="f80854d98441f5f666a756550418ab3915bb0869" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;gt;&amp;gt; 2</source>
          <target state="translated">비트 문자열 : B'10001 '&amp;gt;&amp;gt; 2</target>
        </trans-unit>
        <trans-unit id="020f62b450e6a960545b1de75bca157ae03bc7a2" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;lt;&amp;lt; 3</source>
          <target state="translated">비트 문자열 : B'10001 '&amp;lt;&amp;lt; 3</target>
        </trans-unit>
        <trans-unit id="edcb968f9fd9173bd5d0d4f8617eb3f6d27f69c3" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; | B&amp;#x27;01101&amp;#x27;</source>
          <target state="translated">비트 문자열 : B'10001 '| B'01101 '</target>
        </trans-unit>
        <trans-unit id="292bdc723b3de75f45f35aaf3b8989a7fc5eb2b2" translate="yes" xml:space="preserve">
          <source>Bit String: bit_length</source>
          <target state="translated">비트 문자열 : bit_length</target>
        </trans-unit>
        <trans-unit id="918db4fa99e0649c8060902f9a3e94ba75c279e0" translate="yes" xml:space="preserve">
          <source>Bit String: get_bit</source>
          <target state="translated">비트 문자열 : get_bit</target>
        </trans-unit>
        <trans-unit id="6891e5dceae12938ae30b567970719872fccde2c" translate="yes" xml:space="preserve">
          <source>Bit String: length</source>
          <target state="translated">비트 문자열 : 길이</target>
        </trans-unit>
        <trans-unit id="4f5f6f7cb2e1bc80a507138569c25bed2001e0f1" translate="yes" xml:space="preserve">
          <source>Bit String: octet_length</source>
          <target state="translated">비트 문자열 : octet_length</target>
        </trans-unit>
        <trans-unit id="00634ec6386463ae42b1b7bb26891e1338c4b35c" translate="yes" xml:space="preserve">
          <source>Bit String: overlay</source>
          <target state="translated">비트 문자열 : 오버레이</target>
        </trans-unit>
        <trans-unit id="1a0d8c1cd0116787005f4bee7aff429712b20961" translate="yes" xml:space="preserve">
          <source>Bit String: position</source>
          <target state="translated">비트 문자열 : 위치</target>
        </trans-unit>
        <trans-unit id="38f3120e8f7e91a683313ad8017d180967d09509" translate="yes" xml:space="preserve">
          <source>Bit String: set_bit</source>
          <target state="translated">비트 문자열 : set_bit</target>
        </trans-unit>
        <trans-unit id="eb70e33ea681844ee935ae674a0a87b670e898dd" translate="yes" xml:space="preserve">
          <source>Bit String: substring</source>
          <target state="translated">비트 문자열 : 하위 문자열</target>
        </trans-unit>
        <trans-unit id="4e47fbeeacb2ccb2058a0e13885d27607dc2ff89" translate="yes" xml:space="preserve">
          <source>Bit String: |</source>
          <target state="translated">비트 문자열 : |</target>
        </trans-unit>
        <trans-unit id="a9f58217517f242096405bc47fb766301ddb90d4" translate="yes" xml:space="preserve">
          <source>Bit String: ||</source>
          <target state="translated">비트 문자열 : ||</target>
        </trans-unit>
        <trans-unit id="fb535d3c1297857f6c6638c764b59c16782c04dd" translate="yes" xml:space="preserve">
          <source>Bit String: ~</source>
          <target state="translated">비트 문자열 : ~</target>
        </trans-unit>
        <trans-unit id="91c158702eba7e22d8c0b8480c6181f06bc8d6e5" translate="yes" xml:space="preserve">
          <source>Bit String: ~ B&amp;#x27;10001&amp;#x27;</source>
          <target state="translated">비트 문자열 : ~ B'10001 '</target>
        </trans-unit>
        <trans-unit id="2efae331bc5aa821406a784a6e78c0b9daf6c7df" translate="yes" xml:space="preserve">
          <source>Bit mask identifying trigger firing conditions</source>
          <target state="translated">트리거 발생 조건을 식별하는 비트 마스크</target>
        </trans-unit>
        <trans-unit id="35edcdbad2868d30fa30834e2406d3005ac8363c" translate="yes" xml:space="preserve">
          <source>Bit strings are strings of 1's and 0's. They can be used to store or visualize bit masks. There are two SQL bit types: &lt;code&gt;bit(n)&lt;/code&gt; and &lt;code&gt;bit varying(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a positive integer.</source>
          <target state="translated">비트 문자열은 1과 0의 문자열입니다. 비트 마스크를 저장하거나 시각화하는 데 사용할 수 있습니다. &lt;code&gt;bit(n)&lt;/code&gt; 및 &lt;code&gt;bit varying(n)&lt;/code&gt; 두 가지 SQL 비트 유형이 있습니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 양의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="440588c03e76a6dbf3a0dad3d94ffb56eaf0107d" translate="yes" xml:space="preserve">
          <source>Bit-string constants look like regular string constants with a &lt;code&gt;B&lt;/code&gt; (upper or lower case) immediately before the opening quote (no intervening whitespace), e.g., &lt;code&gt;B'1001'&lt;/code&gt;. The only characters allowed within bit-string constants are &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">비트 열 상수 는 여는 따옴표 바로 앞에 &lt;code&gt;B&lt;/code&gt; (대문자 또는 소문자) 가있는 일반 문자열 상수처럼 보입니다 (예 : &lt;code&gt;B'1001'&lt;/code&gt; . 비트 열 상수 내에서 허용되는 유일한 문자는 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef8b2561e514bdc32792b41e10c969f64c960716" translate="yes" xml:space="preserve">
          <source>Bit-string types</source>
          <target state="translated">비트 열 타입</target>
        </trans-unit>
        <trans-unit id="3119bee988c6c128ef1a7a4d003a2772fc4ae36a" translate="yes" xml:space="preserve">
          <source>BitmapAnd and BitmapOr nodes always report their actual row counts as zero, due to implementation limitations.</source>
          <target state="translated">BitmapAnd 및 BitmapOr 노드는 구현 제한으로 인해 항상 실제 행 수를 0으로보고합니다.</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="2461564dd1b0dd1dfe10a6e27226bb4f00cb800c" translate="yes" xml:space="preserve">
          <source>Bitwise AND (inputs must be of equal length)</source>
          <target state="translated">Bitwise AND (inputs must be of equal length)</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">비트 단위 NOT</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">비트 OR</target>
        </trans-unit>
        <trans-unit id="b3a7a98dcaae40a13757076e24af311dfee77860" translate="yes" xml:space="preserve">
          <source>Bitwise OR (inputs must be of equal length)</source>
          <target state="translated">Bitwise OR (inputs must be of equal length)</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">비트 XOR</target>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="translated">비트 배타적 OR</target>
        </trans-unit>
        <trans-unit id="d16eb5b05790cd70e7dd8947da148a14b1c3b585" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR (inputs must be of equal length)</source>
          <target state="translated">Bitwise exclusive OR (inputs must be of equal length)</target>
        </trans-unit>
        <trans-unit id="c8659c0b8789aa4ee715f09528a9e4eecaaa826e" translate="yes" xml:space="preserve">
          <source>Bitwise shift left</source>
          <target state="translated">Bitwise shift left</target>
        </trans-unit>
        <trans-unit id="5b90f67d593a4af9275c5c94d26eb0e231cb737a" translate="yes" xml:space="preserve">
          <source>Bitwise shift left (string length is preserved)</source>
          <target state="translated">Bitwise shift left (string length is preserved)</target>
        </trans-unit>
        <trans-unit id="50231ce6a71d579851db8fdf27b3184364b82e41" translate="yes" xml:space="preserve">
          <source>Bitwise shift right</source>
          <target state="translated">Bitwise shift right</target>
        </trans-unit>
        <trans-unit id="2b8813dffcb464fd01e7635b2efefa7c701a1bc5" translate="yes" xml:space="preserve">
          <source>Bitwise shift right (string length is preserved)</source>
          <target state="translated">Bitwise shift right (string length is preserved)</target>
        </trans-unit>
        <trans-unit id="8bfd5b423062918623ca47aa91c65abf2e858720" translate="yes" xml:space="preserve">
          <source>Bloat</source>
          <target state="translated">Bloat</target>
        </trans-unit>
        <trans-unit id="6f50e3e14cce1a8627751575e909b4caa4d3a6a3" translate="yes" xml:space="preserve">
          <source>Bloom is better than btree in handling this type of search:</source>
          <target state="translated">이러한 유형의 검색을 처리하는 데 블룸이 btree보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="92c882ac33d0ee2cd51460d3e115370fb18b7f64" translate="yes" xml:space="preserve">
          <source>Blowfish cipher</source>
          <target state="translated">복어 암호</target>
        </trans-unit>
        <trans-unit id="38d26af6e5082bc6e784c3815947a0f5acecada7" translate="yes" xml:space="preserve">
          <source>Blowfish crypt</source>
          <target state="translated">복어 토굴</target>
        </trans-unit>
        <trans-unit id="17d54f2a65a51558dd8c1f3e789157750ff7d6f8" translate="yes" xml:space="preserve">
          <source>Blowfish-based, variant 2a</source>
          <target state="translated">복어 기반, 변형 2a</target>
        </trans-unit>
        <trans-unit id="58299c5eb711f9a461ff1240fa8b1c0679ab5056" translate="yes" xml:space="preserve">
          <source>Boolean AND</source>
          <target state="translated">부울 AND</target>
        </trans-unit>
        <trans-unit id="c69f2185492e832f7277d3fff7b42d01f558fb61" translate="yes" xml:space="preserve">
          <source>Boolean NOT</source>
          <target state="translated">부울 NOT</target>
        </trans-unit>
        <trans-unit id="2c320907721a13b5dd2b75f194044bf4fb118e32" translate="yes" xml:space="preserve">
          <source>Boolean OR</source>
          <target state="translated">부울 OR</target>
        </trans-unit>
        <trans-unit id="54bd3ce38554ce1715613858323d1049c39c0685" translate="yes" xml:space="preserve">
          <source>Boolean Type</source>
          <target state="translated">부울 타입</target>
        </trans-unit>
        <trans-unit id="9656fd514386a9028815794334d9467f9f5a0c5e" translate="yes" xml:space="preserve">
          <source>Boolean Type: boolean</source>
          <target state="translated">부울 유형 : 부울</target>
        </trans-unit>
        <trans-unit id="d602b755186d61e697c04da0a7d821ff7d4efa39" translate="yes" xml:space="preserve">
          <source>Boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. As for &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;some&lt;/code&gt;, it seems that there is an ambiguity built into the standard syntax:</source>
          <target state="translated">부울 집계 &lt;code&gt;bool_and&lt;/code&gt; 및 &lt;code&gt;bool_or&lt;/code&gt; 표준 SQL의 집계에 해당하는 &lt;code&gt;every&lt;/code&gt; 및 &lt;code&gt;any&lt;/code&gt; 또는 &lt;code&gt;some&lt;/code&gt; . 에 관해서는 &lt;code&gt;any&lt;/code&gt; 및 &lt;code&gt;some&lt;/code&gt; , 표준 문법에 내장 애매함이있는 것 같습니다 :</target>
        </trans-unit>
        <trans-unit id="e7e48e64bd944bf0341a3c4f226c0c85bf62984d" translate="yes" xml:space="preserve">
          <source>Boolean constants can be represented in SQL queries by the SQL key words &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;, and &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">부울 상수는 SQL 키워드 &lt;code&gt;TRUE&lt;/code&gt; , &lt;code&gt;FALSE&lt;/code&gt; 및 &lt;code&gt;NULL&lt;/code&gt; 로 SQL 쿼리에 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52e1ee47a7ff1168010b326824ee21ddfeae28c3" translate="yes" xml:space="preserve">
          <source>Boolean types</source>
          <target state="translated">부울 유형</target>
        </trans-unit>
        <trans-unit id="fa793a8aacedef81b06cc550c19f522284580fd4" translate="yes" xml:space="preserve">
          <source>Boolean value tests</source>
          <target state="translated">Boolean value tests</target>
        </trans-unit>
        <trans-unit id="ec240e7050d6f871548eb16c80190949f2f4c3c5" translate="yes" xml:space="preserve">
          <source>Boolean values can also be tested using the predicates</source>
          <target state="translated">부울 값은 술어를 사용하여 테스트 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="61e93ae531636a2f7c54ab2267a73987c4067669" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;NOT NULL&lt;/code&gt; constraints of a partitioned table are always inherited by all its partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints that are marked &lt;code&gt;NO INHERIT&lt;/code&gt; are not allowed to be created on partitioned tables.</source>
          <target state="translated">두 &lt;code&gt;CHECK&lt;/code&gt; 및 &lt;code&gt;NOT NULL&lt;/code&gt; 의 분할 된 테이블의 제약 조건은 항상 모든 파티션에 의해 상속됩니다. &lt;code&gt;NO INHERIT&lt;/code&gt; 로 표시된 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건은 파티션 된 테이블에서 작성 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b889ca8993198c7004a576b1cf90c434b540954c" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; can be any non-null string, with a maximum of 255 characters. The cost parameters specify how much to charge for a character insertion, deletion, or substitution, respectively. You can omit the cost parameters, as in the second version of the function; in that case they all default to 1.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 와 &lt;code&gt;target&lt;/code&gt; 은 모두 최대 255 자의 널이 아닌 문자열 일 수 있습니다. 비용 매개 변수는 각각 문자 삽입, 삭제 또는 대체에 대해 청구 할 금액을 지정합니다. 함수의 두 번째 버전에서와 같이 비용 매개 변수를 생략 할 수 있습니다. 이 경우 모두 1로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5ea32d54e6cfd34abb39f16058fc4fd6f2961804" translate="yes" xml:space="preserve">
          <source>Both advisory locks and regular locks are stored in a shared memory pool whose size is defined by the configuration variables &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;. Care must be taken not to exhaust this memory or the server will be unable to grant any locks at all. This imposes an upper limit on the number of advisory locks grantable by the server, typically in the tens to hundreds of thousands depending on how the server is configured.</source>
          <target state="translated">권고 잠금 및 일반 잠금은 모두 크기가 구성 변수 &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections에&lt;/a&gt; 의해 정의되는 공유 메모리 풀에 저장됩니다 . 이 메모리를 소진하지 않도록주의해야합니다. 그렇지 않으면 서버에서 잠금을 전혀 부여 할 수 없습니다. 이는 서버가 부여 할 수있는 권고 잠금 수에 대한 상한을, 일반적으로 서버 구성 방법에 따라 수십에서 수십만으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="64fe65c7e1e3e888472be5adaa2902cc6b0a1a3b" translate="yes" xml:space="preserve">
          <source>Both forms of bit-string constant can be continued across lines in the same way as regular string constants. Dollar quoting cannot be used in a bit-string constant.</source>
          <target state="translated">비트 스트링 상수의 두 가지 형식은 일반 스트링 상수와 같은 방식으로 여러 행에 걸쳐 계속 될 수 있습니다. 달러 인용 부호는 비트 열 상수에 사용될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b41d8e55f4edf059d0388795bf4f266c2e06c3f" translate="yes" xml:space="preserve">
          <source>Both minmax and inclusion operator classes support cross-data-type operators, though with these the dependencies become more complicated. The minmax operator class requires a full set of operators to be defined with both arguments having the same data type. It allows additional data types to be supported by defining extra sets of operators. Inclusion operator class operator strategies are dependent on another operator strategy as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;Table 67.3&lt;/a&gt;, or the same operator strategy as themselves. They require the dependency operator to be defined with the &lt;code&gt;STORAGE&lt;/code&gt; data type as the left-hand-side argument and the other supported data type to be the right-hand-side argument of the supported operator. See &lt;code&gt;float4_minmax_ops&lt;/code&gt; as an example of minmax, and &lt;code&gt;box_inclusion_ops&lt;/code&gt; as an example of inclusion.</source>
          <target state="translated">minmax 및 포함 연산자 클래스는 모두 데이터 형식 연산자를 지원하지만 이러한 종속성으로 인해 더 복잡해집니다. minmax 연산자 클래스는 동일한 데이터 유형을 갖는 두 인수로 정의 된 전체 연산자 세트를 필요로합니다. 추가 연산자 세트를 정의하여 추가 데이터 유형을 지원할 수 있습니다. 포함 연산자 클래스 운영자 전략은 &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;표 67.3에&lt;/a&gt; 표시된 다른 운영자 전략 또는 동일한 운영자 전략에 의존 합니다. 종속 연산자는 &lt;code&gt;STORAGE&lt;/code&gt; 데이터 유형을 왼쪽 인수로 정의하고 다른 지원되는 데이터 유형을 지원되는 연산자의 오른쪽 인수로 정의해야합니다. minmax의 예로 &lt;code&gt;float4_minmax_ops&lt;/code&gt; 를 참조하십시오. &lt;code&gt;box_inclusion_ops&lt;/code&gt; 포함의 예로 box_inclusion_ops 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d935d6e4440b7d13db8dea9774a168802ac598e0" translate="yes" xml:space="preserve">
          <source>Both star symbols and simple words can be quantified to restrict how many labels they can match:</source>
          <target state="translated">Both star symbols and simple words can be quantified to restrict how many labels they can match:</target>
        </trans-unit>
        <trans-unit id="7b6bb44fe8014c95fc406791cc963af10b33bb29" translate="yes" xml:space="preserve">
          <source>Both the maximum precision and the maximum scale of a &lt;code&gt;numeric&lt;/code&gt; column can be configured. To declare a column of type &lt;code&gt;numeric&lt;/code&gt; use the syntax:</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 열의 최대 정밀도와 최대 스케일을 모두 구성 할 수 있습니다. &lt;code&gt;numeric&lt;/code&gt; 유형의 열을 선언하려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ea3fb61640ce7586a68af124013d79c4c57b81a1" translate="yes" xml:space="preserve">
          <source>Both the scan position and the mark position (if any) must be maintained consistently in the face of concurrent insertions or deletions in the index. It is OK if a freshly-inserted entry is not returned by a scan that would have found the entry if it had existed when the scan started, or for the scan to return such an entry upon rescanning or backing up even though it had not been returned the first time through. Similarly, a concurrent delete might or might not be reflected in the results of a scan. What is important is that insertions or deletions not cause the scan to miss or multiply return entries that were not themselves being inserted or deleted.</source>
          <target state="translated">스캔 위치와 마크 위치 (있는 경우)는 인덱스에서 동시에 삽입 또는 삭제 될 때 일관성있게 유지되어야합니다. 새로 시작한 항목이 검색을 시작할 때 존재했거나 해당 항목이 검색되지 않았더라도 다시 검색하거나 백업 할 때 해당 항목을 반환 한 항목을 찾은 검색에 의해 반환되지 않으면 정상입니다. 처음으로 돌아 왔습니다. 마찬가지로 동시 삭제는 스캔 결과에 반영되거나 반영되지 않을 수 있습니다. 중요한 것은 삽입 또는 삭제로 인해 스캔이 삽입 또는 삭제되지 않은 항목을 누락하거나 여러 번 반환하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3bce0a8d20dfad3adb1a5af3b099eec9aec7a17c" translate="yes" xml:space="preserve">
          <source>Both the system-wide startup file and the user's personal startup file can be made psql-version-specific by appending a dash and the PostgreSQL major or minor release number to the file name, for example &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; or &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt;. The most specific version-matching file will be read in preference to a non-version-specific file.</source>
          <target state="translated">파일 이름에 대시 및 PostgreSQL 주 또는 부 릴리스 번호 (예 : &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; 또는 &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt; 를 추가하여 시스템 전체 시작 파일과 사용자 개인 시작 파일을 psql 버전에 따라 지정할 수 있습니다 . psqlrc-9.2.5 . 가장 구체적인 버전 일치 파일은 버전이 아닌 파일보다 우선적으로 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="a9f1bcbf395b360aecae5c7aad8432687c5d0c98" translate="yes" xml:space="preserve">
          <source>Boxes are output using the second syntax.</source>
          <target state="translated">상자는 두 번째 구문을 사용하여 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="3b7172d9675205f8063e821e7bb335558a00ea56" translate="yes" xml:space="preserve">
          <source>Boxes are represented by pairs of points that are opposite corners of the box. Values of type &lt;code&gt;box&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">상자는 상자의 반대쪽 모서리에있는 점 쌍으로 표시됩니다. &lt;code&gt;box&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="80edaabf28ae789b6d2df8969096454a0d5adc8a" translate="yes" xml:space="preserve">
          <source>Brackets (&lt;code&gt;[]&lt;/code&gt;) are used to select the elements of an array. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more information on arrays.</source>
          <target state="translated">대괄호 ( &lt;code&gt;[]&lt;/code&gt; )는 배열의 요소를 선택하는 데 사용됩니다. 배열에 대한 자세한 내용 &lt;a href=&quot;arrays&quot;&gt;은 8.15 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a42247eae020c4a6a90987074cedeaeafefcb933" translate="yes" xml:space="preserve">
          <source>Break the input string into tokens and categorize each token as a string, time, time zone, or number.</source>
          <target state="translated">입력 문자열을 토큰으로 나누고 각 토큰을 문자열, 시간, 시간대 또는 숫자로 분류하십시오.</target>
        </trans-unit>
        <trans-unit id="7f060d64f6791f16fa5efaff60c076733c80c6cc" translate="yes" xml:space="preserve">
          <source>Brian Gladman</source>
          <target state="translated">브라이언 글 래드 먼</target>
        </trans-unit>
        <trans-unit id="ffa9096408246acd9955cddd88051877608e02b2" translate="yes" xml:space="preserve">
          <source>Bucardo</source>
          <target state="translated">Bucardo</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="8d8140d7cfbb395763a377b0065a8f622c660961" translate="yes" xml:space="preserve">
          <source>Build a new index. The index relation has been physically created, but is empty. It must be filled in with whatever fixed data the access method requires, plus entries for all tuples already existing in the table. Ordinarily the &lt;code&gt;ambuild&lt;/code&gt; function will call &lt;code&gt;table_index_build_scan()&lt;/code&gt; to scan the table for existing tuples and compute the keys that need to be inserted into the index. The function must return a palloc'd struct containing statistics about the new index.</source>
          <target state="translated">새로운 색인을 작성하십시오. 인덱스 관계가 실제로 작성되었지만 비어 있습니다. 액세스 방법에 필요한 고정 데이터와 테이블에 이미 존재하는 모든 튜플에 대한 항목으로 채워 져야합니다. 일반적으로 &lt;code&gt;ambuild&lt;/code&gt; 함수는 &lt;code&gt;table_index_build_scan()&lt;/code&gt; 을 호출 하여 기존 튜플에 대한 테이블을 스캔하고 인덱스에 삽입해야하는 키를 계산합니다. 이 함수는 새 인덱스에 대한 통계가 포함 된 palloc'd 구조체를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ab5f75a4f668c4f5eba6aa186b68fe6555350c4" translate="yes" xml:space="preserve">
          <source>Build an empty index, and write it to the initialization fork (&lt;code&gt;INIT_FORKNUM&lt;/code&gt;) of the given relation. This method is called only for unlogged indexes; the empty index written to the initialization fork will be copied over the main relation fork on each server restart.</source>
          <target state="translated">빈 인덱스를 작성 하고 지정된 관계 의 초기화 포크 ( &lt;code&gt;INIT_FORKNUM&lt;/code&gt; )에 씁니다 . 이 메소드는 로그되지 않은 인덱스에 대해서만 호출됩니다. 초기화 포크에 기록 된 빈 인덱스는 각 서버 재시작시 기본 관계 포크를 통해 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="59b2f3dbb6bd6f1f5bde23a4b9bc5f2c1659dd06" translate="yes" xml:space="preserve">
          <source>Build the new PostgreSQL source with &lt;code&gt;configure&lt;/code&gt; flags that are compatible with the old cluster. pg_upgrade will check &lt;code&gt;pg_controldata&lt;/code&gt; to make sure all settings are compatible before starting the upgrade.</source>
          <target state="translated">이전 클러스터와 호환되는 &lt;code&gt;configure&lt;/code&gt; 플래그를 사용하여 새 PostgreSQL 소스를 빌드하십시오 . pg_upgrade는 업그레이드를 시작하기 전에 &lt;code&gt;pg_controldata&lt;/code&gt; 를 검사 하여 모든 설정이 호환되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b0efda5eef1ba866b7542374c8ece9a4b87bf621" translate="yes" xml:space="preserve">
          <source>Build time for a GIN index is very sensitive to the &lt;code&gt;maintenance_work_mem&lt;/code&gt; setting; it doesn't pay to skimp on work memory during index creation.</source>
          <target state="translated">GIN 인덱스의 빌드 시간은 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 설정에 매우 민감 합니다. 인덱스 작성 중에 작업 메모리를 비축하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33f8808cf736a2f0f4fe91a19f0db395826f76fd" translate="yes" xml:space="preserve">
          <source>Building Indexes Concurrently</source>
          <target state="translated">동시에 인덱스 작성</target>
        </trans-unit>
        <trans-unit id="39c26d35b65d38341a1a91676925e41df6b2055c" translate="yes" xml:space="preserve">
          <source>Building an index type that supports concurrent updates usually requires extensive and subtle analysis of the required behavior. For the b-tree and hash index types, you can read about the design decisions involved in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; and &lt;code&gt;src/backend/access/hash/README&lt;/code&gt;.</source>
          <target state="translated">동시 업데이트를 지원하는 인덱스 유형을 작성하려면 일반적으로 필요한 동작을 광범위하고 미묘하게 분석해야합니다. b- 트리 및 해시 인덱스 유형의 경우 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; 및 &lt;code&gt;src/backend/access/hash/README&lt;/code&gt; 와 관련된 설계 결정에 대해 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47e5cdcd370dad05acde9abb1ab525b1924edb0a" translate="yes" xml:space="preserve">
          <source>Building large GiST indexes by simply inserting all the tuples tends to be slow, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, the insertions need to perform a lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more efficient method to build GiST indexes based on buffering, which can dramatically reduce the number of random I/Os needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as whole does not.</source>
          <target state="translated">인덱스 튜플이 인덱스 전체에 흩어져 있고 인덱스가 캐시에 맞지 않을만큼 충분히 큰 경우 삽입은 많은 임의의 I / O를 수행해야하기 때문에 모든 튜플을 삽입하여 대규모 GiST 인덱스를 구축하는 것은 느리게 진행됩니다. 버전 9.2부터 PostgreSQL은 버퍼링을 기반으로 GiST 인덱스를 작성하는보다 효율적인 방법을 지원하므로 순서가없는 데이터 세트에 필요한 임의 I / O 수를 크게 줄일 수 있습니다. 잘 정렬 된 데이터 세트의 경우 한 번에 적은 수의 페이지 만 새 튜플을 수신하고 인덱스 전체가 아닌 경우에도 해당 페이지가 캐시에 적합하기 때문에 이점이 더 적거나 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="802f99132933c7e50ae4b1dc60414e1dd9622319" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair.</source>
          <target state="translated">텍스트 배열에서 JSON 객체를 빌드합니다. 배열은 짝수의 멤버를 갖는 정확히 하나의 차원을 가져야하며,이 경우 교대하는 키 / 값 쌍으로 간주되거나 각 내부 배열이 정확히 두 개의 요소를 갖도록 두 차원을 가져야합니다. .</target>
        </trans-unit>
        <trans-unit id="12655969a97b05cc10e81a0f90560ca3e925543c" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair. All values are converted to JSON strings.</source>
          <target state="translated">Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair. All values are converted to JSON strings.</target>
        </trans-unit>
        <trans-unit id="f2aecbff08d9f05062e48cef54ff41a7deab5245" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values.</source>
          <target state="translated">가변 인수 목록에서 JSON 객체를 작성합니다. 일반적으로 인수 목록은 대체 키와 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f46fcc8bccbe3831f46147a1da2fc888d15802b" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values. Key arguments are coerced to text; value arguments are converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt;.</source>
          <target state="translated">Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values. Key arguments are coerced to text; value arguments are converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad91ede47a5280dfb0e7c89b0ab06f2bb7e0630d" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list.</source>
          <target state="translated">이기종 인수 목록에서 이기종 유형의 JSON 배열을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="fc07e20c2337d94398080bc4db916907237b8429" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list. Each argument is converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt;.</source>
          <target state="translated">Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list. Each argument is converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b5998f67810590d9a53e6c46c1e94143e2a8d11" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary record from a JSON object (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">JSON 객체에서 임의의 레코드를 작성합니다 (아래 참고 참조). &lt;code&gt;record&lt;/code&gt; 를 반환하는 모든 함수와 마찬가지로 호출자는 &lt;code&gt;AS&lt;/code&gt; 절 을 사용하여 레코드의 구조를 명시 적으로 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="08637f34c0762d04a0506b89a280023ac2d9b88b" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary set of records from a JSON array of objects (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">JSON 객체 배열에서 임의의 레코드 세트를 작성합니다 (아래 참고 참조). &lt;code&gt;record&lt;/code&gt; 를 반환하는 모든 함수와 마찬가지로 호출자는 &lt;code&gt;AS&lt;/code&gt; 절 을 사용하여 레코드의 구조를 명시 적으로 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5cd7d28e330cbb1847ac7f97e57334ab1657662f" translate="yes" xml:space="preserve">
          <source>Built-In Functions</source>
          <target state="translated">내장 함수</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
