<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="95f8a0055f70864568262af7adc2dc1b06f590cc" translate="yes" xml:space="preserve">
          <source>For additional details see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-volatility.html&quot;&gt;Section 37.7&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-volatility.html&quot;&gt;섹션 37.7을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb8ec9455b3b3ecef5cd6da5c8b1451f7a76196b" translate="yes" xml:space="preserve">
          <source>For additional details see &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;.</source>
          <target state="translated">추가 세부 사항은 &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; 및 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bc2c859a66cc47f7ab253d738eacf7f06902a6f" translate="yes" xml:space="preserve">
          <source>For additional information on tuning these settings, see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;.</source>
          <target state="translated">이러한 설정 조정에 대한 자세한 내용 &lt;a href=&quot;wal-configuration&quot;&gt;은 29.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3269f32ce55507d4303558fb95944d5f97b55201" translate="yes" xml:space="preserve">
          <source>For additional information see &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6de3939693bb1f9d3d1fe45488c69d0a8681aad2" translate="yes" xml:space="preserve">
          <source>For additional information, see &lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt;, &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;, &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;, and &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt;.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt; , &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt; , &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt; , &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 및 &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e8aca49f3e5f06e066139112539b79576ab0035" translate="yes" xml:space="preserve">
          <source>For additional variables that affect the server, see &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt;.</source>
          <target state="translated">서버에 영향을주는 추가 변수는 &lt;a href=&quot;app-postgres&quot;&gt;postgres를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdf9570df93b845cb267b78130d56401af562fa2" translate="yes" xml:space="preserve">
          <source>For aggregate functions whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, the &lt;code&gt;combinefunc&lt;/code&gt; must not be strict. In this case the &lt;code&gt;combinefunc&lt;/code&gt; must ensure that null states are handled correctly and that the state being returned is properly stored in the aggregate memory context.</source>
          <target state="translated">누구의 집계 함수의 &lt;code&gt;state_data_type&lt;/code&gt; 입니다 &lt;code&gt;internal&lt;/code&gt; 의 &lt;code&gt;combinefunc&lt;/code&gt; 은 엄격하지 않아야합니다. 이 경우 &lt;code&gt;combinefunc&lt;/code&gt; 는 널 (null) 상태가 올바르게 처리되고 리턴되는 상태가 집계 메모리 컨텍스트에 올바르게 저장되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="96ebaaa890b3287a6cc4cc73ddb31fd495f4b938" translate="yes" xml:space="preserve">
          <source>For all types of in-memory TOAST pointer, the TOAST management code ensures that no such pointer datum can accidentally get stored on disk. In-memory TOAST pointers are automatically expanded to normal in-line varlena values before storage &amp;mdash; and then possibly converted to on-disk TOAST pointers, if the containing tuple would otherwise be too big.</source>
          <target state="translated">모든 유형의 인 메모리 TOAST 포인터의 경우 TOAST 관리 코드는 이러한 포인터 데이텀이 실수로 디스크에 저장되지 않도록합니다. 인 메모리 TOAST 포인터는 저장 전에 자동으로 일반 인라인 varlena 값으로 확장 된 다음 포함 튜플이 너무 큰 경우 디스크상의 TOAST 포인터로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00c5f8e7c27807a2274e36cb656c8abd549f0c2f" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;INSERT ... ON CONFLICT&lt;/code&gt; command, the publication will publish the operation that actually results from the command. So depending of the outcome, it may be published as either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or it may not be published at all.</source>
          <target state="translated">를 들어 &lt;code&gt;INSERT ... ON CONFLICT&lt;/code&gt; 명령을 게시는 것을 실제로 명령의 결과 작업을 게시합니다. 따라서 결과에 따라 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 로 게시되거나 전혀 게시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c28bd7503d02aa54b1f5bc7ca2e5f40da183d1" translate="yes" xml:space="preserve">
          <source>For an MD5 encrypted password, &lt;code&gt;rolpassword&lt;/code&gt; column will begin with the string &lt;code&gt;md5&lt;/code&gt; followed by a 32-character hexadecimal MD5 hash. The MD5 hash will be of the user's password concatenated to their user name. For example, if user &lt;code&gt;joe&lt;/code&gt; has password &lt;code&gt;xyzzy&lt;/code&gt;, PostgreSQL will store the md5 hash of &lt;code&gt;xyzzyjoe&lt;/code&gt;.</source>
          <target state="translated">MD5 암호화 비밀번호의 경우 &lt;code&gt;rolpassword&lt;/code&gt; 열은 문자열 &lt;code&gt;md5&lt;/code&gt; 로 시작 하고 32 자 16 진 MD5 해시가옵니다. MD5 해시는 사용자 이름과 연결된 사용자 암호입니다. 예를 들어, &lt;code&gt;joe&lt;/code&gt; 사용자 에게 암호 &lt;code&gt;xyzzy&lt;/code&gt; 가 있으면 PostgreSQL은 &lt;code&gt;xyzzyjoe&lt;/code&gt; 의 md5 해시를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="a8f9fac8435c636eaa9948982c5c6b1419a33356" translate="yes" xml:space="preserve">
          <source>For an exponential distribution, &lt;code&gt;parameter&lt;/code&gt; controls the distribution by truncating a quickly-decreasing exponential distribution at &lt;code&gt;parameter&lt;/code&gt;, and then projecting onto integers between the bounds. To be precise, with</source>
          <target state="translated">지수 분포를 들어, &lt;code&gt;parameter&lt;/code&gt; 에 재 빠르게 감소 지수 분포를 절단함으로써 분배 제어 &lt;code&gt;parameter&lt;/code&gt; 다음 범위의 정수에 투사한다. 정확히 말하자면</target>
        </trans-unit>
        <trans-unit id="9dddaa17ae34450f80cb35e71888640772ac6f9b" translate="yes" xml:space="preserve">
          <source>For an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;, it is an error to insert an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) without specifying either &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; or &lt;code&gt;OVERRIDING USER VALUE&lt;/code&gt;. (For an identity column defined as &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt;, &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; is the normal behavior and specifying it does nothing, but PostgreSQL allows it as an extension.)</source>
          <target state="translated">&lt;code&gt;GENERATED ALWAYS&lt;/code&gt; 로 정의 된 식별 컬럼의 경우 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 또는 &lt;code&gt;OVERRIDING USER VALUE&lt;/code&gt; 를 지정하지 않고 명시 적 값 ( &lt;code&gt;DEFAULT&lt;/code&gt; 이외 ) 을 삽입하는 것은 오류 입니다. ( &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; 로 정의 된 식별 열의 경우 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 는 정상적인 동작이며 지정하면 아무 작업도 수행되지 않지만 PostgreSQL에서는이를 확장으로 허용합니다.)</target>
        </trans-unit>
        <trans-unit id="65c3010f7ad4d8ce5cd9ffc778600e650d4f3866" translate="yes" xml:space="preserve">
          <source>For an operator family supporting multiple data types, the above laws must hold when &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; are taken from any data types in the family. The transitive laws are the trickiest to ensure, as in cross-type situations they represent statements that the behaviors of two or three different operators are consistent. As an example, it would not work to put &lt;code&gt;float8&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; into the same operator family, at least not with the current semantics that &lt;code&gt;numeric&lt;/code&gt; values are converted to &lt;code&gt;float8&lt;/code&gt; for comparison to a &lt;code&gt;float8&lt;/code&gt;. Because of the limited accuracy of &lt;code&gt;float8&lt;/code&gt;, this means there are distinct &lt;code&gt;numeric&lt;/code&gt; values that will compare equal to the same &lt;code&gt;float8&lt;/code&gt; value, and thus the transitive law would fail.</source>
          <target state="translated">여러 데이터 유형을 지원하는 운영자 제품군의 경우 패밀리의 모든 데이터 유형에서 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 를 가져 오는 경우 위의 법률에 따라야합니다 . 전 이적 법칙은 교차 유형 상황에서 두세 명의 다른 연산자의 행동이 일관된다는 진술을 나타 내기 때문에 가장 까다로울 수 있습니다. 예를 들어, 안 작업 넣는 것 &lt;code&gt;float8&lt;/code&gt; 와 &lt;code&gt;numeric&lt;/code&gt; 적어도 않는 것이 현재의 의미와 동일한 조작 집안 &lt;code&gt;numeric&lt;/code&gt; 값으로 변환 &lt;code&gt;float8&lt;/code&gt; (A)에 비교 &lt;code&gt;float8&lt;/code&gt; . &lt;code&gt;float8&lt;/code&gt; 의 정확도가 제한되어 있기 때문에 이는 고유 한 &lt;code&gt;numeric&lt;/code&gt; 가 있음을 의미합니다동일한 &lt;code&gt;float8&lt;/code&gt; 값 과 동일하게 비교 될 수 있으므로 전이 법칙은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fb67d8e335116f8d04cb145c346f347c48295886" translate="yes" xml:space="preserve">
          <source>For analyze, a similar condition is used: the threshold, defined as:</source>
          <target state="translated">분석을 위해 유사한 조건이 사용됩니다. 임계 값은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d9ad010e024a4439cd621de2da500fdb418cf81a" translate="yes" xml:space="preserve">
          <source>For any pattern, to install shared applications (tables to be used by everyone, additional functions provided by third parties, etc.), put them into separate schemas. Remember to grant appropriate privileges to allow the other users to access them. Users can then refer to these additional objects by qualifying the names with a schema name, or they can put the additional schemas into their search path, as they choose.</source>
          <target state="translated">모든 패턴에 대해 공유 응용 프로그램 (모든 사람이 사용할 테이블, 타사에서 제공하는 추가 기능 등)을 설치하려면 별도의 스키마에 넣으십시오. 다른 사용자가 액세스 할 수 있도록 적절한 권한을 부여하십시오. 그런 다음 사용자는 이름을 스키마 이름으로 규정하여 이러한 추가 오브젝트를 참조하거나 추가 스키마를 원하는대로 검색 경로에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16a497bd5483558f99655038b89f96368461a1c5" translate="yes" xml:space="preserve">
          <source>For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="translated">이전 버전과의 호환성을 위해 이름을 작은 따옴표로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca86393d893511ed217c26aec47e69fc362ff707" translate="yes" xml:space="preserve">
          <source>For both &lt;code&gt;LIKE&lt;/code&gt; and regular-expression searches, keep in mind that a pattern with no extractable trigrams will degenerate to a full-index scan.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;LIKE&lt;/code&gt; 와 정규 표현 검색, 아니 추출 괘와 패턴이 전체 인덱스 스캔으로 변질 것을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="7c873bea9ea29f067ffabebef48d2954f71baefe" translate="yes" xml:space="preserve">
          <source>For both these functions, the optional &lt;code&gt;weights&lt;/code&gt; argument offers the ability to weigh word instances more or less heavily depending on how they are labeled. The weight arrays specify how heavily to weigh each category of word, in the order:</source>
          <target state="translated">이 두 기능 모두에 대해 선택적 &lt;code&gt;weights&lt;/code&gt; 인수는 레이블이 지정된 방식에 따라 단어 인스턴스의 무게를 어느 정도 줄일 수 있습니다. 가중치 배열은 다음과 같은 순서로 각 단어 범주를 얼마나 크게 계량 할 것인지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0b0722cabc6ab2e548afa613aa4953b992a05e07" translate="yes" xml:space="preserve">
          <source>For clarity we omitted the &lt;code&gt;coalesce&lt;/code&gt; function calls which would be needed to find rows that contain &lt;code&gt;NULL&lt;/code&gt; in one of the two fields.</source>
          <target state="translated">명확성 을 위해 두 필드 중 하나에 &lt;code&gt;NULL&lt;/code&gt; 을 포함하는 행을 찾는 데 필요한 &lt;code&gt;coalesce&lt;/code&gt; 함수 호출을 생략했습니다 .</target>
        </trans-unit>
        <trans-unit id="5a4475c3ea46bdd2013d00d5535373f530d5c349" translate="yes" xml:space="preserve">
          <source>For clarity, you can also request default values explicitly, for individual columns or for the entire row:</source>
          <target state="translated">명확하게하기 위해 개별 열 또는 전체 행에 대해 기본값을 명시 적으로 요청할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="93860c51a978bc4e5066beb2f011be832a913dba" translate="yes" xml:space="preserve">
          <source>For clients using extended query protocol, durations of the Parse, Bind, and Execute steps are logged independently.</source>
          <target state="translated">확장 쿼리 프로토콜을 사용하는 클라이언트의 경우 구문 분석, 바인드 및 실행 단계의 지속 기간이 독립적으로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="642c28fcef80f55a7fa8a09654289e47fe6125b8" translate="yes" xml:space="preserve">
          <source>For comparison, the PostgreSQL 8.1 documentation contained 10,441 unique words, a total of 335,420 words, and the most frequent word &amp;ldquo;postgresql&amp;rdquo; was mentioned 6,127 times in 655 documents.</source>
          <target state="translated">비교를 위해 PostgreSQL 8.1 설명서에는 10,441 개의 고유 한 단어, 총 335,420 개의 단어가 포함되어 있으며 가장 빈번한 단어 &quot;postgresql&quot;은 655 개 문서에서 6,127 번 언급되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e2967140afc307af479be8f80698d1858dbc62a" translate="yes" xml:space="preserve">
          <source>For compatibility with output generated by older versions of PostgreSQL, and to allow the output precision to be reduced, the &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; parameter can be used to select rounded decimal output instead. Setting a value of 0 restores the previous default of rounding the value to 6 (for &lt;code&gt;float4&lt;/code&gt;) or 15 (for &lt;code&gt;float8&lt;/code&gt;) significant decimal digits. Setting a negative value reduces the number of digits further; for example -2 would round output to 4 or 13 digits respectively.</source>
          <target state="translated">이전 버전의 PostgreSQL에서 생성 된 출력과 호환되고 출력 정밀도를 &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;낮추기&lt;/a&gt; 위해 extra_float_digits 매개 변수를 사용하여 반올림 된 십진 출력을 대신 선택할 수 있습니다. 값을 0으로 설정하면 값을 6 ( &lt;code&gt;float4&lt;/code&gt; ) 또는 15 ( &lt;code&gt;float8&lt;/code&gt; )의 유효 10 진수로 반올림하는 이전 기본값이 복원 됩니다. 음수 값을 설정하면 자릿수가 더 줄어 듭니다. 예를 들어 -2는 출력을 각각 4 또는 13 자리로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="82e33c9e09cc041982adc16695f27c2ebea4aeea" translate="yes" xml:space="preserve">
          <source>For compatibility with some other database systems, &lt;code&gt;argmode&lt;/code&gt; can be written either before or after &lt;code&gt;argname&lt;/code&gt;. But only the first way is standard-compliant.</source>
          <target state="translated">다른 데이터베이스 시스템과의 호환성을 위해 &lt;code&gt;argmode&lt;/code&gt; 는 이전 또는 이후에 기록 될 수 &lt;code&gt;argname&lt;/code&gt; . 그러나 첫 번째 방법 만 표준을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="28fead7bc1a5393ae5055409c79f82dc0d627975" translate="yes" xml:space="preserve">
          <source>For compatibility's sake, PostgreSQL will accept the &lt;code&gt;GLOBAL&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; keywords in a temporary table declaration, but they currently have no effect. Use of these keywords is discouraged, since future versions of PostgreSQL might adopt a more standard-compliant interpretation of their meaning.</source>
          <target state="translated">호환성을 위해 PostgreSQL은 임시 테이블 선언에서 &lt;code&gt;GLOBAL&lt;/code&gt; 및 &lt;code&gt;LOCAL&lt;/code&gt; 키워드를 허용 하지만 현재는 효과가 없습니다. 이후 버전의 PostgreSQL에서는 의미에 대한보다 표준적인 해석을 채택 할 수 있으므로 이러한 키워드는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cb0d695c453e288497b0e820fe56bdd716e52946" translate="yes" xml:space="preserve">
          <source>For compiled functions, both built-in and dynamically loaded, &lt;code&gt;prosrc&lt;/code&gt; contains the function's C-language name (link symbol). For all other currently-known language types, &lt;code&gt;prosrc&lt;/code&gt; contains the function's source text. &lt;code&gt;probin&lt;/code&gt; is unused except for dynamically-loaded C functions, for which it gives the name of the shared library file containing the function.</source>
          <target state="translated">내장 및 동적으로로드 된 컴파일 된 함수의 경우 &lt;code&gt;prosrc&lt;/code&gt; 에는 함수의 C 언어 이름 (링크 기호)이 포함됩니다. 현재 알려진 다른 모든 언어 유형의 경우 &lt;code&gt;prosrc&lt;/code&gt; 에는 함수의 소스 텍스트가 포함됩니다. &lt;code&gt;probin&lt;/code&gt; 은 동적으로로드 된 C 함수를 제외하고는 사용되지 않으며 함수를 포함하는 공유 라이브러리 파일의 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1593a37c3e4bef998076b51ab60cf493f14debc2" translate="yes" xml:space="preserve">
          <source>For conditional purposes, non zero numerical values are &lt;code&gt;TRUE&lt;/code&gt;, zero numerical values and &lt;code&gt;NULL&lt;/code&gt; are &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">조건부 목적으로, 0이 아닌 숫자 값은 &lt;code&gt;TRUE&lt;/code&gt; , 0 숫자 값 및 &lt;code&gt;NULL&lt;/code&gt; 은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ca450dc70846b4e702e0834dc4a1ac754f8335c" translate="yes" xml:space="preserve">
          <source>For convenience there are also single letter command-line option switches available for some parameters. They are described in &lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;Table 19.2&lt;/a&gt;. Some of these options exist for historical reasons, and their presence as a single-letter option does not necessarily indicate an endorsement to use the option heavily.</source>
          <target state="translated">편의상 일부 매개 변수에 사용 가능한 단일 문자 명령 행 옵션 스위치도 있습니다. 그것들은 &lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;표 19.2에&lt;/a&gt; 설명되어 있습니다. 이러한 옵션 중 일부는 역사적 이유로 존재하며 단일 문자 옵션으로 존재한다고해서 옵션을 많이 사용한다고 보증하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7bc2076f57d611864b1939f513772007f82c5791" translate="yes" xml:space="preserve">
          <source>For convenience there are also single letter command-line option switches available for some parameters. They are described in &lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;Table 19.3&lt;/a&gt;. Some of these options exist for historical reasons, and their presence as a single-letter option does not necessarily indicate an endorsement to use the option heavily.</source>
          <target state="translated">편의를 위해 일부 매개 변수에 사용할 수있는 단일 문자 명령 줄 옵션 스위치도 있습니다. &lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;표 19.3에&lt;/a&gt; 설명되어 있습니다. 이러한 옵션 중 일부는 역사적 이유로 존재하며 단일 문자 옵션으로 존재한다고해서 반드시 옵션을 많이 사용하는 것을 보증하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f4b1609541244f90c1469cfda93f87205751028" translate="yes" xml:space="preserve">
          <source>For convenience, the programs &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; and &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; are provided as wrappers around these SQL commands that can be called from the shell command line:</source>
          <target state="translated">편의상 &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; 및 &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; 프로그램 은 쉘 명령 행에서 호출 할 수있는 이러한 SQL 명령 주위에 랩퍼로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3832912e6c9f91aa4902ff08b60d0cbcee1c2ac8" translate="yes" xml:space="preserve">
          <source>For convenience, there is also a shell program to drop databases, &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt;:</source>
          <target state="translated">편의를 위해 데이터베이스를 삭제하는 쉘 프로그램 &lt;a href=&quot;app-dropdb&quot;&gt;dropdb도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2086e8168bb5d57d0ea6881d92ef9c3d377f6179" translate="yes" xml:space="preserve">
          <source>For crash safety, an AM can use postgres' &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;WAL&lt;/a&gt;, or a custom implementation. If WAL is chosen, either &lt;a href=&quot;generic-wal&quot;&gt;Generic WAL Records&lt;/a&gt; can be used, or a new type of WAL records can be implemented. Generic WAL Records are easy, but imply higher WAL volume. Implementation of a new type of WAL record currently requires modifications to core code (specifically, &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt;).</source>
          <target state="translated">충돌 안전을 위해 AM은 postgres의 &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;WAL&lt;/a&gt; 또는 사용자 정의 구현을 사용할 수 있습니다 . WAL을 선택하면 &lt;a href=&quot;generic-wal&quot;&gt;일반 WAL 레코드&lt;/a&gt; 를 사용하거나 새로운 유형의 WAL 레코드를 구현할 수 있습니다. 일반 WAL 레코드는 쉽지만 더 높은 WAL 볼륨을 의미합니다. 새로운 유형의 WAL 레코드를 구현하려면 현재 핵심 코드 (특히 &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt; )를 수정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bbdc473894ba97ea91078047c916d6159b963419" translate="yes" xml:space="preserve">
          <source>For crash safety, an AM can use postgres' &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;WAL&lt;/a&gt;, or a custom implementation. If WAL is chosen, either &lt;a href=&quot;generic-wal&quot;&gt;Generic WAL Records&lt;/a&gt; can be used, or a new type of WAL records can be implemented. Generic WAL Records are easy, but imply higher WAL volume. Implementation of a new type of WAL record currently requires modifications to core code (specifically, &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt;).</source>
          <target state="translated">충돌 안전을 위해 AM은 postgres의 &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;WAL&lt;/a&gt; 또는 사용자 지정 구현을 사용할 수 있습니다 . WAL을 선택하면 &lt;a href=&quot;generic-wal&quot;&gt;일반 WAL 레코드&lt;/a&gt; 를 사용하거나 새로운 유형의 WAL 레코드를 구현할 수 있습니다. 일반 WAL 레코드는 쉽지만 더 높은 WAL 볼륨을 의미합니다. 새로운 유형의 WAL 레코드를 구현하려면 현재 핵심 코드 (특히 &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt; )를 수정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="45171c5ce1cebf261c0bfc4a29a7bbae2406dddb" translate="yes" xml:space="preserve">
          <source>For databases, allows new schemas and publications to be created within the database, and allows trusted extensions to be installed within the database.</source>
          <target state="translated">데이터베이스의 경우 데이터베이스 내에서 새 스키마 및 게시를 만들 수 있으며 신뢰할 수있는 확장을 데이터베이스 내에 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c062e145de387371ec37dc656ac5b92503663ca" translate="yes" xml:space="preserve">
          <source>For databases, allows new schemas and publications to be created within the database.</source>
          <target state="translated">데이터베이스의 경우 데이터베이스 내에 새 스키마 및 게시를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4984c57688cb1cee66323a19c7444a0a9bb0477" translate="yes" xml:space="preserve">
          <source>For declarative partitioning, partitions must have exactly the same set of columns as the partitioned table, whereas with table inheritance, child tables may have extra columns not present in the parent.</source>
          <target state="translated">선언적 분할의 경우 분할 영역은 분할 된 테이블과 정확히 동일한 열 집합을 가져야하지만 테이블 상속을 사용하면 자식 테이블에 부모에 추가 열이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8cd79e49912cef7e36a49a72250f6cd15cb54e" translate="yes" xml:space="preserve">
          <source>For deployment testing, create a schema-only copy of the old cluster, insert dummy data, and upgrade that.</source>
          <target state="translated">배치 테스트를 위해 이전 클러스터의 스키마 전용 사본을 작성하고 더미 데이터를 삽입 한 후 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="23fcbc4c69f038c631978df5d852e7c988638319" translate="yes" xml:space="preserve">
          <source>For details about proper usage of these functions, see &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;.</source>
          <target state="translated">이 기능의 올바른 사용법에 대한 자세한 내용은 &lt;a href=&quot;continuous-archiving&quot;&gt;25.3 절을&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="7a67dca85d30cbed66dc7cc81857442fa00d590c" translate="yes" xml:space="preserve">
          <source>For details on using &lt;code&gt;jsonpath&lt;/code&gt; expressions with SQL/JSON query functions, see &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;Section 9.15.2&lt;/a&gt;.</source>
          <target state="translated">SQL / JSON 쿼리 함수와 함께 &lt;code&gt;jsonpath&lt;/code&gt; 표현식 사용에 대한 자세한 내용 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;은 9.15.2 절을&lt;/a&gt; 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="0a2ee1a4a4b6ea5b1e5dc69f843d5bf40d2adf1f" translate="yes" xml:space="preserve">
          <source>For details on using &lt;code&gt;jsonpath&lt;/code&gt; expressions with SQL/JSON query functions, see &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;Section 9.16.2&lt;/a&gt;.</source>
          <target state="translated">SQL / JSON 쿼리 함수와 함께 &lt;code&gt;jsonpath&lt;/code&gt; 표현식 을 사용하는 방법 에 대한 자세한 내용 은 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;Section 9.16.2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aba8e3841c67fc994b221c5d39e6ca9666653d88" translate="yes" xml:space="preserve">
          <source>For developers familiar with XQuery and XPath 2.0 or later, XPath 1.0 presents a number of differences to contend with:</source>
          <target state="translated">XQuery 및 XPath 2.0 이상에 익숙한 개발자에게 XPath 1.0은 다음과 같은 여러 가지 차이점을 제시합니다.</target>
        </trans-unit>
        <trans-unit id="444e073c791a9db99f3d6ee4275247eb7942a2d4" translate="yes" xml:space="preserve">
          <source>For development and debugging purposes a few additional configuration parameters exist, as described in &lt;a href=&quot;runtime-config-developer&quot;&gt;Section 19.17&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-developer&quot;&gt;19.17 절&lt;/a&gt; 에서 설명한 것처럼 개발 및 디버깅 목적으로 몇 가지 추가 구성 매개 변수가 있습니다. .</target>
        </trans-unit>
        <trans-unit id="2f6d0f2ed640d213e669a2d88363956decb0dc50" translate="yes" xml:space="preserve">
          <source>For each child table, create an index on the key column(s), as well as any other indexes you might want.</source>
          <target state="translated">각 하위 테이블에 대해 키 열에 인덱스 및 원하는 다른 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="25abda91cdb6a3bbf8ff5bdcb98364248d703bc8" translate="yes" xml:space="preserve">
          <source>For each column in the index key (&lt;code&gt;indnkeyatts&lt;/code&gt; values), this contains the OID of the collation to use for the index, or zero if the column is not of a collatable data type.</source>
          <target state="translated">색인 키의 각 열 ( &lt;code&gt;indnkeyatts&lt;/code&gt; 값)에 대해 인덱스에 사용할 데이터 정렬의 OID가 포함되거나 열이 데이터 형식이 아닌 경우 0이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6fc7ad5122e2bfa01daa15f6eed504af7d2b8967" translate="yes" xml:space="preserve">
          <source>For each column in the index key (&lt;code&gt;indnkeyatts&lt;/code&gt; values), this contains the OID of the operator class to use. See &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">인덱스 키의 각 열 ( &lt;code&gt;indnkeyatts&lt;/code&gt; 값)에 사용할 연산자 클래스의 OID가 포함됩니다. &lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51f668b2a5a8c54bfcef88243c43a45aa5a55a09" translate="yes" xml:space="preserve">
          <source>For each column in the partition key, this contains the OID of the collation to use for partitioning, or zero if the column is not of a collatable data type.</source>
          <target state="translated">파티션 키의 각 열에 대해 파티셔닝에 사용할 데이터 정렬의 OID가 포함되거나 열이 데이터 형식이 아닌 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="3edc803302a59c643149e81e1e75d11544ede04f" translate="yes" xml:space="preserve">
          <source>For each column in the partition key, this contains the OID of the operator class to use. See &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">파티션 키의 각 열마다 사용할 연산자 클래스의 OID가 포함됩니다. 자세한 내용은 &lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7ccb1aca150cd3fd2a76eea5ce2e2c6866c56ef1" translate="yes" xml:space="preserve">
          <source>For each column that will contain unique references to large objects, create a &lt;code&gt;BEFORE UPDATE OR DELETE&lt;/code&gt; trigger, and give the column name as the sole trigger argument. You can also restrict the trigger to only execute on updates to the column by using &lt;code&gt;BEFORE UPDATE OF&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt;. If you need multiple &lt;code&gt;lo&lt;/code&gt; columns in the same table, create a separate trigger for each one, remembering to give a different name to each trigger on the same table.</source>
          <target state="translated">큰 개체에 대한 고유 한 참조를 포함 할 각 열에 대해 &lt;code&gt;BEFORE UPDATE OR DELETE&lt;/code&gt; 트리거를 만들고 열 이름을 유일한 트리거 인수로 지정하십시오. &lt;code&gt;BEFORE UPDATE OF&lt;/code&gt; &lt;code&gt;column_name&lt;/code&gt; 을 사용하여 트리거가 열 업데이트에서만 실행되도록 제한 할 수도 있습니다 . 동일한 테이블에 여러 &lt;code&gt;lo&lt;/code&gt; 열 이 필요한 경우 동일한 테이블의 각 트리거에 다른 이름을 지정하는 것을 기억하여 각각에 대해 별도의 트리거를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="dc93abd020281b000ae47dfd8ef843f236c6a3a8" translate="yes" xml:space="preserve">
          <source>For each combination of data types that a btree operator family provides comparison operators for, it must provide a comparison support function, registered in &lt;code&gt;pg_amproc&lt;/code&gt; with support function number 1 and &lt;code&gt;amproclefttype&lt;/code&gt;/&lt;code&gt;amprocrighttype&lt;/code&gt; equal to the left and right data types for the comparison (i.e., the same data types that the matching operators are registered with in &lt;code&gt;pg_amop&lt;/code&gt;). The comparison function must take two non-null values &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and return an &lt;code&gt;int32&lt;/code&gt; value that is &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, or &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt; when &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, or &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, respectively. A null result is disallowed: all values of the data type must be comparable. See &lt;code&gt;src/backend/access/nbtree/nbtcompare.c&lt;/code&gt; for examples.</source>
          <target state="translated">btree 연산자 제품군이 비교 연산자를 제공하는 각 데이터 유형 조합에 대해 지원 기능 번호 1 및 비교를위한 왼쪽 및 오른쪽 데이터 유형과 동일한 &lt;code&gt;amproclefttype&lt;/code&gt; / &lt;code&gt;amprocrighttype&lt;/code&gt; 과 함께 &lt;code&gt;pg_amproc&lt;/code&gt; 에 등록 된 비교 지원 기능을 제공해야합니다 (예 : 일치하는 연산자가 &lt;code&gt;pg_amop&lt;/code&gt; 에 등록 된 것과 동일한 데이터 유형 ). 비교 함수는 널이 아닌 두 개의 값 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 를 가져 와서 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 인 경우 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; 인 &lt;code&gt;int32&lt;/code&gt; 값을 리턴해야합니다 . &lt;code&gt;A&lt;/code&gt; 인 . &lt;code&gt;=&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 각각. 널 (NULL) 결과는 허용되지 않습니다. 데이터 유형의 모든 값이 비교 가능해야합니다. 예는 &lt;code&gt;src/backend/access/nbtree/nbtcompare.c&lt;/code&gt; 를 참조하십시오 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="816bbd53914791af08e63dd703c10a6ffd0c4825" translate="yes" xml:space="preserve">
          <source>For each database in the cluster there is a subdirectory within &lt;code&gt;PGDATA&lt;/code&gt;&lt;code&gt;/base&lt;/code&gt;, named after the database's OID in &lt;code&gt;pg_database&lt;/code&gt;. This subdirectory is the default location for the database's files; in particular, its system catalogs are stored there.</source>
          <target state="translated">클러스터의 각 데이터베이스마다 &lt;code&gt;pg_database&lt;/code&gt; &lt;code&gt;/base&lt;/code&gt; 의 데이터베이스 OID 이름을 따서 명명 된 &lt;code&gt;PGDATA&lt;/code&gt; / base 내에 서브 디렉토리가 있습니다 . 이 서브 디렉토리는 데이터베이스 파일의 기본 위치입니다. 특히 해당 시스템 카탈로그가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="5a93df004449e3d17d4da507b5cc8728f0ee8920" translate="yes" xml:space="preserve">
          <source>For each of these hypothetical-set aggregates, the list of direct arguments given in &lt;code&gt;args&lt;/code&gt; must match the number and types of the aggregated arguments given in &lt;code&gt;sorted_args&lt;/code&gt;. Unlike most built-in aggregates, these aggregates are not strict, that is they do not drop input rows containing nulls. Null values sort according to the rule specified in the &lt;code&gt;ORDER BY&lt;/code&gt; clause.</source>
          <target state="translated">이러한 가상 집합 집계 각각에 대해 &lt;code&gt;args&lt;/code&gt; 에 지정된 직접 인수 목록은 &lt;code&gt;sorted_args&lt;/code&gt; 에 제공된 집계 인수의 수와 유형과 일치해야합니다 . 대부분의 기본 제공 집계와 달리 이러한 집계는 엄격하지 않습니다. 즉, null을 포함하는 입력 행을 삭제하지 않습니다. 널값은 &lt;code&gt;ORDER BY&lt;/code&gt; 절에 지정된 규칙에 따라 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cc9c8be16b2cd2bfdfefa12d9931dcf7459faa0" translate="yes" xml:space="preserve">
          <source>For each query, output performance statistics of the respective module to the server log. This is a crude profiling instrument, similar to the Unix &lt;code&gt;getrusage()&lt;/code&gt; operating system facility. &lt;code&gt;log_statement_stats&lt;/code&gt; reports total statement statistics, while the others report per-module statistics. &lt;code&gt;log_statement_stats&lt;/code&gt; cannot be enabled together with any of the per-module options. All of these options are disabled by default. Only superusers can change these settings.</source>
          <target state="translated">각 쿼리마다 해당 모듈의 성능 통계를 서버 로그에 출력합니다. 이것은 Unix &lt;code&gt;getrusage()&lt;/code&gt; 운영 체제 기능 과 유사한 조잡한 프로파일 링 도구 입니다. &lt;code&gt;log_statement_stats&lt;/code&gt; 는 전체 명령문 통계를보고하고 나머지는 모듈 별 통계를보고합니다. &lt;code&gt;log_statement_stats&lt;/code&gt; 는 모듈 별 옵션과 함께 사용할 수 없습니다. 이러한 옵션은 모두 기본적으로 비활성화되어 있습니다. 수퍼 유저 만 이러한 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ba598fc8c9be134161735a51a95dc2f9f525608" translate="yes" xml:space="preserve">
          <source>For each relation (table, view, materialized view, index, sequence, or foreign table) or composite type matching the &lt;code&gt;pattern&lt;/code&gt;, show all columns, their types, the tablespace (if not the default) and any special attributes such as &lt;code&gt;NOT NULL&lt;/code&gt; or defaults. Associated indexes, constraints, rules, and triggers are also shown. For foreign tables, the associated foreign server is shown as well. (&amp;ldquo;Matching the pattern&amp;rdquo; is defined in &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치하는 각 관계 (테이블, 뷰, 구체화 된 뷰, 인덱스, 시퀀스 또는 외부 테이블) 또는 복합 유형에 대해 모든 열, 해당 유형, 테이블 스페이스 (기본값이 아닌 경우) 및 &lt;code&gt;NOT NULL&lt;/code&gt; 또는 기본값. 관련 인덱스, 제약 조건, 규칙 및 트리거도 표시됩니다. 외부 테이블의 경우 연관된 외부 서버도 표시됩니다. (&amp;ldquo;패턴 일치&amp;rdquo;는 아래 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴에&lt;/a&gt; 정의되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="77b4eaff32602e55630fc25f0d7615181a46a544" translate="yes" xml:space="preserve">
          <source>For each row R1 of T1, the joined table has a row for each row in T2 that satisfies the join condition with R1.</source>
          <target state="translated">T1의 각 행 R1에 대해 결합 된 테이블에는 R1과의 결합 조건을 만족시키는 T2의 각 행에 대한 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8594ae1b752513c4090775efefd1243bce43044f" translate="yes" xml:space="preserve">
          <source>For efficiency reasons, &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt; are not updated on-the-fly, and so they usually contain somewhat out-of-date values. They are updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;. A &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; operation that does not scan the entire table (which is commonly the case) will incrementally update the &lt;code&gt;reltuples&lt;/code&gt; count on the basis of the part of the table it did scan, resulting in an approximate value. In any case, the planner will scale the values it finds in &lt;code&gt;pg_class&lt;/code&gt; to match the current physical table size, thus obtaining a closer approximation.</source>
          <target state="translated">효율성상의 이유로 &lt;code&gt;reltuples&lt;/code&gt; 와 &lt;code&gt;relpages&lt;/code&gt; 는 즉시 업데이트되지 않으므로 일반적으로 다소 오래된 값을 포함합니다. &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 와 같은 몇 가지 DDL 명령 으로 업데이트됩니다 . &lt;code&gt;VACUUM&lt;/code&gt; 또는 &lt;code&gt;ANALYZE&lt;/code&gt; (경우에 통상적 인) 전체 테이블을 검색하지 않고 점진적으로 업데이트 할 동작 &lt;code&gt;reltuples&lt;/code&gt; 는 근사치의 결과는 스캔 한 테이블의 일부에 기초하여 계산. 어쨌든 플래너는 &lt;code&gt;pg_class&lt;/code&gt; 에서 찾은 값을 현재 실제 테이블 크기와 일치하도록 스케일링하여 더 가까운 근사값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2498c1aea650efa3ff6e721df8f862e425ed274a" translate="yes" xml:space="preserve">
          <source>For enum types (described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;), there are several functions that allow cleaner programming without hard-coding particular values of an enum type. These are listed in &lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;Table 9.33&lt;/a&gt;. The examples assume an enum type created as:</source>
          <target state="translated">열거 형의 경우 ( &lt;a href=&quot;datatype-enum&quot;&gt;8.7 장&lt;/a&gt; 에서 설명 ), 열거 형의 특정 값을 하드 코딩하지 않고보다 깔끔한 프로그래밍을 가능하게하는 몇 가지 기능이 있습니다. 이것들은 &lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;표 9.33에&lt;/a&gt; 나열되어 있습니다. 예제에서는 다음과 같이 열거 형 유형을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7318a3eeb2a0e3f509084e3ec69e3b05be39dc31" translate="yes" xml:space="preserve">
          <source>For enum types (described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;), there are several functions that allow cleaner programming without hard-coding particular values of an enum type. These are listed in &lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;Table 9.34&lt;/a&gt;. The examples assume an enum type created as:</source>
          <target state="translated">열거 형 유형 ( &lt;a href=&quot;datatype-enum&quot;&gt;8.7 절에&lt;/a&gt; 설명 됨 )의 경우 열거 형 유형의 특정 값을 하드 코딩하지 않고도보다 깔끔한 프로그래밍을 할 수있는 몇 가지 함수가 있습니다. 이는 &lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;표 9.34에&lt;/a&gt; 나열되어 있습니다. 예제에서는 다음과 같이 생성 된 enum 유형을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a25a74babc64151f8b4ea2da440ad370951a8d59" translate="yes" xml:space="preserve">
          <source>For every possible combination of rows from &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; (i.e., a Cartesian product), the joined table will contain a row consisting of all columns in &lt;code&gt;T1&lt;/code&gt; followed by all columns in &lt;code&gt;T2&lt;/code&gt;. If the tables have N and M rows respectively, the joined table will have N * M rows.</source>
          <target state="translated">행에서의 모든 가능한 조합에 대해 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; (즉, 데카르트 제품), 조인 테이블의 모든 열 이루어진 연속 포함 &lt;code&gt;T1&lt;/code&gt; 은 모든 열 뒤에 &lt;code&gt;T2&lt;/code&gt; . 테이블에 N 및 M 행이 각각있는 경우 결합 된 테이블에는 N * M 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c6d96910fe12ae8175afb9cb9ebf00927346590" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@-&lt;/code&gt; is an allowed operator name, but &lt;code&gt;*-&lt;/code&gt; is not. This restriction allows PostgreSQL to parse SQL-compliant commands without requiring spaces between tokens.</source>
          <target state="translated">예를 들어 &lt;code&gt;@-&lt;/code&gt; 는 허용되는 연산자 이름이지만 &lt;code&gt;*-&lt;/code&gt; 는 아닙니다. 이 제한 사항으로 PostgreSQL은 토큰 사이에 공백없이 SQL 호환 명령을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7420785e3365d78ac1f9c68594d975825431286b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@-&lt;/code&gt; is an allowed operator name, but &lt;code&gt;*-&lt;/code&gt; is not. This restriction allows PostgreSQL to parse SQL-compliant queries without requiring spaces between tokens.</source>
          <target state="translated">예를 들어 &lt;code&gt;@-&lt;/code&gt; 는 허용되는 연산자 이름이지만 &lt;code&gt;*-&lt;/code&gt; 는 아닙니다. 이 제한 사항으로 PostgreSQL은 토큰 사이에 공백없이 SQL 호환 쿼리를 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1270acc7d371bd67bf727e789543eb2fb05a795a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;count(*)&lt;/code&gt; yields the total number of input rows; &lt;code&gt;count(f1)&lt;/code&gt; yields the number of input rows in which &lt;code&gt;f1&lt;/code&gt; is non-null, since &lt;code&gt;count&lt;/code&gt; ignores nulls; and &lt;code&gt;count(distinct f1)&lt;/code&gt; yields the number of distinct non-null values of &lt;code&gt;f1&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;count(*)&lt;/code&gt; 는 총 입력 행 수를 산출합니다. &lt;code&gt;count(f1)&lt;/code&gt; 된 입력 행수 산출 &lt;code&gt;f1&lt;/code&gt; 때문에, 비 - 널 &lt;code&gt;count&lt;/code&gt; 널이 무시; 그리고 &lt;code&gt;count(distinct f1)&lt;/code&gt; 의 별개의 비 - 널 값의 개수 산출 &lt;code&gt;f1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="241e368bd5f84d8bd9b37213abb0c1ce606628ca" translate="yes" xml:space="preserve">
          <source>For example, &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; might produce a set something like:</source>
          <target state="translated">예를 들어 &lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt; 은 다음과 같은 집합을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="155faecb9306b9147a2e7777bee4e12a795c5623" translate="yes" xml:space="preserve">
          <source>For example, a common way to do case-insensitive comparisons is to use the &lt;code&gt;lower&lt;/code&gt; function:</source>
          <target state="translated">예를 들어 대소 문자를 구분하지 않는 비교를 수행하는 일반적인 방법은 &lt;code&gt;lower&lt;/code&gt; 함수 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5c31174366767191298875589e027e626f3481e" translate="yes" xml:space="preserve">
          <source>For example, an application workload might consist of: 10% of changes are important customer details, while 90% of changes are less important data that the business can more easily survive if it is lost, such as chat messages between users.</source>
          <target state="translated">예를 들어, 애플리케이션 워크로드는 다음과 같이 구성 될 수 있습니다. 10 %의 변경은 중요한 고객 세부 사항이며 90 %의 변경은 비즈니스 간의 손실 메시지 (예 : 사용자 간의 대화 메시지)와 같이 비즈니스에서 더 쉽게 생존 할 수있는 덜 중요한 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="130ff877846a9ba145c6084d6c6d927c9f6f130d" translate="yes" xml:space="preserve">
          <source>For example, consider a bank database that contains balances for various customer accounts, as well as total deposit balances for branches. Suppose that we want to record a payment of $100.00 from Alice's account to Bob's account. Simplifying outrageously, the SQL commands for this might look like:</source>
          <target state="translated">예를 들어, 다양한 고객 계정에 대한 잔액과 지점에 대한 총 예금 잔액이 포함 된 은행 데이터베이스를 고려하십시오. Alice의 계정에서 Bob의 계정으로 $ 100.00의 지불을 기록하려고한다고 가정하십시오. 터무니없이 단순화하기위한 SQL 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f3682a6f9ea0b208434ae010d3a1a17fff514e9" translate="yes" xml:space="preserve">
          <source>For example, consider the definition of a function, &lt;code&gt;dept&lt;/code&gt;, as:</source>
          <target state="translated">예를 들어, 함수 &lt;code&gt;dept&lt;/code&gt; 의 정의를 다음과 같이 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e0f997381e2092937165cc0bbee1c5517c59395" translate="yes" xml:space="preserve">
          <source>For example, consider this table definition:</source>
          <target state="translated">예를 들어,이 테이블 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8190f04d38d06a461e096583cfda36d375198e8e" translate="yes" xml:space="preserve">
          <source>For example, consider:</source>
          <target state="translated">예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c33bc524f5320aea55d00b964061ae906c69106d" translate="yes" xml:space="preserve">
          <source>For example, if for some reason you want to disable the GEQO optimizer for a given database, you'd ordinarily have to either disable it for all databases or make sure that every connecting client is careful to issue &lt;code&gt;SET geqo TO off&lt;/code&gt;. To make this setting the default within a particular database, you can execute the command:</source>
          <target state="translated">예를 들어, 어떤 이유로 특정 데이터베이스에 대해 GEQO 옵티 마이저를 사용하지 않으려면 일반적으로 모든 데이터베이스에 대해 GEQO 옵티 마이저를 사용 안함으로 설정하거나 모든 연결 클라이언트가 &lt;code&gt;SET geqo TO off&lt;/code&gt; 을 발행하도록주의를 기울여야합니다 . 이 설정을 특정 데이터베이스 내에서 기본값으로 설정하려면 다음 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3496b62777d29ce14330d5cf671f27e158b5c5b3" translate="yes" xml:space="preserve">
          <source>For example, in an &lt;code&gt;UPDATE&lt;/code&gt; command requiring both &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; permissions, if there are multiple applicable policies of each type, they will be combined as follows:</source>
          <target state="translated">예를 들어, &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 권한 이 모두 필요한 &lt;code&gt;UPDATE&lt;/code&gt; 명령 에서 각 유형에 적용 가능한 정책이 여러 개인 경우 다음과 같이 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="ab8f2f938fa83461064d386cea51bbcdc598d202" translate="yes" xml:space="preserve">
          <source>For example, suppose you have some JSON data from a GPS tracker that you would like to parse, such as:</source>
          <target state="translated">예를 들어 다음과 같이 구문 분석하려는 GPS 추적기의 JSON 데이터가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="09ccf286e7b8e433098859f728308c846bcff18f" translate="yes" xml:space="preserve">
          <source>For example, suppose you would like to retrieve all heart rate values higher than 130. You can achieve this using the following expression:</source>
          <target state="translated">예를 들어 130보다 큰 모든 심박수 값을 검색한다고 가정합니다. 다음 식을 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06aef20d242f4af58541238d6758845220aef49a" translate="yes" xml:space="preserve">
          <source>For example, the following computes the square root of 2:</source>
          <target state="translated">예를 들어, 다음은 제곱근 2를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d06f05887749d75fd3c1c2ace4acae1fa3061b96" translate="yes" xml:space="preserve">
          <source>For example, the following finds the largest city population in each state:</source>
          <target state="translated">예를 들어 다음은 각 주에서 가장 큰 도시 인구를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="da6cc196eb1d7b4036c8cbb26afabb02667647d5" translate="yes" xml:space="preserve">
          <source>For example, the following is (syntactically) valid SQL input:</source>
          <target state="translated">예를 들어, 다음은 (구문 적으로) 유효한 SQL 입력입니다.</target>
        </trans-unit>
        <trans-unit id="471cd6e5da58fc5eff7b7a62ed009e72a5a73a36" translate="yes" xml:space="preserve">
          <source>For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">예를 들어 다음 쿼리는 주 수도를 포함하여 500 피트 이상의 고도에있는 모든 도시의 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="427b943c4463b780091a4e2b86abe42fce5db1c0" translate="yes" xml:space="preserve">
          <source>For example, the following query finds the names of all cities, including state capitals, that are located at an elevation over 500 feet:</source>
          <target state="translated">예를 들어 다음 쿼리는 수도를 포함하여 고도가 500 피트 이상인 모든 도시의 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8766b8f0ef1ada9c82b69e07f58a59c6fe1e88b5" translate="yes" xml:space="preserve">
          <source>For example, the operating system might provide a locale named &lt;code&gt;de_DE.utf8&lt;/code&gt;. &lt;code&gt;initdb&lt;/code&gt; would then create a collation named &lt;code&gt;de_DE.utf8&lt;/code&gt; for encoding &lt;code&gt;UTF8&lt;/code&gt; that has both &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; set to &lt;code&gt;de_DE.utf8&lt;/code&gt;. It will also create a collation with the &lt;code&gt;.utf8&lt;/code&gt; tag stripped off the name. So you could also use the collation under the name &lt;code&gt;de_DE&lt;/code&gt;, which is less cumbersome to write and makes the name less encoding-dependent. Note that, nevertheless, the initial set of collation names is platform-dependent.</source>
          <target state="translated">예를 들어, 운영 체제는 &lt;code&gt;de_DE.utf8&lt;/code&gt; 로케일을 제공 할 수 있습니다 . 그러면 &lt;code&gt;initdb&lt;/code&gt; 는 &lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; 이 모두 &lt;code&gt;de_DE.utf8&lt;/code&gt; 로 설정된 &lt;code&gt;UTF8&lt;/code&gt; 인코딩을 위해 &lt;code&gt;de_DE.utf8&lt;/code&gt; 이라는 데이터 정렬을 작성합니다 . 또한 이름 에서 &lt;code&gt;.utf8&lt;/code&gt; 태그가 제거 된 데이터 정렬을 만듭니다 . 따라서 &lt;code&gt;de_DE&lt;/code&gt; 라는 이름으로 데이터 정렬을 사용할 수도 있습니다. 이는 쓰기가 덜 번거롭고 이름이 인코딩 종속적이지 않습니다. 그럼에도 불구하고 초기 데이터 정렬 이름 집합은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3d1092481b703760dda3e1ee7578a2b981f6cc15" translate="yes" xml:space="preserve">
          <source>For example, the provided query might produce a set something like:</source>
          <target state="translated">예를 들어 제공된 쿼리는 다음과 같은 세트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52791448958e771d66ed4c02517edcf92f08b5b5" translate="yes" xml:space="preserve">
          <source>For example, this call requests 1000 values with a mean of 5 and a standard deviation of 3:</source>
          <target state="translated">예를 들어이 호출은 평균이 5이고 표준 편차가 3 인 1000 개의 값을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="2183a836f537bf498dab36fed767383696d0c956" translate="yes" xml:space="preserve">
          <source>For example, this command updates all products that have a price of 5 to have a price of 10:</source>
          <target state="translated">예를 들어,이 명령은 가격이 5 인 모든 제품을 가격이 10으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="324c8ee952ed40593d1680efa074498a02761679" translate="yes" xml:space="preserve">
          <source>For example, to check the total size of the data contained in a partitioned table &lt;code&gt;measurement&lt;/code&gt;, one could use the following query:</source>
          <target state="translated">예를 들어 파티션을 나눈 테이블 &lt;code&gt;measurement&lt;/code&gt; 포함 된 데이터의 총 크기를 확인 하려면 다음 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b7cfd87b1d0ccc58641762031f79d95fb10548" translate="yes" xml:space="preserve">
          <source>For example, to find the ten most frequent words in a document collection:</source>
          <target state="translated">예를 들어, 문서 모음에서 가장 빈번한 단어 10 개를 찾으려면</target>
        </trans-unit>
        <trans-unit id="e1319ad17250aad6d336666b42f8c3fc3dd702af" translate="yes" xml:space="preserve">
          <source>For example, we could create a domain over integers that accepts only positive integers:</source>
          <target state="translated">예를 들어 양의 정수만 허용하는 정수 이상의 도메인을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85f07a23cd87e159d728d36de17c8370d8afa3c6" translate="yes" xml:space="preserve">
          <source>For example, when querying the GPS data listed above, you can abstract from the fact that it stores an array of segments when using the lax mode:</source>
          <target state="translated">예를 들어, 위에 나열된 GPS 데이터를 쿼리 할 때 lax 모드를 사용할 때 세그먼트 배열을 저장한다는 사실을 추상화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d772c743b871fd1a2436437c4b730a2cfa282c" translate="yes" xml:space="preserve">
          <source>For examples of usage, see the regression test &lt;code&gt;sql/cube.sql&lt;/code&gt;.</source>
          <target state="translated">사용법의 예는 회귀 테스트 &lt;code&gt;sql/cube.sql&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fc3e3d4179a2417bcd2f2e1fa817b3ae7d39bff" translate="yes" xml:space="preserve">
          <source>For examples of usage, see the regression test &lt;code&gt;sql/seg.sql&lt;/code&gt;.</source>
          <target state="translated">사용법의 예는 회귀 테스트 &lt;code&gt;sql/seg.sql&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3df123af765f2fc11785cbb335e07b630c980edc" translate="yes" xml:space="preserve">
          <source>For fixed-width types used in system tables, it is critical that the size and alignment defined in &lt;code&gt;pg_type&lt;/code&gt; agree with the way that the compiler will lay out the column in a structure representing a table row.</source>
          <target state="translated">시스템 테이블에 사용되는 고정 너비 유형의 경우 &lt;code&gt;pg_type&lt;/code&gt; 에 정의 된 크기와 정렬 이 컴파일러가 테이블 행을 나타내는 구조에 열을 배치하는 방식 과 일치하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="20343bba651c5588f7a79e82c05205aaef985eca" translate="yes" xml:space="preserve">
          <source>For foreign servers, allows creation of foreign tables using the server. Grantees may also create, alter, or drop their own user mappings associated with that server.</source>
          <target state="translated">외부 서버의 경우 서버를 사용하여 외부 테이블을 작성할 수 있습니다. 피부 여자는 해당 서버와 관련된 자신의 사용자 매핑을 생성, 변경 또는 삭제할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b32aab859f58749932d6c6be03c33f6bd3e7d6" translate="yes" xml:space="preserve">
          <source>For foreign-data wrappers, allows creation of new servers using the foreign-data wrapper.</source>
          <target state="translated">외부 데이터 래퍼의 경우 외부 데이터 래퍼를 사용하여 새 서버를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="781dea1ed3385a0b699638076216344a55a6bbec" translate="yes" xml:space="preserve">
          <source>For functions and operators, an object in the search path is said to be visible if there is no object of the same name &lt;em&gt;and argument data type(s)&lt;/em&gt; earlier in the path. For operator classes and families, both the name and the associated index access method are considered.</source>
          <target state="translated">함수 및 연산자의 경우 경로 앞부분에 동일한 이름 &lt;em&gt;및 인수 데이터 유형의&lt;/em&gt; 개체가 없으면 검색 경로의 개체가 표시된다고 합니다. 연산자 클래스 및 패밀리의 경우 이름 및 관련 인덱스 액세스 방법이 모두 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="db80d63b0cfce8e9c534eefc3bfa1133ade5f443" translate="yes" xml:space="preserve">
          <source>For functions built into PostgreSQL itself, the bitcode is installed into &lt;code&gt;$pkglibdir/bitcode/postgres&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 자체에 내장 된 함수의 경우 비트 코드는 &lt;code&gt;$pkglibdir/bitcode/postgres&lt;/code&gt; 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="76b109732d62dd01020a7a1cd75adf97d78489a2" translate="yes" xml:space="preserve">
          <source>For functions, &lt;code&gt;db_procedure:{execute}&lt;/code&gt; will be checked when user tries to execute a function as a part of query, or using fast-path invocation. If this function is a trusted procedure, it also checks &lt;code&gt;db_procedure:{entrypoint}&lt;/code&gt; permission to check whether it can perform as entry point of trusted procedure.</source>
          <target state="translated">함수의 경우 사용자가 쿼리의 일부로 함수를 실행하거나 빠른 경로 호출을 사용 하면 &lt;code&gt;db_procedure:{execute}&lt;/code&gt; 가 점검됩니다. 이 함수가 신뢰할 수있는 프로 시저 인 경우 &lt;code&gt;db_procedure:{entrypoint}&lt;/code&gt; 권한을 확인하여 신뢰할 수있는 프로 시저의 시작점으로 수행 할 수 있는지 여부를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="50f73f941e99db6aff704bfc76eaf9cb53fc581b" translate="yes" xml:space="preserve">
          <source>For further examples of scripts used for bulk editing, see &lt;code&gt;convert_oid2name.pl&lt;/code&gt; and &lt;code&gt;remove_pg_type_oid_symbols.pl&lt;/code&gt; attached to this message: &lt;a href=&quot;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&quot;&gt;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&lt;/a&gt;</source>
          <target state="translated">대량 편집에 사용되는 스크립트의 추가 예는 다음 메시지에 첨부 된 &lt;code&gt;convert_oid2name.pl&lt;/code&gt; 및 &lt;code&gt;remove_pg_type_oid_symbols.pl&lt;/code&gt; 을 참조하십시오 . &lt;a href=&quot;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&quot;&gt;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3Shfmail.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95d0a9533934206493197f921cdd921bcea9067d" translate="yes" xml:space="preserve">
          <source>For historical reasons, &lt;code&gt;ALTER TABLE&lt;/code&gt; can be used with sequences too; but the only variants of &lt;code&gt;ALTER TABLE&lt;/code&gt; that are allowed with sequences are equivalent to the forms shown above.</source>
          <target state="translated">역사적인 이유로 &lt;code&gt;ALTER TABLE&lt;/code&gt; 도 시퀀스와 함께 사용할 수 있습니다. 그러나 시퀀스에 허용되는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 의 유일한 변형은 위에 표시된 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="821eb91f933952c5c235fc4f1d7ebbeff4650e0a" translate="yes" xml:space="preserve">
          <source>For historical reasons, &lt;code&gt;ALTER TABLE&lt;/code&gt; can be used with views too; but the only variants of &lt;code&gt;ALTER TABLE&lt;/code&gt; that are allowed with views are equivalent to the ones shown above.</source>
          <target state="translated">역사적인 이유로 &lt;code&gt;ALTER TABLE&lt;/code&gt; 도 뷰와 함께 사용할 수 있습니다. 그러나 뷰에 허용되는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 의 유일한 변형은 위에 표시된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fd9d930dc3517bba2d1837bdddba003f94a1e402" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;inet_ops&lt;/code&gt; operator class is not the default class for types &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;. To use it, mention the class name in &lt;code&gt;CREATE INDEX&lt;/code&gt;, for example</source>
          <target state="translated">역사적 이유로 &lt;code&gt;inet_ops&lt;/code&gt; 연산자 클래스는 &lt;code&gt;inet&lt;/code&gt; 및 &lt;code&gt;cidr&lt;/code&gt; 유형의 기본 클래스가 아닙니다 . 그것을 사용하려면에서 클래스 이름 언급 &lt;code&gt;CREATE INDEX&lt;/code&gt; 예를 들어,</target>
        </trans-unit>
        <trans-unit id="c4d4c412fef208bbedad98fd29f400c744b1038b" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;penalty&lt;/code&gt; function doesn't just return a &lt;code&gt;float&lt;/code&gt; result; instead it has to store the value at the location indicated by the third argument. The return value per se is ignored, though it's conventional to pass back the address of that argument.</source>
          <target state="translated">역사적 이유로 &lt;code&gt;penalty&lt;/code&gt; 함수는 &lt;code&gt;float&lt;/code&gt; 결과 만 반환하지 않습니다 . 대신 세 번째 인수로 표시된 위치에 값을 저장해야합니다. 반환 값 자체는 무시되지만 해당 인수의 주소를 다시 전달하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="602a56377f9c453998804c9239a3f0e16670f12d" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;same&lt;/code&gt; function doesn't just return a Boolean result; instead it has to store the flag at the location indicated by the third argument. The return value per se is ignored, though it's conventional to pass back the address of that argument.</source>
          <target state="translated">역사적 이유로 &lt;code&gt;same&lt;/code&gt; 함수는 부울 결과 만 반환하지 않습니다. 대신 세 번째 인수로 표시된 위치에 플래그를 저장해야합니다. 반환 값 자체는 무시되지만 해당 인수의 주소를 다시 전달하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="21712eeec3b375c143c6b302dd00ef3b3fdb1287" translate="yes" xml:space="preserve">
          <source>For historical reasons, the function &lt;code&gt;md5&lt;/code&gt; returns a hex-encoded value of type &lt;code&gt;text&lt;/code&gt; whereas the SHA-2 functions return type &lt;code&gt;bytea&lt;/code&gt;. Use the functions &lt;a href=&quot;functions-binarystring#FUNCTION-ENCODE&quot;&gt;&lt;code&gt;encode&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions-binarystring#FUNCTION-DECODE&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; to convert between the two. For example write &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; to get a hex-encoded text representation, or &lt;code&gt;decode(md5('abc'), 'hex')&lt;/code&gt; to get a &lt;code&gt;bytea&lt;/code&gt; value.</source>
          <target state="translated">역사적 이유로 &lt;code&gt;md5&lt;/code&gt; 함수 는 &lt;code&gt;text&lt;/code&gt; 유형의 16 진수 인코딩 값을 반환하는 반면 SHA-2 함수는 &lt;code&gt;bytea&lt;/code&gt; 유형을 반환합니다 . &lt;a href=&quot;functions-binarystring#FUNCTION-ENCODE&quot;&gt; &lt;code&gt;encode&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;functions-binarystring#FUNCTION-DECODE&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 둘 사이를 변환하십시오. 예를 들어 &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; 를 작성하여 16 진수로 인코딩 된 텍스트 표현을 가져 오거나 &lt;code&gt;decode(md5('abc'), 'hex')&lt;/code&gt; 를 작성하여 &lt;code&gt;bytea&lt;/code&gt; 값 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="edf5a6774e8ddac6655d000c335cd8365c752c22" translate="yes" xml:space="preserve">
          <source>For identity columns, the &lt;code&gt;COPY FROM&lt;/code&gt; command will always write the column values provided in the input data, like the &lt;code&gt;INSERT&lt;/code&gt; option &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;.</source>
          <target state="translated">식별 컬럼의 경우 &lt;code&gt;COPY FROM&lt;/code&gt; 명령은 항상 &lt;code&gt;INSERT&lt;/code&gt; 옵션 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 와 같이 입력 데이터에 제공된 컬럼 값을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="330e059840df0474749e60d131c132790cef269d" translate="yes" xml:space="preserve">
          <source>For index methods that support ordered scans (currently, only B-tree), the optional clauses &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; can be specified to modify the sort ordering of the index. Since an ordered index can be scanned either forward or backward, it is not normally useful to create a single-column &lt;code&gt;DESC&lt;/code&gt; index &amp;mdash; that sort ordering is already available with a regular index. The value of these options is that multicolumn indexes can be created that match the sort ordering requested by a mixed-ordering query, such as &lt;code&gt;SELECT ... ORDER BY x ASC, y DESC&lt;/code&gt;. The &lt;code&gt;NULLS&lt;/code&gt; options are useful if you need to support &amp;ldquo;nulls sort low&amp;rdquo; behavior, rather than the default &amp;ldquo;nulls sort high&amp;rdquo;, in queries that depend on indexes to avoid sorting steps.</source>
          <target state="translated">정렬 된 스캔 (현재 B- 트리 만)을 지원하는 인덱스 메소드의 경우 인덱스 의 정렬 순서를 수정하기 위해 선택적 절 &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; , &lt;code&gt;NULLS FIRST&lt;/code&gt; 및 / 또는 &lt;code&gt;NULLS LAST&lt;/code&gt; 를 지정할 수 있습니다. 정렬 된 인덱스는 정방향 또는 역방향으로 스캔 할 수 있으므로 단일 컬럼 &lt;code&gt;DESC&lt;/code&gt; 인덱스 를 작성하는 것은 일반적으로 유용하지 않습니다. 정렬 순서는 이미 일반 인덱스에서 사용 가능합니다. 이 옵션의 값은 &lt;code&gt;SELECT ... ORDER BY x ASC, y DESC&lt;/code&gt; 와 같이 혼합 순서 쿼리에서 요청한 정렬 순서와 일치하는 다중 열 인덱스를 만들 수 있다는 것입니다 . &lt;code&gt;NULLS&lt;/code&gt; 정렬 단계를 피하기 위해 인덱스에 의존하는 쿼리에서 기본 &quot;nulls sort high&quot;대신 &quot;nulls sort low&quot;동작을 지원해야하는 경우 옵션이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b918ccfc93956e12afed439ea7d7ee85b4aa64b" translate="yes" xml:space="preserve">
          <source>For indexes, what is tracked is entirely-unused pages, rather than free space within pages. Therefore, the values are not meaningful, just whether a page is full or empty.</source>
          <target state="translated">색인의 경우, 추적되는 것은 페이지 내의 여유 공간이 아니라 완전히 사용되지 않은 페이지입니다. 따라서 값이 페이지가 가득 찼거나 비어 있는지 여부는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4513c5edb4e83b5f0af5e4602920aeca55f3099c" translate="yes" xml:space="preserve">
          <source>For information about writing new extensions, see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt;.</source>
          <target state="translated">새로운 확장 기능 작성에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;섹션 37.17을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6332e24d7bf340ffc8bee2de4ec1b88cdff7c6ee" translate="yes" xml:space="preserve">
          <source>For information about writing new extensions, see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt;.</source>
          <target state="translated">새 확장 작성에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;섹션 37.17을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f9e4e41c768a47414e220546e9436ef01464205" translate="yes" xml:space="preserve">
          <source>For inheritance:</source>
          <target state="translated">상속의 경우 :</target>
        </trans-unit>
        <trans-unit id="ac175c388fdbc502fc95fbb47ec000df9ac1c1ac" translate="yes" xml:space="preserve">
          <source>For instance, the example given in the previous section would also work as</source>
          <target state="translated">예를 들어, 이전 섹션에 제공된 예제는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aa594066fb4185dd4bf2bb314c6dc858ea1dc91b" translate="yes" xml:space="preserve">
          <source>For large tables, &lt;code&gt;ANALYZE&lt;/code&gt; takes a random sample of the table contents, rather than examining every row. This allows even very large tables to be analyzed in a small amount of time. Note, however, that the statistics are only approximate, and will change slightly each time &lt;code&gt;ANALYZE&lt;/code&gt; is run, even if the actual table contents did not change. This might result in small changes in the planner's estimated costs shown by &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;. In rare situations, this non-determinism will cause the planner's choices of query plans to change after &lt;code&gt;ANALYZE&lt;/code&gt; is run. To avoid this, raise the amount of statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;, as described below.</source>
          <target state="translated">큰 테이블의 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 는 모든 행을 검사하지 않고 테이블 내용의 임의 샘플을 가져옵니다. 이를 통해 아주 큰 테이블도 적은 시간에 분석 할 수 있습니다. 그러나 통계는 대략적인 것이므로 실제 테이블 내용이 변경되지 않은 경우에도 &lt;code&gt;ANALYZE&lt;/code&gt; 가 실행될 때마다 약간 변경됩니다. 이로 인해 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN으로&lt;/a&gt; 표시되는 플래너의 예상 비용이 약간 변경 될 수 있습니다 . 드문 경우이지만이 비결 정성으로 인해 &lt;code&gt;ANALYZE&lt;/code&gt; 가 실행 된 후 플래너의 쿼리 계획 선택이 변경 됩니다. 이를 피하려면 아래 설명과 같이 &lt;code&gt;ANALYZE&lt;/code&gt; 가 수집 한 통계량을 늘리 십시오.</target>
        </trans-unit>
        <trans-unit id="d9def7e76f8e004e7c6ff9a43935027a0e8494d2" translate="yes" xml:space="preserve">
          <source>For magnetic drives, a good starting point for this setting is the number of separate drives comprising a RAID 0 stripe or RAID 1 mirror being used for the database. (For RAID 5 the parity drive should not be counted.) However, if the database is often busy with multiple queries issued in concurrent sessions, lower values may be sufficient to keep the disk array busy. A value higher than needed to keep the disks busy will only result in extra CPU overhead. SSDs and other memory-based storage can often process many concurrent requests, so the best value might be in the hundreds.</source>
          <target state="translated">마그네틱 드라이브의 경우이 설정의 좋은 출발점은 데이터베이스에 사용되는 RAID 0 스트라이프 또는 RAID 1 미러를 포함하는 개별 드라이브의 수입니다. (RAID 5의 경우 패리티 드라이브는 계산되지 않아야합니다.) 그러나 데이터베이스가 종종 동시 세션에서 여러 쿼리를 발행하여 사용중인 경우, 디스크 어레이를 사용 중으로 유지하기 위해 더 낮은 값으로 충분할 수 있습니다. 디스크를 사용 중 상태로 유지하는 데 필요한 값보다 높은 값은 추가 CPU 오버 헤드 만 발생합니다. SSD 및 기타 메모리 기반 스토리지는 종종 많은 동시 요청을 처리 할 수 ​​있으므로 최상의 가치는 수백 개에 달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db0641cab9eeea26c49a646ff42537d081fed018" translate="yes" xml:space="preserve">
          <source>For more detail see &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.23&lt;/a&gt;. Row constructors can also be used in connection with subqueries, as discussed in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;functions-comparisons&quot;&gt;은 9.23 절을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;functions-subquery&quot;&gt;9.22 절&lt;/a&gt; 에서 논의 된 것처럼 행 생성자는 서브 쿼리와 관련하여 사용될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18338d5f8684a02701c33055a650f503dc79428a" translate="yes" xml:space="preserve">
          <source>For more detail see &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.24&lt;/a&gt;. Row constructors can also be used in connection with subqueries, as discussed in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;functions-comparisons&quot;&gt;섹션 9.24를&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;functions-subquery&quot;&gt;9.23 절에&lt;/a&gt; 설명 된대로 행 생성자는 하위 쿼리와 관련하여 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cb95316ba3180c7abceba8b606b2390f6f76c76" translate="yes" xml:space="preserve">
          <source>For more details about the structure of B-tree indexes, see &lt;a href=&quot;btree-implementation#BTREE-STRUCTURE&quot;&gt;Section 63.4.1&lt;/a&gt;. For more details about deduplication and posting lists, see &lt;a href=&quot;btree-implementation#BTREE-DEDUPLICATION&quot;&gt;Section 63.4.2&lt;/a&gt;.</source>
          <target state="translated">B- 트리 인덱스 구조에 대한 자세한 내용은 &lt;a href=&quot;btree-implementation#BTREE-STRUCTURE&quot;&gt;섹션 63.4.1을&lt;/a&gt; 참조하십시오 . 중복 제거 및 게시 목록에 대한 자세한 내용은 &lt;a href=&quot;btree-implementation#BTREE-DEDUPLICATION&quot;&gt;섹션 63.4.2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fb8d2224d716120397e37c095ccc4fc811af648" translate="yes" xml:space="preserve">
          <source>For more details see &lt;code&gt;man gpg&lt;/code&gt;, &lt;a href=&quot;https://www.gnupg.org/gph/en/manual.html&quot;&gt;The GNU Privacy Handbook&lt;/a&gt; and other documentation on &lt;a href=&quot;https://www.gnupg.org/&quot;&gt;https://www.gnupg.org/&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;man gpg&lt;/code&gt; , &lt;a href=&quot;https://www.gnupg.org/gph/en/manual.html&quot;&gt;GNU Privacy Handbook&lt;/a&gt; 및 &lt;a href=&quot;https://www.gnupg.org/&quot;&gt;https://www.gnupg.org/의&lt;/a&gt; 기타 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c6217eaee5aceb86ffc3acacd99e4351f7c6bdf" translate="yes" xml:space="preserve">
          <source>For more examples of using &lt;code&gt;jsonpath&lt;/code&gt; operators and methods within path expressions, see &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;.</source>
          <target state="translated">경로 표현식 내에서 &lt;code&gt;jsonpath&lt;/code&gt; 연산자 및 메소드 를 사용하는 예는 9.15.2.3 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79cf6e3cf917058a0ed742c04d1ca6289aff5a38" translate="yes" xml:space="preserve">
          <source>For more information on each row-level lock mode, refer to &lt;a href=&quot;explicit-locking#LOCKING-ROWS&quot;&gt;Section 13.3.2&lt;/a&gt;.</source>
          <target state="translated">각 행 수준 잠금 모드에 대한 자세한 내용 &lt;a href=&quot;explicit-locking#LOCKING-ROWS&quot;&gt;은 13.3.2 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2f8f8e747ece8758e1b6ba702e3c8c61e76fde3" translate="yes" xml:space="preserve">
          <source>For more information on parallel query, see &lt;a href=&quot;https://www.postgresql.org/docs/12/parallel-query.html&quot;&gt;Chapter 15&lt;/a&gt;.</source>
          <target state="translated">병렬 쿼리에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/parallel-query.html&quot;&gt;15 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c49142dd945917208a161ed15ae4eabdc1feb316" translate="yes" xml:space="preserve">
          <source>For more information on parallel query, see &lt;a href=&quot;https://www.postgresql.org/docs/13/parallel-query.html&quot;&gt;Chapter 15&lt;/a&gt;.</source>
          <target state="translated">병렬 쿼리에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/parallel-query.html&quot;&gt;15 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e9f192fbf0623739197082afd424ce16d42f59b" translate="yes" xml:space="preserve">
          <source>For more information on prepared statements, see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">준비된 명령문에 대한 자세한 정보는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d65fb0f770cbb9d7773305feb7d0f9aff8503a9d" translate="yes" xml:space="preserve">
          <source>For more information on query planning and the statistics collected by PostgreSQL for that purpose, see the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; documentation.</source>
          <target state="translated">이러한 목적으로 PostgreSQL에서 수집 한 통계 및 쿼리 계획에 대한 자세한 내용은 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b483319bfce6914eeb2d77590a6f05860cc2822" translate="yes" xml:space="preserve">
          <source>For more information on row security policies, see &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">행 보안 정책에 대한 자세한 정보는 &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cd57e75dd7c6d9a0bba32ec8cf0aedac82282ff" translate="yes" xml:space="preserve">
          <source>For more information on schema handling, see &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;. In particular, the default configuration is suitable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">스키마 처리에 대한 자세한 내용은 &lt;a href=&quot;ddl-schemas&quot;&gt;섹션 5.9를&lt;/a&gt; 참조하십시오 . 특히, 기본 구성은 데이터베이스에 단일 사용자 또는 소수의 상호 신뢰 사용자가있는 경우에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="7a7cfc539431d71689ab3e6fc5a89a4a3ad68497" translate="yes" xml:space="preserve">
          <source>For more information on tablespaces, see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">테이블 스페이스에 대한 자세한 정보는 &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;22.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="156d896fc36c27213e33f6486192aeb35b072ae4" translate="yes" xml:space="preserve">
          <source>For more information on the creation and usage of prepared statements, see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">준비된 명령문의 작성 및 사용법에 대한 자세한 정보는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5233548445314b3aa1fa8672502b639b8263c6c7" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;sql-values&quot;&gt;VALUES를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4dd314c2b9f8c0a5f4a4e41c5efbe9fea6718856" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;continuous-archiving&quot;&gt;섹션 25.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c8ecf019aee64acad91826dcc7e9b171f0be1a3" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20226217ec3afb436b4729b0abf0339c4c1dd2ec" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;ddl-constraints&quot;&gt;Section 5.4&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;ddl-constraints&quot;&gt;섹션 5.4를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1adc5bd35432adf2eb7a774b8a34ae4fb1d4e1a" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;ddl-schemas&quot;&gt;섹션 5.9를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d79b9c727fe67702d70b6fd9999ab32eca117acb" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.21을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="980ff7abe737ed29a2eef6afee49381fad9641d4" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://www.postgresql.org/docs/13/bgworker.html&quot;&gt;Chapter 47&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/bgworker.html&quot;&gt;47 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="780f7f92af5944157940b8ad375fbf026ad4460e" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;섹션 37.17을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dc856ae16ea4020ceefa8b323354b5bb864a7ae" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;logfile-maintenance&quot;&gt;섹션 24.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1290c10776f1a21730c9d3d4d887ff27a87c6292" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;manage-ag-overview&quot;&gt;Section 22.1&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;manage-ag-overview&quot;&gt;섹션 22.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5e210e5231f27abc7ef42e8fb21b52c35cb3c9d" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;섹션 22.6을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="214a61df4ffb5c9aacd0276fef415f0fd717971e" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;monitoring-stats&quot;&gt;Section 27.2&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;monitoring-stats&quot;&gt;섹션 27.2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69f071548ff8e2bf11f53bb59f5a867ac246fb29" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;routine-vacuuming&quot;&gt;Section 24.1&lt;/a&gt; .</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;routine-vacuuming&quot;&gt;섹션 24.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14fb86a709f50b66214aa6322a762395267a59e5" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="998da92e58bf1cb4909e97dd5246a04a2cb1c611" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-connection&quot;&gt;Section 19.3&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;runtime-config-connection&quot;&gt;섹션 19.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e9cee8d5c892db192aebeb281deff09ba3186a0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-logging&quot;&gt;Section 19.8&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;runtime-config-logging&quot;&gt;섹션 19.8을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57e27342dd33a63d74ae836f45de53d4f70ca811" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER&quot;&gt;Section 19.4.5&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER&quot;&gt;섹션 19.4.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2e214c810c78d30da88471e9743b6fb079f8dc4" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-MEMORY&quot;&gt;Section 19.4.1&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-MEMORY&quot;&gt;섹션 19.4.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57a39e47097148bf2b804e705bbfd7be10e3d22f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-wal&quot;&gt;Section 19.5&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;runtime-config-wal&quot;&gt;섹션 19.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe101332ab82e0d86e6d3cf0a47fcad58b5e3cfd" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;server-start&quot;&gt;섹션 18.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f6e986dbd3152279b0853a52133ca23ef852275" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6b52e4cf0af72d79422d38425c0eeb1d0943c31" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7989d717cddceab28ddd2a4acba5581bf4509f56" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="feb082d47f0b69434fc625c629e1b305bb95391f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="51d486d6d4cc03e053d0925cca9ae38c095cdd43" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="72aa113f96629050f4ef19a2cf379f2dc52cd5f0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3943a2288ce11b53333fada41110757ed47b902a" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cae845df4a402ad075e8e3db9aa71b1455d17920" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-creatematerializedview&quot;&gt;CREATE MATERIALIZED VIEW&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-creatematerializedview&quot;&gt;CREATE MATERIALIZED VIEW&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8ed6c934a5ed774b78b51edbb7e5027d4516dcb3" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ee0c9366d5740e64d2536225af931f9da1914bac" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="49d706ea8beef4d7260b021441cd0098fccedf8c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4b19a5a64f6dac1c732b3ebb9d66397bfe70bd79" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a1615c2ef2a9a56a9cc0e423d2083415987ccd74" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4b63a860f4649a0112c2786fe1bdba3d786899d1" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1020a498be2604ab4d7cd1896dffc51885aca810" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a24d18f5506b6ee9a84a8cd84f78661ee9adf77f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="db99c706cdb285235578b6aba63b47fdabf2194c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="71b270bd4563c9f2060a6d80c982b5fe2fcbf480" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e77ed2d4e2d96aeecd1142f94b637f23ca5612a5" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9e64300e8df12c926d53c45eb642cc98e387af7f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2fb228d5dbcc85882f9f4b3d191b9ca72d6f348f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="91dbc01352523da4727aedf894f80ad7b6f798c5" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2032925ebdd4aacf138805e17a31b7d2c9007880" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5d94d1228165f626fcdafbcea9f9f512b2bcebb2" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;storage-file-layout&quot;&gt;Section 68.1&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;storage-file-layout&quot;&gt;Section 68.1&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="42a31e142177fa23ae77a8cce8af185fdd1360b0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;storage-fsm&quot;&gt;Section 68.3&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;storage-fsm&quot;&gt;Section 68.3&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="24d65fe6857f379faaff0de74d64cfde9e65cff9" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b7ba20758a038db38b1afb4465c53d889c714355" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dae07da77c31ebbc8bba210c0470d446f27cdfe2" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9aca210e015407bccd6e5fff2f3af7fc7dc6dfad" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ccf0df41e7a0c42924a513c55a49a3c1fe56d531" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;wal-internals&quot;&gt;Section 29.5&lt;/a&gt;.</source>
          <target state="translated">For more information, see &lt;a href=&quot;wal-internals&quot;&gt;Section 29.5&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c85bc4c828173ae286d66f5092152fb72a510a4c" translate="yes" xml:space="preserve">
          <source>For more on replication slots, see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;.</source>
          <target state="translated">복제 슬롯에 대한 자세한 내용 &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;은 26.2.6 절&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36e5b0eb43b67d12107b8b4cd8c78c78e3b8f7db" translate="yes" xml:space="preserve">
          <source>For more on replication slots, see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;.</source>
          <target state="translated">For more on replication slots, see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f67c610531547fa3cca67f0d1f83f00712e9e930" translate="yes" xml:space="preserve">
          <source>For most English-text-searching applications the above words would be considered non-normalized, but &lt;code&gt;tsvector&lt;/code&gt; doesn't care. Raw document text should usually be passed through &lt;code&gt;to_tsvector&lt;/code&gt; to normalize the words appropriately for searching:</source>
          <target state="translated">대부분의 영어 텍스트 검색 응용 프로그램에서 위의 단어는 정규화되지 않은 것으로 간주되지만 &lt;code&gt;tsvector&lt;/code&gt; 는 신경 쓰지 않습니다. 원시 문서 텍스트는 일반적으로 &lt;code&gt;to_tsvector&lt;/code&gt; 를 통해 검색 하기에 적합하게 단어를 정규화해야합니다.</target>
        </trans-unit>
        <trans-unit id="d11cb8ba24b12fd4341f66b81cfe8da1a67ba46b" translate="yes" xml:space="preserve">
          <source>For most index methods, the speed of creating an index is dependent on the setting of &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;. Larger values will reduce the time needed for index creation, so long as you don't make it larger than the amount of memory really available, which would drive the machine into swapping.</source>
          <target state="translated">대부분의 색인 메소드의 경우 색인 작성 속도는 &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 설정에 따라 다릅니다 . 값이 클수록 실제로 사용 가능한 메모리 양보다 크게 만들지 않는 한 인덱스 생성에 필요한 시간이 줄어들어 시스템이 스와핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0c13a44404e4e32e101f6de95dbe745d7a8d8623" translate="yes" xml:space="preserve">
          <source>For most kinds of object, only the object's owner can set the comment. Roles don't have owners, so the rule for &lt;code&gt;COMMENT ON ROLE&lt;/code&gt; is that you must be superuser to comment on a superuser role, or have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege to comment on non-superuser roles. Likewise, access methods don't have owners either; you must be superuser to comment on an access method. Of course, a superuser can comment on anything.</source>
          <target state="translated">대부분의 개체 유형의 경우 개체 소유자 만 설명을 설정할 수 있습니다. 역할에는 소유자가 없으므로 &lt;code&gt;COMMENT ON ROLE&lt;/code&gt; 의 규칙은 수퍼 유저 여야 슈퍼 유저 역할 에 댓글을 달거나 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한 이 있어야 비 수퍼 유저 역할에 댓글을 달 수 있습니다. 마찬가지로 액세스 방법에도 소유자가 없습니다. 액세스 방법에 대해 언급하려면 수퍼 유저 여야합니다. 물론 수퍼 유저는 무엇이든 언급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9837f0c6ad7a5aa6e60539d85268c2d3ed2d116e" translate="yes" xml:space="preserve">
          <source>For new relations being written during a DDL operation that requires a table rewrite, this contains the OID of the original relation; otherwise 0. That state is only visible internally; this field should never contain anything other than 0 for a user-visible relation.</source>
          <target state="translated">테이블 재 작성이 필요한 DDL 조작 중에 작성되는 새 관계의 경우 원래 관계의 OID가 포함됩니다. 그렇지 않으면 0입니다. 해당 상태는 내부적으로 만 볼 수 있습니다. 이 필드는 사용자가 볼 수있는 관계에 대해 0 이외의 다른 것을 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="db2d4f573696790d499c4fdcbed43171e9eb9774" translate="yes" xml:space="preserve">
          <source>For non-anonymous binds, &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt; must be specified as separate options.</source>
          <target state="translated">익명이 아닌 바인드의 경우 &lt;code&gt;ldapbinddn&lt;/code&gt; 및 &lt;code&gt;ldapbindpasswd&lt;/code&gt; 를 별도의 옵션으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e8b858bd4de863389670e9fe6770c7877741b6a" translate="yes" xml:space="preserve">
          <source>For non-null inputs, &lt;code&gt;IS DISTINCT FROM&lt;/code&gt; is the same as the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. However, if both inputs are null it returns false, and if only one input is null it returns true. Similarly, &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; is identical to &lt;code&gt;=&lt;/code&gt; for non-null inputs, but it returns true when both inputs are null, and false when only one input is null. Thus, these predicates effectively act as though null were a normal data value, rather than &amp;ldquo;unknown&amp;rdquo;.</source>
          <target state="translated">널이 아닌 입력의 경우 &lt;code&gt;IS DISTINCT FROM&lt;/code&gt; 은 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 와 동일합니다 . 그러나 두 입력이 모두 null이면 false를 반환하고 하나의 입력 만 null이면 true를 반환합니다. 마찬가지로 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 은 널이 아닌 입력의 경우 &lt;code&gt;=&lt;/code&gt; 와 동일 하지만 두 입력이 모두 널이면 true를, 하나의 입력 만 널이면 false를 리턴합니다. 따라서 이러한 술어는 널이 &quot;알 수 없음&quot;이 아닌 정상적인 데이터 값인 것처럼 효과적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="452c316e78163cb01fa71da21305864e3d992733" translate="yes" xml:space="preserve">
          <source>For noninternal languages this references the language handler, which is a special function that is responsible for executing all functions that are written in the particular language</source>
          <target state="translated">내부 언어가 아닌 언어의 경우 특정 언어로 작성된 모든 함수를 실행하는 특수 함수 인 언어 핸들러를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="08f7ad6afcfac3234695bfac00c247d3c8fb6960" translate="yes" xml:space="preserve">
          <source>For operator classes that do not use prefixes, &lt;code&gt;prefixType&lt;/code&gt; can be set to &lt;code&gt;VOIDOID&lt;/code&gt;. Likewise, for operator classes that do not use node labels, &lt;code&gt;labelType&lt;/code&gt; can be set to &lt;code&gt;VOIDOID&lt;/code&gt;. &lt;code&gt;canReturnData&lt;/code&gt; should be set true if the operator class is capable of reconstructing the originally-supplied index value. &lt;code&gt;longValuesOK&lt;/code&gt; should be set true only when the &lt;code&gt;attType&lt;/code&gt; is of variable length and the operator class is capable of segmenting long values by repeated suffixing (see &lt;a href=&quot;spgist-implementation#SPGIST-LIMITS&quot;&gt;Section 65.4.1&lt;/a&gt;).</source>
          <target state="translated">접두사를 사용하지 않는 연산자 클래스의 경우 &lt;code&gt;prefixType&lt;/code&gt; 을 &lt;code&gt;VOIDOID&lt;/code&gt; 로 설정할 수 있습니다 . 마찬가지로 노드 레이블을 사용하지 않는 연산자 클래스의 경우 &lt;code&gt;labelType&lt;/code&gt; 을 &lt;code&gt;VOIDOID&lt;/code&gt; 로 설정할 수 있습니다 . 연산자 클래스가 원래 제공된 색인 값을 재구성 할 수있는 경우 &lt;code&gt;canReturnData&lt;/code&gt; 를 true로 설정해야합니다. &lt;code&gt;longValuesOK&lt;/code&gt; 는 &lt;code&gt;attType&lt;/code&gt; 이 가변 길이이고 연산자 클래스가 접미사를 반복하여 긴 값을 세그먼트 화할 수있는 경우에만 true로 설정해야합니다 ( &lt;a href=&quot;spgist-implementation#SPGIST-LIMITS&quot;&gt;65.4.1 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8734e694c951a6833bd37344ff08949a24e29e7a" translate="yes" xml:space="preserve">
          <source>For optimal performance when relying on Serializable transactions for concurrency control, these issues should be considered:</source>
          <target state="translated">동시성 제어를 위해 직렬화 가능 트랜잭션에 의존 할 때 최적의 성능을 얻으려면 다음 문제를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="6009f4ee46750a96d20ce23527cf9e0e8cb726de" translate="yes" xml:space="preserve">
          <source>For ordered-set (including hypothetical-set) aggregates, the final function receives not only the final state value, but also the values of all the direct arguments.</source>
          <target state="translated">순서 집합 (가설 집합 포함) 집계의 경우 최종 함수는 최종 상태 값뿐만 아니라 모든 직접 인수의 값도받습니다.</target>
        </trans-unit>
        <trans-unit id="be6a9c4c63ed11fa1c2795f316b3b8e9e65b1b58" translate="yes" xml:space="preserve">
          <source>For ordered-set (including hypothetical-set) aggregates, the state transition function receives only the current state value and the aggregated arguments, not the direct arguments. Otherwise it is the same.</source>
          <target state="translated">순서 집합 (가설 집합 포함) 집계의 경우 상태 전이 함수는 직접 인수가 아닌 현재 상태 값과 집계 된 인수 만받습니다. 그렇지 않으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6c0d59e1cc0d04f93b79c02798466c5f3e582923" translate="yes" xml:space="preserve">
          <source>For ordered-set aggregates only, this flag specifies that the aggregate arguments are to be processed according to the requirements for hypothetical-set aggregates: that is, the last few direct arguments must match the data types of the aggregated (&lt;code&gt;WITHIN GROUP&lt;/code&gt;) arguments. The &lt;code&gt;HYPOTHETICAL&lt;/code&gt; flag has no effect on run-time behavior, only on parse-time resolution of the data types and collations of the aggregate's arguments.</source>
          <target state="translated">순서 집합 집합의 경우에만이 플래그는 집합 인수가 가정 집합 집합의 요구 사항에 따라 처리되도록 지정합니다. 즉, 마지막 몇 개의 직접 인수는 집합의 데이터 형식과 일치해야합니다 ( &lt;code&gt;WITHIN GROUP&lt;/code&gt; ) 인수 . &lt;code&gt;HYPOTHETICAL&lt;/code&gt; 플래그는 데이터 유형 및 집계의 인수의 정렬의 구문 분석 시간 해상도에 런타임 동작에 아무런 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13b1b26b35f07e3a875d44019b004753915b48df" translate="yes" xml:space="preserve">
          <source>For pages that cannot be skipped, it scans each tuple, recording its presence and size in the appropriate counters, and adding up the free space on the page. At the end, it estimates the total number of live tuples based on the number of pages and tuples scanned (in the same way that VACUUM estimates pg_class.reltuples).</source>
          <target state="translated">건너 뛸 수없는 페이지의 경우 각 튜플을 스캔하여 해당 카운터의 존재 여부와 크기를 적절한 카운터에 기록하고 페이지에 여유 공간을 추가합니다. 결국, VACUUM이 pg_class.reltuples를 추정하는 것과 같은 방식으로 스캔 된 페이지 및 튜플의 수를 기반으로 총 라이브 튜플 수를 추정합니다.</target>
        </trans-unit>
        <trans-unit id="868352f139d86028da2fe3079d740960bf5a0c0a" translate="yes" xml:space="preserve">
          <source>For parameter defaults, the SQL standard specifies only the syntax with the &lt;code&gt;DEFAULT&lt;/code&gt; key word. The syntax with &lt;code&gt;=&lt;/code&gt; is used in T-SQL and Firebird.</source>
          <target state="translated">매개 변수 기본값의 경우 SQL 표준은 &lt;code&gt;DEFAULT&lt;/code&gt; 키워드를 사용 하는 구문 만 지정합니다 . 문법 &lt;code&gt;=&lt;/code&gt; 가 포함 은 T-SQL 및 Firebird에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d24bbed3cf952c936ab011c509488bf0467fa622" translate="yes" xml:space="preserve">
          <source>For policies that can have both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; expressions (&lt;code&gt;ALL&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt;), if no &lt;code&gt;WITH CHECK&lt;/code&gt; expression is defined, then the &lt;code&gt;USING&lt;/code&gt; expression will be used both to determine which rows are visible (normal &lt;code&gt;USING&lt;/code&gt; case) and which new rows will be allowed to be added (&lt;code&gt;WITH CHECK&lt;/code&gt; case).</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 및 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식 ( &lt;code&gt;ALL&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; ) 을 모두 가질 수있는 정책의 경우 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식이 정의 되지 않은 경우 &lt;code&gt;USING&lt;/code&gt; 표현식을 사용하여 볼 수있는 행 (일반적인 &lt;code&gt;USING&lt;/code&gt; 경우)과 새 행을 결정합니다. 추가 가능 ( &lt;code&gt;WITH CHECK&lt;/code&gt; case).</target>
        </trans-unit>
        <trans-unit id="82d5e1c9db6a18c117c8031e2597235ae83ea517" translate="yes" xml:space="preserve">
          <source>For procedural languages, allows use of the language for the creation of functions in that language. This is the only type of privilege that is applicable to procedural languages.</source>
          <target state="translated">절차 적 언어의 경우 해당 언어로 함수를 작성하기 위해 언어를 사용할 수 있습니다. 이것은 절차 언어에 적용 할 수있는 유일한 권한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="72ae8edf284efd5793c4ac2e8558efa80968a775" translate="yes" xml:space="preserve">
          <source>For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output column name.</source>
          <target state="translated">향후 키워드 추가 가능성을 방지하려면 항상 다음 중 하나를 작성하는 것이 좋습니다. &lt;code&gt;AS&lt;/code&gt; 출력 열 이름을 AS로 쓰거나 큰 따옴표로 묶는 .</target>
        </trans-unit>
        <trans-unit id="90dfd308078c52df87fcfcab656bb11ad21b3919" translate="yes" xml:space="preserve">
          <source>For reasons of backwards compatibility, the commas between successive &lt;code&gt;transaction_modes&lt;/code&gt; can be omitted.</source>
          <target state="translated">이전 버전과의 호환성을 위해 연속적인 &lt;code&gt;transaction_modes&lt;/code&gt; 사이의 쉼표 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee31746206f7099bf155b9a7de2ea519f45916ff" translate="yes" xml:space="preserve">
          <source>For reference purposes, a standard installation also contains files &lt;code&gt;Africa.txt&lt;/code&gt;, &lt;code&gt;America.txt&lt;/code&gt;, etc, containing information about every time zone abbreviation known to be in use according to the IANA timezone database. The zone name definitions found in these files can be copied and pasted into a custom configuration file as needed. Note that these files cannot be directly referenced as &lt;code&gt;timezone_abbreviations&lt;/code&gt; settings, because of the dot embedded in their names.</source>
          <target state="translated">참조 목적으로 표준 설치에는 IANA 시간대 데이터베이스에 따라 사용중인 것으로 알려진 모든 시간대 약어에 대한 정보가 들어있는 &lt;code&gt;Africa.txt&lt;/code&gt; , &lt;code&gt;America.txt&lt;/code&gt; 등의 파일도 포함되어 있습니다 . 이러한 파일에서 찾은 영역 이름 정의는 필요에 따라 사용자 정의 구성 파일에 복사하여 붙여 넣을 수 있습니다. 이러한 파일은 이름에 포함 된 점 때문에 &lt;code&gt;timezone_abbreviations&lt;/code&gt; 설정 으로 직접 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="124811ada3de0016b7583028ff8e0587746fbc22" translate="yes" xml:space="preserve">
          <source>For reliable recovery when changing &lt;code&gt;fsync&lt;/code&gt; off to on, it is necessary to force all modified buffers in the kernel to durable storage. This can be done while the cluster is shutdown or while &lt;code&gt;fsync&lt;/code&gt; is on by running &lt;code&gt;initdb --sync-only&lt;/code&gt;, running &lt;code&gt;sync&lt;/code&gt;, unmounting the file system, or rebooting the server.</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; 를 on으로 변경할 때 안정적인 복구를 위해서는 커널에서 수정 된 모든 버퍼를 영구 저장소로 강제 실행해야합니다. &lt;code&gt;initdb --sync-only&lt;/code&gt; 를 실행 하여 클러스터가 종료되거나 &lt;code&gt;fsync&lt;/code&gt; 가 켜져있는 동안 수행 할 수 있습니다. &lt;code&gt;sync&lt;/code&gt; , 파일 시스템을 마운트 해제하거나 서버를 다시 부팅.</target>
        </trans-unit>
        <trans-unit id="319e6f276af3394d5ebbac353d76e4013f542a01" translate="yes" xml:space="preserve">
          <source>For roles that can log in, this sets maximum number of concurrent connections this role can make. -1 means no limit.</source>
          <target state="translated">로그인 할 수있는 역할의 경우이 역할로 만들 수있는 최대 동시 연결 수를 설정합니다. -1은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0a4172c7b4024e73e796b850c139c38ecd17203c" translate="yes" xml:space="preserve">
          <source>For schemas, allows access to objects contained in the schema (assuming that the objects' own privilege requirements are also met). Essentially this allows the grantee to &amp;ldquo;look up&amp;rdquo; objects within the schema. Without this permission, it is still possible to see the object names, e.g. by querying system catalogs. Also, after revoking this permission, existing sessions might have statements that have previously performed this lookup, so this is not a completely secure way to prevent object access.</source>
          <target state="translated">스키마의 경우 스키마에 포함 된 개체에 대한 액세스를 허용합니다 (개체 자신의 권한 요구 사항도 충족한다고 가정). 기본적으로이를 통해 피부 여자는 스키마 내에서 개체를 &quot;찾을&quot;수 있습니다. 이 권한이 없으면 시스템 카탈로그 조회와 같은 오브젝트 이름을 여전히 볼 수 있습니다. 또한이 권한을 취소 한 후 기존 세션에 이전에이 조회를 수행 한 명령문이있을 수 있으므로 이는 오브젝트 액세스를 막는 완전히 안전한 방법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="104e353c308a9f15b922dc481c8e27852ead1095" translate="yes" xml:space="preserve">
          <source>For schemas, allows access to objects contained in the schema (assuming that the objects' own privilege requirements are also met). Essentially this allows the grantee to &amp;ldquo;look up&amp;rdquo; objects within the schema. Without this permission, it is still possible to see the object names, e.g., by querying system catalogs. Also, after revoking this permission, existing sessions might have statements that have previously performed this lookup, so this is not a completely secure way to prevent object access.</source>
          <target state="translated">For schemas, allows access to objects contained in the schema (assuming that the objects' own privilege requirements are also met). Essentially this allows the grantee to &amp;ldquo;look up&amp;rdquo; objects within the schema. Without this permission, it is still possible to see the object names, e.g., by querying system catalogs. Also, after revoking this permission, existing sessions might have statements that have previously performed this lookup, so this is not a completely secure way to prevent object access.</target>
        </trans-unit>
        <trans-unit id="ca22692db97a2637a8e751de3cc8e36b4187aab7" translate="yes" xml:space="preserve">
          <source>For schemas, allows new objects to be created within the schema. To rename an existing object, you must own the object &lt;em&gt;and&lt;/em&gt; have this privilege for the containing schema.</source>
          <target state="translated">스키마의 경우 스키마 내에서 새 객체를 만들 수 있습니다. 기존 객체의 이름을 바꾸려면 객체를 소유 &lt;em&gt;하고&lt;/em&gt; 포함하는 스키마이 권한을 가지고있다.</target>
        </trans-unit>
        <trans-unit id="77c0cf444f37221ad1fe5a6fc24e9c33e4046529" translate="yes" xml:space="preserve">
          <source>For searches within PostgreSQL, a document is normally a textual field within a row of a database table, or possibly a combination (concatenation) of such fields, perhaps stored in several tables or obtained dynamically. In other words, a document can be constructed from different parts for indexing and it might not be stored anywhere as a whole. For example:</source>
          <target state="translated">PostgreSQL 내에서 검색하는 경우, 문서는 일반적으로 데이터베이스 테이블의 행 내의 텍스트 필드이거나 여러 필드에 저장되거나 동적으로 얻을 수있는 이러한 필드의 조합 (연결)입니다. 즉, 문서는 색인을 생성하기 위해 여러 부분으로 구성 될 수 있으며 전체적으로 저장되지 않을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a142a9753e3ece701e9f2b90c2d239cb6b9b44cd" translate="yes" xml:space="preserve">
          <source>For security reasons the new cluster created by &lt;code&gt;initdb&lt;/code&gt; will only be accessible by the cluster owner by default. The &lt;code&gt;--allow-group-access&lt;/code&gt; option allows any user in the same group as the cluster owner to read files in the cluster. This is useful for performing backups as a non-privileged user.</source>
          <target state="translated">보안상의 이유로 &lt;code&gt;initdb&lt;/code&gt; 에 의해 생성 된 새 클러스터 는 기본적으로 클러스터 소유자 만 액세스 할 수 있습니다. &lt;code&gt;--allow-group-access&lt;/code&gt; 옵션은 클러스터 소유자와 동일한 그룹의 모든 사용자가 클러스터에 파일을 읽을 수 있습니다. 권한이없는 사용자로 백업을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1f1663e5a58c2af0c67ac06b0e2e7c597b770b66" translate="yes" xml:space="preserve">
          <source>For security reasons, only superusers and members of the &lt;code&gt;pg_read_all_stats&lt;/code&gt; role are allowed to see the SQL text and &lt;code&gt;queryid&lt;/code&gt; of queries executed by other users. Other users can see the statistics, however, if the view has been installed in their database.</source>
          <target state="translated">보안상의 이유로 수퍼 유저와 &lt;code&gt;pg_read_all_stats&lt;/code&gt; 역할의 구성원 만 다른 사용자가 실행 한 쿼리 의 SQL 텍스트 및 &lt;code&gt;queryid&lt;/code&gt; 를 볼 수 있습니다. 그러나 뷰가 데이터베이스에 설치된 경우 다른 사용자는 통계를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2387fb268a4aad1cb27f4814253a95ea4053932" translate="yes" xml:space="preserve">
          <source>For sequences, &lt;code&gt;db_sequence:get_value&lt;/code&gt; is checked when we reference a sequence object using &lt;code&gt;SELECT&lt;/code&gt;; however, note that we do not currently check permissions on execution of corresponding functions such as &lt;code&gt;lastval()&lt;/code&gt;.</source>
          <target state="translated">시퀀스의 경우, &lt;code&gt;SELECT&lt;/code&gt; 를 사용하여 시퀀스 객체를 참조 할 때 &lt;code&gt;db_sequence:get_value&lt;/code&gt; 가 검사됩니다 . 그러나 현재 &lt;code&gt;lastval()&lt;/code&gt; 과 같은 해당 함수의 실행에 대한 권한은 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a6107c5c35722f41cd50e68f08c51a50459956c5" translate="yes" xml:space="preserve">
          <source>For sequences, allows use of the &lt;code&gt;currval&lt;/code&gt; and &lt;code&gt;nextval&lt;/code&gt; functions.</source>
          <target state="translated">시퀀스의 경우 &lt;code&gt;currval&lt;/code&gt; 및 &lt;code&gt;nextval&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41c9e0790209171bd641f0e2a59f5f0172d7ebb1" translate="yes" xml:space="preserve">
          <source>For servers that are not regularly connected or have slow communication links, like laptops or remote servers, keeping data consistent among servers is a challenge. Using asynchronous multimaster replication, each server works independently, and periodically communicates with the other servers to identify conflicting transactions. The conflicts can be resolved by users or conflict resolution rules. Bucardo is an example of this type of replication.</source>
          <target state="translated">정기적으로 연결되지 않거나 랩톱 또는 원격 서버와 같이 통신 연결 속도가 느린 서버의 경우 서버간에 데이터를 일관성있게 유지하는 것은 어려운 일입니다. 비동기 멀티 마스터 복제를 사용하면 각 서버가 독립적으로 작동하고 주기적으로 다른 서버와 통신하여 충돌하는 트랜잭션을 식별합니다. 사용자 또는 충돌 해결 규칙으로 충돌을 해결할 수 있습니다. Bucardo는 이러한 유형의 복제의 예입니다.</target>
        </trans-unit>
        <trans-unit id="62b0a1b5925a4635226ab51bcd1ee55bb85746c9" translate="yes" xml:space="preserve">
          <source>For simple &lt;code&gt;IN&lt;/code&gt; tests, it's better to rely on the &lt;a href=&quot;functions-comparisons#FUNCTIONS-COMPARISONS-IN-SCALAR&quot;&gt;list-of-scalars&lt;/a&gt; form of &lt;code&gt;IN&lt;/code&gt; than to write a &lt;code&gt;VALUES&lt;/code&gt; query as shown above. The list of scalars method requires less writing and is often more efficient.</source>
          <target state="translated">간단한 &lt;code&gt;IN&lt;/code&gt; 테스트의 경우 위와 같이 &lt;code&gt;VALUES&lt;/code&gt; 쿼리 를 작성하는 것보다 &lt;a href=&quot;functions-comparisons#FUNCTIONS-COMPARISONS-IN-SCALAR&quot;&gt;스칼라 목록&lt;/a&gt; 형식의 &lt;code&gt;IN&lt;/code&gt; 을 사용하는 것이 좋습니다 . 스칼라리스트 방법은 적은 쓰기를 요구하며 종종 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1c8ca5d9d323066d6d659aa5ff3196102b40293c" translate="yes" xml:space="preserve">
          <source>For some types of errors, the server reports the name of a database object (a table, table column, data type, or constraint) associated with the error; for example, the name of the unique constraint that caused a &lt;code&gt;unique_violation&lt;/code&gt; error. Such names are supplied in separate fields of the error report message so that applications need not try to extract them from the possibly-localized human-readable text of the message. As of PostgreSQL 9.3, complete coverage for this feature exists only for errors in SQLSTATE class 23 (integrity constraint violation), but this is likely to be expanded in future.</source>
          <target state="translated">일부 유형의 오류의 경우, 서버는 오류와 연관된 데이터베이스 오브젝트 (테이블, 테이블 열, 데이터 유형 또는 제한 조건)의 이름을보고합니다. 예를 들어, &lt;code&gt;unique_violation&lt;/code&gt; 오류 를 일으킨 고유 제한 조건의 이름입니다 . 이러한 이름은 오류 보고서 메시지의 개별 필드에 제공되므로 응용 프로그램은 지역화 된 사람이 읽을 수있는 메시지의 텍스트에서 이름을 추출 할 필요가 없습니다. PostgreSQL 9.3부터이 기능에 대한 완전한 적용 범위는 SQLSTATE 클래스 23의 오류 (무결성 제한 위반)에 대해서만 존재하지만 향후 확장 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="b6625213e6e6fa2bc1eaac3fdaba176e51b962e6" translate="yes" xml:space="preserve">
          <source>For some types of relation, &lt;code&gt;\d&lt;/code&gt; shows additional information for each column: column values for sequences, indexed expressions for indexes, and foreign data wrapper options for foreign tables.</source>
          <target state="translated">일부 관계 유형의 경우 &lt;code&gt;\d&lt;/code&gt; 는 각 열에 대한 추가 정보 (시퀀스의 열 값, 인덱스의 인덱스 표현식 및 외부 테이블의 외래 데이터 래퍼 옵션)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="96c3119cad566b7b88d64ca07bab7df7991bc93e" translate="yes" xml:space="preserve">
          <source>For source installs, if you wish to install the new server in a custom location, use the &lt;code&gt;prefix&lt;/code&gt; variable:</source>
          <target state="translated">소스 설치의 경우 사용자 정의 위치에 새 서버를 설치하려면 &lt;code&gt;prefix&lt;/code&gt; 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="02535fa4807bcb15e6b90f67411bc5308adeb97f" translate="yes" xml:space="preserve">
          <source>For tables with GIN indexes, &lt;code&gt;VACUUM&lt;/code&gt; (in any form) also completes any pending index insertions, by moving pending index entries to the appropriate places in the main GIN index structure. See &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details.</source>
          <target state="translated">GIN 인덱스가있는 테이블의 경우 &lt;code&gt;VACUUM&lt;/code&gt; (모든 형식)은 보류중인 인덱스 항목을 기본 GIN 인덱스 구조의 적절한 위치로 이동하여 보류중인 인덱스 삽입을 완료합니다. 자세한 내용 &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;은 66.4.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c91c055bfb7a26b615975cdc96ae00a408c07dd3" translate="yes" xml:space="preserve">
          <source>For tables, &lt;code&gt;db_table:select&lt;/code&gt;, &lt;code&gt;db_table:insert&lt;/code&gt;, &lt;code&gt;db_table:update&lt;/code&gt; or &lt;code&gt;db_table:delete&lt;/code&gt; are checked for all the referenced target tables depending on the kind of statement; in addition, &lt;code&gt;db_table:select&lt;/code&gt; is also checked for all the tables that contain columns referenced in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;RETURNING&lt;/code&gt; clause, as a data source for &lt;code&gt;UPDATE&lt;/code&gt;, and so on.</source>
          <target state="translated">테이블의 경우 &lt;code&gt;db_table:select&lt;/code&gt; , &lt;code&gt;db_table:insert&lt;/code&gt; , &lt;code&gt;db_table:update&lt;/code&gt; 또는 &lt;code&gt;db_table:delete&lt;/code&gt; 는 명령문의 종류에 따라 참조 된 모든 대상 테이블에 대해 점검됩니다. 또한 &lt;code&gt;db_table:select&lt;/code&gt; 는 &lt;code&gt;WHERE&lt;/code&gt; 또는 &lt;code&gt;RETURNING&lt;/code&gt; 절 에서 참조 된 컬럼을 포함하는 모든 테이블에 대해 &lt;code&gt;UPDATE&lt;/code&gt; 등 의 데이터 소스로 검사 됩니다.</target>
        </trans-unit>
        <trans-unit id="c5801368320c105ca425cc142e3ec8942b58fbca" translate="yes" xml:space="preserve">
          <source>For tablespaces, allows tables, indexes, and temporary files to be created within the tablespace, and allows databases to be created that have the tablespace as their default tablespace.</source>
          <target state="translated">For tablespaces, allows tables, indexes, and temporary files to be created within the tablespace, and allows databases to be created that have the tablespace as their default tablespace.</target>
        </trans-unit>
        <trans-unit id="9c7df8e7cc19f2604588ffd58fd2bd20e5c27f91" translate="yes" xml:space="preserve">
          <source>For tablespaces, allows tables, indexes, and temporary files to be created within the tablespace, and allows databases to be created that have the tablespace as their default tablespace. (Note that revoking this privilege will not alter the placement of existing objects.)</source>
          <target state="translated">테이블 스페이스의 경우 테이블 스페이스 내에서 테이블, 인덱스 및 임시 파일을 작성할 수 있으며 테이블 스페이스가 기본 테이블 스페이스 인 데이터베이스를 작성할 수 있습니다. (이 권한을 취소해도 기존 개체의 위치는 변경되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="60dffce454150377149f2bc1c7ec0c5dc5d0791c" translate="yes" xml:space="preserve">
          <source>For temporary tables, &lt;code&gt;CREATE INDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent index creation is cheaper.</source>
          <target state="translated">For temporary tables, &lt;code&gt;CREATE INDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent index creation is cheaper.</target>
        </trans-unit>
        <trans-unit id="93534c68b9e76f0b0f7395d9f112e5d49d630585" translate="yes" xml:space="preserve">
          <source>For temporary tables, &lt;code&gt;DROP INDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent index drop is cheaper.</source>
          <target state="translated">For temporary tables, &lt;code&gt;DROP INDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent index drop is cheaper.</target>
        </trans-unit>
        <trans-unit id="82929702d8109347128382c7167aff5836ee34d7" translate="yes" xml:space="preserve">
          <source>For temporary tables, &lt;code&gt;REINDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent reindex is cheaper.</source>
          <target state="translated">For temporary tables, &lt;code&gt;REINDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent reindex is cheaper.</target>
        </trans-unit>
        <trans-unit id="8ed1cb94cb2f097d1a4265a2618f61e0b1b1ddd6" translate="yes" xml:space="preserve">
          <source>For testing purposes, it is possible to run both primary and standby servers on the same system. This does not provide any worthwhile improvement in server robustness, nor would it be described as HA.</source>
          <target state="translated">테스트 목적으로 동일한 시스템에서 기본 및 대기 서버를 모두 실행할 수 있습니다. 이것은 서버 견고성에있어 가치있는 개선을 제공하지 않으며 HA로 설명되지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="14326aec7784d590e8d770eaca8e03f0b4af843b" translate="yes" xml:space="preserve">
          <source>For text search purposes, each document must be reduced to the preprocessed &lt;code&gt;tsvector&lt;/code&gt; format. Searching and ranking are performed entirely on the &lt;code&gt;tsvector&lt;/code&gt; representation of a document &amp;mdash; the original text need only be retrieved when the document has been selected for display to a user. We therefore often speak of the &lt;code&gt;tsvector&lt;/code&gt; as being the document, but of course it is only a compact representation of the full document.</source>
          <target state="translated">텍스트 검색을 위해 각 문서는 사전 처리 된 &lt;code&gt;tsvector&lt;/code&gt; 형식 으로 축소되어야 합니다. 검색 및 순위는 전적으로 문서 의 &lt;code&gt;tsvector&lt;/code&gt; 표현 에서 수행됩니다. 원본 텍스트는 사용자에게 표시 할 문서를 선택한 경우에만 검색해야합니다. 따라서 우리는 종종 &lt;code&gt;tsvector&lt;/code&gt; 를 문서라고 말하지만 물론 전체 문서를 간단히 표현한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a7a000de4f9a94a7302faa3da1d5fa7c3f403c9e" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; cases, the row elements are compared left-to-right, stopping as soon as an unequal or null pair of elements is found. If either of this pair of elements is null, the result of the row comparison is unknown (null); otherwise comparison of this pair of elements determines the result. For example, &lt;code&gt;ROW(1,2,NULL) &amp;lt; ROW(1,3,0)&lt;/code&gt; yields true, not null, because the third pair of elements are not considered.</source>
          <target state="translated">들어 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 경우, 로우 요소는 왼쪽에서 오른쪽으로, 즉시 정지 요소의 불균등 또는 null 쌍이 발견으로 비교된다. 이 요소 쌍 중 하나가 널이면 행 비교 결과를 알 수 없습니다 (널). 그렇지 않으면이 요소 쌍의 비교가 결과를 결정합니다. 예를 들어, &lt;code&gt;ROW(1,2,NULL) &amp;lt; ROW(1,3,0)&lt;/code&gt; 은 세 번째 요소 쌍이 고려되지 않으므로 null이 아닌 true를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dfc3c21d9ddee1f916ca1387da5b3a8a58887534" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;INNER&lt;/code&gt; and &lt;code&gt;OUTER&lt;/code&gt; join types, a join condition must be specified, namely exactly one of &lt;code&gt;NATURAL&lt;/code&gt;, &lt;code&gt;ON join_condition&lt;/code&gt;, or &lt;code&gt;USING (join_column [, ...])&lt;/code&gt;. See below for the meaning. For &lt;code&gt;CROSS JOIN&lt;/code&gt;, none of these clauses can appear.</source>
          <target state="translated">들어 &lt;code&gt;INNER&lt;/code&gt; 및 &lt;code&gt;OUTER&lt;/code&gt; 형태를 가입하는 조건 중 하나, 즉 정확하게 지정해야 가입 &lt;code&gt;NATURAL&lt;/code&gt; , &lt;code&gt;ON join_condition&lt;/code&gt; 또는 &lt;code&gt;USING (join_column [, ...])&lt;/code&gt; . 의미는 아래를 참조하십시오. 들어 &lt;code&gt;CROSS JOIN&lt;/code&gt; ,이 조항의 어느 것도 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dad37c11367f0fd32c32e9bf08cc2fd30c405130" translate="yes" xml:space="preserve">
          <source>For the default TPC-B-like test scenario, the initialization scale factor (&lt;code&gt;-s&lt;/code&gt;) should be at least as large as the largest number of clients you intend to test (&lt;code&gt;-c&lt;/code&gt;); else you'll mostly be measuring update contention. There are only &lt;code&gt;-s&lt;/code&gt; rows in the &lt;code&gt;pgbench_branches&lt;/code&gt; table, and every transaction wants to update one of them, so &lt;code&gt;-c&lt;/code&gt; values in excess of &lt;code&gt;-s&lt;/code&gt; will undoubtedly result in lots of transactions blocked waiting for other transactions.</source>
          <target state="translated">기본 TPC-B와 유사한 테스트 시나리오의 경우 초기화 스케일 팩터 ( &lt;code&gt;-s&lt;/code&gt; )는 테스트하려는 최대 클라이언트 수 ( &lt;code&gt;-c&lt;/code&gt; ) 만큼 커야합니다 . 그렇지 않으면 대부분 업데이트 경합을 측정하게됩니다. 이 전용 &lt;code&gt;-s&lt;/code&gt; 행 &lt;code&gt;pgbench_branches&lt;/code&gt; 의 테이블은 모든 트랜잭션은 그래서 그들 중 하나를 업데이트하려고합니다 &lt;code&gt;-c&lt;/code&gt; 를 초과하는 값 &lt;code&gt;-s&lt;/code&gt; 는 의심 할 여지없이 다른 트랜잭션을 기다리고 차단 된 트랜잭션이 많이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a5751609fa3abe5700d0557e4f26ffe5f05018e3" translate="yes" xml:space="preserve">
          <source>For the default script, the output will look similar to this:</source>
          <target state="translated">기본 스크립트의 경우 출력은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9007ccafafbe06f38e92e2d086ee0438ce1eec15" translate="yes" xml:space="preserve">
          <source>For the list of built-in functions and operators available for constructing and processing JSON values, see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">JSON 값을 구성하고 처리하는 데 사용할 수있는 내장 함수 및 연산자 목록은 &lt;a href=&quot;functions-json&quot;&gt;섹션 9.15를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3e8f597d5cc47851d8a9d164150d2f7a92e4220" translate="yes" xml:space="preserve">
          <source>For the list of built-in functions and operators available for constructing and processing JSON values, see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">For the list of built-in functions and operators available for constructing and processing JSON values, see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b6a1288823da614ad6ddd8076b29a2c859b00b3d" translate="yes" xml:space="preserve">
          <source>For the purpose of a unique constraint, null values are not considered equal.</source>
          <target state="translated">고유 제한 조건의 목적으로 널값은 동일한 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5aa91a6ae5978dfba449fc8f21af598ecb84b63" translate="yes" xml:space="preserve">
          <source>For the purposes of this option, the multixact ID age of a relation is the greatest of the ages of the main relation and its associated TOAST table, if one exists. Since the commands issued by vacuumdb will also process the TOAST table for the relation if necessary, it does not need to be considered separately.</source>
          <target state="translated">이 옵션의 목적 상, 관계의 멀티 플렉스 ID 연령은 기본 관계 및 연관된 TOAST 테이블이있는 경우 가장 깁니다. vacuumdb가 실행 한 명령은 필요한 경우 관계에 대한 TOAST 테이블도 처리하므로 별도로 고려할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a930282601dc6d73b8f0cbaf1770a134e812692" translate="yes" xml:space="preserve">
          <source>For the purposes of this option, the transaction ID age of a relation is the greatest of the ages of the main relation and its associated TOAST table, if one exists. Since the commands issued by vacuumdb will also process the TOAST table for the relation if necessary, it does not need to be considered separately.</source>
          <target state="translated">이 옵션의 목적 상, 관계의 트랜잭션 ID 연령은 기본 관계 및 연관된 TOAST 테이블이있는 경우 가장 깁니다. vacuumdb가 실행 한 명령은 필요한 경우 관계에 대한 TOAST 테이블도 처리하므로 별도로 고려할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7dd494ba670198b28ebfc500d18e95c5d26c155" translate="yes" xml:space="preserve">
          <source>For the regexp functions, if you want to match case-sensitively, you can specify the &amp;ldquo;c&amp;rdquo; flag to force a case-sensitive match. Otherwise, you must cast to &lt;code&gt;text&lt;/code&gt; before using one of these functions if you want case-sensitive behavior.</source>
          <target state="translated">정규식 함수의 경우 대소 문자를 구분하려면 &quot;c&quot;플래그를 지정하여 대소 문자를 구분할 수 있습니다. 그렇지 않으면 대소 문자 구분 동작을 원하는 경우 이러한 기능 중 하나를 사용하기 전에 &lt;code&gt;text&lt;/code&gt; 캐스트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d78645291bcc7701c1b16378879f0e6ec0613a1b" translate="yes" xml:space="preserve">
          <source>For this purpose, white-space characters are blank, tab, newline, and any character that belongs to the &lt;code&gt;space&lt;/code&gt; character class.</source>
          <target state="translated">이를 위해 공백 문자는 공백, 탭, 줄 바꿈 및 &lt;code&gt;space&lt;/code&gt; 문자 클래스에 속하는 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="74af73ce47f8b4a950cf1dc74d44af070dbfb80a" translate="yes" xml:space="preserve">
          <source>For those interested in further details, estimation of the size of a table (before any &lt;code&gt;WHERE&lt;/code&gt; clauses) is done in &lt;code&gt;src/backend/optimizer/util/plancat.c&lt;/code&gt;. The generic logic for clause selectivities is in &lt;code&gt;src/backend/optimizer/path/clausesel.c&lt;/code&gt;. The operator-specific selectivity functions are mostly found in &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt;.</source>
          <target state="translated">추가 세부 사항에 관심이있는 사용자의 경우 테이블 크기 ( &lt;code&gt;WHERE&lt;/code&gt; 절 이전)의 추정은 &lt;code&gt;src/backend/optimizer/util/plancat.c&lt;/code&gt; 에서 수행 됩니다. 절 선택성의 일반적인 논리는 &lt;code&gt;src/backend/optimizer/path/clausesel.c&lt;/code&gt; 에 있습니다. 운영자 별 선택 기능은 주로 &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f63222727e6629be4e7161b8b3cc8abbda85cb89" translate="yes" xml:space="preserve">
          <source>For those not using autovacuum, a typical approach is to schedule a database-wide &lt;code&gt;VACUUM&lt;/code&gt; once a day during a low-usage period, supplemented by more frequent vacuuming of heavily-updated tables as necessary. (Some installations with extremely high update rates vacuum their busiest tables as often as once every few minutes.) If you have multiple databases in a cluster, don't forget to &lt;code&gt;VACUUM&lt;/code&gt; each one; the program &lt;a href=&quot;app-vacuumdb&quot;&gt;vacuumdb&lt;/a&gt; might be helpful.</source>
          <target state="translated">autovacuum을 사용하지 않는 사람들의 경우, 일반적인 방법은 사용량이 적을 때 하루에 한 번 데이터베이스 전체 &lt;code&gt;VACUUM&lt;/code&gt; 을 예약하고 필요에 따라 많이 업데이트 된 테이블을 더 자주 진공 청소기로 청소하는 것입니다. (매우 높은 업데이트 속도를 가진 일부 설치는 몇 분마다 한 번씩 자주 가장 바쁜 테이블을 진공 청소기로 청소합니다.) 클러스터에 여러 데이터베이스가있는 경우 각 데이터베이스를 &lt;code&gt;VACUUM&lt;/code&gt; 하는 것을 잊지 마십시오 . &lt;a href=&quot;app-vacuumdb&quot;&gt;vacuumdb&lt;/a&gt; 프로그램 이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7b55b171eb70ee6df74b6fa93a4927e18a0f903" translate="yes" xml:space="preserve">
          <source>For tranches registered by extensions, the name is specified by extension and this will be displayed as &lt;code&gt;wait_event&lt;/code&gt;. It is quite possible that user has registered the tranche in one of the backends (by having allocation in dynamic shared memory) in which case other backends won't have that information, so we display &lt;code&gt;extension&lt;/code&gt; for such cases.</source>
          <target state="translated">확장자로 등록 된 트랜치의 경우 이름은 확장자로 지정되며 이는 &lt;code&gt;wait_event&lt;/code&gt; 로 표시됩니다 . 사용자가 백엔드 중 하나 (동적 공유 메모리에 할당하여)에 트랜치를 등록했을 가능성이 있으며,이 경우 다른 백엔드는 해당 정보를 갖지 않으므로 그러한 경우에 대한 &lt;code&gt;extension&lt;/code&gt; 을 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="6ededecf7230bd098333895398724d8cf30ca646" translate="yes" xml:space="preserve">
          <source>For typed tables, the OID of the underlying composite type, zero for all other relations</source>
          <target state="translated">유형이 지정된 테이블의 경우 기본 복합 유형의 OID, 다른 모든 관계의 경우 0</target>
        </trans-unit>
        <trans-unit id="27c45ad1aa00e6a5905b5f896364ccf8b4773847" translate="yes" xml:space="preserve">
          <source>For types and domains, allows use of the type or domain in the creation of tables, functions, and other schema objects. (Note that this privilege does not control all &amp;ldquo;usage&amp;rdquo; of the type, such as values of the type appearing in queries. It only prevents objects from being created that depend on the type. The main purpose of this privilege is controlling which users can create dependencies on a type, which could prevent the owner from changing the type later.)</source>
          <target state="translated">유형 및 도메인의 경우 테이블, 함수 및 기타 스키마 객체를 만들 때 유형 또는 도메인을 사용할 수 있습니다. (이 권한은 쿼리에 나타나는 유형의 값과 같은 유형의 모든 &quot;사용&quot;을 제어하지는 않습니다. 유형에 따라 개체가 생성되는 것을 막을뿐입니다.이 권한의 주된 목적은 사용자를 제어 할 수있는 것입니다. 유형에 대한 종속성을 작성하여 소유자가 나중에 유형을 변경하지 못하게 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="bff214879bf946c9914852230e9d3373cec1aabc" translate="yes" xml:space="preserve">
          <source>For types used in system tables, it is critical that the size and alignment defined in &lt;code&gt;pg_type&lt;/code&gt; agree with the way that the compiler will lay out the column in a structure representing a table row.</source>
          <target state="translated">시스템 테이블에 사용되는 유형의 경우 &lt;code&gt;pg_type&lt;/code&gt; 에 정의 된 크기와 정렬 이 컴파일러가 테이블 행을 나타내는 구조에서 열을 레이아웃하는 방식과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e1106a91cc01fcaaeb464887fd19957f0820912" translate="yes" xml:space="preserve">
          <source>For unlogged relations, everything works the same except that no actual WAL record is emitted. Thus, you typically do not need to do any explicit checks for unlogged relations.</source>
          <target state="translated">기록되지 않은 관계의 경우 실제 WAL 레코드가 생성되지 않는 것을 제외하고 모든 것이 동일하게 작동합니다. 따라서 일반적으로 기록되지 않은 관계에 대한 명시 적 검사를 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="85b738e0688a60aa0821e2d9571d4dd56271215e" translate="yes" xml:space="preserve">
          <source>For user-defined functions, PostgreSQL tracks dependencies associated with a function's externally-visible properties, such as its argument and result types, but &lt;em&gt;not&lt;/em&gt; dependencies that could only be known by examining the function body. As an example, consider this situation:</source>
          <target state="translated">사용자 정의 함수의 경우 PostgreSQL은 인수 및 결과 유형과 같이 함수의 외부에서 볼 수있는 속성과 관련된 종속성을 추적하지만 함수 본문을 검사해야만 알 수있는 종속성은 추적 &lt;em&gt;하지 않습니다&lt;/em&gt; . 예를 들어 다음 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cd43cb783f81232deb1bffc73b358dcab3c75399" translate="yes" xml:space="preserve">
          <source>For very large databases, you might need to combine &lt;code&gt;split&lt;/code&gt; with one of the other two approaches.</source>
          <target state="translated">매우 큰 데이터베이스의 경우 &lt;code&gt;split&lt;/code&gt; 을 다른 두 가지 방법 중 하나와 결합해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33f690385f50f3c83dc2195d926f5a45ebb2cb63" translate="yes" xml:space="preserve">
          <source>For views, &lt;code&gt;db_view:expand&lt;/code&gt; will be checked, then any other required permissions will be checked on the objects being expanded from the view, individually.</source>
          <target state="translated">뷰의 경우 &lt;code&gt;db_view:expand&lt;/code&gt; 가 확인 된 후, 다른 필수 권한이 ​​뷰에서 확장되는 오브젝트에 대해 개별적으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="9bf29d0c0afb407846366a836c4874ef5e6ab74c" translate="yes" xml:space="preserve">
          <source>Forbid the execution of any &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;DDL&lt;/a&gt; command:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;DDL&lt;/a&gt; 명령 실행을 금지하십시오 .</target>
        </trans-unit>
        <trans-unit id="12f8a377f5b991eee465fcb5a9cc92f6309394f2" translate="yes" xml:space="preserve">
          <source>Forbid the execution of any &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;DDL&lt;/a&gt; command:</source>
          <target state="translated">Forbid the execution of any &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;DDL&lt;/a&gt; command:</target>
        </trans-unit>
        <trans-unit id="9e74aa9c02843996563e83950d619d1a48cca853" translate="yes" xml:space="preserve">
          <source>Forbids the use of particular scan and join methods: &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; disable sequential and index scans respectively, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; disable index-only scans, bitmap index scans, and TID scans respectively, while &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; disable nested-loop, merge and hash joins respectively.</source>
          <target state="translated">금지 특히 주사의 사용 및 방법을 조인 &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;i&lt;/code&gt; 비활성화 순차 인덱스를 각각 검사 &lt;code&gt;o&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;t&lt;/code&gt; 비활성화 인덱스 만 스캔, 비트 맵 인덱스 스캔 및 TID는 동안, 각각 검사 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , 및 &lt;code&gt;h&lt;/code&gt; 비활성화 nested- 루프, 병합 및 해시 조인.</target>
        </trans-unit>
        <trans-unit id="6b54925430ba39c29285400ee9438bd06b14498b" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;pg_resetwal&lt;/code&gt; to proceed even if it cannot determine valid data for &lt;code&gt;pg_control&lt;/code&gt;, as explained above.</source>
          <target state="translated">위에서 설명한대로 &lt;code&gt;pg_control&lt;/code&gt; 의 유효한 데이터를 판별 할 수없는 경우에도 &lt;code&gt;pg_resetwal&lt;/code&gt; 을 강제 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eac8549c0aec6316f92f1df6ba514101db909c7" translate="yes" xml:space="preserve">
          <source>Force clusterdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 clusterdb가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b0925c99f8012867ed4e28694186256d8b497b07" translate="yes" xml:space="preserve">
          <source>Force createdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 createdb가 암호를 입력하도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="919f499ede6938621bb948df3ec55861e7b6e806" translate="yes" xml:space="preserve">
          <source>Force createuser to prompt for a password (for connecting to the server, not for the password of the new user).</source>
          <target state="translated">createuser가 암호를 요구하도록합니다 (새 사용자의 암호가 아닌 서버에 연결하기 위해).</target>
        </trans-unit>
        <trans-unit id="0f5754485fd77647fa947500ba7d7eb3887d6390" translate="yes" xml:space="preserve">
          <source>Force dropdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 dropdb가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="873b3fb51bdfb58a81fcee07b36cfd295d4a25ba" translate="yes" xml:space="preserve">
          <source>Force dropuser to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 dropuser가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="68791460318431f1565f0db6649c38933e1c99f9" translate="yes" xml:space="preserve">
          <source>Force pg_basebackup to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_basebackup이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e1db6640e8674298e7ff463f7c01bcb7d3c09291" translate="yes" xml:space="preserve">
          <source>Force pg_dump to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_dump가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="0bf671184854c4cafab424f289da944581383f7f" translate="yes" xml:space="preserve">
          <source>Force pg_dumpall to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_dumpall이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="cd46ad236b5565bc59849836637665c81e945654" translate="yes" xml:space="preserve">
          <source>Force pg_receivewal to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_receivewal이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="cb0cb6641f18ac0a5ebc128cc7585e9485375d09" translate="yes" xml:space="preserve">
          <source>Force pg_recvlogical to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_recvlogical이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4333d7ad34894773d7724c896ba1ace5baa2e67d" translate="yes" xml:space="preserve">
          <source>Force pg_restore to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 pg_restore가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="5d4bbbd7b1b0e3c3b7ba8c83092d65226c1b31be" translate="yes" xml:space="preserve">
          <source>Force psql to prompt for a password before connecting to a database, even if the password will not be used.</source>
          <target state="translated">Force psql to prompt for a password before connecting to a database, even if the password will not be used.</target>
        </trans-unit>
        <trans-unit id="060988688e7df93b56005121dd07764d70ac7fe5" translate="yes" xml:space="preserve">
          <source>Force psql to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 psql이 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b0cd7fd585ccc7a582ee1111bc67d7d89a04cf8e" translate="yes" xml:space="preserve">
          <source>Force quoting of all identifiers. This option is recommended when dumping a database from a server whose PostgreSQL major version is different from pg_dump's, or when the output is intended to be loaded into a server of a different major version. By default, pg_dump quotes only identifiers that are reserved words in its own major version. This sometimes results in compatibility issues when dealing with servers of other versions that may have slightly different sets of reserved words. Using &lt;code&gt;--quote-all-identifiers&lt;/code&gt; prevents such issues, at the price of a harder-to-read dump script.</source>
          <target state="translated">모든 식별자를 강제로 인용합니다. 이 옵션은 PostgreSQL 주 버전이 pg_dump와 다른 서버에서 데이터베이스를 덤프하거나 출력을 다른 주 버전의 서버로로드 할 때 권장됩니다. 기본적으로 pg_dump는 자체 주 버전에서 예약어 인 식별자 만 인용합니다. 이로 인해 예약어가 약간 다른 다른 버전의 서버를 처리 할 때 호환성 문제가 발생하는 경우가 있습니다. 사용 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 힘들어 읽기 덤프 스크립트의 가격으로, 이러한 문제 방지합니다.</target>
        </trans-unit>
        <trans-unit id="b22bd3cb5e64bd74dfce653c7bff0f559c9c1f26" translate="yes" xml:space="preserve">
          <source>Force quoting of all identifiers. This option is recommended when dumping a database from a server whose PostgreSQL major version is different from pg_dumpall's, or when the output is intended to be loaded into a server of a different major version. By default, pg_dumpall quotes only identifiers that are reserved words in its own major version. This sometimes results in compatibility issues when dealing with servers of other versions that may have slightly different sets of reserved words. Using &lt;code&gt;--quote-all-identifiers&lt;/code&gt; prevents such issues, at the price of a harder-to-read dump script.</source>
          <target state="translated">모든 식별자를 강제로 인용합니다. 이 옵션은 PostgreSQL 주 버전이 pg_dumpall과 다른 서버에서 데이터베이스를 덤프하거나 출력을 다른 주 버전의 서버로로드 할 때 권장됩니다. 기본적으로 pg_dumpall은 자체 주 버전의 예약어 인 식별자 만 인용합니다. 이로 인해 예약어가 약간 다른 다른 버전의 서버를 처리 할 때 호환성 문제가 발생하는 경우가 있습니다. 사용 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 힘들어 읽기 덤프 스크립트의 가격으로, 이러한 문제 방지합니다.</target>
        </trans-unit>
        <trans-unit id="5a4d553a940905a5b45f8f4a9271805f05936143" translate="yes" xml:space="preserve">
          <source>Force reindexdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 reindexdb가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="d704d18558a65a962929acf79610b9c10e0ea21f" translate="yes" xml:space="preserve">
          <source>Force switch to a new write-ahead log file (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">새로운 미리 쓰기 로그 파일로 강제 전환 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음)</target>
        </trans-unit>
        <trans-unit id="ad34c2643c5ad08a3b8ba0b861d443b8a1146fd4" translate="yes" xml:space="preserve">
          <source>Force vacuumdb to prompt for a password before connecting to a database.</source>
          <target state="translated">데이터베이스에 연결하기 전에 vacuumdb가 암호를 요구하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8ba33bb09d0b9eedd0a5116108d4c330db881549" translate="yes" xml:space="preserve">
          <source>Forces all filenames in the backup manifest to be hex-encoded. If this option is not specified, only non-UTF8 filenames are hex-encoded. This option is mostly intended to test that tools which read a backup manifest file properly handle this case.</source>
          <target state="translated">Forces all filenames in the backup manifest to be hex-encoded. If this option is not specified, only non-UTF8 filenames are hex-encoded. This option is mostly intended to test that tools which read a backup manifest file properly handle this case.</target>
        </trans-unit>
        <trans-unit id="26d93bada9089cb03adfebd957430eeb5dee1930" translate="yes" xml:space="preserve">
          <source>Forces pg_basebackup to prompt for a password before connecting to the source server.</source>
          <target state="translated">Forces pg_basebackup to prompt for a password before connecting to the source server.</target>
        </trans-unit>
        <trans-unit id="ab1894a9915a1c5bdd4fa99a3c35aa7aef1f3043" translate="yes" xml:space="preserve">
          <source>Forces quoting to be used for all non-&lt;code&gt;NULL&lt;/code&gt; values in each specified column. &lt;code&gt;NULL&lt;/code&gt; output is never quoted. If &lt;code&gt;*&lt;/code&gt; is specified, non-&lt;code&gt;NULL&lt;/code&gt; values will be quoted in all columns. This option is allowed only in &lt;code&gt;COPY TO&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">지정된 각 열에서 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 모든 값에 따옴표를 사용 합니다. &lt;code&gt;NULL&lt;/code&gt; 출력은 인용되지 않습니다. 경우 &lt;code&gt;*&lt;/code&gt; 가 지정되어, 비 &lt;code&gt;NULL&lt;/code&gt; 의 값은 모든 열에서 인용됩니다. 이 옵션은 &lt;code&gt;COPY TO&lt;/code&gt; 및 &lt;code&gt;CSV&lt;/code&gt; 형식을 사용할 때만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="538b02792cabcf9f2865608e41802e229f615f71" translate="yes" xml:space="preserve">
          <source>Forces the server to switch to a new write-ahead log file, which allows the current file to be archived (assuming you are using continuous archiving). The result is the ending write-ahead log location plus 1 within the just-completed write-ahead log file. If there has been no write-ahead log activity since the last write-ahead log switch, &lt;code&gt;pg_switch_wal&lt;/code&gt; does nothing and returns the start location of the write-ahead log file currently in use.</source>
          <target state="translated">Forces the server to switch to a new write-ahead log file, which allows the current file to be archived (assuming you are using continuous archiving). The result is the ending write-ahead log location plus 1 within the just-completed write-ahead log file. If there has been no write-ahead log activity since the last write-ahead log switch, &lt;code&gt;pg_switch_wal&lt;/code&gt; does nothing and returns the start location of the write-ahead log file currently in use.</target>
        </trans-unit>
        <trans-unit id="e53ee207fccbc10bf771537429c8ceb105018b4c" translate="yes" xml:space="preserve">
          <source>Foreign Data</source>
          <target state="translated">외국 데이터</target>
        </trans-unit>
        <trans-unit id="60b698071b99433356500a6664686a79ff0c576f" translate="yes" xml:space="preserve">
          <source>Foreign data is accessed with help from a &lt;em&gt;foreign data wrapper&lt;/em&gt;. A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it. There are some foreign data wrappers available as &lt;code&gt;contrib&lt;/code&gt; modules; see &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt;. Other kinds of foreign data wrappers might be found as third party products. If none of the existing foreign data wrappers suit your needs, you can write your own; see &lt;a href=&quot;https://www.postgresql.org/docs/12/fdwhandler.html&quot;&gt;Chapter 56&lt;/a&gt;.</source>
          <target state="translated">외부 데이터는 &lt;em&gt;외부 데이터 랩퍼의&lt;/em&gt; 도움으로 액세스됩니다 . 외부 데이터 랩퍼는 외부 데이터 소스와 통신 할 수있는 라이브러리로, 데이터 소스에 연결하고 데이터를 가져 오는 세부 사항을 숨 깁니다. &lt;code&gt;contrib&lt;/code&gt; 모듈 로 사용 가능한 일부 외부 데이터 랩퍼가 있습니다 . &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;부록 F를&lt;/a&gt; 참조하십시오 . 다른 종류의 외부 데이터 래퍼는 타사 제품으로 제공 될 수 있습니다. 기존 외부 데이터 래퍼 중 어느 것도 사용자 요구에 맞지 않으면 직접 작성할 수 있습니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/fdwhandler.html&quot;&gt;56 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e081c17d534c83bc3c89dd5e5ae11f9988469a0c" translate="yes" xml:space="preserve">
          <source>Foreign data is accessed with help from a &lt;em&gt;foreign data wrapper&lt;/em&gt;. A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it. There are some foreign data wrappers available as &lt;code&gt;contrib&lt;/code&gt; modules; see &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt;. Other kinds of foreign data wrappers might be found as third party products. If none of the existing foreign data wrappers suit your needs, you can write your own; see &lt;a href=&quot;https://www.postgresql.org/docs/13/fdwhandler.html&quot;&gt;Chapter 56&lt;/a&gt;.</source>
          <target state="translated">Foreign data is accessed with help from a &lt;em&gt;foreign data wrapper&lt;/em&gt;. A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it. There are some foreign data wrappers available as &lt;code&gt;contrib&lt;/code&gt; modules; see &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt;. Other kinds of foreign data wrappers might be found as third party products. If none of the existing foreign data wrappers suit your needs, you can write your own; see &lt;a href=&quot;https://www.postgresql.org/docs/13/fdwhandler.html&quot;&gt;Chapter 56&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1d0b62aaedf4c17c32eaa3ba64c33e854069e4d0" translate="yes" xml:space="preserve">
          <source>Foreign data wrapper</source>
          <target state="translated">Foreign data wrapper</target>
        </trans-unit>
        <trans-unit id="ec49828d4aeea86333a990a4bd9c0abe72c2db0a" translate="yes" xml:space="preserve">
          <source>Foreign key</source>
          <target state="translated">외래 키</target>
        </trans-unit>
        <trans-unit id="94c0cd02df3f1a32213c26c15ceb6bc33046efb5" translate="yes" xml:space="preserve">
          <source>Foreign key deletion action code: &lt;code&gt;a&lt;/code&gt; = no action, &lt;code&gt;r&lt;/code&gt; = restrict, &lt;code&gt;c&lt;/code&gt; = cascade, &lt;code&gt;n&lt;/code&gt; = set null, &lt;code&gt;d&lt;/code&gt; = set default</source>
          <target state="translated">외래 키 삭제 동작 코드 : &lt;code&gt;a&lt;/code&gt; = 동작 없음, &lt;code&gt;r&lt;/code&gt; = 제한, &lt;code&gt;c&lt;/code&gt; = 계단식, &lt;code&gt;n&lt;/code&gt; = 널 설정, &lt;code&gt;d&lt;/code&gt; = 기본값 설정</target>
        </trans-unit>
        <trans-unit id="67ed786663de0061ba336e549d3d7d184b09ab90" translate="yes" xml:space="preserve">
          <source>Foreign key match type: &lt;code&gt;f&lt;/code&gt; = full, &lt;code&gt;p&lt;/code&gt; = partial, &lt;code&gt;s&lt;/code&gt; = simple</source>
          <target state="translated">외래 키 일치 유형 : &lt;code&gt;f&lt;/code&gt; = 전체, &lt;code&gt;p&lt;/code&gt; = 부분, &lt;code&gt;s&lt;/code&gt; = 단순</target>
        </trans-unit>
        <trans-unit id="f7223fe60c8520d1d8c5dd54e60a3a21d67aff2e" translate="yes" xml:space="preserve">
          <source>Foreign key update action code: &lt;code&gt;a&lt;/code&gt; = no action, &lt;code&gt;r&lt;/code&gt; = restrict, &lt;code&gt;c&lt;/code&gt; = cascade, &lt;code&gt;n&lt;/code&gt; = set null, &lt;code&gt;d&lt;/code&gt; = set default</source>
          <target state="translated">외래 키 업데이트 동작 코드 : &lt;code&gt;a&lt;/code&gt; = 동작 없음, &lt;code&gt;r&lt;/code&gt; = 제한, &lt;code&gt;c&lt;/code&gt; = 캐스케이드, &lt;code&gt;n&lt;/code&gt; = 널 설정, &lt;code&gt;d&lt;/code&gt; = 기본값 설정</target>
        </trans-unit>
        <trans-unit id="24479ccb6a12c499e80b0da414bfcc11fa42a42f" translate="yes" xml:space="preserve">
          <source>Foreign server</source>
          <target state="translated">Foreign server</target>
        </trans-unit>
        <trans-unit id="65a5d0add327edf5ad461c0cb7f6054d85e3b0e7" translate="yes" xml:space="preserve">
          <source>Foreign server specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 외부 서버 별 옵션</target>
        </trans-unit>
        <trans-unit id="2328a33941c65762849f0c57e1700f0618ac2c11" translate="yes" xml:space="preserve">
          <source>Foreign table (relation)</source>
          <target state="translated">Foreign table (relation)</target>
        </trans-unit>
        <trans-unit id="b1b45f3e264a3f3e8e58872fe892f43e82136b90" translate="yes" xml:space="preserve">
          <source>Foreign table options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 외부 테이블 옵션</target>
        </trans-unit>
        <trans-unit id="a914bd9dafd1ce6150ce31452c647084bd0851ab" translate="yes" xml:space="preserve">
          <source>Foreign tables (see &lt;a href=&quot;ddl-foreign-data&quot;&gt;Section 5.12&lt;/a&gt;) can also be part of inheritance hierarchies, either as parent or child tables, just as regular tables can be. If a foreign table is part of an inheritance hierarchy then any operations not supported by the foreign table are not supported on the whole hierarchy either.</source>
          <target state="translated">외래 테이블 ( &lt;a href=&quot;ddl-foreign-data&quot;&gt;5.12 절&lt;/a&gt; 참조 )은 일반 테이블과 마찬가지로 부모 또는 자식 테이블과 같은 상속 계층 구조의 일부일 수 있습니다. 외래 테이블이 상속 계층의 일부인 경우 외래 테이블에서 지원하지 않는 작업은 전체 계층에서도 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f355c9e7f0aaa375694a97f071442929b8bef72d" translate="yes" xml:space="preserve">
          <source>Foreign tables are analyzed only when explicitly selected. Not all foreign data wrappers support &lt;code&gt;ANALYZE&lt;/code&gt;. If the table's wrapper does not support &lt;code&gt;ANALYZE&lt;/code&gt;, the command prints a warning and does nothing.</source>
          <target state="translated">외부 테이블은 명시 적으로 선택된 경우에만 분석됩니다. 모든 외부 데이터 랩퍼가 &lt;code&gt;ANALYZE&lt;/code&gt; 를 지원하지는 않습니다 . 테이블의 랩퍼가 &lt;code&gt;ANALYZE&lt;/code&gt; 를 지원하지 않으면 명령이 경고를 표시하고 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="114810936e2e203f850dfc30c1a7c22dda77dc02" translate="yes" xml:space="preserve">
          <source>Foreign tables can have generated columns. See &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for details.</source>
          <target state="translated">외부 테이블은 열을 생성 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="85799ef6669eba496b7c90dd087afbef34699725" translate="yes" xml:space="preserve">
          <source>Foreign-data wrapper specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 외부 데이터 래퍼 특정 옵션</target>
        </trans-unit>
        <trans-unit id="471121e27a3e0f2a208ec3e9a0b109102268a22f" translate="yes" xml:space="preserve">
          <source>Fork</source>
          <target state="translated">Fork</target>
        </trans-unit>
        <trans-unit id="8340dbc9e3b7c8b79fc57d1ea821c4dd6ab2e45a" translate="yes" xml:space="preserve">
          <source>Fork number within the relation; see &lt;code&gt;include/common/relpath.h&lt;/code&gt;</source>
          <target state="translated">관계 내의 포크 번호; &lt;code&gt;include/common/relpath.h&lt;/code&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="bfff5fab0567decaa660bb51d870a4a558ade9bd" translate="yes" xml:space="preserve">
          <source>Form feed (ASCII 12)</source>
          <target state="translated">용지 공급 (ASCII 12)</target>
        </trans-unit>
        <trans-unit id="2186cd568d6445c67ce20f9b2564241918cf9481" translate="yes" xml:space="preserve">
          <source>Format arguments according to a format string. This function is similar to the C function &lt;code&gt;sprintf&lt;/code&gt;. See &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;Section 9.4.1&lt;/a&gt;.</source>
          <target state="translated">형식 문자열에 따라 인수를 형식화하십시오. 이 함수는 C 함수 &lt;code&gt;sprintf&lt;/code&gt; 와 유사합니다 . &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;섹션 9.4.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="2f10703a114eeb65e11771dfbfc8cbc068e4d983" translate="yes" xml:space="preserve">
          <source>Format of the &lt;code&gt;.dict&lt;/code&gt; file is:</source>
          <target state="translated">&lt;code&gt;.dict&lt;/code&gt; 파일의 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d32d1fc793b4203a324b693b7b245d9ad6dbbf1f" translate="yes" xml:space="preserve">
          <source>Format specifiers are introduced by a &lt;code&gt;%&lt;/code&gt; character and have the form</source>
          <target state="translated">형식 지정자는 &lt;code&gt;%&lt;/code&gt; 문자 로 소개되며 형식은</target>
        </trans-unit>
        <trans-unit id="c46b5c69a535eddb26b0b25a59b562dfdb1ab01b" translate="yes" xml:space="preserve">
          <source>Formats arguments according to a format string; see &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;Section 9.4.1&lt;/a&gt;. This function is similar to the C function &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">Formats arguments according to a format string; see &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;Section 9.4.1&lt;/a&gt;. This function is similar to the C function &lt;code&gt;sprintf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac4e3c929fdec4f6080024051a0ba50e01f4af70" translate="yes" xml:space="preserve">
          <source>Formatting Functions</source>
          <target state="translated">서식 기능</target>
        </trans-unit>
        <trans-unit id="27f02bbdc243505380802862dfc269e6f51a4b71" translate="yes" xml:space="preserve">
          <source>Formatting of currency amounts</source>
          <target state="translated">통화 금액 서식</target>
        </trans-unit>
        <trans-unit id="3117b3b2c7e85f24cb15daec9ea8d347a5a664b1" translate="yes" xml:space="preserve">
          <source>Formatting of dates and times</source>
          <target state="translated">날짜 및 시간 형식</target>
        </trans-unit>
        <trans-unit id="860fd1b538482a0032ad8bac4633d0f2e1fcba7b" translate="yes" xml:space="preserve">
          <source>Formatting of numbers</source>
          <target state="translated">숫자 서식</target>
        </trans-unit>
        <trans-unit id="6a1f6ab661d4c193244f17d409e7e72bd4d570ee" translate="yes" xml:space="preserve">
          <source>Fortunately, PostgreSQL has the ability to combine multiple indexes (including multiple uses of the same index) to handle cases that cannot be implemented by single index scans. The system can form &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; conditions across several index scans. For example, a query like &lt;code&gt;WHERE x = 42 OR x = 47 OR x = 53 OR x = 99&lt;/code&gt; could be broken down into four separate scans of an index on &lt;code&gt;x&lt;/code&gt;, each scan using one of the query clauses. The results of these scans are then ORed together to produce the result. Another example is that if we have separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, one possible implementation of a query like &lt;code&gt;WHERE x = 5 AND y = 6&lt;/code&gt; is to use each index with the appropriate query clause and then AND together the index results to identify the result rows.</source>
          <target state="translated">다행스럽게도 PostgreSQL에는 단일 인덱스 스캔으로 구현할 수없는 경우를 처리하기 위해 여러 인덱스 (동일 인덱스의 여러 사용 포함)를 결합 할 수 있습니다. 시스템은 여러 인덱스 스캔에서 &lt;code&gt;AND&lt;/code&gt; 및 &lt;code&gt;OR&lt;/code&gt; 조건을 형성 할 수 있습니다 . 예를 들어 &lt;code&gt;WHERE x = 42 OR x = 47 OR x = 53 OR x = 99&lt;/code&gt; 와 같은 쿼리는 각 쿼리 절 중 하나를 사용하여 &lt;code&gt;x&lt;/code&gt; 에서 인덱스에 대한 4 개의 개별 인덱스 스캔으로 나눌 수 있습니다 . 그런 다음 이러한 스캔 결과를 OR로 연결하여 결과를 생성합니다. 또 다른 예는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 에 별도의 인덱스가있는 경우 &lt;code&gt;WHERE x = 5 AND y = 6&lt;/code&gt; 같은 쿼리 구현이 가능하다는 것입니다 적절한 쿼리 절과 함께 각 인덱스를 사용한 다음 인덱스 결과를 함께 사용하여 결과 행을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="7a4530052e4c5506e1ca3c7fe0019b4ab8ad7aeb" translate="yes" xml:space="preserve">
          <source>Forward transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">이동 집계 모드를위한 순방향 전환 기능 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="f6bf4e66e6e60c9947bd8c75fee01c881afbe844" translate="yes" xml:space="preserve">
          <source>Fourth, verify your shell is operating in the &lt;code&gt;unconfined_t&lt;/code&gt; domain:</source>
          <target state="translated">넷째, 쉘이 &lt;code&gt;unconfined_t&lt;/code&gt; 도메인 에서 작동하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b72b0d434a6da3b7a140f72c4533ea003e1049d" translate="yes" xml:space="preserve">
          <source>Fraction of column entries that are null</source>
          <target state="translated">널 (null) 인 열 항목의 비율</target>
        </trans-unit>
        <trans-unit id="05336909662a05ee4c216375dd2926cd06ca7ff1" translate="yes" xml:space="preserve">
          <source>Free Space Map</source>
          <target state="translated">여유 공간지도</target>
        </trans-unit>
        <trans-unit id="8d1442f2468898b3b97983d4c108633f0dd9704b" translate="yes" xml:space="preserve">
          <source>Free space</source>
          <target state="translated">자유 공간</target>
        </trans-unit>
        <trans-unit id="15b3a8f5ed1b0f0d55b8d26fe0145527a2ec6761" translate="yes" xml:space="preserve">
          <source>Free space map (fork)</source>
          <target state="translated">Free space map (fork)</target>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="eba92e8cbbcf79124e18b38dc9296cb1e7b3c90c" translate="yes" xml:space="preserve">
          <source>FreeBSD also allows changing the time source on the fly, and it logs information about the timer selected during boot:</source>
          <target state="translated">FreeBSD는 또한 시간 소스를 즉시 변경할 수 있으며 부팅 중에 선택된 타이머에 대한 정보를 기록합니다 :</target>
        </trans-unit>
        <trans-unit id="163ea5dad4eb636b98f8ad7f2021b2c2146c890b" translate="yes" xml:space="preserve">
          <source>FreeBSD libcrypt</source>
          <target state="translated">FreeBSD libcrypt</target>
        </trans-unit>
        <trans-unit id="28073e04cfc0b55e307bd7ab2f2fab043889d334" translate="yes" xml:space="preserve">
          <source>FreeBSD versions before 4.0 work like old OpenBSD (see below).</source>
          <target state="translated">4.0 이전의 FreeBSD 버전은 이전 OpenBSD처럼 작동합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="343be4952511cb2fc2b6ddde12f9c10d6cce223e" translate="yes" xml:space="preserve">
          <source>Frequent calls to this function could have some impact on database performance, because it needs access to the predicate lock manager's shared state for a short time.</source>
          <target state="translated">Frequent calls to this function could have some impact on database performance, because it needs access to the predicate lock manager's shared state for a short time.</target>
        </trans-unit>
        <trans-unit id="62bfe0b7eae857a638e0542deb3faf6e7cb6ef3b" translate="yes" xml:space="preserve">
          <source>Frequent calls to this function could have some impact on database performance, because it needs exclusive access to the lock manager's shared state for a short time.</source>
          <target state="translated">Frequent calls to this function could have some impact on database performance, because it needs exclusive access to the lock manager's shared state for a short time.</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="bbd6e32ee1326237814b697269b4368033d50d2f" translate="yes" xml:space="preserve">
          <source>Fri</source>
          <target state="translated">Fri</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="0092eefda9395145cd29888b2348888692bc90be" translate="yes" xml:space="preserve">
          <source>From PostgreSQL 11, adding a column with a constant default value no longer means that each row of the table needs to be updated when the &lt;code&gt;ALTER TABLE&lt;/code&gt; statement is executed. Instead, the default value will be returned the next time the row is accessed, and applied when the table is rewritten, making the &lt;code&gt;ALTER TABLE&lt;/code&gt; very fast even on large tables.</source>
          <target state="translated">PostgreSQL 11부터 상수 기본값을 가진 열을 추가한다고해서 &lt;code&gt;ALTER TABLE&lt;/code&gt; 문을 실행할 때 테이블의 각 행을 업데이트 할 필요가 없습니다 . 대신, 다음에 행에 액세스 할 때 기본값이 리턴되고 테이블을 다시 쓸 때 적용되므로 대형 테이블에서도 &lt;code&gt;ALTER TABLE&lt;/code&gt; 이 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="74866cf8a85ad43b25b0fa833b5c4a9e7721fc2f" translate="yes" xml:space="preserve">
          <source>From PostgreSQL 8.3 on, there is XML-related functionality based on the SQL/XML standard in the core server. That functionality covers XML syntax checking and XPath queries, which is what this module does, and more, but the API is not at all compatible. It is planned that this module will be removed in a future version of PostgreSQL in favor of the newer standard API, so you are encouraged to try converting your applications. If you find that some of the functionality of this module is not available in an adequate form with the newer API, please explain your issue to &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pgsql-hackers@lists.postgresql.org&quot;&gt;pgsql-hackers@lists.postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt; so that the deficiency can be addressed.</source>
          <target state="translated">PostgreSQL 8.3부터 코어 서버에는 SQL / XML 표준을 기반으로하는 XML 관련 기능이 있습니다. 이 기능은이 모듈이하는 XML 구문 검사 및 XPath 쿼리를 다루지 만 API는 전혀 호환되지 않습니다. 이 표준은 최신 표준 API를 위해 향후 PostgreSQL 버전에서 제거 될 예정이므로 애플리케이션 변환을 시도하는 것이 좋습니다. 이 모듈의 일부 기능이 최신 API와 함께 적절한 형태로 제공되지 않는 경우 결함을 해결할 수 있도록 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pgsql-hackers@lists.postgresql.org&quot;&gt;pgsql-hackers@lists.postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt; 문제를 설명하십시오 .</target>
        </trans-unit>
        <trans-unit id="278d8abdb35f5b8d4b7f92c6d932b66d8fe44745" translate="yes" xml:space="preserve">
          <source>From experience, values in the thousands (e.g., 5000 &amp;mdash; 20000) work well.</source>
          <target state="translated">경험상 수천의 값 (예 : 5000 &amp;mdash; 20000)이 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a9f490fca8caa246230fe49e0dcc7c45a0810a07" translate="yes" xml:space="preserve">
          <source>From the point of view of the issuing session, &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; is not unlike a &lt;code&gt;ROLLBACK&lt;/code&gt; command: after executing it, there is no active current transaction, and the effects of the prepared transaction are no longer visible. (The effects will become visible again if the transaction is committed.)</source>
          <target state="translated">발행 세션의 관점에서 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 은 &lt;code&gt;ROLLBACK&lt;/code&gt; 명령 과 다르지 않습니다 . 실행 후 활성 현재 트랜잭션이 없으며 준비된 트랜잭션의 효과가 더 이상 표시되지 않습니다. 트랜잭션이 커밋되면 효과가 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2047a74f4a2930f4b44969e9f4cae7215400249e" translate="yes" xml:space="preserve">
          <source>Frontend code should not include any &lt;code&gt;pg_xxx.h&lt;/code&gt; catalog header file, as these files may contain C code that won't compile outside the backend. (Typically, that happens because these files also contain declarations for functions in &lt;code&gt;src/backend/catalog/&lt;/code&gt; files.) Instead, frontend code may include the corresponding generated &lt;code&gt;pg_xxx_d.h&lt;/code&gt; header, which will contain OID &lt;code&gt;#define&lt;/code&gt;s and any other data that might be of use on the client side. If you want macros or other code in a catalog header to be visible to frontend code, write &lt;code&gt;#ifdef EXPOSE_TO_CLIENT_CODE&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; around that section to instruct &lt;code&gt;genbki.pl&lt;/code&gt; to copy that section to the &lt;code&gt;pg_xxx_d.h&lt;/code&gt; header.</source>
          <target state="translated">프런트 엔드 코드에는 &lt;code&gt;pg_xxx.h&lt;/code&gt; 카탈로그 헤더 파일이 포함되지 않아야 합니다. 이러한 파일에는 백엔드 외부에서 컴파일되지 않는 C 코드가 포함될 수 있습니다. 일반적으로 이러한 파일에는 &lt;code&gt;src/backend/catalog/&lt;/code&gt; 파일의 함수에 대한 선언이 포함되어 있기 때문에 발생 합니다. 대신 프런트 엔드 코드에는 해당 생성 된 &lt;code&gt;pg_xxx_d.h&lt;/code&gt; 헤더 가 포함될 수 있습니다.이 헤더에는 OID &lt;code&gt;#define&lt;/code&gt; 및 기타 데이터가 포함될 수 있습니다. 클라이언트 측에서 사용하십시오. 카탈로그 헤더의 매크로 또는 기타 코드를 프론트 엔드 코드에 표시하려면 &lt;code&gt;#ifdef EXPOSE_TO_CLIENT_CODE&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; 를 해당 섹션 주위 에 작성하여 &lt;code&gt;pg_xxx_d.h&lt;/code&gt; 해당 섹션을 &lt;code&gt;genbki.pl&lt;/code&gt; 에 복사 하도록 지시 하십시오 . 헤더.</target>
        </trans-unit>
        <trans-unit id="5342caa1027afd1b462e71637b0394a8eb14ac7b" translate="yes" xml:space="preserve">
          <source>Frontend/Backend Protocol</source>
          <target state="translated">프론트 엔드 / 백엔드 프로토콜</target>
        </trans-unit>
        <trans-unit id="6b2e86b36efeac1ca193b435611b528921adc671" translate="yes" xml:space="preserve">
          <source>Full Text Search</source>
          <target state="translated">전문 검색</target>
        </trans-unit>
        <trans-unit id="58bab05efd3bb13a137c704cfe50139caf2da01d" translate="yes" xml:space="preserve">
          <source>Full Text Searching (or just &lt;em&gt;text search&lt;/em&gt;) provides the capability to identify natural-language &lt;em&gt;documents&lt;/em&gt; that satisfy a &lt;em&gt;query&lt;/em&gt;, and optionally to sort them by relevance to the query. The most common type of search is to find all documents containing given &lt;em&gt;query terms&lt;/em&gt; and return them in order of their &lt;em&gt;similarity&lt;/em&gt; to the query. Notions of &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;similarity&lt;/code&gt; are very flexible and depend on the specific application. The simplest search considers &lt;code&gt;query&lt;/code&gt; as a set of words and &lt;code&gt;similarity&lt;/code&gt; as the frequency of query words in the document.</source>
          <target state="translated">전체 텍스트 검색 (또는 &lt;em&gt;텍스트 검색&lt;/em&gt; )은 &lt;em&gt;쿼리&lt;/em&gt; 를 만족하는 자연어 &lt;em&gt;문서&lt;/em&gt; 를 식별 하고 선택적으로 &lt;em&gt;쿼리&lt;/em&gt; 와 관련하여 &lt;em&gt;문서&lt;/em&gt; 를 정렬 하는 기능을 제공합니다 . 가장 일반적인 검색 유형은 주어진 &lt;em&gt;검색어를&lt;/em&gt; 포함하는 모든 문서를 찾아서 해당 &lt;em&gt;검색어&lt;/em&gt; 와 &lt;em&gt;유사한&lt;/em&gt; 순서로 반환하는 것입니다 . &lt;code&gt;query&lt;/code&gt; 와 &lt;code&gt;similarity&lt;/code&gt; 개념 은 매우 유연하며 특정 응용 프로그램에 따라 다릅니다. 가장 간단한 검색은 &lt;code&gt;query&lt;/code&gt; 를 단어 집합으로 간주 하고 문서의 쿼리 단어 빈도 와 &lt;code&gt;similarity&lt;/code&gt; 을 고려 합니다 .</target>
        </trans-unit>
        <trans-unit id="db82b334faa95ac9dd9f6513348aba4908da1917" translate="yes" xml:space="preserve">
          <source>Full knowledge of running transactions is required before snapshots can be taken. Transactions that use large numbers of subtransactions (currently greater than 64) will delay the start of read only connections until the completion of the longest running write transaction. If this situation occurs, explanatory messages will be sent to the server log.</source>
          <target state="translated">스냅 샷을 작성하려면 트랜잭션 실행에 대한 모든 지식이 필요합니다. 많은 수의 서브 트랜잭션 (현재 64보다 큰)을 사용하는 트랜잭션은 가장 오래 실행되는 쓰기 트랜잭션이 완료 될 때까지 읽기 전용 연결 시작을 지연시킵니다. 이 상황이 발생하면 설명 메시지가 서버 로그로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4e89b5598c4c2f96620f236425e65a764b4e0c" translate="yes" xml:space="preserve">
          <source>Full path name of the configuration file</source>
          <target state="translated">구성 파일의 전체 경로 이름</target>
        </trans-unit>
        <trans-unit id="f75d588686a67b50b8825a6ec9a2cd0fa788d6f1" translate="yes" xml:space="preserve">
          <source>Full text indexing allows documents to be &lt;em&gt;preprocessed&lt;/em&gt; and an index saved for later rapid searching. Preprocessing includes:</source>
          <target state="translated">전체 텍스트 인덱싱을 통해 문서를 &lt;em&gt;사전 처리&lt;/em&gt; 하고 나중에 빠른 검색을 위해 인덱스를 저장할 수 있습니다 . 전처리에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1e173192dc3f0eff1cb3f86ab840c4e44f26a1a2" translate="yes" xml:space="preserve">
          <source>Full text searching in PostgreSQL is based on the match operator &lt;code&gt;@@&lt;/code&gt;, which returns &lt;code&gt;true&lt;/code&gt; if a &lt;code&gt;tsvector&lt;/code&gt; (document) matches a &lt;code&gt;tsquery&lt;/code&gt; (query). It doesn't matter which data type is written first:</source>
          <target state="translated">PostgreSQL에서 전체 텍스트 검색은 일치 연산자 &lt;code&gt;@@&lt;/code&gt; 을 기반으로하며 , &lt;code&gt;tsvector&lt;/code&gt; (문서)가 &lt;code&gt;tsquery&lt;/code&gt; (쿼리) 와 일치하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 어떤 데이터 유형이 먼저 작성되는지는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31ad0600481ef9dcfec15d2c9583987bbeea5538" translate="yes" xml:space="preserve">
          <source>Full time zone name</source>
          <target state="translated">정규 시간대 이름</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="199b395518a17474f39a98683e459c8710d22bf0" translate="yes" xml:space="preserve">
          <source>Function (degrees)</source>
          <target state="translated">기능 (도)</target>
        </trans-unit>
        <trans-unit id="c4cdc4b98800828d365361d7093d5e13c470e528" translate="yes" xml:space="preserve">
          <source>Function (radians)</source>
          <target state="translated">기능 (라디안)</target>
        </trans-unit>
        <trans-unit id="f20152848a0a27fa254ba49727fe94ca837e87e8" translate="yes" xml:space="preserve">
          <source>Function (routine)</source>
          <target state="translated">Function (routine)</target>
        </trans-unit>
        <trans-unit id="e3ebe4e72fe78109751ae6020102e21b46343c0b" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;concat_lower_or_upper&lt;/code&gt; has two mandatory parameters, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Additionally there is one optional parameter &lt;code&gt;uppercase&lt;/code&gt; which defaults to &lt;code&gt;false&lt;/code&gt;. The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; inputs will be concatenated, and forced to either upper or lower case depending on the &lt;code&gt;uppercase&lt;/code&gt; parameter. The remaining details of this function definition are not important here (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt; for more information).</source>
          <target state="translated">&lt;code&gt;concat_lower_or_upper&lt;/code&gt; 함수 에는 두 개의 필수 매개 변수 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 가 있습니다. 또한 기본적으로 &lt;code&gt;false&lt;/code&gt; 로 설정 되는 선택적 매개 변수 &lt;code&gt;uppercase&lt;/code&gt; 가 있습니다. 및 &lt;code&gt;b&lt;/code&gt; 입력 연접하고, 상하 방향 어느 쪽의 케이스에 따라 강제한다 &lt;code&gt;uppercase&lt;/code&gt; 파라미터. 이 함수 정의의 나머지 세부 사항은 여기서 중요하지 않습니다 ( 자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;37 장&lt;/a&gt; 참조 ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2af2dc6af90c7c987875d7c9624eadd9b65f4d37" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;concat_lower_or_upper&lt;/code&gt; has two mandatory parameters, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Additionally there is one optional parameter &lt;code&gt;uppercase&lt;/code&gt; which defaults to &lt;code&gt;false&lt;/code&gt;. The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; inputs will be concatenated, and forced to either upper or lower case depending on the &lt;code&gt;uppercase&lt;/code&gt; parameter. The remaining details of this function definition are not important here (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend.html&quot;&gt;Chapter 37&lt;/a&gt; for more information).</source>
          <target state="translated">Function &lt;code&gt;concat_lower_or_upper&lt;/code&gt; has two mandatory parameters, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; . Additionally there is one optional parameter &lt;code&gt;uppercase&lt;/code&gt; which defaults to &lt;code&gt;false&lt;/code&gt; . The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; inputs will be concatenated, and forced to either upper or lower case depending on the &lt;code&gt;uppercase&lt;/code&gt; parameter. The remaining details of this function definition are not important here (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend.html&quot;&gt;Chapter 37&lt;/a&gt; for more information).</target>
        </trans-unit>
        <trans-unit id="a9485768ec808a8458b8061522775420e2a0d736" translate="yes" xml:space="preserve">
          <source>Function Calls in &lt;code&gt;FROM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 에서 함수 호출</target>
        </trans-unit>
        <trans-unit id="5cd7aa6580361c1c90294750468e2a6e5d51165d" translate="yes" xml:space="preserve">
          <source>Function Security</source>
          <target state="translated">기능 보안</target>
        </trans-unit>
        <trans-unit id="307d58da1cb5c708acf50f78b41a528827c81cf8" translate="yes" xml:space="preserve">
          <source>Function calls</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="8b07e5d5a0f30facf481faff6183bfd24366f034" translate="yes" xml:space="preserve">
          <source>Function calls can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. When the optional &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is added to the function call, a new column is appended after all the function's output columns with numbering for each row.</source>
          <target state="translated">함수 호출은 &lt;code&gt;FROM&lt;/code&gt; 절에 나타날 수 있습니다 . (결과 세트를 리턴하는 함수에 특히 유용하지만 모든 함수를 사용할 수 있습니다.) 이는 단일 &lt;code&gt;SELECT&lt;/code&gt; 명령 이 지속되는 동안 함수의 출력이 임시 테이블로 작성된 것처럼 작동합니다 . 선택적 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 절이 함수 호출에 추가되면 모든 행의 번호가 지정된 모든 함수의 출력 열 뒤에 새 열이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b4946fa700c9eda6e438f9d998236ae26798c94a" translate="yes" xml:space="preserve">
          <source>Function is a security definer (i.e., a &amp;ldquo;setuid&amp;rdquo; function)</source>
          <target state="translated">함수는 보안 정의 자입니다 (예 : &quot;setuid&quot;함수)</target>
        </trans-unit>
        <trans-unit id="716c6238c1da557cf03815f10e855bae3322359c" translate="yes" xml:space="preserve">
          <source>Function returns a set (i.e., multiple values of the specified data type)</source>
          <target state="translated">함수는 집합 (예 : 지정된 데이터 유형의 여러 값)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23fbe0cb5a01469d890d631e094cc17384405a30" translate="yes" xml:space="preserve">
          <source>Function returns null if any call argument is null. In that case the function won't actually be called at all. Functions that are not &amp;ldquo;strict&amp;rdquo; must be prepared to handle null inputs.</source>
          <target state="translated">호출 인수가 널이면 함수는 널을 리턴합니다. 이 경우 함수가 실제로 호출되지 않습니다. &quot;엄격한&quot;기능이 아닌 함수는 널 입력을 처리하도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fd90f4b1717187c9f3e3d19223db85d2f734625" translate="yes" xml:space="preserve">
          <source>Function that implements this operator</source>
          <target state="translated">이 연산자를 구현하는 함수</target>
        </trans-unit>
        <trans-unit id="3d160cc011b485e39a85d5d485371501ec7cfb5f" translate="yes" xml:space="preserve">
          <source>Function's local settings for run-time configuration variables</source>
          <target state="translated">런타임 구성 변수에 대한 기능의 로컬 설정</target>
        </trans-unit>
        <trans-unit id="ec496000534b307fd515f93c3bf982f8043b1486" translate="yes" xml:space="preserve">
          <source>Function/Operator</source>
          <target state="translated">Function/Operator</target>
        </trans-unit>
        <trans-unit id="72f655d0260fed163ce26bf8c073ff029ead93e0" translate="yes" xml:space="preserve">
          <source>Functional Dependencies</source>
          <target state="translated">기능적 의존성</target>
        </trans-unit>
        <trans-unit id="6538b8b49394fd4058eb032b1ed6c7549c5fd8b9" translate="yes" xml:space="preserve">
          <source>Functional dependencies are currently only applied when considering simple equality conditions that compare columns to constant values, and &lt;code&gt;IN&lt;/code&gt; clauses with constant values. They are not used to improve estimates for equality conditions comparing two columns or comparing a column to an expression, nor for range clauses, &lt;code&gt;LIKE&lt;/code&gt; or any other type of condition.</source>
          <target state="translated">Functional dependencies are currently only applied when considering simple equality conditions that compare columns to constant values, and &lt;code&gt;IN&lt;/code&gt; clauses with constant values. They are not used to improve estimates for equality conditions comparing two columns or comparing a column to an expression, nor for range clauses, &lt;code&gt;LIKE&lt;/code&gt; or any other type of condition.</target>
        </trans-unit>
        <trans-unit id="5ff8dd38721f013a6f2f4a7b0736888d581a5d95" translate="yes" xml:space="preserve">
          <source>Functional dependencies are currently only applied when considering simple equality conditions that compare columns to constant values. They are not used to improve estimates for equality conditions comparing two columns or comparing a column to an expression, nor for range clauses, &lt;code&gt;LIKE&lt;/code&gt; or any other type of condition.</source>
          <target state="translated">함수 종속성은 현재 열을 상수 값과 비교하는 단순 동등 조건을 고려할 때만 적용됩니다. 두 열을 비교하거나 열을 식과 비교하는 등가 조건이나 범위 절, &lt;code&gt;LIKE&lt;/code&gt; 또는 다른 유형의 조건에 대한 추정값을 개선하는 데 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c1d8fc0143ef31c2eddcaedc63b8975839dcb0a6" translate="yes" xml:space="preserve">
          <source>Functional dependency statistics</source>
          <target state="translated">기능적 의존성 통계</target>
        </trans-unit>
        <trans-unit id="66e4b5d56651ee62066b47e8179cf0572f0a44de" translate="yes" xml:space="preserve">
          <source>Functional dependency statistics, serialized as &lt;code&gt;pg_dependencies&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;pg_dependencies&lt;/code&gt; 유형으로 직렬화되는 기능 종속성 통계</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="2ef4610dd144f45355b17173e115381a509a4ae6" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;get_byte&lt;/code&gt; and &lt;code&gt;set_byte&lt;/code&gt; number the first byte of a binary string as byte 0. Functions &lt;code&gt;get_bit&lt;/code&gt; and &lt;code&gt;set_bit&lt;/code&gt; number bits from the right within each byte; for example bit 0 is the least significant bit of the first byte, and bit 15 is the most significant bit of the second byte.</source>
          <target state="translated">Functions &lt;code&gt;get_byte&lt;/code&gt; and &lt;code&gt;set_byte&lt;/code&gt; number the first byte of a binary string as byte 0. Functions &lt;code&gt;get_bit&lt;/code&gt; and &lt;code&gt;set_bit&lt;/code&gt; number bits from the right within each byte; for example bit 0 is the least significant bit of the first byte, and bit 15 is the most significant bit of the second byte.</target>
        </trans-unit>
        <trans-unit id="4bc6ed2a77aad7bfa2b82a40e38f2ba52fbf90bc" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt; are available for adjusting days and hours that overflow their normal ranges.</source>
          <target state="translated">&lt;code&gt;justify_days&lt;/code&gt; 및 &lt;code&gt;justify_hours&lt;/code&gt; 함수 는 정상 범위를 초과하는 요일 및 시간을 조정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be003abde8f2ab71ad33e1cc06ea3dd303feedda" translate="yes" xml:space="preserve">
          <source>Functions and Operators</source>
          <target state="translated">함수와 연산자</target>
        </trans-unit>
        <trans-unit id="c65bb1eea1a55d451d6926238ca1817228c00025" translate="yes" xml:space="preserve">
          <source>Functions and aggregates must be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; if they write to the database, access sequences, change the transaction state even temporarily (e.g. a PL/pgSQL function which establishes an &lt;code&gt;EXCEPTION&lt;/code&gt; block to catch errors), or make persistent changes to settings. Similarly, functions must be marked &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize across workers. For example, &lt;code&gt;setseed&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; are parallel restricted for this last reason.</source>
          <target state="translated">함수 및 집계는 데이터베이스에 쓰거나 시퀀스에 액세스하거나 트랜잭션 상태를 일시적으로 변경하더라도 (예 : 오류를 포착하기 위해 &lt;code&gt;EXCEPTION&lt;/code&gt; 블록을 설정하는 PL / pgSQL 함수 ) 설정을 영구적으로 변경하는 경우 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 로 표시되어야합니다 . 마찬가지로, 함수가 시스템에서 작업자간에 동기화 할 수없는 임시 테이블, 클라이언트 연결 상태, 커서, 준비된 명령문 또는 기타 백엔드 로컬 상태에 액세스하는 경우 함수는 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 로 표시되어야합니다 . 예를 들어 &lt;code&gt;setseed&lt;/code&gt; 및 &lt;code&gt;random&lt;/code&gt; 은이 마지막 이유로 병렬 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="7d1d2a2fe42ec99a70594ecc07d4bafedfeedcc6" translate="yes" xml:space="preserve">
          <source>Functions and aggregates must be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; if they write to the database, access sequences, change the transaction state even temporarily (e.g., a PL/pgSQL function which establishes an &lt;code&gt;EXCEPTION&lt;/code&gt; block to catch errors), or make persistent changes to settings. Similarly, functions must be marked &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize across workers. For example, &lt;code&gt;setseed&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; are parallel restricted for this last reason.</source>
          <target state="translated">Functions and aggregates must be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; if they write to the database, access sequences, change the transaction state even temporarily (e.g., a PL/pgSQL function which establishes an &lt;code&gt;EXCEPTION&lt;/code&gt; block to catch errors), or make persistent changes to settings. Similarly, functions must be marked &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize across workers. For example, &lt;code&gt;setseed&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; are parallel restricted for this last reason.</target>
        </trans-unit>
        <trans-unit id="2fe9555fcfd38cd02c2b84229962727f96f4f2eb" translate="yes" xml:space="preserve">
          <source>Functions and most operators return &lt;code&gt;NULL&lt;/code&gt; on &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">함수와 대부분의 연산자 는 &lt;code&gt;NULL&lt;/code&gt; 입력 에서 NULL을 반환 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f265f85b070748c539b48bb2df1919c8d0132ab" translate="yes" xml:space="preserve">
          <source>Functions and operators that can be used in filter expressions are listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;Table 9.49&lt;/a&gt;. The path evaluation result to be filtered is denoted by the &lt;code&gt;@&lt;/code&gt; variable. To refer to a JSON element stored at a lower nesting level, add one or more accessor operators after &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">필터 표현식에 사용할 수있는 함수와 연산자는 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;표 9.49에&lt;/a&gt; 나열되어 있습니다. 필터링 될 경로 평가 결과는 &lt;code&gt;@&lt;/code&gt; 변수 로 표시됩니다 . 하위 중첩 수준에 저장된 JSON 요소를 참조하려면 &lt;code&gt;@&lt;/code&gt; 뒤에 하나 이상의 접근 자 연산자를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="898ae4ce80d1416da1e82be5528ff4ee3420d0cc" translate="yes" xml:space="preserve">
          <source>Functions are provided to support input in latitude and longitude (in degrees), to support output of latitude and longitude, to calculate the great circle distance between two points and to easily specify a bounding box usable for index searches.</source>
          <target state="translated">위도와 경도 입력을 지원하고 위도와 경도의 출력을 지원하고 두 점 사이의 큰 원거리를 계산하고 인덱스 검색에 사용할 수있는 경계 상자를 쉽게 지정할 수있는 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bab4610ff64d803d4f4e2ad2f2b59a748f8c7899" translate="yes" xml:space="preserve">
          <source>Functions can also be used for &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;triggers&lt;/a&gt; to invoke.</source>
          <target state="translated">Functions can also be used for &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;triggers&lt;/a&gt; to invoke.</target>
        </trans-unit>
        <trans-unit id="363d6f73b8773f17e3ee7b55c329af36a576dd3e" translate="yes" xml:space="preserve">
          <source>Functions coded in C (whether built-in or dynamically loaded) can be declared to accept or return any of these pseudo data types. It is up to the function author to ensure that the function will behave safely when a pseudo-type is used as an argument type.</source>
          <target state="translated">C로 코딩 된 함수 (내장 또는 동적로드 여부)는 이러한 의사 데이터 유형을 승인하거나 리턴하도록 선언 될 수 있습니다. 의사 유형이 인수 유형으로 사용될 때 함수가 안전하게 작동하도록하는 것은 함수 작성자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="e75c7dde792e62f93784e745daa34244d2b25079" translate="yes" xml:space="preserve">
          <source>Functions coded in C (whether built-in or dynamically loaded) can be declared to accept or return any of these pseudo-types. It is up to the function author to ensure that the function will behave safely when a pseudo-type is used as an argument type.</source>
          <target state="translated">Functions coded in C (whether built-in or dynamically loaded) can be declared to accept or return any of these pseudo-types. It is up to the function author to ensure that the function will behave safely when a pseudo-type is used as an argument type.</target>
        </trans-unit>
        <trans-unit id="04ca6b1f3b45b7dfbecfbb5e57babd0db8514f38" translate="yes" xml:space="preserve">
          <source>Functions coded in procedural languages can use pseudo-types only as allowed by their implementation languages. At present most procedural languages forbid use of a pseudo-type as an argument type, and allow only &lt;code&gt;void&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; as a result type (plus &lt;code&gt;trigger&lt;/code&gt; or &lt;code&gt;event_trigger&lt;/code&gt; when the function is used as a trigger or event trigger). Some also support polymorphic functions using the polymorphic pseudo-types, which are shown above and discussed in detail in &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;.</source>
          <target state="translated">Functions coded in procedural languages can use pseudo-types only as allowed by their implementation languages. At present most procedural languages forbid use of a pseudo-type as an argument type, and allow only &lt;code&gt;void&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; as a result type (plus &lt;code&gt;trigger&lt;/code&gt; or &lt;code&gt;event_trigger&lt;/code&gt; when the function is used as a trigger or event trigger). Some also support polymorphic functions using the polymorphic pseudo-types, which are shown above and discussed in detail in &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="357d435e84354e072901789e999d5e8184ddfdf6" translate="yes" xml:space="preserve">
          <source>Functions coded in procedural languages can use pseudo-types only as allowed by their implementation languages. At present most procedural languages forbid use of a pseudo-type as an argument type, and allow only &lt;code&gt;void&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; as a result type (plus &lt;code&gt;trigger&lt;/code&gt; or &lt;code&gt;event_trigger&lt;/code&gt; when the function is used as a trigger or event trigger). Some also support polymorphic functions using the types &lt;code&gt;anyelement&lt;/code&gt;, &lt;code&gt;anyarray&lt;/code&gt;, &lt;code&gt;anynonarray&lt;/code&gt;, &lt;code&gt;anyenum&lt;/code&gt;, and &lt;code&gt;anyrange&lt;/code&gt;.</source>
          <target state="translated">절차 언어로 코딩 된 함수는 구현 언어에서 허용하는 의사 유형 만 사용할 수 있습니다. 현재 대부분의 절차 언어는 의사 유형을 인수 유형으로 사용하는 것을 금지 하고 결과 유형 ( 함수가 트리거 또는 이벤트 트리거로 사용되는 경우 &lt;code&gt;trigger&lt;/code&gt; 또는 &lt;code&gt;event_trigger&lt;/code&gt; ) 으로 &lt;code&gt;void&lt;/code&gt; 및 &lt;code&gt;record&lt;/code&gt; 만 허용합니다 . 일부는 &lt;code&gt;anyelement&lt;/code&gt; , &lt;code&gt;anyarray&lt;/code&gt; , &lt;code&gt;anynonarray&lt;/code&gt; , &lt;code&gt;anyenum&lt;/code&gt; 및 &lt;code&gt;anyrange&lt;/code&gt; 유형을 사용하여 다형성 함수를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="99ae93c6cb1d152d9259b18ff6ab4fe6a95f0f1e" translate="yes" xml:space="preserve">
          <source>Functions for converting strings between different character sets (encodings), and for representing arbitrary binary data in textual form, are shown in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-CONVERSIONS&quot;&gt;Table 9.13&lt;/a&gt;. For these functions, an argument or result of type &lt;code&gt;text&lt;/code&gt; is expressed in the database's default encoding, while arguments or results of type &lt;code&gt;bytea&lt;/code&gt; are in an encoding named by another argument.</source>
          <target state="translated">Functions for converting strings between different character sets (encodings), and for representing arbitrary binary data in textual form, are shown in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-CONVERSIONS&quot;&gt;Table 9.13&lt;/a&gt;. For these functions, an argument or result of type &lt;code&gt;text&lt;/code&gt; is expressed in the database's default encoding, while arguments or results of type &lt;code&gt;bytea&lt;/code&gt; are in an encoding named by another argument.</target>
        </trans-unit>
        <trans-unit id="4a3e904c1371583b52ebdd3a3d3f52a9437f4a8d" translate="yes" xml:space="preserve">
          <source>Functions run inside the backend server process with the operating system permissions of the database server daemon. If the programming language used for the function allows unchecked memory accesses, it is possible to change the server's internal data structures. Hence, among many other things, such functions can circumvent any system access controls. Function languages that allow such access are considered &amp;ldquo;untrusted&amp;rdquo;, and PostgreSQL allows only superusers to create functions written in those languages.</source>
          <target state="translated">함수는 데이터베이스 서버 디먼의 운영 체제 권한으로 백엔드 서버 프로세스 내에서 실행됩니다. 함수에 사용 된 프로그래밍 언어가 검사되지 않은 메모리 액세스를 허용하는 경우 서버의 내부 데이터 구조를 변경할 수 있습니다. 따라서, 많은 다른 것들 중에서도, 그러한 기능들은 모든 시스템 액세스 제어를 우회 할 수있다. 이러한 액세스를 허용하는 함수 언어는 &quot;신뢰할 수없는&quot;것으로 간주되며 PostgreSQL에서는 수퍼 유저 만 해당 언어로 작성된 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="425b58ada88d6e2c4cd54b7ad94f94b6cfbbbdae" translate="yes" xml:space="preserve">
          <source>Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub-transactions, or if they access sequences or attempt to make persistent changes to settings (e.g. &lt;code&gt;setval&lt;/code&gt;). They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize in parallel mode (e.g. &lt;code&gt;setseed&lt;/code&gt; cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader). In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, functions should be labeled as &lt;code&gt;UNSAFE&lt;/code&gt;, which is the default.</source>
          <target state="translated">함수는 데이터베이스 상태를 수정하거나 서브 트랜잭션 사용과 같이 트랜잭션을 변경하거나 시퀀스에 액세스하거나 설정을 지속적으로 변경하려는 경우 (예 : &lt;code&gt;setval&lt;/code&gt; ) 병렬 안전하지 않은 레이블로 표시해야합니다 . 시스템이 병렬 모드에서 동기화 할 수없는 임시 테이블, 클라이언트 연결 상태, 커서, 준비된 명령문 또는 기타 백엔드 로컬 상태에 액세스하는 경우 병렬 제한으로 레이블되어야합니다 (예 : &lt;code&gt;setseed&lt;/code&gt; ).다른 프로세스에서 변경 한 내용은 리더에 반영되지 않으므로 그룹 리더가 아닌 다른 사람은 실행할 수 없습니다. 일반적으로 함수가 제한되거나 안전하지 않을 때 안전하다고 레이블이 지정되거나 실제로 안전하지 않을 때 제한됨으로 레이블이 지정되면 병렬 쿼리에 사용될 때 오류가 발생하거나 잘못된 응답을 생성 할 수 있습니다. 시스템이 임의의 C 코드로부터 자신을 보호 할 방법이 없기 때문에 C 언어 함수는 이론적으로 잘못 레이블이 지정되면 완전히 정의되지 않은 동작을 나타낼 수 있지만, 대부분의 경우 결과는 다른 함수보다 나쁘지 않습니다. &lt;code&gt;UNSAFE&lt;/code&gt; 하지 않은 경우, 함수는 UNSAFE 로 레이블되어야합니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ca99020631ecbd508e87c7482047eede97742a02" translate="yes" xml:space="preserve">
          <source>Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub-transactions, or if they access sequences or attempt to make persistent changes to settings (e.g., &lt;code&gt;setval&lt;/code&gt;). They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize in parallel mode (e.g., &lt;code&gt;setseed&lt;/code&gt; cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader). In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, functions should be labeled as &lt;code&gt;UNSAFE&lt;/code&gt;, which is the default.</source>
          <target state="translated">Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub-transactions, or if they access sequences or attempt to make persistent changes to settings (e.g., &lt;code&gt;setval&lt;/code&gt; ). They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize in parallel mode (e.g., &lt;code&gt;setseed&lt;/code&gt; cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader). In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, functions should be labeled as &lt;code&gt;UNSAFE&lt;/code&gt; , which is the default.</target>
        </trans-unit>
        <trans-unit id="b84230860ab5761ae6c39a0cf038afa0e0d25690" translate="yes" xml:space="preserve">
          <source>Functions that display information about &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; bits are much more costly than those that only consult the visibility map, because they must read the relation's data blocks rather than only the (much smaller) visibility map. Functions that check the relation's data blocks are similarly expensive.</source>
          <target state="translated">&lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; 비트 에 대한 정보를 표시하는 함수 는 가시성 맵만 참조하는 것보다 훨씬 비쌉니다. 가시성 맵이 아닌 관계형 데이터 블록을 읽어야하기 때문입니다. 관계의 데이터 블록을 검사하는 함수도 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="bdbee713b789a01d106896990329fe65f45aec42" translate="yes" xml:space="preserve">
          <source>Functions that have default values for parameters are considered to match any call that omits zero or more of the defaultable parameter positions. If more than one such function matches a call, the one appearing earliest in the search path is used. If there are two or more such functions in the same schema with identical parameter types in the non-defaulted positions (which is possible if they have different sets of defaultable parameters), the system will not be able to determine which to prefer, and so an &amp;ldquo;ambiguous function call&amp;rdquo; error will result if no better match to the call can be found.</source>
          <target state="translated">매개 변수의 기본값이있는 함수는 0 개 이상의 기본 매개 변수 위치를 생략하는 모든 호출과 일치하는 것으로 간주됩니다. 이러한 기능이 둘 이상 호출과 일치하면 검색 경로에서 가장 빠른 기능이 사용됩니다. 기본값이 아닌 위치에서 동일한 매개 변수 유형을 가진 동일한 스키마에 두 개 이상의 이러한 기능이있는 경우 (기본 매개 변수의 다른 세트가있는 경우 가능) 시스템이 선호하는 기능을 결정할 수 없습니다. &quot;모호한 함수 호출&quot;오류는 호출과 더 일치하는 항목을 찾을 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="968a1bb51fb8e88d31fbc6fa43c7108e8557e4b7" translate="yes" xml:space="preserve">
          <source>Functions that have different argument type lists will not be considered to conflict at creation time, but if defaults are provided they might conflict in use. For example, consider</source>
          <target state="translated">인수 유형 목록이 다른 함수는 작성시 충돌하는 것으로 간주되지 않지만 기본값이 제공되면 사용 중에 충돌 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="135becd421fd7ec3a1d11031f3897f120bbd244e" translate="yes" xml:space="preserve">
          <source>Functions, triggers and row-level security policies allow users to insert code into the backend server that other users might execute unintentionally. Hence, these mechanisms permit users to &amp;ldquo;Trojan horse&amp;rdquo; others with relative ease. The strongest protection is tight control over who can define objects. Where that is infeasible, write queries referring only to objects having trusted owners. Remove from &lt;code&gt;search_path&lt;/code&gt; the public schema and any other schemas that permit untrusted users to create objects.</source>
          <target state="translated">기능, 트리거 및 행 수준 보안 정책을 통해 사용자는 다른 사용자가 실수로 실행할 수있는 코드를 백엔드 서버에 삽입 할 수 있습니다. 따라서 이러한 메커니즘을 통해 사용자는 다른 사람을 비교적 쉽게 &quot;트로이 목마&quot;로 만들 수 있습니다. 가장 강력한 보호는 객체를 정의 할 수있는 사람을 엄격하게 제어하는 ​​것입니다. 그것이 불가능한 경우, 신뢰할 수있는 소유자를 가진 객체만을 참조하는 쿼리를 작성하십시오. 신뢰할 수없는 사용자가 오브젝트를 작성할 수있게하는 공용 스키마 및 기타 스키마를 &lt;code&gt;search_path&lt;/code&gt; 에서 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="5108d609f3fb07622f5f3d1be40ac26ef2e0a0a8" translate="yes" xml:space="preserve">
          <source>Functions: Aggregate</source>
          <target state="translated">함수 : 집계</target>
        </trans-unit>
        <trans-unit id="64682352d164f9b71b9cd241b5b867b131e9918f" translate="yes" xml:space="preserve">
          <source>Functions: Array</source>
          <target state="translated">기능 : 배열</target>
        </trans-unit>
        <trans-unit id="a17a5cd5398272b5c3db6c42f415d4231dc9dd50" translate="yes" xml:space="preserve">
          <source>Functions: Binary String</source>
          <target state="translated">함수 : 이진 문자열</target>
        </trans-unit>
        <trans-unit id="46e7b932a583771eba0b904ed9f4220de160a130" translate="yes" xml:space="preserve">
          <source>Functions: Bit String</source>
          <target state="translated">함수 : 비트 문자열</target>
        </trans-unit>
        <trans-unit id="106e142aa5e330cde3a84b7b845817b28d2e9175" translate="yes" xml:space="preserve">
          <source>Functions: Data Type Formatting</source>
          <target state="translated">함수 : 데이터 형식</target>
        </trans-unit>
        <trans-unit id="bfefb2129f2304220f19e00946bdffaabf6dc0e1" translate="yes" xml:space="preserve">
          <source>Functions: Date/Time</source>
          <target state="translated">기능 : 날짜 / 시간</target>
        </trans-unit>
        <trans-unit id="9b63eb1b87b1e024896cd43589c27f090399d066" translate="yes" xml:space="preserve">
          <source>Functions: Geometric</source>
          <target state="translated">기능 : 기하</target>
        </trans-unit>
        <trans-unit id="4d3dafd3b51e63a124d63c626067bce30229ab1f" translate="yes" xml:space="preserve">
          <source>Functions: JSON</source>
          <target state="translated">기능 : JSON</target>
        </trans-unit>
        <trans-unit id="9b518a3dc41009e3acee3808ac0e704f6b08a5f3" translate="yes" xml:space="preserve">
          <source>Functions: Mathematical</source>
          <target state="translated">함수 : 수학</target>
        </trans-unit>
        <trans-unit id="a9c0c6a0475c27e5bdfe98492ed642ea26c29174" translate="yes" xml:space="preserve">
          <source>Functions: Network Address</source>
          <target state="translated">기능 : 네트워크 주소</target>
        </trans-unit>
        <trans-unit id="a4976494155f4e6dade31fdc069e51f1a7d1ce69" translate="yes" xml:space="preserve">
          <source>Functions: Range</source>
          <target state="translated">기능 : 범위</target>
        </trans-unit>
        <trans-unit id="b8fcb9bba13dc3a8cc6d595a39daf47631d430a4" translate="yes" xml:space="preserve">
          <source>Functions: Statistics Information</source>
          <target state="translated">함수 : 통계 정보</target>
        </trans-unit>
        <trans-unit id="d1ee22b179879e9f873763bb172d33f3017f840e" translate="yes" xml:space="preserve">
          <source>Functions: String</source>
          <target state="translated">함수 : 문자열</target>
        </trans-unit>
        <trans-unit id="6843fcead53a6cf24daa8566fecd89162ab37e7f" translate="yes" xml:space="preserve">
          <source>Functions: System Administration</source>
          <target state="translated">기능 : 시스템 관리</target>
        </trans-unit>
        <trans-unit id="a388797fbe7fca428c186d9bd0e36003dc121806" translate="yes" xml:space="preserve">
          <source>Functions: System Information</source>
          <target state="translated">기능 : 시스템 정보</target>
        </trans-unit>
        <trans-unit id="6774bc067b00b4a898fa2d81854d9f8ccd1bb6e9" translate="yes" xml:space="preserve">
          <source>Functions: Text Search</source>
          <target state="translated">기능 : 텍스트 검색</target>
        </trans-unit>
        <trans-unit id="ce981f4dc8ac16f802c8f14bef565b7c26ef8014" translate="yes" xml:space="preserve">
          <source>Functions: UUID</source>
          <target state="translated">Functions: UUID</target>
        </trans-unit>
        <trans-unit id="1acb35ad39f3bcd2faf73955c2408efc740b8965" translate="yes" xml:space="preserve">
          <source>Functions: Window</source>
          <target state="translated">기능 : 창</target>
        </trans-unit>
        <trans-unit id="4ea9b0534343b6662064e8e66df29f936486dcbe" translate="yes" xml:space="preserve">
          <source>Functions: XML</source>
          <target state="translated">함수 : XML</target>
        </trans-unit>
        <trans-unit id="be1881053687afed29c0ae862b5bb84c66f949f7" translate="yes" xml:space="preserve">
          <source>Further along the line of common sense, the fuzziness of the limits suggests that the use of traditional numeric data types leads to a certain loss of information. Consider this: your instrument reads 6.50, and you input this reading into the database. What do you get when you fetch it? Watch:</source>
          <target state="translated">또한 상식에 따라 한계의 어리 석음은 전통적인 숫자 데이터 유형을 사용하면 특정 정보가 손실됨을 나타냅니다. 이것을 고려하십시오 : 계측기는 6.50을 읽고이 판독 값을 데이터베이스에 입력합니다. 가져 오면 무엇을 얻습니까? 손목 시계:</target>
        </trans-unit>
        <trans-unit id="e2310579f06e5c7b30a8aa96bc1d602f5e9203e6" translate="yes" xml:space="preserve">
          <source>Further assumptions are that the aggregate ignores null inputs, and that it delivers a null result if and only if there were no non-null inputs. Ordinarily, a data type's &lt;code&gt;&amp;lt;&lt;/code&gt; operator is the proper sort operator for &lt;code&gt;MIN&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt; is the proper sort operator for &lt;code&gt;MAX&lt;/code&gt;. Note that the optimization will never actually take effect unless the specified operator is the &amp;ldquo;less than&amp;rdquo; or &amp;ldquo;greater than&amp;rdquo; strategy member of a B-tree index operator class.</source>
          <target state="translated">추가 가정은 집계가 널 입력을 무시하고 널이 아닌 입력이없는 경우에만 널 결과를 전달한다고 가정합니다. 일반적으로 데이터 유형의 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자는 &lt;code&gt;MIN&lt;/code&gt; 에 대한 적절한 정렬 연산자 이고 &lt;code&gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;MAX&lt;/code&gt; 에 대한 적절한 정렬 연산자입니다 . 지정된 연산자가 B- 트리 인덱스 연산자 클래스의 &quot;보다 작음&quot;또는 &quot;보다 큼&quot;전략 구성원이 아니면 최적화가 실제로 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e3fde8eb12ee9830b9efa317f6db1a2760019c3" translate="yes" xml:space="preserve">
          <source>Further details about the planner's use of statistics can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt;.</source>
          <target state="translated">플래너의 통계 사용에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;70 장&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65f251a5bf245d188901a7cc3757ef7e35aa3e2d" translate="yes" xml:space="preserve">
          <source>Further details about the planner's use of statistics can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt;.</source>
          <target state="translated">Further details about the planner's use of statistics can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="80923ff08a3698b44c0358905326ad4315d1f3f8" translate="yes" xml:space="preserve">
          <source>Furthermore, although multiple sessions are guaranteed to allocate distinct sequence values, the values might be generated out of sequence when all the sessions are considered. For example, with a &lt;code&gt;cache&lt;/code&gt; setting of 10, session A might reserve values 1..10 and return &lt;code&gt;nextval&lt;/code&gt;=1, then session B might reserve values 11..20 and return &lt;code&gt;nextval&lt;/code&gt;=11 before session A has generated &lt;code&gt;nextval&lt;/code&gt;=2. Thus, with a &lt;code&gt;cache&lt;/code&gt; setting of one it is safe to assume that &lt;code&gt;nextval&lt;/code&gt; values are generated sequentially; with a &lt;code&gt;cache&lt;/code&gt; setting greater than one you should only assume that the &lt;code&gt;nextval&lt;/code&gt; values are all distinct, not that they are generated purely sequentially. Also, &lt;code&gt;last_value&lt;/code&gt; will reflect the latest value reserved by any session, whether or not it has yet been returned by &lt;code&gt;nextval&lt;/code&gt;.</source>
          <target state="translated">또한 여러 세션이 고유 한 시퀀스 값을 할당하도록 보장되지만 모든 세션이 고려 될 때 값이 시퀀스에서 생성되지 않을 수 있습니다. 예를 들어, &lt;code&gt;cache&lt;/code&gt; 설정이 10 인 경우 세션 A는 값 1..10을 예약하고 &lt;code&gt;nextval&lt;/code&gt; = 1을 반환 할 수 있고 세션 B는 값 11..20을 예약하고 세션 A가 &lt;code&gt;nextval&lt;/code&gt; = 2를 생성하기 전에 &lt;code&gt;nextval&lt;/code&gt; = 11을 반환 할 수 있습니다 . 따라서, 함께 &lt;code&gt;cache&lt;/code&gt; 하나의 설치는 것으로 가정하는 것이 안전 &lt;code&gt;nextval&lt;/code&gt; 값이 순차적으로 생성된다; 로모그래퍼 &lt;code&gt;cache&lt;/code&gt; 보다 설정보다 당신은 단지 가정한다 &lt;code&gt;nextval&lt;/code&gt; 값은 순차 순차로 생성되는 것이 아니라 모두 고유합니다. 또한 &lt;code&gt;last_value&lt;/code&gt; 는 아직 &lt;code&gt;nextval&lt;/code&gt; 에 의해 반환되었는지 여부에 관계없이 모든 세션에서 예약 한 최신 값을 반영합니다 .</target>
        </trans-unit>
        <trans-unit id="224c260c1b97921918028686f800ec2a753d6d99" translate="yes" xml:space="preserve">
          <source>Furthermore, if the result of an expression can be determined by evaluating only some parts of it, then other subexpressions might not be evaluated at all. For instance, if one wrote:</source>
          <target state="translated">또한 표현식의 일부만 평가하여 표현식의 결과를 판별 할 수 있으면 다른 하위 표현식이 전혀 평가되지 않을 수 있습니다. 예를 들어, 다음과 같이 쓴 경우 :</target>
        </trans-unit>
        <trans-unit id="c76baa18e3a105ad25a2e47745a365c732d219e6" translate="yes" xml:space="preserve">
          <source>Furthermore, immediately before reporting a uniqueness violation according to the above rules, the access method must recheck the liveness of the row being inserted. If it is committed dead then no violation should be reported. (This case cannot occur during the ordinary scenario of inserting a row that's just been created by the current transaction. It can happen during &lt;code&gt;CREATE UNIQUE INDEX CONCURRENTLY&lt;/code&gt;, however.)</source>
          <target state="translated">또한, 위의 규칙에 따라 고유성 위반을보고하기 직전에 액세스 방법은 삽입되는 행의 활성을 다시 확인해야합니다. 종료 된 경우 위반을보고하지 않아야합니다. (이 경우는 현재 트랜잭션에 의해 생성 된 행을 삽입하는 일반적인 시나리오에서는 발생할 수 없습니다. 그러나 &lt;code&gt;CREATE UNIQUE INDEX CONCURRENTLY&lt;/code&gt; 동안 발생할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="b247028066a34eb255cbd5a7c12a62f7ec515ba5" translate="yes" xml:space="preserve">
          <source>Furthermore, indexes for exclusion constraints cannot be reindexed concurrently. If such an index is named directly in this command, an error is raised. If a table or database with exclusion constraint indexes is reindexed concurrently, those indexes will be skipped. (It is possible to reindex such indexes without the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option.)</source>
          <target state="translated">또한 제외 제약 조건에 대한 인덱스는 동시에 다시 인덱싱 할 수 없습니다. 이 명령에서 이러한 색인의 이름을 직접 지정하면 오류가 발생합니다. 제외 제약 조건 인덱스가있는 테이블 또는 데이터베이스를 동시에 다시 인덱싱하면 해당 인덱스를 건너 뜁니다. &lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션을 사용 하지 않고도 이러한 색인을 다시 색인화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca37f367ca14421a51e0f4caacbc290fabee5387" translate="yes" xml:space="preserve">
          <source>Furthermore, the ordering is total; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">또한 주문은 총계입니다. 즉, 널이 아닌 모든 값 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="403e23f7e975f56f502368918f62f79a68fb24a2" translate="yes" xml:space="preserve">
          <source>Furthermore, the output of &lt;code&gt;JOIN USING&lt;/code&gt; suppresses redundant columns: there is no need to print both of the matched columns, since they must have equal values. While &lt;code&gt;JOIN ON&lt;/code&gt; produces all columns from &lt;code&gt;T1&lt;/code&gt; followed by all columns from &lt;code&gt;T2&lt;/code&gt;, &lt;code&gt;JOIN USING&lt;/code&gt; produces one output column for each of the listed column pairs (in the listed order), followed by any remaining columns from &lt;code&gt;T1&lt;/code&gt;, followed by any remaining columns from &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;JOIN USING&lt;/code&gt; 의 출력은 중복 열을 억제합니다. 일치하는 열을 모두 같은 값을 가져야하므로 인쇄 할 필요가 없습니다. 동안 &lt;code&gt;JOIN ON&lt;/code&gt; 생성 한 모든 열 &lt;code&gt;T1&lt;/code&gt; 은 모든 열 뒤에 &lt;code&gt;T2&lt;/code&gt; , &lt;code&gt;JOIN USING&lt;/code&gt; 에서 나머지 열 뒤에 (열거 된 순서대로) 나열된 열 쌍 각각에 대해 하나의 출력 열을 생성 &lt;code&gt;T1&lt;/code&gt; 에서 나머지 열 뒤에 &lt;code&gt;T2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e40a8533f467834ab1d55c9055f3d84061da31d" translate="yes" xml:space="preserve">
          <source>GEQO</source>
          <target state="translated">GEQO</target>
        </trans-unit>
        <trans-unit id="7c02cecaa08dd20b2878a0e9246d9afddbd1bfa9" translate="yes" xml:space="preserve">
          <source>GIN</source>
          <target state="translated">GIN</target>
        </trans-unit>
        <trans-unit id="ecc6a1db2685ccbd525e456602d8a531d64c012d" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Built-in Operator Classes</source>
          <target state="translated">GIN 인덱스 : 내장 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="df2283621762cf6fbe34492dd970bdc1a2fb8f2e" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Examples</source>
          <target state="translated">GIN 지수 : 예</target>
        </trans-unit>
        <trans-unit id="bcdb1f5984e5f5fc37ee2625a5e106b5ace38b47" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Extensibility</source>
          <target state="translated">GIN 지수 : 확장 성</target>
        </trans-unit>
        <trans-unit id="1f6ebc2a0d191b466ed9b8d366b380c7d0d18de4" translate="yes" xml:space="preserve">
          <source>GIN Indexes: GIN Tips and Tricks</source>
          <target state="translated">GIN 지수 : GIN 팁과 요령</target>
        </trans-unit>
        <trans-unit id="79cd3f5e4f5e10454468404b67550cb2d0ff11bb" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Implementation</source>
          <target state="translated">GIN 지수 : 구현</target>
        </trans-unit>
        <trans-unit id="bac90b5d133adfb4770f3d94ae6faf770a933f01" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Limitations</source>
          <target state="translated">GIN 지수 : 한계</target>
        </trans-unit>
        <trans-unit id="ece4291bbc12d9bc7ed3dfad4dd491c4406b75fd" translate="yes" xml:space="preserve">
          <source>GIN and GiST Index Types</source>
          <target state="translated">GIN 및 GiST 인덱스 유형</target>
        </trans-unit>
        <trans-unit id="838975c5a4d167bd2f6ce5e8ea900f60f03b2972" translate="yes" xml:space="preserve">
          <source>GIN assumes that indexable operators are strict. This means that &lt;code&gt;extractValue&lt;/code&gt; will not be called at all on a null item value (instead, a placeholder index entry is created automatically), and &lt;code&gt;extractQuery&lt;/code&gt; will not be called on a null query value either (instead, the query is presumed to be unsatisfiable). Note however that null key values contained within a non-null composite item or query value are supported.</source>
          <target state="translated">GIN은 색인 가능한 연산자가 엄격하다고 가정합니다. 즉 , &lt;code&gt;extractQuery&lt;/code&gt; 인덱스 항목이 자동으로 생성되는 대신 null 항목 값에서 &lt;code&gt;extractValue&lt;/code&gt; 가 전혀 호출 되지 않고 null 쿼리 값에서도 extractQuery 가 호출되지 않습니다 (대신 쿼리가 만족스럽지 않은 것으로 간주 됨) . 그러나 널이 아닌 복합 항목 또는 쿼리 값에 포함 된 널 키 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fe2b1de04947c2b348e8de70b6c2f63da721161b" translate="yes" xml:space="preserve">
          <source>GIN can support &amp;ldquo;partial match&amp;rdquo; queries, in which the query does not determine an exact match for one or more keys, but the possible matches fall within a reasonably narrow range of key values (within the key sorting order determined by the &lt;code&gt;compare&lt;/code&gt; support method). The &lt;code&gt;extractQuery&lt;/code&gt; method, instead of returning a key value to be matched exactly, returns a key value that is the lower bound of the range to be searched, and sets the &lt;code&gt;pmatch&lt;/code&gt; flag true. The key range is then scanned using the &lt;code&gt;comparePartial&lt;/code&gt; method. &lt;code&gt;comparePartial&lt;/code&gt; must return zero for a matching index key, less than zero for a non-match that is still within the range to be searched, or greater than zero if the index key is past the range that could match.</source>
          <target state="translated">GIN은 쿼리가 하나 이상의 키에 대한 정확한 일치를 결정하지 않지만 가능한 일치는 상당히 좁은 범위의 키 값 ( &lt;code&gt;compare&lt;/code&gt; 지원 방법에 의해 결정된 키 정렬 순서 내)에 속하는 &quot;부분 일치&quot;쿼리를 지원할 수 있습니다. ). &lt;code&gt;extractQuery&lt;/code&gt; 의 대신에 키 값을 되 돌리는 방법이 정확하게 일치하도록, 하부 검색 할 범위 바인딩 된 키 값을 반환하고, 세트 &lt;code&gt;pmatch&lt;/code&gt; 의 진정한 플래그. 그런 다음 &lt;code&gt;comparePartial&lt;/code&gt; 메소드를 사용하여 키 범위를 스캔합니다 . &lt;code&gt;comparePartial&lt;/code&gt; 일치하는 색인 ​​키의 경우 0을, 검색 할 범위 내에있는 비 일치의 경우 0보다 작거나, 색인 키가 일치 할 수있는 범위를 지나면 0보다 큰 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="614db4420feca405f38d8b066253c12c8348900b" translate="yes" xml:space="preserve">
          <source>GIN index extracts statements of following form out of &lt;code&gt;jsonpath&lt;/code&gt;: &lt;code&gt;accessors_chain&lt;/code&gt; = &lt;code&gt;const&lt;/code&gt;. Accessors chain may consist of &lt;code&gt;.key&lt;/code&gt;, &lt;code&gt;[*]&lt;/code&gt;, and &lt;code&gt;[index]&lt;/code&gt; accessors. &lt;code&gt;jsonb_ops&lt;/code&gt; additionally supports &lt;code&gt;.*&lt;/code&gt; and &lt;code&gt;.**&lt;/code&gt; accessors.</source>
          <target state="translated">GIN 색인은 &lt;code&gt;jsonpath&lt;/code&gt; 에서 다음 형식의 명령문을 추출합니다 . &lt;code&gt;accessors_chain&lt;/code&gt; = &lt;code&gt;const&lt;/code&gt; . 접근 자 체인은 &lt;code&gt;.key&lt;/code&gt; , &lt;code&gt;[*]&lt;/code&gt; 및 &lt;code&gt;[index]&lt;/code&gt; 접근 자로 구성 될 수 있습니다 . &lt;code&gt;jsonb_ops&lt;/code&gt; 는 &lt;code&gt;.*&lt;/code&gt; 및 &lt;code&gt;.**&lt;/code&gt; 접근 자를 추가로 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="45189d146afca1631f2530069592ce2a3f6f8758" translate="yes" xml:space="preserve">
          <source>GIN indexes</source>
          <target state="translated">진 지수</target>
        </trans-unit>
        <trans-unit id="b1817ec41a2b97676aa792c5a571f79e3047197e" translate="yes" xml:space="preserve">
          <source>GIN indexes accept different parameters:</source>
          <target state="translated">GIN 인덱스는 다른 매개 변수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9ae2afa12a8014fb0afa678aad4a0a6fdff0194f" translate="yes" xml:space="preserve">
          <source>GIN indexes are &amp;ldquo;inverted indexes&amp;rdquo; which are appropriate for data values that contain multiple component values, such as arrays. An inverted index contains a separate entry for each component value, and can efficiently handle queries that test for the presence of specific component values.</source>
          <target state="translated">GIN 인덱스는 배열과 같이 여러 구성 요소 값이 포함 된 데이터 값에 적합한 &quot;반전 인덱스&quot;입니다. 반전 된 색인에는 각 구성 요소 값에 대한 별도의 항목이 포함되며 특정 구성 요소 값이 있는지 테스트하는 쿼리를 효율적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6e3602f0fe2770a2e803379f390135df1f58a159" translate="yes" xml:space="preserve">
          <source>GIN indexes are the preferred text search index type. As inverted indexes, they contain an index entry for each word (lexeme), with a compressed list of matching locations. Multi-word searches can find the first match, then use the index to remove rows that are lacking additional words. GIN indexes store only the words (lexemes) of &lt;code&gt;tsvector&lt;/code&gt; values, and not their weight labels. Thus a table row recheck is needed when using a query that involves weights.</source>
          <target state="translated">GIN 색인은 선호하는 텍스트 검색 색인 유형입니다. 거꾸로 된 색인으로 일치하는 위치의 압축 된 목록과 함께 각 단어 (lexeme)에 대한 색인 항목이 포함됩니다. 여러 단어 검색은 첫 번째 일치 항목을 찾은 다음 색인을 사용하여 추가 단어가없는 행을 제거 할 수 있습니다. GIN 인덱스는 &lt;code&gt;tsvector&lt;/code&gt; 값 의 단어 ( lexemes ) 만 저장 하고 가중치 레이블은 저장하지 않습니다. 따라서 가중치와 관련된 쿼리를 사용할 때는 테이블 행을 다시 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="662e0bcd43903a7d3e17f00c272dcd79f02aa415" translate="yes" xml:space="preserve">
          <source>GIN indexes can be used to efficiently search for keys or key/value pairs occurring within a large number of &lt;code&gt;jsonb&lt;/code&gt; documents (datums). Two GIN &amp;ldquo;operator classes&amp;rdquo; are provided, offering different performance and flexibility trade-offs.</source>
          <target state="translated">GIN 인덱스는 많은 &lt;code&gt;jsonb&lt;/code&gt; 문서 (데이텀) 내에서 발생하는 키 또는 키 / 값 쌍을 효율적으로 검색하는 데 사용될 수 있습니다 . 서로 다른 성능과 유연성의 균형을 제공하는 두 개의 GIN &quot;운영자 클래스&quot;가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="680a142f22f16149f0a10d5733b44a15bfc9f906" translate="yes" xml:space="preserve">
          <source>GIN is generalized in the sense that the GIN access method code does not need to know the specific operations that it accelerates. Instead, it uses custom strategies defined for particular data types. The strategy defines how keys are extracted from indexed items and query conditions, and how to determine whether a row that contains some of the key values in a query actually satisfies the query.</source>
          <target state="translated">GIN은 GIN 액세스 방법 코드가 가속화하는 특정 작업을 알 필요가 없다는 의미에서 일반화됩니다. 대신 특정 데이터 유형에 대해 정의 된 사용자 지정 전략을 사용합니다. 이 전략은 인덱싱 된 항목 및 쿼리 조건에서 키를 추출하는 방법과 쿼리에 일부 키 값이 포함 된 행이 실제로 쿼리를 만족하는지 여부를 결정하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2d1d5b806ff667bfec2719e4c38322233f7a1f8b" translate="yes" xml:space="preserve">
          <source>GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.</source>
          <target state="translated">GIN은 Generalized Inverted Index의 약자입니다. GIN은 인덱싱 할 항목이 복합 값이고 인덱스에서 처리 할 쿼리가 복합 항목 내에 나타나는 요소 값을 검색해야하는 경우를 처리하기 위해 설계되었습니다. 예를 들어 항목은 문서 일 수 있고 쿼리는 특정 단어가 포함 된 문서를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="823f6d975b918a4f4904609a69bccd4f6db0e016" translate="yes" xml:space="preserve">
          <source>GIN version number</source>
          <target state="translated">진 버전 번호</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="46e5d5c005d767dc686d5fdb5278440482f67660" translate="yes" xml:space="preserve">
          <source>GRANT</source>
          <target state="translated">GRANT</target>
        </trans-unit>
        <trans-unit id="f96c309d7771b4500d22efff00cb264218c6cf3a" translate="yes" xml:space="preserve">
          <source>GRANT &amp;mdash; define access privileges</source>
          <target state="translated">GRANT-액세스 권한 정의</target>
        </trans-unit>
        <trans-unit id="50381ef340ee08d7a029c8e513ea2dc8126c9d21" translate="yes" xml:space="preserve">
          <source>GRANT on Database Objects</source>
          <target state="translated">데이터베이스 객체에 대한 GRANT</target>
        </trans-unit>
        <trans-unit id="040876dd6cec9809d1a84a48115c6451d11d511c" translate="yes" xml:space="preserve">
          <source>GRANT on Roles</source>
          <target state="translated">역할에 대한 열정</target>
        </trans-unit>
        <trans-unit id="18b63165da1ffe19e191b11267fd831d16b20629" translate="yes" xml:space="preserve">
          <source>GSSAPI</source>
          <target state="translated">GSSAPI</target>
        </trans-unit>
        <trans-unit id="6b3f2424f13149fada5347cf28d874ce4ce85971" translate="yes" xml:space="preserve">
          <source>GSSAPI Authentication</source>
          <target state="translated">GSSAPI 인증</target>
        </trans-unit>
        <trans-unit id="3d0265dcf1697d6c2f5c259d07fa634b6fbdea24" translate="yes" xml:space="preserve">
          <source>GSSAPI is an industry-standard protocol for secure authentication defined in RFC 2743. PostgreSQL supports GSSAPI for use as either an encrypted, authenticated layer, or for authentication only. GSSAPI provides automatic authentication (single sign-on) for systems that support it. The authentication itself is secure. If GSSAPI encryption (see &lt;code&gt;hostgssenc&lt;/code&gt;) or SSL encryption are used, the data sent along the database connection will be encrypted; otherwise, it will not.</source>
          <target state="translated">GSSAPI는 RFC 2743에 정의 된 보안 인증을위한 산업 표준 프로토콜입니다. PostgreSQL은 암호화, 인증 된 계층 또는 인증 전용으로 GSSAPI를 지원합니다. GSSAPI는이를 지원하는 시스템에 자동 인증 (싱글 사인온)을 제공합니다. 인증 자체는 안전합니다. GSSAPI 암호화 ( &lt;code&gt;hostgssenc&lt;/code&gt; 참조 ) 또는 SSL 암호화가 사용되면 데이터베이스 연결을 통해 전송 된 데이터가 암호화됩니다. 그렇지 않으면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c340397893e38112dd6e1110b015089ffe980f8" translate="yes" xml:space="preserve">
          <source>GSSAPI support has to be enabled when PostgreSQL is built; see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for more information.</source>
          <target state="translated">PostgreSQL을 빌드 할 때 GSSAPI 지원을 활성화해야합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;16 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="071a79ebe1f1c0887de7c400f4061aba943bc234" translate="yes" xml:space="preserve">
          <source>GSSAPI support has to be enabled when PostgreSQL is built; see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for more information.</source>
          <target state="translated">GSSAPI support has to be enabled when PostgreSQL is built; see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="a65194631e53d423c8f7dc36b0337ca4d0af275f" translate="yes" xml:space="preserve">
          <source>GSSAPI-encrypted connections encrypt all data sent across the network, including queries and data returned. (No password is sent across the network.) The &lt;code&gt;pg_hba.conf&lt;/code&gt; file allows administrators to specify which hosts can use non-encrypted connections (&lt;code&gt;host&lt;/code&gt;) and which require GSSAPI-encrypted connections (&lt;code&gt;hostgssenc&lt;/code&gt;). Also, clients can specify that they connect to servers only on GSSAPI-encrypted connections (&lt;code&gt;gssencmode=require&lt;/code&gt;).</source>
          <target state="translated">GSSAPI 암호화 연결은 쿼리 및 반환 된 데이터를 포함하여 네트워크를 통해 전송 된 모든 데이터를 암호화합니다. (없음 암호는 네트워크를 통해 전송된다.)에 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일 관리자는 호스트가 암호화되지 않은 연결 (사용할 수있는 지정할 수 있습니다 &lt;code&gt;host&lt;/code&gt; ) 및 GSSAPI 암호화 된 연결 (필요 &lt;code&gt;hostgssenc&lt;/code&gt; 을 ). 또한 클라이언트는 GSSAPI 암호화 연결 ( &lt;code&gt;gssencmode=require&lt;/code&gt; ) 에서만 서버에 연결하도록 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f4a781a866c82c10ec06cfdb99d578fac96f0a9" translate="yes" xml:space="preserve">
          <source>GUC</source>
          <target state="translated">GUC</target>
        </trans-unit>
        <trans-unit id="55d3b12a3edecf2084b5b37090f9f7a53387e200" translate="yes" xml:space="preserve">
          <source>Gaussian-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; 가우스 분포 랜덤 정수 ( 아래 참조)</target>
        </trans-unit>
        <trans-unit id="ae313cc97f019cc02b5747068e2416db0beed99a" translate="yes" xml:space="preserve">
          <source>General Purpose</source>
          <target state="translated">범용</target>
        </trans-unit>
        <trans-unit id="3160665d714fc6d7b194361c56057ae8d2d10ef8" translate="yes" xml:space="preserve">
          <source>Generalized Inverted Index</source>
          <target state="translated">일반화 반전 지수</target>
        </trans-unit>
        <trans-unit id="aa5854e74a08fd00bcac0cc44c6f66a2c57b9442" translate="yes" xml:space="preserve">
          <source>Generalized Search Tree</source>
          <target state="translated">일반화 된 검색 트리</target>
        </trans-unit>
        <trans-unit id="3e7c9f89ced37df1cb7e21ed93f1ae9c43e37c8c" translate="yes" xml:space="preserve">
          <source>Generally, any file system with POSIX semantics can be used for PostgreSQL. Users prefer different file systems for a variety of reasons, including vendor support, performance, and familiarity. Experience suggests that, all other things being equal, one should not expect major performance or behavior changes merely from switching file systems or making minor file system configuration changes.</source>
          <target state="translated">일반적으로 POSIX 시맨틱이있는 모든 파일 시스템을 PostgreSQL에 사용할 수 있습니다. 사용자는 공급 업체 지원, 성능 및 친숙성을 포함하여 다양한 이유로 다른 파일 시스템을 선호합니다. 경험에 따르면, 다른 모든 것들이 동일 할 경우 파일 시스템을 전환하거나 파일 시스템 구성을 약간만 변경해도 주요 성능이나 동작 변경이 예상되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e4dfa0a05721faeacd6c28188e09916650d7ec35" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;EXPLAIN&lt;/code&gt; output will display details for every plan node which was generated by the query planner. However, there are cases where the executor is able to determine that certain nodes are not required; currently, the only node types to support this are the &lt;code&gt;Append&lt;/code&gt; and &lt;code&gt;MergeAppend&lt;/code&gt; nodes. These node types have the ability to discard subnodes which they are able to determine won't contain any records required by the query. It is possible to determine that nodes have been removed in this way by the presence of a &quot;Subplans Removed&quot; property in the &lt;code&gt;EXPLAIN&lt;/code&gt; output.</source>
          <target state="translated">일반적으로 &lt;code&gt;EXPLAIN&lt;/code&gt; 출력은 쿼리 플래너가 생성 한 모든 계획 노드에 대한 세부 사항을 표시합니다. 그러나 실행자가 특정 노드가 필요하지 않다고 판단 할 수있는 경우가 있습니다. 현재이를 지원하는 유일한 노드 유형은 &lt;code&gt;Append&lt;/code&gt; 및 &lt;code&gt;MergeAppend&lt;/code&gt; 노드입니다. 이러한 노드 유형에는 쿼리에 필요한 레코드가 포함되어 있지 않은지 확인할 수있는 하위 노드를 버리는 기능이 있습니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 에 &quot;하위 계획 제거&quot;특성이 존재하여 이러한 방식으로 노드가 제거되었는지 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="affe2a15ea854fded86126b770c099c64d24c777" translate="yes" xml:space="preserve">
          <source>Generally, the system will enforce filter conditions imposed using security policies prior to qualifications that appear in user queries, in order to prevent inadvertent exposure of the protected data to user-defined functions which might not be trustworthy. However, functions and operators marked by the system (or the system administrator) as &lt;code&gt;LEAKPROOF&lt;/code&gt; may be evaluated before policy expressions, as they are assumed to be trustworthy.</source>
          <target state="translated">일반적으로, 시스템은 신뢰할 수없는 사용자 정의 기능에 보호 된 데이터가 실수로 노출되는 것을 방지하기 위해 사용자 쿼리에 표시되는 자격에 앞서 보안 정책을 사용하여 적용된 필터 조건을 시행합니다. 그러나 시스템 (또는 시스템 관리자)이 &lt;code&gt;LEAKPROOF&lt;/code&gt; 로 표시 한 기능 및 연산자는 신뢰할 수있는 것으로 간주되기 때문에 정책 표현 전에 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3eac14aa88e73035cec53cd24d7892747e63a31" translate="yes" xml:space="preserve">
          <source>Generate a series comprising the given array's subscripts.</source>
          <target state="translated">주어진 배열의 아래 첨자로 구성된 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4a5175300e4854a10a7b94e474436e6a6e890471" translate="yes" xml:space="preserve">
          <source>Generate a series comprising the given array's subscripts. When &lt;em&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/em&gt; is true, the series is returned in reverse order.</source>
          <target state="translated">주어진 배열의 아래 첨자로 구성된 시리즈를 생성하십시오. 때 &lt;em&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/em&gt; 사실이다 시리즈는 역순으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ad5fcb5a5c8eeebb88c26d2bf0bde7f9fa38281f" translate="yes" xml:space="preserve">
          <source>Generate a series of values, from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt; with a step size of &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">에서, 일련의 값을 생성 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 을 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; 하는 단계 크기 &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5fb2cfb648fe3292c4f21944415cd71835246e3" translate="yes" xml:space="preserve">
          <source>Generate a series of values, from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt; with a step size of one</source>
          <target state="translated">단계 크기가 1 인 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 부터 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; 까지 일련의 값 생성</target>
        </trans-unit>
        <trans-unit id="37f727cfa62167384e5f8947ef57078f0d482808" translate="yes" xml:space="preserve">
          <source>Generate data and load it into the standard tables, replacing any data already present.</source>
          <target state="translated">데이터를 생성하고 표준 테이블에로드하여 이미 존재하는 데이터를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="9dcf1fb2a5619d507a1603ea13343b634907fbb2" translate="yes" xml:space="preserve">
          <source>Generated Columns</source>
          <target state="translated">생성 된 열</target>
        </trans-unit>
        <trans-unit id="75d723afc8209b9ad813733ed0d276b98f57a469" translate="yes" xml:space="preserve">
          <source>Generated columns are, conceptually, updated after &lt;code&gt;BEFORE&lt;/code&gt; triggers have run. Therefore, changes made to base columns in a &lt;code&gt;BEFORE&lt;/code&gt; trigger will be reflected in generated columns. But conversely, it is not allowed to access generated columns in &lt;code&gt;BEFORE&lt;/code&gt; triggers.</source>
          <target state="translated">생성 된 열은 개념적으로 &lt;code&gt;BEFORE&lt;/code&gt; 트리거가 실행 된 후에 업데이트됩니다 . 따라서 &lt;code&gt;BEFORE&lt;/code&gt; 트리거 에서 기본 열에 대한 변경 사항은 생성 된 열에 반영됩니다. 그러나 반대로 &lt;code&gt;BEFORE&lt;/code&gt; 트리거 에서 생성 된 열에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="942c0fc170e0c5a1f9b1ae453e356f340b1b4ebb" translate="yes" xml:space="preserve">
          <source>Generated columns maintain access privileges separately from their underlying base columns. So, it is possible to arrange it so that a particular role can read from a generated column but not from the underlying base columns.</source>
          <target state="translated">생성 된 열은 기본 열과 별도로 액세스 권한을 유지 관리합니다. 따라서 기본 역할이 아닌 생성 된 열에서 특정 역할을 읽을 수 있도록 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f0ef22f71ecfc740ab931db74f147c122ec3d69" translate="yes" xml:space="preserve">
          <source>Generates a great amount of debugging output for the &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt; commands. &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; must be &lt;code&gt;DEBUG1&lt;/code&gt; or lower to send this output to the client or server logs, respectively.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; 및 &lt;code&gt;NOTIFY&lt;/code&gt; 명령에 대한 대량의 디버깅 출력을 생성 합니다. &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; 는 이 출력을 각각 클라이언트 또는 서버 로그로 보내 &lt;code&gt;DEBUG1&lt;/code&gt; 이하 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c512aad043f38a5c410a9715731ea7ab925a02c" translate="yes" xml:space="preserve">
          <source>Generates a new random salt string for use in &lt;code&gt;crypt()&lt;/code&gt;. The salt string also tells &lt;code&gt;crypt()&lt;/code&gt; which algorithm to use.</source>
          <target state="translated">&lt;code&gt;crypt()&lt;/code&gt; 에서 사용할 새로운 임의 솔트 문자열을 생성합니다 . 솔트 문자열은 &lt;code&gt;crypt()&lt;/code&gt; 에게 사용할 알고리즘을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="cbde187b61954e6ea30cd14491acf93d47d93995" translate="yes" xml:space="preserve">
          <source>Generates a series comprising the valid subscripts of the &lt;em&gt;&lt;code&gt;dim&lt;/code&gt;&lt;/em&gt;'th dimension of the given array.</source>
          <target state="translated">Generates a series comprising the valid subscripts of the &lt;em&gt; &lt;code&gt;dim&lt;/code&gt; &lt;/em&gt;'th dimension of the given array.</target>
        </trans-unit>
        <trans-unit id="3315cb9c251ba92b686585eaa006d098cd316db2" translate="yes" xml:space="preserve">
          <source>Generates a series comprising the valid subscripts of the &lt;em&gt;&lt;code&gt;dim&lt;/code&gt;&lt;/em&gt;'th dimension of the given array. When &lt;em&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/em&gt; is true, returns the series in reverse order.</source>
          <target state="translated">Generates a series comprising the valid subscripts of the &lt;em&gt; &lt;code&gt;dim&lt;/code&gt; &lt;/em&gt;'th dimension of the given array. When &lt;em&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/em&gt; is true, returns the series in reverse order.</target>
        </trans-unit>
        <trans-unit id="5b9efd71e8210e50c6cf31398196b39400f42912" translate="yes" xml:space="preserve">
          <source>Generates a series of values from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;, with a step size of &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">Generates a series of values from &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; to &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;, with a step size of &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="2fe64f6ae7efb31df1c280c81e9337ab336a691f" translate="yes" xml:space="preserve">
          <source>Generates a series of values from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;, with a step size of &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt;. &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; defaults to 1.</source>
          <target state="translated">Generates a series of values from &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; to &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;, with a step size of &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;. &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; defaults to 1.</target>
        </trans-unit>
        <trans-unit id="447f18f7fd582d437e245ed58834f9f6f0d3572f" translate="yes" xml:space="preserve">
          <source>Generates a version 1 UUID, but uses a random multicast MAC address instead of the real MAC address of the computer.</source>
          <target state="translated">Generates a version 1 UUID, but uses a random multicast MAC address instead of the real MAC address of the computer.</target>
        </trans-unit>
        <trans-unit id="61eee4f4b5d39293f14efcf028cd9d79aa5d58ef" translate="yes" xml:space="preserve">
          <source>Generates a version 1 UUID. This involves the MAC address of the computer and a time stamp. Note that UUIDs of this kind reveal the identity of the computer that created the identifier and the time at which it did so, which might make it unsuitable for certain security-sensitive applications.</source>
          <target state="translated">Generates a version 1 UUID. This involves the MAC address of the computer and a time stamp. Note that UUIDs of this kind reveal the identity of the computer that created the identifier and the time at which it did so, which might make it unsuitable for certain security-sensitive applications.</target>
        </trans-unit>
        <trans-unit id="72a73fa7358c1c8df9b5e2fd5fbe3bbadb09cc37" translate="yes" xml:space="preserve">
          <source>Generates a version 3 UUID in the given namespace using the specified input name. The namespace should be one of the special constants produced by the &lt;code&gt;uuid_ns_*()&lt;/code&gt; functions shown in &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Table F.33&lt;/a&gt;. (It could be any UUID in theory.) The name is an identifier in the selected namespace.</source>
          <target state="translated">Generates a version 3 UUID in the given namespace using the specified input name. The namespace should be one of the special constants produced by the &lt;code&gt;uuid_ns_*()&lt;/code&gt; functions shown in &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Table F.33&lt;/a&gt;. (It could be any UUID in theory.) The name is an identifier in the selected namespace.</target>
        </trans-unit>
        <trans-unit id="23cef3016afd0a928c6e33c378fcd6c9a3819d0e" translate="yes" xml:space="preserve">
          <source>Generates a version 4 UUID, which is derived entirely from random numbers.</source>
          <target state="translated">Generates a version 4 UUID, which is derived entirely from random numbers.</target>
        </trans-unit>
        <trans-unit id="abf0eb60bb57f570d739469888a828e2f5865138" translate="yes" xml:space="preserve">
          <source>Generates a version 5 UUID, which works like a version 3 UUID except that SHA-1 is used as a hashing method. Version 5 should be preferred over version 3 because SHA-1 is thought to be more secure than MD5.</source>
          <target state="translated">Generates a version 5 UUID, which works like a version 3 UUID except that SHA-1 is used as a hashing method. Version 5 should be preferred over version 3 because SHA-1 is thought to be more secure than MD5.</target>
        </trans-unit>
        <trans-unit id="2aed1c9095c07cc7e84b3424230f02a2d9b469cc" translate="yes" xml:space="preserve">
          <source>Generic Security Services Application Programming Interface</source>
          <target state="translated">일반 보안 서비스 응용 프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="8bc48767cdd05b47e355717259ca35db85925a08" translate="yes" xml:space="preserve">
          <source>Generic WAL Records</source>
          <target state="translated">일반 WAL 레코드</target>
        </trans-unit>
        <trans-unit id="205b89cfc2a1a2269f79b2bc4ed00c40f5cec848" translate="yes" xml:space="preserve">
          <source>Generic WAL assumes that the pages to be modified have standard layout, and in particular that there is no useful data between &lt;code&gt;pd_lower&lt;/code&gt; and &lt;code&gt;pd_upper&lt;/code&gt;.</source>
          <target state="translated">Generic WAL은 수정 될 페이지에 표준 레이아웃이 있으며 특히 &lt;code&gt;pd_lower&lt;/code&gt; 와 &lt;code&gt;pd_upper&lt;/code&gt; 사이에 유용한 데이터가 없다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="651fc79b97c554a5773cb00dd19d49f06b1a6de8" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer</source>
          <target state="translated">유전자 쿼리 최적화 프로그램</target>
        </trans-unit>
        <trans-unit id="285a459d41ebc8b40cc4e21eb5058c5046b9a518" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Further Reading</source>
          <target state="translated">유전자 쿼리 최적화 프로그램 : 추가 정보</target>
        </trans-unit>
        <trans-unit id="0fe3a114537a44f8bb8da3ae145d25fd674c9baa" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Genetic Algorithms</source>
          <target state="translated">유전자 쿼리 최적화 프로그램 : 유전자 알고리즘</target>
        </trans-unit>
        <trans-unit id="a4b0f535ba1259d8c2e707ca90836a3a1579135e" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Genetic Query Optimization (GEQO) in PostgreSQL</source>
          <target state="translated">Genetic Query Optimizer : PostgreSQL의 GEQO (Genetic Query Optimization)</target>
        </trans-unit>
        <trans-unit id="c07c10eab422b8e5a37b4814c23b452b246b27ed" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Query Handling as a Complex Optimization Problem</source>
          <target state="translated">유전자 쿼리 최적화 프로그램 : 복잡한 최적화 문제로서의 쿼리 처리</target>
        </trans-unit>
        <trans-unit id="59a79a1ee234d61d42db147aa7f797d2e6ec2302" translate="yes" xml:space="preserve">
          <source>Geometric Types</source>
          <target state="translated">기하학적 유형</target>
        </trans-unit>
        <trans-unit id="1b872848d87aaa550340d8fe24c7f0a2a9ae8bcb" translate="yes" xml:space="preserve">
          <source>Geometric Types: box</source>
          <target state="translated">기하학적 유형 : box</target>
        </trans-unit>
        <trans-unit id="92cdb69f3efb505ed8f65eafd9adff3faa140669" translate="yes" xml:space="preserve">
          <source>Geometric Types: circle</source>
          <target state="translated">기하학적 유형 : circle</target>
        </trans-unit>
        <trans-unit id="b780ba45a62c07dae122a8391383dec51d0ae3fb" translate="yes" xml:space="preserve">
          <source>Geometric Types: line</source>
          <target state="translated">기하학적 유형 : line</target>
        </trans-unit>
        <trans-unit id="93e949ac77b5da81e10c0d00eb14e5b76ecbcd17" translate="yes" xml:space="preserve">
          <source>Geometric Types: lseg</source>
          <target state="translated">기하학적 유형 : lseg</target>
        </trans-unit>
        <trans-unit id="70c8994901b16ea96046ff8cb3549fb5591cc7c5" translate="yes" xml:space="preserve">
          <source>Geometric Types: path</source>
          <target state="translated">기하학적 유형 : path</target>
        </trans-unit>
        <trans-unit id="5971b419fcb4741dbee95edc6702d224da6e2f8b" translate="yes" xml:space="preserve">
          <source>Geometric Types: point</source>
          <target state="translated">기하학적 유형 : point</target>
        </trans-unit>
        <trans-unit id="a42b9eae0d25dcae6593b119b1ff920376ab3fdb" translate="yes" xml:space="preserve">
          <source>Geometric Types: polygon</source>
          <target state="translated">기하학적 유형 : polygon</target>
        </trans-unit>
        <trans-unit id="c0f24750d757100bf5b4c2c76561499175630de1" translate="yes" xml:space="preserve">
          <source>Geometric data types represent two-dimensional spatial objects. &lt;a href=&quot;datatype-geometric#DATATYPE-GEO-TABLE&quot;&gt;Table 8.20&lt;/a&gt; shows the geometric types available in PostgreSQL.</source>
          <target state="translated">기하 데이터 유형은 2 차원 공간 객체를 나타냅니다. &lt;a href=&quot;datatype-geometric#DATATYPE-GEO-TABLE&quot;&gt;표 8.20&lt;/a&gt; 은 PostgreSQL에서 사용 가능한 기하학적 유형을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7694ba97cb7c18e18a22a41d6adc199509b697ef" translate="yes" xml:space="preserve">
          <source>Geometric types</source>
          <target state="translated">기하학적 유형</target>
        </trans-unit>
        <trans-unit id="9ae1f34e04075cebb1033f14ff7dd7b2bf91177b" translate="yes" xml:space="preserve">
          <source>Geometric: #</source>
          <target state="translated">기하학 : #</target>
        </trans-unit>
        <trans-unit id="623ca67b93ccce110311b935c4b0ce7ca78865ad" translate="yes" xml:space="preserve">
          <source>Geometric: # path &amp;#x27;,,)&amp;#x27;</source>
          <target state="translated">Geometric: # path ',,)'</target>
        </trans-unit>
        <trans-unit id="541465ff2784b3862252a679a04558fbc655a79e" translate="yes" xml:space="preserve">
          <source>Geometric: ##</source>
          <target state="translated">기하학 : ##</target>
        </trans-unit>
        <trans-unit id="72e0052efc06dc944e06a8b63310fcb1f4bce4d7" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;amp;</source>
          <target state="translated">기하학적 : &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="c6f1767ec1ac7b1e533771c3bc6f2d157e3a0ffa" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;gt;</source>
          <target state="translated">기하학적 : &amp;amp;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0efad1957c6995260f5c39d190b260d9567a113b" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;lt;</source>
          <target state="translated">기하학적 : &amp;amp; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="0f689675538b5b4ec110540ff41eb289d6bd6b43" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;lt;|</source>
          <target state="translated">기하학적 : &amp;amp; &amp;lt;|</target>
        </trans-unit>
        <trans-unit id="f1e472c7b332a52572d117379abc66949f9e31c1" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;gt;&amp;gt;</source>
          <target state="translated">기하학적 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6fb2a9acb2064c887124b6f5b0e4e754de5f5fc" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;gt;^</source>
          <target state="translated">기하학 :&amp;gt; ^</target>
        </trans-unit>
        <trans-unit id="d77e84d344e830ae23e28900f46ab81224e68d7d" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;&amp;lt;</source>
          <target state="translated">기하학적 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="114e3e68bec04a11161b64f095fcabaa1b93c022" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;&amp;lt;|</source>
          <target state="translated">기하학적 : &amp;lt;&amp;lt; |</target>
        </trans-unit>
        <trans-unit id="3ebddf62e56d977cd85a67e8678d46b2782a23db" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;-&amp;gt;</source>
          <target state="translated">기하학적 : &amp;lt;-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3447c8a88fb2334b8df577a95ce9dc8220f2dd2" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;@</source>
          <target state="translated">기하학적 : &amp;lt;@</target>
        </trans-unit>
        <trans-unit id="cce9525015da81ce4d350742ece1c53d96c3ca2b" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;^</source>
          <target state="translated">기하학적 : &amp;lt;^</target>
        </trans-unit>
        <trans-unit id="56a2009f06f5c74871588a05282ba0b39fb6ceeb" translate="yes" xml:space="preserve">
          <source>Geometric: *</source>
          <target state="translated">기하학적 : *</target>
        </trans-unit>
        <trans-unit id="fa3ffad94fe9509b3b02c414cf9edaa0a2aba46e" translate="yes" xml:space="preserve">
          <source>Geometric: +</source>
          <target state="translated">기하학 : +</target>
        </trans-unit>
        <trans-unit id="356d9d70234e609b9b853b2369c157f70b7aebbe" translate="yes" xml:space="preserve">
          <source>Geometric: -</source>
          <target state="translated">기하학적 :-</target>
        </trans-unit>
        <trans-unit id="2ffe2cc10b627cd354dfeb7422da5a985c240d62" translate="yes" xml:space="preserve">
          <source>Geometric: /</source>
          <target state="translated">기하학 : /</target>
        </trans-unit>
        <trans-unit id="1c2280f6c1d1edcd9860d33a2a8a075c691adc71" translate="yes" xml:space="preserve">
          <source>Geometric: ?#</source>
          <target state="translated">기하학 :? #</target>
        </trans-unit>
        <trans-unit id="12821b449935c6dc49b03d2b040482308099f146" translate="yes" xml:space="preserve">
          <source>Geometric: ?-</source>
          <target state="translated">기하학적 :?-</target>
        </trans-unit>
        <trans-unit id="3cd66d53af1e48242331e1745ba5fc7187566303" translate="yes" xml:space="preserve">
          <source>Geometric: ?- lseg &amp;#x27;&amp;#x27;</source>
          <target state="translated">Geometric: ?- lseg ''</target>
        </trans-unit>
        <trans-unit id="41659a241d6173118c63109b8d58f3b040547d38" translate="yes" xml:space="preserve">
          <source>Geometric: ?-|</source>
          <target state="translated">기하학 :?-|</target>
        </trans-unit>
        <trans-unit id="d6f03fc9c9b0ab0563a28c6910f4a205a373dffb" translate="yes" xml:space="preserve">
          <source>Geometric: ?|</source>
          <target state="translated">기하학적 :? |</target>
        </trans-unit>
        <trans-unit id="38b31205d1dae501b1ba03ac0e742900375d3d6b" translate="yes" xml:space="preserve">
          <source>Geometric: ?| lseg &amp;#x27;&amp;#x27;</source>
          <target state="translated">Geometric: ?| lseg ''</target>
        </trans-unit>
        <trans-unit id="13e94b0d1073bd3bdfb91bcd5a193786583c973b" translate="yes" xml:space="preserve">
          <source>Geometric: ?||</source>
          <target state="translated">기하학 :? ||</target>
        </trans-unit>
        <trans-unit id="9330c7f285f4544ce63cffaf12c739ac5f145ca1" translate="yes" xml:space="preserve">
          <source>Geometric: @&amp;gt;</source>
          <target state="translated">기하학 : @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5270f97dad19be61277e040028add99dc4c8a2f8" translate="yes" xml:space="preserve">
          <source>Geometric: @-@</source>
          <target state="translated">기하학 : @-@</target>
        </trans-unit>
        <trans-unit id="fe111f6519f93956916d5072524a2a1cf0002778" translate="yes" xml:space="preserve">
          <source>Geometric: @-@ path &amp;#x27;&amp;#x27;</source>
          <target state="translated">Geometric: @-@ path ''</target>
        </trans-unit>
        <trans-unit id="28dfb9d3208de0df87974a869f843209287712a0" translate="yes" xml:space="preserve">
          <source>Geometric: @@</source>
          <target state="translated">기하학 : @@</target>
        </trans-unit>
        <trans-unit id="3c3c043849e3c1e3749e2bdce5b1a842a3084138" translate="yes" xml:space="preserve">
          <source>Geometric: @@ box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: @@ box ','</target>
        </trans-unit>
        <trans-unit id="b52a6568265c2c5d617423e6cf36665bbcecd5cd" translate="yes" xml:space="preserve">
          <source>Geometric: area</source>
          <target state="translated">기하학적 : 면적</target>
        </trans-unit>
        <trans-unit id="81b6264e52168059ad003a6e2b407928038d86a2" translate="yes" xml:space="preserve">
          <source>Geometric: area,&amp;#x27;)</source>
          <target state="translated">Geometric: area,')</target>
        </trans-unit>
        <trans-unit id="93665e808ca1c14ef16cc6912cf6d87101aae4b0" translate="yes" xml:space="preserve">
          <source>Geometric: bound_box</source>
          <target state="translated">기하학 : bound_box</target>
        </trans-unit>
        <trans-unit id="e0c040881075a6da4960c127c1025ca1c4e3e78e" translate="yes" xml:space="preserve">
          <source>Geometric: bound_box,&amp;#x27;, box &amp;#x27;,&amp;#x27;)</source>
          <target state="translated">Geometric: bound_box,', box ',')</target>
        </trans-unit>
        <trans-unit id="39d2105da034c7db21d98973af72a8064f606dda" translate="yes" xml:space="preserve">
          <source>Geometric: box</source>
          <target state="translated">기하학적 : 상자</target>
        </trans-unit>
        <trans-unit id="f2f9f89c4b6f4917d364f4c229b877c630c28339" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; # box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: box ',' # box ','</target>
        </trans-unit>
        <trans-unit id="2816ad481532412dc4f968541eb54f6a73270279" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;amp;&amp;amp; box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: box ',' &amp;amp;&amp;amp; box ','</target>
        </trans-unit>
        <trans-unit id="f2fd06d9fd68d32124c59b325cb0db0d79219bc5" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;amp;&amp;gt; box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: box ',' &amp;amp;&amp;gt; box ','</target>
        </trans-unit>
        <trans-unit id="acff8f01767e5f76f5b1d4fd1a990a03aad21fec" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;amp;&amp;lt; box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: box ',' &amp;amp;&amp;lt; box ','</target>
        </trans-unit>
        <trans-unit id="d6174b595baddb6f900bbe68bd994ef45d5794b9" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;amp;&amp;lt;| box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: box ',' &amp;amp;&amp;lt;| box ','</target>
        </trans-unit>
        <trans-unit id="8c46e012460f34cad22ebb427ed0712715560663" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;lt;&amp;lt;| box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: box ',' &amp;lt;&amp;lt;| box ','</target>
        </trans-unit>
        <trans-unit id="cd84c4808d85b33347dff12aa320353447c00559" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; + point &amp;#x27;&amp;#x27;</source>
          <target state="translated">Geometric: box ',' + point ''</target>
        </trans-unit>
        <trans-unit id="2043406f5483c3b78fe2702d1e60c14292a2b7fc" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; - point &amp;#x27;&amp;#x27;</source>
          <target state="translated">Geometric: box ',' - point ''</target>
        </trans-unit>
        <trans-unit id="ef9ed5b74e6ef8d26a18017da8e1beeeec09cd1e" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; |&amp;amp;&amp;gt; box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: box ',' |&amp;amp;&amp;gt; box ','</target>
        </trans-unit>
        <trans-unit id="a0efc8325a73507b346ab303c99230f031e5d01e" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; |&amp;gt;&amp;gt; box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">Geometric: box ',' |&amp;gt;&amp;gt; box ','</target>
        </trans-unit>
        <trans-unit id="3b4c443e59431193bcca574cac250450f92759da" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,)&amp;#x27; &amp;gt;^ box &amp;#x27;,)&amp;#x27;</source>
          <target state="translated">Geometric: box ',)' &amp;gt;^ box ',)'</target>
        </trans-unit>
        <trans-unit id="ab59191ffc41e6e94384185a516bb868f42810c0" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,)&amp;#x27; &amp;lt;^ box &amp;#x27;,)&amp;#x27;</source>
          <target state="translated">Geometric: box ',)' &amp;lt;^ box ',)'</target>
        </trans-unit>
        <trans-unit id="2fe5ea0c0f9734fffa0671e590985facfaf3a07d" translate="yes" xml:space="preserve">
          <source>Geometric: box&amp;#x27;)</source>
          <target state="translated">Geometric: box')</target>
        </trans-unit>
        <trans-unit id="b9b733d8febdf138608e064b45be416040fbb687" translate="yes" xml:space="preserve">
          <source>Geometric: box&amp;#x27;, point &amp;#x27;&amp;#x27;)</source>
          <target state="translated">Geometric: box', point '')</target>
        </trans-unit>
        <trans-unit id="006e03d5685497ae0051c04f0f60f285cd6720c9" translate="yes" xml:space="preserve">
          <source>Geometric: box,,)&amp;#x27;)</source>
          <target state="translated">Geometric: box,,)')</target>
        </trans-unit>
        <trans-unit id="03bd3a9c2b876396b45f5f79b42b5cdad4adebd2" translate="yes" xml:space="preserve">
          <source>Geometric: box,2&amp;gt;&amp;#x27;)</source>
          <target state="translated">Geometric: box,2&amp;gt;')</target>
        </trans-unit>
        <trans-unit id="f403cd59f8511c55a29a5613deb6dc17553ae356" translate="yes" xml:space="preserve">
          <source>Geometric: center</source>
          <target state="translated">기하학적 : 중심</target>
        </trans-unit>
        <trans-unit id="b8d1e8b02bdbf1095140cb17f5807ecc91d43016" translate="yes" xml:space="preserve">
          <source>Geometric: center,&amp;#x27;)</source>
          <target state="translated">Geometric: center,')</target>
        </trans-unit>
        <trans-unit id="e4f391fd63cca84c9f17c34aa7cc7e489332e1f7" translate="yes" xml:space="preserve">
          <source>Geometric: circle</source>
          <target state="translated">기하학 : 원</target>
        </trans-unit>
        <trans-unit id="c535f92f1ddcd8259b16d0e3bee14e0580797b6f" translate="yes" xml:space="preserve">
          <source>Geometric: circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27; &amp;gt;&amp;gt; circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27;</source>
          <target state="translated">Geometric: circle '&amp;lt;,1&amp;gt;' &amp;gt;&amp;gt; circle '&amp;lt;,1&amp;gt;'</target>
        </trans-unit>
        <trans-unit id="fa5e4572ef426454d58bb1dd84794831792d9e66" translate="yes" xml:space="preserve">
          <source>Geometric: circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27; &amp;lt;&amp;lt; circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27;</source>
          <target state="translated">Geometric: circle '&amp;lt;,1&amp;gt;' &amp;lt;&amp;lt; circle '&amp;lt;,1&amp;gt;'</target>
        </trans-unit>
        <trans-unit id="3cff985774e188b9f562e91cd8addc996ee66f5e" translate="yes" xml:space="preserve">
          <source>Geometric: circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27; &amp;lt;-&amp;gt; circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27;</source>
          <target state="translated">Geometric: circle '&amp;lt;,1&amp;gt;' &amp;lt;-&amp;gt; circle '&amp;lt;,1&amp;gt;'</target>
        </trans-unit>
        <trans-unit id="aca3c18e75d0490dc088bdeee289cf2f2ddb6623" translate="yes" xml:space="preserve">
          <source>Geometric: circle &amp;#x27;&amp;lt;,2&amp;gt;&amp;#x27; @&amp;gt; point &amp;#x27;&amp;#x27;</source>
          <target state="translated">Geometric: circle '&amp;lt;,2&amp;gt;' @&amp;gt; point ''</target>
        </trans-unit>
        <trans-unit id="9e96c558473932e2346f244a964ddae1b0c5b426" translate="yes" xml:space="preserve">
          <source>Geometric: circle&amp;#x27;, 2.0)</source>
          <target state="translated">Geometric: circle', 2.0)</target>
        </trans-unit>
        <trans-unit id="e0a8f29a6cfa0086f71a2371a4a9cfa61519981f" translate="yes" xml:space="preserve">
          <source>Geometric: circle,&amp;#x27;)</source>
          <target state="translated">기하학적 : 원, ')</target>
        </trans-unit>
        <trans-unit id="c0b3563bc1ec602c1db6eda2dfa3e1d52d9bcc3f" translate="yes" xml:space="preserve">
          <source>Geometric: circle,,)&amp;#x27;)</source>
          <target state="translated">기하학적 : 원 ,,) ')</target>
        </trans-unit>
        <trans-unit id="53c6cfb41275da6c404267d632f7f90d89031096" translate="yes" xml:space="preserve">
          <source>Geometric: diagonal</source>
          <target state="translated">기하학적 : 대각선</target>
        </trans-unit>
        <trans-unit id="553006cf848708f4902731c3386a9dc66eabab66" translate="yes" xml:space="preserve">
          <source>Geometric: diagonal,&amp;#x27;)</source>
          <target state="translated">기하학적 : 대각선, ')</target>
        </trans-unit>
        <trans-unit id="e9d52c7012ac5f08fa191553229f86a574d2d1fe" translate="yes" xml:space="preserve">
          <source>Geometric: diameter</source>
          <target state="translated">기하학적 : 직경</target>
        </trans-unit>
        <trans-unit id="373415090bda87622f255f56f7a729917c064931" translate="yes" xml:space="preserve">
          <source>Geometric: diameter,2&amp;gt;&amp;#x27;)</source>
          <target state="translated">기하학적 : 직경, 2&amp;gt; ')</target>
        </trans-unit>
        <trans-unit id="eba387383e96b60f7dd8fc11f767b059ffe3a921" translate="yes" xml:space="preserve">
          <source>Geometric: height</source>
          <target state="translated">기하학적 : 높이</target>
        </trans-unit>
        <trans-unit id="9fe1907c928c52f78e63d26b9f3f3f24fef06655" translate="yes" xml:space="preserve">
          <source>Geometric: height,&amp;#x27;)</source>
          <target state="translated">기하학적 : 높이, ')</target>
        </trans-unit>
        <trans-unit id="dfc5959ea0a6181524e306d022dfcc8e49a1d83c" translate="yes" xml:space="preserve">
          <source>Geometric: isclosed</source>
          <target state="translated">기하학적 : isclosed</target>
        </trans-unit>
        <trans-unit id="6bc612f7069d860cd43f5e1d8de4a3377f55aac2" translate="yes" xml:space="preserve">
          <source>Geometric: isclosed,,)&amp;#x27;)</source>
          <target state="translated">기하학적 : 닫힘 ,,) ')</target>
        </trans-unit>
        <trans-unit id="7f81a6975db9a38b5af5931e1338ccf232987667" translate="yes" xml:space="preserve">
          <source>Geometric: isopen</source>
          <target state="translated">기하학 : isopen</target>
        </trans-unit>
        <trans-unit id="9da3cbb89ee4413929959266836080754f0761b5" translate="yes" xml:space="preserve">
          <source>Geometric: isopen,,]&amp;#x27;)</source>
          <target state="translated">기하학적 : isopen ,,] ')</target>
        </trans-unit>
        <trans-unit id="a9a3900467aaca1b8a4c1362db68f305b19582ef" translate="yes" xml:space="preserve">
          <source>Geometric: length</source>
          <target state="translated">기하학 : 길이</target>
        </trans-unit>
        <trans-unit id="0f477e538e17fdaf626987c0b3e059c4ed218340" translate="yes" xml:space="preserve">
          <source>Geometric: length,)&amp;#x27;)</source>
          <target state="translated">기하학적 : 길이,) ')</target>
        </trans-unit>
        <trans-unit id="1ba5f3a75b551d018972ef798eb335c100716e14" translate="yes" xml:space="preserve">
          <source>Geometric: line</source>
          <target state="translated">기하학 : 선</target>
        </trans-unit>
        <trans-unit id="72246d884c9da412f7faa402c1b15644165242d1" translate="yes" xml:space="preserve">
          <source>Geometric: line&amp;#x27;, point &amp;#x27;&amp;#x27;)</source>
          <target state="translated">기하학적 : 선 ', 점' ')</target>
        </trans-unit>
        <trans-unit id="206f9fccbd7deb8bf02553e15b19fa03337233fd" translate="yes" xml:space="preserve">
          <source>Geometric: lseg</source>
          <target state="translated">기하학 : lseg</target>
        </trans-unit>
        <trans-unit id="a3e0f8989703d9c594a884c56db0eb613ad74516" translate="yes" xml:space="preserve">
          <source>Geometric: lseg &amp;#x27;&amp;#x27; # lseg &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : lseg ''# lseg ''</target>
        </trans-unit>
        <trans-unit id="1cb00d68ff82986196da967a004bf414500fdbc3" translate="yes" xml:space="preserve">
          <source>Geometric: lseg &amp;#x27;&amp;#x27; ?# box &amp;#x27;,&amp;#x27;</source>
          <target state="translated">기하학적 : lseg ''? # box ','</target>
        </trans-unit>
        <trans-unit id="5370b1ba4e23c335eab44730c33ba038eab3dcde" translate="yes" xml:space="preserve">
          <source>Geometric: lseg &amp;#x27;&amp;#x27; ?-| lseg &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : lseg ''?-| lseg ''</target>
        </trans-unit>
        <trans-unit id="ac68a0711d9e1d8888e00b92046aa1a1a2a3a5ec" translate="yes" xml:space="preserve">
          <source>Geometric: lseg &amp;#x27;&amp;#x27; ?|| lseg &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : lseg ''? || lseg ''</target>
        </trans-unit>
        <trans-unit id="602ad64d70c153b03a7b7aac0df2c618dd7413ee" translate="yes" xml:space="preserve">
          <source>Geometric: lseg&amp;#x27;, point &amp;#x27;&amp;#x27;)</source>
          <target state="translated">기하학적 : lseg ', point' ')</target>
        </trans-unit>
        <trans-unit id="87ca41bc81644dec1ecec1aaf558379a4bf49a06" translate="yes" xml:space="preserve">
          <source>Geometric: lseg,&amp;#x27;)</source>
          <target state="translated">기하학적 : lseg, ')</target>
        </trans-unit>
        <trans-unit id="4d54cec15bcab56f2da1b1f390b73632b1dcbf4d" translate="yes" xml:space="preserve">
          <source>Geometric: npoints</source>
          <target state="translated">기하학 : npoints</target>
        </trans-unit>
        <trans-unit id="82f9176da26c349ac3a2fec9cfbb20c91c1ceba2" translate="yes" xml:space="preserve">
          <source>Geometric: npoints,,]&amp;#x27;)</source>
          <target state="translated">기하학적 : npoints ,,] ')</target>
        </trans-unit>
        <trans-unit id="28645e62602ce8fec7218147e4987f407e8f9a72" translate="yes" xml:space="preserve">
          <source>Geometric: path</source>
          <target state="translated">기하학적 : 경로</target>
        </trans-unit>
        <trans-unit id="6f5880dc04850313da101d9308d336ea96de5d8c" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;&amp;#x27; + path &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : 경로 ''+ 경로 ''</target>
        </trans-unit>
        <trans-unit id="cff8e922e3b31692c9ca250b6025ed31dd8fdd3d" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;,,)&amp;#x27; * point &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : 경로 ',,)'* 점 ''</target>
        </trans-unit>
        <trans-unit id="01bbc7843b38974a4c7d9f7e2b9400b56faabea0" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;,,)&amp;#x27; * point, sind)</source>
          <target state="translated">기하학적 : 경로 ',,)'* point, sind)</target>
        </trans-unit>
        <trans-unit id="f0c3a98f4a21bb6236d0f2cfa15d8ab5a7945f46" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;,,)&amp;#x27; / point &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : 경로 ',,)'/ 점 ''</target>
        </trans-unit>
        <trans-unit id="124e9a6db4d0ac040d679077edb6b8ab8a6696d7" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;,,)&amp;#x27; / point, sind)</source>
          <target state="translated">기하학적 : 경로 ',,)'/ point, sind)</target>
        </trans-unit>
        <trans-unit id="0c51b62ccd035da31f83330a680fa86308c2f3d9" translate="yes" xml:space="preserve">
          <source>Geometric: path,,)&amp;#x27;)</source>
          <target state="translated">기하학적 : 경로 ,,) ')</target>
        </trans-unit>
        <trans-unit id="45ec99c5c4e908e62ccff4e585500d723032cfdc" translate="yes" xml:space="preserve">
          <source>Geometric: pclose</source>
          <target state="translated">기하학적 : pclose</target>
        </trans-unit>
        <trans-unit id="b182f6b565883e6e2c646016b78ac68577626b98" translate="yes" xml:space="preserve">
          <source>Geometric: pclose,,]&amp;#x27;)</source>
          <target state="translated">기하학적 : pclose ,,] ')</target>
        </trans-unit>
        <trans-unit id="507989896f0547d05a215ff9f295d24b17e091c7" translate="yes" xml:space="preserve">
          <source>Geometric: point</source>
          <target state="translated">기하학적 : 포인트</target>
        </trans-unit>
        <trans-unit id="a2bd5d2d4b4907f20a470b8849f5a3801b5cf240" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; ## lseg &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : 점 ''## lseg ''</target>
        </trans-unit>
        <trans-unit id="d4fbb59521d848959fc9c310aa00242e442c3c84" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; &amp;gt;^ point &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : 포인트 ''&amp;gt; ^ 포인트 ''</target>
        </trans-unit>
        <trans-unit id="98399bfb394dae31e0ee9be7a1510b6d2f29c20d" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; &amp;lt;@ circle &amp;#x27;&amp;lt;,2&amp;gt;&amp;#x27;</source>
          <target state="translated">기하학적 : 점 ''&amp;lt;@ 원 '&amp;lt;, 2&amp;gt;'</target>
        </trans-unit>
        <trans-unit id="5899e5d0e3c89c66550565207bae86ba6b876cca" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; &amp;lt;^ point &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : 포인트 ''&amp;lt;^ 포인트 ''</target>
        </trans-unit>
        <trans-unit id="6a7ecda7f258e60f6482f618841a959ce963e1eb" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; ?- point &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : 포인트 ''?-포인트 ''</target>
        </trans-unit>
        <trans-unit id="f37b2dc5b2749acec1a49318ba6543c2d864c85f" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; ?| point &amp;#x27;&amp;#x27;</source>
          <target state="translated">기하학적 : 점 ''? | 포인트 ''</target>
        </trans-unit>
        <trans-unit id="6fde5286b89f54817cc5ab239faa374c00dc4606" translate="yes" xml:space="preserve">
          <source>Geometric: point,&amp;#x27;)</source>
          <target state="translated">기하학적 : 점, ')</target>
        </trans-unit>
        <trans-unit id="d8a576ac01a8a1ee78f8ff82f815c76dacfdc290" translate="yes" xml:space="preserve">
          <source>Geometric: point,,)&amp;#x27;)</source>
          <target state="translated">기하학적 : 점 ,,) ')</target>
        </trans-unit>
        <trans-unit id="4f23b963baba040a9faace3d21a05bf602160384" translate="yes" xml:space="preserve">
          <source>Geometric: point,2&amp;gt;&amp;#x27;)</source>
          <target state="translated">기하학적 : 점, 2&amp;gt; ')</target>
        </trans-unit>
        <trans-unit id="65a338ccdb82881febce734e97c4fdf45d453ff3" translate="yes" xml:space="preserve">
          <source>Geometric: point,]&amp;#x27;)</source>
          <target state="translated">기하학적 : 점,] ')</target>
        </trans-unit>
        <trans-unit id="3ae9f6bad12ee8c28eb43284381811f2bae31846" translate="yes" xml:space="preserve">
          <source>Geometric: polygon</source>
          <target state="translated">기하학 : 다각형</target>
        </trans-unit>
        <trans-unit id="5b35c0d746dfcc047a0afcd93f0b3c4cd18bde6b" translate="yes" xml:space="preserve">
          <source>Geometric: polygon &amp;#x27;,)&amp;#x27; ~= polygon &amp;#x27;,)&amp;#x27;</source>
          <target state="translated">기하학적 : 다각형 ',)'~ = 다각형 ',)'</target>
        </trans-unit>
        <trans-unit id="869816f787f3c390221cdff48c373141618216b9" translate="yes" xml:space="preserve">
          <source>Geometric: polygon,&amp;#x27;)</source>
          <target state="translated">기하학적 : 다각형, ')</target>
        </trans-unit>
        <trans-unit id="ab05db392d81b824cdb41f7a6fe5d8d14bc9d11f" translate="yes" xml:space="preserve">
          <source>Geometric: polygon,,)&amp;#x27;)</source>
          <target state="translated">기하학적 : 다각형 ,,) ')</target>
        </trans-unit>
        <trans-unit id="5804fd3a3f57f14319c118fa75cb7051954b6773" translate="yes" xml:space="preserve">
          <source>Geometric: polygon,1&amp;gt;&amp;#x27;)</source>
          <target state="translated">기하학적 : 다각형, 1&amp;gt; ')</target>
        </trans-unit>
        <trans-unit id="d6845c24e84d1c6f6af34f8e667ff55b799afc77" translate="yes" xml:space="preserve">
          <source>Geometric: polygon,2&amp;gt;&amp;#x27;)</source>
          <target state="translated">기하학적 : 다각형, 2&amp;gt; ')</target>
        </trans-unit>
        <trans-unit id="819b82ef2ad538d3fe48c1ae412245c21d9fd58a" translate="yes" xml:space="preserve">
          <source>Geometric: popen</source>
          <target state="translated">기하학 : popen</target>
        </trans-unit>
        <trans-unit id="0ce17112425a0c921d0d37f14277221f7e5cb662" translate="yes" xml:space="preserve">
          <source>Geometric: popen,,)&amp;#x27;)</source>
          <target state="translated">기하학적 : popen ,,) ')</target>
        </trans-unit>
        <trans-unit id="833a7938b28ff55bf890ede9562c88a3cf3616b2" translate="yes" xml:space="preserve">
          <source>Geometric: radius</source>
          <target state="translated">기하학적 : 반경</target>
        </trans-unit>
        <trans-unit id="1c82295a4acd05e88581d706623e57915bba554e" translate="yes" xml:space="preserve">
          <source>Geometric: radius,2&amp;gt;&amp;#x27;)</source>
          <target state="translated">기하학적 : 반경, 2&amp;gt; ')</target>
        </trans-unit>
        <trans-unit id="31424f50624bafbef104ec60ff8d6cd6d9806a4a" translate="yes" xml:space="preserve">
          <source>Geometric: slope</source>
          <target state="translated">기하학적 : 경사</target>
        </trans-unit>
        <trans-unit id="e674485cf8e6967f9fda199dfc4f37a6860ba57a" translate="yes" xml:space="preserve">
          <source>Geometric: slope&amp;#x27;, point &amp;#x27;&amp;#x27;)</source>
          <target state="translated">기하학적 : 기울기 ', 점' ')</target>
        </trans-unit>
        <trans-unit id="7f7868cefc6080ede3e7599ccdee8580f1c6391a" translate="yes" xml:space="preserve">
          <source>Geometric: width</source>
          <target state="translated">기하학적 : 폭</target>
        </trans-unit>
        <trans-unit id="ecb1f3c3e3bb61f6a55b262498f5de376961e7b6" translate="yes" xml:space="preserve">
          <source>Geometric: width,&amp;#x27;)</source>
          <target state="translated">기하학적 : 너비, ')</target>
        </trans-unit>
        <trans-unit id="a3d7536af893973e797484588417b811fa49c9c9" translate="yes" xml:space="preserve">
          <source>Geometric: |&amp;amp;&amp;gt;</source>
          <target state="translated">기하학적 : | &amp;amp;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dac5ddcfb396044c241822b103826072cea9122a" translate="yes" xml:space="preserve">
          <source>Geometric: |&amp;gt;&amp;gt;</source>
          <target state="translated">기하학적 : | &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e1ce90a64a5a3e719604091e787102d24302368f" translate="yes" xml:space="preserve">
          <source>Geometric: ~=</source>
          <target state="translated">기하학적 : ~ =</target>
        </trans-unit>
        <trans-unit id="3764766959b2e2fca792b770cb84c07ab6ed354f" translate="yes" xml:space="preserve">
          <source>Germ&amp;aacute;n M&amp;eacute;ndez Bravo (Kronuz), 2004 - 2006</source>
          <target state="translated">Germ&amp;aacute;n M&amp;eacute;ndez Bravo (크로노 즈), 2004-2006</target>
        </trans-unit>
        <trans-unit id="a5921456830bc3242d009637ad1fbb6f191cdc48" translate="yes" xml:space="preserve">
          <source>Germ&amp;aacute;n M&amp;eacute;ndez Bravo (Kronuz), 2004&amp;ndash;2006</source>
          <target state="translated">Germ&amp;aacute;n M&amp;eacute;ndez Bravo (Kronuz), 2004&amp;ndash;2006</target>
        </trans-unit>
        <trans-unit id="8435540f9357c0427826e02b4177ce363970db3c" translate="yes" xml:space="preserve">
          <source>German collation for Austria, default variant</source>
          <target state="translated">오스트리아에 대한 독일어 데이터 정렬, 기본 변형</target>
        </trans-unit>
        <trans-unit id="7510fc993536622c741a49aafa894361e7ab10a4" translate="yes" xml:space="preserve">
          <source>German collation with phone book collation type</source>
          <target state="translated">전화 번호부 데이터 정렬 유형의 독일어 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="564857758dc8e91c1f74d993f78de5567b5c7dfc" translate="yes" xml:space="preserve">
          <source>German collation, default variant</source>
          <target state="translated">독일어 데이터 정렬, 기본 변형</target>
        </trans-unit>
        <trans-unit id="f27aff0cadc166c49cd93ee1187bf701f6029a5e" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;-th coordinate of cube (counting from 1).</source>
          <target state="translated">가져 &lt;code&gt;n&lt;/code&gt; (1에서 계산) 큐브의 좌표 번째.</target>
        </trans-unit>
        <trans-unit id="d35f795aa05a88fb426392aad122ef3b2bb082f7" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;-th coordinate of cube in following way: n = 2 * k - 1 means lower bound of &lt;code&gt;k&lt;/code&gt;-th dimension, n = 2 * k means upper bound of &lt;code&gt;k&lt;/code&gt;-th dimension. Negative &lt;code&gt;n&lt;/code&gt; denotes the inverse value of the corresponding positive coordinate. This operator is designed for KNN-GiST support.</source>
          <target state="translated">위젯 &lt;code&gt;n&lt;/code&gt; 방식으로 다음의 큐브 좌표 번째 : N = 2 * K는 1 - 수단의 하한 &lt;code&gt;k&lt;/code&gt; 번째 사이즈 N = 2 * K 수단은 상부의 경계 &lt;code&gt;k&lt;/code&gt; 번째의 측정. 음수 &lt;code&gt;n&lt;/code&gt; 은 해당 양의 좌표의 역값을 나타냅니다. 이 운영자는 KNN-GiST 지원을 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc6f8c8aaf13b3fdd311883db3b903abaee70123" translate="yes" xml:space="preserve">
          <source>Get JSON array element (indexed from zero, negative integers count from the end)</source>
          <target state="translated">JSON 배열 요소 가져 오기 (0에서 색인화, 끝에서 음의 정수로 계산)</target>
        </trans-unit>
        <trans-unit id="96cd8c94d1b03053f959c0260a5693091dfb369e" translate="yes" xml:space="preserve">
          <source>Get JSON array element as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">JSON 배열 요소를 &lt;code&gt;text&lt;/code&gt; 로 가져 오기</target>
        </trans-unit>
        <trans-unit id="cf31bd14e1935206dcfd63aadbd1872ba57dea93" translate="yes" xml:space="preserve">
          <source>Get JSON object at the specified path</source>
          <target state="translated">지정된 경로에서 JSON 객체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ef1cbd5cb305475720a9020825d5fd0aab442b3e" translate="yes" xml:space="preserve">
          <source>Get JSON object at the specified path as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">지정된 경로에서 JSON 객체를 &lt;code&gt;text&lt;/code&gt; 로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="25fd43d0d3f16339264c4b37b814115f9d3ce410" translate="yes" xml:space="preserve">
          <source>Get JSON object field as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">JSON 객체 필드를 &lt;code&gt;text&lt;/code&gt; 로 가져 오기</target>
        </trans-unit>
        <trans-unit id="073ceb452af411396658b2179c607b15772b77b9" translate="yes" xml:space="preserve">
          <source>Get JSON object field by key</source>
          <target state="translated">키로 JSON 객체 필드 가져 오기</target>
        </trans-unit>
        <trans-unit id="a3c9485f60ac0e72f3350d75767b48ed6ff294ae" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log flush location</source>
          <target state="translated">현재 미리 쓰기 로그 플러시 위치 가져 오기</target>
        </trans-unit>
        <trans-unit id="ff5bd5ba7d4bd0b1adf164a5c3514a0cde09068d" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log insert location</source>
          <target state="translated">현재 미리 쓰기 로그 삽입 위치 가져 오기</target>
        </trans-unit>
        <trans-unit id="6d563af8ba9dd62228b11fa7ee4de03e9c015df2" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log write location</source>
          <target state="translated">현재 미리 쓰기 로그 쓰기 위치 가져 오기</target>
        </trans-unit>
        <trans-unit id="5a63fc57b07be5ce8ae7fc6091aace9eaf741156" translate="yes" xml:space="preserve">
          <source>Get interval subfield (equivalent to &lt;code&gt;extract&lt;/code&gt;); see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">간격 하위 필드 가져 오기 ( &lt;code&gt;extract&lt;/code&gt; 와 동일 ) &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;9.9.1 절&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="7654b6edcaa442685671e13437c400615fa36a31" translate="yes" xml:space="preserve">
          <source>Get interval subfield; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">간격 하위 필드를 가져옵니다. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;9.9.1 절&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="6128ac644ecb365c2a1eeec7ff1509ae52372521" translate="yes" xml:space="preserve">
          <source>Get last write-ahead log location received and synced to disk by streaming replication. While streaming replication is in progress this will increase monotonically. If recovery has completed this will remain static at the value of the last WAL record received and synced to disk during recovery. If streaming replication is disabled, or if it has not yet started, the function returns NULL.</source>
          <target state="translated">스트리밍 복제를 통해 마지막으로 미리 기록한 로그 위치를 받고 디스크에 동기화합니다. 스트리밍 복제가 진행되는 동안 단조 증가합니다. 복구가 완료되면 복구 중에 디스크에 마지막으로 수신 및 동기화 된 WAL 레코드의 값으로 정적으로 유지됩니다. 스트리밍 복제가 비활성화되었거나 아직 시작되지 않은 경우 함수는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76a64be22601bc127252c3868430ba6f7837c55b" translate="yes" xml:space="preserve">
          <source>Get last write-ahead log location replayed during recovery. If recovery is still in progress this will increase monotonically. If recovery has completed then this value will remain static at the value of the last WAL record applied during that recovery. When the server has been started normally without recovery the function returns NULL.</source>
          <target state="translated">복구 중에 재생 된 마지막 미리 쓰기 로그 위치를 가져옵니다. 복구가 여전히 진행 중이면 단조 증가합니다. 복구가 완료된 경우이 값은 해당 복구 중에 적용된 마지막 WAL 레코드의 값에서 정적으로 유지됩니다. 서버가 복구없이 정상적으로 시작되면 함수는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="406fdc630e83917e4241518be673ae1f0d8347d2" translate="yes" xml:space="preserve">
          <source>Get start time of an on-line exclusive backup in progress.</source>
          <target state="translated">진행중인 온라인 독점 백업의 시작 시간을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dca6c016406c3b0ed8f48fe56cd9e3bf358bbd54" translate="yes" xml:space="preserve">
          <source>Get subfield (equivalent to &lt;code&gt;extract&lt;/code&gt;); see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">서브 필드 가져 오기 ( &lt;code&gt;extract&lt;/code&gt; 과 동일 ); &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;섹션 9.9.1&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="3152064f9ae3eb1ab6d172e1fe8f75ea161bdf61" translate="yes" xml:space="preserve">
          <source>Get subfield; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">서브 필드를 얻으십시오. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;섹션 9.9.1&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="4cfad13dc60760cc3b206a5a63697b11a532048c" translate="yes" xml:space="preserve">
          <source>Get time stamp of last transaction replayed during recovery. This is the time at which the commit or abort WAL record for that transaction was generated on the primary. If no transactions have been replayed during recovery, this function returns NULL. Otherwise, if recovery is still in progress this will increase monotonically. If recovery has completed then this value will remain static at the value of the last transaction applied during that recovery. When the server has been started normally without recovery the function returns NULL.</source>
          <target state="translated">복구 중에 재생 된 마지막 트랜잭션의 타임 스탬프를 가져옵니다. 이것은 해당 트랜잭션에 대한 커밋 또는 중단 WAL 레코드가 기본에서 생성 된 시간입니다. 복구 중에 트랜잭션이 재생되지 않은 경우이 함수는 NULL을 리턴합니다. 그렇지 않으면 복구가 여전히 진행중인 경우 단조 증가합니다. 복구가 완료된 경우이 값은 해당 복구 중에 적용된 마지막 트랜잭션 값에서 정적으로 유지됩니다. 서버가 복구없이 정상적으로 시작되면 함수는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9ab69254c214c6784aca932c9cdbfd619399aeab" translate="yes" xml:space="preserve">
          <source>Get timestamp subfield (equivalent to &lt;code id=&quot;extract&quot;&gt;extract&lt;/code&gt;); see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">타임 스탬프 하위 필드 가져 오기 ( &lt;code id=&quot;extract&quot;&gt;extract&lt;/code&gt; 와 동일 ) &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;9.9.1 절&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="41ba912fbba3eb8b34c259aed583d396fabedb3e" translate="yes" xml:space="preserve">
          <source>Get timestamp subfield; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">타임 스탬프 하위 필드를 가져옵니다. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;9.9.1 절&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="2286e40b8a539e9f8b5d59de04327253f0b8e306" translate="yes" xml:space="preserve">
          <source>Gets all JSON items returned by JSON path for the specified JSON value and wraps result into an array.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 된 모든 JSON 항목을 가져오고 결과를 배열로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="69ca4727f266434b20f8a8cff91f85228790e89c" translate="yes" xml:space="preserve">
          <source>Gets all JSON items returned by JSON path for the specified JSON value.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 된 모든 JSON 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f74211e2c2ac907544fec9e563a5484f2bc9bf8f" translate="yes" xml:space="preserve">
          <source>Gets the current status of the weak mode</source>
          <target state="translated">약한 모드의 현재 상태를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="ffe1d3bb8fb75103abea9d97f24675a5e6f74f12" translate="yes" xml:space="preserve">
          <source>Gets the first JSON item returned by JSON path for the specified JSON value. Returns &lt;code&gt;NULL&lt;/code&gt; on no results.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 된 첫 번째 JSON 항목을 가져옵니다. 결과가 없으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="1ea0c334189a899d918625993b37ead61ecb3937" translate="yes" xml:space="preserve">
          <source>GiST</source>
          <target state="translated">GiST</target>
        </trans-unit>
        <trans-unit id="2c7e841b76f37f5f1283940a7342c797bb3bd024" translate="yes" xml:space="preserve">
          <source>GiST Development Site &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;</source>
          <target state="translated">GiST 개발 사이트 &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77dacc994e0a5c24fbb20b4e435e091dad5586f5" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Built-in Operator Classes</source>
          <target state="translated">GiST 인덱스 : 내장 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="22165dcd40882c92f600bb8d95e394930c229760" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Examples</source>
          <target state="translated">GiST 지수 : 예</target>
        </trans-unit>
        <trans-unit id="cd4fa206206b0d9b9a4a09e74cdc45a9b7bac6d5" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Extensibility</source>
          <target state="translated">GiST 지수 : 확장 성</target>
        </trans-unit>
        <trans-unit id="1e6e31ed1dfc0534ae7fa938c637d58b4def631a" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Implementation</source>
          <target state="translated">GiST 인덱스 : 구현</target>
        </trans-unit>
        <trans-unit id="494456433e65d5f6cf54c8e3f52f00d35404d83c" translate="yes" xml:space="preserve">
          <source>GiST and SP-GiST indexes can be created for table columns of range types. For instance, to create a GiST index:</source>
          <target state="translated">범위 유형의 테이블 컬럼에 대해 GiST 및 SP-GiST 인덱스를 작성할 수 있습니다. 예를 들어 GiST 인덱스를 만들려면</target>
        </trans-unit>
        <trans-unit id="64ccd39c4988da1de12e6185509ac6695e61212e" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree&lt;/code&gt; (&lt;code&gt;gist_ltree_ops&lt;/code&gt; opclass): &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">GIST 지수를 통해 &lt;code&gt;ltree&lt;/code&gt; ( &lt;code&gt;gist_ltree_ops&lt;/code&gt; opclass) : &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;@&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49924620a95a816339f17d76ecc000e2cecd8a90" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">이상 GIST 지수 &lt;code&gt;ltree&lt;/code&gt; : &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;@&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="693c5c0cbde228a43b08f1288fe686338587e0d2" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree[]&lt;/code&gt; (&lt;code&gt;gist__ltree_ops&lt;/code&gt; opclass): &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt;, &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">위에 요지 인덱스 &lt;code&gt;ltree[]&lt;/code&gt; ( &lt;code&gt;gist__ltree_ops&lt;/code&gt; 가 opclass) &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt; , &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c380bccd59920d150dcf1776323ee944932357" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree[]&lt;/code&gt;: &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt;, &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">이상 GIST 지수 &lt;code&gt;ltree[]&lt;/code&gt; : &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt; , &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d319a311ddbbf36d4e1fdb2142c71c77f7a27e3" translate="yes" xml:space="preserve">
          <source>GiST indexes additionally accept this parameter:</source>
          <target state="translated">GiST 색인은이 매개 변수를 추가로 승인합니다.</target>
        </trans-unit>
        <trans-unit id="fd10e71b27221cbba626117e71058b4d0b5d0794" translate="yes" xml:space="preserve">
          <source>GiST indexes are also capable of optimizing &amp;ldquo;nearest-neighbor&amp;rdquo; searches, such as</source>
          <target state="translated">GiST 인덱스는 다음과 같은 &quot;인접 이웃&quot;검색을 최적화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e06a8812b702e9e01b2b2a18cfa676aaed004f" translate="yes" xml:space="preserve">
          <source>GiST indexes are not a single kind of index, but rather an infrastructure within which many different indexing strategies can be implemented. Accordingly, the particular operators with which a GiST index can be used vary depending on the indexing strategy (the &lt;em&gt;operator class&lt;/em&gt;). As an example, the standard distribution of PostgreSQL includes GiST operator classes for several two-dimensional geometric data types, which support indexed queries using these operators:</source>
          <target state="translated">GiST 인덱스는 단일 종류의 인덱스가 아니라 다양한 인덱싱 전략을 구현할 수있는 인프라입니다. 따라서 GiST 인덱스를 사용할 수있는 특정 연산자는 인덱싱 전략 ( &lt;em&gt;오퍼레이터 클래스&lt;/em&gt; ) 에 따라 다릅니다 . 예를 들어, PostgreSQL의 표준 배포에는 다음과 같은 연산자를 사용하여 인덱스 된 쿼리를 지원하는 몇 가지 2 차원 기하학적 데이터 유형에 대한 GiST 연산자 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8444450d765d03c90597419731d461339d26e37a" translate="yes" xml:space="preserve">
          <source>GiST stands for Generalized Search Tree. It is a balanced, tree-structured access method, that acts as a base template in which to implement arbitrary indexing schemes. B-trees, R-trees and many other indexing schemes can be implemented in GiST.</source>
          <target state="translated">GiST는 일반 검색 트리를 나타냅니다. 균형 잡힌 트리 구조 액세스 방법으로, 임의의 인덱싱 체계를 구현하는 기본 템플릿 역할을합니다. B- 트리, R- 트리 및 기타 여러 인덱싱 체계는 GiST에서 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="b0f44dac1f3500cf2c64a5e96b25bdc72296caa1" translate="yes" xml:space="preserve">
          <source>Give a role a non-default setting of the &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 매개 변수 의 기본 설정이 아닌 역할을 역할에 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d339f7ddc04ed38d6c4f1627fd17d7b3c263479" translate="yes" xml:space="preserve">
          <source>Give a role a non-default, database-specific setting of the &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; 매개 변수 의 기본이 아닌 데이터베이스 별 설정을 역할에 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="657b05bd06e4a30ca8560408b6cca3b16ee24c04" translate="yes" xml:space="preserve">
          <source>Give a role the ability to create other roles and new databases:</source>
          <target state="translated">역할에 다른 역할과 새 데이터베이스를 만들 수있는 기능을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="7e461b397ac9e789e72233367d6e54d13bd1ea4f" translate="yes" xml:space="preserve">
          <source>Given an index entry &lt;code&gt;p&lt;/code&gt; and a query value &lt;code&gt;q&lt;/code&gt;, this function determines the index entry's &amp;ldquo;distance&amp;rdquo; from the query value. This function must be supplied if the operator class contains any ordering operators. A query using the ordering operator will be implemented by returning index entries with the smallest &amp;ldquo;distance&amp;rdquo; values first, so the results must be consistent with the operator's semantics. For a leaf index entry the result just represents the distance to the index entry; for an internal tree node, the result must be the smallest distance that any child entry could have.</source>
          <target state="translated">인덱스 항목 &lt;code&gt;p&lt;/code&gt; 와 쿼리 값 &lt;code&gt;q&lt;/code&gt; 가 주어지면 이 함수 는 쿼리 값 에서 인덱스 항목의 &quot;거리&quot;를 결정합니다. 연산자 클래스에 순서 연산자가 포함 된 경우이 함수를 제공해야합니다. 순서 연산자를 사용한 쿼리는 가장 작은 &quot;거리&quot;값을 가진 색인 항목을 먼저 반환하여 구현되므로 결과는 연산자의 의미와 일치해야합니다. 리프 인덱스 항목의 경우 결과는 인덱스 항목까지의 거리 만 나타냅니다. 내부 트리 노드의 경우 결과는 모든 하위 항목이 가질 수있는 최소 거리 여야합니다.</target>
        </trans-unit>
        <trans-unit id="693396c0b50006bc8bf563a767c6df7376338535" translate="yes" xml:space="preserve">
          <source>Given an index entry &lt;code&gt;p&lt;/code&gt; and a query value &lt;code&gt;q&lt;/code&gt;, this function determines whether the index entry is &amp;ldquo;consistent&amp;rdquo; with the query; that is, could the predicate &amp;ldquo;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;indexable_operator&lt;/code&gt;&lt;code&gt;q&lt;/code&gt;&amp;rdquo; be true for any row represented by the index entry? For a leaf index entry this is equivalent to testing the indexable condition, while for an internal tree node this determines whether it is necessary to scan the subtree of the index represented by the tree node. When the result is &lt;code&gt;true&lt;/code&gt;, a &lt;code&gt;recheck&lt;/code&gt; flag must also be returned. This indicates whether the predicate is certainly true or only possibly true. If &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; then the index has tested the predicate condition exactly, whereas if &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; the row is only a candidate match. In that case the system will automatically evaluate the &lt;code&gt;indexable_operator&lt;/code&gt; against the actual row value to see if it is really a match. This convention allows GiST to support both lossless and lossy index structures.</source>
          <target state="translated">인덱스 항목 &lt;code&gt;p&lt;/code&gt; 와 쿼리 값 &lt;code&gt;q&lt;/code&gt; 가 주어지면 이 함수는 인덱스 항목이 쿼리와 &quot;일관성&quot;인지 여부를 결정합니다. 즉 , 인덱스 항목으로 표시되는 행에 대해 술어 &quot; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;indexable_operator&lt;/code&gt; &lt;code&gt;q&lt;/code&gt; &quot;가 참일 수 있습니까? 리프 인덱스 항목의 경우 색인 가능한 조건을 테스트하는 것과 동일하지만 내부 트리 노드의 경우 트리 노드가 나타내는 인덱스의 하위 트리를 스캔해야하는지 여부를 결정합니다. 결과가있을 때 &lt;code&gt;true&lt;/code&gt; 하는 &lt;code&gt;recheck&lt;/code&gt; 플래그도 반환해야합니다. 이것은 술어가 확실히 참인지 아니면 가능한 참인지를 나타냅니다. &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 인 경우인덱스는 술어 조건을 정확하게 테스트 한 반면, &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; 인 경우 행은 후보 일치 일뿐입니다. 이 경우 시스템은 실제 행 값과 비교하여 &lt;code&gt;indexable_operator&lt;/code&gt; 를 자동으로 평가하여 실제로 일치하는지 확인합니다. 이 규칙을 통해 GiST는 무손실 및 무손실 인덱스 구조를 모두 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e92d55ae3ac298e4b66632b1af221ac34e3be444" translate="yes" xml:space="preserve">
          <source>Given an index tuple and an indexed value, modifies the indicated attribute of the tuple so that it additionally represents the new value. If any modification was done to the tuple, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">인덱스 튜플과 인덱스 값이 주어지면 튜플의 표시된 속성을 수정하여 새 값을 추가로 나타냅니다. 튜플을 수정 한 경우 &lt;code&gt;true&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="769764fd5b04005314c3f8df7317ab69c5882b21" translate="yes" xml:space="preserve">
          <source>Given the cost of the plan, it is entirely reasonable that no JIT was used; the cost of JIT would have been bigger than the potential savings. Adjusting the cost limits will lead to JIT use:</source>
          <target state="translated">계획 비용이 주어지면 JIT를 사용하지 않은 것이 전적으로 합리적입니다. JIT의 비용은 잠재적 절감액보다 클 것입니다. 비용 한도를 조정하면 JIT가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37460509d9524c32ce3522fe588bb30e9b9a9e2c" translate="yes" xml:space="preserve">
          <source>Given the default configuration and only the first function existing, the first and second calls are insecure. Any user could intercept them by creating the second or third function. By matching the argument type exactly and using the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, the third call is secure.</source>
          <target state="translated">기본 구성과 첫 번째 기능 만 존재하면 첫 번째와 두 번째 호출은 안전하지 않습니다. 모든 사용자는 두 번째 또는 세 번째 기능을 작성하여이를 가로 챌 수 있습니다. 인수 유형을 정확하게 일치시키고 &lt;code&gt;VARIADIC&lt;/code&gt; 키워드를 사용하면 세 번째 호출이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="40af5c52e4886430e556bb2588adddc7f3345e29" translate="yes" xml:space="preserve">
          <source>Given the sample data from the PostgreSQL tutorial (see &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt;), this returns:</source>
          <target state="translated">PostgreSQL 튜토리얼 ( &lt;a href=&quot;tutorial-sql-intro&quot;&gt;섹션 2.1&lt;/a&gt; 참조 ) 의 샘플 데이터가 주어지면 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48862a4ac236aec67af11d9ca9afc2c469e5ae88" translate="yes" xml:space="preserve">
          <source>Gives syntax help on the specified SQL command. If &lt;code&gt;command&lt;/code&gt; is not specified, then psql will list all the commands for which syntax help is available. If &lt;code&gt;command&lt;/code&gt; is an asterisk (&lt;code&gt;*&lt;/code&gt;), then syntax help on all SQL commands is shown.</source>
          <target state="translated">지정된 SQL 명령에 대한 구문 도움말을 제공합니다. 경우 &lt;code&gt;command&lt;/code&gt; 지정되어 있지 않은 경우, psql의 구문 도움말을 사용할 수있는 모든 명령을 나열합니다. 경우 &lt;code&gt;command&lt;/code&gt; 별표 (입니다 &lt;code&gt;*&lt;/code&gt; 모든 SQL 명령에), 다음 구문 도움말을 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="696e22e619af6c7115546ae99d980b04fd02c2c6" translate="yes" xml:space="preserve">
          <source>Gives the distance in statute miles between two points on the Earth's surface.</source>
          <target state="translated">지표면의 두 지점 사이의 법정 마일 거리를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b2e72630d76d2483c8fcffc2dffd1c7c6a52ab67" translate="yes" xml:space="preserve">
          <source>Global transaction identifier that was assigned to the transaction</source>
          <target state="translated">트랜잭션에 지정된 글로벌 트랜잭션 식별자</target>
        </trans-unit>
        <trans-unit id="31e73c02a46d40c2d70edd740f19c8958fbb213c" translate="yes" xml:space="preserve">
          <source>Global validity checks require extra thought under non-serializable MVCC. For example, a banking application might wish to check that the sum of all credits in one table equals the sum of debits in another table, when both tables are being actively updated. Comparing the results of two successive &lt;code&gt;SELECT sum(...)&lt;/code&gt; commands will not work reliably in Read Committed mode, since the second query will likely include the results of transactions not counted by the first. Doing the two sums in a single repeatable read transaction will give an accurate picture of only the effects of transactions that committed before the repeatable read transaction started &amp;mdash; but one might legitimately wonder whether the answer is still relevant by the time it is delivered. If the repeatable read transaction itself applied some changes before trying to make the consistency check, the usefulness of the check becomes even more debatable, since now it includes some but not all post-transaction-start changes. In such cases a careful person might wish to lock all tables needed for the check, in order to get an indisputable picture of current reality. A &lt;code&gt;SHARE&lt;/code&gt; mode (or higher) lock guarantees that there are no uncommitted changes in the locked table, other than those of the current transaction.</source>
          <target state="translated">전역 유효성 검사에는 직렬화 할 수없는 MVCC에서 추가로 고려해야합니다. 예를 들어, 뱅킹 애플리케이션은 두 테이블이 모두 업데이트 될 때 한 테이블의 모든 크레딧 합계가 다른 테이블의 차변 합계와 같은지 확인하려고 할 수 있습니다. 두 개의 연속 &lt;code&gt;SELECT sum(...)&lt;/code&gt; 의 결과 비교명령은 읽기 커밋 모드에서 안정적으로 작동하지 않습니다. 두 번째 쿼리는 첫 번째 쿼리에서 계산하지 않은 트랜잭션의 결과를 포함하기 때문입니다. 반복 가능한 단일 읽기 트랜잭션에서 두 개의 합계를 수행하면 반복 가능한 읽기 트랜잭션이 시작되기 전에 커밋 된 트랜잭션의 효과 만 정확하게 파악할 수 있지만, 답변이 제공 될 때까지 여전히 관련이 있는지 궁금 할 수 있습니다. 일관성 검사를 시도하기 전에 반복 가능한 읽기 트랜잭션 자체가 일부 변경 사항을 적용한 경우, 트랜잭션 이후의 모든 변경 사항을 포함하지 않기 때문에 점검의 유용성은 더욱 논란의 여지가 있습니다. 이러한 경우주의 깊은 사람은 현재 현실에 대한 확실한 그림을 얻기 위해 점검에 필요한 모든 테이블을 잠그기를 원할 수 있습니다. &lt;code&gt;SHARE&lt;/code&gt; 모드 (또는 그 이상) 잠금은 현재 트랜잭션의 변경 외에 잠긴 테이블에 커밋되지 않은 변경이 없음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="4a647f902e0d765ea12195a96e4829f8b1e8aa9f" translate="yes" xml:space="preserve">
          <source>Good Practices</source>
          <target state="translated">좋은 습관</target>
        </trans-unit>
        <trans-unit id="3c09ec28f005ae7495ffdeada3d59d9447d92430" translate="yes" xml:space="preserve">
          <source>Good results will show most (&amp;gt;90%) individual timing calls take less than one microsecond. Average per loop overhead will be even lower, below 100 nanoseconds. This example from an Intel i7-860 system using a TSC clock source shows excellent performance:</source>
          <target state="translated">좋은 결과는 대부분의 (&amp;gt; 90 %) 개별 타이밍 호출에 1 마이크로 초 미만이 소요됨을 보여줍니다. 루프 당 평균 오버 헤드는 100 나노초 미만으로 훨씬 낮아집니다. TSC 클럭 소스를 사용하는 Intel i7-860 시스템의이 예는 뛰어난 성능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c02329c48f348eb633688f33c499b18b31dcb947" translate="yes" xml:space="preserve">
          <source>Grant</source>
          <target state="translated">Grant</target>
        </trans-unit>
        <trans-unit id="01af961ffadccd5726ec885717dd08dd99e478cf" translate="yes" xml:space="preserve">
          <source>Grant SELECT privilege to everyone for all tables (and views) you subsequently create in schema &lt;code&gt;myschema&lt;/code&gt;, and allow role &lt;code&gt;webuser&lt;/code&gt; to INSERT into them too:</source>
          <target state="translated">나중에 스키마 &lt;code&gt;myschema&lt;/code&gt; 에서 작성하는 모든 테이블 (및 뷰)에 대해 모든 사람에게 SELECT 권한을 부여 하고 &lt;code&gt;webuser&lt;/code&gt; 역할 도 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24617f7e457da3734cfeda27633b2aa731a9c9ef" translate="yes" xml:space="preserve">
          <source>Grant all available privileges to user &lt;code&gt;manuel&lt;/code&gt; on view &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">보기 &lt;code&gt;kinds&lt;/code&gt; 에 대해 사용자 &lt;code&gt;manuel&lt;/code&gt; 에게 사용 가능한 모든 권한을 부여하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e182dc9d9691657bc39b554f5fd47996c873086" translate="yes" xml:space="preserve">
          <source>Grant all of the privileges available for the object's type. The &lt;code&gt;PRIVILEGES&lt;/code&gt; key word is optional in PostgreSQL, though it is required by strict SQL.</source>
          <target state="translated">객체 유형에 사용할 수있는 모든 권한을 부여하십시오. &lt;code&gt;PRIVILEGES&lt;/code&gt; 이 엄격한 SQL에 필요하지만 키 워드는, PostgreSQL의에서 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="bb6ece16050b16e5f45fddd08ab0ab254c3c1353" translate="yes" xml:space="preserve">
          <source>Grant all privileges on all views in schema &lt;code&gt;public&lt;/code&gt; to role &lt;code&gt;webuser&lt;/code&gt;:</source>
          <target state="translated">schema &lt;code&gt;public&lt;/code&gt; 의 모든 뷰에 대한 모든 권한 을 역할 &lt;code&gt;webuser&lt;/code&gt; 에 부여하십시오 .</target>
        </trans-unit>
        <trans-unit id="269d15aac0905b9feb98dc13ab02754db1782270" translate="yes" xml:space="preserve">
          <source>Grant insert privilege to all users on table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;films&lt;/code&gt; 모든 사용자에게 삽입 권한 부여 :</target>
        </trans-unit>
        <trans-unit id="ba27670ed37d6c78d0b14c4148d50cc7aab110fa" translate="yes" xml:space="preserve">
          <source>Grant membership in role &lt;code&gt;admins&lt;/code&gt; to user &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;joe&lt;/code&gt; 사용자에게 역할 &lt;code&gt;admins&lt;/code&gt; 멤버십 부여 :</target>
        </trans-unit>
        <trans-unit id="1f88fd823ea9c3dd2200a42432c3efa9ef706298" translate="yes" xml:space="preserve">
          <source>Granting permission on a table does not automatically extend permissions to any sequences used by the table, including sequences tied to &lt;code&gt;SERIAL&lt;/code&gt; columns. Permissions on sequences must be set separately.</source>
          <target state="translated">테이블에 대한 권한을 &lt;code&gt;SERIAL&lt;/code&gt; 열에 묶인 시퀀스를 포함하여 테이블에 사용 된 시퀀스에 대한 권한이 자동으로 확장되지는 않습니다 . 시퀀스에 대한 권한은 별도로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">보다 큰</target>
        </trans-unit>
        <trans-unit id="a2919540599e9df0beb579ca8d46bdc142657611" translate="yes" xml:space="preserve">
          <source>Greater than or equal to</source>
          <target state="translated">크거나 같음</target>
        </trans-unit>
        <trans-unit id="2b3dd5feef716f81ba8f5a6b4f110f37be61a79c" translate="yes" xml:space="preserve">
          <source>Greater-than comparison</source>
          <target state="translated">보다 큼 비교</target>
        </trans-unit>
        <trans-unit id="e7c7faa35b86c7d8f2aa278406d57686d0e76cab" translate="yes" xml:space="preserve">
          <source>Greater-than operator</source>
          <target state="translated">보다 큰 연산자</target>
        </trans-unit>
        <trans-unit id="6be50f6e20e368774e1648e96e60824f64284093" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equal-to comparison</source>
          <target state="translated">크거나 같음 비교</target>
        </trans-unit>
        <trans-unit id="1b0cd62dcaabb41d866e961c21030484cdf15a5a" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equal-to operator</source>
          <target state="translated">같거나 큰 연산자</target>
        </trans-unit>
        <trans-unit id="016d8dc207e4a957a80df31d268b5c8c6a8e9e53" translate="yes" xml:space="preserve">
          <source>Greatest common divisor (the largest positive number that divides both inputs with no remainder); returns &lt;code id=&quot;0&quot;&gt;0&lt;/code&gt; if both inputs are zero; available for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="translated">최대 공약수 (나머지없이 두 입력을 모두 나누는 가장 큰 양수) 두 입력이 모두 &lt;code id=&quot;0&quot;&gt;0&lt;/code&gt; 이면 0을 반환 합니다. 에 해당하는 &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; 및 &lt;code&gt;numeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="fafd8001d43d87515ae86352c97c37616a4d6762" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time</source>
          <target state="translated">그리니치 표준시</target>
        </trans-unit>
        <trans-unit id="cf098c159fa893be7ea9fe00bfc173e418306bad" translate="yes" xml:space="preserve">
          <source>Gregorian years AD 1&amp;ndash;99 can be entered by using 4 digits with leading zeros (e.g., &lt;code&gt;0099&lt;/code&gt; is AD 99).</source>
          <target state="translated">그레고리력 AD 1&amp;ndash;99는 앞에 0이있는 4 자리 숫자를 사용하여 입력 할 수 있습니다 (예 : &lt;code&gt;0099&lt;/code&gt; 는 AD 99).</target>
        </trans-unit>
        <trans-unit id="6261b12bce7847fa9426739910b4246568401661" translate="yes" xml:space="preserve">
          <source>Gregorian years AD 1-99 can be entered by using 4 digits with leading zeros (e.g., &lt;code&gt;0099&lt;/code&gt; is AD 99).</source>
          <target state="translated">그레고리력 연도 AD 1-99는 앞에 0이있는 4 자리 숫자를 사용하여 입력 할 수 있습니다 (예 : &lt;code&gt;0099&lt;/code&gt; 는 AD 99).</target>
        </trans-unit>
        <trans-unit id="2b13ec9d057eee3b8bf047437042e0b54f1f6425" translate="yes" xml:space="preserve">
          <source>Grouping operations are used in conjunction with grouping sets (see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;) to distinguish result rows. The arguments to the &lt;code&gt;GROUPING&lt;/code&gt; operation are not actually evaluated, but they must match exactly expressions given in the &lt;code&gt;GROUP BY&lt;/code&gt; clause of the associated query level. Bits are assigned with the rightmost argument being the least-significant bit; each bit is 0 if the corresponding expression is included in the grouping criteria of the grouping set generating the result row, and 1 if it is not. For example:</source>
          <target state="translated">그룹화 작업은 결과 행을 구별하기 위해 그룹화 세트 ( &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;7.2.4&lt;/a&gt; 참조)와 함께 사용됩니다 . &lt;code&gt;GROUPING&lt;/code&gt; 연산에 대한 인수 는 실제로 평가되지 않지만 연관된 쿼리 레벨 의 &lt;code&gt;GROUP BY&lt;/code&gt; 절에 제공된 표현식과 정확하게 일치해야합니다 . 비트에는 가장 중요한 인수가 가장 중요하지 않은 비트가 할당됩니다. 결과 행을 생성하는 그룹화 세트의 그룹화 기준에 해당 표현식이 포함되어 있으면 각 비트는 0이고, 그렇지 않으면 1입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88d7c69cfe151f010dd11e55984fa5a2e4485f4b" translate="yes" xml:space="preserve">
          <source>Grouping without aggregate expressions effectively calculates the set of distinct values in a column. This can also be achieved using the &lt;code&gt;DISTINCT&lt;/code&gt; clause (see &lt;a href=&quot;queries-select-lists#QUERIES-DISTINCT&quot;&gt;Section 7.3.3&lt;/a&gt;).</source>
          <target state="translated">집계 식없이 그룹화하면 열의 고유 값 집합을 효과적으로 계산합니다. &lt;code&gt;DISTINCT&lt;/code&gt; 절을 사용 하여이 작업을 수행 할 수도 있습니다 ( &lt;a href=&quot;queries-select-lists#QUERIES-DISTINCT&quot;&gt;섹션 7.3.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="b82d3603eb93c98eb825eb4e6b01ee350ff3fb6d" translate="yes" xml:space="preserve">
          <source>HASH version number</source>
          <target state="translated">해시 버전 번호</target>
        </trans-unit>
        <trans-unit id="1cc155b76768b5b5fb2f3643a0744204e68a9ccc" translate="yes" xml:space="preserve">
          <source>HBA</source>
          <target state="translated">HBA</target>
        </trans-unit>
        <trans-unit id="0feddc013d3db0d214cc286a21a9e52cacbc17e4" translate="yes" xml:space="preserve">
          <source>HMAC: Keyed-Hashing for Message Authentication.</source>
          <target state="translated">HMAC : 메시지 인증을위한 키 해싱.</target>
        </trans-unit>
        <trans-unit id="06833bde6c3138c525040c232dbadac4725bac88" translate="yes" xml:space="preserve">
          <source>HOT</source>
          <target state="translated">HOT</target>
        </trans-unit>
        <trans-unit id="c305ce22fa1ddad5ff6a9a241e6067a9f35cad67" translate="yes" xml:space="preserve">
          <source>HP-UX</source>
          <target state="translated">HP-UX</target>
        </trans-unit>
        <trans-unit id="61a2a1882fc631d64e7d30ef57cec31971ea2c09" translate="yes" xml:space="preserve">
          <source>Had there been MCV lists for the two columns, &lt;code&gt;eqjoinsel&lt;/code&gt; would have used direct comparison of the MCV lists to determine the join selectivity within the part of the column populations represented by the MCVs. The estimate for the remainder of the populations follows the same approach shown here.</source>
          <target state="translated">두 열에 대해 MCV 목록이있는 경우 &lt;code&gt;eqjoinsel&lt;/code&gt; 은 MCV 목록을 직접 비교하여 MCV가 나타내는 열 모집단 부분 내에서 조인 선택성을 결정했을 것입니다. 나머지 모집단의 추정치는 여기에 표시된 것과 동일한 접근 방식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="4bf7a6d465bc019e543ce8b66fbf5cd1235516a8" translate="yes" xml:space="preserve">
          <source>Had we not supplied values for all the subfields of the column, the remaining subfields would have been filled with null values.</source>
          <target state="translated">열의 모든 서브 필드에 값을 제공하지 않은 경우 나머지 서브 필드는 널값으로 채워 졌을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e0c8e4e26ef951b2d257ad48905d56d36c233bc8" translate="yes" xml:space="preserve">
          <source>Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">유효하지 않거나 모호한 타임 스탬프 처리</target>
        </trans-unit>
        <trans-unit id="56d01e9677df53b4a2c4ef118ff77a201dd06a2e" translate="yes" xml:space="preserve">
          <source>Has a replication origin been configured in the current session?</source>
          <target state="translated">현재 세션에서 복제 원본이 구성 되었습니까?</target>
        </trans-unit>
        <trans-unit id="3127cc395c91e262a7a0864c40a7527573818c9c" translate="yes" xml:space="preserve">
          <source>Has the constraint been validated? Currently, can only be false for foreign keys and CHECK constraints</source>
          <target state="translated">구속 조건이 검증 되었습니까? 현재 외래 키 및 CHECK 제약 조건에 대해서만 false 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc36e4e0152a0239de102d530bd0c47b3d9e3a1" translate="yes" xml:space="preserve">
          <source>Hash Partitioning</source>
          <target state="translated">해시 분할</target>
        </trans-unit>
        <trans-unit id="90507c1a5721f22f49292627451907b5c9b469f4" translate="yes" xml:space="preserve">
          <source>Hash functions &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;hash_murmur2&lt;/code&gt; and &lt;code&gt;hash_fnv1a&lt;/code&gt; accept an input value and an optional seed parameter. In case the seed isn't provided the value of &lt;code&gt;:default_seed&lt;/code&gt; is used, which is initialized randomly unless set by the command-line &lt;code&gt;-D&lt;/code&gt; option. Hash functions can be used to scatter the distribution of random functions such as &lt;code&gt;random_zipfian&lt;/code&gt; or &lt;code&gt;random_exponential&lt;/code&gt;. For instance, the following pgbench script simulates possible real world workload typical for social media and blogging platforms where few accounts generate excessive load:</source>
          <target state="translated">해시 함수 &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;hash_murmur2&lt;/code&gt; 및 &lt;code&gt;hash_fnv1a&lt;/code&gt; 는 입력 값과 선택적 시드 매개 변수를 승인합니다. 시드가 제공되지 않은 경우 &lt;code&gt;:default_seed&lt;/code&gt; 값 이 사용되며 명령 행 &lt;code&gt;-D&lt;/code&gt; 옵션으로 설정하지 않는 한 임의로 초기화됩니다 . 해시 함수는 &lt;code&gt;random_zipfian&lt;/code&gt; 또는 &lt;code&gt;random_exponential&lt;/code&gt; 과 같은 임의 함수의 분포를 분산시키는 데 사용할 수 있습니다 . 예를 들어, 다음 pgbench 스크립트는 계정이 과도하게 많은 계정을 생성하는 소셜 미디어 및 블로그 플랫폼에 일반적인 실제 워크로드를 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="cc1cfbcfc5781fb19f027f2126a6d7e099a4d8b1" translate="yes" xml:space="preserve">
          <source>Hash indexes</source>
          <target state="translated">해시 인덱스</target>
        </trans-unit>
        <trans-unit id="f9f75839548d1e6a1a51f586eb631d2c4a104ff8" translate="yes" xml:space="preserve">
          <source>Hash indexes can only handle simple equality comparisons. The query planner will consider using a hash index whenever an indexed column is involved in a comparison using the &lt;code&gt;=&lt;/code&gt; operator. The following command is used to create a hash index:</source>
          <target state="translated">해시 인덱스는 단순한 동등 비교 만 처리 할 수 ​​있습니다. 쿼리 플래너는 인덱스 된 열이 &lt;code&gt;=&lt;/code&gt; 연산자를 사용하여 비교할 때마다 해시 인덱스 사용을 고려 합니다. 다음 명령은 해시 인덱스를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="956456c077f843c8529aa0f90522e368a7e51001" translate="yes" xml:space="preserve">
          <source>Hash-based operations are generally more sensitive to memory availability than equivalent sort-based operations. The memory available for hash tables is computed by multiplying &lt;code&gt;work_mem&lt;/code&gt; by &lt;code&gt;hash_mem_multiplier&lt;/code&gt;. This makes it possible for hash-based operations to use an amount of memory that exceeds the usual &lt;code&gt;work_mem&lt;/code&gt; base amount.</source>
          <target state="translated">해시 기반 작업은 일반적으로 동등한 정렬 기반 작업보다 메모리 가용성에 더 민감합니다. 해시 테이블에 사용 가능한 메모리는 &lt;code&gt;work_mem&lt;/code&gt; 에 &lt;code&gt;hash_mem_multiplier&lt;/code&gt; 를 곱하여 계산됩니다 . 이렇게하면 해시 기반 작업이 일반적인 &lt;code&gt;work_mem&lt;/code&gt; 기본 양 을 초과하는 메모리 양을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea4ccce2369daab1022355aaafd39217be056ac4" translate="yes" xml:space="preserve">
          <source>Hashes/sec</source>
          <target state="translated">Hashes/sec</target>
        </trans-unit>
        <trans-unit id="fa2065c836a17176e9e4314cc0f9ae6d0e4ea762" translate="yes" xml:space="preserve">
          <source>Having created this trigger, any change in &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; will automatically be reflected into &lt;code&gt;tsv&lt;/code&gt;, without the application having to worry about it.</source>
          <target state="translated">이 트리거를 생성 하면 응용 프로그램이 걱정할 필요없이 &lt;code&gt;title&lt;/code&gt; 이나 &lt;code&gt;body&lt;/code&gt; 변경 사항 이 자동으로 &lt;code&gt;tsv&lt;/code&gt; 에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="349ced815f5c84c9f5228e606a1b7ba0c2ddee06" translate="yes" xml:space="preserve">
          <source>Having defined the types, we can use them to create tables:</source>
          <target state="translated">유형을 정의한 후이를 사용하여 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2723c816765ee34102b273de3e99b00ba0f56303" translate="yes" xml:space="preserve">
          <source>Having the bloom index defined on the table is better than btree in handling this type of search:</source>
          <target state="translated">테이블에 정의 된 블룸 인덱스를 갖는 것이 이러한 유형의 검색을 처리 할 때 btree보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="847116884ad55b09c96b3c4dc05ec99dcc5ec687" translate="yes" xml:space="preserve">
          <source>Header extension area length</source>
          <target state="translated">헤더 확장 영역 길이</target>
        </trans-unit>
        <trans-unit id="977169a2f56615065497cd1735f54129679d50ec" translate="yes" xml:space="preserve">
          <source>Heap</source>
          <target state="translated">Heap</target>
        </trans-unit>
        <trans-unit id="e10aa6b979969f7c629b2451c2c2a904b3d450a7" translate="yes" xml:space="preserve">
          <source>Heap-Only Tuples</source>
          <target state="translated">힙 전용 튜플</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="0107076effd18727f0d6bde8cfc48a85171576c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;*&lt;/code&gt; is a shorthand for &amp;ldquo;all columns&amp;rdquo;. &lt;a href=&quot;#ftn.id-1.4.4.6.2.10&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.2.10&quot;&gt;[2]&lt;/sup&gt;&lt;/a&gt; So the same result would be had with:</source>
          <target state="translated">여기서 &lt;code&gt;*&lt;/code&gt; 는&amp;ldquo;모든 열&amp;rdquo;의 약어입니다. &lt;a href=&quot;#ftn.id-1.4.4.6.2.10&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.2.10&quot;&gt;[2]&lt;/sup&gt;&lt;/a&gt; 따라서 동일한 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4c0298ee7318c32798634cdbf2dfdaaab57a634f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;ANY&lt;/code&gt; can be considered either as introducing a subquery, or as being an aggregate function, if the subquery returns one row with a Boolean value. Thus the standard name cannot be given to these aggregates.</source>
          <target state="translated">여기서 &lt;code&gt;ANY&lt;/code&gt; , 부질 도입으로, 또는 총 함수로서 간주 될 수 어느 부질 돌아 가면 부울 값과 하나의 행. 따라서 이러한 집계에는 표준 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa4131a740f8662a6e1405a124ef5fe7cf873c01" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;expression&lt;/code&gt; is an arbitrary value expression that is evaluated for all rows. A set of rows for which all the expressions are equal are considered duplicates, and only the first row of the set is kept in the output. Note that the &amp;ldquo;first row&amp;rdquo; of a set is unpredictable unless the query is sorted on enough columns to guarantee a unique ordering of the rows arriving at the &lt;code&gt;DISTINCT&lt;/code&gt; filter. (&lt;code&gt;DISTINCT ON&lt;/code&gt; processing occurs after &lt;code&gt;ORDER BY&lt;/code&gt; sorting.)</source>
          <target state="translated">여기서 &lt;code&gt;expression&lt;/code&gt; 은 모든 행에 대해 평가되는 임의의 값 표현식입니다. 모든 표현식이 동일한 행 세트는 중복으로 간주되며 세트의 첫 번째 행만 출력에 유지됩니다. &lt;code&gt;DISTINCT&lt;/code&gt; 필터에 도달하는 행의 고유 한 순서를 보장하기 위해 쿼리가 충분한 열에서 정렬되지 않으면 세트의 &quot;첫 번째 행&quot;을 예측할 수 없습니다 . ( &lt;code&gt;ORDER BY&lt;/code&gt; 정렬 후 &lt;code&gt;DISTINCT ON&lt;/code&gt; 처리가 발생합니다 .)</target>
        </trans-unit>
        <trans-unit id="32e70bf63bd6299c1b514b324e5813b6785f48fc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;sum&lt;/code&gt; is an aggregate function that computes a single value over the entire group. More information about the available aggregate functions can be found in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;sum&lt;/code&gt; 은 전체 그룹에서 단일 값을 계산하는 집계 함수입니다. 사용 가능한 집계 함수에 대한 자세한 정보는 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.20&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d1138b514ed4337e7415d5a15b6a232b2308f96" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;sum&lt;/code&gt; is an aggregate function that computes a single value over the entire group. More information about the available aggregate functions can be found in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;sum&lt;/code&gt; 은 전체 그룹에 대해 단일 값을 계산하는 집계 함수입니다. 사용 가능한 집계 함수에 대한 자세한 내용은 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.21&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c74e599f4f4cd10f806357bb4a577d879a636f92" translate="yes" xml:space="preserve">
          <source>Here again, the result row ordering might vary. You can ensure consistent results by using &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; together: &lt;a href=&quot;#ftn.id-1.4.4.6.6.7&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.6.7&quot;&gt;[3]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">여기서도 결과 행 순서가 다를 수 있습니다. &lt;code&gt;DISTINCT&lt;/code&gt; 와 &lt;code&gt;ORDER BY&lt;/code&gt; 를 함께 사용하면 일관된 결과를 얻을 수 있습니다 . &lt;a href=&quot;#ftn.id-1.4.4.6.6.7&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.6.7&quot;&gt;[3]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9361fe781c0dc9515f2a15d806649d45978ad2ff" translate="yes" xml:space="preserve">
          <source>Here are a few more operating-system-specific suggestions. (In each case be sure to use the proper installation directory and user name where we show generic values.)</source>
          <target state="translated">운영 체제 별 제안 사항이 몇 가지 더 있습니다. (각각의 경우 일반적인 값을 표시하는 올바른 설치 디렉토리 및 사용자 이름을 사용해야합니다.)</target>
        </trans-unit>
        <trans-unit id="33c629349369b081c96a4709bd4c05ca3d526b68" translate="yes" xml:space="preserve">
          <source>Here are examples using &lt;code&gt;width&lt;/code&gt; fields and the &lt;code&gt;-&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 필드와 &lt;code&gt;-&lt;/code&gt; 플래그를 사용하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3f1ddfcdc9a3ca5369958338ec3215bfb4261c95" translate="yes" xml:space="preserve">
          <source>Here are examples using &lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt; fields and the &lt;code&gt;-&lt;/code&gt; flag:</source>
          <target state="translated">다음은 &lt;em&gt; &lt;code&gt;width&lt;/code&gt; &lt;/em&gt; 필드와 &lt;code&gt;-&lt;/code&gt; 플래그를 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="7e1f296e08c37893cc7499c23d5ef526f191a997" translate="yes" xml:space="preserve">
          <source>Here are some example collations that might be created:</source>
          <target state="translated">생성 될 수있는 데이터 정렬의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="794bf261c0ef6d9f03e6ee073f42ca9e62437531" translate="yes" xml:space="preserve">
          <source>Here are some examples for the Norwegian language:</source>
          <target state="translated">노르웨이어에 대한 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aedfd7af6c8c45fb8ea4b749385a6c955d7ebd4b" translate="yes" xml:space="preserve">
          <source>Here are some examples of &lt;code&gt;WHERE&lt;/code&gt; clauses:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2b46ad535b1f1605c8d8b383d4b83d313d3c5c39" translate="yes" xml:space="preserve">
          <source>Here are some examples of full text search:</source>
          <target state="translated">전체 텍스트 검색의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59581a37d8149d77f6e2121b432ef3ab5471d652" translate="yes" xml:space="preserve">
          <source>Here are some examples of path matching:</source>
          <target state="translated">경로 일치의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="081304796cf08884f88e8e57322d960864d34d64" translate="yes" xml:space="preserve">
          <source>Here are some examples of the basic format conversions:</source>
          <target state="translated">기본 형식 변환의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6671c9ef7af5c4291212558669b68a47697a4f97" translate="yes" xml:space="preserve">
          <source>Here are some examples of the proper syntax for inserting and updating composite columns. First, inserting or updating a whole column:</source>
          <target state="translated">다음은 복합 열을 삽입하고 업데이트하기위한 올바른 구문의 예입니다. 먼저 전체 열을 삽입하거나 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="cff6bd1f9746e782ec9405f845ffac129954f75a" translate="yes" xml:space="preserve">
          <source>Here are some suggestions about the easiest ways to perform common tasks when updating catalog data files.</source>
          <target state="translated">다음은 카탈로그 데이터 파일을 업데이트 할 때 일반적인 작업을 수행하는 가장 쉬운 방법에 대한 제안입니다.</target>
        </trans-unit>
        <trans-unit id="8d395c7f381e1a472cda6f6e9e7b568dac052ead" translate="yes" xml:space="preserve">
          <source>Here are some trivial examples to help you get started. For more information and examples, see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;.</source>
          <target state="translated">다음은 시작하는 데 도움이되는 간단한 예입니다. 자세한 정보 및 예는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;섹션 37.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="26b8e6990652910b8bb15ce27b2a3afd5fd095c9" translate="yes" xml:space="preserve">
          <source>Here are some trivial examples to help you get started. For more information and examples, see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;.</source>
          <target state="translated">다음은 시작하는 데 도움이되는 몇 가지 간단한 예입니다. 자세한 정보와 예는 &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;섹션 37.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="211fc895cd2c281ef748e752305609850c1006cd" translate="yes" xml:space="preserve">
          <source>Here are some usage examples:</source>
          <target state="translated">사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="869c324dd483307e5d715a3f86abbbcd015bfd60" translate="yes" xml:space="preserve">
          <source>Here are two complete examples:</source>
          <target state="translated">다음은 두 가지 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="461b806fbebb6f513c6608122e9ae50853cfb34f" translate="yes" xml:space="preserve">
          <source>Here are two simple examples of defining composite types:</source>
          <target state="translated">복합 유형을 정의하는 간단한 두 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24ca8b33236bc0d0ef50e2dd43fb66e04162b483" translate="yes" xml:space="preserve">
          <source>Here is a complete example:</source>
          <target state="translated">다음은 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="879a2b3e6157baeae30fe41038c69a70091e7ab2" translate="yes" xml:space="preserve">
          <source>Here is a concatenation of two values of unspecified types:</source>
          <target state="translated">다음은 지정되지 않은 유형의 두 값을 연결 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc7d83360ed38ff4e831e43a35b15e111bd3cccc" translate="yes" xml:space="preserve">
          <source>Here is a more complete example of bloom index definition and usage, as well as a comparison with equivalent btree indexes. The bloom index is considerably smaller than the btree index, and can perform better.</source>
          <target state="translated">다음은 블룸 인덱스 정의 및 사용법에 대한보다 완전한 예제와 동등한 btree 인덱스와의 비교입니다. 블룸 인덱스는 btree 인덱스보다 상당히 작으며 더 잘 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6e374336fa7e724d2419753cd63165e6b67b04" translate="yes" xml:space="preserve">
          <source>Here is a more complex example: &lt;code&gt;to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')&lt;/code&gt; is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds + 1230 microseconds = 2.021230 seconds.</source>
          <target state="translated">더 복잡한 예는 다음과 같습니다. &lt;code&gt;to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')&lt;/code&gt; 는 15 시간, 12 분 및 2 초 + 20 밀리 초 + 1230 마이크로 초 = 2.021230 초입니다. .</target>
        </trans-unit>
        <trans-unit id="4b2dfe5ad07694de5eeb1cdf20070a788ef8e7be" translate="yes" xml:space="preserve">
          <source>Here is a sample of data suitable for copying into a table from &lt;code&gt;STDIN&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;STDIN&lt;/code&gt; 에서 테이블로 복사하기에 적합한 데이터 샘플입니다 .</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="79fce6a010075477b9d4f3d2b7d0892550a64ad8" translate="yes" xml:space="preserve">
          <source>Here is a snippet of a log file generated in a single-client run:</source>
          <target state="translated">다음은 단일 클라이언트 실행에서 생성 된 로그 파일의 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="5a5fc7880a4ea236d1b3bb1d32e27412d9d31338" translate="yes" xml:space="preserve">
          <source>Here is a trivial example, just to show what the output looks like:</source>
          <target state="translated">다음은 출력 결과를 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="196e7b38bd23094a34f08fd4e1d56d0de9737199" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration that uses &lt;code&gt;ldapsearchfilter&lt;/code&gt; instead of &lt;code&gt;ldapsearchattribute&lt;/code&gt; to allow authentication by user ID or email address:</source>
          <target state="translated">다음은 &lt;code&gt;ldapsearchfilter&lt;/code&gt; 대신 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 를 사용하여 사용자 ID 또는 이메일 주소로 인증 할 수 있는 검색 + 바인드 구성의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="adb407aa80bcb23407a6343cd3fb06a44aaa7159" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration that uses DNS SRV discovery to find the host name(s) and port(s) for the LDAP service for the domain name &lt;code&gt;example.net&lt;/code&gt;:</source>
          <target state="translated">다음은 DNS SRV 감지를 사용하여 도메인 이름 &lt;code&gt;example.net&lt;/code&gt; 에 대한 LDAP 서비스의 호스트 이름 및 포트를 찾는 검색 + 바인드 구성의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8294bedf7f93c4debbc985ac5b71d91485ccb87a" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration:</source>
          <target state="translated">검색 + 바인드 구성의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1012c91578d9866c1a1a935ccf5f74b1c398069" translate="yes" xml:space="preserve">
          <source>Here is an example for a simple-bind LDAP configuration:</source>
          <target state="translated">다음은 단순 바인딩 LDAP 구성의 예입니다.</target>
        </trans-unit>
        <trans-unit id="1e2a8eb0839de265c32ba8726c7fb8ce612f9ebc" translate="yes" xml:space="preserve">
          <source>Here is an example of a dictionary definition using the &lt;code&gt;simple&lt;/code&gt; template:</source>
          <target state="translated">다음은 &lt;code&gt;simple&lt;/code&gt; 템플릿을 사용하는 사전 정의의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="d6c310d42c6ff4f581c1e303b9eef10bb403ca6c" translate="yes" xml:space="preserve">
          <source>Here is an example of a function with an ordinality column added:</source>
          <target state="translated">다음은 순서 열이 추가 된 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="39d9a1ec97da0de0b2ebe001d89411c194d0136a" translate="yes" xml:space="preserve">
          <source>Here is an example of a query plan for a query using an aggregate function:</source>
          <target state="translated">다음은 집계 함수를 사용하는 쿼리에 대한 쿼리 계획의 예입니다.</target>
        </trans-unit>
        <trans-unit id="f6d493babc38181bb9e797ebc36b6dee1ed42248" translate="yes" xml:space="preserve">
          <source>Here is an example of collecting functional-dependency statistics:</source>
          <target state="translated">다음은 기능 종속 통계를 수집하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d635cae1e0a20113dd837d7519806bc17d144c7b" translate="yes" xml:space="preserve">
          <source>Here is an example of creating a foreign table with &lt;code&gt;postgres_fdw&lt;/code&gt;. First install the extension:</source>
          <target state="translated">다음은 &lt;code&gt;postgres_fdw&lt;/code&gt; 로 외래 테이블을 만드는 예입니다 . 먼저 확장을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a9d65bbbca8355ed90ddee51a853e323cb2c5356" translate="yes" xml:space="preserve">
          <source>Here is an example of how wait events can be viewed</source>
          <target state="translated">다음은 대기 이벤트를 보는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="d1ba55b43049bc0f3ea6eba1c4f511076f5487a7" translate="yes" xml:space="preserve">
          <source>Here is an example of how wait events can be viewed:</source>
          <target state="translated">다음은 대기 이벤트를 볼 수있는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="289e8ce361948510d7bea9298d834548d8a0bcac" translate="yes" xml:space="preserve">
          <source>Here is an example of selecting a sample of a table with &lt;code&gt;SYSTEM_ROWS&lt;/code&gt;. First install the extension:</source>
          <target state="translated">다음은 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 로 테이블 샘플을 선택하는 예입니다 . 먼저 확장을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a28a21ccc575549b0e4278f1befd6c3171d0c15c" translate="yes" xml:space="preserve">
          <source>Here is an example of selecting a sample of a table with &lt;code&gt;SYSTEM_TIME&lt;/code&gt;. First install the extension:</source>
          <target state="translated">다음은 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; 으로 테이블 샘플을 선택하는 예입니다 . 먼저 확장을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="6c1b25585e57445c9a690160c1f6293b2c2334f6" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; to display the execution plan for a prepared query:</source>
          <target state="translated">다음은 &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; 를 사용하여 준비된 쿼리에 대한 실행 계획을 표시 하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="3d0353f1bd1f4e5d0cdada03e8194af993f90dd3" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to initialize a fresh database cluster with &lt;code&gt;sepgsql&lt;/code&gt; functions and security labels installed. Adjust the paths shown as appropriate for your installation:</source>
          <target state="translated">다음은 &lt;code&gt;sepgsql&lt;/code&gt; 함수 및 보안 레이블이 설치된 새 데이터베이스 클러스터를 초기화하는 방법을 보여주는 예 입니다. 설치에 따라 표시된 경로를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="f5681a46af83bb7c4af1228232eef4280217edbe" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to insert the &lt;code&gt;unaccent&lt;/code&gt; dictionary into a text search configuration:</source>
          <target state="translated">다음은 &lt;code&gt;unaccent&lt;/code&gt; 사전을 텍스트 검색 구성 에 삽입하는 방법을 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="740b499e9d1667a11938c2361c53f8d80be32b73" translate="yes" xml:space="preserve">
          <source>Here is an example showing the effects of &lt;code&gt;LIMIT&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;LIMIT&lt;/code&gt; 의 효과를 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b663de54fe9a475edef4cab194ba9fd34363260e" translate="yes" xml:space="preserve">
          <source>Here is an example that selects only the ten highest-ranked matches:</source>
          <target state="translated">다음은 10 개의 최고 순위 일치 항목 만 선택하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="df8103a128aa015d77a6739520d4e9345c77b089" translate="yes" xml:space="preserve">
          <source>Here is an example that shows how to compare each employee's salary with the average salary in his or her department:</source>
          <target state="translated">다음은 각 직원의 급여를 부서의 평균 급여와 비교하는 방법을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b75486070871a14c2ef5c89ea4b7f39dda615103" translate="yes" xml:space="preserve">
          <source>Here is another example of resolving an operator with one known and one unknown input:</source>
          <target state="translated">다음은 하나의 알려진 입력과 하나의 알려지지 않은 입력으로 연산자를 해결하는 또 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="862cabf7adcfd5c087659f8a55b3eecf121ea793" translate="yes" xml:space="preserve">
          <source>Here is another example: it calculates the total sales for each product (rather than the total sales of all products):</source>
          <target state="translated">또 다른 예는 다음과 같습니다. 모든 제품의 총 매출이 아닌 각 제품의 총 매출을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a6970b339f07dcc03e141391304c0d8752344244" translate="yes" xml:space="preserve">
          <source>Here is sample status output from pg_ctl:</source>
          <target state="translated">다음은 pg_ctl의 샘플 상태 출력입니다.</target>
        </trans-unit>
        <trans-unit id="1352c501bf85911546ec6a7652f925835c799c63" translate="yes" xml:space="preserve">
          <source>Here is some example output:</source>
          <target state="translated">다음은 예제 출력입니다.</target>
        </trans-unit>
        <trans-unit id="e962869eb6c37279a68d52de2ccf4f45b22a61bc" translate="yes" xml:space="preserve">
          <source>Here is the same plan with cost estimates suppressed:</source>
          <target state="translated">비용 산정이 억제 된 동일한 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fabdc0d28afb5f0b655ec42a14587280ddf1ed63" translate="yes" xml:space="preserve">
          <source>Here is the same query, but in YAML format:</source>
          <target state="translated">다음은 동일한 쿼리이지만 YAML 형식입니다.</target>
        </trans-unit>
        <trans-unit id="760b794b45c32777224d4cbdefb3ac43472e24da" translate="yes" xml:space="preserve">
          <source>Here is the same query, with JSON output formatting:</source>
          <target state="translated">다음은 JSON 출력 형식의 동일한 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="a12bd1a7adf1cd80938f005fb42c32962ebef7a7" translate="yes" xml:space="preserve">
          <source>Here is the same search+bind configuration written as a URL:</source>
          <target state="translated">다음은 URL로 작성된 동일한 검색 + 바인드 구성입니다.</target>
        </trans-unit>
        <trans-unit id="841d1a406c85c774b7e74eabd4886bcaf8000efc" translate="yes" xml:space="preserve">
          <source>Here it can be seen that column 1 (zip code) fully determines column 5 (city) so the coefficient is 1.0, while city only determines zip code about 42% of the time, meaning that there are many cities (58%) that are represented by more than a single ZIP code.</source>
          <target state="translated">여기서 1 열 (우편 번호)은 5 열 (도시)을 완전히 결정하므로 계수는 1.0이고, 도시는 우편 번호를 시간의 약 42 % 만 결정하므로 많은 도시 (58 %)가 있음을 의미합니다. 하나 이상의 우편 번호로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae0c10bf978a8e41d20283c701cce10abe5e998" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;$1&lt;/code&gt; references the value of the first function argument whenever the function is invoked.</source>
          <target state="translated">여기서 &lt;code&gt;$1&lt;/code&gt; 은 함수가 호출 될 때마다 첫 번째 함수 인수의 값을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="e24bb102552ef59f6370ebf0e5c3297d839673d3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ONLY&lt;/code&gt; before &lt;code&gt;cities&lt;/code&gt; indicates that the query should be run over only the &lt;code&gt;cities&lt;/code&gt; table, and not tables below &lt;code&gt;cities&lt;/code&gt; in the inheritance hierarchy. Many of the commands that we have already discussed &amp;mdash; &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; &amp;mdash; support this &lt;code&gt;ONLY&lt;/code&gt; notation.</source>
          <target state="translated">여기에 &lt;code&gt;ONLY&lt;/code&gt; 전에 &lt;code&gt;cities&lt;/code&gt; 쿼리 만 이상 실행해야 함을 나타냅니다 &lt;code&gt;cities&lt;/code&gt; 아래 테이블을 테이블을, 그리고 &lt;code&gt;cities&lt;/code&gt; 상속 계층 구조입니다. 이미 논의한 많은 명령 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; ) 은이 표기법 &lt;code&gt;ONLY&lt;/code&gt; 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c60ac8b55debcc4cd6f35118bfe06a2acf106ceb" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ONLY&lt;/code&gt; keyword indicates that the query should apply only to &lt;code&gt;cities&lt;/code&gt;, and not any tables below &lt;code&gt;cities&lt;/code&gt; in the inheritance hierarchy. Many of the commands that we have already discussed &amp;mdash; &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; &amp;mdash; support the &lt;code&gt;ONLY&lt;/code&gt; keyword.</source>
          <target state="translated">여기서 &lt;code&gt;ONLY&lt;/code&gt; 키워드는 상속 계층 구조에서 &lt;code&gt;cities&lt;/code&gt; 아래에있는 테이블이 아니라 쿼리 만 &lt;code&gt;cities&lt;/code&gt; 적용해야 함을 나타냅니다 . 이미 논의한 많은 명령 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; ) 은 &lt;code&gt;ONLY&lt;/code&gt; 키워드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="180331b7141355384ecd89f79e056920df2b9440" translate="yes" xml:space="preserve">
          <source>Here the first field is a non-NULL empty string, the third is NULL.</source>
          <target state="translated">여기서 첫 번째 필드는 NULL이 아닌 빈 문자열이고 세 번째 필드는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="5f5c637c8dd6f2e0bc8a363ff5737852d1e4d516" translate="yes" xml:space="preserve">
          <source>Here the planner has decided to use a two-step plan: the child plan node visits an index to find the locations of rows matching the index condition, and then the upper plan node actually fetches those rows from the table itself. Fetching rows separately is much more expensive than reading them sequentially, but because not all the pages of the table have to be visited, this is still cheaper than a sequential scan. (The reason for using two plan levels is that the upper plan node sorts the row locations identified by the index into physical order before reading them, to minimize the cost of separate fetches. The &amp;ldquo;bitmap&amp;rdquo; mentioned in the node names is the mechanism that does the sorting.)</source>
          <target state="translated">여기서 플래너는 2 단계 계획을 사용하기로 결정했습니다. 하위 계획 노드는 인덱스를 방문하여 인덱스 조건과 일치하는 행의 위치를 ​​찾은 다음 상위 계획 노드는 실제로 해당 행을 테이블 자체에서 가져옵니다. 행을 개별적으로 가져 오는 것은 순차적으로 읽는 것보다 훨씬 비싸지 만 테이블의 모든 페이지를 방문 할 필요는 없기 때문에 순차 스캔보다 저렴합니다. (두 개의 계획 레벨을 사용하는 이유는 상위 계획 노드가 인덱스를 통해 식별 된 행 위치를 읽기 전에 물리적 순서로 정렬하여 별도의 페치 비용을 최소화하기 때문입니다. 노드 이름에 언급 된 &quot;비트 맵&quot;은 정렬합니다.)</target>
        </trans-unit>
        <trans-unit id="09e8656c67ee501e993f2cabda72b9c29cefa0ac" translate="yes" xml:space="preserve">
          <source>Here the query's IP address is covered by the partial index. The following query cannot use the partial index, as it uses an IP address that is excluded from the index:</source>
          <target state="translated">여기서 쿼리의 IP 주소는 부분 인덱스로 덮여 있습니다. 다음 쿼리는 인덱스에서 제외 된 IP 주소를 사용하므로 부분 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ec31c843165653bc80fe695cd716d3b9ef2fc60" translate="yes" xml:space="preserve">
          <source>Here the sum is taken from the first (lowest) salary up through the current one, including any duplicates of the current one (notice the results for the duplicated salaries).</source>
          <target state="translated">여기서 합계는 현재 급여의 사본을 포함하여 현재 급여를 통해 첫 번째 (가장 낮은) 급여에서 가져옵니다 (중복 급여의 결과에 주목).</target>
        </trans-unit>
        <trans-unit id="537366727b0a957f32d32f1d223a0385ada41099" translate="yes" xml:space="preserve">
          <source>Here the system has implicitly resolved the unknown-type literal as type &lt;code&gt;float8&lt;/code&gt; before applying the chosen operator. We can verify that &lt;code&gt;float8&lt;/code&gt; and not some other type was used:</source>
          <target state="translated">여기서 시스템은 선택된 연산자를 적용하기 전에 알 수없는 유형 리터럴을 &lt;code&gt;float8&lt;/code&gt; 유형으로 암시 적으로 해결했습니다 . &lt;code&gt;float8&lt;/code&gt; 과 다른 유형이 사용되지 않았 음을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf1e98ca0f0c927b9d08ba4561b2098f2af147e3" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;tenk1&lt;/code&gt; contains 10000 rows, as do its indexes, but the indexes are (unsurprisingly) much smaller than the table.</source>
          <target state="translated">여기서는 인덱스와 마찬가지로 &lt;code&gt;tenk1&lt;/code&gt; 에 10000 개의 행이 포함되어 있지만 인덱스가 테이블보다 훨씬 작다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0eab29aaf89686f1fe2e4313a3e207759c193e4" translate="yes" xml:space="preserve">
          <source>Here we can see that the index returned one candidate row, which was then rejected by a recheck of the index condition. This happens because a GiST index is &amp;ldquo;lossy&amp;rdquo; for polygon containment tests: it actually returns the rows with polygons that overlap the target, and then we have to do the exact containment test on those rows.</source>
          <target state="translated">여기서 인덱스가 하나의 후보 행을 리턴 한 후 인덱스 조건을 다시 점검하여 거부되었음을 알 수 있습니다. GiST 인덱스는 다각형 포함 테스트에 대해 &quot;손실&quot;하기 때문에 발생합니다. 실제로 대상과 겹치는 다각형이있는 행을 반환 한 다음 해당 행에 대해 정확한 포함 테스트를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d135a143a8ec460162e891ace4cc0562f7f0ea6" translate="yes" xml:space="preserve">
          <source>Here we give a short overview of the stages a query has to pass in order to obtain a result.</source>
          <target state="translated">여기서는 결과를 얻기 위해 쿼리가 통과해야하는 단계에 대한 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bcbe633ffbd28597ca13c601e922e114369f31f0" translate="yes" xml:space="preserve">
          <source>Here we have relabeled the weather table as &lt;code&gt;W1&lt;/code&gt; and &lt;code&gt;W2&lt;/code&gt; to be able to distinguish the left and right side of the join. You can also use these kinds of aliases in other queries to save some typing, e.g.:</source>
          <target state="translated">여기 에서는 조인의 왼쪽과 오른쪽을 구별 할 수 있도록 날씨 테이블의 레이블을 &lt;code&gt;W1&lt;/code&gt; 과 &lt;code&gt;W2&lt;/code&gt; 로 재 지정 했습니다. 다른 쿼리에서 이러한 종류의 별칭을 사용하여 입력 내용을 저장할 수도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="42307deb2832e0c7af756f3107b84bf8b2ea8057" translate="yes" xml:space="preserve">
          <source>Here we have used &lt;code&gt;setweight&lt;/code&gt; to label the source of each lexeme in the finished &lt;code&gt;tsvector&lt;/code&gt;, and then merged the labeled &lt;code&gt;tsvector&lt;/code&gt; values using the &lt;code&gt;tsvector&lt;/code&gt; concatenation operator &lt;code&gt;||&lt;/code&gt;. (&lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; gives details about these operations.)</source>
          <target state="translated">여기에 우리가 사용하고 &lt;code&gt;setweight&lt;/code&gt; 을 완성 각 어휘의 소스 레이블을 &lt;code&gt;tsvector&lt;/code&gt; 한 다음 표시된 통합 &lt;code&gt;tsvector&lt;/code&gt; 의 사용하여 값 &lt;code&gt;tsvector&lt;/code&gt; 의 연결 연산자를 &lt;code&gt;||&lt;/code&gt; . ( &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;12.4.1 절&lt;/a&gt; 에 이러한 작업에 대한 자세한 내용이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ebe0ff0a0f834e90a6235b06460f658da331e569" translate="yes" xml:space="preserve">
          <source>Here's a simple example of usage:</source>
          <target state="translated">다음은 간단한 사용법 예입니다.</target>
        </trans-unit>
        <trans-unit id="a00d1ad8972f6aee9ca962b7dd2f9cc873a842a4" translate="yes" xml:space="preserve">
          <source>Here's an annotated example of &lt;code&gt;lquery&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;lquery&lt;/code&gt; 의 주석이 달린 예입니다 .</target>
        </trans-unit>
        <trans-unit id="d49be83bb6ef95a34484a28f1063c126af2cd0f3" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;ltxtquery&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;ltxtquery&lt;/code&gt; 예 입니다 .</target>
        </trans-unit>
        <trans-unit id="48493c355bde53a50b460fe64d3981e1bf2c28dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;DictFile&lt;/code&gt;, &lt;code&gt;AffFile&lt;/code&gt;, and &lt;code&gt;StopWords&lt;/code&gt; specify the base names of the dictionary, affixes, and stop-words files. The stop-words file has the same format explained above for the &lt;code&gt;simple&lt;/code&gt; dictionary type. The format of the other files is not specified here but is available from the above-mentioned web sites.</source>
          <target state="translated">여기에서 &lt;code&gt;DictFile&lt;/code&gt; , &lt;code&gt;AffFile&lt;/code&gt; 및 &lt;code&gt;StopWords&lt;/code&gt; 는 사전, 접두사 및 중지 단어 파일의 기본 이름을 지정합니다. 중지 단어 파일은 &lt;code&gt;simple&lt;/code&gt; 사전 유형에 대해 위에서 설명한 것과 동일한 형식 입니다. 다른 파일의 형식은 여기에 지정되어 있지 않지만 위에서 언급 한 웹 사이트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a15f0741ab9f0607b3961ed00005a1407be190df" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;db_column:update&lt;/code&gt; will be checked for &lt;code&gt;t1.x&lt;/code&gt;, since it is being updated, &lt;code&gt;db_column:{select update}&lt;/code&gt; will be checked for &lt;code&gt;t1.y&lt;/code&gt;, since it is both updated and referenced, and &lt;code&gt;db_column:select&lt;/code&gt; will be checked for &lt;code&gt;t1.z&lt;/code&gt;, since it is only referenced. &lt;code&gt;db_table:{select update}&lt;/code&gt; will also be checked at the table level.</source>
          <target state="translated">여기, &lt;code&gt;db_column:update&lt;/code&gt; 에 대한 확인됩니다 &lt;code&gt;t1.x&lt;/code&gt; 가 업데이트되고 있기 때문에, &lt;code&gt;db_column:{select update}&lt;/code&gt; 에 대해 확인됩니다 &lt;code&gt;t1.y&lt;/code&gt; 가 모두 업데이트 및 참조하기 때문에, 그리고 &lt;code&gt;db_column:select&lt;/code&gt; 을 위해 확인됩니다 &lt;code&gt;t1.z&lt;/code&gt; 만 참조되므로 참조하십시오. &lt;code&gt;db_table:{select update}&lt;/code&gt; 도 테이블 레벨에서 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="94323f34e2769fd6d8140ecf86916e1a4ffa6df9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;english&lt;/code&gt; is the base name of a file of stop words. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/english.stop&lt;/code&gt;, where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory, often &lt;code&gt;/usr/local/share/postgresql&lt;/code&gt; (use &lt;code&gt;pg_config --sharedir&lt;/code&gt; to determine it if you're not sure). The file format is simply a list of words, one per line. Blank lines and trailing spaces are ignored, and upper case is folded to lower case, but no other processing is done on the file contents.</source>
          <target state="translated">여기서 &lt;code&gt;english&lt;/code&gt; 는 중지 단어 파일의 기본 이름입니다. 파일의 전체 이름이 될 것입니다 &lt;code&gt;$SHAREDIR/tsearch_data/english.stop&lt;/code&gt; 여기서 &lt;code&gt;$SHAREDIR&lt;/code&gt; PostgreSQL의 설치의 공유 데이터 디렉토리, 종종 의미 &lt;code&gt;/usr/local/share/postgresql&lt;/code&gt; (사용 &lt;code&gt;pg_config --sharedir&lt;/code&gt; 을 당신이하지 않으면 그것을 결정 확실한). 파일 형식은 단순히 한 줄에 하나씩 단어 목록입니다. 빈 줄과 후행 공백은 무시되고 대문자는 소문자로 접혀 지지만 파일 내용에 대해서는 다른 처리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c3b85c63ac80bdd86554daac13d878a06c56b22" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;expression&lt;/code&gt; represents any value expression that does not itself contain window function calls.</source>
          <target state="translated">여기서 &lt;code&gt;expression&lt;/code&gt; 은 자체적으로 창 함수 호출을 포함하지 않는 값 표현식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b22882051bae4c80aed43f53d018119709936657" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;key&lt;/code&gt; is an element in the index and &lt;code&gt;query&lt;/code&gt; the value being looked up in the index. The &lt;code&gt;StrategyNumber&lt;/code&gt; parameter indicates which operator of your operator class is being applied &amp;mdash; it matches one of the operator numbers in the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command.</source>
          <target state="translated">여기서 &lt;code&gt;key&lt;/code&gt; 는 인덱스의 요소이며 인덱스에서 &lt;code&gt;query&lt;/code&gt; 되는 값을 쿼리 합니다. &lt;code&gt;StrategyNumber&lt;/code&gt; 의 매개 변수는 적용되는 운영자 클래스의 어떤 연산자를 나타냅니다 - 그것은에서 운영자 번호 중 하나와 일치 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 의 명령.</target>
        </trans-unit>
        <trans-unit id="f689631caa32c4a22198886b0f15d59af75c4c1d" translate="yes" xml:space="preserve">
          <source>Here, all the input punctuation was discarded as being space symbols.</source>
          <target state="translated">여기에서 모든 입력 구두점은 공백 기호로 폐기되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ca2ace43c2caf64cad6ca5ff508187ff18cbed2" translate="yes" xml:space="preserve">
          <source>Here, all the input punctuation was discarded.</source>
          <target state="translated">여기에서는 모든 입력 구두점이 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2bea9418baff2dab8ad2f535eead313521a74b5" translate="yes" xml:space="preserve">
          <source>Here, condition has a format similar to the format of regular expressions. It can use groupings &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt;. For example, &lt;code&gt;[AEIOU]Y&lt;/code&gt; means that the last letter of the word is &lt;code&gt;&quot;y&quot;&lt;/code&gt; and the penultimate letter is &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;e&quot;&lt;/code&gt;, &lt;code&gt;&quot;i&quot;&lt;/code&gt;, &lt;code&gt;&quot;o&quot;&lt;/code&gt; or &lt;code&gt;&quot;u&quot;&lt;/code&gt;. &lt;code&gt;[^EY]&lt;/code&gt; means that the last letter is neither &lt;code&gt;&quot;e&quot;&lt;/code&gt; nor &lt;code&gt;&quot;y&quot;&lt;/code&gt;.</source>
          <target state="translated">여기서 조건은 정규식 형식과 유사한 형식을 갖습니다. 그룹화 &lt;code&gt;[...]&lt;/code&gt; 및 &lt;code&gt;[^...]&lt;/code&gt; 사용할 수 있습니다 . 예를 들어 &lt;code&gt;[AEIOU]Y&lt;/code&gt; 는 단어의 마지막 문자가 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 이고 두 번째 문자는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; , &lt;code&gt;&quot;e&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;o&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;u&quot;&lt;/code&gt; 입니다. &lt;code&gt;[^EY]&lt;/code&gt; 는 마지막 문자가 &lt;code&gt;&quot;e&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 가 아님을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="00e7b43ee7c6b641274238949f463079d5bbf579" translate="yes" xml:space="preserve">
          <source>Here, materialization of the &lt;code&gt;WITH&lt;/code&gt; query ensures that &lt;code&gt;very_expensive_function&lt;/code&gt; is evaluated only once per table row, not twice.</source>
          <target state="translated">여기서 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 &lt;code&gt;very_expensive_function&lt;/code&gt; 하면 very_expensive_function 이 두 번이 아니라 테이블 행당 한 번만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="eadb56d6708463f3d868c5af1a2244c7c4a3fed2" translate="yes" xml:space="preserve">
          <source>Here, since type &lt;code&gt;real&lt;/code&gt; cannot be implicitly cast to &lt;code&gt;integer&lt;/code&gt;, but &lt;code&gt;integer&lt;/code&gt; can be implicitly cast to &lt;code&gt;real&lt;/code&gt;, the union result type is resolved as &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;real&lt;/code&gt; 유형 은 암시 적으로 &lt;code&gt;integer&lt;/code&gt; 로 캐스트 할 수 없지만 &lt;code&gt;integer&lt;/code&gt; 는 암시 적으로 &lt;code&gt;real&lt;/code&gt; 로 캐스트 될 수 있으므로 공용체 결과 유형은 &lt;code&gt;real&lt;/code&gt; 로 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f0dca8cee0ac9d29f980481c680637be6b839c3" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;grouping&lt;/code&gt; value &lt;code&gt;0&lt;/code&gt; in the first four rows shows that those have been grouped normally, over both the grouping columns. The value &lt;code&gt;1&lt;/code&gt; indicates that &lt;code&gt;model&lt;/code&gt; was not grouped by in the next-to-last two rows, and the value &lt;code&gt;3&lt;/code&gt; indicates that neither &lt;code&gt;make&lt;/code&gt; nor &lt;code&gt;model&lt;/code&gt; was grouped by in the last row (which therefore is an aggregate over all the input rows).</source>
          <target state="translated">여기 에서 처음 4 개 행 의 &lt;code&gt;grouping&lt;/code&gt; 값 &lt;code&gt;0&lt;/code&gt; 은 두 그룹화 열에 대해 정상적으로 그룹화되었음을 나타냅니다. 값 &lt;code&gt;1&lt;/code&gt; 은 &lt;code&gt;model&lt;/code&gt; 이 마지막 두 행에서 그룹화 되지 않았 음을 나타내고 값 &lt;code&gt;3&lt;/code&gt; 은 &lt;code&gt;make&lt;/code&gt; 와 &lt;code&gt;model&lt;/code&gt; 이 마지막 행에서 그룹화 되지 않았 음을 나타냅니다 (따라서 모든 입력 행에 대한 집계 임).</target>
        </trans-unit>
        <trans-unit id="cfec33c2243bfacb00b180b26c912c2de7a8aad2" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;uppercase&lt;/code&gt; parameter is omitted, so it receives its default value of &lt;code&gt;false&lt;/code&gt;, resulting in lower case output. In positional notation, arguments can be omitted from right to left so long as they have defaults.</source>
          <target state="translated">여기서 &lt;code&gt;uppercase&lt;/code&gt; 매개 변수는 생략되므로 기본값 인 &lt;code&gt;false&lt;/code&gt; 를 수신하여 소문자 출력이 발생합니다. 위치 표기법에서는 기본값이있는 한 인수를 오른쪽에서 왼쪽으로 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c823dd873535ad7ccdb6e068431505db91bdcea6" translate="yes" xml:space="preserve">
          <source>Here, the planner has chosen to use a hash join, in which rows of one table are entered into an in-memory hash table, after which the other table is scanned and the hash table is probed for matches to each row. Again note how the indentation reflects the plan structure: the bitmap scan on &lt;code&gt;tenk1&lt;/code&gt; is the input to the Hash node, which constructs the hash table. That's then returned to the Hash Join node, which reads rows from its outer child plan and searches the hash table for each one.</source>
          <target state="translated">여기서 플래너는 한 테이블의 행이 메모리 내 해시 테이블에 입력 된 후 다른 테이블이 스캔되고 해시 테이블이 각 행과 일치하는지 조사되는 해시 조인을 사용하도록 선택했습니다. 들여 쓰기에 계획 구조가 어떻게 반영되는지 다시 한 번 주목하십시오. &lt;code&gt;tenk1&lt;/code&gt; 의 비트 맵 스캔 은 해시 노드에 대한 입력으로 해시 테이블을 구성합니다. 그런 다음 해시 조인 노드로 돌아갑니다.이 노드는 외부 자식 계획에서 행을 읽고 각 해시 테이블을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="5850a821f06c0b2f442ebe11558a575852c8aeb5" translate="yes" xml:space="preserve">
          <source>Here, the sequence &lt;code&gt;$q$[\t\r\n\v\\]$q$&lt;/code&gt; represents a dollar-quoted literal string &lt;code&gt;[\t\r\n\v\\]&lt;/code&gt;, which will be recognized when the function body is executed by PostgreSQL. But since the sequence does not match the outer dollar quoting delimiter &lt;code&gt;$function$&lt;/code&gt;, it is just some more characters within the constant so far as the outer string is concerned.</source>
          <target state="translated">여기서 &lt;code&gt;$q$[\t\r\n\v\\]$q$&lt;/code&gt; 시퀀스 는 달러 인용 리터럴 문자열 &lt;code&gt;[\t\r\n\v\\]&lt;/code&gt; 을 나타내며 함수 본문에서 인식됩니다. PostgreSQL에 의해 실행됩니다. 그러나 시퀀스가 ​​외부 달러 인용 구분 기호 &lt;code&gt;$function$&lt;/code&gt; 와 일치하지 않기 때문에 외부 문자열에 관한 한 상수 내에 더 많은 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e42cf0e074b0fa8e95e14f4ebb3e1b606554ddda" translate="yes" xml:space="preserve">
          <source>Here, the unknown-type literal &lt;code&gt;'b'&lt;/code&gt; will be resolved to type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">여기서 알 수없는 문자 리터럴 &lt;code&gt;'b'&lt;/code&gt; 는 &lt;code&gt;text&lt;/code&gt; 를 입력하도록 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="6789cbae03419b1c1cfba25dda2b2a3e23e7e4c6" translate="yes" xml:space="preserve">
          <source>Hex Representation</source>
          <target state="translated">16 진 표현</target>
        </trans-unit>
        <trans-unit id="120e75d0d27169271eff5b30f1995d939cf69223" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits are &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;, and &lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;. Octal digits are &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">진수 숫자들은 &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; , - &lt;code&gt;f&lt;/code&gt; 및 - &lt;code&gt;F&lt;/code&gt; . 진수 숫자는 &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffcadc3bbf92f4882971ddc3bc8286e63dfa62c0" translate="yes" xml:space="preserve">
          <source>High Availability</source>
          <target state="translated">고 가용성</target>
        </trans-unit>
        <trans-unit id="946223b4ede05fe838dc846e6faf0a89f88f0e1d" translate="yes" xml:space="preserve">
          <source>High Value</source>
          <target state="translated">높은 가치</target>
        </trans-unit>
        <trans-unit id="c23ab61c10027c96a9184ffc34b5fb7aecf016a1" translate="yes" xml:space="preserve">
          <source>Historically this module depended on the OSSP UUID library, which accounts for the module's name. While the OSSP UUID library can still be found at &lt;a href=&quot;http://www.ossp.org/pkg/lib/uuid/&quot;&gt;http://www.ossp.org/pkg/lib/uuid/&lt;/a&gt;, it is not well maintained, and is becoming increasingly difficult to port to newer platforms. &lt;code&gt;uuid-ossp&lt;/code&gt; can now be built without the OSSP library on some platforms. On FreeBSD, NetBSD, and some other BSD-derived platforms, suitable UUID creation functions are included in the core &lt;code&gt;libc&lt;/code&gt; library. On Linux, macOS, and some other platforms, suitable functions are provided in the &lt;code&gt;libuuid&lt;/code&gt; library, which originally came from the &lt;code&gt;e2fsprogs&lt;/code&gt; project (though on modern Linux it is considered part of &lt;code&gt;util-linux-ng&lt;/code&gt;). When invoking &lt;code&gt;configure&lt;/code&gt;, specify &lt;code&gt;--with-uuid=bsd&lt;/code&gt; to use the BSD functions, or &lt;code&gt;--with-uuid=e2fs&lt;/code&gt; to use &lt;code&gt;e2fsprogs&lt;/code&gt;' &lt;code&gt;libuuid&lt;/code&gt;, or &lt;code&gt;--with-uuid=ossp&lt;/code&gt; to use the OSSP UUID library. More than one of these libraries might be available on a particular machine, so &lt;code&gt;configure&lt;/code&gt; does not automatically choose one.</source>
          <target state="translated">역사적으로이 모듈은 모듈 이름을 설명하는 OSSP UUID 라이브러리에 의존했습니다. OSSP UUID 라이브러리는 여전히 &lt;a href=&quot;http://www.ossp.org/pkg/lib/uuid/&quot;&gt;http://www.ossp.org/pkg/lib/uuid/&lt;/a&gt; 에서 찾을 수 있지만 잘 관리되지 않아 새로운 플랫폼으로 포팅하기가 점점 어려워지고 있습니다. 일부 플랫폼에서 OSSP 라이브러리없이 &lt;code&gt;uuid-ossp&lt;/code&gt; 를 빌드 할 수 있습니다. FreeBSD, NetBSD 및 기타 BSD 파생 플랫폼에서 적합한 UUID 작성 기능이 코어 &lt;code&gt;libc&lt;/code&gt; 라이브러리에 포함되어 있습니다. Linux, macOS 및 기타 플랫폼의 경우 &lt;code&gt;libuuid&lt;/code&gt; 라이브러리 에 적합한 기능이 제공됩니다. libuuid 라이브러리는 원래 &lt;code&gt;e2fsprogs&lt;/code&gt; 프로젝트 에서 제공되었습니다 (현대 Linux에서는 &lt;code&gt;util-linux-ng&lt;/code&gt; 의 일부로 간주 됨)). &lt;code&gt;configure&lt;/code&gt; 를 호출 할 때 &lt;code&gt;--with-uuid=bsd&lt;/code&gt; 를 지정 하여 BSD 함수를 사용하거나 &lt;code&gt;--with-uuid=e2fs&lt;/code&gt; 를 지정하여 &lt;code&gt;e2fsprogs&lt;/code&gt; ' &lt;code&gt;libuuid&lt;/code&gt; 를 사용 하거나 &lt;code&gt;--with-uuid=ossp&lt;/code&gt; 를 지정하여 OSSP UUID 라이브러리를 사용하십시오. 특정 머신에서 이러한 라이브러리 중 둘 이상을 사용할 수 있으므로 &lt;code&gt;configure&lt;/code&gt; 가 자동으로 하나를 선택하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5584bf16896f3c913b27677d773698adc908eae" translate="yes" xml:space="preserve">
          <source>History of Units</source>
          <target state="translated">단위의 역사</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="7e3d4d69eb95f3292122a5fea9416ed4cba36be3" translate="yes" xml:space="preserve">
          <source>Host name of the connected client, as reported by a reverse DNS lookup of &lt;code&gt;client_addr&lt;/code&gt;. This field will only be non-null for IP connections, and only when &lt;a href=&quot;runtime-config-logging#GUC-LOG-HOSTNAME&quot;&gt;log_hostname&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;client_addr&lt;/code&gt; 의 역방향 DNS 조회에 의해보고 된 연결된 클라이언트의 호스트 이름입니다 . 이 필드는 IP 연결의 경우 null이 &lt;a href=&quot;runtime-config-logging#GUC-LOG-HOSTNAME&quot;&gt;아니며 log_hostname&lt;/a&gt; 이 활성화 된 경우에만 해당됩니다 .</target>
        </trans-unit>
        <trans-unit id="67b082e00139eb65670882e9969e878f533f20b1" translate="yes" xml:space="preserve">
          <source>Host name or IP address, or one of &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;samehost&lt;/code&gt;, or &lt;code&gt;samenet&lt;/code&gt;, or null for local connections</source>
          <target state="translated">호스트 이름 또는 IP 주소 또는 &lt;code&gt;all&lt;/code&gt; , &lt;code&gt;samehost&lt;/code&gt; 또는 &lt;code&gt;samenet&lt;/code&gt; 중 하나 또는 로컬 연결의 경우 null</target>
        </trans-unit>
        <trans-unit id="3acb05d9b4db45ddd95be7a72351a5560907bba2" translate="yes" xml:space="preserve">
          <source>Host of the PostgreSQL instance this WAL receiver is connected to. This can be a host name, an IP address, or a directory path if the connection is via Unix socket. (The path case can be distinguished because it will always be an absolute path, beginning with &lt;code&gt;/&lt;/code&gt;.)</source>
          <target state="translated">이 WAL 수신자가 연결된 PostgreSQL 인스턴스의 호스트입니다. Unix 소켓을 통한 연결 인 경우 호스트 이름, IP 주소 또는 디렉토리 경로 일 수 있습니다. (경로 대 / 소문자는 항상 &lt;code&gt;/&lt;/code&gt; 로 시작하는 절대 경로이므로 구분할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="e716495d010a3dcebf55c7c74d98bdb385a76508" translate="yes" xml:space="preserve">
          <source>Host-Based Authentication</source>
          <target state="translated">호스트 기반 인증</target>
        </trans-unit>
        <trans-unit id="cc53b246d6c96fb218922a66ec6b6ca310bf3021" translate="yes" xml:space="preserve">
          <source>Hot Standby</source>
          <target state="translated">핫 스탠바이</target>
        </trans-unit>
        <trans-unit id="d972243453928257bff4b6354fce98c1493ba542" translate="yes" xml:space="preserve">
          <source>Hot Standby feedback propagates upstream, whatever the cascaded arrangement.</source>
          <target state="translated">계단식 배열에 관계없이 핫 스탠바이 피드백은 업스트림으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="5091beeb3be00f483925a2bb31c058bfcaaaeb31" translate="yes" xml:space="preserve">
          <source>Hot Standby is the term used to describe the ability to connect to the server and run read-only queries while the server is in archive recovery or standby mode. This is useful both for replication purposes and for restoring a backup to a desired state with great precision. The term Hot Standby also refers to the ability of the server to move from recovery through to normal operation while users continue running queries and/or keep their connections open.</source>
          <target state="translated">핫 스탠바이는 서버가 아카이브 복구 또는 대기 모드에있는 동안 서버에 연결하고 읽기 전용 쿼리를 실행하는 기능을 설명하는 데 사용되는 용어입니다. 이는 복제 목적과 백업을 원하는 상태로 매우 정확하게 복원하는 데 유용합니다. 핫 스탠바이라는 용어는 사용자가 쿼리를 계속 실행하거나 연결을 열린 상태로 유지하면서 서버가 복구에서 정상 작동으로 이동하는 기능을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9e25a34e635a123f8958bbe26e7c4843278597fb" translate="yes" xml:space="preserve">
          <source>Hours</source>
          <target state="translated">Hours</target>
        </trans-unit>
        <trans-unit id="b8d371fd69de846ce0d56ec576287b8268a9b53e" translate="yes" xml:space="preserve">
          <source>How Connections Are Established</source>
          <target state="translated">연결 방법</target>
        </trans-unit>
        <trans-unit id="8cecc82d72d68f9151cb0901cfe40eeac15bfca6" translate="yes" xml:space="preserve">
          <source>How It Works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="a41409a5166c5d74bdffdf63899f116578d1e299" translate="yes" xml:space="preserve">
          <source>How Parallel Query Works</source>
          <target state="translated">병렬 쿼리 작동 방식</target>
        </trans-unit>
        <trans-unit id="7604442ec6b924ac1f168d8f81e9b0b61679f4f6" translate="yes" xml:space="preserve">
          <source>How many concurrent connections can be made to this database. -1 (the default) means no limit.</source>
          <target state="translated">이 데이터베이스에 동시에 연결할 수있는 횟수 -1 (기본값)은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d98f671ec6200c3b445e94f09f19857316dd290b" translate="yes" xml:space="preserve">
          <source>How many concurrent connections can be made to this database. -1 means no limit.</source>
          <target state="translated">이 데이터베이스에 동시에 연결할 수있는 횟수 -1은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e914be45633e81e1b35dd5a5a8544fdfa64c8d17" translate="yes" xml:space="preserve">
          <source>How much to compress. Higher levels compress smaller but are slower. 0 disables compression.</source>
          <target state="translated">압축 정도 높은 수준의 압축은 작지만 느립니다. 0은 압축을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ef6f180b70cdcd17c60a982706ebbdc6fbb46234" translate="yes" xml:space="preserve">
          <source>How the planner determines the cardinality of &lt;code&gt;tenk1&lt;/code&gt; is covered in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, but is repeated here for completeness. The number of pages and rows is looked up in &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">플래너가 &lt;code&gt;tenk1&lt;/code&gt; 의 카디널리티를 판별하는 방법은 &lt;a href=&quot;planner-stats&quot;&gt;섹션 14.2&lt;/a&gt; 에서 다루지 만 여기서는 완전성을 위해 반복됩니다. 페이지와 행 수는 &lt;code&gt;pg_class&lt;/code&gt; 에서 조회됩니다 .</target>
        </trans-unit>
        <trans-unit id="94ecf8c7f95f01155b7f0495cbc646415e78c1ae" translate="yes" xml:space="preserve">
          <source>How to choose a good password.</source>
          <target state="translated">올바른 비밀번호를 선택하는 방법</target>
        </trans-unit>
        <trans-unit id="2ba82223beeb024535e1c4a0ddfd885368b08372" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;jsonb&lt;/code&gt; will preserve trailing fractional zeroes, as seen in this example, even though those are semantically insignificant for purposes such as equality checks.</source>
          <target state="translated">그러나 &lt;code&gt;jsonb&lt;/code&gt; 는이 예에서 볼 수 있듯이 후행 소수 0을 유지하지만 등호 검사와 같은 목적 상 의미가 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="483f78f78539b97c5a6d0e5895b7ea66709bc65e" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;TABLE&lt;/code&gt; function is different from the preceding examples, because it actually returns a &lt;em&gt;set&lt;/em&gt; of records, not just one record.</source>
          <target state="translated">그러나 &lt;code&gt;TABLE&lt;/code&gt; 함수는 실제로 하나의 레코드가 아니라 레코드 &lt;em&gt;세트&lt;/em&gt; 를 리턴하므로 이전 예제와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="5593eb449291b54fa57b6d536402c4a2c8454af7" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;WITH&lt;/code&gt; query can be marked &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; to remove this guarantee. In that case, the &lt;code&gt;WITH&lt;/code&gt; query can be folded into the primary query much as though it were a simple sub-&lt;code&gt;SELECT&lt;/code&gt; in the primary query's &lt;code&gt;FROM&lt;/code&gt; clause. This results in duplicate computations if the primary query refers to that &lt;code&gt;WITH&lt;/code&gt; query more than once; but if each such use requires only a few rows of the &lt;code&gt;WITH&lt;/code&gt; query's total output, &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; can provide a net savings by allowing the queries to be optimized jointly. &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; is ignored if it is attached to a &lt;code&gt;WITH&lt;/code&gt; query that is recursive or is not side-effect-free (i.e., is not a plain &lt;code&gt;SELECT&lt;/code&gt; containing no volatile functions).</source>
          <target state="translated">그러나 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 로 표시 하여이 보증을 제거 할 수 있습니다 . 이 경우 기본 쿼리의 &lt;code&gt;FROM&lt;/code&gt; 절 에서 단순한 하위 &lt;code&gt;SELECT&lt;/code&gt; 인 것처럼 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 기본 쿼리로 접을 수 있습니다 . 기본 조회가 &lt;code&gt;WITH&lt;/code&gt; 조회를 두 번 이상 참조하면 중복 계산이 수행됩니다 . 그러나 그러한 각 사용에 &lt;code&gt;WITH&lt;/code&gt; 쿼리의 총 출력 중 몇 행만 필요한 경우 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 는 쿼리를 공동으로 최적화하여 순 절감 효과를 제공 할 수 있습니다. &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 가 &lt;code&gt;WITH&lt;/code&gt; 에 첨부되면 무시됩니다.재귀 적이거나 부작용이없는 쿼리 (즉, 휘발성 함수가없는 일반 &lt;code&gt;SELECT&lt;/code&gt; 가 아님)</target>
        </trans-unit>
        <trans-unit id="b767ca4c454cedd41bdf2ff2cdb11395909dd8d9" translate="yes" xml:space="preserve">
          <source>However, buffering index build needs to call the &lt;code&gt;penalty&lt;/code&gt; function more often, which consumes some extra CPU resources. Also, the buffers used in the buffering build need temporary disk space, up to the size of the resulting index. Buffering can also influence the quality of the resulting index, in both positive and negative directions. That influence depends on various factors, like the distribution of the input data and the operator class implementation.</source>
          <target state="translated">그러나 버퍼링 인덱스 빌드는 &lt;code&gt;penalty&lt;/code&gt; 함수를 더 자주 호출해야하므로 일부 추가 CPU 리소스가 사용됩니다. 또한 버퍼링 빌드에 사용 된 버퍼에는 결과 인덱스 크기까지 임시 디스크 공간이 필요합니다. 버퍼링은 또한 양의 방향과 음의 방향 모두에서 결과 인덱스의 품질에 영향을 줄 수 있습니다. 이러한 영향은 입력 데이터 배포 및 연산자 클래스 구현과 같은 다양한 요소에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9ace55465d56f996227de2d5f96f6d4ae754cfc4" translate="yes" xml:space="preserve">
          <source>However, every year divisible by 100 is not a leap year.</source>
          <target state="translated">그러나 매년 100으로 나눌 수있는 것은 윤년이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="792feefacc6fed97444972da0544bbf7d0187b3d" translate="yes" xml:space="preserve">
          <source>However, every year divisible by 400 is a leap year after all.</source>
          <target state="translated">그러나 매년 400으로 나눌 수있는 해는 윤년입니다.</target>
        </trans-unit>
        <trans-unit id="7f65ac3c6b4eb7f83cd55133554a3e43236a59b1" translate="yes" xml:space="preserve">
          <source>However, filtered forms in Microsoft Access generate queries that appear to use &lt;code&gt;expr = NULL&lt;/code&gt; to test for null values, so if you use that interface to access the database you might want to turn this option on. Since expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; always return the null value (using the SQL standard interpretation), they are not very useful and do not appear often in normal applications so this option does little harm in practice. But new users are frequently confused about the semantics of expressions involving null values, so this option is off by default.</source>
          <target state="translated">그러나 Microsoft Access에서 필터링 된 양식은 &lt;code&gt;expr = NULL&lt;/code&gt; 을 사용하여 null 값을 테스트 하는 것처럼 보이는 쿼리를 생성 하므로 해당 인터페이스를 사용하여 데이터베이스에 액세스하는 경우이 옵션을 설정해야합니다. &lt;code&gt;expr = NULL&lt;/code&gt; 형식의 표현식은 항상 널값을 리턴하므로 (SQL 표준 해석 사용), 유용하지 않으며 일반 응용 프로그램에서는 자주 나타나지 않으므로이 옵션은 실제로 거의 해를 끼치 지 않습니다. 그러나 새로운 사용자는 종종 null 값과 관련된 표현식의 의미에 대해 혼동되므로이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="27fc16525c2f3eccc5221bef3e492bce51567b8a" translate="yes" xml:space="preserve">
          <source>However, if a &lt;code&gt;WITH&lt;/code&gt; query is non-recursive and side-effect-free (that is, it is a &lt;code&gt;SELECT&lt;/code&gt; containing no volatile functions) then it can be folded into the parent query, allowing joint optimization of the two query levels. By default, this happens if the parent query references the &lt;code&gt;WITH&lt;/code&gt; query just once, but not if it references the &lt;code&gt;WITH&lt;/code&gt; query more than once. You can override that decision by specifying &lt;code&gt;MATERIALIZED&lt;/code&gt; to force separate calculation of the &lt;code&gt;WITH&lt;/code&gt; query, or by specifying &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; to force it to be merged into the parent query. The latter choice risks duplicate computation of the &lt;code&gt;WITH&lt;/code&gt; query, but it can still give a net savings if each usage of the &lt;code&gt;WITH&lt;/code&gt; query needs only a small part of the &lt;code&gt;WITH&lt;/code&gt; query's full output.</source>
          <target state="translated">그러나 &lt;code&gt;WITH&lt;/code&gt; 쿼리가 재귀 적이 지 않고 부작용이없는 경우 (즉, 휘발성 함수를 포함하지 않는 &lt;code&gt;SELECT&lt;/code&gt; ) 부모 쿼리로 접을 수 있으므로 두 쿼리 수준의 공동 최적화가 가능합니다. 기본적으로 이는 상위 쿼리가 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 한 번만 참조하지만 &lt;code&gt;WITH&lt;/code&gt; 쿼리를 두 번 이상 참조하는 경우에는 발생하지 않습니다 . &lt;code&gt;WITH&lt;/code&gt; 쿼리를 별도로 계산하도록 &lt;code&gt;MATERIALIZED&lt;/code&gt; 를 지정 하거나 부모 쿼리에 강제로 병합되도록 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 를 지정하여 해당 결정을 무시할 수 있습니다 . 후자의 선택은 &lt;code&gt;WITH&lt;/code&gt; 의 중복 계산 위험이 있습니다. &lt;code&gt;WITH&lt;/code&gt; 쿼리를 사용할 때마다 &lt;code&gt;WITH&lt;/code&gt; 쿼리 전체 출력의 작은 부분 만 필요한 경우 여전히 순 절감 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="057cccafbf2013b3d5aa591e41a10dbea6d97107" translate="yes" xml:space="preserve">
          <source>However, if the default value is volatile (e.g. &lt;code&gt;clock_timestamp()&lt;/code&gt;) each row will need to be updated with the value calculated at the time &lt;code&gt;ALTER TABLE&lt;/code&gt; is executed. To avoid a potentially lengthy update operation, particularly if you intend to fill the column with mostly nondefault values anyway, it may be preferable to add the column with no default, insert the correct values using &lt;code&gt;UPDATE&lt;/code&gt;, and then add any desired default as described below.</source>
          <target state="translated">그러나 기본값이 &lt;code&gt;clock_timestamp()&lt;/code&gt; (예 : clock_timestamp () ) 각 행은 &lt;code&gt;ALTER TABLE&lt;/code&gt; 이 실행될 때 계산 된 값으로 업데이트되어야합니다 . 잠재적으로 긴 업데이트 작업을 피하려면, 특히 어쨌든 주로 기본값이 아닌 값으로 열을 채우려는 경우 기본값이없는 열을 추가하고 &lt;code&gt;UPDATE&lt;/code&gt; 를 사용하여 올바른 값을 삽입 한 다음 아래 설명 된대로 원하는 기본값을 추가하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="ad2998ee50884b058602cae8c89653b7c98ab015" translate="yes" xml:space="preserve">
          <source>However, if the default value is volatile (e.g., &lt;code&gt;clock_timestamp()&lt;/code&gt;) each row will need to be updated with the value calculated at the time &lt;code&gt;ALTER TABLE&lt;/code&gt; is executed. To avoid a potentially lengthy update operation, particularly if you intend to fill the column with mostly nondefault values anyway, it may be preferable to add the column with no default, insert the correct values using &lt;code&gt;UPDATE&lt;/code&gt;, and then add any desired default as described below.</source>
          <target state="translated">그러나 기본값이 휘발성 (예 : &lt;code&gt;clock_timestamp()&lt;/code&gt; ) 인 경우 각 행은 &lt;code&gt;ALTER TABLE&lt;/code&gt; 이 실행될 때 계산 된 값으로 업데이트되어야합니다 . 잠재적으로 긴 업데이트 작업을 피하려면, 특히 대부분 기본값이 아닌 값으로 열을 채우려는 경우 기본값이없는 열을 추가하고 &lt;code&gt;UPDATE&lt;/code&gt; 를 사용하여 올바른 값을 삽입 한 다음 아래 설명 된대로 원하는 기본값을 추가하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="fbbfd51a31cdab8f282fc85ab92999c7b1df44cb" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to remove role memberships involving the role; &lt;code&gt;DROP ROLE&lt;/code&gt; automatically revokes any memberships of the target role in other roles, and of other roles in the target role. The other roles are not dropped nor otherwise affected.</source>
          <target state="translated">그러나 역할과 관련된 역할 구성원 자격을 제거 할 필요는 없습니다. &lt;code&gt;DROP ROLE&lt;/code&gt; 은 다른 역할의 대상 역할 멤버와 대상 역할의 다른 역할 멤버십을 자동으로 취소합니다. 다른 역할은 삭제되거나 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f99a4fe30aa35a7291430986cdc65efbff8dd39f" translate="yes" xml:space="preserve">
          <source>However, the above does not account for amortization of index reads across repeated index scans.</source>
          <target state="translated">그러나 위의 내용은 반복 된 인덱스 스캔에서 인덱스 읽기의 상각을 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c28ea9e20c2e7864029d4301f424d9903192d30" translate="yes" xml:space="preserve">
          <source>However, the current implementation ignores any supplied array size limits, i.e., the behavior is the same as for arrays of unspecified length.</source>
          <target state="translated">그러나 현재 구현은 제공된 배열 크기 제한을 무시합니다. 즉, 동작은 지정되지 않은 길이의 배열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e7668db05f29105ac82edf505ab55c50a37483ff" translate="yes" xml:space="preserve">
          <source>However, the first and second calls will prefer more-specific functions, if available:</source>
          <target state="translated">그러나 첫 번째 및 두 번째 호출은 사용 가능한 경우보다 구체적인 기능을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="8dd49b73a6bd91b9638ef49c19702f4c5cff091d" translate="yes" xml:space="preserve">
          <source>However, the index can also be used in queries that do not involve &lt;code&gt;order_nr&lt;/code&gt; at all, e.g.:</source>
          <target state="translated">그러나 index는 &lt;code&gt;order_nr&lt;/code&gt; 을 전혀 포함하지 않는 쿼리에도 사용될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2b5348adbefd43e71711c0de0facb597d742b53" translate="yes" xml:space="preserve">
          <source>However, the index could not be used for queries like the following, because though the operator &lt;code&gt;?&lt;/code&gt; is indexable, it is not applied directly to the indexed column &lt;code&gt;jdoc&lt;/code&gt;:</source>
          <target state="translated">그러나 연산자 &lt;code&gt;?&lt;/code&gt; 를 통해 다음과 같은 쿼리에는 인덱스를 사용할 수 없습니다 . 인덱싱 가능하며 인덱싱 된 열 &lt;code&gt;jdoc&lt;/code&gt; 에 직접 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="30d62ecc57d7df5a78dd582f05557b7fb23c077b" translate="yes" xml:space="preserve">
          <source>However, the second query may give unexpected results if &lt;code&gt;salesmen&lt;/code&gt;.&lt;code&gt;id&lt;/code&gt; is not a unique key, whereas the first query is guaranteed to raise an error if there are multiple &lt;code&gt;id&lt;/code&gt; matches. Also, if there is no match for a particular &lt;code&gt;accounts&lt;/code&gt;.&lt;code&gt;sales_id&lt;/code&gt; entry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all.</source>
          <target state="translated">그러나 &lt;code&gt;salesmen&lt;/code&gt; 인 경우 두 번째 쿼리에서 예기치 않은 결과가 발생할 수 있습니다 . &lt;code&gt;id&lt;/code&gt; 는 고유 키가 아니지만 여러 &lt;code&gt;id&lt;/code&gt; 일치 가 있으면 첫 번째 쿼리에서 오류가 발생합니다 . 또한 특정 &lt;code&gt;accounts&lt;/code&gt; 과 일치하지 않는 경우 . &lt;code&gt;sales_id&lt;/code&gt; 항목에서 첫 번째 쿼리는 해당 이름 필드를 NULL로 설정하지만 두 번째 쿼리는 해당 행을 전혀 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac0aa3ca3aadbd76b33daf42fe2d9f38b7a21341" translate="yes" xml:space="preserve">
          <source>However, this is not recommended. Floating point numbers should not be used to handle money due to the potential for rounding errors.</source>
          <target state="translated">그러나 이것은 권장되지 않습니다. 반올림 오류 가능성으로 인해 돈을 처리하는 데 부동 소수점 숫자를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e7a5e278e5a670634fe4d0890f09f0f07f287151" translate="yes" xml:space="preserve">
          <source>However, this only works for types whose names are also valid as function names. For example, &lt;code&gt;double precision&lt;/code&gt; cannot be used this way, but the equivalent &lt;code&gt;float8&lt;/code&gt; can. Also, the names &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, and &lt;code&gt;timestamp&lt;/code&gt; can only be used in this fashion if they are double-quoted, because of syntactic conflicts. Therefore, the use of the function-like cast syntax leads to inconsistencies and should probably be avoided.</source>
          <target state="translated">그러나 이것은 이름이 함수 이름으로도 유효한 유형에 대해서만 작동합니다. 예를 들어, &lt;code&gt;double precision&lt;/code&gt; 는 이런 식으로 사용할 수 없지만 &lt;code&gt;float8&lt;/code&gt; 은 사용할 수 있습니다. 또한 이름 &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; 및 시간 &lt;code&gt;timestamp&lt;/code&gt; 은 구문 충돌로 인해 큰 따옴표로 묶인 경우에만이 방식으로 사용할 수 있습니다. 따라서 함수형 캐스트 ​​구문을 사용하면 불일치가 발생하므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab41e0a4da3a7de05a4b7068787924b0e3cb154d" translate="yes" xml:space="preserve">
          <source>However, this quickly becomes tedious for large arrays, and is not helpful if the size of the array is unknown. An alternative method is described in &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.23&lt;/a&gt;. The above query could be replaced by:</source>
          <target state="translated">그러나 이는 대형 배열의 경우 지루해지며 배열의 크기를 알 수없는 경우에는 도움이되지 않습니다. 다른 방법은 &lt;a href=&quot;functions-comparisons&quot;&gt;섹션 9.23에&lt;/a&gt; 설명되어 있습니다. 위의 쿼리는 다음으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36ec95290f6f5b115ce53145f3f502e1463f93d8" translate="yes" xml:space="preserve">
          <source>However, this quickly becomes tedious for large arrays, and is not helpful if the size of the array is unknown. An alternative method is described in &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.24&lt;/a&gt;. The above query could be replaced by:</source>
          <target state="translated">그러나 이것은 큰 배열의 경우 빠르게 지루해지며 배열의 크기를 알 수없는 경우에는 도움이되지 않습니다. 대체 방법은 &lt;a href=&quot;functions-comparisons&quot;&gt;섹션 9.24에&lt;/a&gt; 설명되어 있습니다. 위의 쿼리는 다음으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49121f1f7d3b19887ff759c895c872e45fe0450d" translate="yes" xml:space="preserve">
          <source>However, unless a module is specifically designed to be used in this way by non-superusers, this is usually not the right setting to use. Look at &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; instead.</source>
          <target state="translated">그러나 수퍼 유저가 아닌 사람이 이러한 방식으로 사용하도록 모듈을 특별히 설계하지 않으면 일반적으로 올바른 설정이 아닙니다. 봐 &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="f4744bf3a8101c9dd55ef2a04f348b62af8e9994" translate="yes" xml:space="preserve">
          <source>However, while the directory contents are secure, the default client authentication setup allows any local user to connect to the database and even become the database superuser. If you do not trust other local users, we recommend you use one of &lt;code&gt;initdb&lt;/code&gt;'s &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;--pwprompt&lt;/code&gt; or &lt;code&gt;--pwfile&lt;/code&gt; options to assign a password to the database superuser. Also, specify &lt;code&gt;-A md5&lt;/code&gt; or &lt;code&gt;-A password&lt;/code&gt; so that the default &lt;code&gt;trust&lt;/code&gt; authentication mode is not used; or modify the generated &lt;code&gt;pg_hba.conf&lt;/code&gt; file after running &lt;code&gt;initdb&lt;/code&gt;, but &lt;em&gt;before&lt;/em&gt; you start the server for the first time. (Other reasonable approaches include using &lt;code&gt;peer&lt;/code&gt; authentication or file system permissions to restrict connections. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for more information.)</source>
          <target state="translated">그러나 디렉토리 내용은 안전하지만 기본 클라이언트 인증 설정을 통해 모든 로컬 사용자가 데이터베이스에 연결하고 데이터베이스 수퍼 유저가 될 수도 있습니다. 다른 로컬 사용자를 신뢰하지 않으면 &lt;code&gt;initdb&lt;/code&gt; 의 &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;--pwprompt&lt;/code&gt; 또는 &lt;code&gt;--pwfile&lt;/code&gt; 옵션 중 하나를 사용 하여 데이터베이스 수퍼 유저에게 암호를 할당하는 것이 좋습니다 . 또한 기본 &lt;code&gt;trust&lt;/code&gt; 인증 모드가 사용되지 않도록 &lt;code&gt;-A md5&lt;/code&gt; 또는 &lt;code&gt;-A password&lt;/code&gt; 지정하십시오 . 또는 &lt;code&gt;initdb&lt;/code&gt; 를 실행 한 후 , 그러나 &lt;em&gt;전에&lt;/em&gt; 생성 된 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일을 수정하십시오.&lt;em&gt;&lt;/em&gt;서버를 처음 시작합니다. 다른 합리적인 접근 방법으로는 &lt;code&gt;peer&lt;/code&gt; 인증 또는 파일 시스템 권한을 사용하여 연결을 제한하는 방법이 있습니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c256b10902d81d3561c1f226e5f4cb70fe93cebd" translate="yes" xml:space="preserve">
          <source>However, while the directory contents are secure, the default client authentication setup allows any local user to connect to the database and even become the database superuser. If you do not trust other local users, we recommend you use one of &lt;code&gt;initdb&lt;/code&gt;'s &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;--pwprompt&lt;/code&gt; or &lt;code&gt;--pwfile&lt;/code&gt; options to assign a password to the database superuser. Also, specify &lt;code&gt;-A md5&lt;/code&gt; or &lt;code&gt;-A password&lt;/code&gt; so that the default &lt;code&gt;trust&lt;/code&gt; authentication mode is not used; or modify the generated &lt;code&gt;pg_hba.conf&lt;/code&gt; file after running &lt;code&gt;initdb&lt;/code&gt;, but &lt;em&gt;before&lt;/em&gt; you start the server for the first time. (Other reasonable approaches include using &lt;code&gt;peer&lt;/code&gt; authentication or file system permissions to restrict connections. See &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for more information.)</source>
          <target state="translated">그러나 디렉토리 내용은 안전하지만 기본 클라이언트 인증 설정을 사용하면 모든 로컬 사용자가 데이터베이스에 연결하고 데이터베이스 수퍼 유저가 될 수도 있습니다. 다른 로컬 사용자를 신뢰하지 않는 경우 &lt;code&gt;initdb&lt;/code&gt; 의 &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;--pwprompt&lt;/code&gt; 또는 &lt;code&gt;--pwfile&lt;/code&gt; 옵션 중 하나를 사용 하여 데이터베이스 수퍼 유저에게 암호를 할당하는 것이 좋습니다 . 또한 기본 &lt;code&gt;trust&lt;/code&gt; 인증 모드가 사용되지 않도록 &lt;code&gt;-A md5&lt;/code&gt; 또는 &lt;code&gt;-A password&lt;/code&gt; 지정하십시오 . 또는 생성 된 수정 &lt;code&gt;pg_hba.conf&lt;/code&gt; 실행 후 파일 &lt;code&gt;initdb&lt;/code&gt; 에를 하지만, &lt;em&gt;전에&lt;/em&gt;&lt;em&gt;&lt;/em&gt;처음으로 서버를 시작합니다. (다른 합리적인 접근 방식에는 &lt;code&gt;peer&lt;/code&gt; 인증 또는 파일 시스템 권한을 사용하여 연결을 제한하는 것이 포함됩니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="57ff938f130455fd7c5423b61feb93bb1fcef3bc" translate="yes" xml:space="preserve">
          <source>Huge pages are known as large pages on Windows. To use them, you need to assign the user right Lock Pages in Memory to the Windows user account that runs PostgreSQL. You can use Windows Group Policy tool (gpedit.msc) to assign the user right Lock Pages in Memory. To start the database server on the command prompt as a standalone process, not as a Windows service, the command prompt must be run as an administrator or User Access Control (UAC) must be disabled. When the UAC is enabled, the normal command prompt revokes the user right Lock Pages in Memory when started.</source>
          <target state="translated">큰 페이지는 Windows에서 큰 페이지라고합니다. 이를 사용하려면 PostgreSQL을 실행하는 Windows 사용자 계정에 사용자 권한 메모리의 잠금 페이지를 할당해야합니다. Windows 그룹 정책 도구 (gpedit.msc)를 사용하여 메모리에 사용자 권한 잠금 페이지를 할당 할 수 있습니다. 명령 프롬프트에서 데이터베이스 서비스를 Windows 서비스가 아닌 독립형 프로세스로 시작하려면 명령 프롬프트를 관리자로 실행하거나 UAC (User Access Control)를 사용하지 않아야합니다. UAC가 활성화되면 일반 명령 프롬프트가 시작될 때 사용자 권한 메모리에서 페이지 잠금을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="1f8503304967af954a53ebd078e0b78234d12b54" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine</source>
          <target state="translated">쌍곡 코사인</target>
        </trans-unit>
        <trans-unit id="6cd3a73e406381253718a612b965e023a4f56989" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine</source>
          <target state="translated">쌍곡 사인</target>
        </trans-unit>
        <trans-unit id="9197379568d57d2a0451b5bb547d22e3de876985" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent</source>
          <target state="translated">쌍곡 탄젠트</target>
        </trans-unit>
        <trans-unit id="d8bf3846fb1be35204cb20d765d7076251578e99" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, all ASCII</source>
          <target state="translated">하이픈으로 연결된 단어 부분, 모든 ASCII</target>
        </trans-unit>
        <trans-unit id="8cdd097739f98ad844abd99f2945f21997a9eb1e" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, all letters</source>
          <target state="translated">하이픈으로 묶인 단어 부분, 모든 문자</target>
        </trans-unit>
        <trans-unit id="e93c4156f46693ca03a7e7a80ab8d3ba346ec445" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, letters and digits</source>
          <target state="translated">하이픈으로 연결된 단어 부분, 문자 및 숫자</target>
        </trans-unit>
        <trans-unit id="5b3864b1f64d7c5d3d32b1aa431d4fc8168f5866" translate="yes" xml:space="preserve">
          <source>Hyphenated word, all ASCII</source>
          <target state="translated">하이픈이있는 단어, 모든 ASCII</target>
        </trans-unit>
        <trans-unit id="913f77eb20ad8621544651272e4864006cc9a993" translate="yes" xml:space="preserve">
          <source>Hyphenated word, all letters</source>
          <target state="translated">하이픈이있는 단어, 모든 문자</target>
        </trans-unit>
        <trans-unit id="f8a2b7bdb3666b53d93dd9a984de988e23d346eb" translate="yes" xml:space="preserve">
          <source>Hyphenated word, letters and digits</source>
          <target state="translated">하이픈으로 연결된 단어, 문자 및 숫자</target>
        </trans-unit>
        <trans-unit id="b4d527f11debd0a7c15ff494a4d7c586833b355b" translate="yes" xml:space="preserve">
          <source>I believe this union:</source>
          <target state="translated">나는이 연합을 믿는다 :</target>
        </trans-unit>
        <trans-unit id="778d85fd9d1cf9d0bbf34776934bafa267e37666" translate="yes" xml:space="preserve">
          <source>ICU &amp;ldquo;root&amp;rdquo; collation. Use this to get a reasonable language-agnostic sort order.</source>
          <target state="translated">ICU &quot;루트&quot;데이터 정렬. 언어에 관계없이 합리적인 정렬 순서를 얻으려면 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4186bb5b6042e95ce616f6bfea478c30a4a80a0a" translate="yes" xml:space="preserve">
          <source>ICU allows collations to be customized beyond the basic language+country set that is preloaded by &lt;code&gt;initdb&lt;/code&gt;. Users are encouraged to define their own collation objects that make use of these facilities to suit the sorting behavior to their requirements. See &lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;http://userguide.icu-project.org/locale&lt;/a&gt; and &lt;a href=&quot;http://userguide.icu-project.org/collation/api&quot;&gt;http://userguide.icu-project.org/collation/api&lt;/a&gt; for information on ICU locale naming. The set of acceptable names and attributes depends on the particular ICU version.</source>
          <target state="translated">ICU를 사용하면 &lt;code&gt;initdb&lt;/code&gt; 에 의해 사전로드 된 기본 언어 + 국가 세트를 넘어 데이터 정렬을 사용자 정의 할 수 있습니다 . 사용자는 이러한 기능을 사용하여 요구 사항에 맞는 정렬 동작에 적합한 자체 데이터 정렬 개체를 정의하는 것이 좋습니다. ICU 로캘 이름 지정에 대한 자세한 내용은 &lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;http://userguide.icu-project.org/locale&lt;/a&gt; 및 &lt;a href=&quot;http://userguide.icu-project.org/collation/api&quot;&gt;http://userguide.icu-project.org/collation/api&lt;/a&gt; 를 참조하십시오 . 허용되는 이름과 속성 세트는 특정 ICU 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6f538ad1e5ea2537ef4ecc8ee6d246518b569e28" translate="yes" xml:space="preserve">
          <source>ICU?</source>
          <target state="translated">ICU?</target>
        </trans-unit>
        <trans-unit id="85ddc12eb726993ba7496e593b7b33905cb52428" translate="yes" xml:space="preserve">
          <source>ID of a role that has a member</source>
          <target state="translated">회원이있는 역할의 ID</target>
        </trans-unit>
        <trans-unit id="5e2534334ba3879c3b535d5349da57994812e977" translate="yes" xml:space="preserve">
          <source>ID of a role that is a member of &lt;code&gt;roleid&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;roleid&lt;/code&gt; 의 구성원 인 역할의 ID</target>
        </trans-unit>
        <trans-unit id="b3334a0f3355b9fb358c2a763909308ff227db92" translate="yes" xml:space="preserve">
          <source>ID of role</source>
          <target state="translated">역할의 ID</target>
        </trans-unit>
        <trans-unit id="00ab5d608ce03301bac5fabc168033a98fb8425a" translate="yes" xml:space="preserve">
          <source>ID of the role that granted this membership</source>
          <target state="translated">이 멤버십을 부여한 역할의 ID</target>
        </trans-unit>
        <trans-unit id="4acecf86a885801175aac9f839c4e27dfcd0bb71" translate="yes" xml:space="preserve">
          <source>ID of the transaction targeted by the lock, or null if the target is not a transaction ID</source>
          <target state="translated">잠금이 대상으로하는 트랜잭션의 ID 또는 대상이 트랜잭션 ID가 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="4405588c83fcde9e77a297389a5a77edfc33fd81" translate="yes" xml:space="preserve">
          <source>ID of this group</source>
          <target state="translated">이 그룹의 ID</target>
        </trans-unit>
        <trans-unit id="364041630f947c82ae36797d2d8b4d8c51f1090b" translate="yes" xml:space="preserve">
          <source>ID of this user</source>
          <target state="translated">이 사용자의 ID</target>
        </trans-unit>
        <trans-unit id="efeddb9b2b9bc9d252eb880921c3b8b3f041d65a" translate="yes" xml:space="preserve">
          <source>ID, in the range 1..&lt;code&gt;shared_buffers&lt;/code&gt;</source>
          <target state="translated">1 범위의 ID .. &lt;code&gt;shared_buffers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fab9fa5af6726f4fbc7c7dbc87a28acfc40a63e9" translate="yes" xml:space="preserve">
          <source>IEC</source>
          <target state="translated">IEC</target>
        </trans-unit>
        <trans-unit id="91e003cabbbc52544795f505584d809fe4bf1cdc" translate="yes" xml:space="preserve">
          <source>IEEE</source>
          <target state="translated">IEEE</target>
        </trans-unit>
        <trans-unit id="44285b6e9ccd859327d44fd855fe1b27a08233b1" translate="yes" xml:space="preserve">
          <source>IEEE Std 802-2001 specifies the second shown form (with hyphens) as the canonical form for MAC addresses, and specifies the first form (with colons) as the bit-reversed notation, so that 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. This convention is widely ignored nowadays, and it is relevant only for obsolete network protocols (such as Token Ring). PostgreSQL makes no provisions for bit reversal, and all accepted formats use the canonical LSB order.</source>
          <target state="translated">IEEE Std 802-2001은 MAC 주소의 표준 형식으로 두 번째로 표시된 형식 (하이픈 포함)을 지정하고 첫 번째 형식 (콜론 포함)을 비트 반전 표기법으로 지정하여 08-00-2b-01-02- 03 = 01 : 00 : 4D : 08 : 04 : 0C. 이 규칙은 현재 널리 무시되고 있으며 오래된 네트워크 프로토콜 (예 : 토큰 링)에만 적용됩니다. PostgreSQL은 비트 리버설을 제공하지 않으며 모든 허용 형식은 표준 LSB 순서를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c6125697017457f602c07e148a748e8cb804d044" translate="yes" xml:space="preserve">
          <source>IEEE754 specifies that &lt;code&gt;NaN&lt;/code&gt; should not compare equal to any other floating-point value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow floating-point values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">IEEE754는 &lt;code&gt;NaN&lt;/code&gt; 이 다른 부동 소수점 값 ( &lt;code&gt;NaN&lt;/code&gt; 포함 ) 과 같지 않도록 지정합니다 . 허용하기 위해 부동 소수점 값을 소트 및 트리 기반 인덱스 PostgreSQL의 치료에 사용 &lt;code&gt;NaN&lt;/code&gt; 값 동일한로서, 모든 비 - 초과 &lt;code&gt;NaN&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="0d3a231ed1c6dcab8fa35edd0bd127d0e5d21d84" translate="yes" xml:space="preserve">
          <source>IMPORT FOREIGN SCHEMA</source>
          <target state="translated">수입 외국인 스키마</target>
        </trans-unit>
        <trans-unit id="b8d5fc1f41eb794e02ccf1b51b842239e54448da" translate="yes" xml:space="preserve">
          <source>IMPORT FOREIGN SCHEMA &amp;mdash; import table definitions from a foreign server</source>
          <target state="translated">IMPORT FOREIGN SCHEMA &amp;mdash; 외부 서버에서 테이블 정의 가져 오기</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="b42f874d7db1e2726d84a76cc0d5b0946a10b15b" translate="yes" xml:space="preserve">
          <source>INSERT &amp;mdash; create new rows in a table</source>
          <target state="translated">삽입 &amp;mdash; 테이블에 새 행을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48ef49cd856e5cecb996e0f1d379dbd5b56b7cb9" translate="yes" xml:space="preserve">
          <source>IP address mask, or null if not applicable</source>
          <target state="translated">IP 주소 마스크 또는 해당 사항이없는 경우 null</target>
        </trans-unit>
        <trans-unit id="998514d91724c3d88d4cab07518debfcd96862e2" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this WAL sender. If this field is null, it indicates that the client is connected via a Unix socket on the server machine.</source>
          <target state="translated">이 WAL 발신자에 연결된 클라이언트의 IP 주소입니다. 이 필드가 널인 경우 클라이언트가 서버 시스템의 Unix 소켓을 통해 연결되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26ec3318a4493a39e748c88c589f3baeb8b0af15" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this backend</source>
          <target state="translated">이 백엔드에 연결된 클라이언트의 IP 주소</target>
        </trans-unit>
        <trans-unit id="4da843a738e5c670d4d958349979cce4c9e32eb3" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this backend. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.</source>
          <target state="translated">이 백엔드에 연결된 클라이언트의 IP 주소 이 필드가 널인 경우 클라이언트가 서버 시스템의 Unix 소켓을 통해 연결되었거나 autovacuum과 같은 내부 프로세스임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f4aa7e6cdf843e01253be3fd2becaee731842f78" translate="yes" xml:space="preserve">
          <source>IPC</source>
          <target state="translated">IPC</target>
        </trans-unit>
        <trans-unit id="e5ef9147dc5536f205d6a3c473e0918abe3ea487" translate="yes" xml:space="preserve">
          <source>IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">IPC 매개 변수는 &lt;code&gt;sysctl&lt;/code&gt; 을 사용하여 조정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82c9856123dd418f4774d9eae5cdc6c13b4a17dd" translate="yes" xml:space="preserve">
          <source>IPC parameters can be set in the System Administration Manager (SAM) under Kernel Configuration &amp;rarr; Configurable Parameters. Choose Create A New Kernel when you're done.</source>
          <target state="translated">IPC 매개 변수는 SAM (System Administration Manager)의 Kernel Configuration &amp;rarr; Configurable Parameters에서 설정할 수 있습니다. 완료되면 새 커널 만들기를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="ab288f3447cf3cc34399c5b2b5851efa6c3d80a4" translate="yes" xml:space="preserve">
          <source>IPv4 and IPv6 hosts and networks</source>
          <target state="translated">IPv4 및 IPv6 호스트 및 네트워크</target>
        </trans-unit>
        <trans-unit id="86de966d86cc975242ef8e4aaaa8450d6855f8c5" translate="yes" xml:space="preserve">
          <source>IPv4 and IPv6 networks</source>
          <target state="translated">IPv4 및 IPv6 네트워크</target>
        </trans-unit>
        <trans-unit id="570cca22ddf6e073a6dbd2cc896fd406204eb7b0" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 host address</source>
          <target state="translated">IPv4 또는 IPv6 호스트 주소</target>
        </trans-unit>
        <trans-unit id="c2e4edd4992d9d0688f940e8473197cf9ffe481e" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 network address</source>
          <target state="translated">IPv4 또는 IPv6 네트워크 주소</target>
        </trans-unit>
        <trans-unit id="9d11567d01c59efb43ef67bb8206340e658f9d9d" translate="yes" xml:space="preserve">
          <source>ISBN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISBN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="bb9ab15de59e9d547e927c8c62069791df1e8268" translate="yes" xml:space="preserve">
          <source>ISBN &amp;lt;=&amp;gt; ISBN13</source>
          <target state="translated">ISBN &amp;lt;=&amp;gt; ISBN13</target>
        </trans-unit>
        <trans-unit id="a43d901bb73f40ccaba8783a1129360f50fba85d" translate="yes" xml:space="preserve">
          <source>ISBN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISBN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="4497b3ae9c75adbc043fd5847cc29356be8a5644" translate="yes" xml:space="preserve">
          <source>ISBN13, ISMN13, ISSN13 numbers are all EAN13 numbers.</source>
          <target state="translated">ISBN13, ISMN13, ISSN13 번호는 모두 EAN13 번호입니다.</target>
        </trans-unit>
        <trans-unit id="95889ddf7167ca49889a166a2e3858db51bb28d5" translate="yes" xml:space="preserve">
          <source>ISMN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISMN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="d9a94674870da708d9a2ffc2a85d2b1561319391" translate="yes" xml:space="preserve">
          <source>ISMN &amp;lt;=&amp;gt; ISMN13</source>
          <target state="translated">ISMN &amp;lt;=&amp;gt; ISMN13</target>
        </trans-unit>
        <trans-unit id="9f6fa2a3d8d31764fc531c626fb4ec439b13e49d" translate="yes" xml:space="preserve">
          <source>ISMN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISMN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="4f325d995b6d028ccc75771b1679537b623521c4" translate="yes" xml:space="preserve">
          <source>ISO</source>
          <target state="translated">ISO</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="03b66feb77a5287d927a40831615b0a53c5c265e" translate="yes" xml:space="preserve">
          <source>ISO 8601 &amp;ldquo;alternative format&amp;rdquo;: same meaning as above</source>
          <target state="translated">ISO 8601&amp;ldquo;대체 형식&amp;rdquo;: 위와 동일한 의미</target>
        </trans-unit>
        <trans-unit id="347f83fd1ecbce8da8703c53ec0ee71401af00f9" translate="yes" xml:space="preserve">
          <source>ISO 8601 &amp;ldquo;format with designators&amp;rdquo;: same meaning as above</source>
          <target state="translated">ISO 8601&amp;ldquo;지정자가있는 형식&amp;rdquo;: 위와 동일한 의미</target>
        </trans-unit>
        <trans-unit id="249eb6740bd82a6c1db53f9cab25650c97a5d209" translate="yes" xml:space="preserve">
          <source>ISO 8601 day of the week, Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">ISO 8601 요일, 월요일 ( &lt;code&gt;1&lt;/code&gt; ) ~ 일요일 ( &lt;code&gt;7&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9d2092d27bf384f64eb368a2dfd612d31022bd2b" translate="yes" xml:space="preserve">
          <source>ISO 8601 specifies the use of uppercase letter &lt;code&gt;T&lt;/code&gt; to separate the date and time. PostgreSQL accepts that format on input, but on output it uses a space rather than &lt;code&gt;T&lt;/code&gt;, as shown above. This is for readability and for consistency with RFC 3339 as well as some other database systems.</source>
          <target state="translated">ISO 8601은 대문자 &lt;code&gt;T&lt;/code&gt; 를 사용 하여 날짜와 시간을 구분합니다. PostgreSQL은 입력에서 해당 형식을 허용하지만 출력에서 위에 표시된 것처럼 &lt;code&gt;T&lt;/code&gt; 대신 공백을 사용합니다 . 이것은 가독성과 RFC 3339 및 일부 다른 데이터베이스 시스템과의 일관성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e8d83297c37a8caa9129a785251aaffead6b3d8" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-numbering year (4 or more digits)</source>
          <target state="translated">ISO 8601 주간 번호 년 (4 자리 이상)</target>
        </trans-unit>
        <trans-unit id="5113b76aa827aecd1b2fbeb19739776b2cdcbdb5" translate="yes" xml:space="preserve">
          <source>ISO 8601, SQL standard</source>
          <target state="translated">ISO 8601, SQL 표준</target>
        </trans-unit>
        <trans-unit id="c4bb947ff5dc5345f70f6892f02bf85a04d4eb7d" translate="yes" xml:space="preserve">
          <source>ISO 8601; January 8 in any mode (recommended format)</source>
          <target state="translated">ISO 8601; 모든 모드에서 1 월 8 일 (권장 형식)</target>
        </trans-unit>
        <trans-unit id="a83c80f67456b395aa2704158f1dc68957610271" translate="yes" xml:space="preserve">
          <source>ISO 8601; January 8, 1999 in any mode</source>
          <target state="translated">ISO 8601; 모든 모드에서 1999 년 1 월 8 일</target>
        </trans-unit>
        <trans-unit id="b1922fbd22025577b8a5e43c812e096c3b9acffc" translate="yes" xml:space="preserve">
          <source>ISO 8859-1, ECMA 94</source>
          <target state="translated">ISO 8859-1, ECMA 94</target>
        </trans-unit>
        <trans-unit id="276d48941fbc0543fbb5ce642fe1dc3b05b9bb7d" translate="yes" xml:space="preserve">
          <source>ISO 8859-10, ECMA 144</source>
          <target state="translated">ISO 8859-10, ECMA 144</target>
        </trans-unit>
        <trans-unit id="b206da53a9051bf3226d71a6e114418f28766469" translate="yes" xml:space="preserve">
          <source>ISO 8859-13</source>
          <target state="translated">ISO 8859-13</target>
        </trans-unit>
        <trans-unit id="26424d0dadf461ca6901513d3dcfc085ec66b2c7" translate="yes" xml:space="preserve">
          <source>ISO 8859-14</source>
          <target state="translated">ISO 8859-14</target>
        </trans-unit>
        <trans-unit id="b292668cb49c44b020b58d7d79cd50329ab61aed" translate="yes" xml:space="preserve">
          <source>ISO 8859-15</source>
          <target state="translated">ISO 8859-15</target>
        </trans-unit>
        <trans-unit id="6a937cb9225885ed540430a532e08182311c8fb7" translate="yes" xml:space="preserve">
          <source>ISO 8859-16, ASRO SR 14111</source>
          <target state="translated">ISO 8859-16, ASRO SR 14111</target>
        </trans-unit>
        <trans-unit id="5f8eb67d9b294dc7fa2960e49427ec254bf78d3e" translate="yes" xml:space="preserve">
          <source>ISO 8859-2, ECMA 94</source>
          <target state="translated">ISO 8859-2, ECMA 94</target>
        </trans-unit>
        <trans-unit id="34bfa7b1e0970a505b7c18beda35ee12ae67b627" translate="yes" xml:space="preserve">
          <source>ISO 8859-3, ECMA 94</source>
          <target state="translated">ISO 8859-3, ECMA 94</target>
        </trans-unit>
        <trans-unit id="19f1d5efe10cfb525dac348f64f156d08531f5ba" translate="yes" xml:space="preserve">
          <source>ISO 8859-4, ECMA 94</source>
          <target state="translated">ISO 8859-4, ECMA 94</target>
        </trans-unit>
        <trans-unit id="958ae0517642b5a63a0ba42f16e7dba51f3f03b9" translate="yes" xml:space="preserve">
          <source>ISO 8859-5, ECMA 113</source>
          <target state="translated">ISO 8859-5, ECMA 113</target>
        </trans-unit>
        <trans-unit id="edc58fa1dfcc675f8f0e7cd9ba637022f963b9a5" translate="yes" xml:space="preserve">
          <source>ISO 8859-6, ECMA 114</source>
          <target state="translated">ISO 8859-6, ECMA 114</target>
        </trans-unit>
        <trans-unit id="ac642f9b939a7e25fc9c152794f7c55763fbe736" translate="yes" xml:space="preserve">
          <source>ISO 8859-7, ECMA 118</source>
          <target state="translated">ISO 8859-7, ECMA 118</target>
        </trans-unit>
        <trans-unit id="aafb9bf8d9a3dd18a9bc858aa3091007431a81fe" translate="yes" xml:space="preserve">
          <source>ISO 8859-8, ECMA 121</source>
          <target state="translated">ISO 8859-8, ECMA 121</target>
        </trans-unit>
        <trans-unit id="561419819864b8b7eafa254ff17c2c5838572d02" translate="yes" xml:space="preserve">
          <source>ISO 8859-9, ECMA 128</source>
          <target state="translated">ISO 8859-9, ECMA 128</target>
        </trans-unit>
        <trans-unit id="19fa6eb3258ffb4709ac1dfbba399d0753e7e88f" translate="yes" xml:space="preserve">
          <source>ISO-8601 offset for PST</source>
          <target state="translated">PST에 대한 ISO-8601 오프셋</target>
        </trans-unit>
        <trans-unit id="d9bfc4c480632e7b109f99ac77c51a2a5260171b" translate="yes" xml:space="preserve">
          <source>ISSN</source>
          <target state="translated">ISSN</target>
        </trans-unit>
        <trans-unit id="3941c970e85e394c43837d5b44cc1bf0483f215f" translate="yes" xml:space="preserve">
          <source>ISSN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISSN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="a203140c0f91a7564ce62d86b204a626e15ee7d8" translate="yes" xml:space="preserve">
          <source>ISSN &amp;lt;=&amp;gt; ISSN13</source>
          <target state="translated">ISSN &amp;lt;=&amp;gt; ISSN13</target>
        </trans-unit>
        <trans-unit id="57b604002c866aad17fa814a63620ac73af4bf08" translate="yes" xml:space="preserve">
          <source>ISSN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISSN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="0a6d0a09ee6e1eec933513081c533fbe57cab3a4" translate="yes" xml:space="preserve">
          <source>Ident Authentication</source>
          <target state="translated">신원 인증</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="64ed35bcb9eba82bb5083c305000e3e8e174b736" translate="yes" xml:space="preserve">
          <source>Identifier of the large object that includes this page</source>
          <target state="translated">이 페이지를 포함하는 큰 객체의 식별자</target>
        </trans-unit>
        <trans-unit id="d19347e41a5213caf5fbef640d085e03cc5288d2" translate="yes" xml:space="preserve">
          <source>Identifies a function taking or returning an unspecified row type.</source>
          <target state="translated">지정되지 않은 행 유형을 가져 오거나 리턴하는 함수를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="9f9c67a87f9e8c8e7cd1eee8d202259f233b1765" translate="yes" xml:space="preserve">
          <source>Identifies a not-yet-resolved type, e.g. of an undecorated string literal.</source>
          <target state="translated">아직 해결되지 않은 유형 (예 : 데코레이션되지 않은 문자열 리터럴)을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c41af45b5400af4443194716d5554aafcc29e526" translate="yes" xml:space="preserve">
          <source>Identifies a not-yet-resolved type, e.g., of an undecorated string literal.</source>
          <target state="translated">장식되지 않은 문자열 리터럴과 같이 아직 해결되지 않은 유형을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c7cbe1f08ac13359acc228819549de4cb50db912" translate="yes" xml:space="preserve">
          <source>Identifies a representation of DDL commands that is available to event triggers.</source>
          <target state="translated">이벤트 트리거에 사용 가능한 DDL 명령의 표현을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c10498b4e600d39b28759a6ca1704d299a1166cc" translate="yes" xml:space="preserve">
          <source>Identifies the event for which this trigger fires</source>
          <target state="translated">이 트리거가 발생하는 이벤트를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="708e5b0969ad9b9e70cb24a115182be857e71a40" translate="yes" xml:space="preserve">
          <source>If 1, OIDs are included in the data; if 0, not. Oid system columns are not supported in PostgreSQL anymore, but the format still contains the indicator.</source>
          <target state="translated">1이면 OID가 데이터에 포함됩니다. 0이 아닌 경우 Oid 시스템 열은 PostgreSQL에서 더 이상 지원되지 않지만 형식에는 여전히 표시기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8295c4be7fefd76f1788c97ecf7d786d2a81d6" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; has been configured the cluster name will also be shown in &lt;code&gt;ps&lt;/code&gt; output:</source>
          <target state="translated">경우 &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;CLUSTER_NAME가&lt;/a&gt; 구성된 클러스터 이름은에 표시됩니다 &lt;code&gt;ps&lt;/code&gt; 출력 :</target>
        </trans-unit>
        <trans-unit id="8a629049c6dc481b39f88d9e65ac7e85ce3a796f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; is set to &lt;code&gt;off&lt;/code&gt;, or if no JIT implementation is available (for example because the server was compiled without &lt;code&gt;--with-llvm&lt;/code&gt;), JIT will not be performed, even if it would be beneficial based on the above criteria. Setting &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt; has effects at both plan and execution time.</source>
          <target state="translated">경우 &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;JIT가&lt;/a&gt; 설정되어 &lt;code&gt;off&lt;/code&gt; 더 JIT 구현을 사용할 수없는 경우, 또는 (예를 들어 서버가없이 컴파일 되었기 때문에 &lt;code&gt;--with-llvm&lt;/code&gt; 은 위의 기준에 따라 도움이 될 것입니다 경우에도, JIT는 수행되지 않습니다). &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; 을 &lt;code&gt;off&lt;/code&gt; 로 설정하면 계획 및 실행 시간 모두에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="b58e6f959038162d8a80485253d8424b9f1e1e29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; is non-empty, &lt;code&gt;synchronous_commit&lt;/code&gt; also controls whether transaction commits will wait for their WAL records to be processed on the standby server(s).</source>
          <target state="translated">경우 &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names이&lt;/a&gt; 비 비어, &lt;code&gt;synchronous_commit&lt;/code&gt; 트랜잭션 커밋이 자신의 WAL 기록을 기다릴 것인지도 컨트롤은 대기 서버 (들)에서 처리한다.</target>
        </trans-unit>
        <trans-unit id="9523a6aef92c0b8b469d3754e7282b8f5942c267" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; is non-empty, this parameter also controls whether or not transaction commits will wait for their WAL records to be replicated to the standby server(s). When set to &lt;code&gt;on&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to disk. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_apply&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s). When set to &lt;code&gt;remote_write&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it out to their operating system. This setting is sufficient to ensure data preservation even if a standby instance of PostgreSQL were to crash, but not if the standby suffers an operating-system-level crash, since the data has not necessarily reached stable storage on the standby. Finally, the setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is not usually desirable when synchronous replication is in use, but is provided for completeness.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; 가 비어 있지 않으면 이 매개 변수는 트랜잭션 커밋이 WAL 레코드가 대기 서버로 복제 될 때까지 대기할지 여부를 제어합니다. &lt;code&gt;on&lt;/code&gt; 으로 설정하면 커밋은 현재 동기 대기의 응답이 트랜잭션의 커밋 레코드를 수신하여 디스크로 플러시 할 때까지 기다립니다. 이를 통해 기본 및 모든 동기 대기가 데이터베이스 스토리지의 손상을 입지 않으면 트랜잭션이 유실되지 않습니다. &lt;code&gt;remote_apply&lt;/code&gt; 로 설정하면 커밋은 현재 동기 대기의 응답이 트랜잭션의 커밋 레코드를 수신하고 적용했음을 나타낼 때까지 대기하여 대기의 쿼리에 표시됩니다. 로 설정하면 &lt;code&gt;remote_write&lt;/code&gt; , 커밋은 현재 동기 대기의 응답이 트랜잭션의 커밋 레코드를 수신하여 운영 체제에 기록 할 때까지 기다립니다. 이 설정은 PostgreSQL의 대기 인스턴스가 충돌하더라도 데이터 보존을 보장하기에 충분하지만 데이터가 대기의 안정적인 스토리지에 반드시 도달 할 필요는 없기 때문에 대기에서 운영 체제 수준의 충돌이 발생하지는 않습니다. 마지막으로 &lt;code&gt;local&lt;/code&gt; 을 설정 하면 커밋이 디스크에 대한 로컬 플러시를 기다리지 만 복제는 기다리지 않습니다. 동기식 복제를 사용하는 경우에는 일반적으로 바람직하지 않지만 완전성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1a25dc46209d8ed1ade19ed10060c5c528c285e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the sum of the sizes of each relation's partitions is also displayed, along with the relation's description. If &lt;code&gt;n&lt;/code&gt; is combined with &lt;code&gt;+&lt;/code&gt;, two sizes are shown: one including the total size of directly-attached leaf partitions, and another showing the total size of all partitions, including indirectly attached sub-partitions.</source>
          <target state="translated">경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름을 추가하고, 각각의 관계의 파티션의 크기의 합은 관계의 설명과 함께 표시된다. 경우 &lt;code&gt;n&lt;/code&gt; 결합된다 &lt;code&gt;+&lt;/code&gt; , 두 가지 크기가 도시되어있다 : 하나는 직접 부착 판 파티션의 전체 크기를 포함하고, 다른 간접 부착 서브 파티션을 포함한 모든 파티션의 전체 크기를 표시.</target>
        </trans-unit>
        <trans-unit id="f1cb07ba733b8d98ef45c815d6dfcd5240fbfb93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, then the output lines are numbered from 1.</source>
          <target state="translated">경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 출력 라인은 하나의 숫자가된다.</target>
        </trans-unit>
        <trans-unit id="070b09cd2b09c6b749465149e9d2da178b70c1ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, then the output lines are numbered, with the first line of the function body being line 1.</source>
          <target state="translated">경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 출력 라인은 함수 바디 존재 라인의 제 1 라인으로 넘버링된다.</target>
        </trans-unit>
        <trans-unit id="2d52331f0d53378e8895c635840bb2a68f08d247" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--latency-limit&lt;/code&gt; is used together with &lt;code&gt;--rate&lt;/code&gt;, a transaction can lag behind so much that it is already over the latency limit when the previous transaction ends, because the latency is calculated from the scheduled start time. Such transactions are not sent to the server, but are skipped altogether and counted separately.</source>
          <target state="translated">경우 &lt;code&gt;--latency-limit&lt;/code&gt; 과 함께 사용 &lt;code&gt;--rate&lt;/code&gt; , 트랜잭션이 이미 대기 시간 한도를 초과 너무 많이이라고 뒤쳐 수있을 때 이전 트랜잭션 종료, 대기 시간은 예약 시작 시간을 계산하기 때문에. 이러한 트랜잭션은 서버로 전송되지 않지만 완전히 건너 뛰어 별도로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5b7745b7624e7dd43bb242cb0d62e7379c97ee2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ALTER TYPE ... ADD VALUE&lt;/code&gt; (the form that adds a new value to an enum type) is executed inside a transaction block, the new value cannot be used until after the transaction has been committed.</source>
          <target state="translated">경우 &lt;code&gt;ALTER TYPE ... ADD VALUE&lt;/code&gt; (열거 타입에 새로운 값을 추가하는 형태)가 트랜잭션 블록 내부에서 실행되고, 새로운 값은 트랜잭션이 커밋 된 후에까지 사용될 수 없다.</target>
        </trans-unit>
        <trans-unit id="bb077bc49a16e30ee77115d9ffe115d963646660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AND CHAIN&lt;/code&gt; is specified, a new transaction is immediately started with the same transaction characteristics (see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;) as the just finished one. Otherwise, no new transaction is started.</source>
          <target state="translated">경우 &lt;code&gt;AND CHAIN&lt;/code&gt; 지정, 새로운 트랜잭션은 즉시 동일한 트랜잭션 특성 (참조로 시작 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET 거래를&lt;/a&gt; 방금 완성 된 하나). 그렇지 않으면 새 트랜잭션이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7c08e9bace5b5133ac34adca9a08f4fe042258e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CALL&lt;/code&gt; is executed in a transaction block, then the called procedure cannot execute transaction control statements. Transaction control statements are only allowed if &lt;code&gt;CALL&lt;/code&gt; is executed in its own transaction.</source>
          <target state="translated">경우 &lt;code&gt;CALL&lt;/code&gt; 가 트랜잭션 블록에서 실행 한 후 호출 된 프로 시저는 트랜잭션 제어 문을 실행할 수 없습니다. 트랜잭션 제어문은 &lt;code&gt;CALL&lt;/code&gt; 이 자체 트랜잭션에서 실행 되는 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="848ec5bbdc5b00e6cc3d9f1bcaa95b1dc8f6e6eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the table will be created as the default partition of the parent table. This option is not available for hash-partitioned tables. A partition key value not fitting into any other partition of the given parent will be routed to the default partition.</source>
          <target state="translated">경우 &lt;code&gt;DEFAULT&lt;/code&gt; 가 지정되면, 테이블은 부모 테이블의 기본 파티션으로 생성됩니다. 해시 파티션 된 테이블에는이 옵션을 사용할 수 없습니다. 주어진 부모의 다른 파티션에 맞지 않는 파티션 키 값은 기본 파티션으로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="e7358add8de8561a637a99b57db04968568623ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DISTINCT&lt;/code&gt; is specified in addition to an &lt;code&gt;order_by_clause&lt;/code&gt;, then all the &lt;code&gt;ORDER BY&lt;/code&gt; expressions must match regular arguments of the aggregate; that is, you cannot sort on an expression that is not included in the &lt;code&gt;DISTINCT&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;order_by_clause&lt;/code&gt; 외에 &lt;code&gt;DISTINCT&lt;/code&gt; 가 지정된 경우 모든 &lt;code&gt;ORDER BY&lt;/code&gt; 표현식은 집계의 일반 인수와 일치해야합니다. 즉, &lt;code&gt;DISTINCT&lt;/code&gt; 목록에 포함되지 않은 식을 정렬 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="30705d4f5de2e5919df753dbf707be6e61f46c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DO&lt;/code&gt; is executed in a transaction block, then the procedure code cannot execute transaction control statements. Transaction control statements are only allowed if &lt;code&gt;DO&lt;/code&gt; is executed in its own transaction.</source>
          <target state="translated">경우 &lt;code&gt;DO&lt;/code&gt; 가 트랜잭션 블록에서 실행되는 다음 프로 시저 코드는 트랜잭션 제어 문을 실행할 수 없습니다. 트랜잭션 제어문은 &lt;code&gt;DO&lt;/code&gt; 가 자체 트랜잭션에서 실행 되는 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d029254e59ae42060c8fbefb0b0879b5e2662e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP EXPRESSION IF EXISTS&lt;/code&gt; is specified and the column is not a stored generated column, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">경우 &lt;code&gt;DROP EXPRESSION IF EXISTS&lt;/code&gt; 지정 열이 저장 생성 된 컬럼하지 않다, 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="df6a86ce0cd5c24d459324e69a0c7e3798125378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP IDENTITY IF EXISTS&lt;/code&gt; is specified and the column is not an identity column, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">경우 &lt;code&gt;DROP IDENTITY IF EXISTS&lt;/code&gt; 지정되고 열이 ID 열이 아닌, 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="895523ab1404bbeb5f8a66ec67423cf5c0e02e37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP ROLE&lt;/code&gt; is attempted while dependent objects still remain, it will issue messages identifying which objects need to be reassigned or dropped.</source>
          <target state="translated">종속 오브젝트가 계속 남아있는 동안 &lt;code&gt;DROP ROLE&lt;/code&gt; 을 시도 하면 , 재 할당하거나 삭제해야하는 오브젝트를 식별하는 메시지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="da529f5ed28015eb2651a4b68ada28ed62e240c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FILTER&lt;/code&gt; is specified, then only the input rows for which the &lt;code&gt;filter_clause&lt;/code&gt; evaluates to true are fed to the aggregate function; other rows are discarded. For example:</source>
          <target state="translated">경우 &lt;code&gt;FILTER&lt;/code&gt; 되는, 만 입력 행 지정 &lt;code&gt;filter_clause&lt;/code&gt; 의 참으로 평가를 집계 함수로 공급되는 단계; 다른 행은 삭제됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bc024c5c56715620389a9f40a0a619b2dabf192" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FILTER&lt;/code&gt; is specified, then only the input rows for which the &lt;code&gt;filter_clause&lt;/code&gt; evaluates to true are fed to the window function; other rows are discarded. Only window functions that are aggregates accept a &lt;code&gt;FILTER&lt;/code&gt; clause.</source>
          <target state="translated">경우 &lt;code&gt;FILTER&lt;/code&gt; 지정된 경우 만 입력되는 행을위한 &lt;code&gt;filter_clause&lt;/code&gt; 의 참으로 평가하여 창 함수에 공급된다; 다른 행은 삭제됩니다. 집계 된 창 함수 만 &lt;code&gt;FILTER&lt;/code&gt; 절을 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="cd9e1d53d5d6b7dacb647bc6b43f3a0bb2b3f3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; is specified, then in addition to the final state value and any direct arguments, the final function receives extra NULL values corresponding to the aggregate's regular (aggregated) arguments. This is mainly useful to allow correct resolution of the aggregate result type when a polymorphic aggregate is being defined.</source>
          <target state="translated">경우 &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; 가 지정된 후 최종 상태 값과 직접적인 인자 이외에, 최종 함수는 골재의 정규 (응집) 인자에 대응하는 여분의 NULL 값을 수신한다. 이는 다형성 집계가 정의 될 때 집계 결과 유형의 올바른 해상도를 허용하는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="79c74fbef6be293db9ab06b3c7837e0fb4b62bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FOR UPDATE&lt;/code&gt;, &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; or &lt;code&gt;FOR KEY SHARE&lt;/code&gt; is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement locks the selected rows against concurrent updates. (See &lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;The Locking Clause&lt;/a&gt; below.)</source>
          <target state="translated">경우 &lt;code&gt;FOR UPDATE&lt;/code&gt; , &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;FOR SHARE&lt;/code&gt; 또는 &lt;code&gt;FOR KEY SHARE&lt;/code&gt; 지정되면, &lt;code&gt;SELECT&lt;/code&gt; 문은 동시 업데이트에 대한 선택한 행을 잠급니다. (아래 &lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;의 잠금 조항을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a805c0a50f5da5361e847219abae4a282083ebad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FX&lt;/code&gt; is specified, a separator in the template string matches exactly one character in the input string. But note that the input string character is not required to be the same as the separator from the template string. For example, &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY MON')&lt;/code&gt; works, but &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY&amp;nbsp;&amp;nbsp;MON')&lt;/code&gt; returns an error because the second space in the template string consumes the letter &lt;code&gt;J&lt;/code&gt; from the input string.</source>
          <target state="translated">&lt;code&gt;FX&lt;/code&gt; 가 지정된 경우 템플릿 문자열의 구분 기호는 입력 문자열의 문자 하나와 정확히 일치합니다. 그러나 입력 문자열 문자가 템플릿 문자열의 구분 기호와 같을 필요는 없습니다. 예를 들어, &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY MON')&lt;/code&gt; 는 작동하지만 &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY&amp;nbsp;&amp;nbsp;MON')&lt;/code&gt; 는 템플리트 문자열의 두 번째 공백 이 입력에서 문자 &lt;code&gt;J&lt;/code&gt; 를 소비하므로 오류를 리턴합니다. 끈.</target>
        </trans-unit>
        <trans-unit id="14af0e221ff15633d3dbc5822cb9a995fc47a018" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; is not specified for a registered buffer, the generic WAL record contains a delta between the old and the new page images. This delta is based on byte-by-byte comparison. This is not very compact for the case of moving data within a page, and might be improved in the future.</source>
          <target state="translated">경우 &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; 이 등록 된 버퍼를 지정하지 않은 일반 WAL 레코드 이전 및 새 페이지 이미지 사이의 델타가 포함되어 있습니다. 이 델타는 바이트 단위 비교를 기반으로합니다. 페이지 내에서 데이터를 이동하는 경우에는 그리 간단하지 않으며 앞으로 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5c28224428244bd7b83410c113faa1c8237d3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GRANT OPTION FOR&lt;/code&gt; is specified, only the grant option for the privilege is revoked, not the privilege itself. Otherwise, both the privilege and the grant option are revoked.</source>
          <target state="translated">경우 &lt;code&gt;GRANT OPTION FOR&lt;/code&gt; 지정되면, 권한 만 부여 옵션은 권한 자체를하지 폐기됩니다. 그렇지 않으면 권한과 부여 옵션이 모두 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="36e5c2c5c78fde83426abf27ef6c16ab41ff4995" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GRANTED BY&lt;/code&gt; is specified, the grant is recorded as having been done by the specified role. Only database superusers may use this option, except when it names the same role executing the command.</source>
          <target state="translated">경우 &lt;code&gt;GRANTED BY&lt;/code&gt; 지정, 부여는 지정된 역할에 의해 수행 된 것으로 기록되어있다. 명령을 실행하는 동일한 역할의 이름을 지정하는 경우를 제외하고 데이터베이스 수퍼 유저 만이 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1dbb4a5b057fd9d80b4085324de683535f1772c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified, it is not an error if the type already contains the new value: a notice is issued but no other action is taken. Otherwise, an error will occur if the new value is already present.</source>
          <target state="translated">경우 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 지정된 유형이 이미 새 값을 포함하는 경우, 에러되지 않습니다 : 통지가 발행되지만 다른 작업이 수행되지 않습니다. 그렇지 않으면 새 값이 이미 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="713b84661234cdebeb4eb076bfe7612a7ddb758e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NO CYCLE&lt;/code&gt; is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, &lt;code&gt;NO CYCLE&lt;/code&gt; is the default.</source>
          <target state="translated">경우 &lt;code&gt;NO CYCLE&lt;/code&gt; 이 지정된 경우를 호출하기 &lt;code&gt;nextval&lt;/code&gt; 순서 후에는 최대 값이 오류를 반환 도달했습니다. &lt;code&gt;CYCLE&lt;/code&gt; 또는 &lt;code&gt;NO CYCLE&lt;/code&gt; 을 지정 하지 않으면 &lt;code&gt;NO CYCLE&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="72454c0dc96ec89da5b352eb2463b5c3b5e5fc00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NONE&lt;/code&gt; is selected, the backup manifest will not contain any checksums. Otherwise, it will contain a checksum of each file in the backup using the specified algorithm. In addition, the manifest will always contain a &lt;code&gt;SHA256&lt;/code&gt; checksum of its own contents. The &lt;code&gt;SHA&lt;/code&gt; algorithms are significantly more CPU-intensive than &lt;code&gt;CRC32C&lt;/code&gt;, so selecting one of them may increase the time required to complete the backup.</source>
          <target state="translated">경우 &lt;code&gt;NONE&lt;/code&gt; 선택하지 않은 백업 매니페스트는 체크섬을 포함되지 않습니다. 그렇지 않으면 지정된 알고리즘을 사용하는 백업에있는 각 파일의 체크섬이 포함됩니다. 또한 매니페스트에는 항상 자체 콘텐츠 의 &lt;code&gt;SHA256&lt;/code&gt; 체크섬이 포함됩니다 . &lt;code&gt;SHA&lt;/code&gt; 의 알고리즘은 CPU를 많이 사용하는 것보다 훨씬 더 있습니다 &lt;code&gt;CRC32C&lt;/code&gt; 때문에 시간을 증가시킬 수 있습니다 그 중 하나를 선택하는 백업을 완료하는 데 필요한.</target>
        </trans-unit>
        <trans-unit id="6bbdf1bb14119659019986a40e06a497bd2493a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NULLS LAST&lt;/code&gt; is specified, null values sort after all non-null values; if &lt;code&gt;NULLS FIRST&lt;/code&gt; is specified, null values sort before all non-null values. If neither is specified, the default behavior is &lt;code&gt;NULLS LAST&lt;/code&gt; when &lt;code&gt;ASC&lt;/code&gt; is specified or implied, and &lt;code&gt;NULLS FIRST&lt;/code&gt; when &lt;code&gt;DESC&lt;/code&gt; is specified (thus, the default is to act as though nulls are larger than non-nulls). When &lt;code&gt;USING&lt;/code&gt; is specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator.</source>
          <target state="translated">경우 &lt;code&gt;NULLS LAST&lt;/code&gt; 는 일종의 널 (NULL)이 아닌 모든 값 이후, 널 (null) 값을 지정; 경우 &lt;code&gt;NULLS FIRST&lt;/code&gt; 가 지정되고, 널 (null) 값 종류의 모든 null이 아닌 값 전에. 둘 다 지정하지 않으면 &lt;code&gt;ASC&lt;/code&gt; 를 지정하거나 암시 할 때 기본 동작은 &lt;code&gt;NULLS LAST&lt;/code&gt; 이고 &lt;code&gt;DESC&lt;/code&gt; 가 지정 될 때 &lt;code&gt;NULLS FIRST&lt;/code&gt; 입니다 (따라서 기본값은 널이 널이 아닌 것보다 큰 것처럼 작동 함). 때 &lt;code&gt;USING&lt;/code&gt; 지정, 기본 널 순서는 운영자가 덜 작거나보다 큰 사업자인지에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="8fb56e2e9f0f01bd1fdfbdbf89ac20f3bbcae1c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PARTITION OF&lt;/code&gt; clause is specified then the table is created as a partition of &lt;code&gt;parent_table&lt;/code&gt; with specified bounds.</source>
          <target state="translated">경우 &lt;code&gt;PARTITION OF&lt;/code&gt; 절을 한 후 지정된 테이블의 파티션으로 생성 &lt;code&gt;parent_table&lt;/code&gt; 지정된 범위와.</target>
        </trans-unit>
        <trans-unit id="c7ee0e44f6b6bd7b6f554d708cd5b901ba47c152" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PRIMARY KEY&lt;/code&gt; is specified, and the index's columns are not already marked &lt;code&gt;NOT NULL&lt;/code&gt;, then this command will attempt to do &lt;code&gt;ALTER COLUMN SET NOT NULL&lt;/code&gt; against each such column. That requires a full table scan to verify the column(s) contain no nulls. In all other cases, this is a fast operation.</source>
          <target state="translated">경우 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 가 지정, 인덱스의 열이 이미 표시되지 않은 &lt;code&gt;NOT NULL&lt;/code&gt; 을 ,이 명령을 수행하려고 시도합니다 &lt;code&gt;ALTER COLUMN SET NOT NULL&lt;/code&gt; 각각 같은 열에 대해. 열에 널이 없는지 확인하려면 전체 테이블 스캔이 필요합니다. 다른 모든 경우에는 빠른 작업입니다.</target>
        </trans-unit>
        <trans-unit id="ae2eae0b6691115fff0baa447860d3557c71a926" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RECURSIVE&lt;/code&gt; is specified, it allows a &lt;code&gt;SELECT&lt;/code&gt; subquery to reference itself by name. Such a subquery must have the form</source>
          <target state="translated">경우 &lt;code&gt;RECURSIVE&lt;/code&gt; 지정, 그것은 수 있습니다 &lt;code&gt;SELECT&lt;/code&gt; 이름으로 자신을 참조하는 하위 쿼리를. 이러한 하위 쿼리는 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c5e50c2f4aff13823fb6c53c60eb5ef4318ca54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SELECT DISTINCT&lt;/code&gt; is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates). &lt;code&gt;SELECT ALL&lt;/code&gt; specifies the opposite: all rows are kept; that is the default.</source>
          <target state="translated">경우 &lt;code&gt;SELECT DISTINCT&lt;/code&gt; 가 지정된 모든 중복 행 결과 세트로부터 제거된다 (하나 개의 행이 중복되는 각 그룹에서 유지된다). &lt;code&gt;SELECT ALL&lt;/code&gt; 은 반대를 지정합니다. 모든 행이 유지됩니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="04b3f6938761ce362c4ded325b6abaf0a88a5df2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET LOCAL&lt;/code&gt; is used within a function that has a &lt;code&gt;SET&lt;/code&gt; option for the same variable (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;), the effects of the &lt;code&gt;SET LOCAL&lt;/code&gt; command disappear at function exit; that is, the value in effect when the function was called is restored anyway. This allows &lt;code&gt;SET LOCAL&lt;/code&gt; to be used for dynamic or repeated changes of a parameter within a function, while still having the convenience of using the &lt;code&gt;SET&lt;/code&gt; option to save and restore the caller's value. However, a regular &lt;code&gt;SET&lt;/code&gt; command overrides any surrounding function's &lt;code&gt;SET&lt;/code&gt; option; its effects will persist unless rolled back.</source>
          <target state="translated">동일한 변수에 대해 &lt;code&gt;SET&lt;/code&gt; 옵션 이있는 함수 내에서 &lt;code&gt;SET LOCAL&lt;/code&gt; 을 사용하는 경우 ( &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 참조 ) &lt;code&gt;SET LOCAL&lt;/code&gt; 명령 의 효과는 함수 종료시 사라집니다. 즉, 함수가 호출되었을 때 유효한 값이 어쨌든 복원됩니다. 이를 통해 &lt;code&gt;SET LOCAL&lt;/code&gt; 을 사용하여 함수 내에서 매개 변수를 동적으로 또는 반복적으로 변경할 수 있으며 &lt;code&gt;SET&lt;/code&gt; 옵션을 사용 하여 호출자의 값을 저장하고 복원 할 수 있습니다. 그러나 일반적인 &lt;code&gt;SET&lt;/code&gt; 명령은 모든 주변 기능의 &lt;code&gt;SET&lt;/code&gt; 옵션 보다 우선합니다 . 롤백하지 않으면 효과가 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="ec901162256017a1ee3d75cc5aa3a5194df885bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET TRANSACTION&lt;/code&gt; is executed without a prior &lt;code&gt;START TRANSACTION&lt;/code&gt; or &lt;code&gt;BEGIN&lt;/code&gt;, it emits a warning and otherwise has no effect.</source>
          <target state="translated">경우 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 이전하지 않고 실행 &lt;code&gt;START TRANSACTION&lt;/code&gt; 또는 &lt;code&gt;BEGIN&lt;/code&gt; , 그것은 경고를 방출하고, 그렇지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c679999524623fe277800e4000b75170afd22ce0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET&lt;/code&gt; (or equivalently &lt;code&gt;SET SESSION&lt;/code&gt;) is issued within a transaction that is later aborted, the effects of the &lt;code&gt;SET&lt;/code&gt; command disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SET&lt;/code&gt; (또는 동등 &lt;code&gt;SET SESSION&lt;/code&gt; 가 ) 나중에 중단 된 트랜잭션 내에서 발행,의 효과 &lt;code&gt;SET&lt;/code&gt; 의 트랜잭션이 롤백 될 때 명령은 사라집니다. 주변 트랜잭션이 커밋되면 다른 &lt;code&gt;SET&lt;/code&gt; 가 재정의하지 않는 한 세션이 끝날 때까지 효과가 지속됩니다 .</target>
        </trans-unit>
        <trans-unit id="9705e1f00e76813c6d22bc3d6eab56b5d6ef9cd2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; is specified, the member can in turn grant membership in the role to others, and revoke membership in the role as well. Without the admin option, ordinary users cannot do that. A role is not considered to hold &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; on itself, but it may grant or revoke membership in itself from a database session where the session user matches the role. Database superusers can grant or revoke membership in any role to anyone. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can grant or revoke membership in any role that is not a superuser.</source>
          <target state="translated">경우 &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; 지정된 역할의 멤버 캔 차례로 부여 다른 사람에게 역할의 멤버 및 REVOKE 회원뿐만 아니라. 관리자 옵션이 없으면 일반 사용자는 그렇게 할 수 없습니다. 역할은 자체적으로 &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; 을 보유하는 것으로 간주되지 않지만 세션 사용자가 역할과 일치하는 데이터베이스 세션에서 자체적으로 멤버 자격을 부여하거나 취소 할 수 있습니다. 데이터베이스 수퍼 유저는 모든 역할의 멤버 자격을 누구에게나 부여하거나 취소 할 수 있습니다. 가진 역할 &lt;code&gt;CREATEROLE&lt;/code&gt; 의 권한을 부여하거나 수퍼 유저가 아닌 임의의 역할에 회원 자격을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd80886f4a2be834b3e10dda7c9db6fa997569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; is specified, the recipient of the privilege can in turn grant it to others. Without a grant option, the recipient cannot do that. Grant options cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; 지정, 차례로 권한 캔의받는 사람이 다른 사람에게 부여합니다. 부여 옵션이 없으면 수신자는 그렇게 할 수 없습니다. &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 옵션을 부여 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9373b178281613a72e6b020f7636dc488a5f1d3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH HOLD&lt;/code&gt; is specified and the transaction that created the cursor successfully commits, the cursor can continue to be accessed by subsequent transactions in the same session. (But if the creating transaction is aborted, the cursor is removed.) A cursor created with &lt;code&gt;WITH HOLD&lt;/code&gt; is closed when an explicit &lt;code&gt;CLOSE&lt;/code&gt; command is issued on it, or the session ends. In the current implementation, the rows represented by a held cursor are copied into a temporary file or memory area so that they remain available for subsequent transactions.</source>
          <target state="translated">경우 &lt;code&gt;WITH HOLD&lt;/code&gt; 지정 커서를 생성 한 트랜잭션이 성공적으로 커밋되고, 커서는 같은 세션에서 후속 트랜잭션에 의해 액세스 할 수 계속할 수 있습니다. 그러나 작성 트랜잭션이 중단되면 커서가 제거됩니다. &lt;code&gt;WITH HOLD&lt;/code&gt; 로 작성된 커서 는 명시적인 &lt;code&gt;CLOSE&lt;/code&gt; 명령이 발행되거나 세션 이 종료 될 때 닫힙니다 . 현재 구현에서, 보유 커서로 표시되는 행은 임시 파일 또는 메모리 영역으로 복사되어 후속 트랜잭션에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d9dde45619a2d3c398745c13026f768d6b6b6cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;\d&lt;/code&gt; is used without a &lt;code&gt;pattern&lt;/code&gt; argument, it is equivalent to &lt;code&gt;\dtvmsE&lt;/code&gt; which will show a list of all visible tables, views, materialized views, sequences and foreign tables. This is purely a convenience measure.</source>
          <target state="translated">경우 &lt;code&gt;\d&lt;/code&gt; 없이 사용 &lt;code&gt;pattern&lt;/code&gt; 인수가 동등 &lt;code&gt;\dtvmsE&lt;/code&gt; 보이는 모든 테이블의 목록이 표시되는 뷰는 뷰 시퀀스 외국 테이블을 구체화. 이것은 순전히 편의 수단입니다.</target>
        </trans-unit>
        <trans-unit id="99696408eca3e79444094829903879dfb2c22cfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;\pset columns&lt;/code&gt; is zero, controls the width for the &lt;code&gt;wrapped&lt;/code&gt; format and width for determining if wide output requires the pager or should be switched to the vertical format in expanded auto mode.</source>
          <target state="translated">경우 &lt;code&gt;\pset columns&lt;/code&gt; 제로의 폭 제어를위한 &lt;code&gt;wrapped&lt;/code&gt; 넓은 출력 페이저를 요구하거나 확장 자동 모드에서의 수직 형태로 전환되어야 하는지를 결정하기위한 포맷 및 폭.</target>
        </trans-unit>
        <trans-unit id="65d8ff6e4bb927882e0081eeca2677185a93d180" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;archive_mode&lt;/code&gt; is set to &lt;code&gt;on&lt;/code&gt;, the archiver is not enabled during recovery or standby mode. If the standby server is promoted, it will start archiving after the promotion, but will not archive any WAL it did not generate itself. To get a complete series of WAL files in the archive, you must ensure that all WAL is archived, before it reaches the standby. This is inherently true with file-based log shipping, as the standby can only restore files that are found in the archive, but not if streaming replication is enabled. When a server is not in recovery mode, there is no difference between &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;always&lt;/code&gt; modes.</source>
          <target state="translated">&lt;code&gt;archive_mode&lt;/code&gt; 가 &lt;code&gt;on&lt;/code&gt; 으로 설정되어 있으면 복구 또는 대기 모드 중에 아카이버를 사용할 수 없습니다. 대기 서버가 승격 된 경우 승격 후 보관을 시작하지만 자체 생성하지 않은 WAL은 보관하지 않습니다. 아카이브에서 전체 WAL 파일 시리즈를 얻으려면 대기에 도달하기 전에 모든 WAL이 아카이브되어 있는지 확인해야합니다. 대기는 아카이브에서 찾은 파일 만 복원 할 수 있지만 스트리밍 복제가 사용 가능한 경우는 불가능하므로 파일 기반 로그 전달에서는 본질적으로 적용됩니다. 서버가 복구 모드에 있지 않으면 &lt;code&gt;on&lt;/code&gt; 모드 와 &lt;code&gt;always&lt;/code&gt; 모드 간에 차이가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6c695d4c8ca7c7dc88430e23d97c617405cca08b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;archive_mode&lt;/code&gt; is set to &lt;code&gt;on&lt;/code&gt;, the archiver is not enabled during recovery or standby mode. If the standby server is promoted, it will start archiving after the promotion, but will not archive any WAL or timeline history files that it did not generate itself. To get a complete series of WAL files in the archive, you must ensure that all WAL is archived, before it reaches the standby. This is inherently true with file-based log shipping, as the standby can only restore files that are found in the archive, but not if streaming replication is enabled. When a server is not in recovery mode, there is no difference between &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;always&lt;/code&gt; modes.</source>
          <target state="translated">&lt;code&gt;archive_mode&lt;/code&gt; 가 &lt;code&gt;on&lt;/code&gt; 으로 설정된 경우 아카이버는 복구 또는 대기 모드 중에 활성화되지 않습니다. 대기 서버가 승격 된 경우 승격 후 보관이 시작되지만 자체적으로 생성하지 않은 WAL 또는 타임 라인 기록 파일은 보관하지 않습니다. 아카이브에서 전체 WAL 파일 시리즈를 가져 오려면 모든 WAL이 대기 상태에 도달하기 전에 아카이브되었는지 확인해야합니다. 이는 파일 기반 로그 전달의 경우 본질적으로 사실입니다. 대기 모드는 아카이브에서 찾은 파일 만 복원 할 수 있지만 스트리밍 복제가 활성화 된 경우에는 복원 할 수 없습니다. 서버가 복구 모드가 아닌 경우 &lt;code&gt;on&lt;/code&gt; 모드 와 &lt;code&gt;always&lt;/code&gt; 모드 간에 차이가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4c5e023785c0eaf8158798154829baaec24284f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt; (hyphen), then standard input is read until an EOF indication or &lt;code&gt;\q&lt;/code&gt; meta-command. This can be used to intersperse interactive input with input from files. Note however that Readline is not used in this case (much as if &lt;code&gt;-n&lt;/code&gt; had been specified).</source>
          <target state="translated">경우 &lt;code&gt;filename&lt;/code&gt; 이다 &lt;code&gt;-&lt;/code&gt; (하이픈) 다음 표준 입력은 EOF 또는 표시 될 때까지 판독된다 &lt;code&gt;\q&lt;/code&gt; 메타 명령. 이것은 대화식 입력을 파일 입력과 함께 산재하는 데 사용할 수 있습니다. 그러나이 경우 Readline은 사용되지 않습니다 ( &lt;code&gt;-n&lt;/code&gt; 이 지정된 것처럼 ).</target>
        </trans-unit>
        <trans-unit id="a4833473639ec21367a52ecaec9a765427862e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt; (hyphen), then standard input is read until an EOF indication or &lt;code&gt;\q&lt;/code&gt; meta-command. This can be used to intersperse interactive input with input from files. Note that Readline behavior will be used only if it is active at the outermost level.</source>
          <target state="translated">경우 &lt;code&gt;filename&lt;/code&gt; 이다 &lt;code&gt;-&lt;/code&gt; (하이픈) 다음 표준 입력은 EOF 또는 표시 될 때까지 판독된다 &lt;code&gt;\q&lt;/code&gt; 메타 명령. 이것은 대화식 입력을 파일 입력과 함께 산재하는 데 사용할 수 있습니다. Readline 동작은 가장 바깥 레벨에서 활성화 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d8bdbf29f6ea734e4384d8cec6971a567637c07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is specified, the file is edited; after the editor exits, the file's content is copied into the current query buffer. If no &lt;code&gt;filename&lt;/code&gt; is given, the current query buffer is copied to a temporary file which is then edited in the same fashion. Or, if the current query buffer is empty, the most recently executed query is copied to a temporary file and edited in the same fashion.</source>
          <target state="translated">경우 &lt;code&gt;filename&lt;/code&gt; 지정, 파일은 편집; 편집기가 종료되면 파일 내용이 현재 쿼리 버퍼에 복사됩니다. &lt;code&gt;filename&lt;/code&gt; 을 지정 하지 않으면 현재 쿼리 버퍼가 임시 파일로 복사 된 다음 동일한 방식으로 편집됩니다. 또는 현재 쿼리 버퍼가 비어 있으면 가장 최근에 실행 된 쿼리가 임시 파일로 복사되고 같은 방식으로 편집됩니다.</target>
        </trans-unit>
        <trans-unit id="87b5fa64a8f2d20fd3cdbf376e8372ac5be9682f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame_end&lt;/code&gt; is omitted it defaults to &lt;code&gt;CURRENT ROW&lt;/code&gt;. Restrictions are that &lt;code&gt;frame_start&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt;, &lt;code&gt;frame_end&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;, and the &lt;code&gt;frame_end&lt;/code&gt; choice cannot appear earlier in the above list of &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; options than the &lt;code&gt;frame_start&lt;/code&gt; choice does &amp;mdash; for example &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; is not allowed.</source>
          <target state="translated">&lt;code&gt;frame_end&lt;/code&gt; 가 생략 되면 기본값은 &lt;code&gt;CURRENT ROW&lt;/code&gt; 입니다. 제한 사항이 있습니다 &lt;code&gt;frame_start&lt;/code&gt; 이 될 수 없다 &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; , &lt;code&gt;frame_end&lt;/code&gt; 될 수 없습니다 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 하고 &lt;code&gt;frame_end&lt;/code&gt; 선택의 위의 목록에서 이전에 나타날 수 없습니다 &lt;code&gt;frame_start&lt;/code&gt; 및 &lt;code&gt;frame_end&lt;/code&gt; 댄 옵션 &lt;code&gt;frame_start&lt;/code&gt; 의 선택은 않습니다 - 예에 대한 &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1493aafac52b8fb4240f760d7718dc0ee8aca4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;genbki.pl&lt;/code&gt; needs to assign an OID to a catalog entry that does not have a manually-assigned OID, it will use a value in the range 10000&amp;mdash;11999. The server's OID counter is set to 12000 at the start of a bootstrap run. Thus objects created by regular SQL commands during the later phases of bootstrap, such as objects created while running the &lt;code&gt;information_schema.sql&lt;/code&gt; script, receive OIDs of 12000 or above.</source>
          <target state="translated">&lt;code&gt;genbki.pl&lt;/code&gt; 이 수동으로 할당 한 OID가없는 카탈로그 항목에 OID를 할당 해야하는 경우 10000&amp;mdash;11999 범위의 값을 사용합니다. 부트 스트랩 실행 시작시 서버의 OID 카운터가 12000으로 설정됩니다. 따라서 &lt;code&gt;information_schema.sql&lt;/code&gt; 스크립트 를 실행하는 동안 생성 된 객체와 같이 부트 스트랩의 이후 단계에서 일반 SQL 명령으로 생성 된 객체 는 12000 이상의 OID를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="e8c7103cc04741a131a5ac6b2ff588f135e3ddcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hot_standby&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; (the default value) and there is a &lt;code&gt;standby.signal&lt;/code&gt; file present, the server will run in Hot Standby mode. However, it may take some time for Hot Standby connections to be allowed, because the server will not accept connections until it has completed sufficient recovery to provide a consistent state against which queries can run. During this period, clients that attempt to connect will be refused with an error message. To confirm the server has come up, either loop trying to connect from the application, or look for these messages in the server logs:</source>
          <target state="translated">경우 &lt;code&gt;hot_standby&lt;/code&gt; 가 이다 &lt;code&gt;on&lt;/code&gt; 있는 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 (기본값)과이 &lt;code&gt;standby.signal&lt;/code&gt; 파일 존재는, 서버는 상시 대기 모드로 실행됩니다. 그러나 핫 스탠바이 연결이 허용 되려면 시간이 걸릴 수 있습니다. 서버는 쿼리를 실행할 수있는 일관된 상태를 제공하기에 충분한 복구가 완료 될 때까지 연결을 수락하지 않기 때문입니다. 이 기간 동안 연결을 시도하는 클라이언트는 오류 메시지와 함께 거부됩니다. 서버가 작동했는지 확인하려면 루프를 응용 프로그램에서 연결하려고 시도하거나 서버 로그에서 다음 메시지를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="2c8e31ec3780ebc59dc482c2ca3c59c045a41221" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is false for some &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;, it must be false for every &lt;code&gt;val2&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;val1&lt;/code&gt; with the same &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;in_range&lt;/code&gt; 와 &lt;code&gt;less&lt;/code&gt; 진정한 = 일부에 대한 거짓 &lt;code&gt;val1&lt;/code&gt; 과 &lt;code&gt;base&lt;/code&gt; , 그것은 모든위한 false 여야 &lt;code&gt;val2&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;val1&lt;/code&gt; 과 같은과 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="332193353c52bde38e0eb3c661ad221eb1be8b6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is false for some &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;base1&lt;/code&gt;, it must be false for every &lt;code&gt;base2&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;base1&lt;/code&gt; with the same &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;in_range&lt;/code&gt; 와 &lt;code&gt;less&lt;/code&gt; = 사실이 일부 거짓 &lt;code&gt;val&lt;/code&gt; 과 &lt;code&gt;base1&lt;/code&gt; , 그것은 모든위한 false 여야 &lt;code&gt;base2&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;base1&lt;/code&gt; 같은과 &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa930e16baff55aa31e6852a2b74660f8ec3544e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is true for some &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;, it must be true for every &lt;code&gt;val2&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;val1&lt;/code&gt; with the same &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;in_range&lt;/code&gt; 와 &lt;code&gt;less&lt;/code&gt; = 사실이 일부 사실 &lt;code&gt;val1&lt;/code&gt; 및 &lt;code&gt;base&lt;/code&gt; 도 모든 마찬가지해야합니다 &lt;code&gt;val2&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;val1&lt;/code&gt; 과 같은과 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="342ab2a9a17f2fb194989decac130f65bf2a3ab2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is true for some &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;base1&lt;/code&gt;, it must be true for every &lt;code&gt;base2&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;base1&lt;/code&gt; with the same &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;in_range&lt;/code&gt; 와 &lt;code&gt;less&lt;/code&gt; = 사실이 일부 사실 &lt;code&gt;val&lt;/code&gt; 과 &lt;code&gt;base1&lt;/code&gt; , 그것은 모든 마찬가지해야 &lt;code&gt;base2&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;base1&lt;/code&gt; 같은과 &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3506d1e84d2320597dc89468fa4fbfef68d52af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pager_min_lines&lt;/code&gt; is set to a number greater than the page height, the pager program will not be called unless there are at least this many lines of output to show. The default setting is 0.</source>
          <target state="translated">&lt;code&gt;pager_min_lines&lt;/code&gt; 가 페이지 높이보다 큰 숫자로 설정된 경우 , 표시 할 최소한이 출력 행이 없으면 호출기 프로그램이 호출되지 않습니다. 기본 설정은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ad57f5bc57449c70be03f78cafa8198c7fecd4a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pattern&lt;/code&gt; does not contain percent signs or underscores, then the pattern only represents the string itself; in that case &lt;code&gt;LIKE&lt;/code&gt; acts like the equals operator. An underscore (&lt;code&gt;_&lt;/code&gt;) in &lt;code&gt;pattern&lt;/code&gt; stands for (matches) any single character; a percent sign (&lt;code&gt;%&lt;/code&gt;) matches any sequence of zero or more characters.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 퍼센트 기호 나 밑줄이 없으면 패턴 은 문자열 자체 만 나타냅니다. 이 경우 &lt;code&gt;LIKE&lt;/code&gt; 는 equals 연산자처럼 작동합니다. &lt;code&gt;pattern&lt;/code&gt; 의 밑줄 ( &lt;code&gt;_&lt;/code&gt; )은 단일 문자를 나타냅니다 (일치). 퍼센트 기호 ( &lt;code&gt;%&lt;/code&gt; )는 0 개 이상의 문자 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="929282dbe9432a59498fc7de54e9f120a0c23fde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pg_resetwal&lt;/code&gt; complains that it cannot determine valid data for &lt;code&gt;pg_control&lt;/code&gt;, you can force it to proceed anyway by specifying the &lt;code&gt;-f&lt;/code&gt; (force) option. In this case plausible values will be substituted for the missing data. Most of the fields can be expected to match, but manual assistance might be needed for the next OID, next transaction ID and epoch, next multitransaction ID and offset, and WAL starting location fields. These fields can be set using the options discussed below. If you are not able to determine correct values for all these fields, &lt;code&gt;-f&lt;/code&gt; can still be used, but the recovered database must be treated with even more suspicion than usual: an immediate dump and reload is imperative. &lt;em&gt;Do not&lt;/em&gt; execute any data-modifying operations in the database before you dump, as any such action is likely to make the corruption worse.</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; 이 &lt;code&gt;pg_control&lt;/code&gt; 에 유효한 데이터를 결정할 수 없다고 불평하는 경우 , &lt;code&gt;-f&lt;/code&gt; (force) 옵션 을 지정하여 강제로 진행할 수 있습니다 . 이 경우 그럴듯한 값이 누락 된 데이터로 대체됩니다. 대부분의 필드가 일치 할 것으로 예상되지만 다음 OID, 다음 트랜잭션 ID 및 에포크, 다음 다중 트랜잭션 ID 및 오프셋 및 WAL 시작 위치 필드에는 수동 지원이 필요할 수 있습니다. 이 필드는 아래에서 논의 된 옵션을 사용하여 설정할 수 있습니다. 이러한 모든 필드에 대해 올바른 값을 판별 할 수없는 경우 &lt;code&gt;-f&lt;/code&gt; 를 계속 사용할 수 있지만 복구 된 데이터베이스는 평소보다 훨씬 더 의심을 가지고 처리해야합니다. 즉각 덤프 및 재로드가 필수적입니다. &lt;em&gt;하지 마라&lt;/em&gt; 덤프하기 전에 데이터베이스에서 데이터 수정 조작을 실행하십시오. 이러한 조치는 손상을 악화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f13d0730a2d7549daf41a4dfb84c03f31c4b1319" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pg_upgrade&lt;/code&gt; aborted before linking started, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">링크가 시작되기 전에 &lt;code&gt;pg_upgrade&lt;/code&gt; 가 중단 된 경우 이전 클러스터는 수정되지 않았습니다. 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e188ae9422c6dffedeb340ab362e8934b4b3e43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prokind&lt;/code&gt; indicates that the entry is for an aggregate function, there should be a matching row in &lt;code&gt;pg_aggregate&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;prokind&lt;/code&gt; 이 항목이 집합 함수임을 나타낸다에 일치하는 행이 있어야 &lt;code&gt;pg_aggregate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e29943d28ac675fb4f0be463fde98da976b1859" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;synchronous_standby_names&lt;/code&gt; is empty, the only meaningful settings are &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt;; &lt;code&gt;remote_apply&lt;/code&gt;, &lt;code&gt;remote_write&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; all provide the same local synchronization level as &lt;code&gt;on&lt;/code&gt;. The local behavior of all non-&lt;code&gt;off&lt;/code&gt; modes is to wait for local flush of WAL to disk. In &lt;code&gt;off&lt;/code&gt; mode, there is no waiting, so there can be a delay between when success is reported to the client and when the transaction is later guaranteed to be safe against a server crash. (The maximum delay is three times &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt;.) Unlike &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt;, setting this parameter to &lt;code&gt;off&lt;/code&gt; does not create any risk of database inconsistency: an operating system or database crash might result in some recent allegedly-committed transactions being lost, but the database state will be just the same as if those transactions had been aborted cleanly. So, turning &lt;code&gt;synchronous_commit&lt;/code&gt; off can be a useful alternative when performance is more important than exact certainty about the durability of a transaction. For more discussion see &lt;a href=&quot;wal-async-commit&quot;&gt;Section 29.3&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 가 비어있는, 유일한 의미있는 설정은 다음 &lt;code&gt;on&lt;/code&gt; 와 &lt;code&gt;off&lt;/code&gt; ; &lt;code&gt;remote_apply&lt;/code&gt; , &lt;code&gt;remote_write&lt;/code&gt; 및 &lt;code&gt;local&lt;/code&gt; 모두 동일한 로컬 동기화 레벨을 제공하는 &lt;code&gt;on&lt;/code&gt; . 모든 non- &lt;code&gt;off&lt;/code&gt; 모드 의 로컬 동작 은 WAL이 디스크로 로컬 플러시 될 때까지 기다리는 것입니다. &lt;code&gt;off&lt;/code&gt; 모드 에서는 대기가 없으므로 클라이언트에 성공이보고되는 시점과 트랜잭션이 나중에 서버 충돌에 대해 안전하다고 보장되는 시점 사이에 지연이있을 수 있습니다. (최대 지연은 &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay의&lt;/a&gt; 3 배 입니다 .) &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; 와 달리이 매개 변수를 &lt;code&gt;off&lt;/code&gt; 로 설정 합니다.데이터베이스 불일치의 위험을 유발하지 않습니다. 운영 체제 또는 데이터베이스 충돌로 인해 최근에 커밋 된 트랜잭션이 손실 될 수 있지만 데이터베이스 상태는 해당 트랜잭션이 완전히 중단 된 것과 동일합니다. 따라서 &lt;code&gt;synchronous_commit&lt;/code&gt; 을 끄는 것은 트랜잭션의 내구성에 대한 정확한 확신보다 성능이 더 중요한 경우 유용한 대안이 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;wal-async-commit&quot;&gt;섹션 29.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32186644a8227bc9629078cb6964f294409c3b69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;synchronous_standby_names&lt;/code&gt; is empty, the settings &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;remote_apply&lt;/code&gt;, &lt;code&gt;remote_write&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; all provide the same synchronization level: transaction commits only wait for local flush to disk.</source>
          <target state="translated">&lt;code&gt;synchronous_standby_names&lt;/code&gt; 가 비어 있으면 , &lt;code&gt;remote_apply&lt;/code&gt; , &lt;code&gt;remote_write&lt;/code&gt; 및 &lt;code&gt;local&lt;/code&gt; 설정 &lt;code&gt;on&lt;/code&gt; 모두 동일한 동기화 레벨을 제공합니다. 트랜잭션 커밋은 디스크에 대한 로컬 플러시 만 대기합니다.</target>
        </trans-unit>
        <trans-unit id="e17b6ba8e8e554c6fa5ecad07078e794222b7865" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typarray&lt;/code&gt; is not 0 then it identifies another row in &lt;code&gt;pg_type&lt;/code&gt;, which is the &amp;ldquo;true&amp;rdquo; array type having this type as element</source>
          <target state="translated">&lt;code&gt;typarray&lt;/code&gt; 가 0이 아닌 경우 &lt;code&gt;pg_type&lt;/code&gt; 에서 다른 행을 식별 합니다 .이 행은 이 유형을 요소로 사용하는 &quot;true&quot;배열 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1643f010e11a8ec209a76b1daf0df11fad85a094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typdefaultbin&lt;/code&gt; is not null, it is the &lt;code&gt;nodeToString()&lt;/code&gt; representation of a default expression for the type. This is only used for domains.</source>
          <target state="translated">&lt;code&gt;typdefaultbin&lt;/code&gt; 이 널이 아닌 경우 유형에 대한 기본 표현식 의 &lt;code&gt;nodeToString()&lt;/code&gt; 표시입니다. 도메인에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a098d6d2d4ed82c302d8bd246178fb2399080947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typelem&lt;/code&gt; is not 0 then it identifies another row in &lt;code&gt;pg_type&lt;/code&gt;. The current type can then be subscripted like an array yielding values of type &lt;code&gt;typelem&lt;/code&gt;. A &amp;ldquo;true&amp;rdquo; array type is variable length (&lt;code&gt;typlen&lt;/code&gt; = -1), but some fixed-length (&lt;code&gt;typlen&lt;/code&gt; &amp;gt; 0) types also have nonzero &lt;code&gt;typelem&lt;/code&gt;, for example &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;point&lt;/code&gt;. If a fixed-length type has a &lt;code&gt;typelem&lt;/code&gt; then its internal representation must be some number of values of the &lt;code&gt;typelem&lt;/code&gt; data type with no other data. Variable-length array types have a header defined by the array subroutines.</source>
          <target state="translated">&lt;code&gt;typelem&lt;/code&gt; 이 0 이 아니면 &lt;code&gt;pg_type&lt;/code&gt; 에서 다른 행을 식별 합니다 . 그런 다음 현재 유형을 &lt;code&gt;typelem&lt;/code&gt; 유형의 값을 생성하는 배열처럼 첨자화할 수 있습니다 . &quot;true&quot;배열 유형은 가변 길이 ( &lt;code&gt;typlen&lt;/code&gt; = -1)이지만 일부 고정 길이 ( &lt;code&gt;typlen&lt;/code&gt; &amp;gt; 0) 유형 ( 예 : &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;point&lt;/code&gt; )도 0이 아닌 &lt;code&gt;typelem&lt;/code&gt; 입니다. 고정 길이 타입이있는 경우 &lt;code&gt;typelem&lt;/code&gt; 를 다음 내부 표현의 값의 일부 수 있어야 &lt;code&gt;typelem&lt;/code&gt; 의 다른 데이터를 데이터 타입. 가변 길이 배열 유형에는 배열 서브 루틴에 의해 정의 된 헤더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="962e01512a43e6b662e513b46b2720b8eda2c536" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable display of a locale-specific character to separate groups of digits to the left of the decimal marker. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and locale-specific numeric output.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 하나가되어야합니다 지정 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 있는 활성화 또는 소수점 마커의 왼쪽 자리의 별도의 그룹에 로케일 고유의 문자의 비활성화가 표시됩니다. 경우 &lt;code&gt;value&lt;/code&gt; 정규 로케일 특정 숫자의 출력 명령을 전환 생략한다.</target>
        </trans-unit>
        <trans-unit id="0ac5be223120c8314531a02347c6041d7cd668b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable display of the table footer (the &lt;code&gt;(n rows)&lt;/code&gt; count). If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles footer display on or off.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 지정되어이 중 하나 여야 &lt;code&gt;on&lt;/code&gt; 나 &lt;code&gt;off&lt;/code&gt; 있는 활성화 또는 테이블 바닥 글 (의 비활성화 표시됩니다 &lt;code&gt;(n rows)&lt;/code&gt; 카운트). 경우 &lt;code&gt;value&lt;/code&gt; 또는 해제 명령 토글 바닥 글 표시를 생략하기로한다.</target>
        </trans-unit>
        <trans-unit id="5cba26a9c2b6ebc7647fabad9eea11f281ddf193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable tuples-only mode. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and tuples-only output. Regular output includes extra information such as column headers, titles, and various footers. In tuples-only mode, only actual table data is shown.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 지정되어이 중 하나 여야 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 를 활성화 또는 비활성화 튜플 전용 모드 것이다. 경우 &lt;code&gt;value&lt;/code&gt; 정규 튜플 전용 출력 간의 토글 명령을 생략한다. 일반 출력에는 열 머리글, 제목 및 다양한 바닥 글과 같은 추가 정보가 포함됩니다. 튜플 전용 모드에서는 실제 테이블 데이터 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6fae09f9e5152eceff65217f721d75ba03342e63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;, which will enable or disable expanded mode, or &lt;code&gt;auto&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between the on and off settings. When expanded mode is enabled, query results are displayed in two columns, with the column name on the left and the data on the right. This mode is useful if the data wouldn't fit on the screen in the normal &amp;ldquo;horizontal&amp;rdquo; mode. In the auto setting, the expanded mode is used whenever the query output has more than one column and is wider than the screen; otherwise, the regular mode is used. The auto setting is only effective in the aligned and wrapped formats. In other formats, it always behaves as if the expanded mode is off.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 가 지정 되면 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 여야하며 확장 모드를 사용 또는 사용하지 않도록 설정하거나 &lt;code&gt;auto&lt;/code&gt; 입니다. 경우 &lt;code&gt;value&lt;/code&gt; 에 대한 설정 및 해제 사이의 명령 토글을 생략하기로한다. 확장 모드를 사용하면 왼쪽에 열 이름이 있고 오른쪽에 데이터가있는 두 개의 열에 쿼리 결과가 표시됩니다. 이 모드는 데이터가 일반 &quot;수평&quot;모드에서 화면에 맞지 않을 때 유용합니다. 자동 설정에서 확장 모드는 조회 출력에 둘 이상의 열이 있고 화면보다 넓은 경우 항상 사용됩니다. 그렇지 않으면 일반 모드가 사용됩니다. 자동 설정은 정렬 및 줄 바꿈 형식에서만 유효합니다. 다른 형식에서는 항상 확장 모드가 꺼져있는 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="ca01598c7c349232ee9c2f60f218cecf6c2e9b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is supplied, only occurrences having one of those weights are counted.</source>
          <target state="translated">경우 &lt;code&gt;weights&lt;/code&gt; 공급되고, 그 무게 중 하나를 가진 경우에만 발생 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc5f92abbdc131542b5a63d7715ef7b5720a0a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;do_detoast&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;, attribute that will be detoasted as needed. Default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;do_detoast&lt;/code&gt; &lt;/em&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 필요에 따라 제거되는 속성입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ce8f09a4ea0ee9a5326d6de1774ed409702a270" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;new_value&lt;/code&gt;&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, behaves identically to &lt;code&gt;jsonb_set&lt;/code&gt;. Otherwise behaves according to the value of &lt;em&gt;&lt;code&gt;null_value_treatment&lt;/code&gt;&lt;/em&gt; which must be one of &lt;code&gt;'raise_exception'&lt;/code&gt;, &lt;code&gt;'use_json_null'&lt;/code&gt;, &lt;code&gt;'delete_key'&lt;/code&gt;, or &lt;code&gt;'return_target'&lt;/code&gt;. The default is &lt;code&gt;'use_json_null'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt; &lt;code&gt;new_value&lt;/code&gt; &lt;/em&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; , 동일하게 작동 &lt;code&gt;jsonb_set&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;'raise_exception'&lt;/code&gt; , &lt;code&gt;'use_json_null'&lt;/code&gt; , &lt;code&gt;'delete_key'&lt;/code&gt; 또는 &lt;code&gt;'return_target'&lt;/code&gt; 중 하나 여야 하는 &lt;em&gt; &lt;code&gt;null_value_treatment&lt;/code&gt; &lt;/em&gt; 값에 따라 동작 합니다 . 기본값은 &lt;code&gt;'use_json_null'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9855c6593bb788e4a7fc1baab60a566fbf901f03" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; is false, then the resulting XML document looks like this:</source>
          <target state="translated">경우 &lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; 은&lt;/em&gt; 거짓,이 같은 결과 XML 문서 외모 :</target>
        </trans-unit>
        <trans-unit id="c50916d42c87228c370dd43c14046f7ce4402cc5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; is true, the result is an XML content fragment that looks like this:</source>
          <target state="translated">경우 &lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; 는&lt;/em&gt; 사실, 결과는 XML 콘텐츠 단편은 그 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="a00e85c8c38a440ad71ba2067ec654d399028aa3" translate="yes" xml:space="preserve">
          <source>If BC has been specified, negate the year and add one for internal storage. (There is no year zero in the Gregorian calendar, so numerically 1 BC becomes year zero.)</source>
          <target state="translated">BC가 지정된 경우 연도를 무효화하고 내부 저장 용으로 추가하십시오. 그레고리력에는 0 년이 없으므로 BC 1 년은 0 년이됩니다.</target>
        </trans-unit>
        <trans-unit id="2a6677efb7a76da9c59cedae433efda4935b91f1" translate="yes" xml:space="preserve">
          <source>If BC was not specified, and if the year field was two digits in length, then adjust the year to four digits. If the field is less than 70, then add 2000, otherwise add 1900.</source>
          <target state="translated">BC가 지정되지 않았고 연도 필드의 길이가 두 자리 인 경우 연도를 네 자리로 조정하십시오. 필드가 70보다 작 으면 2000을 추가하고, 그렇지 않으면 1900을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a9b50e5581cb9a085c462f20b706e74a8924f7f1" translate="yes" xml:space="preserve">
          <source>If CSV-format output is enabled in &lt;code&gt;log_destination&lt;/code&gt;, &lt;code&gt;.csv&lt;/code&gt; will be appended to the timestamped log file name to create the file name for CSV-format output. (If &lt;code&gt;log_filename&lt;/code&gt; ends in &lt;code&gt;.log&lt;/code&gt;, the suffix is replaced instead.)</source>
          <target state="translated">&lt;code&gt;log_destination&lt;/code&gt; 에서 CSV 형식 출력이 사용 가능한 경우 &lt;code&gt;.csv&lt;/code&gt; 가 시간 소인이 지정된 로그 파일 이름에 추가되어 CSV 형식 출력의 파일 이름을 작성합니다. ( &lt;code&gt;log_filename&lt;/code&gt; 이 &lt;code&gt;.log&lt;/code&gt; 로 끝나면 대신 접미사가 바뀝니다.)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
