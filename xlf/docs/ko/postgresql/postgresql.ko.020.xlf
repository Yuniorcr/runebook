<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="1434b66fc49d725085b1e8acde6ef195fe9268f9" translate="yes" xml:space="preserve">
          <source>System Administration: pg_is_in_recovery</source>
          <target state="translated">시스템 관리 : pg_is_in_recovery</target>
        </trans-unit>
        <trans-unit id="fda61a223f6f6494afb65bd652ae447ef7e8967c" translate="yes" xml:space="preserve">
          <source>System Administration: pg_is_wal_replay_paused</source>
          <target state="translated">시스템 관리 : pg_is_wal_replay_paused</target>
        </trans-unit>
        <trans-unit id="19f8fe870656d05706fc0706093b303ce1ac1fbb" translate="yes" xml:space="preserve">
          <source>System Administration: pg_last_wal_receive_lsn</source>
          <target state="translated">시스템 관리 : pg_last_wal_receive_lsn</target>
        </trans-unit>
        <trans-unit id="e322ff309458098b2fe147054e066142c1fb31b3" translate="yes" xml:space="preserve">
          <source>System Administration: pg_last_wal_replay_lsn</source>
          <target state="translated">시스템 관리 : pg_last_wal_replay_lsn</target>
        </trans-unit>
        <trans-unit id="22e72c878e8c3f728e8bbe8b693362570aba2d7d" translate="yes" xml:space="preserve">
          <source>System Administration: pg_last_xact_replay_timestamp</source>
          <target state="translated">시스템 관리 : pg_last_xact_replay_timestamp</target>
        </trans-unit>
        <trans-unit id="5139e34ff0dc0163f445bf85b75afafe837e63b5" translate="yes" xml:space="preserve">
          <source>System Administration: pg_logical_emit_message</source>
          <target state="translated">시스템 관리 : pg_logical_emit_message</target>
        </trans-unit>
        <trans-unit id="0bde83582bb2f425183beee7926f164e59ded8a9" translate="yes" xml:space="preserve">
          <source>System Administration: pg_logical_slot_get_binary_changes</source>
          <target state="translated">시스템 관리 : pg_logical_slot_get_binary_changes</target>
        </trans-unit>
        <trans-unit id="e0a2d9d5d4cbf89a0bb2d9af59b02cf097802e14" translate="yes" xml:space="preserve">
          <source>System Administration: pg_logical_slot_get_changes</source>
          <target state="translated">시스템 관리 : pg_logical_slot_get_changes</target>
        </trans-unit>
        <trans-unit id="a4eb91847aad575caf8eaf8e4f6d97c23fc49e4d" translate="yes" xml:space="preserve">
          <source>System Administration: pg_logical_slot_peek_binary_changes</source>
          <target state="translated">시스템 관리 : pg_logical_slot_peek_binary_changes</target>
        </trans-unit>
        <trans-unit id="f287e05f9303eb0346213e47883177f4cee0c8ed" translate="yes" xml:space="preserve">
          <source>System Administration: pg_logical_slot_peek_changes</source>
          <target state="translated">시스템 관리 : pg_logical_slot_peek_changes</target>
        </trans-unit>
        <trans-unit id="fdc6b843f2707e354cffaec09837d56e31944a79" translate="yes" xml:space="preserve">
          <source>System Administration: pg_ls_archive_statusdir</source>
          <target state="translated">시스템 관리 : pg_ls_archive_statusdir</target>
        </trans-unit>
        <trans-unit id="391ee7b334ce78a0f88d53d9b3a0a7990086d266" translate="yes" xml:space="preserve">
          <source>System Administration: pg_ls_dir</source>
          <target state="translated">시스템 관리 : pg_ls_dir</target>
        </trans-unit>
        <trans-unit id="2bc50f0aa2c7d478852bb7fc324ec2ceaa667800" translate="yes" xml:space="preserve">
          <source>System Administration: pg_ls_logdir</source>
          <target state="translated">시스템 관리 : pg_ls_logdir</target>
        </trans-unit>
        <trans-unit id="de8e677b38cc3d8e1f8b71ab798e4bfded04ebf9" translate="yes" xml:space="preserve">
          <source>System Administration: pg_ls_tmpdir</source>
          <target state="translated">시스템 관리 : pg_ls_tmpdir</target>
        </trans-unit>
        <trans-unit id="d0bef0c75ad04c65e676b9c0c3f152a4b003d023" translate="yes" xml:space="preserve">
          <source>System Administration: pg_ls_waldir</source>
          <target state="translated">시스템 관리 : pg_ls_waldir</target>
        </trans-unit>
        <trans-unit id="1fbae1ae0e526eef1eb6afd089c168caee386dc5" translate="yes" xml:space="preserve">
          <source>System Administration: pg_partition_ancestors</source>
          <target state="translated">시스템 관리 : pg_partition_ancestors</target>
        </trans-unit>
        <trans-unit id="bf6722bf0ad1a3eb39c0ba4287df0a8cab3c0b7b" translate="yes" xml:space="preserve">
          <source>System Administration: pg_partition_root</source>
          <target state="translated">시스템 관리 : pg_partition_root</target>
        </trans-unit>
        <trans-unit id="10cea4e6d4e7307fdf2a6d599294867574482127" translate="yes" xml:space="preserve">
          <source>System Administration: pg_partition_tree</source>
          <target state="translated">시스템 관리 : pg_partition_tree</target>
        </trans-unit>
        <trans-unit id="c5deefd066f88fc36f236d74cf8713ce6a69652f" translate="yes" xml:space="preserve">
          <source>System Administration: pg_promote</source>
          <target state="translated">시스템 관리 : pg_promote</target>
        </trans-unit>
        <trans-unit id="5d1c5a442a00b1209682cbf17e28a53ac9de3372" translate="yes" xml:space="preserve">
          <source>System Administration: pg_read_binary_file</source>
          <target state="translated">시스템 관리 : pg_read_binary_file</target>
        </trans-unit>
        <trans-unit id="788a94acf7063934db6918e4fecda165b0a405ef" translate="yes" xml:space="preserve">
          <source>System Administration: pg_read_file</source>
          <target state="translated">시스템 관리 : pg_read_file</target>
        </trans-unit>
        <trans-unit id="5fe07e851d2aa80380868917effeda72efee9139" translate="yes" xml:space="preserve">
          <source>System Administration: pg_relation_filenode</source>
          <target state="translated">시스템 관리 : pg_relation_filenode</target>
        </trans-unit>
        <trans-unit id="a2742ab117eb3fe2b3dabc1e5e54607c7427d8e1" translate="yes" xml:space="preserve">
          <source>System Administration: pg_relation_filepath</source>
          <target state="translated">시스템 관리 : pg_relation_filepath</target>
        </trans-unit>
        <trans-unit id="f85ffbc3af3828935d64682c632a5233a379b748" translate="yes" xml:space="preserve">
          <source>System Administration: pg_relation_size</source>
          <target state="translated">시스템 관리 : pg_relation_size</target>
        </trans-unit>
        <trans-unit id="2866d8b92abae22a9e5aa2c158406c518fd61172" translate="yes" xml:space="preserve">
          <source>System Administration: pg_reload_conf</source>
          <target state="translated">시스템 관리 : pg_reload_conf</target>
        </trans-unit>
        <trans-unit id="cf6ee733fdf66d2945f6237a753fd8bb671d4dbc" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_advance</source>
          <target state="translated">시스템 관리 : pg_replication_origin_advance</target>
        </trans-unit>
        <trans-unit id="b056cede26155b9eefef5d478983102d1b58dc0a" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_create</source>
          <target state="translated">시스템 관리 : pg_replication_origin_create</target>
        </trans-unit>
        <trans-unit id="bd74b91a9698ac5c836575ef6778e9849d485d26" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_drop</source>
          <target state="translated">시스템 관리 : pg_replication_origin_drop</target>
        </trans-unit>
        <trans-unit id="b592a2d6eb715190769f6c645403bed0e0906d70" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_oid</source>
          <target state="translated">시스템 관리 : pg_replication_origin_oid</target>
        </trans-unit>
        <trans-unit id="ce67bddc1c79790f7c7e3ea3e8dfe164e6f8ce5f" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_progress</source>
          <target state="translated">시스템 관리 : pg_replication_origin_progress</target>
        </trans-unit>
        <trans-unit id="657fc44f5701708e68c6f336bb2a1ae4544769e6" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_session_is_setup</source>
          <target state="translated">시스템 관리 : pg_replication_origin_session_is_setup</target>
        </trans-unit>
        <trans-unit id="c3b8bd3cfd052c2da8ebe767266843b270ca923f" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_session_progress</source>
          <target state="translated">시스템 관리 : pg_replication_origin_session_progress</target>
        </trans-unit>
        <trans-unit id="912328a9fba1f826639651be0fc1273c2f02f362" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_session_reset</source>
          <target state="translated">시스템 관리 : pg_replication_origin_session_reset</target>
        </trans-unit>
        <trans-unit id="82b5eb70d23dfc31a269e9ba33378678f0c4c1a3" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_session_setup</source>
          <target state="translated">시스템 관리 : pg_replication_origin_session_setup</target>
        </trans-unit>
        <trans-unit id="b1c6585c55025ccacd14538d8f5ad5bca8c72f61" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_xact_reset</source>
          <target state="translated">시스템 관리 : pg_replication_origin_xact_reset</target>
        </trans-unit>
        <trans-unit id="a0ffd53ad713ea0db7d4ce36f0304a9aba022e70" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_origin_xact_setup</source>
          <target state="translated">시스템 관리 : pg_replication_origin_xact_setup</target>
        </trans-unit>
        <trans-unit id="337e82045a1cbbde57a9f167b879e802f4d12439" translate="yes" xml:space="preserve">
          <source>System Administration: pg_replication_slot_advance</source>
          <target state="translated">시스템 관리 : pg_replication_slot_advance</target>
        </trans-unit>
        <trans-unit id="6b71b6d3ff864fd80fd3c8785ba1d7c0a96e2999" translate="yes" xml:space="preserve">
          <source>System Administration: pg_rotate_logfile</source>
          <target state="translated">시스템 관리 : pg_rotate_logfile</target>
        </trans-unit>
        <trans-unit id="aca32fdd9e7ca6111240d34ea01a49a8b130c6cc" translate="yes" xml:space="preserve">
          <source>System Administration: pg_size_bytes</source>
          <target state="translated">시스템 관리 : pg_size_bytes</target>
        </trans-unit>
        <trans-unit id="19170aeca34f7c8d43679e7a88ce912c055969f5" translate="yes" xml:space="preserve">
          <source>System Administration: pg_size_pretty</source>
          <target state="translated">시스템 관리 : pg_size_pretty</target>
        </trans-unit>
        <trans-unit id="0bf3d94c5147d8ee7961a08ff80ee25a6e90d47d" translate="yes" xml:space="preserve">
          <source>System Administration: pg_start_backup</source>
          <target state="translated">시스템 관리 : pg_start_backup</target>
        </trans-unit>
        <trans-unit id="3950f5fc0c8c83eed16726abbb98db6a45cf49d0" translate="yes" xml:space="preserve">
          <source>System Administration: pg_stat_file</source>
          <target state="translated">시스템 관리 : pg_stat_file</target>
        </trans-unit>
        <trans-unit id="a9ca6c957968a8bae960ef7b6a41e4d1a3ed7c11" translate="yes" xml:space="preserve">
          <source>System Administration: pg_stop_backup</source>
          <target state="translated">시스템 관리 : pg_stop_backup</target>
        </trans-unit>
        <trans-unit id="c74416829dd81cb198394c213f48e6beeabb4a04" translate="yes" xml:space="preserve">
          <source>System Administration: pg_switch_wal</source>
          <target state="translated">시스템 관리 : pg_switch_wal</target>
        </trans-unit>
        <trans-unit id="a05c80bb1ac482b09a06989e21f9651a6f7c741b" translate="yes" xml:space="preserve">
          <source>System Administration: pg_table_size</source>
          <target state="translated">시스템 관리 : pg_table_size</target>
        </trans-unit>
        <trans-unit id="ff1a5af6f71cf0eb6f615fa947ae6a1d64759db6" translate="yes" xml:space="preserve">
          <source>System Administration: pg_tablespace_size</source>
          <target state="translated">시스템 관리 : pg_tablespace_size</target>
        </trans-unit>
        <trans-unit id="33c25c6e57afb7ad5caa0be1975f0a12f8543b56" translate="yes" xml:space="preserve">
          <source>System Administration: pg_terminate_backend</source>
          <target state="translated">시스템 관리 : pg_terminate_backend</target>
        </trans-unit>
        <trans-unit id="e03ea0292a47d4573d13076241954530bc4fcdc9" translate="yes" xml:space="preserve">
          <source>System Administration: pg_total_relation_size</source>
          <target state="translated">시스템 관리 : pg_total_relation_size</target>
        </trans-unit>
        <trans-unit id="34fc1ae23f656dc3cb8e8ea83bc90ffc7af4dc77" translate="yes" xml:space="preserve">
          <source>System Administration: pg_try_advisory_lock</source>
          <target state="translated">시스템 관리 : pg_try_advisory_lock</target>
        </trans-unit>
        <trans-unit id="0984b2fa8f91b8630205f1848c34cb85b429b9c2" translate="yes" xml:space="preserve">
          <source>System Administration: pg_try_advisory_lock_shared</source>
          <target state="translated">시스템 관리 : pg_try_advisory_lock_shared</target>
        </trans-unit>
        <trans-unit id="d57ddae8d8993c231d5c4265bcf38201c6df4966" translate="yes" xml:space="preserve">
          <source>System Administration: pg_try_advisory_xact_lock</source>
          <target state="translated">시스템 관리 : pg_try_advisory_xact_lock</target>
        </trans-unit>
        <trans-unit id="32a4c7a557c2f639c4fd69740cf4d4e56cf1291a" translate="yes" xml:space="preserve">
          <source>System Administration: pg_try_advisory_xact_lock_shared</source>
          <target state="translated">시스템 관리 : pg_try_advisory_xact_lock_shared</target>
        </trans-unit>
        <trans-unit id="30f391eeadd0c0895122be3ea190ad77ab947eb9" translate="yes" xml:space="preserve">
          <source>System Administration: pg_wal_lsn_diff</source>
          <target state="translated">시스템 관리 : pg_wal_lsn_diff</target>
        </trans-unit>
        <trans-unit id="16f787f894b48eb30feb82f472a4d21822764c5e" translate="yes" xml:space="preserve">
          <source>System Administration: pg_wal_replay_pause</source>
          <target state="translated">시스템 관리 : pg_wal_replay_pause</target>
        </trans-unit>
        <trans-unit id="2f1cd61d9e0da8fcc5c19eb536ba58197f0dac02" translate="yes" xml:space="preserve">
          <source>System Administration: pg_wal_replay_resume</source>
          <target state="translated">시스템 관리 : pg_wal_replay_resume</target>
        </trans-unit>
        <trans-unit id="bb80613003057b3a40581f8383c953cde1d51337" translate="yes" xml:space="preserve">
          <source>System Administration: pg_walfile_name</source>
          <target state="translated">시스템 관리 : pg_walfile_name</target>
        </trans-unit>
        <trans-unit id="40d42c9e2fa6791eb10e2722bf48e963bdbdad88" translate="yes" xml:space="preserve">
          <source>System Administration: pg_walfile_name_offset</source>
          <target state="translated">시스템 관리 : pg_walfile_name_offset</target>
        </trans-unit>
        <trans-unit id="80dc35f2dfee33f3af473cb6af39d7a95d651db8" translate="yes" xml:space="preserve">
          <source>System Administration: set_config</source>
          <target state="translated">시스템 관리 : set_config</target>
        </trans-unit>
        <trans-unit id="70ba34565170f82597d954cfe9bcc62ba03f80ba" translate="yes" xml:space="preserve">
          <source>System Catalog Declaration Rules</source>
          <target state="translated">시스템 카탈로그 선언 규칙</target>
        </trans-unit>
        <trans-unit id="bfee83120320ade7931d656f98ea03070c34ba55" translate="yes" xml:space="preserve">
          <source>System Catalog Declarations and Initial Contents</source>
          <target state="translated">시스템 카탈로그 선언 및 초기 내용</target>
        </trans-unit>
        <trans-unit id="a204bb70a9fef2fc920172b6e25704450d55c326" translate="yes" xml:space="preserve">
          <source>System Catalog Initial Data</source>
          <target state="translated">시스템 카탈로그 초기 데이터</target>
        </trans-unit>
        <trans-unit id="05f78922a34c9754d103a3dca09362f10592d27e" translate="yes" xml:space="preserve">
          <source>System Catalog Initial Data: Automatic Creation of Array Types</source>
          <target state="translated">시스템 카탈로그 초기 데이터 : 어레이 유형 자동 생성</target>
        </trans-unit>
        <trans-unit id="15f70d08421239bfba5b5cd868859d3529385a69" translate="yes" xml:space="preserve">
          <source>System Catalog Initial Data: Data File Format</source>
          <target state="translated">시스템 카탈로그 초기 데이터 : 데이터 파일 형식</target>
        </trans-unit>
        <trans-unit id="89eb48da4b01f204cce068ed7a2c8356ed2ed117" translate="yes" xml:space="preserve">
          <source>System Catalog Initial Data: OID Assignment</source>
          <target state="translated">시스템 카탈로그 초기 데이터 : OID 할당</target>
        </trans-unit>
        <trans-unit id="6338504f603907929102648fe297dae03984035f" translate="yes" xml:space="preserve">
          <source>System Catalog Initial Data: OID Reference Lookup</source>
          <target state="translated">시스템 카탈로그 초기 데이터 : OID 참조 조회</target>
        </trans-unit>
        <trans-unit id="e207174928b93045c976bd0f003518aa1f3425a8" translate="yes" xml:space="preserve">
          <source>System Catalog Initial Data: Recipes for Editing Data Files</source>
          <target state="translated">시스템 카탈로그 초기 데이터 : 데이터 파일 편집을위한 레시피</target>
        </trans-unit>
        <trans-unit id="16ffb29fa7538dc5ef61aa7febfae29e9e03479f" translate="yes" xml:space="preserve">
          <source>System Catalogs</source>
          <target state="translated">시스템 카탈로그</target>
        </trans-unit>
        <trans-unit id="c0b5ce1840bdef19cc50b8a118e697841645b666" translate="yes" xml:space="preserve">
          <source>System Columns</source>
          <target state="translated">시스템 열</target>
        </trans-unit>
        <trans-unit id="e7ffcbda1ecb29cd28603d0658a751dd083e9f1f" translate="yes" xml:space="preserve">
          <source>System Information Functions and Operators</source>
          <target state="translated">시스템 정보 기능 및 연산자</target>
        </trans-unit>
        <trans-unit id="00d4ac825cf24eaf6f6abeccd0d6a2abfb0b5ef2" translate="yes" xml:space="preserve">
          <source>System Information: &amp;#x27;calvin=r*w/hobbes&amp;#x27;::aclitem = &amp;#x27;calvin=r*w*/hobbes&amp;#x27;::aclitem</source>
          <target state="translated">System Information: 'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</target>
        </trans-unit>
        <trans-unit id="e7111d7c5d5e897aa1a06a2c2b9f7ef73ec21cad" translate="yes" xml:space="preserve">
          <source>System Information: &amp;#x27;{calvin=r*w/hobbes,hobbes=r*w*/postgres}&amp;#x27;::aclitem @&amp;gt; &amp;#x27;calvin=r*/hobbes&amp;#x27;::aclitem</source>
          <target state="translated">System Information: '{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem @&amp;gt; 'calvin=r*/hobbes'::aclitem</target>
        </trans-unit>
        <trans-unit id="f060fd997110a3adac2d64e864c98f9b738611bf" translate="yes" xml:space="preserve">
          <source>System Information: &amp;#x27;{calvin=r*w/hobbes,hobbes=r*w*/postgres}&amp;#x27;::aclitem ~ &amp;#x27;calvin=r*/hobbes&amp;#x27;::aclitem</source>
          <target state="translated">System Information: '{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem ~ 'calvin=r*/hobbes'::aclitem</target>
        </trans-unit>
        <trans-unit id="969c28c2ba2f17e89e3d1bc0b1ad9a0cec0a4aaa" translate="yes" xml:space="preserve">
          <source>System Information: =</source>
          <target state="translated">시스템 정보 : =</target>
        </trans-unit>
        <trans-unit id="aabf5a989509317fff3f0aff57af38e2880a75fe" translate="yes" xml:space="preserve">
          <source>System Information: @&amp;gt;</source>
          <target state="translated">시스템 정보 : @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f821bef27883bdbdaed016ef8e17c2587f84ad9" translate="yes" xml:space="preserve">
          <source>System Information: COLLATION FOR</source>
          <target state="translated">System Information: COLLATION FOR</target>
        </trans-unit>
        <trans-unit id="36f4dde6f48ab1620daf25c83f9c4325de35c023" translate="yes" xml:space="preserve">
          <source>System Information: CREATE</source>
          <target state="translated">System Information: CREATE</target>
        </trans-unit>
        <trans-unit id="aedb77efc35994e3e2d69577d457d867f4e4674e" translate="yes" xml:space="preserve">
          <source>System Information: EXECUTE</source>
          <target state="translated">System Information: EXECUTE</target>
        </trans-unit>
        <trans-unit id="876740f3ae2a1bea809ff9e30bfc17cb3b8e8354" translate="yes" xml:space="preserve">
          <source>System Information: MEMBER</source>
          <target state="translated">System Information: MEMBER</target>
        </trans-unit>
        <trans-unit id="78cdaf7accf0ebe38b9dfbf0539da289f81b049f" translate="yes" xml:space="preserve">
          <source>System Information: NULL</source>
          <target state="translated">System Information: NULL</target>
        </trans-unit>
        <trans-unit id="8d8211b4dd6a4d45974a78cbbb92ce2774d8dfe1" translate="yes" xml:space="preserve">
          <source>System Information: RETURNS</source>
          <target state="translated">System Information: RETURNS</target>
        </trans-unit>
        <trans-unit id="7738c96a2e05bddb6b9444d1dbc04fdbf2204292" translate="yes" xml:space="preserve">
          <source>System Information: SELECT</source>
          <target state="translated">System Information: SELECT</target>
        </trans-unit>
        <trans-unit id="63e02256430793edd3d7258a6e742ef8d431b5b3" translate="yes" xml:space="preserve">
          <source>System Information: SERIALIZABLE</source>
          <target state="translated">System Information: SERIALIZABLE</target>
        </trans-unit>
        <trans-unit id="4167f7219ad4783a4ce223b4a392c174edc839b4" translate="yes" xml:space="preserve">
          <source>System Information: USAGE</source>
          <target state="translated">System Information: USAGE</target>
        </trans-unit>
        <trans-unit id="65bbb638fc57b0525f565b541cc329bf4fe02a21" translate="yes" xml:space="preserve">
          <source>System Information: acldefault</source>
          <target state="translated">시스템 정보 : acldefault</target>
        </trans-unit>
        <trans-unit id="b970da4aa8d2bd82508a362fe29a2a04bba9470e" translate="yes" xml:space="preserve">
          <source>System Information: aclexplode</source>
          <target state="translated">시스템 정보 : aclexplode</target>
        </trans-unit>
        <trans-unit id="bcabfa8f7d62c253be2f1154e0e9ba6eced044b2" translate="yes" xml:space="preserve">
          <source>System Information: asc</source>
          <target state="translated">시스템 정보 : asc</target>
        </trans-unit>
        <trans-unit id="85d02e715300a12b88a2f31690c0e9b9b3d6b44e" translate="yes" xml:space="preserve">
          <source>System Information: backup_end_lsn</source>
          <target state="translated">시스템 정보 : backup_end_lsn</target>
        </trans-unit>
        <trans-unit id="23d64255e4590b2f12a19dd20b14e27745dfab5a" translate="yes" xml:space="preserve">
          <source>System Information: backup_start_lsn</source>
          <target state="translated">시스템 정보 : backup_start_lsn</target>
        </trans-unit>
        <trans-unit id="4c087b22f931b092479fb6e18ace693f93af0fe7" translate="yes" xml:space="preserve">
          <source>System Information: backward_scan</source>
          <target state="translated">시스템 정보 : backward_scan</target>
        </trans-unit>
        <trans-unit id="93b773e22a38507eeb86078b0e11d2d0061afbab" translate="yes" xml:space="preserve">
          <source>System Information: bitmap_scan</source>
          <target state="translated">시스템 정보 : bitmap_scan</target>
        </trans-unit>
        <trans-unit id="32e264ce46877f132ffa68ce6caebe06013a7b8b" translate="yes" xml:space="preserve">
          <source>System Information: blocks_per_segment</source>
          <target state="translated">시스템 정보 : blocks_per_segment</target>
        </trans-unit>
        <trans-unit id="ad58f9e1040ca4ad8768e972dd47370f9e593ead" translate="yes" xml:space="preserve">
          <source>System Information: bytes_per_wal_segment</source>
          <target state="translated">시스템 정보 : bytes_per_wal_segment</target>
        </trans-unit>
        <trans-unit id="056066ed28ad08fe7e3e1c5049b1ca5af5b75181" translate="yes" xml:space="preserve">
          <source>System Information: can_exclude</source>
          <target state="translated">시스템 정보 : can_exclude</target>
        </trans-unit>
        <trans-unit id="8605ee4e5d9c119704826b7eecc9d0ed2cb0d85d" translate="yes" xml:space="preserve">
          <source>System Information: can_include</source>
          <target state="translated">시스템 정보 : can_include</target>
        </trans-unit>
        <trans-unit id="9298b39d532ec09a50aa73cfbe2be5b83f881728" translate="yes" xml:space="preserve">
          <source>System Information: can_multi_col</source>
          <target state="translated">시스템 정보 : can_multi_col</target>
        </trans-unit>
        <trans-unit id="8f0a62c1c12dd43399bdaf6d9df6ecb2dd518820" translate="yes" xml:space="preserve">
          <source>System Information: can_order</source>
          <target state="translated">시스템 정보 : can_order</target>
        </trans-unit>
        <trans-unit id="400e8a1c70b38db9004cbad160fa918f2f7e1ad9" translate="yes" xml:space="preserve">
          <source>System Information: can_unique</source>
          <target state="translated">시스템 정보 : can_unique</target>
        </trans-unit>
        <trans-unit id="e736336b9a8dec95b281ca1b4ad1f2b199301495" translate="yes" xml:space="preserve">
          <source>System Information: catalog_version_no</source>
          <target state="translated">시스템 정보 : catalog_version_no</target>
        </trans-unit>
        <trans-unit id="0534c39a1aeff460a61921ecc6f0f5968fbe832b" translate="yes" xml:space="preserve">
          <source>System Information: checkpoint_lsn</source>
          <target state="translated">시스템 정보 : checkpoint_lsn</target>
        </trans-unit>
        <trans-unit id="b2d831683977b56d054837365e7c4c6137cb346c" translate="yes" xml:space="preserve">
          <source>System Information: checkpoint_time</source>
          <target state="translated">시스템 정보 : checkpoint_time</target>
        </trans-unit>
        <trans-unit id="fd56b6b0ed17f437c7d382a5a62228fac52ddd99" translate="yes" xml:space="preserve">
          <source>System Information: clusterable</source>
          <target state="translated">시스템 정보 : 클러스터 가능</target>
        </trans-unit>
        <trans-unit id="faf9ba71d05f457d5cf2b0c161cc9b85190087c6" translate="yes" xml:space="preserve">
          <source>System Information: col_description</source>
          <target state="translated">시스템 정보 : col_description</target>
        </trans-unit>
        <trans-unit id="b693016a622c072330d1a225e2610122c5a4ecaa" translate="yes" xml:space="preserve">
          <source>System Information: collation for</source>
          <target state="translated">시스템 정보 : 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="d3ef077e2e9ab0b07261c0b55c324487788c2d2c" translate="yes" xml:space="preserve">
          <source>System Information: current_catalog</source>
          <target state="translated">시스템 정보 : current_catalog</target>
        </trans-unit>
        <trans-unit id="e65f70102c41825e3755ee9ac41a66b9b5ef4b7c" translate="yes" xml:space="preserve">
          <source>System Information: current_database</source>
          <target state="translated">시스템 정보 : current_database</target>
        </trans-unit>
        <trans-unit id="48addaa15e2f44012dc51b7c415dd7060b873bd3" translate="yes" xml:space="preserve">
          <source>System Information: current_query</source>
          <target state="translated">시스템 정보 : current_query</target>
        </trans-unit>
        <trans-unit id="d297b1b694ee69904878d788686adbc9883731c9" translate="yes" xml:space="preserve">
          <source>System Information: current_role</source>
          <target state="translated">시스템 정보 : current_role</target>
        </trans-unit>
        <trans-unit id="95ca22d6c143d6bc6fb08ffa82c72ca0d6a15c43" translate="yes" xml:space="preserve">
          <source>System Information: current_schema</source>
          <target state="translated">시스템 정보 : current_schema</target>
        </trans-unit>
        <trans-unit id="38359341d8d5c0a469f02aba7aa41b082b80a8ff" translate="yes" xml:space="preserve">
          <source>System Information: current_schemas</source>
          <target state="translated">시스템 정보 : current_schemas</target>
        </trans-unit>
        <trans-unit id="8eafe901179ff31ce8412f036521d1a8c4be6883" translate="yes" xml:space="preserve">
          <source>System Information: current_user</source>
          <target state="translated">시스템 정보 : current_user</target>
        </trans-unit>
        <trans-unit id="f7ed096f39bd6234f75ee796841db87b4a3558b0" translate="yes" xml:space="preserve">
          <source>System Information: data_page_checksum_version</source>
          <target state="translated">시스템 정보 : data_page_checksum_version</target>
        </trans-unit>
        <trans-unit id="362fc2829def348fdaa4a0bad46f11ff5d57de34" translate="yes" xml:space="preserve">
          <source>System Information: database_block_size</source>
          <target state="translated">시스템 정보 : database_block_size</target>
        </trans-unit>
        <trans-unit id="529e345af76369ac56523b48409b37bded3d0fdc" translate="yes" xml:space="preserve">
          <source>System Information: desc</source>
          <target state="translated">시스템 정보 : desc</target>
        </trans-unit>
        <trans-unit id="c520b41e3b847c56c06099be51968a2876bde9b8" translate="yes" xml:space="preserve">
          <source>System Information: distance_orderable</source>
          <target state="translated">시스템 정보 : distance_orderable</target>
        </trans-unit>
        <trans-unit id="a117cfbc5c21995ff5a0321c16c1d526f371bd24" translate="yes" xml:space="preserve">
          <source>System Information: end_of_backup_record_required</source>
          <target state="translated">시스템 정보 : end_of_backup_record_required</target>
        </trans-unit>
        <trans-unit id="83abcbed3ed0e1c125019c2cfd29f868037ee49d" translate="yes" xml:space="preserve">
          <source>System Information: float4_pass_by_value</source>
          <target state="translated">시스템 정보 : float4_pass_by_value</target>
        </trans-unit>
        <trans-unit id="b483a1922d633831e4526a076b3ef71861c9853a" translate="yes" xml:space="preserve">
          <source>System Information: float8_pass_by_value</source>
          <target state="translated">시스템 정보 : float8_pass_by_value</target>
        </trans-unit>
        <trans-unit id="a545ca2698f5df95e1772f977810fbc82f5cf785" translate="yes" xml:space="preserve">
          <source>System Information: format_type</source>
          <target state="translated">시스템 정보 : format_type</target>
        </trans-unit>
        <trans-unit id="f9a5514eef728a10d76799e277865b6fb0e4eeeb" translate="yes" xml:space="preserve">
          <source>System Information: full_page_writes</source>
          <target state="translated">시스템 정보 : full_page_writes</target>
        </trans-unit>
        <trans-unit id="1870631cdd21d3a46a1e3d6b190dd75b3dd221b7" translate="yes" xml:space="preserve">
          <source>System Information: has_any_column_privilege</source>
          <target state="translated">시스템 정보 : has_any_column_privilege</target>
        </trans-unit>
        <trans-unit id="7e4f17ffc117832d1e53312538ad9dbcc235b70a" translate="yes" xml:space="preserve">
          <source>System Information: has_column_privilege</source>
          <target state="translated">시스템 정보 : has_column_privilege</target>
        </trans-unit>
        <trans-unit id="52293d9b02048ca39038a62eb928f38bae1ff63b" translate="yes" xml:space="preserve">
          <source>System Information: has_database_privilege</source>
          <target state="translated">시스템 정보 : has_database_privilege</target>
        </trans-unit>
        <trans-unit id="17bc4056779374df65cf5701ce849c9829a8df1f" translate="yes" xml:space="preserve">
          <source>System Information: has_foreign_data_wrapper_privilege</source>
          <target state="translated">시스템 정보 : has_foreign_data_wrapper_privilege</target>
        </trans-unit>
        <trans-unit id="12cfe7e267d8863147010dbc6452e56d4eb9508d" translate="yes" xml:space="preserve">
          <source>System Information: has_function_privilege</source>
          <target state="translated">시스템 정보 : has_function_privilege</target>
        </trans-unit>
        <trans-unit id="58fa2013ba968439a596c956ff116c15cd49c0df" translate="yes" xml:space="preserve">
          <source>System Information: has_language_privilege</source>
          <target state="translated">시스템 정보 : has_language_privilege</target>
        </trans-unit>
        <trans-unit id="a8fef580f2de2f243f56a7451e3ffb78d7a79c77" translate="yes" xml:space="preserve">
          <source>System Information: has_schema_privilege</source>
          <target state="translated">시스템 정보 : has_schema_privilege</target>
        </trans-unit>
        <trans-unit id="134dcc670272d75f7520f0c146ad83faa2406648" translate="yes" xml:space="preserve">
          <source>System Information: has_sequence_privilege</source>
          <target state="translated">시스템 정보 : has_sequence_privilege</target>
        </trans-unit>
        <trans-unit id="7e81340d1ff9ccd37f9a1ddfa5ad0c0a40a8c569" translate="yes" xml:space="preserve">
          <source>System Information: has_server_privilege</source>
          <target state="translated">시스템 정보 : has_server_privilege</target>
        </trans-unit>
        <trans-unit id="ddaadcb30719df032789c2893504594b14a6de1c" translate="yes" xml:space="preserve">
          <source>System Information: has_table_privilege</source>
          <target state="translated">시스템 정보 : has_table_privilege</target>
        </trans-unit>
        <trans-unit id="96a25b4fe115031c645b703f883999fbaadc9427" translate="yes" xml:space="preserve">
          <source>System Information: has_tablespace_privilege</source>
          <target state="translated">시스템 정보 : has_tablespace_privilege</target>
        </trans-unit>
        <trans-unit id="36e99f12ce09178e2e4dfcff3bd547cff1287c94" translate="yes" xml:space="preserve">
          <source>System Information: has_type_privilege</source>
          <target state="translated">시스템 정보 : has_type_privilege</target>
        </trans-unit>
        <trans-unit id="ec43c95e17eac35fb79a33a2ea200a6e5944899b" translate="yes" xml:space="preserve">
          <source>System Information: in progress</source>
          <target state="translated">System Information: in progress</target>
        </trans-unit>
        <trans-unit id="e9e3d5e816290ca4eff8975d1672161ad95c770f" translate="yes" xml:space="preserve">
          <source>System Information: index_scan</source>
          <target state="translated">시스템 정보 : index_scan</target>
        </trans-unit>
        <trans-unit id="db5a5ca0d07e0fefd3eb88779119deb32e1f7cec" translate="yes" xml:space="preserve">
          <source>System Information: inet_client_addr</source>
          <target state="translated">시스템 정보 : inet_client_addr</target>
        </trans-unit>
        <trans-unit id="369812fa61fc7766c69d9150054258e862258bb6" translate="yes" xml:space="preserve">
          <source>System Information: inet_client_port</source>
          <target state="translated">시스템 정보 : inet_client_port</target>
        </trans-unit>
        <trans-unit id="cb46d1e305043a2a119d18a9c24fb93fc9f668d5" translate="yes" xml:space="preserve">
          <source>System Information: inet_server_addr</source>
          <target state="translated">시스템 정보 : inet_server_addr</target>
        </trans-unit>
        <trans-unit id="07041de3bc2c7888acf3c35744df57c94090578e" translate="yes" xml:space="preserve">
          <source>System Information: inet_server_port</source>
          <target state="translated">시스템 정보 : inet_server_port</target>
        </trans-unit>
        <trans-unit id="e02d0041f62f36ed0d93def3e3e4f01af530c2ff" translate="yes" xml:space="preserve">
          <source>System Information: large_object_chunk_size</source>
          <target state="translated">시스템 정보 : large_object_chunk_size</target>
        </trans-unit>
        <trans-unit id="ace351c71b5f31928289b9451ce634c14820635a" translate="yes" xml:space="preserve">
          <source>System Information: makeaclitem</source>
          <target state="translated">시스템 정보 : makeaclitem</target>
        </trans-unit>
        <trans-unit id="314ff5f4b8637153469c06c1f9ff6d342013c46f" translate="yes" xml:space="preserve">
          <source>System Information: max_data_alignment</source>
          <target state="translated">시스템 정보 : max_data_alignment</target>
        </trans-unit>
        <trans-unit id="57386d27691249b5d2a129dd5167bb0a6e9c81e3" translate="yes" xml:space="preserve">
          <source>System Information: max_identifier_length</source>
          <target state="translated">시스템 정보 : max_identifier_length</target>
        </trans-unit>
        <trans-unit id="277ec87cf2af8beff7063bd15ed8b1b8e5159087" translate="yes" xml:space="preserve">
          <source>System Information: max_index_columns</source>
          <target state="translated">시스템 정보 : max_index_columns</target>
        </trans-unit>
        <trans-unit id="748d418ad2c137c48e968e43cd1ed3af2e3598fe" translate="yes" xml:space="preserve">
          <source>System Information: max_toast_chunk_size</source>
          <target state="translated">시스템 정보 : max_toast_chunk_size</target>
        </trans-unit>
        <trans-unit id="dc67814988e03f4488c4d2f12d57462e96e17edb" translate="yes" xml:space="preserve">
          <source>System Information: min_recovery_end_lsn</source>
          <target state="translated">시스템 정보 : min_recovery_end_lsn</target>
        </trans-unit>
        <trans-unit id="ce2f67cecfb5cac7d76e5d7f544a1f26ef3f4fb1" translate="yes" xml:space="preserve">
          <source>System Information: min_recovery_end_timeline</source>
          <target state="translated">시스템 정보 : min_recovery_end_timeline</target>
        </trans-unit>
        <trans-unit id="73cb6153c9f5d12c9b3f12954d391b2f1318dd43" translate="yes" xml:space="preserve">
          <source>System Information: newest_commit_ts_xid</source>
          <target state="translated">시스템 정보 : newest_commit_ts_xid</target>
        </trans-unit>
        <trans-unit id="830baeb3dbcd4f5641b85bde72f71aa00b5baa55" translate="yes" xml:space="preserve">
          <source>System Information: next_multi_offset</source>
          <target state="translated">시스템 정보 : next_multi_offset</target>
        </trans-unit>
        <trans-unit id="bcd8a2a1be3a17b0ff51af32866dfc54479edb86" translate="yes" xml:space="preserve">
          <source>System Information: next_multixact_id</source>
          <target state="translated">시스템 정보 : next_multixact_id</target>
        </trans-unit>
        <trans-unit id="68f92e8158046c5a06a1dcc34f392bca06a9be31" translate="yes" xml:space="preserve">
          <source>System Information: next_oid</source>
          <target state="translated">시스템 정보 : next_oid</target>
        </trans-unit>
        <trans-unit id="630c04efdb47bc8c38be976cb691e7960687b35d" translate="yes" xml:space="preserve">
          <source>System Information: next_xid</source>
          <target state="translated">시스템 정보 : next_xid</target>
        </trans-unit>
        <trans-unit id="2ea887205b5414fc2f5bdfedfc80cccabd23cca9" translate="yes" xml:space="preserve">
          <source>System Information: nulls_first</source>
          <target state="translated">시스템 정보 : nulls_first</target>
        </trans-unit>
        <trans-unit id="dada2f6e605b53e86f6fa1413aadc8747cb9b858" translate="yes" xml:space="preserve">
          <source>System Information: nulls_last</source>
          <target state="translated">시스템 정보 : nulls_last</target>
        </trans-unit>
        <trans-unit id="cda0b304f47c0c92b9fb94787e4ad8fa06111357" translate="yes" xml:space="preserve">
          <source>System Information: obj_description</source>
          <target state="translated">시스템 정보 : obj_description</target>
        </trans-unit>
        <trans-unit id="661053717c21be873a00ccbbd2e36929d6941175" translate="yes" xml:space="preserve">
          <source>System Information: oldest_active_xid</source>
          <target state="translated">시스템 정보 : oldest_active_xid</target>
        </trans-unit>
        <trans-unit id="4e3f29d14f3732c1831a06c73021c997a267f502" translate="yes" xml:space="preserve">
          <source>System Information: oldest_commit_ts_xid</source>
          <target state="translated">시스템 정보 : oldest_commit_ts_xid</target>
        </trans-unit>
        <trans-unit id="3fe59d6562107bf463f48b193bca54173857972b" translate="yes" xml:space="preserve">
          <source>System Information: oldest_multi_dbid</source>
          <target state="translated">시스템 정보 : oldest_multi_dbid</target>
        </trans-unit>
        <trans-unit id="61b1e7e04c812baf7182cacc2b4a38ce545896cd" translate="yes" xml:space="preserve">
          <source>System Information: oldest_multi_xid</source>
          <target state="translated">시스템 정보 : oldest_multi_xid</target>
        </trans-unit>
        <trans-unit id="70ce184e08a42f5c1ac6d7986a0d07970a7facae" translate="yes" xml:space="preserve">
          <source>System Information: oldest_xid</source>
          <target state="translated">시스템 정보 : oldest_xid</target>
        </trans-unit>
        <trans-unit id="7dd414bae4e20c3571f1ece294289c524ced4c9b" translate="yes" xml:space="preserve">
          <source>System Information: oldest_xid_dbid</source>
          <target state="translated">시스템 정보 : oldest_xid_dbid</target>
        </trans-unit>
        <trans-unit id="96ab43b964a2e2ec92f68c73c78bfa4c3c232b46" translate="yes" xml:space="preserve">
          <source>System Information: orderable</source>
          <target state="translated">시스템 정보 : 주문 가능</target>
        </trans-unit>
        <trans-unit id="0a36d5cc024380697c8541df8c45a7d63fa707df" translate="yes" xml:space="preserve">
          <source>System Information: pg_backend_pid</source>
          <target state="translated">시스템 정보 : pg_backend_pid</target>
        </trans-unit>
        <trans-unit id="48fd8eeb5494ff50b63b1751a8fea983bddead51" translate="yes" xml:space="preserve">
          <source>System Information: pg_blocking_pids</source>
          <target state="translated">시스템 정보 : pg_blocking_pids</target>
        </trans-unit>
        <trans-unit id="ac470f51b6353d19664666fdd80c0727777097db" translate="yes" xml:space="preserve">
          <source>System Information: pg_collation_is_visible</source>
          <target state="translated">시스템 정보 : pg_collation_is_visible</target>
        </trans-unit>
        <trans-unit id="4ecc4ae02edb30ba407a957fb98e90ccbff9b0ed" translate="yes" xml:space="preserve">
          <source>System Information: pg_conf_load_time</source>
          <target state="translated">시스템 정보 : pg_conf_load_time</target>
        </trans-unit>
        <trans-unit id="999c1cc5d418485080df0cc5523296901246bde5" translate="yes" xml:space="preserve">
          <source>System Information: pg_control_checkpoint</source>
          <target state="translated">시스템 정보 : pg_control_checkpoint</target>
        </trans-unit>
        <trans-unit id="87482fb783cdbe3f3998180fce939abc436baa15" translate="yes" xml:space="preserve">
          <source>System Information: pg_control_init</source>
          <target state="translated">시스템 정보 : pg_control_init</target>
        </trans-unit>
        <trans-unit id="68591babe844bc9d163934d437d5548f478a52c6" translate="yes" xml:space="preserve">
          <source>System Information: pg_control_last_modified</source>
          <target state="translated">시스템 정보 : pg_control_last_modified</target>
        </trans-unit>
        <trans-unit id="2eb0b9e3f623be09f8c8042c7eb2c3e9594d2245" translate="yes" xml:space="preserve">
          <source>System Information: pg_control_recovery</source>
          <target state="translated">시스템 정보 : pg_control_recovery</target>
        </trans-unit>
        <trans-unit id="64cf1ed53720f00e86a91a6567457fa57ae74978" translate="yes" xml:space="preserve">
          <source>System Information: pg_control_system</source>
          <target state="translated">시스템 정보 : pg_control_system</target>
        </trans-unit>
        <trans-unit id="5178b69884dbbbbd3ba612d92706854cd973c1c4" translate="yes" xml:space="preserve">
          <source>System Information: pg_control_version</source>
          <target state="translated">시스템 정보 : pg_control_version</target>
        </trans-unit>
        <trans-unit id="904d294ad8e14dfc21785e9e21fec9b3d95ff5f8" translate="yes" xml:space="preserve">
          <source>System Information: pg_conversion_is_visible</source>
          <target state="translated">시스템 정보 : pg_conversion_is_visible</target>
        </trans-unit>
        <trans-unit id="b52887972b13a234984a6e5213f2493ad6b657d1" translate="yes" xml:space="preserve">
          <source>System Information: pg_current_logfile</source>
          <target state="translated">시스템 정보 : pg_current_logfile</target>
        </trans-unit>
        <trans-unit id="0c24d902953c1bb898134aa0598cd3c048a0b33e" translate="yes" xml:space="preserve">
          <source>System Information: pg_current_snapshot</source>
          <target state="translated">System Information: pg_current_snapshot</target>
        </trans-unit>
        <trans-unit id="5c79bb5236b9bcc3777faec6aada2f824bb9cccc" translate="yes" xml:space="preserve">
          <source>System Information: pg_current_xact_id</source>
          <target state="translated">System Information: pg_current_xact_id</target>
        </trans-unit>
        <trans-unit id="a54114af825b6d92d3badd72492672274c19f7f5" translate="yes" xml:space="preserve">
          <source>System Information: pg_current_xact_id_if_assigned</source>
          <target state="translated">System Information: pg_current_xact_id_if_assigned</target>
        </trans-unit>
        <trans-unit id="9c717e57df2c1069bf2d508766c5f2c9b667872a" translate="yes" xml:space="preserve">
          <source>System Information: pg_describe_object</source>
          <target state="translated">시스템 정보 : pg_describe_object</target>
        </trans-unit>
        <trans-unit id="2539df32742404e32b149682ace157bfa043bff1" translate="yes" xml:space="preserve">
          <source>System Information: pg_function_is_visible</source>
          <target state="translated">시스템 정보 : pg_function_is_visible</target>
        </trans-unit>
        <trans-unit id="0185b8bdf16ca87ec8e37d2d20bf48e6023b77a7" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_constraintdef</source>
          <target state="translated">시스템 정보 : pg_get_constraintdef</target>
        </trans-unit>
        <trans-unit id="ca41f9f0efb929913b9bcadfa128fa40d11e7da7" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_expr</source>
          <target state="translated">시스템 정보 : pg_get_expr</target>
        </trans-unit>
        <trans-unit id="6babbb55be15be07e83dc1fd80d816bcb4cc470b" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_function_arguments</source>
          <target state="translated">시스템 정보 : pg_get_function_arguments</target>
        </trans-unit>
        <trans-unit id="59a6bc3e85e9bd79e305dae71915cd253a60a7b3" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_function_identity_arguments</source>
          <target state="translated">시스템 정보 : pg_get_function_identity_arguments</target>
        </trans-unit>
        <trans-unit id="a3392e179f2a47b74b0d24e9e4275f913bded668" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_function_result</source>
          <target state="translated">시스템 정보 : pg_get_function_result</target>
        </trans-unit>
        <trans-unit id="85e9bd00750b99f525aac1f170718528b46461e4" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_functiondef</source>
          <target state="translated">시스템 정보 : pg_get_functiondef</target>
        </trans-unit>
        <trans-unit id="08a9d8cc237401fa897f7e7c1c838b23c50e55f6" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_indexdef</source>
          <target state="translated">시스템 정보 : pg_get_indexdef</target>
        </trans-unit>
        <trans-unit id="30bef9f9c1f3af2f4d914426592abf7fb9ba8b6a" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_keywords</source>
          <target state="translated">시스템 정보 : pg_get_keywords</target>
        </trans-unit>
        <trans-unit id="80e72cc6ad3579fa030c583ecb42aac06335c685" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_object_address</source>
          <target state="translated">시스템 정보 : pg_get_object_address</target>
        </trans-unit>
        <trans-unit id="1be1f28d93fedacad99c97baa8b1d17a1bd89a36" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_ruledef</source>
          <target state="translated">시스템 정보 : pg_get_ruledef</target>
        </trans-unit>
        <trans-unit id="12b9809239ad621c9c02735658c5c4107598daee" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_serial_sequence</source>
          <target state="translated">시스템 정보 : pg_get_serial_sequence</target>
        </trans-unit>
        <trans-unit id="dec5082d371a73dcbf8b152bae524dd2b22178a4" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_statisticsobjdef</source>
          <target state="translated">시스템 정보 : pg_get_statisticsobjdef</target>
        </trans-unit>
        <trans-unit id="81a2efb672934a5fee2ff2102f87900034fe8383" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_triggerdef</source>
          <target state="translated">시스템 정보 : pg_get_triggerdef</target>
        </trans-unit>
        <trans-unit id="818567c27d62da4fabf2431e92a6647b61a9ffff" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_userbyid</source>
          <target state="translated">시스템 정보 : pg_get_userbyid</target>
        </trans-unit>
        <trans-unit id="11710a4e12cd2ff7770b8c8da4f39fbd9cdaa48e" translate="yes" xml:space="preserve">
          <source>System Information: pg_get_viewdef</source>
          <target state="translated">시스템 정보 : pg_get_viewdef</target>
        </trans-unit>
        <trans-unit id="b88a178cbbce5641f7b737d6e28d094527ca4306" translate="yes" xml:space="preserve">
          <source>System Information: pg_has_role</source>
          <target state="translated">시스템 정보 : pg_has_role</target>
        </trans-unit>
        <trans-unit id="193b7931779ed0a2cc3a3c4a8dc895fa27f23dcf" translate="yes" xml:space="preserve">
          <source>System Information: pg_identify_object</source>
          <target state="translated">시스템 정보 : pg_identify_object</target>
        </trans-unit>
        <trans-unit id="bd99cad037d2ecf26ef0af20114c79f82b0bff5c" translate="yes" xml:space="preserve">
          <source>System Information: pg_identify_object_as_address</source>
          <target state="translated">시스템 정보 : pg_identify_object_as_address</target>
        </trans-unit>
        <trans-unit id="a547c7b5c453b1ca4dfee8cfe2be371fb12408b8" translate="yes" xml:space="preserve">
          <source>System Information: pg_index_column_has_property</source>
          <target state="translated">시스템 정보 : pg_index_column_has_property</target>
        </trans-unit>
        <trans-unit id="1273e16018265a62f9d27696838ce89e773ee2da" translate="yes" xml:space="preserve">
          <source>System Information: pg_index_has_property</source>
          <target state="translated">시스템 정보 : pg_index_has_property</target>
        </trans-unit>
        <trans-unit id="75cb59284fc87481e4d02e5fea7d37dda69a0062" translate="yes" xml:space="preserve">
          <source>System Information: pg_indexam_has_property</source>
          <target state="translated">시스템 정보 : pg_indexam_has_property</target>
        </trans-unit>
        <trans-unit id="2ee5a61ea81eec477f7a940eaba2bce4cdf2fe37" translate="yes" xml:space="preserve">
          <source>System Information: pg_is_other_temp_schema</source>
          <target state="translated">시스템 정보 : pg_is_other_temp_schema</target>
        </trans-unit>
        <trans-unit id="724a0ca68cba874536836091c15be37e2aa4c94e" translate="yes" xml:space="preserve">
          <source>System Information: pg_jit_available</source>
          <target state="translated">시스템 정보 : pg_jit_available</target>
        </trans-unit>
        <trans-unit id="341a310d0a82f16dbaee7f618163e969e66c252a" translate="yes" xml:space="preserve">
          <source>System Information: pg_last_committed_xact</source>
          <target state="translated">시스템 정보 : pg_last_committed_xact</target>
        </trans-unit>
        <trans-unit id="ffd0a25980817ab382e05ee2971d0b20607e5316" translate="yes" xml:space="preserve">
          <source>System Information: pg_listening_channels</source>
          <target state="translated">시스템 정보 : pg_listening_channels</target>
        </trans-unit>
        <trans-unit id="d0370d9243017dd2bc64ea0e6a19b2e3108bed29" translate="yes" xml:space="preserve">
          <source>System Information: pg_my_temp_schema</source>
          <target state="translated">시스템 정보 : pg_my_temp_schema</target>
        </trans-unit>
        <trans-unit id="9427a469292e8d24202408f2c66b1fead7e55cf0" translate="yes" xml:space="preserve">
          <source>System Information: pg_notification_queue_usage</source>
          <target state="translated">시스템 정보 : pg_notification_queue_usage</target>
        </trans-unit>
        <trans-unit id="2f896acf33d7f4a9bde4da308077a4b846791455" translate="yes" xml:space="preserve">
          <source>System Information: pg_opclass_is_visible</source>
          <target state="translated">시스템 정보 : pg_opclass_is_visible</target>
        </trans-unit>
        <trans-unit id="eb41b67b8d25d28160f040f3b349cafbc234fae5" translate="yes" xml:space="preserve">
          <source>System Information: pg_operator_is_visible</source>
          <target state="translated">시스템 정보 : pg_operator_is_visible</target>
        </trans-unit>
        <trans-unit id="de72c373726e820e11f6ea5bb409fbf46c047981" translate="yes" xml:space="preserve">
          <source>System Information: pg_opfamily_is_visible</source>
          <target state="translated">시스템 정보 : pg_opfamily_is_visible</target>
        </trans-unit>
        <trans-unit id="4a3940ece34fd6158cfbd6daffcf4b87af0e8871" translate="yes" xml:space="preserve">
          <source>System Information: pg_options_to_table</source>
          <target state="translated">시스템 정보 : pg_options_to_table</target>
        </trans-unit>
        <trans-unit id="9a15788f0aad22082f36a4f1a2e92c534d2d78da" translate="yes" xml:space="preserve">
          <source>System Information: pg_postmaster_start_time</source>
          <target state="translated">시스템 정보 : pg_postmaster_start_time</target>
        </trans-unit>
        <trans-unit id="9f0bfdc50b57c1f3804da49c81b9709e4173d6dc" translate="yes" xml:space="preserve">
          <source>System Information: pg_safe_snapshot_blocking_pids</source>
          <target state="translated">시스템 정보 : pg_safe_snapshot_blocking_pids</target>
        </trans-unit>
        <trans-unit id="42869dc2ddab57d5c05003fbfd0dc0a5bf9e8643" translate="yes" xml:space="preserve">
          <source>System Information: pg_snapshot_xip</source>
          <target state="translated">System Information: pg_snapshot_xip</target>
        </trans-unit>
        <trans-unit id="5342145390ca7800d5a5a60b6bb0a35c3212f537" translate="yes" xml:space="preserve">
          <source>System Information: pg_snapshot_xmax</source>
          <target state="translated">System Information: pg_snapshot_xmax</target>
        </trans-unit>
        <trans-unit id="df1823e149c01e3ca5ac2582bdbec33eb95f3950" translate="yes" xml:space="preserve">
          <source>System Information: pg_snapshot_xmin</source>
          <target state="translated">System Information: pg_snapshot_xmin</target>
        </trans-unit>
        <trans-unit id="0b4bea14c80020830b5348de8df609f0b9c57683" translate="yes" xml:space="preserve">
          <source>System Information: pg_statistics_obj_is_visible</source>
          <target state="translated">시스템 정보 : pg_statistics_obj_is_visible</target>
        </trans-unit>
        <trans-unit id="6d79717f1a8eb542a075fce2b845705f15d4446b" translate="yes" xml:space="preserve">
          <source>System Information: pg_table_is_visible</source>
          <target state="translated">시스템 정보 : pg_table_is_visible</target>
        </trans-unit>
        <trans-unit id="7fcbfabf9d15e2e46a11a5689fb040424e1554de" translate="yes" xml:space="preserve">
          <source>System Information: pg_tablespace_databases</source>
          <target state="translated">시스템 정보 : pg_tablespace_databases</target>
        </trans-unit>
        <trans-unit id="624b686def8417598c2d32b3f54a71570db3c930" translate="yes" xml:space="preserve">
          <source>System Information: pg_tablespace_location</source>
          <target state="translated">시스템 정보 : pg_tablespace_location</target>
        </trans-unit>
        <trans-unit id="0208c441c9650c3243c1bd798156148c15efaa0b" translate="yes" xml:space="preserve">
          <source>System Information: pg_trigger_depth</source>
          <target state="translated">시스템 정보 : pg_trigger_depth</target>
        </trans-unit>
        <trans-unit id="b300cfbff6c226ad3af4928ef075c72a6c51b70e" translate="yes" xml:space="preserve">
          <source>System Information: pg_ts_config_is_visible</source>
          <target state="translated">시스템 정보 : pg_ts_config_is_visible</target>
        </trans-unit>
        <trans-unit id="2ed5e52816e4d4da044e4524da07b44a0b8e37da" translate="yes" xml:space="preserve">
          <source>System Information: pg_ts_dict_is_visible</source>
          <target state="translated">시스템 정보 : pg_ts_dict_is_visible</target>
        </trans-unit>
        <trans-unit id="27f20964bd3bf57686e8ac3665c358e456968093" translate="yes" xml:space="preserve">
          <source>System Information: pg_ts_parser_is_visible</source>
          <target state="translated">시스템 정보 : pg_ts_parser_is_visible</target>
        </trans-unit>
        <trans-unit id="2a6f4a8b170015b33e1a33568e11a8ae70375472" translate="yes" xml:space="preserve">
          <source>System Information: pg_ts_template_is_visible</source>
          <target state="translated">시스템 정보 : pg_ts_template_is_visible</target>
        </trans-unit>
        <trans-unit id="65ca7a5937ea157a71ad3f9d3f4a638c0f9577eb" translate="yes" xml:space="preserve">
          <source>System Information: pg_type_is_visible</source>
          <target state="translated">시스템 정보 : pg_type_is_visible</target>
        </trans-unit>
        <trans-unit id="2a3149409814026df972bc0c6c1eb3d69c555f8e" translate="yes" xml:space="preserve">
          <source>System Information: pg_typeof</source>
          <target state="translated">시스템 정보 : pg_typeof</target>
        </trans-unit>
        <trans-unit id="64417ed9c9a664155320e1701854226ad9fbac82" translate="yes" xml:space="preserve">
          <source>System Information: pg_visible_in_snapshot</source>
          <target state="translated">System Information: pg_visible_in_snapshot</target>
        </trans-unit>
        <trans-unit id="990d8ce0cf3602b61f1710d0f90401b03ddd621e" translate="yes" xml:space="preserve">
          <source>System Information: pg_xact_commit_timestamp</source>
          <target state="translated">시스템 정보 : pg_xact_commit_timestamp</target>
        </trans-unit>
        <trans-unit id="1792a0d413fc4539417a0bbb1d554163691cacde" translate="yes" xml:space="preserve">
          <source>System Information: pg_xact_status</source>
          <target state="translated">System Information: pg_xact_status</target>
        </trans-unit>
        <trans-unit id="05801f8090cb34d84bdb7765e474bbda2a55a876" translate="yes" xml:space="preserve">
          <source>System Information: prev_timeline_id</source>
          <target state="translated">시스템 정보 : prev_timeline_id</target>
        </trans-unit>
        <trans-unit id="2d96d4bd3d36dca16caac804a41c1403adfd1503" translate="yes" xml:space="preserve">
          <source>System Information: redo_lsn</source>
          <target state="translated">시스템 정보 : redo_lsn</target>
        </trans-unit>
        <trans-unit id="4a5a7846c2f9da39093f480c7e190ecf637f63d6" translate="yes" xml:space="preserve">
          <source>System Information: redo_wal_file</source>
          <target state="translated">시스템 정보 : redo_wal_file</target>
        </trans-unit>
        <trans-unit id="32897d1342ac3995c768f670c277134c59bc6451" translate="yes" xml:space="preserve">
          <source>System Information: returnable</source>
          <target state="translated">시스템 정보 : 반환 가능</target>
        </trans-unit>
        <trans-unit id="3e97bae654cecca4d7ca8ce303b70b0d63ce1aea" translate="yes" xml:space="preserve">
          <source>System Information: row_security_active</source>
          <target state="translated">시스템 정보 : row_security_active</target>
        </trans-unit>
        <trans-unit id="1db2c6961fdd85f6b4f27652b21dfd636bcbb92b" translate="yes" xml:space="preserve">
          <source>System Information: search_array</source>
          <target state="translated">시스템 정보 : search_array</target>
        </trans-unit>
        <trans-unit id="38d17ba803718a2be294c8582cf0b322d4ba612f" translate="yes" xml:space="preserve">
          <source>System Information: search_nulls</source>
          <target state="translated">시스템 정보 : search_nulls</target>
        </trans-unit>
        <trans-unit id="da01e1b40b5cb56815b9ac6b19499b6c7b3fbfd4" translate="yes" xml:space="preserve">
          <source>System Information: session_user</source>
          <target state="translated">시스템 정보 : session_user</target>
        </trans-unit>
        <trans-unit id="74857d3bdc504df99277acd926266ea7305919c0" translate="yes" xml:space="preserve">
          <source>System Information: shobj_description</source>
          <target state="translated">시스템 정보 : shobj_description</target>
        </trans-unit>
        <trans-unit id="bdcffd2fbb575c94de7879a9b4117acd371067ef" translate="yes" xml:space="preserve">
          <source>System Information: system_identifier</source>
          <target state="translated">시스템 정보 : system_identifier</target>
        </trans-unit>
        <trans-unit id="8bfa30293b890e786eddf1c7720ba10fa8277e00" translate="yes" xml:space="preserve">
          <source>System Information: timeline_id</source>
          <target state="translated">시스템 정보 : timeline_id</target>
        </trans-unit>
        <trans-unit id="0ad9ac0537505c7167a15262a17a7b86dc519351" translate="yes" xml:space="preserve">
          <source>System Information: to_regclass</source>
          <target state="translated">시스템 정보 : to_regclass</target>
        </trans-unit>
        <trans-unit id="1e80d6682f2e8d1d8b288a91df3b797bab4c7258" translate="yes" xml:space="preserve">
          <source>System Information: to_regcollation</source>
          <target state="translated">System Information: to_regcollation</target>
        </trans-unit>
        <trans-unit id="96ddfccfcdcc792a750ec8ac030186f7d37cba65" translate="yes" xml:space="preserve">
          <source>System Information: to_regnamespace</source>
          <target state="translated">시스템 정보 : to_regnamespace</target>
        </trans-unit>
        <trans-unit id="72e9e3450d535e89402eb3191a6e3097bd22551b" translate="yes" xml:space="preserve">
          <source>System Information: to_regoper</source>
          <target state="translated">시스템 정보 : to_regoper</target>
        </trans-unit>
        <trans-unit id="e363101458f0485a40f9b1227f92ac6d18d06790" translate="yes" xml:space="preserve">
          <source>System Information: to_regoperator</source>
          <target state="translated">시스템 정보 : to_regoperator</target>
        </trans-unit>
        <trans-unit id="fa8394d1c21258a57d93bb0d0aa903bbe5f92f65" translate="yes" xml:space="preserve">
          <source>System Information: to_regproc</source>
          <target state="translated">시스템 정보 : to_regproc</target>
        </trans-unit>
        <trans-unit id="f2f8b2af34a75400c61fe7f2659e3371a65ee278" translate="yes" xml:space="preserve">
          <source>System Information: to_regprocedure</source>
          <target state="translated">시스템 정보 : to_regprocedure</target>
        </trans-unit>
        <trans-unit id="adcfdc3f489395a9c4d845c4024ab104b2b43320" translate="yes" xml:space="preserve">
          <source>System Information: to_regrole</source>
          <target state="translated">시스템 정보 : to_regrole</target>
        </trans-unit>
        <trans-unit id="4caf2ddd4ea781468e7857d5870e39316859e3a8" translate="yes" xml:space="preserve">
          <source>System Information: to_regtype</source>
          <target state="translated">시스템 정보 : to_regtype</target>
        </trans-unit>
        <trans-unit id="2ff18c2617fc7e5fba9a57d567e2513bbd75ef9c" translate="yes" xml:space="preserve">
          <source>System Information: txid_current</source>
          <target state="translated">시스템 정보 : txid_current</target>
        </trans-unit>
        <trans-unit id="18290b25e1b9ba51c0baac7291362ff6ddb86c18" translate="yes" xml:space="preserve">
          <source>System Information: txid_current_if_assigned</source>
          <target state="translated">시스템 정보 : txid_current_if_assigned</target>
        </trans-unit>
        <trans-unit id="8217da235b90b0727d52dc2f03af98a083fdfe97" translate="yes" xml:space="preserve">
          <source>System Information: txid_current_snapshot</source>
          <target state="translated">시스템 정보 : txid_current_snapshot</target>
        </trans-unit>
        <trans-unit id="4c3f34d3adfd0d487b59933c5090bbb1abfc51b9" translate="yes" xml:space="preserve">
          <source>System Information: txid_snapshot_xip</source>
          <target state="translated">시스템 정보 : txid_snapshot_xip</target>
        </trans-unit>
        <trans-unit id="b4f34e267df49bb98fdbe58d28cf03124c4bb59b" translate="yes" xml:space="preserve">
          <source>System Information: txid_snapshot_xmax</source>
          <target state="translated">시스템 정보 : txid_snapshot_xmax</target>
        </trans-unit>
        <trans-unit id="b16df7409d8e4621af574ed00fda6acf20737bb4" translate="yes" xml:space="preserve">
          <source>System Information: txid_snapshot_xmin</source>
          <target state="translated">시스템 정보 : txid_snapshot_xmin</target>
        </trans-unit>
        <trans-unit id="c888b9491a62602f505c1d067c4db26662db3442" translate="yes" xml:space="preserve">
          <source>System Information: txid_status</source>
          <target state="translated">시스템 정보 : txid_status</target>
        </trans-unit>
        <trans-unit id="821041065a6170b7c240b1384a24939bb36d4f45" translate="yes" xml:space="preserve">
          <source>System Information: txid_visible_in_snapshot</source>
          <target state="translated">시스템 정보 : txid_visible_in_snapshot</target>
        </trans-unit>
        <trans-unit id="40eb5613ac82bc1527bc94c45ab0b42e2ab81360" translate="yes" xml:space="preserve">
          <source>System Information: user</source>
          <target state="translated">시스템 정보 : 사용자</target>
        </trans-unit>
        <trans-unit id="d341c9172bf1127b8b23455fd6ebd8c1bb8824e2" translate="yes" xml:space="preserve">
          <source>System Information: version</source>
          <target state="translated">시스템 정보 : version</target>
        </trans-unit>
        <trans-unit id="2e22a19399625e3c40b87d6735ff6019b6f7709a" translate="yes" xml:space="preserve">
          <source>System Information: wal_block_size</source>
          <target state="translated">시스템 정보 : wal_block_size</target>
        </trans-unit>
        <trans-unit id="43d78b2c0f2dba3bd6923c2ff5430c7ce02e5515" translate="yes" xml:space="preserve">
          <source>System Information: ~</source>
          <target state="translated">시스템 정보 : ~</target>
        </trans-unit>
        <trans-unit id="0b2a2d814530678f895ce95abd73d8c95d0d9bd6" translate="yes" xml:space="preserve">
          <source>System V IPC features are typically constrained by system-wide allocation limits. When PostgreSQL exceeds one of these limits, the server will refuse to start and should leave an instructive error message describing the problem and what to do about it. (See also &lt;a href=&quot;server-start#SERVER-START-FAILURES&quot;&gt;Section 18.3.1&lt;/a&gt;.) The relevant kernel parameters are named consistently across different systems; &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;Table 18.1&lt;/a&gt; gives an overview. The methods to set them, however, vary. Suggestions for some platforms are given below.</source>
          <target state="translated">System V IPC 기능은 일반적으로 시스템 전체 할당 제한에 의해 제한됩니다. PostgreSQL이 이러한 제한 중 하나를 초과하면 서버는 시작을 거부하고 문제와 그 해결 방법을 설명하는 오류 메시지를 남깁니다. ( &lt;a href=&quot;server-start#SERVER-START-FAILURES&quot;&gt;18.3.1 절&lt;/a&gt; 참조 ) 관련 커널 매개 변수는 다른 시스템에서 일관되게 이름이 지정됩니다. &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;표 18.1&lt;/a&gt; 은 개요를 제공합니다. 그러나 설정 방법은 다양합니다. 일부 플랫폼에 대한 제안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8ada312266934f21f0365b46d3d1998ca0bd822" translate="yes" xml:space="preserve">
          <source>System catalog</source>
          <target state="translated">System catalog</target>
        </trans-unit>
        <trans-unit id="ea2ad791f1f931ed6f36eb3b07a8954fa48d5daf" translate="yes" xml:space="preserve">
          <source>System catalog changes usually only affect database management tools.</source>
          <target state="translated">시스템 카탈로그 변경은 일반적으로 데이터베이스 관리 도구에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3c10328ae12a0ec5efc322bb783f40287312856b" translate="yes" xml:space="preserve">
          <source>SystemTap uses a different notation for trace scripts than DTrace does, even though the underlying trace points are compatible. One point worth noting is that at this writing, SystemTap scripts must reference probe names using double underscores in place of hyphens. This is expected to be fixed in future SystemTap releases.</source>
          <target state="translated">기본 추적 지점이 호환 가능하더라도 SystemTap은 DTrace와 다른 추적 스크립트 표기법을 사용합니다. 주목할만한 점은이 글을 작성할 때 SystemTap 스크립트는 하이픈 대신 이중 밑줄을 사용하여 프로브 이름을 참조해야한다는 것입니다. 이것은 향후 SystemTap 릴리스에서 수정 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8afb07710238ef3f41750b4461be06cb4bdd01f1" translate="yes" xml:space="preserve">
          <source>TCP port number that the client is using for communication</source>
          <target state="translated">클라이언트가 통신에 사용중인 TCP 포트 번호</target>
        </trans-unit>
        <trans-unit id="740e755e160ccdedd8428d28fd9181ce097d395c" translate="yes" xml:space="preserve">
          <source>TCP port number that the client is using for communication with this WAL sender, or &lt;code&gt;-1&lt;/code&gt; if a Unix socket is used</source>
          <target state="translated">클라이언트가이 WAL 발신자와 통신하는 데 사용하는 TCP 포트 번호 또는 Unix 소켓이 사용되는 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f185720bb1c5bfa5b20f9e9bfc8e0cf0bb85cdb7" translate="yes" xml:space="preserve">
          <source>TCP port number that the client is using for communication with this backend, or &lt;code&gt;-1&lt;/code&gt; if a Unix socket is used</source>
          <target state="translated">클라이언트가이 백엔드와의 통신에 사용하는 TCP 포트 번호 또는 Unix 소켓이 사용되는 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7d12fd2aa2c53fd9bd1bf8bf4dbc9b783b8afd7" translate="yes" xml:space="preserve">
          <source>TCP port number that the client is using for communication with this backend, or &lt;code&gt;-1&lt;/code&gt; if a Unix socket is used. If this field is null, it indicates that this is an internal server process.</source>
          <target state="translated">TCP port number that the client is using for communication with this backend, or &lt;code&gt;-1&lt;/code&gt; if a Unix socket is used. If this field is null, it indicates that this is an internal server process.</target>
        </trans-unit>
        <trans-unit id="88da89e91381b190bd9878177d6d1952a36ddc55" translate="yes" xml:space="preserve">
          <source>TCP/IP</source>
          <target state="translated">TCP/IP</target>
        </trans-unit>
        <trans-unit id="047bd611a87b4577b1b30588ada86c2e3ed12201" translate="yes" xml:space="preserve">
          <source>TID</source>
          <target state="translated">TID</target>
        </trans-unit>
        <trans-unit id="7ba264e3ee241c2237411ee8bdc16724b3269e26" translate="yes" xml:space="preserve">
          <source>TOAST</source>
          <target state="translated">TOAST</target>
        </trans-unit>
        <trans-unit id="51d7be94fdffb94b580cc906b9300afdd763b46d" translate="yes" xml:space="preserve">
          <source>TOAST pointers can point to data that is not on disk, but is elsewhere in the memory of the current server process. Such pointers obviously cannot be long-lived, but they are nonetheless useful. There are currently two sub-cases: pointers to &lt;em&gt;indirect&lt;/em&gt; data and pointers to &lt;em&gt;expanded&lt;/em&gt; data.</source>
          <target state="translated">TOAST 포인터는 디스크에는 없지만 현재 서버 프로세스의 메모리에있는 데이터를 가리킬 수 있습니다. 그러한 포인터는 분명히 오래 살 수 없지만 그럼에도 불구하고 유용합니다. 현재 &lt;em&gt;간접&lt;/em&gt; 데이터에 대한 포인터와 &lt;em&gt;확장 된&lt;/em&gt; 데이터에 대한 포인터의 두 가지 하위 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="964c9b659348d852de0f76856a6bfd56433ce188" translate="yes" xml:space="preserve">
          <source>TOAST pointers to expanded values are further broken down into &lt;em&gt;read-write&lt;/em&gt; and &lt;em&gt;read-only&lt;/em&gt; pointers. The pointed-to representation is the same either way, but a function that receives a read-write pointer is allowed to modify the referenced value in-place, whereas one that receives a read-only pointer must not; it must first create a copy if it wants to make a modified version of the value. This distinction and some associated conventions make it possible to avoid unnecessary copying of expanded values during query execution.</source>
          <target state="translated">확장 된 값에 대한 TOAST 포인터는 &lt;em&gt;읽기 / 쓰기&lt;/em&gt; 및 &lt;em&gt;읽기 전용&lt;/em&gt; 포인터 로 세분화됩니다 . 지시 된 표현은 어느 쪽이든 동일하지만, 읽기-쓰기 포인터를받는 함수는 참조 된 값을 제자리에서 수정할 수있는 반면, 읽기 전용 포인터를받는 것은 그렇지 않아야합니다. 수정 된 버전의 값을 만들려면 먼저 사본을 작성해야합니다. 이러한 구별 및 일부 관련 규칙을 사용하면 쿼리 실행 중에 확장 값을 불필요하게 복사하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="8c3910cc79fb5b6d32a435a625feda9854570fff" translate="yes" xml:space="preserve">
          <source>TOAST usurps two bits of the varlena length word (the high-order bits on big-endian machines, the low-order bits on little-endian machines), thereby limiting the logical size of any value of a TOAST-able data type to 1 GB (2&lt;sup&gt;30&lt;/sup&gt; - 1 bytes). When both bits are zero, the value is an ordinary un-TOASTed value of the data type, and the remaining bits of the length word give the total datum size (including length word) in bytes. When the highest-order or lowest-order bit is set, the value has only a single-byte header instead of the normal four-byte header, and the remaining bits of that byte give the total datum size (including length byte) in bytes. This alternative supports space-efficient storage of values shorter than 127 bytes, while still allowing the data type to grow to 1 GB at need. Values with single-byte headers aren't aligned on any particular boundary, whereas values with four-byte headers are aligned on at least a four-byte boundary; this omission of alignment padding provides additional space savings that is significant compared to short values. As a special case, if the remaining bits of a single-byte header are all zero (which would be impossible for a self-inclusive length), the value is a pointer to out-of-line data, with several possible alternatives as described below. The type and size of such a &lt;em&gt;TOAST pointer&lt;/em&gt; are determined by a code stored in the second byte of the datum. Lastly, when the highest-order or lowest-order bit is clear but the adjacent bit is set, the content of the datum has been compressed and must be decompressed before use. In this case the remaining bits of the four-byte length word give the total size of the compressed datum, not the original data. Note that compression is also possible for out-of-line data but the varlena header does not tell whether it has occurred &amp;mdash; the content of the TOAST pointer tells that, instead.</source>
          <target state="translated">TOAST는 varlena 길이 워드의 2 비트 (big-endian 시스템의 상위 비트, little-endian 시스템의 하위 비트)를 사용하여 TOAST 가능 데이터 유형의 모든 값의 논리 크기를 1로 제한합니다. GB (2 &lt;sup&gt;30&lt;/sup&gt;-1 바이트). 두 비트가 모두 0 인 경우, 값은 데이터 유형의 일반 TOTOAST 값이며 길이 워드의 나머지 비트는 총 데이텀 크기 (길이 워드 포함)를 바이트 단위로 제공합니다. 최상위 또는 최하위 비트가 설정되면 값에는 일반 4 바이트 헤더 대신 단일 바이트 헤더 만 있고 해당 바이트의 나머지 비트는 총 데이텀 크기 (길이 바이트 포함)를 바이트 단위로 나타냅니다. . 이 대안은 127 바이트보다 짧은 값을 공간 효율적으로 저장하는 동시에 데이터 유형을 1GB로 늘릴 수 있습니다. 1 바이트 헤더가있는 값은 특정 경계에서 정렬되지 않지만 4 바이트 헤더가있는 값은 4 바이트 이상의 경계에서 정렬됩니다. 이러한 정렬 패딩 누락은 짧은 값에 비해 상당한 공간 절약 효과를 제공합니다.특별한 경우로, 단일 바이트 헤더의 나머지 비트가 모두 0 (자체 포함 길이에서는 불가능할 경우) 인 경우, 값은 설명에 따라 여러 가지 가능한 대안이있는 라인 외부 데이터에 대한 포인터입니다. 이하. 그러한 유형과 크기&lt;em&gt;TOAST 포인터&lt;/em&gt; 는 데이텀의 두 번째 바이트에 저장된 코드로 결정됩니다. 마지막으로 최상위 또는 최하위 비트가 깨끗하지만 인접 비트가 설정된 경우 데이텀의 내용이 압축되었으며 사용하기 전에 압축을 풀어야합니다. 이 경우 4 바이트 길이 워드의 나머지 비트는 원본 데이터가 아니라 압축 된 데이텀의 전체 크기를 나타냅니다. 라인 외부 데이터에 대해서도 압축이 가능하지만 varlena 헤더는 데이터의 발생 여부를 알려주지 않습니다. 대신 TOAST 포인터의 내용이이를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8c658426f6e9645ac24a7cc07d9404747aa712b3" translate="yes" xml:space="preserve">
          <source>TPC</source>
          <target state="translated">TPC</target>
        </trans-unit>
        <trans-unit id="fddf1df7c30cac7908d10246256efd264ce7aa32" translate="yes" xml:space="preserve">
          <source>TRUE</source>
          <target state="translated">TRUE</target>
        </trans-unit>
        <trans-unit id="74303786eb95ccd75228db361d37b804576e18e6" translate="yes" xml:space="preserve">
          <source>TRUNCATE</source>
          <target state="translated">TRUNCATE</target>
        </trans-unit>
        <trans-unit id="c51f9cc32a5064c171ec7fbd3569d531e89a1c56" translate="yes" xml:space="preserve">
          <source>TRUNCATE &amp;mdash; empty a table or set of tables</source>
          <target state="translated">TRUNCATE &amp;mdash; 테이블 또는 테이블 세트를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="6423f0db833042cf5e91c33cf6439a04a79fd980" translate="yes" xml:space="preserve">
          <source>Tab (ASCII 9)</source>
          <target state="translated">탭 (ASCII 9)</target>
        </trans-unit>
        <trans-unit id="0424f6e7026fa4bc2c4a7043083417315113c79b" translate="yes" xml:space="preserve">
          <source>Table</source>
          <target state="translated">Table</target>
        </trans-unit>
        <trans-unit id="fb232362d0a8d2ba0ab9ebeecd048709dca540ac" translate="yes" xml:space="preserve">
          <source>Table Access Method Interface Definition</source>
          <target state="translated">테이블 액세스 방법 인터페이스 정의</target>
        </trans-unit>
        <trans-unit id="11ff41b08d6854848182469ccb18893cc9671879" translate="yes" xml:space="preserve">
          <source>Table Basics</source>
          <target state="translated">테이블 기본</target>
        </trans-unit>
        <trans-unit id="ae752a548fab7b5d8f441e50b07f912b72cd8411" translate="yes" xml:space="preserve">
          <source>Table Expressions</source>
          <target state="translated">테이블 표현식</target>
        </trans-unit>
        <trans-unit id="a4219b61fe0fdfeb7af4dc1a19b1c12ad046bbb3" translate="yes" xml:space="preserve">
          <source>Table Expressions: FROM Clause</source>
          <target state="translated">테이블 표현식 : FROM Clause</target>
        </trans-unit>
        <trans-unit id="1b6769c4d038cb2821fdba571ee9473eaee34a94" translate="yes" xml:space="preserve">
          <source>Table Expressions: FULL OUTER JOIN</source>
          <target state="translated">테이블 표현식 : FULL OUTER JOIN</target>
        </trans-unit>
        <trans-unit id="9b856ea1c66e6eb49aa7e0ed5a2df13195dd8b17" translate="yes" xml:space="preserve">
          <source>Table Expressions: GROUP BY and HAVING Clauses</source>
          <target state="translated">테이블 표현식 : GROUP BY 및 HAVING 절</target>
        </trans-unit>
        <trans-unit id="41e1b5495e0dc98cde2555d00adb2953047b09de" translate="yes" xml:space="preserve">
          <source>Table Expressions: GROUPING SETS, CUBE, and ROLLUP</source>
          <target state="translated">테이블 표현식 : GROUPING SETS, CUBE 및 ROLLUP</target>
        </trans-unit>
        <trans-unit id="aba6037ec4c02435b3056c6225936f6888153fd6" translate="yes" xml:space="preserve">
          <source>Table Expressions: INNER JOIN</source>
          <target state="translated">테이블 표현식 : INNER JOIN</target>
        </trans-unit>
        <trans-unit id="6fc2c101a1a9ff9871f5f39c755a2581191907ab" translate="yes" xml:space="preserve">
          <source>Table Expressions: Joined Tables</source>
          <target state="translated">테이블 표현식 : 결합 된 테이블</target>
        </trans-unit>
        <trans-unit id="bf24960678770f671f056968d4750e7606fbf7e8" translate="yes" xml:space="preserve">
          <source>Table Expressions: LATERAL Subqueries</source>
          <target state="translated">테이블 표현식 : LATERAL 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="e8aa6e33b34bec5d76bce47031ecb49488501d5a" translate="yes" xml:space="preserve">
          <source>Table Expressions: LEFT OUTER JOIN</source>
          <target state="translated">테이블 표현식 : LEFT OUTER JOIN</target>
        </trans-unit>
        <trans-unit id="6d0d3851d827be93ee70a1d1b91d3fac3a92d7cb" translate="yes" xml:space="preserve">
          <source>Table Expressions: RIGHT OUTER JOIN</source>
          <target state="translated">테이블 표현식 : RIGHT OUTER JOIN</target>
        </trans-unit>
        <trans-unit id="753f3a343ebc42b7a9059070dda975d1af74dd5d" translate="yes" xml:space="preserve">
          <source>Table Expressions: Subqueries</source>
          <target state="translated">테이블 표현식 : 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="e4f6830cc6b0a1881b7d017eb2a22f6dda377daf" translate="yes" xml:space="preserve">
          <source>Table Expressions: Table Functions</source>
          <target state="translated">테이블 표현식 : 테이블 함수</target>
        </trans-unit>
        <trans-unit id="ec41e93bdf13abf65ecebcbb1137e4ecec20c31b" translate="yes" xml:space="preserve">
          <source>Table Expressions: Table and Column Aliases</source>
          <target state="translated">테이블 표현식 : 테이블 및 열 별명</target>
        </trans-unit>
        <trans-unit id="e39cfbb2f40f23ebe1f69be21076e1a950018f84" translate="yes" xml:space="preserve">
          <source>Table Expressions: WHERE Clause</source>
          <target state="translated">테이블 표현식 : WHERE Clause</target>
        </trans-unit>
        <trans-unit id="0f4691d4ff404397912df160edd8f94690df8d48" translate="yes" xml:space="preserve">
          <source>Table Expressions: Window Function Processing</source>
          <target state="translated">테이블 표현식 : 창 함수 처리</target>
        </trans-unit>
        <trans-unit id="ea47dd2beba135d5c4d14faca762145b641244e7" translate="yes" xml:space="preserve">
          <source>Table Partitioning</source>
          <target state="translated">테이블 파티셔닝</target>
        </trans-unit>
        <trans-unit id="82d96886774a2410448beeb1c5d39dc583137fae" translate="yes" xml:space="preserve">
          <source>Table Partitioning: Declarative Partitioning</source>
          <target state="translated">테이블 파티셔닝 : 선언적 파티셔닝</target>
        </trans-unit>
        <trans-unit id="0a5ea1d770e67d42ee580bc8259b8d09dd77f082" translate="yes" xml:space="preserve">
          <source>Table Partitioning: Declarative Partitioning Best Practices</source>
          <target state="translated">테이블 파티셔닝 : 선언적 파티셔닝 모범 사례</target>
        </trans-unit>
        <trans-unit id="b3bad99d306d10127133be5426c5d831b8d9d311" translate="yes" xml:space="preserve">
          <source>Table Partitioning: Implementation Inheritance</source>
          <target state="translated">테이블 분할 : 구현 상속</target>
        </trans-unit>
        <trans-unit id="d01f16cd1b52f44bb71ee5ca456a168075c81542" translate="yes" xml:space="preserve">
          <source>Table Partitioning: Partition Pruning</source>
          <target state="translated">테이블 파티셔닝 : 파티션 프 루닝</target>
        </trans-unit>
        <trans-unit id="c7c8b9861f91f48e5645656e08e1f85ae96b10b0" translate="yes" xml:space="preserve">
          <source>Table Partitioning: Partitioning and Constraint Exclusion</source>
          <target state="translated">테이블 파티셔닝 : 파티셔닝 및 제약 조건 제외</target>
        </trans-unit>
        <trans-unit id="d8e31867e8bcb467f9956e189f7b3e1ba6400b8b" translate="yes" xml:space="preserve">
          <source>Table aliases are mainly for notational convenience, but it is necessary to use them when joining a table to itself, e.g.:</source>
          <target state="translated">테이블 별칭은 주로 표기상의 편의를 위해 사용되지만 테이블을 자체에 조인 할 때는 다음과 같이 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2068a0bb2a4c0b1f8a683e70f1c3ff6e4cb604a8" translate="yes" xml:space="preserve">
          <source>Table column</source>
          <target state="translated">테이블 열</target>
        </trans-unit>
        <trans-unit id="e2f409448c02e433d94321231d85469803dc6d9d" translate="yes" xml:space="preserve">
          <source>Table containing the columns described by this object</source>
          <target state="translated">이 객체가 설명하는 열을 포함하는 테이블</target>
        </trans-unit>
        <trans-unit id="d4d581bf434da5a5b4f9434dddc7c882f48f9378" translate="yes" xml:space="preserve">
          <source>Table functions appearing in &lt;code&gt;FROM&lt;/code&gt; can also be preceded by the key word &lt;code&gt;LATERAL&lt;/code&gt;, but for functions the key word is optional; the function's arguments can contain references to columns provided by preceding &lt;code&gt;FROM&lt;/code&gt; items in any case.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 에 나타나는 테이블 함수 앞에는 키워드 &lt;code&gt;LATERAL&lt;/code&gt; 이 올 수 있지만 함수의 경우 키워드는 선택 사항입니다. 함수의 인수는 어떤 경우에도 선행 &lt;code&gt;FROM&lt;/code&gt; 항목이 제공 한 열에 대한 참조를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9185e6d51a58bfa9602cf9ef2d4cb9a7c26ac54" translate="yes" xml:space="preserve">
          <source>Table functions are functions that produce a set of rows, made up of either base data types (scalar types) or composite data types (table rows). They are used like a table, view, or subquery in the &lt;code&gt;FROM&lt;/code&gt; clause of a query. Columns returned by table functions can be included in &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;JOIN&lt;/code&gt;, or &lt;code&gt;WHERE&lt;/code&gt; clauses in the same manner as columns of a table, view, or subquery.</source>
          <target state="translated">테이블 함수는 기본 데이터 유형 (스칼라 유형) 또는 복합 데이터 유형 (테이블 행)으로 구성된 행 세트를 생성하는 함수입니다. 쿼리의 &lt;code&gt;FROM&lt;/code&gt; 절 에서 테이블, 뷰 또는 하위 쿼리처럼 사용됩니다 . 테이블 함수가 리턴 한 컬럼은 테이블, 뷰 또는 서브 쿼리의 컬럼과 동일한 방식으로 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;JOIN&lt;/code&gt; 또는 &lt;code&gt;WHERE&lt;/code&gt; 절에 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c53231dea8f7f64f886f1c20c95992ee143e659a" translate="yes" xml:space="preserve">
          <source>Table functions may also be combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; syntax, with the results returned in parallel columns; the number of result rows in this case is that of the largest function result, with smaller results padded with null values to match.</source>
          <target state="translated">&lt;code&gt;ROWS FROM&lt;/code&gt; 구문을 사용하여 테이블 함수를 결합 할 수도 있으며 결과는 병렬 열로 리턴됩니다. 이 경우 결과 행의 수는 가장 큰 함수 결과의 수이며, 더 작은 결과는 일치하는 null 값으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="aa44580889246402a89399796b738891b726f457" translate="yes" xml:space="preserve">
          <source>Table inheritance allows for multiple inheritance.</source>
          <target state="translated">테이블 상속은 다중 상속을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="785ace202eeb7c163da19cabb3acbebd6b8d9282" translate="yes" xml:space="preserve">
          <source>Table inheritance is typically established when the child table is created, using the &lt;code&gt;INHERITS&lt;/code&gt; clause of the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Alternatively, a table which is already defined in a compatible way can have a new parent relationship added, using the &lt;code&gt;INHERIT&lt;/code&gt; variant of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. To do this the new child table must already include columns with the same names and types as the columns of the parent. It must also include check constraints with the same names and check expressions as those of the parent. Similarly an inheritance link can be removed from a child using the &lt;code&gt;NO INHERIT&lt;/code&gt; variant of &lt;code&gt;ALTER TABLE&lt;/code&gt;. Dynamically adding and removing inheritance links like this can be useful when the inheritance relationship is being used for table partitioning (see &lt;a href=&quot;ddl-partitioning&quot;&gt;Section 5.11&lt;/a&gt;).</source>
          <target state="translated">테이블 상속은 일반적으로 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 &lt;code&gt;INHERITS&lt;/code&gt; 절을 사용하여 자식 테이블을 만들 때 설정됩니다 . 또는 이미 호환 가능한 방식으로 정의 된 테이블 은 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 의 &lt;code&gt;INHERIT&lt;/code&gt; 변형을 사용하여 새 상위 관계를 추가 할 수 있습니다 . 이렇게하려면 새 자식 테이블에 부모의 열과 이름과 유형이 같은 열이 이미 포함되어 있어야합니다. 또한 부모의 이름과 동일한 이름 및 검사 표현식의 검사 제한 조건을 포함해야합니다. 마찬가지로 &lt;code&gt;NO INHERIT&lt;/code&gt; 변형을 사용하여 자식에서 상속 링크를 제거 할 수 있습니다. &lt;code&gt;ALTER TABLE&lt;/code&gt; . 이와 같은 상속 링크를 동적으로 추가하고 제거하는 것은 상속 관계가 테이블 파티셔닝에 사용될 때 유용 할 수 있습니다 ( &lt;a href=&quot;ddl-partitioning&quot;&gt;5.11 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b610381c5aaf8aee8f5aa64c29f4c1854100d53b" translate="yes" xml:space="preserve">
          <source>Table- and row-level locking facilities are also available in PostgreSQL for applications which don't generally need full transaction isolation and prefer to explicitly manage particular points of conflict. However, proper use of MVCC will generally provide better performance than locks. In addition, application-defined advisory locks provide a mechanism for acquiring locks that are not tied to a single transaction.</source>
          <target state="translated">PostgreSQL에서는 일반적으로 전체 트랜잭션 격리가 필요하지 않고 특정 충돌 지점을 명시 적으로 관리하는 것을 선호하는 애플리케이션을 위해 테이블 ​​및 행 수준 잠금 기능을 사용할 수 있습니다. 그러나 MVCC를 올바르게 사용하면 일반적으로 잠금보다 더 나은 성능을 제공합니다. 또한 응용 프로그램 정의 권고 잠금은 단일 트랜잭션에 연결되지 않은 잠금을 획득하기위한 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="193daf137ed8b89de36d47c3df5fd8f66c0e1d14" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="translated">Tables</target>
        </trans-unit>
        <trans-unit id="620fe992f378b573b9ea73b7b55f3d3300fdee87" translate="yes" xml:space="preserve">
          <source>Tables and Indexes</source>
          <target state="translated">테이블과 인덱스</target>
        </trans-unit>
        <trans-unit id="e22db573d19e6a7436aed5c9dc51a2f18ca820a6" translate="yes" xml:space="preserve">
          <source>Tables and foreign tables</source>
          <target state="translated">테이블과 외래 테이블</target>
        </trans-unit>
        <trans-unit id="0f953cc3e8de6bd2f7874259f7207d80832d002d" translate="yes" xml:space="preserve">
          <source>Tables are grouped into databases, and a collection of databases managed by a single PostgreSQL server instance constitutes a database &lt;em&gt;cluster&lt;/em&gt;.</source>
          <target state="translated">테이블은 데이터베이스로 그룹화되며 단일 PostgreSQL 서버 인스턴스가 관리하는 데이터베이스 컬렉션은 데이터베이스 &lt;em&gt;클러스터를&lt;/em&gt; 구성 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b236bf70e4e0c673ef94eb379721e33eea3962ec" translate="yes" xml:space="preserve">
          <source>Tables or foreign tables which are partitions of some other table are automatically excluded. Partitioned tables are imported, unless they are a partition of some other table. Since all data can be accessed through the partitioned table which is the root of the partitioning hierarchy, this approach should allow access to all the data without creating extra objects.</source>
          <target state="translated">다른 테이블의 파티션 인 테이블 또는 외부 테이블은 자동으로 제외됩니다. 파티션 된 테이블은 다른 테이블의 파티션이 아닌 경우 가져옵니다. 모든 데이터는 분할 계층의 루트 인 분할 된 테이블을 통해 액세스 할 수 있으므로이 방법을 사용하면 추가 개체를 만들지 않고도 모든 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b22ad449e620af2f251dab99ace704fb4d41860" translate="yes" xml:space="preserve">
          <source>Tables whose &lt;code&gt;relfrozenxid&lt;/code&gt; value is more than &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; transactions old are always vacuumed (this also applies to those tables whose freeze max age has been modified via storage parameters; see below). Otherwise, if the number of tuples obsoleted since the last &lt;code&gt;VACUUM&lt;/code&gt; exceeds the &amp;ldquo;vacuum threshold&amp;rdquo;, the table is vacuumed. The vacuum threshold is defined as:</source>
          <target state="translated">&lt;code&gt;relfrozenxid&lt;/code&gt; 값이 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; 트랜잭션 이전의 테이블 보다 오래된 테이블은 항상 정리 됩니다 (이는 동결 최대 수명이 스토리지 매개 변수를 통해 수정 된 테이블에도 적용됩니다 (아래 참조)). 그렇지 않으면, 마지막 &lt;code&gt;VACUUM&lt;/code&gt; 이후 폐기 된 튜플 수가 &quot;진공 임계 값&quot;을 초과하면 테이블이 진공 상태가됩니다. 진공 임계 값은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="36e61baf56cf296550418400316f60dbb5ee67d4" translate="yes" xml:space="preserve">
          <source>Tables, indexes, and entire databases can be assigned to particular tablespaces. To do so, a user with the &lt;code&gt;CREATE&lt;/code&gt; privilege on a given tablespace must pass the tablespace name as a parameter to the relevant command. For example, the following creates a table in the tablespace &lt;code&gt;space1&lt;/code&gt;:</source>
          <target state="translated">테이블, 인덱스 및 전체 데이터베이스를 특정 테이블 스페이스에 할당 할 수 있습니다. 이를 위해서는 주어진 테이블 스페이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있는 사용자가 테이블 스페이스 이름을 매개 변수로 관련 명령에 전달해야합니다. 예를 들어, 다음은 테이블 스페이스 &lt;code&gt;space1&lt;/code&gt; 에 테이블을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="acfbd87f319e23d10541fda864650877e64e59d1" translate="yes" xml:space="preserve">
          <source>Tables, views, and foreign tables</source>
          <target state="translated">테이블, 뷰 및 외부 테이블</target>
        </trans-unit>
        <trans-unit id="1cce5d14b9fd8f386cc28f7358476e953b70f5ec" translate="yes" xml:space="preserve">
          <source>Tablespace</source>
          <target state="translated">Tablespace</target>
        </trans-unit>
        <trans-unit id="3b9b3d0eb56fdd1a45491c7eb1ca4007b7dc7c9a" translate="yes" xml:space="preserve">
          <source>Tablespace OID of the relation</source>
          <target state="translated">관계의 테이블 스페이스 OID</target>
        </trans-unit>
        <trans-unit id="46aa83bd623cc70e67c6ad67f254532d3302deb2" translate="yes" xml:space="preserve">
          <source>Tablespace name</source>
          <target state="translated">테이블 스페이스 이름</target>
        </trans-unit>
        <trans-unit id="5742d7c8d581e7c014f1cd9c573785f19819876f" translate="yes" xml:space="preserve">
          <source>Tablespace-level options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 테이블 스페이스 수준 옵션</target>
        </trans-unit>
        <trans-unit id="ff5b9ddf2dd81525ac5b0fb5fcd732fc5c174692" translate="yes" xml:space="preserve">
          <source>Tablespaces</source>
          <target state="translated">Tablespaces</target>
        </trans-unit>
        <trans-unit id="0566d6648625ed8c21950fac6013dc2a7c322afb" translate="yes" xml:space="preserve">
          <source>Tablespaces are only supported on systems that support symbolic links.</source>
          <target state="translated">테이블 스페이스는 기호 링크를 지원하는 시스템에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0aaf64ac79623942c35083c03c8271d360644b69" translate="yes" xml:space="preserve">
          <source>Tablespaces in PostgreSQL allow database administrators to define locations in the file system where the files representing database objects can be stored. Once created, a tablespace can be referred to by name when creating database objects.</source>
          <target state="translated">데이터베이스 관리자는 PostgreSQL의 테이블 스페이스를 사용하여 데이터베이스 객체를 나타내는 파일을 저장할 수있는 파일 시스템의 위치를 ​​정의 할 수 있습니다. 일단 작성된 후에는 데이터베이스 오브젝트를 작성할 때 테이블 스페이스를 이름으로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd917a29f8fbd91c07f263ba5d895a6b71dba6b9" translate="yes" xml:space="preserve">
          <source>Tablespaces make the scenario more complicated. Each user-defined tablespace has a symbolic link inside the &lt;code&gt;PGDATA&lt;/code&gt;&lt;code&gt;/pg_tblspc&lt;/code&gt; directory, which points to the physical tablespace directory (i.e., the location specified in the tablespace's &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; command). This symbolic link is named after the tablespace's OID. Inside the physical tablespace directory there is a subdirectory with a name that depends on the PostgreSQL server version, such as &lt;code&gt;PG_9.0_201008051&lt;/code&gt;. (The reason for using this subdirectory is so that successive versions of the database can use the same &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; location value without conflicts.) Within the version-specific subdirectory, there is a subdirectory for each database that has elements in the tablespace, named after the database's OID. Tables and indexes are stored within that directory, using the filenode naming scheme. The &lt;code&gt;pg_default&lt;/code&gt; tablespace is not accessed through &lt;code&gt;pg_tblspc&lt;/code&gt;, but corresponds to &lt;code&gt;PGDATA&lt;/code&gt;&lt;code&gt;/base&lt;/code&gt;. Similarly, the &lt;code&gt;pg_global&lt;/code&gt; tablespace is not accessed through &lt;code&gt;pg_tblspc&lt;/code&gt;, but corresponds to &lt;code&gt;PGDATA&lt;/code&gt;&lt;code&gt;/global&lt;/code&gt;.</source>
          <target state="translated">테이블 스페이스는 시나리오를 더 복잡하게 만듭니다. 각 사용자 정의 테이블 스페이스에는 &lt;code&gt;PGDATA&lt;/code&gt; &lt;code&gt;/pg_tblspc&lt;/code&gt; 디렉토리 내부에 실제 테이블 스페이스 디렉토리 (예 : 테이블 스페이스의 &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; 명령에 지정된 위치)를 가리키는 기호 링크가 있습니다 . 이 기호 링크는 테이블 스페이스의 OID 이름을 따서 명명됩니다. 실제 테이블 스페이스 디렉토리에는 PostgreSQL 서버 버전 (예 : &lt;code&gt;PG_9.0_201008051&lt;/code&gt; ) 에 따라 이름이있는 서브 디렉토리가 있습니다. (이 서브 디렉토리를 사용하는 이유는 후속 버전의 데이터베이스가 동일한 &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; 를 사용할 수 있기 때문입니다.버전 별 하위 디렉토리에는 데이터베이스의 OID 이름을 따서 명명 된 테이블 공간에 요소가있는 각 데이터베이스에 대한 하위 디렉토리가 있습니다. 테이블 및 인덱스는 파일 노드 이름 지정 체계를 사용하여 해당 디렉토리 내에 저장됩니다. &lt;code&gt;pg_default&lt;/code&gt; 의 테이블 스페이스를 통해 액세스되지 &lt;code&gt;pg_tblspc&lt;/code&gt; 만에 해당 &lt;code&gt;PGDATA&lt;/code&gt; &lt;code&gt;/base&lt;/code&gt; . 마찬가지로 &lt;code&gt;pg_global&lt;/code&gt; 테이블 스페이스는 &lt;code&gt;pg_tblspc&lt;/code&gt; 를 통해 액세스되지 않지만 &lt;code&gt;PGDATA&lt;/code&gt; &lt;code&gt;/global&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="5442fbd8a138a2c29f37122e4c91bd6a144e65e2" translate="yes" xml:space="preserve">
          <source>Tablespaces will in plain format by default be backed up to the same path they have on the server, unless the option &lt;code&gt;--tablespace-mapping&lt;/code&gt; is used. Without this option, running a plain format base backup on the same host as the server will not work if tablespaces are in use, because the backup would have to be written to the same directory locations as the original tablespaces.</source>
          <target state="translated">&lt;code&gt;--tablespace-mapping&lt;/code&gt; 옵션을 사용 하지 않는 한 테이블 스페이스는 기본적으로 일반 형식으로 서버에있는 것과 동일한 경로로 백업 됩니다. 이 옵션을 사용하지 않으면 테이블 스페이스를 사용중인 경우 서버와 동일한 호스트에서 일반 형식 기본 백업을 실행하면 백업이 원래 테이블 스페이스와 동일한 디렉토리 위치에 작성되어야하므로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e512bd8604d28f711a2c4c4091720bddc0bf947" translate="yes" xml:space="preserve">
          <source>Takahiro Itagaki &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:itagaki.takahiro@oss.ntt.co.jp&quot;&gt;itagaki.takahiro@oss.ntt.co.jp&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">타카히로 이타가키 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:itagaki.takahiro@oss.ntt.co.jp&quot;&gt;itagaki.takahiro@oss.ntt.co.jp&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="586f49cf1c8af0021980a48690d8a585d169be3f" translate="yes" xml:space="preserve">
          <source>Takahiro Itagaki &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:itagaki.takahiro@oss.ntt.co.jp&quot;&gt;itagaki.takahiro@oss.ntt.co.jp&lt;/a&gt;&amp;gt;&lt;/code&gt;. Query normalization added by Peter Geoghegan &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@2ndquadrant.com&quot;&gt;peter@2ndquadrant.com&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">타카히로 이타가키 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:itagaki.takahiro@oss.ntt.co.jp&quot;&gt;itagaki.takahiro@oss.ntt.co.jp&lt;/a&gt;&amp;gt;&lt;/code&gt; . Peter Geoghegan &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@2ndquadrant.com&quot;&gt;peter@2ndquadrant.com&lt;/a&gt;&amp;gt;&lt;/code&gt; 에 의해 추가 된 쿼리 정규화 .</target>
        </trans-unit>
        <trans-unit id="accb1b2539b3fdc6500ca3822c79474ef77ca532" translate="yes" xml:space="preserve">
          <source>Take a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on a primary key table when going to perform a delete operation:</source>
          <target state="translated">테이크 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 삭제 작업을 수행하려고 할 때 기본 키 테이블에 잠금을 :</target>
        </trans-unit>
        <trans-unit id="ac578937102b3dd3f7f38602d6d2cc840e122b54" translate="yes" xml:space="preserve">
          <source>Take a base backup as described in &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt; to bootstrap the standby server.</source>
          <target state="translated">대기 서버를 부트 스트랩하려면 &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;섹션 25.3.2&lt;/a&gt; 에 설명 된대로 기본 백업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="a33f520efbf90e9642059e9e58d86ab0773a0e08" translate="yes" xml:space="preserve">
          <source>Tangent, argument in degrees</source>
          <target state="translated">Tangent, argument in degrees</target>
        </trans-unit>
        <trans-unit id="132e5062d63be8f5a66534ddb60a5db9bb8fcd44" translate="yes" xml:space="preserve">
          <source>Tangent, argument in radians</source>
          <target state="translated">Tangent, argument in radians</target>
        </trans-unit>
        <trans-unit id="2879301c4eb4d9d1e7d6db67330e7ae59355bf13" translate="yes" xml:space="preserve">
          <source>Tatsuo Ishii</source>
          <target state="translated">타츠오 이시이</target>
        </trans-unit>
        <trans-unit id="fd8e3a045ba04b09dff4e4cbd6ff902f5dffb538" translate="yes" xml:space="preserve">
          <source>Tatsuo Ishii, Satoshi Nagayasu and Abhijit Menon-Sen</source>
          <target state="translated">이시이 타츠오, 나가야 스 사토시, 아비 짓 메논 센</target>
        </trans-unit>
        <trans-unit id="bbccb82c815d97a0993608659a4544838766b63a" translate="yes" xml:space="preserve">
          <source>Taxicab (L-1 metric) distance between a and b.</source>
          <target state="translated">a와 b 사이의 택시 (L-1 미터법) 거리.</target>
        </trans-unit>
        <trans-unit id="58511427183e07e2c3b2df8ed475af878ee43e8f" translate="yes" xml:space="preserve">
          <source>Technically, this is a string parameter, but &lt;code&gt;'immediate'&lt;/code&gt; is currently the only allowed value.</source>
          <target state="translated">기술적으로 이것은 문자열 매개 변수이지만 현재는 &lt;code&gt;'immediate'&lt;/code&gt; 만이 유일하게 허용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="40bf99abcfdd4cf6a1ea0376ee685e8dd9ab5654" translate="yes" xml:space="preserve">
          <source>Template Databases</source>
          <target state="translated">템플릿 데이터베이스</target>
        </trans-unit>
        <trans-unit id="8bd27170e2bd39031b692cffa7b02ce3c5880bb4" translate="yes" xml:space="preserve">
          <source>Template-specific options can appear in any order.</source>
          <target state="translated">템플릿 별 옵션은 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d18aa9cc2eabd8da836af0c165b0e969643007" translate="yes" xml:space="preserve">
          <source>Temporarily increasing the &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; configuration variable when loading large amounts of data can lead to improved performance. This will help to speed up &lt;code&gt;CREATE INDEX&lt;/code&gt; commands and &lt;code&gt;ALTER TABLE ADD FOREIGN KEY&lt;/code&gt; commands. It won't do much for &lt;code&gt;COPY&lt;/code&gt; itself, so this advice is only useful when you are using one or both of the above techniques.</source>
          <target state="translated">많은 양의 데이터를로드 할 때 &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 구성 변수를 임시로 늘리면 성능이 향상 될 수 있습니다. 이렇게하면 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령 및 &lt;code&gt;ALTER TABLE ADD FOREIGN KEY&lt;/code&gt; 명령의 속도를 높일 수 있습니다. 그것은 훨씬하지 않을 것이다 &lt;code&gt;COPY&lt;/code&gt; 하나 또는 위의 기술을 모두 사용하는 경우이 조언은 유용합니다, 그래서 그 자체.</target>
        </trans-unit>
        <trans-unit id="de111f4e645854c1c0eea7f3b866697e9a997eff" translate="yes" xml:space="preserve">
          <source>Temporarily increasing the &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; configuration variable can also make large data loads faster. This is because loading a large amount of data into PostgreSQL will cause checkpoints to occur more often than the normal checkpoint frequency (specified by the &lt;code&gt;checkpoint_timeout&lt;/code&gt; configuration variable). Whenever a checkpoint occurs, all dirty pages must be flushed to disk. By increasing &lt;code&gt;max_wal_size&lt;/code&gt; temporarily during bulk data loads, the number of checkpoints that are required can be reduced.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; 구성 변수를 임시로 늘리면 큰 데이터로드가 더 빨라질 수 있습니다. 많은 양의 데이터를 PostgreSQL에로드하면 검사 점이 일반적인 검사 점 빈도 ( &lt;code&gt;checkpoint_timeout&lt;/code&gt; 구성 변수로 지정됨)보다 자주 발생하기 때문 입니다. 검사 점이 발생할 때마다 모든 더티 페이지를 디스크로 플러시해야합니다. 대량 데이터로드 중 일시적으로 &lt;code&gt;max_wal_size&lt;/code&gt; 를 늘리면 필요한 체크 포인트 수를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c40b918a3cfc4101451a319cf4d87a5704133cd3" translate="yes" xml:space="preserve">
          <source>Temporary Tables</source>
          <target state="translated">임시 테이블</target>
        </trans-unit>
        <trans-unit id="99cabd3d50c1576ad73931fee289cdf596ec3a2d" translate="yes" xml:space="preserve">
          <source>Temporary data files used in larger SQL queries for sorts, materializations and intermediate results are not currently checksummed, nor will WAL records be written for changes to those files.</source>
          <target state="translated">정렬, 구체화 및 중간 결과에 대해 더 큰 SQL 쿼리에 사용 된 임시 데이터 파일은 현재 체크섬되지 않으며 해당 파일의 변경에 대한 WAL 레코드도 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3fa93b64d8c91e537f976333a91885a30ea848b" translate="yes" xml:space="preserve">
          <source>Temporary files (for operations such as sorting more data than can fit in memory) are created within &lt;code&gt;PGDATA&lt;/code&gt;&lt;code&gt;/base/pgsql_tmp&lt;/code&gt;, or within a &lt;code&gt;pgsql_tmp&lt;/code&gt; subdirectory of a tablespace directory if a tablespace other than &lt;code&gt;pg_default&lt;/code&gt; is specified for them. The name of a temporary file has the form &lt;code&gt;pgsql_tmpPPP.NNN&lt;/code&gt;, where &lt;code&gt;PPP&lt;/code&gt; is the PID of the owning backend and &lt;code&gt;NNN&lt;/code&gt; distinguishes different temporary files of that backend.</source>
          <target state="translated">&lt;code&gt;pg_default&lt;/code&gt; 이외의 테이블 공간 이 지정된 경우 임시 파일 (메모리에 넣을 수있는 것보다 많은 데이터 정렬과 같은 조작의 경우)은 &lt;code&gt;PGDATA&lt;/code&gt; &lt;code&gt;/base/pgsql_tmp&lt;/code&gt; 또는 테이블 공간 디렉토리 의 &lt;code&gt;pgsql_tmp&lt;/code&gt; 서브 디렉토리 내에 작성 됩니다. 임시 파일의 이름은 &lt;code&gt;pgsql_tmpPPP.NNN&lt;/code&gt; 형식입니다 . 여기서 &lt;code&gt;PPP&lt;/code&gt; 는 소유하는 백엔드의 PID이며 &lt;code&gt;NNN&lt;/code&gt; 은 해당 백엔드의 다른 임시 파일을 구별합니다.</target>
        </trans-unit>
        <trans-unit id="8fc87ee47d688555f67f9d69a8255644efb2bc34" translate="yes" xml:space="preserve">
          <source>Temporary replication slots are created by default if no slot name is given with the option &lt;code&gt;-S&lt;/code&gt; when using log streaming.</source>
          <target state="translated">로그 스트리밍을 사용할 때 &lt;code&gt;-S&lt;/code&gt; 옵션으로 슬롯 이름을 지정하지 않으면 기본적으로 임시 복제 슬롯이 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4ce3ecdd5df11fd4e57e9c9bd6a666859a79d94" translate="yes" xml:space="preserve">
          <source>Temporary table</source>
          <target state="translated">Temporary table</target>
        </trans-unit>
        <trans-unit id="fcf5774683387f1179c61f1c3277a10a51bb0558" translate="yes" xml:space="preserve">
          <source>Temporary tables cannot be accessed by autovacuum. Therefore, appropriate vacuum and analyze operations should be performed via session SQL commands.</source>
          <target state="translated">autovacuum으로 임시 테이블에 액세스 할 수 없습니다. 따라서 세션 SQL 명령을 통해 적절한 진공 및 분석 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3ae55a4b420906da4885f0de2385bf7663c4afd" translate="yes" xml:space="preserve">
          <source>Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/oddmuse/index.cgi/Gin&quot;&gt;http://www.sai.msu.su/~megera/oddmuse/index.cgi/Gin&lt;/a&gt; for additional information.</source>
          <target state="translated">Teodor Sigaev ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt; ) 및 Oleg Bartunov ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ). 자세한 내용은&lt;a href=&quot;http://www.sai.msu.su/~megera/oddmuse/index.cgi/Gin&quot;&gt; http://www.sai.msu.su/~megera/oddmuse/index.cgi/Gin&lt;/a&gt; 을참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="614ca58fa223c605393018818d6ca0983b7dc045" translate="yes" xml:space="preserve">
          <source>Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt;), Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;), Janko Richter (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jankorichter@yahoo.de&quot;&gt;jankorichter@yahoo.de&lt;/a&gt;&amp;gt;&lt;/code&gt;), and Paul Jungwirth (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pj@illuminatedcomputing.com&quot;&gt;pj@illuminatedcomputing.com&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information.</source>
          <target state="translated">Teodor Sigaev ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt; ), Oleg Bartunov ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ), Janko Richter ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jankorichter@yahoo.de&quot;&gt;jankorichter@yahoo.de&lt;/a&gt;&amp;gt;&lt;/code&gt; ) 및 Paul Jungwirth ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pj@illuminatedcomputing.com&quot;&gt;pj@illuminatedcomputing.com&lt;/a&gt;&amp;gt;&lt;/code&gt; ) . 자세한 내용은&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt; http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; 를참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1082fb686407fee18e8e9accad75ec36ff221c79" translate="yes" xml:space="preserve">
          <source>Teodor Sigaev &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@postgrespro.ru&quot;&gt;teodor@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">테오도르 시가 에프 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@postgrespro.ru&quot;&gt;teodor@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Postgres Professional, 모스크바, 러시아</target>
        </trans-unit>
        <trans-unit id="f88b3f62d373869f4686eb8646c5ba681379a32e" translate="yes" xml:space="preserve">
          <source>Teodor Sigaev &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Delta-Soft Ltd., Russia</source>
          <target state="translated">테오도르 시가 에프 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , 모스크바, Delta-Soft Ltd., 러시아</target>
        </trans-unit>
        <trans-unit id="85c83faef031b85db1bcafd781d1666a9772a3a6" translate="yes" xml:space="preserve">
          <source>Teodor Sigaev &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Delta-Soft Ltd.,Russia</source>
          <target state="translated">테오도르 시가 에프 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Moscow, Delta-Soft Ltd., 러시아</target>
        </trans-unit>
        <trans-unit id="40d476fe4615dd56bc1810ee72cb99389bd1638b" translate="yes" xml:space="preserve">
          <source>Terminate a backend. This is also allowed if the calling role is a member of the role whose backend is being terminated or the calling role has been granted &lt;code&gt;pg_signal_backend&lt;/code&gt;, however only superusers can terminate superuser backends.</source>
          <target state="translated">백엔드를 종료하십시오. 호출 역할이 백엔드가 종료되거나 호출 역할이 부여 된 역할의 구성원 인 경우에도 허용됩니다. &lt;code&gt;pg_signal_backend&lt;/code&gt; 되지만 수퍼 유저 만 수퍼 유저 백엔드를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d9be054c06942f0be6cacf9ad5c4c3433ef0cd" translate="yes" xml:space="preserve">
          <source>Terminate any session with an open transaction that has been idle for longer than the specified amount of time. This allows any locks held by that session to be released and the connection slot to be reused; it also allows tuples visible only to this transaction to be vacuumed. See &lt;a href=&quot;routine-vacuuming&quot;&gt;Section 24.1&lt;/a&gt; for more details about this.</source>
          <target state="translated">지정된 시간보다 오래 유휴 상태 인 열린 트랜잭션으로 세션을 종료하십시오. 이를 통해 해당 세션이 보유한 잠금을 해제하고 연결 슬롯을 재사용 할 수 있습니다. 또한이 트랜잭션에서만 볼 수있는 튜플을 정리할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;routine-vacuuming&quot;&gt;24.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7a02c4fa75a0a84b914f755cd7ad30ffe74bfbb" translate="yes" xml:space="preserve">
          <source>Terminate replication connections that are inactive for longer than this amount of time. This is useful for the receiving standby server to detect a primary node crash or network outage. If this value is specified without units, it is taken as milliseconds. The default value is 60 seconds. A value of zero disables the timeout mechanism. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이 시간보다 오래 비활성 상태 인 복제 연결을 종료하십시오. 수신 대기 서버가 기본 노드 충돌 또는 네트워크 중단을 감지하는 데 유용합니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 60 초입니다. 값이 0이면 시간 초과 메커니즘이 비활성화됩니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 .</target>
        </trans-unit>
        <trans-unit id="0916dfcc3ba5084b69509238f11bb3e56039e2bb" translate="yes" xml:space="preserve">
          <source>Terminate replication connections that are inactive for longer than this amount of time. This is useful for the sending server to detect a standby crash or network outage. If this value is specified without units, it is taken as milliseconds. The default value is 60 seconds. A value of zero disables the timeout mechanism.</source>
          <target state="translated">이 시간보다 오래 비활성 상태 인 복제 연결을 종료하십시오. 송신 서버가 대기 충돌 또는 네트워크 중단을 감지하는 데 유용합니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 60 초입니다. 값이 0이면 시간 초과 메커니즘이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="265eef95594c45a4b2c3de0df367e455990f9235" translate="yes" xml:space="preserve">
          <source>Terminates the session whose backend process has the specified process ID. This is also allowed if the calling role is a member of the role whose backend is being terminated or the calling role has been granted &lt;code&gt;pg_signal_backend&lt;/code&gt;, however only superusers can terminate superuser backends.</source>
          <target state="translated">Terminates the session whose backend process has the specified process ID. This is also allowed if the calling role is a member of the role whose backend is being terminated or the calling role has been granted &lt;code&gt;pg_signal_backend&lt;/code&gt; , however only superusers can terminate superuser backends.</target>
        </trans-unit>
        <trans-unit id="9ba35d6113ddb3ce3217803e6e1ea4ae8ab739dc" translate="yes" xml:space="preserve">
          <source>Test for finite date (not +/-infinity)</source>
          <target state="translated">유한 날짜 테스트 (+ / 무한대 아님)</target>
        </trans-unit>
        <trans-unit id="cdbbaec2c44fd8a8e4fbb85583894e6e92d607b6" translate="yes" xml:space="preserve">
          <source>Test for finite interval</source>
          <target state="translated">유한 구간 테스트</target>
        </trans-unit>
        <trans-unit id="d2ef26425b9695a80d987316be138b51b8c6c69e" translate="yes" xml:space="preserve">
          <source>Test for finite interval (currently always true)</source>
          <target state="translated">Test for finite interval (currently always true)</target>
        </trans-unit>
        <trans-unit id="7bdb7052bfa8771b8b0c16cd155fce8273ad5994" translate="yes" xml:space="preserve">
          <source>Test for finite time stamp (not +/-infinity)</source>
          <target state="translated">유한 타임 스탬프 테스트 (+ / 무한대 아님)</target>
        </trans-unit>
        <trans-unit id="accf5eafa60dccfef5983c8434a141a56575cef5" translate="yes" xml:space="preserve">
          <source>Test for finite timestamp (not +/-infinity)</source>
          <target state="translated">Test for finite timestamp (not +/-infinity)</target>
        </trans-unit>
        <trans-unit id="2939dde80f6dd9df09b73ae55dafc8344c2f0e9a" translate="yes" xml:space="preserve">
          <source>Test whether boolean expression yields false or unknown.</source>
          <target state="translated">Test whether boolean expression yields false or unknown.</target>
        </trans-unit>
        <trans-unit id="8d05dc6fc3ae205684277b49ffdf2eff81e71281" translate="yes" xml:space="preserve">
          <source>Test whether boolean expression yields false.</source>
          <target state="translated">Test whether boolean expression yields false.</target>
        </trans-unit>
        <trans-unit id="f4c8fb0cfe436f8269929fb26f66eadfa79e8b80" translate="yes" xml:space="preserve">
          <source>Test whether boolean expression yields true or false.</source>
          <target state="translated">부울 표현식이 참인지 거짓인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="f4b27a0503c55837658fea6a6deda2f33a6c2e80" translate="yes" xml:space="preserve">
          <source>Test whether boolean expression yields true or unknown.</source>
          <target state="translated">부울 표현식이 참인지 알 수 없는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="b1351e022fc1b6545b680779a5c676fb2eff94a4" translate="yes" xml:space="preserve">
          <source>Test whether boolean expression yields true.</source>
          <target state="translated">부울 표현식이 참인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="3639b463f66e1f12a86b636501408365ed301ba7" translate="yes" xml:space="preserve">
          <source>Test whether boolean expression yields unknown.</source>
          <target state="translated">부울 표현식이 알 수 없음을 산출하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="aa19831089b901fca5171c73beb7e77deaae53c0" translate="yes" xml:space="preserve">
          <source>Test whether value is not null (nonstandard syntax).</source>
          <target state="translated">값이 null이 아닌지 테스트합니다 (비표준 구문).</target>
        </trans-unit>
        <trans-unit id="49ec60a7bf60c344b20dcb90c9fcbed434e8bb7e" translate="yes" xml:space="preserve">
          <source>Test whether value is not null.</source>
          <target state="translated">값이 null이 아닌지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0b6116b7838c82903f45a4581262d15055f84322" translate="yes" xml:space="preserve">
          <source>Test whether value is null (nonstandard syntax).</source>
          <target state="translated">값이 null (비표준 구문)인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="a19fafc43a59335f299192c8ea0737a2f44007bb" translate="yes" xml:space="preserve">
          <source>Test whether value is null.</source>
          <target state="translated">값이 null인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="445124b559bc599d91ca24fbc59d02791f8fdd14" translate="yes" xml:space="preserve">
          <source>Testing &lt;em&gt;containment&lt;/em&gt; is an important capability of &lt;code&gt;jsonb&lt;/code&gt;. There is no parallel set of facilities for the &lt;code&gt;json&lt;/code&gt; type. Containment tests whether one &lt;code&gt;jsonb&lt;/code&gt; document has contained within it another one. These examples return true except as noted:</source>
          <target state="translated">테스트 &lt;em&gt;격리&lt;/em&gt; 는 &lt;code&gt;jsonb&lt;/code&gt; 의 중요한 기능입니다 . &lt;code&gt;json&lt;/code&gt; 유형에 대한 병렬 기능 세트가 없습니다 . 포함 은 하나의 &lt;code&gt;jsonb&lt;/code&gt; 문서에 다른 jsonb 문서가 포함되어 있는지 테스트합니다 . 이 예제는 명시된 경우를 제외하고 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="55206ed65929de630ecdd306e29ede23e136df2d" translate="yes" xml:space="preserve">
          <source>Testing and Debugging Text Search</source>
          <target state="translated">텍스트 검색 테스트 및 디버깅</target>
        </trans-unit>
        <trans-unit id="b9adf72b80eb55c8c282b8629f001aad1e38691d" translate="yes" xml:space="preserve">
          <source>Tests whether a Boolean condition is &lt;code&gt;unknown&lt;/code&gt;</source>
          <target state="translated">부울 조건을 &lt;code&gt;unknown&lt;/code&gt; 없는지 테스트</target>
        </trans-unit>
        <trans-unit id="890e48a74c40e972783aaee4b9a6eb2f56d02026" translate="yes" xml:space="preserve">
          <source>Tests whether a Boolean condition is &lt;code&gt;unknown&lt;/code&gt;.</source>
          <target state="translated">부울 조건을 &lt;code&gt;unknown&lt;/code&gt; 없는지 여부를 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="0f2b90b3ef38d55fc55f20750516451be7e841ad" translate="yes" xml:space="preserve">
          <source>Tests whether a path expression matches at least one SQL/JSON item</source>
          <target state="translated">경로 표현식이 하나 이상의 SQL / JSON 항목과 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="84a0e399cf6a9589e1a73a457bb4c8744d865929" translate="yes" xml:space="preserve">
          <source>Tests whether a path expression matches at least one SQL/JSON item. Returns &lt;code&gt;unknown&lt;/code&gt; if the path expression would result in an error; the second example uses this to avoid a no-such-key error in strict mode.</source>
          <target state="translated">경로 표현식이 하나 이상의 SQL / JSON 항목과 일치하는지 여부를 테스트합니다. 경로 표현식에서 오류가 발생하면 &lt;code&gt;unknown&lt;/code&gt; 을 반환 합니다. 두 번째 예제에서는 엄격 모드에서 이러한 키가없는 오류를 방지하기 위해이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d6430dbe50f9f2c73dfc6862277c9ca75a3a3cc4" translate="yes" xml:space="preserve">
          <source>Tests whether an index access method has the named property. Access method properties are listed in &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEXAM-PROPS&quot;&gt;Table 9.71&lt;/a&gt;. &lt;code&gt;NULL&lt;/code&gt; is returned if the property name is not known or does not apply to the particular object, or if the OID does not identify a valid object.</source>
          <target state="translated">인덱스 액세스 방법에 명명 된 속성이 있는지 여부를 테스트합니다. 액세스 방법 속성은 &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEXAM-PROPS&quot;&gt;표 9.71에&lt;/a&gt; 나열되어 있습니다. 속성 이름이 알려지지 않았거나 특정 개체에 적용되지 않거나 OID가 유효한 개체를 식별하지 않는 경우 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="809fbc34e2badac07adc27f5bbdfd9793ac0ac16" translate="yes" xml:space="preserve">
          <source>Tests whether an index column has the named property. Common index column properties are listed in &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEX-COLUMN-PROPS&quot;&gt;Table 9.69&lt;/a&gt;. (Note that extension access methods can define additional property names for their indexes.) &lt;code&gt;NULL&lt;/code&gt; is returned if the property name is not known or does not apply to the particular object, or if the OID or column number does not identify a valid object.</source>
          <target state="translated">인덱스 열에 명명 된 속성이 있는지 여부를 테스트합니다. 일반적인 인덱스 열 속성은 &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEX-COLUMN-PROPS&quot;&gt;표 9.69에&lt;/a&gt; 나열되어 있습니다. (확장 액세스 방법은 인덱스에 대한 추가 속성 이름을 정의 할 수 있습니다.) 속성 이름이 알려지지 않았거나 특정 개체에 적용되지 않거나 OID 또는 열 번호가 유효한 개체를 식별하지 않는 경우 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a8bc77249269e294d5893acfb4e4f6b088dd71" translate="yes" xml:space="preserve">
          <source>Tests whether an index has the named property. Common index properties are listed in &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEX-PROPS&quot;&gt;Table 9.70&lt;/a&gt;. (Note that extension access methods can define additional property names for their indexes.) &lt;code&gt;NULL&lt;/code&gt; is returned if the property name is not known or does not apply to the particular object, or if the OID does not identify a valid object.</source>
          <target state="translated">인덱스에 명명 된 속성이 있는지 여부를 테스트합니다. 일반적인 인덱스 속성은 &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEX-PROPS&quot;&gt;표 9.70에&lt;/a&gt; 나열되어 있습니다. (확장 액세스 방법은 인덱스에 대한 추가 속성 이름을 정의 할 수 있습니다.) 속성 이름이 알려지지 않았거나 특정 개체에 적용되지 않거나 OID가 유효한 개체를 식별하지 않는 경우 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="719d43a21c48df6177727e361f494bf6a959519a" translate="yes" xml:space="preserve">
          <source>Tests whether the addresses belong to the same IP family.</source>
          <target state="translated">주소가 동일한 IP 계열에 속하는지 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="f91ce2567933be56838f71a226b10323b36bb421" translate="yes" xml:space="preserve">
          <source>Tests whether the first operand matches the regular expression given by the second operand, optionally with modifications described by a string of &lt;code&gt;flag&lt;/code&gt; characters (see &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.15.2.2&lt;/a&gt;)</source>
          <target state="translated">첫 번째 피연산자가 두 번째 피연산자가 제공 한 정규식과 일치하는지 여부를 테스트하고 선택적으로 &lt;code&gt;flag&lt;/code&gt; 문자 문자열로 설명 된 수정 사항을 사용 합니다 ( &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;9.15.2.2 절&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="819919c5133618ef201e3cf4f292a32df8e95172" translate="yes" xml:space="preserve">
          <source>Tests whether the first operand matches the regular expression given by the second operand, optionally with modifications described by a string of &lt;code&gt;flag&lt;/code&gt; characters (see &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.16.2.3&lt;/a&gt;).</source>
          <target state="translated">첫 번째 피연산자가 두 번째 피연산자가 제공하는 정규식과 일치하는지 여부를 테스트합니다. 선택적으로 &lt;code&gt;flag&lt;/code&gt; 문자 문자열로 설명 된 수정 사항을 사용 합니다 ( &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;섹션 9.16.2.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e5a6b53359b18dc1dd69e2ba98d514fa3a02af23" translate="yes" xml:space="preserve">
          <source>Tests whether the second operand is an initial substring of the first operand</source>
          <target state="translated">두 번째 피연산자가 첫 번째 피연산자의 초기 하위 문자열인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="8e1e807a8a3e4e24fe312135f988fb8d0d6c4146" translate="yes" xml:space="preserve">
          <source>Tests whether the second operand is an initial substring of the first operand.</source>
          <target state="translated">두 번째 피연산자가 첫 번째 피연산자의 초기 하위 문자열인지 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5af2ecb9710946dd29f669e4693e2cb96f8a2ff9" translate="yes" xml:space="preserve">
          <source>Text Format</source>
          <target state="translated">텍스트 형식</target>
        </trans-unit>
        <trans-unit id="6509408ddc376ae9e654513586320c57ba212535" translate="yes" xml:space="preserve">
          <source>Text Search Functions and Operators</source>
          <target state="translated">텍스트 검색 기능 및 연산자</target>
        </trans-unit>
        <trans-unit id="09a84dcc327ab0da236689c47a632005360e9626" translate="yes" xml:space="preserve">
          <source>Text Search Types</source>
          <target state="translated">텍스트 검색 유형</target>
        </trans-unit>
        <trans-unit id="4f3f5ba9e6b610bfba59369804390ef76e0150c6" translate="yes" xml:space="preserve">
          <source>Text Search Types: tsquery</source>
          <target state="translated">텍스트 검색 유형 : tsquery</target>
        </trans-unit>
        <trans-unit id="ace1dc60019c8ca3bb8f7e545fdea229a2d5e217" translate="yes" xml:space="preserve">
          <source>Text Search Types: tsvector</source>
          <target state="translated">텍스트 검색 유형 : tsvector</target>
        </trans-unit>
        <trans-unit id="f7df0a41fe6e3881c7531b19b48ca62084212826" translate="yes" xml:space="preserve">
          <source>Text Search: !!</source>
          <target state="translated">텍스트 검색 : !!</target>
        </trans-unit>
        <trans-unit id="d2ed51767723f6c081e04db45ff4debd1b419327" translate="yes" xml:space="preserve">
          <source>Text Search: !! &amp;#x27;cat&amp;#x27;::tsquery</source>
          <target state="translated">텍스트 검색 : !! '고양이':: tsquery</target>
        </trans-unit>
        <trans-unit id="bdf301fdea89798cce455c6330167fe9cedff198" translate="yes" xml:space="preserve">
          <source>Text Search: &amp;#x27;cat&amp;#x27;::tsquery &amp;lt;@ &amp;#x27;!cat &amp;amp; rat&amp;#x27;::tsquery</source>
          <target state="translated">텍스트 검색 : 'cat':: tsquery &amp;lt;@ '! cat &amp;amp; rat':: tsquery</target>
        </trans-unit>
        <trans-unit id="90ad5126f2a641e2c73ab209c3a25d6df69f2827" translate="yes" xml:space="preserve">
          <source>Text Search: &amp;#x27;cat&amp;#x27;::tsquery &amp;lt;@ &amp;#x27;cat &amp;amp; rat&amp;#x27;::tsquery</source>
          <target state="translated">텍스트 검색 : 'cat':: tsquery &amp;lt;@ 'cat &amp;amp; rat':: tsquery</target>
        </trans-unit>
        <trans-unit id="c38fe603f2e85e402a1c656e9c1ab1931ae44718" translate="yes" xml:space="preserve">
          <source>Text Search: &amp;#x27;cat&amp;#x27;::tsquery @&amp;gt; &amp;#x27;cat &amp;amp; rat&amp;#x27;::tsquery</source>
          <target state="translated">텍스트 검색 : 'cat':: tsquery @&amp;gt; 'cat &amp;amp; rat':: tsquery</target>
        </trans-unit>
        <trans-unit id="67510ed565570b6fb910ba82c9b7f280221f7c6b" translate="yes" xml:space="preserve">
          <source>Text Search: &amp;#x27;fat cats ate rats&amp;#x27; @@ to_tsquery</source>
          <target state="translated">텍스트 검색 : 'fat cats ate rats'@@ to_tsquery</target>
        </trans-unit>
        <trans-unit id="2bcb1e7523af8335ac13ac2d939334bc9544b8e8" translate="yes" xml:space="preserve">
          <source>Text Search: &amp;#x27;fat | rat&amp;#x27;::tsquery &amp;amp;&amp;amp; &amp;#x27;cat&amp;#x27;::tsquery</source>
          <target state="translated">텍스트 검색 : 'fat | rat ':: tsquery &amp;amp;&amp;amp;'cat ':: tsquery</target>
        </trans-unit>
        <trans-unit id="7dcc7beb8d84ba30021a3ab4f9202b7ec2bb4a32" translate="yes" xml:space="preserve">
          <source>Text Search: &amp;amp;&amp;amp;</source>
          <target state="translated">텍스트 검색 : &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="0d633d5e161e3683b12454ed028be298cbdfeab7" translate="yes" xml:space="preserve">
          <source>Text Search: &amp;lt;-&amp;gt;</source>
          <target state="translated">텍스트 검색 : &amp;lt;-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="34abdfd10686da1f58e85a2231a52db262595bd5" translate="yes" xml:space="preserve">
          <source>Text Search: &amp;lt;@</source>
          <target state="translated">텍스트 검색 : &amp;lt;@</target>
        </trans-unit>
        <trans-unit id="d6b900de9fab3b5d4665e677adc16159f823df05" translate="yes" xml:space="preserve">
          <source>Text Search: @&amp;gt;</source>
          <target state="translated">텍스트 검색 : @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="18653b67b7c3d615259a3f6b03e0a9db634b9bad" translate="yes" xml:space="preserve">
          <source>Text Search: @@</source>
          <target state="translated">텍스트 검색 : @@</target>
        </trans-unit>
        <trans-unit id="3b7e5f8b55c4bb8c25ed217ec49c252923864de7" translate="yes" xml:space="preserve">
          <source>Text Search: @@@</source>
          <target state="translated">텍스트 검색 : @@@</target>
        </trans-unit>
        <trans-unit id="93fd84fccbcda101783791b55b8187dc0ed5d7a0" translate="yes" xml:space="preserve">
          <source>Text Search: SELECT ts_rewrite</source>
          <target state="translated">텍스트 검색 : SELECT ts_rewrite</target>
        </trans-unit>
        <trans-unit id="5273f92a62f114691a0ef3ab23c904ba92c08ca7" translate="yes" xml:space="preserve">
          <source>Text Search: T</source>
          <target state="translated">텍스트 검색 : T</target>
        </trans-unit>
        <trans-unit id="96f6a4b5003d03d2c5e4bca49a6fae66eb9e43e1" translate="yes" xml:space="preserve">
          <source>Text Search: array_to_tsvector</source>
          <target state="translated">텍스트 검색 : array_to_tsvector</target>
        </trans-unit>
        <trans-unit id="193eaeb2812b3700754cec0574846af7e857d324" translate="yes" xml:space="preserve">
          <source>Text Search: get_current_ts_config</source>
          <target state="translated">텍스트 검색 : get_current_ts_config</target>
        </trans-unit>
        <trans-unit id="5036c90d8c5b4db33d0b84599691db5cc5585ef2" translate="yes" xml:space="preserve">
          <source>Text Search: json_to_tsvector</source>
          <target state="translated">텍스트 검색 : json_to_tsvector</target>
        </trans-unit>
        <trans-unit id="c08c6352a19856ee5cf69366c43242726d39a410" translate="yes" xml:space="preserve">
          <source>Text Search: json_to_tsvector, filter json)</source>
          <target state="translated">텍스트 검색 : json_to_tsvector, json 필터)</target>
        </trans-unit>
        <trans-unit id="33846370190b07e748d4d4da9032437930789051" translate="yes" xml:space="preserve">
          <source>Text Search: jsonb_to_tsvector</source>
          <target state="translated">텍스트 검색 : jsonb_to_tsvector</target>
        </trans-unit>
        <trans-unit id="176da00aff26b6d5b4d6fabe3ac6cf3798c07b6e" translate="yes" xml:space="preserve">
          <source>Text Search: length</source>
          <target state="translated">텍스트 검색 : 길이</target>
        </trans-unit>
        <trans-unit id="d32a72537a17443ba2cce02360297677c4f4d991" translate="yes" xml:space="preserve">
          <source>Text Search: numnode</source>
          <target state="translated">텍스트 검색 : numnode</target>
        </trans-unit>
        <trans-unit id="90584c7dcc5dba9c8f9ef09c6dbea2f51f4199e1" translate="yes" xml:space="preserve">
          <source>Text Search: numnode | cat&amp;#x27;::tsquery)</source>
          <target state="translated">텍스트 검색 : numnode | cat ':: tsquery)</target>
        </trans-unit>
        <trans-unit id="4706e75f5ac0d1588a67f848ad7f00059c2d83b3" translate="yes" xml:space="preserve">
          <source>Text Search: phraseto_tsquery</source>
          <target state="translated">텍스트 검색 : phraseto_tsquery</target>
        </trans-unit>
        <trans-unit id="cd0ad6a06f1e36e21213ad232dff3334c0997120" translate="yes" xml:space="preserve">
          <source>Text Search: plainto_tsquery</source>
          <target state="translated">텍스트 검색 : plainto_tsquery</target>
        </trans-unit>
        <trans-unit id="2d856130b3ab297c873448c246b2d285074d315a" translate="yes" xml:space="preserve">
          <source>Text Search: querytree</source>
          <target state="translated">텍스트 검색 : querytree</target>
        </trans-unit>
        <trans-unit id="645a83a26a01c980611292cb2af96872ba7e36e2" translate="yes" xml:space="preserve">
          <source>Text Search: select * from unnest</source>
          <target state="translated">텍스트 검색 : 중첩 해제에서 * 선택</target>
        </trans-unit>
        <trans-unit id="6f4239d92ceb7781e3647a37e2ae75ed5625e33f" translate="yes" xml:space="preserve">
          <source>Text Search: setweight</source>
          <target state="translated">텍스트 검색 : setweight</target>
        </trans-unit>
        <trans-unit id="96e182e3de30f9ee962a1d90f077aaf4dd742c27" translate="yes" xml:space="preserve">
          <source>Text Search: strip</source>
          <target state="translated">텍스트 검색 : strip</target>
        </trans-unit>
        <trans-unit id="ccfac20e3487ee137d540a3c4bdc34e7355ac14a" translate="yes" xml:space="preserve">
          <source>Text Search: to_tsquery</source>
          <target state="translated">텍스트 검색 : to_tsquery</target>
        </trans-unit>
        <trans-unit id="35773bb856523e13d7215e2560302a8985784a52" translate="yes" xml:space="preserve">
          <source>Text Search: to_tsquery &amp;lt;-&amp;gt; to_tsquery</source>
          <target state="translated">텍스트 검색 : to_tsquery &amp;lt;-&amp;gt; to_tsquery</target>
        </trans-unit>
        <trans-unit id="5b4508cc95b9acf23ba68e2ad9fa1ee5cc23f472" translate="yes" xml:space="preserve">
          <source>Text Search: to_tsvector</source>
          <target state="translated">텍스트 검색 : to_tsvector</target>
        </trans-unit>
        <trans-unit id="bb4dd16339fa5f03e32ce753c91e523d6eb23aec" translate="yes" xml:space="preserve">
          <source>Text Search: to_tsvector @@ to_tsquery</source>
          <target state="translated">텍스트 검색 : to_tsvector @@ to_tsquery</target>
        </trans-unit>
        <trans-unit id="075654cae91e3ab947ea8b77477e8b8ee3cc4799" translate="yes" xml:space="preserve">
          <source>Text Search: to_tsvector @@@ to_tsquery</source>
          <target state="translated">텍스트 검색 : to_tsvector @@@ to_tsquery</target>
        </trans-unit>
        <trans-unit id="b19586eeff198dcba8039d82c0c78b52aabc4217" translate="yes" xml:space="preserve">
          <source>Text Search: to_tsvector)</source>
          <target state="translated">텍스트 검색 : to_tsvector)</target>
        </trans-unit>
        <trans-unit id="694d79b108cb262c323003c4afc9cef1ccb98671" translate="yes" xml:space="preserve">
          <source>Text Search: ts_debug</source>
          <target state="translated">텍스트 검색 : ts_debug</target>
        </trans-unit>
        <trans-unit id="bcc23995a523f3caac183feb0ac8c6d54fac6fe4" translate="yes" xml:space="preserve">
          <source>Text Search: ts_delete</source>
          <target state="translated">텍스트 검색 : ts_delete</target>
        </trans-unit>
        <trans-unit id="4e41f026863bbc7e579fd46602df9f2270010cc1" translate="yes" xml:space="preserve">
          <source>Text Search: ts_filter</source>
          <target state="translated">텍스트 검색 : ts_filter</target>
        </trans-unit>
        <trans-unit id="5134d1997c1d30de5b9c728a0f8a4a011ba52437" translate="yes" xml:space="preserve">
          <source>Text Search: ts_headline</source>
          <target state="translated">텍스트 검색 : ts_headline</target>
        </trans-unit>
        <trans-unit id="6c9cdcc266f4cd773eecb07eb2b2dd4705269f81" translate="yes" xml:space="preserve">
          <source>Text Search: ts_headline, query tsquery )</source>
          <target state="translated">텍스트 검색 : ts_headline, query tsquery)</target>
        </trans-unit>
        <trans-unit id="07ce61639b93a1cc4003a4b449f2b08b39f9a05a" translate="yes" xml:space="preserve">
          <source>Text Search: ts_lexize</source>
          <target state="translated">텍스트 검색 : ts_lexize</target>
        </trans-unit>
        <trans-unit id="2750826a3ed4f6bb16f358aed6df1e9aa01b7935" translate="yes" xml:space="preserve">
          <source>Text Search: ts_parse</source>
          <target state="translated">텍스트 검색 : ts_parse</target>
        </trans-unit>
        <trans-unit id="a6999b160dc39dd0eead2ac6d0d94589216be1cd" translate="yes" xml:space="preserve">
          <source>Text Search: ts_rank</source>
          <target state="translated">텍스트 검색 : ts_rank</target>
        </trans-unit>
        <trans-unit id="4cac1edd5b1c665a5c2dfb6d54c268479c85c5b2" translate="yes" xml:space="preserve">
          <source>Text Search: ts_rank, &amp;#x27;cat&amp;#x27;)</source>
          <target state="translated">텍스트 검색 : ts_rank, 'cat')</target>
        </trans-unit>
        <trans-unit id="19446f92f8e2597de8ca3b30ee1cc48452dffa39" translate="yes" xml:space="preserve">
          <source>Text Search: ts_rank_cd</source>
          <target state="translated">텍스트 검색 : ts_rank_cd</target>
        </trans-unit>
        <trans-unit id="fef8e387931f3d619329461b948eb0a2c2172d52" translate="yes" xml:space="preserve">
          <source>Text Search: ts_rank_cd, &amp;#x27;cat&amp;#x27;)</source>
          <target state="translated">텍스트 검색 : ts_rank_cd, 'cat')</target>
        </trans-unit>
        <trans-unit id="abfe60e9923cf50c2f8990c4a8f4e50c1552ac56" translate="yes" xml:space="preserve">
          <source>Text Search: ts_rewrite</source>
          <target state="translated">텍스트 검색 : ts_rewrite</target>
        </trans-unit>
        <trans-unit id="16c34017ff0151e0a478b5d74e7a9b093c786420" translate="yes" xml:space="preserve">
          <source>Text Search: ts_stat</source>
          <target state="translated">텍스트 검색 : ts_stat</target>
        </trans-unit>
        <trans-unit id="78deb0639e3e3d69cbaf3f18b56bf45175c737ad" translate="yes" xml:space="preserve">
          <source>Text Search: ts_token_type</source>
          <target state="translated">텍스트 검색 : ts_token_type</target>
        </trans-unit>
        <trans-unit id="9b944b36345e4dac65010bdde261aed705a982b0" translate="yes" xml:space="preserve">
          <source>Text Search: tsquery_phrase</source>
          <target state="translated">텍스트 검색 : tsquery_phrase</target>
        </trans-unit>
        <trans-unit id="94fd3c7040f485d37b2e324bb6d012e3d4fd7d56" translate="yes" xml:space="preserve">
          <source>Text Search: tsquery_phrase, to_tsquery)</source>
          <target state="translated">텍스트 검색 : tsquery_phrase, to_tsquery)</target>
        </trans-unit>
        <trans-unit id="bd2cda33430e15ba2b3d6a2b2c5b875d674fbebf" translate="yes" xml:space="preserve">
          <source>Text Search: tsquery_phrase, to_tsquery, 10)</source>
          <target state="translated">텍스트 검색 : tsquery_phrase, to_tsquery, 10)</target>
        </trans-unit>
        <trans-unit id="9c7b08a018ec9f7d2c614fe67d3cc6936323752a" translate="yes" xml:space="preserve">
          <source>Text Search: tsvector_to_array</source>
          <target state="translated">텍스트 검색 : tsvector_to_array</target>
        </trans-unit>
        <trans-unit id="0f432a1032fe64cd183420781fc008e329048956" translate="yes" xml:space="preserve">
          <source>Text Search: tsvector_update_trigger</source>
          <target state="translated">텍스트 검색 : tsvector_update_trigger</target>
        </trans-unit>
        <trans-unit id="95c1a10437e84ae8ab4b858b1c993b10005c7da0" translate="yes" xml:space="preserve">
          <source>Text Search: tsvector_update_trigger_column</source>
          <target state="translated">텍스트 검색 : tsvector_update_trigger_column</target>
        </trans-unit>
        <trans-unit id="763baae781c7b26b846d03309aba2a542c67f876" translate="yes" xml:space="preserve">
          <source>Text Search: unnest</source>
          <target state="translated">텍스트 검색 : unnest</target>
        </trans-unit>
        <trans-unit id="29d317cac3562666d0a1ba97a9de4f2e87895446" translate="yes" xml:space="preserve">
          <source>Text Search: websearch_to_tsquery</source>
          <target state="translated">텍스트 검색 : websearch_to_tsquery</target>
        </trans-unit>
        <trans-unit id="2513c24801f33876b45a293652317dc173dc1eaf" translate="yes" xml:space="preserve">
          <source>Text Search: ||</source>
          <target state="translated">텍스트 검색 : ||</target>
        </trans-unit>
        <trans-unit id="eb81ea3c445f5c1813131812c1c1dbed76b96939" translate="yes" xml:space="preserve">
          <source>Text files created by pg_dump are intended to be read in by the psql program. The general command form to restore a dump is</source>
          <target state="translated">pg_dump로 작성된 텍스트 파일은 psql 프로그램에서 읽도록되어 있습니다. 덤프를 복원하는 일반적인 명령 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6118c557f7bc000009d8fb338c20ecce8567ac1a" translate="yes" xml:space="preserve">
          <source>Text of a representative statement</source>
          <target state="translated">대표 성명서</target>
        </trans-unit>
        <trans-unit id="9aa4f9397ef1fa1bf1c4db350c88d43a977e7b64" translate="yes" xml:space="preserve">
          <source>Text of this backend's most recent query</source>
          <target state="translated">이 백엔드의 최신 쿼리 텍스트</target>
        </trans-unit>
        <trans-unit id="25208cfb5d5d77bf082dde84926e0af3c2355ee4" translate="yes" xml:space="preserve">
          <source>Text of this backend's most recent query. If &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;active&lt;/code&gt; this field shows the currently executing query. In all other states, it shows the last query that was executed. By default the query text is truncated at 1024 bytes; this value can be changed via the parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITY-QUERY-SIZE&quot;&gt;track_activity_query_size&lt;/a&gt;.</source>
          <target state="translated">이 백엔드의 가장 최근 쿼리의 텍스트입니다. &lt;code&gt;state&lt;/code&gt; 가 &lt;code&gt;active&lt;/code&gt; 이면 이 필드에는 현재 실행중인 쿼리가 표시됩니다. 다른 모든 상태에서는 실행 된 마지막 쿼리가 표시됩니다. 기본적으로 쿼리 텍스트는 1024 바이트에서 잘립니다. 이 값은 &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITY-QUERY-SIZE&quot;&gt;track_activity_query_size&lt;/a&gt; 매개 변수를 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a0a6a09423c624adfc0ce2a444da0c13ea6dabb" translate="yes" xml:space="preserve">
          <source>Text of this backend's most recent query. If &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;active&lt;/code&gt; this field shows the currently executing query. In all other states, it shows the last query that was executed. By default the query text is truncated at 1024 characters; this value can be changed via the parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITY-QUERY-SIZE&quot;&gt;track_activity_query_size&lt;/a&gt;.</source>
          <target state="translated">이 백엔드의 최신 쿼리 텍스트 &lt;code&gt;state&lt;/code&gt; 가 &lt;code&gt;active&lt;/code&gt; 이면 이 필드는 현재 실행중인 쿼리를 표시합니다. 다른 모든 상태에서는 마지막으로 실행 된 쿼리가 표시됩니다. 기본적으로 쿼리 텍스트는 1024 자로 잘립니다. 이 값은 &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITY-QUERY-SIZE&quot;&gt;track_activity_query_size&lt;/a&gt; 매개 변수를 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b459859c6dfee5d5d8eb44f5ea13959102568983" translate="yes" xml:space="preserve">
          <source>Text search configuration name</source>
          <target state="translated">텍스트 검색 구성 이름</target>
        </trans-unit>
        <trans-unit id="8ec1710d0551a61fb26e76b458f5d15a8e9300fc" translate="yes" xml:space="preserve">
          <source>Text search dictionary name</source>
          <target state="translated">텍스트 검색 사전 이름</target>
        </trans-unit>
        <trans-unit id="02931a8dc1cbcecf3b9caf406df7be9fe6cba819" translate="yes" xml:space="preserve">
          <source>Text search parser name</source>
          <target state="translated">텍스트 검색 파서 이름</target>
        </trans-unit>
        <trans-unit id="9b71c0f4d3f48cbada2f53abc14c6823ab537e29" translate="yes" xml:space="preserve">
          <source>Text search parsers and templates are built from low-level C functions; therefore it requires C programming ability to develop new ones, and superuser privileges to install one into a database. (There are examples of add-on parsers and templates in the &lt;code&gt;contrib/&lt;/code&gt; area of the PostgreSQL distribution.) Since dictionaries and configurations just parameterize and connect together some underlying parsers and templates, no special privilege is needed to create a new dictionary or configuration. Examples of creating custom dictionaries and configurations appear later in this chapter.</source>
          <target state="translated">텍스트 검색 파서 및 템플릿은 저수준 C 함수로 구축됩니다. 따라서 새로운 것을 개발하기 위해서는 C 프로그래밍 능력과 데이터베이스에 설치할 수있는 슈퍼 유저 권한이 필요합니다. ( PostgreSQL 배포 의 &lt;code&gt;contrib/&lt;/code&gt; 영역 에는 애드온 파서 및 템플릿의 예가 있습니다 .) 사전 및 구성은 일부 기본 파서 및 템플릿을 매개 변수화하고 함께 연결하기 때문에 새로운 사전 또는 구성을 생성하는 데 특별한 권한이 필요하지 않습니다. 사용자 정의 사전 및 구성 작성의 예는이 장의 후반에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="95c083c8f57d3371e5998cf4bd62735fbecf7e8b" translate="yes" xml:space="preserve">
          <source>Text search parsers are responsible for splitting raw document text into &lt;em&gt;tokens&lt;/em&gt; and identifying each token's type, where the set of possible types is defined by the parser itself. Note that a parser does not modify the text at all &amp;mdash; it simply identifies plausible word boundaries. Because of this limited scope, there is less need for application-specific custom parsers than there is for custom dictionaries. At present PostgreSQL provides just one built-in parser, which has been found to be useful for a wide range of applications.</source>
          <target state="translated">텍스트 검색 파서는 원시 문서 텍스트를 &lt;em&gt;토큰&lt;/em&gt; 으로 분할 하고 각 토큰 유형을 식별하는 역할을하며, 여기서 가능한 유형 세트는 구문 분석기 자체에 의해 정의됩니다. 파서는 텍스트를 전혀 수정하지 않으며 단지 그럴듯한 단어 경계를 식별합니다. 이 제한된 범위로 인해 사용자 지정 사전보다 응용 프로그램 별 사용자 지정 파서가 덜 필요합니다. 현재 PostgreSQL은 하나의 내장 파서를 제공하며, 이는 광범위한 응용 프로그램에 유용한 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="31e4cd3673c9fcbc17219dee97ccb4c37debfd2c" translate="yes" xml:space="preserve">
          <source>Text search template name</source>
          <target state="translated">텍스트 검색 템플릿 이름</target>
        </trans-unit>
        <trans-unit id="de8e2c968a85099bcb023fe16bec7716271343f5" translate="yes" xml:space="preserve">
          <source>Text similarity using trigram matching</source>
          <target state="translated">트라이 그램 일치를 사용한 텍스트 유사성</target>
        </trans-unit>
        <trans-unit id="2625084429ff534ed984d871ad53eb943f796d88" translate="yes" xml:space="preserve">
          <source>Textual search operators have existed in databases for years. PostgreSQL has &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;~*&lt;/code&gt;, &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;ILIKE&lt;/code&gt; operators for textual data types, but they lack many essential properties required by modern information systems:</source>
          <target state="translated">텍스트 검색 연산자는 수년간 데이터베이스에 존재했습니다. PostgreSQL에는 텍스트 데이터 형식에 대한 &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;~*&lt;/code&gt; , &lt;code&gt;LIKE&lt;/code&gt; 및 &lt;code&gt;ILIKE&lt;/code&gt; 연산자가 있지만 최신 정보 시스템에 필요한 많은 필수 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c32767e0541fe7038ff8d87e7b8aed17f49474f8" translate="yes" xml:space="preserve">
          <source>Thai</source>
          <target state="translated">Thai</target>
        </trans-unit>
        <trans-unit id="7de93f5a276e3908933588d846e0c9e7fdac70f8" translate="yes" xml:space="preserve">
          <source>That constraint will prevent any overlapping values from existing in the table at the same time:</source>
          <target state="translated">이 제약 조건으로 인해 테이블에 겹치는 값이 동시에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faab194ef826baca22c25bee165a44d9807156a4" translate="yes" xml:space="preserve">
          <source>That didn't work either, because now the RE as a whole is non-greedy and so it ends the overall match as soon as possible. We can get what we want by forcing the RE as a whole to be greedy:</source>
          <target state="translated">RE 전체가 욕심이 없기 때문에 가능한 빨리 전체 경기를 끝내기 때문에 그것은 효과가 없었습니다. RE를 전체적으로 탐욕스럽게 만들면 원하는 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52a22e389661a6740133d4e4ad2d3dc74d62fa65" translate="yes" xml:space="preserve">
          <source>That didn't work: the first &lt;code&gt;.*&lt;/code&gt; is greedy so it &amp;ldquo;eats&amp;rdquo; as much as it can, leaving the &lt;code&gt;\d+&lt;/code&gt; to match at the last possible place, the last digit. We might try to fix that by making it non-greedy:</source>
          <target state="translated">그것은 작동하지 않았다 : 첫 번째 &lt;code&gt;.*&lt;/code&gt; 는 탐욕 스럽기 때문에 가능한 한 많이 먹으며 &lt;code&gt;\d+&lt;/code&gt; 는 마지막 자리, 마지막 자리에 일치시킵니다. 우리는 그것을 탐욕스럽지 않게 만들어서 고칠 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cf0d8f0d8bd02f4cabd6683555281783d3c10f0b" translate="yes" xml:space="preserve">
          <source>That is, add up all the frequencies for the MCVs and subtract them from one, then divide by the number of &lt;em&gt;other&lt;/em&gt; distinct values. This amounts to assuming that the fraction of the column that is not any of the MCVs is evenly distributed among all the other distinct values. Notice that there are no null values so we don't have to worry about those (otherwise we'd subtract the null fraction from the numerator as well). The estimated number of rows is then calculated as usual:</source>
          <target state="translated">즉, MCV의 모든 주파수를 합산하여 하나에서 빼고 &lt;em&gt;다른&lt;/em&gt; 고유 값 의 수로 나눕니다 . 이는 MCV가 아닌 컬럼의 비율이 다른 모든 고유 값 사이에 균등하게 분포되어 있다고 가정합니다. null 값이 없으므로 걱정할 필요가 없습니다 (그렇지 않으면 분자에서 null 분수를 뺍니다). 그런 다음 예상 행 수는 평소와 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="46ddb2a2b82cbcf6203c6dd1f8422c623a6c806a" translate="yes" xml:space="preserve">
          <source>That looks safe; there is no window wherein &lt;code&gt;mallory&lt;/code&gt; should be able to see the &amp;ldquo;secret from mallory&amp;rdquo; string. However, there is a race condition here. If &lt;code&gt;mallory&lt;/code&gt; is concurrently doing, say,</source>
          <target state="translated">안전 해 보입니다. 특징에는 윈도우가없는 &lt;code&gt;mallory&lt;/code&gt; 문자열 &quot;말로리의 비밀&quot;을 볼 수 있어야합니다은. 그러나 여기에는 경쟁 조건이 있습니다. &lt;code&gt;mallory&lt;/code&gt; 가 동시에하고 있다면</target>
        </trans-unit>
        <trans-unit id="8d1c394f9c1c71c8b5f650e6551afe32e569cf65" translate="yes" xml:space="preserve">
          <source>That query is actually transformed by the parser to:</source>
          <target state="translated">이 쿼리는 실제로 파서에 의해 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3e6b2da87a127000d8da1305187b0960b53695" translate="yes" xml:space="preserve">
          <source>That will cause all existing rows in the table to be filled with null values for the new column.</source>
          <target state="translated">그러면 테이블의 모든 기존 행이 새 열에 대한 null 값으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="8c544579b955943216f2982dee933d3718490075" translate="yes" xml:space="preserve">
          <source>That would mean you are a database superuser, which is most likely the case if you installed the PostgreSQL instance yourself. Being a superuser means that you are not subject to access controls. For the purposes of this tutorial that is not important.</source>
          <target state="translated">이는 데이터베이스 수퍼 유저임을 의미하며 PostgreSQL 인스턴스를 직접 설치 한 경우에 해당됩니다. 수퍼 유저는 액세스 제어 대상이 아님을 의미합니다. 이 자습서에서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4685fb204c9b08a966e0970a1a589c17579eff01" translate="yes" xml:space="preserve">
          <source>That's because per-schema default privileges can only add privileges to the global setting, not remove privileges granted by it.</source>
          <target state="translated">스키마 별 기본 권한은 전역 설정에만 권한을 추가 할 수 있으며 부여 된 권한은 제거 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c6b3f6df803793db61a7f4f009af2325633e5344" translate="yes" xml:space="preserve">
          <source>That's it &amp;mdash; now you can query your log directly. In production, of course, you would need to define some way to deal with log rotation.</source>
          <target state="translated">이제 로그를 직접 쿼리 할 수 ​​있습니다. 물론 프로덕션에서는 로그 회전을 처리 할 방법을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="214a0563af5e2bb2b039815fa4094c3eceb7d916" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Identification Protocol&amp;rdquo; is described in RFC 1413. Virtually every Unix-like operating system ships with an ident server that listens on TCP port 113 by default. The basic functionality of an ident server is to answer questions like &amp;ldquo;What user initiated the connection that goes out of your port &lt;code&gt;X&lt;/code&gt; and connects to my port &lt;code&gt;Y&lt;/code&gt;?&amp;rdquo;. Since PostgreSQL knows both &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; when a physical connection is established, it can interrogate the ident server on the host of the connecting client and can theoretically determine the operating system user for any given connection.</source>
          <target state="translated">&amp;ldquo;식별 프로토콜&amp;rdquo;은 RFC 1413에 설명되어 있습니다. 사실상 모든 유닉스 계열 운영 체제는 기본적으로 TCP 포트 113을 수신하는 ID 서버와 함께 제공됩니다. ident 서버의 기본 기능은&amp;ldquo;어떤 사용자가 포트 &lt;code&gt;X&lt;/code&gt; 에서 나가 포트 &lt;code&gt;Y&lt;/code&gt; 에 연결하는 연결을 시작 했습니까?&amp;rdquo; 와 같은 질문에 대답하는 것입니다 . 물리적 연결이 설정되면 PostgreSQL은 &lt;code&gt;X&lt;/code&gt; 와 &lt;code&gt;Y&lt;/code&gt; 를 모두 알고 있으므로 연결 클라이언트의 호스트에서 ID 서버를 조사 할 수 있으며 이론적으로 주어진 연결에 대한 운영 체제 사용자를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f7b6f0c96644cf05b9e7ecaf27714bacadfef3" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;autovacuum daemon&amp;rdquo; actually consists of multiple processes. There is a persistent daemon process, called the &lt;em&gt;autovacuum launcher&lt;/em&gt;, which is in charge of starting &lt;em&gt;autovacuum worker&lt;/em&gt; processes for all databases. The launcher will distribute the work across time, attempting to start one worker within each database every &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-NAPTIME&quot;&gt;autovacuum_naptime&lt;/a&gt; seconds. (Therefore, if the installation has &lt;code&gt;N&lt;/code&gt; databases, a new worker will be launched every &lt;code&gt;autovacuum_naptime&lt;/code&gt;/&lt;code&gt;N&lt;/code&gt; seconds.) A maximum of &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; worker processes are allowed to run at the same time. If there are more than &lt;code&gt;autovacuum_max_workers&lt;/code&gt; databases to be processed, the next database will be processed as soon as the first worker finishes. Each worker process will check each table within its database and execute &lt;code&gt;VACUUM&lt;/code&gt; and/or &lt;code&gt;ANALYZE&lt;/code&gt; as needed. &lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt; can be set to monitor autovacuum workers' activity.</source>
          <target state="translated">&amp;ldquo;autovacuum 데몬&amp;rdquo;은 실제로 여러 프로세스로 구성됩니다. 모든 데이터베이스에 대해 &lt;em&gt;autovacuum 작업자&lt;/em&gt; 프로세스 시작을 담당 하는 &lt;em&gt;autovacuum launcher&lt;/em&gt; 라고하는 영구 디먼 프로세스 가 있습니다. 런처는 시간이 지남에 따라 작업을 분배하여 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-NAPTIME&quot;&gt;autovacuum_naptime&lt;/a&gt; 초 마다 각 데이터베이스에서 한 명의 작업자를 시작하려고 시도합니다 . (따라서 설치에 &lt;code&gt;N&lt;/code&gt; 개의 데이터베이스가있는 경우 &lt;code&gt;autovacuum_naptime&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; 초 마다 새 작업자가 시작됩니다 .) 최대 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; 작업자 프로세스가 동시에 실행될 수 있습니다. &lt;code&gt;autovacuum_max_workers&lt;/code&gt; 보다 많은 경우&lt;em&gt;&lt;/em&gt;처리 할 데이터베이스의 경우 첫 번째 작업자가 완료되는 즉시 다음 데이터베이스가 처리됩니다. 각 작업자 프로세스는 데이터베이스 내의 각 테이블을 확인 하고 필요에 따라 &lt;code&gt;VACUUM&lt;/code&gt; 및 / 또는 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행합니다. autovacuum 작업자의 활동을 모니터링하도록 &lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt; 을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e3b42f598f775e409231001c9d7523815d127a" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;branch&amp;rdquo; output column shows the path of keys taken to reach the current row. The keys are separated by the specified &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; string. If no branch display is wanted, omit both the &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; parameter and the branch column in the output column list.</source>
          <target state="translated">&quot;분기&quot;출력 열은 현재 행에 도달하기 위해 취한 키의 경로를 보여줍니다. 키는 지정된 &lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt; 문자열 로 구분됩니다 . 분기 표시를 원하지 않으면 출력 열 목록에서 &lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt; 매개 변수와 분기 열을 모두 생략 하십시오.</target>
        </trans-unit>
        <trans-unit id="7976724c528d95f857de531a1a64cc3f2ed2ee15" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;escape&amp;rdquo; format is the traditional PostgreSQL format for the &lt;code&gt;bytea&lt;/code&gt; type. It takes the approach of representing a binary string as a sequence of ASCII characters, while converting those bytes that cannot be represented as an ASCII character into special escape sequences. If, from the point of view of the application, representing bytes as characters makes sense, then this representation can be convenient. But in practice it is usually confusing because it fuzzes up the distinction between binary strings and character strings, and also the particular escape mechanism that was chosen is somewhat unwieldy. Therefore, this format should probably be avoided for most new applications.</source>
          <target state="translated">&quot;탈출&quot;형식은 &lt;code&gt;bytea&lt;/code&gt; 유형 의 기존 PostgreSQL 형식입니다 . ASCII 문자로 표현할 수없는 바이트를 특수 이스케이프 시퀀스로 변환하는 동안 이진 문자열을 ASCII 문자 시퀀스로 표시하는 방식이 사용됩니다. 응용 프로그램의 관점에서 바이트를 문자로 나타내는 것이 이치에 맞으면이 표현이 편리 할 수 ​​있습니다. 그러나 실제로는 이진 문자열과 문자열 사이의 구별을 혼란스럽게하기 때문에 일반적으로 혼란 스럽습니다. 또한 선택된 특정 이스케이프 메커니즘은 다소 다루기 어렵습니다. 따라서 대부분의 새 응용 프로그램에서는이 형식을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="affb2b0b14e11a3cd2e0c9f61bf2e82200f35468" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;hex&amp;rdquo; format encodes binary data as 2 hexadecimal digits per byte, most significant nibble first. The entire string is preceded by the sequence &lt;code&gt;\x&lt;/code&gt; (to distinguish it from the escape format). In some contexts, the initial backslash may need to be escaped by doubling it (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;). For input, the hexadecimal digits can be either upper or lower case, and whitespace is permitted between digit pairs (but not within a digit pair nor in the starting &lt;code&gt;\x&lt;/code&gt; sequence). The hex format is compatible with a wide range of external applications and protocols, and it tends to be faster to convert than the escape format, so its use is preferred.</source>
          <target state="translated">&quot;16 진수&quot;형식은 이진 데이터를 바이트 당 2 개의 16 진수로 인코딩하며 가장 중요한 니블을 먼저 사용합니다. 이스케이프 형식과 구별하기 위해 전체 문자열 앞에 &lt;code&gt;\x&lt;/code&gt; 시퀀스가옵니다 . 일부 상황에서는 초기 백 슬래시를 두 배로 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;늘려야&lt;/a&gt; 할 수도 있습니다 ( 4.1.2.1 단원 참조 ). 입력의 경우, 16 진 숫자는 대문자 또는 소문자 일 수 있으며 숫자 쌍 사이에 공백이 허용됩니다 (단, 숫자 쌍 내 또는 시작 &lt;code&gt;\x&lt;/code&gt; 순서 는 허용되지 않음 ). 16 진 형식은 광범위한 외부 응용 프로그램 및 프로토콜과 호환되며 이스케이프 형식보다 변환 속도가 빠르기 때문에 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c1e7f0d609d4c2cb72dd50b76f7d434b4ee42696" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;payload&amp;rdquo; string to be communicated along with the notification. This must be specified as a simple string literal. In the default configuration it must be shorter than 8000 bytes. (If binary data or large amounts of information need to be communicated, it's best to put it in a database table and send the key of the record.)</source>
          <target state="translated">알림과 함께 통신 할 &quot;페이로드&quot;문자열 간단한 문자열 리터럴로 지정해야합니다. 기본 구성에서는 8000 바이트보다 짧아야합니다. (이진 데이터 또는 많은 양의 정보를 전달해야하는 경우 데이터베이스 테이블에 저장하고 레코드 키를 보내는 것이 가장 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="f749de0758a44991d9f41367ef0c9c5379f17608" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;start-up cost&amp;rdquo; is the part of the total scan cost that must be expended before we can begin to fetch the first row. For most indexes this can be taken as zero, but an index type with a high start-up cost might want to set it nonzero.</source>
          <target state="translated">&quot;시작 비용&quot;은 첫 번째 행을 가져 오기 전에 소비해야하는 총 스캔 비용의 일부입니다. 대부분의 인덱스의 경우이 값을 0으로 지정할 수 있지만 시작 비용이 높은 인덱스 유형은 0이 아닌 값을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6eb4561e4b487f0013b8095b316b5bf43f4d7dd" translate="yes" xml:space="preserve">
          <source>The (possibly schema-qualified) name of another table referenced by the constraint. This option is used for foreign-key constraints and is not recommended for general use. This can only be specified for constraint triggers.</source>
          <target state="translated">제한 조건이 참조하는 다른 테이블의 이름 (아마도 스키마 규정 된) 이름입니다. 이 옵션은 외래 키 제약 조건에 사용되며 일반적인 용도로는 권장되지 않습니다. 구속 조건 트리거에 대해서만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83f3f02a7f9ae14fe518a481b342195ce7d604c0" translate="yes" xml:space="preserve">
          <source>The (unqualified) name to be used within the trigger for this transition relation.</source>
          <target state="translated">이 전이 관계에 대한 트리거 내에서 사용되는 규정되지 않은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9bba84ac2eaf3595ab5595b6173e241f93e943c0" translate="yes" xml:space="preserve">
          <source>The 1-million-transaction safety margin exists to let the administrator recover without data loss, by manually executing the required &lt;code&gt;VACUUM&lt;/code&gt; commands. However, since the system will not execute commands once it has gone into the safety shutdown mode, the only way to do this is to stop the server and start the server in single-user mode to execute &lt;code&gt;VACUUM&lt;/code&gt;. The shutdown mode is not enforced in single-user mode. See the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page for details about using single-user mode.</source>
          <target state="translated">필요한 &lt;code&gt;VACUUM&lt;/code&gt; 명령 을 수동으로 실행하여 관리자가 데이터 손실없이 복구 할 수 있도록 1 백만 개의 트랜잭션 안전 여유가 존재 합니다. 그러나 시스템이 안전 종료 모드로 전환되면 명령이 실행되지 않으므로이를 수행 할 수있는 유일한 방법은 서버를 중지하고 단일 사용자 모드에서 서버를 시작하여 &lt;code&gt;VACUUM&lt;/code&gt; 을 실행하는 것 입니다. 단일 사용자 모드에서는 종료 모드가 적용되지 않습니다. 단일 사용자 모드 사용에 대한 자세한 내용은 &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="11a8ccd22a090ad617ccbc158ae498802713ee14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; program provides a convenient interface for sending these signals to shut down the server. Alternatively, you can send the signal directly using &lt;code&gt;kill&lt;/code&gt; on non-Windows systems. The PID of the &lt;code&gt;postgres&lt;/code&gt; process can be found using the &lt;code&gt;ps&lt;/code&gt; program, or from the file &lt;code&gt;postmaster.pid&lt;/code&gt; in the data directory. For example, to do a fast shutdown:</source>
          <target state="translated">&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl의&lt;/a&gt; 프로그램은 서버를 종료하기 위해 이러한 신호를 보내기위한 편리한 인터페이스를 제공합니다. 또는 Windows 이외의 시스템에서 &lt;code&gt;kill&lt;/code&gt; 을 사용하여 신호를 직접 보낼 수 있습니다. &lt;code&gt;postgres&lt;/code&gt; 프로세스 의 PID는 &lt;code&gt;ps&lt;/code&gt; 프로그램을 사용하거나 데이터 디렉토리의 &lt;code&gt;postmaster.pid&lt;/code&gt; 파일에서 찾을 수 있습니다 . 예를 들어, 빠른 종료를 수행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b47733fda252867c3633ae8aed603546f6a06da8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; program's &lt;code&gt;\db&lt;/code&gt; meta-command is also useful for listing the existing tablespaces.</source>
          <target state="translated">&lt;a href=&quot;app-psql&quot;&gt;psql의의&lt;/a&gt; 프로그램의 &lt;code&gt;\db&lt;/code&gt; 메타 명령은 기존의 테이블을 나열하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="144511389e293a310e49e5f366abbd74aec19a42" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; program's &lt;code&gt;\du&lt;/code&gt; meta-command is also useful for listing the existing roles.</source>
          <target state="translated">&lt;a href=&quot;app-psql&quot;&gt;psql의의&lt;/a&gt; 프로그램의 &lt;code&gt;\du&lt;/code&gt; 메타 명령은 기존 역할을 나열하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="041f95f3db1d27435b39d161c2c343347cf2ceb3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; program's &lt;code&gt;\l&lt;/code&gt; meta-command and &lt;code&gt;-l&lt;/code&gt; command-line option are also useful for listing the existing databases.</source>
          <target state="translated">&lt;a href=&quot;app-psql&quot;&gt;psql의의&lt;/a&gt; 프로그램의 &lt;code&gt;\l&lt;/code&gt; 메타 명령과 &lt;code&gt;-l&lt;/code&gt; 명령 줄 옵션은 기존의 데이터베이스를 나열하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c0ea16378e5b904cb3e7c0a0f131af5d9f9cb6cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension has a cast from &lt;code&gt;hstore&lt;/code&gt; to &lt;code&gt;json&lt;/code&gt;, so that &lt;code&gt;hstore&lt;/code&gt; values converted via the JSON creation functions will be represented as JSON objects, not as primitive string values.</source>
          <target state="translated">&lt;a href=&quot;hstore&quot;&gt;hstore의&lt;/a&gt; 확장에서 던지 &lt;code&gt;hstore&lt;/code&gt; 에 &lt;code&gt;json&lt;/code&gt; 되도록, &lt;code&gt;hstore&lt;/code&gt; 의 값 JSON하지 프리미티브 문자열 값으로, 객체로서 표현 될 JSON 생성 함수로 변환된다.</target>
        </trans-unit>
        <trans-unit id="f27bdc97580489cfaa7d8d800b925e51bf0ef0ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-function.html&quot;&gt;dblink&lt;/a&gt; function (part of the &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module) executes a remote query. It is declared to return &lt;code&gt;record&lt;/code&gt; since it might be used for any kind of query. The actual column set must be specified in the calling query so that the parser knows, for example, what &lt;code&gt;*&lt;/code&gt; should expand to.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-function.html&quot;&gt;DBLINK의&lt;/a&gt; 함수 (의 일부 &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;DBLINK의&lt;/a&gt; 모듈)은 원격 쿼리를 실행한다. 모든 종류의 쿼리에 사용될 수 있으므로 &lt;code&gt;record&lt;/code&gt; 를 반환하도록 선언됩니다 . 실제 열 세트는 구문 분석기가 예를 들어 &lt;code&gt;*&lt;/code&gt; 확장 대상을 알 수 있도록 호출 쿼리에 지정 해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb4492c1bf4ecbc4c154632b803129ad54ccb73e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib-dblink-function.html&quot;&gt;dblink&lt;/a&gt; function (part of the &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module) executes a remote query. It is declared to return &lt;code&gt;record&lt;/code&gt; since it might be used for any kind of query. The actual column set must be specified in the calling query so that the parser knows, for example, what &lt;code&gt;*&lt;/code&gt; should expand to.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/contrib-dblink-function.html&quot;&gt;DBLINK의&lt;/a&gt; 함수 (의 일부 &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;DBLINK의&lt;/a&gt; 모듈)은 원격 쿼리를 실행한다. 모든 종류의 쿼리에 사용할 수 있으므로 &lt;code&gt;record&lt;/code&gt; 를 반환하도록 선언됩니다 . 파서가 예를 들어 &lt;code&gt;*&lt;/code&gt; 를 확장해야하는 항목 을 알 수 있도록 실제 열 집합을 호출 쿼리에 지정 해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fcca203d628312f10551e54654efafdbfa7e32c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module allows certain fields to be stored encrypted. This is useful if only some of the data is sensitive. The client supplies the decryption key and the data is decrypted on the server and then sent to the client.</source>
          <target state="translated">&lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto의&lt;/a&gt; 모듈은 특정 필드는 암호화되어 저장되도록한다. 일부 데이터 만 민감한 경우에 유용합니다. 클라이언트는 암호 해독 키를 제공하고 데이터는 서버에서 암호 해독 된 다음 클라이언트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8b76198028841bbdfd82b872f404aff5561c3fc8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade&lt;/a&gt; module allows an installation to be migrated in-place from one major PostgreSQL version to another. Upgrades can be performed in minutes, particularly with &lt;code&gt;--link&lt;/code&gt; mode. It requires steps similar to pg_dumpall above, e.g. starting/stopping the server, running initdb. The pg_upgrade &lt;a href=&quot;pgupgrade&quot;&gt;documentation&lt;/a&gt; outlines the necessary steps.</source>
          <target state="translated">&lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade의&lt;/a&gt; 모듈 설치 한 주요 PostgreSQL의 버젼에서 다른 장소로 이주 할 수있다. 특히 &lt;code&gt;--link&lt;/code&gt; 모드를 사용 하면 몇 분 안에 업그레이드를 수행 할 수 있습니다 . 위의 pg_dumpall과 유사한 단계 (예 : 서버 시작 / 중지, initdb 실행)가 필요합니다. pg_upgrade &lt;a href=&quot;pgupgrade&quot;&gt;문서&lt;/a&gt; 는 필요한 단계를 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b9aff4e3382c737b51a377a1d4368abea46f4beb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade&lt;/a&gt; module allows an installation to be migrated in-place from one major PostgreSQL version to another. Upgrades can be performed in minutes, particularly with &lt;code&gt;--link&lt;/code&gt; mode. It requires steps similar to pg_dumpall above, e.g., starting/stopping the server, running initdb. The pg_upgrade &lt;a href=&quot;pgupgrade&quot;&gt;documentation&lt;/a&gt; outlines the necessary steps.</source>
          <target state="translated">&lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade의&lt;/a&gt; 모듈 설치 한 주요 PostgreSQL의 버젼에서 다른 장소로 이주 할 수있다. 특히 &lt;code&gt;--link&lt;/code&gt; 모드를 사용 하면 몇 분 만에 업그레이드를 수행 할 수 있습니다 . 위의 pg_dumpall과 유사한 단계가 필요합니다 (예 : 서버 시작 / 중지, initdb 실행). pg_upgrade &lt;a href=&quot;pgupgrade&quot;&gt;문서&lt;/a&gt; 는 필요한 단계를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="99161f2083b5230429b584eae782995b02d5d7b5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pgvisibility&quot;&gt;pg_visibility&lt;/a&gt; module can be used to examine the information stored in the visibility map.</source>
          <target state="translated">&lt;a href=&quot;pgvisibility&quot;&gt;pg_visibility의&lt;/a&gt; 모듈은 가시성 맵에 저장된 정보를 검사하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a5b080701c78727c19ae01f8d0f7ddf7baf2b5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum daemon&lt;/a&gt; cannot access and therefore cannot vacuum or analyze temporary tables. For this reason, appropriate vacuum and analyze operations should be performed via session SQL commands. For example, if a temporary table is going to be used in complex queries, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on the temporary table after it is populated.</source>
          <target state="translated">&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;자동 진공 데몬&lt;/a&gt; 에 액세스 할 수 없습니다, 따라서 진공 또는 임시 테이블을 분석 할 수 없습니다. 따라서 세션 SQL 명령을 통해 적절한 진공 및 분석 작업을 수행해야합니다. 예를 들어 임시 테이블을 복잡한 쿼리에 사용 하려는 경우 채워진 후에 임시 테이블 에서 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9613432b17ace5faf7f65dc7e21e1d2b7d892803" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; configuration parameter can be set in the file &lt;code&gt;postgresql.conf&lt;/code&gt;, or in any of the other standard ways described in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. There are also some special ways to set it:</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;시간대의&lt;/a&gt; 구성 매개 변수 파일에 설정 될 수 &lt;code&gt;postgresql.conf&lt;/code&gt; , 또는 다른 표준 방법으로 설명 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;제 19 장&lt;/a&gt; . 그것을 설정하는 몇 가지 특별한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="974c08886ef2693da953e2b07327383026c16807" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; configuration parameter can be set in the file &lt;code&gt;postgresql.conf&lt;/code&gt;, or in any of the other standard ways described in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. There are also some special ways to set it:</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;시간대의&lt;/a&gt; 구성 매개 변수 파일에 설정 될 수 &lt;code&gt;postgresql.conf&lt;/code&gt; , 또는 다른 표준 방법으로 설명 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;제 19 장&lt;/a&gt; . 이를 설정하는 몇 가지 특별한 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c88a560f10b3c50ec7287bdd7cb6641bec4b949f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; is only invoked for completed WAL segments. Hence, if your server generates little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To limit how old unarchived data can be, you can set &lt;code&gt;archive_timeout&lt;/code&gt; to force the server to switch to a new WAL segment file periodically. When this parameter is greater than zero, the server will switch to a new segment file whenever this amount of time has elapsed since the last segment file switch, and there has been any database activity, including a single checkpoint (checkpoints are skipped if there is no database activity). Note that archived files that are closed early due to a forced switch are still the same length as completely full files. Therefore, it is unwise to use a very short &lt;code&gt;archive_timeout&lt;/code&gt; &amp;mdash; it will bloat your archive storage. &lt;code&gt;archive_timeout&lt;/code&gt; settings of a minute or so are usually reasonable. You should consider using streaming replication, instead of archiving, if you want data to be copied off the master server more quickly than that. If this value is specified without units, it is taken as seconds. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command는&lt;/a&gt; 완벽한 한 WAL 세그먼트에 대해 호출됩니다. 따라서 서버에서 WAL 트래픽이 거의 발생하지 않거나 시간이 오래 걸리면 트랜잭션 완료와 보관 저장소의 안전한 기록간에 시간이 오래 걸릴 수 있습니다. 보관되지 않은 오래된 데이터를 제한하기 위해 &lt;code&gt;archive_timeout&lt;/code&gt; 을 설정할 수 있습니다서버가 주기적으로 새 WAL 세그먼트 파일로 전환하도록합니다. 이 매개 변수가 0보다 큰 경우, 서버는 마지막 세그먼트 파일 전환 이후이 시간이 경과 할 때마다 새 세그먼트 파일로 전환하며 단일 체크 포인트를 포함하여 데이터베이스 활동이있는 경우 (검사 점이없는 경우 체크 포인트는 생략 됨) 데이터베이스 활동 없음). 강제 스위치로 인해 일찍 닫히는 보관 파일은 여전히 ​​전체 파일과 길이가 같습니다. 따라서 매우 짧은 &lt;code&gt;archive_timeout&lt;/code&gt; 을 사용하는 것은 현명하지 않습니다. 즉, 아카이브 스토리지를 팽창시킵니다. &lt;code&gt;archive_timeout&lt;/code&gt; 1 분 정도의 설정은 일반적으로 합리적입니다. 마스터 서버에서 데이터를보다 빠르게 복사하려면 아카이브 대신 스트리밍 복제 사용을 고려해야합니다. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5399f56401bf97d632785b4b8929b530e6e2d8a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;runtime-config-wal#GUC-COMMIT-DELAY&quot;&gt;commit_delay&lt;/a&gt; parameter defines for how many microseconds a group commit leader process will sleep after acquiring a lock within &lt;code&gt;XLogFlush&lt;/code&gt;, while group commit followers queue up behind the leader. This delay allows other server processes to add their commit records to the WAL buffers so that all of them will be flushed by the leader's eventual sync operation. No sleep will occur if &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; is not enabled, or if fewer than &lt;a href=&quot;runtime-config-wal#GUC-COMMIT-SIBLINGS&quot;&gt;commit_siblings&lt;/a&gt; other sessions are currently in active transactions; this avoids sleeping when it's unlikely that any other session will commit soon. Note that on some platforms, the resolution of a sleep request is ten milliseconds, so that any nonzero &lt;code&gt;commit_delay&lt;/code&gt; setting between 1 and 10000 microseconds would have the same effect. Note also that on some platforms, sleep operations may take slightly longer than requested by the parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-COMMIT-DELAY&quot;&gt;commit_delay의&lt;/a&gt; 그룹이 리더 프로세스를 위탁 얼마나 많은 마이크로에 대한 매개 변수를 정의가 내 잠금 획득 후 잠을 것 &lt;code&gt;XLogFlush&lt;/code&gt; 을 그룹 추종자들이 지도자 뒤에 대기 저지하면서. 이 지연을 통해 다른 서버 프로세스는 커밋 레코드를 WAL 버퍼에 추가하여 리더의 최종 동기화 작업으로 모든 데이터를 플러시 할 수 있습니다. &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; 가 사용 가능하지 않거나 &lt;a href=&quot;runtime-config-wal#GUC-COMMIT-SIBLINGS&quot;&gt;commit_siblings&lt;/a&gt; 보다 적은 수의 다른 세션이 현재 활성 트랜잭션에 있는 경우 휴면이 발생 하지 않습니다 . 다른 세션이 곧 커밋되지 않을 경우에는 잠을 자지 않습니다. 일부 플랫폼에서는 휴면 요청의 해상도가 10 밀리 초이므로 0이 아닌 &lt;code&gt;commit_delay&lt;/code&gt; 1에서 10000 마이크로 초 사이의 설정은 동일한 효과를 갖습니다. 일부 플랫폼에서는 절전 모드 작업이 매개 변수에서 요청한 것보다 약간 더 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84b33cc182a87456d65b5fb6d81772353bfa0c5a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; parameter determines how PostgreSQL will ask the kernel to force WAL updates out to disk. All the options should be the same in terms of reliability, with the exception of &lt;code&gt;fsync_writethrough&lt;/code&gt;, which can sometimes force a flush of the disk cache even when other options do not do so. However, it's quite platform-specific which one will be the fastest. You can test the speeds of different options using the &lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync&lt;/a&gt; program. Note that this parameter is irrelevant if &lt;code&gt;fsync&lt;/code&gt; has been turned off.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method의&lt;/a&gt; 매개 변수는 PostgreSQL의이 WAL이 디스크에 업데이트 강제로 커널을 요청할 것입니다 방법을 결정합니다. &lt;code&gt;fsync_writethrough&lt;/code&gt; 를 제외하고는 모든 옵션이 안정성면에서 동일해야합니다. fsync_writethrough 는 다른 옵션이없는 경우에도 디스크 캐시를 강제로 플러시 할 수 있습니다. 그러나 어느 플랫폼이 가장 빠를지는 플랫폼에 따라 다릅니다. &lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync&lt;/a&gt; 프로그램 을 사용하여 다른 옵션의 속도를 테스트 할 수 있습니다 . &lt;code&gt;fsync&lt;/code&gt; 가 해제 된 경우이 매개 변수는 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e72b4863ff3997bef9aca527ca369e356276257b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt; command allows global settings to be overridden on a per-database basis.</source>
          <target state="translated">&lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER 데이타베이스&lt;/a&gt; 명령은 전역 설정이 당 데이터베이스으로 오버라이드 (override) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c0ec7186a18a07237555b98b7d5c31ff8ec36da" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt; command is used to set default access privileges. The meaning of the privilege display is explained in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT의 권한&lt;/a&gt; 명령 세트 기본 액세스 권한에 사용됩니다. 권한 표시의 의미는 &lt;a href=&quot;ddl-priv&quot;&gt;5.7 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3f704bdd36eb12f482635a52facda66282ddc34" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt; commands are used to define per-role and per-database configuration settings.</source>
          <target state="translated">&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER 역할&lt;/a&gt; 및 &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER의 DATABASE&lt;/a&gt; 명령은 역할 별 및 데이터베이스 구성 설정을 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e108f94237a08c62d8e64461ae3859204755baee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; command allows both global and per-database settings to be overridden with user-specific values.</source>
          <target state="translated">&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER 역할&lt;/a&gt; 명령은 사용자가 특정 값으로 대체 할 글로벌 및 데이터베이스 별 설정을 모두 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="195fdcb704ebe40818b9ddf06532a834252f8376" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; command is an alternative that simply drops all the database objects owned by one or more roles.</source>
          <target state="translated">&lt;a href=&quot;sql-drop-owned&quot;&gt;DROP 소유&lt;/a&gt; 명령은 단순히 모든 데이터베이스가 하나 개 이상의 역할 소유 객체 떨어 대안입니다.</target>
        </trans-unit>
        <trans-unit id="b923e313b5089841051703b8fc819e1404870767" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; commands are used to set access privileges. The meaning of the privilege display is explained in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 및 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; 명령은 설정 액세스 권한에 사용됩니다. 권한 표시의 의미는 &lt;a href=&quot;ddl-priv&quot;&gt;5.7 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="337453e73263e51bd5484f9f75d637cf6fa2348f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; command is an alternative that reassigns the ownership of all the database objects owned by one or more roles. However, &lt;code&gt;REASSIGN OWNED&lt;/code&gt; does not deal with privileges for other objects.</source>
          <target state="translated">&lt;a href=&quot;sql-reassign-owned&quot;&gt;재 할당 소유&lt;/a&gt; 명령은 데이터베이스가 하나 개 이상의 역할 소유 객체 모두의 소유권을 재 할당 대안입니다. 그러나 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; 는 다른 객체에 대한 권한을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32052f448bd0c24564647675d7c7bccf3da94b74" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; command is used to revoke access privileges.</source>
          <target state="translated">&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE의&lt;/a&gt; 명령은 액세스 권한을 취소하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="914ad7f44e365f0117e74b7ee5b3f005733493b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; statement allows assignment of a security label to a database object.</source>
          <target state="translated">&lt;a href=&quot;sql-security-label&quot;&gt;보안 레이블&lt;/a&gt; 문은 데이터베이스 객체에 대한 보안 레이블의 할당을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="269a69c635d697de109489390d8de3c484410f96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; derives a table from one or more other tables given in a comma-separated table reference list.</source>
          <target state="translated">&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 절은&lt;/a&gt; 쉼표로 구분 테이블 참조 목록에서 지정된 하나 개 이상의 다른 테이블에서 테이블을 유도한다.</target>
        </trans-unit>
        <trans-unit id="acd01c6b3f744d1f906abdbe7c137423a64d0d6b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause derives a table from one or more other tables given in a comma-separated table reference list.</source>
          <target state="translated">&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; &lt;/a&gt; 절은 쉼표로 구분 테이블 참조 목록에서 지정된 하나 개 이상의 다른 테이블에서 테이블을 유도한다.</target>
        </trans-unit>
        <trans-unit id="0ce5e0b25e37c625d6441dcfcc9d89a41053fa65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt; is used to group together those rows in a table that have the same values in all the columns listed. The order in which the columns are listed does not matter. The effect is to combine each set of rows having common values into one group row that represents all rows in the group. This is done to eliminate redundancy in the output and/or compute aggregates that apply to these groups. For instance:</source>
          <target state="translated">&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 절은&lt;/a&gt; 함께 그룹에 나열된 모든 열에서 같은 값이 테이블의 해당 행을 사용합니다. 열이 나열되는 순서는 중요하지 않습니다. 그 결과 공통 값을 갖는 각 행 세트를 그룹의 모든 행을 나타내는 하나의 그룹 행으로 결합합니다. 이는 출력 및 / 또는 이러한 그룹에 적용되는 계산 집계에서 중복성을 제거하기 위해 수행됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="8c6ac1734e0a190e05c94cd28cb06f3accef6f7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt;&lt;/a&gt; clause is used to group together those rows in a table that have the same values in all the columns listed. The order in which the columns are listed does not matter. The effect is to combine each set of rows having common values into one group row that represents all rows in the group. This is done to eliminate redundancy in the output and/or compute aggregates that apply to these groups. For instance:</source>
          <target state="translated">&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; &lt;/a&gt; 절은 함께 그룹에 나열된 모든 열에서 같은 값이 테이블의 해당 행을 사용합니다. 열이 나열되는 순서는 중요하지 않습니다. 그 결과 공통 값이있는 각 행 세트를 그룹의 모든 행을 나타내는 하나의 그룹 행으로 결합합니다. 이는 출력에서 ​​중복을 제거하고 이러한 그룹에 적용되는 집계를 계산하기 위해 수행됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="363c7ac6e0692386d5610ac55d561224210b8a92" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command allows modification of the current value of those parameters that can be set locally to a session; it has no effect on other sessions. The corresponding function is &lt;code&gt;set_config(setting_name, new_value, is_local)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-set&quot;&gt;SET의&lt;/a&gt; 명령은 세션에 로컬로 설정할 수있는 이러한 매개 변수의 현재 값을 변경할 수있게한다; 다른 세션에는 영향을 미치지 않습니다. 해당 기능은 &lt;code&gt;set_config(setting_name, new_value, is_local)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="185fc2c06409d3c4aabd5fe76eeaa8facbaa2eb1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; command allows inspection of the current value of all parameters. The corresponding function is &lt;code&gt;current_setting(setting_name text)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-show&quot;&gt;SHOW의&lt;/a&gt; 명령은 모든 매개 변수의 현재 값을 검사 할 수 있습니다. 해당 기능은 &lt;code&gt;current_setting(setting_name text)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75ebcd7006e980d1a721493d3e0c9faa5861d303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;uuid-ossp&quot;&gt;uuid-ossp&lt;/a&gt; module provides additional functions that implement other standard algorithms for generating UUIDs.</source>
          <target state="translated">&lt;a href=&quot;uuid-ossp&quot;&gt;UUID-OSSP의&lt;/a&gt; 모듈 UUID를 생성하기위한 다른 표준 알고리즘을 구현하는 추가적인 기능을 제공한다.</target>
        </trans-unit>
        <trans-unit id="9db9437c62739b64989fda778dbfe8e3dbe07643" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt; operator is converted to &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; in the parser stage. It is not possible to implement &lt;code&gt;!=&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operators that do different things.</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; 연산자로 변환된다 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 파서 단계. 다른 일 을하는 &lt;code&gt;!=&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 를 구현할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b4b39879f1c00635679dbf6257789a56ab870c6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%I&lt;/code&gt; and &lt;code&gt;%L&lt;/code&gt; format specifiers are particularly useful for safely constructing dynamic SQL statements. See &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%I&lt;/code&gt; 와 &lt;code&gt;%L&lt;/code&gt; 형식 지정 안전하게 동적 SQL 문을 구성하는 데 유용합니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;예 42.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21ea706682d50f9db930023e09b94e431215ca9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%I&lt;/code&gt; and &lt;code&gt;%L&lt;/code&gt; format specifiers are particularly useful for safely constructing dynamic SQL statements. See &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%I&lt;/code&gt; 와 &lt;code&gt;%L&lt;/code&gt; 형식 지정 안전하게 동적 SQL 문을 구성하는 데 유용합니다. &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="613196988c221e27fa2ba0fd9b48e90265f53f2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%c&lt;/code&gt; escape prints a quasi-unique session identifier, consisting of two 4-byte hexadecimal numbers (without leading zeros) separated by a dot. The numbers are the process start time and the process ID, so &lt;code&gt;%c&lt;/code&gt; can also be used as a space saving way of printing those items. For example, to generate the session identifier from &lt;code&gt;pg_stat_activity&lt;/code&gt;, use this query:</source>
          <target state="translated">&lt;code&gt;%c&lt;/code&gt; 탈출 (0이 붙지 않는) 바이트 4 개의 16 진수로 이루어진 도트로 구분하여 준 고유 세션 식별자를 출력한다. 숫자는 프로세스 시작 시간 및 프로세스 ID이므로 &lt;code&gt;%c&lt;/code&gt; 는 해당 항목을 인쇄하는 공간 절약 방법으로도 사용할 수 있습니다. 예를 들어, &lt;code&gt;pg_stat_activity&lt;/code&gt; 에서 세션 식별자를 생성 하려면 다음 쿼리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="be62a410fba8b688007f925d66c6f0b0239d47a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%q&lt;/code&gt; escape is useful when including information that is only available in session (backend) context like user or database name. For example:</source>
          <target state="translated">&lt;code&gt;%q&lt;/code&gt; 사용자 또는 데이터베이스 이름과 같은 세션 (백엔드) 환경에서만 사용할 수 있습니다 정보를 포함 할 경우 에스 케이프 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0846a3eba9942d2eb08fef499bfe2405f66d139a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; options will not work on FreeBSD or OpenBSD. Use &lt;code&gt;-c&lt;/code&gt; instead. This is a bug in the affected operating systems; a future release of PostgreSQL will provide a workaround if this is not fixed.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 옵션은 FreeBSD의 또는 오픈 BSD에서 작동하지 않습니다. 대신 &lt;code&gt;-c&lt;/code&gt; 를 사용하십시오 . 영향을받는 운영 체제의 버그입니다. PostgreSQL의 향후 릴리스에서는 해결되지 않은 경우 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bb48a8fd13ffc656f2d3563ef0148faa8767e1f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--clean&lt;/code&gt; option can be useful even when your intention is to restore the dump script into a fresh cluster. Use of &lt;code&gt;--clean&lt;/code&gt; authorizes the script to drop and re-create the built-in &lt;code&gt;postgres&lt;/code&gt; and &lt;code&gt;template1&lt;/code&gt; databases, ensuring that those databases will retain the same properties (for instance, locale and encoding) that they had in the source cluster. Without the option, those databases will retain their existing database-level properties, as well as any pre-existing contents.</source>
          <target state="translated">&lt;code&gt;--clean&lt;/code&gt; 당신의 의도가 새로운 클러스터로 덤프 스크립트를 복원 할 경우에도 옵션이 유용 할 수 있습니다. &lt;code&gt;--clean&lt;/code&gt; 을 사용 하면 스크립트가 내장 &lt;code&gt;postgres&lt;/code&gt; 및 &lt;code&gt;template1&lt;/code&gt; 데이터베이스 를 삭제 및 재 작성할 수있는 권한을 부여하여 해당 데이터베이스가 소스 클러스터에서와 동일한 특성 (예 : 로케일 및 인코딩)을 보유하게합니다. 옵션이 없으면 해당 데이터베이스는 기존 데이터베이스 레벨 특성과 기존 컨텐츠를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="130647018e3093894742562a95f803e39af61e68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--endpos&lt;/code&gt; option is not aware of transaction boundaries and may truncate output partway through a transaction. Any partially output transaction will not be consumed and will be replayed again when the slot is next read from. Individual messages are never truncated.</source>
          <target state="translated">&lt;code&gt;--endpos&lt;/code&gt; 옵션은 트랜잭션 경계를 인식하지 못하므로 트랜잭션을 통해 출력 이 부분적으로 잘릴 수 있습니다. 부분적으로 출력 된 트랜잭션은 소비되지 않으며 다음에 슬롯을 읽을 때 다시 재생됩니다. 개별 메시지는 절대 잘리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d789e6215fd5e2a66e4d9dfcc1b5b16821b92fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--jobs&lt;/code&gt; option allows multiple CPU cores to be used for copying/linking of files and to dump and reload database schemas in parallel; a good place to start is the maximum of the number of CPU cores and tablespaces. This option can dramatically reduce the time to upgrade a multi-database server running on a multiprocessor machine.</source>
          <target state="translated">&lt;code&gt;--jobs&lt;/code&gt; 옵션은 여러 개의 CPU 코어 파일의 연결과 병렬로 덤프하고 다시로드 데이터베이스 스키마에 / 복사하는 데 사용할 수 있습니다; 시작하기에 좋은 곳은 최대 CPU 코어 및 테이블 스페이스 수입니다. 이 옵션을 사용하면 다중 프로세서 시스템에서 실행중인 다중 데이터베이스 서버를 업그레이드하는 시간을 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60c0fc2785d87157e1081e9835a3407e37d6052f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option allows control over &lt;em&gt;how&lt;/em&gt; the server shuts down:</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 옵션을 제어 할 수 있도록 &lt;em&gt;하는 방법&lt;/em&gt; 서버 닫힌다를 아래로 :</target>
        </trans-unit>
        <trans-unit id="f6de6d14022951042a07aec36849186c4f5bfb5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; switches have no effect when &lt;code&gt;-t&lt;/code&gt; is used, because tables selected by &lt;code&gt;-t&lt;/code&gt; will be dumped regardless of those switches, and non-table objects will not be dumped.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; 및 &lt;code&gt;-N&lt;/code&gt; 때 스위치는 적용되지 &lt;code&gt;-t&lt;/code&gt; 를 사용하여 선택된 테이블 때문에 &lt;code&gt;-t&lt;/code&gt; 는 관계없이 그 덤프 스위치되며, 비 나타난 개체가 덤프 될 것이다.</target>
        </trans-unit>
        <trans-unit id="1c021a68434c51a64fadf69148028650f81ac04a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-n&lt;/code&gt;/&lt;code&gt;--dry-run&lt;/code&gt; option instructs &lt;code&gt;pg_resetwal&lt;/code&gt; to print the values reconstructed from &lt;code&gt;pg_control&lt;/code&gt; and values about to be changed, and then exit without modifying anything. This is mainly a debugging tool, but can be useful as a sanity check before allowing &lt;code&gt;pg_resetwal&lt;/code&gt; to proceed for real.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; / &lt;code&gt;--dry-run&lt;/code&gt; 옵션에 지시가 &lt;code&gt;pg_resetwal&lt;/code&gt; 으로부터 복원 값 인쇄 &lt;code&gt;pg_control&lt;/code&gt; 아무것도 수정하지 않고 변경하는 대한과 값, 다음 종료. 주로 디버깅 도구이지만 &lt;code&gt;pg_resetwal&lt;/code&gt; 이 실제로 진행 되도록 허용하기 전에 온 전성 검사로 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afbc5026b590cc92ecfafcc8bf05e16decdcee72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.affix&lt;/code&gt; file of Ispell has the following structure:</source>
          <target state="translated">Ispell 의 &lt;code&gt;.affix&lt;/code&gt; 파일 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0aaa705ee0fcfa2388ca815156eb97bc745ef75a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.dict&lt;/code&gt; file looks like the &lt;code&gt;.dict&lt;/code&gt; file of Ispell:</source>
          <target state="translated">&lt;code&gt;.dict&lt;/code&gt; 의 파일과 같은 &lt;code&gt;.dict&lt;/code&gt; 의 아마도 Ispell의 파일 :</target>
        </trans-unit>
        <trans-unit id="4b92e4eb25a1e0875c92022432554fb50cee9d37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt;, &lt;code&gt;CAST()&lt;/code&gt;, and function-call syntaxes can also be used to specify run-time type conversions of arbitrary expressions, as discussed in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt;. To avoid syntactic ambiguity, the &lt;code&gt;type 'string'&lt;/code&gt; syntax can only be used to specify the type of a simple literal constant. Another restriction on the &lt;code&gt;type 'string'&lt;/code&gt; syntax is that it does not work for array types; use &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;CAST()&lt;/code&gt; to specify the type of an array constant.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; , &lt;code&gt;CAST()&lt;/code&gt; 에서 논의 된 바와 같이, 그리고 함수 호출 구문도, 임의의 식의 실행시의 형태 변환을 지정하는 데 사용할 수 있습니다 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;제 4.2.9&lt;/a&gt; . 구문 상 모호성을 피하기 위해 &lt;code&gt;type 'string'&lt;/code&gt; 구문은 단순한 리터럴 상수의 형식을 지정하는 데만 사용할 수 있습니다. &lt;code&gt;type 'string'&lt;/code&gt; 구문 에 대한 다른 제한 사항 은 배열 유형에 대해 작동하지 않는다는 것입니다. 사용 &lt;code&gt;::&lt;/code&gt; 또는 &lt;code&gt;CAST()&lt;/code&gt; 배열 상수의 유형을 지정.</target>
        </trans-unit>
        <trans-unit id="218d1743d0cb00c454c40f10c667dcbc5d4724ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:{?name}&lt;/code&gt; special syntax returns TRUE or FALSE depending on whether the variable exists or not, and is thus always substituted, unless the colon is backslash-escaped.</source>
          <target state="translated">&lt;code&gt;:{?name}&lt;/code&gt; 특수 구문 반환 TRUE 또는 변수가 존재 여부 및 콜론 백 슬래시 이스케이프하지 않는 한, 따라서 항상 교체 여부에 따라 FALSE.</target>
        </trans-unit>
        <trans-unit id="20ec88aea7341643c603b25a4a5e95db36e60cca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; cases work slightly differently from the others. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of the row comparison is unknown (null).</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 의 경우는 다른 사람에서 약간 다르게 작동합니다. 해당하는 모든 멤버가 널이 아니고 같으면 두 행이 동일한 것으로 간주됩니다. 대응하는 멤버가 널이 아니거나 같으면 행이 동일하지 않습니다. 그렇지 않으면 행 비교 결과를 알 수 없습니다 (널).</target>
        </trans-unit>
        <trans-unit id="76c364cd99d16fbdee060a1f142838c1f0bb9202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@?&lt;/code&gt; and &lt;code&gt;@@&lt;/code&gt; operators suppress the following errors: lacking object field or array element, unexpected JSON item type, and numeric errors. This behavior might be helpful while searching over JSON document collections of varying structure.</source>
          <target state="translated">&lt;code&gt;@?&lt;/code&gt; 및 &lt;code&gt;@@&lt;/code&gt; 연산자는 다음과 같은 오류를 억제 : 오브젝트 필드 또는 배열 요소, 예상치 못한 JSON 항목 유형 및 숫자 오류가 부족. 이 동작은 다양한 구조의 JSON 문서 컬렉션을 검색 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a2242f98120d8e47de3265a4acf7938f0816abb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; operators test whether an array satisfies a &lt;em&gt;query&lt;/em&gt;, which is expressed as a value of a specialized data type &lt;code&gt;query_int&lt;/code&gt;. A &lt;em&gt;query&lt;/em&gt; consists of integer values that are checked against the elements of the array, possibly combined using the operators &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (OR), and &lt;code&gt;!&lt;/code&gt; (NOT). Parentheses can be used as needed. For example, the query &lt;code&gt;1&amp;amp;(2|3)&lt;/code&gt; matches arrays that contain 1 and also contain either 2 or 3.</source>
          <target state="translated">&lt;code&gt;@@&lt;/code&gt; 와 &lt;code&gt;~~&lt;/code&gt; 배열 만족하는 여부 연산자 시험 &lt;em&gt;질의&lt;/em&gt; 특수한 데이터 유형의 값으로 표현되고, &lt;code&gt;query_int&lt;/code&gt; . &lt;em&gt;쿼리&lt;/em&gt; 배열의 요소에 대해 선택되어 정수 값으로 구성 가능한 연산자로 결합 &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) &lt;code&gt;|&lt;/code&gt; (OR),와 &lt;code&gt;!&lt;/code&gt; (아니). 필요에 따라 괄호를 사용할 수 있습니다. 예를 들어, 쿼리 &lt;code&gt;1&amp;amp;(2|3)&lt;/code&gt; 은 1을 포함하고 2 또는 3도 포함하는 배열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5b7dc0f549fc8d4bcaa680825c09ad5a95a8ca20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@@&lt;/code&gt; operator also supports &lt;code&gt;text&lt;/code&gt; input, allowing explicit conversion of a text string to &lt;code&gt;tsvector&lt;/code&gt; or &lt;code&gt;tsquery&lt;/code&gt; to be skipped in simple cases. The variants available are:</source>
          <target state="translated">&lt;code&gt;@@&lt;/code&gt; 연산자는 지원 &lt;code&gt;text&lt;/code&gt; 에 텍스트 스트링을 명시 적으로 전환하므로 입력 &lt;code&gt;tsvector&lt;/code&gt; 또는 &lt;code&gt;tsquery&lt;/code&gt; 을 간단한 경우 생략한다. 사용 가능한 변형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30895671a21d77017876ea7eed20dcf436e9f5da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@INCLUDE&lt;/code&gt; syntax allows inclusion of another file in the &lt;code&gt;.../share/timezonesets/&lt;/code&gt; directory. Inclusion can be nested, to a limited depth.</source>
          <target state="translated">&lt;code&gt;@INCLUDE&lt;/code&gt; 의 구문은 다른 파일을 포함 할 수 있습니다 &lt;code&gt;.../share/timezonesets/&lt;/code&gt; 디렉토리. 포함은 제한된 깊이로 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73f7fb2569c1bf7198e289506cf390d52263021" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@OVERRIDE&lt;/code&gt; syntax indicates that subsequent entries in the file can override previous entries (typically, entries obtained from included files). Without this, conflicting definitions of the same timezone abbreviation are considered an error.</source>
          <target state="translated">&lt;code&gt;@OVERRIDE&lt;/code&gt; 의 구문은 파일의 후속 항목 (일반적으로, 항목이 포함 된 파일에서 얻은) 이전 항목을 대체 할 수 있음을 나타냅니다. 이를 사용하지 않으면 동일한 시간대 약어의 충돌 정의가 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3ce7ae779cc4c96e9d85dc3b91172987fc826c9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ADD ATTRIBUTE&lt;/code&gt;, &lt;code&gt;DROP ATTRIBUTE&lt;/code&gt;, and &lt;code&gt;ALTER ATTRIBUTE&lt;/code&gt; actions can be combined into a list of multiple alterations to apply in parallel. For example, it is possible to add several attributes and/or alter the type of several attributes in a single command.</source>
          <target state="translated">&lt;code&gt;ADD ATTRIBUTE&lt;/code&gt; , &lt;code&gt;DROP ATTRIBUTE&lt;/code&gt; 및 &lt;code&gt;ALTER ATTRIBUTE&lt;/code&gt; 작업은 병렬로 적용하기 위해 여러 변화의 목록으로 결합 할 수 있습니다. 예를 들어, 하나의 명령으로 여러 속성을 추가하거나 여러 속성의 유형을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c82109d40f6d847786413ac572aab290b0770b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ADD MAPPING FOR&lt;/code&gt; form installs a list of dictionaries to be consulted for the specified token type(s); it is an error if there is already a mapping for any of the token types. The &lt;code&gt;ALTER MAPPING FOR&lt;/code&gt; form does the same, but first removing any existing mapping for those token types. The &lt;code&gt;ALTER MAPPING REPLACE&lt;/code&gt; forms substitute &lt;code&gt;new_dictionary&lt;/code&gt; for &lt;code&gt;old_dictionary&lt;/code&gt; anywhere the latter appears. This is done for only the specified token types when &lt;code&gt;FOR&lt;/code&gt; appears, or for all mappings of the configuration when it doesn't. The &lt;code&gt;DROP MAPPING&lt;/code&gt; form removes all dictionaries for the specified token type(s), causing tokens of those types to be ignored by the text search configuration. It is an error if there is no mapping for the token types, unless &lt;code&gt;IF EXISTS&lt;/code&gt; appears.</source>
          <target state="translated">&lt;code&gt;ADD MAPPING FOR&lt;/code&gt; 형태는 지정된 토큰 유형 (들)에 대한 상담을 할 사전의 목록을 설치합니다; 토큰 유형에 대한 매핑이 이미 있으면 오류입니다. &lt;code&gt;ALTER MAPPING FOR&lt;/code&gt; 형태 역시 동일하지만, 먼저 그 토큰 유형에 대한 기존의 매핑을 제거. &lt;code&gt;ALTER MAPPING REPLACE&lt;/code&gt; 형태의 대체 &lt;code&gt;new_dictionary&lt;/code&gt; 에 대한 &lt;code&gt;old_dictionary&lt;/code&gt; 후자가 나타납니다 어디서나. 이는 &lt;code&gt;FOR&lt;/code&gt; 가 나타날 때 지정된 토큰 유형 또는 구성이 없을 때의 모든 매핑에 대해 수행됩니다. &lt;code&gt;DROP MAPPING&lt;/code&gt; form은 지정된 토큰 유형에 대한 모든 사전을 제거하여 해당 유형의 토큰이 텍스트 검색 구성에서 무시되도록합니다. &lt;code&gt;IF EXISTS&lt;/code&gt; 가 표시 되지 않으면 토큰 유형에 대한 맵핑이 없으면 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="4265f388b14c9bc45f67ecc3a11ed01719e3bf45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ADMIN&lt;/code&gt; clause is like &lt;code&gt;ROLE&lt;/code&gt;, but the named roles are added to the new role &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt;, giving them the right to grant membership in this role to others.</source>
          <target state="translated">&lt;code&gt;ADMIN&lt;/code&gt; 의 절처럼 &lt;code&gt;ROLE&lt;/code&gt; 만라는 이름의 역할은 새 역할에 추가됩니다 &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; 그들에게 다른 사람에게이 역할의 구성원 자격을 부여 할 수있는 권리를 부여.</target>
        </trans-unit>
        <trans-unit id="d95ee8a0a7e97df569ab0bc6a3b70b2476a22d5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALTER DATABASE&lt;/code&gt; statement is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;ALTER DATABASE&lt;/code&gt; 문은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="82e96a243c3b3c45f817dbbcc38562dae8379f22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALTER ROLE&lt;/code&gt; statement is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;ALTER ROLE&lt;/code&gt; 문은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="2a7e4c13b470262479973c6bd7c44308acb43aa5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALTER SYSTEM&lt;/code&gt; statement is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;ALTER SYSTEM&lt;/code&gt; 의 문은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="86d3bef8a210b09d96afd110f16f5de67d4ca1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALTER TABLE&lt;/code&gt; method requires an exclusive lock on the table, but does not result in bloating the table with old row versions.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; 의 방법은 테이블에 배타적 잠금이 필요하지만, 이전 행 버전 테이블을 팽만감 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c6e0be8824e92ed0cf7a61a96c4d893ffd4b297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALTER USER&lt;/code&gt; statement is a PostgreSQL extension. The SQL standard leaves the definition of users to the implementation.</source>
          <target state="translated">&lt;code&gt;ALTER USER&lt;/code&gt; 문은 PostgreSQL의 확장입니다. SQL 표준은 사용자 정의를 구현에 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="d04bc7f32a809cba3ceefbc64223f38d2bcaedda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ANALYZE&lt;/code&gt; option causes the statement to be actually executed, not only planned. Then actual run time statistics are added to the display, including the total elapsed time expended within each plan node (in milliseconds) and the total number of rows it actually returned. This is useful for seeing whether the planner's estimates are close to reality.</source>
          <target state="translated">는 &lt;code&gt;ANALYZE&lt;/code&gt; 옵션은 실제로 단지 계획하지, 실행하기 위해 문을 발생합니다. 그런 다음 각 계획 노드 내에서 소비 된 총 경과 시간 (밀리 초)과 실제로 반환 된 총 행 수를 포함하여 실제 런타임 통계가 디스플레이에 추가됩니다. 이것은 플래너의 추정치가 현실에 가까운 지 여부를 확인하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c2e677d360502253ce0ba5dcaac208672ce955e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ARRAY&lt;/code&gt; constructor syntax (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;Section 4.2.12&lt;/a&gt;) is often easier to work with than the array-literal syntax when writing array values in SQL commands. In &lt;code&gt;ARRAY&lt;/code&gt;, individual element values are written the same way they would be written when not members of an array.</source>
          <target state="translated">&lt;code&gt;ARRAY&lt;/code&gt; 의 생성자 구문 (참조 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;섹션 4.2.12을&lt;/a&gt; ) 배열 리터럴 구문보다 SQL 명령에 배열 값을 기록 할 때와 작업에 자주 쉽습니다. 에서는 &lt;code&gt;ARRAY&lt;/code&gt; 개별적인 요소 값들이 기록 될 것 같은 방법을 기록하지 않을 때 어레이의 부재.</target>
        </trans-unit>
        <trans-unit id="a14756a4782980d192f1e9c9b815bed9eb64adea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ARRAY&lt;/code&gt; constructor syntax can also be used:</source>
          <target state="translated">&lt;code&gt;ARRAY&lt;/code&gt; 의 생성자 구문도 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c709ef97abf25019a718b3b56ecc90d8da643f8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AS&lt;/code&gt; clause defines the names and types of the columns in the output table. The first is the &amp;ldquo;key&amp;rdquo; field and the rest correspond to the XPath queries. If there are more XPath queries than result columns, the extra queries will be ignored. If there are more result columns than XPath queries, the extra columns will be NULL.</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 의 절은 출력 테이블의 컬럼의 이름과 유형을 정의합니다. 첫 번째는 &quot;키&quot;필드이고 나머지는 XPath 쿼리에 해당합니다. 결과 열보다 많은 XPath 쿼리가 있으면 추가 쿼리는 무시됩니다. XPath 쿼리보다 결과 열이 더 많으면 추가 열은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="614608ef47ca44f29dec326a00fbdc8845ddc5d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AS&lt;/code&gt; key word is optional noise. &lt;code&gt;alias&lt;/code&gt; can be any identifier.</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 키워드는 선택 소음이다. &lt;code&gt;alias&lt;/code&gt; 은 임의의 식별자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="570aa62b83c7e1ef7c13882b42b310d6df5c71f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AS&lt;/code&gt; keyword is optional, but only if the new column name does not match any PostgreSQL keyword (see &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;). To avoid an accidental match to a keyword, you can double-quote the column name. For example, &lt;code&gt;VALUE&lt;/code&gt; is a keyword, so this does not work:</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 의 키워드는 선택 사항이지만, 새로운 열 이름에 PostgreSQL의 키워드와 일치하지 않는 경우에만 (참조 &lt;a href=&quot;sql-keywords-appendix&quot;&gt;부록 C&lt;/a&gt; ). 실수로 키워드와 일치하지 않도록 열 이름을 큰 따옴표로 묶을 수 있습니다. 예를 들어 &lt;code&gt;VALUE&lt;/code&gt; 는 키워드이므로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5c9d334e13b1cff2797d1f5d42bdd83891085f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AT TIME ZONE&lt;/code&gt; converts time stamp &lt;em&gt;without time zone&lt;/em&gt; to/from time stamp &lt;em&gt;with time zone&lt;/em&gt;, and &lt;em&gt;time&lt;/em&gt; values to different time zones. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT-TABLE&quot;&gt;Table 9.32&lt;/a&gt; shows its variants.</source>
          <target state="translated">&lt;code&gt;AT TIME ZONE&lt;/code&gt; 은 타임 스탬프 변환 &lt;em&gt;시간대없이&lt;/em&gt; 시간 스탬프로부터 /에 &lt;em&gt;표준 시간대&lt;/em&gt; 및 &lt;em&gt;시간&lt;/em&gt; 다른 시간대에 값. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT-TABLE&quot;&gt;표 9.32&lt;/a&gt; 는 그 변형을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="33b5c56fe35e6765006bae12e23f9fe08ce2c9da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator converts time stamp &lt;em&gt;without&lt;/em&gt; time zone to/from time stamp &lt;em&gt;with&lt;/em&gt; time zone, and &lt;code&gt;time with time zone&lt;/code&gt; values to different time zones. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT-TABLE&quot;&gt;Table 9.33&lt;/a&gt; shows its variants.</source>
          <target state="translated">&lt;code&gt;AT TIME ZONE&lt;/code&gt; 운전자 변환 타임 스탬프 &lt;em&gt;없이&lt;/em&gt; 타임 스탬프로부터 /까지 시간대 &lt;em&gt;와&lt;/em&gt; 시간대와 &lt;code&gt;time with time zone&lt;/code&gt; 다른 시간대에 값. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT-TABLE&quot;&gt;표 9.33&lt;/a&gt; 은 변형을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0ddb589e9d98058f974226b1de568ed89b19b1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BERNOULLI&lt;/code&gt; and &lt;code&gt;SYSTEM&lt;/code&gt; sampling methods each accept a single &lt;code&gt;argument&lt;/code&gt; which is the fraction of the table to sample, expressed as a percentage between 0 and 100. This argument can be any &lt;code&gt;real&lt;/code&gt;-valued expression. (Other sampling methods might accept more or different arguments.) These two methods each return a randomly-chosen sample of the table that will contain approximately the specified percentage of the table's rows. The &lt;code&gt;BERNOULLI&lt;/code&gt; method scans the whole table and selects or ignores individual rows independently with the specified probability. The &lt;code&gt;SYSTEM&lt;/code&gt; method does block-level sampling with each block having the specified chance of being selected; all rows in each selected block are returned. The &lt;code&gt;SYSTEM&lt;/code&gt; method is significantly faster than the &lt;code&gt;BERNOULLI&lt;/code&gt; method when small sampling percentages are specified, but it may return a less-random sample of the table as a result of clustering effects.</source>
          <target state="translated">&lt;code&gt;BERNOULLI&lt;/code&gt; 및 &lt;code&gt;SYSTEM&lt;/code&gt; 샘플링 방법은 각각 하나의 수용 &lt;code&gt;argument&lt;/code&gt; 이 인수 일 수있는 0과 100 사이의 비율로 표현 샘플 테이블의 일부이며, &lt;code&gt;real&lt;/code&gt; -valued 식. (다른 샘플링 방법은 더 많거나 다른 인수를 사용할 수 있습니다.)이 두 방법은 각각 테이블 행의 대략 지정된 비율을 포함하는 임의로 선택된 테이블 샘플을 반환합니다. &lt;code&gt;BERNOULLI&lt;/code&gt; 방법은 전체 테이블을 선택하여 스캔하거나 지정된 확률로 독립적으로 각각의 행을 무시한다. &lt;code&gt;SYSTEM&lt;/code&gt; 이 방법은 지정된 확률이 선택된 각 블록으로 블록 레벨 샘플링을 수행합니다. 선택한 각 블록의 모든 행이 반환됩니다. &lt;code&gt;SYSTEM&lt;/code&gt; 의 방법보다 훨씬 빠르게 인 &lt;code&gt;BERNOULLI&lt;/code&gt; 작은 샘플링 비율이 지정되는 방법이지만 효과 클러스터링의 결과 테이블의 작은 무작위 샘플을 반환 할 수있다.</target>
        </trans-unit>
        <trans-unit id="571b957d3f7fab3d793660465b9a0e13866265c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BETWEEN&lt;/code&gt; predicate simplifies range tests:</source>
          <target state="translated">&lt;code&gt;BETWEEN&lt;/code&gt; 술어 단순화는 시험 범위 :</target>
        </trans-unit>
        <trans-unit id="db6d5820ecdd5a8f7e0b3d64324b7e94d1144715" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY REF&lt;/code&gt; and &lt;code&gt;BY VALUE&lt;/code&gt; clauses are accepted in PostgreSQL, but are ignored, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-POSTGRESQL&quot;&gt;Section D.3.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;BY REF&lt;/code&gt; 와 &lt;code&gt;BY VALUE&lt;/code&gt; 절은 PostgreSQL의에서 인정되지만에서 논의 된 바와 같이, 무시됩니다 &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-POSTGRESQL&quot;&gt;섹션 D.3.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f58a6da12682bf61030340725b9a30308528c8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY REF&lt;/code&gt; and &lt;code&gt;BY VALUE&lt;/code&gt; clauses are accepted in PostgreSQL, but are ignored, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-POSTGRESQL&quot;&gt;Section D.3.2&lt;/a&gt;. In the SQL standard, the &lt;code&gt;xmlexists&lt;/code&gt; function evaluates an expression in the XML Query language, but PostgreSQL allows only an XPath 1.0 expression, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;BY REF&lt;/code&gt; 와 &lt;code&gt;BY VALUE&lt;/code&gt; 절은 PostgreSQL의에서 인정되지만에서 논의 된 바와 같이, 무시됩니다 &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-POSTGRESQL&quot;&gt;섹션 D.3.2&lt;/a&gt; . SQL 표준에서 &lt;code&gt;xmlexists&lt;/code&gt; 함수는 XML 쿼리 언어로 표현식을 평가하지만 PostgreSQL은 &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;섹션 D.3.1&lt;/a&gt; 에서 논의 된 것처럼 XPath 1.0 표현식 만 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="4d361ee74863162af2cdbb6997f13ac466116d12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CAST()&lt;/code&gt; syntax conforms to SQL. The &lt;code&gt;type 'string'&lt;/code&gt; syntax is a generalization of the standard: SQL specifies this syntax only for a few data types, but PostgreSQL allows it for all types. The syntax with &lt;code&gt;::&lt;/code&gt; is historical PostgreSQL usage, as is the function-call syntax.</source>
          <target state="translated">&lt;code&gt;CAST()&lt;/code&gt; SQL에 대한 구문을 준수합니다. &lt;code&gt;type 'string'&lt;/code&gt; SQL 단지 몇 데이터 유형에 대한 구문을 지정하지만 PostgreSQL은 모든 종류의를 할 수 있습니다 : 구문은 표준의 일반화이다. &lt;code&gt;::&lt;/code&gt; 의 구문 은 함수 호출 구문과 마찬가지로 역사적인 PostgreSQL 사용법입니다.</target>
        </trans-unit>
        <trans-unit id="8c70a0f6972b720eea25e301d502be637e2846f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CAST&lt;/code&gt; syntax conforms to SQL; the syntax with &lt;code&gt;::&lt;/code&gt; is historical PostgreSQL usage.</source>
          <target state="translated">&lt;code&gt;CAST&lt;/code&gt; 의 SQL에 대한 구문 부합 함을 선언합니다; &lt;code&gt;::&lt;/code&gt; 의 구문 은 역사적인 PostgreSQL 사용법입니다.</target>
        </trans-unit>
        <trans-unit id="4973e32927f37539b48f144b25ebc1cbe9dd3ee8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK OPTION&lt;/code&gt; may not be used with &lt;code&gt;RECURSIVE&lt;/code&gt; views.</source>
          <target state="translated">&lt;code&gt;CHECK OPTION&lt;/code&gt; 함께 사용할 수 없습니다 &lt;code&gt;RECURSIVE&lt;/code&gt; 전망.</target>
        </trans-unit>
        <trans-unit id="1dc23a20dcd6904900cc7a9feb49a2ad7ab05c12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; clause specifies an expression producing a Boolean result which each row in the foreign table is expected to satisfy; that is, the expression should produce TRUE or UNKNOWN, never FALSE, for all rows in the foreign table. A check constraint specified as a column constraint should reference that column's value only, while an expression appearing in a table constraint can reference multiple columns.</source>
          <target state="translated">&lt;code&gt;CHECK&lt;/code&gt; 절 외부 테이블의 각 행에 만족하는 것으로 예상되는 부울 결과를 생성하는 연산 식을 지정; 즉, 표현식은 외부 테이블의 모든 행에 대해 TRUE 또는 UNKNOWN을 생성해야하며 절대 FALSE가 아닙니다. 열 제약 조건으로 지정된 검사 제약 조건은 해당 열의 값만 참조해야하지만 테이블 제약 조건에 나타나는 식은 여러 열을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1cf02ad28fb264c5a37f3c6cdfecd073618b093" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; clause specifies an expression producing a Boolean result which new or updated rows must satisfy for an insert or update operation to succeed. Expressions evaluating to TRUE or UNKNOWN succeed. Should any row of an insert or update operation produce a FALSE result, an error exception is raised and the insert or update does not alter the database. A check constraint specified as a column constraint should reference that column's value only, while an expression appearing in a table constraint can reference multiple columns.</source>
          <target state="translated">&lt;code&gt;CHECK&lt;/code&gt; 절을 지정하는 식 새로운 또는 업데이트 된 행이 성공 삽입 또는 업데이트 작업에 만족해야 부울 결과를 생성. TRUE 또는 UNKNOWN으로 평가되는식이 성공합니다. 삽입 또는 갱신 조작의 행이 FALSE 결과를 생성하면, 오류 예외가 발생하고 삽입 또는 갱신이 데이터베이스를 변경하지 않습니다. 열 제약 조건으로 지정된 검사 제약 조건은 해당 열의 값만 참조해야하지만 테이블 제약 조건에 나타나는 식은 여러 열을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b41ba615aba0591ab80e7fe6b54632defabd08a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECKPOINT&lt;/code&gt; command forces an immediate checkpoint when the command is issued, without waiting for a regular checkpoint scheduled by the system (controlled by the settings in &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-CHECKPOINTS&quot;&gt;Section 19.5.2&lt;/a&gt;). &lt;code&gt;CHECKPOINT&lt;/code&gt; is not intended for use during normal operation.</source>
          <target state="translated">&lt;code&gt;CHECKPOINT&lt;/code&gt; 명령 강제 명령이 (의 설정에 의해 제어 시스템에 의해 예정된 정기 검사를 기다리지 않고, 발급 즉시 체크 포인트 &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-CHECKPOINTS&quot;&gt;제 19.5.2&lt;/a&gt; ). &lt;code&gt;CHECKPOINT&lt;/code&gt; 는 정상 작동 중에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb8bf5bd6d3a91c1dd7356bcc64f2834c5842703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is a PostgreSQL language extension.</source>
          <target state="translated">&lt;code&gt;CHECKPOINT&lt;/code&gt; 명령은 PostgreSQL의 언어 확장입니다.</target>
        </trans-unit>
        <trans-unit id="9d7f2538136f2f5eb3180ad5eaeb2e7f06dbaab5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COALESCE&lt;/code&gt; function returns the first of its arguments that is not null. Null is returned only if all arguments are null. It is often used to substitute a default value for null values when data is retrieved for display, for example:</source>
          <target state="translated">&lt;code&gt;COALESCE&lt;/code&gt; 기능은 널 (NULL) 인수의 첫 번째 반환합니다. 모든 인수가 널인 경우에만 널이 리턴됩니다. 표시 할 데이터를 검색 할 때 종종 null 값을 기본값으로 대체하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19ae97f9e5f98371a99a56a7b6e3d462bf222143" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COLLATE&lt;/code&gt; clause assigns a collation to the column (which must be of a collatable data type). If not specified, the column data type's default collation is used.</source>
          <target state="translated">&lt;code&gt;COLLATE&lt;/code&gt; 절 (a collatable 데이터 유형이어야 함) 열에 정렬을 할당한다. 지정하지 않으면 열 데이터 유형의 기본 데이터 정렬이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fcd6b0e43a1d2817c2d32c1ebf44d3b4c6a3e75e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COLLATE&lt;/code&gt; clause overrides the collation of an expression. It is appended to the expression it applies to:</source>
          <target state="translated">&lt;code&gt;COLLATE&lt;/code&gt; 절은 표현식 의 콜 레이션 을 대체합니다. 적용되는 표현식에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="65f26ae6ee51182f66d012e018d2f6eb6c70e87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECTION LIMIT&lt;/code&gt; option is only enforced approximately; if two new sessions start at about the same time when just one connection &amp;ldquo;slot&amp;rdquo; remains for the database, it is possible that both will fail. Also, the limit is not enforced against superusers or background worker processes.</source>
          <target state="translated">&lt;code&gt;CONNECTION LIMIT&lt;/code&gt; 옵션은 약 적용됩니다; 데이터베이스에 하나의 연결 &quot;슬롯&quot;만 남아있을 때 두 개의 새 세션이 거의 동시에 시작되면 두 세션이 모두 실패 할 수 있습니다. 또한 수퍼 유저 또는 백그라운드 작업자 프로세스에는 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="062c5f519a335dcd49bb329faac889a19968f3da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECTION LIMIT&lt;/code&gt; option is only enforced approximately; if two new sessions start at about the same time when just one connection &amp;ldquo;slot&amp;rdquo; remains for the role, it is possible that both will fail. Also, the limit is never enforced for superusers.</source>
          <target state="translated">&lt;code&gt;CONNECTION LIMIT&lt;/code&gt; 옵션은 약 적용됩니다; 하나의 연결 &quot;슬롯&quot;이 역할에 남아있을 때 두 개의 새 세션이 거의 동시에 시작되면 두 세션이 모두 실패 할 수 있습니다. 또한 수퍼 유저에게는이 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b32ed065648439d92b413e5fb3a8ea0f7b10faa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CREATE CAST&lt;/code&gt; command conforms to the SQL standard, except that SQL does not make provisions for binary-coercible types or extra arguments to implementation functions. &lt;code&gt;AS IMPLICIT&lt;/code&gt; is a PostgreSQL extension, too.</source>
          <target state="translated">은 &lt;code&gt;CREATE CAST&lt;/code&gt; 그 SQL은 바이너리 강제 할 수있는 유형 또는 실행 기능에 추가 인수에 대한 조항을하지 않습니다 제외하고, 표준 SQL에 명령 부합 함을 선언합니다. &lt;code&gt;AS IMPLICIT&lt;/code&gt; 도 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="187598f79a62101321433db8a06ecc28f8a5aa54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; command largely conforms to the SQL standard; however, much as with &lt;a href=&quot;sql-createtable&quot;&gt;&lt;code&gt;CREATE TABLE&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;NULL&lt;/code&gt; constraints and zero-column foreign tables are permitted. The ability to specify column default values is also a PostgreSQL extension. Table inheritance, in the form defined by PostgreSQL, is nonstandard.</source>
          <target state="translated">는 &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; 명령을 SQL 표준에 크게 부합 함을 선언을; 그러나, 많은처럼 &lt;a href=&quot;sql-createtable&quot;&gt; &lt;code&gt;CREATE TABLE&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;NULL&lt;/code&gt; 의 제약과 제로 열 해외 테이블이 허용됩니다. 열 기본값을 지정하는 기능도 PostgreSQL 확장입니다. PostgreSQL에서 정의한 형식의 테이블 상속은 비표준입니다.</target>
        </trans-unit>
        <trans-unit id="917995eb679e93500c01bc0f518d9ec79725c204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CREATE POLICY&lt;/code&gt; command defines a new row-level security policy for a table. Note that row-level security must be enabled on the table (using &lt;code&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/code&gt;) in order for created policies to be applied.</source>
          <target state="translated">&lt;code&gt;CREATE POLICY&lt;/code&gt; 명령은 테이블에 새 행 수준의 보안 정책을 정의합니다. 작성된 정책을 적용 하려면 테이블에서 행 레벨 보안이 사용 가능해야합니다 ( &lt;code&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a5dbac1a8440c8b3a793203fdc06c7059beb8e7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CREATE ROLE&lt;/code&gt; statement is in the SQL standard, but the standard only requires the syntax</source>
          <target state="translated">&lt;code&gt;CREATE ROLE&lt;/code&gt; 문은 SQL 표준에 있지만 표준은 구문 만 필요</target>
        </trans-unit>
        <trans-unit id="d49c3d0cb3b8508e9c64a962d3f2df4b9348351f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CREATE TABLE&lt;/code&gt; command conforms to the SQL standard, with exceptions listed below.</source>
          <target state="translated">는 &lt;code&gt;CREATE TABLE&lt;/code&gt; 예외가 아래로, SQL 표준에 명령 부합 함을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="34346c5bcbf247853dd2537a0fa4acf0314be750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CREATE TRIGGER&lt;/code&gt; statement in PostgreSQL implements a subset of the SQL standard. The following functionalities are currently missing:</source>
          <target state="translated">PostgreSQL 의 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 문은 SQL 표준의 하위 집합을 구현합니다. 다음 기능이 현재 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8927a97783e527d921492294ca03418cc7bc609" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CREATE USER&lt;/code&gt; statement is a PostgreSQL extension. The SQL standard leaves the definition of users to the implementation.</source>
          <target state="translated">은 &lt;code&gt;CREATE USER&lt;/code&gt; 문은 PostgreSQL의 확장입니다. SQL 표준은 사용자 정의를 구현에 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="b56c90fb34729328b141dbd1bf882954ed24239b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CSV&lt;/code&gt; format has no standard way to distinguish a &lt;code&gt;NULL&lt;/code&gt; value from an empty string. PostgreSQL's &lt;code&gt;COPY&lt;/code&gt; handles this by quoting. A &lt;code&gt;NULL&lt;/code&gt; is output as the &lt;code&gt;NULL&lt;/code&gt; parameter string and is not quoted, while a non-&lt;code&gt;NULL&lt;/code&gt; value matching the &lt;code&gt;NULL&lt;/code&gt; parameter string is quoted. For example, with the default settings, a &lt;code&gt;NULL&lt;/code&gt; is written as an unquoted empty string, while an empty string data value is written with double quotes (&lt;code&gt;&quot;&quot;&lt;/code&gt;). Reading values follows similar rules. You can use &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; to prevent &lt;code&gt;NULL&lt;/code&gt; input comparisons for specific columns. You can also use &lt;code&gt;FORCE_NULL&lt;/code&gt; to convert quoted null string data values to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CSV&lt;/code&gt; 의 형식은 구분하는 표준 방법이 없습니다 &lt;code&gt;NULL&lt;/code&gt; 의 빈 문자열 값입니다. PostgreSQL의 &lt;code&gt;COPY&lt;/code&gt; 는이를 인용하여 처리합니다. &lt;code&gt;NULL&lt;/code&gt; 이 는 AS 출력 &lt;code&gt;NULL&lt;/code&gt; 의 비하면서, 매개 변수 문자열과 인용되지 &lt;code&gt;NULL&lt;/code&gt; 의 매칭 값 &lt;code&gt;NULL&lt;/code&gt; 의 매개 변수 문자열이 인용된다. 예를 들어, 기본 설정을 사용하면 &lt;code&gt;NULL&lt;/code&gt; 이 인용되지 않은 빈 문자열로 기록되고 빈 문자열 데이터 값은 큰 따옴표 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )로 기록됩니다. 값을 읽는 것은 비슷한 규칙을 따릅니다. &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; 을 사용 하여 특정 열에 대한 &lt;code&gt;NULL&lt;/code&gt; 입력 비교 를 방지 할 수 있습니다 . 당신은 또한 사용할 수 있습니다 &lt;code&gt;FORCE_NULL&lt;/code&gt; 따옴표로 묶인 null 문자열 데이터 값을 &lt;code&gt;NULL&lt;/code&gt; 로 변환하려면 FORCE_NULL .</target>
        </trans-unit>
        <trans-unit id="27848105f531dba37df61e0f599a930d7894c235" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CUBE&lt;/code&gt; and &lt;code&gt;ROLLUP&lt;/code&gt; constructs can be used either directly in the &lt;code&gt;GROUP BY&lt;/code&gt; clause, or nested inside a &lt;code&gt;GROUPING SETS&lt;/code&gt; clause. If one &lt;code&gt;GROUPING SETS&lt;/code&gt; clause is nested inside another, the effect is the same as if all the elements of the inner clause had been written directly in the outer clause.</source>
          <target state="translated">&lt;code&gt;CUBE&lt;/code&gt; 와 &lt;code&gt;ROLLUP&lt;/code&gt; 구조는에서 직접 사용할 수 있습니다 &lt;code&gt;GROUP BY&lt;/code&gt; 절, 또는 내에 중첩 &lt;code&gt;GROUPING SETS&lt;/code&gt; 절. 하나의 &lt;code&gt;GROUPING SETS&lt;/code&gt; 절이 다른 GROUPING SETS 절에 중첩 된 경우 내부 절의 모든 요소가 외부 절에 직접 작성된 것처럼 효과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ba5e1541f9b1c331ac56a62a8908b7b233dd2a63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CYCLE&lt;/code&gt; option allows the sequence to wrap around when the &lt;code&gt;maxvalue&lt;/code&gt; or &lt;code&gt;minvalue&lt;/code&gt; has been reached by an ascending or descending sequence respectively. If the limit is reached, the next number generated will be the &lt;code&gt;minvalue&lt;/code&gt; or &lt;code&gt;maxvalue&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;CYCLE&lt;/code&gt; 옵션 때 시퀀스 랩 어라운드 할 수 &lt;code&gt;maxvalue&lt;/code&gt; 또는 &lt;code&gt;minvalue&lt;/code&gt; 오름차순 또는 내림차순 순서 각각 도달되었다. 한계에 도달하면 다음에 생성되는 숫자는 각각 &lt;code&gt;minvalue&lt;/code&gt; 또는 &lt;code&gt;maxvalue&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b03d1a3fd7d158ee818f8642d4498091ab340a59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFAULT&lt;/code&gt; and &lt;code&gt;RESET&lt;/code&gt; forms reset the session and current user identifiers to be the originally authenticated user name. These forms can be executed by any user.</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 및 &lt;code&gt;RESET&lt;/code&gt; 형태 원래 인증 된 사용자 이름이 세션 및 현재 사용자 식별자를 재설정. 이 양식은 모든 사용자가 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96ebdb068b4855814e051da0ab472b47b8e1e75d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFAULT&lt;/code&gt; clause assigns a default data value for the column whose column definition it appears within. The value is any variable-free expression (in particular, cross-references to other columns in the current table are not allowed). Subqueries are not allowed either. The data type of the default expression must match the data type of the column.</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 의 절은 열 정의가 내에서 표시되는 열에 대한 기본 데이터 값을 할당합니다. 값은 변수가없는 표현식입니다. 특히 현재 테이블의 다른 열에 대한 상호 참조는 허용되지 않습니다. 하위 쿼리도 허용되지 않습니다. 기본 표현식의 데이터 유형은 열의 데이터 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="15b298180cf301dcc422f08d525602e45df91867" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFAULT&lt;/code&gt; clause assigns a default data value for the column whose column definition it appears within. The value is any variable-free expression (subqueries and cross-references to other columns in the current table are not allowed). The data type of the default expression must match the data type of the column.</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 의 절은 열 정의가 내에서 표시되는 열에 대한 기본 데이터 값을 할당합니다. 값은 변수가없는 표현식입니다 (현재 테이블의 다른 열에 대한 서브 쿼리 및 상호 참조는 허용되지 않음). 기본 표현식의 데이터 유형은 열의 데이터 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d20c2b5065e9f732563e6d5c0614edee39f93e17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFAULT&lt;/code&gt; clause indicates that this conversion is the default for this particular source to destination encoding. There should be only one default encoding in a schema for the encoding pair.</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 의 절은이 변환 대상 인코딩이 특정 소스에 대한 기본 있음을 나타냅니다. 인코딩 쌍의 스키마에는 기본 인코딩이 하나만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a609d2e53efa3c746223bd6d1fa685e36d7c5fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFAULT&lt;/code&gt; clause specifies a default value for columns of the domain data type. The value is any variable-free expression (but subqueries are not allowed). The data type of the default expression must match the data type of the domain. If no default value is specified, then the default value is the null value.</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 의 절은 도메인 데이터 유형의 컬럼에 대한 기본 값을 지정합니다. 값은 변수가없는 표현식입니다 (하위 조회는 허용되지 않음). 기본 표현식의 데이터 유형은 도메인의 데이터 유형과 일치해야합니다. 기본값이 지정되지 않은 경우 기본값은 널값입니다.</target>
        </trans-unit>
        <trans-unit id="2f90ae9cfb7477e295a6a04f820259e7d83d6550" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFERRABLE&lt;/code&gt; transaction property has no effect unless the transaction is also &lt;code&gt;SERIALIZABLE&lt;/code&gt; and &lt;code&gt;READ ONLY&lt;/code&gt;. When all three of these properties are selected for a transaction, the transaction may block when first acquiring its snapshot, after which it is able to run without the normal overhead of a &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction and without any risk of contributing to or being canceled by a serialization failure. This mode is well suited for long-running reports or backups.</source>
          <target state="translated">&lt;code&gt;DEFERRABLE&lt;/code&gt; 트랜잭션도되지 않는 트랜잭션 속성은 효과가 없습니다 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 및 &lt;code&gt;READ ONLY&lt;/code&gt; . 이러한 속성 중 세 가지 속성이 모두 트랜잭션에 대해 선택되면 트랜잭션은 스냅 샷을 처음 획득 할 때 차단 될 수 있으며, 그 후에는 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 트랜잭션 의 정상적인 오버 헤드없이, 직렬화 에 기여하거나 취소 될 위험없이 실행할 수 있습니다. 실패. 이 모드는 장시간 실행되는 보고서 또는 백업에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="47fbcdc5947ad1b3ef7ef06deb64e49ce2369a35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEFERRABLE&lt;/code&gt;&lt;code&gt;transaction_mode&lt;/code&gt; is a PostgreSQL language extension.</source>
          <target state="translated">&lt;code&gt;DEFERRABLE&lt;/code&gt; &lt;code&gt;transaction_mode&lt;/code&gt; PostgreSQL의 언어 확장입니다.</target>
        </trans-unit>
        <trans-unit id="7f66a213e419ed48c08ff0291b264323bc02332e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; will have no effect even though there is a &lt;code&gt;website.hits = 10&lt;/code&gt; row before and after the &lt;code&gt;UPDATE&lt;/code&gt;. This occurs because the pre-update row value &lt;code&gt;9&lt;/code&gt; is skipped, and when the &lt;code&gt;UPDATE&lt;/code&gt; completes and &lt;code&gt;DELETE&lt;/code&gt; obtains a lock, the new row value is no longer &lt;code&gt;10&lt;/code&gt; but &lt;code&gt;11&lt;/code&gt;, which no longer matches the criteria.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 는 이 경우에도 아무런 영향을주지 않습니다 &lt;code&gt;website.hits = 10&lt;/code&gt; 이전과 이후 행을 &lt;code&gt;UPDATE&lt;/code&gt; . 이는 사전 갱신 행 값 &lt;code&gt;9&lt;/code&gt; 를 건너 뛰고 &lt;code&gt;UPDATE&lt;/code&gt; 가 완료되고 &lt;code&gt;DELETE&lt;/code&gt; 가 잠금을 확보 할 때 새 행 값이 더 이상 &lt;code&gt;10&lt;/code&gt; 이 아니라 &lt;code&gt;11&lt;/code&gt; 이므로 더 이상 기준과 일치하지 않기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b30c741a4b6acac36c3c1f49255bfc747dff96b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEPENDS ON EXTENSION&lt;/code&gt; form marks the materialized view as dependent on an extension, such that the materialized view will automatically be dropped if the extension is dropped.</source>
          <target state="translated">&lt;code&gt;DEPENDS ON EXTENSION&lt;/code&gt; 형태의 표시는 확장이 삭제되는 경우 구체화 된 뷰가 자동으로 삭제됩니다 있도록, 확장에 따라 같은보기를 구체화.</target>
        </trans-unit>
        <trans-unit id="ee755c1de2060e56203798a2286c488803c96944" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DISTINCT ON&lt;/code&gt; clause is not part of the SQL standard and is sometimes considered bad style because of the potentially indeterminate nature of its results. With judicious use of &lt;code&gt;GROUP BY&lt;/code&gt; and subqueries in &lt;code&gt;FROM&lt;/code&gt;, this construct can be avoided, but it is often the most convenient alternative.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 의 절은 SQL 표준의 일부가 아닌 때로는 때문에 결과의 가능성이 불확실한 성격 나쁜 스타일로 간주됩니다. &lt;code&gt;FROM&lt;/code&gt; 에서 &lt;code&gt;GROUP BY&lt;/code&gt; 와 하위 쿼리를 신중하게 사용하면 이 구문을 피할 수 있지만 가장 편리한 대안입니다.</target>
        </trans-unit>
        <trans-unit id="8263d90ff6ffdae1372239c757291f48e712a876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DISTINCT ON&lt;/code&gt; expression(s) must match the leftmost &lt;code&gt;ORDER BY&lt;/code&gt; expression(s). The &lt;code&gt;ORDER BY&lt;/code&gt; clause will normally contain additional expression(s) that determine the desired precedence of rows within each &lt;code&gt;DISTINCT ON&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;DISTINCT ON&lt;/code&gt; 의 발현 (들)은 왼쪽 일치해야 &lt;code&gt;ORDER BY&lt;/code&gt; 표현 (들). &lt;code&gt;ORDER BY&lt;/code&gt; 절은 일반적으로 각 내 행의 원하는 우선 순위를 결정하는 추가 표현 (들)이 포함됩니다 &lt;code&gt;DISTINCT ON&lt;/code&gt; 의 그룹.</target>
        </trans-unit>
        <trans-unit id="44806e39c2022da7c6348cbee79866dd830d6678" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DROP CAST&lt;/code&gt; command conforms to the SQL standard.</source>
          <target state="translated">&lt;code&gt;DROP CAST&lt;/code&gt; 표준 SQL 명령을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="f14ad5d45be2726fe2c215fbfcdcda187612c03b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DROP COLLATION&lt;/code&gt; command conforms to the SQL standard, apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;DROP COLLATION&lt;/code&gt; 표준 SQL 명령 부합 함을 선언는 떨어져에서 &lt;code&gt;IF EXISTS&lt;/code&gt; PostgreSQL의 확장입니다 옵션을.</target>
        </trans-unit>
        <trans-unit id="5b716fa2947bc8274f82c911c00d79b442281591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DROP COLUMN&lt;/code&gt; form does not physically remove the column, but simply makes it invisible to SQL operations. Subsequent insert and update operations in the table will store a null value for the column. Thus, dropping a column is quick but it will not immediately reduce the on-disk size of your table, as the space occupied by the dropped column is not reclaimed. The space will be reclaimed over time as existing rows are updated.</source>
          <target state="translated">&lt;code&gt;DROP COLUMN&lt;/code&gt; 형태는 물리적으로 열을 제거 할 수 있지만 단순히 SQL 작업에이 보이지 않게되지 않습니다. 이후의 테이블에 삽입 및 업데이트 작업을 수행하면 열에 null 값이 저장됩니다. 따라서 열을 삭제하는 것은 빠르지 만 삭제 된 열이 차지하는 공간이 회수되지 않기 때문에 테이블의 디스크 크기를 즉시 줄이지 않습니다. 기존 행이 업데이트되면 시간이 지남에 따라 공간이 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="6145d898e7e666ea7b82181b35386eff8e943642" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DROP OWNED&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;DROP OWNED&lt;/code&gt; 명령은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="958d248668cd8315457da47d07fa5a9121607f5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DROP TRIGGER&lt;/code&gt; statement in PostgreSQL is incompatible with the SQL standard. In the SQL standard, trigger names are not local to tables, so the command is simply &lt;code&gt;DROP TRIGGER name&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 의 &lt;code&gt;DROP TRIGGER&lt;/code&gt; 문은 SQL 표준과 호환되지 않습니다. SQL 표준에서 트리거 이름은 테이블에 대해 로컬이 아니므로 명령은 단순히 &lt;code&gt;DROP TRIGGER name&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32ebe00e2f6bc9c860af0307e68495e786a216ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DROP USER&lt;/code&gt; statement is a PostgreSQL extension. The SQL standard leaves the definition of users to the implementation.</source>
          <target state="translated">&lt;code&gt;DROP USER&lt;/code&gt; 문은 PostgreSQL의 확장입니다. SQL 표준은 사용자 정의를 구현에 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="4895a1ee67fd5261253d3006ec43de9052ff83a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXCEPT&lt;/code&gt; clause has this general form:</source>
          <target state="translated">&lt;code&gt;EXCEPT&lt;/code&gt; 조항이 일반 형식은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="53587bd6a69d2af3b71efe62992f03f5ab23d877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXCEPT&lt;/code&gt; operator computes the set of rows that are in the result of the left &lt;code&gt;SELECT&lt;/code&gt; statement but not in the result of the right one.</source>
          <target state="translated">&lt;code&gt;EXCEPT&lt;/code&gt; 연산자는 왼쪽의 결과에 행 세트 계산 &lt;code&gt;SELECT&lt;/code&gt; 문이 아니라 바로 하나의 결과에있다.</target>
        </trans-unit>
        <trans-unit id="39954f4150bc5ded7310764e89ef32cdf830e19c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXCLUDE&lt;/code&gt; clause defines an exclusion constraint, which guarantees that if any two rows are compared on the specified column(s) or expression(s) using the specified operator(s), not all of these comparisons will return &lt;code&gt;TRUE&lt;/code&gt;. If all of the specified operators test for equality, this is equivalent to a &lt;code&gt;UNIQUE&lt;/code&gt; constraint, although an ordinary unique constraint will be faster. However, exclusion constraints can specify constraints that are more general than simple equality. For example, you can specify a constraint that no two rows in the table contain overlapping circles (see &lt;a href=&quot;datatype-geometric&quot;&gt;Section 8.8&lt;/a&gt;) by using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">은 &lt;code&gt;EXCLUDE&lt;/code&gt; 절은 두 행이 지정된 운영자 (들)를 사용하여 지정된 컬럼 (들) 또는 식 (들)에 비교되는 경우 보장 제외 제약, 모든 이러한 비교의 반환 정의 &lt;code&gt;TRUE&lt;/code&gt; 를 . 지정된 모든 연산자가 동등성을 테스트 하는 경우 일반 고유 제한 조건이 더 빠르더라도 &lt;code&gt;UNIQUE&lt;/code&gt; 제한 조건 과 같습니다 . 그러나 제외 제약 조건은 단순한 평등보다 일반적인 제약 조건을 지정할 수 있습니다. 예를 들어, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자 를 사용하여 테이블의 두 행에 겹치는 원이 포함되지 않는 제약 조건을 지정할 수 있습니다 ( &lt;a href=&quot;datatype-geometric&quot;&gt;섹션 8.8&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="8d05f597aad03abfc46ad2fda9a47250135456bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXCLUDE&lt;/code&gt; constraint type is a PostgreSQL extension.</source>
          <target state="translated">는 &lt;code&gt;EXCLUDE&lt;/code&gt; 제한 유형은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="5ef31faef2ced2929c428f4e11e5e16c8210dea0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Execution time&lt;/code&gt; shown by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; includes executor start-up and shut-down time, as well as the time to run any triggers that are fired, but it does not include parsing, rewriting, or planning time. Time spent executing &lt;code&gt;BEFORE&lt;/code&gt; triggers, if any, is included in the time for the related Insert, Update, or Delete node; but time spent executing &lt;code&gt;AFTER&lt;/code&gt; triggers is not counted there because &lt;code&gt;AFTER&lt;/code&gt; triggers are fired after completion of the whole plan. The total time spent in each trigger (either &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt;) is also shown separately. Note that deferred constraint triggers will not be executed until end of transaction and are thus not considered at all by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Execution time&lt;/code&gt; 으로 표시 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 포함 집행자 최대-시작과 종료가 다운 시간뿐만 아니라 시간이 해고되는 모든 트리거를 실행하지만, 다시 쓰기, 구문 분석, 또는 계획 시간은 포함되지 않습니다. &lt;code&gt;BEFORE&lt;/code&gt; 트리거 (있는 경우)를 실행하는 데 소요 된 시간은 관련 삽입, 업데이트 또는 삭제 노드 시간에 포함됩니다. 하지만 시간이 실행하는 데 &lt;code&gt;AFTER&lt;/code&gt; 때문에이 계산되지 않습니다 트리거 &lt;code&gt;AFTER&lt;/code&gt; 의 트리거가 전체 계획의 완료 후 해고된다. 각 트리거에 소요 된 총 시간 ( &lt;code&gt;BEFORE&lt;/code&gt; 또는 &lt;code&gt;AFTER&lt;/code&gt; ))도 별도로 표시됩니다. 지연된 제약 조건 트리거는 트랜잭션이 끝날 때까지 실행되지 않으므로 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 에 의해 전혀 고려되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ae6e95540d22517d9811c9ef931b02dd140cfce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FETCH&lt;/code&gt; forms involving &lt;code&gt;FORWARD&lt;/code&gt; and &lt;code&gt;BACKWARD&lt;/code&gt;, as well as the forms &lt;code&gt;FETCH count&lt;/code&gt; and &lt;code&gt;FETCH ALL&lt;/code&gt;, in which &lt;code&gt;FORWARD&lt;/code&gt; is implicit, are PostgreSQL extensions.</source>
          <target state="translated">&lt;code&gt;FETCH&lt;/code&gt; 포함하는 형태 &lt;code&gt;FORWARD&lt;/code&gt; 및 &lt;code&gt;BACKWARD&lt;/code&gt; 을 뿐만 아니라 형태의 &lt;code&gt;FETCH count&lt;/code&gt; 및 &lt;code&gt;FETCH ALL&lt;/code&gt; 하는, &lt;code&gt;FORWARD&lt;/code&gt; 는 암시 적이다, PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="65f079b4eb99abf10f8495ff6808e8dab09683cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOR UPDATE&lt;/code&gt; lock mode is also acquired by any &lt;code&gt;DELETE&lt;/code&gt; on a row, and also by an &lt;code&gt;UPDATE&lt;/code&gt; that modifies the values of certain columns. Currently, the set of columns considered for the &lt;code&gt;UPDATE&lt;/code&gt; case are those that have a unique index on them that can be used in a foreign key (so partial indexes and expressional indexes are not considered), but this may change in the future.</source>
          <target state="translated">&lt;code&gt;FOR UPDATE&lt;/code&gt; 로크 모드는 어느 것에 의해 취득 &lt;code&gt;DELETE&lt;/code&gt; 의해서도하는 행 및 &lt;code&gt;UPDATE&lt;/code&gt; 특정 컬럼의 수정 값. 현재 &lt;code&gt;UPDATE&lt;/code&gt; 케이스에 대해 고려되는 컬럼 세트는 외래 키에서 사용할 수있는 고유 인덱스가있는 컬럼 세트이지만 (따라서 부분 인덱스 및 표현식 인덱스는 고려되지 않음) 이는 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73dfff30b656da6fc9301e9d60e5d477ad1f8673" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOR UPDATE&lt;/code&gt; lock mode is also acquired by any &lt;code&gt;DELETE&lt;/code&gt; on a row, and also by an &lt;code&gt;UPDATE&lt;/code&gt; that modifies the values on certain columns. Currently, the set of columns considered for the &lt;code&gt;UPDATE&lt;/code&gt; case are those that have a unique index on them that can be used in a foreign key (so partial indexes and expressional indexes are not considered), but this may change in the future.</source>
          <target state="translated">&lt;code&gt;FOR UPDATE&lt;/code&gt; 로크 모드는 어느 것에 의해 취득 &lt;code&gt;DELETE&lt;/code&gt; 의해서도하는 행 및 &lt;code&gt;UPDATE&lt;/code&gt; 특정 열에 수정 값있다. 현재 &lt;code&gt;UPDATE&lt;/code&gt; 케이스에 대해 고려되는 컬럼 세트는 외래 키에서 사용할 수있는 고유 인덱스가있는 컬럼 세트입니다 (따라서 부분 인덱스 및 표현식 인덱스는 고려되지 않음). 그러나 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="331b0e81a9e755c3a0e45ecf0ec49020dc596e7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; clause can contain the following elements:</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절은 다음과 같은 요소를 포함 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="33f40d521a946b2dec0d730c44a73f3bb8392cb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; clause must define the output as one &lt;code&gt;row_name&lt;/code&gt; column (of the same data type as the first result column of the SQL query) followed by N &lt;code&gt;value&lt;/code&gt; columns (all of the same data type as the third result column of the SQL query). You can set up as many output value columns as you wish. The names of the output columns are up to you.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절은 하나의 출력 정의해야 &lt;code&gt;row_name&lt;/code&gt; (SQL 쿼리의 첫번째 결과 열과 동일한 데이터 형식의) 열 N의 그 다음 &lt;code&gt;value&lt;/code&gt; 열 (SQL 쿼리의 세 번째 결과 열과 동일한 데이터 유형의 모든). 원하는만큼 출력 값 열을 설정할 수 있습니다. 출력 열의 이름은 귀하에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="e92c609479b0621a0fc990292248501743a4d3fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; clause must define the proper number of output columns of the proper data types. If there are &lt;code&gt;N&lt;/code&gt; columns in the &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; query's result, the first &lt;code&gt;N&lt;/code&gt;-2 of them must match up with the first &lt;code&gt;N&lt;/code&gt;-2 output columns. The remaining output columns must have the type of the last column of the &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; query's result, and there must be exactly as many of them as there are rows in the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query's result.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절 적절한 데이터 형식의 출력 컬럼의 적절한 수를 정의한다. &lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt; 쿼리 결과 에 &lt;code&gt;N&lt;/code&gt; 개의 열 이 있으면 첫 번째 &lt;code&gt;N&lt;/code&gt; - 2가 첫 번째 &lt;code&gt;N&lt;/code&gt; - 2 출력 열과 일치해야합니다 . 나머지 출력 열에는 &lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt; 쿼리 결과 의 마지막 열 유형 이 있어야하며 &lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt; 쿼리 결과에 행이있는 수만큼 정확하게 있어야합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14bc91205c368d8f257ab9f701c65d7558eeaba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; clause specifies one or more source tables for the &lt;code&gt;SELECT&lt;/code&gt;. If multiple sources are specified, the result is the Cartesian product (cross join) of all the sources. But usually qualification conditions are added (via &lt;code&gt;WHERE&lt;/code&gt;) to restrict the returned rows to a small subset of the Cartesian product.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절은 하나 개 이상의 소스 테이블을 지정 &lt;code&gt;SELECT&lt;/code&gt; 를 . 여러 소스를 지정하면 모든 소스의 직교 곱 (교차 조인)이 결과입니다. 그러나 일반적으로 자격 조건이 추가되어 ( &lt;code&gt;WHERE&lt;/code&gt; 를 통해 ) 리턴 된 행을 카티 전 곱의 작은 서브 세트로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="8313aa4c308ea39cfdceb940bf96c5903be8aa0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FULL&lt;/code&gt; option is not recommended for routine use, but might be useful in special cases. An example is when you have deleted or updated most of the rows in a table and would like the table to physically shrink to occupy less disk space and allow faster table scans. &lt;code&gt;VACUUM FULL&lt;/code&gt; will usually shrink the table more than a plain &lt;code&gt;VACUUM&lt;/code&gt; would.</source>
          <target state="translated">&lt;code&gt;FULL&lt;/code&gt; 옵션은 일상적인 사용하지 않는 것이 좋습니다,하지만 특별한 경우에 유용 할 수 있습니다. 예를 들어 테이블에서 대부분의 행을 삭제하거나 업데이트 한 경우 테이블이 디스크 공간을 덜 차지하고 테이블 스캔 속도를 높이기 위해 물리적으로 테이블을 축소하려는 경우가 있습니다. &lt;code&gt;VACUUM FULL&lt;/code&gt; 은 보통 일반 &lt;code&gt;VACUUM&lt;/code&gt; 보다 테이블을 축소합니다 .</target>
        </trans-unit>
        <trans-unit id="86d3075313d2af14321def3b31e24ee35c8613b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FUNCTION&lt;/code&gt; syntax works for plain functions, aggregate functions, and window functions, but not for procedures; use &lt;code&gt;PROCEDURE&lt;/code&gt; for those. Alternatively, use &lt;code&gt;ROUTINE&lt;/code&gt; to refer to a function, aggregate function, window function, or procedure regardless of its precise type.</source>
          <target state="translated">&lt;code&gt;FUNCTION&lt;/code&gt; 구문은 일반 함수, 집계 함수 및 윈도우 기능,하지만 절차 작동; 그것들을 위해 &lt;code&gt;PROCEDURE&lt;/code&gt; 를 사용하십시오 . 또는 &lt;code&gt;ROUTINE&lt;/code&gt; 을 사용 하여 정확한 유형에 관계없이 함수, 집계 함수, 창 함수 또는 프로 시저를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="891e1ca441e57fd00db2b454308f10eee7754380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GRANT&lt;/code&gt; command has two basic variants: one that grants privileges on a database object (table, column, view, foreign table, sequence, database, foreign-data wrapper, foreign server, function, procedure, procedural language, schema, or tablespace), and one that grants membership in a role. These variants are similar in many ways, but they are different enough to be described separately.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; 의 명령은 두 가지 기본 변형이 있습니다 하나를 그 데이터베이스 오브젝트에 대한 권한을 부여합니다 (테이블, 열, 뷰, 외부 테이블, 순서, 데이터베이스, 외부 데이터 래퍼, 외국 서버, 기능, 절차, 절차 적 언어, 스키마 또는 테이블) , 그리고 역할의 멤버 자격을 부여하는 것. 이러한 변형은 여러면에서 유사하지만 별도로 설명하기에 충분히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="977eda311d1d79116b5b2c2b5a0874f5382d192d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; functions select the largest or smallest value from a list of any number of expressions. The expressions must all be convertible to a common data type, which will be the type of the result (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for details). NULL values in the list are ignored. The result will be NULL only if all the expressions evaluate to NULL.</source>
          <target state="translated">&lt;code&gt;GREATEST&lt;/code&gt; 와 &lt;code&gt;LEAST&lt;/code&gt; 함수는 식의 수의 목록에서 가장 큰 또는 작은 값을 선택합니다. 표현식은 모두 공통 데이터 유형으로 변환 할 수 있어야하며 이는 결과 유형입니다 (자세한 내용 &lt;a href=&quot;typeconv-union-case&quot;&gt;은 10.5 절&lt;/a&gt; 참조). 목록의 NULL 값은 무시됩니다. 모든 표현식이 NULL로 평가되는 경우에만 결과가 NULL이됩니다.</target>
        </trans-unit>
        <trans-unit id="be0fc3f52ed935023eedfa0731ed1d21af66f490" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IF EXISTS&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;IF EXISTS&lt;/code&gt; 옵션을</target>
        </trans-unit>
        <trans-unit id="57bce4e9bdfa25f76d925fb142ebe6e3e8f8396d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IF NOT EXISTS&lt;/code&gt; option is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;IF NOT EXISTS&lt;/code&gt; 옵션은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="90c655a8d399c68ec546283b401cd86c6d3da561" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command conforms to the SQL standard, except that the &lt;code&gt;OPTIONS&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; 표준 SQL 명령 부합 함을 선언는 점을 제외하고 &lt;code&gt;OPTIONS&lt;/code&gt; 절은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="e2a88d188f36cc114975839b521433281fe355dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN ROLE&lt;/code&gt; clause lists one or more existing roles to which the new role will be immediately added as a new member. (Note that there is no option to add the new role as an administrator; use a separate &lt;code&gt;GRANT&lt;/code&gt; command to do that.)</source>
          <target state="translated">&lt;code&gt;IN ROLE&lt;/code&gt; 절 목록에 하나 이상의 기존 역할이있는 새 역할은 바로 새로운 구성원으로 추가됩니다. (관리자로서 새 역할을 추가 할 수있는 옵션이 없으므로 별도의 &lt;code&gt;GRANT&lt;/code&gt; 명령을 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3b0c6bd082b9438730c44b123984d29738293313" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INHERIT&lt;/code&gt; attribute governs inheritance of grantable privileges (that is, access privileges for database objects and role memberships). It does not apply to the special role attributes set by &lt;code&gt;CREATE ROLE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt;. For example, being a member of a role with &lt;code&gt;CREATEDB&lt;/code&gt; privilege does not immediately grant the ability to create databases, even if &lt;code&gt;INHERIT&lt;/code&gt; is set; it would be necessary to become that role via &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; before creating a database.</source>
          <target state="translated">&lt;code&gt;INHERIT&lt;/code&gt; 의 (이다, 데이터베이스 객체 및 역할 구성원에 대한 액세스 권한) 부여 가능한 권한의 특성을 다스리 상속. &lt;code&gt;CREATE ROLE&lt;/code&gt; 및 &lt;code&gt;ALTER ROLE&lt;/code&gt; 에 의해 설정된 특수 역할 속성에는 적용되지 않습니다 . 예를 들어, &lt;code&gt;CREATEDB&lt;/code&gt; 권한이 있는 역할의 멤버가 되더라도 &lt;code&gt;INHERIT&lt;/code&gt; 이 설정되어 있어도 데이터베이스를 작성하는 기능이 즉시 부여되지는 않습니다 . 데이터베이스를 작성하기 전에 &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 을 통해 해당 역할이되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="11950124f137ab1b3b29d5312c33140b0085fa30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INHERIT&lt;/code&gt; attribute is the default for reasons of backwards compatibility: in prior releases of PostgreSQL, users always had access to all privileges of groups they were members of. However, &lt;code&gt;NOINHERIT&lt;/code&gt; provides a closer match to the semantics specified in the SQL standard.</source>
          <target state="translated">&lt;code&gt;INHERIT&lt;/code&gt; 의 속성은 이전 버전과의 호환성의 이유에 대한 기본값입니다 PostgreSQL을의 이전 릴리스에서, 사용자는 항상이의 일원이었다 그룹의 모든 권한에 접근했다. 그러나 &lt;code&gt;NOINHERIT&lt;/code&gt; 는 SQL 표준에 지정된 의미론과 더 밀접하게 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d1a4f9690ce7e26c8924892aa7417c3dc21a3ae2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INSERT&lt;/code&gt; statement is used to populate a table with rows:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 의 문은 행 테이블을 채우는 데 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="bb164c110048f642f9967f6798e5f2daa48843e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INTERSECT&lt;/code&gt; clause has this general form:</source>
          <target state="translated">&lt;code&gt;INTERSECT&lt;/code&gt; 의 절은이 일반적인 형식은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="b0af4aa2cff56983554b5dfd6aea4022d42a30a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INTERSECT&lt;/code&gt; operator computes the set intersection of the rows returned by the involved &lt;code&gt;SELECT&lt;/code&gt; statements. A row is in the intersection of two result sets if it appears in both result sets.</source>
          <target state="translated">&lt;code&gt;INTERSECT&lt;/code&gt; 의 작업자가 개입하여 리턴 된 행 세트 교차점 계산 &lt;code&gt;SELECT&lt;/code&gt; 문. 두 결과 세트 모두에 표시되는 경우 두 결과 세트의 교차 부분에 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3710966a5964edf86a5e94dad6ccef2f09e50690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ISBN&lt;/code&gt;, &lt;code&gt;ISMN&lt;/code&gt;, and &lt;code&gt;ISSN&lt;/code&gt; types will display the short version of the number (ISxN 10) whenever it's possible, and will show ISxN 13 format for numbers that do not fit in the short version. The &lt;code&gt;EAN13&lt;/code&gt;, &lt;code&gt;ISBN13&lt;/code&gt;, &lt;code&gt;ISMN13&lt;/code&gt; and &lt;code&gt;ISSN13&lt;/code&gt; types will always display the long version of the ISxN (EAN13).</source>
          <target state="translated">&lt;code&gt;ISBN&lt;/code&gt; , &lt;code&gt;ISMN&lt;/code&gt; 및 &lt;code&gt;ISSN&lt;/code&gt; 의 유형은 가능 할 때마다 수 (ISxN 10)의 짧은 버전을 표시하고, 짧은 버전에 맞지 않는 번호를 ISxN (13) 형식으로 표시됩니다. &lt;code&gt;EAN13&lt;/code&gt; , &lt;code&gt;ISBN13&lt;/code&gt; , &lt;code&gt;ISMN13&lt;/code&gt; 및 &lt;code&gt;ISSN13&lt;/code&gt; 유형은 항상 ISxN (EAN13)의 긴 버전을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7b1a2d9b3af27ec14ac83825b4e9390e81b28ab6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IntervalStyle&lt;/code&gt; parameter also affects the interpretation of ambiguous interval input. See &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-INPUT&quot;&gt;Section 8.5.4&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;IntervalStyle&lt;/code&gt; 의 매개 변수는 간격 모호한 입력의 해석에 영향을 미친다. 자세한 정보는 &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-INPUT&quot;&gt;섹션 8.5.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cb07a7b0b456e75c7d7fb8309d5a950ea4dfdb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LATERAL&lt;/code&gt; key word can precede a sub-&lt;code&gt;SELECT&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item. This allows the sub-&lt;code&gt;SELECT&lt;/code&gt; to refer to columns of &lt;code&gt;FROM&lt;/code&gt; items that appear before it in the &lt;code&gt;FROM&lt;/code&gt; list. (Without &lt;code&gt;LATERAL&lt;/code&gt;, each sub-&lt;code&gt;SELECT&lt;/code&gt; is evaluated independently and so cannot cross-reference any other &lt;code&gt;FROM&lt;/code&gt; item.)</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; 키워드는이 하위에 선행 할 수 &lt;code&gt;SELECT&lt;/code&gt; &lt;code&gt;FROM&lt;/code&gt; 항목입니다. 이를 통해 하위 &lt;code&gt;SELECT&lt;/code&gt; 는 &lt;code&gt;FROM&lt;/code&gt; 목록 에서 앞에 나오는 &lt;code&gt;FROM&lt;/code&gt; 항목의 열을 참조 할 수 있습니다 . &lt;code&gt;LATERAL&lt;/code&gt; 이 없으면 각 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 독립적으로 평가되므로 다른 &lt;code&gt;FROM&lt;/code&gt; 항목을 상호 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0a14b782795f85302f04f02639a6c4f62ab4e062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; clause can also be used to copy column definitions from views, foreign tables, or composite types. Inapplicable options (e.g., &lt;code&gt;INCLUDING INDEXES&lt;/code&gt; from a view) are ignored.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 의 절은 조회수, 외부 테이블, 또는 복합 형 정의로부터 열을 복사 할 수있다. 적용 할 수없는 옵션 (예 : 뷰에서 &lt;code&gt;INCLUDING INDEXES&lt;/code&gt; )은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="396ab12c5362824aaa283637f9c77c9a00f331f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; clause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 의 절을 지정 테이블에있는 새 테이블이 자동으로 복사 모든 열 이름에서, 데이터 유형, 그들의하지 null이 제약.</target>
        </trans-unit>
        <trans-unit id="572dfcd3f9f7897b067c547ebc46891efd6417fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; expression returns true if the &lt;code&gt;string&lt;/code&gt; matches the supplied &lt;code&gt;pattern&lt;/code&gt;. (As expected, the &lt;code&gt;NOT LIKE&lt;/code&gt; expression returns false if &lt;code&gt;LIKE&lt;/code&gt; returns true, and vice versa. An equivalent expression is &lt;code&gt;NOT (string LIKE pattern)&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 의 경우 생성 표현식이 true 반환 &lt;code&gt;string&lt;/code&gt; 제공된 일치하는 &lt;code&gt;pattern&lt;/code&gt; . (예상대로 &lt;code&gt;LIKE&lt;/code&gt; 가 true를 리턴 하면 &lt;code&gt;NOT LIKE&lt;/code&gt; 표현식은 false를 리턴하고 그 반대도 마찬가지입니다. 동등한 표현식은 &lt;code&gt;NOT (string LIKE pattern)&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="258e69d1b09cf77569de7c47f8a8dba66e04bb7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; operator does pattern matching and is explained in &lt;a href=&quot;functions-matching&quot;&gt;Section 9.7&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 의 운영자는 패턴 매칭을 수행하고 설명한다 &lt;a href=&quot;functions-matching&quot;&gt;섹션 9.7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7480e6b2427d5d0d2afbc0d3981cabf8d8c5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIMIT&lt;/code&gt; clause consists of two independent sub-clauses:</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; 의 절은 두 개의 독립적 인 하위 절로 구성되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="708ccea922303afce980063d897062a660ce918c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;M&lt;/code&gt; format is sufficient to describe many common daylight-savings transition laws. But note that none of these variants can deal with daylight-savings law changes, so in practice the historical data stored for named time zones (in the IANA time zone database) is necessary to interpret past time stamps correctly.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 의 형식은 많은 일반적인 일광 절약 전이 법을 설명하기에 충분하다. 그러나 이러한 변형 중 어느 것도 일광 절약 법칙 변경을 처리 할 수 ​​없으므로 실제로 과거 타임 스탬프를 올바르게 해석하려면 명명 된 시간대 (IAA 시간대 데이터베이스에 있음)에 대해 저장된 과거 데이터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5092a579b1157c3ece79f6e0b69fb148ae975b71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MATERIALIZED&lt;/code&gt; and &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; options of &lt;code&gt;WITH&lt;/code&gt; are extensions of the SQL standard.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 &lt;code&gt;MATERIALIZED&lt;/code&gt; 및 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 옵션은 SQL 표준의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="03c245095fff9e37994e71505cc2de7e6fbaeb07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MergeJoin&lt;/code&gt; node similarly demands the first row from its right subplan. Then it compares the two rows to see if they can be joined; if so, it returns a join row to its caller. On the next call, or immediately if it cannot join the current pair of inputs, it advances to the next row of one table or the other (depending on how the comparison came out), and again checks for a match. Eventually, one subplan or the other is exhausted, and the &lt;code&gt;MergeJoin&lt;/code&gt; node returns NULL to indicate that no more join rows can be formed.</source>
          <target state="translated">&lt;code&gt;MergeJoin&lt;/code&gt; 의 노드는 유사하게 오른쪽 하위 계획에서 첫 번째 행을 요구한다. 그런 다음 두 행을 비교하여 이들이 결합 될 수 있는지 확인합니다. 그렇다면, 호출자에게 조인 행을 리턴합니다. 다음 호출에서 또는 현재 입력 쌍을 조인 할 수없는 경우 즉시 한 테이블의 다음 행 또는 다른 행으로 진행하여 (비교 방법에 따라) 일치 여부를 다시 확인합니다. 결국 하나의 하위 계획 또는 다른 하위 계획이 소진되고 &lt;code&gt;MergeJoin&lt;/code&gt; 노드는 NULL을 반환하여 더 이상 조인 행을 만들 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50c96e90dd3ca2b2b4787fd18890dca99f28ab8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NONE&lt;/code&gt; and &lt;code&gt;RESET&lt;/code&gt; forms reset the current user identifier to be the current session user identifier. These forms can be executed by any user.</source>
          <target state="translated">&lt;code&gt;NONE&lt;/code&gt; 과 &lt;code&gt;RESET&lt;/code&gt; 형태는 현재 세션의 사용자 식별자로 현재의 사용자 식별자를 재설정. 이 양식은 모든 사용자가 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b13dc16a3a4fce3da18ccb704fb39295955bdea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOT NULL&lt;/code&gt; constraint has an inverse: the &lt;code&gt;NULL&lt;/code&gt; constraint. This does not mean that the column must be null, which would surely be useless. Instead, this simply selects the default behavior that the column might be null. The &lt;code&gt;NULL&lt;/code&gt; constraint is not present in the SQL standard and should not be used in portable applications. (It was only added to PostgreSQL to be compatible with some other database systems.) Some users, however, like it because it makes it easy to toggle the constraint in a script file. For example, you could start with:</source>
          <target state="translated">&lt;code&gt;NOT NULL&lt;/code&gt; 의 : 제약은 역이 &lt;code&gt;NULL&lt;/code&gt; 의 제약 조건을. 그렇다고해서 열이 null이어야한다는 의미는 아니며 반드시 쓸모가 없습니다. 대신 이것은 단순히 열이 null 일 수있는 기본 동작을 선택합니다. &lt;code&gt;NULL&lt;/code&gt; 의 제약 조건은 SQL 표준에없는 휴대용 애플리케이션에서 사용할 수 없습니다. (일부 다른 데이터베이스 시스템과 호환되도록 PostgreSQL에만 추가되었습니다.) 그러나 일부 사용자는 스크립트 파일에서 제약 조건을 쉽게 전환 할 수 있기 때문에 좋아합니다. 예를 들어 다음과 같이 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea1d2c35460104bbb73410ce7cfdee6383ad73d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOTIFY&lt;/code&gt; command sends a notification event together with an optional &amp;ldquo;payload&amp;rdquo; string to each client application that has previously executed &lt;code&gt;LISTEN channel&lt;/code&gt; for the specified channel name in the current database. Notifications are visible to all users.</source>
          <target state="translated">는 &lt;code&gt;NOTIFY&lt;/code&gt; 명령은 이전에 실행 한 각 클라이언트 응용 프로그램 선택 &quot;페이로드&quot;문자열과 함께 알림 이벤트를 송신 &lt;code&gt;LISTEN channel&lt;/code&gt; 현재 데이터베이스에서 지정된 채널 이름을. 모든 사용자에게 알림이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc1aa8547d4f45a3a74ddce2ee6f66c1ad2e63b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULL&lt;/code&gt; keyword is case-insensitive. Double-quote the &lt;code&gt;NULL&lt;/code&gt; to treat it as the ordinary string &amp;ldquo;NULL&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 의 키워드는 대소 문자를 구분합니다. &lt;code&gt;NULL&lt;/code&gt; 을 큰 따옴표로 묶어 일반 문자열&amp;ldquo;NULL&amp;rdquo;로 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="962da68b59592e76d7efdc84ac1e5105db667c11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULL&lt;/code&gt;&amp;ldquo;constraint&amp;rdquo; (actually a non-constraint) is a PostgreSQL extension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with the &lt;code&gt;NOT NULL&lt;/code&gt; constraint). Since it is the default for any column, its presence is simply noise.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; &quot;제약&quot;(실제로는 비 제약) 다른 데이터베이스 시스템과의 호환성을 위해 포함 (과와 대칭에있는 SQL 표준에 대한 PostgreSQL의 확장입니다 &lt;code&gt;NOT NULL&lt;/code&gt; 제약). 모든 열의 기본값이므로 단순히 노이즈입니다.</target>
        </trans-unit>
        <trans-unit id="f89a70ab2187a4125b8af941eb48d2104a35aae4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULLIF&lt;/code&gt; function returns a null value if &lt;code&gt;value1&lt;/code&gt; equals &lt;code&gt;value2&lt;/code&gt;; otherwise it returns &lt;code&gt;value1&lt;/code&gt;. This can be used to perform the inverse operation of the &lt;code&gt;COALESCE&lt;/code&gt; example given above:</source>
          <target state="translated">&lt;code&gt;NULLIF&lt;/code&gt; 의 경우, 함수는 널 (null) 값을 반환 &lt;code&gt;value1&lt;/code&gt; 동일 &lt;code&gt;value2&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;value1&lt;/code&gt; 을 반환합니다 . 이것은 위에서 주어진 &lt;code&gt;COALESCE&lt;/code&gt; 예의 역 연산을 수행하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01fdd1712e7b0454ab7f170cffda1945f0082b71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULLS FIRST&lt;/code&gt; and &lt;code&gt;NULLS LAST&lt;/code&gt; options can be used to determine whether nulls appear before or after non-null values in the sort ordering. By default, null values sort as if larger than any non-null value; that is, &lt;code&gt;NULLS FIRST&lt;/code&gt; is the default for &lt;code&gt;DESC&lt;/code&gt; order, and &lt;code&gt;NULLS LAST&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;NULLS FIRST&lt;/code&gt; 및 &lt;code&gt;NULLS LAST&lt;/code&gt; 의 옵션은 널 (null) 전이나 정렬 순서에 null이 아닌 값 뒤에 표시 여부를 결정하는 데 사용할 수 있습니다. 기본적으로 널값은 널이 아닌 값보다 큰 것처럼 정렬됩니다. 즉, &lt;code&gt;NULLS FIRST&lt;/code&gt; 는 &lt;code&gt;DESC&lt;/code&gt; 순서 의 기본값 이고 그렇지 않은 경우 &lt;code&gt;NULLS LAST&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db3f6d7975c35350055f22165f8267b483d36caa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ON COMMIT&lt;/code&gt; clause for temporary tables also resembles the SQL standard, but has some differences. If the &lt;code&gt;ON COMMIT&lt;/code&gt; clause is omitted, SQL specifies that the default behavior is &lt;code&gt;ON COMMIT DELETE ROWS&lt;/code&gt;. However, the default behavior in PostgreSQL is &lt;code&gt;ON COMMIT PRESERVE ROWS&lt;/code&gt;. The &lt;code&gt;ON COMMIT DROP&lt;/code&gt; option does not exist in SQL.</source>
          <target state="translated">임시 테이블 의 &lt;code&gt;ON COMMIT&lt;/code&gt; 절도 SQL 표준과 비슷하지만 약간의 차이가 있습니다. 는 IF &lt;code&gt;ON COMMIT&lt;/code&gt; 를 절을 생략하면 기본 동작입니다 SQL의 지정 &lt;code&gt;ON COMMIT DELETE ROWS&lt;/code&gt; . 그러나 PostgreSQL의 기본 동작은 &lt;code&gt;ON COMMIT PRESERVE ROWS&lt;/code&gt; 입니다. &lt;code&gt;ON COMMIT DROP&lt;/code&gt; SQL에 존재하지 않는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="472f32dda3820f4f49769a24b22c0964256b23e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ON&lt;/code&gt; clause is the most general kind of join condition: it takes a Boolean value expression of the same kind as is used in a &lt;code&gt;WHERE&lt;/code&gt; clause. A pair of rows from &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; match if the &lt;code&gt;ON&lt;/code&gt; expression evaluates to true.</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; 의 절은 조인 조건의 가장 일반적인 종류이다 : 그것은에 사용되는 것과 같은 종류의 부울 값 표현합니다 &lt;code&gt;WHERE&lt;/code&gt; 절을. &lt;code&gt;ON&lt;/code&gt; 표현식이 true로 평가 되면 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 의 행 쌍이 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="793025f43fd046d2375fc2d1347d2ad6be35fd9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPERATOR&lt;/code&gt; and &lt;code&gt;FUNCTION&lt;/code&gt; clauses can appear in any order.</source>
          <target state="translated">&lt;code&gt;OPERATOR&lt;/code&gt; 및 &lt;code&gt;FUNCTION&lt;/code&gt; 절은 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed146b628b9143aa8d465b9f6a969399e0078fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPERATOR&lt;/code&gt;, &lt;code&gt;FUNCTION&lt;/code&gt;, and &lt;code&gt;STORAGE&lt;/code&gt; clauses can appear in any order.</source>
          <target state="translated">&lt;code&gt;OPERATOR&lt;/code&gt; , &lt;code&gt;FUNCTION&lt;/code&gt; , 및 &lt;code&gt;STORAGE&lt;/code&gt; 절은 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7408278e5a49c7a21e1d564882fc738063e8ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ORDER BY&lt;/code&gt; clause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order.</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 절은 결과 행은 지정된 식 (들)에 따라 정렬됩니다. 가장 왼쪽 표현식에 따라 두 행이 같으면 다음 표현식에 따라 비교됩니다. 지정된 모든 표현식에 따라 같으면 구현 종속 순서로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b02f359cd58f3fe912dce4590fe56eb7fd3fc933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ORDER BY&lt;/code&gt; clause specifies the sort order:</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 절은 정렬 순서를 지정합니다 :</target>
        </trans-unit>
        <trans-unit id="5c192bece45872266b8038f6a0a05d716d357e85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; 절은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="bdc9e5eec52a1ba378bd2fb8274d7c97650e7deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well. If specified, this association replaces any previously specified association for the sequence. The specified table must have the same owner and be in the same schema as the sequence. Specifying &lt;code&gt;OWNED BY NONE&lt;/code&gt; removes any existing association, making the sequence &amp;ldquo;free-standing&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; 옵션 시퀀스는 해당 열 (또는 전체 테이블)이 삭제 된 경우, 시퀀스는 자동으로 삭제 아니라한다되도록 특정 테이블 컬럼과 연관되게한다. 지정된 경우이 연관은 시퀀스에 대해 이전에 지정된 연관을 대체합니다. 지정된 테이블은 소유자가 동일해야하며 시퀀스와 동일한 스키마에 있어야합니다. &lt;code&gt;OWNED BY NONE&lt;/code&gt; 을 지정 하면 기존 연결이 제거되어 시퀀스가 ​​&quot;독립적&quot;이됩니다.</target>
        </trans-unit>
        <trans-unit id="56fdd5a6277f3365172855b96f924d0b384fe495" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well. The specified table must have the same owner and be in the same schema as the sequence. &lt;code&gt;OWNED BY NONE&lt;/code&gt;, the default, specifies that there is no such association.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; 옵션 시퀀스는 해당 열 (또는 전체 테이블)이 삭제 된 경우, 시퀀스는 자동으로 삭제 아니라한다되도록 특정 테이블 컬럼과 연관되게한다. 지정된 테이블은 소유자가 동일해야하며 시퀀스와 동일한 스키마에 있어야합니다. 기본값 인 &lt;code&gt;OWNED BY NONE&lt;/code&gt; 은 그러한 연관이 없음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1d1ab5157b5e964e4779d754d984ea5918dd7889" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARALLEL&lt;/code&gt; option is used only for vacuum purposes. If this option is specified with the &lt;code&gt;ANALYZE&lt;/code&gt; option, it does not affect &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PARALLEL&lt;/code&gt; 옵션은 진공 용도로만 사용됩니다. 이 옵션이 지정 될 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 옵션은 영향을주지 않습니다 &lt;code&gt;ANALYZE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a2d7bf96f2a0b5a81febb7cc2f04c359a2ce962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARSER&lt;/code&gt; and &lt;code&gt;COPY&lt;/code&gt; options are mutually exclusive, because when an existing configuration is copied, its parser selection is copied too.</source>
          <target state="translated">&lt;code&gt;PARSER&lt;/code&gt; 와 &lt;code&gt;COPY&lt;/code&gt; 기존 구성을 복사 할 때, 그 파서 선택이 너무 복사되기 때문에 옵션은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="6ad47e1225da856fc1e4e1ae21e6437e7c3be2c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION BY&lt;/code&gt; clause groups the rows of the query into &lt;em&gt;partitions&lt;/em&gt;, which are processed separately by the window function. &lt;code&gt;PARTITION BY&lt;/code&gt; works similarly to a query-level &lt;code&gt;GROUP BY&lt;/code&gt; clause, except that its expressions are always just expressions and cannot be output-column names or numbers. Without &lt;code&gt;PARTITION BY&lt;/code&gt;, all rows produced by the query are treated as a single partition. The &lt;code&gt;ORDER BY&lt;/code&gt; clause determines the order in which the rows of a partition are processed by the window function. It works similarly to a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, but likewise cannot use output-column names or numbers. Without &lt;code&gt;ORDER BY&lt;/code&gt;, rows are processed in an unspecified order.</source>
          <target state="translated">&lt;code&gt;PARTITION BY&lt;/code&gt; 에 절 단체 쿼리 행 &lt;em&gt;분할&lt;/em&gt; 윈도우 함수에 의해 개별적으로 처리된다. &lt;code&gt;PARTITION BY&lt;/code&gt; 는 식이 항상 식이며 출력 열 이름 또는 숫자 일 수 없다는 점을 제외하고 쿼리 수준 &lt;code&gt;GROUP BY&lt;/code&gt; 절 과 유사하게 작동 합니다. &lt;code&gt;PARTITION BY&lt;/code&gt; 가 없으면 쿼리로 생성 된 모든 행이 단일 파티션으로 처리됩니다. &lt;code&gt;ORDER BY&lt;/code&gt; 절 파티션의 행 윈도우 함수에 의해 처리되는 순서를 결정한다. 쿼리 수준 &lt;code&gt;ORDER BY&lt;/code&gt; 절 과 유사하게 작동 하지만 마찬가지로 출력 열 이름 또는 숫자를 사용할 수 없습니다. &lt;code&gt;ORDER BY&lt;/code&gt; 없이행은 지정되지 않은 순서로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3b20c2706e18115ac776637bd86595bd36306e04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION BY&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;PARTITION BY&lt;/code&gt; 절은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="393ad05ac9e0d59452b4a8f8039dc3a261130b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION OF&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;PARTITION OF&lt;/code&gt; 절은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="0614d6d969b75211746fef3527fa36c2e0bf9b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PGDATA&lt;/code&gt; directory contains several subdirectories and control files, as shown in &lt;a href=&quot;storage-file-layout#PGDATA-CONTENTS-TABLE&quot;&gt;Table 68.1&lt;/a&gt;. In addition to these required items, the cluster configuration files &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt;, and &lt;code&gt;pg_ident.conf&lt;/code&gt; are traditionally stored in &lt;code&gt;PGDATA&lt;/code&gt;, although it is possible to place them elsewhere.</source>
          <target state="translated">&lt;code&gt;PGDATA&lt;/code&gt; 에 같이 디렉토리, 하위 디렉토리 및 제어 파일 몇 가지를 포함 &lt;a href=&quot;storage-file-layout#PGDATA-CONTENTS-TABLE&quot;&gt;표 68.1&lt;/a&gt; . 이러한 필수 항목 외에도 클러스터 구성 파일 &lt;code&gt;postgresql.conf&lt;/code&gt; , &lt;code&gt;pg_hba.conf&lt;/code&gt; 및 &lt;code&gt;pg_ident.conf&lt;/code&gt; 는 일반적으로 &lt;code&gt;PGDATA&lt;/code&gt; 에 저장 되지만 다른 위치에 배치 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c212a5664d9166a52f4030be9966cfbd740b8e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PGTZ&lt;/code&gt; environment variable is used by libpq clients to send a &lt;code&gt;SET TIME ZONE&lt;/code&gt; command to the server upon connection.</source>
          <target state="translated">&lt;code&gt;PGTZ&lt;/code&gt; 의 환경 변수는 보낼 libpq를 클라이언트에서 사용되는 &lt;code&gt;SET TIME ZONE&lt;/code&gt; 의 연결시 서버에 명령을.</target>
        </trans-unit>
        <trans-unit id="34a48a54277ef76ad5806acc41cf35d3fff139d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint specifies that a column or columns of a table can contain only unique (non-duplicate), nonnull values. Only one primary key can be specified for a table, whether as a column constraint or a table constraint.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 의 테이블의 열 또는 열은 고유의 (비 중복)을 포함 할 수 있다는 제약 조건 지정, 널 (null)이 아닌 값. 열 제한 조건 또는 테이블 제한 조건으로 테이블에 대해 하나의 기본 키만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46186111e10cd3fae630f6ffd1000b220d009aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Planning time&lt;/code&gt; shown by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; is the time it took to generate the query plan from the parsed query and optimize it. It does not include parsing or rewriting.</source>
          <target state="translated">&lt;code&gt;Planning time&lt;/code&gt; 으로 표시 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 이 분석 된 쿼리의 쿼리 계획을 생성하고 최적화하는 데 걸린 시간입니다. 구문 분석 또는 재 작성은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d7e8e781faa2b1b8c5b786d22498b3437e1d217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REASSIGN OWNED&lt;/code&gt; command does not affect any privileges granted to the &lt;code&gt;old_roles&lt;/code&gt; on objects that are not owned by them. Likewise, it does not affect default privileges created with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;. Use &lt;code&gt;DROP OWNED&lt;/code&gt; to revoke such privileges.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; 명령에 부여 된 권한에 영향을주지 않습니다 &lt;code&gt;old_roles&lt;/code&gt; 그들에 의해 소유하지 않은 개체를. 마찬가지로, &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 로 작성된 기본 권한에는 영향을 미치지 않습니다 . 이러한 권한을 취소 하려면 &lt;code&gt;DROP OWNED&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab1105a54870883f7696c90d586d2ea0eba9685c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REASSIGN OWNED&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; 명령은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="f532c71d7a7a8a330117caf1f3776cf4f07cbb57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REFERENCING&lt;/code&gt; option enables collection of &lt;em&gt;transition relations&lt;/em&gt;, which are row sets that include all of the rows inserted, deleted, or modified by the current SQL statement. This feature lets the trigger see a global view of what the statement did, not just one row at a time. This option is only allowed for an &lt;code&gt;AFTER&lt;/code&gt; trigger that is not a constraint trigger; also, if the trigger is an &lt;code&gt;UPDATE&lt;/code&gt; trigger, it must not specify a &lt;code&gt;column_name&lt;/code&gt; list. &lt;code&gt;OLD TABLE&lt;/code&gt; may only be specified once, and only for a trigger that can fire on &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;; it creates a transition relation containing the &lt;em&gt;before-images&lt;/em&gt; of all rows updated or deleted by the statement. Similarly, &lt;code&gt;NEW TABLE&lt;/code&gt; may only be specified once, and only for a trigger that can fire on &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;; it creates a transition relation containing the &lt;em&gt;after-images&lt;/em&gt; of all rows updated or inserted by the statement.</source>
          <target state="translated">&lt;code&gt;REFERENCING&lt;/code&gt; 의 옵션을 수집 할 수 &lt;em&gt;전환 관계&lt;/em&gt; , 삽입, 삭제, 또는 현재 SQL 문에 의해 수정 된 모든 행을 포함하는 행 집합입니다. 이 기능을 통해 트리거는 한 번에 한 행이 아니라 명령문이 수행 한 내용을 전체적으로 볼 수 있습니다. 이 옵션은 구속 조건 트리거가 아닌 &lt;code&gt;AFTER&lt;/code&gt; 트리거 에만 허용 됩니다. 또한 트리거가 &lt;code&gt;UPDATE&lt;/code&gt; 트리거 인 경우 &lt;code&gt;column_name&lt;/code&gt; 목록을 지정하지 않아야 합니다. &lt;code&gt;OLD TABLE&lt;/code&gt; 은 한 번만 지정할 수 있으며 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 에서 실행될 수있는 트리거에 대해서만 지정할 수 있습니다 . &lt;em&gt;사전 이미지를&lt;/em&gt; 포함하는 전환 관계를 만듭니다.&lt;em&gt;&lt;/em&gt;문에 의해 업데이트되거나 삭제 된 모든 행 중 마찬가지로 &lt;code&gt;NEW TABLE&lt;/code&gt; 은 한 번만 지정할 수 있으며 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;INSERT&lt;/code&gt; 시 트리거 할 수있는 트리거에 대해서만 지정할 수 있습니다 . 명령문에 의해 갱신되거나 삽입 된 모든 행 의 &lt;em&gt;사후 이미지&lt;/em&gt; 를 포함하는 전이 관계를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="128c0fd3af0b907c660e6b2d23e97c6334b157b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; form changes the name of the index. If the index is associated with a table constraint (either &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt;), the constraint is renamed as well. There is no effect on the stored data.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 형태는 인덱스의 이름을 변경합니다. 인덱스가 테이블 제한 조건 ( &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;EXCLUDE&lt;/code&gt; ) 과 연관된 경우 제한 조건의 이름도 변경됩니다. 저장된 데이터에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3e19c1e234f0ed8c9c4710a3c3098a7ed897e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; forms change the name of a foreign table or the name of an individual column in a foreign table.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 의 형태는 외부 테이블의 이름 또는 외부 표에서 개별 항목의 이름을 변경.</target>
        </trans-unit>
        <trans-unit id="f1e7a50326fd3c3ba151f96454fa2cb157ff1c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; forms change the name of a table (or an index, sequence, view, materialized view, or foreign table), the name of an individual column in a table, or the name of a constraint of the table. When renaming a constraint that has an underlying index, the index is renamed as well. There is no effect on the stored data.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 의 형태는 테이블의 이름 변경, 테이블의 개별 열 또는 테이블 제약의 이름의 이름 (또는 지수 시퀀스, 뷰, 뷰 또는 외부 표 구체화). 기본 인덱스가있는 제약 조건의 이름을 바꾸면 인덱스 이름도 변경됩니다. 저장된 데이터에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9e363fe4d9083d2f665b243a400d5bf63d40f84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RETURNING&lt;/code&gt; clause is also very useful with &lt;code&gt;INSERT ... SELECT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 절은 또한 매우 유용 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="622683abc0fee3cca0a4ff24efb6bac3bc69274b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REVOKE&lt;/code&gt; command revokes previously granted privileges from one or more roles. The key word &lt;code&gt;PUBLIC&lt;/code&gt; refers to the implicitly defined group of all roles.</source>
          <target state="translated">&lt;code&gt;REVOKE&lt;/code&gt; 의 명령은 이전에 하나 개 이상의 역할에서 권한을 부여 취소합니다. 키워드 &lt;code&gt;PUBLIC&lt;/code&gt; 은 암시 적으로 정의 된 모든 역할 그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a7eb06850162cc121e0dcb4f71d5d5cc238a6fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROLE&lt;/code&gt; clause lists one or more existing roles which are automatically added as members of the new role. (This in effect makes the new role a &amp;ldquo;group&amp;rdquo;.)</source>
          <target state="translated">&lt;code&gt;ROLE&lt;/code&gt; 절 목록에 하나 더 자동으로 새 역할의 구성원으로 추가하는 역할을 기존의. (이는 사실상 새로운 역할을&amp;ldquo;그룹&amp;rdquo;으로 만듭니다.)</target>
        </trans-unit>
        <trans-unit id="e90b140ccb8d754cc8582d110f40bb1462ca56ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; constructor syntax is usually easier to work with than the composite-literal syntax when writing composite values in SQL commands. In &lt;code&gt;ROW&lt;/code&gt;, individual field values are written the same way they would be written when not members of a composite.</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; 생성자 구문은 SQL 명령에 복합 값을 기록 할 때 복합 리터럴 구문보다 더와 작업에 일반적으로 쉽습니다. 에서 &lt;code&gt;ROW&lt;/code&gt; , 각각의 필드 값들이 기록 될 것 같은 방법을 쓸 때없는 복합의 구성원.</target>
        </trans-unit>
        <trans-unit id="bc33402fa9910608d16738542893ffc3652dba40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; expression syntax can also be used to construct composite values. In most cases this is considerably simpler to use than the string-literal syntax since you don't have to worry about multiple layers of quoting. We already used this method above:</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; 표현 구문은 합성 값을 구성하는데 사용될 수있다. 대부분의 경우 인용의 여러 계층에 대해 걱정할 필요가 없으므로 문자열 리터럴 구문보다 사용이 훨씬 간단합니다. 우리는 이미 위의 방법을 사용했습니다 :</target>
        </trans-unit>
        <trans-unit id="fec4fc51d12e7ec5b1c6011953c7d9a01518ad18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; expression syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; 표현 구문에 자세히 설명 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;섹션 4.2.13&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66771ec27e64ee38d7a73db993c4f98dda1eefb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SCROLL&lt;/code&gt; option should be specified when defining a cursor that will be used to fetch backwards. This is required by the SQL standard. However, for compatibility with earlier versions, PostgreSQL will allow backward fetches without &lt;code&gt;SCROLL&lt;/code&gt;, if the cursor's query plan is simple enough that no extra overhead is needed to support it. However, application developers are advised not to rely on using backward fetches from a cursor that has not been created with &lt;code&gt;SCROLL&lt;/code&gt;. If &lt;code&gt;NO SCROLL&lt;/code&gt; is specified, then backward fetches are disallowed in any case.</source>
          <target state="translated">&lt;code&gt;SCROLL&lt;/code&gt; 뒤쪽을 가져 오기 위해 사용되는 커서를 정의 할 때 옵션을 지정해야합니다. 이것은 SQL 표준에 필요합니다. 그러나 이전 버전과의 호환성을 위해 커서의 쿼리 계획이 단순하여이를 지원하기 위해 추가 오버 헤드가 필요하지 않은 경우 PostgreSQL은 &lt;code&gt;SCROLL&lt;/code&gt; 없이 역방향 페치를 허용 합니다. 그러나 응용 프로그램 개발자는 &lt;code&gt;SCROLL&lt;/code&gt; 로 작성되지 않은 커서에서 뒤로 가져 오기를 사용하지 않는 것이 좋습니다 . 경우 &lt;code&gt;NO SCROLL&lt;/code&gt; 을 지정하면 후방 페치 어떤 경우에 허용된다.</target>
        </trans-unit>
        <trans-unit id="7724f5cbcba172f246fa8b7c71da000b2776330f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands acquire a lock of this mode on the target table(s) (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other tables that are referenced but not selected &lt;code&gt;FOR UPDATE/FOR SHARE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 와 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 의 명령 (이외에 목표 테이블 (들)이 모드의 잠금을 획득 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 참조하지만, 선택되지 않은 다른 테이블에 잠금 &lt;code&gt;FOR UPDATE/FOR SHARE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e96e7802d4cb7db701f609eba9f870f4c8748bdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; command acquires a lock of this mode on referenced tables. In general, any query that only &lt;em&gt;reads&lt;/em&gt; a table and does not modify it will acquire this lock mode.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 명령은 참조 테이블에이 모드의 잠금을 획득합니다. 일반적으로 테이블을 &lt;em&gt;읽고&lt;/em&gt; 수정하지 않는 쿼리는 이 잠금 모드를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="3a31e8d24fd1e02295c813f049f933c4c7dd023e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; list (between the key words &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;FROM&lt;/code&gt;) specifies expressions that form the output rows of the &lt;code&gt;SELECT&lt;/code&gt; statement. The expressions can (and usually do) refer to columns computed in the &lt;code&gt;FROM&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 리스트 (핵심어 사이에는 &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;FROM&lt;/code&gt; 의 출력 행 형성 지정 식) &lt;code&gt;SELECT&lt;/code&gt; 문. 표현식은 &lt;code&gt;FROM&lt;/code&gt; 절 에서 계산 된 열을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1d3b2383acf67ec80d1e37ede72853554a335de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; statement will return one tuple, even though the &lt;code&gt;nick&lt;/code&gt; column was set to &lt;code&gt;larry&lt;/code&gt; and the query was for &lt;code&gt;Larry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 의 짝수하지만 문은 하나 개의 튜플을 반환 &lt;code&gt;nick&lt;/code&gt; 열로 설정 &lt;code&gt;larry&lt;/code&gt; 쿼리가되었다 &lt;code&gt;Larry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f1ef68b6a727bfef21aefb3a5eb92e57da175a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SERIAL&lt;/code&gt; shorthand is discussed further in &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;Section 8.1.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SERIAL&lt;/code&gt; 의 약칭은 더욱 설명 &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;절 8.1.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a726476c5c9f5995fa747df038eaa20f04dca47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers act the same as for the regular &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;SESSION&lt;/code&gt; 및 &lt;code&gt;LOCAL&lt;/code&gt; 수식은 일반과 동일한 역할을 &lt;a href=&quot;sql-set&quot;&gt;SET의&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="9f2d0dd2017fb0dc1fe3da723f3e961e02aaf3eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET ROLE&lt;/code&gt; command always allows selecting any role that the original login role is directly or indirectly a member of. Thus, in the above example, it is not necessary to become &lt;code&gt;admin&lt;/code&gt; before becoming &lt;code&gt;wheel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SET ROLE&lt;/code&gt; 명령은 항상 원래 로그인 역할은 직접 또는 간접적으로의 구성원인지 어떤 역할을 선택 할 수 있습니다. 따라서 위의 예에서 &lt;code&gt;wheel&lt;/code&gt; 이 되기 전에 &lt;code&gt;admin&lt;/code&gt; 가 될 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d850a29f519a30a60f848219dab3f598ebc95064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command allows a new transaction to run with the same &lt;em&gt;snapshot&lt;/em&gt; as an existing transaction. The pre-existing transaction must have exported its snapshot with the &lt;code&gt;pg_export_snapshot&lt;/code&gt; function (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt;). That function returns a snapshot identifier, which must be given to &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; to specify which snapshot is to be imported. The identifier must be written as a string literal in this command, for example &lt;code&gt;'000003A1-1'&lt;/code&gt;. &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; can only be executed at the start of a transaction, before the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of the transaction. Furthermore, the transaction must already be set to &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level (otherwise, the snapshot would be discarded immediately, since &lt;code&gt;READ COMMITTED&lt;/code&gt; mode takes a new snapshot for each command). If the importing transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level, then the transaction that exported the snapshot must also use that isolation level. Also, a non-read-only serializable transaction cannot import a snapshot from a read-only transaction.</source>
          <target state="translated">&lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 명령은 같은 실행하는 새로운 트랜잭션 수 &lt;em&gt;스냅 샷&lt;/em&gt; 기존의 트랜잭션으로한다. 기존 트랜잭션은 &lt;code&gt;pg_export_snapshot&lt;/code&gt; 함수를 사용하여 스냅 샷을 내 보내야 합니다 ( &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;9.26.5 절&lt;/a&gt; 참조 ). 이 함수는 가져올 스냅 샷을 지정 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 위해 스냅 샷 식별자를 SET TRANSACTION SNAPSHOT 에 제공해야합니다 . 식별자는이 명령에서 문자열 리터럴로 작성해야합니다 (예 : &lt;code&gt;'000003A1-1'&lt;/code&gt; ) . &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 은 첫 번째 쿼리 또는 데이터 수정 명령문 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; ) 이전에 트랜잭션 시작시에만 실행될 수 있습니다.트랜잭션의 , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; 또는 &lt;code&gt;COPY&lt;/code&gt; ) 또한 트랜잭션은 이미 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 또는 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 격리 수준 으로 설정되어 있어야합니다. 그렇지 않으면 &lt;code&gt;READ COMMITTED&lt;/code&gt; 모드가 각 명령에 대해 새 스냅 샷을 생성 하므로 스냅 샷이 즉시 삭제됩니다 . 가져 오기 트랜잭션이 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 격리 레벨을 사용하는 경우 스냅 샷을 내 보낸 트랜잭션도 해당 격리 레벨을 사용해야합니다. 또한 읽기 전용 직렬화 가능 트랜잭션은 읽기 전용 트랜잭션에서 스냅 샷을 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b1ee2050493abe360a4da165b08e75ef8b23207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command allows a new transaction to run with the same &lt;em&gt;snapshot&lt;/em&gt; as an existing transaction. The pre-existing transaction must have exported its snapshot with the &lt;code&gt;pg_export_snapshot&lt;/code&gt; function (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.27.5&lt;/a&gt;). That function returns a snapshot identifier, which must be given to &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; to specify which snapshot is to be imported. The identifier must be written as a string literal in this command, for example &lt;code&gt;'000003A1-1'&lt;/code&gt;. &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; can only be executed at the start of a transaction, before the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of the transaction. Furthermore, the transaction must already be set to &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level (otherwise, the snapshot would be discarded immediately, since &lt;code&gt;READ COMMITTED&lt;/code&gt; mode takes a new snapshot for each command). If the importing transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level, then the transaction that exported the snapshot must also use that isolation level. Also, a non-read-only serializable transaction cannot import a snapshot from a read-only transaction.</source>
          <target state="translated">&lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 명령은 같은 실행하는 새로운 트랜잭션 수 &lt;em&gt;스냅 샷&lt;/em&gt; 기존의 트랜잭션으로한다. 기존 트랜잭션은 &lt;code&gt;pg_export_snapshot&lt;/code&gt; 함수를 사용하여 스냅 샷을 내보냈 어야 합니다 ( &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;섹션 9.27.5&lt;/a&gt; 참조 ). 이 함수는 가져올 스냅 샷을 지정 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 위해 SET TRANSACTION SNAPSHOT 에 제공되어야하는 스냅 샷 ID를 리턴합니다 . 식별자는이 명령에서 문자열 리터럴로 작성되어야합니다 (예 : &lt;code&gt;'000003A1-1'&lt;/code&gt; ) . &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 는 첫 번째 쿼리 또는 데이터 수정 문 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; 또는 &lt;code&gt;COPY&lt;/code&gt; ). 또한 트랜잭션은 이미 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 또는 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 격리 수준 으로 설정되어 있어야합니다 (그렇지 않으면 &lt;code&gt;READ COMMITTED&lt;/code&gt; 모드가 각 명령에 대해 새 스냅 샷을 생성 하므로 스냅 샷이 즉시 삭제됩니다 ). 가져 오는 트랜잭션이 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 격리 수준을 사용하는 경우 스냅 샷을 내 보낸 트랜잭션도 해당 격리 수준을 사용해야합니다. 또한 읽기 전용이 아닌 직렬화 가능 트랜잭션은 읽기 전용 트랜잭션에서 스냅 샷을 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc6c2a89c55f352db834e7ae3a14fa98c839cbdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION&lt;/code&gt; command sets the characteristics of the current transaction. It has no effect on any subsequent transactions. &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; sets the default transaction characteristics for subsequent transactions of a session. These defaults can be overridden by &lt;code&gt;SET TRANSACTION&lt;/code&gt; for an individual transaction.</source>
          <target state="translated">&lt;code&gt;SET TRANSACTION&lt;/code&gt; 명령은 현재 트랜잭션의 특성을 설정합니다. 후속 트랜잭션에는 영향을 미치지 않습니다. &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; 는 세션의 후속 트랜잭션에 대한 기본 트랜잭션 특성을 설정합니다. 개별 트랜잭션에 대해 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 으로이 기본값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6625f1cde96b5821cc50429e57aa65382ce3cbff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; clause causes the specified configuration parameter to be set to the specified value when the function is entered, and then restored to its prior value when the function exits. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;CREATE FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 의 절 지정된 구성 파라미터 함수가 입력 될 때 지정된 값으로 설정하고 그 이전 값 함수가 종료되면 복원되도록한다. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 이 실행될 때 현재 매개 변수 의 값을 함수가 입력 될 때 적용되는 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="40cb501cbc3608b578aae96ed6d694a6c1181e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; clause causes the specified configuration parameter to be set to the specified value when the procedure is entered, and then restored to its prior value when the procedure exits. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 의 절은 지정된 구성 매개 변수는 프로 시저가 입력 될 때 지정된 값으로 설정 한 다음 그 이전 값 때 절차가 종료로 복원됩니다. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 가 실행될 때 현재 매개 변수 값을 프로 시저가 입력 될 때 적용되는 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="2d4ac1bc1f3cd753f1587a3604ac6e4583d02fa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; command changes run-time configuration parameters. Many of the run-time parameters listed in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; can be changed on-the-fly with &lt;code&gt;SET&lt;/code&gt;. (But some require superuser privileges to change, and others cannot be changed after server or session start.) &lt;code&gt;SET&lt;/code&gt; only affects the value used by the current session.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 의 명령은 런타임 구성 매개 변수를 변경합니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 나열된 많은 런타임 매개 변수 는 &lt;code&gt;SET&lt;/code&gt; 을 사용 하여 즉석에서 변경할 수 있습니다 . 그러나 일부는 변경하려면 수퍼 유저 권한이 필요하고 다른 일부는 서버 나 세션이 시작된 후에는 변경할 수 없습니다. &lt;code&gt;SET&lt;/code&gt; 는 현재 세션에서 사용 된 값에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3ed9804354cf023d1c6b84d23d87ca12258a85b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; command changes run-time configuration parameters. Many of the run-time parameters listed in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; can be changed on-the-fly with &lt;code&gt;SET&lt;/code&gt;. (But some require superuser privileges to change, and others cannot be changed after server or session start.) &lt;code&gt;SET&lt;/code&gt; only affects the value used by the current session.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 의 명령은 런타임 구성 매개 변수를 변경합니다. &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 나열된 많은 런타임 매개 변수 는 &lt;code&gt;SET&lt;/code&gt; 를 사용 하여 즉석에서 변경할 수 있습니다 . (그러나 일부는 변경하려면 수퍼 유저 권한이 필요하고 다른 일부는 서버 또는 세션 시작 후 변경할 수 없습니다.) &lt;code&gt;SET&lt;/code&gt; 는 현재 세션에서 사용하는 값에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="020c7ebd698e864a60548a6b3a70eb85bc868cc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SETOF&lt;/code&gt; modifier indicates that the function will return a set of items, rather than a single item.</source>
          <target state="translated">&lt;code&gt;SETOF&lt;/code&gt; 의 수정은 함수가 아니라 단일 항목보다는 항목 집합을 반환 할 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b5fb6cd6b15fe6f84ab20f8db329dfba5800e08d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHOW&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;SHOW&lt;/code&gt; 의 명령은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="3bda179acb0a4ef77b97eb421bed8ee9a254cd87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGHUP&lt;/code&gt; signal will reload the server configuration files. It is also possible to send &lt;code&gt;SIGHUP&lt;/code&gt; to an individual server process, but that is usually not sensible.</source>
          <target state="translated">&lt;code&gt;SIGHUP&lt;/code&gt; 의 신호는 서버 구성 파일을 다시로드합니다. &lt;code&gt;SIGHUP&lt;/code&gt; 을 개별 서버 프로세스 로 보낼 수도 있지만 일반적으로는 합리적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e039e8324d913df2408570fc591e852edc81e921" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIMILAR TO&lt;/code&gt; operator returns true or false depending on whether its pattern matches the given string. It is similar to &lt;code&gt;LIKE&lt;/code&gt;, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between &lt;code&gt;LIKE&lt;/code&gt; notation and common (POSIX) regular expression notation.</source>
          <target state="translated">&lt;code&gt;SIMILAR TO&lt;/code&gt; 연산자는 true를 반환 또는 그 패턴이 주어진 문자열과 일치 여부에 따라 거짓. SQL 표준의 정규 표현식 정의를 사용하여 패턴을 해석한다는 점을 제외하면 &lt;code&gt;LIKE&lt;/code&gt; 와 유사합니다 . SQL 정규식은 &lt;code&gt;LIKE&lt;/code&gt; 표기법과 일반 (POSIX) 정규식 표기법 사이의 흥미로운 교차 입니다.</target>
        </trans-unit>
        <trans-unit id="dbdafa6a0951a5a4f8ae3d651aa4483d02aaf656" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIMILAR TO&lt;/code&gt; operator returns true or false depending on whether its pattern matches the given string. It is similar to &lt;code&gt;LIKE&lt;/code&gt;, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between &lt;code&gt;LIKE&lt;/code&gt; notation and common regular expression notation.</source>
          <target state="translated">&lt;code&gt;SIMILAR TO&lt;/code&gt; 연산자는 true를 반환 또는 그 패턴이 주어진 문자열과 일치 여부에 따라 거짓. SQL 표준의 정규 표현식 정의를 사용하여 패턴을 해석한다는 점을 제외하면 &lt;code&gt;LIKE&lt;/code&gt; 와 유사합니다 . SQL 정규 표현식은 &lt;code&gt;LIKE&lt;/code&gt; 표기법과 일반적인 정규 표현식 표기법 사이의 흥미로운 교차점 입니다.</target>
        </trans-unit>
        <trans-unit id="e0f29f613d042694209acf2bfc2b15f650be2213" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SQL_ASCII&lt;/code&gt; setting behaves considerably differently from the other settings. When the server character set is &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server interprets byte values 0&amp;ndash;127 according to the ASCII standard, while byte values 128&amp;ndash;255 are taken as uninterpreted characters. No encoding conversion will be done when the setting is &lt;code&gt;SQL_ASCII&lt;/code&gt;. Thus, this setting is not so much a declaration that a specific encoding is in use, as a declaration of ignorance about the encoding. In most cases, if you are working with any non-ASCII data, it is unwise to use the &lt;code&gt;SQL_ASCII&lt;/code&gt; setting because PostgreSQL will be unable to help you by converting or validating non-ASCII characters.</source>
          <target state="translated">&lt;code&gt;SQL_ASCII&lt;/code&gt; 다른 설정과 상당히 다르게 동작 설정. 서버 문자 집합이 &lt;code&gt;SQL_ASCII&lt;/code&gt; 이면 서버는 ASCII 표준에 따라 0&amp;ndash;127 바이트 값을 해석하고 128&amp;ndash;255 바이트 값은 해석되지 않는 문자로 간주됩니다. 설정이 &lt;code&gt;SQL_ASCII&lt;/code&gt; 인 경우 인코딩 변환이 수행되지 않습니다 . 따라서이 설정은 특정 인코딩이 사용중인 선언이 아니라 인코딩에 대한 무지 선언입니다. 대부분의 경우 비 ASCII 데이터로 작업하는 경우 PostgreSQL이 비 ASCII 문자를 변환하거나 유효성을 검사하여 도움을 줄 수 없기 때문에 &lt;code&gt;SQL_ASCII&lt;/code&gt; 설정 을 사용하는 것은 현명하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0015ba66976ccc10a8545b59f15f445b21a50742" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SQL_ASCII&lt;/code&gt; setting behaves considerably differently from the other settings. When the server character set is &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server interprets byte values 0-127 according to the ASCII standard, while byte values 128-255 are taken as uninterpreted characters. No encoding conversion will be done when the setting is &lt;code&gt;SQL_ASCII&lt;/code&gt;. Thus, this setting is not so much a declaration that a specific encoding is in use, as a declaration of ignorance about the encoding. In most cases, if you are working with any non-ASCII data, it is unwise to use the &lt;code&gt;SQL_ASCII&lt;/code&gt; setting because PostgreSQL will be unable to help you by converting or validating non-ASCII characters.</source>
          <target state="translated">&lt;code&gt;SQL_ASCII&lt;/code&gt; 다른 설정과 상당히 다르게 동작 설정. 서버 문자 세트가 &lt;code&gt;SQL_ASCII&lt;/code&gt; 인 경우, 서버는 ASCII 표준에 따라 바이트 값 0-127을 해석하는 반면 바이트 값 128-255는 해석되지 않은 문자로 간주됩니다. 설정이 &lt;code&gt;SQL_ASCII&lt;/code&gt; 이면 인코딩 변환이 수행되지 않습니다 . 따라서이 설정은 인코딩에 대한 무지 선언으로서 특정 인코딩이 사용되는 선언이 아닙니다. 대부분의 경우 비 ASCII 데이터로 작업하는 경우 PostgreSQL이 비 ASCII 문자를 변환하거나 유효성 검증하여 도움을 줄 수 없으므로 &lt;code&gt;SQL_ASCII&lt;/code&gt; 설정 을 사용하는 것은 현명하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7d7d5e46d6c54b21b25eeef48c6ca4551b1f61a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SYSID&lt;/code&gt; clause is ignored, but is accepted for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;SYSID&lt;/code&gt; 의 절은 무시되지만 이전 버전과의 호환성을 위해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba9a4c3ee7dd77407d80711565ddf84296946777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause is currently accepted only on regular tables and materialized views. According to the SQL standard it should be possible to apply it to any &lt;code&gt;FROM&lt;/code&gt; item.</source>
          <target state="translated">&lt;code&gt;TABLESAMPLE&lt;/code&gt; 의 절은 현재 일반 테이블 접수 및 뷰를 구체화된다. SQL 표준에 따라 &lt;code&gt;FROM&lt;/code&gt; 항목 에 적용 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3600170fb18cff60f53eb4ba51d9dce974f3e1f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRUSTED&lt;/code&gt; option and the support function name(s) are ignored if the server has an entry for the specified language name in &lt;code&gt;pg_pltemplate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TRUSTED&lt;/code&gt; 서버가 지정된 언어 이름에 대한 항목이있는 경우 옵션과 지원 기능의 이름은 무시됩니다 &lt;code&gt;pg_pltemplate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53faeaca5564f551951f6575a18b776e07cb73f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNION&lt;/code&gt; clause has this general form:</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; 의 절은이 일반적인 형식은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="d37a98042f90333d3d9b66690fc343fe11354a51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNION&lt;/code&gt; operator computes the set union of the rows returned by the involved &lt;code&gt;SELECT&lt;/code&gt; statements. A row is in the set union of two result sets if it appears in at least one of the result sets. The two &lt;code&gt;SELECT&lt;/code&gt; statements that represent the direct operands of the &lt;code&gt;UNION&lt;/code&gt; must produce the same number of columns, and corresponding columns must be of compatible data types.</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; 의 운영자는 참여에 의해 반환 된 행 세트 조합 계산 &lt;code&gt;SELECT&lt;/code&gt; 문을. 행이 결과 집합 중 하나 이상에 나타나는 경우 두 결과 집합의 집합 집합에 있습니다. &lt;code&gt;UNION&lt;/code&gt; 의 직접 피연산자를 나타내는 두 개의 &lt;code&gt;SELECT&lt;/code&gt; 문 은 동일한 수의 열을 생성해야하며 해당 열은 호환 가능한 데이터 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="df2f42f8ff2203573828998bc521aa46717845dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNIQUE&lt;/code&gt; constraint specifies that a group of one or more columns of a table can contain only unique values. The behavior of the unique table constraint is the same as that for column constraints, with the additional capability to span multiple columns.</source>
          <target state="translated">&lt;code&gt;UNIQUE&lt;/code&gt; 의 제약 조건 지정은 테이블의 하나 이상의 열에의 그룹은 고유 한 값을 포함 할 수 있습니다. 고유 테이블 제한 조건의 동작은 열 제한 조건의 동작과 동일하며 여러 열에 걸쳐있는 추가 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="440900ea1c49963507f35e80410def61bdfb2e10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USER&lt;/code&gt; clause is an obsolete spelling of the &lt;code&gt;ROLE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;USER&lt;/code&gt; 절은의 오래된 철자 &lt;code&gt;ROLE&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="df5573cea50ffa4699b0e7de14e2efa40e40f614" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; clause is a shorthand that allows you to take advantage of the specific situation where both sides of the join use the same name for the joining column(s). It takes a comma-separated list of the shared column names and forms a join condition that includes an equality comparison for each one. For example, joining &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; with &lt;code&gt;USING (a, b)&lt;/code&gt; produces the join condition &lt;code&gt;ON T1.a = T2.a AND T1.b = T2.b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 절은 당신이 양쪽이 결합 컬럼 (들)에 같은 이름을 사용하는 조인 특정 상황을 활용할 수 속기이다. 쉼표로 구분 된 공유 열 이름 목록을 사용하고 각 항목에 대한 동등 비교를 포함하는 결합 조건을 형성합니다. 예를 들어, &lt;code&gt;T1&lt;/code&gt; 과 &lt;code&gt;T2&lt;/code&gt; 를 &lt;code&gt;USING (a, b)&lt;/code&gt; 과 결합하면 결합 조건이 &lt;code&gt;ON T1.a = T2.a AND T1.b = T2.b&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd69a2ff12f6e6b4d3bf9a9a6b47532dc2d1194" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; expression for the policy. See &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 정책에 대한 식입니다. 자세한 내용은 &lt;a href=&quot;sql-createpolicy&quot;&gt;정책 생성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bbe3012f251c3e27b73557dcb624091be7838ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; option of &lt;code&gt;SET DATA TYPE&lt;/code&gt; can actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted. This allows very general conversions to be done with the &lt;code&gt;SET DATA TYPE&lt;/code&gt; syntax. Because of this flexibility, the &lt;code&gt;USING&lt;/code&gt; expression is not applied to the column's default value (if any); the result might not be a constant expression as required for a default. This means that when there is no implicit or assignment cast from old to new type, &lt;code&gt;SET DATA TYPE&lt;/code&gt; might fail to convert the default even though a &lt;code&gt;USING&lt;/code&gt; clause is supplied. In such cases, drop the default with &lt;code&gt;DROP DEFAULT&lt;/code&gt;, perform the &lt;code&gt;ALTER TYPE&lt;/code&gt;, and then use &lt;code&gt;SET DEFAULT&lt;/code&gt; to add a suitable new default. Similar considerations apply to indexes and constraints involving the column.</source>
          <target state="translated">&lt;code&gt;SET DATA TYPE&lt;/code&gt; 의 &lt;code&gt;USING&lt;/code&gt; 옵션은 실제로 행의 이전 값과 관련된 표현식을 지정할 수 있습니다. 즉, 다른 열과 변환되는 열을 참조 할 수 있습니다. 이를 통해 &lt;code&gt;SET DATA TYPE&lt;/code&gt; 구문을 사용하여 매우 일반적인 변환을 수행 할 수 있습니다 . 이러한 유연성으로 인해 &lt;code&gt;USING&lt;/code&gt; 표현식은 열의 기본값 (있는 경우)에 적용되지 않습니다. 기본값에 필요한 결과는 상수 표현식이 아닐 수 있습니다. 즉, 이전 유형에서 새 유형으로 암시 적 또는 할당 캐스트가 없으면 &lt;code&gt;USING&lt;/code&gt; 절이 제공 되어도 &lt;code&gt;SET DATA TYPE&lt;/code&gt; 이 기본값을 변환하지 못할 수 있습니다 . 이러한 경우 &lt;code&gt;DROP DEFAULT&lt;/code&gt; 를 사용 하여 기본값을 삭제하십시오. &lt;code&gt;ALTER TYPE&lt;/code&gt; 을 수행 한 다음 &lt;code&gt;SET DEFAULT&lt;/code&gt; 를 사용 하여 적절한 새 기본값을 추가하십시오. 열과 관련된 인덱스 및 제약 조건에도 비슷한 고려 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ac72d27e393aaa10fa09ec0c99e41bf31ba8f68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VALID UNTIL&lt;/code&gt; clause defines an expiration time for a password only, not for the role &lt;em&gt;per se&lt;/em&gt;. In particular, the expiration time is not enforced when logging in using a non-password-based authentication method.</source>
          <target state="translated">&lt;code&gt;VALID UNTIL&lt;/code&gt; 절은 아닌 역할에 대한 암호를 만료 시간을 정의 &lt;em&gt;그 자체&lt;/em&gt; . 특히 비 암호 기반 인증 방법을 사용하여 로그인 할 때는 만료 시간이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4254f4cbb5558ecbcabbf94985890347bc617c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VALID UNTIL&lt;/code&gt; clause sets a date and time after which the role's password is no longer valid. If this clause is omitted the password will be valid for all time.</source>
          <target state="translated">&lt;code&gt;VALID UNTIL&lt;/code&gt; 절은 역할의 암호가 더 이상 유효 후 날짜와 시간을 설정합니다. 이 절을 생략하면 암호는 항상 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3c44efcbdf803edc09491650dc604f24489fb4e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH CHECK&lt;/code&gt; expression for the policy. See &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; for details.</source>
          <target state="translated">정책 의 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식입니다. 자세한 내용은 &lt;a href=&quot;sql-createpolicy&quot;&gt;정책 생성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f909d6d352b763da5996539ec5a35b3e1508bd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;DELETE&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 당신이에서 이름으로 참조 할 수있는 하나 개 이상의 하위 쿼리를 지정할 수 있습니다 &lt;code&gt;DELETE&lt;/code&gt; 쿼리를. 자세한 내용 &lt;a href=&quot;queries-with&quot;&gt;은 7.8 절&lt;/a&gt; 및 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c86cbf90270e40ca5022ce8fed26f2e4b7126438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;INSERT&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 당신이에서 이름으로 참조 할 수있는 하나 개 이상의 하위 쿼리를 지정할 수 있습니다 &lt;code&gt;INSERT&lt;/code&gt; 의 쿼리를. 자세한 내용 &lt;a href=&quot;queries-with&quot;&gt;은 7.8 절&lt;/a&gt; 및 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b5376c90f6e32eea66f4e1b2c109c7f56e3b3b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;UPDATE&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 당신이에서 이름으로 참조 할 수있는 하나 개 이상의 하위 쿼리를 지정할 수 있습니다 &lt;code&gt;UPDATE&lt;/code&gt; 쿼리를. 자세한 내용 &lt;a href=&quot;queries-with&quot;&gt;은 7.8 절&lt;/a&gt; 및 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d36279616fce39b7667637feae639cf048d9729b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be a &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;TABLE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement. When writing a data-modifying statement (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;) in &lt;code&gt;WITH&lt;/code&gt;, it is usual to include a &lt;code&gt;RETURNING&lt;/code&gt; clause. It is the output of &lt;code&gt;RETURNING&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt; the underlying table that the statement modifies, that forms the temporary table that is read by the primary query. If &lt;code&gt;RETURNING&lt;/code&gt; is omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 기본 쿼리에서 이름으로 참조 할 수있는 하나 개 이상의 하위 쿼리를 지정할 수 있습니다. 서브 쿼리는 효과적으로 기본 쿼리 기간 동안 임시 테이블 또는 뷰 역할을합니다. 각 하위 쿼리는 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;TABLE&lt;/code&gt; , &lt;code&gt;VALUES&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 문일 수 있습니다. &lt;code&gt;WITH&lt;/code&gt; 에 데이터 수정 명령문 ( &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; )을 작성할 때 &lt;code&gt;RETURNING&lt;/code&gt; 절 을 포함하는 것이 일반적 입니다. 그것은의 출력 &lt;code&gt;RETURNING&lt;/code&gt; , &lt;em&gt;하지&lt;/em&gt;&lt;em&gt;&lt;/em&gt;명령문이 수정하는 기본 테이블이며 기본 조회가 읽는 임시 테이블을 형성합니다. 경우 &lt;code&gt;RETURNING&lt;/code&gt; 생략 문은 여전히 실행되지만,이 차의 요청에 의한 테이블로 참조 할 수 없습니다 있도록 출력 기능은 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd82170932e06b9823fd64af1127b85442398023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause can specify &lt;em&gt;storage parameters&lt;/em&gt; for tables, and for indexes associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint. Storage parameters for indexes are documented in &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;. The storage parameters currently available for tables are listed below. For many of these parameters, as shown, there is an additional parameter with the same name prefixed with &lt;code&gt;toast.&lt;/code&gt;, which controls the behavior of the table's secondary TOAST table, if any (see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information about TOAST). If a table parameter value is set and the equivalent &lt;code&gt;toast.&lt;/code&gt; parameter is not, the TOAST table will use the table's parameter value. Specifying these parameters for partitioned tables is not supported, but you may specify them for individual leaf partitions.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절을 지정할 수 있습니다 &lt;em&gt;저장 매개 변수를&lt;/em&gt; 테이블 및 인덱스에 대한과 관련된 &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;EXCLUDE&lt;/code&gt; 제약 조건을. 인덱스의 스토리지 매개 변수는 &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX에&lt;/a&gt; 문서화되어 있습니다. 현재 테이블에 사용 가능한 스토리지 매개 변수가 아래에 나열되어 있습니다. 표시된 바와 같이 이러한 많은 매개 변수의 경우 이름 앞에 &lt;code&gt;toast.&lt;/code&gt; 붙은 동일한 추가 매개 변수가 있습니다. , 이것은 테이블의 2 차 TOAST 테이블의 동작을 제어합니다 ( TOAST에 대한 자세한 정보는 &lt;a href=&quot;storage-toast&quot;&gt;68.2 절&lt;/a&gt; 참조 ). 테이블 매개 변수 값이 설정되고 해당하는 &lt;code&gt;toast.&lt;/code&gt; 매개 변수가 아닌 경우 TOAST 테이블은 테이블의 매개 변수 값을 사용합니다. 파티션 된 테이블에 이러한 매개 변수를 지정하는 것은 지원되지 않지만 개별 리프 파티션에 대해 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59e61d24618bca5f4d5d76d9ae780c2dce93b6f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause is a PostgreSQL extension; storage parameters are not in the standard.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 PostgreSQL의 확장입니다 스토리지 매개 변수가 표준에 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9bfddf2848aa0b39782b5bc4bcc89ef2f85698a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\i&lt;/code&gt; command reads in commands from the specified file. &lt;code&gt;psql&lt;/code&gt;'s &lt;code&gt;-s&lt;/code&gt; option puts you in single step mode which pauses before sending each statement to the server. The commands used in this section are in the file &lt;code&gt;basics.sql&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\i&lt;/code&gt; 명령은 지정된 파일에서 명령을 읽습니다. &lt;code&gt;psql&lt;/code&gt; 의 &lt;code&gt;-s&lt;/code&gt; 옵션은 단일 단계 모드로 전환하여 각 명령문을 서버로 보내기 전에 일시 정지합니다. 이 섹션에서 사용 된 명령은 &lt;code&gt;basics.sql&lt;/code&gt; 파일에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d745a90b32000102fbaf10faab8dc20a84ca8bde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\if&lt;/code&gt; and &lt;code&gt;\elif&lt;/code&gt; commands read their argument(s) and evaluate them as a boolean expression. If the expression yields &lt;code&gt;true&lt;/code&gt; then processing continues normally; otherwise, lines are skipped until a matching &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, or &lt;code&gt;\endif&lt;/code&gt; is reached. Once an &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; test has succeeded, the arguments of later &lt;code&gt;\elif&lt;/code&gt; commands in the same block are not evaluated but are treated as false. Lines following an &lt;code&gt;\else&lt;/code&gt; are processed only if no earlier matching &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; succeeded.</source>
          <target state="translated">&lt;code&gt;\if&lt;/code&gt; 와 &lt;code&gt;\elif&lt;/code&gt; 명령 자신의 주장 (들)을 읽고 부울 표현으로 그들을 평가합니다. 표현식이 &lt;code&gt;true&lt;/code&gt; 이면 처리는 정상적으로 계속됩니다. 그렇지 않으면 일치하는 &lt;code&gt;\elif&lt;/code&gt; , &lt;code&gt;\else&lt;/code&gt; 또는 &lt;code&gt;\endif&lt;/code&gt; 에 도달 할 때까지 줄을 건너 뜁니다 . 일단 &lt;code&gt;\if&lt;/code&gt; 또는 &lt;code&gt;\elif&lt;/code&gt; 테스트에 성공, 이후의 인수 &lt;code&gt;\elif&lt;/code&gt; 명령 같은 블록에서 평가되지 않고 허위로 처리됩니다. &lt;code&gt;\else&lt;/code&gt; 다음의 행 은 이전에 일치하는 &lt;code&gt;\if&lt;/code&gt; 또는 &lt;code&gt;\elif&lt;/code&gt; 가 성공 하지 않은 경우에만 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea3a007939b7e11bbba46ea6419ffc5cadf17bf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\ir&lt;/code&gt; command is similar to &lt;code&gt;\i&lt;/code&gt;, but resolves relative file names differently. When executing in interactive mode, the two commands behave identically. However, when invoked from a script, &lt;code&gt;\ir&lt;/code&gt; interprets file names relative to the directory in which the script is located, rather than the current working directory.</source>
          <target state="translated">&lt;code&gt;\ir&lt;/code&gt; 명령과 비슷 &lt;code&gt;\i&lt;/code&gt; ,하지만 다르게 결의 상대 파일 이름. 대화식 모드에서 실행할 때 두 명령은 동일하게 작동합니다. 그러나 스크립트에서 호출되면 &lt;code&gt;\ir&lt;/code&gt; 은 현재 작업 디렉토리가 아니라 스크립트가있는 디렉토리를 기준으로 파일 이름을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="cc556ad110a04b305663af7200be893f4116db8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abbrev&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt;, and &lt;code&gt;text&lt;/code&gt; functions are primarily intended to offer alternative display formats for IP addresses.</source>
          <target state="translated">&lt;code&gt;abbrev&lt;/code&gt; , &lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 기능은 주로 IP 주소를 다른 디스플레이 형식을 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5384c8f8a006169515dc3ae72338f807023b1033" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;absval&lt;/code&gt; parameter specifies whether leading &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; signs should be removed from integer words. The default is &lt;code&gt;false&lt;/code&gt;. When &lt;code&gt;true&lt;/code&gt;, the sign is removed before &lt;code&gt;maxlen&lt;/code&gt; is applied.</source>
          <target state="translated">&lt;code&gt;absval&lt;/code&gt; &quot;선도 여부를 매개 변수를 지정 &lt;code&gt;+&lt;/code&gt; &quot; &quot;나 &lt;code&gt;-&lt;/code&gt; &quot;표시가 정수 단어에서 제거해야합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 때 &lt;code&gt;true&lt;/code&gt; 전에 기호가 제거됩니다 &lt;code&gt;maxlen&lt;/code&gt; 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="169f5705e6b515a085e5b6da75e17e9f4dc2b9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;age&lt;/code&gt; column measures the number of transactions from the cutoff XID to the current transaction's XID.</source>
          <target state="translated">&lt;code&gt;age&lt;/code&gt; 열은 현재 트랜잭션의 XID에 차단 XID에서 트랜잭션의 수를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="525d0fc7bca054a06817564f9e4e716d7d8750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alignment&lt;/code&gt; parameter specifies the storage alignment required for the data type. The allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries. Note that variable-length types must have an alignment of at least 4, since they necessarily contain an &lt;code&gt;int4&lt;/code&gt; as their first component.</source>
          <target state="translated">&lt;code&gt;alignment&lt;/code&gt; 파라미터는 데이터 유형에 필요한 저장 배열을 지정한다. 허용 된 값은 1, 2, 4 또는 8 바이트 경계에서 정렬하는 것과 같습니다. 가변 길이 유형은 반드시 첫 번째 구성 요소로 &lt;code&gt;int4&lt;/code&gt; 를 포함하므로 최소 4의 정렬을 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="66ec02f3867429174e02872bcd9ba803a6ca7a3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amcheck&lt;/code&gt; module provides functions that allow you to verify the logical consistency of the structure of relations. If the structure appears to be valid, no error is raised.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; 의 모듈은 관계의 구조의 논리적 일관성을 검증 할 수있는 기능을 제공합니다. 구조가 유효하면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04aff6c7be2111c7103649cab8f33b7af9c81d97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amcostestimate&lt;/code&gt; function is given information describing a possible index scan, including lists of WHERE and ORDER BY clauses that have been determined to be usable with the index. It must return estimates of the cost of accessing the index and the selectivity of the WHERE clauses (that is, the fraction of parent-table rows that will be retrieved during the index scan). For simple cases, nearly all the work of the cost estimator can be done by calling standard routines in the optimizer; the point of having an &lt;code&gt;amcostestimate&lt;/code&gt; function is to allow index access methods to provide index-type-specific knowledge, in case it is possible to improve on the standard estimates.</source>
          <target state="translated">&lt;code&gt;amcostestimate&lt;/code&gt; 기능 정보의리스트를 포함하는 검색 가능한 인덱스를 기술 주어진다 순서 인덱스와 사용할 수있는 것으로 판정 된 절 BY. 인덱스 액세스 비용 및 WHERE 절의 선택성 (즉, 인덱스 스캔 중에 검색 될 상위 테이블 행의 비율)에 대한 추정값을 리턴해야합니다. 간단한 경우, 옵티 마이저에서 표준 루틴을 호출하여 비용 견적 도구의 거의 모든 작업을 수행 할 수 있습니다. &lt;code&gt;amcostestimate&lt;/code&gt; 기능 의 요점은 표준 추정치를 개선 할 수있는 경우 인덱스 액세스 방법이 인덱스 유형별 지식을 제공 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6898a2ba9037019e5df24b6e547743d4cc59ddab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgetbitmap&lt;/code&gt; function need only be provided if the access method supports &amp;ldquo;bitmap&amp;rdquo; index scans. If it doesn't, the &lt;code&gt;amgetbitmap&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct must be set to NULL.</source>
          <target state="translated">&lt;code&gt;amgetbitmap&lt;/code&gt; 의 기능 요구하는 경우에만 액세스 방법 지지체 &quot;비트 맵&quot;인덱스 스캔을 제공한다. 그렇지 않은 경우, &lt;code&gt;amgetbitmap&lt;/code&gt; 의 그 필드 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 의 구조체는 NULL로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="388cb503bc9fecd1c56c284bf2fd7e41a507c9b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgettuple&lt;/code&gt; function has a &lt;code&gt;direction&lt;/code&gt; argument, which can be either &lt;code&gt;ForwardScanDirection&lt;/code&gt; (the normal case) or &lt;code&gt;BackwardScanDirection&lt;/code&gt;. If the first call after &lt;code&gt;amrescan&lt;/code&gt; specifies &lt;code&gt;BackwardScanDirection&lt;/code&gt;, then the set of matching index entries is to be scanned back-to-front rather than in the normal front-to-back direction, so &lt;code&gt;amgettuple&lt;/code&gt; must return the last matching tuple in the index, rather than the first one as it normally would. (This will only occur for access methods that set &lt;code&gt;amcanorder&lt;/code&gt; to true.) After the first call, &lt;code&gt;amgettuple&lt;/code&gt; must be prepared to advance the scan in either direction from the most recently returned entry. (But if &lt;code&gt;amcanbackward&lt;/code&gt; is false, all subsequent calls will have the same direction as the first one.)</source>
          <target state="translated">&lt;code&gt;amgettuple&lt;/code&gt; 의 함수를 갖는 &lt;code&gt;direction&lt;/code&gt; 이 될 수 인수 &lt;code&gt;ForwardScanDirection&lt;/code&gt; (통상의 경우) 또는 &lt;code&gt;BackwardScanDirection&lt;/code&gt; 를 . &lt;code&gt;amrescan&lt;/code&gt; 이후의 첫 번째 호출이 &lt;code&gt;BackwardScanDirection&lt;/code&gt; 을 지정 하면 일치하는 색인 ​​항목 세트가 정상적인 전후 방향이 아닌 연속적으로 스캔되므로 &lt;code&gt;amgettuple&lt;/code&gt; 은 색인에서 마지막으로 일치하는 튜플을 리턴해야합니다. 평소처럼 첫 번째 것보다. (이것은 &lt;code&gt;amcanorder&lt;/code&gt; 를 true로 설정 한 액세스 메소드에서만 발생 합니다.) 첫 번째 호출 후 &lt;code&gt;amgettuple&lt;/code&gt; 가장 최근에 반환 된 항목에서 스캔을 어느 방향 으로든 진행할 수 있도록 준비해야합니다. 그러나 &lt;code&gt;amcanbackward&lt;/code&gt; 가 false이면 모든 후속 통화는 첫 번째와 동일한 방향을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a0f7a76e8330fc4bc94786133307659b91dcdc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgettuple&lt;/code&gt; function need only be provided if the access method supports &amp;ldquo;plain&amp;rdquo; index scans. If it doesn't, the &lt;code&gt;amgettuple&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct must be set to NULL.</source>
          <target state="translated">&lt;code&gt;amgettuple&lt;/code&gt; 기능 필요가있는 경우에만이 액세스 방법을 지원하는 &quot;일반&quot;인덱스 스캔을 제공한다. 그렇지 않은 경우 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;amgettuple&lt;/code&gt; 필드 를 NULL로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cde20037ee1497cd6ab533acce975df0e8aa1224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ammarkpos&lt;/code&gt; function need only be provided if the access method supports ordered scans. If it doesn't, the &lt;code&gt;ammarkpos&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct may be set to NULL.</source>
          <target state="translated">&lt;code&gt;ammarkpos&lt;/code&gt; 의 액세스 방법이 지원하는 스캔을 주문한 경우 기능의 필요성은 제공 될 수있다. 그렇지 않으면 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;ammarkpos&lt;/code&gt; 필드 가 NULL로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccdf26b3604c28eca91ce1c3b3a35a7a58b7e44e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amproperty&lt;/code&gt; method allows index access methods to override the default behavior of &lt;code&gt;pg_index_column_has_property&lt;/code&gt; and related functions. If the access method does not have any special behavior for index property inquiries, the &lt;code&gt;amproperty&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct can be set to NULL. Otherwise, the &lt;code&gt;amproperty&lt;/code&gt; method will be called with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; both zero for &lt;code&gt;pg_indexam_has_property&lt;/code&gt; calls, or with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; valid and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; zero for &lt;code&gt;pg_index_has_property&lt;/code&gt; calls, or with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; valid and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; greater than zero for &lt;code&gt;pg_index_column_has_property&lt;/code&gt; calls. &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt; is an enum value identifying the property being tested, while &lt;em&gt;&lt;code&gt;propname&lt;/code&gt;&lt;/em&gt; is the original property name string. If the core code does not recognize the property name then &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;AMPROP_UNKNOWN&lt;/code&gt;. Access methods can define custom property names by checking &lt;em&gt;&lt;code&gt;propname&lt;/code&gt;&lt;/em&gt; for a match (use &lt;code&gt;pg_strcasecmp&lt;/code&gt; to match, for consistency with the core code); for names known to the core code, it's better to inspect &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt;. If the &lt;code&gt;amproperty&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; then it has determined the property test result: it must set &lt;code&gt;*res&lt;/code&gt; to the boolean value to return, or set &lt;code&gt;*isnull&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; to return a NULL. (Both of the referenced variables are initialized to &lt;code&gt;false&lt;/code&gt; before the call.) If the &lt;code&gt;amproperty&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; then the core code will proceed with its normal logic for determining the property test result.</source>
          <target state="translated">&lt;code&gt;amproperty&lt;/code&gt; 의 방법은 인덱스 접근 방법의 기본 동작을 대체 할 수 있습니다 &lt;code&gt;pg_index_column_has_property&lt;/code&gt; 및 관련 기능. 액세스 메소드에 인덱스 특성 조회에 대한 특수 동작이없는 경우 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;amproperty&lt;/code&gt; 필드 를 NULL로 설정할 수 있습니다. 그렇지 않으면, &lt;code&gt;amproperty&lt;/code&gt; 의 방법으로 호출됩니다 &lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt; 양쪽 모두 0에 대한 &lt;code&gt;pg_indexam_has_property&lt;/code&gt; 의 전화, 또는에 &lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt; 유효하고 &lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt; 제로 &lt;code&gt;pg_index_has_property&lt;/code&gt; 의 전화, 또는에 &lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt; 유효하고 &lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;pg_index_column_has_property&lt;/code&gt; 호출의 경우 0보다 큽니다 . &lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt; 은 테스트중인 속성을 식별하는 열거 형 값이며 &lt;em&gt; &lt;code&gt;propname&lt;/code&gt; &lt;/em&gt; 은 원래 속성 이름 문자열입니다. 코어 코드가 특성 이름을 인식하지 못하면 &lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt; 은 &lt;code&gt;AMPROP_UNKNOWN&lt;/code&gt; 입니다. 액세스 메소드는 일치에 대한 &lt;em&gt; &lt;code&gt;propname&lt;/code&gt; &lt;/em&gt; 을 검사하여 사용자 정의 특성 이름을 정의 할 수 있습니다 ( 핵심 코드와의 일관성을 위해 일치 하도록 &lt;code&gt;pg_strcasecmp&lt;/code&gt; 사용 ). 핵심 코드에 알려진 이름의 경우 &lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt; 검사하는 것이 좋습니다 . 는 IF &lt;code&gt;amproperty&lt;/code&gt; 의 방법은 반환 &lt;code&gt;true&lt;/code&gt; 다음은 특성 시험 결과를 결정했다 : 그것은 설정해야합니다 &lt;code&gt;*res&lt;/code&gt; 부울 값으로 리턴하거나 &lt;code&gt;*isnull&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정 하여 NULL을 리턴하십시오. 참조 된 변수는 모두 호출하기 전에 &lt;code&gt;false&lt;/code&gt; 로 초기화됩니다 . &lt;code&gt;amproperty&lt;/code&gt; 메소드가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하면 코어 코드는 특성 테스트 결과를 판별하기위한 일반 로직으로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="ee6ce83ebaf748f648fd0330541075210e5894e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amrestrpos&lt;/code&gt; function need only be provided if the access method supports ordered scans. If it doesn't, the &lt;code&gt;amrestrpos&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct may be set to NULL.</source>
          <target state="translated">&lt;code&gt;amrestrpos&lt;/code&gt; 의 액세스 방법이 지원하는 스캔을 주문한 경우 기능은 제공 될 필요가있다. 그렇지 않은 경우 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;amrestrpos&lt;/code&gt; 필드 가 NULL로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe809061c1f64f874371a0dcea9b46cff8a18bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;application_name&lt;/code&gt; can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). It is typically set by an application upon connection to the server. The name will be displayed in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view and included in CSV log entries. It can also be included in regular log entries via the &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; parameter. Only printable ASCII characters may be used in the &lt;code&gt;application_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;application_name&lt;/code&gt; 이하의 문자열이 될 수 있습니다 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 의 문자 (표준 빌드 64 자). 일반적으로 서버에 연결할 때 응용 프로그램에 의해 설정됩니다. 이름은 &lt;code&gt;pg_stat_activity&lt;/code&gt; 보기에 표시 되고 CSV 로그 항목에 포함됩니다. &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; 매개 변수 를 통해 일반 로그 항목에 포함될 수도 있습니다 . &lt;code&gt;application_name&lt;/code&gt; 값 에는 인쇄 가능한 ASCII 문자 만 사용할 수 있습니다 . 다른 문자는 물음표 ( &lt;code&gt;?&lt;/code&gt; ) 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="810ba7465a70771d2961f660e2ffe00a08ad7b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function works for the types &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;, and &lt;code&gt;path&lt;/code&gt;. The &lt;code&gt;area&lt;/code&gt; function only works on the &lt;code&gt;path&lt;/code&gt; data type if the points in the &lt;code&gt;path&lt;/code&gt; are non-intersecting. For example, the &lt;code&gt;path&lt;/code&gt;&lt;code&gt;'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH&lt;/code&gt; will not work; however, the following visually identical &lt;code&gt;path&lt;/code&gt;&lt;code&gt;'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH&lt;/code&gt; will work. If the concept of an intersecting versus non-intersecting &lt;code&gt;path&lt;/code&gt; is confusing, draw both of the above &lt;code&gt;path&lt;/code&gt;s side by side on a piece of graph paper.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 기능은 유형의 작동 &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; 및 &lt;code&gt;path&lt;/code&gt; . &lt;code&gt;area&lt;/code&gt; 기능 만 작동 &lt;code&gt;path&lt;/code&gt; 의 포인트 경우 데이터 유형 &lt;code&gt;path&lt;/code&gt; 교차하지 않는입니다. 예를 들어 &lt;code&gt;path&lt;/code&gt; &lt;code&gt;'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH&lt;/code&gt; 가 작동하지 않습니다. 그러나 다음 시각적으로 동일한 &lt;code&gt;path&lt;/code&gt; &lt;code&gt;'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH&lt;/code&gt; 가 작동합니다. 교차 &lt;code&gt;path&lt;/code&gt; 와 교차하지 않는 경로 의 개념 이 혼동되면 위의 &lt;code&gt;path&lt;/code&gt; 를 그래프 용지에 나란히 그리십시오 .</target>
        </trans-unit>
        <trans-unit id="59f921ad3facaf5178eff030fa07dc7338005685" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asciidoc&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;latex&lt;/code&gt;, &lt;code&gt;latex-longtable&lt;/code&gt;, and &lt;code&gt;troff-ms&lt;/code&gt; formats put out tables that are intended to be included in documents using the respective mark-up language. They are not complete documents! This might not be necessary in HTML, but in LaTeX you must have a complete document wrapper. The &lt;code&gt;latex&lt;/code&gt; format uses LaTeX's &lt;code&gt;tabular&lt;/code&gt; environment. The &lt;code&gt;latex-longtable&lt;/code&gt; format requires the LaTeX &lt;code&gt;longtable&lt;/code&gt; and &lt;code&gt;booktabs&lt;/code&gt; packages.</source>
          <target state="translated">&lt;code&gt;asciidoc&lt;/code&gt; , &lt;code&gt;html&lt;/code&gt; , &lt;code&gt;latex&lt;/code&gt; , &lt;code&gt;latex-longtable&lt;/code&gt; 및 &lt;code&gt;troff-ms&lt;/code&gt; 형식은 각각의 마크 업 언어를 사용하여 문서에 포함된다 테이블을 넣어. 그들은 완전한 문서가 아닙니다! HTML에서는 필요하지 않지만 LaTeX에서는 완전한 문서 래퍼가 있어야합니다. &lt;code&gt;latex&lt;/code&gt; 형식은 유액의 사용 &lt;code&gt;tabular&lt;/code&gt; 환경을. &lt;code&gt;latex-longtable&lt;/code&gt; 형식은 LaTeX의 필요 &lt;code&gt;longtable&lt;/code&gt; 및 &lt;code&gt;booktabs&lt;/code&gt; 패키지를.</target>
        </trans-unit>
        <trans-unit id="f35bd0bda526ded9e0b91c584dead64c2d3ef9b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto_explain&lt;/code&gt; module provides a means for logging execution plans of slow statements automatically, without having to run &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; by hand. This is especially helpful for tracking down un-optimized queries in large applications.</source>
          <target state="translated">&lt;code&gt;auto_explain&lt;/code&gt; 의 모듈은 실행하지 않아도 자동으로 속도가 느린 문장의 실행 계획을 기록하는 수단을 제공 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 손으로. 이는 대규모 응용 프로그램에서 최적화되지 않은 쿼리를 추적하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="50ca73398e0d8534f7dee77b5416915bbe7c2fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base64&lt;/code&gt; format is that of &lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6.8&quot;&gt;RFC 2045 Section 6.8&lt;/a&gt;. As per the RFC, encoded lines are broken at 76 characters. However instead of the MIME CRLF end-of-line marker, only a newline is used for end-of-line. The &lt;code&gt;decode&lt;/code&gt; function ignores carriage-return, newline, space, and tab characters. Otherwise, an error is raised when &lt;code&gt;decode&lt;/code&gt; is supplied invalid base64 data &amp;mdash; including when trailing padding is incorrect.</source>
          <target state="translated">&lt;code&gt;base64&lt;/code&gt; 형식은입니다 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6.8&quot;&gt;RFC 2045의 6.8 절&lt;/a&gt; . RFC에 따라 인코딩 된 줄은 76 자로 나뉩니다. 그러나 MIME CRLF 줄 끝 마커 대신 줄 바꿈에만 줄 바꿈이 사용됩니다. &lt;code&gt;decode&lt;/code&gt; 기능은 캐리지 리턴, 줄 바꿈, 공백 및 탭 문자를 무시합니다. 그렇지 않으면 &lt;code&gt;decode&lt;/code&gt; 에 유효하지 않은 base64 데이터가 제공 될 때 오류가 발생합니다 ( 후행 패딩이 잘못된 경우 포함).</target>
        </trans-unit>
        <trans-unit id="9f04194d1f661ec08cbef8138cc1ebad08b480fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bench.pl&lt;/code&gt; script has numerous options, which are displayed when it is run without any arguments.</source>
          <target state="translated">&lt;code&gt;bench.pl&lt;/code&gt; 의 스크립트는이 인수없이 실행될 때 표시되는 다양한 옵션을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e37968903b5f952d43e00009d52dc6bb5a6d28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; file format consists of a file header, zero or more tuples containing the row data, and a file trailer. Headers and data are in network byte order.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 파일 형식은 파일 헤더, 행 데이터를 포함하는 0 개 이상의 튜플 및 파일 트레일러로 구성되어 있습니다. 헤더와 데이터는 네트워크 바이트 순서로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5593a80ab4eb5986c84ab5663e69124cb8f2b569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; format option causes all data to be stored/read as binary format rather than as text. It is somewhat faster than the text and &lt;code&gt;CSV&lt;/code&gt; formats, but a binary-format file is less portable across machine architectures and PostgreSQL versions. Also, the binary format is very data type specific; for example it will not work to output binary data from a &lt;code&gt;smallint&lt;/code&gt; column and read it into an &lt;code&gt;integer&lt;/code&gt; column, even though that would work fine in text format.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 포맷 옵션은 모든 데이터가 바이너리 형식으로가 아닌 텍스트로 읽기 / 저장됩니다. 텍스트 및 &lt;code&gt;CSV&lt;/code&gt; 형식 보다 다소 빠르지 만 이진 형식 파일은 머신 아키텍처 및 PostgreSQL 버전에서 이식성이 떨어집니다. 또한 이진 형식은 데이터 형식에 따라 다릅니다. 예를 들어 &lt;code&gt;smallint&lt;/code&gt; 열 에서 이진 데이터를 출력 하고 &lt;code&gt;integer&lt;/code&gt; 열로 읽는 것은 작동하지 않지만 텍스트 형식에서는 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="402f6e7dc47cea56b75bd8100479b08159b6b07c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytea&lt;/code&gt; data type allows storage of binary strings; see &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-TABLE&quot;&gt;Table 8.6&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 데이터 타입은 이진 스트링의 저장을 허용; &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-TABLE&quot;&gt;표 8.6을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6287927d29cc83d11891a4932630e624e03a0f93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytea&lt;/code&gt; type supports two formats for input and output: &amp;ldquo;hex&amp;rdquo; format and PostgreSQL's historical &amp;ldquo;escape&amp;rdquo; format. Both of these are always accepted on input. The output format depends on the configuration parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;bytea_output&lt;/a&gt;; the default is hex. (Note that the hex format was introduced in PostgreSQL 9.0; earlier versions and some tools don't understand it.)</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 와의 종류가 지원하는 입력 및 출력에 대한 두 가지 형식 : &quot;진수&quot;형식과 PostgreSQL의 역사 &quot;탈출&quot;형식입니다. 이 두 가지 모두 입력시 항상 허용됩니다. 출력 형식은 &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;bytea_output&lt;/a&gt; 구성 매개 변수에 따라 다릅니다 . 디폴트는 16 진입니다. 16 진수 형식은 PostgreSQL 9.0에서 도입되었으며 이전 버전 및 일부 도구는이를 이해하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="e03633603ba240cb14fd9f2ba15fb155d7d2a20f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; and &lt;code&gt;preferred&lt;/code&gt; parameters can be used to help control which implicit cast will be applied in ambiguous situations. Each data type belongs to a category named by a single ASCII character, and each type is either &amp;ldquo;preferred&amp;rdquo; or not within its category. The parser will prefer casting to preferred types (but only from other types within the same category) when this rule is helpful in resolving overloaded functions or operators. For more details see &lt;a href=&quot;https://www.postgresql.org/docs/12/typeconv.html&quot;&gt;Chapter 10&lt;/a&gt;. For types that have no implicit casts to or from any other types, it is sufficient to leave these settings at the defaults. However, for a group of related types that have implicit casts, it is often helpful to mark them all as belonging to a category and select one or two of the &amp;ldquo;most general&amp;rdquo; types as being preferred within the category. The &lt;code&gt;category&lt;/code&gt; parameter is especially useful when adding a user-defined type to an existing built-in category, such as the numeric or string types. However, it is also possible to create new entirely-user-defined type categories. Select any ASCII character other than an upper-case letter to name such a category.</source>
          <target state="translated">&lt;code&gt;category&lt;/code&gt; 및 &lt;code&gt;preferred&lt;/code&gt; 매개 변수는 암시 적 캐스트가 모호한 상황에서 적용됩니다 도움말 제어 할 수 있습니다. 각 데이터 유형은 단일 ASCII 문자로 명명 된 카테고리에 속하며 각 유형은 &quot;선호&quot;또는 카테고리 내에 있지 않습니다. 이 규칙이 오버로드 된 함수 나 연산자를 해결하는 데 도움이되는 경우 파서는 선호하는 유형 (동일한 범주 내의 다른 유형에서만)으로 캐스팅하는 것을 선호합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/typeconv.html&quot;&gt;10 장을&lt;/a&gt; 참조하십시오. 다른 유형과의 암시 적 캐스트가없는 유형의 경우 이러한 설정을 기본값으로 두는 것으로 충분합니다. 그러나 내재 된 캐스트가있는 관련 유형 그룹의 경우, 모두 유형에 속하는 것으로 표시하고 카테고리 내에서 선호하는 &quot;가장 일반적인&quot;유형 중 하나 또는 두 개를 선택하는 것이 종종 도움이됩니다. &lt;code&gt;category&lt;/code&gt; 사용자 정의 형 파라미터를 추가하는 경우가 특히 유용 기존의 기본 범주, 이러한 숫자 또는 문자열 유형으로. 그러나 완전히 사용자 정의 된 새 유형 범주를 만들 수도 있습니다. 대문자 이외의 ASCII 문자를 선택하여 해당 범주의 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ae9b3a9d8d6f4a13befdf57fd60cc43eadf9e46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; and &lt;code&gt;preferred&lt;/code&gt; parameters can be used to help control which implicit cast will be applied in ambiguous situations. Each data type belongs to a category named by a single ASCII character, and each type is either &amp;ldquo;preferred&amp;rdquo; or not within its category. The parser will prefer casting to preferred types (but only from other types within the same category) when this rule is helpful in resolving overloaded functions or operators. For more details see &lt;a href=&quot;https://www.postgresql.org/docs/13/typeconv.html&quot;&gt;Chapter 10&lt;/a&gt;. For types that have no implicit casts to or from any other types, it is sufficient to leave these settings at the defaults. However, for a group of related types that have implicit casts, it is often helpful to mark them all as belonging to a category and select one or two of the &amp;ldquo;most general&amp;rdquo; types as being preferred within the category. The &lt;code&gt;category&lt;/code&gt; parameter is especially useful when adding a user-defined type to an existing built-in category, such as the numeric or string types. However, it is also possible to create new entirely-user-defined type categories. Select any ASCII character other than an upper-case letter to name such a category.</source>
          <target state="translated">&lt;code&gt;category&lt;/code&gt; 및 &lt;code&gt;preferred&lt;/code&gt; 매개 변수는 암시 적 캐스트가 모호한 상황에서 적용됩니다 도움말 제어 할 수 있습니다. 각 데이터 유형은 단일 ASCII 문자로 명명 된 범주에 속하며 각 유형은 &quot;선호&quot;되거나 해당 범주에 속하지 않습니다. 이 규칙이 오버로드 된 함수 또는 연산자를 해결하는 데 도움이되는 경우 파서는 선호되는 유형 (동일 범주 내의 다른 유형에서만)으로 캐스팅하는 것을 선호합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/typeconv.html&quot;&gt;10 장을&lt;/a&gt; 참조하십시오.. 다른 유형에 대한 암시 적 캐스트가없는 유형의 경우 이러한 설정을 기본값으로 두는 것으로 충분합니다. 그러나 암시 적 캐스트가있는 관련 유형 그룹의 경우 모두 카테고리에 속하는 것으로 표시하고 카테고리 내에서 선호되는 &quot;가장 일반적인&quot;유형 중 하나 또는 두 개를 선택하는 것이 도움이됩니다. &lt;code&gt;category&lt;/code&gt; 사용자 정의 형 파라미터를 추가하는 경우가 특히 유용 기존의 기본 범주, 이러한 숫자 또는 문자열 유형으로. 그러나 완전히 사용자 정의 된 새로운 유형 범주를 생성하는 것도 가능합니다. 이러한 범주의 이름을 지정하려면 대문자 이외의 ASCII 문자를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="8d165445c71930fc47e32f1799f62450eb66b7c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_length&lt;/code&gt; function is discussed in &lt;a href=&quot;functions-string&quot;&gt;Section 9.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char_length&lt;/code&gt; 함수로 설명 &lt;a href=&quot;functions-string&quot;&gt;9.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77163d06028806a119645154241f80d46c25a3ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checksum&lt;/code&gt; field is the checksum stored in the page, which might be incorrect if the page is somehow corrupted. If data checksums are not enabled for this instance, then the value stored is meaningless.</source>
          <target state="translated">&lt;code&gt;checksum&lt;/code&gt; 필드는 페이지가 어떻게 든 손상된 경우 올바르지 않을 수 있습니다 페이지에 저장된 체크섬이다. 이 인스턴스에 대해 데이터 체크섬을 사용할 수없는 경우 저장된 값은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="82779e6580b956b5bd325b957d4ac6fe2940b5b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;choose&lt;/code&gt; function can determine either that the new value matches one of the existing child nodes, or that a new child node must be added, or that the new value is inconsistent with the tuple prefix and so the inner tuple must be split to create a less restrictive prefix.</source>
          <target state="translated">&lt;code&gt;choose&lt;/code&gt; 새 값이 기존의 자식 노드 중 하나와 일치하는지, 또는 새 자식 노드를 추가해야한다는, 또는 새로운 값이를 만들 분할해야 튜플 접두사와 내부 튜플 너무 일치하지 않는 부분 중 하나를 확인할 수 있습니다 기능을 덜 제한적인 접두사.</target>
        </trans-unit>
        <trans-unit id="21462edf88e71a2a5abedaf79780415d3cc77658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cidr&lt;/code&gt; type holds an IPv4 or IPv6 network specification. Input and output formats follow Classless Internet Domain Routing conventions. The format for specifying networks is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is the network represented as an IPv4 or IPv6 address, and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If &lt;code&gt;y&lt;/code&gt; is omitted, it is calculated using assumptions from the older classful network numbering system, except it will be at least large enough to include all of the octets written in the input. It is an error to specify a network address that has bits set to the right of the specified netmask.</source>
          <target state="translated">&lt;code&gt;cidr&lt;/code&gt; 유형은 IPv4 또는 IPv6 네트워크 사양을 보유하고 있습니다. 입력 및 출력 형식은 클래스리스 인터넷 도메인 라우팅 규칙을 따릅니다. 네트워크를 지정하는 형식은 &lt;code&gt;address/y&lt;/code&gt; 입니다. 여기서 &lt;code&gt;address&lt;/code&gt; 는 IPv4 또는 IPv6 주소로 표시되는 네트워크이고 &lt;code&gt;y&lt;/code&gt; 는 넷 마스크의 비트 수입니다. 경우 &lt;code&gt;y&lt;/code&gt; 생략이 입력에 기록 된 모든 옥텟을 포함하는 적어도 충분한있을 것 이외에는, 또, 기존의 네트워크 클래스 번호 시스템에서 가정을 사용하여 계산된다. 지정된 넷 마스크의 오른쪽에 비트가 설정된 네트워크 주소를 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="83d341b6c5b04bb2ef3744b33127cc01588e2a85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cidr&lt;/code&gt; type holds an IPv4 or IPv6 network specification. Input and output formats follow Classless Internet Domain Routing conventions. The format for specifying networks is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is the network's lowest address represented as an IPv4 or IPv6 address, and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If &lt;code&gt;y&lt;/code&gt; is omitted, it is calculated using assumptions from the older classful network numbering system, except it will be at least large enough to include all of the octets written in the input. It is an error to specify a network address that has bits set to the right of the specified netmask.</source>
          <target state="translated">&lt;code&gt;cidr&lt;/code&gt; 유형은 IPv4 또는 IPv6 네트워크 사양을 보유하고 있습니다. 입력 및 출력 형식은 클래스없는 인터넷 도메인 라우팅 규칙을 따릅니다. 네트워크를 지정하는 형식은 &lt;code&gt;address/y&lt;/code&gt; 입니다. 여기서 &lt;code&gt;address&lt;/code&gt; 는 IPv4 또는 IPv6 주소로 표시되는 네트워크의 가장 낮은 주소이고 &lt;code&gt;y&lt;/code&gt; 는 넷 마스크의 비트 수입니다. 경우 &lt;code&gt;y&lt;/code&gt; 생략이 입력에 기록 된 모든 옥텟을 포함하는 적어도 충분한있을 것 이외에는, 또, 기존의 네트워크 클래스 번호 시스템에서 가정을 사용하여 계산된다. 지정된 넷 마스크의 오른쪽에 비트가 설정된 네트워크 주소를 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="313dbc3735e1e6015db884f05770b0b3141b691a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;citext&lt;/code&gt; data type allows you to eliminate calls to &lt;code&gt;lower&lt;/code&gt; in SQL queries, and allows a primary key to be case-insensitive. &lt;code&gt;citext&lt;/code&gt; is locale-aware, just like &lt;code&gt;text&lt;/code&gt;, which means that the matching of upper case and lower case characters is dependent on the rules of the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting. Again, this behavior is identical to the use of &lt;code&gt;lower&lt;/code&gt; in queries. But because it's done transparently by the data type, you don't have to remember to do anything special in your queries.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 의 데이터 타입은 당신이 전화 제거 할 수 있습니다 &lt;code&gt;lower&lt;/code&gt; SQL 쿼리에, 그리고 대소 문자를 구별 될 수있는 기본 키를 할 수 있습니다. &lt;code&gt;citext&lt;/code&gt; 는 &lt;code&gt;text&lt;/code&gt; 와 마찬가지로 로케일을 인식 하므로 대문자와 소문자의 일치는 데이터베이스의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정 규칙에 따라 다릅니다 . 이 동작은 &lt;code&gt;lower&lt;/code&gt; 쿼리를 사용하는 것과 동일 합니다. 그러나 데이터 유형별로 투명하게 수행되므로 쿼리에서 특별한 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd87bdad25baf813522f25a71f5adc18488d42f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;citext&lt;/code&gt; module provides a case-insensitive character string type, &lt;code&gt;citext&lt;/code&gt;. Essentially, it internally calls &lt;code&gt;lower&lt;/code&gt; when comparing values. Otherwise, it behaves almost exactly like &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 의 모듈은 대소 문자를 구분 문자열 유형을 제공 &lt;code&gt;citext&lt;/code&gt; 을 . 본질적으로, 내부적으로 호출 &lt;code&gt;lower&lt;/code&gt; 값을 비교할 때. 그렇지 않으면 &lt;code&gt;text&lt;/code&gt; 와 거의 동일하게 동작 합니다 .</target>
        </trans-unit>
        <trans-unit id="bfdaff8a345f235278633882be7cad6ce5741ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clientcert&lt;/code&gt; authentication option is available for all authentication methods, but only in &lt;code&gt;pg_hba.conf&lt;/code&gt; lines specified as &lt;code&gt;hostssl&lt;/code&gt;. When &lt;code&gt;clientcert&lt;/code&gt; is not specified or is set to &lt;code&gt;no-verify&lt;/code&gt;, the server will still verify any presented client certificates against its CA file, if one is configured &amp;mdash; but it will not insist that a client certificate be presented.</source>
          <target state="translated">&lt;code&gt;clientcert&lt;/code&gt; 의 인증 옵션 만에, 모든 인증 방법을 사용할 수 &lt;code&gt;pg_hba.conf&lt;/code&gt; 로 지정된 라인 &lt;code&gt;hostssl&lt;/code&gt; . 때 &lt;code&gt;clientcert&lt;/code&gt; 가 지정되지 않았거나로 설정되어 &lt;code&gt;no-verify&lt;/code&gt; 한 구성되어있는 경우 서버가 계속 그 CA 파일에 대해 어떤되게 클라이언트 인증서를 확인합니다 -하지만 클라이언트 인증서가 제공 될 주장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c87c5b4f9f4b1dd6255f18fc98a9e79dfa277fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;column_expression&lt;/code&gt; for a column is an XPath 1.0 expression that is evaluated for each row, with the current node from the &lt;code&gt;row_expression&lt;/code&gt; result as its context item, to find the value of the column. If no &lt;code&gt;column_expression&lt;/code&gt; is given, then the column name is used as an implicit path.</source>
          <target state="translated">&lt;code&gt;column_expression&lt;/code&gt; 열의는로부터 현재 노드와, 각 행에 대해 평가하는 XPath 표현 1.0 &lt;code&gt;row_expression&lt;/code&gt; 의 열 값을 찾기 위해, 그 컨텍스트 항목과 결과. &lt;code&gt;column_expression&lt;/code&gt; 이 제공 되지 않으면 열 이름이 암시 적 경로로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee6cd05e41a967e8fffae0ba56f38e3c8841aa41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combinefunc&lt;/code&gt; function may optionally be specified to allow the aggregate function to support partial aggregation. If provided, the &lt;code&gt;combinefunc&lt;/code&gt; must combine two &lt;code&gt;state_data_type&lt;/code&gt; values, each containing the result of aggregation over some subset of the input values, to produce a new &lt;code&gt;state_data_type&lt;/code&gt; that represents the result of aggregating over both sets of inputs. This function can be thought of as an &lt;code&gt;sfunc&lt;/code&gt;, where instead of acting upon an individual input row and adding it to the running aggregate state, it adds another aggregate state to the running state.</source>
          <target state="translated">&lt;code&gt;combinefunc&lt;/code&gt; 의 기능을 선택적으로 집계 기능 부분 집합을 지원하도록 지정 될 수있다. 제공되는 경우 &lt;code&gt;combinefunc&lt;/code&gt; 는 두 입력 집합에 대한 집계 결과를 나타내는 새로운 &lt;code&gt;state_data_type&lt;/code&gt; 을 생성하기 위해 각각 입력 값의 일부 하위 집합에 대한 집계 결과를 포함하는 두 개의 &lt;code&gt;state_data_type&lt;/code&gt; 값을 결합해야합니다 . 이 함수는 개별 입력 행에 작용하여 실행 집계 상태에 추가하는 대신 다른 집계 상태를 실행 상태에 추가 하는 &lt;code&gt;sfunc&lt;/code&gt; 로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47761aa84c1d418aac8f5102d13fb4baaa2c9ec6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combinefunc&lt;/code&gt; must be declared as taking two arguments of the &lt;code&gt;state_data_type&lt;/code&gt; and returning a value of the &lt;code&gt;state_data_type&lt;/code&gt;. Optionally this function may be &amp;ldquo;strict&amp;rdquo;. In this case the function will not be called when either of the input states are null; the other state will be taken as the correct result.</source>
          <target state="translated">&lt;code&gt;combinefunc&lt;/code&gt; 이 의 두 개의 인수 복용으로 선언해야 &lt;code&gt;state_data_type&lt;/code&gt; 을 하고 값 반환 &lt;code&gt;state_data_type&lt;/code&gt; 을 . 선택적으로이 기능은&amp;ldquo;엄격&amp;rdquo;할 수 있습니다. 이 경우 입력 상태 중 하나가 null 인 경우 함수가 호출되지 않습니다. 다른 상태는 올바른 결과로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="09fe595cccceb2fd23743e43b5600a7fb060859e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;composite_value&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; syntax results in column expansion of this kind when it appears at the top level of a &lt;a href=&quot;queries-select-lists&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; output list&lt;/a&gt;, a &lt;a href=&quot;dml-returning&quot;&gt;&lt;code&gt;RETURNING&lt;/code&gt; list&lt;/a&gt; in &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;, a &lt;a href=&quot;queries-values&quot;&gt;&lt;code&gt;VALUES&lt;/code&gt; clause&lt;/a&gt;, or a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. In all other contexts (including when nested inside one of those constructs), attaching &lt;code&gt;.*&lt;/code&gt; to a composite value does not change the value, since it means &amp;ldquo;all columns&amp;rdquo; and so the same composite value is produced again. For example, if &lt;code&gt;somefunc()&lt;/code&gt; accepts a composite-valued argument, these queries are the same:</source>
          <target state="translated">&lt;code&gt;composite_value&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 이러한 종류의 열 팽창 구문 결과 그것의 최상위에 나타나는 &lt;a href=&quot;queries-select-lists&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; 출력리스트&lt;/a&gt; 하는 &lt;a href=&quot;dml-returning&quot;&gt; &lt;code&gt;RETURNING&lt;/code&gt; 리스트&lt;/a&gt; 에 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; 하는 &lt;a href=&quot;queries-values&quot;&gt; &lt;code&gt;VALUES&lt;/code&gt; 의 절&lt;/a&gt; 또는 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;연속 생성자&lt;/a&gt; . 다른 모든 컨텍스트 (해당 구문 중 하나에 중첩 된 경우 포함)에서 복합 값에 &lt;code&gt;.*&lt;/code&gt; 를 첨부 해도 값은 변경되지 않습니다. &quot;모든 열&quot;을 의미하므로 동일한 복합 값이 다시 생성됩니다. 예를 들어 &lt;code&gt;somefunc()&lt;/code&gt; 가 복합 값 인수를 허용하면 이러한 쿼리는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="76f0da3cbd2adb16157bd1e6643bd7a0df3d22de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;concat_ws&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; functions are variadic, so it is possible to pass the values to be concatenated or formatted as an array marked with the &lt;code&gt;VARIADIC&lt;/code&gt; keyword (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;Section 37.5.5&lt;/a&gt;). The array's elements are treated as if they were separate ordinary arguments to the function. If the variadic array argument is NULL, &lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concat_ws&lt;/code&gt; return NULL, but &lt;code&gt;format&lt;/code&gt; treats a NULL as a zero-element array.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; , &lt;code&gt;concat_ws&lt;/code&gt; 과 &lt;code&gt;format&lt;/code&gt; 이 연접하거나 표시된 어레이로서 포맷되는 값 통과 할 수 있도록 기능이있는 가변 &lt;code&gt;VARIADIC&lt;/code&gt; 의 키워드 (참조 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;섹션을 37.5.5&lt;/a&gt; ). 배열의 요소는 마치 함수에 대한 별도의 일반 인수 인 것처럼 처리됩니다. variadic 배열 인수가 NULL이면 &lt;code&gt;concat&lt;/code&gt; 및 &lt;code&gt;concat_ws&lt;/code&gt; 는 NULL을 반환하지만 &lt;code&gt;format&lt;/code&gt; 은 NULL을 0 요소 배열로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8848aba9dd7be7afc0e552cb7431ead72ee718f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;concat_ws&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; functions are variadic, so it is possible to pass the values to be concatenated or formatted as an array marked with the &lt;code&gt;VARIADIC&lt;/code&gt; keyword (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;Section 37.5.5&lt;/a&gt;). The array's elements are treated as if they were separate ordinary arguments to the function. If the variadic array argument is NULL, &lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concat_ws&lt;/code&gt; return NULL, but &lt;code&gt;format&lt;/code&gt; treats a NULL as a zero-element array.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; , &lt;code&gt;concat_ws&lt;/code&gt; 과 &lt;code&gt;format&lt;/code&gt; 이 연접하거나 표시된 어레이로서 포맷되는 값 통과 할 수 있도록 기능이있는 가변 &lt;code&gt;VARIADIC&lt;/code&gt; 의 키워드 (참조 &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;섹션을 37.5.5&lt;/a&gt; ). 배열의 요소는 함수에 대한 별도의 일반 인수 인 것처럼 처리됩니다. 가변 배열 인수가 NULL이면 &lt;code&gt;concat&lt;/code&gt; 및 &lt;code&gt;concat_ws&lt;/code&gt; 는 NULL을 반환하지만 &lt;code&gt;format&lt;/code&gt; 은 NULL을 요소가없는 배열로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a299b1850dd68d90e4960be66574857975c076da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connectby&lt;/code&gt; function is declared to return &lt;code&gt;setof record&lt;/code&gt;, so the actual names and types of the output columns must be defined in the &lt;code&gt;FROM&lt;/code&gt; clause of the calling &lt;code&gt;SELECT&lt;/code&gt; statement, for example:</source>
          <target state="translated">&lt;code&gt;connectby&lt;/code&gt; 의 기능은 복귀 선언 &lt;code&gt;setof record&lt;/code&gt; 출력 컬럼의 실제 이름과 유형이 정의해야합니다, 그래서 &lt;code&gt;FROM&lt;/code&gt; 호출 절 &lt;code&gt;SELECT&lt;/code&gt; 예를 들어, 문 :</target>
        </trans-unit>
        <trans-unit id="2da96468cede4a34e23f2e877f5cf905f10ef78c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connectby&lt;/code&gt; function produces a display of hierarchical data that is stored in a table. The table must have a key field that uniquely identifies rows, and a parent-key field that references the parent (if any) of each row. &lt;code&gt;connectby&lt;/code&gt; can display the sub-tree descending from any row.</source>
          <target state="translated">&lt;code&gt;connectby&lt;/code&gt; 의 함수는 테이블에 저장된 계층 적 데이터의 표시를 생성한다. 테이블에는 행을 고유하게 식별하는 키 필드와 각 행의 상위 (있는 경우)를 참조하는 상위 키 필드가 있어야합니다. &lt;code&gt;connectby&lt;/code&gt; 는 모든 행에서 내림차순으로 하위 트리를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85d82cc59d92a5d0a18334cf90938c8ed88a3a9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contrib&lt;/code&gt; section contains a number of extensions that provide transforms, which can serve as real-world examples.</source>
          <target state="translated">&lt;code&gt;contrib&lt;/code&gt; 섹션은 실제 사례 역할을 할 수 변환을 제공하는 확장의 수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1ffcb414402375d1d42596e7d3c9b1593a173043" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows copied.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 복사 된 행의 수입니다.</target>
        </trans-unit>
        <trans-unit id="af73b626e7353c20a6881d071978129473a029ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows deleted. Note that the number may be less than the number of rows that matched the &lt;code&gt;condition&lt;/code&gt; when deletes were suppressed by a &lt;code&gt;BEFORE DELETE&lt;/code&gt; trigger. If &lt;code&gt;count&lt;/code&gt; is 0, no rows were deleted by the query (this is not considered an error).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 삭제 된 행의 수입니다. &lt;code&gt;BEFORE DELETE&lt;/code&gt; 트리거에 의해 삭제가 억제 된 경우이 수는 &lt;code&gt;condition&lt;/code&gt; 과 일치하는 행 수보다 적을 수 있습니다 . 경우 &lt;code&gt;count&lt;/code&gt; 0, 행이 (이 오류로 간주되지 않음) 쿼리에 의해 삭제되지 않았다.</target>
        </trans-unit>
        <trans-unit id="429e699d049ecd7be74bd5a583ab136d3d21eca9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows fetched (possibly zero). Note that in psql, the command tag will not actually be displayed, since psql displays the fetched rows instead.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 행의 수 (가능한 제로) 페치된다. psql에서는 페치 된 행을 대신 표시하므로 명령 태그는 실제로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e0d4008484fc3a6fda992772be11542d78e11a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows inserted or updated. &lt;code&gt;oid&lt;/code&gt; is always 0 (it used to be the OID assigned to the inserted row if &lt;code&gt;count&lt;/code&gt; was exactly one and the target table was declared &lt;code&gt;WITH OIDS&lt;/code&gt; and 0 otherwise, but creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 삽입되거나 갱신 된 행의 수이다. &lt;code&gt;oid&lt;/code&gt; 는 항상 0입니다. &lt;code&gt;count&lt;/code&gt; 가 정확히 1이고 대상 테이블이 &lt;code&gt;WITH OIDS&lt;/code&gt; 로 선언 된 경우 삽입 된 행에 지정된 OID 였으며 그렇지 않은 경우 0이지만 더 이상 &lt;code&gt;WITH OIDS&lt;/code&gt; 를 갖는 테이블 은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d59e6fa3805ce82c8f3b0c639019e005fef26c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows that a &lt;code&gt;FETCH&lt;/code&gt; command with the same parameters would have returned (possibly zero).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; A가 행수 &lt;code&gt;FETCH&lt;/code&gt; 반환 한 것과 동일한 파라미터를 명령 (아마도 제로).</target>
        </trans-unit>
        <trans-unit id="ffde14c1ea2e01417c3435708517261d052ddb1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows updated, including matched rows whose values did not change. Note that the number may be less than the number of rows that matched the &lt;code&gt;condition&lt;/code&gt; when updates were suppressed by a &lt;code&gt;BEFORE UPDATE&lt;/code&gt; trigger. If &lt;code&gt;count&lt;/code&gt; is 0, no rows were updated by the query (this is not considered an error).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 그 값을 변경하지 않은 유사한 행을 포함하여 갱신 된 행의 수이다. &lt;code&gt;BEFORE UPDATE&lt;/code&gt; 트리거에 의해 업데이트가 억제 될 때이 수 는 &lt;code&gt;condition&lt;/code&gt; 과 일치하는 행 수보다 적을 수 있습니다 . 경우 &lt;code&gt;count&lt;/code&gt; 0, 행이 (이 오류로 간주되지 않음) 쿼리에 의해 업데이트되지 않았다.</target>
        </trans-unit>
        <trans-unit id="1bd1175f717b500daf5cf94e2ae95b1e5dd562f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function is declared to return &lt;code&gt;setof record&lt;/code&gt;, so the actual names and types of the output columns must be defined in the &lt;code&gt;FROM&lt;/code&gt; clause of the calling &lt;code&gt;SELECT&lt;/code&gt; statement, for example:</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 기능은 복귀 선언 &lt;code&gt;setof record&lt;/code&gt; 출력 컬럼의 실제 이름과 유형이 정의해야합니다, 그래서 &lt;code&gt;FROM&lt;/code&gt; 호출 절 &lt;code&gt;SELECT&lt;/code&gt; 예를 들어, 문 :</target>
        </trans-unit>
        <trans-unit id="d8aadf50544262136fa7d8c76d5edc945fb11396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function is used to produce &amp;ldquo;pivot&amp;rdquo; displays, wherein data is listed across the page rather than down. For example, we might have data like</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 함수는 데이터 페이지보다 아래에 나열되는 것을 특징으로하는 &quot;피봇&quot;디스플레이를 생산하는데 사용된다. 예를 들어 다음과 같은 데이터가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fc99faab5d994fa37274aca83e33cbe8ab82de4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function produces one output row for each consecutive group of input rows with the same &lt;code&gt;row_name&lt;/code&gt; value. It fills the output &lt;code&gt;value&lt;/code&gt; columns, left to right, with the &lt;code&gt;value&lt;/code&gt; fields from these rows. If there are fewer rows in a group than there are output &lt;code&gt;value&lt;/code&gt; columns, the extra output columns are filled with nulls; if there are more rows, the extra input rows are skipped.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 함수와 같은 입력 행들 각각 연속 그룹에 대해 하나의 열 출력을 생성 &lt;code&gt;row_name&lt;/code&gt; 값. 이 행 의 &lt;code&gt;value&lt;/code&gt; 필드로 왼쪽에서 오른쪽으로 출력 &lt;code&gt;value&lt;/code&gt; 열을 채 웁니다 . 그룹에 출력 &lt;code&gt;value&lt;/code&gt; 열 보다 적은 수의 행이 있으면 추가 출력 열은 널로 채워집니다. 더 많은 행이 있으면 추가 입력 행을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="fc54c6a3ee9f1815fead23a991ca1a3cbc31deef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function produces one output row for each consecutive group of input rows with the same &lt;code&gt;row_name&lt;/code&gt; value. The output &lt;code&gt;row_name&lt;/code&gt; column, plus any &amp;ldquo;extra&amp;rdquo; columns, are copied from the first row of the group. The output &lt;code&gt;value&lt;/code&gt; columns are filled with the &lt;code&gt;value&lt;/code&gt; fields from rows having matching &lt;code&gt;category&lt;/code&gt; values. If a row's &lt;code&gt;category&lt;/code&gt; does not match any output of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query, its &lt;code&gt;value&lt;/code&gt; is ignored. Output columns whose matching category is not present in any input row of the group are filled with nulls.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 함수와 같은 입력 행들 각각 연속 그룹에 대해 하나의 열 출력을 생성 &lt;code&gt;row_name&lt;/code&gt; 값. 출력 &lt;code&gt;row_name&lt;/code&gt; 열과 &quot;추가&quot;열이 그룹의 첫 번째 행에서 복사됩니다. 출력 &lt;code&gt;value&lt;/code&gt; 열은 &lt;code&gt;category&lt;/code&gt; 값 이 일치하는 행 의 &lt;code&gt;value&lt;/code&gt; 필드 로 채워집니다 . 행의 &lt;code&gt;category&lt;/code&gt; 가 &lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt; 쿼리의 출력과 일치하지 않으면 해당 &lt;code&gt;value&lt;/code&gt; 이 무시됩니다. 그룹의 입력 행에 일치하는 카테고리가없는 출력 열은 널로 채워집니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d30aa2f376a61f86fd4ea02ce6152e230c73fa37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function takes a text parameter that is a SQL query producing raw data formatted in the first way, and produces a table formatted in the second way.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 함수는 두 번째 방법으로 포맷 테이블을 제 방식으로 포맷 된 원시 데이터를 생성하는 SQL 쿼리되는 텍스트 매개 변수를 사용하고 생성한다.</target>
        </trans-unit>
        <trans-unit id="cf52a8ddea78696a7f9befff4ffbcb20d2c48c6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstabN&lt;/code&gt; functions are examples of how to set up custom wrappers for the general &lt;code&gt;crosstab&lt;/code&gt; function, so that you need not write out column names and types in the calling &lt;code&gt;SELECT&lt;/code&gt; query. The &lt;code&gt;tablefunc&lt;/code&gt; module includes &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt;, whose output row types are defined as</source>
          <target state="translated">&lt;code&gt;crosstabN&lt;/code&gt; 의 기능은 일반 사용자 정의 래퍼를 설정하는 방법의 예입니다 &lt;code&gt;crosstab&lt;/code&gt; 이 호출에 열 이름과 유형을 쓸 필요가 그래서, 기능 &lt;code&gt;SELECT&lt;/code&gt; 쿼리. &lt;code&gt;tablefunc&lt;/code&gt; 의 모듈을 포함 &lt;code&gt;crosstab2&lt;/code&gt; , &lt;code&gt;crosstab3&lt;/code&gt; 및 &lt;code&gt;crosstab4&lt;/code&gt; 출력이 행의 형식으로 정의를</target>
        </trans-unit>
        <trans-unit id="54ac58ac577c46bd040592fa91e1a077c06d943c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cube&lt;/code&gt; module also provides a GiST index operator class for &lt;code&gt;cube&lt;/code&gt; values. A &lt;code&gt;cube&lt;/code&gt; GiST index can be used to search for values using the &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;@&lt;/code&gt; operators in &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">&lt;code&gt;cube&lt;/code&gt; 모듈은 요지를위한 지수 연산자 클래스 제공 &lt;code&gt;cube&lt;/code&gt; 값. &lt;code&gt;cube&lt;/code&gt; 요지 인덱스 값을 이용하여 검색 할 수 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;@&lt;/code&gt; 운영자에 &lt;code&gt;WHERE&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="50f70b486d4ad8f59d32b634d01c225abbf16c1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cube&lt;/code&gt; module must be installed before &lt;code&gt;earthdistance&lt;/code&gt; can be installed (although you can use the &lt;code&gt;CASCADE&lt;/code&gt; option of &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to install both in one command).</source>
          <target state="translated">&lt;code&gt;cube&lt;/code&gt; 전에 모듈이 설치되어 있어야합니다 &lt;code&gt;earthdistance&lt;/code&gt; 가 설치 될 수있다 (당신이 사용할 수 있지만 &lt;code&gt;CASCADE&lt;/code&gt; 의 옵션을 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 하나의 명령에 모두 설치).</target>
        </trans-unit>
        <trans-unit id="f843170ee2f9efd669c186bf546d0e5dd7a1284a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;date_part&lt;/code&gt; function is modeled on the traditional Ingres equivalent to the SQL-standard function &lt;code&gt;extract&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;date_part&lt;/code&gt; 의 기능은 SQL 표준 기능으로 기존의 앵그르 해당하는 모델로되어 &lt;code&gt;extract&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f86c2923695a5cb7e765ce636cd1eaf768157c0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;datetime()&lt;/code&gt; and &lt;code&gt;datetime(template)&lt;/code&gt; methods use the same parsing rules as the &lt;code&gt;to_timestamp&lt;/code&gt; SQL function does (see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;), with three exceptions. First, these methods don't allow unmatched template patterns. Second, only the following separators are allowed in the template string: minus sign, period, solidus (slash), comma, apostrophe, semicolon, colon and space. Third, separators in the template string must exactly match the input string.</source>
          <target state="translated">&lt;code&gt;datetime()&lt;/code&gt; 및 &lt;code&gt;datetime(template)&lt;/code&gt; 방법은 동일한 구문 분석 규칙을 사용 &lt;code&gt;to_timestamp&lt;/code&gt; (참조 않는 SQL 기능 &lt;a href=&quot;functions-formatting&quot;&gt;9.8 절을&lt;/a&gt; 세 가지 예외를 제외하고). 첫째, 이러한 방법은 일치하지 않는 템플릿 패턴을 허용하지 않습니다. 둘째, 빼기 기호, 마침표, solidus (슬래시), 쉼표, 아포스트로피, 세미콜론, 콜론 및 공백과 같은 구분 기호 만 템플릿 문자열에 허용됩니다. 셋째, 템플릿 문자열의 구분 기호는 입력 문자열과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="69a9982714cc2b591df8607d261cb35421749d2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;datetime()&lt;/code&gt; method sequentially tries to match its input string to the ISO formats for &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;timetz&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamptz&lt;/code&gt;, and &lt;code&gt;timestamp&lt;/code&gt;. It stops on the first matching format and emits the corresponding data type.</source>
          <target state="translated">&lt;code&gt;datetime()&lt;/code&gt; 메소드는 순차적에 대한 ISO 형식으로 입력 문자열을 일치 시키려고 &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;timetz&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamptz&lt;/code&gt; 및 &lt;code&gt;timestamp&lt;/code&gt; . 첫 번째 일치 형식에서 중지하고 해당 데이터 유형을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="836a783180131a8185f89b0cfb15c8fdbfca6765" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;datetime(template)&lt;/code&gt; method determines the result type according to the fields used in the provided template string.</source>
          <target state="translated">&lt;code&gt;datetime(template)&lt;/code&gt; 에있어서, 상기 제공된 템플릿 문자열에 사용되는 분야에 따라 결과 유형을 결정한다.</target>
        </trans-unit>
        <trans-unit id="c29b4371698f7a456bc5cd073d69c9abf2e592bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;earthdistance&lt;/code&gt; module provides two different approaches to calculating great circle distances on the surface of the Earth. The one described first depends on the &lt;code&gt;cube&lt;/code&gt; module (which &lt;em&gt;must&lt;/em&gt; be installed before &lt;code&gt;earthdistance&lt;/code&gt; can be installed). The second one is based on the built-in &lt;code&gt;point&lt;/code&gt; data type, using longitude and latitude for the coordinates.</source>
          <target state="translated">&lt;code&gt;earthdistance&lt;/code&gt; 의 모듈은 지구 표면에 큰 원형의 거리를 계산하는 두 가지 방법을 제공합니다. 먼저 설명 된 것은 &lt;code&gt;cube&lt;/code&gt; 모듈 ( &lt;code&gt;earthdistance&lt;/code&gt; 설치하기 전에 설치 &lt;em&gt;해야&lt;/em&gt; 함) 에 따라 다릅니다 . 두 번째 는 좌표에 경도와 위도를 사용하여 내장 &lt;code&gt;point&lt;/code&gt; 데이터 유형을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="4ce65fcae4e9e56b4f592c30ab1fe2e2c8644fa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;earthdistance&lt;/code&gt; module provides two different approaches to calculating great circle distances on the surface of the Earth. The one described first depends on the &lt;code&gt;cube&lt;/code&gt; module. The second one is based on the built-in &lt;code&gt;point&lt;/code&gt; data type, using longitude and latitude for the coordinates.</source>
          <target state="translated">&lt;code&gt;earthdistance&lt;/code&gt; 의 모듈은 지구 표면에 큰 원형의 거리를 계산하는 두 가지 방법을 제공합니다. 처음 설명하는 것은 &lt;code&gt;cube&lt;/code&gt; 모듈 에 따라 다릅니다 . 두 번째 는 좌표에 경도와 위도를 사용 하는 내장 &lt;code&gt;point&lt;/code&gt; 데이터 유형을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="06785e03ac7e4e9a6e816edf3f7c1c724a9e14ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; functions support the following textual formats:</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt; 및 &lt;code&gt;decode&lt;/code&gt; 기능은 다음과 같은 텍스트 형식을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="dc1e26adb33859e4bdd5e363f386c1126ad60f8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;escape&lt;/code&gt; format converts zero bytes and bytes with the high bit set into octal escape sequences (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;nnn&lt;/code&gt;), and it doubles backslashes. Other byte values are represented literally. The &lt;code&gt;decode&lt;/code&gt; function will raise an error if a backslash is not followed by either a second backslash or three octal digits; it accepts other byte values unchanged.</source>
          <target state="translated">&lt;code&gt;escape&lt;/code&gt; 형식 변환은 진수 이스케이프 시퀀스 (상위 비트에 설정된 바이트 바이트 제로 &lt;code&gt;\&lt;/code&gt; &lt;code&gt;nnn&lt;/code&gt; ), 그리고 백 슬래시 배로. 다른 바이트 값은 문자 그대로 표시됩니다. &lt;code&gt;decode&lt;/code&gt; 백 슬래시 제 슬래시 또는 세 자리수로 진수 따르지 않으면 기능에서 오류가 발생한다; 변경되지 않은 다른 바이트 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a7890123059537fdc57582740cd61da006402b74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expression&lt;/code&gt; argument of an &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; command is subject to variable interpolation and backquote expansion, just like any other backslash command argument. After that it is evaluated like the value of an on/off option variable. So a valid value is any unambiguous case-insensitive match for one of: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;. For example, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;tR&lt;/code&gt; will all be considered to be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\if&lt;/code&gt; 또는 &lt;code&gt;\elif&lt;/code&gt; 명령 의 &lt;code&gt;expression&lt;/code&gt; 인수는 다른 백 슬래시 명령 인수와 마찬가지로 변수 보간 및 역 따옴표 확장의 영향을받습니다. 그 후에는 설정 / 해제 옵션 변수의 값처럼 평가됩니다. 따라서 유효한 값은 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; , &lt;code&gt;no&lt;/code&gt; 중 하나에 대한 대소 문자를 구분하지 않는 일치입니다 . 예를 들어, &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;tR&lt;/code&gt; 은 모두 &lt;code&gt;true&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="7490327a2b864afa9b5748785adec8119b5d2704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function is primarily intended for computational processing. For formatting date/time values for display, see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; 기능은 주로 연산 처리를위한 것이다. 표시 할 날짜 / 시간 값의 형식 &lt;a href=&quot;functions-formatting&quot;&gt;은 9.8 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a9a9ab120adc12bc2db1bb30c3120ad00c0facd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function retrieves subfields such as year or hour from date/time values. &lt;code&gt;source&lt;/code&gt; must be a value expression of type &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, or &lt;code&gt;interval&lt;/code&gt;. (Expressions of type &lt;code&gt;date&lt;/code&gt; are cast to &lt;code&gt;timestamp&lt;/code&gt; and can therefore be used as well.) &lt;code&gt;field&lt;/code&gt; is an identifier or string that selects what field to extract from the source value. The &lt;code&gt;extract&lt;/code&gt; function returns values of type &lt;code&gt;double precision&lt;/code&gt;. The following are valid field names:</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; 등의 날짜 / 시간 값에서 년 또는 시간 등의 기능을 검색하여 서브 필드. &lt;code&gt;source&lt;/code&gt; 는 &lt;code&gt;timestamp&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; 또는 &lt;code&gt;interval&lt;/code&gt; 유형의 값 표현식이어야합니다 . &lt;code&gt;date&lt;/code&gt; 유형의 표현은 &lt;code&gt;timestamp&lt;/code&gt; 로 캐스트 되므로 사용할 수도 있습니다. &lt;code&gt;field&lt;/code&gt; 는 소스 값에서 추출 할 필드를 선택하는 식별자 또는 문자열입니다. &lt;code&gt;extract&lt;/code&gt; 기능은 유형의 값 반환 &lt;code&gt;double precision&lt;/code&gt; . 유효한 필드 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1a437c414eaca06c0d45719567f040e8a9a62f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_fdw&lt;/code&gt; module provides the foreign-data wrapper &lt;code&gt;file_fdw&lt;/code&gt;, which can be used to access data files in the server's file system, or to execute programs on the server and read their output. The data file or program output must be in a format that can be read by &lt;code&gt;COPY FROM&lt;/code&gt;; see &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; for details. Access to data files is currently read-only.</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; 의 모듈은 래퍼 외국 데이터 제공 &lt;code&gt;file_fdw&lt;/code&gt; 서버의 파일 시스템에 데이터 파일에 액세스하는 데 사용할 수 있습니다, 또는 서버에 프로그램을 실행하고 자신의 출력을 읽어. 데이터 파일 또는 프로그램 출력은 &lt;code&gt;COPY FROM&lt;/code&gt; 에서 읽을 수있는 형식이어야합니다 . 자세한 내용은 &lt;a href=&quot;sql-copy&quot;&gt;복사&lt;/a&gt; 를 참조하십시오. 데이터 파일에 대한 액세스는 현재 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="dc48dad184d44a7c4859e34f48c4985dbe248e9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame_clause&lt;/code&gt; specifies the set of rows constituting the &lt;em&gt;window frame&lt;/em&gt;, which is a subset of the current partition, for those window functions that act on the frame instead of the whole partition. The set of rows in the frame can vary depending on which row is the current row. The frame can be specified in &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode; in each case, it runs from the &lt;code&gt;frame_start&lt;/code&gt; to the &lt;code&gt;frame_end&lt;/code&gt;. If &lt;code&gt;frame_end&lt;/code&gt; is omitted, the end defaults to &lt;code&gt;CURRENT ROW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;frame_clause&lt;/code&gt; 는 구성하는 일련의 행을 지정 &lt;em&gt;창틀&lt;/em&gt; 해당 윈도우 함수의 경우, 현재의 파티션들의 서브 세트이며, 대신, 전체 파티션의 프레임에 작용하여. 프레임의 행 세트는 현재 행인 행에 따라 달라질 수 있습니다. 프레임은 &lt;code&gt;RANGE&lt;/code&gt; , &lt;code&gt;ROWS&lt;/code&gt; 또는 &lt;code&gt;GROUPS&lt;/code&gt; 모드 에서 지정할 수 있습니다 . 각각의 경우에 &lt;code&gt;frame_start&lt;/code&gt; 에서 &lt;code&gt;frame_end&lt;/code&gt; 까지 실행됩니다 . 경우 &lt;code&gt;frame_end&lt;/code&gt; 생략되고, 최종 기본적으로 &lt;code&gt;CURRENT ROW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71d31c525333bb24cffbf41e507f2b1076452ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame_exclusion&lt;/code&gt; option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. &lt;code&gt;EXCLUDE CURRENT ROW&lt;/code&gt; excludes the current row from the frame. &lt;code&gt;EXCLUDE GROUP&lt;/code&gt; excludes the current row and its ordering peers from the frame. &lt;code&gt;EXCLUDE TIES&lt;/code&gt; excludes any peers of the current row from the frame, but not the current row itself. &lt;code&gt;EXCLUDE NO OTHERS&lt;/code&gt; simply specifies explicitly the default behavior of not excluding the current row or its peers.</source>
          <target state="translated">&lt;code&gt;frame_exclusion&lt;/code&gt; 의 옵션은이 프레임 시작 및 프레임 끝 옵션에 따라 포함 할 경우에도, 현재 행 주위 행이 프레임에서 제외 할 수 있습니다. &lt;code&gt;EXCLUDE CURRENT ROW&lt;/code&gt; 는 프레임에서 현재 행을 제외합니다. &lt;code&gt;EXCLUDE GROUP&lt;/code&gt; 은 현재 행과 순서 피어를 프레임에서 제외합니다. &lt;code&gt;EXCLUDE TIES&lt;/code&gt; 는 현재 행의 모든 ​​피어를 프레임에서 제외하지만 현재 행 자체는 제외하지 않습니다. &lt;code&gt;EXCLUDE NO OTHERS&lt;/code&gt; 는 단순히 현재 행이나 해당 피어를 제외하지 않는 기본 동작을 명시 적으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="79c90a36b51a75ac7dbb48737a2d7af10a18b852" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;function_name&lt;/code&gt; function must have been previously defined using &lt;code&gt;CREATE FUNCTION&lt;/code&gt; and must be defined to accept the correct number of arguments (either one or two) of the indicated types.</source>
          <target state="translated">&lt;code&gt;function_name&lt;/code&gt; 기능은 이전에 사용하여 정의되어 있어야 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 하고 올바른 수의 인수 지정된 유형의 (하나 또는 두 개)을 허용하도록 정의되어야한다.</target>
        </trans-unit>
        <trans-unit id="9897a44892259c96709c3ce90278ea27b2732f53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fuzzystrmatch&lt;/code&gt; module provides several functions to determine similarities and distance between strings.</source>
          <target state="translated">&lt;code&gt;fuzzystrmatch&lt;/code&gt; 의 모듈은 문자열 사이의 유사점과 거리를 결정하는 여러 가지 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90731181621f8d5d3209f6554f81fdd98c3fb7ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fuzzystrmatch&lt;/code&gt; module provides two functions for working with Soundex codes:</source>
          <target state="translated">&lt;code&gt;fuzzystrmatch&lt;/code&gt; 의 모듈은 Soundex와 코드 작업을위한 두 가지 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="5f2de67e35fa833f15a2382f7411e578ceeb591f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;heap_tuple_infomask_flags&lt;/code&gt; function can be used to unpack the flag bits of &lt;code&gt;t_infomask&lt;/code&gt; and &lt;code&gt;t_infomask2&lt;/code&gt; for heap tuples.</source>
          <target state="translated">&lt;code&gt;heap_tuple_infomask_flags&lt;/code&gt; 의 함수의 플래그 비트 압축 해제하는데 사용될 수있다 &lt;code&gt;t_infomask&lt;/code&gt; 및 &lt;code&gt;t_infomask2&lt;/code&gt; 을 힙 튜플.</target>
        </trans-unit>
        <trans-unit id="e52e2996734358f7b940c41742059deb0d5af09d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hex&lt;/code&gt; format represents each 4 bits of data as one hexadecimal digit, &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;, writing the higher-order digit of each byte first. The &lt;code&gt;encode&lt;/code&gt; function outputs the &lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt; hex digits in lower case. Because the smallest unit of data is 8 bits, there are always an even number of characters returned by &lt;code&gt;encode&lt;/code&gt;. The &lt;code&gt;decode&lt;/code&gt; function accepts the &lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt; characters in either upper or lower case. An error is raised when &lt;code&gt;decode&lt;/code&gt; is given invalid hex data &amp;mdash; including when given an odd number of characters.</source>
          <target state="translated">&lt;code&gt;hex&lt;/code&gt; 포맷은 하나 진수 디지트로서 데이터의 각 4 개 비트를 나타내는 &lt;code&gt;0&lt;/code&gt; 내지 &lt;code&gt;f&lt;/code&gt; 먼저 각 바이트의 고차의 자릿수를 작성. &lt;code&gt;encode&lt;/code&gt; 기능은 출력 - &lt;code&gt;f&lt;/code&gt; 소문자 진수 숫자. 가장 작은 데이터 단위는 8 비트이므로 &lt;code&gt;encode&lt;/code&gt; 에서 반환하는 문자 수는 항상 짝수 입니다. &lt;code&gt;decode&lt;/code&gt; 기능은 수락 - &lt;code&gt;f&lt;/code&gt; 대문자 또는 소문자의 문자. &lt;code&gt;decode&lt;/code&gt; 에 유효하지 않은 16 진 데이터가 제공 되면 오류가 발생 합니다 (홀수 문자가 제공되는 경우 포함). &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a076afe3d48bfb5bc5090c4b36aa5c47d792bbb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hstore&lt;/code&gt; type, because of its intrinsic liberality, could contain a lot of different keys. Checking for valid keys is the task of the application. The following examples demonstrate several techniques for checking keys and obtaining statistics.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 유형은, 때문에 고유의 관대함의 다른 키를 많이 포함 할 수 있습니다. 유효한 키를 확인하는 것은 응용 프로그램의 작업입니다. 다음 예는 키를 확인하고 통계를 얻는 몇 가지 기술을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="aa50c73dc35b9d5466c5f124d66eb983ecec8b30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;idx_tup_read&lt;/code&gt; and &lt;code&gt;idx_tup_fetch&lt;/code&gt; counts can be different even without any use of bitmap scans, because &lt;code&gt;idx_tup_read&lt;/code&gt; counts index entries retrieved from the index while &lt;code&gt;idx_tup_fetch&lt;/code&gt; counts live rows fetched from the table. The latter will be less if any dead or not-yet-committed rows are fetched using the index, or if any heap fetches are avoided by means of an index-only scan.</source>
          <target state="translated">&lt;code&gt;idx_tup_read&lt;/code&gt; 의 값 과 &lt;code&gt;idx_tup_fetch&lt;/code&gt; 때문에 카운트, 심지어 비트 맵 스캔의 사용없이 다를 수 있습니다 &lt;code&gt;idx_tup_read&lt;/code&gt; 의 값 카운트 인덱스 항목이 인덱스 동안에서 검색 &lt;code&gt;idx_tup_fetch&lt;/code&gt; 의 카운트 라이브 행이 테이블에서 가져온. 인덱스를 사용하여 데드 또는 아직 커밋되지 않은 행을 페치하거나 인덱스 전용 스캔을 통해 힙 페치를 피하는 경우 후자는 더 적습니다.</target>
        </trans-unit>
        <trans-unit id="105555b766284240eda53764bbf412df3e426218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inet&lt;/code&gt; type holds an IPv4 or IPv6 host address, and optionally its subnet, all in one field. The subnet is represented by the number of network address bits present in the host address (the &amp;ldquo;netmask&amp;rdquo;). If the netmask is 32 and the address is IPv4, then the value does not indicate a subnet, only a single host. In IPv6, the address length is 128 bits, so 128 bits specify a unique host address. Note that if you want to accept only networks, you should use the &lt;code&gt;cidr&lt;/code&gt; type rather than &lt;code&gt;inet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 형태는 하나 개의 필드에 임의의 서브넷 모두는 IPv4 또는 IPv6 호스트 주소를 보유하고 있으며. 서브넷은 호스트 주소 (&amp;ldquo;넷 마스크&amp;rdquo;)에있는 네트워크 주소 비트 수로 표시됩니다. 넷 마스크가 32이고 주소가 IPv4 인 경우 값은 서브넷을 나타내지 않고 단일 호스트 만 나타냅니다. IPv6에서 주소 길이는 128 비트이므로 128 비트는 고유 한 호스트 주소를 지정합니다. 네트워크 만 허용하려면 &lt;code&gt;inet&lt;/code&gt; 대신 &lt;code&gt;cidr&lt;/code&gt; 유형을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1480b7e9f9737ecb46229fdd00be59d12607dc11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;initdb&lt;/code&gt; mode creates a new PostgreSQL database cluster, that is, a collection of databases that will be managed by a single server instance. This mode invokes the &lt;code&gt;initdb&lt;/code&gt; command. See &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;initdb&lt;/code&gt; 에 모드는 새로운 PostgreSQL 데이터베이스 클러스터, 단일 서버 인스턴스가 관리 할 데이터베이스의 컬렉션을 만듭니다. 이 모드는 &lt;code&gt;initdb&lt;/code&gt; 명령을 호출합니다 . &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecc5e8a2b17fca84bdc393620a0520a109ffd200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initdb-options&lt;/code&gt; should usually be surrounded by single or double quotes to ensure that they are passed through as a group.</source>
          <target state="translated">&lt;code&gt;initdb-options&lt;/code&gt; 보통 그룹으로 통과되는 것을 보장하기 위해 단일 또는 쌍 따옴표로 묶어야한다.</target>
        </trans-unit>
        <trans-unit id="16d1ccc7e1029a4cfe055973c1a279885ae0a68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input_function&lt;/code&gt; converts the type's external textual representation to the internal representation used by the operators and functions defined for the type. &lt;code&gt;output_function&lt;/code&gt; performs the reverse transformation. The input function can be declared as taking one argument of type &lt;code&gt;cstring&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;cstring&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is the input text as a C string, the second argument is the type's own OID (except for array types, which instead receive their element type's OID), and the third is the &lt;code&gt;typmod&lt;/code&gt; of the destination column, if known (-1 will be passed if not). The input function must return a value of the data type itself. Usually, an input function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain input functions, which might need to reject NULL inputs.) The output function must be declared as taking one argument of the new data type. The output function must return type &lt;code&gt;cstring&lt;/code&gt;. Output functions are not invoked for NULL values.</source>
          <target state="translated">&lt;code&gt;input_function&lt;/code&gt; 는 유형에 대해 정의 된 연산자와 함수가 사용하는 내부 표현 형식의 외부 텍스트 표현을 변환합니다. &lt;code&gt;output_function&lt;/code&gt; 은 역변환을 수행합니다. 입력 함수는 &lt;code&gt;cstring&lt;/code&gt; 유형의 인수 하나를 받거나 &lt;code&gt;cstring&lt;/code&gt; , &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; 유형의 인수를 세 개로 선언 할 수 있습니다 . 첫 번째 인수는 입력 문자열을 C 문자열로, 두 번째 인수는 유형의 자체 OID (배열 유형은 제외하고 대신 요소 유형의 OID를 수신함)이고 세 번째 인수는 &lt;code&gt;typmod&lt;/code&gt; 입니다.알려진 경우 대상 열의 이름입니다 (없는 경우 -1이 전달됨). 입력 함수는 데이터 유형 자체의 값을 리턴해야합니다. 일반적으로 입력 함수는 STRICT로 선언해야합니다. 그렇지 않은 경우 NULL 입력 값을 읽을 때 NULL 첫 번째 매개 변수와 함께 호출됩니다. 이 경우 오류가 발생하지 않는 한 함수는 여전히 NULL을 반환해야합니다. (이 경우는 주로 도메인 입력 함수를 지원하기위한 것으로 NULL 입력을 거부해야 할 수도 있습니다.) 출력 함수는 새 데이터 유형의 인수 하나를 취하는 것으로 선언해야합니다. 출력 함수는 &lt;code&gt;cstring&lt;/code&gt; 유형을 리턴해야합니다 . NULL 값에 대해서는 출력 함수가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dd3f06b986fa431b874d54dd865659b27cfc58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intagg&lt;/code&gt; module provides an integer aggregator and an enumerator. &lt;code&gt;intagg&lt;/code&gt; is now obsolete, because there are built-in functions that provide a superset of its capabilities. However, the module is still provided as a compatibility wrapper around the built-in functions.</source>
          <target state="translated">&lt;code&gt;intagg&lt;/code&gt; 의 모듈은 정수 애그리 게이터 (aggregator) 및 열거를 제공한다. 기능의 상위 세트를 제공하는 내장 함수가 있기 때문에 &lt;code&gt;intagg&lt;/code&gt; 는 이제 더 이상 사용되지 않습니다. 그러나이 모듈은 여전히 ​​내장 함수 주위의 호환성 래퍼로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e5f078a6fe0cf9ef6c6e521625243e1894589ca0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intarray&lt;/code&gt; module provides a number of useful functions and operators for manipulating null-free arrays of integers. There is also support for indexed searches using some of the operators.</source>
          <target state="translated">&lt;code&gt;intarray&lt;/code&gt; 모듈은 정수의 널 (null)이없는 배열을 조작하기위한 유용한 함수와 연산자를 제공합니다. 일부 연산자를 사용하여 인덱스 검색을 지원하기도합니다.</target>
        </trans-unit>
        <trans-unit id="5e20537f440b22c9608c2d38b191b83f09961384" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;internal&lt;/code&gt; pseudo-type is used to declare functions that are meant only to be called internally by the database system, and not by direct invocation in an SQL query. If a function has at least one &lt;code&gt;internal&lt;/code&gt;-type argument then it cannot be called from SQL. To preserve the type safety of this restriction it is important to follow this coding rule: do not create any function that is declared to return &lt;code&gt;internal&lt;/code&gt; unless it has at least one &lt;code&gt;internal&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 의사 유형은 SQL 쿼리에서 직접 호출하여 데이터베이스 시스템에 의해 내부적으로 호출 할 경우에만 의미 기능 및하지를 선언하는 데 사용됩니다. 함수에 하나 이상의 &lt;code&gt;internal&lt;/code&gt; 유형 인수 가 있으면 SQL에서 호출 할 수 없습니다. 이 제한의 형식 안전성을 유지하려면이 코딩 규칙을 따르는 것이 중요합니다 . &lt;code&gt;internal&lt;/code&gt; 인수가 하나 이상없는 경우 &lt;code&gt;internal&lt;/code&gt; 를 반환하도록 선언 된 함수를 만들지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="23ef30a7477168386c4be2c94609fc89528b3dee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interval&lt;/code&gt; type has an additional option, which is to restrict the set of stored fields by writing one of these phrases:</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; 유형은 다음 문구 중 하나를 작성하여 저장된 필드의 집합을 제한 할 수있는 추가 옵션을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a73e1543f8cd6ed8bbf8ea80c60bc4c27a544945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides data types for the following international product numbering standards: EAN13, UPC, ISBN (books), ISMN (music), and ISSN (serials). Numbers are validated on input according to a hard-coded list of prefixes; this list of prefixes is also used to hyphenate numbers on output. Since new prefixes are assigned from time to time, the list of prefixes may be out of date. It is hoped that a future version of this module will obtain the prefix list from one or more tables that can be easily updated by users as needed; however, at present, the list can only be updated by modifying the source code and recompiling. Alternatively, prefix validation and hyphenation support may be dropped from a future version of this module.</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; EAN13, UPC, ISBN (서적), ISMN (음악) 및 ISSN (시리얼) : 모듈은 다음과 같은 국제 제품 번호 표준 데이터 유형을 제공합니다. 숫자는 하드 코딩 된 접두사 목록에 따라 입력시 확인됩니다. 이 접두사 목록은 출력에서 ​​숫자를 하이픈으로 연결하는데도 사용됩니다. 새 접두사가 수시로 지정되기 때문에 접두사 목록이 오래되었을 수 있습니다. 이 모듈의 차기 버전은 필요에 따라 사용자가 쉽게 업데이트 할 수있는 하나 이상의 테이블에서 접두사 목록을 가져 오기를 바랍니다. 그러나 현재 목록은 소스 코드를 수정하고 다시 컴파일해야만 업데이트 할 수 있습니다. 또는 접두사 유효성 검사 및 하이픈 연결 지원이이 모듈의 향후 버전에서 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ae9c44664a456573cddd9031643c02edb22183c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides data types for the following international product numbering standards: EAN13, UPC, ISBN (books), ISMN (music), and ISSN (serials). Numbers are validated on input according to a hard-coded list of prefixes; this list of prefixes is also used to hyphenate numbers on output. Since new prefixes are assigned from time to time, the list of prefixes may be out of date. It is hoped that a future version of this module will obtained the prefix list from one or more tables that can be easily updated by users as needed; however, at present, the list can only be updated by modifying the source code and recompiling. Alternatively, prefix validation and hyphenation support may be dropped from a future version of this module.</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; EAN13, UPC, ISBN (서적), ISMN (음악) 및 ISSN (시리얼) : 모듈은 다음과 같은 국제 제품 번호 표준 데이터 유형을 제공합니다. 하드 코딩 된 접두사 목록에 따라 입력시 숫자의 유효성이 검사됩니다. 이 접두사 목록은 출력에서 ​​숫자에 하이픈을 넣는 데에도 사용됩니다. 새 접두사가 때때로 할당되기 때문에 접두사 목록이 오래되었을 수 있습니다. 이 모듈의 향후 버전은 필요에 따라 사용자가 쉽게 업데이트 할 수있는 하나 이상의 테이블에서 접두사 목록을 가져 오기를 희망합니다. 그러나 현재 소스 코드를 수정하고 다시 컴파일해야만 목록을 업데이트 할 수 있습니다. 또는이 모듈의 향후 버전에서 접두사 유효성 검사 및 하이픈 지원이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9815d1f84bba26cf75ea57db75cbb748c781beb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides the following pairs of type casts:</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; 모듈 형 캐스트의 다음 쌍을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="1f3d136969e19c7266e1a9a82b8a9977ef2ab272" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides the standard comparison operators, plus B-tree and hash indexing support for all these data types. In addition there are several specialized functions; shown in &lt;a href=&quot;isn#ISN-FUNCTIONS&quot;&gt;Table F.12&lt;/a&gt;. In this table, &lt;code&gt;isn&lt;/code&gt; means any one of the module's data types.</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; 모듈은 표준 비교 연산자를 제공, 플러스 B-트리 및 모든 데이터 유형에 대한 해시 색인을 지원합니다. 또한 몇 가지 특수 기능이 있습니다. &lt;a href=&quot;isn#ISN-FUNCTIONS&quot;&gt;표 F.12&lt;/a&gt; 에 나와있다 . 이 표에서, &lt;code&gt;isn&lt;/code&gt; 모듈의 데이터 형식의 수단 중 어느 하나.</target>
        </trans-unit>
        <trans-unit id="ea0300aa881bba7f19acdd017cb9ddd3ccdf7dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; data types accept &lt;em&gt;almost&lt;/em&gt; identical sets of values as input. The major practical difference is one of efficiency. The &lt;code&gt;json&lt;/code&gt; data type stores an exact copy of the input text, which processing functions must reparse on each execution; while &lt;code&gt;jsonb&lt;/code&gt; data is stored in a decomposed binary format that makes it slightly slower to input due to added conversion overhead, but significantly faster to process, since no reparsing is needed. &lt;code&gt;jsonb&lt;/code&gt; also supports indexing, which can be a significant advantage.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;jsonb&lt;/code&gt; 데이터 타입을 수락 &lt;em&gt;거의&lt;/em&gt; 입력으로서 동일한 값을 설정. 주요한 실질적인 차이점은 효율성 중 하나입니다. &lt;code&gt;json&lt;/code&gt; 데이터 유형을 저장 처리 기능을 각각 실행한다 재분석에 입력 된 텍스트의 정확한 사본; 반면 &lt;code&gt;jsonb&lt;/code&gt; 데이터는 어떠한 파싱이 필요하지 않기 때문에, 오버 헤드로 인해 추가 전환 약간 느린 입력을 만들지 만, 훨씬 빠르게 분해 공정에 이진 포맷으로 저장된다. &lt;code&gt;jsonb&lt;/code&gt; 는 인덱싱도 지원하므로 상당한 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18a0defa6788cb12c053fbf70d6cdb3c5a6ee90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json_typeof&lt;/code&gt; function's &lt;code&gt;null&lt;/code&gt; return value should not be confused with a SQL NULL. While calling &lt;code&gt;json_typeof('null'::json)&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;, calling &lt;code&gt;json_typeof(NULL::json)&lt;/code&gt; will return a SQL NULL.</source>
          <target state="translated">&lt;code&gt;json_typeof&lt;/code&gt; 의 함수의 &lt;code&gt;null&lt;/code&gt; 반환 값이 SQL NULL의와 혼동해서는 안됩니다. 호출하는 동안 &lt;code&gt;json_typeof('null'::json)&lt;/code&gt; 반환 &lt;code&gt;null&lt;/code&gt; 호출 &lt;code&gt;json_typeof(NULL::json)&lt;/code&gt; 하여 SQL NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="168cc05ce6845d58616f3f7646b54fd243f5124d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonb_path_exists&lt;/code&gt;, &lt;code&gt;jsonb_path_match&lt;/code&gt;, &lt;code&gt;jsonb_path_query&lt;/code&gt;, &lt;code&gt;jsonb_path_query_array&lt;/code&gt;, and &lt;code&gt;jsonb_path_query_first&lt;/code&gt; functions have optional &lt;code&gt;vars&lt;/code&gt; and &lt;code&gt;silent&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;jsonb_path_exists&lt;/code&gt; , &lt;code&gt;jsonb_path_match&lt;/code&gt; , &lt;code&gt;jsonb_path_query&lt;/code&gt; , &lt;code&gt;jsonb_path_query_array&lt;/code&gt; 및 &lt;code&gt;jsonb_path_query_first&lt;/code&gt; 기능은 선택이 &lt;code&gt;vars&lt;/code&gt; 와 &lt;code&gt;silent&lt;/code&gt; 인수를.</target>
        </trans-unit>
        <trans-unit id="d8bb5936d2f03a1533134defe5051fab74fe1485" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonpath&lt;/code&gt; operators &lt;code&gt;@?&lt;/code&gt; and &lt;code&gt;@@&lt;/code&gt; suppress the following errors: missing object field or array element, unexpected JSON item type, datetime and numeric errors. The &lt;code&gt;jsonpath&lt;/code&gt;-related functions described below can also be told to suppress these types of errors. This behavior might be helpful when searching JSON document collections of varying structure.</source>
          <target state="translated">&lt;code&gt;jsonpath&lt;/code&gt; 의 사업자 &lt;code&gt;@?&lt;/code&gt; 및 &lt;code&gt;@@&lt;/code&gt; 누락 오브젝트 필드 또는 어레이 소자 예기치 JSON 항목 유형, 날짜 및 숫자 에러 다음 에러를 억제. 아래에 설명 된 &lt;code&gt;jsonpath&lt;/code&gt; 관련 함수는 이러한 유형의 오류를 억제하도록 지시 할 수도 있습니다. 이 동작은 다양한 구조의 JSON 문서 컬렉션을 검색 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="772704f4d66d5faa09292e5f927a415dbd1364fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonpath&lt;/code&gt; type implements support for the SQL/JSON path language in PostgreSQL to efficiently query JSON data. It provides a binary representation of the parsed SQL/JSON path expression that specifies the items to be retrieved by the path engine from the JSON data for further processing with the SQL/JSON query functions.</source>
          <target state="translated">&lt;code&gt;jsonpath&lt;/code&gt; 의 유형 구현을 효율적으로 쿼리 JSON 데이터에 PostgreSQL을에 SQL / JSON 경로 언어에 대한 지원합니다. SQL / JSON 쿼리 함수로 추가 처리 할 수 ​​있도록 JSON 데이터에서 경로 엔진이 검색 할 항목을 지정하는 구문 분석 된 SQL / JSON 경로 표현식의 2 진 표현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2149f5c0dd4945e41bb0756947056ef98b639170" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;like_type&lt;/code&gt; parameter provides an alternative method for specifying the basic representation properties of a data type: copy them from some existing type. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from the named type. (It is possible, though usually undesirable, to override some of these values by specifying them along with the &lt;code&gt;LIKE&lt;/code&gt; clause.) Specifying representation this way is especially useful when the low-level implementation of the new type &amp;ldquo;piggybacks&amp;rdquo; on an existing type in some fashion.</source>
          <target state="translated">&lt;code&gt;like_type&lt;/code&gt; 의 파라미터는 데이터 유형의 기본 표현 속성을 지정하기위한 다른 방법을 제공한다 : 기존의 일부 유형에서 복사. &lt;code&gt;internallength&lt;/code&gt; , &lt;code&gt;passedbyvalue&lt;/code&gt; , &lt;code&gt;alignment&lt;/code&gt; 및 &lt;code&gt;storage&lt;/code&gt; 의 값은 명명 된 유형에서 복사됩니다. (일반적으로 바람직하지는 않지만 &lt;code&gt;LIKE&lt;/code&gt; 절 과 함께 이들 값을 지정하여 이러한 값 중 일부를 대체 할 수 있습니다 .)이 방법으로 표현을 지정하면 기존 유형에서 새 유형 &quot;피기 백&quot;의 저수준 구현이 특히 유용합니다. 어떤 패션.</target>
        </trans-unit>
        <trans-unit id="9d22eb5dee38146c30421a70885a4db31297786e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; module allows fixing this by attaching a trigger to tables that contain LO reference columns. The trigger essentially just does a &lt;code&gt;lo_unlink&lt;/code&gt; whenever you delete or modify a value referencing a large object. When you use this trigger, you are assuming that there is only one database reference to any large object that is referenced in a trigger-controlled column!</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; 모듈 LO 기준 열을 포함하는 테이블에 트리거를 부착하여 고정 할 수 있습니다. 트리거는 기본적 으로 큰 객체를 참조하는 값을 삭제하거나 수정할 때마다 &lt;code&gt;lo_unlink&lt;/code&gt; 를 수행 합니다. 이 트리거를 사용하면 트리거 제어 컬럼에서 참조되는 대형 오브젝트에 대한 데이터베이스 참조가 하나만 있다고 가정합니다!</target>
        </trans-unit>
        <trans-unit id="41e1b86fc89c1b3ca96870ada2d42cd830ee60fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; module provides support for managing Large Objects (also called LOs or BLOBs). This includes a data type &lt;code&gt;lo&lt;/code&gt; and a trigger &lt;code&gt;lo_manage&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; 모듈 (또한 LO를 나에 BLOB라고도 함) 대형 오브젝트 관리를위한 지원을 제공합니다. 여기에는 데이터 유형 &lt;code&gt;lo&lt;/code&gt; 및 트리거 &lt;code&gt;lo_manage&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="9b1213fb426cb2334040aa09e1426c55587c855d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower-bound&lt;/code&gt; may be either a string that is valid input for the subtype, or empty to indicate no lower bound. Likewise, &lt;code&gt;upper-bound&lt;/code&gt; may be either a string that is valid input for the subtype, or empty to indicate no upper bound.</source>
          <target state="translated">&lt;code&gt;lower-bound&lt;/code&gt; 하위 유형에 대한 유효한 입력입니다 중 문자열, 또는 더 하한 나타 내기 위해 비울 수 있습니다. 마찬가지로 &lt;code&gt;upper-bound&lt;/code&gt; 은 부속 유형에 유효한 입력 문자열이거나 상한이 없음을 표시하기 위해 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a4962a0009307ba6431284c97bb49876d7ddc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt; functions return null if the range is empty or the requested bound is infinite. The &lt;code&gt;lower_inc&lt;/code&gt;, &lt;code&gt;upper_inc&lt;/code&gt;, &lt;code&gt;lower_inf&lt;/code&gt;, and &lt;code&gt;upper_inf&lt;/code&gt; functions all return false for an empty range.</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; 및 &lt;code&gt;upper&lt;/code&gt; 범위는 비어 있거나 결합 요청이 무한인지 기능 NULL을 반환. &lt;code&gt;lower_inc&lt;/code&gt; , &lt;code&gt;upper_inc&lt;/code&gt; , &lt;code&gt;lower_inf&lt;/code&gt; 및 &lt;code&gt;upper_inf&lt;/code&gt; 빈 범위의 기능을 모두 반환 거짓.</target>
        </trans-unit>
        <trans-unit id="4c2262ab90d9e2b626f4f4bf1ee1e56f90448be3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower_inc&lt;/code&gt;, &lt;code&gt;upper_inc&lt;/code&gt;, &lt;code&gt;lower_inf&lt;/code&gt;, and &lt;code&gt;upper_inf&lt;/code&gt; functions all return false for an empty range.</source>
          <target state="translated">&lt;code&gt;lower_inc&lt;/code&gt; , &lt;code&gt;upper_inc&lt;/code&gt; , &lt;code&gt;lower_inf&lt;/code&gt; 및 &lt;code&gt;upper_inf&lt;/code&gt; 빈 범위의 기능을 모두 반환 거짓.</target>
        </trans-unit>
        <trans-unit id="7854ce56999a9ecbf4528c8d9ad238714a056945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ltree&lt;/code&gt; module provides several data types:</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 의 모듈은 여러 가지 데이터 유형을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="4f5d05ac37c953266fc286bdc00b9352cf6192f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr8&lt;/code&gt; type also supports the standard relational operators (&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.) for ordering, and the bitwise arithmetic operators (&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) for NOT, AND and OR.</source>
          <target state="translated">&lt;code&gt;macaddr8&lt;/code&gt; 의 유형은 표준 관계 연산자 (지원 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , 등) 주문을 위해, 그리고 비트 산술 연산자 ( &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; AND 및 OR, NOT를 들어).</target>
        </trans-unit>
        <trans-unit id="ee970738f8a83aad38467525f7f37d7c159f8d4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr8&lt;/code&gt; type stores MAC addresses in EUI-64 format, known for example from Ethernet card hardware addresses (although MAC addresses are used for other purposes as well). This type can accept both 6 and 8 byte length MAC addresses and stores them in 8 byte length format. MAC addresses given in 6 byte format will be stored in 8 byte length format with the 4th and 5th bytes set to FF and FE, respectively. Note that IPv6 uses a modified EUI-64 format where the 7th bit should be set to one after the conversion from EUI-48. The function &lt;code&gt;macaddr8_set7bit&lt;/code&gt; is provided to make this change. Generally speaking, any input which is comprised of pairs of hex digits (on byte boundaries), optionally separated consistently by one of &lt;code&gt;':'&lt;/code&gt;, &lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'.'&lt;/code&gt;, is accepted. The number of hex digits must be either 16 (8 bytes) or 12 (6 bytes). Leading and trailing whitespace is ignored. The following are examples of input formats that are accepted:</source>
          <target state="translated">&lt;code&gt;macaddr8&lt;/code&gt; 의 이더넷 카드 하드웨어 주소에서 예컨대 EUI-64 공지 된 형식으로 저장 타입 MAC 주소 (MAC 주소가 아니라 다른 목적을 위해 사용 되기는하지만). 이 유형은 6 및 8 바이트 길이의 MAC 주소를 모두 수용하여 8 바이트 길이 형식으로 저장할 수 있습니다. 6 바이트 형식으로 제공된 MAC 주소는 각각 4 번째 및 5 번째 바이트가 FF 및 FE로 설정된 8 바이트 길이 형식으로 저장됩니다. IPv6은 수정 된 EUI-64 형식을 사용하며 EUI-48에서 변환 한 후 7 번째 비트를 1로 설정해야합니다. &lt;code&gt;macaddr8_set7bit&lt;/code&gt; 기능 이이 변경을 위해 제공됩니다. 일반적으로 말하자면 16 진 숫자 쌍 (바이트 경계)으로 구성되며 선택적으로 &lt;code&gt;':'&lt;/code&gt; , &lt;code&gt;'-'&lt;/code&gt; 또는 &lt;code&gt;'.'&lt;/code&gt; 허용됩니다. 16 진 숫자의 수는 16 (8 바이트) 또는 12 (6 바이트) 여야합니다. 선행 및 후행 공백은 무시됩니다. 다음은 허용되는 입력 형식의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c3d79930eaf5f7ce13b46f6856c277aea9ede8da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr&lt;/code&gt; type also supports the standard relational operators (&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.) for lexicographical ordering, and the bitwise arithmetic operators (&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) for NOT, AND and OR.</source>
          <target state="translated">&lt;code&gt;macaddr&lt;/code&gt; 유형은 표준 관계 연산자 (지원 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 사전 편찬 순서에 대한, 등), 그리고 비트 산술 연산자 ( &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; )하지 않는, AND 및 OR.</target>
        </trans-unit>
        <trans-unit id="6ebc662e3381183673c8582b7b95fb9aee6ddcc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr&lt;/code&gt; type stores MAC addresses, known for example from Ethernet card hardware addresses (although MAC addresses are used for other purposes as well). Input is accepted in the following formats:</source>
          <target state="translated">&lt;code&gt;macaddr&lt;/code&gt; 이더넷 카드 하드웨어 주소의 예를 들어 공지 된 유형의 저장 MAC 주소 (MAC 주소가 아니라 다른 목적을 위해 사용 되기는하지만). 입력은 다음 형식으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="abb88e6f4baf5008ffda8309a1c86c82f34be1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxlen&lt;/code&gt; parameter specifies the maximum number of digits allowed in an integer word. The default value is 6.</source>
          <target state="translated">&lt;code&gt;maxlen&lt;/code&gt; 파라미터는 정수 워드의 최대 자리수를 지정한다. 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="c0858eea09f10a0e5d0453c7f76531a7abbd443b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;md5&lt;/code&gt; method cannot be used with the &lt;a href=&quot;runtime-config-connection#GUC-DB-USER-NAMESPACE&quot;&gt;db_user_namespace&lt;/a&gt; feature.</source>
          <target state="translated">&lt;code&gt;md5&lt;/code&gt; 방법은 사용할 수 없습니다 &lt;a href=&quot;runtime-config-connection#GUC-DB-USER-NAMESPACE&quot;&gt;db_user_namespace의&lt;/a&gt; 기능입니다.</target>
        </trans-unit>
        <trans-unit id="b398ca59b1e24ecdf79b1f3151e58ecf006b28e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min()&lt;/code&gt; and &lt;code&gt;avg()&lt;/code&gt; aggregates are computed concurrently over all the input rows, so if any row has &lt;code&gt;employees&lt;/code&gt; equal to zero, the division-by-zero error will occur before there is any opportunity to test the result of &lt;code&gt;min()&lt;/code&gt;. Instead, use a &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;FILTER&lt;/code&gt; clause to prevent problematic input rows from reaching an aggregate function in the first place.</source>
          <target state="translated">&lt;code&gt;min()&lt;/code&gt; 와 &lt;code&gt;avg()&lt;/code&gt; 응집체는 임의의 행이 보유 그렇다면, 모든 입력 행 위에 동시에 계산 &lt;code&gt;employees&lt;/code&gt; 의 결과를 테스트하기 위해 모든 기회가 전에 0으로 나누기 오류가 발생 제로인 &lt;code&gt;min()&lt;/code&gt; . 대신 &lt;code&gt;WHERE&lt;/code&gt; 또는 &lt;code&gt;FILTER&lt;/code&gt; 절을 사용하여 문제가있는 입력 행이 처음에 집계 함수에 도달하지 못하게하십시오.</target>
        </trans-unit>
        <trans-unit id="6fa5889a0b42548324335d58d566964f3bd48031" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;money&lt;/code&gt; type stores a currency amount with a fixed fractional precision; see &lt;a href=&quot;datatype-money#DATATYPE-MONEY-TABLE&quot;&gt;Table 8.3&lt;/a&gt;. The fractional precision is determined by the database's &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; setting. The range shown in the table assumes there are two fractional digits. Input is accepted in a variety of formats, including integer and floating-point literals, as well as typical currency formatting, such as &lt;code&gt;'$1,000.00'&lt;/code&gt;. Output is generally in the latter form but depends on the locale.</source>
          <target state="translated">&lt;code&gt;money&lt;/code&gt; 유형은 고정 소수점 정밀도로 통화 금액을 저장; &lt;a href=&quot;datatype-money#DATATYPE-MONEY-TABLE&quot;&gt;표 8.3을&lt;/a&gt; 참조하십시오 . 분수 정밀도는 데이터베이스의 &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; 설정에 의해 결정됩니다 . 표에 표시된 범위는 두 개의 소수 자릿수가 있다고 가정합니다. 입력은 정수 및 부동 소수점 리터럴뿐만 아니라 &lt;code&gt;'$1,000.00'&lt;/code&gt; 과 같은 일반적인 통화 형식을 포함하여 다양한 형식으로 허용됩니다 . 출력은 일반적으로 후자의 형식이지만 로캘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="591d71ee5e714d1d5bb09ebf8473fd24333cc869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid&lt;/code&gt; type is currently implemented as an unsigned four-byte integer. Therefore, it is not large enough to provide database-wide uniqueness in large databases, or even in large individual tables.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 유형은 현재 부호없는 4 바이트 정수로 구현됩니다. 따라서 큰 데이터베이스 또는 큰 개별 테이블에서 데이터베이스 전체에 고유성을 제공 할만큼 크지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78dc4927f04eeaf9a8229a0fc622fc80f07cd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid&lt;/code&gt; type itself has few operations beyond comparison. It can be cast to integer, however, and then manipulated using the standard integer operators. (Beware of possible signed-versus-unsigned confusion if you do this.)</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 유형 자체는 비교를 제외하고는 몇가지 연산을. 그러나 정수로 캐스트 한 다음 표준 정수 연산자를 사용하여 조작 할 수 있습니다. 이렇게하면 부호있는 대 부호없는 혼동에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="8b3f043e5a35248587843b04ae8abd46f9b04293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opcintype&lt;/code&gt; argument is the &lt;code&gt;pg_type.oid&lt;/code&gt; of the data type that the operator class indexes. This is a convenience that allows reuse of the same underlying &lt;code&gt;equalimage&lt;/code&gt; function across operator classes. If &lt;code&gt;opcintype&lt;/code&gt; is a collatable data type, the appropriate collation OID will be passed to the &lt;code&gt;equalimage&lt;/code&gt; function, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">&lt;code&gt;opcintype&lt;/code&gt; 의 인수는이다 &lt;code&gt;pg_type.oid&lt;/code&gt; 연산자 클래스 인덱스가 데이터 유형의. 이것은 연산자 클래스 에서 동일한 기본 &lt;code&gt;equalimage&lt;/code&gt; 함수를 재사용 할 수있는 편리함입니다 . 경우 &lt;code&gt;opcintype&lt;/code&gt; 가 collatable 데이터 타입, 적절한 정렬 OID가 전달 될 &lt;code&gt;equalimage&lt;/code&gt; 의 표준 사용 기능 &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; 메커니즘.</target>
        </trans-unit>
        <trans-unit id="90126f847a19f26e444b96e74dbf5fc70037caf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open_&lt;/code&gt;* options also use &lt;code&gt;O_DIRECT&lt;/code&gt; if available. Not all of these choices are available on all platforms. The default is the first method in the above list that is supported by the platform, except that &lt;code&gt;fdatasync&lt;/code&gt; is the default on Linux. The default is not necessarily ideal; it might be necessary to change this setting or other aspects of your system configuration in order to create a crash-safe configuration or achieve optimal performance. These aspects are discussed in &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;open_&lt;/code&gt; 는 * 옵션도 사용 &lt;code&gt;O_DIRECT&lt;/code&gt; 를 사용할 수있는 경우. 모든 플랫폼에서 이러한 선택을 모두 사용할 수있는 것은 아닙니다. 기본값은 위의 목록에서 플랫폼이 지원하는 첫 번째 방법입니다 ( Linux에서 &lt;code&gt;fdatasync&lt;/code&gt; 가 기본값 임 ). 기본값이 반드시 이상적인 것은 아닙니다. 충돌 방지 구성을 만들거나 최적의 성능을 얻으려면이 설정 또는 시스템 구성의 다른 측면을 변경해야 할 수도 있습니다. 이러한 측면은 &lt;a href=&quot;wal-reliability&quot;&gt;29.1 절&lt;/a&gt; 에서 논의됩니다 . 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16a36edbea2e846254ac5ddec5ac6c48d1565749" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; function is passed a pointer to a &lt;code&gt;local_relopts&lt;/code&gt; struct, which needs to be filled with a set of operator class specific options. The options can be accessed from other support functions using the &lt;code&gt;PG_HAS_OPCLASS_OPTIONS()&lt;/code&gt; and &lt;code&gt;PG_GET_OPCLASS_OPTIONS()&lt;/code&gt; macros.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 함수에 대한 포인터를 전달 &lt;code&gt;local_relopts&lt;/code&gt; 의 연산자 클래스 특정 옵션들의 세트로 채워질 필요 구조체. 옵션은 &lt;code&gt;PG_HAS_OPCLASS_OPTIONS()&lt;/code&gt; 및 &lt;code&gt;PG_GET_OPCLASS_OPTIONS()&lt;/code&gt; 매크로를 사용하여 다른 지원 함수에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1deebe3b08e139dca519f072e65bc0913b196cc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; should usually be surrounded by single or double quotes to ensure that they are passed through as a group.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 보통 그룹으로 통과되는 것을 보장하기 위해 단일 또는 쌍 따옴표로 묶어야한다.</target>
        </trans-unit>
        <trans-unit id="e287f99758c3cdb10c1fc61789ee15a8d908a550" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pageinspect&lt;/code&gt; module provides functions that allow you to inspect the contents of database pages at a low level, which is useful for debugging purposes. All of these functions may be used only by superusers.</source>
          <target state="translated">&lt;code&gt;pageinspect&lt;/code&gt; 의 모듈은 디버깅 목적에 유용 낮은 수준에서 데이터베이스 페이지의 내용을 검사 할 수있는 기능을 제공합니다. 이러한 모든 기능은 수퍼 유저 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="530a467c47cea19dd0c00ec1dbc483debfa27dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;partition_bound_spec&lt;/code&gt; must correspond to the partitioning method and partition key of the parent table, and must not overlap with any existing partition of that parent. The form with &lt;code&gt;IN&lt;/code&gt; is used for list partitioning, the form with &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;TO&lt;/code&gt; is used for range partitioning, and the form with &lt;code&gt;WITH&lt;/code&gt; is used for hash partitioning.</source>
          <target state="translated">&lt;code&gt;partition_bound_spec&lt;/code&gt; 은 상위 테이블의 분할 방법 및 분할 키에 대응하고, 중첩해야하지 그 부모 기존 파티션한다. 와 형상 &lt;code&gt;IN&lt;/code&gt; 은 함께리스트 파티셔닝 폼을 사용 &lt;code&gt;FROM&lt;/code&gt; 및 &lt;code&gt;TO&lt;/code&gt; 범위 분할 사용되어,와 형태 &lt;code&gt;WITH&lt;/code&gt; 은 해시 분할을 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="321cdf6012708ec28d857a16216ddd141b4795b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passwordcheck&lt;/code&gt; module checks users' passwords whenever they are set with &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. If a password is considered too weak, it will be rejected and the command will terminate with an error.</source>
          <target state="translated">&lt;code&gt;passwordcheck&lt;/code&gt; 의 그들이 설정 될 때마다 모듈 검사 사용자의 암호 &lt;a href=&quot;sql-createrole&quot;&gt;역할 CREATE&lt;/a&gt; 또는 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER 역할&lt;/a&gt; . 암호가 너무 약한 것으로 간주되면 암호가 거부되고 오류와 함께 명령이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="86ab56758cab8beb34df6aa406664611103452cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;penalty&lt;/code&gt; function is crucial to good performance of the index. It'll get used at insertion time to determine which branch to follow when choosing where to add the new entry in the tree. At query time, the more balanced the index, the quicker the lookup.</source>
          <target state="translated">&lt;code&gt;penalty&lt;/code&gt; 기능은 인덱스의 좋은 성능에 매우 중요하다. 삽입 시점에 트리에서 새 항목을 추가 할 위치를 선택할 때 따라야 할 분기를 결정하는 데 사용됩니다. 쿼리시 인덱스의 균형이 좋을수록 조회 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="eca57d9a0482509128492e1b7deb298ac5bcf1be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extension_versions&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_available_extension_versions&lt;/code&gt; 의 뷰는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="e30cddb8256b97d7a85be6f99c4ef44cdaa252a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extension_versions&lt;/code&gt; view lists the specific extension versions that are available for installation. See also the &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt; catalog, which shows the extensions currently installed.</source>
          <target state="translated">&lt;code&gt;pg_available_extension_versions&lt;/code&gt; 은 나열 설치에 사용할 수있는 특정 확장 버전을 볼 수 있습니다. 현재 설치된 확장을 보여주는 &lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt; 카탈로그 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e7d98e76ccc0a3eea34c953f9960047fdf4d011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extensions&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_available_extensions&lt;/code&gt; 의 뷰는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="5019d9408165c6f3daf9b540d710ea624fb4f2a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extensions&lt;/code&gt; view lists the extensions that are available for installation. See also the &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt; catalog, which shows the extensions currently installed.</source>
          <target state="translated">&lt;code&gt;pg_available_extensions&lt;/code&gt; 은 나열 설치에 사용할 수있는 확장 기능을 볼 수 있습니다. 현재 설치된 확장을 보여주는 &lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt; 카탈로그 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23147896a0bb8cdf56e9c2215878569d76558769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_buffercache&lt;/code&gt; module provides a means for examining what's happening in the shared buffer cache in real time.</source>
          <target state="translated">&lt;code&gt;pg_buffercache&lt;/code&gt; 의 모듈은 실시간으로 공유 버퍼 캐시에 무슨 일이 일어나고 있는지 검사하는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33f64b3a0516da571bdaabc8707c7cfc6382a6fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_constraint&lt;/code&gt; entry associated with the trigger, if any</source>
          <target state="translated">&lt;code&gt;pg_constraint&lt;/code&gt; 의 트리거와 관련된 항목 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="0a3b068150ce34aa7d8adbd51da299ff6a0e91b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view displays cursors created by any of these means. Cursors only exist for the duration of the transaction that defines them, unless they have been declared &lt;code&gt;WITH HOLD&lt;/code&gt;. Therefore non-holdable cursors are only present in the view until the end of their creating transaction.</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; 는 이러한 방법 중 하나에 의해 생성 된 디스플레이 커서를 볼. &lt;code&gt;WITH HOLD&lt;/code&gt; 로 선언되지 않은 경우 커서는 해당 트랜잭션을 정의하는 트랜잭션 기간 동안 만 존재합니다 . 따라서 보류 불가능한 커서는 트랜잭션 작성이 끝날 때까지만보기에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="769140bc4ff0be33d8261a2c2495473c9aa06419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; 의 뷰는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="943080f1bca8bfb0a861af0a7366bc0f87ecea56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view lists the cursors that are currently available. Cursors can be defined in several ways:</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; 는 목록을 현재 사용할 수있는 커서를 볼 수 있습니다. 커서는 여러 가지 방법으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f9e99ef77cc93d164810339140c3e9aee6dc96a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_enum&lt;/code&gt; catalog contains entries showing the values and labels for each enum type. The internal representation of a given enum value is actually the OID of its associated row in &lt;code&gt;pg_enum&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_enum&lt;/code&gt; 의 카탈로그는 각 열거 형의 값 및 레이블을 보여주는 항목이 포함되어 있습니다. 주어진 열거 형 값의 내부 표현은 실제로 &lt;code&gt;pg_enum&lt;/code&gt; 에서 연관된 행의 OID입니다 .</target>
        </trans-unit>
        <trans-unit id="85db4109eb0a5caec74c9817c0a2aae5033501c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_freespacemap&lt;/code&gt; module provides a means for examining the free space map (FSM). It provides a function called &lt;code&gt;pg_freespace&lt;/code&gt;, or two overloaded functions, to be precise. The functions show the value recorded in the free space map for a given page, or for all pages in the relation.</source>
          <target state="translated">&lt;code&gt;pg_freespacemap&lt;/code&gt; 의 모듈은 여유 공간 맵 (FSM)을 검사하는 수단을 제공합니다. &lt;code&gt;pg_freespace&lt;/code&gt; 라는 함수 또는 두 개의 오버로드 된 함수를 정확하게 제공합니다. 함수는 주어진 페이지 또는 관계의 모든 페이지에 대한 여유 공간 맵에 기록 된 값을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d26269fc6d836fb10263bde9dc1a6bf13ade8034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_hba.conf&lt;/code&gt; file is read on start-up and when the main server process receives a SIGHUP signal. If you edit the file on an active system, you will need to signal the postmaster (using &lt;code&gt;pg_ctl reload&lt;/code&gt;, calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, or using &lt;code&gt;kill -HUP&lt;/code&gt;) to make it re-read the file.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 파일은 기동시와 메인 서버 프로세스가 SIGHUP 신호를 수신에서 판독된다. 활성 시스템에서 파일을 편집하는 경우 파일을 &lt;code&gt;pg_ctl reload&lt;/code&gt; &lt;code&gt;pg_reload_conf()&lt;/code&gt; 도록 포스트 마스터에게 신호를 보내야합니다 ( pg_ctl reload 사용 , SQL 함수 pg_reload_conf () 호출 또는 &lt;code&gt;kill -HUP&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="04191b45aa50aed85c91e48e8294ab1b8975519d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ident.conf&lt;/code&gt; file is read on start-up and when the main server process receives a SIGHUP signal. If you edit the file on an active system, you will need to signal the postmaster (using &lt;code&gt;pg_ctl reload&lt;/code&gt;, calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, or using &lt;code&gt;kill -HUP&lt;/code&gt;) to make it re-read the file.</source>
          <target state="translated">&lt;code&gt;pg_ident.conf&lt;/code&gt; 의 파일은 기동시와 메인 서버 프로세스가 SIGHUP 신호를 수신에서 판독된다. 활성 시스템에서 파일을 편집하는 경우 파일을 &lt;code&gt;pg_ctl reload&lt;/code&gt; &lt;code&gt;pg_reload_conf()&lt;/code&gt; 도록 포스트 마스터에게 신호를 보내야합니다 ( pg_ctl reload 사용 , SQL 함수 pg_reload_conf () 호출 또는 &lt;code&gt;kill -HUP&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="27acedebfd1c20546e890a5790d75026d8a69e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_locks&lt;/code&gt; view displays data from both the regular lock manager and the predicate lock manager, which are separate systems; in addition, the regular lock manager subdivides its locks into regular and &lt;em&gt;fast-path&lt;/em&gt; locks. This data is not guaranteed to be entirely consistent. When the view is queried, data on fast-path locks (with &lt;code&gt;fastpath&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;) is gathered from each backend one at a time, without freezing the state of the entire lock manager, so it is possible for locks to be taken or released while information is gathered. Note, however, that these locks are known not to conflict with any other lock currently in place. After all backends have been queried for fast-path locks, the remainder of the regular lock manager is locked as a unit, and a consistent snapshot of all remaining locks is collected as an atomic action. After unlocking the regular lock manager, the predicate lock manager is similarly locked and all predicate locks are collected as an atomic action. Thus, with the exception of fast-path locks, each lock manager will deliver a consistent set of results, but as we do not lock both lock managers simultaneously, it is possible for locks to be taken or released after we interrogate the regular lock manager and before we interrogate the predicate lock manager.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; 는 일반 잠금 관리자와 별도의 시스템이다 술어 잠금 관리자 모두에서 데이터를 표시를 볼 수; 또한 일반 잠금 관리자는 잠금을 일반 및 &lt;em&gt;빠른 경로&lt;/em&gt; 잠금 으로 세분화합니다 . 이 데이터는 완전히 일관성이 보장되지는 않습니다. 보기가 조회 될 때 빠른 경로 잠금의 데이터 ( &lt;code&gt;fastpath&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; ))는 전체 잠금 관리자의 상태를 정지시키지 않고 각 백엔드에서 한 번에 하나씩 수집되므로 정보를 수집하는 동안 잠금을 해제하거나 해제 할 수 있습니다. 그러나 이러한 잠금은 현재 사용중인 다른 잠금과 충돌하지 않는 것으로 알려져 있습니다. 빠른 경로 잠금에 대해 모든 백엔드를 쿼리 한 후, 일반 잠금 관리자의 나머지는 한 단위로 잠기고 나머지 모든 잠금의 일관된 스냅 샷은 원자 적 조치로 수집됩니다. 일반 잠금 관리자를 잠금 해제하면 술어 잠금 관리자가 유사하게 잠기고 모든 술어 잠금이 원자 적 조치로 수집됩니다. 따라서 빠른 경로 잠금을 제외하고 각 잠금 관리자는 일관된 결과 집합을 제공하지만 두 잠금 관리자를 동시에 잠그지 않으므로일반 잠금 관리자를 조사한 후 그리고 술어 잠금 관리자를 조사하기 전에 잠금을 수행하거나 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc09426bbd89792d56d781e38f0585623a0a6b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_lsn&lt;/code&gt; data type can be used to store LSN (Log Sequence Number) data which is a pointer to a location in the WAL. This type is a representation of &lt;code&gt;XLogRecPtr&lt;/code&gt; and an internal system type of PostgreSQL.</source>
          <target state="translated">&lt;code&gt;pg_lsn&lt;/code&gt; 의 데이터 타입은 WAL의 위치에 대한 포인터 LSN (로그 시퀀스 번호)의 데이터를 저장하는데 사용될 수있다. 이 유형은 &lt;code&gt;XLogRecPtr&lt;/code&gt; 및 PostgreSQL의 내부 시스템 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2453f80583b015c097d94096a21e07fa08a7d653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_mcv_list_items&lt;/code&gt; function can be used like this:</source>
          <target state="translated">&lt;code&gt;pg_mcv_list_items&lt;/code&gt; 의 기능은 다음과 같이 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a0dd30f02c62fffd16e92aa745931812e6881ee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_monitor&lt;/code&gt;, &lt;code&gt;pg_read_all_settings&lt;/code&gt;, &lt;code&gt;pg_read_all_stats&lt;/code&gt; and &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; roles are intended to allow administrators to easily configure a role for the purpose of monitoring the database server. They grant a set of common privileges allowing the role to read various useful configuration settings, statistics and other system information normally restricted to superusers.</source>
          <target state="translated">&lt;code&gt;pg_monitor&lt;/code&gt; , &lt;code&gt;pg_read_all_settings&lt;/code&gt; , &lt;code&gt;pg_read_all_stats&lt;/code&gt; 및 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 의 역할은 관리자가 쉽게 데이터베이스 서버를 모니터링의 목적을 위해 역할을 구성 할 수 있도록하기위한 것입니다. 역할은 일반적으로 수퍼 유저로 제한된 다양한 유용한 구성 설정, 통계 및 기타 시스템 정보를 읽을 수있는 공통 권한 세트를 부여합니다.</target>
        </trans-unit>
        <trans-unit id="a9d719c2beab0d60be72a57746a97a87438b5577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prepared_statements&lt;/code&gt; view displays all the prepared statements that are available in the current session. See &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; for more information about prepared statements.</source>
          <target state="translated">&lt;code&gt;pg_prepared_statements&lt;/code&gt; 는 표시를 현재 세션에서 사용할 수있는 모든 준비가 문을 볼 수 있습니다. 준비된 명령문에 대한 자세한 정보는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f0733b71ce39a3b0da7d8656a3e5bc9319c9957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prepared_statements&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_prepared_statements&lt;/code&gt; 의 뷰는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="712cfe11a273eb23a78bfc37d1131dc7151bd1af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prewarm&lt;/code&gt; module provides a convenient way to load relation data into either the operating system buffer cache or the PostgreSQL buffer cache. Prewarming can be performed manually using the &lt;code&gt;pg_prewarm&lt;/code&gt; function, or can be performed automatically by including &lt;code&gt;pg_prewarm&lt;/code&gt; in &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;. In the latter case, the system will run a background worker which periodically records the contents of shared buffers in a file called &lt;code&gt;autoprewarm.blocks&lt;/code&gt; and will, using 2 background workers, reload those same blocks after a restart.</source>
          <target state="translated">&lt;code&gt;pg_prewarm&lt;/code&gt; 의 모듈은 운영 시스템의 버퍼 캐시 또는 PostgreSQL의 버퍼 캐시에로드하거나 관계 데이터에 편리한 방법을 제공한다. Prewarming는 사용 수동으로 수행 될 수 &lt;code&gt;pg_prewarm&lt;/code&gt; 의 기능을 포함하여 또는 자동적으로 수행 될 수 &lt;code&gt;pg_prewarm&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries를&lt;/a&gt; . 후자의 경우 시스템은 백그라운드 작업자를 실행하여 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; 라는 파일에 공유 버퍼의 내용을 정기적으로 기록하고 백그라운드 작업자 2 명을 사용하여 재시작 후 동일한 블록을 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="ae5fc12234ea79efc44835461370ba2ea861b98c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_read_server_files&lt;/code&gt;, &lt;code&gt;pg_write_server_files&lt;/code&gt; and &lt;code&gt;pg_execute_server_program&lt;/code&gt; roles are intended to allow administrators to have trusted, but non-superuser, roles which are able to access files and run programs on the database server as the user the database runs as. As these roles are able to access any file on the server file system, they bypass all database-level permission checks when accessing files directly and they could be used to gain superuser-level access, therefore great care should be taken when granting these roles to users.</source>
          <target state="translated">&lt;code&gt;pg_read_server_files&lt;/code&gt; , &lt;code&gt;pg_write_server_files&lt;/code&gt; 및 &lt;code&gt;pg_execute_server_program&lt;/code&gt; 의 역할은 관리자가 신뢰할 수있는 할 수 있도록 구성되지만, 비 슈퍼 유저, 데이터베이스 실행으로 사용자로 데이터베이스 서버에 액세스 파일과 실행 프로그램을 수있는 역할. 이러한 역할은 서버 파일 시스템의 모든 파일에 액세스 할 수 있으므로 파일에 직접 액세스 할 때 모든 데이터베이스 수준 권한 검사를 무시하고 수퍼 유저 수준 액세스를 얻는 데 사용될 수 있으므로 이러한 역할을 부여 할 때는 각별히주의해야합니다. 사용자.</target>
        </trans-unit>
        <trans-unit id="d4f7cb10a03b4cb92179c151a9345f858223dd84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_relation_filepath()&lt;/code&gt; function shows the entire path (relative to &lt;code&gt;PGDATA&lt;/code&gt;) of any relation. It is often useful as a substitute for remembering many of the above rules. But keep in mind that this function just gives the name of the first segment of the main fork of the relation &amp;mdash; you may need to append a segment number and/or &lt;code&gt;_fsm&lt;/code&gt;, &lt;code&gt;_vm&lt;/code&gt;, or &lt;code&gt;_init&lt;/code&gt; to find all the files associated with the relation.</source>
          <target state="translated">&lt;code&gt;pg_relation_filepath()&lt;/code&gt; 함수 쇼 (상대 전체 경로 &lt;code&gt;PGDATA&lt;/code&gt; 어떤 관계). 위의 많은 규칙을 기억하기위한 대체물로 종종 유용합니다. 그러나이 함수는 관계의 주요 포크의 첫 번째 세그먼트 이름 만 제공합니다 . 관계와 관련된 모든 파일을 찾으 &lt;code&gt;_vm&lt;/code&gt; 세그먼트 번호 및 / 또는 &lt;code&gt;_fsm&lt;/code&gt; , _vm 또는 &lt;code&gt;_init&lt;/code&gt; 를 추가해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03e84c5eab2e8606b5c93d96958f3280a2a3feb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin&lt;/code&gt; catalog contains all replication origins created. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin&lt;/code&gt; 의 카탈로그 생성 된 모든 복제 기원을 포함한다. 복제 기점에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;49 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a201c42fb9a458c1738bf941ca2be53c0cc3e6d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin&lt;/code&gt; catalog contains all replication origins created. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/13/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin&lt;/code&gt; 의 카탈로그 생성 된 모든 복제 기원을 포함한다. 복제 오리진에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/replication-origins.html&quot;&gt;49 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94519dfaf1a7e0c715cbe6d005de1e67132adafc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin_status&lt;/code&gt; view contains information about how far replay for a certain origin has progressed. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin_status&lt;/code&gt; 의 보기는 지금까지 진행 한 특정 기원 재생 방법에 대한 정보가 들어 있습니다. 복제 기점에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;49 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0bd227e95f044b9aab2e5468460e42e851b683b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin_status&lt;/code&gt; view contains information about how far replay for a certain origin has progressed. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/13/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin_status&lt;/code&gt; 의 보기는 지금까지 진행 한 특정 기원 재생 방법에 대한 정보가 들어 있습니다. 복제 오리진에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/replication-origins.html&quot;&gt;49 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6aff87cbf65850e431b7483477c97e1f7e57d54e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_slots&lt;/code&gt; view provides a listing of all replication slots that currently exist on the database cluster, along with their current state.</source>
          <target state="translated">&lt;code&gt;pg_replication_slots&lt;/code&gt; 의 보기는 현재 자신의 현재 상태와 함께 데이터베이스 클러스터에있는 모든 복제 슬롯의 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b0e21895d1c29cfa7bd5d292f490ca241b01ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_rules&lt;/code&gt; view excludes the &lt;code&gt;ON SELECT&lt;/code&gt; rules of views and materialized views; those can be seen in &lt;code&gt;pg_views&lt;/code&gt; and &lt;code&gt;pg_matviews&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_rules&lt;/code&gt; 는 제외 볼 &lt;code&gt;ON SELECT&lt;/code&gt; 는 뷰의 규칙과 전망을 구체화; 그것들은에서 볼 수 있습니다 &lt;code&gt;pg_views&lt;/code&gt; 및 &lt;code&gt;pg_matviews&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b04c9372466f179b32ff250ffc0d648d21a6075f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_settings&lt;/code&gt; view cannot be inserted into or deleted from, but it can be updated. An &lt;code&gt;UPDATE&lt;/code&gt; applied to a row of &lt;code&gt;pg_settings&lt;/code&gt; is equivalent to executing the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command on that named parameter. The change only affects the value used by the current session. If an &lt;code&gt;UPDATE&lt;/code&gt; is issued within a transaction that is later aborted, the effects of the &lt;code&gt;UPDATE&lt;/code&gt; command disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_settings&lt;/code&gt; 의 보기에 삽입 또는 삭제하지만, 업데이트 할 수 있습니다 할 수 없습니다. &lt;code&gt;UPDATE&lt;/code&gt; 의 행에 적용 &lt;code&gt;pg_settings&lt;/code&gt; 는 실행중인 동등 &lt;a href=&quot;sql-set&quot;&gt;SET의&lt;/a&gt; 명명 된 파라미터에 명령한다. 변경 사항은 현재 세션에서 사용 된 값에만 영향을줍니다. 는 IF &lt;code&gt;UPDATE&lt;/code&gt; 가 나중에 중단 된 트랜잭션 내에서 발행,의 효과 &lt;code&gt;UPDATE&lt;/code&gt; 의 트랜잭션이 롤백 될 때 명령은 사라집니다. 주변 트랜잭션이 커밋되면 다른 세션에 의해 재정의되지 않는 한 세션이 끝날 때까지 효과가 지속됩니다. &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;SET&lt;/code&gt; 로 .</target>
        </trans-unit>
        <trans-unit id="ffe931c8d58c1205468c69d9611286abaa96a718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_shmem_allocations&lt;/code&gt; view shows allocations made from the server's main shared memory segment. This includes both memory allocated by postgres itself and memory allocated by extensions using the mechanisms detailed in &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-c.html#XFUNC-SHARED-ADDIN&quot;&gt;Section 37.10.10&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_shmem_allocations&lt;/code&gt; 는 서버의 주 공유 메모리 세그먼트로 만든 쇼 할당을 볼 수 있습니다. 여기에는 postgres 자체에 의해 할당 된 메모리와 &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-c.html#XFUNC-SHARED-ADDIN&quot;&gt;섹션 37.10.10에&lt;/a&gt; 자세히 설명 된 메커니즘을 사용하여 확장에 의해 할당 된 메모리가 모두 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="959ff59e7cb2ea926dc414727d1a287d75002cdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_signal_backend&lt;/code&gt; role is intended to allow administrators to enable trusted, but non-superuser, roles to send signals to other backends. Currently this role enables sending of signals for canceling a query on another backend or terminating its session. A user granted this role cannot however send signals to a backend owned by a superuser. See &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.26.2&lt;/a&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;pg_signal_backend&lt;/code&gt; 의 역할은 관리자가 신뢰 설정할 수있는하도록 구성되어 있지만, 비 슈퍼 유저는 역할이 다른 백엔드에 신호를 보낼 수 있습니다. 현재이 역할을 통해 다른 백엔드에서 쿼리를 취소하거나 세션을 종료하기 위해 신호를 보낼 수 있습니다. 그러나이 역할이 부여 된 사용자는 수퍼 유저가 소유 한 백엔드에 신호를 보낼 수 없습니다. &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;9.26.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e3a31cbbdf0a9745d07c318b7a8ce915995d224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_signal_backend&lt;/code&gt; role is intended to allow administrators to enable trusted, but non-superuser, roles to send signals to other backends. Currently this role enables sending of signals for canceling a query on another backend or terminating its session. A user granted this role cannot however send signals to a backend owned by a superuser. See &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.27.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_signal_backend&lt;/code&gt; 의 역할은 관리자가 신뢰 설정할 수있는하도록 구성되어 있지만, 비 슈퍼 유저는 역할이 다른 백엔드에 신호를 보낼 수 있습니다. 현재이 역할을 사용하면 다른 백엔드에서 쿼리를 취소하거나 세션을 종료하기위한 신호를 보낼 수 있습니다. 그러나이 역할이 부여 된 사용자는 수퍼 유저가 소유 한 백엔드에 신호를 보낼 수 없습니다. &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;섹션 9.27.2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="364ec70800885a32c9b384791eb887b060833388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_activity&lt;/code&gt; view will have one row per server process, showing information related to the current activity of that process.</source>
          <target state="translated">그만큼 &lt;code&gt;pg_stat_activity&lt;/code&gt; 의 뷰는 서버 프로세스 당 하나의 열, 즉 공정의 현재의 활동에 관한 정보를 나타내는 것이다.</target>
        </trans-unit>
        <trans-unit id="0d5cfe66d3c739cee322847b588c9d5b35df5eee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; view will contain one row for each index in the current database, showing statistics about accesses to that specific index. The &lt;code&gt;pg_stat_user_indexes&lt;/code&gt; and &lt;code&gt;pg_stat_sys_indexes&lt;/code&gt; views contain the same information, but filtered to only show user and system indexes respectively.</source>
          <target state="translated">&lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 뷰는 특정 지수에 대한 액세스에 대한 통계를 보여 현재 데이터베이스에 각 인덱스에 대한 하나의 행이 포함됩니다. &lt;code&gt;pg_stat_user_indexes&lt;/code&gt; 및 &lt;code&gt;pg_stat_sys_indexes&lt;/code&gt; 의 뷰와 동일한 정보를 포함하고 있지만, 각각의 표시 대상 사용자와 시스템 인덱스로 여과 하였다.</target>
        </trans-unit>
        <trans-unit id="4915eaf62d5fac508cd463bbfeb67c5bc9a1f887" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_all_tables&lt;/code&gt; view will contain one row for each table in the current database (including TOAST tables), showing statistics about accesses to that specific table. The &lt;code&gt;pg_stat_user_tables&lt;/code&gt; and &lt;code&gt;pg_stat_sys_tables&lt;/code&gt; views contain the same information, but filtered to only show user and system tables respectively.</source>
          <target state="translated">&lt;code&gt;pg_stat_all_tables&lt;/code&gt; 의 뷰는 특정 테이블에 대한 액세스에 대한 통계를 보여 (TOAST 테이블 포함) 현재 데이터베이스의 각 테이블에 대해 하나 개의 행이 포함됩니다. &lt;code&gt;pg_stat_user_tables&lt;/code&gt; 및 &lt;code&gt;pg_stat_sys_tables&lt;/code&gt; 의 뷰와 동일한 정보를 포함하고 있지만, 각각의 표시 대상 사용자와 시스템 테이블 여과 하였다.</target>
        </trans-unit>
        <trans-unit id="e920a84446b775991fa1eb14f7bc867a07c08969" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_archiver&lt;/code&gt; view will always have a single row, containing data about the archiver process of the cluster.</source>
          <target state="translated">&lt;code&gt;pg_stat_archiver&lt;/code&gt; 의 보기는 항상 클러스터의 아카이버 프로세스에 대한 데이터를 포함하는 단일 행을해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1fdaad38e5659f088cd956997f18528cb8adec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; view will always have a single row, containing global data for the cluster.</source>
          <target state="translated">&lt;code&gt;pg_stat_bgwriter&lt;/code&gt; 의 보기는 항상 클러스터에 대한 글로벌 데이터를 포함, 단일 행을해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5e37f5dd787f2d54c1785bbeac6cabe3525147b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database&lt;/code&gt; view will contain one row for each database in the cluster, plus one for shared objects, showing database-wide statistics.</source>
          <target state="translated">&lt;code&gt;pg_stat_database&lt;/code&gt; 의 뷰는 데이터베이스 전체의 통계를 보여주는, 공유 객체에 대해 하나 개의 클러스터에있는 각 데이터베이스에 대한 행을 더한를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="393da291bc9e23ea3e77a3450fa686048aaf2442" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database&lt;/code&gt; view will contain one row for each database in the cluster, plus one for the shared objects, showing database-wide statistics.</source>
          <target state="translated">&lt;code&gt;pg_stat_database&lt;/code&gt; 의 뷰는 데이터베이스 전체의 통계를 보여주는, 공유 객체에 대한 각 클러스터의 데이터베이스 플러스 하나 하나 개의 행을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3c93e50dd3fc817fe9ad114869b45a8e9cc6f37d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; view will contain one row per database, showing database-wide statistics about query cancels occurring due to conflicts with recovery on standby servers. This view will only contain information on standby servers, since conflicts do not occur on master servers.</source>
          <target state="translated">&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; 이 때문에 대기 서버에 복구와의 충돌로 발생하는 취소됩니다 쿼리에 대한 데이터베이스 차원의 통계를 보여주는, 데이터베이스 당 하나의 행이 포함됩니다 볼 수 있습니다. 마스터 서버에서는 충돌이 발생하지 않으므로이보기에는 대기 서버에 대한 정보 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9ca86aca5bdcd3b49612a77c80efa58451d60340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_gssapi&lt;/code&gt; view will contain one row per backend, showing information about GSSAPI usage on this connection. It can be joined to &lt;code&gt;pg_stat_activity&lt;/code&gt; or &lt;code&gt;pg_stat_replication&lt;/code&gt; on the &lt;code&gt;pid&lt;/code&gt; column to get more details about the connection.</source>
          <target state="translated">&lt;code&gt;pg_stat_gssapi&lt;/code&gt; 의 볼이 연결에 GSSAPI 사용에 대한 정보를 표시, 백엔드 당 하나 개의 행을 포함합니다. &lt;code&gt;pg_stat_activity&lt;/code&gt; 또는 &lt;code&gt;pg_stat_replication&lt;/code&gt; 에 결합 될 수 있습니다 . &lt;code&gt;pid&lt;/code&gt; 열 하여 연결에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d861488085903be47118e7cb1eda5ee9716d20c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_replication&lt;/code&gt; view will contain one row per WAL sender process, showing statistics about replication to that sender's connected standby server. Only directly connected standbys are listed; no information is available about downstream standby servers.</source>
          <target state="translated">&lt;code&gt;pg_stat_replication&lt;/code&gt; 보기는 보낸 사람의 연결 대기 서버로 복제에 대한 통계를 보여 WAL 발신자 프로세스 당 하나 개의 행을 포함합니다. 직접 연결된 대기만 나열됩니다. 다운 스트림 대기 서버에 대한 정보가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fc5431a476a7e29631b45416342385e30449578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_ssl&lt;/code&gt; view will contain one row per backend or WAL sender process, showing statistics about SSL usage on this connection. It can be joined to &lt;code&gt;pg_stat_activity&lt;/code&gt; or &lt;code&gt;pg_stat_replication&lt;/code&gt; on the &lt;code&gt;pid&lt;/code&gt; column to get more details about the connection.</source>
          <target state="translated">&lt;code&gt;pg_stat_ssl&lt;/code&gt; 의 볼이 연결에 SSL 사용에 대한 통계를 보여 백엔드 또는 WAL 발신자 프로세스 당 하나 개의 행을 포함합니다. &lt;code&gt;pid&lt;/code&gt; 에서 &lt;code&gt;pg_stat_activity&lt;/code&gt; 또는 &lt;code&gt;pg_stat_replication&lt;/code&gt; 에 결합 할 수 있습니다 열 하여 연결에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daf211b37dbd6853dfd5eb7dd10c7c12b2c0042c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; module provides a means for tracking execution statistics of all SQL statements executed by a server.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; 모듈은 서버에서 실행되는 모든 SQL 문 실행 통계를 추적하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb037906e08d65818b386fd71c5ec4aa0004699e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; module provides a means for tracking planning and execution statistics of all SQL statements executed by a server.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; 의 모듈은 서버에서 실행되는 모든 SQL 문의 계획 및 실행 통계를 추적하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98e909d7ac4e2a7927d69b3536cd3fab24324d97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; view is defined in terms of a function also named &lt;code&gt;pg_stat_statements&lt;/code&gt;. It is possible for clients to call the &lt;code&gt;pg_stat_statements&lt;/code&gt; function directly, and by specifying &lt;code&gt;showtext := false&lt;/code&gt; have query text be omitted (that is, the &lt;code&gt;OUT&lt;/code&gt; argument that corresponds to the view's &lt;code&gt;query&lt;/code&gt; column will return nulls). This feature is intended to support external tools that might wish to avoid the overhead of repeatedly retrieving query texts of indeterminate length. Such tools can instead cache the first query text observed for each entry themselves, since that is all &lt;code&gt;pg_stat_statements&lt;/code&gt; itself does, and then retrieve query texts only as needed. Since the server stores query texts in a file, this approach may reduce physical I/O for repeated examination of the &lt;code&gt;pg_stat_statements&lt;/code&gt; data.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; 의 뷰는 또한 함수라는 관점에서 정의된다 &lt;code&gt;pg_stat_statements&lt;/code&gt; . 클라이언트가 &lt;code&gt;pg_stat_statements&lt;/code&gt; 함수를 직접 호출하고 &lt;code&gt;showtext := false&lt;/code&gt; 를 지정하여 쿼리 텍스트를 생략 할 수 있습니다 (즉 , 뷰의 &lt;code&gt;query&lt;/code&gt; 자체에 해당하는 &lt;code&gt;OUT&lt;/code&gt; 인수는 필요에 따라 쿼리 텍스트를 검색 함). 서버는 쿼리 텍스트를 파일에 저장합니다.이 접근 방식은 &lt;code&gt;pg_stat_statements&lt;/code&gt; 데이터 의 반복 검사를 위해 물리적 I / O를 줄일 수 있습니다 . 열에 널을 리턴 함). 이 기능은 길이가 불확실한 쿼리 텍스트를 반복적으로 검색하는 오버 헤드를 피할 수있는 외부 도구를 지원하기위한 것입니다. 이러한 도구는 각 항목 자체에서 관찰 된 첫 번째 쿼리 텍스트를 대신 캐시 할 수 있습니다. &lt;code&gt;pg_stat_statements&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abb8ed00a27312be8d978730672b0b28bbcb5469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_subscription&lt;/code&gt; view will contain one row per subscription for main worker (with null PID if the worker is not running), and additional rows for workers handling the initial data copy of the subscribed tables.</source>
          <target state="translated">&lt;code&gt;pg_stat_subscription&lt;/code&gt; (작업자가 실행되고 있지 않은 경우는 null PID와)보기 주 노동자에 대한 구독 당 하나 개의 행을 포함하고 초기 데이터를 취급 근로자에 대한 추가 행이 가입 된 테이블로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="10b53f5c8cdaebaaf4ec10ef70cc41030a5f49c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_user_functions&lt;/code&gt; view will contain one row for each tracked function, showing statistics about executions of that function. The &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; parameter controls exactly which functions are tracked.</source>
          <target state="translated">&lt;code&gt;pg_stat_user_functions&lt;/code&gt; 의 보기는 그 기능의 실행에 대한 통계를 나타내는 각각의 추적 된 기능에 대한 하나 개의 행을 포함 할 것이다. &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; 제어 매개 변수는 정확하게 기능을 추적한다.</target>
        </trans-unit>
        <trans-unit id="192cc2da4edef74cee3104eea30272179c17353c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; view will contain only one row, showing statistics about the WAL receiver from that receiver's connected server.</source>
          <target state="translated">&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; 의 보기는 수신기의 연결된 서버에서 WAL 수신기에 대한 통계를 보여주는 하나의 행을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ccb7822cb6072c4067c2cc69eddb66f1fcb783d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_&lt;/code&gt; views are primarily useful to determine the effectiveness of the buffer cache. When the number of actual disk reads is much smaller than the number of buffer hits, then the cache is satisfying most read requests without invoking a kernel call. However, these statistics do not give the entire story: due to the way in which PostgreSQL handles disk I/O, data that is not in the PostgreSQL buffer cache might still reside in the kernel's I/O cache, and might therefore still be fetched without requiring a physical read. Users interested in obtaining more detailed information on PostgreSQL I/O behavior are advised to use the PostgreSQL statistics collector in combination with operating system utilities that allow insight into the kernel's handling of I/O.</source>
          <target state="translated">&lt;code&gt;pg_statio_&lt;/code&gt; 보기는 버퍼 캐시의 효과를 결정하는 주로 유용합니다. 실제 디스크 읽기 수가 버퍼 적중 횟수보다 훨씬 적은 경우 캐시는 커널 호출을 호출하지 않고 대부분의 읽기 요청을 충족시킵니다. 그러나 이러한 통계는 전체 스토리를 제공하지는 않습니다. PostgreSQL이 디스크 I / O를 처리하는 방식으로 인해 PostgreSQL 버퍼 캐시에없는 데이터는 여전히 커널의 I / O 캐시에있을 수 있으며 여전히 페치 될 수 있습니다 실제 읽기가 필요하지 않습니다. PostgreSQL I / O 동작에 대한 자세한 정보를 얻는 데 관심이있는 사용자는 커널의 I / O 처리에 대한 통찰력을 제공하는 운영 체제 유틸리티와 함께 ​​PostgreSQL 통계 수집기를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4275ef4261b6d2382694080172180d4c6bb50fe7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_indexes&lt;/code&gt; view will contain one row for each index in the current database, showing statistics about I/O on that specific index. The &lt;code&gt;pg_statio_user_indexes&lt;/code&gt; and &lt;code&gt;pg_statio_sys_indexes&lt;/code&gt; views contain the same information, but filtered to only show user and system indexes respectively.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_indexes&lt;/code&gt; 는 I / 특정 지수에 O에 대한 통계를 보여, 현재 데이터베이스에 각 인덱스에 대한 하나의 행이 포함됩니다 볼 수 있습니다. &lt;code&gt;pg_statio_user_indexes&lt;/code&gt; 및 &lt;code&gt;pg_statio_sys_indexes&lt;/code&gt; 의 뷰와 동일한 정보를 포함하고 있지만, 각각의 표시 대상 사용자와 시스템 인덱스로 여과 하였다.</target>
        </trans-unit>
        <trans-unit id="633f3d97ee7656ef624fbb5d36d3f8580d36168e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_sequences&lt;/code&gt; view will contain one row for each sequence in the current database, showing statistics about I/O on that specific sequence.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_sequences&lt;/code&gt; 는 I / 특정 순서에 O에 대한 통계를 보여 현재 데이터베이스의 각 시퀀스에 대해 하나의 행이 포함됩니다 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3f0cb49815d4460862c6bbe716f068280da5e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_tables&lt;/code&gt; view will contain one row for each table in the current database (including TOAST tables), showing statistics about I/O on that specific table. The &lt;code&gt;pg_statio_user_tables&lt;/code&gt; and &lt;code&gt;pg_statio_sys_tables&lt;/code&gt; views contain the same information, but filtered to only show user and system tables respectively.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_tables&lt;/code&gt; 는 I / 특정 테이블에 O에 대한 통계를 보여 (TOAST 테이블 포함) 현재 데이터베이스의 각 테이블에 대해 하나의 행이 포함됩니다 볼 수 있습니다. &lt;code&gt;pg_statio_user_tables&lt;/code&gt; 및 &lt;code&gt;pg_statio_sys_tables&lt;/code&gt; 의 뷰와 동일한 정보를 포함하고 있지만, 각각의 표시 대상 사용자와 시스템 테이블 여과 하였다.</target>
        </trans-unit>
        <trans-unit id="57e3b64868b02c0a85487789a181915c3308f04e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statistic_ext&lt;/code&gt; entry is filled in completely during &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, but the actual statistical values are not computed then. Subsequent &lt;code&gt;ANALYZE&lt;/code&gt; commands compute the desired values and populate an entry in the &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="translated">&lt;code&gt;pg_statistic_ext&lt;/code&gt; 의 항목 중에 완전히 채워진다 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 있지만, 실제 통계 값은 다음으로 계산되지 않는다. 후속 &lt;code&gt;ANALYZE&lt;/code&gt; 명령은 원하는 값을 계산하고 &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt; &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; &lt;/a&gt; 카탈로그 의 항목을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="4ab16db4ae44ab46362ea23499bbb4d24c58bacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stop_backup&lt;/code&gt; will return one row with three values. The second of these fields should be written to a file named &lt;code&gt;backup_label&lt;/code&gt; in the root directory of the backup. The third field should be written to a file named &lt;code&gt;tablespace_map&lt;/code&gt; unless the field is empty. These files are vital to the backup working, and must be written without modification.</source>
          <target state="translated">&lt;code&gt;pg_stop_backup&lt;/code&gt; 는 세 개의 값을 하나 개의 행을 반환합니다. 이 필드 중 두 번째 필드는 &lt;code&gt;backup_label&lt;/code&gt; 이라는 파일에 작성해야합니다. 백업의 루트 디렉토리에있는 . 필드가 비어 있지 않으면 세 번째 필드는 &lt;code&gt;tablespace_map&lt;/code&gt; 이라는 파일에 작성해야합니다 . 이 파일들은 백업 작업에 필수적이며 수정없이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ccb3d590fa85ee9247d7f4bf77a2f3efc4344c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_trgm&lt;/code&gt; module provides GiST and GIN index operator classes that allow you to create an index over a text column for the purpose of very fast similarity searches. These index types support the above-described similarity operators, and additionally support trigram-based index searches for &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;ILIKE&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; queries. (These indexes do not support equality nor simple comparison operators, so you may need a regular B-tree index too.)</source>
          <target state="translated">&lt;code&gt;pg_trgm&lt;/code&gt; 의 모듈은 매우 빠른 유사성 검색을 목적으로 텍스트 컬럼을 통해 인덱스를 만들 수 GIST 및 GIN 인덱스 연산자 클래스를 제공합니다. 이러한 인덱스 유형은 위에서 설명한 유사성 연산자를 지원하고 &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;ILIKE&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 및 trigram 기반 인덱스 검색을 추가로 지원합니다. &lt;code&gt;~*&lt;/code&gt; 쿼리에 합니다. (이 인덱스는 동등성이나 간단한 비교 연산자를 지원하지 않으므로 일반 B- 트리 인덱스도 필요할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="fc7db08f494b7bd6b75737a77c0ee6584bbbf782" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_trgm&lt;/code&gt; module provides functions and operators for determining the similarity of alphanumeric text based on trigram matching, as well as index operator classes that support fast searching for similar strings.</source>
          <target state="translated">그만큼 &lt;code&gt;pg_trgm&lt;/code&gt; 의 모듈은 트라이 그램 매칭 지원뿐만 아니라 빠른 유사한 문자열을 찾고 그 인덱스 연산자 클래스를 기반 영숫자 문자의 유사성을 결정하기위한 함수와 연산자를 제공한다.</target>
        </trans-unit>
        <trans-unit id="0591f005154500c944add92ac3b7183691fb1ca4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_config&lt;/code&gt; catalog contains entries representing text search configurations. A configuration specifies a particular text search parser and a list of dictionaries to use for each of the parser's output token types. The parser is shown in the &lt;code&gt;pg_ts_config&lt;/code&gt; entry, but the token-to-dictionary mapping is defined by subsidiary entries in &lt;a href=&quot;catalog-pg-ts-config-map&quot;&gt;&lt;code&gt;pg_ts_config_map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ts_config&lt;/code&gt; 의 카탈로그는 텍스트 검색 구성을 나타내는 항목이 포함되어 있습니다. 구성은 특정 텍스트 검색 파서와 각 파서의 출력 토큰 유형에 사용할 사전 목록을 지정합니다. 파서는 &lt;code&gt;pg_ts_config&lt;/code&gt; 항목에 표시되지만 토큰-사전 매핑은 &lt;a href=&quot;catalog-pg-ts-config-map&quot;&gt; &lt;code&gt;pg_ts_config_map&lt;/code&gt; 의&lt;/a&gt; 자회사 항목으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed3b9b0c162846ed7796c343a7cd6db3dce66f59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_config_map&lt;/code&gt; catalog contains entries showing which text search dictionaries should be consulted, and in what order, for each output token type of each text search configuration's parser.</source>
          <target state="translated">&lt;code&gt;pg_ts_config_map&lt;/code&gt; 의 카탈로그 항목이 각 텍스트 검색 구성의 파서의 각 출력 토큰 유형, 텍스트 검색 사전을 상담해야하는 보여주는, 그리고 어떤 순서로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1aa79ed96a9f64450a185ab7801c634f26ba881" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_dict&lt;/code&gt; catalog contains entries defining text search dictionaries. A dictionary depends on a text search template, which specifies all the implementation functions needed; the dictionary itself provides values for the user-settable parameters supported by the template. This division of labor allows dictionaries to be created by unprivileged users. The parameters are specified by a text string &lt;code&gt;dictinitoption&lt;/code&gt;, whose format and meaning vary depending on the template.</source>
          <target state="translated">&lt;code&gt;pg_ts_dict&lt;/code&gt; 의 카탈로그는 텍스트 검색 사전을 정의하는 항목이 포함되어 있습니다. 사전은 필요한 모든 구현 기능을 지정하는 텍스트 검색 템플릿에 따라 다릅니다. 사전 자체는 템플리트가 지원하는 사용자 설정 가능 매개 변수의 값을 제공합니다. 이 분업으로 인해 권한이없는 사용자가 사전을 만들 수 있습니다. 매개 변수는 텍스트 문자열 &lt;code&gt;dictinitoption&lt;/code&gt; 에 의해 지정되며 형식과 의미는 템플리트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="214cf3524f01d220fbc4c1ed75c24082b9d19637" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_parser&lt;/code&gt; catalog contains entries defining text search parsers. A parser is responsible for splitting input text into lexemes and assigning a token type to each lexeme. Since a parser must be implemented by C-language-level functions, creation of new parsers is restricted to database superusers.</source>
          <target state="translated">&lt;code&gt;pg_ts_parser&lt;/code&gt; 의 카탈로그는 텍스트 검색 파서를 정의하는 항목이 포함되어 있습니다. 파서는 입력 텍스트를 exeme으로 나누고 각 lexeme에 토큰 유형을 할당합니다. 구문 분석기는 C 언어 레벨 함수로 구현해야하므로 새 구문 분석기 작성은 데이터베이스 수퍼 유저로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="cb87e8d8ef4d72f7f47347f20f99911a07cb666c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_template&lt;/code&gt; catalog contains entries defining text search templates. A template is the implementation skeleton for a class of text search dictionaries. Since a template must be implemented by C-language-level functions, creation of new templates is restricted to database superusers.</source>
          <target state="translated">&lt;code&gt;pg_ts_template&lt;/code&gt; 의 카탈로그는 텍스트 검색 템플릿을 정의하는 항목이 포함되어 있습니다. 템플릿은 텍스트 검색 사전 클래스의 구현 골격입니다. C 언어 수준의 기능으로 템플릿을 구현해야하므로 새 템플릿 생성은 데이터베이스 수퍼 유저로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="98aec2c9411d89139f2d3f0f94ddaca8b8727976" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_visibility&lt;/code&gt; module provides a means for examining the visibility map (VM) and page-level visibility information of a table. It also provides functions to check the integrity of a visibility map and to force it to be rebuilt.</source>
          <target state="translated">&lt;code&gt;pg_visibility&lt;/code&gt; 의 모듈은 시정지도 (VM) 및 테이블의 페이지 수준의 가시성 정보를 검사하는 수단을 제공합니다. 또한 가시성 맵의 무결성을 확인하고 강제로 다시 작성하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aebe4e3ccf987f601f3ce63d73da2ecfe326511d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgcrypto&lt;/code&gt; module provides cryptographic functions for PostgreSQL.</source>
          <target state="translated">&lt;code&gt;pgcrypto&lt;/code&gt; 의 모듈은 PostgreSQL을위한 암호화 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7582806e57c12c2e0e98376d6a43f53ffd981a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgrowlocks&lt;/code&gt; module provides a function to show row locking information for a specified table.</source>
          <target state="translated">&lt;code&gt;pgrowlocks&lt;/code&gt; 의 모듈은 지정된 테이블 행 잠금 정보를 표시하는 기능을 제공한다.</target>
        </trans-unit>
        <trans-unit id="0aa04313fa7e95bfad5b3c29fac2331cea3b0811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgstattuple&lt;/code&gt; module provides various functions to obtain tuple-level statistics.</source>
          <target state="translated">&lt;code&gt;pgstattuple&lt;/code&gt; 의 모듈 튜플 레벨 통계를 획득하기위한 다양한 기능을 제공한다.</target>
        </trans-unit>
        <trans-unit id="b0c0e6c63f820b164f2eadaa8c5ae11d57326dbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pid&lt;/code&gt; column can be joined to the &lt;code&gt;pid&lt;/code&gt; column of the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt; view to get more information on the session holding or awaiting each lock, for example</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 열이 결합 될 수있다 &lt;code&gt;pid&lt;/code&gt; 의 열 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt; &lt;code&gt;pg_stat_activity&lt;/code&gt; 의&lt;/a&gt; 예를 들어, 세션 유지 또는 각 잠금 대기에 대한 자세한 정보를 얻을보기</target>
        </trans-unit>
        <trans-unit id="3550763c8f87c7c5071a2ae4590cbccf7d821554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pid&lt;/code&gt; column can be joined to the &lt;code&gt;pid&lt;/code&gt; column of the &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt; view to get more information on the session holding or awaiting each lock, for example</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 열이 결합 될 수있다 &lt;code&gt;pid&lt;/code&gt; 의 열 &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt; &lt;code&gt;pg_stat_activity&lt;/code&gt; 의&lt;/a&gt; 예를 들어, 세션 유지 또는 각 잠금 대기에 대한 자세한 정보를 얻을보기</target>
        </trans-unit>
        <trans-unit id="1772c228a2ba486f02c419b09475ac82a8dda4c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; type is an example of a PostgreSQL-specific data type.</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; 타입 PostgreSQL의 특정 데이터 유형의 예이다.</target>
        </trans-unit>
        <trans-unit id="6d33330f4a5a6a6e60ef800433563c926a762925" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; type requires a coordinate pair as input, as shown here:</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; 유형이 여기 도시 한 바와 같이, 입력으로 쌍 좌표 필요</target>
        </trans-unit>
        <trans-unit id="5140039e3c9f8558e37b9c94c77a69208747ed9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; command can also be called in single-user mode. The primary use for this mode is during bootstrapping by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Sometimes it is used for debugging or disaster recovery; note that running a single-user server is not truly suitable for debugging the server, since no realistic interprocess communication and locking will happen. When invoked in single-user mode from the shell, the user can enter queries and the results will be printed to the screen, but in a form that is more useful for developers than end users. In the single-user mode, the session user will be set to the user with ID 1, and implicit superuser powers are granted to this user. This user does not actually have to exist, so the single-user mode can be used to manually recover from certain kinds of accidental damage to the system catalogs.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 명령은 단일 사용자 모드로 호출 할 수 있습니다. 이 모드의 기본 용도는 &lt;a href=&quot;app-initdb&quot;&gt;initdb로&lt;/a&gt; 부트 스트랩하는 동안입니다.. 때로는 디버깅 또는 재해 복구에 사용되기도합니다. 실제 프로세스 간 통신 및 잠금이 발생하지 않으므로 단일 사용자 서버를 실행하는 것이 서버 디버깅에 실제로 적합하지는 않습니다. 셸에서 단일 사용자 모드로 호출하면 사용자가 쿼리를 입력 할 수 있으며 결과는 화면에 인쇄되지만 최종 사용자보다 개발자에게 더 유용한 형식으로 인쇄됩니다. 단일 사용자 모드에서 세션 사용자는 ID 1의 사용자로 설정되며 암시 적 슈퍼 유저 권한이이 사용자에게 부여됩니다. 이 사용자는 실제로 존재하지 않아도되므로 단일 사용자 모드를 사용하여 시스템 카탈로그에 대한 특정 유형의 우발적 인 손상을 수동으로 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73edbc735e1da3f91be137ad83f38e16d0101877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; database is also created when a database cluster is initialized. This database is meant as a default database for users and applications to connect to. It is simply a copy of &lt;code&gt;template1&lt;/code&gt; and can be dropped and recreated if necessary.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 데이터베이스 클러스터가 초기화 될 때 데이터베이스도 생성됩니다. 이 데이터베이스는 사용자와 응용 프로그램이 연결하는 기본 데이터베이스로 사용됩니다. 이는 단순히 &lt;code&gt;template1&lt;/code&gt; 의 사본이며 필요한 경우 삭제하고 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c82b8fca9884597f624dea1153620a237bd20b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; program also takes a number of other command-line options. For more information, see the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page and &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 프로그램은 또한 다른 명령 줄 옵션을합니다. 자세한 내용은 &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; 참조 페이지와 아래 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eda7d54c28eff433f5434e637f13adc9ca90a215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; program also takes a number of other command-line options. For more information, see the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page and &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 프로그램은 또한 다른 명령 줄 옵션을합니다. 자세한 내용은 &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; 참조 페이지와 아래의 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7330a81519eca7bce15eddcdea10af1a633af88b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; server uses &lt;code&gt;SIGQUIT&lt;/code&gt; to tell subordinate server processes to terminate without normal cleanup. This signal &lt;em&gt;should not&lt;/em&gt; be used by users. It is also unwise to send &lt;code&gt;SIGKILL&lt;/code&gt; to a server process &amp;mdash; the main &lt;code&gt;postgres&lt;/code&gt; process will interpret this as a crash and will force all the sibling processes to quit as part of its standard crash-recovery procedure.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 서버 사용의 &lt;code&gt;SIGQUIT&lt;/code&gt; 는 정상 정리하지 않고 종료 하위 서버 프로세스를 알 수 있습니다. 이 신호 &lt;em&gt;는&lt;/em&gt; 사용자가 사용 &lt;em&gt;해서는 안됩니다&lt;/em&gt; . 또한 &lt;code&gt;SIGKILL&lt;/code&gt; 을 서버 프로세스 로 보내는 것은 현명하지 못합니다 . 기본 &lt;code&gt;postgres&lt;/code&gt; 프로세스는이를 크래시로 해석하고 모든 형제 프로세스를 표준 크래시 복구 절차의 일부로 강제 종료합니다.</target>
        </trans-unit>
        <trans-unit id="c92653f4d0fd5ea002d544c735e92bfa8e8c8314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres_fdw&lt;/code&gt; module provides the foreign-data wrapper &lt;code&gt;postgres_fdw&lt;/code&gt;, which can be used to access data stored in external PostgreSQL servers.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 모듈은 외부 데이터 래퍼 &lt;code&gt;postgres_fdw&lt;/code&gt; 를 제공합니다 . postgres_fdw 는 외부 PostgreSQL 서버에 저장된 데이터에 액세스하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90fd3421ad39e8fc161b92d89f61f89037308547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgresql.auto.conf&lt;/code&gt; file will record the connection settings and, if specified, the replication slot that pg_basebackup is using, so that streaming replication will use the same settings later on.</source>
          <target state="translated">&lt;code&gt;postgresql.auto.conf&lt;/code&gt; 를 지정한 경우 파일을 스트리밍 복제가 나중에 동일한 설정을 사용 그래서,,, pg_basebackup가 사용하고있는 복제 슬롯을 연결 설정을 기록하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e090ec42938a8e07ce95bbef3862c409a5d10ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgresql.conf&lt;/code&gt; file can also contain &lt;code&gt;include_dir&lt;/code&gt; directives, which specify an entire directory of configuration files to include. These look like</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 파일도 포함 할 수 있습니다 &lt;code&gt;include_dir&lt;/code&gt; 구성 파일의 전체 디렉토리를 포함하도록 지정 지침을. 이것들은</target>
        </trans-unit>
        <trans-unit id="b3d5fb19af808b68f842086f75de8bd4758fc142" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;predicate&lt;/code&gt; allows you to specify an exclusion constraint on a subset of the table; internally this creates a partial index. Note that parentheses are required around the predicate.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; 당신이 테이블의 부분 집합에 제외 제약 조건을 지정할 수 있습니다; 내부적으로 이것은 부분 인덱스를 만듭니다. 술어 주위에 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1b637034a943affe6ee006c1f9d5b95a5ccbc7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;psql&lt;/code&gt; program has a number of internal commands that are not SQL commands. They begin with the backslash character, &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo;. For example, you can get help on the syntax of various PostgreSQL SQL commands by typing:</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; 의의 프로그램은 SQL 명령하지 않은 내부 명령을 가지고 있습니다. 백 슬래시 문자 &quot; &lt;code&gt;\&lt;/code&gt; &quot;로 시작합니다. 예를 들어 다음을 입력하여 다양한 PostgreSQL SQL 명령의 구문에 대한 도움말을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce36c6cfc7d62a93cbf69277d65d4367aa5df13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quad_point_ops&lt;/code&gt;, &lt;code&gt;kd_point_ops&lt;/code&gt; and &lt;code&gt;poly_ops&lt;/code&gt; operator classes support the &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ordering operator, which enables the k-nearest neighbor (&lt;code&gt;k-NN&lt;/code&gt;) search over indexed point or polygon data sets.</source>
          <target state="translated">&lt;code&gt;quad_point_ops&lt;/code&gt; , &lt;code&gt;kd_point_ops&lt;/code&gt; 및 &lt;code&gt;poly_ops&lt;/code&gt; 연산자 클래스 지지체 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; K 개의 최근 접 (수 순서 연산자 &lt;code&gt;k-NN&lt;/code&gt; ) 인덱스 점 또는 폴리곤 데이터 세트를 통해 검색한다.</target>
        </trans-unit>
        <trans-unit id="603e4354460ff268426362e0c3963c884ac4c1a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random()&lt;/code&gt; function uses a simple linear congruential algorithm. It is fast but not suitable for cryptographic applications; see the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module for a more secure alternative. If &lt;code&gt;setseed()&lt;/code&gt; is called, the results of subsequent &lt;code&gt;random()&lt;/code&gt; calls in the current session are repeatable by re-issuing &lt;code&gt;setseed()&lt;/code&gt; with the same argument.</source>
          <target state="translated">&lt;code&gt;random()&lt;/code&gt; 함수는 선형 합동 간단한 알고리즘을 사용한다. 빠르지 만 암호화 응용 프로그램에는 적합하지 않습니다. 보다 안전한 대안 은 &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; 모듈을 참조하십시오 . 경우 &lt;code&gt;setseed()&lt;/code&gt; 라고, 이후의 결과 &lt;code&gt;random()&lt;/code&gt; 현재 세션의 호출에 의해 반복되어 재 발급 &lt;code&gt;setseed()&lt;/code&gt; 같은 인수와 함께.</target>
        </trans-unit>
        <trans-unit id="ff10a2167c2124d5d47ea963256c5ecf533fb464" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random()&lt;/code&gt; function uses a simple linear congruential algorithm. It is fast but not suitable for cryptographic applications; see the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module for a more secure alternative. If &lt;code&gt;setseed()&lt;/code&gt; is called, the series of results of subsequent &lt;code&gt;random()&lt;/code&gt; calls in the current session can be repeated by re-issuing &lt;code&gt;setseed()&lt;/code&gt; with the same argument.</source>
          <target state="translated">&lt;code&gt;random()&lt;/code&gt; 함수는 선형 합동 간단한 알고리즘을 사용한다. 빠르지 만 암호화 애플리케이션에는 적합하지 않습니다. 보다 안전한 대안 은 &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; 모듈을 참조하십시오 . 경우 &lt;code&gt;setseed()&lt;/code&gt; 라고, 이후의 결과 일련의 &lt;code&gt;random()&lt;/code&gt; 현재 세션의 호출에 의해 반복 될 수 재 발행 &lt;code&gt;setseed()&lt;/code&gt; 같은 인수와 함께.</target>
        </trans-unit>
        <trans-unit id="0231cb3d8ce00a0c5b86b501f35685f87444ba0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random&lt;/code&gt; function generates values using a uniform distribution, that is all the values are drawn within the specified range with equal probability. The &lt;code&gt;random_exponential&lt;/code&gt;, &lt;code&gt;random_gaussian&lt;/code&gt; and &lt;code&gt;random_zipfian&lt;/code&gt; functions require an additional double parameter which determines the precise shape of the distribution.</source>
          <target state="translated">&lt;code&gt;random&lt;/code&gt; 함수는 모든 값이 동일한 확률로 지정된 범위 내에 그려진 것이다 균일 분포를 이용하여 값을 생성한다. &lt;code&gt;random_exponential&lt;/code&gt; , &lt;code&gt;random_gaussian&lt;/code&gt; 및 &lt;code&gt;random_zipfian&lt;/code&gt; 함수 분포의 정확한 형상을 결정하는 추가 2 파라미터를 필요로한다.</target>
        </trans-unit>
        <trans-unit id="9c090601f4f464e87f2fbb4f8206fe29858dd81d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_match&lt;/code&gt; function returns a text array of captured substring(s) resulting from the first match of a POSIX regular expression pattern to a string. It has the syntax &lt;code&gt;regexp_match&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match, the result is &lt;code&gt;NULL&lt;/code&gt;. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains no parenthesized subexpressions, then the result is a single-element text array containing the substring matching the whole pattern. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains parenthesized subexpressions, then the result is a text array whose &lt;code&gt;n&lt;/code&gt;'th element is the substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the &lt;code&gt;pattern&lt;/code&gt; (not counting &amp;ldquo;non-capturing&amp;rdquo; parentheses; see below for details). The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Supported flags are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_match&lt;/code&gt; 의 기능 문자열로 POSIX 정규식 패턴의 제 매치의 결과 (S)의 촬상 서브 스트링 텍스트 배열을 반환한다. &lt;code&gt;regexp_match&lt;/code&gt; 구문 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ])이 있습니다. 일치하는 것이 없으면 결과는 &lt;code&gt;NULL&lt;/code&gt; 입니다. 일치하는 항목이 있고 &lt;code&gt;pattern&lt;/code&gt; 에 괄호로 묶인 하위 표현식이 없으면 결과는 전체 패턴과 일치하는 하위 문자열을 포함하는 단일 요소 텍스트 배열입니다. 일치하는 것이 있고 &lt;code&gt;pattern&lt;/code&gt; 에 괄호로 묶인 하위 표현식이 포함 된 경우 결과는 &lt;code&gt;n&lt;/code&gt; 번째 요소가 &lt;code&gt;n&lt;/code&gt; 과 일치하는 하위 문자열 인 텍스트 배열입니다. &lt;code&gt;pattern&lt;/code&gt; 의 괄호로 묶인 하위 표현 ( &quot;캡처하지 않는&quot;괄호를 세지 않음; 자세한 내용은 아래 참조) &lt;code&gt;flags&lt;/code&gt; 매개 변수는 함수의 동작을 변경 0 개 이상의 단일 문자 플래그를 포함한 옵션 텍스트 문자열입니다. 지원되는 플래그는 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="917f9f51cb17b9d6456a02068927d749ccdfe0f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_match&lt;/code&gt; function returns a text array of captured substring(s) resulting from the first match of a POSIX regular expression pattern to a string. It has the syntax &lt;code&gt;regexp_match&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match, the result is &lt;code&gt;NULL&lt;/code&gt;. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains no parenthesized subexpressions, then the result is a single-element text array containing the substring matching the whole pattern. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains parenthesized subexpressions, then the result is a text array whose &lt;code&gt;n&lt;/code&gt;'th element is the substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the &lt;code&gt;pattern&lt;/code&gt; (not counting &amp;ldquo;non-capturing&amp;rdquo; parentheses; see below for details). The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Supported flags are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_match&lt;/code&gt; 의 기능 문자열로 POSIX 정규식 패턴의 제 매치의 결과 (S)의 촬상 서브 스트링 텍스트 배열을 반환한다. &lt;code&gt;regexp_match&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]) 구문이 있습니다 . 일치하는 항목이 없으면 결과는 &lt;code&gt;NULL&lt;/code&gt; 입니다. 일치하는 항목이 있고 &lt;code&gt;pattern&lt;/code&gt; 에 괄호로 묶인 하위 표현식이없는 경우 결과는 전체 패턴과 일치하는 하위 문자열을 포함하는 단일 요소 텍스트 배열입니다. 일치하는 항목이 있고 &lt;code&gt;pattern&lt;/code&gt; 에 괄호로 묶인 하위 표현식이 포함 된 경우 결과는 &lt;code&gt;n&lt;/code&gt; 번째 요소가 &lt;code&gt;n&lt;/code&gt; 과 일치하는 하위 문자열 인 텍스트 배열입니다. &lt;code&gt;pattern&lt;/code&gt; 의 '번째 괄호로 묶인 하위 표현식 ( &quot;비 캡처&quot;괄호는 계산하지 않음. 자세한 내용은 아래 참조) &lt;code&gt;flags&lt;/code&gt; 매개 변수는 함수의 동작을 변경 0 개 이상의 단일 문자 플래그를 포함한 옵션 텍스트 문자열입니다. 지원되는 플래그는 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="91a9d1b88379c50aed0c3fa7f79c63d3f93f4473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_matches&lt;/code&gt; function returns a set of text arrays of captured substring(s) resulting from matching a POSIX regular expression pattern to a string. It has the same syntax as &lt;code&gt;regexp_match&lt;/code&gt;. This function returns no rows if there is no match, one row if there is a match and the &lt;code&gt;g&lt;/code&gt; flag is not given, or &lt;code&gt;N&lt;/code&gt; rows if there are &lt;code&gt;N&lt;/code&gt; matches and the &lt;code&gt;g&lt;/code&gt; flag is given. Each returned row is a text array containing the whole matched substring or the substrings matching parenthesized subexpressions of the &lt;code&gt;pattern&lt;/code&gt;, just as described above for &lt;code&gt;regexp_match&lt;/code&gt;. &lt;code&gt;regexp_matches&lt;/code&gt; accepts all the flags shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;, plus the &lt;code&gt;g&lt;/code&gt; flag which commands it to return all matches, not just the first one.</source>
          <target state="translated">&lt;code&gt;regexp_matches&lt;/code&gt; 는 복귀에게 문자열에 POSIX 정규식 패턴 매칭에 의한 촬상 스트링 (들)의 텍스트 배열 세트 기능한다. &lt;code&gt;regexp_match&lt;/code&gt; 와 동일한 구문을 갖습니다 . 이 일치하고있는 경우 일치하는, 하나 개의 행이없는 경우이 함수는 행을 반환하지 않습니다 &lt;code&gt;g&lt;/code&gt; 의 플래그가 지정되지 않았거나 &lt;code&gt;N&lt;/code&gt; 의 가있는 경우 행이 &lt;code&gt;N&lt;/code&gt; 의 일치와 &lt;code&gt;g&lt;/code&gt; 의 플래그가 지정됩니다. 반환 된 각 행은 위에서 설명한 &lt;code&gt;regexp_match&lt;/code&gt; 표현식 하위 문자열 또는 &lt;code&gt;pattern&lt;/code&gt; 의 괄호로 묶인 하위 표현식과 일치하는 하위 문자열을 포함하는 텍스트 배열 입니다. &lt;code&gt;regexp_matches&lt;/code&gt; 는 다음에 표시된 모든 플래그를 허용합니다.&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt; 과 &lt;code&gt;g&lt;/code&gt; 플래그는 첫 번째 항목뿐만 아니라 모든 일치 항목을 반환하도록 명령합니다.</target>
        </trans-unit>
        <trans-unit id="fe1481597a512367a1b4c46972878a08ea644086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_matches&lt;/code&gt; function returns a set of text arrays of captured substring(s) resulting from matching a POSIX regular expression pattern to a string. It has the same syntax as &lt;code&gt;regexp_match&lt;/code&gt;. This function returns no rows if there is no match, one row if there is a match and the &lt;code&gt;g&lt;/code&gt; flag is not given, or &lt;code&gt;N&lt;/code&gt; rows if there are &lt;code&gt;N&lt;/code&gt; matches and the &lt;code&gt;g&lt;/code&gt; flag is given. Each returned row is a text array containing the whole matched substring or the substrings matching parenthesized subexpressions of the &lt;code&gt;pattern&lt;/code&gt;, just as described above for &lt;code&gt;regexp_match&lt;/code&gt;. &lt;code&gt;regexp_matches&lt;/code&gt; accepts all the flags shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;, plus the &lt;code&gt;g&lt;/code&gt; flag which commands it to return all matches, not just the first one.</source>
          <target state="translated">&lt;code&gt;regexp_matches&lt;/code&gt; 는 복귀에게 문자열에 POSIX 정규식 패턴 매칭에 의한 촬상 스트링 (들)의 텍스트 배열 세트 기능한다. &lt;code&gt;regexp_match&lt;/code&gt; 와 동일한 구문을 사용 합니다. 이 일치하고있는 경우 일치하는, 하나 개의 행이없는 경우이 함수는 행을 반환하지 않습니다 &lt;code&gt;g&lt;/code&gt; 의 플래그가 지정되지 않았거나 &lt;code&gt;N&lt;/code&gt; 의 가있는 경우 행이 &lt;code&gt;N&lt;/code&gt; 의 일치와 &lt;code&gt;g&lt;/code&gt; 의 플래그가 지정됩니다. 반환 된 각 행은 &lt;code&gt;regexp_match&lt;/code&gt; 에 대해 위에서 설명한 것처럼 일치하는 전체 하위 문자열 또는 &lt;code&gt;pattern&lt;/code&gt; 의 괄호로 묶인 하위 식과 일치하는 하위 문자열을 포함하는 텍스트 배열 입니다. &lt;code&gt;regexp_matches&lt;/code&gt; 는 다음에 표시된 모든 플래그를 허용합니다.&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt; , 첫 번째 항목뿐 아니라 모든 일치 항목을 반환하도록 명령 하는 &lt;code&gt;g&lt;/code&gt; 플래그.</target>
        </trans-unit>
        <trans-unit id="a1d960616f19511c8709605bafb8561fb42fd92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_replace&lt;/code&gt; function provides substitution of new text for substrings that match POSIX regular expression patterns. It has the syntax &lt;code&gt;regexp_replace&lt;/code&gt;(&lt;code&gt;source&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt;, &lt;code&gt;replacement&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The &lt;code&gt;source&lt;/code&gt; string is returned unchanged if there is no match to the &lt;code&gt;pattern&lt;/code&gt;. If there is a match, the &lt;code&gt;source&lt;/code&gt; string is returned with the &lt;code&gt;replacement&lt;/code&gt; string substituted for the matching substring. The &lt;code&gt;replacement&lt;/code&gt; string can contain &lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is 1 through 9, to indicate that the source substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the pattern should be inserted, and it can contain &lt;code&gt;\&amp;amp;&lt;/code&gt; to indicate that the substring matching the entire pattern should be inserted. Write &lt;code&gt;\\&lt;/code&gt; if you need to put a literal backslash in the replacement text. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag &lt;code&gt;i&lt;/code&gt; specifies case-insensitive matching, while flag &lt;code&gt;g&lt;/code&gt; specifies replacement of each matching substring rather than only the first one. Supported flags (though not &lt;code&gt;g&lt;/code&gt;) are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_replace&lt;/code&gt; 함수는 POSIX 정규식 패턴과 일치 하는 서브 스트링의 새 텍스트 대체를 제공합니다. &lt;code&gt;regexp_replace&lt;/code&gt; 구문 ( &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; , &lt;code&gt;replacement&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ])이 있습니다. &lt;code&gt;source&lt;/code&gt; 받는 일치가없는 경우 문자열은 변경되지 반환 &lt;code&gt;pattern&lt;/code&gt; . 일치하는 것이 있으면 일치하는 하위 문자열을 &lt;code&gt;replacement&lt;/code&gt; 문자열로 대체 하여 &lt;code&gt;source&lt;/code&gt; 문자열을 반환합니다 . &lt;code&gt;replacement&lt;/code&gt; 문자열을 포함 할 수 있습니다 &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 은 여기서 &lt;code&gt;n&lt;/code&gt; 은패턴 의 &lt;code&gt;n&lt;/code&gt; 번째 괄호로 묶인 하위 표현식과 일치하는 소스 하위 문자열을 삽입해야 함 을 나타내려면 1에서 9까지이며 전체 패턴과 일치하는 하위 문자열을 삽입해야 함을 표시하기 위해 &lt;code&gt;\&amp;amp;&lt;/code&gt; 를 포함 할 수 있습니다 . 대체 텍스트에 리터럴 백 슬래시를 넣어야하는 경우 &lt;code&gt;\\&lt;/code&gt; 를 쓰십시오 . &lt;code&gt;flags&lt;/code&gt; 매개 변수는 함수의 동작을 변경 0 개 이상의 단일 문자 플래그를 포함한 옵션 텍스트 문자열입니다. 플래그 &lt;code&gt;i&lt;/code&gt; 는 대소 문자를 구분하지 않는 일치를 지정 하고 플래그 &lt;code&gt;g&lt;/code&gt; 는 첫 번째 문자열이 아닌 일치하는 각 하위 문자열의 대체를 지정합니다. 지원되는 플래그 ( &lt;code&gt;g&lt;/code&gt; 는 아님 )는 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3cb5e04335ea4e890ffa3045c20167ab432492" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_replace&lt;/code&gt; function provides substitution of new text for substrings that match POSIX regular expression patterns. It has the syntax &lt;code&gt;regexp_replace&lt;/code&gt;(&lt;code&gt;source&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt;, &lt;code&gt;replacement&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The &lt;code&gt;source&lt;/code&gt; string is returned unchanged if there is no match to the &lt;code&gt;pattern&lt;/code&gt;. If there is a match, the &lt;code&gt;source&lt;/code&gt; string is returned with the &lt;code&gt;replacement&lt;/code&gt; string substituted for the matching substring. The &lt;code&gt;replacement&lt;/code&gt; string can contain &lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is 1 through 9, to indicate that the source substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the pattern should be inserted, and it can contain &lt;code&gt;\&amp;amp;&lt;/code&gt; to indicate that the substring matching the entire pattern should be inserted. Write &lt;code&gt;\\&lt;/code&gt; if you need to put a literal backslash in the replacement text. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag &lt;code&gt;i&lt;/code&gt; specifies case-insensitive matching, while flag &lt;code&gt;g&lt;/code&gt; specifies replacement of each matching substring rather than only the first one. Supported flags (though not &lt;code&gt;g&lt;/code&gt;) are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_replace&lt;/code&gt; 기능은 POSIX 정규 표현식 패턴과 일치하는 문자열에 대한 새로운 텍스트의 대체를 제공합니다. &lt;code&gt;regexp_replace&lt;/code&gt; ( &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; , &lt;code&gt;replacement&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]) 구문이 있습니다 . &lt;code&gt;source&lt;/code&gt; 받는 일치가없는 경우 문자열은 변경되지 반환 &lt;code&gt;pattern&lt;/code&gt; . 일치하는 항목이 있으면 일치하는 하위 문자열을 &lt;code&gt;replacement&lt;/code&gt; 문자열로 대체 하여 &lt;code&gt;source&lt;/code&gt; 문자열이 반환됩니다 . &lt;code&gt;replacement&lt;/code&gt; 문자열을 포함 할 수 있습니다 &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 은 여기서 &lt;code&gt;n&lt;/code&gt; 은패턴 의 &lt;code&gt;n&lt;/code&gt; 번째 괄호로 묶인 하위 표현식과 일치하는 소스 하위 문자열 이 삽입되어야 함 을 나타 내기 위해 1에서 9까지이며 , 전체 패턴과 일치하는 하위 문자열이 삽입되어야 함을 나타 내기 위해 &lt;code&gt;\&amp;amp;&lt;/code&gt; 를 포함 할 수 있습니다 . 대체 텍스트에 리터럴 백 슬래시를 넣어야하는 경우 &lt;code&gt;\\&lt;/code&gt; 를 작성 하십시오. &lt;code&gt;flags&lt;/code&gt; 매개 변수는 함수의 동작을 변경 0 개 이상의 단일 문자 플래그를 포함한 옵션 텍스트 문자열입니다. 플래그 &lt;code&gt;i&lt;/code&gt; 는 대소 문자를 구분하지 않는 일치를 지정하는 반면 플래그 &lt;code&gt;g&lt;/code&gt; 는 첫 번째 문자열 만이 아닌 각 일치하는 부분 문자열의 대체를 지정합니다. 지원되는 플래그 ( &lt;code&gt;g&lt;/code&gt; 는 아님 )는 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c5dbc2991320b01f06b6978f16f854503224464" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_array&lt;/code&gt; function behaves the same as &lt;code&gt;regexp_split_to_table&lt;/code&gt;, except that &lt;code&gt;regexp_split_to_array&lt;/code&gt; returns its result as an array of &lt;code&gt;text&lt;/code&gt;. It has the syntax &lt;code&gt;regexp_split_to_array&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The parameters are the same as for &lt;code&gt;regexp_split_to_table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_split_to_array&lt;/code&gt; 기능과 같은 동작 &lt;code&gt;regexp_split_to_table&lt;/code&gt; 것을 제외 &lt;code&gt;regexp_split_to_array&lt;/code&gt; 는 배열로 그 결과를 돌려 &lt;code&gt;text&lt;/code&gt; . &lt;code&gt;regexp_split_to_array&lt;/code&gt; 구문 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ])이 있습니다. 매개 변수는 &lt;code&gt;regexp_split_to_table&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="8a5d6df08eb9f63de1570ffdc8142a19efaaf0c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_table&lt;/code&gt; function splits a string using a POSIX regular expression pattern as a delimiter. It has the syntax &lt;code&gt;regexp_split_to_table&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match to the &lt;code&gt;pattern&lt;/code&gt;, the function returns the &lt;code&gt;string&lt;/code&gt;. If there is at least one match, for each match it returns the text from the end of the last match (or the beginning of the string) to the beginning of the match. When there are no more matches, it returns the text from the end of the last match to the end of the string. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. &lt;code&gt;regexp_split_to_table&lt;/code&gt; supports the flags described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_split_to_table&lt;/code&gt; 함수는 구분 기호로 POSIX 정규 표현식 패턴을 사용하여 문자열을 분할합니다. &lt;code&gt;regexp_split_to_table&lt;/code&gt; 구문이 있습니다 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). &lt;code&gt;pattern&lt;/code&gt; 과 일치하지 않으면이 함수는 &lt;code&gt;string&lt;/code&gt; 반환 합니다 . 일치하는 항목이 하나 이상있는 경우 각 일치 할 때마다 마지막 일치의 끝 (또는 문자열의 시작)부터 일치의 시작까지 텍스트를 반환합니다. 더 이상 일치하는 항목이 없으면 마지막 일치의 끝에서 문자열의 끝까지 텍스트를 반환합니다. &lt;code&gt;flags&lt;/code&gt; parameter는 함수의 동작을 변경하는 0 개 이상의 단일 문자 플래그를 포함하는 선택적 텍스트 문자열입니다. &lt;code&gt;regexp_split_to_table&lt;/code&gt; 은 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23에&lt;/a&gt; 설명 된 플래그를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="bc3bede2eb66cdd78ca1dcbb5fb3f541be65acaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_table&lt;/code&gt; function splits a string using a POSIX regular expression pattern as a delimiter. It has the syntax &lt;code&gt;regexp_split_to_table&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match to the &lt;code&gt;pattern&lt;/code&gt;, the function returns the &lt;code&gt;string&lt;/code&gt;. If there is at least one match, for each match it returns the text from the end of the last match (or the beginning of the string) to the beginning of the match. When there are no more matches, it returns the text from the end of the last match to the end of the string. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. &lt;code&gt;regexp_split_to_table&lt;/code&gt; supports the flags described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_split_to_table&lt;/code&gt; 함수는 구분 기호로 POSIX 정규 표현식 패턴을 사용하여 문자열을 분할합니다. &lt;code&gt;regexp_split_to_table&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]) 구문이 있습니다 . &lt;code&gt;pattern&lt;/code&gt; 일치하는 항목이 없으면 함수는 &lt;code&gt;string&lt;/code&gt; 반환 합니다 . 일치하는 항목이 하나 이상있는 경우 각 일치 항목에 대해 마지막 일치 항목의 끝 (또는 문자열의 시작 부분)에서 일치 시작 부분까지의 텍스트를 반환합니다. 더 이상 일치하는 항목이 없으면 마지막 일치 항목의 끝부터 문자열 끝까지의 텍스트를 반환합니다. &lt;code&gt;flags&lt;/code&gt; 매개 변수는 함수의 동작을 변경하는 0 개 이상의 단일 문자 플래그를 포함하는 선택적 텍스트 문자열입니다. &lt;code&gt;regexp_split_to_table&lt;/code&gt; 은 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24에&lt;/a&gt; 설명 된 플래그를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9e8de7218b8205a5ca7a11a8952394be28359d1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rejectlong&lt;/code&gt; parameter specifies whether an overlength integer should be truncated or ignored. If &lt;code&gt;rejectlong&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), the dictionary returns the first &lt;code&gt;maxlen&lt;/code&gt; digits of the integer. If &lt;code&gt;rejectlong&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the dictionary treats an overlength integer as a stop word, so that it will not be indexed. Note that this also means that such an integer cannot be searched for.</source>
          <target state="translated">&lt;code&gt;rejectlong&lt;/code&gt; 매개 변수 는 길이 가 긴 정수의 잘림 또는 무시 여부를 지정합니다. 경우 &lt;code&gt;rejectlong&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; (기본), 사전 반환 처음 &lt;code&gt;maxlen&lt;/code&gt; 을 정수의 숫자. 경우 &lt;code&gt;rejectlong&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 사전 치료가 인덱싱되지 않도록하는 중지 단어로 과도 길이의 정수. 이것은 또한 그러한 정수를 검색 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5f7fc02f4398b9958b820fde1c0031fecdf666d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rows&lt;/code&gt; value is a little tricky because it is not the number of rows processed or scanned by the plan node, but rather the number emitted by the node. This is often less than the number scanned, as a result of filtering by any &lt;code&gt;WHERE&lt;/code&gt;-clause conditions that are being applied at the node. Ideally the top-level rows estimate will approximate the number of rows actually returned, updated, or deleted by the query.</source>
          <target state="translated">&lt;code&gt;rows&lt;/code&gt; 가 계획 노드에 의해 처리되거나 스캐닝 행 수 있지만, 오히려 노드 방출 수가 없기 때문에 값이 조금 까다 롭다. 이는 노드에서 적용되는 &lt;code&gt;WHERE&lt;/code&gt; 절 조건에 의해 필터링 된 결과 스캔되는 수보다 적은 경우가 많습니다 . 이상적으로 최상위 행 추정치는 쿼리에 의해 실제로 반환, 업데이트 또는 삭제 된 행 수에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="32edd13f077af046b2b71b1ee64a9b61285ac864" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seg&lt;/code&gt; module includes a GiST index operator class for &lt;code&gt;seg&lt;/code&gt; values. The operators supported by the GiST operator class are shown in &lt;a href=&quot;seg#SEG-GIST-OPERATORS&quot;&gt;Table F.28&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;seg&lt;/code&gt; 모듈 용 요지 지수 연산자 클래스 포함 &lt;code&gt;seg&lt;/code&gt; 값. GiST 연산자 클래스가 지원하는 연산자는 &lt;a href=&quot;seg#SEG-GIST-OPERATORS&quot;&gt;표 F.28&lt;/a&gt; 에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="060f961f6a4bd265394e2d5e72b7544d4d3d9777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;session_user&lt;/code&gt; is normally the user who initiated the current database connection; but superusers can change this setting with &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt;. The &lt;code&gt;current_user&lt;/code&gt; is the user identifier that is applicable for permission checking. Normally it is equal to the session user, but it can be changed with &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. It also changes during the execution of functions with the attribute &lt;code&gt;SECURITY DEFINER&lt;/code&gt;. In Unix parlance, the session user is the &amp;ldquo;real user&amp;rdquo; and the current user is the &amp;ldquo;effective user&amp;rdquo;. &lt;code&gt;current_role&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; are synonyms for &lt;code&gt;current_user&lt;/code&gt;. (The SQL standard draws a distinction between &lt;code&gt;current_role&lt;/code&gt; and &lt;code&gt;current_user&lt;/code&gt;, but PostgreSQL does not, since it unifies users and roles into a single kind of entity.)</source>
          <target state="translated">&lt;code&gt;session_user&lt;/code&gt; 일반적으로 현재 데이터베이스 연결을 시작한 사용자입니다; 그러나 수퍼 유저는 &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; 으로이 설정을 변경할 수 있습니다 . &lt;code&gt;current_user&lt;/code&gt; 권한 검사에 적용되는 사용자 식별자입니다. 일반적으로 세션 사용자와 동일하지만 &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 로 변경할 수 있습니다 . &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 속성을 가진 함수 실행 중에도 변경됩니다 . 유닉스 용어에서 세션 사용자는 &quot;실제 사용자&quot;이고 현재 사용자는 &quot;유효 사용자&quot;입니다. &lt;code&gt;current_role&lt;/code&gt; 및 &lt;code&gt;user&lt;/code&gt; 동의어입니다 &lt;code&gt;current_user&lt;/code&gt; . (SQL 표준은 &lt;code&gt;current_role&lt;/code&gt; 을 구별합니다.및 &lt;code&gt;current_user&lt;/code&gt; 는 기업의 하나의 종류로 사용자 및 역할을 통합하기 때문에,하지만, PostgreSQL는하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="2300a7ac4740013d2132caac3afdd183cf0cf9ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sestatus&lt;/code&gt; command allows you to check the status of SELinux. A typical display is:</source>
          <target state="translated">&lt;code&gt;sestatus&lt;/code&gt; 의 명령은 SELinux에의 상태를 확인할 수 있습니다. 일반적인 디스플레이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c1528675485f3ac22728a56ac6684f04d6015ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; setting is useful to have the instance ready at the exact replay point desired. The instance will still be able to replay more WAL records (and in fact will have to replay WAL records since the last checkpoint next time it is started).</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 설정은 원하는 정확한 재생 시점에서 인스턴스를 준비하는 데 유용합니다. 인스턴스는 여전히 더 많은 WAL 레코드를 재생할 수 있습니다 (실제로 다음에 시작될 때 체크 포인트 이후 WAL 레코드를 재생해야 함).</target>
        </trans-unit>
        <trans-unit id="0dfff4474b03b711fe3d607009c52f929707603f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simple&lt;/code&gt; dictionary template operates by converting the input token to lower case and checking it against a file of stop words. If it is found in the file then an empty array is returned, causing the token to be discarded. If not, the lower-cased form of the word is returned as the normalized lexeme. Alternatively, the dictionary can be configured to report non-stop-words as unrecognized, allowing them to be passed on to the next dictionary in the list.</source>
          <target state="translated">&lt;code&gt;simple&lt;/code&gt; 사전 템플릿 소문자로 입력 토큰 변환 중지 워드의 파일에 대해이를 확인하여 동작한다. 파일에서 발견되면 빈 배열이 반환되어 토큰이 삭제됩니다. 그렇지 않은 경우, 소문자 형태의 단어가 정규화 된 exeme으로 리턴됩니다. 또는 사전이 아닌 단어를 인식 할 수없는 것으로보고하여 사전을 목록의 다음 사전으로 전달하도록 사전을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="261a0b38493fc85b48b40ee18eb66df54582ef51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;soundex&lt;/code&gt; function converts a string to its Soundex code. The &lt;code&gt;difference&lt;/code&gt; function converts two strings to their Soundex codes and then reports the number of matching code positions. Since Soundex codes have four characters, the result ranges from zero to four, with zero being no match and four being an exact match. (Thus, the function is misnamed &amp;mdash; &lt;code&gt;similarity&lt;/code&gt; would have been a better name.)</source>
          <target state="translated">&lt;code&gt;soundex&lt;/code&gt; 함수는 Soundex와 코드를 문자열로 변환합니다. &lt;code&gt;difference&lt;/code&gt; 함수 변환 한 다음 그 두 Soundex와 코드와 문자열과 코드 위치 일치의 수를보고한다. Soundex 코드에는 4 개의 문자가 있으므로 결과 범위는 0에서 4까지이며 0은 일치하지 않으며 4는 정확히 일치합니다. (따라서 기능의 이름이 잘못 되었습니다. &lt;code&gt;similarity&lt;/code&gt; 이 더 나은 이름이었을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="09ea80f1981124188490dc9028b6ab305b1bc451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sql_standard&lt;/code&gt; style produces output that conforms to the SQL standard's specification for interval literal strings, if the interval value meets the standard's restrictions (either year-month only or day-time only, with no mixing of positive and negative components). Otherwise the output looks like a standard year-month literal string followed by a day-time literal string, with explicit signs added to disambiguate mixed-sign intervals.</source>
          <target state="translated">&lt;code&gt;sql_standard&lt;/code&gt; 스타일은 출력을 생성하는 간격 리터럴 문자열에 대한 SQL 표준의 사양을 준수, 간격 값이 (긍정적이고 부정적인 요소없이 혼합하여 하나 만 년 - 월 또는 일 - 시간 만) 표준의 제한을 충족하는 경우. 그렇지 않으면 출력은 표준 년 월 리터럴 문자열 다음에 주간 리터럴 문자열이 표시되며 혼합 부호 간격을 명확하게하기 위해 명시 적 부호가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7f1517c885d0f9ba998151ca37f036c0bd997847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sslinfo&lt;/code&gt; module provides information about the SSL certificate that the current client provided when connecting to PostgreSQL. The module is useless (most functions will return NULL) if the current connection does not use SSL.</source>
          <target state="translated">&lt;code&gt;sslinfo&lt;/code&gt; 의 모듈은 PostgreSQL을 연결할 때 현재의 클라이언트가 제공하는 SSL 인증서에 대한 정보를 제공합니다. 현재 연결에서 SSL을 사용하지 않으면 모듈이 쓸모가 없습니다 (대부분의 함수는 NULL을 반환 함).</target>
        </trans-unit>
        <trans-unit id="0d9a65154d6a387434a029c400053d901ea5349c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;storage&lt;/code&gt; parameter allows selection of storage strategies for variable-length data types. (Only &lt;code&gt;plain&lt;/code&gt; is allowed for fixed-length types.) &lt;code&gt;plain&lt;/code&gt; specifies that data of the type will always be stored in-line and not compressed. &lt;code&gt;extended&lt;/code&gt; specifies that the system will first try to compress a long data value, and will move the value out of the main table row if it's still too long. &lt;code&gt;external&lt;/code&gt; allows the value to be moved out of the main table, but the system will not try to compress it. &lt;code&gt;main&lt;/code&gt; allows compression, but discourages moving the value out of the main table. (Data items with this storage strategy might still be moved out of the main table if there is no other way to make a row fit, but they will be kept in the main table preferentially over &lt;code&gt;extended&lt;/code&gt; and &lt;code&gt;external&lt;/code&gt; items.)</source>
          <target state="translated">&lt;code&gt;storage&lt;/code&gt; 파라미터는 가변 길이 데이터 유형 스토리지 전략을 선택할 수있다. 고정 길이 유형에는 &lt;code&gt;plain&lt;/code&gt; 만 허용됩니다. &lt;code&gt;plain&lt;/code&gt; 은 유형의 데이터가 항상 인라인으로 저장되고 압축되지 않도록 지정합니다. &lt;code&gt;extended&lt;/code&gt; 는 시스템이 먼저 긴 데이터 값을 압축하려고 시도하고 여전히 너무 긴 경우 기본 테이블 행 밖으로 값을 이동하도록 지정합니다. &lt;code&gt;external&lt;/code&gt; 을 사용하면 값을 기본 테이블 밖으로 이동할 수 있지만 시스템은 압축을 시도하지 않습니다. &lt;code&gt;main&lt;/code&gt; 압축을 허용하지만 주 테이블에서 값을 이동하지 않는 것이 좋습니다. (이 스토리지 전략을 사용하는 데이터 항목은 행을 맞추는 다른 방법이없는 경우 여전히 기본 테이블에서 이동 될 수 있지만 &lt;code&gt;extended&lt;/code&gt; 및 &lt;code&gt;external&lt;/code&gt; 항목 보다 우선적으로 기본 테이블에 유지 됩니다.)</target>
        </trans-unit>
        <trans-unit id="17d900c212bdba8eb8ed8106792c420e1bbe3e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;substring&lt;/code&gt; function with three parameters provides extraction of a substring that matches an SQL regular expression pattern. The function can be written according to SQL99 syntax:</source>
          <target state="translated">세 개의 매개 변수가 있는 &lt;code&gt;substring&lt;/code&gt; 함수는 SQL 정규식 패턴과 일치하는 서브 스트링 추출을 제공합니다. SQL99 구문에 따라 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07c583000c12edad2a23f1677f8c511b9802bf22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;substring&lt;/code&gt; function with two parameters, &lt;code&gt;substring(string from pattern)&lt;/code&gt;, provides extraction of a substring that matches a POSIX regular expression pattern. It returns null if there is no match, otherwise the portion of the text that matched the pattern. But if the pattern contains any parentheses, the portion of the text that matched the first parenthesized subexpression (the one whose left parenthesis comes first) is returned. You can put parentheses around the whole expression if you want to use parentheses within it without triggering this exception. If you need parentheses in the pattern before the subexpression you want to extract, see the non-capturing parentheses described below.</source>
          <target state="translated">&lt;code&gt;substring(string from pattern)&lt;/code&gt; 이라는 두 개의 매개 변수가 있는 &lt;code&gt;substring&lt;/code&gt; 함수 는 POSIX 정규식 패턴과 일치하는 부분 문자열의 추출을 제공합니다. 일치하지 않으면 null을 반환하고 그렇지 않으면 패턴과 일치하는 텍스트 부분을 반환합니다. 그러나 패턴에 괄호가 포함되어 있으면 첫 번째 괄호로 묶인 하위 표현식 (왼쪽 괄호가 먼저 오는 부분)과 일치하는 텍스트 부분이 반환됩니다. 이 예외를 유발하지 않고 괄호를 사용하려면 전체 표현식을 괄호로 묶을 수 있습니다. 추출하려는 하위 표현식 이전에 패턴에 괄호가 필요한 경우 아래에 설명 된 비 캡처 괄호를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6de727710530de8b72a4404a0cd48c771eb547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;synonym&lt;/code&gt; template also has an optional parameter &lt;code&gt;CaseSensitive&lt;/code&gt;, which defaults to &lt;code&gt;false&lt;/code&gt;. When &lt;code&gt;CaseSensitive&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, words in the synonym file are folded to lower case, as are input tokens. When it is &lt;code&gt;true&lt;/code&gt;, words and tokens are not folded to lower case, but are compared as-is.</source>
          <target state="translated">&lt;code&gt;synonym&lt;/code&gt; 템플릿은 또한 선택적 매개 변수가 &lt;code&gt;CaseSensitive&lt;/code&gt; , 기본값은 &lt;code&gt;false&lt;/code&gt; . 경우 &lt;code&gt;CaseSensitive&lt;/code&gt; 있다 &lt;code&gt;false&lt;/code&gt; , 동의어 파일 단어로서 입력 토큰이고, 소문자로 절첩되어있다. 이 경우 &lt;code&gt;true&lt;/code&gt; 단어와 토큰은 소문자로 절첩되지 않고 그대로 비교된다.</target>
        </trans-unit>
        <trans-unit id="c07e672b3264d398cb9ebee058a21feb90ad8f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_len&lt;/code&gt; will always be greater than the sum of the &lt;code&gt;tuple_len&lt;/code&gt;, &lt;code&gt;dead_tuple_len&lt;/code&gt; and &lt;code&gt;free_space&lt;/code&gt;. The difference is accounted for by fixed page overhead, the per-page table of pointers to tuples, and padding to ensure that tuples are correctly aligned.</source>
          <target state="translated">&lt;code&gt;table_len&lt;/code&gt; 는 항상의 합보다 클 것이다 &lt;code&gt;tuple_len&lt;/code&gt; , &lt;code&gt;dead_tuple_len&lt;/code&gt; 및 &lt;code&gt;free_space&lt;/code&gt; . 차이점은 고정 페이지 오버 헤드, 튜플에 대한 페이지 당 포인터 테이블 및 튜플이 올바르게 정렬되도록 패딩으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f00658cdbd1a37668746a630df6795de40f40a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablefunc&lt;/code&gt; module includes various functions that return tables (that is, multiple rows). These functions are useful both in their own right and as examples of how to write C functions that return multiple rows.</source>
          <target state="translated">&lt;code&gt;tablefunc&lt;/code&gt; 의 모듈은 다양한 기능이 반송 테이블 (인 여러 행)를 포함한다. 이러한 함수는 자체적으로 유용하며 여러 행을 반환하는 C 함수를 작성하는 방법의 예로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9cdf44adfa31acc1639b19ed48b2eb69211df790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new materialized view is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 새로운 구체화 된 뷰가 작성 될 테이블 스페이스의 이름입니다. 지정하지 않으면 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 가 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ab317f2006a81d25a82a98e87d5a85e8a273f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new table is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 새로운 테이블이 작성되는 테이블 스페이스의 이름입니다. 지정하지 않으면 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 를 참조하거나 테이블이 임시 인 경우 &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="f686e75d0e393aa19100c981a93d00a43780aed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new table is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary. For partitioned tables, since no storage is required for the table itself, the tablespace specified overrides &lt;code&gt;default_tablespace&lt;/code&gt; as the default tablespace to use for any newly created partitions when no other tablespace is explicitly specified.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 새로운 테이블이 작성되는 테이블 스페이스의 이름입니다. 지정하지 않으면 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 를 참조하거나 테이블이 임시 인 경우 &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces를&lt;/a&gt; 참조 하십시오. 파티션 된 테이블의 경우 테이블 자체에 스토리지가 필요하지 않기 때문에 지정된 테이블 스페이스는 &lt;code&gt;default_tablespace&lt;/code&gt; 를 다른 테이블 스페이스가 명시 적으로 지정되지 않은 경우 새로 작성된 파티션에 사용할 기본 테이블 스페이스로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="0b4265a037b613093215c3a2b0f1964512919269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tcn&lt;/code&gt; module provides a trigger function that notifies listeners of changes to any table on which it is attached. It must be used as an &lt;code&gt;AFTER&lt;/code&gt; trigger &lt;code&gt;FOR EACH ROW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tcn&lt;/code&gt; 모듈은 트리거 기능을 제공가 장착되어있는 모든 테이블의 변경 통지 리스너있다. &lt;code&gt;FOR EACH ROW&lt;/code&gt; &lt;code&gt;AFTER&lt;/code&gt; 트리거 로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="17aaa8650f37c6cdde06430e667abefb0767b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_char&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;to_char&lt;/code&gt; 기능의 가족</target>
        </trans-unit>
        <trans-unit id="e895ae79ff8443b98ab632e79a7fde4140eb2a9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_regclass&lt;/code&gt;, &lt;code&gt;to_regproc&lt;/code&gt;, &lt;code&gt;to_regprocedure&lt;/code&gt;, &lt;code&gt;to_regoper&lt;/code&gt;, &lt;code&gt;to_regoperator&lt;/code&gt;, &lt;code&gt;to_regtype&lt;/code&gt;, &lt;code&gt;to_regnamespace&lt;/code&gt;, and &lt;code&gt;to_regrole&lt;/code&gt; functions translate relation, function, operator, type, schema, and role names (given as &lt;code&gt;text&lt;/code&gt;) to objects of type &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, and &lt;code&gt;regrole&lt;/code&gt; respectively. These functions differ from a cast from text in that they don't accept a numeric OID, and that they return null rather than throwing an error if the name is not found (or, for &lt;code&gt;to_regproc&lt;/code&gt; and &lt;code&gt;to_regoper&lt;/code&gt;, if the given name matches multiple objects).</source>
          <target state="translated">&lt;code&gt;to_regclass&lt;/code&gt; , &lt;code&gt;to_regproc&lt;/code&gt; , &lt;code&gt;to_regprocedure&lt;/code&gt; , &lt;code&gt;to_regoper&lt;/code&gt; , &lt;code&gt;to_regoperator&lt;/code&gt; , &lt;code&gt;to_regtype&lt;/code&gt; , &lt;code&gt;to_regnamespace&lt;/code&gt; 및 &lt;code&gt;to_regrole&lt;/code&gt; 함수 (같이 주어진 관계 함수 운영자 입력, 스키마 및 역할 이름 번역 &lt;code&gt;text&lt;/code&gt; 형식의 개체) &lt;code&gt;regclass&lt;/code&gt; 형 , &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoper&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; 을 , &lt;code&gt;regtype&lt;/code&gt; , &lt;code&gt;regnamespace&lt;/code&gt; 및 &lt;code&gt;regrole&lt;/code&gt; 각기. 이러한 함수는 숫자 OID를 허용하지 않으며 이름을 찾을 수없는 경우 (또는 주어진 이름이 여러 객체와 일치하는 경우 &lt;code&gt;to_regproc&lt;/code&gt; 및 &lt;code&gt;to_regoper&lt;/code&gt; 의 경우) 오류를 발생시키지 않고 null을 반환한다는 점에서 텍스트 캐스트 와 다릅니다 . ).</target>
        </trans-unit>
        <trans-unit id="9bc966f611788c95433ef51cb7b635ecd99368eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_tsvector&lt;/code&gt; function internally calls a parser which breaks the document text into tokens and assigns a type to each token. For each token, a list of dictionaries (&lt;a href=&quot;textsearch-dictionaries&quot;&gt;Section 12.6&lt;/a&gt;) is consulted, where the list can vary depending on the token type. The first dictionary that &lt;em&gt;recognizes&lt;/em&gt; the token emits one or more normalized &lt;em&gt;lexemes&lt;/em&gt; to represent the token. For example, &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt; because one of the dictionaries recognized that the word &lt;code&gt;rats&lt;/code&gt; is a plural form of &lt;code&gt;rat&lt;/code&gt;. Some words are recognized as &lt;em&gt;stop words&lt;/em&gt; (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;), which causes them to be ignored since they occur too frequently to be useful in searching. In our example these are &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;it&lt;/code&gt;. If no dictionary in the list recognizes the token then it is also ignored. In this example that happened to the punctuation sign &lt;code&gt;-&lt;/code&gt; because there are in fact no dictionaries assigned for its token type (&lt;code&gt;Space symbols&lt;/code&gt;), meaning space tokens will never be indexed. The choices of parser, dictionaries and which types of tokens to index are determined by the selected text search configuration (&lt;a href=&quot;textsearch-configuration&quot;&gt;Section 12.7&lt;/a&gt;). It is possible to have many different configurations in the same database, and predefined configurations are available for various languages. In our example we used the default configuration &lt;code&gt;english&lt;/code&gt; for the English language.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; 의 기능은 내부적으로 토큰으로 문서 텍스트를 중단하고 각 토큰 유형을 할당하는 파서를 호출합니다. 각 토큰에 대해 사전 목록 ( &lt;a href=&quot;textsearch-dictionaries&quot;&gt;12.6 절&lt;/a&gt; )을 참조하면 토큰 유형에 따라 목록이 다를 수 있습니다. 토큰 을 &lt;em&gt;인식&lt;/em&gt; 하는 첫 번째 사전 은 토큰 을 나타 내기 위해 하나 이상의 정규화 된 &lt;em&gt;렉스&lt;/em&gt; 를 방출 합니다. 예를 들어, &lt;code&gt;rats&lt;/code&gt; 가되었다 &lt;code&gt;rat&lt;/code&gt; 사전의 중 하나가 단어 것으로 인식하기 때문에 &lt;code&gt;rats&lt;/code&gt; 의 복수 형태이다 &lt;code&gt;rat&lt;/code&gt; . 일부 단어는 &lt;em&gt;중지&lt;/em&gt; 단어로 인식됩니다 ( &lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;12.6.1 단원)&lt;/a&gt;)가 너무 자주 발생하여 검색에 유용하지 않으므로 무시됩니다. 이 예에서 이들은 , &lt;code&gt;on&lt;/code&gt; , 그리고 &lt;code&gt;it&lt;/code&gt; . 목록에서 사전을 인식하지 못하면 토큰도 무시됩니다. 구두점 기호에게 무슨 일이 예에서 &lt;code&gt;-&lt;/code&gt; 그 토큰 유형에 할당 된 사전 (사실이 없기 때문에 &lt;code&gt;Space symbols&lt;/code&gt; ), 즉 공간 토큰은 인덱싱되지 않습니다. 파서, 사전 및 색인을 생성 할 토큰의 선택은 선택한 텍스트 검색 구성에 따라 결정됩니다 ( &lt;a href=&quot;textsearch-configuration&quot;&gt;섹션 12.7)&lt;/a&gt; &lt;code&gt;a&lt;/code&gt; ). 동일한 데이터베이스에서 다양한 구성을 수행 할 수 있으며 다양한 언어에 대해 사전 정의 된 구성을 사용할 수 있습니다. 이 예에서는 &lt;code&gt;english&lt;/code&gt; 에 기본 구성 영어 를 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="25a8b2b35ba5bb7ac691f2af5d9013c610a29764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_lexize&lt;/code&gt; function expects a single &lt;em&gt;token&lt;/em&gt;, not text. Here is a case where this can be confusing:</source>
          <target state="translated">&lt;code&gt;ts_lexize&lt;/code&gt; 의 기능은 하나의 기대 &lt;em&gt;토큰&lt;/em&gt; , 텍스트가 아닌. 혼동 될 수있는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="414a4e254a9e67a84663f59263f88c95c42cfbfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_lexize&lt;/code&gt; function facilitates dictionary testing.</source>
          <target state="translated">&lt;code&gt;ts_lexize&lt;/code&gt; 의 기능은 사전 테스트를 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="4acca59985cbdc80cca43fe97ac114ac2ea61d90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_rewrite&lt;/code&gt; family of functions search a given &lt;code&gt;tsquery&lt;/code&gt; for occurrences of a target subquery, and replace each occurrence with a substitute subquery. In essence this operation is a &lt;code&gt;tsquery&lt;/code&gt;-specific version of substring replacement. A target and substitute combination can be thought of as a &lt;em&gt;query rewrite rule&lt;/em&gt;. A collection of such rewrite rules can be a powerful search aid. For example, you can expand the search using synonyms (e.g., &lt;code&gt;new york&lt;/code&gt;, &lt;code&gt;big apple&lt;/code&gt;, &lt;code&gt;nyc&lt;/code&gt;, &lt;code&gt;gotham&lt;/code&gt;) or narrow the search to direct the user to some hot topic. There is some overlap in functionality between this feature and thesaurus dictionaries (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;). However, you can modify a set of rewrite rules on-the-fly without reindexing, whereas updating a thesaurus requires reindexing to be effective.</source>
          <target state="translated">&lt;code&gt;ts_rewrite&lt;/code&gt; 의 계열의 함수는 주어진 검색 &lt;code&gt;tsquery&lt;/code&gt; 타겟 부질의 발생을위한, 그리고 대체 부질 각 항목을 바꾸. 본질적으로이 작업은 &lt;code&gt;tsquery&lt;/code&gt; 특정 버전의 부분 문자열 대체입니다. 대상 및 대체 조합은 &lt;em&gt;쿼리 다시 쓰기 규칙&lt;/em&gt; 으로 생각할 수 있습니다 . 이러한 재 작성 규칙 모음은 강력한 검색 지원이 될 수 있습니다. 예를 들어 동의어 (예 : &lt;code&gt;new york&lt;/code&gt; , &lt;code&gt;big apple&lt;/code&gt; , &lt;code&gt;nyc&lt;/code&gt; , &lt;code&gt;gotham&lt;/code&gt; )를 사용하여 검색을 확장하거나 검색 범위를 좁혀서 사용자를 인기 주제로 안내 할 수 있습니다. 이 기능과 동의어 사전 사전간에 기능이 일부 겹칩니다 (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;섹션 12.6.4&lt;/a&gt; ). 그러나 재 인덱싱 없이도 즉시 재 작성 규칙 세트를 수정할 수 있지만 동의어 사전을 업데이트하려면 재 인덱싱이 효과적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f5ce57d748f7a336aa1b84fb89aaf298351d6555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsm_system_rows&lt;/code&gt; module provides the table sampling method &lt;code&gt;SYSTEM_ROWS&lt;/code&gt;, which can be used in the &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause of a &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;tsm_system_rows&lt;/code&gt; 용 모듈에있어서 샘플링 테이블 제공 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 에서 사용될 수 &lt;code&gt;TABLESAMPLE&lt;/code&gt; 의 (A)의 절 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="ec2660bd7bfa7364869659c121d8520debb99419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsm_system_time&lt;/code&gt; module provides the table sampling method &lt;code&gt;SYSTEM_TIME&lt;/code&gt;, which can be used in the &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause of a &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;tsm_system_time&lt;/code&gt; 의 모듈은 테이블 추출법에 제공 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; 에서 사용될 수 &lt;code&gt;TABLESAMPLE&lt;/code&gt; 의 (A)의 절 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="390aa178cbfa17e56fd10d81213ce2e7d202995c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsquery&lt;/code&gt; containment operators consider only the lexemes listed in the two queries, ignoring the combining operators.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 의 포함 연산자는 결합 연산자를 무시하고 두 개의 쿼리에 나열에만 어휘를 고려한다.</target>
        </trans-unit>
        <trans-unit id="d94003b7d5e3893485cdec1b88bc0aea54d3d7f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsvector&lt;/code&gt; concatenation operator returns a vector which combines the lexemes and positional information of the two vectors given as arguments. Positions and weight labels are retained during the concatenation. Positions appearing in the right-hand vector are offset by the largest position mentioned in the left-hand vector, so that the result is nearly equivalent to the result of performing &lt;code&gt;to_tsvector&lt;/code&gt; on the concatenation of the two original document strings. (The equivalence is not exact, because any stop-words removed from the end of the left-hand argument will not affect the result, whereas they would have affected the positions of the lexemes in the right-hand argument if textual concatenation were used.)</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 의 연결 연산자는 어휘 및 인수로 주어진 두 벡터의 위치 정보를 결합한 벡터를 리턴한다. 연결하는 동안 위치 및 무게 레이블이 유지됩니다. 오른쪽 벡터에 나타나는 위치는 왼쪽 벡터에 언급 된 가장 큰 위치로 오프셋되므로 결과는 두 원본 문서 문자열의 연결에서 &lt;code&gt;to_tsvector&lt;/code&gt; 를 수행 한 결과와 거의 같습니다 . (왼쪽 인수의 끝에서 제거 된 모든 단어는 결과에 영향을 미치지 않지만 텍스트 연결이 사용 된 경우 오른쪽 인수의 렉 세스 위치에 영향을 주었으므로 동등성은 정확하지 않습니다. )</target>
        </trans-unit>
        <trans-unit id="64e34183b8dfafa188cf43b0a5c4b0041a97f2d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unaccent()&lt;/code&gt; function removes accents (diacritic signs) from a given string. Basically, it's a wrapper around &lt;code&gt;unaccent&lt;/code&gt;-type dictionaries, but it can be used outside normal text search contexts.</source>
          <target state="translated">&lt;code&gt;unaccent()&lt;/code&gt; 함수는 주어진 문자열에서 액센트 (분음 부호)를 제거합니다. 기본적으로 이것은 &lt;code&gt;unaccent&lt;/code&gt; 유형 사전 의 래퍼 이지만 일반 텍스트 검색 컨텍스트 외부에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb54fa28d01791fcb6f7f658cdfdf7f9c3926fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;lower&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt; functions</source>
          <target state="translated">은 &lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , 및 &lt;code&gt;initcap&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="dae2537a13fb0c8fd0778a9239206e8184aecf1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uuid-ossp&lt;/code&gt; module provides functions to generate universally unique identifiers (UUIDs) using one of several standard algorithms. There are also functions to produce certain special UUID constants.</source>
          <target state="translated">&lt;code&gt;uuid-ossp&lt;/code&gt; 모듈은 여러 표준 알고리즘 중 하나를 사용하여 범용 고유 식별자 (UUID를)를 생성하는 기능을 제공한다. 특정 특수 UUID 상수를 생성하는 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95603d31ddd956bbf48efc32f974f08b4573811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uuid-ossp&lt;/code&gt; module provides functions to generate universally unique identifiers (UUIDs) using one of several standard algorithms. There are also functions to produce certain special UUID constants. This module is only necessary for special requirements beyond what is available in core PostgreSQL. See &lt;a href=&quot;functions-uuid&quot;&gt;Section 9.14&lt;/a&gt; for built-in ways to generate UUIDs.</source>
          <target state="translated">&lt;code&gt;uuid-ossp&lt;/code&gt; 모듈은 여러 표준 알고리즘 중 하나를 사용하여 범용 고유 식별자 (UUID를)를 생성하는 기능을 제공한다. 특정 특수 UUID 상수를 생성하는 함수도 있습니다. 이 모듈은 핵심 PostgreSQL에서 사용할 수있는 것 이상의 특별한 요구 사항에만 필요합니다. UUID를 생성하는 기본 제공 방법 은 &lt;a href=&quot;functions-uuid&quot;&gt;섹션 9.14&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c33dc4b6b3f3d4e4e7276aab8066c7be89f11d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; must be a number. In general, the higher the number the more borders and lines the tables will have, but details depend on the particular format. In HTML format, this will translate directly into the &lt;code&gt;border=...&lt;/code&gt; attribute. In most other formats only values 0 (no border), 1 (internal dividing lines), and 2 (table frame) make sense, and values above 2 will be treated the same as &lt;code&gt;border = 2&lt;/code&gt;. The &lt;code&gt;latex&lt;/code&gt; and &lt;code&gt;latex-longtable&lt;/code&gt; formats additionally allow a value of 3 to add dividing lines between data rows.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 숫자 여야합니다. 일반적으로 숫자가 많을수록 테이블의 테두리와 선이 많아 지지만 세부 사항은 특정 형식에 따라 다릅니다. HTML 형식에서는 &lt;code&gt;border=...&lt;/code&gt; 속성 으로 직접 변환됩니다 . 대부분의 다른 형식에서는 값 0 (경계선 없음), 1 (내부 분할 선) 및 2 (테이블 프레임) 만 의미가 있으며 2보다 큰 값은 &lt;code&gt;border = 2&lt;/code&gt; 와 동일하게 취급됩니다 . &lt;code&gt;latex&lt;/code&gt; 및 &lt;code&gt;latex-longtable&lt;/code&gt; 형식 별도로 3의 값이 데이터 행 사이의 구분선에 추가 할 수있다.</target>
        </trans-unit>
        <trans-unit id="2ed006ed7919dad8517461e6b9bbcdfb9261bd7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait_event&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; columns are independent. If a backend is in the &lt;code&gt;active&lt;/code&gt; state, it may or may not be &lt;code&gt;waiting&lt;/code&gt; on some event. If the state is &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;wait_event&lt;/code&gt; is non-null, it means that a query is being executed, but is being blocked somewhere in the system.</source>
          <target state="translated">&lt;code&gt;wait_event&lt;/code&gt; 및 &lt;code&gt;state&lt;/code&gt; 열은 독립적이다. 백엔드가 &lt;code&gt;active&lt;/code&gt; 상태 인 경우 일부 이벤트를 &lt;code&gt;waiting&lt;/code&gt; 거나 대기 하지 않을 수 있습니다 . 상태가 &lt;code&gt;active&lt;/code&gt; 이고 &lt;code&gt;wait_event&lt;/code&gt; 가 널이 아닌 경우, 쿼리가 실행되고 있지만 시스템 어딘가에서 차단되고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0125e5f4ec341f59b7fbf88d54a9be3ac7c60904" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml2&lt;/code&gt; module provides XPath querying and XSLT functionality.</source>
          <target state="translated">&lt;code&gt;xml2&lt;/code&gt; 의 모듈의 XPath 쿼리 및 XSLT 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b8ee7c238579a8efef3d1bbe76947df3fd98bf79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type can be used to store XML data. Its advantage over storing XML data in a &lt;code&gt;text&lt;/code&gt; field is that it checks the input values for well-formedness, and there are support functions to perform type-safe operations on it; see &lt;a href=&quot;functions-xml&quot;&gt;Section 9.14&lt;/a&gt;. Use of this data type requires the installation to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 형식은 XML 데이터를 저장하는 데 사용할 수 있습니다. &lt;code&gt;text&lt;/code&gt; 필드 에 XML 데이터를 저장하는 것의 장점 은 입력 값의 형식이 올바른지 확인하고 형식 안전 연산을 수행하는 지원 기능이 있다는 것입니다. &lt;a href=&quot;functions-xml&quot;&gt;섹션 9.14&lt;/a&gt; 참조 . 이 데이터 유형을 사용하려면 &lt;code&gt;configure --with-libxml&lt;/code&gt; 로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d41c5328e583aaf8b442d8bd12b244d54695c64b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type can be used to store XML data. Its advantage over storing XML data in a &lt;code&gt;text&lt;/code&gt; field is that it checks the input values for well-formedness, and there are support functions to perform type-safe operations on it; see &lt;a href=&quot;functions-xml&quot;&gt;Section 9.15&lt;/a&gt;. Use of this data type requires the installation to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 형식은 XML 데이터를 저장하는 데 사용할 수 있습니다. XML 데이터를 &lt;code&gt;text&lt;/code&gt; 필드 에 저장하는 것보다 장점 은 입력 값의 형식이 올바른지 확인하고 형식에 안전한 작업을 수행하는 지원 기능이 있다는 것입니다. &lt;a href=&quot;functions-xml&quot;&gt;9.15 항을&lt;/a&gt; 참조하십시오 . 이 데이터 유형을 사용하려면 &lt;code&gt;configure --with-libxml&lt;/code&gt; 을 사용하여 설치를 빌드해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="e872bad693cf86fd556718feb449776c1f39b558" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type is unusual in that it does not provide any comparison operators. This is because there is no well-defined and universally useful comparison algorithm for XML data. One consequence of this is that you cannot retrieve rows by comparing an &lt;code&gt;xml&lt;/code&gt; column against a search value. XML values should therefore typically be accompanied by a separate key field such as an ID. An alternative solution for comparing XML values is to convert them to character strings first, but note that character string comparison has little to do with a useful XML comparison method.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 형식은 어떤 비교 연산자를 제공하지 않는다는 점에서 특별하다. XML 데이터에 대해 잘 정의되고 보편적으로 유용한 비교 알고리즘이 없기 때문입니다. 그 결과 &lt;code&gt;xml&lt;/code&gt; 열을 검색 값 과 비교하여 행을 검색 할 수 없습니다 . 따라서 XML 값에는 일반적으로 ID와 같은 별도의 키 필드가 수반되어야합니다. XML 값을 비교하는 대체 솔루션은 먼저 값을 문자열로 변환하는 것이지만 문자열 비교는 유용한 XML 비교 방법과 관련이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="59e179d52ab69f7b0f66292f2459b29798716de6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; type can store well-formed &amp;ldquo;documents&amp;rdquo;, as defined by the XML standard, as well as &amp;ldquo;content&amp;rdquo; fragments, which are defined by reference to the more permissive &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode&quot;&gt;&amp;ldquo;document node&amp;rdquo;&lt;/a&gt; of the XQuery and XPath data model. Roughly, this means that content fragments can have more than one top-level element or character node. The expression &lt;code&gt;xmlvalue IS DOCUMENT&lt;/code&gt; can be used to evaluate whether a particular &lt;code&gt;xml&lt;/code&gt; value is a full document or only a content fragment.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 더 관대 참조하여 정의 된 XML 표준뿐만 아니라, &quot;콘텐츠&quot;단편으로 정의 된 타입은, &quot;문서&quot;잘 형성된 저장할 수있는 &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode&quot;&gt;&quot;문서 노드&quot;&lt;/a&gt; XQuery에 및 XPath는 데이터 모델. 대략 이것은 콘텐츠 조각에 둘 이상의 최상위 요소 또는 문자 노드가있을 수 있음을 의미합니다. &lt;code&gt;xmlvalue IS DOCUMENT&lt;/code&gt; 표현식을 사용하여 특정 &lt;code&gt;xml&lt;/code&gt; 값이 전체 문서인지 컨텐츠 조각 인지를 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70fece117905c5ca56558a0c032db75b892af97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; type does not validate input values against a document type declaration (DTD), even when the input value specifies a DTD. There is also currently no built-in support for validating against other XML schema languages such as XML Schema.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 유형은 입력 값이 DTD를 지정 되더라도, 문서 형 선언 (DTD)에 대한 검증되지 입력 값을한다. 또한 현재 XML 스키마와 같은 다른 XML 스키마 언어에 대한 유효성 검사를위한 기본 지원 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1deef1e666f438cec77e8c3e2e2981fe717c4002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlelement&lt;/code&gt; expression produces an XML element with the given name, attributes, and content.</source>
          <target state="translated">&lt;code&gt;xmlelement&lt;/code&gt; 표현은 지정된 이름, 특성, 및 콘텐츠와 XML 요소를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4ee0ea7e4de80223e9f57e26dca25df9c2bbc0e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlelement&lt;/code&gt; expression produces an XML element with the given name, attributes, and content. The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;attname&lt;/code&gt; items shown in the syntax are simple identifiers, not values. The &lt;code&gt;attvalue&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; items are expressions, which can yield any PostgreSQL data type. The argument(s) within &lt;code&gt;XMLATTRIBUTES&lt;/code&gt; generate attributes of the XML element; the &lt;code&gt;content&lt;/code&gt; value(s) are concatenated to form its content.</source>
          <target state="translated">&lt;code&gt;xmlelement&lt;/code&gt; 표현은 지정된 이름, 특성, 및 콘텐츠와 XML 요소를 생성합니다. &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;attname&lt;/code&gt; 구문에 표시된 항목은 단순 식별자가 아닌 값이다. &lt;code&gt;attvalue&lt;/code&gt; 및 &lt;code&gt;content&lt;/code&gt; 항목은 PostgreSQL의 데이터 유형을 얻을 수있는 표현입니다. &lt;code&gt;XMLATTRIBUTES&lt;/code&gt; 내의 인수 는 XML 요소의 속성을 생성합니다. &lt;code&gt;content&lt;/code&gt; 값 은 콘텐츠 를 형성하기 위해 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="69f2f71a5ec8ec9b6b661345ad1ff563285eb198" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlforest&lt;/code&gt; expression produces an XML forest (sequence) of elements using the given names and content.</source>
          <target state="translated">&lt;code&gt;xmlforest&lt;/code&gt; 표현은 주어진 이름과 내용을 사용하여 요소의 XML 숲 (순서)를 생성한다.</target>
        </trans-unit>
        <trans-unit id="dc2e8a68cfe71170b4e6b7d11888b6c5e22264d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlforest&lt;/code&gt; expression produces an XML forest (sequence) of elements using the given names and content. As for &lt;code&gt;xmlelement&lt;/code&gt;, each &lt;code&gt;name&lt;/code&gt; must be a simple identifier, while the &lt;code&gt;content&lt;/code&gt; expressions can have any data type.</source>
          <target state="translated">&lt;code&gt;xmlforest&lt;/code&gt; 표현은 주어진 이름과 내용을 사용하여 요소의 XML 숲 (순서)를 생성한다. 에 관해서는 &lt;code&gt;xmlelement&lt;/code&gt; , 각각의 &lt;code&gt;name&lt;/code&gt; 그동안 간단한 식별자 여야 &lt;code&gt;content&lt;/code&gt; 표현은 모든 데이터 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3af3e77f21a9c79b293de9c85e2a7ba1150f3fa6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlpi&lt;/code&gt; expression creates an XML processing instruction. As for &lt;code&gt;xmlelement&lt;/code&gt;, the &lt;code&gt;name&lt;/code&gt; must be a simple identifier, while the &lt;code&gt;content&lt;/code&gt; expression can have any data type. The &lt;code&gt;content&lt;/code&gt;, if present, must not contain the character sequence &lt;code&gt;?&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xmlpi&lt;/code&gt; 의 발현은 XML 처리 명령을 생성한다. 관해서 &lt;code&gt;xmlelement&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 그동안 단순한 식별자 여야 &lt;code&gt;content&lt;/code&gt; 표현이 데이터 타입을 가질 수있다. &lt;code&gt;content&lt;/code&gt; 존재하는 경우, 문자 시퀀스를 포함 할 수 없습니다 &lt;code&gt;?&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c704d359323afbae05aea7d4c253db38a9779402" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlpi&lt;/code&gt; expression creates an XML processing instruction. The content, if present, must not contain the character sequence &lt;code&gt;?&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xmlpi&lt;/code&gt; 의 발현은 XML 처리 명령을 생성한다. 컨텐츠는 존재하는 경우 문자 시퀀스 &lt;code&gt;?&amp;gt;&lt;/code&gt; 를 포함해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="483ff2aaee5c62e793871dd92a52c8a7e7cf4d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlroot&lt;/code&gt; expression alters the properties of the root node of an XML value. If a version is specified, it replaces the value in the root node's version declaration; if a standalone setting is specified, it replaces the value in the root node's standalone declaration.</source>
          <target state="translated">&lt;code&gt;xmlroot&lt;/code&gt; 의 표현 달라져있는 XML 값의 루트 노드의 속성. 버전이 지정되면 루트 노드 버전 선언의 값을 대체합니다. 독립형 설정을 지정하면 루트 노드의 독립형 선언 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="a8fdd07a68e94ca4d18d8472b68004096bb553e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmltable&lt;/code&gt; expression produces a table based on an XML value, an XPath filter to extract rows, and a set of column definitions. Although it syntactically resembles a function, it can only appear as a table in a query's &lt;code&gt;FROM&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;xmltable&lt;/code&gt; 표현식은 XML 값 추출 된 행에 대한 XPath는 필터 및 열 정의 세트에 기초하여 테이블을 생성한다. 구문 상 함수와 비슷하지만 쿼리의 &lt;code&gt;FROM&lt;/code&gt; 절 에서 테이블로만 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="194749c8350686b704674839bea4fca3eca2b901" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmltable&lt;/code&gt; function produces a table based on the given XML value, an XPath filter to extract rows, and a set of column definitions.</source>
          <target state="translated">&lt;code&gt;xmltable&lt;/code&gt; 함수는 주어진 XML 값 추출 된 행에 대한 XPath는 필터 및 열 정의 세트에 기초하여 테이블을 생성한다.</target>
        </trans-unit>
        <trans-unit id="241345ed65eaa6c1efb430df3084f0d4151592bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xpath_table&lt;/code&gt; function assumes that the results of each XPath query might be multivalued, so the number of rows returned by the function may not be the same as the number of input documents. The first row returned contains the first result from each query, the second row the second result from each query. If one of the queries has fewer values than the others, null values will be returned instead.</source>
          <target state="translated">&lt;code&gt;xpath_table&lt;/code&gt; 함수는 함수에 의해 반환되는 행의 수를 입력 문서의 수와 동일하지 않을 수 있도록 각 XPath 쿼리의 결과, 여러 값을 가질 수 있다고 가정합니다. 반환 된 첫 번째 행에는 각 쿼리의 첫 번째 결과가, 두 번째 행에는 각 쿼리의 두 번째 결과가 포함됩니다. 쿼리 중 하나가 다른 것보다 적은 값을 갖는 경우 대신 널값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8f26d57e1c368d060299c1c81b28042f79fcca60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; operator concatenates the elements at the top level of each of its operands. It does not operate recursively. For example, if both operands are objects with a common key field name, the value of the field in the result will just be the value from the right hand operand.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; 연산자는 각 피연산자의 최상위 레벨에서 요소를 연결합니다. 재귀 적으로 작동하지 않습니다. 예를 들어 두 피연산자가 모두 공통 키 필드 이름을 가진 객체 인 경우 결과의 필드 값은 오른쪽 피연산자의 값일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="25839180048fba8f8f9437939d20a2f9e4fca2ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&amp;gt;&lt;/code&gt; operator can also be used in this way to efficiently retrieve the first few values sorted by a selected coordinate. For example, to get the first few cubes ordered by the first coordinate (lower left corner) ascending one could use the following query:</source>
          <target state="translated">이 방법으로 &lt;code&gt;~&amp;gt;&lt;/code&gt; 연산자를 사용하여 선택한 좌표로 정렬 된 처음 몇 개의 값을 효율적으로 검색 할 수 있습니다. 예를 들어, 첫 번째 좌표 (왼쪽 아래) 오름차순으로 정렬 된 처음 몇 개의 큐브를 가져 오려면 다음 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="809dd3cf23829e5aba0aac6f0c8cd829bcb11269" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexCorrelation&lt;/code&gt;&lt;/em&gt; should be set to the correlation (ranging between -1.0 and 1.0) between the index order and the table order. This is used to adjust the estimate for the cost of fetching rows from the parent table.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexCorrelation&lt;/code&gt; 는&lt;/em&gt; 상관 설정되어야 번호순 테이블 간의 순서 (범위 -1.0 내지 1.0). 부모 테이블에서 행을 가져 오는 비용에 대한 추정치를 조정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d81aee55a8d4dcdc2397573ababbf7924223c018" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexPages&lt;/code&gt;&lt;/em&gt; should be set to the number of leaf pages. This is used to estimate the number of workers for parallel index scan.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexPages&lt;/code&gt; 은&lt;/em&gt; 리프 페이지의 수를 설정해야합니다. 병렬 인덱스 스캔 작업자 수를 추정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7685e1c43506ada1cffddeedf06115e445c9d085" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexSelectivity&lt;/code&gt;&lt;/em&gt; should be set to the estimated fraction of the parent table rows that will be retrieved during the index scan. In the case of a lossy query, this will typically be higher than the fraction of rows that actually pass the given qual conditions.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexSelectivity&lt;/code&gt; 는&lt;/em&gt; 인덱스 스캔 중에 취득되는 상위 테이블 행의 예상 비율을 설정한다. 손실 쿼리의 경우 일반적으로 주어진 규정 조건을 실제로 통과하는 행의 비율보다 높습니다.</target>
        </trans-unit>
        <trans-unit id="ae5c470364e9e087f35c4b0de71e765afe691f23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; parameter lets the user specify the iteration count, for algorithms that have one. The higher the count, the more time it takes to hash the password and therefore the more time to break it. Although with too high a count the time to calculate a hash may be several years &amp;mdash; which is somewhat impractical. If the &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; parameter is omitted, the default iteration count is used. Allowed values for &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; depend on the algorithm and are shown in &lt;a href=&quot;pgcrypto#PGCRYPTO-ICFC-TABLE&quot;&gt;Table F.17&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt; 매개 변수는 사용자가 하나가 알고리즘, 반복 횟수를 지정할 수 있습니다. 카운트가 높을수록 암호를 해시하는 데 더 많은 시간이 걸리므로 암호를 해독하는 데 더 많은 시간이 걸립니다. 카운트가 너무 많으면 해시를 계산하는 데 몇 년이 걸릴 수 있습니다. 이는 다소 비현실적입니다. 경우 &lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt; 매개 변수를 생략, 기본 반복 횟수가 사용됩니다. &lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt; 에 허용되는 값 은 알고리즘에 따라 다르며 &lt;a href=&quot;pgcrypto#PGCRYPTO-ICFC-TABLE&quot;&gt;표 F.17&lt;/a&gt; 에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b20f1e5072b09c8c12330c4cbb5380dc3c53e3d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;options&lt;/code&gt;&lt;/em&gt; parameter can contain option settings, as described below.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;options&lt;/code&gt; &lt;/em&gt; 아래와 같이 매개 변수는 옵션 설정을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="048387eb78e0888018ae5bf5cface4e6e6cf82bc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;sql&lt;/code&gt;&lt;/em&gt; parameter is a SQL statement that produces the source set of data. This statement must return one &lt;code&gt;row_name&lt;/code&gt; column, one &lt;code&gt;category&lt;/code&gt; column, and one &lt;code&gt;value&lt;/code&gt; column. &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is an obsolete parameter, ignored if supplied (formerly this had to match the number of output value columns, but now that is determined by the calling query).</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;sql&lt;/code&gt; &lt;/em&gt; 매개 변수는 데이터의 소스 세트를 생성하는 SQL 문입니다. 이 명령문은 하나의 &lt;code&gt;row_name&lt;/code&gt; 컬럼, 하나의 &lt;code&gt;category&lt;/code&gt; 컬럼 및 하나의 &lt;code&gt;value&lt;/code&gt; 컬럼을 리턴해야합니다 . &lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt; 은 사용되지 않는 매개 변수이며, 제공되는 경우 무시됩니다 (이전의 출력 값 열 수와 일치해야하지만 이제는 호출 쿼리에 의해 결정됨).</target>
        </trans-unit>
        <trans-unit id="a58a0a84dc580d747afb8a21f647c284a9244868" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; parameter specifies the hashing algorithm. The accepted types are: &lt;code&gt;des&lt;/code&gt;, &lt;code&gt;xdes&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 파라미터는 해시 알고리즘을 지정한다. 허용되는 유형은 &lt;code&gt;des&lt;/code&gt; , &lt;code&gt;xdes&lt;/code&gt; , &lt;code&gt;md5&lt;/code&gt; 및 &lt;code&gt;bf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aec319309bdc25febac97e4a69d58b94df9998b0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Julian Date&lt;/em&gt; system is another type of calendar, unrelated to the Julian calendar though it is confusingly named similarly to that calendar. The Julian Date system was invented by the French scholar Joseph Justus Scaliger (1540&amp;ndash;1609) and probably takes its name from Scaliger's father, the Italian scholar Julius Caesar Scaliger (1484&amp;ndash;1558). In the Julian Date system, each day has a sequential number, starting from JD 0 (which is sometimes called &lt;em&gt;the&lt;/em&gt; Julian Date). JD 0 corresponds to 1 January 4713 BC in the Julian calendar, or 24 November 4714 BC in the Gregorian calendar. Julian Date counting is most often used by astronomers for labeling their nightly observations, and therefore a date runs from noon UTC to the next noon UTC, rather than from midnight to midnight: JD 0 designates the 24 hours from noon UTC on 24 November 4714 BC to noon UTC on 25 November 4714 BC.</source>
          <target state="translated">&lt;em&gt;율리우스 날짜&lt;/em&gt; 시스템은이 혼동이 일정 유사 이름 불구하고 율리우스 력과 관련이없는 달력의 또 다른 유형이다. Julian Date 시스템은 프랑스 학자 Joseph Justus Scaliger (1540-1609)에 의해 발명되었으며 아마도 Scaliger의 아버지 인 이탈리아 학자 Julius Caesar Scaliger (1484-1558)에서 이름을 따 왔습니다. 율리우스 날짜 시스템에서, 매일이라고도한다 JD 0 (부터 순차적으로 번호가&lt;em&gt;&lt;/em&gt;Julian Date). JD 0은 율리우스 력의 BC 4713 년 1 월 1 일 또는 그레고리력의 BC 4714 년 11 월 24 일에 해당합니다. 줄리안 날짜 계산은 천문학 자들이 야간 관측에 레이블을 지정하기 위해 가장 자주 사용하므로 날짜는 자정부터 자정까지가 아닌 UTC 정오부터 다음 정오 UTC까지 실행됩니다. JD 0은 BC 4714 년 11 월 24 일 정오 UTC부터 24 시간을 나타냅니다. 기원전 4714 년 11 월 25 일 정오 UTC까지.</target>
        </trans-unit>
        <trans-unit id="484484b19f7f2f2b36524197848aeb0d9d4987ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Julian Date&lt;/em&gt; system is another type of calendar, unrelated to the Julian calendar though it is confusingly named similarly to that calendar. The Julian Date system was invented by the French scholar Joseph Justus Scaliger (1540-1609) and probably takes its name from Scaliger's father, the Italian scholar Julius Caesar Scaliger (1484-1558). In the Julian Date system, each day has a sequential number, starting from JD 0 (which is sometimes called &lt;em&gt;the&lt;/em&gt; Julian Date). JD 0 corresponds to 1 January 4713 BC in the Julian calendar, or 24 November 4714 BC in the Gregorian calendar. Julian Date counting is most often used by astronomers for labeling their nightly observations, and therefore a date runs from noon UTC to the next noon UTC, rather than from midnight to midnight: JD 0 designates the 24 hours from noon UTC on 24 November 4714 BC to noon UTC on 25 November 4714 BC.</source>
          <target state="translated">&lt;em&gt;율리우스 날짜&lt;/em&gt; 시스템은이 혼동이 일정 유사 이름 불구하고 율리우스 력과 관련이없는 달력의 또 다른 유형이다. Julian Date 시스템은 프랑스 학자 Joseph Justus Scaliger (1540-1609)가 발명했으며 아마도 Scaliger의 아버지 인 이탈리아 학자 Julius Caesar Scaliger (1484-1558)의 이름을 따를 것입니다. 율리우스 날짜 시스템에서, 매일이라고도한다 JD 0 (부터 순차적으로 번호가&lt;em&gt;&lt;/em&gt;율리우스 날짜). JD 0은 율리우스 력으로 BC 4713 년 1 월 1 일 또는 그레고리력으로 4714 년 11 월 24 일 BC에 해당합니다. 율리우스 날짜 계산은 천문학자가 야간 관측에 레이블을 지정하는 데 가장 자주 사용되므로 날짜는 자정에서 자정이 아닌 정오 UTC에서 다음 정오 UTC로 실행됩니다. 4714 년 11 월 25 일 UTC 정오까지.</target>
        </trans-unit>
        <trans-unit id="c767ea884019c639904724de55aaea8a6ef4f2e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Repeatable Read&lt;/em&gt; isolation level only sees data committed before the transaction began; it never sees either uncommitted data or changes committed during transaction execution by concurrent transactions. (However, the query does see the effects of previous updates executed within its own transaction, even though they are not yet committed.) This is a stronger guarantee than is required by the SQL standard for this isolation level, and prevents all of the phenomena described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt; except for serialization anomalies. As mentioned above, this is specifically allowed by the standard, which only describes the &lt;em&gt;minimum&lt;/em&gt; protections each isolation level must provide.</source>
          <target state="translated">&lt;em&gt;반복 읽기의&lt;/em&gt; 분리 레벨은 트랜잭션이 시작되기 전에 최선을 다하고 데이터를보고, 커밋되지 않은 데이터 나 동시 트랜잭션이 트랜잭션을 실행하는 동안 커밋 된 변경 내용은 절대 볼 수 없습니다. 그러나 쿼리는 아직 커밋되지 않았더라도 자체 트랜잭션 내에서 실행 된 이전 업데이트의 영향을 확인합니다. 이는이 격리 수준에 대해 SQL 표준에서 요구하는 것보다 더 강력한 보장이며 모든 현상을 방지합니다. 직렬화 이상을 제외하고 &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;표 13.1에&lt;/a&gt; 설명되어 있습니다. 위에서 언급했듯이, 이는 표준에 의해 특별히 허용되며, 각 격리 수준이 제공해야하는 &lt;em&gt;최소&lt;/em&gt; 보호 만 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="f9cbb4655ce1c4dfa140be7dcae24f9bc53c423c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Serializable&lt;/em&gt; isolation level provides the strictest transaction isolation. This level emulates serial transaction execution for all committed transactions; as if transactions had been executed one after another, serially, rather than concurrently. However, like the Repeatable Read level, applications using this level must be prepared to retry transactions due to serialization failures. In fact, this isolation level works exactly the same as Repeatable Read except that it monitors for conditions which could make execution of a concurrent set of serializable transactions behave in a manner inconsistent with all possible serial (one at a time) executions of those transactions. This monitoring does not introduce any blocking beyond that present in repeatable read, but there is some overhead to the monitoring, and detection of the conditions which could cause a &lt;em&gt;serialization anomaly&lt;/em&gt; will trigger a &lt;em&gt;serialization failure&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;직렬화&lt;/em&gt;격리 수준은 가장 엄격한 트랜잭션 격리를 제공합니다. 이 레벨은 커밋 된 모든 트랜잭션에 대한 직렬 트랜잭션 실행을 에뮬레이트합니다. 마치 트랜잭션이 순차적이 아니라 순차적으로 실행 된 것처럼. 그러나 반복 가능한 읽기 수준과 같이이 수준을 사용하는 응용 프로그램은 직렬화 오류로 인해 트랜잭션을 다시 시도하도록 준비해야합니다. 실제로,이 분리 레벨은 반복 가능한 읽기와 정확히 동일하게 작동합니다. 직렬화 가능한 동시 트랜잭션 세트의 실행이 해당 트랜잭션의 모든 가능한 직렬 (한 번에) 실행과 일치하지 않는 방식으로 작동 할 수있는 조건을 모니터한다는 점을 제외하면. 이 모니터링은 반복 가능한 읽기에 존재하는 것 이상의 차단을 일으키지 않지만 모니터링에 약간의 오버 헤드가 있으며&lt;em&gt;직렬화 이상&lt;/em&gt; 은 &lt;em&gt;직렬화 실패&lt;/em&gt; 를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="f95abb4a8d7bbdd16928c9f5238fbb89514c9dcf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;collation derivation&lt;/em&gt; of an expression can be implicit or explicit. This distinction affects how collations are combined when multiple different collations appear in an expression. An explicit collation derivation occurs when a &lt;code&gt;COLLATE&lt;/code&gt; clause is used; all other collation derivations are implicit. When multiple collations need to be combined, for example in a function call, the following rules are used:</source>
          <target state="translated">식의 &lt;em&gt;데이터 정렬 파생&lt;/em&gt; 은 암시 적이거나 명시적일 수 있습니다. 이 차이는 식에 여러 개의 다른 데이터 정렬이 나타날 때 데이터 정렬이 결합되는 방식에 영향을줍니다. &lt;code&gt;COLLATE&lt;/code&gt; 절이 사용될 때 명시 적 데이터 정렬 파생이 발생합니다 . 다른 모든 데이터 정렬 파생은 암시 적입니다. 예를 들어 함수 호출에서 여러 데이터 정렬을 결합해야하는 경우 다음 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1cf554eac84360c1dd91eed12720bf8c618bfb93" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cost&lt;/em&gt; variables described in this section are measured on an arbitrary scale. Only their relative values matter, hence scaling them all up or down by the same factor will result in no change in the planner's choices. By default, these cost variables are based on the cost of sequential page fetches; that is, &lt;code&gt;seq_page_cost&lt;/code&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost variables are set with reference to that. But you can use a different scale if you prefer, such as actual execution times in milliseconds on a particular machine.</source>
          <target state="translated">&lt;em&gt;비용&lt;/em&gt; 이 섹션에서 설명 변수는 임의의 크기를 측정한다. 상대적인 값만 중요하므로 같은 요인으로 모두 확대 또는 축소하면 플래너의 선택에 아무런 변화가 없습니다. 기본적으로 이러한 비용 변수는 순차적 페이지 페치 비용을 기반으로합니다. 즉, &lt;code&gt;seq_page_cost&lt;/code&gt; 는 일반적으로 &lt;code&gt;1.0&lt;/code&gt; 으로 설정되고 다른 비용 변수는이를 참조하여 설정됩니다. 그러나 특정 머신에서 실제 실행 시간 (밀리 초)과 같이 원하는 경우 다른 스케일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdab0ead2317e8987500975ac391b000a895f851" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;executor&lt;/em&gt; takes the plan created by the planner/optimizer and recursively processes it to extract the required set of rows. This is essentially a demand-pull pipeline mechanism. Each time a plan node is called, it must deliver one more row, or report that it is done delivering rows.</source>
          <target state="translated">&lt;em&gt;실행기는&lt;/em&gt; 플래너 / 최적화에 의해 생성 된 평면을 얻어 재귀 행의 필요한 집합을 추출하기 위해 그것을 처리한다. 이것은 본질적으로 수요 풀 파이프 라인 메커니즘입니다. 계획 노드가 호출 될 때마다 하나 이상의 행을 전달하거나 행 전달을 완료했다고보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="060116e5a7301adb249c93dbfa36c11220a4c9e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;join condition&lt;/em&gt; is specified in the &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause, or implicitly by the word &lt;code&gt;NATURAL&lt;/code&gt;. The join condition determines which rows from the two source tables are considered to &amp;ldquo;match&amp;rdquo;, as explained in detail below.</source>
          <target state="translated">&lt;em&gt;가입 조건&lt;/em&gt; 에 지정된되어 &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;USING&lt;/code&gt; 단어에 의해 암시 적 절을, 또는 &lt;code&gt;NATURAL&lt;/code&gt; . 결합 조건은 아래에 자세히 설명 된 것처럼 두 소스 테이블에서 &quot;일치&quot;하는 것으로 간주되는 행을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e845d5a4041970d6090d5e417e410e4537e73642" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;lexer&lt;/em&gt; is defined in the file &lt;code&gt;scan.l&lt;/code&gt; and is responsible for recognizing &lt;em&gt;identifiers&lt;/em&gt;, the &lt;em&gt;SQL key words&lt;/em&gt; etc. For every key word or identifier that is found, a &lt;em&gt;token&lt;/em&gt; is generated and handed to the parser.</source>
          <target state="translated">&lt;em&gt;렉서는&lt;/em&gt; 파일에 정의되어 &lt;code&gt;scan.l&lt;/code&gt; 및 인식에 대한 책임이 &lt;em&gt;식별자&lt;/em&gt; 는 &lt;em&gt;SQL 키 워드&lt;/em&gt; 를 찾을 때마다 핵심 단어 나 식별자 등을하는 &lt;em&gt;토큰이&lt;/em&gt; 생성되고 파서에 넘겨진다.</target>
        </trans-unit>
        <trans-unit id="b14305d3078ee82aaf737dbdfa8a94d4d85285ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;minmax&lt;/em&gt; operator classes store the minimum and the maximum values appearing in the indexed column within the range. The &lt;em&gt;inclusion&lt;/em&gt; operator classes store a value which includes the values in the indexed column within the range.</source>
          <target state="translated">&lt;em&gt;MINMAX&lt;/em&gt; 연산자 클래스는 최소 범위 내에서 인덱싱 된 컬럼에 나타나는 최대 값을 저장한다. &lt;em&gt;내포&lt;/em&gt; 연산자 클래스 범위 내의 인덱싱 된 열 값을 포함하는 값을 저장한다.</target>
        </trans-unit>
        <trans-unit id="4ba1c2981b2fbd2dd1eede149e275316be5425fc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser stage&lt;/em&gt; checks the query transmitted by the application program for correct syntax and creates a &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;파서 스테이지&lt;/em&gt; 쿼리 정확한 구문은 응용 프로그램에 의해 전송 및 확인이 생성 &lt;em&gt;쿼리 트리&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8d38c6ccc62204fc543f643ffbd579a373675e1c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser stage&lt;/em&gt; consists of two parts:</source>
          <target state="translated">&lt;em&gt;파서 단계는&lt;/em&gt; 두 부분으로 구성되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c5bfac80be17dbbeff4a6cdab20060a18710ec0b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser&lt;/em&gt; defined in &lt;code&gt;gram.y&lt;/code&gt; and &lt;code&gt;scan.l&lt;/code&gt; is built using the Unix tools bison and flex.</source>
          <target state="translated">&lt;em&gt;파서&lt;/em&gt; 에 정의 &lt;code&gt;gram.y&lt;/code&gt; 및 &lt;code&gt;scan.l&lt;/code&gt; 는 들소와 플렉스 유닉스 도구를 사용하여 만들어집니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
