<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="e5c40c51852d1db370144af8b27881f2a58ad27c" translate="yes" xml:space="preserve">
          <source>Do not protect data with SHA-1. The only good reason to use this option is to achieve compatibility with ancient PGP products, predating the addition of SHA-1 protected packets to RFC 4880. Recent gnupg.org and pgp.com software supports it fine.</source>
          <target state="translated">SHA-1로 데이터를 보호하지 마십시오. 이 옵션을 사용하는 유일한 이유는 RFC 4880에 SHA-1 보호 패킷을 추가하기 전에 고대 PGP 제품과의 호환성을 달성하는 것입니다. 최근 gnupg.org 및 pgp.com 소프트웨어는이를 잘 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7464e579d544e1490598db7995c21722a2582e99" translate="yes" xml:space="preserve">
          <source>Do not read the start-up file (neither the system-wide &lt;code&gt;psqlrc&lt;/code&gt; file nor the user's &lt;code&gt;~/.psqlrc&lt;/code&gt; file).</source>
          <target state="translated">시작 파일 (시스템 전체 &lt;code&gt;psqlrc&lt;/code&gt; 파일이나 사용자의 &lt;code&gt;~/.psqlrc&lt;/code&gt; .psqlrc 파일)을 읽지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="419228082583a5d3897025fe88118a0fad779586" translate="yes" xml:space="preserve">
          <source>Do not restore objects that are in the named schema. Multiple schemas to be excluded may be specified with multiple &lt;code&gt;-N&lt;/code&gt; switches.</source>
          <target state="translated">명명 된 스키마에있는 개체를 복원하지 마십시오. 제외 할 여러 스키마는 여러 개의 &lt;code&gt;-N&lt;/code&gt; 스위치 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a959cf4a809e3d1562473aa74b557dfc0cab64c" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a collation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing collation is anything like the one that would have been created.</source>
          <target state="translated">같은 이름의 데이터 정렬이 이미 있으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 데이터 정렬이 생성 된 데이터 정렬과 같은 것을 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="649a97789cf14b5d6974680e15267c3e322c406c" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a mapping of the given user to the given foreign server already exists. A notice is issued in this case. Note that there is no guarantee that the existing user mapping is anything like the one that would have been created.</source>
          <target state="translated">지정된 사용자와 지정된 외부 서버에 대한 매핑이 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 사용자 매핑이 생성 된 것과 비슷한 것을 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="27cb93ec38d689aff8db3ab3fe0d7d5c3e348523" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a materialized view with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing materialized view is anything like the one that would have been created.</source>
          <target state="translated">동일한 이름의 구체화 된 뷰가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 구체화 된 뷰가 생성 된 뷰와 같은 것을 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="98186bbeb2ed0749527f083f8213011d78644463" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing index is anything like the one that would have been created. Index name is required when &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 색인이 작성된 색인과 다름을 보증하지 않습니다. &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 가 지정된 경우 색인 이름이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="834d3460fc8005f3aea73eb04212128e25f203f6" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing relation is anything like the one that would have been created.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 관계가 작성된 관계와 같은 것을 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="748d23d425fe1f3f1db7c34a1114842eed2cdb52" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing relation is anything like the sequence that would have been created &amp;mdash; it might not even be a sequence.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 관계가 생성되었을 시퀀스와 유사하다는 보장은 없습니다. 시퀀스가 ​​아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4468e557fbd022f362186b25d203acdff76890d2" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing relation is anything like the sequence that would have been created - it might not even be a sequence.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 관계가 생성 된 시퀀스와 유사하다는 보장은 없습니다. 심지어 시퀀스가 ​​아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="41b9e5f0fa59fbd950645c2dd02f46959aa59a20" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a relation with the same name already exists. A notice is issued in this case. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">같은 이름의 관계가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ae04ab134e47fe25b398dae820484170ac9b3e0" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a server with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing server is anything like the one that would have been created.</source>
          <target state="translated">같은 이름의 서버가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 서버가 작성된 서버와 같은 서버라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcebad473dcc4eee3043b0222f58a0d2bd1e708c" translate="yes" xml:space="preserve">
          <source>Do not throw an error if a statistics object with the same name already exists. A notice is issued in this case. Note that only the name of the statistics object is considered here, not the details of its definition.</source>
          <target state="translated">같은 이름의 통계 개체가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 통계 오브젝트의 이름 만 여기에서 고려되며 정의의 세부 사항은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4bc72f4656e524f04810f27b3f3abd1fa036a9c0" translate="yes" xml:space="preserve">
          <source>Do not throw an error if an extension with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing extension is anything like the one that would have been created from the currently-available script file.</source>
          <target state="translated">같은 이름의 확장자가 이미 존재하는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다. 기존 확장이 현재 사용 가능한 스크립트 파일에서 생성 된 확장과 동일하다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="86a392087235d29d2756da6807d948d7139e08cd" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the access method does not exist. A notice is issued in this case.</source>
          <target state="translated">액세스 방법이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="d83f66a16dc09425c3a72b2eb69f4e766690024a" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the aggregate does not exist. A notice is issued in this case.</source>
          <target state="translated">집계가 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="08209801f14336e9d0a054fd445e99f81d3d7bce" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the cast does not exist. A notice is issued in this case.</source>
          <target state="translated">캐스트가 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="7a76d68c1857062357f7d8db55de8919ef49944f" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the collation does not exist. A notice is issued in this case.</source>
          <target state="translated">데이터 정렬이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8465af39f185f9c6cc5c2919c5a306f7d480deaf" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the conversion does not exist. A notice is issued in this case.</source>
          <target state="translated">변환이 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="c8acd7c64523763c5a343233452d4d3bdc021ed8" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the database does not exist. A notice is issued in this case.</source>
          <target state="translated">데이터베이스가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="ce16a031cfcc5745a9e2c0502a634517a7d81a22" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the domain does not exist. A notice is issued in this case.</source>
          <target state="translated">도메인이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="440d1746f214a514f20e24af1d13b08a9fed25ae" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the event trigger does not exist. A notice is issued in this case.</source>
          <target state="translated">이벤트 트리거가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="88d8420232fd2310619a1e4b1b65e116a3e5c2c1" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the extension does not exist. A notice is issued in this case.</source>
          <target state="translated">확장이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="3b53b3a5b66729e2d82cca27836b44793e319b9b" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the foreign table does not exist. A notice is issued in this case.</source>
          <target state="translated">외부 테이블이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="c2bafb9e707a65189fb4c175b92b98ea2955ba9d" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the foreign-data wrapper does not exist. A notice is issued in this case.</source>
          <target state="translated">외부 데이터 랩퍼가없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="3d1f799bfb7ab5956e34d625575f04baeca247a1" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the function does not exist. A notice is issued in this case.</source>
          <target state="translated">함수가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="4b59c4ddb9070fc22cbae29d732ed6c0ba171ccc" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the index does not exist. A notice is issued in this case.</source>
          <target state="translated">색인이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7be96437ecd160ba0c5df2293ca24cdaad01c7" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the language does not exist. A notice is issued in this case.</source>
          <target state="translated">언어가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="a4cdf2a8b108d00b6d4ec4eddaf401f8eb21599a" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the materialized view does not exist. A notice is issued in this case.</source>
          <target state="translated">구체화 된 뷰가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="2059447ea2ceab96cc0790936e5d53b052c338a3" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the operator class does not exist. A notice is issued in this case.</source>
          <target state="translated">연산자 클래스가 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="e05bc4c6b98bad30fafd6399feb7591e7d17abe5" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the operator does not exist. A notice is issued in this case.</source>
          <target state="translated">연산자가 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef7535fc3526366c6c3c344e9a1930bfa9dcfc2" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the operator family does not exist. A notice is issued in this case.</source>
          <target state="translated">운영자 제품군이없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="77e5ef3e5fffba0904b6dbcbdde58401194934be" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the policy does not exist. A notice is issued in this case.</source>
          <target state="translated">정책이 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="ba92fd4b74c7007ccb25e8c2c12a614e648815ad" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the procedure does not exist. A notice is issued in this case.</source>
          <target state="translated">절차가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="580ab3a4fca82e175fc9e041941c0bbb5606da00" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the publication does not exist. A notice is issued in this case.</source>
          <target state="translated">발행물이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="dc8f68861705f245e6c1a0318af8fc3ad51208a6" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the role does not exist. A notice is issued in this case.</source>
          <target state="translated">역할이 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="b04b712e02e9f117f930897fe5aef8271beac18f" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the rule does not exist. A notice is issued in this case.</source>
          <target state="translated">규칙이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="9118e341b6ecc73648a291f45c5f8a2ee770317e" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the schema does not exist. A notice is issued in this case.</source>
          <target state="translated">스키마가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="92aa852d80a1a3c28aea7bffd74a935b11a21f2e" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the sequence does not exist. A notice is issued in this case.</source>
          <target state="translated">시퀀스가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8f9d6984455f53ccd847e3b2412a66166bd91d5a" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the server does not exist. A notice is issued in this case.</source>
          <target state="translated">서버가 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6e60fbfe6dbe35cc5b8b5280e84e5eb192b96e" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the statistics object does not exist. A notice is issued in this case.</source>
          <target state="translated">통계 오브젝트가없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="5e879dd31b56dd9d7ceb910c29ee66a8ae5d6b7d" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the table does not exist. A notice is issued in this case.</source>
          <target state="translated">테이블이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="b53d78838383e3a93ed23545557e80c808dde9b2" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the tablespace does not exist. A notice is issued in this case.</source>
          <target state="translated">테이블 스페이스가없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="63eab72e1b11a0effaed0332862bc36b827445c9" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the text search configuration does not exist. A notice is issued in this case.</source>
          <target state="translated">텍스트 검색 구성이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4ed9c5b587e515f69b4cd2fa322fc5acd20b38" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the text search dictionary does not exist. A notice is issued in this case.</source>
          <target state="translated">텍스트 검색 사전이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="fe76f21f4e80a87b0b18068cd5e209238176ef08" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the text search parser does not exist. A notice is issued in this case.</source>
          <target state="translated">텍스트 검색 파서가없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="e6be7b21927c4294da04777cc6a6587ae3094ec2" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the text search template does not exist. A notice is issued in this case.</source>
          <target state="translated">텍스트 검색 템플릿이없는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="bdd3d494ae40a87f77adb032f6192ea525f37124" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the transform does not exist. A notice is issued in this case.</source>
          <target state="translated">변환이 존재하지 않는 경우 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="18afb1f92e7fa1b7cb2a1502a3ae88886a473bfd" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the trigger does not exist. A notice is issued in this case.</source>
          <target state="translated">트리거가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="593cb323d835a409bd58f18ebbdb6437fb9acd92" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the type does not exist. A notice is issued in this case.</source>
          <target state="translated">유형이 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="dd8c9bf79c7b56c000d4b79cd2d828190b901d3f" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the user does not exist. A notice is issued in this case.</source>
          <target state="translated">사용자가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="8f294cf5a31c3c8e6b4053dbb5f2dca944fd8300" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the user mapping does not exist. A notice is issued in this case.</source>
          <target state="translated">사용자 매핑이 없으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="0b517045375dd57c661998c97237a302fad962ca" translate="yes" xml:space="preserve">
          <source>Do not throw an error if the view does not exist. A notice is issued in this case.</source>
          <target state="translated">보기가 존재하지 않으면 오류를 발생시키지 마십시오. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="aecd31e282542c2f634ad41996eb4931eda571b4" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;trust&lt;/code&gt; unless you trust all local users on your system. &lt;code&gt;trust&lt;/code&gt; is the default for ease of installation.</source>
          <target state="translated">시스템의 모든 로컬 사용자를 &lt;code&gt;trust&lt;/code&gt; 하지 않으면 신뢰를 사용하지 마십시오 . &lt;code&gt;trust&lt;/code&gt; 설치가 용이하도록 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f9677f0bbbea4f4186994ea9ded2744a92cf57b9" translate="yes" xml:space="preserve">
          <source>Do not use Readline for line editing and do not use the command history. This can be useful to turn off tab expansion when cutting and pasting.</source>
          <target state="translated">행 편집에 Readline을 사용하지 말고 명령 기록을 사용하지 마십시오. 잘라 내기 및 붙여 넣기시 탭 확장을 끄는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ea93e72f74f0d71bbeeb8070e22a9f11989cb77" translate="yes" xml:space="preserve">
          <source>Do not use indicators but instead use special values to represent null values. Historically there have been databases using this approach.</source>
          <target state="translated">인디케이터를 사용하지 말고 대신 널 (NULL) 값을 나타내는 특수 값을 사용하십시오. 역사적으로이 접근법을 사용하는 데이터베이스가있었습니다.</target>
        </trans-unit>
        <trans-unit id="034b4314ea8be40733a06e32d575d62057905398" translate="yes" xml:space="preserve">
          <source>Do not use pg_standby or similar tools with the built-in standby mode described here. &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; should return immediately if the file does not exist; the server will retry the command again if necessary. See &lt;a href=&quot;log-shipping-alternative&quot;&gt;Section 26.4&lt;/a&gt; for using tools like pg_standby.</source>
          <target state="translated">여기에 설명 된 내장 대기 모드에서 pg_standby 또는 이와 유사한 도구를 사용하지 마십시오. 파일이 존재하지 않으면 &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 가 즉시 리턴해야합니다. 필요한 경우 서버가 명령을 다시 시도합니다. pg_standby와 같은 도구 사용에 대해서는 &lt;a href=&quot;log-shipping-alternative&quot;&gt;26.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="390983aa2d018c91830afaa9775a68a1710af0b7" translate="yes" xml:space="preserve">
          <source>Do not use the third form when specifying a value to be evaluated later, for example in a &lt;code&gt;DEFAULT&lt;/code&gt; clause for a table column. The system will convert &lt;code&gt;now&lt;/code&gt; to a &lt;code&gt;timestamp&lt;/code&gt; as soon as the constant is parsed, so that when the default value is needed, the time of the table creation would be used! The first two forms will not be evaluated until the default value is used, because they are function calls. Thus they will give the desired behavior of defaulting to the time of row insertion. (See also &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-VALUES&quot;&gt;Section 8.5.1.4&lt;/a&gt;.)</source>
          <target state="translated">나중에 평가할 값을 지정할 때 세 번째 형식을 사용하지 마십시오 (예 : 테이블 열의 &lt;code&gt;DEFAULT&lt;/code&gt; 절에서). 이 시스템은 변환됩니다 &lt;code&gt;now&lt;/code&gt; A를 &lt;code&gt;timestamp&lt;/code&gt; 즉시 상수가 구문 분석으로, 그래서 디폴트 값이 필요할 때, 테이블 작성시 사용되는 것! 처음 두 양식은 함수 호출이기 때문에 기본값이 사용될 때까지 평가되지 않습니다. 따라서 행 삽입 시간을 기본값으로 설정하는 원하는 동작을 제공합니다. ( &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-VALUES&quot;&gt;섹션 8.5.1.4&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="3c70ba61e3459676a1c8f0976ca0cff9701bb1ca" translate="yes" xml:space="preserve">
          <source>Do not verify data file checksums. The presence or absence of files and the sizes of those files will still be checked. This is much faster, because the files themselves do not need to be read.</source>
          <target state="translated">데이터 파일 체크섬을 확인하지 마십시오. 파일의 유무와 해당 파일의 크기는 계속 확인됩니다. 파일 자체를 읽을 필요가 없기 때문에 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="8126e1ed0b6614723be2e186ee52e7d3c81c5a4f" translate="yes" xml:space="preserve">
          <source>Do not verify existing stored data for constraint validity.</source>
          <target state="translated">제한 조건 유효성에 대해 기존의 저장된 데이터를 확인하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="46a09fece9a4c0f8e5d9983ec48b4da9e781148b" translate="yes" xml:space="preserve">
          <source>Do not wait for the operation to complete. This is the opposite of the option &lt;code&gt;-w&lt;/code&gt;.</source>
          <target state="translated">작업이 완료 될 때까지 기다리지 마십시오. &lt;code&gt;-w&lt;/code&gt; 옵션과 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="a354e745b71c79bd26167718a30b36daeb0cb5b5" translate="yes" xml:space="preserve">
          <source>Do not wait forever to acquire shared table locks at the beginning of the dump. Instead fail if unable to lock a table within the specified &lt;code&gt;timeout&lt;/code&gt;. The timeout may be specified in any of the formats accepted by &lt;code&gt;SET statement_timeout&lt;/code&gt;. (Allowed formats vary depending on the server version you are dumping from, but an integer number of milliseconds is accepted by all versions.)</source>
          <target state="translated">덤프 시작시 공유 테이블 잠금을 획득하기 위해 영원히 기다리지 마십시오. 지정된 &lt;code&gt;timeout&lt;/code&gt; 내에 테이블을 잠글 수 없으면 대신 실패합니다 . 제한 시간은 &lt;code&gt;SET statement_timeout&lt;/code&gt; 에서 허용되는 형식으로 지정할 수 있습니다 . (허용되는 형식은 덤프하는 서버 버전에 따라 다르지만 모든 버전에서 정수 밀리 초를 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="315591fe4909ae8f4cfc10cdd40e834a565965d3" translate="yes" xml:space="preserve">
          <source>Do not wait forever to acquire shared table locks at the beginning of the dump. Instead, fail if unable to lock a table within the specified &lt;code&gt;timeout&lt;/code&gt;. The timeout may be specified in any of the formats accepted by &lt;code&gt;SET statement_timeout&lt;/code&gt;. Allowed values vary depending on the server version you are dumping from, but an integer number of milliseconds is accepted by all versions since 7.3. This option is ignored when dumping from a pre-7.3 server.</source>
          <target state="translated">덤프 시작시 공유 테이블 잠금을 획득하기 위해 영원히 기다리지 마십시오. 대신 지정된 &lt;code&gt;timeout&lt;/code&gt; 내에 테이블을 잠글 수 없으면 실패합니다 . 제한 시간은 &lt;code&gt;SET statement_timeout&lt;/code&gt; 에서 허용되는 형식으로 지정할 수 있습니다 . 허용되는 값은 덤프하는 서버 버전에 따라 다르지만 7.3 이후의 모든 버전에서 정수 밀리 초를 허용합니다. 이 옵션은 7.3 이전 서버에서 덤프 할 때 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1cbb6712fbb2ec963fc240a169aba9d0eaf374" translate="yes" xml:space="preserve">
          <source>Do nothing (except issuing a notice) if a schema with the same name already exists. &lt;code&gt;schema_element&lt;/code&gt; subcommands cannot be included when this option is used.</source>
          <target state="translated">동일한 이름의 스키마가 이미 존재하는 경우에는 통지를 발행하지 않습니다. 이 옵션을 사용하면 &lt;code&gt;schema_element&lt;/code&gt; 하위 명령을 포함시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61290251b04843c605ece29b0717dc5bb1f4ffff" translate="yes" xml:space="preserve">
          <source>Do the arrays overlap, that is, have any elements in common?</source>
          <target state="translated">배열이 겹치는가, 즉 공통 요소가 있습니까?</target>
        </trans-unit>
        <trans-unit id="aeca44b0b7b136064132592e73dab96849a1fe1b" translate="yes" xml:space="preserve">
          <source>Do the cubes overlap?</source>
          <target state="translated">큐브가 겹치나요?</target>
        </trans-unit>
        <trans-unit id="a37431de620331c72173b23908d3b653b920f191" translate="yes" xml:space="preserve">
          <source>Do the ranges overlap, that is, have any elements in common?</source>
          <target state="translated">범위가 겹치는가, 즉 공통 요소가 있습니까?</target>
        </trans-unit>
        <trans-unit id="9b7765988d379c25c8b3ac6d0031f83a83c76d66" translate="yes" xml:space="preserve">
          <source>Do the two &lt;code&gt;seg&lt;/code&gt;s overlap?</source>
          <target state="translated">두 &lt;code&gt;seg&lt;/code&gt; 가 겹치나요?</target>
        </trans-unit>
        <trans-unit id="81343a68f6224c859cda5db695f70eb986d06d97" translate="yes" xml:space="preserve">
          <source>Do these objects intersect? Available for these pairs of types: (&lt;code&gt;box&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;line&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;line&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;path&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;).</source>
          <target state="translated">이 물체가 교차합니까? ( &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; ), ( &lt;code&gt;lseg&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; ), ( &lt;code&gt;lseg&lt;/code&gt; , &lt;code&gt;lseg&lt;/code&gt; ), ( &lt;code&gt;lseg&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; ), ( &lt;code&gt;line&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; ), ( &lt;code&gt;line&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; ), ( &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;path&lt;/code&gt; ) 유형의 쌍에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="533c37df407766463b0722f19a7b64618d2cb2da" translate="yes" xml:space="preserve">
          <source>Do these objects overlap? (One point in common makes this true.) Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">이러한 개체가 겹치나요? (하나의 공통점은 이것을 사실로 만듭니다.) &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; 에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c67a2c76df14834b062cbb89b0413d341b43ba5a" translate="yes" xml:space="preserve">
          <source>Documentation: Christopher Kings-Lynne</source>
          <target state="translated">문서 : Christopher Kings-Lynne</target>
        </trans-unit>
        <trans-unit id="cb03ae0caf6e0daea81a80fe40f6ab912effc7b1" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;hstore&lt;/code&gt; contain a non-&lt;code&gt;NULL&lt;/code&gt; value for key?</source>
          <target state="translated">않습니다 &lt;code&gt;hstore&lt;/code&gt; 는 비 포함 &lt;code&gt;NULL&lt;/code&gt; 의 키에 대한 값을?</target>
        </trans-unit>
        <trans-unit id="a421158009e5f56f494ab8e65bba23f64a98475c" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;hstore&lt;/code&gt; contain all the specified keys?</source>
          <target state="translated">않습니다 &lt;code&gt;hstore&lt;/code&gt; 가 지정된 모든 키를 포함?</target>
        </trans-unit>
        <trans-unit id="6a51c61ed3015ac3c43fd58e842557bc05370845" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;hstore&lt;/code&gt; contain any of the specified keys?</source>
          <target state="translated">않습니다 &lt;code&gt;hstore&lt;/code&gt; 가 지정된 키를 포함 할?</target>
        </trans-unit>
        <trans-unit id="caffa764a39d791c9bdac796e367bcaa32b76f52" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;hstore&lt;/code&gt; contain key?</source>
          <target state="translated">합니까 &lt;code&gt;hstore&lt;/code&gt; 가 키를 포함?</target>
        </trans-unit>
        <trans-unit id="ae7e9d382a9c9e04510f9e5f6cc6966a47f1ef9d" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;ltree&lt;/code&gt; array contain any path matching any &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">않습니다 &lt;code&gt;ltree&lt;/code&gt; 배열이 일치하는 어떤 경로 포함 &lt;code&gt;lquery&lt;/code&gt; 를 ?</target>
        </trans-unit>
        <trans-unit id="d85571eae19800d344de661ccfb5aeeadab28f6a" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">합니까 &lt;code&gt;ltree&lt;/code&gt; 일치 &lt;code&gt;lquery&lt;/code&gt; 를 ?</target>
        </trans-unit>
        <trans-unit id="633f089d74a66238c40b90317182bea3b5edac62" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">합니까 &lt;code&gt;ltree&lt;/code&gt; 일치 &lt;code&gt;ltxtquery&lt;/code&gt; 를 ?</target>
        </trans-unit>
        <trans-unit id="10f8efcaf0f3704a75ddf5223a3da9ea67df80f6" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;ltree&lt;/code&gt; match any &lt;code&gt;lquery&lt;/code&gt; in array?</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 가 배열의 &lt;code&gt;lquery&lt;/code&gt; 와 일치 합니까 ?</target>
        </trans-unit>
        <trans-unit id="214e66f2e6d45f0e8321baa3a9da347e357ee368" translate="yes" xml:space="preserve">
          <source>Does &lt;code&gt;tsvector&lt;/code&gt; match &lt;code&gt;tsquery&lt;/code&gt;? (The arguments can be given in either order.)</source>
          <target state="translated">합니까 &lt;code&gt;tsvector&lt;/code&gt; 의 일치 &lt;code&gt;tsquery&lt;/code&gt; 는 ? (인수는 어느 순서로든 주어질 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e8534a768aff765a5fcad0aa4441beb5f2118482" translate="yes" xml:space="preserve">
          <source>Does JSON path return any item for the specified JSON value?</source>
          <target state="translated">JSON 경로가 지정된 JSON 값에 대한 항목을 반환합니까?</target>
        </trans-unit>
        <trans-unit id="7678f0ed3fd51f7e80fd2b2dc5df540d644577af" translate="yes" xml:space="preserve">
          <source>Does array contain a descendant of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">배열에 &lt;code&gt;ltree&lt;/code&gt; 의 자손이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="ad2a8a47592796b7da46ee5bbdf1512472a89149" translate="yes" xml:space="preserve">
          <source>Does array contain an ancestor of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">배열에 &lt;code&gt;ltree&lt;/code&gt; 의 조상이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="201793db4da9a94e08e8240a8bc60c5d1c313502" translate="yes" xml:space="preserve">
          <source>Does array contain any path matching &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">배열에 &lt;code&gt;lquery&lt;/code&gt; 와 일치하는 경로가 있습니까?</target>
        </trans-unit>
        <trans-unit id="bf69d201f13c91918f41a69a4859c1ea48d31af5" translate="yes" xml:space="preserve">
          <source>Does array contain any path matching &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">배열에 &lt;code&gt;ltxtquery&lt;/code&gt; 와 일치하는 경로가 있습니까?</target>
        </trans-unit>
        <trans-unit id="b7aee1b1f046c96870c7a7783cacc422f1389235" translate="yes" xml:space="preserve">
          <source>Does array contain the specified privileges? (This is true if there is an array entry that matches the &lt;code&gt;aclitem&lt;/code&gt;'s grantee and grantor, and has at least the specified set of privileges.)</source>
          <target state="translated">어레이에 지정된 권한이 있습니까? (이는 &lt;code&gt;aclitem&lt;/code&gt; 의 피부 여자 및 부 여자와 일치하고 최소한 지정된 권한 집합을 가진 배열 항목이있는 경우에 해당됩니다 .)</target>
        </trans-unit>
        <trans-unit id="f78447d62eb5682b23ec7c793da289fae22c698b" translate="yes" xml:space="preserve">
          <source>Does array satisfy query? (commutator of &lt;code&gt;@@&lt;/code&gt;)</source>
          <target state="translated">배열이 쿼리를 충족합니까? ( &lt;code&gt;@@&lt;/code&gt; 의 정류자 )</target>
        </trans-unit>
        <trans-unit id="a92d0ce09672fc608f2735beb2aab64b3b53f006" translate="yes" xml:space="preserve">
          <source>Does array satisfy query? (see below)</source>
          <target state="translated">배열이 쿼리를 충족합니까? (아래 참조)</target>
        </trans-unit>
        <trans-unit id="8ace711da6b408bea7c7d7c8154d96116134b5c3" translate="yes" xml:space="preserve">
          <source>Does either subnet contain or equal the other?</source>
          <target state="translated">서브넷에 다른 서브넷이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="11bc7d9c8b8e4a3ed1dc4c4de04eead61f3aaa7a" translate="yes" xml:space="preserve">
          <source>Does first &lt;code&gt;tsquery&lt;/code&gt; contain the second? (This considers only whether all the lexemes appearing in one query appear in the other, ignoring the combining operators.)</source>
          <target state="translated">첫 번째 &lt;code&gt;tsquery&lt;/code&gt; 에 두 번째가 포함되어 있습니까? (이는 결합 연산자를 무시하고 한 쿼리에 나타나는 모든 용어가 다른 쿼리에 나타나는지 여부 만 고려합니다.)</target>
        </trans-unit>
        <trans-unit id="96de8802aee8b653ad43b1998b2adfecee1766ec" translate="yes" xml:space="preserve">
          <source>Does first object contain second? Available for these pairs of types: (&lt;code id=&quot;box&quot;&gt;box&lt;/code&gt;, &lt;code&gt;point&lt;/code&gt;), (&lt;code&gt;box&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;path&lt;/code&gt;, &lt;code&gt;point&lt;/code&gt;), (&lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;point&lt;/code&gt;), (&lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;circle&lt;/code&gt;, &lt;code&gt;point&lt;/code&gt;), (&lt;code&gt;circle&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;).</source>
          <target state="translated">첫 번째 개체에 두 번째 개체가 포함되어 있습니까? ( &lt;code id=&quot;box&quot;&gt;box&lt;/code&gt; , &lt;code&gt;point&lt;/code&gt; ), ( &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; ), ( &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;point&lt;/code&gt; ), ( &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;point&lt;/code&gt; ), ( &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; ), ( &lt;code&gt;circle&lt;/code&gt; , &lt;code&gt;point&lt;/code&gt; ), ( &lt;code&gt;circle&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; ) 유형의 쌍에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a0e9d6743f20878acfad081c3f38d55ecfda0cb" translate="yes" xml:space="preserve">
          <source>Does first object not extend above second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">첫 번째 개체가 두 번째 위로 확장되지 않습니까? 가능 &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a05adf0b6833a4d5a9d89abf70ed8f3fa3928c9" translate="yes" xml:space="preserve">
          <source>Does first object not extend below second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">첫 번째 개체가 두 번째 아래로 확장되지 않습니까? 가능 &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba567827e380f63c30c00cf981f8c568e62b834" translate="yes" xml:space="preserve">
          <source>Does first object not extend to the left of second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">첫 번째 개체가 두 번째 개체의 왼쪽으로 확장되지 않습니까? 가능 &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ea1430327d8477ea0d6005f0373d74197bfc0d2" translate="yes" xml:space="preserve">
          <source>Does first object not extend to the right of second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">첫 번째 개체가 두 번째 오른쪽으로 확장되지 않습니까? 가능 &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f788303f937fbb6b64f17ba2a7fad3976907e8cb" translate="yes" xml:space="preserve">
          <source>Does left array contain right array?</source>
          <target state="translated">왼쪽 배열에 오른쪽 배열이 있습니까?</target>
        </trans-unit>
        <trans-unit id="77de519e428ecc42287884deed59d2602f752e53" translate="yes" xml:space="preserve">
          <source>Does left operand contain right?</source>
          <target state="translated">왼쪽 피연산자에 오른쪽이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="1d71ff371784a348f9c12a352bc76caaae987330" translate="yes" xml:space="preserve">
          <source>Does not extend above?</source>
          <target state="translated">이상으로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="253123d1162a517f04a5ee9fd02d365f25c36adc" translate="yes" xml:space="preserve">
          <source>Does not extend below?</source>
          <target state="translated">아래로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="add602c08fe405618614a22bb2c72529b335161c" translate="yes" xml:space="preserve">
          <source>Does not extend to the left of?</source>
          <target state="translated">왼쪽으로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="e07e4fa0874bbb4b32f819c4b8f203d1c6858afb" translate="yes" xml:space="preserve">
          <source>Does not extend to the right of?</source>
          <target state="translated">의 오른쪽으로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="67e33d862ea98de3a421509890f6998594008921" translate="yes" xml:space="preserve">
          <source>Does not match regular expression, case insensitive</source>
          <target state="translated">대소 문자를 구분하지 않는 정규식과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5b2eb54c55e1d00f4b5dc4d67d0e5f2fe84d39a" translate="yes" xml:space="preserve">
          <source>Does not match regular expression, case sensitive</source>
          <target state="translated">대소 문자를 구분하는 정규식과 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="b0d9126c75206ec4c7dfe96432db67a38a1a8751" translate="yes" xml:space="preserve">
          <source>Does subnet contain or equal subnet?</source>
          <target state="translated">서브넷에 서브넷이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="cc7b54a295c67d9f9a8c95baa63b3663f2414597" translate="yes" xml:space="preserve">
          <source>Does subnet strictly contain subnet?</source>
          <target state="translated">서브넷에 서브넷이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="40183ea0a22e0fc022486c448e67391fb20474f6" translate="yes" xml:space="preserve">
          <source>Does text string, after implicit invocation of &lt;code id=&quot;to_tsvector&quot;&gt;to_tsvector()&lt;/code&gt;, match &lt;code&gt;tsquery&lt;/code&gt;?</source>
          <target state="translated">&lt;code id=&quot;to_tsvector&quot;&gt;to_tsvector()&lt;/code&gt; 의 암시 적 호출 후 텍스트 문자열이 tsquery 와 일치 &lt;code&gt;tsquery&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a3bdc835bceb148f38a752943d8b7b4dc4bcbc04" translate="yes" xml:space="preserve">
          <source>Does the &lt;em&gt;string&lt;/em&gt; exist as a top-level key within the JSON value?</source>
          <target state="translated">&lt;em&gt;문자열&lt;/em&gt; 이 JSON 값 내에 최상위 키로 존재 합니까 ?</target>
        </trans-unit>
        <trans-unit id="03ba5cf03bf4fbd798f77a355da2957d8284b101" translate="yes" xml:space="preserve">
          <source>Does the access method support &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt; and related keywords in &lt;code&gt;CREATE INDEX&lt;/code&gt;?</source>
          <target state="translated">액세스 방법 이 &lt;code&gt;CREATE INDEX&lt;/code&gt; 에서 &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; 및 관련 키워드를 지원합니까 ?</target>
        </trans-unit>
        <trans-unit id="fb913abb5c49330f0377cb2bc42a471044b0555c" translate="yes" xml:space="preserve">
          <source>Does the access method support exclusion constraints?</source>
          <target state="translated">액세스 방법이 제외 제약 조건을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="879909ef15ed6acf0beaf326ab6fec44b52b3c5e" translate="yes" xml:space="preserve">
          <source>Does the access method support indexes with multiple columns?</source>
          <target state="translated">액세스 방법이 여러 열이있는 인덱스를 지원합니까?</target>
        </trans-unit>
        <trans-unit id="6453c4c495cc610787e73fb0ae04205fd538bcbb" translate="yes" xml:space="preserve">
          <source>Does the access method support the &lt;code&gt;INCLUDE&lt;/code&gt; clause of &lt;code&gt;CREATE INDEX&lt;/code&gt;?</source>
          <target state="translated">액세스 방법 이 &lt;code&gt;CREATE INDEX&lt;/code&gt; 의 &lt;code&gt;INCLUDE&lt;/code&gt; 절을 지원합니까 ?</target>
        </trans-unit>
        <trans-unit id="cfc9c010de9381229fd83fcf505998f9b9821e8d" translate="yes" xml:space="preserve">
          <source>Does the access method support unique indexes?</source>
          <target state="translated">액세스 방법이 고유 인덱스를 지원합니까?</target>
        </trans-unit>
        <trans-unit id="216de41f9cbdff166df017bbef3accd4d29b2eff" translate="yes" xml:space="preserve">
          <source>Does the column natively support &lt;code&gt;col = ANY(array)&lt;/code&gt; searches?</source>
          <target state="translated">열이 기본적으로 &lt;code&gt;col = ANY(array)&lt;/code&gt; 검색을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="68fd60934753d2550ca7db3f70d3a9626bf64fbc" translate="yes" xml:space="preserve">
          <source>Does the column possess any defined sort ordering?</source>
          <target state="translated">열에 정의 된 정렬 순서가 있습니까?</target>
        </trans-unit>
        <trans-unit id="44e4c108b376d30b30390dfadb54272d724d6c79" translate="yes" xml:space="preserve">
          <source>Does the column sort in ascending order on a forward scan?</source>
          <target state="translated">정방향 스캔에서 열이 오름차순으로 정렬됩니까?</target>
        </trans-unit>
        <trans-unit id="624b72742f7340536d8c41c26fd99d9f75165b8b" translate="yes" xml:space="preserve">
          <source>Does the column sort in descending order on a forward scan?</source>
          <target state="translated">정방향 스캔에서 열이 내림차순으로 정렬됩니까?</target>
        </trans-unit>
        <trans-unit id="7d5b73a8840fb440669eafdd08be2bf0f8372175" translate="yes" xml:space="preserve">
          <source>Does the column sort with nulls first on a forward scan?</source>
          <target state="translated">정방향 스캔에서 열이 먼저 널로 정렬됩니까?</target>
        </trans-unit>
        <trans-unit id="7e98e107338f4cd5beb68f7b54e73f00debec7aa" translate="yes" xml:space="preserve">
          <source>Does the column sort with nulls last on a forward scan?</source>
          <target state="translated">정방향 스캔에서 열이 널로 정렬됩니까?</target>
        </trans-unit>
        <trans-unit id="614b9c69d6588988042647fac537366e8e09fcc7" translate="yes" xml:space="preserve">
          <source>Does the column support &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; searches?</source>
          <target state="translated">열이 &lt;code&gt;IS NULL&lt;/code&gt; 및 &lt;code&gt;IS NOT NULL&lt;/code&gt; 검색을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="6130b63031c7f46d3440ef10baba3c7417658622" translate="yes" xml:space="preserve">
          <source>Does the first &lt;code&gt;seg&lt;/code&gt; contain the second?</source>
          <target state="translated">첫 번째 &lt;code&gt;seg&lt;/code&gt; 에 두 번째 세그먼트가 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="c2295143c4a5a274cd8f28f28bbbd74c9d885f14" translate="yes" xml:space="preserve">
          <source>Does the first &lt;code&gt;seg&lt;/code&gt; not extend to the left of the second? [a, b] &amp;amp;&amp;gt; [c, d] is true if a &amp;gt;= c.</source>
          <target state="translated">첫 번째 &lt;code&gt;seg&lt;/code&gt; 가 두 번째 세그먼트 의 왼쪽으로 확장되지 않습니까? [a, b] &amp;amp;&amp;gt; [c, d]는 a&amp;gt; = c이면 참입니다.</target>
        </trans-unit>
        <trans-unit id="c9017e0d17f0ff266c99d8c5ef01efeafef818fd" translate="yes" xml:space="preserve">
          <source>Does the first &lt;code&gt;seg&lt;/code&gt; not extend to the right of the second? [a, b] &amp;amp;&amp;lt; [c, d] is true if b &amp;lt;= d.</source>
          <target state="translated">첫 번째 &lt;code&gt;seg&lt;/code&gt; 가 두 번째 세그먼트 의 오른쪽으로 확장되지 않습니까? [a, b] &amp;amp; &amp;lt;[c, d]는 b &amp;lt;= d이면 참입니다.</target>
        </trans-unit>
        <trans-unit id="08c4bdbd4cbae3d23461ef96a6ed89bc8d4954a5" translate="yes" xml:space="preserve">
          <source>Does the first JSON value contain the second? (See &lt;a href=&quot;datatype-json#JSON-CONTAINMENT&quot;&gt;Section 8.14.3&lt;/a&gt; for details about containment.)</source>
          <target state="translated">첫 번째 JSON 값에 두 번째 값이 포함됩니까? ( 격리에 대한 자세한 내용은 &lt;a href=&quot;datatype-json#JSON-CONTAINMENT&quot;&gt;섹션 8.14.3&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="567d9986119ded6b997921e3d8fe0dbabca6b12d" translate="yes" xml:space="preserve">
          <source>Does the first array contain the second, that is, does each element appearing in the second array equal some element of the first array? (Duplicates are not treated specially, thus &lt;code id=&quot;array&quot;&gt;ARRAY[1]&lt;/code&gt; and &lt;code&gt;ARRAY[1,1]&lt;/code&gt; are each considered to contain the other.)</source>
          <target state="translated">첫 번째 배열에 두 번째 배열이 포함되어 있습니까? 즉, 두 번째 배열에 나타나는 각 요소가 첫 번째 배열의 일부 요소와 동일합니까? (중복은 특별히 처리되지 않으므로 &lt;code id=&quot;array&quot;&gt;ARRAY[1]&lt;/code&gt; 및 &lt;code&gt;ARRAY[1,1]&lt;/code&gt; 은 각각 다른 것을 포함하는 것으로 간주됩니다.)</target>
        </trans-unit>
        <trans-unit id="6206f207d44b637c7011da8ff74a38be55971876" translate="yes" xml:space="preserve">
          <source>Does the first cube contain the second?</source>
          <target state="translated">첫 번째 큐브에 두 번째 큐브가 있습니까?</target>
        </trans-unit>
        <trans-unit id="f6a037e33f0c48ee36c14313a969013482661269" translate="yes" xml:space="preserve">
          <source>Does the first range contain the second?</source>
          <target state="translated">첫 번째 범위에 두 번째 범위가 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="8eb4bd158b71bf0d304ec15d83938cec09b5c026" translate="yes" xml:space="preserve">
          <source>Does the first range not extend to the left of the second?</source>
          <target state="translated">첫 번째 범위가 두 번째 범위의 왼쪽으로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="5781dd65149109ee9df544efd6d1e1d886e55d24" translate="yes" xml:space="preserve">
          <source>Does the first range not extend to the right of the second?</source>
          <target state="translated">첫 번째 범위가 두 번째 범위의 오른쪽으로 확장되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="7242f0264cca02688205293e7aba32e21945855c" translate="yes" xml:space="preserve">
          <source>Does the index support bitmap scans?</source>
          <target state="translated">인덱스가 비트 맵 스캔을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="ef53c30eccf8ae98790d427d2faa9e7c00273781" translate="yes" xml:space="preserve">
          <source>Does the index support plain (non-bitmap) scans?</source>
          <target state="translated">인덱스가 일반 (비 비트 맵) 스캔을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="14e5a573eb1bb894fdc6ebb3db56ca889d046493" translate="yes" xml:space="preserve">
          <source>Does the left JSON value contain the right JSON path/value entries at the top level?</source>
          <target state="translated">왼쪽 JSON 값에 최상위 JSON 경로 / 값 항목이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="21bd97f5a7ff19f924f2bd59ddbf9cfebc11008d" translate="yes" xml:space="preserve">
          <source>Does the range contain the element?</source>
          <target state="translated">범위에 요소가 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="c84eb06e3b6c599ef8410360f743c802f409f8a3" translate="yes" xml:space="preserve">
          <source>Does the text string exist as a top-level key or array element within the JSON value?</source>
          <target state="translated">텍스트 문자열이 JSON 값 내에서 최상위 키 또는 배열 요소로 존재합니까?</target>
        </trans-unit>
        <trans-unit id="b228adf023701e4542fda9584b75a29e21cd28ba" translate="yes" xml:space="preserve">
          <source>Does user have privilege for any column of table? This succeeds either if the privilege is held for the whole table, or if there is a column-level grant of the privilege for at least one column. Allowable privilege types are &lt;code id=&quot;select&quot;&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;REFERENCES&lt;/code&gt;.</source>
          <target state="translated">사용자에게 테이블 열에 대한 권한이 있습니까? 이는 전체 테이블에 대한 권한이 유지되거나 적어도 하나의 열에 대한 권한의 열 수준 부여가있는 경우에 성공합니다. 허용되는 권한 유형은 &lt;code id=&quot;select&quot;&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;REFERENCES&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ff9f98c32cfc0f1a6e7d74a2fc10098c37dfff6" translate="yes" xml:space="preserve">
          <source>Does user have privilege for data type? The only allowable privilege type is &lt;code&gt;USAGE&lt;/code&gt;. When specifying a type by name rather than by OID, the allowed input is the same as for the &lt;code&gt;regtype&lt;/code&gt; data type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;).</source>
          <target state="translated">사용자에게 데이터 유형에 대한 권한이 있습니까? 허용되는 유일한 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; 입니다. OID가 아닌 이름으로 유형을 지정할 때 허용되는 입력은 &lt;code&gt;regtype&lt;/code&gt; 데이터 유형 의 경우와 동일 합니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cdd5192cb438ff863be0b986409a123e8085ca5f" translate="yes" xml:space="preserve">
          <source>Does user have privilege for database? Allowable privilege types are &lt;code id=&quot;create&quot;&gt;CREATE&lt;/code&gt;, &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;TEMPORARY&lt;/code&gt;, and &lt;code&gt;TEMP&lt;/code&gt; (which is equivalent to &lt;code&gt;TEMPORARY&lt;/code&gt;).</source>
          <target state="translated">사용자에게 데이터베이스 권한이 있습니까? 허용되는 권한 유형은 &lt;code id=&quot;create&quot;&gt;CREATE&lt;/code&gt; , &lt;code&gt;CONNECT&lt;/code&gt; , &lt;code&gt;TEMPORARY&lt;/code&gt; 및 &lt;code&gt;TEMP&lt;/code&gt; ( &lt;code&gt;TEMPORARY&lt;/code&gt; 와 동일 함 )입니다.</target>
        </trans-unit>
        <trans-unit id="702595354822f3ddfed0925bec912142f7d98c32" translate="yes" xml:space="preserve">
          <source>Does user have privilege for foreign server? The only allowable privilege type is &lt;code&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">사용자에게 외부 서버에 대한 권한이 있습니까? 허용되는 유일한 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3ea719eff38cea4ebcaed1ed047bba5804ed1f1b" translate="yes" xml:space="preserve">
          <source>Does user have privilege for foreign-data wrapper? The only allowable privilege type is &lt;code id=&quot;usage&quot;&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">사용자에게 외부 데이터 래퍼에 대한 권한이 있습니까? 허용되는 유일한 권한 유형은 &lt;code id=&quot;usage&quot;&gt;USAGE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="298188744f7cf6acda784d76dcd94933e2a6f398" translate="yes" xml:space="preserve">
          <source>Does user have privilege for function? The only allowable privilege type is &lt;code id=&quot;execute&quot;&gt;EXECUTE&lt;/code&gt;.</source>
          <target state="translated">사용자에게 기능 권한이 있습니까? 허용되는 유일한 권한 유형은 &lt;code id=&quot;execute&quot;&gt;EXECUTE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fd516d50163bce5f31cc09a56b2493073189de81" translate="yes" xml:space="preserve">
          <source>Does user have privilege for language? The only allowable privilege type is &lt;code&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">사용자에게 언어 권한이 있습니까? 허용되는 유일한 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb1c42ee2162885809eb942de5a56b0a21d459c9" translate="yes" xml:space="preserve">
          <source>Does user have privilege for role? Allowable privilege types are &lt;code id=&quot;member&quot;&gt;MEMBER&lt;/code&gt; and &lt;code&gt;USAGE&lt;/code&gt;. &lt;code&gt;MEMBER&lt;/code&gt; denotes direct or indirect membership in the role (that is, the right to do &lt;code&gt;SET ROLE&lt;/code&gt;), while &lt;code&gt;USAGE&lt;/code&gt; denotes whether the privileges of the role are immediately available without doing &lt;code&gt;SET ROLE&lt;/code&gt;. This function does not allow the special case of setting &lt;em&gt;&lt;code&gt;user&lt;/code&gt;&lt;/em&gt; to &lt;code&gt;public&lt;/code&gt;, because the PUBLIC pseudo-role can never be a member of real roles.</source>
          <target state="translated">사용자에게 역할에 대한 권한이 있습니까? 허용되는 권한 유형은 &lt;code id=&quot;member&quot;&gt;MEMBER&lt;/code&gt; 및 &lt;code&gt;USAGE&lt;/code&gt; 입니다. &lt;code&gt;MEMBER&lt;/code&gt; 역할에 직접 또는 간접 회원 (즉, 바로이해야 할 의미 &lt;code&gt;SET ROLE&lt;/code&gt; 하면서) &lt;code&gt;USAGE&lt;/code&gt; 나타냅니다에게 역할의 권한을 수행하지 않고 즉시 사용할 수 있는지 여부를 &lt;code&gt;SET ROLE&lt;/code&gt; . PUBLIC 의사 역할은 실제 역할의 구성원이 될 수 없기 때문에이 함수는 &lt;em&gt; &lt;code&gt;user&lt;/code&gt; &lt;/em&gt; 를 &lt;code&gt;public&lt;/code&gt; 으로 설정하는 특별한 경우를 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cb4c7631e8c58d25e9d82f74773ffecc90b2d562" translate="yes" xml:space="preserve">
          <source>Does user have privilege for schema? Allowable privilege types are &lt;code&gt;CREATE&lt;/code&gt; and &lt;code&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">사용자에게 스키마에 대한 권한이 있습니까? 허용되는 권한 유형은 &lt;code&gt;CREATE&lt;/code&gt; 및 &lt;code&gt;USAGE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb3af682f10936f90d2c3447bc0ac14ad886cc5a" translate="yes" xml:space="preserve">
          <source>Does user have privilege for sequence? Allowable privilege types are &lt;code&gt;USAGE&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, and &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">사용자에게 시퀀스 권한이 있습니까? 허용되는 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; , &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a64b430772790367667210abc59af4737ca691b" translate="yes" xml:space="preserve">
          <source>Does user have privilege for table? Allowable privilege types are &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REFERENCES&lt;/code&gt;, and &lt;code&gt;TRIGGER&lt;/code&gt;.</source>
          <target state="translated">사용자에게 테이블에 대한 권한이 있습니까? 허용되는 권한 유형은 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REFERENCES&lt;/code&gt; 및 &lt;code&gt;TRIGGER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc1f55ca8394bc231029dbe37006c7ed0a672584" translate="yes" xml:space="preserve">
          <source>Does user have privilege for tablespace? The only allowable privilege type is &lt;code&gt;CREATE&lt;/code&gt;.</source>
          <target state="translated">사용자에게 테이블 스페이스에 대한 권한이 있습니까? 허용되는 유일한 권한 유형은 &lt;code&gt;CREATE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f7e3da7ead83696c88e87b88f8e46cd2b8c0fe1" translate="yes" xml:space="preserve">
          <source>Does user have privilege for the specified table column? This succeeds either if the privilege is held for the whole table, or if there is a column-level grant of the privilege for the column. The column can be specified by name or by attribute number (&lt;code&gt;pg_attribute&lt;/code&gt;.&lt;code&gt;attnum&lt;/code&gt;). Allowable privilege types are &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;REFERENCES&lt;/code&gt;.</source>
          <target state="translated">사용자에게 지정된 테이블 열에 대한 권한이 있습니까? 권한이 전체 테이블에 대해 유지되거나 열에 대한 권한의 열 수준 부여가있는 경우 성공합니다. 열은 이름 또는 속성 번호 ( &lt;code&gt;pg_attribute&lt;/code&gt; . &lt;code&gt;attnum&lt;/code&gt; ) 로 지정할 수 있습니다 . 허용되는 권한 유형은 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;REFERENCES&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be846d72fad3df0bc7f1c552be7f26dd20d67401" translate="yes" xml:space="preserve">
          <source>Dollar quoting is not part of the SQL standard, but it is often a more convenient way to write complicated string literals than the standard-compliant single quote syntax. It is particularly useful when representing string constants inside other constants, as is often needed in procedural function definitions. With single-quote syntax, each backslash in the above example would have to be written as four backslashes, which would be reduced to two backslashes in parsing the original string constant, and then to one when the inner string constant is re-parsed during function execution.</source>
          <target state="translated">달러 인용은 SQL 표준의 일부가 아니지만 종종 표준 호환 작은 따옴표 구문보다 복잡한 문자열 리터럴을 작성하는 것이 더 편리한 방법입니다. 프로 시저 함수 정의에서 종종 필요한 것처럼 다른 상수 내에서 문자열 상수를 나타낼 때 특히 유용합니다. 작은 따옴표 구문을 사용하면 위 예제의 각 백 슬래시는 4 개의 백 슬래시로 작성되어야합니다. 백 슬래시는 원래 문자열 상수를 구문 분석 할 때 2 개의 백 슬래시로 감소한 다음 함수 중에 내부 문자열 상수가 다시 구문 분석 될 때 1로 감소합니다. 실행.</target>
        </trans-unit>
        <trans-unit id="299fdf04cba228f518669cf01c99ac27abcc66f7" translate="yes" xml:space="preserve">
          <source>Domain Types</source>
          <target state="translated">도메인 유형</target>
        </trans-unit>
        <trans-unit id="89eb4d5646a45612dd3ca144ea0a29e4cdfca3ab" translate="yes" xml:space="preserve">
          <source>Domain constraints, particularly &lt;code&gt;NOT NULL&lt;/code&gt;, are checked when converting a value to the domain type. It is possible for a column that is nominally of the domain type to read as null despite there being such a constraint. For example, this can happen in an outer-join query, if the domain column is on the nullable side of the outer join. A more subtle example is</source>
          <target state="translated">도메인 제약 조건, 특히 &lt;code&gt;NOT NULL&lt;/code&gt; 은 값을 도메인 유형으로 변환 할 때 확인됩니다. 도메인 유형이 공칭 인 열은 그러한 제한 조건이 있음에도 불구하고 널로 읽을 수 있습니다. 예를 들어 도메인 열이 외부 조인의 Null을 허용하는쪽에있는 경우 외부 조인 쿼리에서 발생할 수 있습니다. 더 미묘한 예는</target>
        </trans-unit>
        <trans-unit id="2abdad646fb44d4d610efcbe79a830794cd64bf9" translate="yes" xml:space="preserve">
          <source>Domains are useful for abstracting common constraints on fields into a single location for maintenance. For example, several tables might contain email address columns, all requiring the same CHECK constraint to verify the address syntax. Define a domain rather than setting up each table's constraint individually.</source>
          <target state="translated">도메인은 유지 보수를 위해 필드의 공통 제한 조건을 단일 위치로 추상화하는 데 유용합니다. 예를 들어, 여러 테이블에 이메일 주소 열이 포함될 수 있으며, 모두 주소 구문을 확인하기 위해 동일한 CHECK 제약 조건이 필요합니다. 각 테이블의 제약 조건을 개별적으로 설정하는 대신 도메인을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="7b14ee932a350cc527859e6afd76cead3251e675" translate="yes" xml:space="preserve">
          <source>Domains use &lt;code&gt;typtypmod&lt;/code&gt; to record the &lt;code&gt;typmod&lt;/code&gt; to be applied to their base type (-1 if base type does not use a &lt;code&gt;typmod&lt;/code&gt;). -1 if this type is not a domain.</source>
          <target state="translated">도메인은 &lt;code&gt;typtypmod&lt;/code&gt; 를 사용 하여 기본 유형에 적용 할 &lt;code&gt;typmod&lt;/code&gt; 를 기록합니다 (기본 유형이 &lt;code&gt;typmod&lt;/code&gt; 를 사용하지 않는 경우 -1 ). 이 유형이 도메인이 아닌 경우 -1입니다.</target>
        </trans-unit>
        <trans-unit id="6fa043cd6370679883ad51ebb89fce26ca06e740" translate="yes" xml:space="preserve">
          <source>Don't attempt to parse write-ahead log data that will be needed to recover from this backup.</source>
          <target state="translated">이 백업에서 복구하는 데 필요한 미리 쓰기 로그 데이터를 구문 분석하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="74754f8ebf1860694f41ab11263488f49d2334f3" translate="yes" xml:space="preserve">
          <source>Don't include write-ahead log in the backup.</source>
          <target state="translated">백업에 미리 기록 로그를 포함시키지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6cdd13201fd19cf732632420dda3b869691e77e0" translate="yes" xml:space="preserve">
          <source>Don't include write-ahead logs in the backup.</source>
          <target state="translated">백업에 미리 쓰기 로그를 포함하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="efbbc563b332126ef2578ac6901c3ec90f1dbc98" translate="yes" xml:space="preserve">
          <source>Don't leave connections dangling &amp;ldquo;idle in transaction&amp;rdquo; longer than necessary. The configuration parameter &lt;a href=&quot;runtime-config-client#GUC-IDLE-IN-TRANSACTION-SESSION-TIMEOUT&quot;&gt;idle_in_transaction_session_timeout&lt;/a&gt; may be used to automatically disconnect lingering sessions.</source>
          <target state="translated">연결이 &quot;유휴 상태&quot;에 매달려있는 동안 필요 이상으로 두지 마십시오. 구성 매개 변수 &lt;a href=&quot;runtime-config-client#GUC-IDLE-IN-TRANSACTION-SESSION-TIMEOUT&quot;&gt;idle_in_transaction_session_timeout을&lt;/a&gt; 사용하여 느린 세션의 연결을 자동으로 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8d45de9f00429ca5b53c7f234e4ab44bcf9705" translate="yes" xml:space="preserve">
          <source>Don't loop on connection errors. Instead, exit right away with an error.</source>
          <target state="translated">연결 오류를 반복하지 마십시오. 대신 오류가 발생하면 즉시 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="079ab82f0de2331934c2ede4f66cea128c46d373" translate="yes" xml:space="preserve">
          <source>Don't print anything when a backup is successfully verified.</source>
          <target state="translated">백업이 성공적으로 확인되면 아무것도 인쇄하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f3fc27f7ea73735ee61962c17ae8611b94f64e4f" translate="yes" xml:space="preserve">
          <source>Don't put more into a single transaction than needed for integrity purposes.</source>
          <target state="translated">무결성 목적에 필요한 것보다 단일 트랜잭션에 더 많은 것을 넣지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d1207520ff0a565537c007a53269e3261c6bd8c8" translate="yes" xml:space="preserve">
          <source>Dot (&lt;code&gt;.&lt;/code&gt;) is used for member access.</source>
          <target state="translated">점 ( &lt;code&gt;.&lt;/code&gt; )은 회원 액세스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5df432c8c8dbc55f99758989ab422fd0f4ef23e0" translate="yes" xml:space="preserve">
          <source>Drop a publication:</source>
          <target state="translated">발행물을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="4ac9f745c628bc958118f6ed763e2a1442043a73" translate="yes" xml:space="preserve">
          <source>Drop a server &lt;code&gt;foo&lt;/code&gt; if it exists:</source>
          <target state="translated">존재하는 경우 서버 &lt;code&gt;foo&lt;/code&gt; 를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="93d5bbb17a8c38f06b908475f91177219b6e5365" translate="yes" xml:space="preserve">
          <source>Drop a subscription:</source>
          <target state="translated">구독을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="0efb9df76ce6bb0c19ee2a980a677ca924beeaf3" translate="yes" xml:space="preserve">
          <source>Drop a user mapping &lt;code&gt;bob&lt;/code&gt;, server &lt;code&gt;foo&lt;/code&gt; if it exists:</source>
          <target state="translated">사용자 맵핑 &lt;code&gt;bob&lt;/code&gt; , 서버 &lt;code&gt;foo&lt;/code&gt; 가있는 경우이를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="58f0d64c8558580252204c03f90d90e1bfb7a28b" translate="yes" xml:space="preserve">
          <source>Drop any existing pgbench tables.</source>
          <target state="translated">기존 pgbench 테이블을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="326f543b1017ef892a8231ce1a80b0c93a80c52a" translate="yes" xml:space="preserve">
          <source>Drop multiple functions in one command:</source>
          <target state="translated">하나의 명령으로 여러 기능을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="591aefafc0cb1112269eec12b89b4b23ed9aaac5" translate="yes" xml:space="preserve">
          <source>Drop the access method &lt;code&gt;heptree&lt;/code&gt;:</source>
          <target state="translated">액세스 방법 &lt;code&gt;heptree&lt;/code&gt; 를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="e467322a0e06a4f2e03ebed261e871f325317f57" translate="yes" xml:space="preserve">
          <source>Drop the foreign-data wrapper &lt;code&gt;dbi&lt;/code&gt;:</source>
          <target state="translated">외부 데이터 래퍼 &lt;code&gt;dbi&lt;/code&gt; 를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="b005b49eeb0932041751efe51bfa289cb8d388e5" translate="yes" xml:space="preserve">
          <source>Drop the index without locking out concurrent selects, inserts, updates, and deletes on the index's table. A normal &lt;code&gt;DROP INDEX&lt;/code&gt; acquires exclusive lock on the table, blocking other accesses until the index drop can be completed. With this option, the command instead waits until conflicting transactions have completed.</source>
          <target state="translated">인덱스 테이블에서 동시 선택, 삽입, 업데이트 및 삭제를 잠그지 않고 인덱스를 삭제하십시오. 일반 &lt;code&gt;DROP INDEX&lt;/code&gt; 는 테이블에서 배타적 잠금을 획득하여 인덱스 삭제가 완료 될 때까지 다른 액세스를 차단합니다. 이 옵션을 사용하면 충돌하는 트랜잭션이 완료 될 때까지 명령이 대신 대기합니다.</target>
        </trans-unit>
        <trans-unit id="63bbc062ffd5dcec9e7d8f06903c428715c1fcfb" translate="yes" xml:space="preserve">
          <source>Drop the replication slot with the name specified by &lt;code&gt;--slot&lt;/code&gt;, then exit.</source>
          <target state="translated">&lt;code&gt;--slot&lt;/code&gt; 에 지정된 이름으로 복제 슬롯을 삭제 한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e77bdc67e0eb1a9828de69a267601200dc5b1120" translate="yes" xml:space="preserve">
          <source>Drop the replication slot with the name specified in &lt;code&gt;--slot&lt;/code&gt;, then exit.</source>
          <target state="translated">&lt;code&gt;--slot&lt;/code&gt; 에 지정된 이름으로 복제 슬롯을 삭제 한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="db6283865228ed49d3592194f4d42fbbb357949c" translate="yes" xml:space="preserve">
          <source>Dropping Roles</source>
          <target state="translated">역할 삭제</target>
        </trans-unit>
        <trans-unit id="a9cfbbdc85ccf8af404bf68b314b6c3fbe73c256" translate="yes" xml:space="preserve">
          <source>Dropping a database on the primary conflicts with sessions connected to that database on the standby.</source>
          <target state="translated">기본에서 데이터베이스를 삭제하면 대기에서 해당 데이터베이스에 연결된 세션과 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="52cfca4e5356615c98bd7dc9395f21bc36322f98" translate="yes" xml:space="preserve">
          <source>Dropping a table will still orphan any objects it contains, as the trigger is not executed. You can avoid this by preceding the &lt;code&gt;DROP TABLE&lt;/code&gt; with &lt;code&gt;DELETE FROM table&lt;/code&gt;.</source>
          <target state="translated">트리거를 실행하지 않기 때문에 테이블을 삭제하면 테이블에 포함 된 개체가 여전히 고아가됩니다. &lt;code&gt;DROP TABLE&lt;/code&gt; 을 &lt;code&gt;DELETE FROM table&lt;/code&gt; 과 함께 사용 하면이를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b04562d85f79214513954b38b3c0dd5219a517e3" translate="yes" xml:space="preserve">
          <source>Dropping a tablespace on the primary conflicts with standby queries using that tablespace for temporary work files.</source>
          <target state="translated">기본에서 테이블 스페이스를 삭제하면 임시 작업 파일에 대해 해당 테이블 스페이스를 사용하는 대기 쿼리와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="3bf79a210f5bff70979738390a60829a46b95975" translate="yes" xml:space="preserve">
          <source>Drops all temporary tables created in the current session.</source>
          <target state="translated">현재 세션에서 생성 된 모든 임시 테이블을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="28e3182564ff9f2b19110ace5eed1b5ef4dc68a6" translate="yes" xml:space="preserve">
          <source>Drops the physical or logical replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. Same as replication protocol command &lt;code&gt;DROP_REPLICATION_SLOT&lt;/code&gt;. For logical slots, this must be called when connected to the same database the slot was created on.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; 이라는 물리적 또는 논리적 복제 슬롯을 삭제합니다 . 복제 프로토콜 명령 &lt;code&gt;DROP_REPLICATION_SLOT&lt;/code&gt; 과 동일합니다 . 논리 슬롯의 경우 슬롯이 작성된 동일한 데이터베이스에 연결될 때 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="249a92306df3ef1552be6df01f06ada7d810ccde" translate="yes" xml:space="preserve">
          <source>Drops the physical or logical replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. Same as replication protocol command &lt;code&gt;DROP_REPLICATION_SLOT&lt;/code&gt;. For logical slots, this must be called while connected to the same database the slot was created on.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; 이라는 물리적 또는 논리적 복제 슬롯을 삭제합니다 . 복제 프로토콜 명령 &lt;code&gt;DROP_REPLICATION_SLOT&lt;/code&gt; 과 동일합니다 . 논리적 슬롯의 경우 슬롯이 생성 된 동일한 데이터베이스에 연결되어있는 동안 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="258c60100861b523b967c0638c700489453c1860" translate="yes" xml:space="preserve">
          <source>Due to implementation restrictions, DCL operations do not check permissions.</source>
          <target state="translated">구현 제한으로 인해 DCL 작업은 권한을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28747ebea8da10721c1430a1e3600b6360d8fc6d" translate="yes" xml:space="preserve">
          <source>Due to implementation restrictions, some DDL operations do not check permissions.</source>
          <target state="translated">구현 제한으로 인해 일부 DDL 작업은 권한을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00b39d3da7dc0222f671ae4e16cb733b95cfc11d" translate="yes" xml:space="preserve">
          <source>Due to the nature of SELinux, running the regression tests for &lt;code&gt;sepgsql&lt;/code&gt; requires several extra configuration steps, some of which must be done as root. The regression tests will not be run by an ordinary &lt;code&gt;make check&lt;/code&gt; or &lt;code&gt;make installcheck&lt;/code&gt; command; you must set up the configuration and then invoke the test script manually. The tests must be run in the &lt;code&gt;contrib/sepgsql&lt;/code&gt; directory of a configured PostgreSQL build tree. Although they require a build tree, the tests are designed to be executed against an installed server, that is they are comparable to &lt;code&gt;make installcheck&lt;/code&gt; not &lt;code&gt;make check&lt;/code&gt;.</source>
          <target state="translated">SELinux의 특성상 &lt;code&gt;sepgsql&lt;/code&gt; 에 대한 회귀 테스트를 실행 하려면 몇 가지 추가 구성 단계가 필요 하며이 중 일부는 루트로 수행해야합니다. 회귀 테스트는 일반적인 &lt;code&gt;make check&lt;/code&gt; 또는 &lt;code&gt;make installcheck&lt;/code&gt; 명령 으로 실행되지 않습니다 . 구성을 설정 한 다음 테스트 스크립트를 수동으로 호출해야합니다. 테스트는 구성된 PostgreSQL 빌드 트리 의 &lt;code&gt;contrib/sepgsql&lt;/code&gt; 디렉토리 에서 실행해야합니다 . 빌드 트리가 필요하지만 테스트는 설치된 서버에 대해 실행되도록 설계되었습니다. 즉, &lt;code&gt;make installcheck&lt;/code&gt; &lt;code&gt;make check&lt;/code&gt; 하지 않도록 하는 것과 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="45ec1692682503d82d8975d2c913c5404a874c98" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands (rather than &lt;code&gt;COPY&lt;/code&gt;). Controls the maximum number of rows per &lt;code&gt;INSERT&lt;/code&gt; command. The value specified must be a number greater than zero. Any error during reloading will cause only rows that are part of the problematic &lt;code&gt;INSERT&lt;/code&gt; to be lost, rather than the entire table contents.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 대신 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프하십시오 . &lt;code&gt;INSERT&lt;/code&gt; 명령 당 최대 행 수를 제어합니다 . 지정된 값은 0보다 큰 숫자 여야합니다. 다시로드하는 동안 오류가 발생 하면 전체 테이블 내용이 아닌 문제가있는 &lt;code&gt;INSERT&lt;/code&gt; 의 일부인 행만 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="773e7ab91120390a7da90299d9a0a911b2e1a184" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands (rather than &lt;code&gt;COPY&lt;/code&gt;). This will make restoration very slow; it is mainly useful for making dumps that can be loaded into non-PostgreSQL databases. Any error during reloading will cause only rows that are part of the problematic &lt;code&gt;INSERT&lt;/code&gt; to be lost, rather than the entire table contents. Note that the restore might fail altogether if you have rearranged column order. The &lt;code&gt;--column-inserts&lt;/code&gt; option is safe against column order changes, though even slower.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 대신 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프하십시오 . 이렇게하면 복원이 매우 느려집니다. PostgreSQL 이외의 데이터베이스에로드 할 수있는 덤프를 만드는 데 주로 유용합니다. 다시로드하는 동안 오류가 발생 하면 전체 테이블 내용이 아닌 문제가있는 &lt;code&gt;INSERT&lt;/code&gt; 의 일부인 행만 손실됩니다. 열 순서를 재정렬하면 복원이 완전히 실패 할 수 있습니다. &lt;code&gt;--column-inserts&lt;/code&gt; 옵션도 느린 불구하고, 열 순서 변경에 대한 안전합니다.</target>
        </trans-unit>
        <trans-unit id="e7a8de54701108e6f3f264904f89316e6abaa91e" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands (rather than &lt;code&gt;COPY&lt;/code&gt;). This will make restoration very slow; it is mainly useful for making dumps that can be loaded into non-PostgreSQL databases. Note that the restore might fail altogether if you have rearranged column order. The &lt;code&gt;--column-inserts&lt;/code&gt; option is safer, though even slower.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 대신 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프하십시오 . 이렇게하면 복원이 매우 느려집니다. PostgreSQL 이외의 데이터베이스에로드 할 수있는 덤프를 만드는 데 주로 유용합니다. 열 순서를 재정렬하면 복원이 완전히 실패 할 수 있습니다. &lt;code&gt;--column-inserts&lt;/code&gt; 옵션도 느린하지만, 안전합니다.</target>
        </trans-unit>
        <trans-unit id="be2e3a27442d383522945fa01292f4bd454153b9" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands with explicit column names (&lt;code&gt;INSERT INTO table (column, ...) VALUES ...&lt;/code&gt;). This will make restoration very slow; it is mainly useful for making dumps that can be loaded into non-PostgreSQL databases.</source>
          <target state="translated">명시적인 열 이름을 가진 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프 합니다 ( &lt;code&gt;INSERT INTO table (column, ...) VALUES ...&lt;/code&gt; ). 이렇게하면 복원이 매우 느려집니다. PostgreSQL 이외의 데이터베이스에로드 할 수있는 덤프를 만드는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b2744b71a20f76757bc5ec4a25669195de11873e" translate="yes" xml:space="preserve">
          <source>Dump data as &lt;code&gt;INSERT&lt;/code&gt; commands with explicit column names (&lt;code&gt;INSERT INTO table (column, ...) VALUES ...&lt;/code&gt;). This will make restoration very slow; it is mainly useful for making dumps that can be loaded into non-PostgreSQL databases. Any error during reloading will cause only rows that are part of the problematic &lt;code&gt;INSERT&lt;/code&gt; to be lost, rather than the entire table contents.</source>
          <target state="translated">명시 적 열 이름을 가진 &lt;code&gt;INSERT&lt;/code&gt; 명령으로 데이터를 덤프하십시오 ( &lt;code&gt;INSERT INTO table (column, ...) VALUES ...&lt;/code&gt; ). 이렇게하면 복원이 매우 느려집니다. PostgreSQL 이외의 데이터베이스에로드 할 수있는 덤프를 만드는 데 주로 유용합니다. 다시로드하는 동안 오류가 발생 하면 전체 테이블 내용이 아닌 문제가있는 &lt;code&gt;INSERT&lt;/code&gt; 의 일부인 행만 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="05e13a7e94996a48baf836ba10162b8d102ea084" translate="yes" xml:space="preserve">
          <source>Dump only global objects (roles and tablespaces), no databases.</source>
          <target state="translated">데이터베이스가없는 글로벌 오브젝트 (역할 및 테이블 스페이스) 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="d9f11940d71cc1177f78da933c7fb53c94282ba1" translate="yes" xml:space="preserve">
          <source>Dump only roles, no databases or tablespaces.</source>
          <target state="translated">데이터베이스 나 테이블 스페이스가없는 역할 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="3be4414a016284bddab6610f6c90725d7c59716a" translate="yes" xml:space="preserve">
          <source>Dump only schemas matching &lt;code&gt;pattern&lt;/code&gt;; this selects both the schema itself, and all its contained objects. When this option is not specified, all non-system schemas in the target database will be dumped. Multiple schemas can be selected by writing multiple &lt;code&gt;-n&lt;/code&gt; switches. The &lt;code&gt;pattern&lt;/code&gt; parameter is interpreted as a pattern according to the same rules used by psql's &lt;code&gt;\d&lt;/code&gt; commands (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt; below), so multiple schemas can also be selected by writing wildcard characters in the pattern. When using wildcards, be careful to quote the pattern if needed to prevent the shell from expanding the wildcards; see &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;Examples&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치하는 스키마 만 덤프합니다 . 이렇게하면 스키마 자체와 포함 된 모든 개체가 모두 선택됩니다. 이 옵션을 지정하지 않으면 대상 데이터베이스의 모든 비 시스템 스키마가 덤프됩니다. &lt;code&gt;-n&lt;/code&gt; 스위치를 여러 개 작성하여 여러 스키마를 선택할 수 있습니다 . &lt;code&gt;pattern&lt;/code&gt; 파라미터의 psql를 사용하는 것과 같은 규칙에 따른 패턴으로 해석 &lt;code&gt;\d&lt;/code&gt; 명령 (참조 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; 이하)를 위해 다중 스키마는 또한 패턴에 와일드 카드 문자를 기록함으로써 선택 될 수있다. 와일드 카드를 사용할 때, 쉘이 와일드 카드를 확장하지 못하도록 필요한 경우 패턴을 인용하도록주의하십시오. 아래의 &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="18e2fd63c0671c6e33c31501010f51773fc9ac11" translate="yes" xml:space="preserve">
          <source>Dump only schemas matching &lt;code&gt;pattern&lt;/code&gt;; this selects both the schema itself, and all its contained objects. When this option is not specified, all non-system schemas in the target database will be dumped. Multiple schemas can be selected by writing multiple &lt;code&gt;-n&lt;/code&gt; switches. The &lt;code&gt;pattern&lt;/code&gt; parameter is interpreted as a pattern according to the same rules used by psql's &lt;code&gt;\d&lt;/code&gt; commands (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt;), so multiple schemas can also be selected by writing wildcard characters in the pattern. When using wildcards, be careful to quote the pattern if needed to prevent the shell from expanding the wildcards; see &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;Examples&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치하는 스키마 만 덤프하십시오 . 스키마 자체와 포함 된 모든 개체를 모두 선택합니다. 이 옵션을 지정하지 않으면 대상 데이터베이스의 모든 비 시스템 스키마가 덤프됩니다. 여러 개의 &lt;code&gt;-n&lt;/code&gt; 스위치 를 작성하여 여러 스키마를 선택할 수 있습니다 . &lt;code&gt;pattern&lt;/code&gt; 파라미터의 psql를 사용하는 것과 같은 규칙에 따른 패턴으로 해석 &lt;code&gt;\d&lt;/code&gt; 명령 (참조 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; )이므로 여러 스키마는 또한 패턴에 와일드 카드 문자를 기록함으로써 선택 될 수있다. 와일드 카드를 사용할 때 쉘이 와일드 카드를 확장하지 못하게하려면 필요한 경우 패턴을 인용하십시오. &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82d464e541415e383825ea221c467f7ff042a561" translate="yes" xml:space="preserve">
          <source>Dump only tables with names matching &lt;code&gt;pattern&lt;/code&gt;. For this purpose, &amp;ldquo;table&amp;rdquo; includes views, materialized views, sequences, and foreign tables. Multiple tables can be selected by writing multiple &lt;code&gt;-t&lt;/code&gt; switches. The &lt;code&gt;pattern&lt;/code&gt; parameter is interpreted as a pattern according to the same rules used by psql's &lt;code&gt;\d&lt;/code&gt; commands (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt;), so multiple tables can also be selected by writing wildcard characters in the pattern. When using wildcards, be careful to quote the pattern if needed to prevent the shell from expanding the wildcards; see &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;Examples&lt;/a&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;pattern&lt;/code&gt; 과 일치하는 테이블 만 덤프하십시오 . 이를 위해&amp;ldquo;테이블&amp;rdquo;에는 뷰, 구체화 된 뷰, 시퀀스 및 외부 테이블이 포함됩니다. 여러 개의 &lt;code&gt;-t&lt;/code&gt; 스위치 를 작성하여 여러 테이블을 선택할 수 있습니다 . &lt;code&gt;pattern&lt;/code&gt; 파라미터의 psql를 사용하는 것과 같은 규칙에 따른 패턴으로 해석 &lt;code&gt;\d&lt;/code&gt; 명령 (참조 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; ) 때문에 다중 테이블은 패턴에 와일드 카드 문자를 기록함으로써 선택 될 수있다. 와일드 카드를 사용할 때 쉘이 와일드 카드를 확장하지 못하게하려면 필요한 경우 패턴을 인용하십시오. &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b287345a0d6c965d789d7c4139247dfe38d41f8" translate="yes" xml:space="preserve">
          <source>Dump only tables with names matching &lt;code&gt;pattern&lt;/code&gt;. Multiple tables can be selected by writing multiple &lt;code&gt;-t&lt;/code&gt; switches. The &lt;code&gt;pattern&lt;/code&gt; parameter is interpreted as a pattern according to the same rules used by psql's &lt;code&gt;\d&lt;/code&gt; commands (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt; below), so multiple tables can also be selected by writing wildcard characters in the pattern. When using wildcards, be careful to quote the pattern if needed to prevent the shell from expanding the wildcards; see &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;Examples&lt;/a&gt; below.</source>
          <target state="translated">이름이 &lt;code&gt;pattern&lt;/code&gt; 과 일치하는 테이블 만 덤프합니다 . 여러 &lt;code&gt;-t&lt;/code&gt; 스위치 를 작성하여 여러 테이블을 선택할 수 있습니다 . &lt;code&gt;pattern&lt;/code&gt; 파라미터의 psql를 사용하는 것과 같은 규칙에 따른 패턴으로 해석 &lt;code&gt;\d&lt;/code&gt; 명령 (참조 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; 이하)를 위해 다중 테이블은 패턴에 와일드 카드 문자를 기록함으로써 선택 될 수있다. 와일드 카드를 사용할 때, 쉘이 와일드 카드를 확장하지 못하도록 필요한 경우 패턴을 인용하도록주의하십시오. 아래의 &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c50b3cf78208c818ebec3a1ce26491ce4dec1b6" translate="yes" xml:space="preserve">
          <source>Dump only tablespaces, no databases or roles.</source>
          <target state="translated">데이터베이스 나 역할이없는 테이블 스페이스 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="95679ba0c9930eb2f5afc93c363ee358885b7464" translate="yes" xml:space="preserve">
          <source>Dump only the data, not the schema (data definitions).</source>
          <target state="translated">스키마가 아닌 데이터 만 덤프하십시오 (데이터 정의).</target>
        </trans-unit>
        <trans-unit id="94c497beb41584499029745f0d584ed2d822c652" translate="yes" xml:space="preserve">
          <source>Dump only the data, not the schema (data definitions). Table data, large objects, and sequence values are dumped.</source>
          <target state="translated">스키마가 아닌 데이터 만 덤프하십시오 (데이터 정의). 테이블 데이터, 큰 객체 및 시퀀스 값이 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="8d61d7a6561789d6bec3f419956bd92574a77822" translate="yes" xml:space="preserve">
          <source>Dump only the object definitions (schema), not data.</source>
          <target state="translated">데이터가 아닌 오브젝트 정의 (스키마) 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="4c41ecc9dbf8b96d131dab3f2b5bece705d874ca" translate="yes" xml:space="preserve">
          <source>Dump scripts generated by pg_dump automatically apply several, but not all, of the above guidelines. To reload a pg_dump dump as quickly as possible, you need to do a few extra things manually. (Note that these points apply while &lt;em&gt;restoring&lt;/em&gt; a dump, not while &lt;em&gt;creating&lt;/em&gt; it. The same points apply whether loading a text dump with psql or using pg_restore to load from a pg_dump archive file.)</source>
          <target state="translated">pg_dump에 의해 생성 된 덤프 스크립트는 위의 지침 중 일부만 자동으로 적용됩니다. pg_dump 덤프를 가능한 빨리 재로드하려면 몇 가지 추가 작업을 수동으로 수행해야합니다. (이 포인트 는 덤프를 &lt;em&gt;작성&lt;/em&gt; 하는 동안이 아니라 덤프 를 &lt;em&gt;복원&lt;/em&gt; 하는 동안 적용됩니다 . psql로 텍스트 덤프를로드하거나 pg_restore를 사용하여 pg_dump 아카이브 파일에서로드 할 때 동일한 포인트가 적용됩니다.)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4498927e8c9c14cfc4faf82c2601f28c9ec3a7df" translate="yes" xml:space="preserve">
          <source>Dump the data for any foreign table with a foreign server matching &lt;code&gt;foreignserver&lt;/code&gt; pattern. Multiple foreign servers can be selected by writing multiple &lt;code&gt;--include-foreign-data&lt;/code&gt; switches. Also, the &lt;code&gt;foreignserver&lt;/code&gt; parameter is interpreted as a pattern according to the same rules used by psql's &lt;code&gt;\d&lt;/code&gt; commands (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt; below), so multiple foreign servers can also be selected by writing wildcard characters in the pattern. When using wildcards, be careful to quote the pattern if needed to prevent the shell from expanding the wildcards; see &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;Examples&lt;/a&gt; below. The only exception is that an empty pattern is disallowed.</source>
          <target state="translated">&lt;code&gt;foreignserver&lt;/code&gt; 패턴과 일치하는 외부 서버가있는 외부 테이블의 데이터를 덤프하십시오 . 여러 개의 &lt;code&gt;--include-foreign-data&lt;/code&gt; 스위치 를 작성하여 여러 외부 서버를 선택할 수 있습니다 . 또한 &lt;code&gt;foreignserver&lt;/code&gt; 매개 변수는 psql의 &lt;code&gt;\d&lt;/code&gt; 명령 (아래 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; 참조)에서 사용하는 것과 동일한 규칙에 따라 패턴으로 해석되므로 패턴에 와일드 카드 문자를 작성하여 여러 외부 서버를 선택할 수도 있습니다. 와일드 카드를 사용할 때, 쉘이 와일드 카드를 확장하지 못하도록 필요한 경우 패턴을 인용하도록주의하십시오. 아래의 &lt;a href=&quot;app-pgdump#PG-DUMP-EXAMPLES&quot;&gt;예를&lt;/a&gt; 참조하십시오 . 유일한 예외는 빈 패턴이 허용되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aaabbf2e5086464616dc82d516df8ab03c355c59" translate="yes" xml:space="preserve">
          <source>Dumps can be output in script or archive file formats. Script dumps are plain-text files containing the SQL commands required to reconstruct the database to the state it was in at the time it was saved. To restore from such a script, feed it to &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Script files can be used to reconstruct the database even on other machines and other architectures; with some modifications, even on other SQL database products.</source>
          <target state="translated">덤프는 스크립트 또는 아카이브 파일 형식으로 출력 될 수 있습니다. 스크립트 덤프는 데이터베이스를 저장된 당시의 상태로 재구성하는 데 필요한 SQL 명령이 포함 된 일반 텍스트 파일입니다. 이러한 스크립트에서 복원하려면 &lt;a href=&quot;app-psql&quot;&gt;psql에&lt;/a&gt; 공급하십시오 . 스크립트 파일을 사용하여 다른 시스템 및 다른 아키텍처에서도 데이터베이스를 재구성 할 수 있습니다. 다른 SQL 데이터베이스 제품에서도 약간의 수정이있었습니다.</target>
        </trans-unit>
        <trans-unit id="eaf1baa1f617ecb2911c60562e4fdfbca8276c9b" translate="yes" xml:space="preserve">
          <source>Dumps created by pg_dump are internally consistent, meaning, the dump represents a snapshot of the database at the time pg_dump began running. pg_dump does not block other operations on the database while it is working. (Exceptions are those operations that need to operate with an exclusive lock, such as most forms of &lt;code&gt;ALTER TABLE&lt;/code&gt;.)</source>
          <target state="translated">pg_dump에 의해 생성 된 덤프는 내부적으로 일관성이 있습니다. 즉, 덤프는 pg_dump가 시작된 시점의 데이터베이스 스냅 샷을 나타냅니다. pg_dump는 데이터베이스가 작동하는 동안 다른 작업을 차단하지 않습니다. (대부분의 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식과 같은 독점 잠금으로 작동해야하는 작업은 예외 입니다.)</target>
        </trans-unit>
        <trans-unit id="74dd08678521bd750ecafbc34a117a08ebb03272" translate="yes" xml:space="preserve">
          <source>Durability</source>
          <target state="translated">Durability</target>
        </trans-unit>
        <trans-unit id="88534ad7513782c209091770ebf75e66a9535341" translate="yes" xml:space="preserve">
          <source>Durability is a database feature that guarantees the recording of committed transactions even if the server crashes or loses power. However, durability adds significant database overhead, so if your site does not require such a guarantee, PostgreSQL can be configured to run much faster. The following are configuration changes you can make to improve performance in such cases. Except as noted below, durability is still guaranteed in case of a crash of the database software; only abrupt operating system stoppage creates a risk of data loss or corruption when these settings are used.</source>
          <target state="translated">내구성은 서버가 중단되거나 전원이 꺼진 경우에도 커밋 된 트랜잭션의 기록을 보장하는 데이터베이스 기능입니다. 그러나 내구성으로 인해 데이터베이스 오버 헤드가 크게 증가하므로 사이트에서 이러한 보장이 필요하지 않은 경우 PostgreSQL을 훨씬 빠르게 실행하도록 구성 할 수 있습니다. 다음은 이러한 경우 성능을 향상시키기 위해 수행 할 수있는 구성 변경입니다. 아래에 언급 된 경우를 제외하고 데이터베이스 소프트웨어의 충돌시 내구성은 여전히 ​​보장됩니다. 이러한 설정을 사용하면 갑작스러운 운영 체제 중지만으로 데이터가 손실되거나 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f1f3bb500eb22bbc0932ef88126441697bb253d" translate="yes" xml:space="preserve">
          <source>Duration relative to &lt;code&gt;md5 hash&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;md5 hash&lt;/code&gt; 관련된 기간</target>
        </trans-unit>
        <trans-unit id="02c6b2056e308ac26d87da4c64b11f9b031969c7" translate="yes" xml:space="preserve">
          <source>During a daylight-savings-time transition, it is possible for a seemingly valid timestamp string to represent a nonexistent or ambiguous timestamp. Such cases are not rejected; the ambiguity is resolved by determining which UTC offset to apply. For example, supposing that the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; parameter is set to &lt;code&gt;America/New_York&lt;/code&gt;, consider</source>
          <target state="translated">일광 절약 시간제 전환 중에는 유효한 타임 스탬프 문자열이 존재하지 않거나 모호한 타임 스탬프를 나타낼 수 있습니다. 이러한 경우는 기각되지 않습니다. 적용 할 UTC 오프셋을 결정하여 모호성을 해결합니다. 예를 들어, 것을 가정하여 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;시간대의&lt;/a&gt; 매개 변수로 설정되어 &lt;code&gt;America/New_York&lt;/code&gt; , 고려</target>
        </trans-unit>
        <trans-unit id="649d7eaff87026bc3227c40d2cbf9934eabfe840" translate="yes" xml:space="preserve">
          <source>During a query that references any remote tables on a foreign server, &lt;code&gt;postgres_fdw&lt;/code&gt; opens a transaction on the remote server if one is not already open corresponding to the current local transaction. The remote transaction is committed or aborted when the local transaction commits or aborts. Savepoints are similarly managed by creating corresponding remote savepoints.</source>
          <target state="translated">외부 서버의 원격 테이블을 참조하는 쿼리 중에 &lt;code&gt;postgres_fdw&lt;/code&gt; 는 원격 서버에서 현재 로컬 트랜잭션에 해당하는 트랜잭션이 아직 열려 있지 않은 경우 원격 서버에서 트랜잭션을 엽니 다. 로컬 트랜잭션이 커밋되거나 중단되면 원격 트랜잭션이 커밋되거나 중단됩니다. 저장 점은 해당 원격 저장 점을 작성하여 유사하게 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="376142efafb26017135a78a9b3a0f82b773855c9" translate="yes" xml:space="preserve">
          <source>During a series of insertions into an existing GIN index that has &lt;code&gt;fastupdate&lt;/code&gt; enabled, the system will clean up the pending-entry list whenever the list grows larger than &lt;code&gt;gin_pending_list_limit&lt;/code&gt;. To avoid fluctuations in observed response time, it's desirable to have pending-list cleanup occur in the background (i.e., via autovacuum). Foreground cleanup operations can be avoided by increasing &lt;code&gt;gin_pending_list_limit&lt;/code&gt; or making autovacuum more aggressive. However, enlarging the threshold of the cleanup operation means that if a foreground cleanup does occur, it will take even longer.</source>
          <target state="translated">&lt;code&gt;fastupdate&lt;/code&gt; 활성화 된 기존 GIN 인덱스에 일련의 삽입하는 동안 시스템은 목록이 &lt;code&gt;gin_pending_list_limit&lt;/code&gt; 보다 커질 때마다 보류중인 항목 목록을 정리합니다 . 관찰 된 응답 시간의 변동을 피하기 위해, 대기-목록 정리가 백그라운드에서 발생하는 것이 바람직하다 (즉, 자동 진공을 통해). &lt;code&gt;gin_pending_list_limit&lt;/code&gt; 를 늘리 거나 autovacuum을보다 공격적으로 만들면 전경 정리 작업을 피할 수 있습니다 . 그러나 정리 작업의 임계 값을 늘리면 포 그라운드 정리가 발생하면 시간이 더 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="e665b83d95fa89018b4471ab2b6da31bdceb1a0a" translate="yes" xml:space="preserve">
          <source>During actual execution of the query plan. Partition pruning may also be performed here to remove partitions using values which are only known during actual query execution. This includes values from subqueries and values from execution-time parameters such as those from parameterized nested loop joins. Since the value of these parameters may change many times during the execution of the query, partition pruning is performed whenever one of the execution parameters being used by partition pruning changes. Determining if partitions were pruned during this phase requires careful inspection of the &lt;code&gt;loops&lt;/code&gt; property in the &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; output. Subplans corresponding to different partitions may have different values for it depending on how many times each of them was pruned during execution. Some may be shown as &lt;code&gt;(never executed)&lt;/code&gt; if they were pruned every time.</source>
          <target state="translated">쿼리 계획을 실제로 실행하는 동안 실제 쿼리 실행 중에 만 알려진 값을 사용하여 파티션을 제거하기 위해 파티션 정리를 수행 할 수도 있습니다. 여기에는 하위 쿼리의 값과 매개 변수화 된 중첩 루프 조인의 값과 같은 실행 시간 매개 변수의 값이 포함됩니다. 이러한 매개 변수의 값은 조회 실행 중에 여러 번 변경 될 수 있으므로, 파티션 프 루닝 변경에 의해 실행 매개 변수 중 하나가 사용될 때마다 파티션 프 루닝이 수행됩니다. 이 단계에서 파티션이 프룬되었는지 판별하려면 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 에서 &lt;code&gt;loops&lt;/code&gt; 특성을 신중하게 검사해야합니다.산출. 다른 파티션에 해당하는 서브 플랜은 각 파티션이 실행 중에 정리 된 횟수에 따라 다른 값을 가질 수 있습니다. 매번 정리 된 경우 일부는 &lt;code&gt;(never executed)&lt;/code&gt; 않음)으로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63efb16fc413c0d7ad6b7e818ea4ee467528e158" translate="yes" xml:space="preserve">
          <source>During hot standby, the parameter &lt;code&gt;transaction_read_only&lt;/code&gt; is always true and may not be changed. But as long as no attempt is made to modify the database, connections during hot standby will act much like any other database connection. If failover or switchover occurs, the database will switch to normal processing mode. Sessions will remain connected while the server changes mode. Once hot standby finishes, it will be possible to initiate read-write transactions (even from a session begun during hot standby).</source>
          <target state="translated">상시 대기 중 &lt;code&gt;transaction_read_only&lt;/code&gt; 매개 변수 는 항상 true이며 변경할 수 없습니다. 그러나 데이터베이스를 수정하려고 시도하지 않는 한, 핫 스탠바이 동안의 연결은 다른 데이터베이스 연결과 매우 유사하게 작동합니다. 장애 조치 또는 전환이 발생하면 데이터베이스는 일반 처리 모드로 전환됩니다. 서버가 모드를 변경하는 동안 세션은 연결된 상태로 유지됩니다. 핫 스탠바이가 완료되면 (핫 스탠바이 중에 시작된 세션에서도) 읽기-쓰기 트랜잭션을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98920c65ae127f00513b833551d1231b0ae54aef" translate="yes" xml:space="preserve">
          <source>During initialization of the query plan. Partition pruning can be performed here for parameter values which are known during the initialization phase of execution. Partitions which are pruned during this stage will not show up in the query's &lt;code&gt;EXPLAIN&lt;/code&gt; or &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;. It is possible to determine the number of partitions which were removed during this phase by observing the &amp;ldquo;Subplans Removed&amp;rdquo; property in the &lt;code&gt;EXPLAIN&lt;/code&gt; output.</source>
          <target state="translated">쿼리 계획을 초기화하는 동안 실행 초기화 단계에서 알려진 매개 변수 값에 대해 파티션 정리를 수행 할 수 있습니다. 이 단계에서 정리 된 파티션은 쿼리의 &lt;code&gt;EXPLAIN&lt;/code&gt; 또는 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 에 표시되지 않습니다 . &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 에서 &quot;Subplans Removed&quot;속성을 관찰하여이 단계 동안 제거 된 파티션 수를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcd1cf4071c0223f011ef29f707521b1833e5ad0" translate="yes" xml:space="preserve">
          <source>During installation an appropriate configuration is selected and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; is set accordingly in &lt;code&gt;postgresql.conf&lt;/code&gt;. If you are using the same text search configuration for the entire cluster you can use the value in &lt;code&gt;postgresql.conf&lt;/code&gt;. To use different configurations throughout the cluster but the same configuration within any one database, use &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt;. Otherwise, you can set &lt;code&gt;default_text_search_config&lt;/code&gt; in each session.</source>
          <target state="translated">설치하는 동안 적절한 구성이 선택되고 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; 가 설정됩니다 . 전체 클러스터에 대해 동일한 텍스트 검색 구성을 사용하는 경우 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 값을 사용할 수 있습니다 . 클러스터 전체에서 다른 구성을 사용하지만 한 데이터베이스 내에서 동일한 구성을 사용하려면 &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt; . 그렇지 않으면 각 세션에서 &lt;code&gt;default_text_search_config&lt;/code&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eccf031bb1a6ebed76c6dc48278b20f95064a8ed" translate="yes" xml:space="preserve">
          <source>During server startup, parameter settings can be passed to the &lt;code&gt;postgres&lt;/code&gt; command via the &lt;code&gt;-c&lt;/code&gt; command-line parameter. For example,</source>
          <target state="translated">서버 시작 중에 &lt;code&gt;-c&lt;/code&gt; 명령 줄 매개 변수 를 통해 매개 변수 설정을 &lt;code&gt;postgres&lt;/code&gt; 명령 으로 전달할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="079a296ff5b5be1f0458b0eea0b5b8b0a01f3f04" translate="yes" xml:space="preserve">
          <source>During the execution of &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; commands, the system maintains an internal counter that keeps track of the estimated cost of the various I/O operations that are performed. When the accumulated cost reaches a limit (specified by &lt;code&gt;vacuum_cost_limit&lt;/code&gt;), the process performing the operation will sleep for a short period of time, as specified by &lt;code&gt;vacuum_cost_delay&lt;/code&gt;. Then it will reset the counter and continue execution.</source>
          <target state="translated">&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 및 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 실행하는 동안 시스템은 수행되는 다양한 I / O 작업의 예상 비용을 추적하는 내부 카운터를 유지 관리합니다. 누적 비용이 한계에 도달하면 ( &lt;code&gt;vacuum_cost_limit&lt;/code&gt; 로 지정됨 ) vacuum_cost_delay에 지정된대로 조작을 수행하는 프로세스가 짧은 시간 동안 휴면 상태가 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; . 그런 다음 카운터를 재설정하고 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="87a76b8e4b15674f0f67d6633c956f38b093285c" translate="yes" xml:space="preserve">
          <source>Dynamic Tracing</source>
          <target state="translated">동적 추적</target>
        </trans-unit>
        <trans-unit id="713a44108c01ba93077b4f4f0d58807f38a85305" translate="yes" xml:space="preserve">
          <source>Dynamic domain transitions should be considered carefully, because they allow users to switch their label, and therefore their privileges, at their option, rather than (as in the case of a trusted procedure) as mandated by the system. Thus, the &lt;code&gt;dyntransition&lt;/code&gt; permission is only considered safe when used to switch to a domain with a smaller set of privileges than the original one. For example:</source>
          <target state="translated">동적 도메인 전환은 사용자가 시스템에서 지정한대로 (신뢰할 수있는 절차의 경우와 같이) 자신의 선택에 따라 레이블과 권한을 전환 할 수 있도록주의해서 고려해야합니다. 따라서 &lt;code&gt;dyntransition&lt;/code&gt; 권한은 원래 권한보다 더 작은 권한 집합을 가진 도메인으로 전환하는 데 사용될 때만 안전한 것으로 간주됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c124e6336755449222656c78278aee8224bd8a12" translate="yes" xml:space="preserve">
          <source>Dynamically loadable modules work, including &lt;code&gt;pg_stat_statements&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; 를 포함하여 동적으로로드 가능한 모듈이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="6a879b77c2521dc21654838b1ef36fe63eea51a7" translate="yes" xml:space="preserve">
          <source>E-Mail of Cryptocom OpenSSL development group: &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:openssl@cryptocom.ru&quot;&gt;openssl@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Cryptocom OpenSSL 개발 그룹의 이메일 : &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:openssl@cryptocom.ru&quot;&gt;openssl@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9444b51afb6d88079dadef6a3aae007418cea1d" translate="yes" xml:space="preserve">
          <source>EAN13 numbers aren't always ISBN13, ISMN13 or ISSN13 (some are).</source>
          <target state="translated">EAN13 번호가 항상 ISBN13, ISMN13 또는 ISSN13 (일부) 인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6544628da02c21bc6dadd46248d452c1cf9af913" translate="yes" xml:space="preserve">
          <source>ECPG</source>
          <target state="translated">ECPG</target>
        </trans-unit>
        <trans-unit id="d205abee3d2a71688a6b66568be289a94050031c" translate="yes" xml:space="preserve">
          <source>END</source>
          <target state="translated">END</target>
        </trans-unit>
        <trans-unit id="8fac2036001ae3f80847916907033e4cfe81af30" translate="yes" xml:space="preserve">
          <source>END &amp;mdash; commit the current transaction</source>
          <target state="translated">종료 &amp;mdash; 현재 거래 커밋</target>
        </trans-unit>
        <trans-unit id="1608f513c48df25cff4b9dccf8ad4db68426771c" translate="yes" xml:space="preserve">
          <source>ESQL</source>
          <target state="translated">ESQL</target>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="790392d6b839abbb5b061152b6a3114de84502b4" translate="yes" xml:space="preserve">
          <source>EXECUTE</source>
          <target state="translated">EXECUTE</target>
        </trans-unit>
        <trans-unit id="c4cb7766ac2508346a678d94a4e10d75ba028e5b" translate="yes" xml:space="preserve">
          <source>EXECUTE &amp;mdash; execute a prepared statement</source>
          <target state="translated">EXECUTE &amp;mdash; 준비된 문장을 실행</target>
        </trans-unit>
        <trans-unit id="4f7eee905948e6076168f8edbc3bf97ae8823930" translate="yes" xml:space="preserve">
          <source>EXPLAIN</source>
          <target state="translated">EXPLAIN</target>
        </trans-unit>
        <trans-unit id="efc2c00ebfdf6ae3c760f83f873743b150a0fd4b" translate="yes" xml:space="preserve">
          <source>EXPLAIN &amp;mdash; show the execution plan of a statement</source>
          <target state="translated">EXPLAIN &amp;mdash; 문장의 실행 계획을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="0eef064be41e6afcc8812bb71602a4ebf2f8f3c9" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;.dat&lt;/code&gt; file contains Perl data structure literals that are simply eval'd to produce an in-memory data structure consisting of an array of hash references, one per catalog row. A slightly modified excerpt from &lt;code&gt;pg_database.dat&lt;/code&gt; will demonstrate the key features:</source>
          <target state="translated">각 &lt;code&gt;.dat&lt;/code&gt; 파일에는 카탈로그 행당 하나씩 해시 참조 배열로 구성된 메모리 내 데이터 구조를 생성하기 위해 평가 된 Perl 데이터 구조 리터럴이 포함되어 있습니다. &lt;code&gt;pg_database.dat&lt;/code&gt; 에서 약간 수정 된 내용은 다음 과 같은 주요 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="52629a868eedbea648b7a4a638a5af4aed7eaf71" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;amcostestimate&lt;/code&gt; function must have the signature:</source>
          <target state="translated">각 &lt;code&gt;amcostestimate&lt;/code&gt; 함수에는 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee555043838db244d6461d0e5cd48e5593131cd6" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;expression&lt;/code&gt; can be the name or ordinal number of an output column (&lt;code&gt;SELECT&lt;/code&gt; list item), or it can be an arbitrary expression formed from input-column values.</source>
          <target state="translated">각 &lt;code&gt;expression&lt;/code&gt; 은 출력 열의 이름 또는 서수 ( &lt;code&gt;SELECT&lt;/code&gt; 목록 항목)이거나 입력 열 값으로 구성된 임의의 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1490188fec78ab89e976340e8a306b20caeaa221" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;standby_name&lt;/code&gt; should have the form of a valid SQL identifier, unless it is &lt;code&gt;*&lt;/code&gt;. You can use double-quoting if necessary. But note that &lt;code&gt;standby_name&lt;/code&gt;s are compared to standby application names case-insensitively, whether double-quoted or not.</source>
          <target state="translated">각 &lt;code&gt;standby_name&lt;/code&gt; 은 &lt;code&gt;*&lt;/code&gt; 가 아닌 한 유효한 SQL 식별자 형식이어야합니다 . 필요한 경우 큰 따옴표를 사용할 수 있습니다. 그러나 &lt;code&gt;standby_name&lt;/code&gt; 은 인용 부호에 관계없이 대소 문자를 구분하지 않고 대기 애플리케이션 이름과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="cfcd2e76e362b6545b1b1ab46191393e33b3c350" translate="yes" xml:space="preserve">
          <source>Each ISO 8601 week-numbering year begins with the Monday of the week containing the 4th of January, so in early January or late December the ISO year may be different from the Gregorian year. See the &lt;code&gt;week&lt;/code&gt; field for more information.</source>
          <target state="translated">각 ISO 8601 주 번호 매기기 연도는 1 월 4 일을 포함하는 주 월요일부터 시작되므로 1 월 초 또는 12 월 말에 ISO 연도가 그레고리력 연도와 다를 수 있습니다. 자세한 내용은 &lt;code&gt;week&lt;/code&gt; 필드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96f0f5a7b759cd740a7c972fd3ab3c64864cb957" translate="yes" xml:space="preserve">
          <source>Each SQL command string passed to &lt;code&gt;-c&lt;/code&gt; is sent to the server as a single request. Because of this, the server executes it as a single transaction even if the string contains multiple SQL commands, unless there are explicit &lt;code&gt;BEGIN&lt;/code&gt;/&lt;code&gt;COMMIT&lt;/code&gt; commands included in the string to divide it into multiple transactions. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT&quot;&gt;Section 52.2.2.1&lt;/a&gt; for more details about how the server handles multi-query strings.) Also, psql only prints the result of the last SQL command in the string. This is different from the behavior when the same string is read from a file or fed to psql's standard input, because then psql sends each SQL command separately.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 에 전달 된 각 SQL 명령 문자열 은 단일 요청으로 서버에 전송됩니다. 이로 인해, 문자열 에 여러 트랜잭션으로 나누기 위해 명시적인 &lt;code&gt;BEGIN&lt;/code&gt; / &lt;code&gt;COMMIT&lt;/code&gt; 명령이 포함되어 있지 않으면 서버는 문자열에 여러 SQL 명령이 포함되어 있어도 단일 트랜잭션으로 서버를 실행합니다 . ( 서버가 다중 쿼리 문자열을 처리하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT&quot;&gt;52.2.2.1 단원&lt;/a&gt; 을 참조하십시오.) 또한 psql은 문자열에서 마지막 SQL 명령의 결과 만 인쇄합니다. 이는 psql이 각 SQL 명령을 개별적으로 전송하기 때문에 파일에서 동일한 문자열을 읽거나 psql의 표준 입력으로 공급할 때의 동작과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="71230532ba90bf43943bfde0ff2a54ed11dece4e" translate="yes" xml:space="preserve">
          <source>Each SQL command string passed to &lt;code&gt;-c&lt;/code&gt; is sent to the server as a single request. Because of this, the server executes it as a single transaction even if the string contains multiple SQL commands, unless there are explicit &lt;code&gt;BEGIN&lt;/code&gt;/&lt;code&gt;COMMIT&lt;/code&gt; commands included in the string to divide it into multiple transactions. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT&quot;&gt;Section 52.2.2.1&lt;/a&gt; for more details about how the server handles multi-query strings.) Also, psql only prints the result of the last SQL command in the string. This is different from the behavior when the same string is read from a file or fed to psql's standard input, because then psql sends each SQL command separately.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 에 전달 된 각 SQL 명령 문자열 은 단일 요청으로 서버에 전송됩니다. 이로 인해 서버는 문자열에 여러 SQL 명령이 포함되어 있어도 여러 트랜잭션으로 나누기 위해 문자열에 명시적인 &lt;code&gt;BEGIN&lt;/code&gt; / &lt;code&gt;COMMIT&lt;/code&gt; 명령이 포함 되지 않는 한 단일 트랜잭션으로 실행합니다 . ( 서버가 다중 쿼리 문자열을 처리하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT&quot;&gt;섹션 52.2.2.1&lt;/a&gt; 을 참조하십시오.) 또한 psql은 문자열에서 마지막 SQL 명령의 결과 만 인쇄합니다. 이것은 동일한 문자열을 파일에서 읽거나 psql의 표준 입력에 공급할 때의 동작과 다릅니다. psql이 각 SQL 명령을 개별적으로 전송하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="eda9854e68bbff726bf168438cbf61263c89d2cc" translate="yes" xml:space="preserve">
          <source>Each SQL transaction has an isolation level, which can be either &amp;ldquo;read uncommitted&amp;rdquo;, &amp;ldquo;read committed&amp;rdquo;, &amp;ldquo;repeatable read&amp;rdquo;, or &amp;ldquo;serializable&amp;rdquo;. This parameter controls the default isolation level of each new transaction. The default is &amp;ldquo;read committed&amp;rdquo;.</source>
          <target state="translated">각 SQL 트랜잭션에는 분리 커밋 수준이 있으며 &quot;커밋되지 않은 읽기&quot;, &quot;읽기 커밋 된&quot;, &quot;반복 가능한 읽기&quot;또는 &quot;직렬화 가능&quot;일 수 있습니다. 이 매개 변수는 각 새 트랜잭션의 기본 격리 레벨을 제어합니다. 기본값은 &quot;읽기 커밋&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2844b82e9d99613d9651694329c65d9f27ce77dc" translate="yes" xml:space="preserve">
          <source>Each TOAST-able data type specifies a default strategy for columns of that data type, but the strategy for a given table column can be altered with &lt;a href=&quot;sql-altertable&quot;&gt;&lt;code&gt;ALTER TABLE ... SET STORAGE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 TOAST 가능 데이터 유형은 해당 데이터 유형의 컬럼에 대한 기본 전략을 지정하지만 주어진 테이블 컬럼에 대한 전략은 &lt;a href=&quot;sql-altertable&quot;&gt; &lt;code&gt;ALTER TABLE ... SET STORAGE&lt;/code&gt; &lt;/a&gt; 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67e5e965f2d4dcd40970ff62ef3910a8ca4c0a7d" translate="yes" xml:space="preserve">
          <source>Each WAL file can be released after a &lt;a href=&quot;glossary#GLOSSARY-CHECKPOINT&quot;&gt;checkpoint&lt;/a&gt; writes all the changes in it to the corresponding data files. Releasing the file can be done either by deleting it, or by changing its name so that it will be used in the future, which is called &lt;em&gt;recycling&lt;/em&gt;.</source>
          <target state="translated">각 WAL 파일은 &lt;a href=&quot;glossary#GLOSSARY-CHECKPOINT&quot;&gt;체크 포인트가&lt;/a&gt; 모든 변경 사항을 해당 데이터 파일에 기록한 후에 해제 될 수 있습니다 . 파일 해제는 파일을 삭제하거나 나중에 사용할 수 있도록 이름을 변경하여 수행 할 수 있습니다 . 이를 &lt;em&gt;재활용&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="55aff67e18553aba02a98a4064e139e4057218c6" translate="yes" xml:space="preserve">
          <source>Each bound value can be quoted using &lt;code&gt;&quot;&lt;/code&gt; (double quote) characters. This is necessary if the bound value contains parentheses, brackets, commas, double quotes, or backslashes, since these characters would otherwise be taken as part of the range syntax. To put a double quote or backslash in a quoted bound value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted bound value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as range syntax. Also, to write a bound value that is an empty string, write &lt;code&gt;&quot;&quot;&lt;/code&gt;, since writing nothing means an infinite bound.</source>
          <target state="translated">각 바운드 값은 &lt;code&gt;&quot;&lt;/code&gt; (큰 따옴표) 문자를 사용하여 따옴표로 묶을 수 있습니다 . 바운드 값에 괄호, 괄호, 쉼표, 큰 따옴표 또는 백 슬래시가 포함 된 경우에는 이러한 문자가 범위 구문의 일부로 사용되기 때문에 필요합니다. 따옴표로 묶인 바운드 값의 큰 따옴표 또는 백 슬래시 앞에 백 슬래시를 붙입니다. (또한 큰 따옴표로 묶인 바운드 값 내의 큰 따옴표 쌍은 SQL의 작은 따옴표 규칙과 유사하게 큰 따옴표 문자를 나타 내기 위해 사용됩니다. 리터럴 문자열.) 또는 인용 부호를 피하고 백 슬래시 이스케이프를 사용하여 범위 구문으로 간주 될 모든 데이터 문자를 보호 할 수 있으며 빈 문자열 인 바운드 값을 쓰려면 아무 것도 쓰지 않기 때문에 &lt;code&gt;&quot;&quot;&lt;/code&gt; 을 쓰십시오 무한한 한계.</target>
        </trans-unit>
        <trans-unit id="0a72f66856b3e613b196ae8833ef35864d4174d8" translate="yes" xml:space="preserve">
          <source>Each catalog that has any manually-created initial data (some do not) has a corresponding &lt;code&gt;.dat&lt;/code&gt; file that contains its initial data in an editable format.</source>
          <target state="translated">수동으로 만든 초기 데이터가있는 각 카탈로그 (일부에는없는)에는 편집 가능한 형식의 초기 데이터가 포함 된 해당 &lt;code&gt;.dat&lt;/code&gt; 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="34807a2fc50e85269825ffe29ec3e43edacd5b30" translate="yes" xml:space="preserve">
          <source>Each column has a data type. The data type constrains the set of possible values that can be assigned to a column and assigns semantics to the data stored in the column so that it can be used for computations. For instance, a column declared to be of a numerical type will not accept arbitrary text strings, and the data stored in such a column can be used for mathematical computations. By contrast, a column declared to be of a character string type will accept almost any kind of data but it does not lend itself to mathematical calculations, although other operations such as string concatenation are available.</source>
          <target state="translated">각 열에는 데이터 형식이 있습니다. 데이터 형식은 열에 할당 할 수있는 가능한 값 집합을 제한하고 계산에 사용할 수 있도록 열에 저장된 데이터에 의미를 할당합니다. 예를 들어, 숫자 유형으로 선언 된 열은 임의의 텍스트 문자열을 허용하지 않으며 이러한 열에 저장된 데이터는 수학 계산에 사용될 수 있습니다. 반대로, 문자열 유형으로 선언 된 열은 거의 모든 종류의 데이터를 허용하지만 문자열 연결과 같은 다른 연산을 사용할 수는 있지만 수학 계산에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4d4f8ac998bb0bf76d30e14459d3ffb4f3fdd7a" translate="yes" xml:space="preserve">
          <source>Each column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or null if there is none.</source>
          <target state="translated">명시 적 또는 내재적 열 목록에없는 각 열은 기본값으로 선언 된 기본값이거나 채워지지 않은 경우 널로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="2cd0b247f063881e4120caeaa0c5cc15f8c99e31" translate="yes" xml:space="preserve">
          <source>Each column specification can be a column number (starting at 1) or a column name. The usual SQL case folding and quoting rules apply to column names. If omitted, &lt;code&gt;colV&lt;/code&gt; is taken as column 1 and &lt;code&gt;colH&lt;/code&gt; as column 2. &lt;code&gt;colH&lt;/code&gt; must differ from &lt;code&gt;colV&lt;/code&gt;. If &lt;code&gt;colD&lt;/code&gt; is not specified, then there must be exactly three columns in the query result, and the column that is neither &lt;code&gt;colV&lt;/code&gt; nor &lt;code&gt;colH&lt;/code&gt; is taken to be &lt;code&gt;colD&lt;/code&gt;.</source>
          <target state="translated">각 열 스펙은 열 번호 (1부터 시작) 또는 열 이름 일 수 있습니다. 일반적인 SQL 케이스 접기 및 인용 규칙은 열 이름에 적용됩니다. 생략하면 &lt;code&gt;colV&lt;/code&gt; 는 열 1로, &lt;code&gt;colH&lt;/code&gt; 는 열 2로 &lt;code&gt;colH&lt;/code&gt; &lt;code&gt;colV&lt;/code&gt; . colH 는 colV 와 달라야 합니다 . 경우 &lt;code&gt;colD&lt;/code&gt; 지정되어 있지 않은 경우, 정확히 3 질의 결과에서 열 및도 아닌 열이 있어야합니다 &lt;code&gt;colV&lt;/code&gt; 도 &lt;code&gt;colH&lt;/code&gt; 가 로 촬영 &lt;code&gt;colD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d401dabac1c5a63cbaa2ae914726d49a76a34df4" translate="yes" xml:space="preserve">
          <source>Each data type has an external representation determined by its input and output functions. Many of the built-in types have obvious external formats. However, several types are either unique to PostgreSQL, such as geometric paths, or have several possible formats, such as the date and time types. Some of the input and output functions are not invertible, i.e., the result of an output function might lose accuracy when compared to the original input.</source>
          <target state="translated">각 데이터 유형에는 입력 및 출력 기능에 의해 결정되는 외부 표현이 있습니다. 많은 내장 유형에는 명백한 외부 형식이 있습니다. 그러나 여러 유형은 기하학적 경로와 같은 PostgreSQL에 고유하거나 날짜 및 시간 유형과 같은 여러 가지 가능한 형식을 갖습니다. 일부 입력 및 출력 기능은 되돌릴 수 없습니다. 즉, 출력 기능의 결과는 원래 입력과 비교할 때 정확도가 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9202ff880e980c6a970df736a03fbff970d67727" translate="yes" xml:space="preserve">
          <source>Each enumerated data type is separate and cannot be compared with other enumerated types. See this example:</source>
          <target state="translated">열거 된 각 데이터 형식은 별개이므로 다른 열거 된 형식과 비교할 수 없습니다. 이 예제를보십시오 :</target>
        </trans-unit>
        <trans-unit id="70e86803855d294ff554c4470870fa79b45f5d14" translate="yes" xml:space="preserve">
          <source>Each function performs the visibility check for one type of database object. Note that &lt;code&gt;pg_table_is_visible&lt;/code&gt; can also be used with views, materialized views, indexes, sequences and foreign tables; &lt;code&gt;pg_function_is_visible&lt;/code&gt; can also be used with procedures and aggregates; &lt;code&gt;pg_type_is_visible&lt;/code&gt; can also be used with domains. For functions and operators, an object in the search path is visible if there is no object of the same name &lt;em&gt;and argument data type(s)&lt;/em&gt; earlier in the path. For operator classes, both name and associated index access method are considered.</source>
          <target state="translated">각 함수는 한 가지 유형의 데이터베이스 개체에 대한 가시성 검사를 수행합니다. 참고 &lt;code&gt;pg_table_is_visible&lt;/code&gt; 는 또한 뷰와 함께 사용할 수 있습니다, 뷰, 인덱스, 시퀀스 및 외국 테이블을 구체화; &lt;code&gt;pg_function_is_visible&lt;/code&gt; 은 프로 시저 및 집계와 함께 사용할 수도 있습니다. &lt;code&gt;pg_type_is_visible&lt;/code&gt; 을 도메인과 함께 사용할 수도 있습니다. 함수와 연산자의 경우 경로에 이름 &lt;em&gt;과 인수 데이터 유형&lt;/em&gt; 이 같은 개체가 없으면 검색 경로의 개체가 표시됩니다 . 연산자 클래스의 경우 이름 및 연관된 인덱스 액세스 방법이 모두 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="3cb437189cdd5811ffdded3ab110033cbf3f1b5f" translate="yes" xml:space="preserve">
          <source>Each heap and index relation, except for hash indexes, has a Free Space Map (FSM) to keep track of available space in the relation. It's stored alongside the main relation data in a separate relation fork, named after the filenode number of the relation, plus a &lt;code&gt;_fsm&lt;/code&gt; suffix. For example, if the filenode of a relation is 12345, the FSM is stored in a file called &lt;code&gt;12345_fsm&lt;/code&gt;, in the same directory as the main relation file.</source>
          <target state="translated">해시 인덱스를 제외한 각 힙 및 인덱스 관계에는 관계에서 사용 가능한 공간을 추적하기위한 FSM (Free Space Map)이 있습니다. 주요 관계 데이터와 함께 관계의 파일 노드 번호와 &lt;code&gt;_fsm&lt;/code&gt; 접미사를 따서 명명 된 별도의 관계 포크에 저장 됩니다. 예를 들어, 관계의 파일 &lt;code&gt;12345_fsm&lt;/code&gt; 가 12345 인 경우 FSM은 기본 관계 파일과 동일한 디렉토리에 12345_fsm 이라는 파일에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="bde5bfb2a3b2ea3516a48dc94ba28c29e2c03d67" translate="yes" xml:space="preserve">
          <source>Each heap relation has a Visibility Map (VM) to keep track of which pages contain only tuples that are known to be visible to all active transactions; it also keeps track of which pages contain only frozen tuples. It's stored alongside the main relation data in a separate relation fork, named after the filenode number of the relation, plus a &lt;code&gt;_vm&lt;/code&gt; suffix. For example, if the filenode of a relation is 12345, the VM is stored in a file called &lt;code&gt;12345_vm&lt;/code&gt;, in the same directory as the main relation file. Note that indexes do not have VMs.</source>
          <target state="translated">각 힙 관계에는 모든 활성 트랜잭션에 표시되는 것으로 알려진 튜플이 포함 된 페이지를 추적하는 가시성 맵 (VM)이 있습니다. 또한 고정 된 튜플 만 포함하는 페이지를 추적합니다. 기본 관계 데이터와 함께 관계의 파일 노드 번호와 &lt;code&gt;_vm&lt;/code&gt; 접미사를 따서 명명 된 별도의 관계 포크에 저장 됩니다. 예를 들어, 관계의 파일 &lt;code&gt;12345_vm&lt;/code&gt; 가 12345 인 경우 VM은 기본 관계 파일과 동일한 디렉토리에 12345_vm 이라는 파일에 저장 됩니다. 인덱스에는 VM이 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="d83c0ee46ab5aec7f645ecee3bc6fee47067fe37" translate="yes" xml:space="preserve">
          <source>Each index access method is described by a row in the &lt;a href=&quot;catalog-pg-am&quot;&gt;&lt;code&gt;pg_am&lt;/code&gt;&lt;/a&gt; system catalog. The &lt;code&gt;pg_am&lt;/code&gt; entry specifies a name and a &lt;em&gt;handler function&lt;/em&gt; for the index access method. These entries can be created and deleted using the &lt;a href=&quot;sql-create-access-method&quot;&gt;CREATE ACCESS METHOD&lt;/a&gt; and &lt;a href=&quot;sql-drop-access-method&quot;&gt;DROP ACCESS METHOD&lt;/a&gt; SQL commands.</source>
          <target state="translated">각 인덱스 액세스 방법은 &lt;a href=&quot;catalog-pg-am&quot;&gt; &lt;code&gt;pg_am&lt;/code&gt; &lt;/a&gt; 시스템 카탈로그 의 행으로 설명됩니다 . &lt;code&gt;pg_am&lt;/code&gt; 의 항목은 이름과 지정 &lt;em&gt;핸들러 함수&lt;/em&gt; 인덱스 액세스 방법이있다. 이 항목은 &lt;a href=&quot;sql-create-access-method&quot;&gt;CREATE ACCESS METHOD&lt;/a&gt; 및 &lt;a href=&quot;sql-drop-access-method&quot;&gt;DROP ACCESS METHOD&lt;/a&gt; SQL 명령을 사용하여 작성 및 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="181d4444400920b544aae648daddcab396dab897" translate="yes" xml:space="preserve">
          <source>Each individual record in a WAL file is protected by a CRC-32 (32-bit) check that allows us to tell if record contents are correct. The CRC value is set when we write each WAL record and checked during crash recovery, archive recovery and replication.</source>
          <target state="translated">WAL 파일의 각 개별 레코드는 CRC-32 (32 비트) 검사로 보호되므로 레코드 내용이 올바른지 알 수 있습니다. CRC 값은 각 WAL 레코드를 쓸 때 설정되며 응급 복구, 아카이브 복구 및 복제 중에 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="542120034dc0135bcba8fedcb62c0e5f5267d887" translate="yes" xml:space="preserve">
          <source>Each job is one process or one thread, depending on the operating system, and uses a separate connection to the server.</source>
          <target state="translated">각 작업은 운영 체제에 따라 하나의 프로세스 또는 하나의 스레드이며 서버에 대한 별도의 연결을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b38f7992dc346f7b5d0eda049bdeffb8af610ff4" translate="yes" xml:space="preserve">
          <source>Each key in an &lt;code&gt;hstore&lt;/code&gt; is unique. If you declare an &lt;code&gt;hstore&lt;/code&gt; with duplicate keys, only one will be stored in the &lt;code&gt;hstore&lt;/code&gt; and there is no guarantee as to which will be kept:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 각 키 는 고유합니다. 당신이 선언하면 &lt;code&gt;hstore&lt;/code&gt; 을 중복 키를 사용하여, 하나는에 저장됩니다 &lt;code&gt;hstore&lt;/code&gt; 및 유지 될에 관해서는 보장은 없습니다 :</target>
        </trans-unit>
        <trans-unit id="11bc7d32ed41735d7a7637cde449142c78ff4596" translate="yes" xml:space="preserve">
          <source>Each line represents a group of synonyms for a single word, which is given first on the line. Synonyms are separated by whitespace, thus:</source>
          <target state="translated">각 줄은 한 단어에 대한 동의어 그룹을 나타냅니다. 동의어는 공백으로 구분되므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f37fe98f5d306326dfab1b4227b4a2ceb6a13a80" translate="yes" xml:space="preserve">
          <source>Each line represents one translation rule, consisting of a character with accent followed by a character without accent. The first is translated into the second. For example,</source>
          <target state="translated">각 줄은 하나의 변환 규칙을 나타내며 악센트가있는 문자와 악센트가없는 문자로 구성됩니다. 첫 번째는 두 번째로 번역됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bab1cea7c36490e841156b8c476a06b7066c88eb" translate="yes" xml:space="preserve">
          <source>Each of the &amp;ldquo;hypothetical-set&amp;rdquo; aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-HYPOTHETICAL-TABLE&quot;&gt;Table 9.58&lt;/a&gt; is associated with a window function of the same name defined in &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;. In each case, the aggregate's result is the value that the associated window function would have returned for the &amp;ldquo;hypothetical&amp;rdquo; row constructed from &lt;code&gt;args&lt;/code&gt;, if such a row had been added to the sorted group of rows represented by the &lt;code&gt;sorted_args&lt;/code&gt;. For each of these functions, the list of direct arguments given in &lt;code&gt;args&lt;/code&gt; must match the number and types of the aggregated arguments given in &lt;code&gt;sorted_args&lt;/code&gt;. Unlike most built-in aggregates, these aggregates are not strict, that is they do not drop input rows containing nulls. Null values sort according to the rule specified in the &lt;code&gt;ORDER BY&lt;/code&gt; clause.</source>
          <target state="translated">&lt;a href=&quot;functions-aggregate#FUNCTIONS-HYPOTHETICAL-TABLE&quot;&gt;표 9.58에&lt;/a&gt; 나열된 각 &quot;가설 집합&quot;집계 는 &lt;a href=&quot;functions-window&quot;&gt;섹션 9.22에&lt;/a&gt; 정의 된 동일한 이름의 창 함수와 연결됩니다 . 각각의 경우 집계의 결과는 해당 행이 &lt;code&gt;sorted_args&lt;/code&gt; 로 표시되는 정렬 된 행 그룹에 추가 된 경우 &lt;code&gt;args&lt;/code&gt; 에서 생성 된 &quot;가상&quot;행에 대해 연관된 창 함수가 반환했을 값입니다 . 이러한 각 함수에 대해 &lt;code&gt;args&lt;/code&gt; 에 제공된 직접 인수 목록은 &lt;code&gt;sorted_args&lt;/code&gt; 에 제공된 집계 인수의 수 및 유형과 일치해야합니다.. 대부분의 기본 제공 집계와 달리 이러한 집계는 엄격하지 않습니다. 즉, 널을 포함하는 입력 행을 삭제하지 않습니다. Null 값은 &lt;code&gt;ORDER BY&lt;/code&gt; 절에 지정된 규칙에 따라 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f29b2cb20607f0de648e5996c4daf9f4a539aeb" translate="yes" xml:space="preserve">
          <source>Each of the aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-HYPOTHETICAL-TABLE&quot;&gt;Table 9.58&lt;/a&gt; is associated with a window function of the same name defined in &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;. In each case, the aggregate result is the value that the associated window function would have returned for the &amp;ldquo;hypothetical&amp;rdquo; row constructed from &lt;code&gt;args&lt;/code&gt;, if such a row had been added to the sorted group of rows computed from the &lt;code&gt;sorted_args&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-aggregate#FUNCTIONS-HYPOTHETICAL-TABLE&quot;&gt;표 9.58에&lt;/a&gt; 나열된 각 집계 는 &lt;a href=&quot;functions-window&quot;&gt;섹션 9.21에&lt;/a&gt; 정의 된 동일한 이름의 창 함수와 연관됩니다 . 각각의 경우 집계 결과는 &lt;code&gt;sorted_args&lt;/code&gt; 에서 계산 된 정렬 된 행 그룹에 해당 행이 추가 된 경우 &lt;code&gt;args&lt;/code&gt; 로 구성된 &quot;가상&quot;행에 대해 연관된 창 함수가 리턴 한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="c1241bdfba73578126cf6ac1b2eac99aae13e728" translate="yes" xml:space="preserve">
          <source>Each of the groups of functions described below is provided as a separately-installable extension.</source>
          <target state="translated">아래에 설명 된 각 기능 그룹은 별도로 설치 가능한 확장으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fa5023a4c00658abfdb99cce65758dae1e7f37bd" translate="yes" xml:space="preserve">
          <source>Each of the separate segmented file sets in which a relation is stored. The &lt;em&gt;main fork&lt;/em&gt; is where the actual data resides. There also exist two secondary forks for metadata: the &lt;a href=&quot;glossary#GLOSSARY-FSM&quot;&gt;free space map&lt;/a&gt; and the &lt;a href=&quot;glossary#GLOSSARY-VM&quot;&gt;visibility map&lt;/a&gt;. &lt;a href=&quot;glossary#GLOSSARY-UNLOGGED&quot;&gt;Unlogged relations&lt;/a&gt; also have an &lt;em&gt;init fork&lt;/em&gt;.</source>
          <target state="translated">관계가 저장되는 각각의 분리 된 세그먼트 파일 세트. &lt;em&gt;메인 포크는&lt;/em&gt; 실제 데이터가있는 곳이다. 또한 메타 데이터를위한 두 가지 보조 포크가 있습니다 : &lt;a href=&quot;glossary#GLOSSARY-FSM&quot;&gt;여유 공간 맵&lt;/a&gt; 과 &lt;a href=&quot;glossary#GLOSSARY-VM&quot;&gt;가시성 맵&lt;/a&gt; . &lt;a href=&quot;glossary#GLOSSARY-UNLOGGED&quot;&gt;로그되지 않은 관계&lt;/a&gt; 에는 &lt;em&gt;초기화 포크&lt;/em&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50960f9603aec9053de8ce026fa8b9bad3694f86" translate="yes" xml:space="preserve">
          <source>Each of these functions returns &lt;code&gt;true&lt;/code&gt; if successful and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">이러한 각 함수는 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5aadeec9bfb43fa57316615de66c4aef9c8a773" translate="yes" xml:space="preserve">
          <source>Each of these reasons dictates performing &lt;code&gt;VACUUM&lt;/code&gt; operations of varying frequency and scope, as explained in the following subsections.</source>
          <target state="translated">이러한 각 이유는 다음 하위 섹션에 설명 된대로 다양한 주파수 및 범위의 &lt;code&gt;VACUUM&lt;/code&gt; 작업을 수행하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="4cac5c8759285e213ca52d09af21f1ad8f3faebb" translate="yes" xml:space="preserve">
          <source>Each page is typically 8 kilobytes. (Remember, &lt;code&gt;relpages&lt;/code&gt; is only updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.) The file path name is of interest if you want to examine the table's disk file directly.</source>
          <target state="translated">각 페이지는 일반적으로 8 킬로바이트입니다. (기억 &lt;code&gt;relpages&lt;/code&gt; 이 만 업데이트됩니다 &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; , 몇 DDL은 다음과 같은 명령을 &lt;code&gt;CREATE INDEX&lt;/code&gt; 를 .) 파일 경로 이름은 관심을 당신이 직접 테이블의 디스크 파일을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="b29fd5f9859281b104853180c6852f111f06e0a6" translate="yes" xml:space="preserve">
          <source>Each parenthesized list of expressions generates a row in the table. The lists must all have the same number of elements (i.e., the number of columns in the table), and corresponding entries in each list must have compatible data types. The actual data type assigned to each column of the result is determined using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="translated">괄호로 묶은 각 표현식 목록은 테이블에 행을 생성합니다. 목록은 모두 동일한 수의 요소 (예 : 테이블의 열 수)를 가져야하며 각 목록의 해당 항목은 호환 가능한 데이터 유형을 가져야합니다. 결과의 각 열에 할당 된 실제 데이터 유형은 &lt;code&gt;UNION&lt;/code&gt; 과 동일한 규칙을 사용하여 결정됩니다 ( &lt;a href=&quot;typeconv-union-case&quot;&gt;10.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1744b77868ba36643b35518a8f8800e30eb35f9f" translate="yes" xml:space="preserve">
          <source>Each policy has a name and multiple policies can be defined for a table. As policies are table-specific, each policy for a table must have a unique name. Different tables may have policies with the same name.</source>
          <target state="translated">각 정책에는 이름이 있으며 테이블에 대해 여러 정책을 정의 할 수 있습니다. 정책은 테이블별로 다르므로 테이블에 대한 각 정책의 이름은 고유해야합니다. 다른 테이블에는 동일한 이름의 정책이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5bbed626ca3e97951a441f33d6e26844cab0c1" translate="yes" xml:space="preserve">
          <source>Each range type has a constructor function with the same name as the range type. Using the constructor function is frequently more convenient than writing a range literal constant, since it avoids the need for extra quoting of the bound values. The constructor function accepts two or three arguments. The two-argument form constructs a range in standard form (lower bound inclusive, upper bound exclusive), while the three-argument form constructs a range with bounds of the form specified by the third argument. The third argument must be one of the strings &amp;ldquo;&lt;code&gt;()&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;(]&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;[)&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;[]&lt;/code&gt;&amp;rdquo;. For example:</source>
          <target state="translated">각 범위 유형에는 범위 유형과 이름이 같은 생성자 함수가 있습니다. 생성자 함수를 사용하면 범위 리터럴 상수를 작성하는 것보다 바운드 값을 추가로 인용 할 필요가 없으므로 편리합니다. 생성자 함수는 2 개 또는 3 개의 인수를 허용합니다. 2 인수 형식은 표준 형식 (하한값 포함, 상한값 독점)으로 범위를 구성하는 반면 3 인수 형식은 세 번째 인수로 지정된 형식의 범위로 범위를 구성합니다. 세 번째 인수는 문자열 &quot; &lt;code&gt;()&lt;/code&gt; &quot;, &quot; &lt;code&gt;(]&lt;/code&gt; &quot;, &quot; &lt;code&gt;[)&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;[]&lt;/code&gt; &quot; 중 하나 여야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e2bf65321e7b74210e532591a945c9830329341" translate="yes" xml:space="preserve">
          <source>Each record specifies a connection type, a client IP address range (if relevant for the connection type), a database name, a user name, and the authentication method to be used for connections matching these parameters. The first record with a matching connection type, client address, requested database, and user name is used to perform authentication. There is no &amp;ldquo;fall-through&amp;rdquo; or &amp;ldquo;backup&amp;rdquo;: if one record is chosen and the authentication fails, subsequent records are not considered. If no record matches, access is denied.</source>
          <target state="translated">각 레코드는 연결 유형, 클라이언트 IP 주소 범위 (연결 유형과 관련된 경우), 데이터베이스 이름, 사용자 이름 및 이러한 매개 변수와 일치하는 연결에 사용되는 인증 방법을 지정합니다. 연결 유형, 클라이언트 주소, 요청 된 데이터베이스 및 사용자 이름이 일치하는 첫 번째 레코드가 인증을 수행하는 데 사용됩니다. &quot;fall-through&quot;또는 &quot;backup&quot;은 없습니다. 하나의 레코드를 선택하고 인증에 실패하면 후속 레코드는 고려되지 않습니다. 일치하는 레코드가 없으면 액세스가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="93486fa5bd5a52fe6d58233709c3e4afeee246ef" translate="yes" xml:space="preserve">
          <source>Each replication slot has a name, which can contain lower-case letters, numbers, and the underscore character.</source>
          <target state="translated">각 복제 슬롯에는 이름이 있으며 소문자, 숫자 및 밑줄 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714ca6d72fba05d3addae8d6cd117d5f8c7ed46e" translate="yes" xml:space="preserve">
          <source>Each row of &lt;code&gt;pg_largeobject&lt;/code&gt; holds data for one page of a large object, beginning at byte offset (&lt;code&gt;pageno * LOBLKSIZE&lt;/code&gt;) within the object. The implementation allows sparse storage: pages might be missing, and might be shorter than &lt;code&gt;LOBLKSIZE&lt;/code&gt; bytes even if they are not the last page of the object. Missing regions within a large object read as zeroes.</source>
          <target state="translated">&lt;code&gt;pg_largeobject&lt;/code&gt; 의 각 행은 객체 내에서 바이트 오프셋 ( &lt;code&gt;pageno * LOBLKSIZE&lt;/code&gt; )에서 시작하여 큰 객체의 한 페이지에 대한 데이터를 보유 합니다. 이 구현은 스파 스 저장을 허용합니다. 페이지가 누락되었거나 객체의 마지막 페이지가 아닌 경우에도 &lt;code&gt;LOBLKSIZE&lt;/code&gt; 바이트 보다 짧을 수 있습니다 . 큰 객체 내에 누락 된 영역은 0으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="7563f681a972af2d750923993e463dd76792481c" translate="yes" xml:space="preserve">
          <source>Each side is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The two row values must have the same number of fields. Each side is evaluated and they are compared row-wise. Row constructor comparisons are allowed when the &lt;code&gt;operator&lt;/code&gt; is &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;. Every row element must be of a type which has a default B-tree operator class or the attempted comparison may generate an error.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;4.2.13 절&lt;/a&gt; 에서 설명한 것처럼 각면은 행 생성자 입니다. 두 개의 행 값은 동일한 수의 필드를 가져야합니다. 각면이 평가되고 행 단위로 비교됩니다. &lt;code&gt;operator&lt;/code&gt; 가 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 인 경우 행 생성자 비교가 허용됩니다 . 모든 행 요소는 기본 B- 트리 연산자 클래스가있는 유형이어야합니다. 그렇지 않으면 비교를 시도하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f52ee79936460cf46e9e8bc3284b90d60086864" translate="yes" xml:space="preserve">
          <source>Each side is evaluated and they are compared row-wise. Composite type comparisons are allowed when the &lt;code&gt;operator&lt;/code&gt; is &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;, or has semantics similar to one of these. (To be specific, an operator can be a row comparison operator if it is a member of a B-tree operator class, or is the negator of the &lt;code&gt;=&lt;/code&gt; member of a B-tree operator class.) The default behavior of the above operators is the same as for &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; for row constructors (see &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;).</source>
          <target state="translated">각면이 평가되고 행 단위로 비교됩니다. &lt;code&gt;operator&lt;/code&gt; 가 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 이거나 이들 중 하나와 유사한 의미 가있는 경우 복합 유형 비교가 허용됩니다 . 구체적으로, 연산자는 B- 트리 연산자 클래스의 멤버이거나 B- 트리 연산자 클래스의 &lt;code&gt;=&lt;/code&gt; 멤버에 대한 부정 인 경우 행 비교 연산자 일 수 있습니다 . 위 연산자의 기본 동작 행 생성자에 대한 &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; 과 동일합니다 ( &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;섹션 9.23.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="685d69575ba0b9d3b478864257aa519d161b8704" translate="yes" xml:space="preserve">
          <source>Each side is evaluated and they are compared row-wise. Composite type comparisons are allowed when the &lt;code&gt;operator&lt;/code&gt; is &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;, or has semantics similar to one of these. (To be specific, an operator can be a row comparison operator if it is a member of a B-tree operator class, or is the negator of the &lt;code&gt;=&lt;/code&gt; member of a B-tree operator class.) The default behavior of the above operators is the same as for &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; for row constructors (see &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;).</source>
          <target state="translated">각 측면이 평가되고 행별로 비교됩니다. &lt;code&gt;operator&lt;/code&gt; 가 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 이거나 이들 중 하나와 유사한 의미를 갖는 경우 복합 유형 비교가 허용됩니다 . (구체적으로 말하자면, 연산자는 B- 트리 연산자 클래스의 멤버이거나 B- 트리 연산자 클래스의 &lt;code&gt;=&lt;/code&gt; 멤버의 부정 인 경우 행 비교 연산자가 될 수 있습니다 .) 위 연산자의 기본 동작 행 생성자에 대한 &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; 과 동일합니다 ( &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;섹션 9.24.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3a16e416687c1027abc371b1bdfdb07eec0683b0" translate="yes" xml:space="preserve">
          <source>Each sublist of &lt;code&gt;GROUPING SETS&lt;/code&gt; may specify zero or more columns or expressions and is interpreted the same way as though it were directly in the &lt;code&gt;GROUP BY&lt;/code&gt; clause. An empty grouping set means that all rows are aggregated down to a single group (which is output even if no input rows were present), as described above for the case of aggregate functions with no &lt;code&gt;GROUP BY&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;GROUPING SETS&lt;/code&gt; 의 각 하위 목록은 0 개 이상의 열 또는 표현식을 지정할 수 있으며 &lt;code&gt;GROUP BY&lt;/code&gt; 절에 직접있는 것처럼 동일한 방식으로 해석 됩니다. 빈 그룹화 세트는 &lt;code&gt;GROUP BY&lt;/code&gt; 절이 없는 집계 함수의 경우 위에서 설명한대로 모든 행이 단일 그룹 (입력 행이없는 경우에도 출력 됨)으로 집계됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="712d108aedc3ee50932324d38a0347254415d7fa" translate="yes" xml:space="preserve">
          <source>Each subscription will receive changes via one replication slot (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). Additional temporary replication slots may be required for the initial data synchronization of pre-existing table data.</source>
          <target state="translated">각 구독은 하나의 복제 슬롯을 통해 변경 사항을 수신합니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;26.2.6 절&lt;/a&gt; 참조 ). 기존 테이블 데이터의 초기 데이터 동기화를 위해 추가 임시 복제 슬롯이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bf5a50bb4ae3fd15a1d550ecd3ff88b2910e0b2" translate="yes" xml:space="preserve">
          <source>Each table access method is described by a row in the &lt;a href=&quot;catalog-pg-am&quot;&gt;&lt;code&gt;pg_am&lt;/code&gt;&lt;/a&gt; system catalog. The &lt;code&gt;pg_am&lt;/code&gt; entry specifies a name and a &lt;em&gt;handler function&lt;/em&gt; for the table access method. These entries can be created and deleted using the &lt;a href=&quot;sql-create-access-method&quot;&gt;CREATE ACCESS METHOD&lt;/a&gt; and &lt;a href=&quot;sql-drop-access-method&quot;&gt;DROP ACCESS METHOD&lt;/a&gt; SQL commands.</source>
          <target state="translated">각 테이블 액세스 방법은 &lt;a href=&quot;catalog-pg-am&quot;&gt; &lt;code&gt;pg_am&lt;/code&gt; &lt;/a&gt; 시스템 카탈로그 의 행으로 설명됩니다 . &lt;code&gt;pg_am&lt;/code&gt; 의 항목은 이름과 지정 &lt;em&gt;핸들러 함수&lt;/em&gt; 테이블 액세스 방법을. 이 항목은 &lt;a href=&quot;sql-create-access-method&quot;&gt;CREATE ACCESS METHOD&lt;/a&gt; 및 &lt;a href=&quot;sql-drop-access-method&quot;&gt;DROP ACCESS METHOD&lt;/a&gt; SQL 명령을 사용하여 작성 및 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9bd474cfe905272d1ed130fc8be7d40f6eb50a6" translate="yes" xml:space="preserve">
          <source>Each table and index is stored in a separate file. For ordinary relations, these files are named after the table or index's &lt;em&gt;filenode&lt;/em&gt; number, which can be found in &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt;. But for temporary relations, the file name is of the form &lt;code&gt;tBBB_FFF&lt;/code&gt;, where &lt;code&gt;BBB&lt;/code&gt; is the backend ID of the backend which created the file, and &lt;code&gt;FFF&lt;/code&gt; is the filenode number. In either case, in addition to the main file (a/k/a main fork), each table and index has a &lt;em&gt;free space map&lt;/em&gt; (see &lt;a href=&quot;storage-fsm&quot;&gt;Section 68.3&lt;/a&gt;), which stores information about free space available in the relation. The free space map is stored in a file named with the filenode number plus the suffix &lt;code&gt;_fsm&lt;/code&gt;. Tables also have a &lt;em&gt;visibility map&lt;/em&gt;, stored in a fork with the suffix &lt;code&gt;_vm&lt;/code&gt;, to track which pages are known to have no dead tuples. The visibility map is described further in &lt;a href=&quot;storage-vm&quot;&gt;Section 68.4&lt;/a&gt;. Unlogged tables and indexes have a third fork, known as the initialization fork, which is stored in a fork with the suffix &lt;code&gt;_init&lt;/code&gt; (see &lt;a href=&quot;storage-init&quot;&gt;Section 68.5&lt;/a&gt;).</source>
          <target state="translated">각 테이블과 인덱스는 별도의 파일에 저장됩니다. 일반적인 관계의 경우 이러한 파일은 &lt;code&gt;pg_class&lt;/code&gt; 에서 찾을 수있는 테이블 또는 인덱스의 파일 &lt;em&gt;노드&lt;/em&gt; 번호를 따라 이름이 지정 됩니다. &lt;code&gt;relfilenode&lt;/code&gt; . 그러나 임시 관계의 경우 파일 이름은 &lt;code&gt;tBBB_FFF&lt;/code&gt; 형식 입니다 . 여기서 &lt;code&gt;BBB&lt;/code&gt; 는 파일을 작성한 백엔드의 백엔드 ID이고 &lt;code&gt;FFF&lt;/code&gt; 는 파일 노드 번호입니다. 두 경우 모두 메인 파일 (a / k / a 메인 포크) 외에 각 테이블과 인덱스에는 사용 가능한 여유 공간에 대한 정보를 저장 하는 &lt;em&gt;여유 공간 맵&lt;/em&gt; ( &lt;a href=&quot;storage-fsm&quot;&gt;68.3&lt;/a&gt; 참조 )이 있습니다. 여유 공간 맵은 파일 노드 번호와 접미 부가 붙은 파일에 저장됩니다&lt;em&gt;&lt;/em&gt; &lt;code&gt;_fsm&lt;/code&gt; . 표에는 또한 &lt;code&gt;_vm&lt;/code&gt; 접미사와 함께 포크에 저장 되는 &lt;em&gt;가시성 맵&lt;/em&gt; 이있어 어떤 페이지에 사용 가능한 튜플이 없는지 추적합니다. 가시성 맵은 &lt;a href=&quot;storage-vm&quot;&gt;68.4 절에&lt;/a&gt; 자세히 설명되어 있습니다. 로그되지 않은 테이블과 인덱스에는 초기화 포크라고하는 세 번째 포크가 있으며 이는 접미어 &lt;code&gt;_init&lt;/code&gt; ( &lt;a href=&quot;storage-init&quot;&gt;68.5 절&lt;/a&gt; 참조) 와 함께 포크에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="275b9850c8ac2609ae18b924589bca752bf47340" translate="yes" xml:space="preserve">
          <source>Each table has a primary heap disk file where most of the data is stored. If the table has any columns with potentially-wide values, there also might be a TOAST file associated with the table, which is used to store values too wide to fit comfortably in the main table (see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;). There will be one valid index on the TOAST table, if present. There also might be indexes associated with the base table. Each table and index is stored in a separate disk file &amp;mdash; possibly more than one file, if the file would exceed one gigabyte. Naming conventions for these files are described in &lt;a href=&quot;storage-file-layout&quot;&gt;Section 68.1&lt;/a&gt;.</source>
          <target state="translated">각 테이블에는 대부분의 데이터가 저장되는 기본 힙 디스크 파일이 있습니다. 테이블에 잠재적으로 넓은 값을 가진 열이있는 경우, 테이블과 연관된 TOAST 파일이있을 수 있습니다.이 파일은 기본 테이블에 편안하게 맞지 않을 정도로 너무 넓은 값을 저장하는 데 사용됩니다 ( &lt;a href=&quot;storage-toast&quot;&gt;68.2 절&lt;/a&gt; 참조 ). TOAST 테이블에는 유효한 인덱스가 하나 있습니다 (있는 경우). 기본 테이블과 연관된 인덱스가있을 수도 있습니다. 각 테이블과 인덱스는 별도의 디스크 파일 (파일이 1 기가 바이트를 초과 할 경우 둘 이상의 파일)에 저장됩니다. 이 파일들에 대한 명명 규칙은 &lt;a href=&quot;storage-file-layout&quot;&gt;68.1 장에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c85019013f60e190262e90fe6e11caa77e51ee" translate="yes" xml:space="preserve">
          <source>Each table is a named collection of &lt;em&gt;rows&lt;/em&gt;. Each row of a given table has the same set of named &lt;em&gt;columns&lt;/em&gt;, and each column is of a specific data type. Whereas columns have a fixed order in each row, it is important to remember that SQL does not guarantee the order of the rows within the table in any way (although they can be explicitly sorted for display).</source>
          <target state="translated">각 테이블은 명명 된 &lt;em&gt;행&lt;/em&gt; 모음입니다 . 주어진 테이블의 각 행에는 동일한 이름의 &lt;em&gt;columns&lt;/em&gt; 세트가 있으며 각 열은 특정 데이터 유형입니다. 열은 각 행마다 순서가 정해져 있지만 SQL은 표 내에서 행 순서를 보장하지 않습니다 (표시를 위해 명시 적으로 정렬 할 수는 있지만).</target>
        </trans-unit>
        <trans-unit id="685b66b0c7dcaf80c826236b5adf115b1b72905f" translate="yes" xml:space="preserve">
          <source>Each text search function that depends on a configuration has an optional &lt;code&gt;regconfig&lt;/code&gt; argument, so that the configuration to use can be specified explicitly. &lt;code&gt;default_text_search_config&lt;/code&gt; is used only when this argument is omitted.</source>
          <target state="translated">구성에 의존하는 각 텍스트 검색 기능에는 선택적 &lt;code&gt;regconfig&lt;/code&gt; 인수가 있으므로 사용할 구성을 명시 적으로 지정할 수 있습니다. &lt;code&gt;default_text_search_config&lt;/code&gt; 는이 인수가 생략 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2730705d08be86e159a9812b430c3cfef93639d7" translate="yes" xml:space="preserve">
          <source>Each trace macro has a corresponding &lt;code&gt;ENABLED&lt;/code&gt; macro.</source>
          <target state="translated">각 추적 매크로에는 해당 &lt;code&gt;ENABLED&lt;/code&gt; 매크로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df910acc982080fcc4c6b3270ef5470d877e657" translate="yes" xml:space="preserve">
          <source>Each tuple begins with a 16-bit integer count of the number of fields in the tuple. (Presently, all tuples in a table will have the same count, but that might not always be true.) Then, repeated for each field in the tuple, there is a 32-bit length word followed by that many bytes of field data. (The length word does not include itself, and can be zero.) As a special case, -1 indicates a NULL field value. No value bytes follow in the NULL case.</source>
          <target state="translated">각 튜플은 튜플의 필드 수에 대한 16 비트 정수 카운트로 시작합니다. (현재 테이블의 모든 튜플의 개수는 동일하지만 항상 적용되는 것은 아닙니다.) 그런 다음 튜플의 각 필드에 대해 반복하면 32 비트 길이의 단어와 그 뒤에 많은 바이트의 필드 데이터가 있습니다. 길이 단어는 자체를 포함하지 않으며 0 일 수 있습니다. 특수한 경우 -1은 NULL 필드 값을 나타냅니다. NULL의 경우 값 바이트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2de56541538675ce5432246894338529335d8929" translate="yes" xml:space="preserve">
          <source>Each unique table constraint must name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table. (Otherwise it would just be the same constraint listed twice.)</source>
          <target state="translated">각 고유 테이블 제약 조건은 테이블에 대해 정의 된 다른 고유 또는 기본 키 제약 조건으로 명명 된 열 집합과 다른 열 집합의 이름을 지정해야합니다. (그렇지 않으면 두 번 나열된 동일한 제약 조건 일 것입니다.)</target>
        </trans-unit>
        <trans-unit id="8bbff92e83b108022ae759643aa4ab54b925d10f" translate="yes" xml:space="preserve">
          <source>Each unlogged table, and each index on an unlogged table, has an initialization fork. The initialization fork is an empty table or index of the appropriate type. When an unlogged table must be reset to empty due to a crash, the initialization fork is copied over the main fork, and any other forks are erased (they will be recreated automatically as needed).</source>
          <target state="translated">로깅되지 않은 각 테이블과 로깅되지 않은 테이블의 각 인덱스에는 초기화 포크가 있습니다. 초기화 포크는 빈 테이블 또는 적절한 유형의 인덱스입니다. 충돌로 인해 로그되지 않은 테이블을 비우도록 재설정해야하는 경우 초기화 포크가 기본 포크에 복사되고 다른 포크는 지워집니다 (필요에 따라 자동으로 다시 작성 됨).</target>
        </trans-unit>
        <trans-unit id="a9e254619788fb33e63ce5b37d508d1966d6a8d8" translate="yes" xml:space="preserve">
          <source>Earliest transaction ID (txid) that is still active. All earlier transactions will either be committed and visible, or rolled back and dead.</source>
          <target state="translated">아직 활성화 된 가장 빠른 트랜잭션 ID (txid). 이전의 모든 트랜잭션은 커밋되고 표시되거나 롤백 및 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b93b9d0fad915a7ff2436d43361bd4e666886561" translate="yes" xml:space="preserve">
          <source>Echo all commands to standard output before executing them.</source>
          <target state="translated">모든 명령을 실행하기 전에 표준 출력으로 에코하십시오.</target>
        </trans-unit>
        <trans-unit id="31fb51222602fbffe196ffb2e7a990011bd130df" translate="yes" xml:space="preserve">
          <source>Echo the actual queries generated by &lt;code&gt;\d&lt;/code&gt; and other backslash commands. You can use this to study psql's internal operations. This is equivalent to setting the variable &lt;code&gt;ECHO_HIDDEN&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 및 기타 백 슬래시 명령으로 생성 된 실제 쿼리를 에코 합니다. 이것을 사용하여 psql의 내부 작업을 연구 할 수 있습니다. 이는 &lt;code&gt;ECHO_HIDDEN&lt;/code&gt; 변수 를 &lt;code&gt;on&lt;/code&gt; 으로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b2d12fd936b0e591c9f3ba992f2d39bfdf979b58" translate="yes" xml:space="preserve">
          <source>Echo the commands that clusterdb generates and sends to the server.</source>
          <target state="translated">clusterdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="c834bb0b0858d3c39e0ad807e49c73ad604e39eb" translate="yes" xml:space="preserve">
          <source>Echo the commands that createdb generates and sends to the server.</source>
          <target state="translated">createdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="f2fff24f50e42a42eba51d06a9742eabe4aa7f9d" translate="yes" xml:space="preserve">
          <source>Echo the commands that createuser generates and sends to the server.</source>
          <target state="translated">createuser가 생성하고 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="9d94af5551e2463ee5c6eb6201ef2f56bf3d3e29" translate="yes" xml:space="preserve">
          <source>Echo the commands that dropdb generates and sends to the server.</source>
          <target state="translated">dropdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="ac3cec1ed7d72c588fde05f0859ee42ebd61c794" translate="yes" xml:space="preserve">
          <source>Echo the commands that dropuser generates and sends to the server.</source>
          <target state="translated">dropuser가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="31938ea32c7dbab891aac5986f9157b135c1d3d3" translate="yes" xml:space="preserve">
          <source>Echo the commands that reindexdb generates and sends to the server.</source>
          <target state="translated">reindexdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="bb88bf5e806d864cde80f7a1f4ec7070ab3d3a49" translate="yes" xml:space="preserve">
          <source>Echo the commands that vacuumdb generates and sends to the server.</source>
          <target state="translated">vacuumdb가 생성하여 서버로 보내는 명령을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="aa410e37b7eb78f6b0db88c9106078ce2821d967" translate="yes" xml:space="preserve">
          <source>Editor used by the &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, and &lt;code&gt;\ev&lt;/code&gt; commands. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use &lt;code&gt;vi&lt;/code&gt; on Unix systems or &lt;code&gt;notepad.exe&lt;/code&gt; on Windows systems.</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\ef&lt;/code&gt; 및 &lt;code&gt;\ev&lt;/code&gt; 명령에서 사용하는 편집기 . 이러한 변수는 나열된 순서대로 검사됩니다. 설정된 첫 번째가 사용됩니다. 설정되지 않은 경우 기본값은 Unix 시스템 에서는 &lt;code&gt;vi&lt;/code&gt; 를 사용 하고 Windows 시스템에서는 &lt;code&gt;notepad.exe&lt;/code&gt; 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="720b5dbc53190f0e13902f7885ccaf43bb9991de" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Effect</target>
        </trans-unit>
        <trans-unit id="0f11ff9075b757e9f28a73bab73613b127126f41" translate="yes" xml:space="preserve">
          <source>Eight-Bit Unicode Transformation Format</source>
          <target state="translated">8 비트 유니 코드 변환 형식</target>
        </trans-unit>
        <trans-unit id="19d107541598c45354a43a5924575cdd88fc3077" translate="yes" xml:space="preserve">
          <source>Either form overrides whatever setting might exist for &lt;code&gt;work_mem&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. Notice that underscores in parameter names can be written as either underscore or dash on the command line. Except for short-term experiments, it's probably better practice to edit the setting in &lt;code&gt;postgresql.conf&lt;/code&gt; than to rely on a command-line switch to set a parameter.</source>
          <target state="translated">어느 형식이든 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 &lt;code&gt;work_mem&lt;/code&gt; 에 대해 존재할 수있는 모든 설정을 무시합니다 . 매개 변수 이름의 밑줄은 명령 줄에서 밑줄 또는 대시로 쓸 수 있습니다. 단기 실험을 제외하고 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 설정을 편집하는 것이 명령 줄 스위치를 사용하여 매개 변수를 설정하는 것보다 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="45cfbed15cab9000815bed95176339e841fcee5f" translate="yes" xml:space="preserve">
          <source>Either the 4-digit or the 6-digit escape form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but are combined into a single code point.)</source>
          <target state="translated">4 자리 또는 6 자리 이스케이프 형식을 사용하여 UTF-16 서로 게이트 쌍을 지정하여 U + FFFF보다 큰 코드 포인트가있는 문자를 구성 할 수 있지만, 6 자리 형식을 사용할 수 있기 때문에 기술적으로이를 불필요하게 만들 수 있습니다. (대리자 쌍은 직접 저장되지 않고 단일 코드 포인트로 결합됩니다.)</target>
        </trans-unit>
        <trans-unit id="7f1f1f37763bf0059ec0085f40e07996ff76a200" translate="yes" xml:space="preserve">
          <source>Either way, you will only have a partially restored database. Alternatively, you can specify that the whole dump should be restored as a single transaction, so the restore is either fully completed or fully rolled back. This mode can be specified by passing the &lt;code&gt;-1&lt;/code&gt; or &lt;code&gt;--single-transaction&lt;/code&gt; command-line options to psql. When using this mode, be aware that even a minor error can rollback a restore that has already run for many hours. However, that might still be preferable to manually cleaning up a complex database after a partially restored dump.</source>
          <target state="translated">어느 쪽이든, 부분적으로 복원 된 데이터베이스 만 있습니다. 또는 전체 덤프를 단일 트랜잭션으로 복원하도록 지정하여 복원이 완전히 완료되거나 완전히 롤백되도록 지정할 수 있습니다. 이 모드는 &lt;code&gt;-1&lt;/code&gt; 또는 &lt;code&gt;--single-transaction&lt;/code&gt; 명령 행 옵션을 psql 에 전달하여 지정할 수 있습니다 . 이 모드를 사용할 때는 사소한 오류라도 이미 몇 시간 동안 이미 실행 된 복원을 롤백 할 수 있습니다. 그러나 부분적으로 복원 된 덤프 후 복잡한 데이터베이스를 수동으로 정리하는 것이 여전히 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2d216392756a3dca10170b407f8cc7f2a8ebe8" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">해시 테이블을 할당 할 병렬 해시 참가자 선출.</target>
        </trans-unit>
        <trans-unit id="6873f61d619db679e7470f5643312237e0240439" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to allocate more batches.</source>
          <target state="translated">더 많은 배치를 할당하기 위해 Parallel Hash 참가자 선출.</target>
        </trans-unit>
        <trans-unit id="27564de983e60879d25a8fb30933d1d02e9fefc7" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to allocate more buckets.</source>
          <target state="translated">더 많은 버킷을 할당하기 위해 Parallel Hash 참가자 선출.</target>
        </trans-unit>
        <trans-unit id="dd07d1b2b5646cfd064828cd9f36124d4b5c4865" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">병렬 해시 참가자를 선출하여 초기 해시 테이블을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="2ea1bfc4ea1822c938799e42d641a239c5778775" translate="yes" xml:space="preserve">
          <source>Electing a Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">향후 배치 성장을 결정하기 위해 Parallel Hash 참가자 선출.</target>
        </trans-unit>
        <trans-unit id="3458b3ac42872c6eac5357f958184c0446ba0f65" translate="yes" xml:space="preserve">
          <source>Element and attribute names that are not valid XML names are escaped by replacing the offending characters by the sequence &lt;code&gt;_xHHHH_&lt;/code&gt;, where &lt;code&gt;HHHH&lt;/code&gt; is the character's Unicode codepoint in hexadecimal notation. For example:</source>
          <target state="translated">올바른 XML 이름이 아닌 요소 및 속성 이름은 문제가있는 문자를 &lt;code&gt;_xHHHH_&lt;/code&gt; 시퀀스로 대체하여 이스케이프됩니다 . 여기서 &lt;code&gt;HHHH&lt;/code&gt; 는 16 진 표기법으로 문자의 유니 코드 코드 포인트입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44fbc2768dbe44346b6baf10d03fef8413a56811" translate="yes" xml:space="preserve">
          <source>Element content, if specified, will be formatted according to its data type. If the content is itself of type &lt;code&gt;xml&lt;/code&gt;, complex XML documents can be constructed. For example:</source>
          <target state="translated">지정된 경우 요소 내용은 데이터 유형에 따라 형식이 지정됩니다. 컨텐츠 자체가 &lt;code&gt;xml&lt;/code&gt; 유형 인 경우 복잡한 XML 문서를 구성 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f872fe45bb2bfc5b19093ab727825b2056ae0af2" translate="yes" xml:space="preserve">
          <source>Element names that are not valid XML names are escaped as shown for &lt;code&gt;xmlelement&lt;/code&gt; above. Similarly, content data is escaped to make valid XML content, unless it is already of type &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">유효한 XML 이름이 아닌 요소 이름은 위의 &lt;code&gt;xmlelement&lt;/code&gt; 에 표시된 것처럼 이스케이프됩니다 . 마찬가지로 컨텐츠 데이터는 이미 &lt;code&gt;xml&lt;/code&gt; 유형이 아닌 한 유효한 XML 컨텐츠를 만들기 위해 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="26a7ed3f12dc1c32f560e11a4e21644ad90b6f7e" translate="yes" xml:space="preserve">
          <source>Element types that have the notion of &amp;ldquo;infinity&amp;rdquo; can use them as explicit bound values. For example, with timestamp ranges, &lt;code&gt;[today,infinity)&lt;/code&gt; excludes the special &lt;code&gt;timestamp&lt;/code&gt; value &lt;code&gt;infinity&lt;/code&gt;, while &lt;code&gt;[today,infinity]&lt;/code&gt; include it, as does &lt;code&gt;[today,)&lt;/code&gt; and &lt;code&gt;[today,]&lt;/code&gt;.</source>
          <target state="translated">&quot;무한&quot;개념이있는 요소 유형은이를 명시 적 바운드 값으로 사용할 수 있습니다. 예를 들어, 타임 스탬프의 범위와 &lt;code&gt;[today,infinity)&lt;/code&gt; 제외 특수 &lt;code&gt;timestamp&lt;/code&gt; 값 &lt;code&gt;infinity&lt;/code&gt; 반면 &lt;code&gt;[today,infinity]&lt;/code&gt; 마찬가지로, 그것을 포함 &lt;code&gt;[today,)&lt;/code&gt; 및 &lt;code&gt;[today,]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7314da9aa08610fc7e551e14db13b15692e217a1" translate="yes" xml:space="preserve">
          <source>Eliminate explicit locks, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; where no longer needed due to the protections automatically provided by Serializable transactions.</source>
          <target state="translated">Serializable 트랜잭션에 의해 자동으로 제공되는 보호 기능으로 인해 더 이상 필요하지 않은 경우 명시 적 잠금, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c94d3175a6560565410511df2cebab9cda96027e" translate="yes" xml:space="preserve">
          <source>Email address</source>
          <target state="translated">이메일 주소</target>
        </trans-unit>
        <trans-unit id="78c45bfb7672fb0b2779428d901045aa7ce5bb61" translate="yes" xml:space="preserve">
          <source>Embedded C for PostgreSQL</source>
          <target state="translated">PostgreSQL 용 임베디드 C</target>
        </trans-unit>
        <trans-unit id="85c8d5ee732d2fb7da94ef6eea3e87e8049eee03" translate="yes" xml:space="preserve">
          <source>Embedded SQL</source>
          <target state="translated">임베디드 SQL</target>
        </trans-unit>
        <trans-unit id="0cf2ac97075bf1426575db1ed50de372ff47b973" translate="yes" xml:space="preserve">
          <source>Embedded options take effect at the &lt;code&gt;)&lt;/code&gt; terminating the sequence. They can appear only at the start of an ARE (after the &lt;code&gt;***:&lt;/code&gt; director if any).</source>
          <target state="translated">임베디드 옵션에서 효과를 가지고 &lt;code&gt;)&lt;/code&gt; 순서를 종료합니다. ARE 시작시에만 나타날 수 있습니다 ( &lt;code&gt;***:&lt;/code&gt; 감독이있는 경우).</target>
        </trans-unit>
        <trans-unit id="a80013744d7929a3261137d545cbd42a3af4f5d5" translate="yes" xml:space="preserve">
          <source>Emit binary logical decoding message. This can be used to pass generic messages to logical decoding plugins through WAL. The parameter &lt;em&gt;&lt;code&gt;transactional&lt;/code&gt;&lt;/em&gt; specifies if the message should be part of current transaction or if it should be written immediately and decoded as soon as the logical decoding reads the record. The &lt;em&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/em&gt; is textual prefix used by the logical decoding plugins to easily recognize interesting messages for them. The &lt;em&gt;&lt;code&gt;content&lt;/code&gt;&lt;/em&gt; is the binary content of the message.</source>
          <target state="translated">이진 논리 디코딩 메시지를 방출합니다. WAL을 통해 일반 메시지를 논리적 디코딩 플러그인으로 전달하는 데 사용할 수 있습니다. &lt;em&gt; &lt;code&gt;transactional&lt;/code&gt; &lt;/em&gt; 매개 변수 는 메시지가 현재 트랜잭션의 일부 여야하는지 또는 논리적 디코딩이 레코드를 읽는 즉시 메시지를 즉시 작성하고 디코딩해야하는지 지정합니다. &lt;em&gt; &lt;code&gt;prefix&lt;/code&gt; &lt;/em&gt; IS 텍스트 접두사 쉽게 그들을 위해 재미있는 메시지를 인식하는 논리적 디코딩 플러그인에 의해 사용. &lt;em&gt; &lt;code&gt;content&lt;/code&gt; &lt;/em&gt; 메시지의 바이너리 콘텐츠입니다.</target>
        </trans-unit>
        <trans-unit id="7e0751c561c57bf2cbf1d1e9d274fe418b07635b" translate="yes" xml:space="preserve">
          <source>Emit text logical decoding message. This can be used to pass generic messages to logical decoding plugins through WAL. The parameter &lt;em&gt;&lt;code&gt;transactional&lt;/code&gt;&lt;/em&gt; specifies if the message should be part of current transaction or if it should be written immediately and decoded as soon as the logical decoding reads the record. The &lt;em&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/em&gt; is textual prefix used by the logical decoding plugins to easily recognize interesting messages for them. The &lt;em&gt;&lt;code&gt;content&lt;/code&gt;&lt;/em&gt; is the text of the message.</source>
          <target state="translated">텍스트 논리적 디코딩 메시지를 방출합니다. WAL을 통해 일반 메시지를 논리적 디코딩 플러그인으로 전달하는 데 사용할 수 있습니다. &lt;em&gt; &lt;code&gt;transactional&lt;/code&gt; &lt;/em&gt; 매개 변수 는 메시지가 현재 트랜잭션의 일부 여야하는지 또는 논리적 디코딩이 레코드를 읽는 즉시 메시지를 즉시 작성하고 디코딩해야하는지 지정합니다. &lt;em&gt; &lt;code&gt;prefix&lt;/code&gt; &lt;/em&gt; IS 텍스트 접두사 쉽게 그들을 위해 재미있는 메시지를 인식하는 논리적 디코딩 플러그인에 의해 사용. &lt;em&gt; &lt;code&gt;content&lt;/code&gt; &lt;/em&gt; 메시지의 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="58569c7211c13b035c450683afb595ff8f8eefd3" translate="yes" xml:space="preserve">
          <source>Emits a logical decoding message. This can be used to pass generic messages to logical decoding plugins through WAL. The &lt;em&gt;&lt;code&gt;transactional&lt;/code&gt;&lt;/em&gt; parameter specifies if the message should be part of the current transaction, or if it should be written immediately and decoded as soon as the logical decoder reads the record. The &lt;em&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/em&gt; parameter is a textual prefix that can be used by logical decoding plugins to easily recognize messages that are interesting for them. The &lt;em&gt;&lt;code&gt;content&lt;/code&gt;&lt;/em&gt; parameter is the content of the message, given either in text or binary form.</source>
          <target state="translated">논리적 디코딩 메시지를 내 보냅니다. 이것은 WAL을 통해 논리적 디코딩 플러그인에 일반 메시지를 전달하는 데 사용할 수 있습니다. &lt;em&gt; &lt;code&gt;transactional&lt;/code&gt; &lt;/em&gt; 파라미터 지정 메시지는 현재 트랜잭션의 일부 또는할지 즉시 기록되고 즉시 복호화 논리 레코드를 읽고 디코딩되어야 하는지를. &lt;em&gt; &lt;code&gt;prefix&lt;/code&gt; &lt;/em&gt; 매개 변수 텍스트 접두사가 쉽게 흥미있는 메시지를 인식하는 논리적 디코딩 플러그인을 사용할 수 있습니다. &lt;em&gt; &lt;code&gt;content&lt;/code&gt; &lt;/em&gt; 매개 변수는 텍스트 또는 바이너리 형식 중 주어진 메시지의 내용이다.</target>
        </trans-unit>
        <trans-unit id="1d9158fa67b04334360a28023c58f2a63817f4c9" translate="yes" xml:space="preserve">
          <source>Empty &lt;code&gt;SELECT&lt;/code&gt; Lists</source>
          <target state="translated">빈 &lt;code&gt;SELECT&lt;/code&gt; 목록</target>
        </trans-unit>
        <trans-unit id="12d6c3df584f9cd6e2bed1f88b3a723f1f5371fd" translate="yes" xml:space="preserve">
          <source>Enable progress reporting. Turning this on will deliver a progress report while checking or enabling checksums.</source>
          <target state="translated">진행률보고를 활성화합니다. 이 기능을 켜면 체크섬을 확인하거나 활성화하는 동안 진행률 보고서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f7a9c4f8b315d7d939ff2a001b201b4a11afef2b" translate="yes" xml:space="preserve">
          <source>Enable verbose output. Lists all checked files.</source>
          <target state="translated">자세한 출력을 활성화합니다. 확인 된 모든 파일을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="6a055feda4ebabb382fa12b1358761956e1105a6" translate="yes" xml:space="preserve">
          <source>Enables SSL connections. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">SSL 연결을 활성화합니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="626f01adb36a8ee098e309481b7ca3978eb10e34" translate="yes" xml:space="preserve">
          <source>Enables advertising the server's existence via Bonjour. The default is off. This parameter can only be set at server start.</source>
          <target state="translated">Bonjour를 통해 서버의 존재를 광고 할 수 있습니다. 기본 설정은 꺼져 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3410afd43005ba74c5e78a3c64358ed3118a2cb" translate="yes" xml:space="preserve">
          <source>Enables checksums.</source>
          <target state="translated">체크섬을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="78d4690c9afde1f8eefa94cd72a39b6d1a2c122d" translate="yes" xml:space="preserve">
          <source>Enables collection of statistics on database activity. This parameter is on by default, because the autovacuum daemon needs the collected information. Only superusers can change this setting.</source>
          <target state="translated">데이터베이스 활동에 대한 통계 콜렉션을 사용합니다. autovacuum 데몬에는 수집 된 정보가 필요하므로이 매개 변수는 기본적으로 켜져 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b45b9af6b6dbed04ecf07b2ffe0eb9095973ef5d" translate="yes" xml:space="preserve">
          <source>Enables display of progress messages.</source>
          <target state="translated">진행 메시지를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97255bb87514b6caf0bb2e2c2d781f5f1ac293a5" translate="yes" xml:space="preserve">
          <source>Enables gzip compression of tar file output, and specifies the compression level (0 through 9, 0 being no compression and 9 being best compression). Compression is only available when using the tar format, and the suffix &lt;code&gt;.gz&lt;/code&gt; will automatically be added to all tar filenames.</source>
          <target state="translated">tar 파일 출력의 gzip 압축을 활성화하고 압축 레벨을 지정합니다 (0-9, 0은 압축되지 않고 9는 최상의 압축 임). 압축은 tar 형식을 사용할 때만 사용할 수 있으며 접미사 &lt;code&gt;.gz&lt;/code&gt; 는 모든 tar 파일 이름에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f90c3e668a373c21e31be412cfe3ee4c4edf41be" translate="yes" xml:space="preserve">
          <source>Enables gzip compression of tar file output, with the default compression level. Compression is only available when using the tar format, and the suffix &lt;code&gt;.gz&lt;/code&gt; will automatically be added to all tar filenames.</source>
          <target state="translated">기본 압축 수준으로 tar 파일 출력의 gzip 압축을 활성화합니다. 압축은 tar 형식을 사용할 때만 사용할 수 있으며 접미사 &lt;code&gt;.gz&lt;/code&gt; 는 모든 tar 파일 이름에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5aa4f75e43a6e407c6e8a82b94739a07685c33bd" translate="yes" xml:space="preserve">
          <source>Enables gzip compression of write-ahead logs, and specifies the compression level (0 through 9, 0 being no compression and 9 being best compression). The suffix &lt;code&gt;.gz&lt;/code&gt; will automatically be added to all filenames.</source>
          <target state="translated">미리 쓰기 로그의 gzip 압축을 사용하고 압축 레벨을 지정합니다 (0-9, 0은 압축되지 않고 9는 최상의 압축 임). 접미사 &lt;code&gt;.gz&lt;/code&gt; 가 모든 파일 이름에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4ed86902b76f841e1bca0b744a2e7335fa8f66ce" translate="yes" xml:space="preserve">
          <source>Enables logging of recovery-related debugging output that otherwise would not be logged. This parameter allows the user to override the normal setting of &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;, but only for specific messages. This is intended for use in debugging Hot Standby. Valid values are &lt;code&gt;DEBUG5&lt;/code&gt;, &lt;code&gt;DEBUG4&lt;/code&gt;, &lt;code&gt;DEBUG3&lt;/code&gt;, &lt;code&gt;DEBUG2&lt;/code&gt;, &lt;code&gt;DEBUG1&lt;/code&gt;, and &lt;code&gt;LOG&lt;/code&gt;. The default, &lt;code&gt;LOG&lt;/code&gt;, does not affect logging decisions at all. The other values cause recovery-related debug messages of that priority or higher to be logged as though they had &lt;code&gt;LOG&lt;/code&gt; priority; for common settings of &lt;code&gt;log_min_messages&lt;/code&gt; this results in unconditionally sending them to the server log. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">그렇지 않으면 기록되지 않은 복구 관련 디버깅 출력을 기록 할 수 있습니다. 이 매개 변수를 사용하면 사용자 는 특정 메시지에 대해서만 &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; 의 일반 설정을 대체 할 수 있습니다 . 이것은 핫 스탠바이 디버깅에 사용하기위한 것입니다. 유효한 값은 &lt;code&gt;DEBUG5&lt;/code&gt; , &lt;code&gt;DEBUG4&lt;/code&gt; , &lt;code&gt;DEBUG3&lt;/code&gt; , &lt;code&gt;DEBUG2&lt;/code&gt; , &lt;code&gt;DEBUG1&lt;/code&gt; 및 &lt;code&gt;LOG&lt;/code&gt; 입니다. 기본값 인 &lt;code&gt;LOG&lt;/code&gt; 는 로깅 결정에 전혀 영향을 미치지 않습니다. 다른 값을 사용하면 해당 우선 순위 이상의 복구 관련 디버그 메시지가 &lt;code&gt;LOG&lt;/code&gt; 우선 순위를 갖는 것처럼 로그됩니다 . &lt;code&gt;log_min_messages&lt;/code&gt; 의 공통 설정이로 인해 무조건 서버 로그로 전송됩니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0bc8678d4e01747d95ba708742ba1d0ffa28593" translate="yes" xml:space="preserve">
          <source>Enables or disables genetic query optimization. This is on by default. It is usually best not to turn it off in production; the &lt;code&gt;geqo_threshold&lt;/code&gt; variable provides more granular control of GEQO.</source>
          <target state="translated">유전자 쿼리 최적화를 활성화하거나 비활성화합니다. 이것은 기본적으로 켜져 있습니다. 일반적으로 프로덕션 환경에서는 끄지 않는 것이 가장 좋습니다. &lt;code&gt;geqo_threshold&lt;/code&gt; 의 변수 GEQO보다 세밀한 제어를 제공한다.</target>
        </trans-unit>
        <trans-unit id="9b962689d04bf23cf75c28eb69f1f5503647fd60" translate="yes" xml:space="preserve">
          <source>Enables or disables index cleanup when &lt;code&gt;VACUUM&lt;/code&gt; is run on this table. The default value is &lt;code&gt;true&lt;/code&gt;. Disabling index cleanup can speed up &lt;code&gt;VACUUM&lt;/code&gt; very significantly, but may also lead to severely bloated indexes if table modifications are frequent. The &lt;code&gt;INDEX_CLEANUP&lt;/code&gt; parameter of &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;, if specified, overrides the value of this option.</source>
          <target state="translated">이 테이블에서 &lt;code&gt;VACUUM&lt;/code&gt; 이 실행될 때 인덱스 정리를 사용하거나 사용하지 않습니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 인덱스 정리를 비활성화하면 &lt;code&gt;VACUUM&lt;/code&gt; 속도가 매우 빨라지 지만 테이블 수정이 빈번한 경우 인덱스가 심각하게 부 풀릴 수 있습니다. &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 의 &lt;code&gt;INDEX_CLEANUP&lt;/code&gt; 매개 변수는 지정된 경우이 옵션의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="b7ded5623d6f7d4469db9ae10d91b2c5b4f8e4c9" translate="yes" xml:space="preserve">
          <source>Enables or disables the autovacuum daemon for a particular table. If true, the autovacuum daemon will perform automatic &lt;code&gt;VACUUM&lt;/code&gt; and/or &lt;code&gt;ANALYZE&lt;/code&gt; operations on this table following the rules discussed in &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;. If false, this table will not be autovacuumed, except to prevent transaction ID wraparound. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt; for more about wraparound prevention. Note that the autovacuum daemon does not run at all (except to prevent transaction ID wraparound) if the &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; parameter is false; setting individual tables' storage parameters does not override that. Therefore there is seldom much point in explicitly setting this storage parameter to &lt;code&gt;true&lt;/code&gt;, only to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">특정 테이블에 대해 autovacuum 데몬을 활성화하거나 비활성화합니다. true 인 경우 autovacuum 데몬은 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;24.1.6 절&lt;/a&gt; 에서 논의 된 규칙에 따라이 테이블에서 자동 &lt;code&gt;VACUUM&lt;/code&gt; 및 / 또는 &lt;code&gt;ANALYZE&lt;/code&gt; 작업을 수행합니다 . False 인 경우이 테이블은 트랜잭션 ID 랩 어라운드를 방지하기 위해 자동 진공 청소기로 처리되지 않습니다. 랩 어라운드 방지에 대한 자세한 내용 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;은 24.1.5 절을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; 매개 변수가 false 인 경우 autovacuum 데몬은 전혀 실행되지 않습니다 (트랜잭션 ID 랩 어라운드 방지) . 개별 테이블의 스토리지 매개 변수를 설정해도이를 무시하지 않습니다. 따라서 명시 적으로이 스토리지 매개 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정 하고 &lt;code&gt;false&lt;/code&gt; 로만 설정하는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="d14b153fda30f0ce055fd69a40d0d971812f5076" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's ability to eliminate a partitioned table's partitions from query plans. This also controls the planner's ability to generate query plans which allow the query executor to remove (ignore) partitions during query execution. The default is &lt;code&gt;on&lt;/code&gt;. See &lt;a href=&quot;ddl-partitioning#DDL-PARTITION-PRUNING&quot;&gt;Section 5.11.4&lt;/a&gt; for details.</source>
          <target state="translated">쿼리 계획에서 파티션 된 테이블의 파티션을 제거하는 쿼리 플래너 기능을 사용하거나 사용하지 않습니다. 또한 쿼리 실행 중에 쿼리 실행 프로그램이 파티션을 제거 (무시) ​​할 수 있도록하는 쿼리 계획을 생성하는 플래너의 기능을 제어합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다. 자세한 내용 &lt;a href=&quot;ddl-partitioning#DDL-PARTITION-PRUNING&quot;&gt;은 5.11.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="995969994dd32d0bf4b12e39bb21f11336caee94" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of TID scan plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 TID 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="caca9d6ce8d0139ac2e9013c1679f2c727efff8d" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of bitmap-scan plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 비트 맵 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b769d85abc23e2d30d27dc61faa1ee8cd8536874" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of explicit sort steps. It is impossible to suppress explicit sorts entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 명시 적 정렬 단계 사용을 활성화하거나 비활성화합니다. 명시 적 정렬을 완전히 억제하는 것은 불가능하지만,이 변수를 끄면 다른 방법이있을 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="96879e71d00598fc0f4d556be7d62c9abbec4411" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of gather merge plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 수집 병합 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="21deb6a95d8d9fae5d39c1db9d16de9fde4fe130" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of hash-join plan types with parallel hash. Has no effect if hash-join plans are not also enabled. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너가 병렬 해시와 함께 해시 조인 계획 유형을 사용하거나 사용하지 않도록 설정합니다. 해시 조인 계획도 활성화되어 있지 않으면 아무런 영향을 미치지 않습니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ec6953e4ca5a59667d50f27f71b28a7da33814e" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of hash-join plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 해시 조인 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf6533f43b0ca3981492c5998f149d18d7ac70d5" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of hashed aggregation plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 해시 집계 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f2f01ea036fd2693709193b2b30c6f0e822f2fc7" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of incremental sort steps. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 증분 정렬 단계 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f2cf88152ca7bdcdf755fdc5e2656bab2a7a57e" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of index-only-scan plan types (see &lt;a href=&quot;indexes-index-only-scans&quot;&gt;Section 11.9&lt;/a&gt;). The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너가 인덱스 전용 스캔 계획 유형을 사용하거나 사용하지 않도록 설정합니다 ( &lt;a href=&quot;indexes-index-only-scans&quot;&gt;11.9 절&lt;/a&gt; 참조 ). 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="089511ca11c8382f30cdec2fd90407e060a0adb1" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of index-scan plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 인덱스 스캔 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f661c5fad3c336c0f972c99ffe732a268f196b0a" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of materialization. It is impossible to suppress materialization entirely, but turning this variable off prevents the planner from inserting materialize nodes except in cases where it is required for correctness. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 구체화 사용을 활성화하거나 비활성화합니다. 구체화를 완전히 억제하는 것은 불가능하지만이 변수를 끄면 계획자가 정확성이 필요한 경우를 제외하고 구체화 노드를 삽입 할 수 없습니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="690ff5cababf5bcdde1cb25f0adf2fc43533ddce" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of merge-join plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 병합 결합 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e00d7ba7fbb9b915299589cfef88ee157fde2ccd" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of nested-loop join plans. It is impossible to suppress nested-loop joins entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 계획자가 중첩 루프 조인 계획을 사용하거나 사용하지 않도록 설정합니다. 중첩 루프 조인을 완전히 억제하는 것은 불가능하지만이 변수를 끄면 다른 방법이있을 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d754190306e47bfd240a6fdc2ef4c38fba88f3b" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of parallel-aware append plan types. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 병렬 인식 추가 계획 유형 사용을 활성화하거나 비활성화합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f36ea54e6ea533ca675dde4f1180490e7a02b1cf" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of partitionwise grouping or aggregation, which allows grouping or aggregation on a partitioned tables performed separately for each partition. If the &lt;code&gt;GROUP BY&lt;/code&gt; clause does not include the partition keys, only partial aggregation can be performed on a per-partition basis, and finalization must be performed later. Because partitionwise grouping or aggregation can use significantly more CPU time and memory during planning, the default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너가 파티션 단위 그룹화 또는 집계 사용을 활성화 또는 비활성화하여 각 파티션에 대해 개별적으로 수행되는 파티션 된 테이블에 대한 그룹화 또는 집계를 허용합니다. 는 IF &lt;code&gt;GROUP BY&lt;/code&gt; 절은 파티션 키를 포함하지 않는, 단지 부분적인 통합은 당 파티션 단위로 수행 할 수 있으며, 마무리는 나중에 수행해야합니다. 파티션 단위 그룹화 또는 집계는 계획 중에 훨씬 더 많은 CPU 시간과 메모리를 사용할 수 있으므로 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2f9ba67905015767bb926e17fa47e22352d954b" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of partitionwise join, which allows a join between partitioned tables to be performed by joining the matching partitions. Partitionwise join currently applies only when the join conditions include all the partition keys, which must be of the same data type and have exactly matching sets of child partitions. Because partitionwise join planning can use significantly more CPU time and memory during planning, the default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 파티션 방식 조인 사용을 활성화 또는 비활성화하여 일치하는 파티션을 조인하여 파티션 된 테이블 간의 조인을 수행 할 수 있습니다. 파티션 방식 조인은 현재 조인 조건에 모든 파티션 키가 포함되어 있고 데이터 유형이 동일해야하며 정확히 일치하는 하위 파티션 세트를 가져야하는 경우에만 적용됩니다. 파티션 방식 조인 계획은 계획 중에 훨씬 더 많은 CPU 시간과 메모리를 사용할 수 있으므로 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5825a242811cf6bc813ec8e70cc038cd8324808" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of partitionwise join, which allows a join between partitioned tables to be performed by joining the matching partitions. Partitionwise join currently applies only when the join conditions include all the partition keys, which must be of the same data type and have one-to-one matching sets of child partitions. Because partitionwise join planning can use significantly more CPU time and memory during planning, the default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 분할 조인 사용을 활성화하거나 비활성화합니다. 이렇게하면 일치하는 파티션을 조인하여 분할 된 테이블 간 조인을 수행 할 수 있습니다. 파티션 별 조인은 현재 조인 조건에 모든 파티션 키가 포함되어있는 경우에만 적용됩니다.이 키는 동일한 데이터 유형이어야하며 일대일 일치하는 하위 파티션 세트가 있어야합니다. 파티션 별 조인 계획은 계획 중에 훨씬 더 많은 CPU 시간과 메모리를 사용할 수 있으므로 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ce1e4579696c287d022b50be0db1ba092c4338e" translate="yes" xml:space="preserve">
          <source>Enables or disables the query planner's use of sequential scan plan types. It is impossible to suppress sequential scans entirely, but turning this variable off discourages the planner from using one if there are other methods available. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">쿼리 플래너의 순차 스캔 계획 유형 사용을 사용하거나 사용하지 않습니다. 순차 스캔을 완전히 억제하는 것은 불가능하지만이 변수를 끄면 다른 방법이있는 경우 플래너가 하나를 사용하지 못하게됩니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b95c71c8efec42f210959555c75df0f25880db1" translate="yes" xml:space="preserve">
          <source>Enables or disables vacuum to try to truncate off any empty pages at the end of this table. The default value is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt; and autovacuum do the truncation and the disk space for the truncated pages is returned to the operating system. Note that the truncation requires &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the table. The &lt;code&gt;TRUNCATE&lt;/code&gt; parameter of &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;, if specified, overrides the value of this option.</source>
          <target state="translated">이 테이블의 끝에서 빈 페이지를 잘라내도록 진공을 활성화 또는 비활성화합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 경우 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; 및 자동 진공이 수행립니다 페이지의 절단 및 디스크 공간은 운영 체제에 반환됩니다. 잘림을 위해서는 테이블에 대한 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금이 필요 합니다. &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 의 &lt;code&gt;TRUNCATE&lt;/code&gt; 매개 변수는 지정된 경우이 옵션의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="1b31308aef37918b17682773a33dbb4bc9f00918" translate="yes" xml:space="preserve">
          <source>Enables progress reporting. Turning this on will deliver an approximate progress report during the backup. Since the database may change during the backup, this is only an approximation and may not end at exactly &lt;code&gt;100%&lt;/code&gt;. In particular, when WAL log is included in the backup, the total amount of data cannot be estimated in advance, and in this case the estimated target size will increase once it passes the total estimate without WAL.</source>
          <target state="translated">진행률보고를 활성화합니다. 이 기능을 켜면 백업 중에 대략적인 진행률 보고서가 제공됩니다. 백업 중에 데이터베이스가 변경 될 수 있으므로 이는 대략적인 것일 뿐이며 정확히 &lt;code&gt;100%&lt;/code&gt; 끝나지 않을 수 있습니다 . 특히, WAL 로그가 백업에 포함 된 경우 총 데이터 양을 미리 예측할 수 없으며이 경우 WAL없이 총 예상치를 통과하면 예상 대상 크기가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="ac15fe597310e5f701ec3560c99c834fe685738b" translate="yes" xml:space="preserve">
          <source>Enables progress reporting. Turning this on will deliver an approximate progress report while copying data from the source cluster.</source>
          <target state="translated">진행률보고를 활성화합니다. 이 기능을 켜면 소스 클러스터에서 데이터를 복사하는 동안 대략적인 진행률 보고서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4c6e8b43364e9301fa7393aaf1ee6a5531e8fd39" translate="yes" xml:space="preserve">
          <source>Enables secure connections using SSL. PostgreSQL must have been compiled with support for SSL for this option to be available. For more information on using SSL, refer to &lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt;.</source>
          <target state="translated">SSL을 사용하여 보안 연결을 사용합니다. 이 옵션을 사용하려면 PostgreSQL이 SSL을 지원하도록 컴파일되어 있어야합니다. SSL 사용에 대한 자세한 내용 &lt;a href=&quot;ssl-tcp&quot;&gt;은 18.9 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="639cdb727b936af4ccbde200e725e387830f011c" translate="yes" xml:space="preserve">
          <source>Enables the collection of information on the currently executing command of each session, along with the time when that command began execution. This parameter is on by default. Note that even when enabled, this information is not visible to all users, only to superusers and the user owning the session being reported on, so it should not represent a security risk. Only superusers can change this setting.</source>
          <target state="translated">각 세션에서 현재 실행중인 명령에 대한 정보 수집과 해당 명령이 실행을 시작한 시간을 활성화합니다. 이 매개 변수는 기본적으로 켜져 있습니다. 활성화 된 경우에도이 정보는 모든 사용자에게 표시되지 않으며 수퍼 유저 및보고되는 세션을 소유 한 사용자에게만 표시되므로 보안 위험을 나타내지 않아야합니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c924445fb5317940d918e85cdabb3cd269d58308" translate="yes" xml:space="preserve">
          <source>Enables the previously disabled subscription, starting the logical replication worker at the end of transaction.</source>
          <target state="translated">트랜잭션이 끝날 때 논리적 복제 작업자를 시작하여 이전에 비활성화 된 가입을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f48d7a17f7eb8c15985acad2202de0094c6b6420" translate="yes" xml:space="preserve">
          <source>Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms. You can use the &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; tool to measure the overhead of timing on your system. I/O timing information is displayed in &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt;&lt;code&gt;pg_stat_database&lt;/code&gt;&lt;/a&gt;, in the output of &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; when the &lt;code&gt;BUFFERS&lt;/code&gt; option is used, and by &lt;a href=&quot;pgstatstatements&quot;&gt;pg_stat_statements&lt;/a&gt;. Only superusers can change this setting.</source>
          <target state="translated">데이터베이스 I / O 호출 타이밍을 활성화합니다. 이 매개 변수는 현재 시간에 대해 운영 체제를 반복적으로 쿼리하므로 일부 플랫폼에서 상당한 오버 헤드가 발생할 수 있으므로 기본적으로 해제되어 있습니다. &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; 도구를 사용 하여 시스템의 타이밍 오버 헤드를 측정 할 수 있습니다. I / O 타이밍 정보가 표시된다 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt; &lt;code&gt;pg_stat_database&lt;/code&gt; &lt;/a&gt; 의 출력에서 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 때 &lt;code&gt;BUFFERS&lt;/code&gt; 옵션을 사용하고,에 의해 &lt;a href=&quot;pgstatstatements&quot;&gt;pg_stat_statements&lt;/a&gt; . 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ba9870f478d2bde43f63790fab9c752de4bfaa0" translate="yes" xml:space="preserve">
          <source>Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms. You can use the &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; tool to measure the overhead of timing on your system. I/O timing information is displayed in &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt;, in the output of &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; when the &lt;code&gt;BUFFERS&lt;/code&gt; option is used, and by &lt;a href=&quot;pgstatstatements&quot;&gt;pg_stat_statements&lt;/a&gt;. Only superusers can change this setting.</source>
          <target state="translated">데이터베이스 I / O 호출 타이밍을 활성화합니다. 이 매개 변수는 현재 시간 동안 운영 체제를 반복해서 조회하므로 일부 플랫폼에서 상당한 오버 헤드가 발생할 수 있으므로 기본적으로 해제되어 있습니다. &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; 도구를 사용 하여 시스템의 타이밍 오버 헤드를 측정 할 수 있습니다. I / O 타이밍 정보는 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; , &lt;code&gt;BUFFERS&lt;/code&gt; 옵션 사용시 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 출력 및 &lt;a href=&quot;pgstatstatements&quot;&gt;pg_stat_statements에 표시&lt;/a&gt; 됩니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1205b107d21f6fa21fec7f98257f15ab13c062b3" translate="yes" xml:space="preserve">
          <source>Enables tracking of function call counts and time used. Specify &lt;code&gt;pl&lt;/code&gt; to track only procedural-language functions, &lt;code&gt;all&lt;/code&gt; to also track SQL and C language functions. The default is &lt;code&gt;none&lt;/code&gt;, which disables function statistics tracking. Only superusers can change this setting.</source>
          <target state="translated">함수 호출 횟수 및 사용 시간을 추적 할 수 있습니다. 절차 언어 함수 만 추적하려면 &lt;code&gt;pl&lt;/code&gt; 을 지정 하고 &lt;code&gt;all&lt;/code&gt; SQL 및 C 언어 함수도 추적하십시오. 기본값은 &lt;code&gt;none&lt;/code&gt; 이며 함수 통계 추적을 사용하지 않습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91758902f000617c78a32904c3bce42de9ae0b26" translate="yes" xml:space="preserve">
          <source>Enables updating of the process title every time a new SQL command is received by the server. This setting defaults to &lt;code&gt;on&lt;/code&gt; on most platforms, but it defaults to &lt;code&gt;off&lt;/code&gt; on Windows due to that platform's larger overhead for updating the process title. Only superusers can change this setting.</source>
          <target state="translated">서버가 새 SQL 명령을 수신 할 때마다 프로세스 제목을 업데이트 할 수 있습니다. 이 설정은 기본값 &lt;code&gt;on&lt;/code&gt; 대부분의 플랫폼 만에 디폴트 &lt;code&gt;off&lt;/code&gt; 로 인해 프로세스 제목을 업데이트 해당 플랫폼의 더 큰 오버 헤드 Windows에서. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0770fd14bde6f2b9d7a84507b79c75b3bf13dbb" translate="yes" xml:space="preserve">
          <source>Enables verbose mode.</source>
          <target state="translated">상세 모드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="be686f7be5950cf34bad6b75adc70f588a3070c6" translate="yes" xml:space="preserve">
          <source>Enables verbose mode. Will output some extra steps during startup and shutdown, as well as show the exact file name that is currently being processed if progress reporting is also enabled.</source>
          <target state="translated">상세 모드를 사용합니다. 시작 및 종료 중에 몇 가지 추가 단계를 출력 할뿐만 아니라 진행률보고가 활성화 된 경우 현재 처리중인 정확한 파일 이름을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fe31a01f44f98b228218e52dbf8b5e37e32c2524" translate="yes" xml:space="preserve">
          <source>Enabling and disabling row security, as well as adding policies to a table, is always the privilege of the table owner only.</source>
          <target state="translated">행 보안 활성화 및 비활성화와 테이블에 정책 추가는 항상 테이블 소유자의 특권입니다.</target>
        </trans-unit>
        <trans-unit id="d88bdb1d59885197da92cd539e47bd75193672fe" translate="yes" xml:space="preserve">
          <source>Enabling checksums in a large cluster can potentially take a long time. During this operation, the cluster or other programs that write to the data directory must not be started or else data loss may occur.</source>
          <target state="translated">대규모 클러스터에서 체크섬을 활성화하면 시간이 오래 걸릴 수 있습니다. 이 작업 중에 데이터 디렉토리에 쓰는 클러스터 또는 다른 프로그램을 시작하지 않아야합니다. 그렇지 않으면 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16eb09418a7d2058bea03afe5a97ce2e66b20131" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;a href=&quot;runtime-config-developer#GUC-WAL-DEBUG&quot;&gt;wal_debug&lt;/a&gt; configuration parameter (provided that PostgreSQL has been compiled with support for it) will result in each &lt;code&gt;XLogInsertRecord&lt;/code&gt; and &lt;code&gt;XLogFlush&lt;/code&gt; WAL call being logged to the server log. This option might be replaced by a more general mechanism in the future.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-developer#GUC-WAL-DEBUG&quot;&gt;wal_debug&lt;/a&gt; 구성 매개 변수를 활성화하면 (PostgreSQL &lt;code&gt;XLogInsertRecord&lt;/code&gt; 를 지원하도록 컴파일 된 경우) 각 XLogInsertRecord 및 &lt;code&gt;XLogFlush&lt;/code&gt; WAL 호출이 서버 로그에 기록됩니다. 이 옵션은 향후보다 일반적인 메커니즘으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e6da64af06028e20756acd4e64347dc93ae83ca" translate="yes" xml:space="preserve">
          <source>Encode binary data into a textual representation. Supported formats are: &lt;code&gt;base64&lt;/code&gt;, &lt;code&gt;hex&lt;/code&gt;, &lt;code&gt;escape&lt;/code&gt;. &lt;code&gt;escape&lt;/code&gt; converts zero bytes and high-bit-set bytes to octal sequences (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;nnn&lt;/code&gt;) and doubles backslashes.</source>
          <target state="translated">이진 데이터를 텍스트 표현으로 인코딩합니다. 지원되는 형식은 &lt;code&gt;base64&lt;/code&gt; , &lt;code&gt;hex&lt;/code&gt; , &lt;code&gt;escape&lt;/code&gt; 입니다. &lt;code&gt;escape&lt;/code&gt; 는 0 바이트 및 높은 비트 세트 바이트를 8 진 시퀀스 ( &lt;code&gt;\&lt;/code&gt; &lt;code&gt;nnn&lt;/code&gt; )로 변환하고 백 슬래시를 두 배로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cd4cfe682c625d2b3d6ab21cf4c88023527bf8c6" translate="yes" xml:space="preserve">
          <source>Encodes binary data into a textual representation; supported &lt;em&gt;&lt;code&gt;format&lt;/code&gt;&lt;/em&gt; values are: &lt;a href=&quot;functions-binarystring#ENCODE-FORMAT-BASE64&quot;&gt;&lt;code&gt;base64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions-binarystring#ENCODE-FORMAT-ESCAPE&quot;&gt;&lt;code&gt;escape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions-binarystring#ENCODE-FORMAT-HEX&quot;&gt;&lt;code&gt;hex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이진 데이터를 텍스트 표현으로 인코딩합니다. 지원되는 &lt;em&gt; &lt;code&gt;format&lt;/code&gt; &lt;/em&gt; 값은 &lt;a href=&quot;functions-binarystring#ENCODE-FORMAT-BASE64&quot;&gt; &lt;code&gt;base64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions-binarystring#ENCODE-FORMAT-ESCAPE&quot;&gt; &lt;code&gt;escape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions-binarystring#ENCODE-FORMAT-HEX&quot;&gt; &lt;code&gt;hex&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0451cbe9a0060c77e165e28a5107c4842ddc570b" translate="yes" xml:space="preserve">
          <source>Encoding in which the collation is applicable, or -1 if it works for any encoding</source>
          <target state="translated">데이터 정렬이 적용되는 인코딩 또는 인코딩에 작동하는 경우 -1</target>
        </trans-unit>
        <trans-unit id="341a64b217af4e5bb3b26e6e6aaaa7a31cc97ef1" translate="yes" xml:space="preserve">
          <source>Encrypt &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt; with a public PGP key &lt;em&gt;&lt;code&gt;key&lt;/code&gt;&lt;/em&gt;. Giving this function a secret key will produce an error.</source>
          <target state="translated">공개 PGP 키 &lt;em&gt; &lt;code&gt;key&lt;/code&gt; &lt;/em&gt;&lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt; 를 암호화하십시오 . 이 기능에 비밀 키를 부여하면 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a3990a8b9259bdb5f6a9b6abcbeffcba8897c8c" translate="yes" xml:space="preserve">
          <source>Encrypt &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt; with a symmetric PGP key &lt;em&gt;&lt;code&gt;psw&lt;/code&gt;&lt;/em&gt;. The &lt;em&gt;&lt;code&gt;options&lt;/code&gt;&lt;/em&gt; parameter can contain option settings, as described below.</source>
          <target state="translated">대칭 PGP 키 &lt;em&gt; &lt;code&gt;psw&lt;/code&gt; 로&lt;/em&gt;&lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt; 를 암호화하십시오 . &lt;em&gt; &lt;code&gt;options&lt;/code&gt; &lt;/em&gt; 아래와 같이 매개 변수는 옵션 설정을 포함 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9842995d92188012295a50b3899a0efd3fcda9d" translate="yes" xml:space="preserve">
          <source>Encrypt/decrypt data using the cipher method specified by &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt;. The syntax of the &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; string is:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type&lt;/code&gt; 에&lt;/em&gt; 지정된 암호 방법을 사용하여 데이터를 암호화 / 복호화 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 문자열 의 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5f8215dc00e7bd6f42b2309756207f16408e9f0" translate="yes" xml:space="preserve">
          <source>Encrypting Data Across A Network</source>
          <target state="translated">네트워크에서 데이터 암호화</target>
        </trans-unit>
        <trans-unit id="057f65baf1aec748dff67fe4eada3e2606712a49" translate="yes" xml:space="preserve">
          <source>Encryption For Specific Columns</source>
          <target state="translated">특정 열에 대한 암호화</target>
        </trans-unit>
        <trans-unit id="4533f510df88e2b0af919518ba19446d6841df20" translate="yes" xml:space="preserve">
          <source>Encryption Options</source>
          <target state="translated">암호화 옵션</target>
        </trans-unit>
        <trans-unit id="fb3559bc56acc81a8a2588665e15cc63cab9ccbc" translate="yes" xml:space="preserve">
          <source>End LSN for &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; states.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;r&lt;/code&gt; 상태에 대한 LSN을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="a0004120567bc0ebdbad1553091224b55d732de5" translate="yes" xml:space="preserve">
          <source>End a scan and release resources. The &lt;code&gt;scan&lt;/code&gt; struct itself should not be freed, but any locks or pins taken internally by the access method must be released, as well as any other memory allocated by &lt;code&gt;ambeginscan&lt;/code&gt; and other scan-related functions.</source>
          <target state="translated">스캔을 종료하고 자원을 해제하십시오. &lt;code&gt;scan&lt;/code&gt; 구조체 자체가 해제되지 않아야하지만, 액세스 방식에 의해 내부적으로 취해진 잠금 또는 핀에 의해 할당 된 다른 어떤 메모리뿐만 아니라 해제되어야 &lt;code&gt;ambeginscan&lt;/code&gt; 다른 검색 관련 기능.</target>
        </trans-unit>
        <trans-unit id="73135e91289bc93517190d0e6d3559a0e3664634" translate="yes" xml:space="preserve">
          <source>End of data can be represented by a single line containing just backslash-period (&lt;code&gt;\.&lt;/code&gt;). An end-of-data marker is not necessary when reading from a file, since the end of file serves perfectly well; it is needed only when copying data to or from client applications using pre-3.0 client protocol.</source>
          <target state="translated">데이터 끝은 백 슬래시 ( &lt;code&gt;\.&lt;/code&gt; ) 만 포함하는 단일 행으로 표시 될 수 있습니다 . 파일 끝을 완벽하게 제공하므로 파일에서 읽을 때 데이터 끝 표시가 필요하지 않습니다. 3.0 이전 클라이언트 프로토콜을 사용하여 클라이언트 응용 프로그램에서 데이터를 복사하거나 클라이언트 응용 프로그램에서 데이터를 복사 할 때만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7244ed52ecd0e00af92538864226baa5f273cc0f" translate="yes" xml:space="preserve">
          <source>Enhanced support for &lt;code&gt;int[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int[]&lt;/code&gt; 대한 향상된 지원</target>
        </trans-unit>
        <trans-unit id="1ef09b2c14360d7df9156ee864e5abbe1317f83d" translate="yes" xml:space="preserve">
          <source>Ensure that WAL archiving is enabled and working.</source>
          <target state="translated">WAL 아카이브가 사용 가능하고 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3096dbf7c9f089e5b75e6925610e01340ab4c14" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; configuration parameter is not disabled in &lt;code&gt;postgresql.conf&lt;/code&gt;; otherwise child tables may be accessed unnecessarily.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; 구성 매개 변수가 비활성화되어 있지 않은지 확인하십시오 . 그렇지 않으면 자식 테이블에 불필요하게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8c39032c5c162b802bfe063fb69e0eb9d71a9e" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; configuration parameter is not disabled in &lt;code&gt;postgresql.conf&lt;/code&gt;. If it is, queries will not be optimized as desired.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; 구성 매개 변수가 비활성화되어 있지 않은지 확인하십시오 . 그렇다면 쿼리가 원하는대로 최적화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e907b2d96c2e0510565b023e9313668a750f15ca" translate="yes" xml:space="preserve">
          <source>Ensure that the constraints guarantee that there is no overlap between the key values permitted in different child tables. A common mistake is to set up range constraints like:</source>
          <target state="translated">제약 조건으로 인해 다른 자식 테이블에서 허용되는 키 값이 겹치지 않아야합니다. 일반적인 실수는 다음과 같은 범위 제약 조건을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="74aec26e5aaa65d62267666deee0f48ec96663e2" translate="yes" xml:space="preserve">
          <source>Entering SQL Commands</source>
          <target state="translated">SQL 명령 입력</target>
        </trans-unit>
        <trans-unit id="046e4581b1c5aec34636d90839e4ed2b7307eb8a" translate="yes" xml:space="preserve">
          <source>Enum Functions</source>
          <target state="translated">열거 형 함수</target>
        </trans-unit>
        <trans-unit id="b8610d3e64c42d92c7dbc67b095e4215c3ffaaa5" translate="yes" xml:space="preserve">
          <source>Enum Functions: enum_first</source>
          <target state="translated">열거 형 함수 : enum_first</target>
        </trans-unit>
        <trans-unit id="7336a1c5ba5c19629373d430d26c38c6c87e8d09" translate="yes" xml:space="preserve">
          <source>Enum Functions: enum_last</source>
          <target state="translated">열거 형 함수 : enum_last</target>
        </trans-unit>
        <trans-unit id="be93ad7bbe09be7d1a2f12be74753766ff71b28b" translate="yes" xml:space="preserve">
          <source>Enum Functions: enum_range</source>
          <target state="translated">열거 형 함수 : enum_range</target>
        </trans-unit>
        <trans-unit id="8e316f488e30a30d5ab0c69be046123afa59e223" translate="yes" xml:space="preserve">
          <source>Enum labels are case sensitive, so &lt;code&gt;'happy'&lt;/code&gt; is not the same as &lt;code&gt;'HAPPY'&lt;/code&gt;. White space in the labels is significant too.</source>
          <target state="translated">열거 형 레이블은 대소 문자를 구분하므로 &lt;code&gt;'happy'&lt;/code&gt; 는 &lt;code&gt;'HAPPY'&lt;/code&gt; 와 다릅니다 . 레이블의 공백도 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a90b45275712d81cce74968837bc94f42d058471" translate="yes" xml:space="preserve">
          <source>Enum types</source>
          <target state="translated">열거 형 유형</target>
        </trans-unit>
        <trans-unit id="9c690fbe950b46ebdaae8dec97255d2d06e0850f" translate="yes" xml:space="preserve">
          <source>Enum types are created using the &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; command, for example:</source>
          <target state="translated">열거 형 유형은 다음과 같이 &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 명령을 사용하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="70b0c9b305752d04f1cf7f83d022114f817e1f4b" translate="yes" xml:space="preserve">
          <source>Enumerated (enum) types are data types that comprise a static, ordered set of values. They are equivalent to the &lt;code&gt;enum&lt;/code&gt; types supported in a number of programming languages. An example of an enum type might be the days of the week, or a set of status values for a piece of data.</source>
          <target state="translated">열거 형 (enum) 유형은 정적이고 순서가 정해진 값 세트를 구성하는 데이터 유형입니다. 그것들은 많은 프로그래밍 언어에서 지원되는 &lt;code&gt;enum&lt;/code&gt; 유형 과 같습니다 . 열거 형 유형의 예로는 요일 또는 데이터 조각에 대한 상태 값 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0366a10ef9d6d3ef8c64dd51eeccb78bad1656a" translate="yes" xml:space="preserve">
          <source>Enumerated Types</source>
          <target state="translated">열거 형</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="2c5dd77c7fad36918bfc17bd58ac4f9cc27c04d1" translate="yes" xml:space="preserve">
          <source>Epoch</source>
          <target state="translated">Epoch</target>
        </trans-unit>
        <trans-unit id="a472ce8d19d10484177dabb05deb4ee299058a0c" translate="yes" xml:space="preserve">
          <source>Equal</source>
          <target state="translated">Equal</target>
        </trans-unit>
        <trans-unit id="2081725ae4c002cb91da6ad56683b859418ee4a3" translate="yes" xml:space="preserve">
          <source>Equal, treating null as a comparable value.</source>
          <target state="translated">같음, null을 비교 가능한 값으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="d6768de4ea3856a8dc9524f7d67ec0786109ac2b" translate="yes" xml:space="preserve">
          <source>Equality comparison (this, and the other comparison operators, work on all JSON scalar values)</source>
          <target state="translated">동등 비교 (이 및 기타 비교 연산자는 모든 JSON 스칼라 값에서 작동 함)</target>
        </trans-unit>
        <trans-unit id="225f38b6ef3f013c2d18dbba5fe2e96af347bda3" translate="yes" xml:space="preserve">
          <source>Equality operator</source>
          <target state="translated">평등 연산자</target>
        </trans-unit>
        <trans-unit id="1f55cac8623bcd3e718c002528aa20c26ca69289" translate="yes" xml:space="preserve">
          <source>Equivalent</source>
          <target state="translated">Equivalent</target>
        </trans-unit>
        <trans-unit id="8fa1f90fe55ee69c7cc450279ce5054a76f35455" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;--locale=C&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--locale=C&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f75ad773988ea805c001deb8afac5f240f296a82" translate="yes" xml:space="preserve">
          <source>Error Code</source>
          <target state="translated">에러 코드</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="b7d9c1592623f8da811bdb9234af75a411c93a5c" translate="yes" xml:space="preserve">
          <source>Error Reporting and Logging</source>
          <target state="translated">오류보고 및 로깅</target>
        </trans-unit>
        <trans-unit id="7bc277840854dfa75df978bf81562fcab6c7816c" translate="yes" xml:space="preserve">
          <source>Errors along the line of &amp;ldquo;could not initialize database directory&amp;rdquo; are most likely related to insufficient permissions on the data directory, a full disk, or other file system problems.</source>
          <target state="translated">&amp;ldquo;데이터베이스 디렉토리를 초기화 할 수 없음&amp;rdquo;행의 오류는 데이터 디렉토리, 전체 디스크 또는 기타 파일 시스템 문제에 대한 권한이 충분하지 않은 것과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="567e2f29b36f15d7010e15b228d15b8b57008175" translate="yes" xml:space="preserve">
          <source>Errors related to the number or types of elements might not occur if the comparison is resolved using earlier columns.</source>
          <target state="translated">이전 열을 사용하여 비교를 해결하면 요소 수 또는 유형과 관련된 오류가 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="d92a0d6cc6ff18c625e4d2d10fa6f8398ba4b65d" translate="yes" xml:space="preserve">
          <source>Escaped Input Representation</source>
          <target state="translated">이스케이프 된 입력 표현</target>
        </trans-unit>
        <trans-unit id="a70529587a3b8c1eb3289010686d7afc6353fa45" translate="yes" xml:space="preserve">
          <source>Escaped Output Representation</source>
          <target state="translated">이스케이프 된 출력 표현</target>
        </trans-unit>
        <trans-unit id="69dbe5a9614224b4c161533b3c69c7a40c11a8f1" translate="yes" xml:space="preserve">
          <source>Establish a new connection for each transaction, rather than doing it just once per client session. This is useful to measure the connection overhead.</source>
          <target state="translated">클라이언트 세션 당 한 번만 수행하지 말고 각 트랜잭션마다 새 연결을 설정하십시오. 연결 오버 헤드를 측정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5a0cf6b10c30e13b7d98111e1c85c486aa9626d9" translate="yes" xml:space="preserve">
          <source>Establishes a new connection to a PostgreSQL server. The connection parameters to use can be specified either using a positional syntax (one or more of database name, user, host, and port), or using a &lt;code&gt;conninfo&lt;/code&gt; connection string as detailed in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;. If no arguments are given, a new connection is made using the same parameters as before.</source>
          <target state="translated">PostgreSQL 서버에 대한 새 연결을 설정합니다. 사용할 연결 매개 변수는 위치 구문 (데이터베이스 이름, 사용자, 호스트 및 포트 중 하나 이상)을 사용하거나 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;섹션 33.1.1에&lt;/a&gt; 설명 된대로 &lt;code&gt;conninfo&lt;/code&gt; 연결 문자열을 사용하여 지정할 수 있습니다. 인수가 제공되지 않으면 이전과 동일한 매개 변수를 사용하여 새 연결이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="47cfb90040ab1fc595e208467aae6de960b9eeb8" translate="yes" xml:space="preserve">
          <source>Establishes a new connection to a PostgreSQL server. The connection parameters to use can be specified either using a positional syntax, or using &lt;code&gt;conninfo&lt;/code&gt; connection strings as detailed in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 서버에 대한 새로운 연결을 설정합니다. 사용할 연결 매개 변수는 위치 구문을 사용하거나 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;33.1.1 절에&lt;/a&gt; 설명 된대로 &lt;code&gt;conninfo&lt;/code&gt; 연결 문자열을 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d03a086aee28b751fe576fa4bdabc53fb0f54ece" translate="yes" xml:space="preserve">
          <source>Estimate and return the fraction of parent-table rows that will be visited based on the given qual conditions. In the absence of any index-type-specific knowledge, use the standard optimizer function &lt;code&gt;clauselist_selectivity()&lt;/code&gt;:</source>
          <target state="translated">주어진 조건에 따라 방문 할 부모 테이블 행의 비율을 추정하고 반환합니다. 인덱스 유형별 지식이없는 경우 표준 옵티 마이저 함수 &lt;code&gt;clauselist_selectivity()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bec848de4aa44a0a15fc9c8942c2c946c78e91a1" translate="yes" xml:space="preserve">
          <source>Estimate and return the number of bytes of dynamic shared memory which the access method will be needed to perform a parallel scan. (This number is in addition to, not in lieu of, the amount of space needed for AM-independent data in &lt;code&gt;ParallelIndexScanDescData&lt;/code&gt;.)</source>
          <target state="translated">병렬 스캔을 수행하기 위해 액세스 방법이 필요한 동적 공유 메모리의 바이트 수를 추정하고 리턴하십시오. (이 숫자는 &lt;code&gt;ParallelIndexScanDescData&lt;/code&gt; 의 AM 독립 데이터에 필요한 공간을 대신하는 것이 아니라 그 대신입니다 .)</target>
        </trans-unit>
        <trans-unit id="7c6211936151b852e2f185a6b6a4f2437a25bb7b" translate="yes" xml:space="preserve">
          <source>Estimate the costs of an index scan. This function is described fully in &lt;a href=&quot;index-cost-estimation&quot;&gt;Section 61.6&lt;/a&gt;, below.</source>
          <target state="translated">인덱스 스캔 비용을 추정하십시오. 이 기능은 아래 &lt;a href=&quot;index-cost-estimation&quot;&gt;61.6 절에&lt;/a&gt; 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ded5e0300c03bb82b5d8f2aac16597430daf7c7b" translate="yes" xml:space="preserve">
          <source>Estimate the index correlation. For a simple ordered index on a single field, this can be retrieved from pg_statistic. If the correlation is not known, the conservative estimate is zero (no correlation).</source>
          <target state="translated">지수 상관을 추정하십시오. 단일 필드의 간단한 정렬 된 인덱스의 경우 pg_statistic에서 검색 할 수 있습니다. 상관이 알려지지 않은 경우 보수적 추정값은 0입니다 (상관 없음).</target>
        </trans-unit>
        <trans-unit id="2e36f34dab37d809ba9546de4730f9fe0465c9de" translate="yes" xml:space="preserve">
          <source>Estimate the number of index pages that will be retrieved during the scan. This might be just &lt;em&gt;&lt;code&gt;indexSelectivity&lt;/code&gt;&lt;/em&gt; times the index's size in pages.</source>
          <target state="translated">스캔 중에 검색 될 인덱스 페이지 수를 추정하십시오. 이것은 &lt;em&gt; &lt;code&gt;indexSelectivity&lt;/code&gt; &lt;/em&gt; 에 페이지 크기의 인덱스 크기를 곱한 것일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22f6d2800be54bd8d034e5f9fc23de7b2154ac60" translate="yes" xml:space="preserve">
          <source>Estimate the number of index rows that will be visited during the scan. For many index types this is the same as &lt;em&gt;&lt;code&gt;indexSelectivity&lt;/code&gt;&lt;/em&gt; times the number of rows in the index, but it might be more. (Note that the index's size in pages and rows is available from the &lt;code&gt;path-&amp;gt;indexinfo&lt;/code&gt; struct.)</source>
          <target state="translated">스캔 중에 방문 할 인덱스 행 수를 추정하십시오. 많은 인덱스 유형의 경우 이는 &lt;em&gt; &lt;code&gt;indexSelectivity&lt;/code&gt; &lt;/em&gt; 와 인덱스의 행 수를 곱한 것과 같지만 더 &lt;em&gt;클&lt;/em&gt; 수 있습니다. (페이지와 행의 색인 크기는 &lt;code&gt;path-&amp;gt;indexinfo&lt;/code&gt; 구조체 에서 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="9c7c4c0dbcde2cda466ad2979c816be2d9783880" translate="yes" xml:space="preserve">
          <source>Estimated average width of rows output by this plan node (in bytes).</source>
          <target state="translated">이 계획 노드에서 출력 한 예상 평균 행 너비 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="827aaed24a33d71c3aa9bc8bd44e74adc59bb3f9" translate="yes" xml:space="preserve">
          <source>Estimated execution cost (in units of &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;); if &lt;code&gt;proretset&lt;/code&gt;, this is cost per row returned</source>
          <target state="translated">예상 실행 비용 ( &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt; 단위 ); &lt;code&gt;proretset&lt;/code&gt; 인 경우 이것은 행당 반환 된 비용입니다</target>
        </trans-unit>
        <trans-unit id="162ceaab20109a5357a32758bbe2f6408fbc1e4a" translate="yes" xml:space="preserve">
          <source>Estimated number of dead rows</source>
          <target state="translated">데드 행의 예상 수</target>
        </trans-unit>
        <trans-unit id="694bdaaaaeaf00e19172f4b998db9c74caa5dc14" translate="yes" xml:space="preserve">
          <source>Estimated number of live rows</source>
          <target state="translated">예상 라이브 행 수</target>
        </trans-unit>
        <trans-unit id="6b46d923d47a400cec25631616b87a8ff2384267" translate="yes" xml:space="preserve">
          <source>Estimated number of result rows (zero if not &lt;code&gt;proretset&lt;/code&gt;)</source>
          <target state="translated">예상 결과 행 수 ( &lt;code&gt;proretset&lt;/code&gt; 이 아닌 경우 0 )</target>
        </trans-unit>
        <trans-unit id="d75455cff906b72838587195bcc9dd728a600aa0" translate="yes" xml:space="preserve">
          <source>Estimated number of rows inserted since this table was last vacuumed</source>
          <target state="translated">이 테이블이 마지막으로 비워진 이후 삽입 된 예상 행 수</target>
        </trans-unit>
        <trans-unit id="7728ea9ebbd6e71eba25826b64a5b37d25d134ef" translate="yes" xml:space="preserve">
          <source>Estimated number of rows modified since this table was last analyzed</source>
          <target state="translated">이 테이블을 마지막으로 분석 한 이후 수정 된 예상 행 수</target>
        </trans-unit>
        <trans-unit id="c10501d9a9b57a73d47cb5e0b89d85408e3e48f6" translate="yes" xml:space="preserve">
          <source>Estimated number of rows output by this plan node. Again, the node is assumed to be run to completion.</source>
          <target state="translated">이 계획 노드가 출력 한 예상 행 수입니다. 다시, 노드는 실행이 완료된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="bae3d1780605a78d7cb6c307c6325610550caa57" translate="yes" xml:space="preserve">
          <source>Estimated start-up cost. This is the time expended before the output phase can begin, e.g., time to do the sorting in a sort node.</source>
          <target state="translated">예상 시작 비용. 이는 출력 단계가 시작되기 전에 소비 된 시간입니다 (예 : 정렬 노드에서 정렬을 수행하는 시간).</target>
        </trans-unit>
        <trans-unit id="1c29292196fc470907aa2bfb67dd0623f0fd1b46" translate="yes" xml:space="preserve">
          <source>Estimated total cost. This is stated on the assumption that the plan node is run to completion, i.e., all available rows are retrieved. In practice a node's parent node might stop short of reading all available rows (see the &lt;code&gt;LIMIT&lt;/code&gt; example below).</source>
          <target state="translated">총 예상 비용. 이는 계획 노드가 완료 될 때까지 실행된다는 가정하에 설명됩니다. 즉, 사용 가능한 모든 행이 검색됩니다. 실제로 노드의 상위 노드는 사용 가능한 모든 행을 읽지 못하는 것을 중지 할 수 있습니다 ( 아래 &lt;code&gt;LIMIT&lt;/code&gt; 예 참조).</target>
        </trans-unit>
        <trans-unit id="b7626dd6115dd399a5451b8ceae77eb4101118cd" translate="yes" xml:space="preserve">
          <source>Euclidean distance between a and b.</source>
          <target state="translated">a와 b 사이의 유클리드 거리.</target>
        </trans-unit>
        <trans-unit id="fe3e5f6519ca15884710875534191a619674a62c" translate="yes" xml:space="preserve">
          <source>European Article Numbers, always displayed in the EAN13 display format</source>
          <target state="translated">항상 EAN13 표시 형식으로 표시되는 유럽 품목 번호</target>
        </trans-unit>
        <trans-unit id="2125658827a39fbf69c352b9f37f15d674ff0bf3" translate="yes" xml:space="preserve">
          <source>Evaluate the non-recursive term. For &lt;code&gt;UNION&lt;/code&gt; (but not &lt;code&gt;UNION ALL&lt;/code&gt;), discard duplicate rows. Include all remaining rows in the result of the recursive query, and also place them in a temporary &lt;em&gt;working table&lt;/em&gt;.</source>
          <target state="translated">비 재귀 항을 평가하십시오. 들어 &lt;code&gt;UNION&lt;/code&gt; (그러나 &lt;code&gt;UNION ALL&lt;/code&gt; ), 중복 행을 폐기합니다. 재귀 쿼리 결과에 나머지 행을 모두 포함하고 임시 &lt;em&gt;작업 테이블&lt;/em&gt; 에 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="123b32554a699621dd91baee8db3dada8e957007" translate="yes" xml:space="preserve">
          <source>Evaluate the recursive term, substituting the current contents of the working table for the recursive self-reference. For &lt;code&gt;UNION&lt;/code&gt; (but not &lt;code&gt;UNION ALL&lt;/code&gt;), discard duplicate rows and rows that duplicate any previous result row. Include all remaining rows in the result of the recursive query, and also place them in a temporary &lt;em&gt;intermediate table&lt;/em&gt;.</source>
          <target state="translated">재귀 자체 참조를 위해 작업 테이블의 현재 내용을 대체하여 재귀 용어를 평가하십시오. 들어 &lt;code&gt;UNION&lt;/code&gt; (그러나 &lt;code&gt;UNION ALL&lt;/code&gt; ), 중복 행과 이전 결과 행을 중복 행을 폐기합니다. 재귀 쿼리 결과에 나머지 행을 모두 포함하고 임시 &lt;em&gt;중간 테이블&lt;/em&gt; 에 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="ea7cf540807343327ce5217edad7c8b0e89b3c37" translate="yes" xml:space="preserve">
          <source>Evaluates the XPath query on the supplied document, and casts the result to &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">제공된 문서에서 XPath 쿼리를 평가하고 결과를 &lt;code&gt;boolean&lt;/code&gt; 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="59add1a14b4ee96acdf1a11adf89a0d0b10780fd" translate="yes" xml:space="preserve">
          <source>Evaluates the XPath query on the supplied document, and casts the result to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">제공된 문서에서 XPath 쿼리를 평가하고 결과를 &lt;code&gt;real&lt;/code&gt; 로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="ef1f1cff3cc51d1adfc527f95648e9089755ea9e" translate="yes" xml:space="preserve">
          <source>Evaluates the XPath query on the supplied document, and casts the result to &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">제공된 문서에서 XPath 쿼리를 평가하고 결과를 &lt;code&gt;text&lt;/code&gt; 로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="41d1b8c7e65fe16b848d70c1c54444f833e388f9" translate="yes" xml:space="preserve">
          <source>Evaluates the query on the document and returns multiple values separated by the specified separator, for example &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; if &lt;em&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">문서에 대한 쿼리를 평가하고 지정된 구분 기호로 구분 된 여러 값을 반환합니다 (예 : &lt;em&gt; &lt;code&gt;separator&lt;/code&gt; &lt;/em&gt; 가 &lt;code&gt;,&lt;/code&gt; 인 경우 &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; ) .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ee23d0bc4bbb93ad1acafca673718e2d3af0570" translate="yes" xml:space="preserve">
          <source>Evaluates the query on the document and wraps the result in XML tags. If the result is multivalued, the output will look like:</source>
          <target state="translated">문서에 대한 쿼리를 평가하고 결과를 XML 태그로 래핑합니다. 결과가 다중 값이면 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6aad88fc80f312751092cf88c7c06421eced67d6" translate="yes" xml:space="preserve">
          <source>Even though located outside the main PostgreSQL data directory, tablespaces are an integral part of the database cluster and &lt;em&gt;cannot&lt;/em&gt; be treated as an autonomous collection of data files. They are dependent on metadata contained in the main data directory, and therefore cannot be attached to a different database cluster or backed up individually. Similarly, if you lose a tablespace (file deletion, disk failure, etc), the database cluster might become unreadable or unable to start. Placing a tablespace on a temporary file system like a RAM disk risks the reliability of the entire cluster.</source>
          <target state="translated">기본 PostgreSQL 데이터 디렉토리 외부에 있더라도 테이블 스페이스는 데이터베이스 클러스터의 필수 부분이며 자율적 인 데이터 파일 모음으로 취급 &lt;em&gt;할 수 없습니다&lt;/em&gt; . 기본 데이터 디렉토리에 포함 된 메타 데이터에 종속되므로 다른 데이터베이스 클러스터에 연결하거나 개별적으로 백업 할 수 없습니다. 마찬가지로, 테이블 스페이스 (파일 삭제, 디스크 장애 등)가 손실되면 데이터베이스 클러스터를 읽을 수 없거나 시작할 수 없습니다. RAM 디스크와 같은 임시 파일 시스템에 테이블 스페이스를 배치하면 전체 클러스터의 안정성이 위험합니다.</target>
        </trans-unit>
        <trans-unit id="98bacc5b3624fe67c2aed3cd0d840dd98240baea" translate="yes" xml:space="preserve">
          <source>Even though most kinds of &lt;code&gt;JOIN&lt;/code&gt; don't completely constrain the join order, it is possible to instruct the PostgreSQL query planner to treat all &lt;code&gt;JOIN&lt;/code&gt; clauses as constraining the join order anyway. For example, these three queries are logically equivalent:</source>
          <target state="translated">대부분의 &lt;code&gt;JOIN&lt;/code&gt; 유형이 조인 순서를 완전히 제한하지는 않지만 PostgreSQL 쿼리 플래너가 모든 &lt;code&gt;JOIN&lt;/code&gt; 절을 조인 순서를 제한하는 것으로 취급하도록 지시 할 수 있습니다 . 예를 들어이 세 쿼리는 논리적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cd014339f1de23b1bcc5f4c392258b778fd9ab7f" translate="yes" xml:space="preserve">
          <source>Even when it is in general possible for parallel query plans to be generated, the planner will not generate them for a given query if any of the following are true:</source>
          <target state="translated">병렬 쿼리 계획을 생성하는 것이 일반적으로 가능하더라도 계획자는 다음 중 하나에 해당하는 경우 지정된 쿼리에 대해 계획을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a80c31308193949b9e4da18926b517610092195c" translate="yes" xml:space="preserve">
          <source>Even when parallel query plan is generated for a particular query, there are several circumstances under which it will be impossible to execute that plan in parallel at execution time. If this occurs, the leader will execute the portion of the plan below the &lt;code&gt;Gather&lt;/code&gt; node entirely by itself, almost as if the &lt;code&gt;Gather&lt;/code&gt; node were not present. This will happen if any of the following conditions are met:</source>
          <target state="translated">특정 쿼리에 대해 병렬 쿼리 계획이 생성 된 경우에도 실행시 해당 계획을 병렬로 실행할 수없는 몇 가지 상황이 있습니다. 이런 일이 발생하면 리더는 마치 &lt;code&gt;Gather&lt;/code&gt; 노드가없는 것처럼 &lt;code&gt;Gather&lt;/code&gt; 노드 아래에서 계획의 일부를 완전히 실행합니다 . 다음 조건 중 하나라도 충족되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7301a5b3f073f8978da3f9c7256efff55a0dbf7b" translate="yes" xml:space="preserve">
          <source>Even with the btree index defined the result will still be a sequential scan:</source>
          <target state="translated">btree 인덱스가 정의되어 있어도 결과는 여전히 순차적 스캔입니다.</target>
        </trans-unit>
        <trans-unit id="24fb24cc746ad21c0ebd0ce7281b566ac42b0326" translate="yes" xml:space="preserve">
          <source>Even with this option only one &lt;code&gt;REFRESH&lt;/code&gt; at a time may run against any one materialized view.</source>
          <target state="translated">이 옵션을 사용하더라도 한 번에 하나의 &lt;code&gt;REFRESH&lt;/code&gt; 만 하나의 구체화 된보기에 대해 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="fff9768e2dd5a78de391bf51471900a97575446e" translate="yes" xml:space="preserve">
          <source>Event triggers are disabled in single-user mode (see &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt;). If an erroneous event trigger disables the database so much that you can't even drop the trigger, restart in single-user mode and you'll be able to do that.</source>
          <target state="translated">단일 사용자 모드에서는 이벤트 트리거가 비활성화됩니다 ( &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; 참조 ). 잘못된 이벤트 트리거가 데이터베이스를 너무 비활성화하여 트리거를 제거 할 수없는 경우 단일 사용자 모드에서 다시 시작하면 해당 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d5400e57a51014f9b79b404545a075676f05d7" translate="yes" xml:space="preserve">
          <source>Event type that the rule is for: 1 = &lt;code&gt;SELECT&lt;/code&gt;, 2 = &lt;code&gt;UPDATE&lt;/code&gt;, 3 = &lt;code&gt;INSERT&lt;/code&gt;, 4 = &lt;code&gt;DELETE&lt;/code&gt;</source>
          <target state="translated">규칙이 적용되는 이벤트 유형 : 1 = &lt;code&gt;SELECT&lt;/code&gt; , 2 = &lt;code&gt;UPDATE&lt;/code&gt; , 3 = &lt;code&gt;INSERT&lt;/code&gt; , 4 = &lt;code&gt;DELETE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="510cbff4e121671fd1f953b5d4677d9d6b219a24" translate="yes" xml:space="preserve">
          <source>Every background worker process which is successfully started for a given parallel query will execute the parallel portion of the plan. The leader will also execute that portion of the plan, but it has an additional responsibility: it must also read all of the tuples generated by the workers. When the parallel portion of the plan generates only a small number of tuples, the leader will often behave very much like an additional worker, speeding up query execution. Conversely, when the parallel portion of the plan generates a large number of tuples, the leader may be almost entirely occupied with reading the tuples generated by the workers and performing any further processing steps which are required by plan nodes above the level of the &lt;code&gt;Gather&lt;/code&gt; node or &lt;code&gt;Gather Merge&lt;/code&gt; node. In such cases, the leader will do very little of the work of executing the parallel portion of the plan.</source>
          <target state="translated">주어진 병렬 쿼리에 대해 성공적으로 시작된 모든 백그라운드 작업자 프로세스는 계획의 병렬 부분을 실행합니다. 리더는 계획의 해당 부분을 실행하지만 추가 책임이 있습니다. 또한 작업자가 생성 한 모든 튜플을 읽어야합니다. 계획의 병렬 부분이 적은 수의 튜플 만 생성하는 경우 리더는 종종 추가 작업자와 매우 유사하게 동작하여 쿼리 실행 속도를 높입니다. 반대로, 계획의 병렬 부분이 많은 수의 튜플을 생성 할 때, 리더는 거의 전적으로 작업자가 생성 한 튜플을 읽고 &lt;code&gt;Gather&lt;/code&gt; 노드 레벨 이상의 계획 노드에 필요한 추가 처리 단계를 수행 할 수 있습니다. 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 마디. 이러한 경우 리더는 계획의 병렬 부분을 실행하는 작업을 거의 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="887b1e1617523b87a76a1697a9705c423761807a" translate="yes" xml:space="preserve">
          <source>Every connection to the database server is made using the name of some particular role, and this role determines the initial access privileges for commands issued in that connection. The role name to use for a particular database connection is indicated by the client that is initiating the connection request in an application-specific fashion. For example, the &lt;code&gt;psql&lt;/code&gt; program uses the &lt;code&gt;-U&lt;/code&gt; command line option to indicate the role to connect as. Many applications assume the name of the current operating system user by default (including &lt;code&gt;createuser&lt;/code&gt; and &lt;code&gt;psql&lt;/code&gt;). Therefore it is often convenient to maintain a naming correspondence between roles and operating system users.</source>
          <target state="translated">데이터베이스 서버에 대한 모든 연결은 특정 역할의 이름을 사용하여 이루어지며이 역할은 해당 연결에서 실행 된 명령에 대한 초기 액세스 권한을 결정합니다. 특정 데이터베이스 연결에 사용할 역할 이름은 응용 프로그램 특정 방식으로 연결 요청을 시작하는 클라이언트에 의해 표시됩니다. 예를 들어, &lt;code&gt;psql&lt;/code&gt; 프로그램은 &lt;code&gt;-U&lt;/code&gt; 명령 행 옵션을 사용하여 연결할 역할을 나타냅니다. 많은 응용 프로그램은 기본적으로 현재 운영 체제 사용자의 이름 ( &lt;code&gt;createuser&lt;/code&gt; 및 &lt;code&gt;psql&lt;/code&gt; 포함 )을 가정합니다. 따라서 역할과 운영 체제 사용자간에 이름 지정 통신을 유지하는 것이 편리한 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="068f0103f321b3d8229524e3f77030d33340bd95" translate="yes" xml:space="preserve">
          <source>Every non-empty range has two bounds, the lower bound and the upper bound. All points between these values are included in the range. An inclusive bound means that the boundary point itself is included in the range as well, while an exclusive bound means that the boundary point is not included in the range.</source>
          <target state="translated">비어 있지 않은 모든 범위에는 하한과 상한의 두 가지 경계가 있습니다. 이 값 사이의 모든 지점이 범위에 포함됩니다. 포함 된 경계는 경계점 자체도 범위에 포함됨을 의미하고, 독점적 경계는 경계점이 범위에 포함되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bb703aeb5d096be9bf34789666296b83ddbb3364" translate="yes" xml:space="preserve">
          <source>Every non-holdable open cursor is implicitly closed when a transaction is terminated by &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;. A holdable cursor is implicitly closed if the transaction that created it aborts via &lt;code&gt;ROLLBACK&lt;/code&gt;. If the creating transaction successfully commits, the holdable cursor remains open until an explicit &lt;code&gt;CLOSE&lt;/code&gt; is executed, or the client disconnects.</source>
          <target state="translated">트랜잭션이 &lt;code&gt;COMMIT&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK&lt;/code&gt; 에 의해 종료되면 보류 불가능한 모든 열린 커서가 내재적으로 닫힙니다 . 작성 가능한 트랜잭션이 &lt;code&gt;ROLLBACK&lt;/code&gt; 을 통해 중단되면 보류 가능 커서가 내재적으로 닫힙니다 . 작성 트랜잭션이 성공적으로 커미트되면 명시 적 &lt;code&gt;CLOSE&lt;/code&gt; 가 실행되거나 클라이언트 연결이 끊어 질 때까지 보류 가능 커서가 열린 상태로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="a8cef86d379ae9636ed2bcb0391d594e7540897a" translate="yes" xml:space="preserve">
          <source>Every publication can have multiple subscribers.</source>
          <target state="translated">모든 발행물에는 여러 구독자가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba11d62e4d7864e97ea8d9fbf2b997ccf619aaaf" translate="yes" xml:space="preserve">
          <source>Every table and index is stored as an array of &lt;em&gt;pages&lt;/em&gt; of a fixed size (usually 8 kB, although a different page size can be selected when compiling the server). In a table, all the pages are logically equivalent, so a particular item (row) can be stored in any page. In indexes, the first page is generally reserved as a &lt;em&gt;metapage&lt;/em&gt; holding control information, and there can be different types of pages within the index, depending on the index access method.</source>
          <target state="translated">모든 테이블과 인덱스는 고정 된 크기 의 &lt;em&gt;페이지&lt;/em&gt; 배열로 저장됩니다 (일반적으로 8kB이지만 서버를 컴파일 할 때 다른 페이지 크기를 선택할 수 있음). 테이블에서 모든 페이지는 논리적으로 동일하므로 특정 항목 (행)을 모든 페이지에 저장할 수 있습니다. 인덱스에서 첫 번째 페이지는 일반적으로 제어 정보를 보유 하는 &lt;em&gt;메타 페이지&lt;/em&gt; 로 예약되며 인덱스 액세스 방법에 따라 인덱스 내에 다른 유형의 페이지가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92b0c5180a9306aebfb659340d557ae0f5e7b48c" translate="yes" xml:space="preserve">
          <source>Every table has several &lt;em&gt;system columns&lt;/em&gt; that are implicitly defined by the system. Therefore, these names cannot be used as names of user-defined columns. (Note that these restrictions are separate from whether the name is a key word or not; quoting a name will not allow you to escape these restrictions.) You do not really need to be concerned about these columns; just know they exist.</source>
          <target state="translated">Every table has several &lt;em&gt;system columns&lt;/em&gt; that are implicitly defined by the system. Therefore, these names cannot be used as names of user-defined columns. (Note that these restrictions are separate from whether the name is a key word or not; quoting a name will not allow you to escape these restrictions.) You do not really need to be concerned about these columns; just know they exist.</target>
        </trans-unit>
        <trans-unit id="4e5c5f63629e607e2e60e453db01fe36ebacfaa6" translate="yes" xml:space="preserve">
          <source>Every time a new timeline is created, PostgreSQL creates a &amp;ldquo;timeline history&amp;rdquo; file that shows which timeline it branched off from and when. These history files are necessary to allow the system to pick the right WAL segment files when recovering from an archive that contains multiple timelines. Therefore, they are archived into the WAL archive area just like WAL segment files. The history files are just small text files, so it's cheap and appropriate to keep them around indefinitely (unlike the segment files which are large). You can, if you like, add comments to a history file to record your own notes about how and why this particular timeline was created. Such comments will be especially valuable when you have a thicket of different timelines as a result of experimentation.</source>
          <target state="translated">새로운 타임 라인이 생성 될 때마다 PostgreSQL은 &quot;타임 라인 기록&quot;파일을 생성하여 어느 타임 라인에서 언제 시작했는지를 보여줍니다. 이 기록 파일은 여러 타임 라인이 포함 된 아카이브에서 복구 할 때 시스템이 올바른 WAL 세그먼트 파일을 선택하는 데 필요합니다. 따라서 WAL 세그먼트 파일과 마찬가지로 WAL 아카이브 영역에 아카이브됩니다. 히스토리 파일은 작은 텍스트 파일이므로 큰 세그먼트 파일과 달리 저렴하고 적절하게 보관하는 것이 좋습니다. 원하는 경우 기록 파일에 주석을 추가하여이 특정 타임 라인이 생성 된 방법과 이유에 대한 자신의 메모를 기록 할 수 있습니다. 이러한 의견은 실험 결과로 서로 다른 타임 라인이있을 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65c4690b5ee5940e1c991c2b4b010f9b8b6ec89f" translate="yes" xml:space="preserve">
          <source>Every year divisible by 4 is a leap year.</source>
          <target state="translated">매년 4로 나눌 수있는 것은 윤년입니다.</target>
        </trans-unit>
        <trans-unit id="fa0eaf50a3a9b3fdec2a0517bd238d0ab91cd49b" translate="yes" xml:space="preserve">
          <source>Everything that is greater than or equal to 50</source>
          <target state="translated">50 이상의 모든 것</target>
        </trans-unit>
        <trans-unit id="28879d5603a0a05cd2d48100416506dd23aa25e4" translate="yes" xml:space="preserve">
          <source>Everything that is less than or equal to 0</source>
          <target state="translated">0보다 작거나 같은 모든 것</target>
        </trans-unit>
        <trans-unit id="e228d6b915ccfaec49cff235ad28c3f3c6c06405" translate="yes" xml:space="preserve">
          <source>Examining Index Usage</source>
          <target state="translated">인덱스 사용법 검사</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="fb903849014d52641a3ffc7db73f43574d560760" translate="yes" xml:space="preserve">
          <source>Example JSON</source>
          <target state="translated">JSON 예</target>
        </trans-unit>
        <trans-unit id="66effdf0836c4ad9c2c4b516463c39866827fe51" translate="yes" xml:space="preserve">
          <source>Example Output</source>
          <target state="translated">출력 예</target>
        </trans-unit>
        <trans-unit id="0568e4ecb01023a64507eb23cb66260dfd45368e" translate="yes" xml:space="preserve">
          <source>Example Query</source>
          <target state="translated">쿼리 예</target>
        </trans-unit>
        <trans-unit id="08e254953c8903a29788b024528486e1068199ed" translate="yes" xml:space="preserve">
          <source>Example Result</source>
          <target state="translated">결과 예</target>
        </trans-unit>
        <trans-unit id="3e1793a53c9bdcb0a95661b265938b8f743356e7" translate="yes" xml:space="preserve">
          <source>Example of authentication:</source>
          <target state="translated">인증 예 :</target>
        </trans-unit>
        <trans-unit id="b9863d8fa771c0597a3c22bdbfb624db7e334885" translate="yes" xml:space="preserve">
          <source>Example of creating such an index with a signature length of 100 bytes:</source>
          <target state="translated">서명 길이가 100 바이트 인 인덱스를 만드는 예 :</target>
        </trans-unit>
        <trans-unit id="9374382a95d80ba3b6ebab20980c40e147063b78" translate="yes" xml:space="preserve">
          <source>Example of creating such an index with a signature length of 32 bytes:</source>
          <target state="translated">32 바이트의 서명 길이로 이러한 인덱스를 만드는 예 :</target>
        </trans-unit>
        <trans-unit id="96cc7b00428b722b2c5d0ca42970f741c68bdd63" translate="yes" xml:space="preserve">
          <source>Example of creating such an index with the default signature length of 28 bytes:</source>
          <target state="translated">기본 서명 길이가 28 바이트 인 인덱스를 만드는 예 :</target>
        </trans-unit>
        <trans-unit id="63ad51e2c6fa9e36798f4847aa03de2466a549e9" translate="yes" xml:space="preserve">
          <source>Example of creating such an index with the default signature length of 8 bytes:</source>
          <target state="translated">기본 서명 길이가 8 바이트 인 이러한 인덱스를 만드는 예 :</target>
        </trans-unit>
        <trans-unit id="0b22ade5b2f97763a168cfba8698b54d3d6aa013" translate="yes" xml:space="preserve">
          <source>Example of creating such an index:</source>
          <target state="translated">그러한 색인을 작성하는 예 :</target>
        </trans-unit>
        <trans-unit id="92aaf122d1c7a2579eb3c87262fb4d3445ced618" translate="yes" xml:space="preserve">
          <source>Example of setting a new password:</source>
          <target state="translated">새 비밀번호 설정의 예 :</target>
        </trans-unit>
        <trans-unit id="dc0c325e49d7d3da30cbe13f9ce394101527f7b5" translate="yes" xml:space="preserve">
          <source>Example(s)</source>
          <target state="translated">Example(s)</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7f059574672fc1093b2a4e3e6c7eb57e0d0c1dc4" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Top.Countries.Europe.Russia&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;Top.Countries.Europe.Russia&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0075bd7af823016703d64e76064357a7f98bafcc" translate="yes" xml:space="preserve">
          <source>Example: To keep 24 hours of logs, one log file per hour, but also rotate sooner if the log file size exceeds 1GB, set &lt;code&gt;log_filename&lt;/code&gt; to &lt;code&gt;server_log.%H%M&lt;/code&gt;, &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;log_rotation_age&lt;/code&gt; to &lt;code&gt;60&lt;/code&gt;, and &lt;code&gt;log_rotation_size&lt;/code&gt; to &lt;code&gt;1000000&lt;/code&gt;. Including &lt;code&gt;%M&lt;/code&gt; in &lt;code&gt;log_filename&lt;/code&gt; allows any size-driven rotations that might occur to select a file name different from the hour's initial file name.</source>
          <target state="translated">예 : 로그 파일 크기가 1GB를 초과 할 경우 24 시간의 로그를 시간당 하나의 로그 파일로 유지하지만 더 빨리 회전하려면 &lt;code&gt;log_filename&lt;/code&gt; 을 &lt;code&gt;server_log.%H%M&lt;/code&gt; , &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; 을 &lt;code&gt;on&lt;/code&gt; 으로 , &lt;code&gt;log_rotation_age&lt;/code&gt; 를 &lt;code&gt;60&lt;/code&gt; 으로 , &lt;code&gt;log_rotation_size&lt;/code&gt; 를 &lt;code&gt;1000000&lt;/code&gt; 으로 설정하십시오 . &lt;code&gt;log_filename&lt;/code&gt; 에 &lt;code&gt;%M&lt;/code&gt; 을 포함 하면 시간의 초기 파일 이름과 다른 파일 이름을 선택하기 위해 발생할 수있는 크기 중심 회전이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9f0388078445111d3dbb9e29940a6d2e0a03fa91" translate="yes" xml:space="preserve">
          <source>Example: To keep 7 days of logs, one log file per day named &lt;code&gt;server_log.Mon&lt;/code&gt;, &lt;code&gt;server_log.Tue&lt;/code&gt;, etc, and automatically overwrite last week's log with this week's log, set &lt;code&gt;log_filename&lt;/code&gt; to &lt;code&gt;server_log.%a&lt;/code&gt;, &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;log_rotation_age&lt;/code&gt; to &lt;code&gt;1440&lt;/code&gt;.</source>
          <target state="translated">예 : 하루에 &lt;code&gt;server_log.Mon&lt;/code&gt; , &lt;code&gt;server_log.Tue&lt;/code&gt; 등으로 이름 지정된 로그 파일 7 일을 유지 하고 이번 주 로그로 지난 주 로그를 자동으로 덮어 &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; 려면 &lt;code&gt;log_filename&lt;/code&gt; 을 &lt;code&gt;server_log.%a&lt;/code&gt; , log_truncate_on_rotation 을 &lt;code&gt;on&lt;/code&gt; 으로 , &lt;code&gt;log_rotation_age&lt;/code&gt; 로 설정하십시오. ~ &lt;code&gt;1440&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="20eecb033aad96ed4ef8943e3f3587ebb40cb8ce" translate="yes" xml:space="preserve">
          <source>Examples (assuming the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting is &lt;code&gt;America/Los_Angeles&lt;/code&gt;):</source>
          <target state="translated">예 (현재 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 설정이 &lt;code&gt;America/Los_Angeles&lt;/code&gt; 라고 가정 ) :</target>
        </trans-unit>
        <trans-unit id="8472e2354405f69deb803796fe2c02c7737842bd" translate="yes" xml:space="preserve">
          <source>Examples (assuming the local time zone is &lt;code&gt;America/Los_Angeles&lt;/code&gt;):</source>
          <target state="translated">예 (현지 시간대가 &lt;code&gt;America/Los_Angeles&lt;/code&gt; 라고 가정 ) :</target>
        </trans-unit>
        <trans-unit id="33cdb73d833d65f495cd316014972491e84a6421" translate="yes" xml:space="preserve">
          <source>Examples (assuming the local time zone is &lt;code&gt;America/New_York&lt;/code&gt;):</source>
          <target state="translated">예 (현지 시간대가 &lt;code&gt;America/New_York&lt;/code&gt; 라고 가정 ) :</target>
        </trans-unit>
        <trans-unit id="f13f87d217fdf3d4f4f4a504bffad71085c9288c" translate="yes" xml:space="preserve">
          <source>Examples are given in &lt;a href=&quot;sql-prepare#SQL-PREPARE-EXAMPLES&quot;&gt;Examples&lt;/a&gt; in the &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; documentation.</source>
          <target state="translated">예제는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; 문서의 &lt;a href=&quot;sql-prepare#SQL-PREPARE-EXAMPLES&quot;&gt;예제&lt;/a&gt; 에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="099d24c3abaa6b8f8c50508e2936f6f3e4940ccb" translate="yes" xml:space="preserve">
          <source>Examples are given in the &lt;a href=&quot;sql-prepare#SQL-PREPARE-EXAMPLES&quot;&gt;Examples&lt;/a&gt; section of the &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; documentation.</source>
          <target state="translated">예는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; 문서 의 &lt;a href=&quot;sql-prepare#SQL-PREPARE-EXAMPLES&quot;&gt;예&lt;/a&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="742c8a1506366726fbe52da33bbba1b91ba9383e" translate="yes" xml:space="preserve">
          <source>Examples in this manual can also be found in the PostgreSQL source distribution in the directory &lt;code&gt;src/tutorial/&lt;/code&gt;. (Binary distributions of PostgreSQL might not compile these files.) To use those files, first change to that directory and run make:</source>
          <target state="translated">이 매뉴얼의 예제는 &lt;code&gt;src/tutorial/&lt;/code&gt; 디렉토리의 PostgreSQL 소스 배포에서도 찾을 수 있습니다 . (PostgreSQL의 바이너리 배포판은 이러한 파일을 컴파일하지 못할 수 있습니다.) 해당 파일을 사용하려면 먼저 해당 디렉토리로 변경하고 make를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="46ada8ab8f7f6bba7ddd1881ea3bc88ca95c9039" translate="yes" xml:space="preserve">
          <source>Examples in this section are drawn from the regression test database after doing a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;, using 9.3 development sources. You should be able to get similar results if you try the examples yourself, but your estimated costs and row counts might vary slightly because &lt;code&gt;ANALYZE&lt;/code&gt;'s statistics are random samples rather than exact, and because costs are inherently somewhat platform-dependent.</source>
          <target state="translated">이 섹션의 예제는 9.3 개발 소스를 사용하여 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 를 수행 한 후 회귀 테스트 데이터베이스에서 가져옵니다 . 예제를 직접 시도하면 비슷한 결과를 얻을 수 있지만 &lt;code&gt;ANALYZE&lt;/code&gt; 의 통계는 정확한 것이 아니라 무작위 샘플이고 비용은 본질적으로 플랫폼에 따라 다르기 때문에 예상 비용과 행 수는 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83b362a5cd12ed5136add2e4a37fd6e93b3b3081" translate="yes" xml:space="preserve">
          <source>Examples of cost estimator functions can be found in &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt;.</source>
          <target state="translated">비용 견적 기능의 예는 &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5de2f10ca767c0e44c4a3cce854ed17297b86a17" translate="yes" xml:space="preserve">
          <source>Examples of requirements that might be solved within a script include:</source>
          <target state="translated">스크립트 내에서 해결 될 수있는 요구 사항의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6875ccc7e641f5de84d947d364ef4dad711ae2d8" translate="yes" xml:space="preserve">
          <source>Examples of safe circumstances for turning off &lt;code&gt;fsync&lt;/code&gt; include the initial loading of a new database cluster from a backup file, using a database cluster for processing a batch of data after which the database will be thrown away and recreated, or for a read-only database clone which gets recreated frequently and is not used for failover. High quality hardware alone is not a sufficient justification for turning off &lt;code&gt;fsync&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; 를 해제하기위한 안전한 환경의 예로는 백업 파일에서 새 데이터베이스 클러스터를 처음로드하는 것, 데이터베이스 클러스터를 사용하여 데이터베이스를 폐기하고 다시 생성 한 후 또는 읽기 전용 데이터베이스를 사용하는 것 등이 있습니다. 복제가 자주 이루어지고 장애 조치에 사용되지 않습니다. 고품질 하드웨어만으로는 &lt;code&gt;fsync&lt;/code&gt; 를 끄기에 충분하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="851cdc1cfb89f844054b6836cfc41b2c935d46b8" translate="yes" xml:space="preserve">
          <source>Examples: &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;Personal_Services&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;42&lt;/code&gt; , &lt;code&gt;Personal_Services&lt;/code&gt; _ 서비스</target>
        </trans-unit>
        <trans-unit id="35da7c6b32a24e6eed204eac089ed634cb1bf145" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;ACCESS SHARE&lt;/code&gt;, &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt;, and &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock modes, the PostgreSQL lock modes and the &lt;code&gt;LOCK TABLE&lt;/code&gt; syntax are compatible with those present in Oracle.</source>
          <target state="translated">를 제외하고 &lt;code&gt;ACCESS SHARE&lt;/code&gt; , &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 및 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 락 모드를, PostgreSQL의 락 모드와 &lt;code&gt;LOCK TABLE&lt;/code&gt; 구문은 오라클에서 그 존재와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="e4fe039bd062569c687ede9f41e7b80ad57465cf" translate="yes" xml:space="preserve">
          <source>Except where noted, all the views described here are read-only.</source>
          <target state="translated">언급 된 경우를 제외하고 여기에 설명 된 모든보기는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="e828254c0368c4232a43a1d8994e1832d17dfacb" translate="yes" xml:space="preserve">
          <source>Exclude large objects in the dump.</source>
          <target state="translated">덤프에서 큰 오브젝트를 제외하십시오.</target>
        </trans-unit>
        <trans-unit id="83fdd2c71eb5fbf45469325c816eabb498d9afbf" translate="yes" xml:space="preserve">
          <source>Exclude specified foreign tables from the import. All tables existing in the foreign schema will be imported except the ones listed here.</source>
          <target state="translated">가져 오기에서 지정된 외부 테이블을 제외하십시오. 여기에 나열된 테이블을 제외하고 외부 스키마에 존재하는 모든 테이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8d1ff854ba786d4a02750ff27dbde99c53eb7679" translate="yes" xml:space="preserve">
          <source>Exclusion constraints are implemented using an index, so each specified operator must be associated with an appropriate operator class (see &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt;) for the index access method &lt;code&gt;index_method&lt;/code&gt;. The operators are required to be commutative. Each &lt;code&gt;exclude_element&lt;/code&gt; can optionally specify an operator class and/or ordering options; these are described fully under &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;.</source>
          <target state="translated">제외 제약 조건은 인덱스를 사용하여 구현되므로 지정된 각 연산자는 인덱스 액세스 방법 &lt;code&gt;index_method&lt;/code&gt; 에 적합한 연산자 클래스 ( &lt;a href=&quot;indexes-opclass&quot;&gt;11.10 절&lt;/a&gt; 참조)와 연결되어야합니다 . 연산자는 정식이어야합니다. 각 &lt;code&gt;exclude_element&lt;/code&gt; 는 선택적으로 연산자 클래스 및 / 또는 순서 옵션을 지정할 수 있습니다. 이것들은 &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="325362b3bfcd3f16918d4d0c6750a65a1dd8f170" translate="yes" xml:space="preserve">
          <source>Exclusion constraints ensure that if any two rows are compared on the specified columns or expressions using the specified operators, at least one of these operator comparisons will return false or null. The syntax is:</source>
          <target state="translated">제외 제약 조건은 지정된 연산자를 사용하여 지정된 열이나 식에서 두 행을 비교하는 경우 이러한 연산자 비교 중 하나 이상이 false 또는 null을 반환합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="213cfc7597d88344bf806d4892d04bfbbc89fcea" translate="yes" xml:space="preserve">
          <source>Execute monitoring functions that may take &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on tables, potentially for a long time.</source>
          <target state="translated">잠재적으로 테이블에서 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 잠금을 수행 할 수있는 모니터링 기능을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="f68d1ff40afb62998db4655ae79b633e479f56e2" translate="yes" xml:space="preserve">
          <source>Execute the function &lt;code&gt;check_account_update&lt;/code&gt; whenever a row of the table &lt;code&gt;accounts&lt;/code&gt; is about to be updated:</source>
          <target state="translated">테이블 &lt;code&gt;accounts&lt;/code&gt; 의 행을 업데이트 &lt;code&gt;check_account_update&lt;/code&gt; 할 때마다 check_account_update 함수를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="973f7fa817c4c00cf8cb1f780941428a1b6ce439" translate="yes" xml:space="preserve">
          <source>Execute the function &lt;code&gt;check_matching_pairs&lt;/code&gt; for each row to confirm that changes are made to matching pairs at the same time (by the same statement):</source>
          <target state="translated">각 행에 대해 &lt;code&gt;check_matching_pairs&lt;/code&gt; 함수를 실행하여 동일한 명령문으로 일치하는 쌍이 동시에 변경 되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="80f7e2f983e8dc04b3b9350ac9e67b90053423f7" translate="yes" xml:space="preserve">
          <source>Execute the function &lt;code&gt;check_transfer_balances_to_zero&lt;/code&gt; for each statement to confirm that the &lt;code&gt;transfer&lt;/code&gt; rows offset to a net of zero:</source>
          <target state="translated">각 명령문에 대해 &lt;code&gt;check_transfer_balances_to_zero&lt;/code&gt; 함수를 실행하여 &lt;code&gt;transfer&lt;/code&gt; 행이 0의 순으로 오프셋 되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="325bf3f48152d3c7b85e0489bf435ea01b518f1f" translate="yes" xml:space="preserve">
          <source>Execute the function &lt;code&gt;view_insert_row&lt;/code&gt; for each row to insert rows into the tables underlying a view:</source>
          <target state="translated">각 행에 대해 &lt;code&gt;view_insert_row&lt;/code&gt; 함수를 실행하여 뷰의 기초가되는 테이블에 행을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="1c97d9e53c4c266e1f7bab849114ba5ae30988bb" translate="yes" xml:space="preserve">
          <source>Execute the reindex commands in parallel by running &lt;code&gt;njobs&lt;/code&gt; commands simultaneously. This option may reduce the processing time but it also increases the load on the database server.</source>
          <target state="translated">&lt;code&gt;njobs&lt;/code&gt; 명령을 동시에 실행하여 reindex 명령을 병렬로 실행 합니다. 이 옵션은 처리 시간을 줄일 수 있지만 데이터베이스 서버의로드도 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="dbc75e4af30fdf9e85a66b0417aa7a131b074cf2" translate="yes" xml:space="preserve">
          <source>Execute the restore as a single transaction (that is, wrap the emitted commands in &lt;code&gt;BEGIN&lt;/code&gt;/&lt;code&gt;COMMIT&lt;/code&gt;). This ensures that either all the commands complete successfully, or no changes are applied. This option implies &lt;code&gt;--exit-on-error&lt;/code&gt;.</source>
          <target state="translated">단일 트랜잭션으로 복원을 실행하십시오 (즉, 생성 된 명령을 &lt;code&gt;BEGIN&lt;/code&gt; / &lt;code&gt;COMMIT&lt;/code&gt; 에 랩 ). 이렇게하면 모든 명령이 성공적으로 완료되거나 변경 사항이 적용되지 않습니다. 이 옵션은 &lt;code&gt;--exit-on-error&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="d36410ea33dda661076546d6a103be6811ac9b66" translate="yes" xml:space="preserve">
          <source>Execute the vacuum or analyze commands in parallel by running &lt;code&gt;njobs&lt;/code&gt; commands simultaneously. This option may reduce the processing time but it also increases the load on the database server.</source>
          <target state="translated">&lt;code&gt;njobs&lt;/code&gt; 명령을 동시에 실행하여 vacuum을 실행하거나 명령을 분석합니다 . 이 옵션은 처리 시간을 줄일 수 있지만 데이터베이스 서버의로드도 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="373f9c05993c1a03043edfc39866631c89b0f5e8" translate="yes" xml:space="preserve">
          <source>Execute the vacuum or analyze commands in parallel by running &lt;code&gt;njobs&lt;/code&gt; commands simultaneously. This option reduces the time of the processing but it also increases the load on the database server.</source>
          <target state="translated">&lt;code&gt;njobs&lt;/code&gt; 명령을 동시에 실행하여 진공을 실행하거나 명령을 병렬로 실행 하십시오 . 이 옵션은 처리 시간을 줄이지 만 데이터베이스 서버의로드도 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="8e26d205c84542e88787603bb1bf7d32c21bd66e" translate="yes" xml:space="preserve">
          <source>Execute transactions targeting the specified rate instead of running as fast as possible (the default). The rate is given in transactions per second. If the targeted rate is above the maximum possible rate, the rate limit won't impact the results.</source>
          <target state="translated">가능한 빨리 실행하는 대신 지정된 비율을 대상으로하는 트랜잭션을 실행하십시오 (기본값). 비율은 초당 트랜잭션으로 제공됩니다. 목표 요율이 최대 요율보다 높으면 요율 제한이 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98533d4770f6729d5035062ebb03b9d7de2b38d3" translate="yes" xml:space="preserve">
          <source>Executes the &lt;em&gt;&lt;code&gt;sqlquery&lt;/code&gt;&lt;/em&gt;, which must return a single &lt;code&gt;tsvector&lt;/code&gt; column, and returns statistics about each distinct lexeme contained in the data. See &lt;a href=&quot;textsearch-features#TEXTSEARCH-STATISTICS&quot;&gt;Section 12.4.4&lt;/a&gt; for details.</source>
          <target state="translated">단일 &lt;code&gt;tsvector&lt;/code&gt; 열을 반환해야하는 &lt;em&gt; &lt;code&gt;sqlquery&lt;/code&gt; 를&lt;/em&gt; 실행하고 데이터에 포함 된 각 고유 한 용어 에 대한 통계를 반환합니다. 자세한 내용은 &lt;a href=&quot;textsearch-features#TEXTSEARCH-STATISTICS&quot;&gt;섹션 12.4.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec29950a103356b62716ea977952173d73196586" translate="yes" xml:space="preserve">
          <source>Executes the current query buffer (like &lt;code&gt;\g&lt;/code&gt;) and shows the results in a crosstab grid. The query must return at least three columns. The output column identified by &lt;code&gt;colV&lt;/code&gt; becomes a vertical header and the output column identified by &lt;code&gt;colH&lt;/code&gt; becomes a horizontal header. &lt;code&gt;colD&lt;/code&gt; identifies the output column to display within the grid. &lt;code&gt;sortcolH&lt;/code&gt; identifies an optional sort column for the horizontal header.</source>
          <target state="translated">현재 쿼리 버퍼 ( &lt;code&gt;\g&lt;/code&gt; )를 실행하고 결과를 크로스 탭 그리드에 표시합니다. 쿼리는 3 개 이상의 열을 반환해야합니다. &lt;code&gt;colV&lt;/code&gt; 로 식별 된 출력 열 은 세로 헤더 가 되고 &lt;code&gt;colH&lt;/code&gt; 로 식별 된 출력 열 은 가로 헤더가됩니다. &lt;code&gt;colD&lt;/code&gt; 는 그리드 내에 표시 할 출력 열을 식별합니다. &lt;code&gt;sortcolH&lt;/code&gt; 는 수평 헤더에 대한 선택적 정렬 열을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="2a264333c89958c5123b9533cdf455a29d775b5b" translate="yes" xml:space="preserve">
          <source>Executing a command with &lt;code&gt;PROGRAM&lt;/code&gt; might be restricted by the operating system's access control mechanisms, such as SELinux.</source>
          <target state="translated">&lt;code&gt;PROGRAM&lt;/code&gt; 으로 명령을 실행하는 것은 SELinux와 같은 운영 체제의 액세스 제어 메커니즘에 의해 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="339a8528af8223bc10ea0f77d0f208de3f1ce898" translate="yes" xml:space="preserve">
          <source>Execution-time partition pruning currently only occurs for the &lt;code&gt;Append&lt;/code&gt; and &lt;code&gt;MergeAppend&lt;/code&gt; node types. It is not yet implemented for the &lt;code&gt;ModifyTable&lt;/code&gt; node type, but that is likely to be changed in a future release of PostgreSQL.</source>
          <target state="translated">실행 시간 파티션 정리는 현재 &lt;code&gt;Append&lt;/code&gt; 및 &lt;code&gt;MergeAppend&lt;/code&gt; 노드 유형에 대해서만 발생합니다 . &lt;code&gt;ModifyTable&lt;/code&gt; 노드 유형에 대해서는 아직 구현되지 않았지만 향후 PostgreSQL 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1f6604b7486fef57febf39070b6b5f55ece6c6b" translate="yes" xml:space="preserve">
          <source>Executor</source>
          <target state="translated">Executor</target>
        </trans-unit>
        <trans-unit id="b90fddf2bc2d6256c8e2ecb71d9c0ed9bde6a5bf" translate="yes" xml:space="preserve">
          <source>Existing &amp;amp; new rows</source>
          <target state="translated">기존 및 새 행</target>
        </trans-unit>
        <trans-unit id="934b5c9d3d27ed262c8bd429e388e9a9abd89875" translate="yes" xml:space="preserve">
          <source>Existing &amp;amp; new rows &lt;a href=&quot;sql-createpolicy#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">기존 및 새 행 &lt;a href=&quot;sql-createpolicy#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96bcff04ab58951d1c3f0f0f49a13b92eb241eba" translate="yes" xml:space="preserve">
          <source>Existing Lock Mode</source>
          <target state="translated">기존 잠금 모드</target>
        </trans-unit>
        <trans-unit id="8dc5a6c01e5f162f19b12916d1546797cdbec555" translate="yes" xml:space="preserve">
          <source>Existing replication slots and their state can be seen in the &lt;a href=&quot;view-pg-replication-slots&quot;&gt;&lt;code&gt;pg_replication_slots&lt;/code&gt;&lt;/a&gt; view.</source>
          <target state="translated">기존 복제 슬롯 및 해당 상태는 &lt;a href=&quot;view-pg-replication-slots&quot;&gt; &lt;code&gt;pg_replication_slots&lt;/code&gt; &lt;/a&gt; 보기 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="606c3933da970b1c7e75f4ef36f3c7ad379d14ac" translate="yes" xml:space="preserve">
          <source>Existing row</source>
          <target state="translated">기존 행</target>
        </trans-unit>
        <trans-unit id="419dd50ebb1b22b3eb16972fe85c81ef88d5f9e5" translate="yes" xml:space="preserve">
          <source>Existing row &lt;a href=&quot;sql-createpolicy#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">기존 행 &lt;a href=&quot;sql-createpolicy#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="48bc07ca7935e9337112fe3b40e606ae37e6dba7" translate="yes" xml:space="preserve">
          <source>Existing rows will be filled with &lt;code&gt;old&lt;/code&gt;, but then the default for subsequent commands will be &lt;code&gt;current&lt;/code&gt;. The effects are the same as if the two sub-commands had been issued in separate &lt;code&gt;ALTER TABLE&lt;/code&gt; commands.</source>
          <target state="translated">기존의 행이 채워집니다 &lt;code&gt;old&lt;/code&gt; , 그러나 후속 명령의 기본이 될 것입니다 &lt;code&gt;current&lt;/code&gt; . 효과는 두 개의 하위 명령이 별도의 &lt;code&gt;ALTER TABLE&lt;/code&gt; 명령 에서 실행 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f7b38897c28dc7ef74832f46494c945adcbaee74" translate="yes" xml:space="preserve">
          <source>Existing rows will be filled with the current time as the value of the new column, and then new rows will receive the time of their insertion.</source>
          <target state="translated">기존 행은 새 열의 값으로 현재 시간으로 채워지고 새 행은 삽입 시간을받습니다.</target>
        </trans-unit>
        <trans-unit id="6f147bbcdc2ea57f6c81bec669ec536b253dc54b" translate="yes" xml:space="preserve">
          <source>Exit Status</source>
          <target state="translated">종료 상태</target>
        </trans-unit>
        <trans-unit id="cbfe965735e4f03874cb10d2d7f50f432172b6e0" translate="yes" xml:space="preserve">
          <source>Exit as soon as a problem with the backup is detected. If this option is not specified, &lt;code&gt;pg_verifybackup&lt;/code&gt; will continue checking the backup even after a problem has been detected, and will report all problems detected as errors.</source>
          <target state="translated">백업 문제가 감지되는 즉시 종료하십시오. 이 옵션을 지정하지 않으면 &lt;code&gt;pg_verifybackup&lt;/code&gt; 은 문제가 감지 된 후에도 백업을 계속 확인하고 감지 된 모든 문제를 오류로보고합니다.</target>
        </trans-unit>
        <trans-unit id="028ddb1fdd2ac3734c1e28cdf22fa5a854aaece2" translate="yes" xml:space="preserve">
          <source>Exit if an error is encountered while sending SQL commands to the database. The default is to continue and to display a count of errors at the end of the restoration.</source>
          <target state="translated">SQL 명령을 데이터베이스에 보내는 동안 오류가 발생하면 종료하십시오. 기본값은 계속되고 복원 종료시 오류 수를 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd3f1eddfd61de0467e1a1bf980bcdc41ac18497" translate="yes" xml:space="preserve">
          <source>Expanded TOAST pointers are useful for complex data types whose on-disk representation is not especially suited for computational purposes. As an example, the standard varlena representation of a PostgreSQL array includes dimensionality information, a nulls bitmap if there are any null elements, then the values of all the elements in order. When the element type itself is variable-length, the only way to find the &lt;code&gt;N&lt;/code&gt;'th element is to scan through all the preceding elements. This representation is appropriate for on-disk storage because of its compactness, but for computations with the array it's much nicer to have an &amp;ldquo;expanded&amp;rdquo; or &amp;ldquo;deconstructed&amp;rdquo; representation in which all the element starting locations have been identified. The TOAST pointer mechanism supports this need by allowing a pass-by-reference Datum to point to either a standard varlena value (the on-disk representation) or a TOAST pointer that points to an expanded representation somewhere in memory. The details of this expanded representation are up to the data type, though it must have a standard header and meet the other API requirements given in &lt;code&gt;src/include/utils/expandeddatum.h&lt;/code&gt;. C-level functions working with the data type can choose to handle either representation. Functions that do not know about the expanded representation, but simply apply &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; to their inputs, will automatically receive the traditional varlena representation; so support for an expanded representation can be introduced incrementally, one function at a time.</source>
          <target state="translated">확장 된 TOAST 포인터는 온 디스크 표현이 계산 목적에 특히 적합하지 않은 복잡한 데이터 유형에 유용합니다. 예를 들어, PostgreSQL 배열의 표준 varlena 표현에는 차원 정보, 널 요소가있는 경우 널 비트 맵, 모든 요소의 값이 순서대로 포함됩니다. 요소 유형 자체가 가변 길이 인 경우 &lt;code&gt;N&lt;/code&gt; 을 찾는 유일한 방법'번째 요소는 앞의 모든 요소를 ​​스캔하는 것입니다. 이 표현은 크기가 작기 때문에 온 디스크 스토리지에 적합하지만 어레이를 사용한 계산의 경우 모든 요소 시작 위치가 식별 된 &quot;확장&quot;또는 &quot;해체&quot;표현이 훨씬 좋습니다. TOAST 포인터 메커니즘은 기준 별 기준 데이텀이 표준 varlena 값 (온 디스크 표현) 또는 메모리 어딘가의 확장 표현을 가리키는 TOAST 포인터를 가리 키도록하여 이러한 요구를 지원합니다. 이 확장 표현의 세부 사항은 데이터 유형에 따라 다르지만 표준 헤더가 있어야하고 &lt;code&gt;src/include/utils/expandeddatum.h&lt;/code&gt; 에 제공된 다른 API 요구 사항을 충족해야합니다.. 데이터 유형으로 작업하는 C 레벨 함수는 두 표현 중 하나를 처리하도록 선택할 수 있습니다. 확장 표현에 대해서는 모르지만 &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; 을 입력에 적용하는 함수 는 자동으로 전통적인 바레 나 표현을받습니다. 확장 된 표현에 대한 지원은 한 번에 한 기능 씩 점진적으로 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c39f8fbfa22293d273148e9a77b9a280b6f5036" translate="yes" xml:space="preserve">
          <source>Expands a &lt;code&gt;tsvector&lt;/code&gt; into a set of rows, one per lexeme.</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 를 lexeme 당 하나씩, 행 세트로 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="370e6267e22c067604ebc57062ada21b7609d4c3" translate="yes" xml:space="preserve">
          <source>Expands a JSON array to a set of &lt;code&gt;text&lt;/code&gt; values.</source>
          <target state="translated">JSON 배열을 일련의 &lt;code&gt;text&lt;/code&gt; 값으로 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="bf9f5179e248278db3bd9e202741f05d488c956f" translate="yes" xml:space="preserve">
          <source>Expands a JSON array to a set of JSON values.</source>
          <target state="translated">JSON 배열을 일련의 JSON 값으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="e64a47c736350aa33f9a9ef2b26ac52bdb473a74" translate="yes" xml:space="preserve">
          <source>Expands an array to a set of rows.</source>
          <target state="translated">배열을 행 세트로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="a80ff9cf2b042f81246594e42fe5e0fc634820eb" translate="yes" xml:space="preserve">
          <source>Expands multiple arrays (possibly of different data types) to a set of rows. If the arrays are not all the same length then the shorter ones are padded with &lt;code&gt;NULL&lt;/code&gt;s. This is only allowed in a query's FROM clause; see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;Section 7.2.1.4&lt;/a&gt;.</source>
          <target state="translated">여러 배열 (데이터 유형이 다를 수 있음)을 행 집합으로 확장합니다. 배열의 길이가 모두 같지 않으면 더 짧은 배열은 &lt;code&gt;NULL&lt;/code&gt; 로 채워집니다 . 이것은 쿼리의 FROM 절에서만 허용됩니다. &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;7.2.1.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d82ee60a5062bc5b8e066e5961be39131485da38" translate="yes" xml:space="preserve">
          <source>Expands the object in &lt;code&gt;from_json&lt;/code&gt; to a row whose columns match the record type defined by &lt;code&gt;base&lt;/code&gt; (see note below).</source>
          <target state="translated">&lt;code&gt;from_json&lt;/code&gt; 의 오브젝트를 열이 &lt;code&gt;base&lt;/code&gt; 에 의해 정의 된 레코드 유형과 일치하는 행으로 확장합니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="6fbf031c9047c3f5e9366977102918179b27f990" translate="yes" xml:space="preserve">
          <source>Expands the outermost JSON object into a set of key/value pairs.</source>
          <target state="translated">가장 바깥 쪽 JSON 객체를 일련의 키 / 값 쌍으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="ef70fe44bd312be7a9fa6873660eab981e4f5489" translate="yes" xml:space="preserve">
          <source>Expands the outermost JSON object into a set of key/value pairs. The returned values will be of type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">가장 바깥 쪽 JSON 객체를 일련의 키 / 값 쌍으로 확장합니다. 반환되는 값은 &lt;code&gt;text&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="07d2aad3737c433e4d588a6cebf30375bd4aeada" translate="yes" xml:space="preserve">
          <source>Expands the outermost array of objects in &lt;code&gt;from_json&lt;/code&gt; to a set of rows whose columns match the record type defined by &lt;code&gt;base&lt;/code&gt; (see note below).</source>
          <target state="translated">&lt;code&gt;from_json&lt;/code&gt; 의 가장 바깥 쪽 객체 배열을 &lt;code&gt;base&lt;/code&gt; 정의 된 레코드 유형과 일치하는 열 집합으로 확장합니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="5037757ed62d61772dde0245a6e0380408af04a5" translate="yes" xml:space="preserve">
          <source>Expands the top-level JSON array into a set of &lt;code&gt;text&lt;/code&gt; values.</source>
          <target state="translated">최상위 JSON 배열을 &lt;code&gt;text&lt;/code&gt; 값 세트로 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="32d899610739c4d6710bdb8a752b68dd1693848d" translate="yes" xml:space="preserve">
          <source>Expands the top-level JSON array into a set of JSON values.</source>
          <target state="translated">최상위 JSON 배열을 JSON 값 세트로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="f0e629ca626f1a99640629e40bf9bd3b56ab3d95" translate="yes" xml:space="preserve">
          <source>Expands the top-level JSON array of objects to a set of rows having the composite type defined by an &lt;code&gt;AS&lt;/code&gt; clause. (As with all functions returning &lt;code&gt;record&lt;/code&gt;, the calling query must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.) Each element of the JSON array is processed as described above for &lt;code&gt;json[b]_populate_record&lt;/code&gt;.</source>
          <target state="translated">객체의 최상위 JSON 배열을 &lt;code&gt;AS&lt;/code&gt; 절에 의해 정의 된 복합 유형이있는 행 집합으로 확장합니다 . ( &lt;code&gt;record&lt;/code&gt; 를 반환하는 모든 함수와 마찬가지로 호출 쿼리는 &lt;code&gt;AS&lt;/code&gt; 절 을 사용하여 레코드 구조를 명시 적으로 정의해야합니다 .) JSON 배열의 각 요소는 &lt;code&gt;json[b]_populate_record&lt;/code&gt; 대해 위에서 설명한대로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="13c1ebeb3ed758ad87565c024dbef148501abf7d" translate="yes" xml:space="preserve">
          <source>Expands the top-level JSON array of objects to a set of rows having the composite type of the &lt;em&gt;&lt;code&gt;base&lt;/code&gt;&lt;/em&gt; argument. Each element of the JSON array is processed as described above for &lt;code&gt;json[b]_populate_record&lt;/code&gt;.</source>
          <target state="translated">객체의 최상위 JSON 배열을 &lt;em&gt; &lt;code&gt;base&lt;/code&gt; &lt;/em&gt; 인수 의 복합 유형이있는 행 세트로 확장합니다 . JSON 배열의 각 요소는 &lt;code&gt;json[b]_populate_record&lt;/code&gt; 대해 위에서 설명한대로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="df68f2063feec449ecb43ad8f2fe27305fa06fe8" translate="yes" xml:space="preserve">
          <source>Expands the top-level JSON object into a set of key/value pairs.</source>
          <target state="translated">최상위 JSON 개체를 키 / 값 쌍 집합으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="56f0fca8c5938d949293f85c425f8caa825f2252" translate="yes" xml:space="preserve">
          <source>Expands the top-level JSON object into a set of key/value pairs. The returned &lt;em&gt;&lt;code&gt;value&lt;/code&gt;&lt;/em&gt;s will be of type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">최상위 JSON 개체를 키 / 값 쌍 집합으로 확장합니다. 반환 된 &lt;em&gt; &lt;code&gt;value&lt;/code&gt; &lt;/em&gt; 은 &lt;code&gt;text&lt;/code&gt; 유형이 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e9b34d66b165d3209261ab82f550a96c3355d36" translate="yes" xml:space="preserve">
          <source>Expands the top-level JSON object to a row having the composite type defined by an &lt;code&gt;AS&lt;/code&gt; clause. (As with all functions returning &lt;code&gt;record&lt;/code&gt;, the calling query must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.) The output record is filled from fields of the JSON object, in the same way as described above for &lt;code&gt;json[b]_populate_record&lt;/code&gt;. Since there is no input record value, unmatched columns are always filled with nulls.</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 절에 의해 정의 된 복합 유형이있는 행으로 최상위 JSON 개체를 확장합니다 . ( &lt;code&gt;record&lt;/code&gt; 를 반환하는 모든 함수와 마찬가지로 호출 쿼리는 &lt;code&gt;AS&lt;/code&gt; 절 을 사용하여 레코드의 구조를 명시 적으로 정의해야합니다 .) 출력 레코드는 &lt;code&gt;json[b]_populate_record&lt;/code&gt; 대해 위에서 설명한 것과 동일한 방식으로 JSON 객체의 필드에서 채워 집니다. . 입력 레코드 값이 없기 때문에 일치하지 않는 열은 항상 null로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="4055cfc6d6987fedf6579551536d9339faf07719" translate="yes" xml:space="preserve">
          <source>Expands the top-level JSON object to a row having the composite type of the &lt;em&gt;&lt;code&gt;base&lt;/code&gt;&lt;/em&gt; argument. The JSON object is scanned for fields whose names match column names of the output row type, and their values are inserted into those columns of the output. (Fields that do not correspond to any output column name are ignored.) In typical use, the value of &lt;em&gt;&lt;code&gt;base&lt;/code&gt;&lt;/em&gt; is just &lt;code&gt;NULL&lt;/code&gt;, which means that any output columns that do not match any object field will be filled with nulls. However, if &lt;em&gt;&lt;code&gt;base&lt;/code&gt;&lt;/em&gt; isn't &lt;code&gt;NULL&lt;/code&gt; then the values it contains will be used for unmatched columns.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;base&lt;/code&gt; &lt;/em&gt; 인수 의 복합 유형이있는 행으로 최상위 JSON 오브젝트를 확장합니다 . JSON 개체는 이름이 출력 행 유형의 열 이름과 일치하는 필드를 검색하고 해당 값이 출력의 해당 열에 삽입됩니다. (모든 출력 열 이름에 해당하지 않는 필드는 무시된다.) 일반적인 사용에서의 값 &lt;em&gt; &lt;code&gt;base&lt;/code&gt; &lt;/em&gt; 그냥 &lt;code&gt;NULL&lt;/code&gt; 물체 필드와 일치하지 않는 출력 컬럼 널 충전 될 것을 의미한다. 그러나 &lt;em&gt; &lt;code&gt;base&lt;/code&gt; &lt;/em&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아니면 포함 된 값 이 일치하지 않는 열에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d3b4356c136073d19e986dde8e382aa16bfea32" translate="yes" xml:space="preserve">
          <source>Experienced users should note that both row version cleanup and row version freezing will potentially conflict with standby queries. Running a manual &lt;code&gt;VACUUM FREEZE&lt;/code&gt; is likely to cause conflicts even on tables with no updated or deleted rows.</source>
          <target state="translated">숙련 된 사용자는 행 버전 정리 및 행 버전 동결이 모두 대기 쿼리와 충돌 할 수 있습니다. 수동 &lt;code&gt;VACUUM FREEZE&lt;/code&gt; 를 실행하면 업데이트되거나 삭제 된 행이없는 테이블에서도 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df0a1a0293d8d5772b31ea82ca7e2d1df56d915" translate="yes" xml:space="preserve">
          <source>Experiment with the parallel dump and restore modes of both pg_dump and pg_restore and find the optimal number of concurrent jobs to use. Dumping and restoring in parallel by means of the &lt;code&gt;-j&lt;/code&gt; option should give you a significantly higher performance over the serial mode.</source>
          <target state="translated">pg_dump 및 pg_restore의 병렬 덤프 및 복원 모드를 실험하고 사용할 최적의 동시 작업 수를 찾으십시오. &lt;code&gt;-j&lt;/code&gt; 옵션 을 사용하여 병렬로 덤프 및 복원 하면 직렬 모드보다 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="10f4c78e2d54e6fc16c1649b65551ffb5394a047" translate="yes" xml:space="preserve">
          <source>Explanation of the default value:</source>
          <target state="translated">기본값에 대한 설명 :</target>
        </trans-unit>
        <trans-unit id="bd377ba1030565fb2d84b794128302f008afe983" translate="yes" xml:space="preserve">
          <source>Explicit Locking</source>
          <target state="translated">명시 적 잠금</target>
        </trans-unit>
        <trans-unit id="07389d02cbf0907278f5b5c21ac954bccbd86d65" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Advisory Locks</source>
          <target state="translated">명시 적 잠금 : 권고 잠금</target>
        </trans-unit>
        <trans-unit id="715daa93ec48db20fc1b4a09d1802add0d50f89b" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Deadlocks</source>
          <target state="translated">명시 적 잠금 : 교착 상태</target>
        </trans-unit>
        <trans-unit id="ed518bfe5cc7ec8d2baadfa5f341c6a5faaafab9" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Page-Level Locks</source>
          <target state="translated">명시 적 잠금 : 페이지 수준 잠금</target>
        </trans-unit>
        <trans-unit id="bf8e4170549e2eb66334d6e43c2f17d676270190" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Row-Level Locks</source>
          <target state="translated">명시 적 잠금 : 행 수준 잠금</target>
        </trans-unit>
        <trans-unit id="69bc449531e08c8db82219a45329b4077d173450" translate="yes" xml:space="preserve">
          <source>Explicit Locking: Table-Level Locks</source>
          <target state="translated">명시 적 잠금 : 테이블 수준 잠금</target>
        </trans-unit>
        <trans-unit id="8a4798d12c7f788cdaf284307c4d2130df861d48" translate="yes" xml:space="preserve">
          <source>Explicit inner join syntax (&lt;code&gt;INNER JOIN&lt;/code&gt;, &lt;code&gt;CROSS JOIN&lt;/code&gt;, or unadorned &lt;code&gt;JOIN&lt;/code&gt;) is semantically the same as listing the input relations in &lt;code&gt;FROM&lt;/code&gt;, so it does not constrain the join order.</source>
          <target state="translated">명시 적 내부 조인 구문 ( &lt;code&gt;INNER JOIN&lt;/code&gt; , &lt;code&gt;CROSS JOIN&lt;/code&gt; 또는 unadorned &lt;code&gt;JOIN&lt;/code&gt; )은 의미 적으로 &lt;code&gt;FROM&lt;/code&gt; 에 입력 관계를 나열하는 것과 동일 하므로 조인 순서를 제한하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29509d345e82da65e8974d9bce320a4045bf4357" translate="yes" xml:space="preserve">
          <source>Explicitly specifies an arbiter &lt;em&gt;constraint&lt;/em&gt; by name, rather than inferring a constraint or index.</source>
          <target state="translated">제약 조건이나 인덱스를 유추하지 않고 이름으로 중재자 &lt;em&gt;제약 조건&lt;/em&gt; 을 명시 적으로 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="3954f8e64e0f4b9dc77a619692ac06c377b37329" translate="yes" xml:space="preserve">
          <source>Exponential (&lt;code id=&quot;e&quot;&gt;e&lt;/code&gt; raised to the given power)</source>
          <target state="translated">지수 ( &lt;code id=&quot;e&quot;&gt;e&lt;/code&gt; 가 주어진 거듭 제곱으로 올림)</target>
        </trans-unit>
        <trans-unit id="695fbbc802f9975f9a5649fcbddb5e7169f798c1" translate="yes" xml:space="preserve">
          <source>Exponential (&lt;code&gt;e&lt;/code&gt; raised to the given power)</source>
          <target state="translated">지수 ( &lt;code&gt;e&lt;/code&gt; 가 주어진 거듭 제곱으로 올림)</target>
        </trans-unit>
        <trans-unit id="45b409c1a241089b894c113d436f688182bc3059" translate="yes" xml:space="preserve">
          <source>Exponentiation (unlike typical mathematical practice, multiple uses of &lt;code id=&quot;94&quot;&gt;^&lt;/code&gt; will associate left to right)</source>
          <target state="translated">지수화 (일반적인 수학적 실습과 달리 &lt;code id=&quot;94&quot;&gt;^&lt;/code&gt; 을 여러 번 사용 하면 왼쪽에서 오른쪽으로 연결됨)</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="365e3a9a34943313be4ba1dc166152310bb9ff19" translate="yes" xml:space="preserve">
          <source>Expression evaluation is used to evaluate &lt;code&gt;WHERE&lt;/code&gt; clauses, target lists, aggregates and projections. It can be accelerated by generating code specific to each case.</source>
          <target state="translated">식 평가는 &lt;code&gt;WHERE&lt;/code&gt; 절, 대상 목록, 집계 및 예측 을 평가하는 데 사용됩니다 . 각 경우에 맞는 코드를 생성하여 가속화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ba4e5b8b6216e5d70e5f6f22f4545d9b2ac1883" translate="yes" xml:space="preserve">
          <source>Expression tree (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for partial index predicate. Null if not a partial index.</source>
          <target state="translated">부분 인덱스 술어에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현). 부분 인덱스가 아닌 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="ed5fd30c0216e18f0c9c36db6432c2bb2eccc517" translate="yes" xml:space="preserve">
          <source>Expression tree (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the trigger's &lt;code&gt;WHEN&lt;/code&gt; condition, or null if none</source>
          <target state="translated">트리거의 &lt;code&gt;WHEN&lt;/code&gt; 조건에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현) 또는없는 경우 널</target>
        </trans-unit>
        <trans-unit id="016286ae409d7c91d1a1498bfae9a81ea0711739" translate="yes" xml:space="preserve">
          <source>Expression tree (in the form of a &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the rule's qualifying condition</source>
          <target state="translated">규칙의 한정 조건에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현 형식)</target>
        </trans-unit>
        <trans-unit id="469a93adf4f3e0c5965c1ffbcb51388c4d1f61c4" translate="yes" xml:space="preserve">
          <source>Expression trees (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for default values. This is a list with &lt;code&gt;pronargdefaults&lt;/code&gt; elements, corresponding to the last &lt;code&gt;N&lt;/code&gt;&lt;em&gt;input&lt;/em&gt; arguments (i.e., the last &lt;code&gt;N&lt;/code&gt;&lt;code&gt;proargtypes&lt;/code&gt; positions). If none of the arguments have defaults, this field will be null.</source>
          <target state="translated">기본값의 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현) 마지막 &lt;code&gt;N&lt;/code&gt; 개의&lt;em&gt;입력&lt;/em&gt; 인수 (즉, 마지막 &lt;code&gt;N&lt;/code&gt; 개의 &lt;code&gt;proargtypes&lt;/code&gt; 위치)에 해당하는 &lt;code&gt;pronargdefaults&lt;/code&gt; 요소 가있는 목록입니다 . 기본값이없는 인수가 없으면이 필드는 널입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7938a326f59c4e813d7b7ad39b5fb56dac45fa45" translate="yes" xml:space="preserve">
          <source>Expression trees (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for index attributes that are not simple column references. This is a list with one element for each zero entry in &lt;code&gt;indkey&lt;/code&gt;. Null if all index attributes are simple references.</source>
          <target state="translated">단순한 열 참조가 아닌 인덱스 속성에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현) 이것은 &lt;code&gt;indkey&lt;/code&gt; 의 각 0 항목에 대해 하나의 요소가있는 목록입니다 . 모든 인덱스 속성이 간단한 참조이면 null입니다.</target>
        </trans-unit>
        <trans-unit id="534241592d7ae67f9f1ae679891827b2ed8498d6" translate="yes" xml:space="preserve">
          <source>Expression trees (in &lt;code&gt;nodeToString()&lt;/code&gt; representation) for partition key columns that are not simple column references. This is a list with one element for each zero entry in &lt;code&gt;partattrs&lt;/code&gt;. Null if all partition key columns are simple references.</source>
          <target state="translated">단순 열 참조가 아닌 파티션 키 열에 대한 표현식 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현). 이 목록은 &lt;code&gt;partattrs&lt;/code&gt; 의 각 0 항목에 대해 하나의 요소가있는 목록입니다 . 모든 파티션 키 열이 간단한 참조 인 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="f6adaa99da80e4400f1f7a90282b9da5f047824b" translate="yes" xml:space="preserve">
          <source>Expressions are not supported as included columns since they cannot be used in index-only scans.</source>
          <target state="translated">인덱스 전용 스캔에서는 사용할 수 없으므로 표현식은 포함 된 열로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c772de246f3ef8977c4194f44909593460fd72c" translate="yes" xml:space="preserve">
          <source>Expressions in the &lt;code&gt;HAVING&lt;/code&gt; clause can refer both to grouped expressions and to ungrouped expressions (which necessarily involve an aggregate function).</source>
          <target state="translated">&lt;code&gt;HAVING&lt;/code&gt; 절의 표현식은 그룹화 된 표현식과 그룹화되지 않은 표현식 (필수적으로 집계 함수를 포함 함)을 모두 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcee9a80b5efecec53c25e1a9558b021c463d7ea" translate="yes" xml:space="preserve">
          <source>Expressions that do not properly evaluate to true or false will generate a warning and be treated as false.</source>
          <target state="translated">true 또는 false로 올바르게 평가되지 않은 표현식은 경고를 생성하고 false로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3df35db9e658f59390afaab4ee6ca6a77c762e48" translate="yes" xml:space="preserve">
          <source>Extended DES</source>
          <target state="translated">확장 된 DES</target>
        </trans-unit>
        <trans-unit id="610ac3f96dd2b6898def2f89d8c23932807ddd84" translate="yes" xml:space="preserve">
          <source>Extended National Standard</source>
          <target state="translated">확장 된 국가 표준</target>
        </trans-unit>
        <trans-unit id="f9502e7d5dd333ff5052f41e8c24f18e62ed6956" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-CN</source>
          <target state="translated">확장 UNIX 코드 CN</target>
        </trans-unit>
        <trans-unit id="76f1a6ce7cdd954c81e01d8064d59c892a6935e9" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-JP</source>
          <target state="translated">확장 UNIX 코드 -JP</target>
        </trans-unit>
        <trans-unit id="e0d26490286dcf8cc651f76d5d159e52f88230ef" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-JP, JIS X 0213</source>
          <target state="translated">확장 UNIX 코드 -JP, JIS X 0213</target>
        </trans-unit>
        <trans-unit id="71c48b0679f5fd722af2729d8d29a635127b32bb" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-KR</source>
          <target state="translated">확장 UNIX 코드 KR</target>
        </trans-unit>
        <trans-unit id="6f052b7ecf6ec012c2c3fcbee8854db7f563b07f" translate="yes" xml:space="preserve">
          <source>Extended UNIX Code-TW</source>
          <target state="translated">확장 UNIX 코드 -TW</target>
        </trans-unit>
        <trans-unit id="ffc0097bfdee7b41005e9ec7165c9b9a978c0d17" translate="yes" xml:space="preserve">
          <source>Extended statistic object containing the definition for this data</source>
          <target state="translated">이 데이터에 대한 정의를 포함하는 확장 된 통계 개체</target>
        </trans-unit>
        <trans-unit id="23e4ded7109281c27fc76881f77dd71ff7811e57" translate="yes" xml:space="preserve">
          <source>Extended statistics are copied to the new table.</source>
          <target state="translated">확장 된 통계는 새 테이블로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="407c62f3cdf9938b804b40798d4c850e36174c55" translate="yes" xml:space="preserve">
          <source>Extends the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; to length &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; by appending the characters &lt;em&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/em&gt; (a space by default). If the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; is already longer than &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; then it is truncated.</source>
          <target state="translated">문자 &lt;em&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/em&gt; (기본적으로 공백)를 추가 하여 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 을 길이 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 로 확장합니다 . 는 IF &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 이상 이미 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 후 잘립니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12369cbf01bada10db47edf75f22cfc102ce1e6d" translate="yes" xml:space="preserve">
          <source>Extends the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; to length &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; by prepending the characters &lt;em&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/em&gt; (a space by default). If the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; is already longer than &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; then it is truncated (on the right).</source>
          <target state="translated">문자 &lt;em&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/em&gt; (기본적으로 공백)를 앞에 추가 하여 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 을 길이 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 로 확장합니다 . 는 IF &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 보다 이미 더 이상 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 다음은 (오른쪽) 잘립니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="02c94538d1874480a4371b6ab14ef1e2eea48fb4" translate="yes" xml:space="preserve">
          <source>Extensibility</source>
          <target state="translated">Extensibility</target>
        </trans-unit>
        <trans-unit id="04c63ad73302c8ab810c48f3053854e7cbfe493c" translate="yes" xml:space="preserve">
          <source>Extensibility: Inlining Support for Extensions</source>
          <target state="translated">확장 성 : 확장 지원 지원</target>
        </trans-unit>
        <trans-unit id="5c32910fca448eba323615ca2bb16526e8cfcae9" translate="yes" xml:space="preserve">
          <source>Extensibility: Pluggable JIT Providers</source>
          <target state="translated">확장 성 : 플러그 가능 JIT 제공자</target>
        </trans-unit>
        <trans-unit id="d8379449b77cd40626b7ba635ee49b685b2d0526" translate="yes" xml:space="preserve">
          <source>Extensible Markup Language</source>
          <target state="translated">확장 가능한 마크 업 언어</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="b209f03aa540026e6f57dfc538bb2aed73ef4f66" translate="yes" xml:space="preserve">
          <source>Extension name</source>
          <target state="translated">확장명</target>
        </trans-unit>
        <trans-unit id="309f90cc01c6f9da1171d1991a8a0a9788d84a58" translate="yes" xml:space="preserve">
          <source>Extensions can add &lt;code&gt;LWLock&lt;/code&gt; types to the list shown in &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LWLOCK-TABLE&quot;&gt;Table 27.12&lt;/a&gt;. In some cases, the name assigned by an extension will not be available in all server processes; so an &lt;code&gt;LWLock&lt;/code&gt; wait event might be reported as just &amp;ldquo;&lt;code&gt;extension&lt;/code&gt;&amp;rdquo; rather than the extension-assigned name.</source>
          <target state="translated">확장은 &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LWLOCK-TABLE&quot;&gt;표 27.12에&lt;/a&gt; 표시된 목록 에 &lt;code&gt;LWLock&lt;/code&gt; 유형을 추가 할 수 있습니다 . 경우에 따라 확장에 의해 할당 된 이름은 모든 서버 프로세스에서 사용할 수 없습니다. 따라서 &lt;code&gt;LWLock&lt;/code&gt; 대기 이벤트 는 확장이 할당 된 이름이 아닌 &quot; &lt;code&gt;extension&lt;/code&gt; &quot; 로보고 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13c07b09fd86c98bcc81518e9db1451bc5c4b54f" translate="yes" xml:space="preserve">
          <source>External Syntax</source>
          <target state="translated">외부 구문</target>
        </trans-unit>
        <trans-unit id="1dd06b9587505cd303a5381507906388efe27f22" translate="yes" xml:space="preserve">
          <source>External tools may also modify &lt;code&gt;postgresql.auto.conf&lt;/code&gt;. It is not recommended to do this while the server is running, since a concurrent &lt;code&gt;ALTER SYSTEM&lt;/code&gt; command could overwrite such changes. Such tools might simply append new settings to the end, or they might choose to remove duplicate settings and/or comments (as &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will).</source>
          <target state="translated">외부 도구도 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 를 수정할 수 있습니다 . 동시 &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 명령이 이러한 변경 사항을 겹쳐 쓸 수 있으므로 서버가 실행 중일 때는이 작업을 수행하지 않는 것이 좋습니다 . 이러한 도구는 단순히 새로운 설정을 끝에 추가하거나 중복 설정 및 / 또는 주석을 제거하도록 선택할 수 있습니다 ( &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="b8ec878cfa9ef45438a6cae306a1abbb10bc541e" translate="yes" xml:space="preserve">
          <source>Extract bit from string</source>
          <target state="translated">문자열에서 비트 추출</target>
        </trans-unit>
        <trans-unit id="efbac2c77c617feef5ed32054f6ec6f4dc45fc3c" translate="yes" xml:space="preserve">
          <source>Extract byte from string</source>
          <target state="translated">문자열에서 바이트 추출</target>
        </trans-unit>
        <trans-unit id="2f797a8b6f50a18e5a2075a9206a7b17e7ba785a" translate="yes" xml:space="preserve">
          <source>Extract substring</source>
          <target state="translated">부분 문자열 추출</target>
        </trans-unit>
        <trans-unit id="42e4ecc9582b48bbbe7ec04769377c6b3c2d2f45" translate="yes" xml:space="preserve">
          <source>Extract substring (same as &lt;code&gt;substring(&lt;em&gt;string&lt;/em&gt; from &lt;em&gt;from&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt;)&lt;/code&gt;)</source>
          <target state="translated">추출 문자열 (동일 &lt;code&gt;substring(&lt;em&gt;string&lt;/em&gt; from &lt;em&gt;from&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt;)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="74120afc87666fe0a0017da57004971b56a6d2b1" translate="yes" xml:space="preserve">
          <source>Extract substring matching POSIX regular expression. See &lt;a href=&quot;functions-matching&quot;&gt;Section 9.7&lt;/a&gt; for more information on pattern matching.</source>
          <target state="translated">POSIX 정규식과 일치하는 부분 문자열을 추출하십시오. 패턴 일치에 대한 자세한 내용 &lt;a href=&quot;functions-matching&quot;&gt;은 9.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6201f97ec818d2ec790c00a0a34c900f98d2aaaa" translate="yes" xml:space="preserve">
          <source>Extract substring matching SQL regular expression. See &lt;a href=&quot;functions-matching&quot;&gt;Section 9.7&lt;/a&gt; for more information on pattern matching.</source>
          <target state="translated">SQL 정규식과 일치하는 부분 문자열을 추출하십시오. 패턴 일치에 대한 자세한 내용 &lt;a href=&quot;functions-matching&quot;&gt;은 9.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a8adcf101bb565b6a7046ac7fa0b47e46728d03" translate="yes" xml:space="preserve">
          <source>Extracts &lt;a href=&quot;functions-binarystring#FUNCTIONS-ZEROBASED-NOTE&quot;&gt;n'th&lt;/a&gt; bit from binary string.</source>
          <target state="translated">이진 문자열에서 &lt;a href=&quot;functions-binarystring#FUNCTIONS-ZEROBASED-NOTE&quot;&gt;n 번째&lt;/a&gt; 비트를 추출 합니다.</target>
        </trans-unit>
        <trans-unit id="d13de3cc918aefb5a2fcfaab8d3ef5d5cf50bc45" translate="yes" xml:space="preserve">
          <source>Extracts &lt;a href=&quot;functions-binarystring#FUNCTIONS-ZEROBASED-NOTE&quot;&gt;n'th&lt;/a&gt; byte from binary string.</source>
          <target state="translated">바이너리 문자열에서 &lt;a href=&quot;functions-binarystring#FUNCTIONS-ZEROBASED-NOTE&quot;&gt;n 번째&lt;/a&gt; 바이트를 추출 합니다.</target>
        </trans-unit>
        <trans-unit id="f3fcee6dc22eaa801c8cc2d60b72e0033f6ed7be" translate="yes" xml:space="preserve">
          <source>Extracts &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;'th bit from bit string; the first (leftmost) bit is bit 0.</source>
          <target state="translated">비트 문자열에서 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 번째 비트를 추출 합니다. 첫 번째 (가장 왼쪽) 비트는 비트 0입니다.</target>
        </trans-unit>
        <trans-unit id="84e47e31b5e545dfc93ba8c5eab1fe85c9dd6f35" translate="yes" xml:space="preserve">
          <source>Extracts &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;'th element of JSON array (array elements are indexed from zero, but negative integers count from the end).</source>
          <target state="translated">JSON 배열의 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 번째 요소를 추출합니다 (배열 요소는 0부터 인덱싱되지만 음의 정수는 끝부터 계산됩니다).</target>
        </trans-unit>
        <trans-unit id="4eeb8d19a13a68c3d5054da80210317e05d41c4a" translate="yes" xml:space="preserve">
          <source>Extracts &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;'th element of JSON array, as &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">JSON 배열의 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 번째 요소를 &lt;code&gt;text&lt;/code&gt; 로 추출 합니다 .</target>
        </trans-unit>
        <trans-unit id="b2167786ff3804569f1a3e1528b5e8f151d57bb6" translate="yes" xml:space="preserve">
          <source>Extracts JSON object field with the given key, as &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">지정된 키를 사용하여 JSON 개체 필드를 &lt;code&gt;text&lt;/code&gt; 로 추출 합니다 .</target>
        </trans-unit>
        <trans-unit id="7593660705779622c5ef13d80c641afba395e7f4" translate="yes" xml:space="preserve">
          <source>Extracts JSON object field with the given key.</source>
          <target state="translated">지정된 키로 JSON 개체 필드를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="134b9c1cbb50a07d0e7e390014cab4689fa9afa9" translate="yes" xml:space="preserve">
          <source>Extracts JSON sub-object at the specified path as &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">지정된 경로에서 JSON 하위 개체를 &lt;code&gt;text&lt;/code&gt; 로 추출 합니다 .</target>
        </trans-unit>
        <trans-unit id="faf152d102d0284411d9683e81caa591ea424557" translate="yes" xml:space="preserve">
          <source>Extracts JSON sub-object at the specified path as &lt;code&gt;text&lt;/code&gt;. (This is functionally equivalent to the &lt;code&gt;#&amp;gt;&amp;gt;&lt;/code&gt; operator.)</source>
          <target state="translated">지정된 경로에서 JSON 하위 개체를 &lt;code&gt;text&lt;/code&gt; 로 추출 합니다 . (이것은 &lt;code&gt;#&amp;gt;&amp;gt;&lt;/code&gt; 연산자 와 기능적으로 동일합니다 .)</target>
        </trans-unit>
        <trans-unit id="b5303a84dc6d847753d8e9cc14186c7a4ae72630" translate="yes" xml:space="preserve">
          <source>Extracts JSON sub-object at the specified path, where path elements can be either field keys or array indexes.</source>
          <target state="translated">지정된 경로에서 JSON 하위 개체를 추출합니다. 여기서 경로 요소는 필드 키 또는 배열 인덱스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9446dc079d4167a257cefccea154091f3500632" translate="yes" xml:space="preserve">
          <source>Extracts JSON sub-object at the specified path. (This is functionally equivalent to the &lt;code&gt;#&amp;gt;&lt;/code&gt; operator, but writing the path out as a variadic list can be more convenient in some cases.)</source>
          <target state="translated">지정된 경로에서 JSON 하위 개체를 추출합니다. (이것은 기능적으로 &lt;code&gt;#&amp;gt;&lt;/code&gt; 연산자와 동일하지만 경우에 따라 가변 목록으로 경로를 작성하는 것이 더 편리 할 수 ​​있습니다.)</target>
        </trans-unit>
        <trans-unit id="8e2f91aab7a702599e12fe3a57a5b7e9a524212d" translate="yes" xml:space="preserve">
          <source>Extracts a subset of an &lt;code&gt;hstore&lt;/code&gt; containing only the specified keys.</source>
          <target state="translated">지정된 키만 포함 하는 &lt;code&gt;hstore&lt;/code&gt; 의 하위 집합을 추출 합니다.</target>
        </trans-unit>
        <trans-unit id="b72b1a0f9484fe8cbf856d84e5504f9c618b983a" translate="yes" xml:space="preserve">
          <source>Extracts an &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a set of records.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 키와 값을 레코드 세트로 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="5abc0e83c100148a747c33aba3066ce3dcbbf1cb" translate="yes" xml:space="preserve">
          <source>Extracts an &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a two-dimensional array.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 키와 값을 2 차원 배열로 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="eba7918c513c3a0ba47fa75ae2afd57ea70d8785" translate="yes" xml:space="preserve">
          <source>Extracts an &lt;code&gt;hstore&lt;/code&gt;'s keys and values as an array of alternating keys and values.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 키와 값을 대체 키와 값의 배열로 추출 합니다.</target>
        </trans-unit>
        <trans-unit id="430ab8a9ad1ace316470a4790a4cfd3de6142930" translate="yes" xml:space="preserve">
          <source>Extracts an &lt;code&gt;hstore&lt;/code&gt;'s keys as a set.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 키를 세트로 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="85c8506a5c2f06847e0126e7a82b29c886f42372" translate="yes" xml:space="preserve">
          <source>Extracts an &lt;code&gt;hstore&lt;/code&gt;'s keys as an array.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 키를 배열로 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="d59ebe61e8fdcb17089e768a5138c8b1f2544970" translate="yes" xml:space="preserve">
          <source>Extracts an &lt;code&gt;hstore&lt;/code&gt;'s values as a set.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 값을 집합으로 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="22096f93ed75f028ecf5927c0c544a0e4edeb56f" translate="yes" xml:space="preserve">
          <source>Extracts an &lt;code&gt;hstore&lt;/code&gt;'s values as an array.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 값을 배열로 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="8b197507f5ea034eac02509be42869989fcb5ea4" translate="yes" xml:space="preserve">
          <source>Extracts and normalizes tokens from the &lt;em&gt;&lt;code&gt;document&lt;/code&gt;&lt;/em&gt; according to the specified or default text search configuration, and returns information about how each token was processed. See &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-CONFIGURATION-TESTING&quot;&gt;Section 12.8.1&lt;/a&gt; for details.</source>
          <target state="translated">지정된 또는 기본 텍스트 검색 구성에 따라 &lt;em&gt; &lt;code&gt;document&lt;/code&gt; &lt;/em&gt; 에서 토큰을 추출 및 정규화 하고 각 토큰이 처리 된 방법에 대한 정보를 반환합니다. 자세한 내용은 &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-CONFIGURATION-TESTING&quot;&gt;섹션 12.8.1&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="244a534345ee455bdd7d2010f1fc9ec53e734286" translate="yes" xml:space="preserve">
          <source>Extracts box's diagonal as a line segment (same as &lt;code id=&quot;lseg&quot;&gt;lseg(box)&lt;/code&gt;).</source>
          <target state="translated">상자의 대각선을 선분으로 추출합니다 ( &lt;code id=&quot;lseg&quot;&gt;lseg(box)&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="941ca3a7d724df3e2981637403f9147ccca48c88" translate="yes" xml:space="preserve">
          <source>Extracts box's diagonal as a line segment.</source>
          <target state="translated">상자의 대각선을 선분으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="67286711c704916b7150f8d87def792759711fa6" translate="yes" xml:space="preserve">
          <source>Extracts substring matching POSIX regular expression; see &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;.</source>
          <target state="translated">POSIX 정규식과 일치하는 하위 문자열을 추출합니다. &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0657b59efa8fea91ca0990aab3327163e3a89015" translate="yes" xml:space="preserve">
          <source>Extracts substring matching SQL regular expression; see &lt;a href=&quot;functions-matching#FUNCTIONS-SIMILARTO-REGEXP&quot;&gt;Section 9.7.2&lt;/a&gt;.</source>
          <target state="translated">SQL 정규식과 일치하는 하위 문자열을 추출합니다. &lt;a href=&quot;functions-matching#FUNCTIONS-SIMILARTO-REGEXP&quot;&gt;9.7.2 항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb0f762719fdf7c752b464ba23c1d8298a5a40b2" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;-th coordinate of the cube (counting from 1).</source>
          <target state="translated">큐브 의 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 번째 좌표를 추출합니다 (1부터 계산).</target>
        </trans-unit>
        <trans-unit id="c9870bc4c92c76aeeec58d6f4b3e3a755df5d165" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;-th coordinate of the cube, counting in the following way: &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; = 2 * &lt;em&gt;&lt;code&gt;k&lt;/code&gt;&lt;/em&gt; - 1 means lower bound of &lt;em&gt;&lt;code&gt;k&lt;/code&gt;&lt;/em&gt;-th dimension, &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; = 2 * &lt;em&gt;&lt;code&gt;k&lt;/code&gt;&lt;/em&gt; means upper bound of &lt;em&gt;&lt;code&gt;k&lt;/code&gt;&lt;/em&gt;-th dimension. Negative &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; denotes the inverse value of the corresponding positive coordinate. This operator is designed for KNN-GiST support.</source>
          <target state="translated">다음과 같은 방식으로 계산하여 큐브 의 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 번째 좌표를 추출합니다 . &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; = 2 * &lt;em&gt; &lt;code&gt;k&lt;/code&gt; &lt;/em&gt; -1은 &lt;em&gt; &lt;code&gt;k&lt;/code&gt; &lt;/em&gt; 번째 차원의 하한을 의미하고 , &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; = 2 * &lt;em&gt; &lt;code&gt;k&lt;/code&gt; &lt;/em&gt; 는 &lt;em&gt; &lt;code&gt;k&lt;/code&gt; &lt;/em&gt; 번째 차원 의 상한을 의미 합니다. 음수 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 은 해당 양수 좌표의 역값을 나타냅니다. 이 연산자는 KNN-GiST 지원을 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="a6e7cd5feb9ef183e87a52601c5acf9d7ecbcafc" translate="yes" xml:space="preserve">
          <source>Extracts the lower bound of the range (&lt;code id=&quot;null&quot;&gt;NULL&lt;/code&gt; if the range is empty or the lower bound is infinite).</source>
          <target state="translated">범위의 하한을 추출합니다 ( 범위가 비어 있거나 하한이 무한이면 &lt;code id=&quot;null&quot;&gt;NULL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4f70014f747d654230c56d30656ebc316cac776a" translate="yes" xml:space="preserve">
          <source>Extracts the portion of the array starting at position &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;, with &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt; elements.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 요소를 사용 하여 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 위치에서 &lt;em&gt;시작&lt;/em&gt; 하는 배열 부분을 추출합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a7d44a47f9d69b1195f7053cc44c397dc3d73cc" translate="yes" xml:space="preserve">
          <source>Extracts the portion of the array starting at position &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 위치에서 &lt;em&gt;시작&lt;/em&gt; 하는 배열 부분을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="5ad6eba62548e7d8c46b6fc6ace6ff405f69603f" translate="yes" xml:space="preserve">
          <source>Extracts the substring of &lt;em&gt;&lt;code&gt;bits&lt;/code&gt;&lt;/em&gt; starting at the &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;'th bit if that is specified, and stopping after &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; bits if that is specified. Provide at least one of &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">지정된 경우 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; '번째 비트 에서 &lt;em&gt;시작&lt;/em&gt; 하고 지정된 경우 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 비트 후에 중지 되는 &lt;em&gt; &lt;code&gt;bits&lt;/code&gt; &lt;/em&gt; 의 하위 문자열을 추출 합니다. &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 중 하나 이상을 제공하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c5cf6a254adb00b8e5311136b3995918d773f9b0" translate="yes" xml:space="preserve">
          <source>Extracts the substring of &lt;em&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/em&gt; starting at the &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;'th byte if that is specified, and stopping after &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; bytes if that is specified. Provide at least one of &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">지정된 경우 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; '번째 바이트 에서 &lt;em&gt;시작&lt;/em&gt; 하고 지정된 경우 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 바이트 후에 중지 되는 &lt;em&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/em&gt; 의 하위 문자열을 추출 합니다. &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 중 하나 이상을 제공하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49112fc9b02be32a748d94058e0be573c4c5e9fe" translate="yes" xml:space="preserve">
          <source>Extracts the substring of &lt;em&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/em&gt; starting at the &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;'th byte, and extending for &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; bytes if that is specified. (Same as &lt;code&gt;substring(&lt;em&gt;bytes&lt;/em&gt; from &lt;em&gt;start&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt;)&lt;/code&gt;.)</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; '번째 바이트 에서 시작하여 지정된 경우 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 바이트 까지 확장되는 &lt;em&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/em&gt; 의 하위 문자열을 추출 합니다. ( &lt;code&gt;substring(&lt;em&gt;bytes&lt;/em&gt; from &lt;em&gt;start&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt;)&lt;/code&gt; &lt;em&gt;bytes&lt;/em&gt; from &lt;em&gt;start&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt; ) 와 동일합니다 .)&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f5b90d919f1a1012c727567442b250301da127a2" translate="yes" xml:space="preserve">
          <source>Extracts the substring of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; starting at the &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;'th character if that is specified, and stopping after &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; characters if that is specified. Provide at least one of &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">추출물의 하위 문자열 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 상기 시작 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; '즉 지정된 경우 일 문자, 이후 중지 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 가 지정된 경우 문자. &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 중 하나 이상을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c48a5d0926c6ec8872f6852e064053e4bf27619" translate="yes" xml:space="preserve">
          <source>Extracts the substring of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; starting at the &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;'th character, and extending for &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; characters if that is specified. (Same as &lt;code&gt;substring(&lt;em&gt;string&lt;/em&gt; from &lt;em&gt;start&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt;)&lt;/code&gt;.)</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; '번째 문자 에서 시작하여 지정된 경우 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 문자 까지 확장되는 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 하위 문자열을 추출 합니다. ( &lt;code&gt;substring(&lt;em&gt;string&lt;/em&gt; from &lt;em&gt;start&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt;)&lt;/code&gt; &lt;em&gt;string&lt;/em&gt; from &lt;em&gt;start&lt;/em&gt; for &lt;em&gt;count&lt;/em&gt; ) 와 동일합니다 .)&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d9d71a2540185d9890d6309ba1f2c30ab54b741" translate="yes" xml:space="preserve">
          <source>Extracts the upper bound of the range (&lt;code&gt;NULL&lt;/code&gt; if the range is empty or the upper bound is infinite).</source>
          <target state="translated">범위의 상한을 추출합니다 ( 범위가 비어 있거나 상한이 무한한 경우 &lt;code&gt;NULL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd069d4fb2ae5c4158603428006686981f7531d4" translate="yes" xml:space="preserve">
          <source>Extracts tokens from the &lt;em&gt;&lt;code&gt;document&lt;/code&gt;&lt;/em&gt; using a parser specified by OID. See &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-PARSER-TESTING&quot;&gt;Section 12.8.2&lt;/a&gt; for details.</source>
          <target state="translated">OID로 지정된 구문 분석기를 사용 하여 &lt;em&gt; &lt;code&gt;document&lt;/code&gt; &lt;/em&gt; 에서 토큰을 추출 합니다. 자세한 내용은 &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-PARSER-TESTING&quot;&gt;섹션 12.8.2&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df156eb2ea4fa3ae772e036af2b41542967f420c" translate="yes" xml:space="preserve">
          <source>Extracts tokens from the &lt;em&gt;&lt;code&gt;document&lt;/code&gt;&lt;/em&gt; using the named parser. See &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-PARSER-TESTING&quot;&gt;Section 12.8.2&lt;/a&gt; for details.</source>
          <target state="translated">명명 된 파서를 사용 하여 &lt;em&gt; &lt;code&gt;document&lt;/code&gt; &lt;/em&gt; 에서 토큰을 추출합니다 . 자세한 내용은 &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-PARSER-TESTING&quot;&gt;섹션 12.8.2&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7a71a465de60f23a58aaea7cebfe239e39640f3" translate="yes" xml:space="preserve">
          <source>F.1. adminpack</source>
          <target state="translated">F.1. adminpack</target>
        </trans-unit>
        <trans-unit id="25e26bea23097f562c5939c8d8c67e04ba7a8b4f" translate="yes" xml:space="preserve">
          <source>F.10. dblink</source>
          <target state="translated">F.10. dblink</target>
        </trans-unit>
        <trans-unit id="2ea823f8fd9afb139b70cf67092903d0e6c25b37" translate="yes" xml:space="preserve">
          <source>F.11. dict_int</source>
          <target state="translated">F.11. dict_int</target>
        </trans-unit>
        <trans-unit id="dd955bfaab7ef81b6056677b03d388fab6e57725" translate="yes" xml:space="preserve">
          <source>F.11.1. Configuration</source>
          <target state="translated">F.11.1. 구성</target>
        </trans-unit>
        <trans-unit id="90cd34db8f683504ca7feb85f746bcccec795423" translate="yes" xml:space="preserve">
          <source>F.11.2. Usage</source>
          <target state="translated">F.11.2. 용법</target>
        </trans-unit>
        <trans-unit id="e4eb1c3b3665242eea5c8771c3e66c28d9b95d26" translate="yes" xml:space="preserve">
          <source>F.12. dict_xsyn</source>
          <target state="translated">F.12. dict_xsyn</target>
        </trans-unit>
        <trans-unit id="559d903e93034a8bc26cce649452b3d7c4e09db2" translate="yes" xml:space="preserve">
          <source>F.12.1. Configuration</source>
          <target state="translated">F.12.1. 구성</target>
        </trans-unit>
        <trans-unit id="8be278f6fd96a9ff480b8439afb4a5a665d35702" translate="yes" xml:space="preserve">
          <source>F.12.2. Usage</source>
          <target state="translated">F.12.2. 용법</target>
        </trans-unit>
        <trans-unit id="ac893b7a0dcfacce489e0073e329ea96e63c563b" translate="yes" xml:space="preserve">
          <source>F.13. earthdistance</source>
          <target state="translated">F.13. 지구 거리</target>
        </trans-unit>
        <trans-unit id="ff97f4fa26386c910402ae19f89b6487e0920ace" translate="yes" xml:space="preserve">
          <source>F.13.1. Cube-Based Earth Distances</source>
          <target state="translated">F.13.1. 큐브 기반 지구 거리</target>
        </trans-unit>
        <trans-unit id="4fd65f14ed4c44985b32a94078e996104aba2da6" translate="yes" xml:space="preserve">
          <source>F.13.2. Point-Based Earth Distances</source>
          <target state="translated">F.13.2. 점 기반 지구 거리</target>
        </trans-unit>
        <trans-unit id="0dc089c0dd2cd42162c54a744ba53c987297088c" translate="yes" xml:space="preserve">
          <source>F.14. file_fdw</source>
          <target state="translated">F.14. file_fdw</target>
        </trans-unit>
        <trans-unit id="cc2bb28833eaac5566f6cf4a700a0c159682a67d" translate="yes" xml:space="preserve">
          <source>F.15. fuzzystrmatch</source>
          <target state="translated">F.15. 퍼지</target>
        </trans-unit>
        <trans-unit id="f3b8cdd7c68dccc31c5a4c3eebfa3b2fd3e60972" translate="yes" xml:space="preserve">
          <source>F.15.1. Soundex</source>
          <target state="translated">F.15.1. Soundex</target>
        </trans-unit>
        <trans-unit id="805bad02d817987c917d35cc2cda97fa20a921ad" translate="yes" xml:space="preserve">
          <source>F.15.2. Levenshtein</source>
          <target state="translated">F.15.2. 레 벤슈 테인</target>
        </trans-unit>
        <trans-unit id="72b84cc4ce4a7652ee1c055849e248af26d7acaf" translate="yes" xml:space="preserve">
          <source>F.15.3. Metaphone</source>
          <target state="translated">F.15.3. 메타 폰</target>
        </trans-unit>
        <trans-unit id="d9dcc939a71a29db0754dbbcb70da7a2cc01dcf5" translate="yes" xml:space="preserve">
          <source>F.15.4. Double Metaphone</source>
          <target state="translated">F.15.4. 이중 메타 폰</target>
        </trans-unit>
        <trans-unit id="bb9c2fb77946283e8033e242669e0f3f42028773" translate="yes" xml:space="preserve">
          <source>F.16. hstore</source>
          <target state="translated">F.16. hstore</target>
        </trans-unit>
        <trans-unit id="8fc2df587935c2448dff4335b06917a6034820c9" translate="yes" xml:space="preserve">
          <source>F.16.1. &lt;code&gt;hstore&lt;/code&gt; External Representation</source>
          <target state="translated">F.16.1. &lt;code&gt;hstore&lt;/code&gt; 외부 표현</target>
        </trans-unit>
        <trans-unit id="f61c1443f146183c037e0b1f2d2228cb582573d5" translate="yes" xml:space="preserve">
          <source>F.16.2. &lt;code&gt;hstore&lt;/code&gt; Operators and Functions</source>
          <target state="translated">F.16.2. &lt;code&gt;hstore&lt;/code&gt; 연산자 및 함수</target>
        </trans-unit>
        <trans-unit id="b7d1274db689ce60845678187d1dc8f42e9ee40e" translate="yes" xml:space="preserve">
          <source>F.16.3. Indexes</source>
          <target state="translated">F.16.3. 인덱스</target>
        </trans-unit>
        <trans-unit id="2b4c4f8198eac2368ebc714da19af84efddf447c" translate="yes" xml:space="preserve">
          <source>F.16.4. Examples</source>
          <target state="translated">F.16.4. 예</target>
        </trans-unit>
        <trans-unit id="90eff5025bc75068b267164038875e1635c8c255" translate="yes" xml:space="preserve">
          <source>F.16.5. Statistics</source>
          <target state="translated">F.16.5. 통계</target>
        </trans-unit>
        <trans-unit id="4e05f5c308dbbec0149addbb2463eaae08cc46aa" translate="yes" xml:space="preserve">
          <source>F.16.6. Compatibility</source>
          <target state="translated">F.16.6. 적합성</target>
        </trans-unit>
        <trans-unit id="8dbd0f1c1b12de81fb830bd3d477e7aff624c869" translate="yes" xml:space="preserve">
          <source>F.16.7. Transforms</source>
          <target state="translated">F.16.7. 변형</target>
        </trans-unit>
        <trans-unit id="0ed7a6c55a15524787fdd24e0a9887282515d660" translate="yes" xml:space="preserve">
          <source>F.16.8. Authors</source>
          <target state="translated">F.16.8. 저자</target>
        </trans-unit>
        <trans-unit id="ef901c5ecf993a0bec18e20827b1f5ebc01cc3cf" translate="yes" xml:space="preserve">
          <source>F.17. intagg</source>
          <target state="translated">F.17. 잉 타그</target>
        </trans-unit>
        <trans-unit id="8a846eabac892182bc4942f68dee9cb6533c96ba" translate="yes" xml:space="preserve">
          <source>F.17.1. Functions</source>
          <target state="translated">F.17.1. 기능</target>
        </trans-unit>
        <trans-unit id="096cf2f5427dd0642d7d558315e8e41f6aa0f435" translate="yes" xml:space="preserve">
          <source>F.17.2. Sample Uses</source>
          <target state="translated">F.17.2. 샘플 사용</target>
        </trans-unit>
        <trans-unit id="9d497c427457423611035a8e1138104c1a6454a8" translate="yes" xml:space="preserve">
          <source>F.18. intarray</source>
          <target state="translated">F.18. 인타 레이</target>
        </trans-unit>
        <trans-unit id="35e426f40a1fafe8fbd71778b978044b1313f6f2" translate="yes" xml:space="preserve">
          <source>F.18.1. &lt;code&gt;intarray&lt;/code&gt; Functions and Operators</source>
          <target state="translated">F.18.1. &lt;code&gt;intarray&lt;/code&gt; 함수 및 연산자</target>
        </trans-unit>
        <trans-unit id="590ecf1fe16e8463507cf8f6509beae0fac95454" translate="yes" xml:space="preserve">
          <source>F.18.2. Index Support</source>
          <target state="translated">F.18.2. 인덱스 지원</target>
        </trans-unit>
        <trans-unit id="0d7d6d82f910ac69b2bc79023a1885d00e7344d1" translate="yes" xml:space="preserve">
          <source>F.18.3. Example</source>
          <target state="translated">F.18.3. 예</target>
        </trans-unit>
        <trans-unit id="20d030c951773c391dae57ec9d360978ed9da7f9" translate="yes" xml:space="preserve">
          <source>F.18.4. Benchmark</source>
          <target state="translated">F.18.4. 기준</target>
        </trans-unit>
        <trans-unit id="32f9d82ac93f98fee1302ae4f678f7c6c937faf5" translate="yes" xml:space="preserve">
          <source>F.18.5. Authors</source>
          <target state="translated">F.18.5. 저자</target>
        </trans-unit>
        <trans-unit id="9949e04de9d9987a5e2e2d73820cb9572bdebefc" translate="yes" xml:space="preserve">
          <source>F.19. isn</source>
          <target state="translated">F.19. 이다</target>
        </trans-unit>
        <trans-unit id="f92b23aaa94e36a0b083631460692494c2541740" translate="yes" xml:space="preserve">
          <source>F.19.1. Data Types</source>
          <target state="translated">F.19.1. 데이터 타입</target>
        </trans-unit>
        <trans-unit id="824ef2156675e38b6922d9d3b5f1c62e81c74da8" translate="yes" xml:space="preserve">
          <source>F.19.2. Casts</source>
          <target state="translated">F.19.2. 캐스트</target>
        </trans-unit>
        <trans-unit id="bd4150a7873586e455ef10f2ee9fe10ea1d82054" translate="yes" xml:space="preserve">
          <source>F.19.3. Functions and Operators</source>
          <target state="translated">F.19.3. 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="8de2bcf5499966294b7a89a6d8111df3d3be5517" translate="yes" xml:space="preserve">
          <source>F.19.4. Examples</source>
          <target state="translated">F.19.4. 예</target>
        </trans-unit>
        <trans-unit id="54dd8b5077354d8f9842781edab86b35438f5df5" translate="yes" xml:space="preserve">
          <source>F.19.5. Bibliography</source>
          <target state="translated">F.19.5. 서지</target>
        </trans-unit>
        <trans-unit id="98c2220c95292d8a74cab397c3a701da35a004a9" translate="yes" xml:space="preserve">
          <source>F.19.6. Author</source>
          <target state="translated">F.19.6. 저자</target>
        </trans-unit>
        <trans-unit id="7ce29efe3aba103127578bb92d471da26a8e1c27" translate="yes" xml:space="preserve">
          <source>F.2. amcheck</source>
          <target state="translated">F.2. amcheck</target>
        </trans-unit>
        <trans-unit id="866feedaa5ba7bd021b78167df606b7bc7159ccc" translate="yes" xml:space="preserve">
          <source>F.2.1. Functions</source>
          <target state="translated">F.2.1. 기능</target>
        </trans-unit>
        <trans-unit id="bfd61595a640584e873b81cf6fa71fc6d8b5aef8" translate="yes" xml:space="preserve">
          <source>F.2.2. Optional &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; Verification</source>
          <target state="translated">F.2.2. 선택적 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 검증</target>
        </trans-unit>
        <trans-unit id="fb374459ade3b0e685573e23d45028532781fde2" translate="yes" xml:space="preserve">
          <source>F.2.3. Using &lt;code&gt;amcheck&lt;/code&gt; Effectively</source>
          <target state="translated">F.2.3. 효과적으로 &lt;code&gt;amcheck&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5c03c3a67f58e049c3e64357a6e75f2ba616ae36" translate="yes" xml:space="preserve">
          <source>F.2.4. Repairing Corruption</source>
          <target state="translated">F.2.4. 부패 수리</target>
        </trans-unit>
        <trans-unit id="c5aac668fae89db07299f936ff73b8263417e113" translate="yes" xml:space="preserve">
          <source>F.20. lo</source>
          <target state="translated">F.20. 봐라</target>
        </trans-unit>
        <trans-unit id="7f097c1b2d299fc1bd2add0f834cf8d6748c6f0d" translate="yes" xml:space="preserve">
          <source>F.20.1. Rationale</source>
          <target state="translated">F.20.1. 이론적 해석</target>
        </trans-unit>
        <trans-unit id="c9b4132cf12dff8738567aada10b65102fe62f79" translate="yes" xml:space="preserve">
          <source>F.20.2. How to Use It</source>
          <target state="translated">F.20.2. 사용 방법</target>
        </trans-unit>
        <trans-unit id="4a0ef949ca5051e3b9bb2b885b51a7ad8ff29ee0" translate="yes" xml:space="preserve">
          <source>F.20.3. Limitations</source>
          <target state="translated">F.20.3. 한계</target>
        </trans-unit>
        <trans-unit id="1123ff142a5242119d2bf382684a6c72470c9075" translate="yes" xml:space="preserve">
          <source>F.20.4. Author</source>
          <target state="translated">F.20.4. 저자</target>
        </trans-unit>
        <trans-unit id="7b3d074a1e31ac3a21aed7f7232c1047e9b97c30" translate="yes" xml:space="preserve">
          <source>F.21. ltree</source>
          <target state="translated">F.21. ltree</target>
        </trans-unit>
        <trans-unit id="e1953c5653ae6bfb304f654683ee1f77f6e74691" translate="yes" xml:space="preserve">
          <source>F.21.1. Definitions</source>
          <target state="translated">F.21.1. 정의</target>
        </trans-unit>
        <trans-unit id="7817803d1ae9f2a24f51a444d32288a38debe6c3" translate="yes" xml:space="preserve">
          <source>F.21.2. Operators and Functions</source>
          <target state="translated">F.21.2. 연산자와 함수</target>
        </trans-unit>
        <trans-unit id="ff5edf8f9c269c18e0958d380b29953bd2d87078" translate="yes" xml:space="preserve">
          <source>F.21.3. Indexes</source>
          <target state="translated">F.21.3. 인덱스</target>
        </trans-unit>
        <trans-unit id="192ce328b7167fccab29f3f2a477a993a2987060" translate="yes" xml:space="preserve">
          <source>F.21.4. Example</source>
          <target state="translated">F.21.4. 예</target>
        </trans-unit>
        <trans-unit id="d8fc608061497440e40e867e8967ad73ca799bd8" translate="yes" xml:space="preserve">
          <source>F.21.5. Transforms</source>
          <target state="translated">F.21.5. 변형</target>
        </trans-unit>
        <trans-unit id="6286519146bdf56d1bdd6acb5c5cc657edbf9085" translate="yes" xml:space="preserve">
          <source>F.21.6. Authors</source>
          <target state="translated">F.21.6. 저자</target>
        </trans-unit>
        <trans-unit id="9cd818eeaf1eaf95d1d44dff8bac406869884842" translate="yes" xml:space="preserve">
          <source>F.22. pageinspect</source>
          <target state="translated">F.22. 페이지 검사</target>
        </trans-unit>
        <trans-unit id="de632b965c073d5b3cb6bc5bcd13d127f991db35" translate="yes" xml:space="preserve">
          <source>F.22.1. General Functions</source>
          <target state="translated">F.22.1. 일반 기능</target>
        </trans-unit>
        <trans-unit id="e44f80c235d00e99a3eb77a1a02409ba129b2041" translate="yes" xml:space="preserve">
          <source>F.22.2. Heap Functions</source>
          <target state="translated">F.22.2. 힙 기능</target>
        </trans-unit>
        <trans-unit id="1c71737be20a941d4c7bf90768621397c72df758" translate="yes" xml:space="preserve">
          <source>F.22.3. B-Tree Functions</source>
          <target state="translated">F.22.3. B- 트리 기능</target>
        </trans-unit>
        <trans-unit id="34b300cac314927d744692ef92150cc67d2dd3d4" translate="yes" xml:space="preserve">
          <source>F.22.4. BRIN Functions</source>
          <target state="translated">F.22.4. 브린 기능</target>
        </trans-unit>
        <trans-unit id="5435da81280a932f2cfdafa55cf6b8963c3c9668" translate="yes" xml:space="preserve">
          <source>F.22.5. GIN Functions</source>
          <target state="translated">F.22.5. 진 기능</target>
        </trans-unit>
        <trans-unit id="b19f99ab1ffabf3311f71b36992c192b8477a00f" translate="yes" xml:space="preserve">
          <source>F.22.6. Hash Functions</source>
          <target state="translated">F.22.6. 해시 함수</target>
        </trans-unit>
        <trans-unit id="8f2b599b901de0542fc5213060869a06aec04f41" translate="yes" xml:space="preserve">
          <source>F.23. passwordcheck</source>
          <target state="translated">F.23. 비밀번호 확인</target>
        </trans-unit>
        <trans-unit id="dd69d26b0ef3fde0364251a95b289c9c283c2ca5" translate="yes" xml:space="preserve">
          <source>F.24. pg_buffercache</source>
          <target state="translated">F.24. pg_buffercache</target>
        </trans-unit>
        <trans-unit id="c4cbdb669bb06e75c07d4e7a9a03b46492702c60" translate="yes" xml:space="preserve">
          <source>F.24.1. The &lt;code&gt;pg_buffercache&lt;/code&gt; View</source>
          <target state="translated">F.24.1. &lt;code&gt;pg_buffercache&lt;/code&gt; 의 보기</target>
        </trans-unit>
        <trans-unit id="6511735718d4497449c0a7a96e48310acbfcd007" translate="yes" xml:space="preserve">
          <source>F.24.2. Sample Output</source>
          <target state="translated">F.24.2. 샘플 출력</target>
        </trans-unit>
        <trans-unit id="7237b1e65b9d6babc2c271e2b1ade2e599c67443" translate="yes" xml:space="preserve">
          <source>F.24.3. Authors</source>
          <target state="translated">F.24.3. 저자</target>
        </trans-unit>
        <trans-unit id="f6c54ece16019f60246b8dfda4b639acdfd3efbb" translate="yes" xml:space="preserve">
          <source>F.25. pgcrypto</source>
          <target state="translated">F.25. pgcrypto</target>
        </trans-unit>
        <trans-unit id="1b69a53eb9fc01a412e3eb39bb09c9940b5893fe" translate="yes" xml:space="preserve">
          <source>F.25.1. General Hashing Functions</source>
          <target state="translated">F.25.1. 일반 해싱 함수</target>
        </trans-unit>
        <trans-unit id="20ef4ddd6e94a918f41c006dba66b7f9f4e2de33" translate="yes" xml:space="preserve">
          <source>F.25.1.1. &lt;code&gt;digest()&lt;/code&gt;</source>
          <target state="translated">F.25.1.1. &lt;code&gt;digest()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73bdda1ec2d12f4343e8f6ed415383cdfabd7e01" translate="yes" xml:space="preserve">
          <source>F.25.1.2. &lt;code&gt;hmac()&lt;/code&gt;</source>
          <target state="translated">F.25.1.2. &lt;code&gt;hmac()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8aed6d345ad282f7dd6852c664093afce29119a" translate="yes" xml:space="preserve">
          <source>F.25.2. Password Hashing Functions</source>
          <target state="translated">F.25.2. 비밀번호 해싱 기능</target>
        </trans-unit>
        <trans-unit id="648294b1d552ef98633615ce2c099cb17e284418" translate="yes" xml:space="preserve">
          <source>F.25.2.1. &lt;code&gt;crypt()&lt;/code&gt;</source>
          <target state="translated">F.25.2.1. &lt;code&gt;crypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f436cf61bca1c78ff4c8b5cd56400150126eee8" translate="yes" xml:space="preserve">
          <source>F.25.2.2. &lt;code&gt;gen_salt()&lt;/code&gt;</source>
          <target state="translated">F.25.2.2. &lt;code&gt;gen_salt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba94d8ceafdbe9c995cd42cc672a2052fa9f849f" translate="yes" xml:space="preserve">
          <source>F.25.3. PGP Encryption Functions</source>
          <target state="translated">F.25.3. PGP 암호화 기능</target>
        </trans-unit>
        <trans-unit id="9dc741981d2f1f646431199c235db18f4f70eaa6" translate="yes" xml:space="preserve">
          <source>F.25.3.1. &lt;code&gt;pgp_sym_encrypt()&lt;/code&gt;</source>
          <target state="translated">F.25.3.1. &lt;code&gt;pgp_sym_encrypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ce9c368c9322da0152d1e6c730dbd3ca796d29c" translate="yes" xml:space="preserve">
          <source>F.25.3.10. Limitations of PGP Code</source>
          <target state="translated">F.25.3.10. PGP 코드의 한계</target>
        </trans-unit>
        <trans-unit id="c3b7a720a2e61a8e29b7c0d5651d11585d728158" translate="yes" xml:space="preserve">
          <source>F.25.3.2. &lt;code&gt;pgp_sym_decrypt()&lt;/code&gt;</source>
          <target state="translated">F.25.3.2. &lt;code&gt;pgp_sym_decrypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1440fd16b327d52206e6bbc27209e40f3c25518b" translate="yes" xml:space="preserve">
          <source>F.25.3.3. &lt;code&gt;pgp_pub_encrypt()&lt;/code&gt;</source>
          <target state="translated">F.25.3.3. &lt;code&gt;pgp_pub_encrypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4511f95f7118c70ecd722deb1cf4890abad67ee" translate="yes" xml:space="preserve">
          <source>F.25.3.4. &lt;code&gt;pgp_pub_decrypt()&lt;/code&gt;</source>
          <target state="translated">F.25.3.4. &lt;code&gt;pgp_pub_decrypt()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="851ac5e05147051b81591361f3b4b9029afc4b0d" translate="yes" xml:space="preserve">
          <source>F.25.3.5. &lt;code&gt;pgp_key_id()&lt;/code&gt;</source>
          <target state="translated">F.25.3.5. &lt;code&gt;pgp_key_id()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c88a1aaf0769a9f9305f8fb7d047ded9966673d8" translate="yes" xml:space="preserve">
          <source>F.25.3.6. &lt;code&gt;armor()&lt;/code&gt;, &lt;code&gt;dearmor()&lt;/code&gt;</source>
          <target state="translated">F.25.3.6. &lt;code&gt;armor()&lt;/code&gt; , &lt;code&gt;dearmor()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b166f7f6622cb2c7c5278090124129c0f130698" translate="yes" xml:space="preserve">
          <source>F.25.3.7. &lt;code&gt;pgp_armor_headers&lt;/code&gt;</source>
          <target state="translated">F.25.3.7. &lt;code&gt;pgp_armor_headers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72ca2237372393c19189f0ae1dbe11e53949a8f6" translate="yes" xml:space="preserve">
          <source>F.25.3.8. Options for PGP Functions</source>
          <target state="translated">F.25.3.8. PGP 기능 옵션</target>
        </trans-unit>
        <trans-unit id="5bccea5eab8c2ac75c619e98f506cf7b3a7838c8" translate="yes" xml:space="preserve">
          <source>F.25.3.8.1. cipher-algo</source>
          <target state="translated">F.25.3.8.1. 암호 알고리즘</target>
        </trans-unit>
        <trans-unit id="4ff1dcef2ae938211c3e9fb4eed66f1d015acf5a" translate="yes" xml:space="preserve">
          <source>F.25.3.8.10. s2k-cipher-algo</source>
          <target state="translated">F.25.3.8.10. s2k 암호 알고리즘</target>
        </trans-unit>
        <trans-unit id="0184a6d40ce7402329bcbaaab1c15ad1f3ec81c7" translate="yes" xml:space="preserve">
          <source>F.25.3.8.11. unicode-mode</source>
          <target state="translated">F.25.3.8.11. 유니 코드 모드</target>
        </trans-unit>
        <trans-unit id="1b1f6de6ead087ad34ce3dde6ba8c8588dd79fb7" translate="yes" xml:space="preserve">
          <source>F.25.3.8.2. compress-algo</source>
          <target state="translated">F.25.3.8.2. 압축 알고리즘</target>
        </trans-unit>
        <trans-unit id="123e13a4af409a09f2921448f1c91f349c921d54" translate="yes" xml:space="preserve">
          <source>F.25.3.8.3. compress-level</source>
          <target state="translated">F.25.3.8.3. 압축 수준</target>
        </trans-unit>
        <trans-unit id="65b75e3362b8b79cafa308f084bd508871fee9a9" translate="yes" xml:space="preserve">
          <source>F.25.3.8.4. convert-crlf</source>
          <target state="translated">F.25.3.8.4. 개 심자</target>
        </trans-unit>
        <trans-unit id="d5dc7cface8b5bc0ef3d9c52244f630ff84c0e87" translate="yes" xml:space="preserve">
          <source>F.25.3.8.5. disable-mdc</source>
          <target state="translated">F.25.3.8.5. disable-mdc</target>
        </trans-unit>
        <trans-unit id="8ebebefcc75be5058839e0b78a1c9c7da4466f00" translate="yes" xml:space="preserve">
          <source>F.25.3.8.6. sess-key</source>
          <target state="translated">F.25.3.8.6. 세스 키</target>
        </trans-unit>
        <trans-unit id="f6b2059d09268d64aa31ef2ce2c067102d67e99b" translate="yes" xml:space="preserve">
          <source>F.25.3.8.7. s2k-mode</source>
          <target state="translated">F.25.3.8.7. s2k 모드</target>
        </trans-unit>
        <trans-unit id="3ec7953362b03623b0193374c90382e4f6836554" translate="yes" xml:space="preserve">
          <source>F.25.3.8.8. s2k-count</source>
          <target state="translated">F.25.3.8.8. s2k- 카운트</target>
        </trans-unit>
        <trans-unit id="7b93d3dded709dbf34f19195fd711141a7d39724" translate="yes" xml:space="preserve">
          <source>F.25.3.8.9. s2k-digest-algo</source>
          <target state="translated">F.25.3.8.9. s2k- 다이제스트-알고</target>
        </trans-unit>
        <trans-unit id="aaf39f460b7cc3fff87b2265321ff5a520b79870" translate="yes" xml:space="preserve">
          <source>F.25.3.9. Generating PGP Keys with GnuPG</source>
          <target state="translated">F.25.3.9. GnuPG로 PGP 키 생성</target>
        </trans-unit>
        <trans-unit id="9b2d739f0baf5d9701c6c85f4ff01bae0c21de15" translate="yes" xml:space="preserve">
          <source>F.25.4. Raw Encryption Functions</source>
          <target state="translated">F.25.4. 원시 암호화 기능</target>
        </trans-unit>
        <trans-unit id="9d26da86c3ede2eb658f6d30d59cab3fe6086098" translate="yes" xml:space="preserve">
          <source>F.25.5. Random-Data Functions</source>
          <target state="translated">F.25.5. 랜덤 데이터 함수</target>
        </trans-unit>
        <trans-unit id="204e00a028516b1945b846a226f3b7c88787462f" translate="yes" xml:space="preserve">
          <source>F.25.6. Notes</source>
          <target state="translated">F.25.6. 노트</target>
        </trans-unit>
        <trans-unit id="6eaf14101828f85289bf3861eca422eca65adcf8" translate="yes" xml:space="preserve">
          <source>F.25.6.1. Configuration</source>
          <target state="translated">F.25.6.1. 구성</target>
        </trans-unit>
        <trans-unit id="278a46e8c054cd1ab368f6c28c75f41eb33b3ce9" translate="yes" xml:space="preserve">
          <source>F.25.6.2. NULL Handling</source>
          <target state="translated">F.25.6.2. NULL 처리</target>
        </trans-unit>
        <trans-unit id="5a795e063ffd476cbb12cdbea7497a6a89028a71" translate="yes" xml:space="preserve">
          <source>F.25.6.3. Security Limitations</source>
          <target state="translated">F.25.6.3. 보안 제한</target>
        </trans-unit>
        <trans-unit id="0a20df0b20779a999c62ff097aac89375c902e0d" translate="yes" xml:space="preserve">
          <source>F.25.6.4. Useful Reading</source>
          <target state="translated">F.25.6.4. 유용한 독서</target>
        </trans-unit>
        <trans-unit id="a8f89e01b1a3c968473d516b54dd2a27fcff5d23" translate="yes" xml:space="preserve">
          <source>F.25.6.5. Technical References</source>
          <target state="translated">F.25.6.5. 기술 참조</target>
        </trans-unit>
        <trans-unit id="95ec7f2a276d43cdddf8d912e1dc59cff5b486a2" translate="yes" xml:space="preserve">
          <source>F.25.7. Author</source>
          <target state="translated">F.25.7. 저자</target>
        </trans-unit>
        <trans-unit id="6d87ba341737e825fea1649de07238172e85db44" translate="yes" xml:space="preserve">
          <source>F.26. pg_freespacemap</source>
          <target state="translated">F.26. pg_freespacemap</target>
        </trans-unit>
        <trans-unit id="776eea32accc24dda78b8fe28fa0f7c45dff5c2e" translate="yes" xml:space="preserve">
          <source>F.26.1. Functions</source>
          <target state="translated">F.26.1. 기능</target>
        </trans-unit>
        <trans-unit id="dbf2204ce6fc1c9faa7f16be35f1922e9a96127e" translate="yes" xml:space="preserve">
          <source>F.26.2. Sample Output</source>
          <target state="translated">F.26.2. 샘플 출력</target>
        </trans-unit>
        <trans-unit id="9a3afb36a016059607419287b873395130efbcba" translate="yes" xml:space="preserve">
          <source>F.26.3. Author</source>
          <target state="translated">F.26.3. 저자</target>
        </trans-unit>
        <trans-unit id="c770ac7064fe14e68deabe20f96bd726d85a4c53" translate="yes" xml:space="preserve">
          <source>F.27. pg_prewarm</source>
          <target state="translated">F.27. pg_prewarm</target>
        </trans-unit>
        <trans-unit id="c83979c6186932e7f06c2286a6e5ae62b4f96e5d" translate="yes" xml:space="preserve">
          <source>F.27.1. Functions</source>
          <target state="translated">F.27.1. 기능</target>
        </trans-unit>
        <trans-unit id="0a4f8191cf5b90a57e9bbb4b3e3f2dbc3a1b162a" translate="yes" xml:space="preserve">
          <source>F.27.2. Configuration Parameters</source>
          <target state="translated">F.27.2. 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="52e656be642fd38c2cc04fe4f0c163370650aec9" translate="yes" xml:space="preserve">
          <source>F.27.3. Author</source>
          <target state="translated">F.27.3. 저자</target>
        </trans-unit>
        <trans-unit id="f34a78f1d8034dfca697da3e2e901050c64f7389" translate="yes" xml:space="preserve">
          <source>F.28. pgrowlocks</source>
          <target state="translated">F.28. pgrowlocks</target>
        </trans-unit>
        <trans-unit id="e23ecf44779814c897e31c3fc14848fd3c39577b" translate="yes" xml:space="preserve">
          <source>F.28.1. Overview</source>
          <target state="translated">F.28.1. 개요</target>
        </trans-unit>
        <trans-unit id="722835953492c125abcca028d29b6cb31745b1f0" translate="yes" xml:space="preserve">
          <source>F.28.2. Sample Output</source>
          <target state="translated">F.28.2. 샘플 출력</target>
        </trans-unit>
        <trans-unit id="a3c331c6911f6a88efd0e0be66df1e82ba2c5ba5" translate="yes" xml:space="preserve">
          <source>F.28.3. Author</source>
          <target state="translated">F.28.3. 저자</target>
        </trans-unit>
        <trans-unit id="34f192913b27a9575099b4354abfc96f154647a9" translate="yes" xml:space="preserve">
          <source>F.29. pg_stat_statements</source>
          <target state="translated">F.29. pg_stat_statements</target>
        </trans-unit>
        <trans-unit id="98d099f81eb49092c7fa45a4620f13cbca7eb4b4" translate="yes" xml:space="preserve">
          <source>F.29.1. The &lt;code&gt;pg_stat_statements&lt;/code&gt; View</source>
          <target state="translated">F.29.1. &lt;code&gt;pg_stat_statements&lt;/code&gt; 는 보기</target>
        </trans-unit>
        <trans-unit id="f604837ab61bc198722329e277e0b0f4d017c9f3" translate="yes" xml:space="preserve">
          <source>F.29.2. Functions</source>
          <target state="translated">F.29.2. 기능</target>
        </trans-unit>
        <trans-unit id="9630871d326e2082b4c0dc726cf97969a02fb58a" translate="yes" xml:space="preserve">
          <source>F.29.3. Configuration Parameters</source>
          <target state="translated">F.29.3. 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="b4a60f9b108b5f6bc5f54d10335cf495a4365aaf" translate="yes" xml:space="preserve">
          <source>F.29.4. Sample Output</source>
          <target state="translated">F.29.4. 샘플 출력</target>
        </trans-unit>
        <trans-unit id="959ad93c5611ec265d706a857a3ce74fa8c1be07" translate="yes" xml:space="preserve">
          <source>F.29.5. Authors</source>
          <target state="translated">F.29.5. 저자</target>
        </trans-unit>
        <trans-unit id="704b887fb1ff7881213018edeff2e0bef27a3135" translate="yes" xml:space="preserve">
          <source>F.3. auth_delay</source>
          <target state="translated">F.3. auth_delay</target>
        </trans-unit>
        <trans-unit id="b509ada65fd8784b515a28bc785543896ffe0c44" translate="yes" xml:space="preserve">
          <source>F.3.1. Configuration Parameters</source>
          <target state="translated">F.3.1. 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="0963c804bdd94f69573ed873c878d960aaa02c67" translate="yes" xml:space="preserve">
          <source>F.3.2. Author</source>
          <target state="translated">F.3.2. 저자</target>
        </trans-unit>
        <trans-unit id="13ca2dc97e6c093802774b17400831f98e95d847" translate="yes" xml:space="preserve">
          <source>F.30. pgstattuple</source>
          <target state="translated">F.30. pgstattuple</target>
        </trans-unit>
        <trans-unit id="80820b9c19b9082fd01b22b80e375b02bdcbd982" translate="yes" xml:space="preserve">
          <source>F.30.1. Functions</source>
          <target state="translated">F.30.1. 기능</target>
        </trans-unit>
        <trans-unit id="3e8b9844693185862cd930605a318fb08f0daa62" translate="yes" xml:space="preserve">
          <source>F.30.2. Authors</source>
          <target state="translated">F.30.2. 저자</target>
        </trans-unit>
        <trans-unit id="681d27f3112d152e9b16db16fadea92227b24d55" translate="yes" xml:space="preserve">
          <source>F.31. pg_trgm</source>
          <target state="translated">F.31. pg_trgm</target>
        </trans-unit>
        <trans-unit id="c89a28a6d1f56e27f367a06ec7379fca446be6c7" translate="yes" xml:space="preserve">
          <source>F.31.1. Trigram (or Trigraph) Concepts</source>
          <target state="translated">F.31.1. Trigram (또는 Trigraph) 개념</target>
        </trans-unit>
        <trans-unit id="2d9cb416fb09a81cc6d2c51704de4c8b5ba9cfe8" translate="yes" xml:space="preserve">
          <source>F.31.2. Functions and Operators</source>
          <target state="translated">F.31.2. 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="ff85d5fa8354d2d9281d02f0b6f23de90e8c02d7" translate="yes" xml:space="preserve">
          <source>F.31.3. GUC Parameters</source>
          <target state="translated">F.31.3. GUC 매개 변수</target>
        </trans-unit>
        <trans-unit id="f3264e50a672ede496f91bd277d84fcf943750a6" translate="yes" xml:space="preserve">
          <source>F.31.4. Index Support</source>
          <target state="translated">F.31.4. 인덱스 지원</target>
        </trans-unit>
        <trans-unit id="1fcf8d6131447541df442d15baeaf11459619fc5" translate="yes" xml:space="preserve">
          <source>F.31.5. Text Search Integration</source>
          <target state="translated">F.31.5. 텍스트 검색 통합</target>
        </trans-unit>
        <trans-unit id="8dcae1083d938ff89dd80c6da49b52ea44e0b8b3" translate="yes" xml:space="preserve">
          <source>F.31.6. References</source>
          <target state="translated">F.31.6. 참고 문헌</target>
        </trans-unit>
        <trans-unit id="9df69f7c595b9652f29399e102d937ad43270ce6" translate="yes" xml:space="preserve">
          <source>F.31.7. Authors</source>
          <target state="translated">F.31.7. 저자</target>
        </trans-unit>
        <trans-unit id="66f1a37f115acc2f3f09b71c19b4ab6e4fe99b87" translate="yes" xml:space="preserve">
          <source>F.32. pg_visibility</source>
          <target state="translated">F.32 pg_visibility</target>
        </trans-unit>
        <trans-unit id="2e568ce017cd15afddab3f2b3a3623d54ce19800" translate="yes" xml:space="preserve">
          <source>F.32.1. Functions</source>
          <target state="translated">F.32.1. 기능</target>
        </trans-unit>
        <trans-unit id="983f4b75d738b3142d08500f7dc7740b0d08da84" translate="yes" xml:space="preserve">
          <source>F.32.2. Author</source>
          <target state="translated">F.32.2. 저자</target>
        </trans-unit>
        <trans-unit id="9273fa777dbf591ea861acb44c324bfc1f47c3c6" translate="yes" xml:space="preserve">
          <source>F.33. postgres_fdw</source>
          <target state="translated">F.33. postgres_fdw</target>
        </trans-unit>
        <trans-unit id="193b83877ad110c43d18c17fa85bc266b3589e87" translate="yes" xml:space="preserve">
          <source>F.33.1. FDW Options of postgres_fdw</source>
          <target state="translated">F.33.1. postgres_fdw의 FDW 옵션</target>
        </trans-unit>
        <trans-unit id="5412c884ac336714c4398df021f14f3acfc2cc8d" translate="yes" xml:space="preserve">
          <source>F.33.1.1. Connection Options</source>
          <target state="translated">F.33.1.1. 연결 옵션</target>
        </trans-unit>
        <trans-unit id="269c16164be1a1095f225f73c7ce5a51294dc815" translate="yes" xml:space="preserve">
          <source>F.33.1.2. Object Name Options</source>
          <target state="translated">F.33.1.2. 객체 이름 옵션</target>
        </trans-unit>
        <trans-unit id="dfeb9338540cd6b729a939516830d6cc198332da" translate="yes" xml:space="preserve">
          <source>F.33.1.3. Cost Estimation Options</source>
          <target state="translated">F.33.1.3. 비용 추정 옵션</target>
        </trans-unit>
        <trans-unit id="007d50d7c6a3fb29c267c851f2f73026db5294c9" translate="yes" xml:space="preserve">
          <source>F.33.1.4. Remote Execution Options</source>
          <target state="translated">F.33.1.4. 원격 실행 옵션</target>
        </trans-unit>
        <trans-unit id="939b45466c24ec90b5230dca452452bbd649bf93" translate="yes" xml:space="preserve">
          <source>F.33.1.5. Updatability Options</source>
          <target state="translated">F.33.1.5. 업데이트 가능성 옵션</target>
        </trans-unit>
        <trans-unit id="d9f27c8d768a3bb2417485f8db64eee51be52484" translate="yes" xml:space="preserve">
          <source>F.33.1.6. Importing Options</source>
          <target state="translated">F.33.1.6. 가져 오기 옵션</target>
        </trans-unit>
        <trans-unit id="2b2c01fcf10adb380e0ed33448e2d3f4238d7812" translate="yes" xml:space="preserve">
          <source>F.33.2. Connection Management</source>
          <target state="translated">F.33.2. 연결 관리</target>
        </trans-unit>
        <trans-unit id="ab6004832e8fa28f0f4237df2ffaeb324d443fa2" translate="yes" xml:space="preserve">
          <source>F.33.3. Transaction Management</source>
          <target state="translated">F.33.3. 거래 관리</target>
        </trans-unit>
        <trans-unit id="a1dfc91d53cf08246f4f53f3009e93d89b6a231c" translate="yes" xml:space="preserve">
          <source>F.33.4. Remote Query Optimization</source>
          <target state="translated">F.33.4. 원격 쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="298bc93d569355f87b81fe19414a86c661d83ef1" translate="yes" xml:space="preserve">
          <source>F.33.5. Remote Query Execution Environment</source>
          <target state="translated">F.33.5. 원격 쿼리 실행 환경</target>
        </trans-unit>
        <trans-unit id="6c812df5f2650246a5da313d3d83550da9fa68f2" translate="yes" xml:space="preserve">
          <source>F.33.6. Cross-Version Compatibility</source>
          <target state="translated">F.33.6. 버전 간 호환성</target>
        </trans-unit>
        <trans-unit id="f79780fd8ba8dc90bbdc8966f8e88fd8bb05063d" translate="yes" xml:space="preserve">
          <source>F.33.7. Examples</source>
          <target state="translated">F.33.7. 예</target>
        </trans-unit>
        <trans-unit id="432a0ebb55cf26d92ead0a91a747b8341156ffc1" translate="yes" xml:space="preserve">
          <source>F.33.8. Author</source>
          <target state="translated">F.33.8. 저자</target>
        </trans-unit>
        <trans-unit id="16b654685a2d9cd826f23038130d516d1946f903" translate="yes" xml:space="preserve">
          <source>F.34. seg</source>
          <target state="translated">F.34. 세그</target>
        </trans-unit>
        <trans-unit id="d79c41978f6fcd2989e2c59dff39b1eb0e2b1ab2" translate="yes" xml:space="preserve">
          <source>F.34.1. Rationale</source>
          <target state="translated">F.34.1. 이론적 해석</target>
        </trans-unit>
        <trans-unit id="f381dda45532b33f9b25ac406472931c193f29f5" translate="yes" xml:space="preserve">
          <source>F.34.2. Syntax</source>
          <target state="translated">F.34.2. 통사론</target>
        </trans-unit>
        <trans-unit id="c68c1caf01c3b9e2f432a702040137d0b1a0112d" translate="yes" xml:space="preserve">
          <source>F.34.3. Precision</source>
          <target state="translated">F.34.3. 정도</target>
        </trans-unit>
        <trans-unit id="e9928901c9ae448513c326ba6d46773618882907" translate="yes" xml:space="preserve">
          <source>F.34.4. Usage</source>
          <target state="translated">F.34.4. 용법</target>
        </trans-unit>
        <trans-unit id="487522e1f9e9fdcc603756f55afc3ba3026ea478" translate="yes" xml:space="preserve">
          <source>F.34.5. Notes</source>
          <target state="translated">F.34.5. 노트</target>
        </trans-unit>
        <trans-unit id="e01b0c3849c2815614ff98ea8042fc4d0d3a8bee" translate="yes" xml:space="preserve">
          <source>F.34.6. Credits</source>
          <target state="translated">F.34.6. 크레딧</target>
        </trans-unit>
        <trans-unit id="aaea0df06c8afc5721c399416715a43d27b1f41d" translate="yes" xml:space="preserve">
          <source>F.35. sepgsql</source>
          <target state="translated">F.35. sepgsql</target>
        </trans-unit>
        <trans-unit id="5206feae808dab22e63b8f42cce9d33f2f135f52" translate="yes" xml:space="preserve">
          <source>F.35.1. Overview</source>
          <target state="translated">F.35.1. 개요</target>
        </trans-unit>
        <trans-unit id="6068791fc5c5c74ce128385c01570e2fd8c4a48b" translate="yes" xml:space="preserve">
          <source>F.35.2. Installation</source>
          <target state="translated">F.35.2. 설치</target>
        </trans-unit>
        <trans-unit id="94f1cb62f780d101543cd8044a3dfd934adbecfc" translate="yes" xml:space="preserve">
          <source>F.35.3. Regression Tests</source>
          <target state="translated">F.35.3. 회귀 테스트</target>
        </trans-unit>
        <trans-unit id="0a70e740ffcee05fc260767a1f95581165e5376f" translate="yes" xml:space="preserve">
          <source>F.35.4. GUC Parameters</source>
          <target state="translated">F.35.4. GUC 매개 변수</target>
        </trans-unit>
        <trans-unit id="6003590508d8bec77373f3d360244ded0e767160" translate="yes" xml:space="preserve">
          <source>F.35.5. Features</source>
          <target state="translated">F.35.5. 풍모</target>
        </trans-unit>
        <trans-unit id="4a9d2250255492ada5787896be52456a102ee3be" translate="yes" xml:space="preserve">
          <source>F.35.5.1. Controlled Object Classes</source>
          <target state="translated">F.35.5.1. 제어 객체 클래스</target>
        </trans-unit>
        <trans-unit id="f03a61735b6f9f8ae6f77db6c0ff006611d25b69" translate="yes" xml:space="preserve">
          <source>F.35.5.2. DML Permissions</source>
          <target state="translated">F.35.5.2. DML 권한</target>
        </trans-unit>
        <trans-unit id="43a9568bd958ec3f010bf2ab4df6ebdfc75230e3" translate="yes" xml:space="preserve">
          <source>F.35.5.3. DDL Permissions</source>
          <target state="translated">F.35.5.3. DDL 권한</target>
        </trans-unit>
        <trans-unit id="8ef73da6478fbece425ec33df2d34fd27c99f85a" translate="yes" xml:space="preserve">
          <source>F.35.5.4. Trusted Procedures</source>
          <target state="translated">F.35.5.4. 신뢰할 수있는 절차</target>
        </trans-unit>
        <trans-unit id="e3ae8efb8c0c1c98ae79553e1966e3502b8f9585" translate="yes" xml:space="preserve">
          <source>F.35.5.5. Dynamic Domain Transitions</source>
          <target state="translated">F.35.5.5. 동적 도메인 전환</target>
        </trans-unit>
        <trans-unit id="bf5bb12781dc975cf063d2968ff739805c304822" translate="yes" xml:space="preserve">
          <source>F.35.5.6. Miscellaneous</source>
          <target state="translated">F.35.5.6. 여러 가지 잡다한</target>
        </trans-unit>
        <trans-unit id="05b9c78d7bcd4bbd6c5e9e875a0bb0adbc8122d7" translate="yes" xml:space="preserve">
          <source>F.35.6. Sepgsql Functions</source>
          <target state="translated">F.35.6. Sepgsql 함수</target>
        </trans-unit>
        <trans-unit id="bfa8e70472b0775d65efab1472dd8d042c56a6a2" translate="yes" xml:space="preserve">
          <source>F.35.7. Limitations</source>
          <target state="translated">F.35.7. 한계</target>
        </trans-unit>
        <trans-unit id="4903d823dafd075b549d4d5ea82159af1e3dfa1c" translate="yes" xml:space="preserve">
          <source>F.35.8. External Resources</source>
          <target state="translated">F.35.8. 외부 자료</target>
        </trans-unit>
        <trans-unit id="eca08e46b02dad577f925d4b88f2fbb3cc95508e" translate="yes" xml:space="preserve">
          <source>F.35.9. Author</source>
          <target state="translated">F.35.9. 저자</target>
        </trans-unit>
        <trans-unit id="403dcb3cfdeecf1876f217fac3e72c3abf223756" translate="yes" xml:space="preserve">
          <source>F.36. spi</source>
          <target state="translated">F.36. spi</target>
        </trans-unit>
        <trans-unit id="077826ec37e8b7233b4e75eb9db7221bf9399eea" translate="yes" xml:space="preserve">
          <source>F.36.1. refint &amp;mdash; Functions for Implementing Referential Integrity</source>
          <target state="translated">F.36.1. refint &amp;mdash; 참조 무결성 구현 기능</target>
        </trans-unit>
        <trans-unit id="b4ebef02a6e3cae6adef5624dc45c8c1dc1f748b" translate="yes" xml:space="preserve">
          <source>F.36.2. autoinc &amp;mdash; Functions for Autoincrementing Fields</source>
          <target state="translated">F.36.2. autoinc &amp;mdash; 자동 증분 필드 기능</target>
        </trans-unit>
        <trans-unit id="021fec897b35d84822f6b1e782db6f3db5faff68" translate="yes" xml:space="preserve">
          <source>F.36.3. insert_username &amp;mdash; Functions for Tracking Who Changed a Table</source>
          <target state="translated">F.36.3. insert_username &amp;mdash; 테이블을 변경 한 사람을 추적하는 기능</target>
        </trans-unit>
        <trans-unit id="8cb8c0687c13a8ca41e996a8275886c28cd48465" translate="yes" xml:space="preserve">
          <source>F.36.4. moddatetime &amp;mdash; Functions for Tracking Last Modification Time</source>
          <target state="translated">F.36.4. moddatetime &amp;mdash; 마지막 수정 시간 추적 기능</target>
        </trans-unit>
        <trans-unit id="d57995f7aca0c64c159764eca0ad70e7cef116d9" translate="yes" xml:space="preserve">
          <source>F.37. sslinfo</source>
          <target state="translated">F.37. sslinfo</target>
        </trans-unit>
        <trans-unit id="6e38711f605d1ea1bf029605dbbea18953a2c328" translate="yes" xml:space="preserve">
          <source>F.37.1. Functions Provided</source>
          <target state="translated">F.37.1. 제공되는 기능</target>
        </trans-unit>
        <trans-unit id="e8f10e576f9530ae876dffa73026f21b1790fdb1" translate="yes" xml:space="preserve">
          <source>F.37.2. Author</source>
          <target state="translated">F.37.2. 저자</target>
        </trans-unit>
        <trans-unit id="d15932480528eb9e164d3f8d1e0fa9c2c520f95e" translate="yes" xml:space="preserve">
          <source>F.38. tablefunc</source>
          <target state="translated">F.38. 테이블 펑크</target>
        </trans-unit>
        <trans-unit id="bc9583045d4d45aff583dd3214484f26260af7d3" translate="yes" xml:space="preserve">
          <source>F.38.1. Functions Provided</source>
          <target state="translated">F.38.1. 제공되는 기능</target>
        </trans-unit>
        <trans-unit id="1dd8d5dfb4d1b5a2cb639abc5e9229429c74316b" translate="yes" xml:space="preserve">
          <source>F.38.1.1. &lt;code&gt;normal_rand&lt;/code&gt;</source>
          <target state="translated">F.38.1.1. &lt;code&gt;normal_rand&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75cb330e2bb121fed69b21cc6897099dff250f04" translate="yes" xml:space="preserve">
          <source>F.38.1.2. &lt;code&gt;crosstab(text)&lt;/code&gt;</source>
          <target state="translated">F.38.1.2. &lt;code&gt;crosstab(text)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="accdaf833c1fc8d3e68f6365ba9a4589bb980b75" translate="yes" xml:space="preserve">
          <source>F.38.1.3. &lt;code&gt;crosstabN(text)&lt;/code&gt;</source>
          <target state="translated">F.38.1.3. &lt;code&gt;crosstabN(text)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0aeddce04c69309380516e234020d78dc1f1ccba" translate="yes" xml:space="preserve">
          <source>F.38.1.4. &lt;code&gt;crosstab(text, text)&lt;/code&gt;</source>
          <target state="translated">F.38.1.4. &lt;code&gt;crosstab(text, text)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f533800a5ac65ab86b0fc20fe9cdb1d6334280f" translate="yes" xml:space="preserve">
          <source>F.38.1.5. &lt;code&gt;connectby&lt;/code&gt;</source>
          <target state="translated">F.38.1.5. &lt;code&gt;connectby&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0a17ab8d01f23f25e79997ed5e34403b5487d05" translate="yes" xml:space="preserve">
          <source>F.38.2. Author</source>
          <target state="translated">F.38.2. 저자</target>
        </trans-unit>
        <trans-unit id="80cd48066e2d9fe4d7954db8cf58f889aac317b5" translate="yes" xml:space="preserve">
          <source>F.39. tcn</source>
          <target state="translated">F.39. tcn</target>
        </trans-unit>
        <trans-unit id="e5027e63223df7517f07d367030af4c60f215a85" translate="yes" xml:space="preserve">
          <source>F.4. auto_explain</source>
          <target state="translated">F.4. auto_explain</target>
        </trans-unit>
        <trans-unit id="00ece7bcdd1d310b29789b78356ec422c388a58a" translate="yes" xml:space="preserve">
          <source>F.4.1. Configuration Parameters</source>
          <target state="translated">F.4.1. 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="a0a6256879cb7cae75467d1b4ea4fe196f0404c6" translate="yes" xml:space="preserve">
          <source>F.4.2. Example</source>
          <target state="translated">F.4.2. 예</target>
        </trans-unit>
        <trans-unit id="f50a8147f2d047d7a8751be893c1ec347609e3a5" translate="yes" xml:space="preserve">
          <source>F.4.3. Author</source>
          <target state="translated">F.4.3. 저자</target>
        </trans-unit>
        <trans-unit id="fc8940df593b4b360f8e1f45a289b3b422d6f20d" translate="yes" xml:space="preserve">
          <source>F.40. test_decoding</source>
          <target state="translated">F.40. test_decoding</target>
        </trans-unit>
        <trans-unit id="03f67d82c28db2a84958e8890b5de8b5bf6347a1" translate="yes" xml:space="preserve">
          <source>F.41. tsm_system_rows</source>
          <target state="translated">F.41. tsm_system_rows</target>
        </trans-unit>
        <trans-unit id="416a3659d3a356c02da8e3d689ffdcca451ee3da" translate="yes" xml:space="preserve">
          <source>F.41.1. Examples</source>
          <target state="translated">F.41.1. 예</target>
        </trans-unit>
        <trans-unit id="9aa25fbcbbafa308d7f1a07d231f4ae202c22734" translate="yes" xml:space="preserve">
          <source>F.42. tsm_system_time</source>
          <target state="translated">F.42. tsm_system_time</target>
        </trans-unit>
        <trans-unit id="539b9cd2fd284c4cf26fd26d3168aeb51dfa147f" translate="yes" xml:space="preserve">
          <source>F.42.1. Examples</source>
          <target state="translated">F.42.1. 예</target>
        </trans-unit>
        <trans-unit id="1d99770788a99649f583440e4fb4cd1f411fed9b" translate="yes" xml:space="preserve">
          <source>F.43. unaccent</source>
          <target state="translated">F.43. 무심한</target>
        </trans-unit>
        <trans-unit id="b957a5d2e5c88500638617c009686a587a5f4c5a" translate="yes" xml:space="preserve">
          <source>F.43.1. Configuration</source>
          <target state="translated">F.43.1. 구성</target>
        </trans-unit>
        <trans-unit id="2426a96f2db13b59ffeb995ba7efbddf713709cb" translate="yes" xml:space="preserve">
          <source>F.43.2. Usage</source>
          <target state="translated">F.43.2. 용법</target>
        </trans-unit>
        <trans-unit id="a77b3be2e90d4ad5267bee4914834745ced63df4" translate="yes" xml:space="preserve">
          <source>F.43.3. Functions</source>
          <target state="translated">F.43.3. 기능</target>
        </trans-unit>
        <trans-unit id="f5487dbd0be3f95eb366af7c9d2a030d8c0eae51" translate="yes" xml:space="preserve">
          <source>F.44. uuid-ossp</source>
          <target state="translated">F.44. UUID-OSSP</target>
        </trans-unit>
        <trans-unit id="837bdea5d3e52ed4ac250bc37414453dc903790d" translate="yes" xml:space="preserve">
          <source>F.44.1. &lt;code&gt;uuid-ossp&lt;/code&gt; Functions</source>
          <target state="translated">F.44.1. &lt;code&gt;uuid-ossp&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="5637522de808bcbaadbfbedc5d103c9cea419b4e" translate="yes" xml:space="preserve">
          <source>F.44.2. Building &lt;code&gt;uuid-ossp&lt;/code&gt;</source>
          <target state="translated">F.44.2. 구축 &lt;code&gt;uuid-ossp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b6a6a63d4650a6f31a2f4856888515e66d6e02c" translate="yes" xml:space="preserve">
          <source>F.44.3. Author</source>
          <target state="translated">F.44.3. 저자</target>
        </trans-unit>
        <trans-unit id="f641301979073e6b556b7bd23c74d427bc166669" translate="yes" xml:space="preserve">
          <source>F.45. xml2</source>
          <target state="translated">F.45. xml2</target>
        </trans-unit>
        <trans-unit id="c843ec4b20006ee1af6f7ef0dcca81dad92b0374" translate="yes" xml:space="preserve">
          <source>F.45.1. Deprecation Notice</source>
          <target state="translated">F.45.1. 지원 중단 알림</target>
        </trans-unit>
        <trans-unit id="eab90c2b75ae93d1508fbcfdc1e75d4c11e98593" translate="yes" xml:space="preserve">
          <source>F.45.2. Description of Functions</source>
          <target state="translated">F.45.2. 기능 설명</target>
        </trans-unit>
        <trans-unit id="7bc5848d72a5fb71d196f91689fe900f02b6d89d" translate="yes" xml:space="preserve">
          <source>F.45.3. &lt;code&gt;xpath_table&lt;/code&gt;</source>
          <target state="translated">F.45.3. &lt;code&gt;xpath_table&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a984102dec30c0cff21eac3a7b5933e35959c053" translate="yes" xml:space="preserve">
          <source>F.45.3.1. Multivalued Results</source>
          <target state="translated">F.45.3.1. 다중 값 결과</target>
        </trans-unit>
        <trans-unit id="c7ac9fed24b1b2ae692a896b628cdab596ef2e91" translate="yes" xml:space="preserve">
          <source>F.45.4. XSLT Functions</source>
          <target state="translated">F.45.4. XSLT 기능</target>
        </trans-unit>
        <trans-unit id="cfc8c5fb6b07724425c9de739fb9ca52e19dfcd9" translate="yes" xml:space="preserve">
          <source>F.45.4.1. &lt;code&gt;xslt_process&lt;/code&gt;</source>
          <target state="translated">F.45.4.1. &lt;code&gt;xslt_process&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbca4f30190cfc2ab53ed342af0bd911de756565" translate="yes" xml:space="preserve">
          <source>F.45.5. Author</source>
          <target state="translated">F.45.5. 저자</target>
        </trans-unit>
        <trans-unit id="0c9f43206fdfe18d51f7f5571d14209ea19e37b5" translate="yes" xml:space="preserve">
          <source>F.5. bloom</source>
          <target state="translated">F.5. 꽃</target>
        </trans-unit>
        <trans-unit id="84ab20aba2d92cc1a1590909f4b482005c47645b" translate="yes" xml:space="preserve">
          <source>F.5.1. Parameters</source>
          <target state="translated">F.5.1. 매개 변수</target>
        </trans-unit>
        <trans-unit id="673e2d3f99b61c3d59eaa3f1d59e87f1bde89a66" translate="yes" xml:space="preserve">
          <source>F.5.2. Examples</source>
          <target state="translated">F.5.2. 예</target>
        </trans-unit>
        <trans-unit id="b7d7af901e503b3bd3361bcb44f2ca4e7f0f982f" translate="yes" xml:space="preserve">
          <source>F.5.3. Operator Class Interface</source>
          <target state="translated">F.5.3. 운영자 클래스 인터페이스</target>
        </trans-unit>
        <trans-unit id="406348dbcd7a4871777a0a0e27c87f1318473cdc" translate="yes" xml:space="preserve">
          <source>F.5.4. Limitations</source>
          <target state="translated">F.5.4. 한계</target>
        </trans-unit>
        <trans-unit id="dd61580c12a4f98b1cabd570abfde001db6de3d1" translate="yes" xml:space="preserve">
          <source>F.5.5. Authors</source>
          <target state="translated">F.5.5. 저자</target>
        </trans-unit>
        <trans-unit id="a89981817fb8aa3dd68bb59664597b224f16d5f0" translate="yes" xml:space="preserve">
          <source>F.6. btree_gin</source>
          <target state="translated">F.6. btree_gin</target>
        </trans-unit>
        <trans-unit id="298c7e5ff8550c0946352688d4d3e6a4b25575a8" translate="yes" xml:space="preserve">
          <source>F.6.1. Example Usage</source>
          <target state="translated">F.6.1. 사용법 예</target>
        </trans-unit>
        <trans-unit id="9b044f8ec33c35746bb232092d3cfcfa4f666672" translate="yes" xml:space="preserve">
          <source>F.6.2. Authors</source>
          <target state="translated">F.6.2. 저자</target>
        </trans-unit>
        <trans-unit id="6557988a7591a0506bac1834fde39bd8b124ef58" translate="yes" xml:space="preserve">
          <source>F.7. btree_gist</source>
          <target state="translated">F.7. btree_gist</target>
        </trans-unit>
        <trans-unit id="db6dc2c96c276017488bc338eff3b96529ea0429" translate="yes" xml:space="preserve">
          <source>F.7.1. Example Usage</source>
          <target state="translated">F.7.1. 사용법 예</target>
        </trans-unit>
        <trans-unit id="4e9e64a99b250a192332d6b3c5227a8dfbf209e9" translate="yes" xml:space="preserve">
          <source>F.7.2. Authors</source>
          <target state="translated">F.7.2. 저자</target>
        </trans-unit>
        <trans-unit id="d1f76faa362480f2e84be9515db1d46ec8bb6a6f" translate="yes" xml:space="preserve">
          <source>F.8. citext</source>
          <target state="translated">F.8. 인용문</target>
        </trans-unit>
        <trans-unit id="6cde381ccc3fba94785b363e72753335dad08a56" translate="yes" xml:space="preserve">
          <source>F.8.1. Rationale</source>
          <target state="translated">F.8.1. 이론적 해석</target>
        </trans-unit>
        <trans-unit id="daae387369be9c7b6760bea450197227fccec483" translate="yes" xml:space="preserve">
          <source>F.8.2. How to Use It</source>
          <target state="translated">F.8.2. 사용 방법</target>
        </trans-unit>
        <trans-unit id="452ac339dee9be15e0568551b363547190886f57" translate="yes" xml:space="preserve">
          <source>F.8.3. String Comparison Behavior</source>
          <target state="translated">F.8.3. 문자열 비교 동작</target>
        </trans-unit>
        <trans-unit id="0638e188511f78ff49f7d5f4a67daace014f9f04" translate="yes" xml:space="preserve">
          <source>F.8.4. Limitations</source>
          <target state="translated">F.8.4. 한계</target>
        </trans-unit>
        <trans-unit id="ae62161d7090f631bab8e10ef93e795cb01ae0f1" translate="yes" xml:space="preserve">
          <source>F.8.5. Author</source>
          <target state="translated">F.8.5. 저자</target>
        </trans-unit>
        <trans-unit id="958c63dbb41d34478eb5d9903df2fbfe62fa0232" translate="yes" xml:space="preserve">
          <source>F.9. cube</source>
          <target state="translated">F.9. 입방체</target>
        </trans-unit>
        <trans-unit id="00e2e8ac74d90d0e143f1f95eb3aed8d07fdba6f" translate="yes" xml:space="preserve">
          <source>F.9.1. Syntax</source>
          <target state="translated">F.9.1. 통사론</target>
        </trans-unit>
        <trans-unit id="866d69bd804840afc072e42503476085271a3b11" translate="yes" xml:space="preserve">
          <source>F.9.2. Precision</source>
          <target state="translated">F.9.2. 정도</target>
        </trans-unit>
        <trans-unit id="26b1dd423d59d0ec9d01bc49c61bd2e3a130cde9" translate="yes" xml:space="preserve">
          <source>F.9.3. Usage</source>
          <target state="translated">F.9.3. 용법</target>
        </trans-unit>
        <trans-unit id="c3f5eb1d068801be237889607268f24e6e3ab414" translate="yes" xml:space="preserve">
          <source>F.9.4. Defaults</source>
          <target state="translated">F.9.4. 기본값</target>
        </trans-unit>
        <trans-unit id="e70fe9f6ff69447cd9c1390f81924b15d9d13996" translate="yes" xml:space="preserve">
          <source>F.9.5. Notes</source>
          <target state="translated">F.9.5. 노트</target>
        </trans-unit>
        <trans-unit id="7c4439349b83474406b10addc29c3c8578b55471" translate="yes" xml:space="preserve">
          <source>F.9.6. Credits</source>
          <target state="translated">F.9.6. 크레딧</target>
        </trans-unit>
        <trans-unit id="0ed2d7b5cdb77627bc46c6fac5026ec27b694d42" translate="yes" xml:space="preserve">
          <source>FALSE</source>
          <target state="translated">FALSE</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="a721f50a7a690a4a15e9a37c997197a6892fe7c1" translate="yes" xml:space="preserve">
          <source>FETCH</source>
          <target state="translated">FETCH</target>
        </trans-unit>
        <trans-unit id="89ec4fbb02681a94c7c5aceacee470704677dddd" translate="yes" xml:space="preserve">
          <source>FETCH &amp;mdash; retrieve rows from a query using a cursor</source>
          <target state="translated">FETCH &amp;mdash; 커서를 사용하여 쿼리에서 행을 검색</target>
        </trans-unit>
        <trans-unit id="3528e0aafdb15c80ec4aeb0892214fe763bf95b7" translate="yes" xml:space="preserve">
          <source>FNV-1a hash</source>
          <target state="translated">FNV-1a 해시</target>
        </trans-unit>
        <trans-unit id="eaa03e9feab1e85231315c30a563eae4cc597208" translate="yes" xml:space="preserve">
          <source>FOR KEY SHARE</source>
          <target state="translated">키 쉐어</target>
        </trans-unit>
        <trans-unit id="54a6a18e44a3063d3d591757a74e0cfec02a9176" translate="yes" xml:space="preserve">
          <source>FOR NO KEY UPDATE</source>
          <target state="translated">키 업데이트가없는 경우</target>
        </trans-unit>
        <trans-unit id="6a4900b69d309a0653aa71228c074fde940798c1" translate="yes" xml:space="preserve">
          <source>FOR SHARE</source>
          <target state="translated">공유</target>
        </trans-unit>
        <trans-unit id="380bce20ad76a7dcc21915daa6f049f535f22be2" translate="yes" xml:space="preserve">
          <source>FOR UPDATE</source>
          <target state="translated">업데이트</target>
        </trans-unit>
        <trans-unit id="a1150974d640edc4e9165f393ec148407a36653d" translate="yes" xml:space="preserve">
          <source>FSM</source>
          <target state="translated">FSM</target>
        </trans-unit>
        <trans-unit id="8e4e872b30d442c4d7f1edf2cabdff971300b607" translate="yes" xml:space="preserve">
          <source>Factorial</source>
          <target state="translated">Factorial</target>
        </trans-unit>
        <trans-unit id="924645c3f79b667ca16a56a314836b3bfa6dbb18" translate="yes" xml:space="preserve">
          <source>Factorial (deprecated, use &lt;a href=&quot;functions-math#FUNCTION-FACTORIAL&quot;&gt;&lt;code&gt;factorial()&lt;/code&gt;&lt;/a&gt; instead)</source>
          <target state="translated">팩토리얼 (더 이상 사용되지 않음, 대신 &lt;a href=&quot;functions-math#FUNCTION-FACTORIAL&quot;&gt; &lt;code&gt;factorial()&lt;/code&gt; &lt;/a&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="8f1d586dcf695708e2360bffc16fb3a03770e245" translate="yes" xml:space="preserve">
          <source>Factorial as a prefix operator (deprecated, use &lt;a href=&quot;functions-math#FUNCTION-FACTORIAL&quot;&gt;&lt;code&gt;factorial()&lt;/code&gt;&lt;/a&gt; instead)</source>
          <target state="translated">접두사 연산자로 &lt;a href=&quot;functions-math#FUNCTION-FACTORIAL&quot;&gt; &lt;code&gt;factorial()&lt;/code&gt; &lt;/a&gt; 더 이상 사용되지 않음, 대신 factorial () 사용)</target>
        </trans-unit>
        <trans-unit id="6d272f803d08e8669caa084ab669e54ff905af2c" translate="yes" xml:space="preserve">
          <source>Failover</source>
          <target state="translated">Failover</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="a7120cc7e891f5699da63567561c7d0959631572" translate="yes" xml:space="preserve">
          <source>Features of XQuery beyond those of XPath include:</source>
          <target state="translated">XPath의 기능 외에 XQuery의 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc8415ccfe52505f1d0a74025c76b3c26c88c59d" translate="yes" xml:space="preserve">
          <source>Feb</source>
          <target state="translated">Feb</target>
        </trans-unit>
        <trans-unit id="5c3a35ef85f22d508f90171bdcb2e6d820731d20" translate="yes" xml:space="preserve">
          <source>February</source>
          <target state="translated">February</target>
        </trans-unit>
        <trans-unit id="619eaef9800d32e19402dbff39695c018eaba796" translate="yes" xml:space="preserve">
          <source>Fedora SELinux FAQ</source>
          <target state="translated">Fedora SELinux FAQ</target>
        </trans-unit>
        <trans-unit id="6f0eaf23fd0273cb96743cd0db99201691fbc2ae" translate="yes" xml:space="preserve">
          <source>Fetch all prior rows (scanning backwards).</source>
          <target state="translated">모든 이전 행을 가져옵니다 (뒤로 스캔).</target>
        </trans-unit>
        <trans-unit id="108fc4dc6fa49881adf4bb4eea1cfc55cc99332e" translate="yes" xml:space="preserve">
          <source>Fetch all remaining rows (same as &lt;code&gt;FORWARD ALL&lt;/code&gt;).</source>
          <target state="translated">나머지 모든 행을 가져옵니다 ( &lt;code&gt;FORWARD ALL&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="68bf6e4a1871298e3413b429bc1d1b24a5517a50" translate="yes" xml:space="preserve">
          <source>Fetch all remaining rows.</source>
          <target state="translated">나머지 모든 행을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f3984af856aedf00a083630ebeae90c1c2329b24" translate="yes" xml:space="preserve">
          <source>Fetch all tuples in the given scan and add them to the caller-supplied &lt;code&gt;TIDBitmap&lt;/code&gt; (that is, OR the set of tuple IDs into whatever set is already in the bitmap). The number of tuples fetched is returned (this might be just an approximate count, for instance some AMs do not detect duplicates). While inserting tuple IDs into the bitmap, &lt;code&gt;amgetbitmap&lt;/code&gt; can indicate that rechecking of the scan conditions is required for specific tuple IDs. This is analogous to the &lt;code&gt;xs_recheck&lt;/code&gt; output parameter of &lt;code&gt;amgettuple&lt;/code&gt;. Note: in the current implementation, support for this feature is conflated with support for lossy storage of the bitmap itself, and therefore callers recheck both the scan conditions and the partial index predicate (if any) for recheckable tuples. That might not always be true, however. &lt;code&gt;amgetbitmap&lt;/code&gt; and &lt;code&gt;amgettuple&lt;/code&gt; cannot be used in the same index scan; there are other restrictions too when using &lt;code&gt;amgetbitmap&lt;/code&gt;, as explained in &lt;a href=&quot;index-scanning&quot;&gt;Section 61.3&lt;/a&gt;.</source>
          <target state="translated">지정된 스캔에서 모든 튜플을 &lt;code&gt;TIDBitmap&lt;/code&gt; 호출자 제공 TIDBitmap (즉, 이미 비트 맵에있는 모든 세트에 튜플 ID 세트)에 추가합니다. 페치 된 튜플 수를 리턴합니다 (이는 대략적인 수일 수 있습니다 (예 : 일부 AM은 중복을 감지하지 않음)). 튜플 ID를 비트 맵에 삽입하는 동안 &lt;code&gt;amgetbitmap&lt;/code&gt; 은 특정 튜플 ID에 스캔 조건을 다시 확인해야 함을 나타낼 수 있습니다. 이것은 &lt;code&gt;xs_recheck&lt;/code&gt; 의 xs_recheck 출력 매개 변수와 &lt;code&gt;amgettuple&lt;/code&gt; . 참고 : 현재 구현에서이 기능에 대한 지원은 비트 맵 자체의 손실 저장에 대한 지원과 함께 제공되므로 호출자는 다시 검사 가능한 튜플에 대해 스캔 조건과 부분 인덱스 조건 자 (있는 경우)를 다시 확인합니다. 그러나 항상 그런 것은 아닙니다. &lt;code&gt;amgetbitmap&lt;/code&gt; 과 &lt;code&gt;amgettuple&lt;/code&gt; 은 동일한 인덱스 스캔에서 사용할 수 없습니다. &lt;a href=&quot;index-scanning&quot;&gt;섹션 61.3&lt;/a&gt; 에서 설명한 것처럼 &lt;code&gt;amgetbitmap&lt;/code&gt; 을 사용할 때 다른 제한 사항도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f5012398f10dec65c55c3d7896e6e346eff005" translate="yes" xml:space="preserve">
          <source>Fetch missing table information from publisher. This will start replication of tables that were added to the subscribed-to publications since the last invocation of &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; or since &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt;.</source>
          <target state="translated">게시자로부터 누락 된 테이블 정보를 가져옵니다. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 의 마지막 호출 이후 또는 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 이후 구독 된 발행물에 추가 된 테이블의 복제가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="12be322cb6ed809af2a5a44f16e8baee5c640e43" translate="yes" xml:space="preserve">
          <source>Fetch the &lt;code&gt;count&lt;/code&gt;'th row of the query, or the &lt;code&gt;abs(count)&lt;/code&gt;'th row from the end if &lt;code&gt;count&lt;/code&gt; is negative. Position before first row or after last row if &lt;code&gt;count&lt;/code&gt; is out of range; in particular, &lt;code&gt;ABSOLUTE 0&lt;/code&gt; positions before the first row.</source>
          <target state="translated">쿼리 의 &lt;code&gt;count&lt;/code&gt; 번째 행 또는 &lt;code&gt;count&lt;/code&gt; 가 음수 이면 끝에서 &lt;code&gt;abs(count)&lt;/code&gt; '번째 행을 가져옵니다 . &lt;code&gt;count&lt;/code&gt; 가 범위를 벗어난 경우 첫 번째 행 앞 또는 마지막 행 후 위치 ; 특히, &lt;code&gt;ABSOLUTE 0&lt;/code&gt; 은 첫 번째 행 앞에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="ee66ff3651bfa860af594812c7431f4ee88f894d" translate="yes" xml:space="preserve">
          <source>Fetch the &lt;code&gt;count&lt;/code&gt;'th succeeding row, or the &lt;code&gt;abs(count)&lt;/code&gt;'th prior row if &lt;code&gt;count&lt;/code&gt; is negative. &lt;code&gt;RELATIVE 0&lt;/code&gt; re-fetches the current row, if any.</source>
          <target state="translated">페치 &lt;code&gt;count&lt;/code&gt; '번째 이후의 행 또는 &lt;code&gt;abs(count)&lt;/code&gt; '일 경우 종래의 행 &lt;code&gt;count&lt;/code&gt; 부정한다. &lt;code&gt;RELATIVE 0&lt;/code&gt; 은 현재 행을 다시 가져옵니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="ff4caca2298e6b2a18643be90f1ff4dbe3a2d96e" translate="yes" xml:space="preserve">
          <source>Fetch the first row of the query (same as &lt;code&gt;ABSOLUTE 1&lt;/code&gt;).</source>
          <target state="translated">쿼리의 첫 번째 행을 가져옵니다 ( &lt;code&gt;ABSOLUTE 1&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="c37af31bfc90a72a2a5d248d807ee535ad9886dc" translate="yes" xml:space="preserve">
          <source>Fetch the last row of the query (same as &lt;code&gt;ABSOLUTE -1&lt;/code&gt;).</source>
          <target state="translated">쿼리의 마지막 행을 가져옵니다 ( &lt;code&gt;ABSOLUTE -1&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="015f0234c411ae45e9fbeb4f8e7749dee5090740" translate="yes" xml:space="preserve">
          <source>Fetch the next &lt;code&gt;count&lt;/code&gt; rows (same as &lt;code&gt;FORWARD count&lt;/code&gt;).</source>
          <target state="translated">다음 &lt;code&gt;count&lt;/code&gt; 행을 가져옵니다 ( &lt;code&gt;FORWARD count&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="37e8b8482794ca9076e152cf1e93a0dabc1fc631" translate="yes" xml:space="preserve">
          <source>Fetch the next &lt;code&gt;count&lt;/code&gt; rows. &lt;code&gt;FORWARD 0&lt;/code&gt; re-fetches the current row.</source>
          <target state="translated">다음 &lt;code&gt;count&lt;/code&gt; 행을 가져옵니다 . &lt;code&gt;FORWARD 0&lt;/code&gt; 은 현재 행을 다시 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bc7db6c5bb73a28b60746aa4dd9afa53ace9b03e" translate="yes" xml:space="preserve">
          <source>Fetch the next row (same as &lt;code&gt;NEXT&lt;/code&gt;).</source>
          <target state="translated">다음 행을 가져옵니다 ( &lt;code&gt;NEXT&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="b59bd04fef728ce25c648534357dff558bc4035b" translate="yes" xml:space="preserve">
          <source>Fetch the next row. This is the default if &lt;code&gt;direction&lt;/code&gt; is omitted.</source>
          <target state="translated">다음 행을 가져옵니다. &lt;code&gt;direction&lt;/code&gt; 이 생략 된 경우 이것이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="959aabca02277db50f570abe9b455e7f6b7b5ed0" translate="yes" xml:space="preserve">
          <source>Fetch the next tuple in the given scan, moving in the given direction (forward or backward in the index). Returns true if a tuple was obtained, false if no matching tuples remain. In the true case the tuple TID is stored into the &lt;code&gt;scan&lt;/code&gt; structure. Note that &amp;ldquo;success&amp;rdquo; means only that the index contains an entry that matches the scan keys, not that the tuple necessarily still exists in the heap or will pass the caller's snapshot test. On success, &lt;code&gt;amgettuple&lt;/code&gt; must also set &lt;code&gt;scan-&amp;gt;xs_recheck&lt;/code&gt; to true or false. False means it is certain that the index entry matches the scan keys. True means this is not certain, and the conditions represented by the scan keys must be rechecked against the heap tuple after fetching it. This provision supports &amp;ldquo;lossy&amp;rdquo; index operators. Note that rechecking will extend only to the scan conditions; a partial index predicate (if any) is never rechecked by &lt;code&gt;amgettuple&lt;/code&gt; callers.</source>
          <target state="translated">주어진 방향 (인덱스에서 앞으로 또는 뒤로)으로 이동하여 주어진 스캔에서 다음 튜플을 가져옵니다. 튜플을 얻었 으면 true를 반환하고, 일치하는 튜플이 남아 있지 않으면 false를 반환합니다. 실제 경우 튜플 TID는 &lt;code&gt;scan&lt;/code&gt; 구조에 저장됩니다 . &quot;성공&quot;은 인덱스에 스캔 키와 일치하는 항목이 포함되어 있음을 의미하며, 튜플이 반드시 힙에 존재하거나 호출자의 스냅 샷 테스트를 통과한다는 의미는 아닙니다. 성공하면 &lt;code&gt;amgettuple&lt;/code&gt; 도 &lt;code&gt;scan-&amp;gt;xs_recheck&lt;/code&gt; 를 설정해야합니다.참 또는 거짓. False는 색인 항목이 스캔 키와 일치 함을 의미합니다. True는 이것이 확실하지 않음을 의미하며 스캔 키가 나타내는 조건을 가져온 후 힙 튜플에 대해 다시 확인해야합니다. 이 조항은 &quot;손실&quot;인덱스 연산자를 지원합니다. 재확인은 스캔 조건으로 만 확장됩니다. 부분 색인 술어 (있는 경우)는 &lt;code&gt;amgettuple&lt;/code&gt; 호출자에 의해 다시 확인되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b9e61f7e1ebaad2cb2dddb47d03889f358a882d6" translate="yes" xml:space="preserve">
          <source>Fetch the next tuple in the given scan, moving in the given direction (forward or backward in the index). Returns true if a tuple was obtained, false if no matching tuples remain. In the true case the tuple TID is stored into the &lt;code&gt;scan&lt;/code&gt; structure. Note that &amp;ldquo;success&amp;rdquo; means only that the index contains an entry that matches the scan keys, not that the tuple necessarily still exists in the heap or will pass the caller's snapshot test. On success, &lt;code&gt;amgettuple&lt;/code&gt; must also set &lt;code&gt;scan-&amp;gt;xs_recheck&lt;/code&gt; to true or false. False means it is certain that the index entry matches the scan keys. true means this is not certain, and the conditions represented by the scan keys must be rechecked against the heap tuple after fetching it. This provision supports &amp;ldquo;lossy&amp;rdquo; index operators. Note that rechecking will extend only to the scan conditions; a partial index predicate (if any) is never rechecked by &lt;code&gt;amgettuple&lt;/code&gt; callers.</source>
          <target state="translated">주어진 방향으로 (인덱스에서 앞뒤로) 이동하여 주어진 스캔에서 다음 튜플을 가져옵니다. 튜플을 얻은 경우 true를, 일치하는 튜플이 남아 있지 않으면 false를 반환합니다. 실제 경우에 튜플 TID는 &lt;code&gt;scan&lt;/code&gt; 구조에 저장됩니다 . &quot;성공&quot;은 인덱스에 스캔 키와 일치하는 항목 만 포함하고 튜플이 여전히 힙에 있거나 호출자의 스냅 샷 테스트를 통과하지는 않는다는 것을 의미합니다. 성공하면 &lt;code&gt;amgettuple&lt;/code&gt; 도 &lt;code&gt;scan-&amp;gt;xs_recheck&lt;/code&gt; 를 설정해야합니다.참 또는 거짓으로. False는 인덱스 항목이 스캔 키와 일치 함을 의미합니다. true는 이것이 확실하지 않음을 의미하며 스캔 키로 표시되는 조건은 페치 후에 힙 튜플에 대해 다시 확인해야합니다. 이 조항은 &quot;손실&quot;인덱스 연산자를 지원합니다. 다시 확인하면 스캔 조건까지만 확장됩니다. &lt;code&gt;amgettuple&lt;/code&gt; 호출자 가 부분 인덱스 술어 (있는 경우)를 다시 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="794747f1afd7ec6cd3112f0f3646aa022d474d36" translate="yes" xml:space="preserve">
          <source>Fetch the prior &lt;code&gt;count&lt;/code&gt; rows (scanning backwards). &lt;code&gt;BACKWARD 0&lt;/code&gt; re-fetches the current row.</source>
          <target state="translated">이전 &lt;code&gt;count&lt;/code&gt; 행을 가져옵니다 (뒤로 스캔). &lt;code&gt;BACKWARD 0&lt;/code&gt; 은 현재 행을 다시 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="47567c2261024838c3ac160fffc8a3cee3c387c3" translate="yes" xml:space="preserve">
          <source>Fetch the prior row (same as &lt;code&gt;PRIOR&lt;/code&gt;).</source>
          <target state="translated">이전 행을 가져옵니다 ( &lt;code&gt;PRIOR&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="48d3a55ee879a7ef23c7fe13e569066bdb53be52" translate="yes" xml:space="preserve">
          <source>Fetch the prior row.</source>
          <target state="translated">이전 행을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c326a4660b674d2f6ea82687a1e1abae2337541f" translate="yes" xml:space="preserve">
          <source>Field</source>
          <target state="translated">Field</target>
        </trans-unit>
        <trans-unit id="1e2d2a8e9ba1e96bec6ca1b3b3837c537bc64ff3" translate="yes" xml:space="preserve">
          <source>Field values that are OIDs of other catalog entries should be represented by symbolic names rather than actual numeric OIDs. (In the example above, &lt;code&gt;dattablespace&lt;/code&gt; contains such a reference.) This is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-REFERENCES&quot;&gt;Section 69.2.3&lt;/a&gt; below.</source>
          <target state="translated">다른 카탈로그 항목의 OID 인 필드 값은 실제 숫자 OID가 아닌 기호 이름으로 표시되어야합니다. (위의 예에서, &lt;code&gt;dattablespace&lt;/code&gt; 는 그러한 참조를 포함합니다.) 이것은 아래 &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-REFERENCES&quot;&gt;69.2.3 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="0d12a3f0ea99ebe85fe967431fc2aa6a3e0fd02b" translate="yes" xml:space="preserve">
          <source>File Formats</source>
          <target state="translated">파일 형식</target>
        </trans-unit>
        <trans-unit id="82598273eeb580afccf97b6a25626aefaef910ed" translate="yes" xml:space="preserve">
          <source>File Header</source>
          <target state="translated">파일 헤더</target>
        </trans-unit>
        <trans-unit id="83cab9651541d6505641439c0f1356ce8d3d088c" translate="yes" xml:space="preserve">
          <source>File Locations</source>
          <target state="translated">파일 위치</target>
        </trans-unit>
        <trans-unit id="aeac4db7a64d853e4153f7b1cd002ebc7db03bcc" translate="yes" xml:space="preserve">
          <source>File System (Block Device) Replication</source>
          <target state="translated">파일 시스템 (블록 장치) 복제</target>
        </trans-unit>
        <trans-unit id="f05e38d3789ebad590246017f1a1bf01f9623718" translate="yes" xml:space="preserve">
          <source>File System Level Backup</source>
          <target state="translated">파일 시스템 레벨 백업</target>
        </trans-unit>
        <trans-unit id="90b7432bde6739e45805ab710dca13a0768c675a" translate="yes" xml:space="preserve">
          <source>File System Repl.</source>
          <target state="translated">파일 시스템 Repl.</target>
        </trans-unit>
        <trans-unit id="d72a124d87b5deba4a9972d8918749069bf98f69" translate="yes" xml:space="preserve">
          <source>File System Replication</source>
          <target state="translated">파일 시스템 복제</target>
        </trans-unit>
        <trans-unit id="aa5dc4b3bb787c150f84e5b8a9676302a4dddb66" translate="yes" xml:space="preserve">
          <source>File Trailer</source>
          <target state="translated">파일 예고편</target>
        </trans-unit>
        <trans-unit id="ff8be812330ed8eb012f7d2b99ed4048f24d67ce" translate="yes" xml:space="preserve">
          <source>File cloning is only supported on some operating systems and file systems. If it is selected but not supported, the pg_upgrade run will error. At present, it is supported on Linux (kernel 4.5 or later) with Btrfs and XFS (on file systems created with reflink support), and on macOS with APFS.</source>
          <target state="translated">파일 복제는 일부 운영 체제 및 파일 시스템에서만 지원됩니다. 선택되었지만 지원되지 않으면 pg_upgrade 실행에 오류가 발생합니다. 현재 Btrfs 및 XFS (reflink 지원으로 작성된 파일 시스템)가있는 Linux (커널 4.5 이상) 및 APFS가있는 macOS에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5afa53bb0ce293865ce8fe12e6764e92b21d55e8" translate="yes" xml:space="preserve">
          <source>File or path name</source>
          <target state="translated">파일 또는 경로 이름</target>
        </trans-unit>
        <trans-unit id="169f20cb38c9875b8d9b6448cf77ebcb49f4b735" translate="yes" xml:space="preserve">
          <source>File path name of the specified relation</source>
          <target state="translated">지정된 관계의 파일 경로 이름</target>
        </trans-unit>
        <trans-unit id="b5a241a4e88dea37ff234e6325621f35e769b187" translate="yes" xml:space="preserve">
          <source>File recording the log file(s) currently written to by the logging collector</source>
          <target state="translated">로깅 수집기에서 현재 기록한 로그 파일을 기록하는 파일</target>
        </trans-unit>
        <trans-unit id="647ea13825f77afc3eec7ae59500a5b815ca8243" translate="yes" xml:space="preserve">
          <source>File segment</source>
          <target state="translated">파일 세그먼트</target>
        </trans-unit>
        <trans-unit id="8ebef13d126d46f9fd475e2e699e8aedad4eaa96" translate="yes" xml:space="preserve">
          <source>File system or storage subsystem faults where checksums happen to simply not be enabled.</source>
          <target state="translated">체크섬이 단순히 활성화되지 않는 파일 시스템 또는 스토리지 서브 시스템 결함.</target>
        </trans-unit>
        <trans-unit id="20e9dc282b64930c018dbbdebd189a315da71641" translate="yes" xml:space="preserve">
          <source>Filenode number of the relation</source>
          <target state="translated">관계의 파일 노드 번호</target>
        </trans-unit>
        <trans-unit id="dd7b439ca5a5202bf813b7c741151de540088b41" translate="yes" xml:space="preserve">
          <source>Filenode number of the specified relation</source>
          <target state="translated">지정된 관계의 파일 노드 번호</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="a827ddc455c062dd8bc05525342358ed28649c99" translate="yes" xml:space="preserve">
          <source>Files included by &lt;code&gt;@&lt;/code&gt; constructs are read as lists of names, which can be separated by either whitespace or commas. Comments are introduced by &lt;code&gt;#&lt;/code&gt;, just as in &lt;code&gt;pg_hba.conf&lt;/code&gt;, and nested &lt;code&gt;@&lt;/code&gt; constructs are allowed. Unless the file name following &lt;code&gt;@&lt;/code&gt; is an absolute path, it is taken to be relative to the directory containing the referencing file.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 구문에 포함 된 파일 은 이름 목록으로 읽 히며 공백 또는 쉼표로 구분할 수 있습니다. 주석은 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에서처럼 &lt;code&gt;#&lt;/code&gt; 에 의해 소개되며 중첩 된 &lt;code&gt;@&lt;/code&gt; 구문이 허용됩니다. &lt;code&gt;@&lt;/code&gt; 다음에 오는 파일 이름 이 절대 경로가 아닌 경우 참조 파일을 포함하는 디렉토리에 상대적인 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f684d3f323220fd489978388c876711f71f0edd9" translate="yes" xml:space="preserve">
          <source>Files named in a &lt;code&gt;COPY&lt;/code&gt; command are read or written directly by the server, not by the client application. Therefore, they must reside on or be accessible to the database server machine, not the client. They must be accessible to and readable or writable by the PostgreSQL user (the user ID the server runs as), not the client. Similarly, the command specified with &lt;code&gt;PROGRAM&lt;/code&gt; is executed directly by the server, not by the client application, must be executable by the PostgreSQL user. &lt;code&gt;COPY&lt;/code&gt; naming a file or command is only allowed to database superusers or users who are granted one of the default roles &lt;code&gt;pg_read_server_files&lt;/code&gt;, &lt;code&gt;pg_write_server_files&lt;/code&gt;, or &lt;code&gt;pg_execute_server_program&lt;/code&gt;, since it allows reading or writing any file or running a program that the server has privileges to access.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 명령으로 이름 지정된 파일 은 클라이언트 응용 프로그램이 아닌 서버에서 직접 읽거나 씁니다. 따라서 클라이언트가 아닌 데이터베이스 서버 시스템에 상주하거나 액세스 할 수 있어야합니다. 클라이언트가 아닌 PostgreSQL 사용자 (서버가 실행하는 사용자 ID)가 액세스하고 읽고 쓸 수 있어야합니다. 마찬가지로 &lt;code&gt;PROGRAM&lt;/code&gt; 으로 지정된 명령 은 클라이언트 응용 프로그램이 아닌 서버에서 직접 실행되며 PostgreSQL 사용자가 실행할 수 있어야합니다. &lt;code&gt;COPY&lt;/code&gt; 파일이나 명령 이름은 기본 역할 중 하나를 부여 데이터베이스 슈퍼 유저 또는 사용자에게 허용 &lt;code&gt;pg_read_server_files&lt;/code&gt; , &lt;code&gt;pg_write_server_files&lt;/code&gt; , 또는 &lt;code&gt;pg_execute_server_program&lt;/code&gt; 서버가 액세스 권한을 가진 파일을 읽거나 쓰거나 프로그램을 실행할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b8f791813a640903c10ebc229e20037ce8247e20" translate="yes" xml:space="preserve">
          <source>Fill up the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; to length &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; by appending the characters &lt;em&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/em&gt; (a space by default). If the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; is already longer than &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; then it is truncated.</source>
          <target state="translated">문자 &lt;em&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/em&gt; (기본적으로 공백)을 추가 하여 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 을 길이 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 로 &lt;em&gt;채 웁니다&lt;/em&gt; . 는 IF &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 이상 이미 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 후 잘립니다.</target>
        </trans-unit>
        <trans-unit id="f60bc3c5f471357d3405d7e2039ebf2a3c18f421" translate="yes" xml:space="preserve">
          <source>Fill up the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; to length &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; by prepending the characters &lt;em&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/em&gt; (a space by default). If the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; is already longer than &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; then it is truncated (on the right).</source>
          <target state="translated">문자 &lt;em&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/em&gt; 를 앞에 추가 하여 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 을 길이 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 로 &lt;em&gt;채 웁니다&lt;/em&gt; (기본적으로 공백). 는 IF &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 보다 이미 더 이상 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 다음은 (오른쪽) 잘립니다.</target>
        </trans-unit>
        <trans-unit id="3bb8242ee5d5ce7bcf8ba7f71d1da0e8901d9a45" translate="yes" xml:space="preserve">
          <source>Filter expressions must be specified right after the path evaluation step to which they are applied. The result of this step is filtered to include only those items that satisfy the provided condition. SQL/JSON defines three-valued logic, so the condition can be &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or &lt;code&gt;unknown&lt;/code&gt;. The &lt;code&gt;unknown&lt;/code&gt; value plays the same role as SQL &lt;code&gt;NULL&lt;/code&gt; and can be tested for with the &lt;code&gt;is unknown&lt;/code&gt; predicate. Further path evaluation steps use only those items for which filter expressions return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">필터 표현식은 적용되는 경로 평가 단계 직후에 지정해야합니다. 이 단계의 결과는 제공된 조건을 만족하는 항목 만 포함하도록 필터링됩니다. SQL / JSON은 3 값 논리를 정의하므로 조건이 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;unknown&lt;/code&gt; 일 수 있습니다. &lt;code&gt;unknown&lt;/code&gt; 값은 SQL과 같은 역할을한다 &lt;code&gt;NULL&lt;/code&gt; 을 하고 함께 테스트 할 수있는 &lt;code&gt;is unknown&lt;/code&gt; 조건. 추가 경로 평가 단계는 필터 표현식이 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 항목 만 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="2431e3f17245a827fda6d1a0fa7059f22c4c6385" translate="yes" xml:space="preserve">
          <source>Filter expressions must be written just after the path evaluation step to which they should apply. The result of that step is filtered to include only those items that satisfy the provided condition. SQL/JSON defines three-valued logic, so the condition can be &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or &lt;code&gt;unknown&lt;/code&gt;. The &lt;code&gt;unknown&lt;/code&gt; value plays the same role as SQL &lt;code&gt;NULL&lt;/code&gt; and can be tested for with the &lt;code&gt;is unknown&lt;/code&gt; predicate. Further path evaluation steps use only those items for which the filter expression returned &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">필터 표현식은 적용해야하는 경로 평가 단계 직후에 작성해야합니다. 해당 단계의 결과는 제공된 조건을 충족하는 항목 만 포함하도록 필터링됩니다. SQL / JSON은 3 개 값 논리를 정의하므로 조건은 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;unknown&lt;/code&gt; 일 수 있습니다. &lt;code&gt;unknown&lt;/code&gt; 값은 SQL과 같은 역할을한다 &lt;code&gt;NULL&lt;/code&gt; 을 하고 함께 테스트 할 수있는 &lt;code&gt;is unknown&lt;/code&gt; 조건. 추가 경로 평가 단계에서는 필터 표현식이 &lt;code&gt;true&lt;/code&gt; 를 반환 한 항목 만 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="674a4d37699655591bca2da4bc50c7669f40486b" translate="yes" xml:space="preserve">
          <source>Final function (zero if none)</source>
          <target state="translated">최종 함수 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="b2f2ce3bfb7523b2f652baed7eac39cf356a1244" translate="yes" xml:space="preserve">
          <source>Final function for moving-aggregate mode (zero if none)</source>
          <target state="translated">이동 집계 모드의 최종 기능 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="53ed47c708396102af0c273ef92199955b450206" translate="yes" xml:space="preserve">
          <source>Finally we will examine a query that involves a join:</source>
          <target state="translated">마지막으로 조인과 관련된 쿼리를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="0bbec6f2250a9fe7d7708ab9ef4e5e279e682b97" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;NATURAL&lt;/code&gt; is a shorthand form of &lt;code&gt;USING&lt;/code&gt;: it forms a &lt;code&gt;USING&lt;/code&gt; list consisting of all column names that appear in both input tables. As with &lt;code&gt;USING&lt;/code&gt;, these columns appear only once in the output table. If there are no common column names, &lt;code&gt;NATURAL JOIN&lt;/code&gt; behaves like &lt;code&gt;JOIN ... ON TRUE&lt;/code&gt;, producing a cross-product join.</source>
          <target state="translated">마지막으로, &lt;code&gt;NATURAL&lt;/code&gt; 은 &lt;code&gt;USING&lt;/code&gt; 의 약식 입니다. 두 입력 테이블 모두에 나타나는 모든 열 이름으로 구성된 &lt;code&gt;USING&lt;/code&gt; 목록을 형성합니다 . &lt;code&gt;USING&lt;/code&gt; 과 마찬가지로이 열은 출력 테이블에 한 번만 나타납니다. 공통 열 이름이 없으면 &lt;code&gt;NATURAL JOIN&lt;/code&gt; 은 &lt;code&gt;JOIN ... ON TRUE&lt;/code&gt; 와 같이 동작 하여 교차 제품 조인을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9fa37f3708890cf7cf6993c4da83cb438ec44e25" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;pg_verifybackup&lt;/code&gt; will use the manifest to verify that the write-ahead log records which will be needed to recover the backup are present and that they can be read and parsed. The &lt;code&gt;backup_manifest&lt;/code&gt; contains information about which write-ahead log records will be needed, and &lt;code&gt;pg_verifybackup&lt;/code&gt; will use that information to invoke &lt;code&gt;pg_waldump&lt;/code&gt; to parse those write-ahead log records. The &lt;code&gt;--quiet&lt;/code&gt; flag will be used, so that &lt;code&gt;pg_waldump&lt;/code&gt; will only report errors, without producing any other output. While this level of verification is sufficient to detect obvious problems such as a missing file or one whose internal checksums do not match, they aren't extensive enough to detect every possible problem that might occur when attempting to recover. For instance, a server bug that produces write-ahead log records that have the correct checksums but specify nonsensical actions can't be detected by this method.</source>
          <target state="translated">마지막으로, &lt;code&gt;pg_verifybackup&lt;/code&gt; 은 매니페스트를 사용하여 백업을 복구하는 데 필요한 미리 쓰기 로그 레코드가 있는지, 그리고이를 읽고 구문 분석 할 수 있는지 확인합니다. &lt;code&gt;backup_manifest&lt;/code&gt; 는 미리 쓰기 기록이 필요합니다 로그인하고있는 대한 정보가 포함 &lt;code&gt;pg_verifybackup&lt;/code&gt; 가 호출에 해당 정보를 사용합니다 &lt;code&gt;pg_waldump&lt;/code&gt; 그 미리 쓰기 로그 기록을 구문 분석합니다. &lt;code&gt;--quiet&lt;/code&gt; 플래그는되도록 사용됩니다 &lt;code&gt;pg_waldump&lt;/code&gt; 다른 출력을 생성하지 않고 오류 만보고합니다. 이 수준의 확인은 누락 된 파일 또는 내부 체크섬이 일치하지 않는 문제와 같은 명백한 문제를 감지하는 데 충분하지만 복구를 시도 할 때 발생할 수있는 모든 가능한 문제를 감지 할만큼 광범위하지는 않습니다. 예를 들어, 올바른 체크섬이 있지만 의미없는 작업을 지정하는 미리 쓰기 로그 레코드를 생성하는 서버 버그는이 방법으로 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8076b2f8f80def5a9432bb881260d2bb11a414af" translate="yes" xml:space="preserve">
          <source>Finally, a partial index can also be used to override the system's query plan choices. Also, data sets with peculiar distributions might cause the system to use an index when it really should not. In that case the index can be set up so that it is not available for the offending query. Normally, PostgreSQL makes reasonable choices about index usage (e.g., it avoids them when retrieving common values, so the earlier example really only saves index size, it is not required to avoid index usage), and grossly incorrect plan choices are cause for a bug report.</source>
          <target state="translated">마지막으로, 부분 인덱스를 사용하여 시스템의 쿼리 계획 선택을 무시할 수도 있습니다. 또한 고유 한 분포를 가진 데이터 세트로 인해 시스템이 실제로 사용하지 않아야 할 때 인덱스를 사용할 수 있습니다. 이 경우 문제가되는 쿼리에 인덱스를 사용할 수 없도록 인덱스를 설정할 수 있습니다. 일반적으로 PostgreSQL은 인덱스 사용에 대해 합리적인 선택을합니다 (예 : 공통 값을 검색 할 때이를 피하므로 앞의 예제는 실제로 인덱스 크기 만 저장하고 인덱스 사용을 피할 필요는 없습니다). 그리고 잘못된 계획 선택은 버그의 원인입니다. 보고서.</target>
        </trans-unit>
        <trans-unit id="86ba78973aa60c7a6565a34b0ffa02800cf420f9" translate="yes" xml:space="preserve">
          <source>Finally, create a server certificate signed by the new root certificate authority:</source>
          <target state="translated">마지막으로, 새로운 루트 인증 기관이 서명 한 서버 인증서를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="15ed2ff4f015b0482bf51e69c35c5b895d26b77c" translate="yes" xml:space="preserve">
          <source>Finally, in an ARE, outside bracket expressions, the sequence &lt;code&gt;(?#&lt;/code&gt;&lt;code&gt;ttt&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;ttt&lt;/code&gt; is any text not containing a &lt;code&gt;)&lt;/code&gt;) is a comment, completely ignored. Again, this is not allowed between the characters of multi-character symbols, like &lt;code&gt;(?:&lt;/code&gt;. Such comments are more a historical artifact than a useful facility, and their use is deprecated; use the expanded syntax instead.</source>
          <target state="translated">마지막으로 ARE 외부 괄호 표현식에서 시퀀스 &lt;code&gt;(?#&lt;/code&gt; &lt;code&gt;ttt&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; (여기서 &lt;code&gt;ttt&lt;/code&gt; 는을 포함하지 않는 텍스트 &lt;code&gt;)&lt;/code&gt; )는 주석이며 완전히 무시됩니다. 다시 말하지만 &lt;code&gt;(?:&lt;/code&gt; . 와 같은 다중 문자 기호 문자 사이에는 허용되지 않습니다 . 이러한 주석은 유용한 기능보다 역사적인 유물이므로 더 이상 사용되지 않습니다. 대신 확장 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7d5dc7a4d442f90df516e6bebea9b72e06fbc64" translate="yes" xml:space="preserve">
          <source>Finally, it should be mentioned that if you don't need a table any longer or want to recreate it differently you can remove it using the following command:</source>
          <target state="translated">마지막으로, 더 이상 테이블이 필요하지 않거나 다르게 다시 작성하려는 경우 다음 명령을 사용하여 테이블을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0593833ae070eb8197fa796874b0e02ac1b71abc" translate="yes" xml:space="preserve">
          <source>Finally, restore your data from backup with:</source>
          <target state="translated">마지막으로 다음을 사용하여 백업에서 데이터를 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="612e83a4042e46de0c9a02f14b12eb7806a107e9" translate="yes" xml:space="preserve">
          <source>Finally, run &lt;code&gt;make reformat-dat-files&lt;/code&gt; to remove the useless old entries from &lt;code&gt;pg_proc.dat&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;make reformat-dat-files&lt;/code&gt; 를 실행 하여 &lt;code&gt;pg_proc.dat&lt;/code&gt; 에서 쓸모없는 오래된 항목을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f44e5621a7452438120d0ba556957913fe9053b" translate="yes" xml:space="preserve">
          <source>Finally, run the regression test script:</source>
          <target state="translated">마지막으로 회귀 테스트 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e18f0fdeaf348134e3044f2eab682793c70b9d83" translate="yes" xml:space="preserve">
          <source>Finally, when the authentication exchange is completed successfully, the server sends an AuthenticationSASLFinal message, followed immediately by an AuthenticationOk message. The AuthenticationSASLFinal contains additional server-to-client data, whose content is particular to the selected authentication mechanism. If the authentication mechanism doesn't use additional data that's sent at completion, the AuthenticationSASLFinal message is not sent.</source>
          <target state="translated">마지막으로 인증 교환이 성공적으로 완료되면 서버는 AuthenticationSASLFinal 메시지를 보낸 다음 AuthenticationOk 메시지를 즉시 보냅니다. AuthenticationSASLFinal에는 추가 서버-클라이언트 데이터가 포함되어 있으며 해당 컨텐츠는 선택된 인증 메커니즘에 따라 다릅니다. 인증 메커니즘이 완료시 전송 된 추가 데이터를 사용하지 않으면 AuthenticationSASLFinal 메시지가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16fed1b1ce9d7613dbd3436ad2e1dd85f771ac9d" translate="yes" xml:space="preserve">
          <source>Find the relation associated with a given tablespace and filenode</source>
          <target state="translated">주어진 테이블 스페이스 및 파일 노드와 관련된 관계 찾기</target>
        </trans-unit>
        <trans-unit id="4351167b6edda62343061bf1021443ffaded3a99" translate="yes" xml:space="preserve">
          <source>Finish performing exclusive on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">단독 온라인 백업 수행 완료 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음)</target>
        </trans-unit>
        <trans-unit id="28837b5e432b22380e4a6b15ce9678ae92f06934" translate="yes" xml:space="preserve">
          <source>Finish performing exclusive or non-exclusive on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">단독 또는 비 독점 온라인 백업 수행 완료 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음)</target>
        </trans-unit>
        <trans-unit id="d3fbb64609256d4773c35f81da7596ecdf86e79b" translate="yes" xml:space="preserve">
          <source>Finishes performing an exclusive on-line backup. This simplified version is equivalent to &lt;code&gt;pg_stop_backup(true, true)&lt;/code&gt;, except that it only returns the &lt;code&gt;pg_lsn&lt;/code&gt; result.</source>
          <target state="translated">독점 온라인 백업 수행을 완료합니다. 이 단순화 된 버전은 &lt;code&gt;pg_lsn&lt;/code&gt; 결과 만 반환한다는 점을 제외하면 &lt;code&gt;pg_stop_backup(true, true)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3d4f2d7707af54483829dde500f95e74fab6f363" translate="yes" xml:space="preserve">
          <source>Finishes performing an exclusive or non-exclusive on-line backup. The &lt;em&gt;&lt;code&gt;exclusive&lt;/code&gt;&lt;/em&gt; parameter must match the previous &lt;code&gt;pg_start_backup&lt;/code&gt; call. In an exclusive backup, &lt;code&gt;pg_stop_backup&lt;/code&gt; removes the backup label file and, if it exists, the tablespace map file created by &lt;code&gt;pg_start_backup&lt;/code&gt;. In a non-exclusive backup, the desired contents of these files are returned as part of the result of the function, and should be written to files in the backup area (not in the data directory).</source>
          <target state="translated">배타적 또는 비 배타적 온라인 백업 수행을 완료합니다. &lt;em&gt; &lt;code&gt;exclusive&lt;/code&gt; &lt;/em&gt; 매개 변수는 이전과 일치해야 &lt;code&gt;pg_start_backup&lt;/code&gt; 의 전화를. 배타적 백업에서 &lt;code&gt;pg_stop_backup&lt;/code&gt; 은 백업 레이블 파일과 존재하는 경우 &lt;code&gt;pg_start_backup&lt;/code&gt; 에 의해 생성 된 테이블 스페이스 맵 파일을 제거합니다 . 비 독점 백업에서 이러한 파일의 원하는 내용은 기능 결과의 일부로 반환되며 데이터 디렉토리가 아닌 백업 영역의 파일에 기록되어야합니다.</target>
        </trans-unit>
        <trans-unit id="680f8d6a1be590a645a63ba3165212f3150701e2" translate="yes" xml:space="preserve">
          <source>Finite line segment</source>
          <target state="translated">유한 한 선분</target>
        </trans-unit>
        <trans-unit id="6dd4b1fa37883a130370f1fbf1595d8ffda7a5a6" translate="yes" xml:space="preserve">
          <source>First as-yet-unassigned txid. All txids greater than or equal to this are not yet started as of the time of the snapshot, and thus invisible.</source>
          <target state="translated">아직 할당되지 않은 txid입니다. 이보다 크거나 같은 모든 txid는 아직 스냅 샷 시점에 시작되지 않았으므로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a92b72f69ca6ff6bb186f802066ae0391ebc94d0" translate="yes" xml:space="preserve">
          <source>First make sure that an SSH server is running properly on the same machine as the PostgreSQL server and that you can log in using &lt;code&gt;ssh&lt;/code&gt; as some user. Then you can establish a secure tunnel with a command like this from the client machine:</source>
          <target state="translated">먼저 SSH 서버가 PostgreSQL 서버와 동일한 시스템에서 제대로 실행되고 있고 일부 사용자로 &lt;code&gt;ssh&lt;/code&gt; 를 사용하여 로그인 할 수 있는지 확인하십시오 . 그런 다음 클라이언트 시스템에서 다음과 같은 명령으로 보안 터널을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d522fbe472ed0681428f0971fcafeedd2205bbd0" translate="yes" xml:space="preserve">
          <source>First make sure that an SSH server is running properly on the same machine as the PostgreSQL server and that you can log in using &lt;code&gt;ssh&lt;/code&gt; as some user; you then can establish a secure tunnel to the remote server. A secure tunnel listens on a local port and forwards all traffic to a port on the remote machine. Traffic sent to the remote port can arrive on its &lt;code&gt;localhost&lt;/code&gt; address, or different bind address if desired; it does not appear as coming from your local machine. This command creates a secure tunnel from the client machine to the remote machine &lt;code&gt;foo.com&lt;/code&gt;:</source>
          <target state="translated">먼저 SSH 서버가 PostgreSQL 서버와 동일한 시스템에서 제대로 실행되고 있는지 , 일부 사용자로 &lt;code&gt;ssh&lt;/code&gt; 를 사용하여 로그인 할 수 있는지 확인하십시오 . 그런 다음 원격 서버에 대한 보안 터널을 설정할 수 있습니다. 보안 터널은 로컬 포트에서 수신 대기하고 모든 트래픽을 원격 시스템의 포트로 전달합니다. 원격 포트로 전송 된 트래픽은 &lt;code&gt;localhost&lt;/code&gt; 주소 또는 원하는 경우 다른 바인드 주소 에 도착할 수 있습니다 . 로컬 시스템에서 오는 것으로 나타나지 않습니다. 이 명령은 클라이언트 시스템에서 원격 시스템 &lt;code&gt;foo.com&lt;/code&gt; 으로 의 보안 터널을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ce51821c54f1d7bdbd595d320e5ee7c12e340da7" translate="yes" xml:space="preserve">
          <source>First set the configuration options in &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 구성 옵션을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4c575efa87d0a2df5442b6dd3794eb5790de14d" translate="yes" xml:space="preserve">
          <source>First timeline number used when WAL receiver is started</source>
          <target state="translated">WAL 수신기가 시작될 때 사용 된 첫 번째 타임 라인 번호</target>
        </trans-unit>
        <trans-unit id="da1cd65fbb15acd2e7834eed28e35abcbc8c82ad" translate="yes" xml:space="preserve">
          <source>First write-ahead log location used when WAL receiver is started</source>
          <target state="translated">WAL 수신자가 시작될 때 사용 된 최초 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="3d68839eda494d2d4c816d693a636ee1fdff60af" translate="yes" xml:space="preserve">
          <source>First, an inner join is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, a joined row is added with null values in columns of T2. Also, for each row of T2 that does not satisfy the join condition with any row in T1, a joined row with null values in the columns of T1 is added.</source>
          <target state="translated">먼저 내부 결합이 수행됩니다. 그런 다음 T2의 행과의 결합 조건을 만족하지 않는 T1의 각 행에 대해 결합 된 행은 T2의 열에 널값으로 추가됩니다. 또한 T1의 행과의 조인 조건을 만족하지 않는 T2의 각 행에 대해 T1의 열에 널값이있는 조인 된 행이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bf68160bb0b09be302c80f5a6377c6068618a82e" translate="yes" xml:space="preserve">
          <source>First, an inner join is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, a joined row is added with null values in columns of T2. Thus, the joined table always has at least one row for each row in T1.</source>
          <target state="translated">먼저 내부 결합이 수행됩니다. 그런 다음 T2의 행과의 결합 조건을 만족하지 않는 T1의 각 행에 대해 결합 된 행은 T2의 열에 널값으로 추가됩니다. 따라서 조인 된 테이블에는 항상 T1의 각 행에 대해 하나 이상의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfbacc69c4a250767394293662a5c10dcd05d405" translate="yes" xml:space="preserve">
          <source>First, an inner join is performed. Then, for each row in T2 that does not satisfy the join condition with any row in T1, a joined row is added with null values in columns of T1. This is the converse of a left join: the result table will always have a row for each row in T2.</source>
          <target state="translated">먼저 내부 결합이 수행됩니다. 그런 다음 T1의 행과의 조인 조건을 만족하지 않는 T2의 각 행에 대해 조인 된 행은 T1의 열에 널값으로 추가됩니다. 이것은 왼쪽 조인의 반대입니다. 결과 테이블에는 항상 T2의 각 행에 대한 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="112f7a7760de963ce73e2b79934214d9ac1a3666" translate="yes" xml:space="preserve">
          <source>First, set up &lt;code&gt;sepgsql&lt;/code&gt; in a working database according to the instructions in &lt;a href=&quot;sepgsql#SEPGSQL-INSTALLATION&quot;&gt;Section F.35.2&lt;/a&gt;. Note that the current operating system user must be able to connect to the database as superuser without password authentication.</source>
          <target state="translated">먼저 &lt;code&gt;sepgsql&lt;/code&gt; &lt;a href=&quot;sepgsql#SEPGSQL-INSTALLATION&quot;&gt;절의&lt;/a&gt; 지시 사항에 따라 작업중인 데이터베이스에 sepgsql을 설정하십시오 . 현재 운영 체제 사용자는 비밀번호 인증없이 데이터베이스에 수퍼 유저로 연결할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6ef0e65838b9c348fc778edd09543e18bd957409" translate="yes" xml:space="preserve">
          <source>Flag bits</source>
          <target state="translated">플래그 비트</target>
        </trans-unit>
        <trans-unit id="ea519240a9625ab43f20185bccd0e6d889013f94" translate="yes" xml:space="preserve">
          <source>Flags field</source>
          <target state="translated">플래그 필드</target>
        </trans-unit>
        <trans-unit id="085e4cb0a6de22bf43046dc7ac72d42d6d84b37b" translate="yes" xml:space="preserve">
          <source>Flush the WAL data to disk immediately after it has been received. Also send a status packet back to the server immediately after flushing, regardless of &lt;code&gt;--status-interval&lt;/code&gt;.</source>
          <target state="translated">WAL 데이터를받은 직후 디스크로 플러시하십시오. &lt;code&gt;--status-interval&lt;/code&gt; 에 관계없이 플러시 직후 서버에 상태 패킷을 다시 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="88a20b45cfacc5947c49f2f3bfe45e58e60574ad" translate="yes" xml:space="preserve">
          <source>Flushes a file or directory to disk.</source>
          <target state="translated">파일 또는 디렉토리를 디스크로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="2fd5404dbcdae2377752d6efc221270ab4825d00" translate="yes" xml:space="preserve">
          <source>Following the page header are item identifiers (&lt;code&gt;ItemIdData&lt;/code&gt;), each requiring four bytes. An item identifier contains a byte-offset to the start of an item, its length in bytes, and a few attribute bits which affect its interpretation. New item identifiers are allocated as needed from the beginning of the unallocated space. The number of item identifiers present can be determined by looking at &lt;code&gt;pd_lower&lt;/code&gt;, which is increased to allocate a new identifier. Because an item identifier is never moved until it is freed, its index can be used on a long-term basis to reference an item, even when the item itself is moved around on the page to compact free space. In fact, every pointer to an item (&lt;code&gt;ItemPointer&lt;/code&gt;, also known as &lt;code&gt;CTID&lt;/code&gt;) created by PostgreSQL consists of a page number and the index of an item identifier.</source>
          <target state="translated">페이지 헤더 다음에는 각각 4 바이트가 필요한 항목 식별자 ( &lt;code&gt;ItemIdData&lt;/code&gt; )가 있습니다. 항목 식별자에는 항목 시작에 대한 바이트 오프셋, 길이 (바이트) 및 해석에 영향을주는 몇 가지 속성 비트가 포함됩니다. 새 항목 식별자는 할당되지 않은 공간의 시작부터 필요에 따라 할당됩니다. 존재하는 아이템 식별자의 수 는 새로운 식별자를 할당하기 위해 증가되는 &lt;code&gt;pd_lower&lt;/code&gt; 를보고 결정될 수있다 . 항목 식별자는 해제 될 때까지 이동되지 않으므로 항목 자체를 페이지에서 이동하여 여유 공간을 줄이더라도 색인을 사용하여 항목을 참조 할 수 있습니다. 실제로 항목에 대한 모든 포인터 ( &lt;code&gt;ItemPointer&lt;/code&gt; , &lt;code&gt;CTID&lt;/code&gt; 라고도 함)PostgreSQL에 의해 생성 된)는 페이지 번호와 항목 식별자의 색인으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ad6c883e61266aaca99ae374d0bc028890e49de7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; statements, &lt;code&gt;WITH CHECK&lt;/code&gt; expressions are enforced after &lt;code&gt;BEFORE&lt;/code&gt; triggers are fired, and before any actual data modifications are made. Thus a &lt;code&gt;BEFORE ROW&lt;/code&gt; trigger may modify the data to be inserted, affecting the result of the security policy check. &lt;code&gt;WITH CHECK&lt;/code&gt; expressions are enforced before any other constraints.</source>
          <target state="translated">들어 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 문, &lt;code&gt;WITH CHECK&lt;/code&gt; 표현은 이후에 적용됩니다 &lt;code&gt;BEFORE&lt;/code&gt; 트리거 해고하고, 실제 데이터 수정이되기 전에. 따라서 &lt;code&gt;BEFORE ROW&lt;/code&gt; 트리거는 삽입 할 데이터를 수정하여 보안 정책 검사 결과에 영향을 줄 수 있습니다. &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식은 다른 제한 조건보다 먼저 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="99deed17908e48271fc11c71fccf1c3dff1b0821" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; queries a RETURNING clause must be provided, and the target relation must not have a conditional rule, nor an &lt;code&gt;ALSO&lt;/code&gt; rule, nor an &lt;code&gt;INSTEAD&lt;/code&gt; rule that expands to multiple statements.</source>
          <target state="translated">들어 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 쿼리 복귀 절을 제공해야하며, 대상 관계는 조건부 규칙도 아니다 없어야합니다 &lt;code&gt;ALSO&lt;/code&gt; 의 규칙을,도 아니다은 &lt;code&gt;INSTEAD&lt;/code&gt; 여러 문에 그 팽창을 지배.</target>
        </trans-unit>
        <trans-unit id="0e7b7a49d626091f4506fce89e08d0ff24c020c0" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UPDATE&lt;/code&gt; events, it is possible to specify a list of columns using this syntax:</source>
          <target state="translated">들어 &lt;code&gt;UPDATE&lt;/code&gt; 의 이벤트,이 구문을 사용하여 열 목록을 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="13c83d161616830e1f33c382b701d227cd558a73" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;[A-Za-z0-9]&lt;/code&gt;</source>
          <target state="translated">들면 &lt;code&gt;[A-Za-z0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445725043f2e2c6f25fb417e94f2563fb378bf70" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;[a-z]&lt;/code&gt;</source>
          <target state="translated">들면 &lt;code&gt;[a-z]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75b922537c547ae7448037c7c6ad96a06167147a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;\copy ... from stdin&lt;/code&gt;, data rows are read from the same source that issued the command, continuing until &lt;code&gt;\.&lt;/code&gt; is read or the stream reaches EOF. This option is useful for populating tables in-line within a SQL script file. For &lt;code&gt;\copy ... to stdout&lt;/code&gt;, output is sent to the same place as psql command output, and the &lt;code&gt;COPY count&lt;/code&gt; command status is not printed (since it might be confused with a data row). To read/write psql's standard input or output regardless of the current command source or &lt;code&gt;\o&lt;/code&gt; option, write &lt;code&gt;from pstdin&lt;/code&gt; or &lt;code&gt;to pstdout&lt;/code&gt;.</source>
          <target state="translated">를 들어 &lt;code&gt;\copy ... from stdin&lt;/code&gt; 데이터 행이 될 때까지 계속 명령을 발행 한 같은 소스에서 읽 &lt;code&gt;\.&lt;/code&gt; 읽거나 스트림이 EOF에 도달합니다. 이 옵션은 SQL 스크립트 파일 내에서 테이블을 인라인으로 채우는 데 유용합니다. 들면 &lt;code&gt;\copy ... to stdout&lt;/code&gt; , 출력 명령 psql의 출력과 동일한 장소에 전송되고, &lt;code&gt;COPY count&lt;/code&gt; (이 데이터 행과 혼동 될 수 있기 때문) 명령 상태는 인쇄되지 않는다. 현재 명령 소스 또는 &lt;code&gt;\o&lt;/code&gt; 옵션에 관계없이 psql의 표준 입력 또는 출력을 읽거나 쓰려면 &lt;code&gt;from pstdin&lt;/code&gt; 또는 &lt;code&gt;to pstdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbe40a2f96bfb1794b52f2ae977f36a6df890e78" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp with time zone&lt;/code&gt; values, the number of seconds since 1970-01-01 00:00:00 UTC (can be negative); for &lt;code&gt;date&lt;/code&gt; and &lt;code&gt;timestamp&lt;/code&gt; values, the number of seconds since 1970-01-01 00:00:00 local time; for &lt;code&gt;interval&lt;/code&gt; values, the total number of seconds in the interval</source>
          <target state="translated">&lt;code&gt;timestamp with time zone&lt;/code&gt; 값이 있는 시간 소인의 경우 1970-01-01 00:00:00 UTC 이후의 초 수 (음수 일 수 있음). 위한 &lt;code&gt;date&lt;/code&gt; 및 &lt;code&gt;timestamp&lt;/code&gt; 값, 1970-01-01 0시 0분 0초 로컬 시간 보낸 초; 대 &lt;code&gt;interval&lt;/code&gt; 값 간격 (초) 총 개수</target>
        </trans-unit>
        <trans-unit id="022c7b4734aca13c0e569da1037faae44d208be0" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp with time zone&lt;/code&gt;, the internally stored value is always in UTC (Universal Coordinated Time, traditionally known as Greenwich Mean Time, GMT). An input value that has an explicit time zone specified is converted to UTC using the appropriate offset for that time zone. If no time zone is stated in the input string, then it is assumed to be in the time zone indicated by the system's &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; parameter, and is converted to UTC using the offset for the &lt;code&gt;timezone&lt;/code&gt; zone.</source>
          <target state="translated">들어 &lt;code&gt;timestamp with time zone&lt;/code&gt; , 내부적으로 저장된 값은 UTC (전통적으로 그리니치 표준시, GMT로 알려진 표준시)에 항상이다. 명시 적 시간대가 지정된 입력 값은 해당 시간대에 대한 적절한 오프셋을 사용하여 UTC로 변환됩니다. 입력 문자열에 시간대가 지정되어 있지 않으면 시스템의 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 매개 변수로 표시된 시간대에있는 것으로 가정 하고 &lt;code&gt;timezone&lt;/code&gt; 대한 오프셋을 사용하여 UTC로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbd7164f3c2b0f4f4f5eac0a4b59bfa56e2902cb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp&lt;/code&gt; values, the day (of the month) field (1 - 31) ; for &lt;code&gt;interval&lt;/code&gt; values, the number of days</source>
          <target state="translated">시간 &lt;code&gt;timestamp&lt;/code&gt; 값의 경우, 일 (월) 필드 (1-31); 대 &lt;code&gt;interval&lt;/code&gt; 값 일수</target>
        </trans-unit>
        <trans-unit id="635acd816eed6f70bd831fd2f271ba1330d102b2" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp&lt;/code&gt; values, the day (of the month) field (1&amp;ndash;31) ; for &lt;code&gt;interval&lt;/code&gt; values, the number of days</source>
          <target state="translated">대한 &lt;code&gt;timestamp&lt;/code&gt; 값 필드 (1-31) (매월) 일; 대 &lt;code&gt;interval&lt;/code&gt; 값 일수</target>
        </trans-unit>
        <trans-unit id="3546baced469dfb3851387c39eb316d80942a913" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp&lt;/code&gt; values, the number of the month within the year (1 - 12) ; for &lt;code&gt;interval&lt;/code&gt; values, the number of months, modulo 12 (0 - 11)</source>
          <target state="translated">대한 &lt;code&gt;timestamp&lt;/code&gt; 값, 올해 (1-12) 내에서 달의 수 위한 &lt;code&gt;interval&lt;/code&gt; 값 월수는 모듈로 (12) (0-11)</target>
        </trans-unit>
        <trans-unit id="858fa4846439dc5608801b9362a6bd73af350fa4" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;timestamp&lt;/code&gt; values, the number of the month within the year (1&amp;ndash;12) ; for &lt;code&gt;interval&lt;/code&gt; values, the number of months, modulo 12 (0&amp;ndash;11)</source>
          <target state="translated">대한 &lt;code&gt;timestamp&lt;/code&gt; 값, 올해 (1 ~ 12)에서 달의 수 위한 &lt;code&gt;interval&lt;/code&gt; 값 월수 12 (0-11)를 모듈로 (modulo)</target>
        </trans-unit>
        <trans-unit id="b666b88755ac187f5a8ca6b56b29e5e20fd687c8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;xdes&lt;/code&gt; there is an additional limitation that the iteration count must be an odd number.</source>
          <target state="translated">들면 &lt;code&gt;xdes&lt;/code&gt; 반복 수가 홀수이어야한다는 추가적인 제약이있다.</target>
        </trans-unit>
        <trans-unit id="58dbe42e8e8c3048bd4768729e3a37b374beaf95" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;major&lt;/em&gt; releases of PostgreSQL, the internal data storage format is subject to change, thus complicating upgrades. The traditional method for moving data to a new major version is to dump and reload the database, though this can be slow. A faster method is &lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade&lt;/a&gt;. Replication methods are also available, as discussed below.</source>
          <target state="translated">들어 &lt;em&gt;주요&lt;/em&gt; PostgreSQL의 릴리스, 내부 데이터 저장 형식 따라서 업그레이드를 복잡하게 변경 될 수 있습니다. 데이터를 새로운 주요 버전으로 옮기는 전통적인 방법은 데이터베이스를 덤프하고 다시로드하는 것입니다. 더 빠른 방법은 &lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade&lt;/a&gt; 입니다. 아래에 설명 된대로 복제 방법도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a38da720b6a33263ecd24c3c5ab58988bc256541" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;major&lt;/em&gt; releases of PostgreSQL, the internal data storage format is subject to change, thus complicating upgrades. The traditional method for moving data to a new major version is to dump and reload the database, though this can be slow. A faster method is &lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade&lt;/a&gt;. Replication methods are also available, as discussed below. (If you are using a pre-packaged version of PostgreSQL, it may provide scripts to assist with major version upgrades. Consult the package-level documentation for details.)</source>
          <target state="translated">들어 &lt;em&gt;주요&lt;/em&gt; PostgreSQL의 릴리스, 내부 데이터 저장 형식 따라서 업그레이드를 복잡하게 변경 될 수 있습니다. 데이터를 새로운 주 버전으로 이동하는 전통적인 방법은 데이터베이스를 덤프하고 다시로드하는 것이지만 속도가 느릴 수 있습니다. 더 빠른 방법은 &lt;a href=&quot;pgupgrade&quot;&gt;pg_upgrade&lt;/a&gt; 입니다. 아래에서 설명하는 것처럼 복제 방법도 사용할 수 있습니다. (사전 패키지 버전의 PostgreSQL을 사용하는 경우 주요 버전 업그레이드를 지원하는 스크립트를 제공 할 수 있습니다. 자세한 내용은 패키지 수준 설명서를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="42e579402933c607f670c845aa7f8cfca193a4e5" translate="yes" xml:space="preserve">
          <source>For FreeBSD, look at the file &lt;code&gt;contrib/start-scripts/freebsd&lt;/code&gt; in the PostgreSQL source distribution.</source>
          <target state="translated">FreeBSD의 경우 PostgreSQL 소스 배포에서 &lt;code&gt;contrib/start-scripts/freebsd&lt;/code&gt; 파일을보십시오 .</target>
        </trans-unit>
        <trans-unit id="65a36d32e3a8fe156cfc690cdec561261e81aec6" translate="yes" xml:space="preserve">
          <source>For RSA encryption you must create either DSA or RSA sign-only key as master and then add an RSA encryption subkey with &lt;code&gt;gpg --edit-key&lt;/code&gt;.</source>
          <target state="translated">RSA 암호화의 경우 DSA 또는 RSA 서명 전용 키를 마스터로 생성 한 다음 &lt;code&gt;gpg --edit-key&lt;/code&gt; 를 사용하여 RSA 암호화 하위 키를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5dd1f47d5dc0087dbc26af3dcfa192ab806aa921" translate="yes" xml:space="preserve">
          <source>For Windows users, you must be logged into an administrative account, and then start a shell as the &lt;code&gt;postgres&lt;/code&gt; user and set the proper path:</source>
          <target state="translated">Windows 사용자의 경우 관리 계정으로 로그인 한 후 &lt;code&gt;postgres&lt;/code&gt; 사용자 로 쉘을 시작 하고 올바른 경로를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea1047057136e71c7f021f5dae197764108e8152" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;hostssl&lt;/code&gt; entry with &lt;code&gt;clientcert=verify-ca&lt;/code&gt;, the server will verify that the client's certificate is signed by one of the trusted certificate authorities. If &lt;code&gt;clientcert=verify-full&lt;/code&gt; is specified, the server will not only verify the certificate chain, but it will also check whether the username or its mapping matches the &lt;code&gt;cn&lt;/code&gt; (Common Name) of the provided certificate. Note that certificate chain validation is always ensured when the &lt;code&gt;cert&lt;/code&gt; authentication method is used (see &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;clientcert=verify-ca&lt;/code&gt; 가 있는 &lt;code&gt;hostssl&lt;/code&gt; 항목의 경우, 서버는 클라이언트의 인증서가 신뢰할 수있는 인증 기관 중 하나에 의해 서명되었는지 확인합니다. 경우 &lt;code&gt;clientcert=verify-full&lt;/code&gt; 지정되면, 서버는 인증서 체인을 확인하지 않습니다, 그러나 그것은 또한 사용자 이름 또는 매핑이 일치하는지 여부를 확인합니다 &lt;code&gt;cn&lt;/code&gt; 제공된 인증서 (공통 이름). &lt;code&gt;cert&lt;/code&gt; 인증 방법을 사용 하면 인증서 체인 유효성 검사가 항상 보장 됩니다 ( &lt;a href=&quot;auth-cert&quot;&gt;섹션 20.12&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0e7295a68549852c29d6fecae79435a579540b69" translate="yes" xml:space="preserve">
          <source>For a Gaussian distribution, the interval is mapped onto a standard normal distribution (the classical bell-shaped Gaussian curve) truncated at &lt;code&gt;-parameter&lt;/code&gt; on the left and &lt;code&gt;+parameter&lt;/code&gt; on the right. Values in the middle of the interval are more likely to be drawn. To be precise, if &lt;code&gt;PHI(x)&lt;/code&gt; is the cumulative distribution function of the standard normal distribution, with mean &lt;code&gt;mu&lt;/code&gt; defined as &lt;code&gt;(max + min) / 2.0&lt;/code&gt;, with</source>
          <target state="translated">가우스 분포를 들어, 간격은 절단 표준 정규 분포 (고전 종 모양의 가우스 곡선)에 매핑된다 &lt;code&gt;-parameter&lt;/code&gt; 왼쪽에 &lt;code&gt;+parameter&lt;/code&gt; 오른쪽. 구간 중간의 값이 더 많이 그려 질 수 있습니다. 만약 정확한 될 &lt;code&gt;PHI(x)&lt;/code&gt; , 평균, 표준 정규 분포의 누적 분포 함수 &lt;code&gt;mu&lt;/code&gt; 정의 &lt;code&gt;(max + min) / 2.0&lt;/code&gt; 으로,</target>
        </trans-unit>
        <trans-unit id="c70c859349570f9d2df772492a1cca445d1bebc6" translate="yes" xml:space="preserve">
          <source>For a comment on a table column, this is the column number (the &lt;code&gt;objoid&lt;/code&gt; and &lt;code&gt;classoid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 컬럼에 코멘트의 경우, 이것은 열 번호입니다합니다 ( &lt;code&gt;objoid&lt;/code&gt; 가 와 &lt;code&gt;classoid&lt;/code&gt; 테이블 자체 참조). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c77c040fe7ed64266629248efa7e92eaaf49a102" translate="yes" xml:space="preserve">
          <source>For a consistent backup, the database server needs to support synchronized snapshots, a feature that was introduced in PostgreSQL 9.2 for primary servers and 10 for standbys. With this feature, database clients can ensure they see the same data set even though they use different connections. &lt;code&gt;pg_dump -j&lt;/code&gt; uses multiple database connections; it connects to the database once with the master process and once again for each worker job. Without the synchronized snapshot feature, the different worker jobs wouldn't be guaranteed to see the same data in each connection, which could lead to an inconsistent backup.</source>
          <target state="translated">일관된 백업을 위해서는 데이터베이스 서버가 PostgreSQL 9.2 (기본 서버의 경우 10 개, 대기의 경우 10 개)에 도입 된 기능인 동기화 된 스냅 샷을 지원해야합니다. 이 기능을 사용하면 데이터베이스 클라이언트는 다른 연결을 사용하더라도 동일한 데이터 세트를 볼 수 있습니다. &lt;code&gt;pg_dump -j&lt;/code&gt; 는 여러 데이터베이스 연결을 사용합니다. 마스터 프로세스로 한 번 데이터베이스에 연결하고 각 작업자 작업마다 다시 연결합니다. 동기화 된 스냅 샷 기능이 없으면 서로 다른 작업자 작업이 각 연결에서 동일한 데이터를 보도록 보장 할 수 없으므로 백업이 일관되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b742e0426def8e161b548a97e5e242fbcf821e02" translate="yes" xml:space="preserve">
          <source>For a detailed description of the Linux huge pages feature have a look at &lt;a href=&quot;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&quot;&gt;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&lt;/a&gt;.</source>
          <target state="translated">Linux 거대한 페이지 기능에 대한 자세한 설명은 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&quot;&gt;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f619524dce98e4031aba392da00393e55b558403" translate="yes" xml:space="preserve">
          <source>For a fixed-size type, &lt;code&gt;typlen&lt;/code&gt; is the number of bytes in the internal representation of the type. But for a variable-length type, &lt;code&gt;typlen&lt;/code&gt; is negative. -1 indicates a &amp;ldquo;varlena&amp;rdquo; type (one that has a length word), -2 indicates a null-terminated C string.</source>
          <target state="translated">고정 크기 유형의 경우 &lt;code&gt;typlen&lt;/code&gt; 은 유형 의 내부 표현에서 바이트 수입니다. 그러나 가변 길이 유형의 경우 &lt;code&gt;typlen&lt;/code&gt; 은 음수입니다. -1은 &quot;varlena&quot;유형 (길이 워드가있는 유형)을 나타내고 -2는 널 종료 C 문자열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c716c97bef682a5580619511cc00e4ae11e29df3" translate="yes" xml:space="preserve">
          <source>For a foreign table using &lt;code&gt;file_fdw&lt;/code&gt;, &lt;code&gt;EXPLAIN&lt;/code&gt; shows the name of the file to be read or program to be run. For a file, unless &lt;code&gt;COSTS OFF&lt;/code&gt; is specified, the file size (in bytes) is shown as well.</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; 를 사용하는 외부 테이블의 경우 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 읽을 파일 이름 또는 실행할 프로그램 이름을 표시합니다. 파일의 경우 &lt;code&gt;COSTS OFF&lt;/code&gt; 를 지정 하지 않으면 파일 크기 (바이트)도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2fb6748fc19be0ed0a5abf4e0f452d7dd4259e2" translate="yes" xml:space="preserve">
          <source>For a function or operator call, the collation that is derived by examining the argument collations is used at run time for performing the specified operation. If the result of the function or operator call is of a collatable data type, the collation is also used at parse time as the defined collation of the function or operator expression, in case there is a surrounding expression that requires knowledge of its collation.</source>
          <target state="translated">함수 또는 연산자 호출의 경우 인수 데이터 정렬을 검사하여 파생 된 데이터 정렬은 런타임에 지정된 작업을 수행하는 데 사용됩니다. 함수 또는 연산자 호출의 결과가 데이터 정렬 가능 유형 인 경우 데이터 정렬에 대한 지식이 필요한 주변 표현식이있는 경우 구문 분석시 함수 또는 연산자 표현식의 정의 된 데이터 정렬로 구문 분석 시간도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="873de634341e3f4f17aa404bfb78db0b8b1d7819" translate="yes" xml:space="preserve">
          <source>For a language not known in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog, a sequence such as this is needed:</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; 카탈로그에 알려지지 않은 언어의 경우 다음 과 같은 순서가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="51c1f1c841407e1e55f78883fd3c8f0203af376b" translate="yes" xml:space="preserve">
          <source>For a more extensive demonstration, we first create a &lt;code&gt;public.english&lt;/code&gt; configuration and Ispell dictionary for the English language:</source>
          <target state="translated">보다 광범위한 데모를 위해 먼저 영어 용 &lt;code&gt;public.english&lt;/code&gt; 구성 및 Ispell 사전을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="790cb0afd5e6474475083710292021c180b53bde" translate="yes" xml:space="preserve">
          <source>For a security label on a table column, this is the column number (the &lt;code&gt;objoid&lt;/code&gt; and &lt;code&gt;classoid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 컬럼에 대한 보안 레이블의 경우,이 열 번호입니다합니다 ( &lt;code&gt;objoid&lt;/code&gt; 가 와 &lt;code&gt;classoid&lt;/code&gt; 테이블 자체 참조). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="65033bc1e9e88185caf62bac78563d365080e3d5" translate="yes" xml:space="preserve">
          <source>For a table column, this is the column number (the &lt;code&gt;objid&lt;/code&gt; and &lt;code&gt;classid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 열의 경우 열 번호입니다 ( &lt;code&gt;objid&lt;/code&gt; 및 &lt;code&gt;classid&lt;/code&gt; 는 테이블 자체를 나타냄). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c5ce9480f6b6749d12052ad99ca0fb55409dd48e" translate="yes" xml:space="preserve">
          <source>For a table column, this is the column number (the &lt;code&gt;objoid&lt;/code&gt; and &lt;code&gt;classoid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 항목은이 열 번호 ( &lt;code&gt;objoid&lt;/code&gt; 은 과 &lt;code&gt;classoid&lt;/code&gt; 테이블 자체 참조). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="649ae99e00f56ecf560264794b88e680e3e3769c" translate="yes" xml:space="preserve">
          <source>For a table column, this is the column number (the &lt;code&gt;refobjid&lt;/code&gt; and &lt;code&gt;refclassid&lt;/code&gt; refer to the table itself). For all other object types, this column is zero.</source>
          <target state="translated">테이블 열의 경우 열 번호입니다 ( &lt;code&gt;refobjid&lt;/code&gt; 및 &lt;code&gt;refclassid&lt;/code&gt; 는 테이블 자체를 나타냄). 다른 모든 객체 유형의 경우이 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="eabd8eb6f239223b555e1ca5f4a755e59810f860" translate="yes" xml:space="preserve">
          <source>For a target column declared as &lt;code&gt;character(20)&lt;/code&gt; the following statement shows that the stored value is sized correctly:</source>
          <target state="translated">&lt;code&gt;character(20)&lt;/code&gt; 로 선언 된 대상 열의 경우 다음 명령문은 저장된 값의 크기가 올바르게 지정되었음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e7c0ff43494255c9b4e4649e18a3ecb09a7c13cb" translate="yes" xml:space="preserve">
          <source>For additional details see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-volatility.html&quot;&gt;Section 37.7&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-volatility.html&quot;&gt;37.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
