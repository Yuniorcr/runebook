<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d2256e3896ead62f77d423e731b976ceab4c8935" translate="yes" xml:space="preserve">
          <source>Includes the required write-ahead log files (WAL files) in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster directly in the extracted directory without the need to consult the log archive, thus making this a completely standalone backup.</source>
          <target state="translated">백업에 필요한 미리 쓰기 로그 파일 (WAL 파일)을 포함합니다. 여기에는 백업 중에 생성 된 모든 미리 쓰기 로그가 포함됩니다. 메소드 않는 한 &lt;code&gt;none&lt;/code&gt; 지정되지 않은, 따라서이 완전히 독립 백업하고, 로그 아카이브를 참조 할 필요없이 압축을 푼 디렉토리에 직접 전자 메일 관리자를 시작하는 것이 가능하다.</target>
        </trans-unit>
        <trans-unit id="bba52d333ab18b6249842b58dabb5827d455ee93" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), and application name. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="translated">&lt;code&gt;log_error_verbosity&lt;/code&gt; 에 &lt;code&gt;csvlog&lt;/code&gt; 를 포함하는 것은 &lt;code&gt;verbose&lt;/code&gt; 로 설정 되고 응용 프로그램 이름입니다. CSV 형식 로그 출력을 저장하기위한 샘플 테이블 정의는 다음과 같습니다. &lt;code&gt;log_destination&lt;/code&gt; 목록에 로그 파일을 데이터베이스 테이블로 가져 오는 편리한 방법을 제공합니다. 이 옵션은 밀리 초가 포함 된 타임 스탬프, 사용자 이름, 데이터베이스 이름, 프로세스 ID, 클라이언트 호스트 : 포트 번호, 세션 ID, 세션 별 라인 번호, 명령과 같은 열을 사용하여 쉼표로 구분 된 값 (CSV) 형식으로 로그 라인을 생성합니다. 태그, 세션 시작 시간, 가상 트랜잭션 ID, 일반 트랜잭션 ID, 오류 심각도, SQLSTATE 코드, 오류 메시지, 오류 메시지 세부 사항, 힌트, 오류가 발생한 내부 쿼리 (있는 경우), 오류 위치의 문자 수, 오류 컨텍스트, 오류를 &lt;code&gt;log_min_error_statement&lt;/code&gt; 사용자 쿼리 (있는 경우 log_min_error_statement에 의해 활성화 됨)), 오류 위치의 문자 수, PostgreSQL 소스 코드의 오류 위치 ( 경우</target>
        </trans-unit>
        <trans-unit id="3277b28011c125843d31a46c71b92575dd21118e" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), application name, and backend type. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="translated">&lt;code&gt;log_destination&lt;/code&gt; 목록에 &lt;code&gt;csvlog&lt;/code&gt; 를 포함하면 로그 파일을 데이터베이스 테이블로 편리하게 가져올 수 있습니다. 이 옵션은 밀리 초가 포함 된 타임 스탬프, 사용자 이름, 데이터베이스 이름, 프로세스 ID, 클라이언트 호스트 : 포트 번호, 세션 ID, 세션 별 줄 번호, 명령 열과 함께 CSV (쉼표로 구분 된 값) 형식으로 로그 줄을 내 보냅니다. 태그, 세션 시작 시간, 가상 트랜잭션 ID, 일반 트랜잭션 ID, 오류 심각도, SQLSTATE 코드, 오류 메시지, 오류 메시지 세부 정보, 힌트, 오류를 유발 한 내부 쿼리 (있는 경우), 오류 위치의 문자 수, 오류 컨텍스트, 오류를 &lt;code&gt;log_min_error_statement&lt;/code&gt; 사용자 쿼리 (있는 경우 log_min_error_statement에 의해 활성화 됨)), 오류 위치의 문자 수, PostgreSQL 소스 코드의 오류 위치 ( &lt;code&gt;log_error_verbosity&lt;/code&gt; 가 &lt;code&gt;verbose&lt;/code&gt; 로 설정된 경우 ), 애플리케이션 이름 및 백엔드 유형. 다음은 CSV 형식 로그 출력을 저장하기위한 샘플 테이블 정의입니다.</target>
        </trans-unit>
        <trans-unit id="4c47c86c8d425f70d8b2151c0d809c6c1813e865" translate="yes" xml:space="preserve">
          <source>Increase &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; and &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;; this reduces the frequency of checkpoints, but increases the storage requirements of &lt;code&gt;/pg_wal&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout을&lt;/a&gt; 늘리 십시오 . 이것은 체크 포인트의 빈도를 줄이지 만 &lt;code&gt;/pg_wal&lt;/code&gt; 의 스토리지 요구 사항을 증가 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="491d088ee8f4f607e5e1e928bb9bf8875f9a361a" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;code&gt;r&lt;/code&gt; in at least &lt;code&gt;n&lt;/code&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;code&gt;r&lt;/code&gt;. Lower-left coordinates are decreased by &lt;code&gt;r&lt;/code&gt; and upper-right coordinates are increased by &lt;code&gt;r&lt;/code&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;code&gt;r&lt;/code&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;code&gt;n&lt;/code&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;code&gt;r&lt;/code&gt; &amp;gt; 0), then extra dimensions are added to make &lt;code&gt;n&lt;/code&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="translated">최소 &lt;code&gt;n&lt;/code&gt; 치수 에서 지정된 반경 &lt;code&gt;r&lt;/code&gt; 만큼 큐브 크기를 증가시킵니다 . 반경이 음수이면 큐브가 대신 축소됩니다. 정의 된 모든 치수는 반지름 &lt;code&gt;r&lt;/code&gt; 에 의해 변경됩니다 . 왼쪽 아래 좌표가 &lt;code&gt;r&lt;/code&gt; 만큼 감소합니다 오른쪽 위 좌표는 &lt;code&gt;r&lt;/code&gt; 증가합니다 . 왼쪽 하단 좌표가 해당 오른쪽 상단 좌표 이상으로 증가하면 ( &lt;code&gt;r&lt;/code&gt; &amp;lt;0 인 경우에만 발생 ) 두 좌표가 평균으로 설정됩니다. 경우 &lt;code&gt;n&lt;/code&gt; 은 정의 된 치수의 수보다 크고 큐브가 확대되고있다 ( &lt;code&gt;r&lt;/code&gt; &amp;gt; 0), 그 다음 추가로 치수 메이크업에 추가 &lt;code&gt;n&lt;/code&gt; 전부; 추가 좌표의 초기 값으로 0이 사용됩니다. 이 기능은 근처 점을 검색하기 위해 점 주위에 경계 상자를 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a6f168056ed493abc9b82ee898684e7de650c44e" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; in at least &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt;. Lower-left coordinates are decreased by &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; and upper-right coordinates are increased by &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; &amp;gt; 0), then extra dimensions are added to make &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="translated">최소 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 차원 에서 지정된 반경 &lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt; 만큼 큐브의 크기를 늘 립니다. 반경이 음수이면 큐브가 대신 축소됩니다. 정의 된 모든 치수는 반지름 &lt;em&gt; &lt;code&gt;r&lt;/code&gt; 에&lt;/em&gt; 의해 변경됩니다 . 왼쪽 아래 좌표는 &lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt; 만큼 감소하고 오른쪽 위 좌표는 &lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt; 만큼 증가합니다 . 왼쪽 아래 좌표가 해당 오른쪽 위 좌표보다 더 많이 증가하면 (이는 &lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt; &amp;lt;0 일 때만 발생할 수 있음 ) 두 좌표가 평균으로 설정됩니다. 경우 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; 은&lt;/em&gt; 정의 된 치수의 수보다 크고 큐브가 확대되고있다 ( &lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt; &amp;gt; 0), 그 다음 여분의 사이즈하도록 추가 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;전부; 0은 추가 좌표의 초기 값으로 사용됩니다. 이 기능은 주변 지점을 검색하기 위해 지점 주변에 경계 상자를 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f9c0442f572435bb8c34c7304c10e685fc7ac4b3" translate="yes" xml:space="preserve">
          <source>Increment an integer, making use of an argument name, in PL/pgSQL:</source>
          <target state="translated">PL / pgSQL에서 인수 이름을 사용하여 정수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="d5e6a1521753325e1f10aefe90f61ed951c60b45" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:</source>
          <target state="translated">Acme Corporation의 계정을 관리하는 영업 사원의 판매 수를 늘리고 업데이트 된 전체 행과 현재 시간을 로그 테이블에 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="016cda80a0391be204d7aeb8cae7ec5708da297f" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, using the &lt;code&gt;FROM&lt;/code&gt; clause syntax:</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절 구문을 사용하여 Acme Corporation의 계정을 관리하는 영업 사원의 판매 수를 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="9a4352e3ce439f57ce839ae2217c61914bab2036" translate="yes" xml:space="preserve">
          <source>Increment value of the sequence</source>
          <target state="translated">시퀀스의 증가 값</target>
        </trans-unit>
        <trans-unit id="0baba858aebf401bd8fc5997be9e51de35556b66" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 most recent WAL files are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="translated">독립적으로의 &lt;code&gt;max_wal_size&lt;/code&gt; , &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 가장 최근의 WAL 파일은 항상 유지됩니다. 또한 WAL 보관을 사용하는 경우 오래된 세그먼트는 보관 될 때까지 제거하거나 재활용 할 수 없습니다. WAL 보관이 WAL 생성 속도를 유지할 수 없거나 &lt;code&gt;archive_command&lt;/code&gt; 가 반복적으로 실패 하면 상황이 해결 될 때까지 오래된 WAL 파일이 &lt;code&gt;pg_wal&lt;/code&gt; 에 누적됩니다 . 복제 슬롯을 사용하는 느리거나 실패한 대기 서버는 동일한 효과를 갖습니다 (참조&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt; 26.2.6 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac2969c439badc170cf6b29ba051a5583d528c7a" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, the most recent &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; megabytes of WAL files plus one additional WAL file are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="translated">독립적으로 &lt;code&gt;max_wal_size&lt;/code&gt; , 가장 최근의 &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size의&lt;/a&gt; WAL 파일을 더한 추가 WAL 파일의 메가 바이트는 항상 유지됩니다. 또한 WAL 보관을 사용하는 경우 보관할 때까지 오래된 세그먼트를 제거하거나 재활용 할 수 없습니다. WAL 아카이브가 WAL이 생성되는 속도를 따라갈 수 없거나 &lt;code&gt;archive_command&lt;/code&gt; 가 반복적으로 실패 하는 경우 상황이 해결 될 때까지 이전 WAL 파일이 &lt;code&gt;pg_wal&lt;/code&gt; 에 누적됩니다 . 복제 슬롯을 사용하는 느리거나 실패한 대기 서버는 동일한 효과를 갖습니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;섹션 26.2.6&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bbdcb0b3a79497de0963b2de12972bc29faac57b" translate="yes" xml:space="preserve">
          <source>Index (relation)</source>
          <target state="translated">색인 (관계)</target>
        </trans-unit>
        <trans-unit id="fc7301cd0f493014b9a0674c1f9a1816640cb05f" translate="yes" xml:space="preserve">
          <source>Index Access Method: Basic API Structure for Indexes</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스의 기본 API 구조</target>
        </trans-unit>
        <trans-unit id="f78511aae833dc82a57faebbdb5be9d2b811c5ba" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Access Method Functions</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 액세스 방법 기능</target>
        </trans-unit>
        <trans-unit id="67844b6b086746a2175da308cd69b3a3322c8f8a" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Cost Estimation Functions</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 비용 추정 함수</target>
        </trans-unit>
        <trans-unit id="ed0cf00558f5f3be604eab3a16ea9444c680fa41" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Locking Considerations</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 잠금 고려 사항</target>
        </trans-unit>
        <trans-unit id="23bdd1e7799979f5184920ab721afb82ac1bc5bc" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Scanning</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 스캔</target>
        </trans-unit>
        <trans-unit id="1b3aa3923e02606cc47b91d3beb9e0be0fcf698b" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Uniqueness Checks</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 고유성 검사</target>
        </trans-unit>
        <trans-unit id="5ec145b22f866c8350ec8fde02299443b400da81" translate="yes" xml:space="preserve">
          <source>Index Storage Parameters</source>
          <target state="translated">인덱스 스토리지 매개 변수</target>
        </trans-unit>
        <trans-unit id="4e09dcdaddb1a9558501d09366dc72f53b93938b" translate="yes" xml:space="preserve">
          <source>Index Types</source>
          <target state="translated">색인 유형</target>
        </trans-unit>
        <trans-unit id="f19762ba6cf5f18bb6bfea402f2aaa7605c7a6d9" translate="yes" xml:space="preserve">
          <source>Index access method operator class is for</source>
          <target state="translated">인덱스 액세스 방법 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="aa270689b00c3b50db9d0d870a5d8e7c14e30f9d" translate="yes" xml:space="preserve">
          <source>Index access method operator family is for</source>
          <target state="translated">인덱스 액세스 방법 운영자 제품군</target>
        </trans-unit>
        <trans-unit id="7f91618c60dc341c28ac1a80ab4b5e00b3b36fa4" translate="yes" xml:space="preserve">
          <source>Index access method specific data. Different methods store different data. Empty in ordinary tables.</source>
          <target state="translated">인덱스 액세스 방법 별 데이터. 다른 방법은 다른 데이터를 저장합니다. 일반 테이블에서 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="31a6a8a40d18f374bed6deff03fed3f43968a4d7" translate="yes" xml:space="preserve">
          <source>Index access methods must handle concurrent updates of the index by multiple processes. The core PostgreSQL system obtains &lt;code&gt;AccessShareLock&lt;/code&gt; on the index during an index scan, and &lt;code&gt;RowExclusiveLock&lt;/code&gt; when updating the index (including plain &lt;code&gt;VACUUM&lt;/code&gt;). Since these lock types do not conflict, the access method is responsible for handling any fine-grained locking it might need. An exclusive lock on the index as a whole will be taken only during index creation, destruction, or &lt;code&gt;REINDEX&lt;/code&gt;.</source>
          <target state="translated">인덱스 액세스 방법은 여러 프로세스에 의한 인덱스의 동시 업데이트를 처리해야합니다. 핵심 PostgreSQL 시스템은 인덱스 스캔 중에 인덱스에서 &lt;code&gt;AccessShareLock&lt;/code&gt; 을 &lt;code&gt;RowExclusiveLock&lt;/code&gt; 하고 인덱스를 업데이트 할 때 RowExclusiveLock (일반 &lt;code&gt;VACUUM&lt;/code&gt; 포함 )을 얻습니다 . 이러한 잠금 유형은 충돌하지 않으므로 액세스 방법은 필요할 수있는 세밀한 잠금을 처리합니다. 인덱스 전체에 대한 독점 잠금은 인덱스 생성, 소멸 또는 &lt;code&gt;REINDEX&lt;/code&gt; 중에 만 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="411152cefe270170bdbd707fa7bb100f59936ac0" translate="yes" xml:space="preserve">
          <source>Index definition (a reconstructed &lt;code&gt;CREATE INDEX&lt;/code&gt; command)</source>
          <target state="translated">인덱스 정의 (재구성 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령)</target>
        </trans-unit>
        <trans-unit id="fdde6507a698ff6040826cbe9781cf5e41a80789" translate="yes" xml:space="preserve">
          <source>Index expressions are relatively expensive to maintain, because the derived expression(s) must be computed for each row upon insertion and whenever it is updated. However, the index expressions are &lt;em&gt;not&lt;/em&gt; recomputed during an indexed search, since they are already stored in the index. In both examples above, the system sees the query as just &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; and so the speed of the search is equivalent to any other simple index query. Thus, indexes on expressions are useful when retrieval speed is more important than insertion and update speed.</source>
          <target state="translated">인덱스 표현식은 삽입시 및 업데이트 될 때마다 각 행에 대해 파생 표현식을 계산해야하므로 유지 관리 비용이 상대적으로 비쌉니다. 그러나 인덱스 표현식은 인덱스 에 이미 저장되어 있으므로 인덱스 검색 중에 다시 계산 &lt;em&gt;되지 않습니다&lt;/em&gt; . 위의 두 예에서 시스템은 쿼리를 &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; 하므로 검색 속도는 다른 간단한 인덱스 쿼리와 같습니다. 따라서 식의 인덱스는 검색 속도가 삽입 및 업데이트 속도보다 중요 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="137221474050ee597f18d1d2a9bf5cc8c57090b0" translate="yes" xml:space="preserve">
          <source>Index-Only Scans and Covering Indexes</source>
          <target state="translated">인덱스 전용 스캔 및 커버링 인덱스</target>
        </trans-unit>
        <trans-unit id="fa0d50739fe1e6ebbc17d0c70d81ac62acbaf58d" translate="yes" xml:space="preserve">
          <source>Indexable Operators</source>
          <target state="translated">인덱서 블 연산자</target>
        </trans-unit>
        <trans-unit id="69a6a1b0f4ad606d0ae7c258868e72a29f0777ef" translate="yes" xml:space="preserve">
          <source>Indexed Data Type</source>
          <target state="translated">인덱싱 된 데이터 유형</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="0b07dd7c1e4d64ef5d5ba2561b6e35701b2906b6" translate="yes" xml:space="preserve">
          <source>Indexes and foreign key constraints apply to single tables and not to their inheritance children, hence they have some &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;caveats&lt;/a&gt; to be aware of.</source>
          <target state="translated">인덱스와 외래 키 제약 조건은 상속 자식이 아닌 단일 테이블에 적용되므로 몇 가지 &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;주의 사항이 있습니다.&lt;/a&gt; 해야 할 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e15643bd769ae7fcf2c35c27f2ab1732e1a9d5c1" translate="yes" xml:space="preserve">
          <source>Indexes can also be used to enforce uniqueness of a column's value, or the uniqueness of the combined values of more than one column.</source>
          <target state="translated">인덱스를 사용하여 열 값의 고유성 또는 둘 이상의 열의 결합 된 값의 고유성을 강화할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94aa2c39061285d86804bbba30d7e52d694f4564" translate="yes" xml:space="preserve">
          <source>Indexes can also benefit &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands with search conditions. Indexes can moreover be used in join searches. Thus, an index defined on a column that is part of a join condition can also significantly speed up queries with joins.</source>
          <target state="translated">인덱스는 검색 조건이있는 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 명령 에도 도움이 됩니다. 또한 인덱스는 조인 검색에 사용될 수 있습니다. 따라서 조인 조건의 일부인 열에 정의 된 인덱스는 조인을 사용하여 쿼리 속도를 크게 높일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68c16c2b91128e4f41955f5ff646c75a169f39bb" translate="yes" xml:space="preserve">
          <source>Indexes can be used by simple index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, and the optimizer. In a bitmap scan the output of several indexes can be combined via AND or OR rules, so it is difficult to associate individual heap row fetches with specific indexes when a bitmap scan is used. Therefore, a bitmap scan increments the &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_read&lt;/code&gt; count(s) for the index(es) it uses, and it increments the &lt;code&gt;pg_stat_all_tables&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt; count for the table, but it does not affect &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt;. The optimizer also accesses indexes to check for supplied constants whose values are outside the recorded range of the optimizer statistics because the optimizer statistics might be stale.</source>
          <target state="translated">간단한 인덱스 스캔, &quot;비트 맵&quot;인덱스 스캔 및 옵티 마이저에서 인덱스를 사용할 수 있습니다. 비트 맵 스캔에서 AND 또는 OR 규칙을 통해 여러 인덱스의 출력을 결합 할 수 있으므로 비트 맵 스캔을 사용할 때 개별 힙 행 페치를 특정 인덱스와 연관시키기가 어렵습니다. 따라서 비트 맵 스캔은 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 를 증가시킵니다 . 사용하는 인덱스에 대한 &lt;code&gt;idx_tup_read&lt;/code&gt; 카운트 및 &lt;code&gt;pg_stat_all_tables&lt;/code&gt; 를 증가시킵니다 . &lt;code&gt;idx_tup_fetch&lt;/code&gt; 는 테이블의 수이지만 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 에는 영향을 미치지 않습니다 . &lt;code&gt;idx_tup_fetch&lt;/code&gt; . 옵티마이 저는 또한 인덱스에 액세스하여 옵티 마이저 통계가 오래되었을 수 있으므로 값이 옵티 마이저 통계의 기록 된 범위를 벗어난 제공된 상수를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fe87987c8ecb565fcb320eb91d374313994665e6" translate="yes" xml:space="preserve">
          <source>Indexes can even concatenate columns:</source>
          <target state="translated">인덱스는 열을 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="615b513b7bf8866eb4478326c86bda00dbb8833c" translate="yes" xml:space="preserve">
          <source>Indexes can not have multiple inheritance, since they can only inherit when using declarative partitioning.</source>
          <target state="translated">인덱스는 선언적 분할을 사용할 때만 상속 할 수 있으므로 다중 상속을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8fee069b42975ecfc0bf523b8f7af8b0cf11b9bb" translate="yes" xml:space="preserve">
          <source>Indexes, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;UNIQUE&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)</source>
          <target state="translated">원래 테이블에 대한 인덱스, &lt;code&gt;PRIMARY KEY&lt;/code&gt; , &lt;code&gt;UNIQUE&lt;/code&gt; 및 &lt;code&gt;EXCLUDE&lt;/code&gt; 제약 조건이 새 테이블에 생성됩니다. 원본의 이름 지정 방법에 관계없이 새 색인 및 제약 조건의 이름은 기본 규칙에 따라 선택됩니다. (이 동작은 새 인덱스에 대한 중복 이름 오류를 방지합니다.)</target>
        </trans-unit>
        <trans-unit id="64accc47bb83e575341063f3658e1d1e7d2113e1" translate="yes" xml:space="preserve">
          <source>Indexing for &amp;ldquo;float ranges&amp;rdquo;</source>
          <target state="translated">&quot;부동 범위&quot;에 대한 인덱싱</target>
        </trans-unit>
        <trans-unit id="d165c70b9c7feb2704f3285d8d27cbb3a58c3a91" translate="yes" xml:space="preserve">
          <source>Indexing for multidimensional cubes</source>
          <target state="translated">다차원 큐브에 대한 인덱싱</target>
        </trans-unit>
        <trans-unit id="b91462559e819269659f845aa92e7f5041a36896" translate="yes" xml:space="preserve">
          <source>Indexing for tree-like structures</source>
          <target state="translated">나무 같은 구조에 대한 인덱싱</target>
        </trans-unit>
        <trans-unit id="610e7a10148c311249b3bbd57cd9833a58b8714d" translate="yes" xml:space="preserve">
          <source>Indicates how the cast is performed. &lt;code&gt;f&lt;/code&gt; means that the function specified in the &lt;code&gt;castfunc&lt;/code&gt; field is used. &lt;code&gt;i&lt;/code&gt; means that the input/output functions are used. &lt;code&gt;b&lt;/code&gt; means that the types are binary-coercible, thus no conversion is required.</source>
          <target state="translated">캐스트 수행 방법을 나타냅니다. &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;castfunc&lt;/code&gt; 필드에 지정된 기능 이 사용됨을 의미합니다. &lt;code&gt;i&lt;/code&gt; 는 입력 / 출력 기능이 사용됨을 의미합니다. &lt;code&gt;b&lt;/code&gt; 는 유형이 이진-강제이므로 변환이 필요하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c8e4b2b3e4731dd79133b34f9f993d48a44e51e7" translate="yes" xml:space="preserve">
          <source>Indicates not to recurse creating indexes on partitions, if the table is partitioned. The default is to recurse.</source>
          <target state="translated">테이블이 파티션 된 경우 파티션에서 인덱스 작성을 재귀하지 않도록 나타냅니다. 기본값은 재귀입니다.</target>
        </trans-unit>
        <trans-unit id="c934b82eb6dc908677ffc76af2256f04ecf84094" translate="yes" xml:space="preserve">
          <source>Indicates role to which this role will be added immediately as a new member. Multiple roles to which this role will be added as a member can be specified by writing multiple &lt;code&gt;-g&lt;/code&gt; switches.</source>
          <target state="translated">이 역할이 새 구성원으로 즉시 추가 될 역할을 나타냅니다. 이 역할이 구성원으로 추가 될 여러 역할은 여러 개의 &lt;code&gt;-g&lt;/code&gt; 스위치 를 작성하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bba08c6b0be5e0b5de1c5dd077ea609cb92072f0" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 배열 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eeaf761f967f3ec9a6c653153e34b899c18b98b6" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 배열 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2af32ec08da7863e95ebf028210e1919471adfda" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 여러 인수를 공통 데이터 유형으로 자동 승격하여 모든 배열 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7a2f7fb68c39785b7c61d53497fe5cf5bd1568bd" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3dcc0fc3f371079dcd8cbcbfff1f3968fc460f48" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5be49c718755809ee9277f9ab09722e8b9a182ec" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 여러 인수를 공통 데이터 유형으로 자동 승격하여 모든 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9f46df9b9c0db2bde38cb75f71fb9153783611d4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 열거 형 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5&lt;/a&gt; 및 &lt;a href=&quot;datatype-enum&quot;&gt;섹션 8.7 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8fccdb3ecc85b5b077cee3a13e6c3bbb009743e7" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 열거 형 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 및 &lt;a href=&quot;datatype-enum&quot;&gt;섹션 8.7 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="46bd42bb48f3fa999abde7cc36ebf5b6f5ac5c8d" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any input data type.</source>
          <target state="translated">함수가 모든 입력 데이터 유형을 허용 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4e38b6c5ff227f9cc8a0278ba387f1ee54390caf" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 배열이 아닌 데이터 유형을 수용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bd2da16b809ae60477ecb6e3765117401057fff5" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 배열이 아닌 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a67aeb7edc5c822452d3c7740dc6c35d51323bcb" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 여러 인수를 공통 데이터 유형으로 자동 승격하는 비 배열 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="95d9465560cf78be64ef72d2e6367284edb5463f" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 범위의 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5&lt;/a&gt; 및 &lt;a href=&quot;rangetypes&quot;&gt;8.17 섹션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="035276077ea5e5ea9bea1d81e40e660b2873cd5b" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 범위 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 및 &lt;a href=&quot;rangetypes&quot;&gt;섹션 8.17 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4af7c5b9171c91763d28f65430601eb54e6589ed" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">함수가 여러 인수를 공통 데이터 유형으로 자동 승격하여 모든 범위 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 및 &lt;a href=&quot;rangetypes&quot;&gt;섹션 8.17 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="99e158daaace8eac02a3ccf2b3b765596ccc91e4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a null-terminated C string.</source>
          <target state="translated">함수가 널 종료 C 문자열을 승인하거나 리턴 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="54761c9282026639ec5c8540cc79ebf4ba11462a" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a server-internal data type.</source>
          <target state="translated">함수가 서버 내부 데이터 유형을 승인하거나 리턴 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89dc9ca8b4db982fb593e3e44e25350b25d82bea" translate="yes" xml:space="preserve">
          <source>Indicates that a function returns no value.</source>
          <target state="translated">함수가 값을 반환하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7d75608f451e28beb0733c0d6c1c5d589e592ee3" translate="yes" xml:space="preserve">
          <source>Indicates that data retrieved from the cursor should be unaffected by updates to the table(s) underlying the cursor that occur after the cursor is created. In PostgreSQL, this is the default behavior; so this key word has no effect and is only accepted for compatibility with the SQL standard.</source>
          <target state="translated">커서에서 검색된 데이터는 커서가 작성된 후 발생하는 커서의 기본이되는 테이블의 업데이트에 영향을받지 않아야 함을 나타냅니다. PostgreSQL에서는 이것이 기본 동작입니다. 따라서이 키워드는 효과가 없으며 SQL 표준과의 호환성을 위해서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="95cdb06015680fe563a8aa9dd541903933a11ad2" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in any context.</source>
          <target state="translated">어떤 컨텍스트에서도 캐스트를 내재적으로 호출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0390d2ebad5b8b8a226d9901a34d76e7770b71be" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in assignment contexts.</source>
          <target state="translated">할당 컨텍스트에서 캐스트를 암시 적으로 호출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3840502dacc9907db02fe8896c3bfeafcfa9e633" translate="yes" xml:space="preserve">
          <source>Indicates that the cast is an I/O conversion cast, performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type.</source>
          <target state="translated">캐스트가 소스 데이터 유형의 출력 함수를 호출하고 결과 문자열을 대상 데이터 유형의 입력 함수에 전달하여 수행되는 I / O 변환 캐스트임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01e358ef1ee49de64b80b741226b8d05654b1eb9" translate="yes" xml:space="preserve">
          <source>Indicates that the source type is binary-coercible to the target type, so no function is required to perform the cast.</source>
          <target state="translated">소스 유형이 대상 유형에 대해 2 진 변환 가능하므로 캐스트를 수행하는 기능이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f0180a78d5a13ddfb20f673dc1c1a653a0dbf1c" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a hash join.</source>
          <target state="translated">이 연산자가 해시 조인을 지원할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f8be265aa5381d640f66bb0fbb51979d62652fa" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a merge join.</source>
          <target state="translated">이 연산자가 병합 조인을 지원할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="88982366e025d973d9fdcbf523cd379f45035c49" translate="yes" xml:space="preserve">
          <source>Indicates what contexts the cast can be invoked in. &lt;code&gt;e&lt;/code&gt; means only as an explicit cast (using &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; syntax). &lt;code&gt;a&lt;/code&gt; means implicitly in assignment to a target column, as well as explicitly. &lt;code&gt;i&lt;/code&gt; means implicitly in expressions, as well as the other cases.</source>
          <target state="translated">캐스트를 호출 할 수있는 컨텍스트를 나타냅니다. &lt;code&gt;e&lt;/code&gt; 는 명시 적 캐스트 ( &lt;code&gt;CAST&lt;/code&gt; 또는 &lt;code&gt;::&lt;/code&gt; 구문 사용)로만 의미합니다 . 암시 적 목표 컬럼에 할당의 수단뿐만 아니라 명시 적으로. &lt;code&gt;i&lt;/code&gt; 다른 경우뿐만 아니라 표현에도 암묵적으로 의미한다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1335256027d947c4a5d7cbed371240e3fa5176d" translate="yes" xml:space="preserve">
          <source>Indirect TOAST pointers simply point at a non-indirect varlena value stored somewhere in memory. This case was originally created merely as a proof of concept, but it is currently used during logical decoding to avoid possibly having to create physical tuples exceeding 1 GB (as pulling all out-of-line field values into the tuple might do). The case is of limited use since the creator of the pointer datum is entirely responsible that the referenced data survives for as long as the pointer could exist, and there is no infrastructure to help with this.</source>
          <target state="translated">간접 TOAST 포인터는 단순히 메모리 어딘가에 저장된 비 간접 varlena 값을 가리 킵니다. 이 사례는 원래 개념 증명의 목적으로 만 작성되었지만 현재 1GB를 초과하는 물리적 튜플을 만들 필요가 없도록 논리적 디코딩 중에 사용됩니다 (모든 라인 외부 필드 값을 튜플로 가져 오는 것처럼). 포인터 데이텀의 작성자는 포인터가 존재할 수있는 한 참조 된 데이터가 존속 할 책임이 있으며,이를 지원할 인프라가 없기 때문에이 경우는 제한적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="749d2a57690cd8938d324488d8b64d9826db075f" translate="yes" xml:space="preserve">
          <source>Individual leaf tuples and inner tuples must fit on a single index page (8kB by default). Therefore, when indexing values of variable-length data types, long values can only be supported by methods such as radix trees, in which each level of the tree includes a prefix that is short enough to fit on a page, and the final leaf level includes a suffix also short enough to fit on a page. The operator class should set &lt;code&gt;longValuesOK&lt;/code&gt; to true only if it is prepared to arrange for this to happen. Otherwise, the SP-GiST core will reject any request to index a value that is too large to fit on an index page.</source>
          <target state="translated">개별 리프 튜플 및 내부 튜플은 단일 인덱스 페이지 (기본적으로 8kB)에 맞아야합니다. 따라서 가변 길이 데이터 형식의 값을 인덱싱 할 때 기수 트리와 같은 방법으로 만 긴 값을 지원할 수 있습니다. 트리의 각 수준에는 페이지에 맞출 수있을만큼 짧은 접두사와 최종 리프 수준이 포함됩니다. 페이지에 맞출 수있을만큼 짧은 접미사를 포함합니다. 연산자 클래스는 이를 수행 할 준비가되어있는 경우에만 &lt;code&gt;longValuesOK&lt;/code&gt; 를 true로 설정해야합니다 . 그렇지 않으면 SP-GiST 코어가 너무 커서 색인 페이지에 맞지 않는 값을 색인하기위한 요청을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="60182f316e9821f12c8e613a5f4a51ed0303f8be" translate="yes" xml:space="preserve">
          <source>Individual partitions are linked to the partitioned table with inheritance behind-the-scenes; however, it is not possible to use some of the generic features of inheritance (discussed below) with declaratively partitioned tables or their partitions. For example, a partition cannot have any parents other than the partitioned table it is a partition of, nor can a regular table inherit from a partitioned table making the latter its parent. That means partitioned tables and their partitions do not participate in inheritance with regular tables. Since a partition hierarchy consisting of the partitioned table and its partitions is still an inheritance hierarchy, all the normal rules of inheritance apply as described in &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; with some exceptions, most notably:</source>
          <target state="translated">개별 파티션은 무대 뒤에서 상속 된 파티션 된 테이블에 연결됩니다. 그러나 선언적으로 분할 된 테이블 또는 해당 분할 영역과 함께 일부 상속 기능 (아래에서 설명)을 사용할 수는 없습니다. 예를 들어, 파티션은 파티션 된 파티션 된 테이블 이외의 다른 부모를 가질 수 없으며, 일반 테이블은 파티션 된 테이블을 부모 테이블로 상속 할 수 없습니다. 이는 파티션 된 테이블 및 해당 파티션이 일반 테이블의 상속에 참여하지 않음을 의미합니다. 분할 된 테이블과 해당 파티션으로 구성된 파티션 계층 구조는 여전히 상속 계층 구조이므로 &lt;a href=&quot;ddl-inherit&quot;&gt;섹션 5.10에&lt;/a&gt; 설명 된대로 모든 일반적인 상속 규칙이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8da164cdd479d1b5a117c145f315adf86e0bbc9" translate="yes" xml:space="preserve">
          <source>Individual state files in &lt;code&gt;pg_twophase&lt;/code&gt; are protected by CRC-32.</source>
          <target state="translated">&lt;code&gt;pg_twophase&lt;/code&gt; 의 개별 상태 파일은 CRC-32에 의해 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="10dbe9c3ced898e42dd1884b1b4e3f1dc8f408e3" translate="yes" xml:space="preserve">
          <source>Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:</source>
          <target state="translated">정확하지 않은 값은 일부 값을 내부 형식으로 정확하게 변환 할 수없고 근사값으로 저장되므로 값을 저장하고 검색하면 약간의 차이가있을 수 있습니다. 이러한 오류를 관리하고 계산을 통해 전파되는 방식은 전체 수학 및 컴퓨터 과학 분야의 주제이며 다음 사항을 제외하고는 여기에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d7d8b040e79c74720337a20e81bb860b0667a32" translate="yes" xml:space="preserve">
          <source>Infinite line</source>
          <target state="translated">무한 라인</target>
        </trans-unit>
        <trans-unit id="6f943c69647f371e6d494b5d1c35aba8e91e86d6" translate="yes" xml:space="preserve">
          <source>Information about text search configuration objects can be obtained in psql using a set of commands:</source>
          <target state="translated">텍스트 검색 구성 객체에 대한 정보는 psql에서 일련의 명령을 사용하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="40def20f80d8ba48037f621df42aa0343e15ee73" translate="yes" xml:space="preserve">
          <source>Inheritance does not automatically propagate data from &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;COPY&lt;/code&gt; commands to other tables in the inheritance hierarchy. In our example, the following &lt;code&gt;INSERT&lt;/code&gt; statement will fail:</source>
          <target state="translated">상속은 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;COPY&lt;/code&gt; 명령의 데이터를 상속 계층의 다른 테이블로 자동 전파하지 않습니다 . 이 예에서 다음 &lt;code&gt;INSERT&lt;/code&gt; 문은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="48cefe4735516b5da581e0949fa06f740d2b885b" translate="yes" xml:space="preserve">
          <source>Inheritance is a concept from object-oriented databases. It opens up interesting new possibilities of database design.</source>
          <target state="translated">상속은 객체 지향 데이터베이스의 개념입니다. 데이터베이스 디자인의 새로운 가능성을 열어줍니다.</target>
        </trans-unit>
        <trans-unit id="ad5cfb3ab229a84f8bd5bd34780ce3d5e37a4e03" translate="yes" xml:space="preserve">
          <source>Inherited queries perform access permission checks on the parent table only. Thus, for example, granting &lt;code&gt;UPDATE&lt;/code&gt; permission on the &lt;code&gt;cities&lt;/code&gt; table implies permission to update rows in the &lt;code&gt;capitals&lt;/code&gt; table as well, when they are accessed through &lt;code&gt;cities&lt;/code&gt;. This preserves the appearance that the data is (also) in the parent table. But the &lt;code&gt;capitals&lt;/code&gt; table could not be updated directly without an additional grant. In a similar way, the parent table's row security policies (see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;) are applied to rows coming from child tables during an inherited query. A child table's policies, if any, are applied only when it is the table explicitly named in the query; and in that case, any policies attached to its parent(s) are ignored.</source>
          <target state="translated">상속 된 쿼리는 부모 테이블에 대해서만 액세스 권한 검사를 수행합니다. 따라서, 예를 들어, 부여 &lt;code&gt;UPDATE&lt;/code&gt; 의 상의 권한을 &lt;code&gt;cities&lt;/code&gt; 테이블은의 업데이트 행에 대한 허가를 의미 &lt;code&gt;capitals&lt;/code&gt; 그들이 통해 액세스 할 때뿐만 아니라 테이블을 &lt;code&gt;cities&lt;/code&gt; . 이렇게하면 부모 테이블에 데이터가있는 것처럼 보이게됩니다. 그러나 추가 보조금 없이는 &lt;code&gt;capitals&lt;/code&gt; 테이블을 직접 업데이트 할 수 없습니다. 비슷한 방식으로 부모 테이블의 행 보안 정책 ( &lt;a href=&quot;ddl-rowsecurity&quot;&gt;섹션 5.8&lt;/a&gt; 참조))는 상속 된 쿼리 중에 자식 테이블에서 오는 행에 적용됩니다. 자식 테이블의 정책 (있는 경우)은 쿼리에서 명시 적으로 명명 된 테이블 인 경우에만 적용됩니다. 이 경우 상위에 연결된 모든 정책은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1f25aac16509c63c647e201e6dca9b42be580c36" translate="yes" xml:space="preserve">
          <source>Initialization Options</source>
          <target state="translated">초기화 옵션</target>
        </trans-unit>
        <trans-unit id="02678e4e52eadddd5b615833652cf8428b2afe6a" translate="yes" xml:space="preserve">
          <source>Initialization option string for the template</source>
          <target state="translated">템플릿의 초기화 옵션 문자열</target>
        </trans-unit>
        <trans-unit id="6528a9644e65de4c79a52fdab1106b0b771a6d92" translate="yes" xml:space="preserve">
          <source>Initialize the new cluster using &lt;code&gt;initdb&lt;/code&gt;. Again, use compatible &lt;code&gt;initdb&lt;/code&gt; flags that match the old cluster. Many prebuilt installers do this step automatically. There is no need to start the new cluster.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 를 사용하여 새 클러스터를 초기화하십시오 . 다시, 이전 클러스터와 일치하는 호환 가능한 &lt;code&gt;initdb&lt;/code&gt; 플래그를 사용 하십시오. 많은 사전 빌드 된 설치 프로그램이이 단계를 자동으로 수행합니다. 새 클러스터를 시작할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a5c551f4615e330d270ad5f3b0629fcdfcd3de2" translate="yes" xml:space="preserve">
          <source>Inner tuples are more complex, since they are branching points in the search tree. Each inner tuple contains a set of one or more &lt;em&gt;nodes&lt;/em&gt;, which represent groups of similar leaf values. A node contains a downlink that leads either to another, lower-level inner tuple, or to a short list of leaf tuples that all lie on the same index page. Each node normally has a &lt;em&gt;label&lt;/em&gt; that describes it; for example, in a radix tree the node label could be the next character of the string value. (Alternatively, an operator class can omit the node labels, if it works with a fixed set of nodes for all inner tuples; see &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;Section 65.4.2&lt;/a&gt;.) Optionally, an inner tuple can have a &lt;em&gt;prefix&lt;/em&gt; value that describes all its members. In a radix tree this could be the common prefix of the represented strings. The prefix value is not necessarily really a prefix, but can be any data needed by the operator class; for example, in a quad-tree it can store the central point that the four quadrants are measured with respect to. A quad-tree inner tuple would then also contain four nodes corresponding to the quadrants around this central point.</source>
          <target state="translated">내부 튜플은 검색 트리의 분기점이므로 더 복잡합니다. 각 내부 튜플에는 유사한 리프 값 그룹을 나타내는 하나 이상의 &lt;em&gt;노드&lt;/em&gt; 집합이 포함 됩니다. 노드에는 다른 하위 레벨 내부 튜플 또는 모두 동일한 색인 페이지에있는 짧은 잎 튜플 목록으로 연결되는 다운 링크가 포함되어 있습니다. 각 노드에는 일반적으로 이를 설명 하는 &lt;em&gt;레이블&lt;/em&gt; 이 있습니다. 예를 들어 기수 트리에서 노드 레이블은 문자열 값의 다음 문자가 될 수 있습니다. (또는 모든 내부 튜플에 대해 고정 된 노드 세트와 함께 작동하는 경우 연산자 클래스는 노드 레이블을 생략 할 수 있습니다 ( &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;섹션 65.4.2&lt;/a&gt; 참조 ). 선택적으로 내부 튜플에는 &lt;em&gt;접두사&lt;/em&gt; 가있을 수 있습니다.&lt;em&gt;&lt;/em&gt;모든 구성원을 설명하는 가치. 기수 트리에서 이는 표현 된 문자열의 공통 접두사 일 수 있습니다. 접두사 값은 반드시 접두사 일 필요는 없지만 연산자 클래스에 필요한 데이터 일 수 있습니다. 예를 들어, 쿼드 트리에는 4 개의 사분면이 측정되는 중심점을 저장할 수 있습니다. 쿼드 트리 내부 튜플은이 중심점 주위의 사분면에 해당하는 4 개의 노드도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0029fb34c419096901cb17ee7f69f8d100b925e7" translate="yes" xml:space="preserve">
          <source>Input Ordering</source>
          <target state="translated">입력 주문</target>
        </trans-unit>
        <trans-unit id="c651bb8d20d59b648e5817a714d081c24490bd28" translate="yes" xml:space="preserve">
          <source>Input String</source>
          <target state="translated">입력 문자열</target>
        </trans-unit>
        <trans-unit id="c42fb65381608e452debc58ec5ce5a7de90ede68" translate="yes" xml:space="preserve">
          <source>Input conversion function (binary format), or 0 if none</source>
          <target state="translated">입력 변환 함수 (이진 형식) 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="6ede32a74b25d24d933316273b8d1a1c5b311742" translate="yes" xml:space="preserve">
          <source>Input conversion function (text format)</source>
          <target state="translated">입력 변환 기능 (텍스트 형식)</target>
        </trans-unit>
        <trans-unit id="445431b172a9cb689a043786c27d77bc63ec81f4" translate="yes" xml:space="preserve">
          <source>Input data is interpreted according to &lt;code&gt;ENCODING&lt;/code&gt; option or the current client encoding, and output data is encoded in &lt;code&gt;ENCODING&lt;/code&gt; or the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server.</source>
          <target state="translated">입력 데이터는 &lt;code&gt;ENCODING&lt;/code&gt; 옵션 또는 현재 클라이언트 인코딩 에 따라 해석되며 , 데이터가 클라이언트를 통과하지 않고 서버에서 직접 파일을 읽거나 파일을 작성하더라도 출력 데이터는 &lt;code&gt;ENCODING&lt;/code&gt; 또는 현재 클라이언트 인코딩으로 인코딩됩니다. .</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="aa563adcb5d00e2fc3a73ea58d9fd1b265968174" translate="yes" xml:space="preserve">
          <source>Insert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column:</source>
          <target state="translated">분배자를 삽입하거나 기존의 제외 된 행 (행 삽입이 트리거되기 전에 일치하는 제한 컬럼이있는 행)이 존재하는 경우 삽입을 제안 된 행에 대해 아무 것도 수행하지 마십시오. 예에서는 &lt;code&gt;did&lt;/code&gt; 열에 나타나는 값을 제한하는 고유 인덱스가 정의되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1b0022e72f294401989398fe077aa7293c9d0864" translate="yes" xml:space="preserve">
          <source>Insert a new tuple into an existing index. The &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;isnull&lt;/code&gt; arrays give the key values to be indexed, and &lt;code&gt;heap_tid&lt;/code&gt; is the TID to be indexed. If the access method supports unique indexes (its &lt;code&gt;amcanunique&lt;/code&gt; flag is true) then &lt;code&gt;checkUnique&lt;/code&gt; indicates the type of uniqueness check to perform. This varies depending on whether the unique constraint is deferrable; see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt; for details. Normally the access method only needs the &lt;code&gt;heapRelation&lt;/code&gt; parameter when performing uniqueness checking (since then it will have to look into the heap to verify tuple liveness).</source>
          <target state="translated">기존 색인에 새 튜플을 삽입하십시오. &lt;code&gt;values&lt;/code&gt; 과 &lt;code&gt;isnull&lt;/code&gt; 배열은 인덱스 될 키 값을주고, &lt;code&gt;heap_tid&lt;/code&gt; 는 인덱싱 할 수있는 TID입니다. 액세스 방법이 고유 인덱스를 지원하는 경우 ( &lt;code&gt;amcanunique&lt;/code&gt; 플래그는 true) &lt;code&gt;checkUnique&lt;/code&gt; 는 수행 할 고유성 검사 유형을 나타냅니다. 이는 고유 제한 조건이 연기 가능한지 여부에 따라 다릅니다. 자세한 내용 &lt;a href=&quot;index-unique-checks&quot;&gt;은 61.5 절&lt;/a&gt; 을 참조하십시오. 일반적으로 액세스 방법에는 고유성 검사를 수행 할 때 &lt;code&gt;heapRelation&lt;/code&gt; 매개 변수 만 필요합니다 (따라서 튜플 라이브 니스를 확인하려면 힙을 조사해야합니다).</target>
        </trans-unit>
        <trans-unit id="0f674319e8780ea4807c4a4acfb9e949fb5f9a9e" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;distributors&lt;/code&gt;, returning the sequence number generated by the &lt;code&gt;DEFAULT&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 절에 의해 생성 된 시퀀스 번호를 리턴하여 단일 행을 테이블 &lt;code&gt;distributors&lt;/code&gt; 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="632c13df9b06de5c5de5b6f56617f6d898fc7280" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;films&lt;/code&gt; 단일 행을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="3892df53992670e16381ba584272763bbe059b7e" translate="yes" xml:space="preserve">
          <source>Insert new distributor if possible; otherwise &lt;code&gt;DO NOTHING&lt;/code&gt;. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column on a subset of rows where the &lt;code&gt;is_active&lt;/code&gt; Boolean column evaluates to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">가능하면 새 배포자를 삽입하십시오. 그렇지 않으면 &lt;code&gt;DO NOTHING&lt;/code&gt; 하지 마십시오 . 예에서는 &lt;code&gt;is_active&lt;/code&gt; 부울 열이 &lt;code&gt;true&lt;/code&gt; 로 평가되는 행의 하위 집합 에서 &lt;code&gt;did&lt;/code&gt; 열에 나타나는 값을 제한하는 고유 인덱스가 정의되었다고 가정 합니다 .</target>
        </trans-unit>
        <trans-unit id="db80c622e1c5ed5095a7dd936600840392c749b3" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. Note that the special &lt;code&gt;excluded&lt;/code&gt; table is used to reference values originally proposed for insertion:</source>
          <target state="translated">새 배포자를 적절하게 삽입하거나 업데이트하십시오. &lt;code&gt;did&lt;/code&gt; 열에 나타나는 값을 제한하는 고유 인덱스가 정의되었다고 가정합니다 . &lt;code&gt;excluded&lt;/code&gt; 특수 테이블은 원래 삽입을 위해 제안 된 값을 참조하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="449538b0ed8e6f507ea1c64d35164fae0d826023" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. &lt;code&gt;WHERE&lt;/code&gt; clause is used to limit the rows actually updated (any existing row not updated will still be locked, though):</source>
          <target state="translated">새 배포자를 적절하게 삽입하거나 업데이트하십시오. 예에서는 &lt;code&gt;did&lt;/code&gt; 열에 나타나는 값을 제한하는 고유 인덱스가 정의되었다고 가정합니다 . &lt;code&gt;WHERE&lt;/code&gt; 절은 실제로 업데이트 된 행을 제한하는 데 사용됩니다 (업데이트되지 않은 기존 행은 여전히 ​​잠겨 있음).</target>
        </trans-unit>
        <trans-unit id="ae6eaf6a32e43f0bf6ecef28e872215845bae1e6" translate="yes" xml:space="preserve">
          <source>Inserting</source>
          <target state="translated">Inserting</target>
        </trans-unit>
        <trans-unit id="0dd2b481ad724309af4e29174757be7f9ad67dd8" translate="yes" xml:space="preserve">
          <source>Inserting Data</source>
          <target state="translated">데이터 삽입</target>
        </trans-unit>
        <trans-unit id="a58e264f985643a8003e2d8ae2f19f1f44151747" translate="yes" xml:space="preserve">
          <source>Insertion into a GIN index can be slow due to the likelihood of many keys being inserted for each item. So, for bulk insertions into a table it is advisable to drop the GIN index and recreate it after finishing bulk insertion.</source>
          <target state="translated">각 항목에 많은 키를 삽입 할 가능성으로 인해 GIN 색인에 삽입하는 속도가 느려질 수 있습니다. 따라서 테이블에 대량 삽입하려면 대량 삽입을 마친 후에 GIN 색인을 삭제하고 다시 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a514639c0e9db066f2ca50c5677c9c0ad2871adb" translate="yes" xml:space="preserve">
          <source>Inside the crosstab grid, for each distinct value &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;colH&lt;/code&gt; and each distinct value &lt;code&gt;y&lt;/code&gt; of &lt;code&gt;colV&lt;/code&gt;, the cell located at the intersection &lt;code&gt;(x,y)&lt;/code&gt; contains the value of the &lt;code&gt;colD&lt;/code&gt; column in the query result row for which the value of &lt;code&gt;colH&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; and the value of &lt;code&gt;colV&lt;/code&gt; is &lt;code&gt;y&lt;/code&gt;. If there is no such row, the cell is empty. If there are multiple such rows, an error is reported.</source>
          <target state="translated">크로스 탭 그리드 내부 각 고유 값에 대한 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;colH&lt;/code&gt; 각 고유 값 &lt;code&gt;y&lt;/code&gt; 의 &lt;code&gt;colV&lt;/code&gt; , 교차점에 위치하는 셀 &lt;code&gt;(x,y)&lt;/code&gt; 의 값이 포함 된 &lt;code&gt;colD&lt;/code&gt; 가치있는 질의 결과 행 열 &lt;code&gt;colH&lt;/code&gt; 가 입니다 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;colV&lt;/code&gt; 값 은 &lt;code&gt;y&lt;/code&gt; 입니다. 그러한 행이 없으면 셀이 비어 있습니다. 이러한 행이 여러 개인 경우 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b00cb7892b66a87132bdd26b6401b8b521c81e40" translate="yes" xml:space="preserve">
          <source>Inspect the contents of the database to ensure you have recovered to the desired state. If not, return to step 1. If all is well, allow your users to connect by restoring &lt;code&gt;pg_hba.conf&lt;/code&gt; to normal.</source>
          <target state="translated">데이터베이스의 내용을 검사하여 원하는 상태로 복구했는지 확인하십시오. 그렇지 않은 경우 1 단계로 돌아가십시오. 모두 정상 이면 &lt;code&gt;pg_hba.conf&lt;/code&gt; 를 정상 으로 복원하여 사용자가 연결하도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb93c6938a2011d934988eab5986d385a4c4d0be" translate="yes" xml:space="preserve">
          <source>Inspecting the MCV list is possible using &lt;code&gt;pg_mcv_list_items&lt;/code&gt; set-returning function.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list_items&lt;/code&gt; 세트 복귀 기능을 사용하여 MCV리스트 검사가 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="ff17c423681bf713fcd55cb3b3eb644d120028a0" translate="yes" xml:space="preserve">
          <source>Inspired by the original &lt;code&gt;citext&lt;/code&gt; module by Donald Fraser.</source>
          <target state="translated">Donald Fraser 의 원본 &lt;code&gt;citext&lt;/code&gt; 모듈 에서 영감을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="e2f807d3934f67c59236ce54638758a511971353" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g. &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g. &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="translated">예를 들어, 새 클러스터로 기존 클러스터에서 사용하는 모든 사용자 정의 공유 객체 파일 (또는 DLL을)를 설치 &lt;code&gt;pgcrypto.so&lt;/code&gt; 가에서인지, &lt;code&gt;contrib&lt;/code&gt; 이나 다른 소스. 스키마 정의 (예 : &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt; )는 이전 클러스터에서 업그레이드되므로 설치하지 마십시오 . 또한 사용자 정의 전체 텍스트 검색 파일 (사전, 동의어, 동의어 사전, 중지 단어)도 새 클러스터에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad8735c38dbf2201c7954106ea9c90d304db5a72" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g., &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g., &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="translated">이전 클러스터에서 사용하는 사용자 지정 공유 객체 파일 (또는 DLL)을 새 클러스터 (예 : &lt;code&gt;pgcrypto.so&lt;/code&gt; )에 설치합니다 ( 예 : &lt;code&gt;contrib&lt;/code&gt; 또는 다른 소스 에서 가져옴 ) . 스키마 정의 (예 : &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt; )는 이전 클러스터에서 업그레이드되므로 설치하지 마십시오 . 또한 사용자 지정 전체 텍스트 검색 파일 (사전, 동의어, 동의어 사전, 불용어)도 새 클러스터에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a0968ed3e41692f76e13c55e2d74df0fcf64b5b" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database, placing its objects in schema &lt;code&gt;addons&lt;/code&gt;:</source>
          <target state="translated">설치 &lt;a href=&quot;hstore&quot;&gt;hstore의&lt;/a&gt; 스키마에서의 오브젝트를 배치, 현재 데이터베이스로 확장 &lt;code&gt;addons&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="34a5a70619c2c19e2c9702b13c9847e5c653791a" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database:</source>
          <target state="translated">현재 데이터베이스에 &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; 확장을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f7a627a6509f6c7b363a56555a0d35366acc62" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;postgres_fdw&lt;/code&gt; extension using &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION을&lt;/a&gt; 사용하여 &lt;code&gt;postgres_fdw&lt;/code&gt; 확장을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="9684579d3e7c9b1f5825f61e639d95625abccadc" translate="yes" xml:space="preserve">
          <source>Install the new server's binaries and support files. pg_upgrade is included in a default installation.</source>
          <target state="translated">새 서버의 바이너리 및 지원 파일을 설치하십시오. pg_upgrade는 기본 설치에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2992c5a571b6edb98a5bf527c86c020a33e35d" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;섹션 16.4에&lt;/a&gt; 요약 된대로 새 버전의 PostgreSQL을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7e4ec31b8bf1a9e0464c75a90e53710f79548e0" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html&quot;&gt;섹션 16.4에&lt;/a&gt; 설명 된대로 새 버전의 PostgreSQL을 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="90075fb521dd4d59c46ee65abf78d28b40851d8c" translate="yes" xml:space="preserve">
          <source>Install the same custom shared object files on the new standbys that you installed in the new primary cluster.</source>
          <target state="translated">새 기본 클러스터에 설치 한 새 대기에 동일한 사용자 정의 공유 오브젝트 파일을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="f0738ede58ba3533e9ba6fac10de77528d0eda5f" translate="yes" xml:space="preserve">
          <source>Installing an extension as superuser requires trusting that the extension's author wrote the extension installation script in a secure fashion. It is not terribly difficult for a malicious user to create trojan-horse objects that will compromise later execution of a carelessly-written extension script, allowing that user to acquire superuser privileges. However, trojan-horse objects are only hazardous if they are in the &lt;code&gt;search_path&lt;/code&gt; during script execution, meaning that they are in the extension's installation target schema or in the schema of some extension it depends on. Therefore, a good rule of thumb when dealing with extensions whose scripts have not been carefully vetted is to install them only into schemas for which CREATE privilege has not been and will not be granted to any untrusted users. Likewise for any extensions they depend on.</source>
          <target state="translated">수퍼 유저로 확장을 설치하려면 확장의 작성자가 확장 설치 스크립트를 안전한 방식으로 작성했음을 신뢰해야합니다. 악의적 인 사용자가 나중에 부주의하게 작성된 확장 스크립트의 실행을 손상시켜 해당 사용자가 수퍼 유저 권한을 얻을 수 있도록하는 트로이 목마 개체를 만드는 것은 그리 어렵지 않습니다. 그러나 트로이 목마 개체는 &lt;code&gt;search_path&lt;/code&gt; 에있는 경우에만 위험합니다.이는 스크립트 실행 중에 확장의 설치 대상 스키마 또는 종속 된 일부 확장의 스키마에 있음을 의미합니다. 따라서 스크립트가 신중하게 검사되지 않은 확장을 다룰 때 경험상 좋은 규칙은 CREATE 권한이없는 스키마에만 설치하고 신뢰할 수없는 사용자에게 부여하지 않을 것입니다. 그들이 의존하는 모든 확장에 대해서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="00a4641a5ec01b91ac5755c29e1f7d10ca370b2e" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_int&lt;/code&gt; extension creates a text search template &lt;code&gt;intdict_template&lt;/code&gt; and a dictionary &lt;code&gt;intdict&lt;/code&gt; based on it, with the default parameters. You can alter the parameters, for example</source>
          <target state="translated">&lt;code&gt;dict_int&lt;/code&gt; 확장을 설치하면 기본 매개 변수를 사용하여 텍스트 검색 템플리트 &lt;code&gt;intdict_template&lt;/code&gt; 및이를 기반으로 하는 사전 &lt;code&gt;intdict&lt;/code&gt; 가 작성됩니다. 예를 들어 매개 변수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88a4b249e71fce074c62157e59fbc27119675b0b" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_xsyn&lt;/code&gt; extension creates a text search template &lt;code&gt;xsyn_template&lt;/code&gt; and a dictionary &lt;code&gt;xsyn&lt;/code&gt; based on it, with default parameters. You can alter the parameters, for example</source>
          <target state="translated">&lt;code&gt;dict_xsyn&lt;/code&gt; 확장을 설치하면 기본 매개 변수를 사용하여 텍스트 검색 템플리트 &lt;code&gt;xsyn_template&lt;/code&gt; 및이를 기반으로 하는 사전 &lt;code&gt;xsyn&lt;/code&gt; 이 작성됩니다. 예를 들어 매개 변수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf52efd63633f939852f89750e72d737a7ef8451" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;unaccent&lt;/code&gt; extension creates a text search template &lt;code&gt;unaccent&lt;/code&gt; and a dictionary &lt;code&gt;unaccent&lt;/code&gt; based on it. The &lt;code&gt;unaccent&lt;/code&gt; dictionary has the default parameter setting &lt;code&gt;RULES='unaccent'&lt;/code&gt;, which makes it immediately usable with the standard &lt;code&gt;unaccent.rules&lt;/code&gt; file. If you wish, you can alter the parameter, for example</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 확장을 설치하면 텍스트 검색 템플릿이 &lt;code&gt;unaccent&lt;/code&gt; 없고 텍스트 기반 의 사전이 &lt;code&gt;unaccent&lt;/code&gt; 없습니다. &lt;code&gt;unaccent&lt;/code&gt; 사전은 기본 파라미터 설정이 &lt;code&gt;RULES='unaccent'&lt;/code&gt; 표준에 즉시 사용할 수 있습니다, &lt;code&gt;unaccent.rules&lt;/code&gt; 파일을. 원하는 경우 매개 변수를 변경할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="5f97f8775628e86310829ab9e8c465258ab92a5e" translate="yes" xml:space="preserve">
          <source>Instance</source>
          <target state="translated">Instance</target>
        </trans-unit>
        <trans-unit id="5b4ebcd87748b86d7b51facd78d76e7b88a0adf7" translate="yes" xml:space="preserve">
          <source>Instead of an expression, &lt;code&gt;*&lt;/code&gt; can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write &lt;code&gt;table_name.*&lt;/code&gt; as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with &lt;code&gt;AS&lt;/code&gt;; the output column names will be the same as the table columns' names.</source>
          <target state="translated">표현식 대신에 &lt;code&gt;*&lt;/code&gt; 를 선택된 행의 모든 ​​열에 대한 속기로 출력 목록에 쓸 수 있습니다. 또한 &lt;code&gt;table_name.*&lt;/code&gt; 을 해당 테이블에서 오는 열의 약어로 작성할 수 있습니다 . 이 경우 &lt;code&gt;AS&lt;/code&gt; 로 새 이름을 지정할 수 없습니다 . 출력 열 이름은 테이블 열 이름과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a6521c09d55a0d983da28cb3b1223e411f459cda" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;amgettuple&lt;/code&gt;, an index scan can be done with &lt;code&gt;amgetbitmap&lt;/code&gt; to fetch all tuples in one call. This can be noticeably more efficient than &lt;code&gt;amgettuple&lt;/code&gt; because it allows avoiding lock/unlock cycles within the access method. In principle &lt;code&gt;amgetbitmap&lt;/code&gt; should have the same effects as repeated &lt;code&gt;amgettuple&lt;/code&gt; calls, but we impose several restrictions to simplify matters. First of all, &lt;code&gt;amgetbitmap&lt;/code&gt; returns all tuples at once and marking or restoring scan positions isn't supported. Secondly, the tuples are returned in a bitmap which doesn't have any specific ordering, which is why &lt;code&gt;amgetbitmap&lt;/code&gt; doesn't take a &lt;code&gt;direction&lt;/code&gt; argument. (Ordering operators will never be supplied for such a scan, either.) Also, there is no provision for index-only scans with &lt;code&gt;amgetbitmap&lt;/code&gt;, since there is no way to return the contents of index tuples. Finally, &lt;code&gt;amgetbitmap&lt;/code&gt; does not guarantee any locking of the returned tuples, with implications spelled out in &lt;a href=&quot;index-locking&quot;&gt;Section 61.4&lt;/a&gt;.</source>
          <target state="translated">대신에 사용하는 &lt;code&gt;amgettuple&lt;/code&gt; 를 , 인덱스 스캔을 수행 할 수 있습니다 &lt;code&gt;amgetbitmap&lt;/code&gt; 한 전화에있는 모든 튜플을 가져. 액세스 방법 내에서 잠금 / 잠금 해제주기를 피할 수 있기 때문에 &lt;code&gt;amgettuple&lt;/code&gt; 보다 훨씬 효율적일 수 있습니다 . 기본적으로 &lt;code&gt;amgetbitmap&lt;/code&gt; 은 반복적 인 &lt;code&gt;amgettuple&lt;/code&gt; 호출 과 동일한 효과를 가져야 하지만 문제를 단순화하기 위해 몇 가지 제한을 적용합니다. 우선, &lt;code&gt;amgetbitmap&lt;/code&gt; 은 모든 튜플을 한 번에 반환하며 스캔 위치 표시 또는 복원은 지원되지 않습니다. 둘째, 튜플은 특정 순서가없는 비트 맵으로 반환되므로 &lt;code&gt;amgetbitmap&lt;/code&gt; 이 &lt;code&gt;direction&lt;/code&gt; 취하지 않는 이유논의. (주문 연산자는 이러한 스캔에도 제공되지 않습니다.) 또한 인덱스 튜플의 컨텐츠를 리턴 할 방법이 없으므로 &lt;code&gt;amgetbitmap&lt;/code&gt; 을 사용 하여 인덱스 전용 스캔을 제공 할 수 없습니다. 마지막으로, &lt;code&gt;amgetbitmap&lt;/code&gt; 은 반환 된 튜플의 잠금을 보장하지 않으며 &lt;a href=&quot;index-locking&quot;&gt;61.4 절에&lt;/a&gt; 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="d79849f61d583b44d9d0fdc8025d98ffb5bbfd35" translate="yes" xml:space="preserve">
          <source>Instead of writing &lt;code&gt;ONLY&lt;/code&gt; before the table name, you can write &lt;code&gt;*&lt;/code&gt; after the table name to explicitly specify that descendant tables are included. There is no real reason to use this syntax any more, because searching descendant tables is now always the default behavior. However, it is supported for compatibility with older releases.</source>
          <target state="translated">테이블 이름 &lt;code&gt;ONLY&lt;/code&gt; 쓰는 대신 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 쓰면 하위 테이블이 포함되도록 명시 적으로 지정할 수 있습니다. 하위 테이블 검색은 항상 기본 동작이므로이 구문을 더 이상 사용할 이유가 없습니다. 그러나 이전 릴리스와의 호환성을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4a1635249102b1ddea4769929b8a71df3f648e09" translate="yes" xml:space="preserve">
          <source>Institute of Electrical and Electronics Engineers</source>
          <target state="translated">전기 전자 공학회</target>
        </trans-unit>
        <trans-unit id="e877a09ab092ea6de15878a42ea4226bbdc6693d" translate="yes" xml:space="preserve">
          <source>Integer bit mask indicating which arguments are not being included in the current grouping set</source>
          <target state="translated">현재 그룹화 세트에 포함되지 않은 인수를 나타내는 정수 비트 마스크</target>
        </trans-unit>
        <trans-unit id="03c1016d0a2fd0151189914ddf3d90f010d5ee41" translate="yes" xml:space="preserve">
          <source>Integer quotient of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt; (truncates towards zero)</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;y&lt;/code&gt; &lt;/em&gt; / &lt;em&gt; &lt;code&gt;x&lt;/code&gt; &lt;/em&gt; 의 정수 몫 (0쪽으로 자름)</target>
        </trans-unit>
        <trans-unit id="897c83dd3fcb5ef382c1b65917bd9be2f5323fd2" translate="yes" xml:space="preserve">
          <source>Inter-Process Communication</source>
          <target state="translated">프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="d85d227df828a06ee1ce26f9f247a35c482de85a" translate="yes" xml:space="preserve">
          <source>Interesting idea for picking passwords.</source>
          <target state="translated">비밀번호 선택에 대한 흥미로운 아이디어.</target>
        </trans-unit>
        <trans-unit id="457737863c2801b7971002cd15c9223e0c9b404e" translate="yes" xml:space="preserve">
          <source>Interfacing with monitoring software to report errors</source>
          <target state="translated">모니터링 소프트웨어와 인터페이스하여 오류보고</target>
        </trans-unit>
        <trans-unit id="bc34e531672634aab3b26d4017b45aa2bbc7b3db" translate="yes" xml:space="preserve">
          <source>Interfacing with other backup and recovery software</source>
          <target state="translated">다른 백업 및 복구 소프트웨어와 인터페이스</target>
        </trans-unit>
        <trans-unit id="ec9a27bfbcfba0ca31c61c9c952115c2287d92f0" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set.</source>
          <target state="translated">기존 루트 인증서로 연결되는 중간 인증서는 클라이언트에 저장하지 않으려는 경우 &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; 파일에 나타날 수도 있습니다 (루트 및 중간 인증서가 &lt;code&gt;v3_ca&lt;/code&gt; 확장 으로 생성되었다고 가정 ). 매개 변수 &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; 이 설정된 경우 인증서 폐기 목록 (CRL) 항목도 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="087813fa40caa10b888af01dbc97f7437b81b67d" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set. (See &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; for diagrams showing SSL certificate usage.)</source>
          <target state="translated">클라이언트에 저장하지 않으려는 경우 (루트 및 중간 인증서가 &lt;code&gt;v3_ca&lt;/code&gt; 확장자 로 작성된 경우) 기존 루트 인증서에 연결되는 중간 인증서도 &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; 파일에 나타날 수 있습니다 . &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; 매개 변수 가 설정되어 있으면 CRL (인증서 해지 목록) 항목도 확인됩니다 . SSL 인증서 사용을 보여주는 다이어그램 은 &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8784a00f8fa083e2a06f38fd51cc35a39bb77fca" translate="yes" xml:space="preserve">
          <source>Internal access to the system catalogs is not done using the isolation level of the current transaction. This means that newly created database objects such as tables are visible to concurrent Repeatable Read and Serializable transactions, even though the rows they contain are not. In contrast, queries that explicitly examine the system catalogs don't see rows representing concurrently created database objects, in the higher isolation levels.</source>
          <target state="translated">시스템 카탈로그에 대한 내부 액세스는 현재 트랜잭션의 격리 수준을 사용하여 수행되지 않습니다. 즉, 테이블과 같이 새로 생성 된 데이터베이스 개체는 포함 된 행이 아닌 경우에도 동시 반복 읽기 및 직렬화 가능 트랜잭션에 표시됩니다. 반대로 시스템 카탈로그를 명시 적으로 검사하는 쿼리는 더 높은 격리 수준에서 동시에 생성 된 데이터베이스 개체를 나타내는 행을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6ed083a1fd80d11b5474ab6a44b299da8513f67" translate="yes" xml:space="preserve">
          <source>Internal data structures such as &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;pg_subtrans&lt;/code&gt;, &lt;code&gt;pg_multixact&lt;/code&gt;, &lt;code&gt;pg_serial&lt;/code&gt;, &lt;code&gt;pg_notify&lt;/code&gt;, &lt;code&gt;pg_stat&lt;/code&gt;, &lt;code&gt;pg_snapshots&lt;/code&gt; are not directly checksummed, nor are pages protected by full page writes. However, where such data structures are persistent, WAL records are written that allow recent changes to be accurately rebuilt at crash recovery and those WAL records are protected as discussed above.</source>
          <target state="translated">&lt;code&gt;pg_xact&lt;/code&gt; , &lt;code&gt;pg_subtrans&lt;/code&gt; , &lt;code&gt;pg_multixact&lt;/code&gt; , &lt;code&gt;pg_serial&lt;/code&gt; , &lt;code&gt;pg_notify&lt;/code&gt; , &lt;code&gt;pg_stat&lt;/code&gt; , &lt;code&gt;pg_snapshots&lt;/code&gt; 와 같은 내부 데이터 구조 는 직접 체크섬되지 않으며 페이지를 전체 페이지 쓰기로 보호하지 않습니다. 그러나 이러한 데이터 구조가 지속되는 경우 응급 복구시 최근 변경 내용을 정확하게 다시 작성할 수 있도록 WAL 레코드가 작성되며 이러한 WAL 레코드는 위에서 설명한대로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="210293c0eebe094c6cf4191095ebf7c83ba53d58" translate="yes" xml:space="preserve">
          <source>Internal hash code, computed from the statement's parse tree</source>
          <target state="translated">명령문의 구문 분석 트리에서 계산 된 내부 해시 코드</target>
        </trans-unit>
        <trans-unit id="e2daadb2e211983a80b38897bed9d140e91cd8e5" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;interval&lt;/code&gt; values are stored as months, days, and seconds. This is done because the number of days in a month varies, and a day can have 23 or 25 hours if a daylight savings time adjustment is involved. The months and days fields are integers while the seconds field can store fractions. Because intervals are usually created from constant strings or &lt;code&gt;timestamp&lt;/code&gt; subtraction, this storage method works well in most cases, but can cause unexpected results:</source>
          <target state="translated">내부 &lt;code&gt;interval&lt;/code&gt; 값은 월, 일 및 초로 저장됩니다. 이는 한 달의 일 수가 다르고 일광 절약 시간제 조정이 포함 된 경우 하루에 23 시간 또는 25 시간이있을 수 있기 때문에 수행됩니다. 월 및 일 필드는 정수이고 초 필드는 분수를 저장할 수 있습니다. 간격은 일반적으로 상수 문자열 또는 &lt;code&gt;timestamp&lt;/code&gt; 빼기 에서 만들어 지므로이 저장 방법은 대부분의 경우 잘 작동하지만 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d68b94ef37a16fd1db6257f62457d5c440b435" translate="yes" xml:space="preserve">
          <source>Internally, a GIN index contains a B-tree index constructed over keys, where each key is an element of one or more indexed items (a member of an array, for example) and where each tuple in a leaf page contains either a pointer to a B-tree of heap pointers (a &amp;ldquo;posting tree&amp;rdquo;), or a simple list of heap pointers (a &amp;ldquo;posting list&amp;rdquo;) when the list is small enough to fit into a single index tuple along with the key value. &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;Figure 66.1&lt;/a&gt; illustrates these components of a GIN index.</source>
          <target state="translated">내부적으로 GIN 인덱스는 키에 대해 구성된 B- 트리 인덱스를 포함합니다. 여기서 각 키는 하나 이상의 인덱싱 된 항목 (예 : 배열의 멤버)의 요소이며 리프 페이지의 각 튜플은 리스트가 키 값과 함께 단일 인덱스 튜플에 맞을만큼 작을 때 힙 포인터의 B- 트리 ( &quot;포스팅 트리&quot;) 또는 간단한 힙 포인터 목록 ( &quot;포스팅 목록&quot;). &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;그림 66.1&lt;/a&gt; 은 이러한 GIN 인덱스 구성 요소를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7c7cae0387037fdfc011139b31adb37771e499bb" translate="yes" xml:space="preserve">
          <source>Internally, all these types use the same representation (a 64-bit integer), and all are interchangeable. Multiple types are provided to control display formatting and to permit tighter validity checking of input that is supposed to denote one particular type of number.</source>
          <target state="translated">내부적으로 이러한 모든 유형은 동일한 표현 (64 비트 정수)을 사용하며 모두 호환 가능합니다. 디스플레이 형식을 제어하고 특정 유형의 숫자를 나타내는 입력의 유효성 검사를보다 엄격하게하기 위해 여러 유형이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="801996043d0146904ef0a7b7426c0b0decab6e65" translate="yes" xml:space="preserve">
          <source>Internally, an LSN is a 64-bit integer, representing a byte position in the write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 digits each, separated by a slash; for example, &lt;code&gt;16/B374D848&lt;/code&gt;. The &lt;code&gt;pg_lsn&lt;/code&gt; type supports the standard comparison operators, like &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. Two LSNs can be subtracted using the &lt;code&gt;-&lt;/code&gt; operator; the result is the number of bytes separating those write-ahead log locations.</source>
          <target state="translated">내부적으로 LSN은 미리 쓰기 로그 스트림에서 바이트 위치를 나타내는 64 비트 정수입니다. 슬래시로 구분하여 각각 최대 8 자리의 두 개의 16 진수로 인쇄됩니다. 예를 들어 &lt;code&gt;16/B374D848&lt;/code&gt; 입니다. &lt;code&gt;pg_lsn&lt;/code&gt; 의 유형은 표준 비교 연산자와 같은 지원 &lt;code&gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;code&gt;-&lt;/code&gt; 연산자를 사용하여 두 개의 LSN을 뺄 수 있습니다 . 결과는 미리 쓰기 로그 위치를 분리하는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="68baab823cf9c4d570311e278e9e088b97918aa9" translate="yes" xml:space="preserve">
          <source>Internals: BRIN Indexes</source>
          <target state="translated">내부 : BRIN 지수</target>
        </trans-unit>
        <trans-unit id="30d8bd593f993584038a1e0fe42a81f00b0963a3" translate="yes" xml:space="preserve">
          <source>Internals: Catalogs</source>
          <target state="translated">내부 : 카탈로그</target>
        </trans-unit>
        <trans-unit id="3af4bd3be7009ecb5492dd21a7a43e553ce2cd0e" translate="yes" xml:space="preserve">
          <source>Internals: GIN Indexes</source>
          <target state="translated">내부 : GIN 지수</target>
        </trans-unit>
        <trans-unit id="dc575f859035c87eddb3703eb9f32faa91a064d5" translate="yes" xml:space="preserve">
          <source>Internals: Genetic Query Optimizer</source>
          <target state="translated">내부 : 유전자 쿼리 최적화 프로그램</target>
        </trans-unit>
        <trans-unit id="2fdd0d171f1a82304db06140f5b0e0b132641e9d" translate="yes" xml:space="preserve">
          <source>Internals: GiST Indexes</source>
          <target state="translated">내부 : GiST 지수</target>
        </trans-unit>
        <trans-unit id="3353317a88b7d0fe5733c291ee0c6066760bb027" translate="yes" xml:space="preserve">
          <source>Internals: Index Access Method</source>
          <target state="translated">내부 : 색인 액세스 방법</target>
        </trans-unit>
        <trans-unit id="2cfa78663fb409507ad30892f6c62ca88915c849" translate="yes" xml:space="preserve">
          <source>Internals: Physical Storage</source>
          <target state="translated">내부 : 물리적 저장</target>
        </trans-unit>
        <trans-unit id="72bd21b653073da0193a18c2b147b4e07c551c2d" translate="yes" xml:space="preserve">
          <source>Internals: SP-GiST Indexes</source>
          <target state="translated">내부 : SP-GiST 인덱스</target>
        </trans-unit>
        <trans-unit id="9a4222dfc9fdc77f19f92dba6e20438075629f39" translate="yes" xml:space="preserve">
          <source>International Electrotechnical Commission</source>
          <target state="translated">국제 전자 기술위원회</target>
        </trans-unit>
        <trans-unit id="efd83bf4b70a77811c228aa3f499876839b1a079" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization</source>
          <target state="translated">국제 표준화기구</target>
        </trans-unit>
        <trans-unit id="2bafd8d16b13f2565f9ae12e4063fa2d0cddcfb9" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">새로운 EAN13 디스플레이 형식으로 표시 될 국제 표준 도서 번호</target>
        </trans-unit>
        <trans-unit id="08b688b4eb6cf112f11ba47bac6e099bfb8d453f" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the old short display format</source>
          <target state="translated">기존의 짧은 표시 형식으로 표시 될 국제 표준 도서 번호</target>
        </trans-unit>
        <trans-unit id="ebb2e09bb43f37cc7a01fd763ee8d3845536f4c8" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">새로운 EAN13 디스플레이 형식으로 표시 될 국제 표준 음악 번호</target>
        </trans-unit>
        <trans-unit id="ef34d5e58a9ceadea54e7a66e1ff9112f05b0da0" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the old short display format</source>
          <target state="translated">기존의 짧은 표시 형식으로 표시 될 국제 표준 음악 번호</target>
        </trans-unit>
        <trans-unit id="8dd6340c1b5827c9a707b92916af32dcdcd785bc" translate="yes" xml:space="preserve">
          <source>International Standard Serial Number</source>
          <target state="translated">국제 표준 일련 번호</target>
        </trans-unit>
        <trans-unit id="4e1c1c5e087cdba177b1e3d204777d49f8f64412" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">새로운 EAN13 디스플레이 형식으로 표시 될 국제 표준 일련 번호</target>
        </trans-unit>
        <trans-unit id="105b56360755198078a6d52573dd0840458a5750" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the old short display format</source>
          <target state="translated">기존의 짧은 표시 형식으로 표시 될 국제 표준 일련 번호</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="8fa33d4271f21b38b9499a714668d1694939db92" translate="yes" xml:space="preserve">
          <source>Interpreting Results</source>
          <target state="translated">결과 해석</target>
        </trans-unit>
        <trans-unit id="27d548cba7b30ac38c7cf5611fd348dac11ee53d" translate="yes" xml:space="preserve">
          <source>Interpreting the actual data can only be done with information obtained from other tables, mostly &lt;code&gt;pg_attribute&lt;/code&gt;. The key values needed to identify field locations are &lt;code&gt;attlen&lt;/code&gt; and &lt;code&gt;attalign&lt;/code&gt;. There is no way to directly get a particular attribute, except when there are only fixed width fields and no null values. All this trickery is wrapped up in the functions &lt;em&gt;heap_getattr&lt;/em&gt;, &lt;em&gt;fastgetattr&lt;/em&gt; and &lt;em&gt;heap_getsysattr&lt;/em&gt;.</source>
          <target state="translated">실제 데이터 해석은 다른 테이블에서 얻은 정보 (주로 &lt;code&gt;pg_attribute&lt;/code&gt; ) 로만 수행 할 수 있습니다 . 필드 위치를 식별하는 데 필요한 키 값이된다 &lt;code&gt;attlen&lt;/code&gt; 및 &lt;code&gt;attalign&lt;/code&gt; . 고정 너비 필드 만 있고 널값이없는 경우를 제외하고는 특정 속성을 직접 가져올 수있는 방법이 없습니다. 이 모든 속임수는 &lt;em&gt;heap_getattr&lt;/em&gt; , &lt;em&gt;fastgetattr&lt;/em&gt; 및 &lt;em&gt;heap_getsysattr&lt;/em&gt; 함수에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24238f9afeb08c45bbce6cbe5bfc823ad38ca9fd" translate="yes" xml:space="preserve">
          <source>Intersects?</source>
          <target state="translated">Intersects?</target>
        </trans-unit>
        <trans-unit id="4e15cd1f984843596070878cf276c50b3a281208" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</source>
          <target state="translated">간격에서 &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; 에 &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264b54df84208c3c82823ada24d9901903b36609" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;y&lt;/code&gt; 까지의 간격</target>
        </trans-unit>
        <trans-unit id="d6c942376df50e42c9c8ec0a3deb9eba3459225b" translate="yes" xml:space="preserve">
          <source>Interval values can also be written as ISO 8601 time intervals, using either the &amp;ldquo;format with designators&amp;rdquo; of the standard's section 4.4.3.2 or the &amp;ldquo;alternative format&amp;rdquo; of section 4.4.3.3. The format with designators looks like this:</source>
          <target state="translated">간격 값은 표준 섹션 4.4.3.2의 &quot;지정자가있는 형식&quot;또는 섹션 4.4.3.3의 &quot;대체 형식&quot;을 사용하여 ISO 8601 시간 간격으로 기록 될 수도 있습니다. 부호가있는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e96fd04cfd40c6866ae4fadc2523f325bbca5474" translate="yes" xml:space="preserve">
          <source>Intuitively, the larger the &lt;code&gt;parameter&lt;/code&gt;, the more frequently values close to &lt;code&gt;min&lt;/code&gt; are accessed, and the less frequently values close to &lt;code&gt;max&lt;/code&gt; are accessed. The closer to 0 &lt;code&gt;parameter&lt;/code&gt; is, the flatter (more uniform) the access distribution. A crude approximation of the distribution is that the most frequent 1% values in the range, close to &lt;code&gt;min&lt;/code&gt;, are drawn &lt;code&gt;parameter&lt;/code&gt;% of the time. The &lt;code&gt;parameter&lt;/code&gt; value must be strictly positive.</source>
          <target state="translated">직관적으로 &lt;code&gt;parameter&lt;/code&gt; 가 클수록 &lt;code&gt;min&lt;/code&gt; 에 가까운 값에 더 자주 액세스하고 &lt;code&gt;max&lt;/code&gt; 에 가까운 값에 덜 액세스합니다. 0에 가까워 &lt;code&gt;parameter&lt;/code&gt; 상기 편평 (균일) 액세스 분포이다. 분포의 대략적인 근사값은 &lt;code&gt;min&lt;/code&gt; 에 가까운 범위에서 가장 빈번한 1 % 값 이 시간의 &lt;code&gt;parameter&lt;/code&gt; %로 그려진다 는 것입니다. &lt;code&gt;parameter&lt;/code&gt; 값은 엄격하게 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="fa5dcf3086d32573b28d785efef236569ee934d3" translate="yes" xml:space="preserve">
          <source>Inverse cosine, result in degrees</source>
          <target state="translated">역 코사인, 결과도</target>
        </trans-unit>
        <trans-unit id="65156637d01418342819a73cb6f0c84ed3aadd9b" translate="yes" xml:space="preserve">
          <source>Inverse cosine, result in radians</source>
          <target state="translated">역 코사인, 결과 라디안</target>
        </trans-unit>
        <trans-unit id="044acbc59a99d5be1dcd2df39272182f119202c9" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine</source>
          <target state="translated">역 쌍곡 코사인</target>
        </trans-unit>
        <trans-unit id="aa52c84bd7eb12aa1c433c5d2762f1447b2f7569" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine</source>
          <target state="translated">역 쌍곡 사인</target>
        </trans-unit>
        <trans-unit id="d2adf2990a26a6381a709615ea39f05a1bb69453" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent</source>
          <target state="translated">역 쌍곡 탄젠트</target>
        </trans-unit>
        <trans-unit id="76a2b17d6de61349537c2d6805d0dd47465a55e8" translate="yes" xml:space="preserve">
          <source>Inverse sine, result in degrees</source>
          <target state="translated">역 사인, 결과도</target>
        </trans-unit>
        <trans-unit id="c2443561103c4f30b566171f3e2681acb12058ea" translate="yes" xml:space="preserve">
          <source>Inverse sine, result in radians</source>
          <target state="translated">역 사인, 결과 라디안</target>
        </trans-unit>
        <trans-unit id="0e43d0792058a59dfb9b5584a76b17083ea3f125" translate="yes" xml:space="preserve">
          <source>Inverse tangent of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;, result in degrees</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;y&lt;/code&gt; &lt;/em&gt; / &lt;em&gt; &lt;code&gt;x&lt;/code&gt; &lt;/em&gt; 의 역 탄젠트 , 결과도</target>
        </trans-unit>
        <trans-unit id="43cbfde7a6966208306cd1536838dca692e6b35d" translate="yes" xml:space="preserve">
          <source>Inverse tangent of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;, result in radians</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;y&lt;/code&gt; &lt;/em&gt; / &lt;em&gt; &lt;code&gt;x&lt;/code&gt; &lt;/em&gt; 의 역 탄젠트 , 결과 라디안</target>
        </trans-unit>
        <trans-unit id="7c7267a29db6fb274a599fb9151d3055e43e152d" translate="yes" xml:space="preserve">
          <source>Inverse tangent, result in degrees</source>
          <target state="translated">역 탄젠트, 결과 각도</target>
        </trans-unit>
        <trans-unit id="d9e9282eef441e5d3e97532b28f7543960a0fda3" translate="yes" xml:space="preserve">
          <source>Inverse tangent, result in radians</source>
          <target state="translated">역 탄젠트, 결과 라디안</target>
        </trans-unit>
        <trans-unit id="d4c4d2a44d0c1732fb4957da686a2c8c6fd4c621" translate="yes" xml:space="preserve">
          <source>Inverse transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">이동 집계 모드에 대한 역 전이 기능 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="28b7eaaae619dbbc89f335962aef4470def2f3e3" translate="yes" xml:space="preserve">
          <source>Invoke &lt;code&gt;VACUUM&lt;/code&gt; on the standard tables.</source>
          <target state="translated">표준 테이블에서 &lt;code&gt;VACUUM&lt;/code&gt; 을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3018fd4dab61ebc08a8223638bc64040a2d9e057" translate="yes" xml:space="preserve">
          <source>Is above (allows touching)?</source>
          <target state="translated">위가 (만져도됩니까)?</target>
        </trans-unit>
        <trans-unit id="da6fc6925748c3c1aaf71338cad9d5f477a2383e" translate="yes" xml:space="preserve">
          <source>Is below (allows touching)?</source>
          <target state="translated">아래에 있습니까 (만질 수 있습니까)?</target>
        </trans-unit>
        <trans-unit id="4cde919e343d25f19646be89eb578d4418ea8a44" translate="yes" xml:space="preserve">
          <source>Is collation visible in search path?</source>
          <target state="translated">검색 경로에 데이터 정렬이 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="fa29522fdb9c9289837f5d8f7d870cd6a67b34d7" translate="yes" xml:space="preserve">
          <source>Is conversion visible in search path?</source>
          <target state="translated">전환이 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="94be39b60eecf97da6c05767e63714ce3bb576d4" translate="yes" xml:space="preserve">
          <source>Is first &lt;code&gt;tsquery&lt;/code&gt; contained in the second? (This considers only whether all the lexemes appearing in one query appear in the other, ignoring the combining operators.)</source>
          <target state="translated">첫 번째 &lt;code&gt;tsquery&lt;/code&gt; 가 두 번째에 포함되어 있습니까? (이는 결합 연산자를 무시하고 한 쿼리에 나타나는 모든 용어가 다른 쿼리에 나타나는지 여부 만 고려합니다.)</target>
        </trans-unit>
        <trans-unit id="c1572ea1eb7fef37d46de7513f84f0e67fb37082" translate="yes" xml:space="preserve">
          <source>Is first object above second (allows edges to touch)?</source>
          <target state="translated">첫 번째 개체가 두 번째 위에 있습니까 (가장자리가 닿을 수 있음)?</target>
        </trans-unit>
        <trans-unit id="c505339eacef9319fd285351332723a55918638e" translate="yes" xml:space="preserve">
          <source>Is first object below second (allows edges to touch)?</source>
          <target state="translated">첫 번째 개체가 두 번째 아래에 있습니까 (가장자리가 닿을 수 있음)?</target>
        </trans-unit>
        <trans-unit id="e5bac705c5e60b2475e9b17e98087c0990a2c946" translate="yes" xml:space="preserve">
          <source>Is first object contained in or on second? Available for these pairs of types: (&lt;code id=&quot;point&quot;&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;), (&lt;code&gt;box&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;circle&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;).</source>
          <target state="translated">첫 번째 개체가 두 번째에 포함되어 있습니까? ( &lt;code id=&quot;point&quot;&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; ), ( &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;lseg&lt;/code&gt; ), ( &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; ), ( &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;path&lt;/code&gt; ), ( &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; ), ( &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; ), ( &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; ), ( &lt;code&gt;lseg&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; ), ( &lt;code&gt;lseg&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; ), ( &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; ), ( &lt;code&gt;circle&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e54349160763b512bf27d165196d02b1f67231a" translate="yes" xml:space="preserve">
          <source>Is first object strictly above second? (This operator is misnamed; it should be &lt;code id=&quot;1246262&quot;&gt;|&amp;gt;&amp;gt;&lt;/code&gt;.)</source>
          <target state="translated">첫 번째 개체가 엄격하게 두 번째 개체보다 높습니까? (이 연산자는 이름이 잘못되었습니다. &lt;code id=&quot;1246262&quot;&gt;|&amp;gt;&amp;gt;&lt;/code&gt; 이어야합니다 .)</target>
        </trans-unit>
        <trans-unit id="2ba666af39de93d6cf6a684c0aa3dde8c77aa45b" translate="yes" xml:space="preserve">
          <source>Is first object strictly above second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">첫 번째 개체가 엄격하게 두 번째 개체보다 높습니까? 가능 &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a74a8665c56409f78bc9b13ad274898bb226d641" translate="yes" xml:space="preserve">
          <source>Is first object strictly below second? (This operator is misnamed; it should be &lt;code id=&quot;6060124&quot;&gt;&amp;lt;&amp;lt;|&lt;/code&gt;.)</source>
          <target state="translated">첫 번째 개체가 두 번째보다 엄격하게 아래입니까? (이 연산자는 이름이 잘못되었습니다. &lt;code id=&quot;6060124&quot;&gt;&amp;lt;&amp;lt;|&lt;/code&gt; 이어야합니다 .)</target>
        </trans-unit>
        <trans-unit id="0bb75e79e36aeff0c7858d8fb478e380c0c08061" translate="yes" xml:space="preserve">
          <source>Is first object strictly below second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">첫 번째 개체가 두 번째보다 엄격하게 아래입니까? 가능 &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82493964e24c37744bf5de6c7abddd6d617b2dbe" translate="yes" xml:space="preserve">
          <source>Is first object strictly left of second? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">첫 번째 개체는 엄격하게 두 번째 개체입니까? 가능 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb9750549fc2256498ec80ab691b24c888f4e5c" translate="yes" xml:space="preserve">
          <source>Is first object strictly right of second? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">첫 번째 객체가 두 번째의 엄격하게 맞습니까? 가능 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2352c4320a598b186beeca1fa33e9ebc446c5989" translate="yes" xml:space="preserve">
          <source>Is function visible in search path? (This also works for procedures and aggregates.)</source>
          <target state="translated">검색 경로에 기능이 표시됩니까? (이것은 프로 시저 및 집계에도 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="ea56f04ac22e5eca73342cefd404d9c1b002af61" translate="yes" xml:space="preserve">
          <source>Is horizontal?</source>
          <target state="translated">수평입니까?</target>
        </trans-unit>
        <trans-unit id="1818cd29919e00fd168940f58522c1a837de41d9" translate="yes" xml:space="preserve">
          <source>Is left argument a descendant of right (or equal)?</source>
          <target state="translated">왼쪽 인수가 오른쪽 (또는 같음)의 후손입니까?</target>
        </trans-unit>
        <trans-unit id="c6269d3f15bfebe74c5b103d510d2f6af4fbb1be" translate="yes" xml:space="preserve">
          <source>Is left argument an ancestor of right (or equal)?</source>
          <target state="translated">왼쪽 인수가 오른쪽 (또는 같음)의 조상입니까?</target>
        </trans-unit>
        <trans-unit id="0bfb83cf12d958867b468135803b461105b5e313" translate="yes" xml:space="preserve">
          <source>Is left array contained in right array?</source>
          <target state="translated">왼쪽 배열이 오른쪽 배열에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="931e59a6570abe457c179e4beff2927ed26d2296" translate="yes" xml:space="preserve">
          <source>Is left operand contained in right?</source>
          <target state="translated">왼쪽 피연산자가 오른쪽에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="571e67a163dd7cbf36b6a8d1f61104a0a31bbc98" translate="yes" xml:space="preserve">
          <source>Is line horizontal?</source>
          <target state="translated">선이 수평입니까?</target>
        </trans-unit>
        <trans-unit id="d1926a606e864164a6ebd58c12b6d35ee6a87c25" translate="yes" xml:space="preserve">
          <source>Is line vertical?</source>
          <target state="translated">선이 수직입니까?</target>
        </trans-unit>
        <trans-unit id="ae143f55d7c085448a695f852ae27520ec5aa08b" translate="yes" xml:space="preserve">
          <source>Is operator class visible in search path?</source>
          <target state="translated">연산자 클래스가 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="a5787d3510293778cafab6156a15c641287921cd" translate="yes" xml:space="preserve">
          <source>Is operator family visible in search path?</source>
          <target state="translated">연산자 패밀리가 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="2c15be0091b6642fd23724ba17d912f27c02d8aa" translate="yes" xml:space="preserve">
          <source>Is operator visible in search path?</source>
          <target state="translated">연산자가 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="07ef905d97492d046c005a27265c8219bcc2fb0c" translate="yes" xml:space="preserve">
          <source>Is path closed?</source>
          <target state="translated">경로가 닫혀 있습니까?</target>
        </trans-unit>
        <trans-unit id="692378f0378ddf6c5206700062aa1ea0e029afe6" translate="yes" xml:space="preserve">
          <source>Is path open?</source>
          <target state="translated">경로가 열려 있습니까?</target>
        </trans-unit>
        <trans-unit id="c9fe9c5adbc8c22895dcd6a5a3619390deb9964a" translate="yes" xml:space="preserve">
          <source>Is perpendicular?</source>
          <target state="translated">수직입니까?</target>
        </trans-unit>
        <trans-unit id="aee38f7bf2589d5e14735890024a26f0647e7b2b" translate="yes" xml:space="preserve">
          <source>Is row-level security active for the specified table in the context of the current user and current environment?</source>
          <target state="translated">현재 사용자 및 현재 환경의 컨텍스트에서 지정된 테이블에 대해 행 수준 보안이 활성화되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="a3bd90c2bab054cba48ad1eb7ff2752205acec58" translate="yes" xml:space="preserve">
          <source>Is statistics object visible in search path?</source>
          <target state="translated">통계 개체가 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="fefaf9d6dfa31078880e5655df30026e38004358" translate="yes" xml:space="preserve">
          <source>Is strictly above?</source>
          <target state="translated">엄밀히 위입니까?</target>
        </trans-unit>
        <trans-unit id="a05cc4a278817fbe41225c1212990f7a42609499" translate="yes" xml:space="preserve">
          <source>Is strictly below?</source>
          <target state="translated">아래는 엄격합니까?</target>
        </trans-unit>
        <trans-unit id="b70722f5747da5b37c94b2e21f108653a4a0d9d2" translate="yes" xml:space="preserve">
          <source>Is strictly left of?</source>
          <target state="translated">엄격하게 남았습니까?</target>
        </trans-unit>
        <trans-unit id="c41dadb911bf56e59cfeff92444afa779a0c9714" translate="yes" xml:space="preserve">
          <source>Is strictly right of?</source>
          <target state="translated">엄격히 맞습니까?</target>
        </trans-unit>
        <trans-unit id="fd466dacfa71c9a3651034da3efd29046bfe7fec" translate="yes" xml:space="preserve">
          <source>Is subnet contained by or equal to subnet?</source>
          <target state="translated">서브넷이 서브넷에 포함되어 있거나 같습니까?</target>
        </trans-unit>
        <trans-unit id="608df21f03573c35e537fec94e301c9c05a0ef8c" translate="yes" xml:space="preserve">
          <source>Is subnet strictly contained by subnet? This operator, and the next four, test for subnet inclusion. They consider only the network parts of the two addresses (ignoring any bits to the right of the netmasks) and determine whether one network is identical to or a subnet of the other.</source>
          <target state="translated">서브넷이 서브넷에 엄격하게 포함되어 있습니까? 이 연산자와 다음 네 개는 서브넷 포함을 테스트합니다. 두 주소의 네트워크 부분 만 고려하고 (넷 마스크 오른쪽에있는 비트 무시) 한 네트워크가 다른 네트워크와 동일한 지 아니면 서브넷인지를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="46cc6fe87dd8470a9509c9da1c694aaec675334f" translate="yes" xml:space="preserve">
          <source>Is table visible in search path? (This works for all types of relations, including views, materialized views, indexes, sequences and foreign tables.)</source>
          <target state="translated">검색 경로에 테이블이 표시됩니까? (이는 뷰, 구체화 된 뷰, 인덱스, 시퀀스 및 외부 테이블을 포함한 모든 유형의 관계에서 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="c16dfcb2d9f33c5ed1d4f60e7e94de5cdb8bb497" translate="yes" xml:space="preserve">
          <source>Is text search configuration visible in search path?</source>
          <target state="translated">텍스트 검색 구성이 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="b171387fa6a48bfddce09bcc6374af3cb74ce2b7" translate="yes" xml:space="preserve">
          <source>Is text search dictionary visible in search path?</source>
          <target state="translated">텍스트 검색 사전이 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="cb8ecee88af93cf9199b28e0c89bec38e335e65b" translate="yes" xml:space="preserve">
          <source>Is text search parser visible in search path?</source>
          <target state="translated">텍스트 검색 파서가 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="ea7a21a45c17bac5fc36d8a030345a04d716413b" translate="yes" xml:space="preserve">
          <source>Is text search template visible in search path?</source>
          <target state="translated">텍스트 검색 템플릿이 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="0992b021bae889bee0f11abcbb95dee7929e73aa" translate="yes" xml:space="preserve">
          <source>Is the collation deterministic?</source>
          <target state="translated">데이터 정렬이 결정적입니까?</target>
        </trans-unit>
        <trans-unit id="8a25c1b43d537dd1a7d2ddd1e8080433f5e3eacd" translate="yes" xml:space="preserve">
          <source>Is the constraint deferrable?</source>
          <target state="translated">제약이 지연 될 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fef490f8fe9dee88c33c6a89d30667da1bd2fb9a" translate="yes" xml:space="preserve">
          <source>Is the constraint deferred by default?</source>
          <target state="translated">제약 조건이 기본적으로 지연됩니까?</target>
        </trans-unit>
        <trans-unit id="f2477e67686fc75771da395271b903b89c805e05" translate="yes" xml:space="preserve">
          <source>Is the element contained in the range?</source>
          <target state="translated">요소가 범위에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="48e41905df707985819a963b62a733ad231a70af" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; contained in the second?</source>
          <target state="translated">첫 번째 &lt;code&gt;seg&lt;/code&gt; 가 두 번째 세그먼트에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="c56a2a69c3c21bd55c585fa99939bf4f7fc0147c" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; entirely to the left of the second? [a, b] &amp;lt;&amp;lt; [c, d] is true if b &amp;lt; c.</source>
          <target state="translated">첫 번째 &lt;code&gt;seg&lt;/code&gt; 완전히 두 번째 세그먼트 의 왼쪽에 있습니까? [a, b] &amp;lt;&amp;lt; [c, d]는 b &amp;lt;c이면 참입니다.</target>
        </trans-unit>
        <trans-unit id="ee8b00f339a2f532b4e9c2b55069412b977dc8e8" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; entirely to the right of the second? [a, b] &amp;gt;&amp;gt; [c, d] is true if a &amp;gt; d.</source>
          <target state="translated">첫 번째 &lt;code&gt;seg&lt;/code&gt; 완전히 두 번째 세그먼트 의 오른쪽에 있습니까? [a, b] &amp;gt;&amp;gt; [c, d]는 a&amp;gt; d이면 참입니다.</target>
        </trans-unit>
        <trans-unit id="aea89b97de3ee5955142d5113dfb9dcdb02c115c" translate="yes" xml:space="preserve">
          <source>Is the first JSON value contained in the second?</source>
          <target state="translated">첫 번째 JSON 값이 두 번째에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="19d335f2a70cca44d7330f0d373f5cb2960385ef" translate="yes" xml:space="preserve">
          <source>Is the first array contained by the second?</source>
          <target state="translated">첫 번째 배열이 두 번째 배열에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="07c8facc78abfeb194236811a0926e5445b93180" translate="yes" xml:space="preserve">
          <source>Is the first cube contained in the second?</source>
          <target state="translated">첫 번째 큐브가 두 번째 큐브에 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="e609c817143333de1521a8cf7a158b827be99cd2" translate="yes" xml:space="preserve">
          <source>Is the first range contained by the second?</source>
          <target state="translated">첫 번째 범위가 두 번째 범위에 포함됩니까?</target>
        </trans-unit>
        <trans-unit id="68559d84b5ac88d0e9e0f63a5f0039af51bf0f9e" translate="yes" xml:space="preserve">
          <source>Is the first range strictly left of the second?</source>
          <target state="translated">첫 번째 범위가 두 번째 범위에서 완전히 왼쪽입니까?</target>
        </trans-unit>
        <trans-unit id="bf2611d9965b16ffb44827feb465cfe43a1b6dc3" translate="yes" xml:space="preserve">
          <source>Is the first range strictly right of the second?</source>
          <target state="translated">첫 번째 범위가 두 번째 범위에 정확히 맞습니까?</target>
        </trans-unit>
        <trans-unit id="3225d84455e28cf3582ea057725108c97e83f30e" translate="yes" xml:space="preserve">
          <source>Is the given transaction ID &lt;em&gt;visible&lt;/em&gt; according to this snapshot (that is, was it completed before the snapshot was taken)? Note that this function will not give the correct answer for a subtransaction ID.</source>
          <target state="translated">이 스냅 샷에 따라 주어진 트랜잭션 ID가 &lt;em&gt;표시&lt;/em&gt; 됩니까 (즉, 스냅 샷이 생성되기 전에 완료 되었습니까)? 이 함수는 서브 트랜잭션 ID에 대한 정답을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db516f5dadc3d5e25dea043648eeea3321f5ccdb" translate="yes" xml:space="preserve">
          <source>Is the page dirty?</source>
          <target state="translated">페이지가 더럽습니까?</target>
        </trans-unit>
        <trans-unit id="7a5b28f2abec65dff2a005cef1bab93ce79757ac" translate="yes" xml:space="preserve">
          <source>Is the policy permissive or restrictive?</source>
          <target state="translated">정책이 허용 또는 제한적인가?</target>
        </trans-unit>
        <trans-unit id="1c868da3e376b67ccb29be6664b407ae22b09b84" translate="yes" xml:space="preserve">
          <source>Is the range empty?</source>
          <target state="translated">범위가 비어 있습니까?</target>
        </trans-unit>
        <trans-unit id="ff182ac571c70913b62ea8bad05f34c331a87f89" translate="yes" xml:space="preserve">
          <source>Is the range's lower bound inclusive?</source>
          <target state="translated">범위의 하한이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="ca739e6c1b1df7d98a703e7f4cf56e0c0b73eb1f" translate="yes" xml:space="preserve">
          <source>Is the range's lower bound infinite?</source>
          <target state="translated">범위의 하한이 무한합니까?</target>
        </trans-unit>
        <trans-unit id="d3f822412dc56d423cd1651a21ff0e5c86774082" translate="yes" xml:space="preserve">
          <source>Is the range's upper bound inclusive?</source>
          <target state="translated">범위의 상한이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="6edd78c835bde36ba19726c52d54bb7fc15f1a47" translate="yes" xml:space="preserve">
          <source>Is the range's upper bound infinite?</source>
          <target state="translated">범위의 상한이 무한합니까?</target>
        </trans-unit>
        <trans-unit id="69a6303395c0e1b94086b05146ed59054275f0b9" translate="yes" xml:space="preserve">
          <source>Is type (or domain) visible in search path?</source>
          <target state="translated">유형 (또는 도메인)이 검색 경로에 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="272dd553360faca6d08c14d4f1b40a013a88fc82" translate="yes" xml:space="preserve">
          <source>Is vertical?</source>
          <target state="translated">수직입니까?</target>
        </trans-unit>
        <trans-unit id="616318d9db61d03876a33f8c27e6df459bd2eff6" translate="yes" xml:space="preserve">
          <source>Isolation</source>
          <target state="translated">Isolation</target>
        </trans-unit>
        <trans-unit id="04fa9226f0713bae8b60402f090506b8771675ec" translate="yes" xml:space="preserve">
          <source>Isolation Level</source>
          <target state="translated">격리 수준</target>
        </trans-unit>
        <trans-unit id="5ef461ce76cd9304ad8686fa89152e4b6011f931" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries support splitting compound words; a useful feature. Notice that the affix file should specify a special flag using the &lt;code&gt;compoundwords controlled&lt;/code&gt; statement that marks dictionary words that can participate in compound formation:</source>
          <target state="translated">Ispell 사전은 복합 단어 분리를 지원합니다. 유용한 기능입니다. 접미사 파일은 복합어 구성에 참여할 수있는 사전 단어를 표시 하는 &lt;code&gt;compoundwords controlled&lt;/code&gt; 명령문을 사용하여 특수 플래그를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a44764c80f1ba0b240d3f5d527b95ad90a01a872" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries usually recognize a limited set of words, so they should be followed by another broader dictionary; for example, a Snowball dictionary, which recognizes everything.</source>
          <target state="translated">Ispell 사전은 일반적으로 제한된 단어 세트를 인식하므로 더 넓은 사전을 따라야합니다. 예를 들어 모든 것을 인식하는 Snowball 사전입니다.</target>
        </trans-unit>
        <trans-unit id="d78243d5b6a6182e6f2ddf831b4aabfb7caae3f0" translate="yes" xml:space="preserve">
          <source>Issues a verification prompt before doing anything destructive.</source>
          <target state="translated">파괴적인 일을하기 전에 확인 프롬프트를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="f4c1344e1b107a94e97cb2d1c0387b09d48b1998" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ABORT&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">트랜잭션 블록 외부에서 &lt;code&gt;ABORT&lt;/code&gt; 를 발행 하면 경고가 발생하고 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51092034eb6099bfab57ce2cf44c57b972ed851c" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;BEGIN&lt;/code&gt; when already inside a transaction block will provoke a warning message. The state of the transaction is not affected. To nest transactions within a transaction block, use savepoints (see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;).</source>
          <target state="translated">이미 트랜잭션 블록 내에있을 때 &lt;code&gt;BEGIN&lt;/code&gt; 을 발행 하면 경고 메시지가 나타납니다. 트랜잭션 상태는 영향을받지 않습니다. 트랜잭션 블록 내에 트랜잭션을 중첩 시키려면 저장 점을 사용하십시오 ( &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1c66e92badb172759ea8ab0365668fbc4bfcd29b" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;COMMIT&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message. &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; when not inside a transaction is an error.</source>
          <target state="translated">트랜잭션 내부에 있지 않을 때 &lt;code&gt;COMMIT&lt;/code&gt; 를 발행 해도 아무런 해가 없지만 경고 메시지가 나타납니다. 트랜잭션 내에 있지 않을 때 &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; 은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d8f2914a3de77623d7fcc2d76c1402e19f0682c2" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;END&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message.</source>
          <target state="translated">트랜잭션 내부에 있지 않을 때 &lt;code&gt;END&lt;/code&gt; 를 발행 해도 아무런 해가 없지만 경고 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9a3f1f230232d57deb86f9d1d1a7e859eaa17234" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ROLLBACK&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect. &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; outside of a transaction block is an error.</source>
          <target state="translated">트랜잭션 블록 외부에서 &lt;code&gt;ROLLBACK&lt;/code&gt; 을 발행 하면 경고가 표시되고 그렇지 않으면 영향을 미치지 않습니다. 트랜잭션 블록 외부의 &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1dd72b5f30a56642ade69ef87bd0dd32591ebc8c" translate="yes" xml:space="preserve">
          <source>It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, &lt;code&gt;EXCEPT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, &lt;code&gt;OFFSET&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;FOR&lt;/code&gt; locking clauses can be used with &lt;code&gt;TABLE&lt;/code&gt;; the &lt;code&gt;WHERE&lt;/code&gt; clause and any form of aggregation cannot be used.</source>
          <target state="translated">복잡한 쿼리의 일부에서 최상위 명령 또는 공간 절약형 구문 변형으로 사용할 수 있습니다. 만 &lt;code&gt;WITH&lt;/code&gt; 은 , &lt;code&gt;UNION&lt;/code&gt; 은 , &lt;code&gt;INTERSECT&lt;/code&gt; 는 , &lt;code&gt;EXCEPT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; , &lt;code&gt;OFFSET&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; 및 &lt;code&gt;FOR&lt;/code&gt; 사용할 수 있습니다 절을 잠금 &lt;code&gt;TABLE&lt;/code&gt; ; &lt;code&gt;WHERE&lt;/code&gt; 의 조항 및 집계의 형태는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="985845c593d43702ba4580f789c62a95ef3e445a" translate="yes" xml:space="preserve">
          <source>It can return 2 special key IDs:</source>
          <target state="translated">두 개의 특수 키 ID를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06e730d80da388853db0ab9a33a7b2a082e1e65" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="translated">복제 모드 연결을 작성하므로 &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt; 과 동일한 제한 조건과 논리적 복제에 대한 제한 조건이 적용됩니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="34093efa4b222287cf39e63aac85890d7758d772" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="translated">복제 모드 연결을 생성하므로 &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt; 과 동일한 제약 조건과 논리적 복제에 대한 제약 조건이 적용됩니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ee4e1383f1e9f315e70a9d76f0a1946de5a791a1" translate="yes" xml:space="preserve">
          <source>It does not matter which order the opposite corners of a cube are entered in. The &lt;code&gt;cube&lt;/code&gt; functions automatically swap values if needed to create a uniform &amp;ldquo;lower left &amp;mdash; upper right&amp;rdquo; internal representation. When the corners coincide, &lt;code&gt;cube&lt;/code&gt; stores only one corner along with an &amp;ldquo;is point&amp;rdquo; flag to avoid wasting space.</source>
          <target state="translated">큐브의 반대쪽 모서리를 입력 한 순서는 중요하지 않습니다. &lt;code&gt;cube&lt;/code&gt; 기능은 균일 한 &quot;왼쪽 아래-오른쪽 위&quot;내부 표현을 작성해야하는 경우 값을 자동으로 교환합니다. 모서리가 일치하면 &lt;code&gt;cube&lt;/code&gt; 는 공간 낭비를 피하기 위해 &quot;is point&quot;플래그와 함께 하나의 모서리 만 저장합니다.</target>
        </trans-unit>
        <trans-unit id="aeb260c8d10781feddd45ff6a16008fdceb285b4" translate="yes" xml:space="preserve">
          <source>It does so by first creating all possible &lt;em&gt;paths&lt;/em&gt; leading to the same result. For example if there is an index on a relation to be scanned, there are two paths for the scan. One possibility is a simple sequential scan and the other possibility is to use the index. Next the cost for the execution of each path is estimated and the cheapest path is chosen. The cheapest path is expanded into a complete plan that the executor can use.</source>
          <target state="translated">먼저 가능한 모든 &lt;em&gt;경로를&lt;/em&gt; 만들어 동일한 결과를 얻습니다. 예를 들어 스캔 할 관계에 대한 인덱스가있는 경우 스캔 경로는 두 가지입니다. 하나는 간단한 순차 스캔이고 다른 하나는 인덱스를 사용하는 것입니다. 다음으로 각 경로의 실행 비용이 추정되고 가장 저렴한 경로가 선택됩니다. 가장 저렴한 경로는 실행자가 사용할 수있는 완전한 계획으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="22062c54b59724e3ba4ff79971e8d1516ebd1cef" translate="yes" xml:space="preserve">
          <source>It does this by skipping pages that have only visible tuples according to the visibility map (if a page has the corresponding VM bit set, then it is assumed to contain no dead tuples). For such pages, it derives the free space value from the free space map, and assumes that the rest of the space on the page is taken up by live tuples.</source>
          <target state="translated">가시성 맵에 따라 표시되는 튜플 만있는 페이지를 건너 뛰어이를 수행합니다 (페이지에 해당 VM 비트 세트가 있으면 사용 가능한 튜플이없는 것으로 가정). 이러한 페이지의 경우 여유 공간 맵에서 여유 공간 값을 파생시키고 페이지의 나머지 공간이 라이브 튜플에 의해 사용된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="289bb6de0c119ae341fea7727f0ae465a6ffb7a2" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;not&lt;/em&gt; recommended that you override this behavior by changing the session-level settings of these parameters; that is likely to cause &lt;code&gt;postgres_fdw&lt;/code&gt; to malfunction.</source>
          <target state="translated">되어 &lt;em&gt;있지&lt;/em&gt; 이러한 매개 변수의 세션 수준 설정을 변경하여이 동작을 오버라이드 (override)하는 것을 추천합니다; &lt;code&gt;postgres_fdw&lt;/code&gt; 가 오작동 할 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1927f65da9f3267669c003e30b5762ebad0dc5a9" translate="yes" xml:space="preserve">
          <source>It is a good idea to save the database server's log output somewhere, rather than just discarding it via &lt;code&gt;/dev/null&lt;/code&gt;. The log output is invaluable when diagnosing problems. However, the log output tends to be voluminous (especially at higher debug levels) so you won't want to save it indefinitely. You need to &lt;em&gt;rotate&lt;/em&gt; the log files so that new log files are started and old ones removed after a reasonable period of time.</source>
          <target state="translated">데이터베이스 서버의 로그 출력을 &lt;code&gt;/dev/null&lt;/code&gt; 을 통해 버리지 않고 어딘가에 저장하는 것이 좋습니다 . 문제점 진단시 로그 출력은 매우 중요합니다. 그러나 로그 출력은 방대한 양 (특히 더 높은 디버그 레벨에서)이되기 때문에 무기한 저장하지 않으려 고합니다. 새 로그 파일이 시작되고 적절한 시간이 지나면 이전 로그 파일이 제거되도록 로그 파일 을 &lt;em&gt;회전&lt;/em&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="45d3adbb3df378f5fff436872f95f728d888325a" translate="yes" xml:space="preserve">
          <source>It is advantageous if the log is located on a different disk from the main database files. This can be achieved by moving the &lt;code&gt;pg_wal&lt;/code&gt; directory to another location (while the server is shut down, of course) and creating a symbolic link from the original location in the main data directory to the new location.</source>
          <target state="translated">로그가 기본 데이터베이스 파일과 다른 디스크에 있으면 유리합니다. 이것은 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리를 다른 위치 (물론 서버가 종료 된 상태)로 옮기고 기본 데이터 디렉토리의 원래 위치에서 새 위치로 심볼릭 링크를 만들어서 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25c2883a31f29210a79363008b59988d33c5a31b" translate="yes" xml:space="preserve">
          <source>It is advisable to set &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; to a reasonably large value (but not more than the amount of RAM you can dedicate to the &lt;code&gt;CLUSTER&lt;/code&gt; operation) before clustering.</source>
          <target state="translated">클러스터링하기 전에 &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 을 상당히 큰 값 (그러나 &lt;code&gt;CLUSTER&lt;/code&gt; 조작에 전용 할 수있는 RAM의 양을 초과하지 않음)으로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f4c2ed49f12a870b96cb954dbc625ee0c439a239" translate="yes" xml:space="preserve">
          <source>It is advisable to test your proposed archive command to ensure that it indeed does not overwrite an existing file, &lt;em&gt;and that it returns nonzero status in this case&lt;/em&gt;. The example command above for Unix ensures this by including a separate &lt;code&gt;test&lt;/code&gt; step. On some Unix platforms, &lt;code&gt;cp&lt;/code&gt; has switches such as &lt;code&gt;-i&lt;/code&gt; that can be used to do the same thing less verbosely, but you should not rely on these without verifying that the right exit status is returned. (In particular, GNU &lt;code&gt;cp&lt;/code&gt; will return status zero when &lt;code&gt;-i&lt;/code&gt; is used and the target file already exists, which is &lt;em&gt;not&lt;/em&gt; the desired behavior.)</source>
          <target state="translated">제안 된 아카이브 명령을 테스트하여 실제로 기존 파일을 덮어 쓰지 &lt;em&gt;않고이 경우 0이 아닌 상태를 리턴&lt;/em&gt; 하는지 확인하는 것이 좋습니다 . 위의 Unix 명령 예제는 별도의 &lt;code&gt;test&lt;/code&gt; 단계를 포함하여이를 보장합니다 . 일부 유닉스 플랫폼에서 &lt;code&gt;cp&lt;/code&gt; 는 &lt;code&gt;-i&lt;/code&gt; 와 같은 스위치를 사용하여 같은 일을 덜 자세하게 수행하는 데 사용할 수 있지만 올바른 종료 상태가 반환되는지 확인하지 않고 스위치에 의존해서는 안됩니다. (특히, GNU &lt;code&gt;cp&lt;/code&gt; 는 &lt;code&gt;-i&lt;/code&gt; 를 사용하고 대상 파일이 이미 존재하는 경우 상태 0을 반환 합니다. 이는 바람직한 동작 이 &lt;em&gt;아닙니다&lt;/em&gt; .)</target>
        </trans-unit>
        <trans-unit id="5ccc1a490a09faccece314c281e5a4bacdabe99b" translate="yes" xml:space="preserve">
          <source>It is also important to consider the overhead of partitioning during query planning and execution. The query planner is generally able to handle partition hierarchies with up to a few thousand partitions fairly well, provided that typical queries allow the query planner to prune all but a small number of partitions. Planning times become longer and memory consumption becomes higher when more partitions remain after the planner performs partition pruning. This is particularly true for the &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. Another reason to be concerned about having a large number of partitions is that the server's memory consumption may grow significantly over a period of time, especially if many sessions touch large numbers of partitions. That's because each partition requires its metadata to be loaded into the local memory of each session that touches it.</source>
          <target state="translated">쿼리 계획 및 실행 중에 파티셔닝 오버 헤드를 고려해야합니다. 일반적인 쿼리로 인해 쿼리 플래너가 소수의 파티션을 제외한 모든 파티션을 프룬 (prune) 할 수 있다면 쿼리 플래너는 일반적으로 최대 수천 개의 파티션으로 파티션 계층 구조를 상당히 잘 처리 할 수 ​​있습니다. 플래너가 파티션 정리를 수행 한 후 더 많은 파티션이 남아 있으면 계획 시간이 길어지고 메모리 소비가 높아집니다. 이것은 특히 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 에 해당됩니다.명령. 많은 수의 파티션을 보유해야하는 또 다른 이유는 특히 많은 세션이 많은 수의 파티션에 닿는 경우 서버의 메모리 소비가 일정 기간 동안 크게 증가 할 수 있기 때문입니다. 각 파티션은 메타 데이터를 해당 세션과 접촉하는 각 세션의 로컬 메모리에로드해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="08e56c7bbb1c5c1ca45ba0adfbd971830db5b40e" translate="yes" xml:space="preserve">
          <source>It is also possible to access the file as a foreign table, using the supplied &lt;a href=&quot;file-fdw&quot;&gt;file_fdw&lt;/a&gt; module.</source>
          <target state="translated">제공된 &lt;a href=&quot;file-fdw&quot;&gt;file_fdw&lt;/a&gt; 모듈을 사용하여 외부 테이블로 파일에 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8a8c0ea8274eada7feb8d1cce002d08a07341cc" translate="yes" xml:space="preserve">
          <source>It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word &lt;code&gt;ARRAY&lt;/code&gt; followed by a parenthesized (not bracketed) subquery. For example:</source>
          <target state="translated">하위 쿼리 결과에서 배열을 구성 할 수도 있습니다. 이 형식에서, 배열 생성자는 키워드 &lt;code&gt;ARRAY&lt;/code&gt; 와 괄호로 묶인 (괄호로 묶이지 않은) 서브 쿼리로 작성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21db650c844a5c99fb809ce100bf6bab36b3a9c1" translate="yes" xml:space="preserve">
          <source>It is also possible to create a chain of trust that includes intermediate certificates:</source>
          <target state="translated">중간 인증서를 포함하는 신뢰 체인을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bbde7dfe5218957bc7115e4bb121f93797376d5" translate="yes" xml:space="preserve">
          <source>It is also possible to implement record-based log shipping using this alternative method, though this requires custom development, and changes will still only become visible to hot standby queries after a full WAL file has been shipped.</source>
          <target state="translated">이 대체 방법을 사용하여 레코드 기반 로그 전달을 구현할 수도 있지만, 이는 사용자 정의 개발이 필요하며 전체 WAL 파일이 제공된 후에도 변경 사항은 여전히 ​​대기 모드 쿼리에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a889ddd9646ac2e435b2d44d186929390a588c8e" translate="yes" xml:space="preserve">
          <source>It is also possible to insert the result of a query (which might be no rows, one row, or many rows):</source>
          <target state="translated">쿼리 결과를 삽입 할 수도 있습니다 (행이 없거나 한 행 또는 여러 행일 수 있음).</target>
        </trans-unit>
        <trans-unit id="23dc30a3752f1a0512f87d6b42f04212daedc525" translate="yes" xml:space="preserve">
          <source>It is also possible to make a backup while the server is stopped. In this case, you obviously cannot use &lt;code&gt;pg_start_backup&lt;/code&gt; or &lt;code&gt;pg_stop_backup&lt;/code&gt;, and you will therefore be left to your own devices to keep track of which backup is which and how far back the associated WAL files go. It is generally better to follow the continuous archiving procedure above.</source>
          <target state="translated">서버가 중지 된 동안 백업을 만들 수도 있습니다. 이 경우 분명히 &lt;code&gt;pg_start_backup&lt;/code&gt; 또는 &lt;code&gt;pg_stop_backup&lt;/code&gt; 을 사용할 수 없으므로 관련 WAL 파일의 백업 및 백업 위치를 추적하기 위해 자신의 장치에 맡겨야합니다. 일반적으로 위의 연속 보관 절차를 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6383187f9793f49474de63c9c18fca5ed6c8c44d" translate="yes" xml:space="preserve">
          <source>It is also possible to pass a page to &lt;code&gt;bt_page_items&lt;/code&gt; as a &lt;code&gt;bytea&lt;/code&gt; value. A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. So the last example could also be rewritten like this:</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 값 으로 페이지를 &lt;code&gt;bt_page_items&lt;/code&gt; 에 전달할 수도 있습니다 . &lt;code&gt;get_raw_page&lt;/code&gt; 로 얻은 페이지 이미지 는 인수로 전달되어야합니다. 따라서 마지막 예제는 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f6da252a14d7892790fa503a4f493737f34471" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type cast using a function-like syntax:</source>
          <target state="translated">함수형 구문을 사용하여 유형 캐스트를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da0d70336d913c862f76912f7ff4b7d2cecbbfee" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type coercion using a function-like syntax:</source>
          <target state="translated">함수와 같은 구문을 사용하여 유형 강제 변환을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce33e1d5683bd1e633283bcca0d2a1c2815c050" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific database rather than to a role; see &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt;. If there is a conflict, database-role-specific settings override role-specific ones, which in turn override database-specific ones.</source>
          <target state="translated">세션 기본값을 역할이 아닌 특정 데이터베이스에 연결할 수도 있습니다. &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE를&lt;/a&gt; 참조하십시오 . 충돌이 발생하면 데이터베이스 역할 별 설정이 역할 별 설정보다 우선하며, 이로 인해 데이터베이스 별 설정이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="752073224562183bf86377a6f918beef1da4c653" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific role rather than to a database; see &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. Role-specific settings override database-specific ones if there is a conflict.</source>
          <target state="translated">세션 기본값을 데이터베이스가 아닌 특정 역할에 연결할 수도 있습니다. &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE을&lt;/a&gt; 참조하십시오 . 충돌이 발생하면 역할 별 설정이 데이터베이스 별 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="c7b08ca18ddba24ea9814754a2d56bec9634faff" translate="yes" xml:space="preserve">
          <source>It is also possible to use arbitrary expressions in the &lt;code&gt;ORDER BY&lt;/code&gt; clause, including columns that do not appear in the &lt;code&gt;SELECT&lt;/code&gt; output list. Thus the following statement is valid:</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 출력 목록에 나타나지 않는 열을 포함 하여 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서 임의의 표현식을 사용할 수도 있습니다 . 따라서 다음 진술은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f4e580c8b0c33e188baa71c64a617a90c70459e7" translate="yes" xml:space="preserve">
          <source>It is also possible to use logical replication methods to create a standby server with the updated version of PostgreSQL. This is possible because logical replication supports replication between different major versions of PostgreSQL. The standby can be on the same computer or a different computer. Once it has synced up with the master server (running the older version of PostgreSQL), you can switch masters and make the standby the master and shut down the older database instance. Such a switch-over results in only several seconds of downtime for an upgrade.</source>
          <target state="translated">논리적 복제 방법을 사용하여 업데이트 된 PostgreSQL 버전으로 대기 서버를 생성 할 수도 있습니다. 논리적 복제는 다른 주요 버전의 PostgreSQL 간의 복제를 지원하기 때문에 가능합니다. 대기는 동일한 컴퓨터 또는 다른 컴퓨터에있을 수 있습니다. 마스터 서버와 동기화되면 (이전 버전의 PostgreSQL 실행) 마스터를 전환하고 대기를 마스터로 만들고 이전 데이터베이스 인스턴스를 종료 할 수 있습니다. 이러한 전환으로 인해 업그레이드시 다운 타임이 몇 초에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="2f14f1cce0e64f81899ff66a139003d88acce025" translate="yes" xml:space="preserve">
          <source>It is an error to mix configuration options for simple bind with options for search+bind.</source>
          <target state="translated">단순 바인드에 대한 구성 옵션과 검색 + 바인드 옵션을 혼합하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a93dfee21deef6822077b576885ec96bea313d5" translate="yes" xml:space="preserve">
          <source>It is best not to use SIGKILL to shut down the server. Doing so will prevent the server from releasing shared memory and semaphores. Furthermore, SIGKILL kills the &lt;code&gt;postgres&lt;/code&gt; process without letting it relay the signal to its subprocesses, so it might be necessary to kill the individual subprocesses by hand as well.</source>
          <target state="translated">서버를 종료하기 위해 SIGKILL을 사용하지 않는 것이 가장 좋습니다. 그렇게하면 서버가 공유 메모리와 세마포어를 해제하지 못하게됩니다. 또한 SIGKILL 은 신호를 하위 프로세스로 릴레이하지 않고 &lt;code&gt;postgres&lt;/code&gt; 프로세스를 종료 하므로 개별 하위 프로세스도 수동으로 종료해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03425b40ae836e9eabd64694b0fe5bdd09ab82f4" translate="yes" xml:space="preserve">
          <source>It is best not to use parallelism when restoring from an archive made with this option, because pg_restore will not know exactly which partition(s) a given archive data item will load data into. This could result in inefficiency due to lock conflicts between parallel jobs, or perhaps even reload failures due to foreign key constraints being set up before all the relevant data is loaded.</source>
          <target state="translated">pg_restore는 지정된 아카이브 데이터 항목이 데이터를로드 할 파티션을 정확하게 알지 못하므로이 옵션으로 만든 아카이브에서 복원 할 때 병렬 처리를 사용하지 않는 것이 가장 좋습니다. 이로 인해 병렬 작업 간의 잠금 충돌로 인해 비 효율성이 발생하거나 관련 데이터를 모두로드하기 전에 외래 키 제약 조건이 설정되어 다시로드 오류가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e38adf41282f06a6bcba53d9fb2cad2cffe8b4" translate="yes" xml:space="preserve">
          <source>It is common for a client that executes &lt;code&gt;NOTIFY&lt;/code&gt; to be listening on the same notification channel itself. In that case it will get back a notification event, just like all the other listening sessions. Depending on the application logic, this could result in useless work, for example, reading a database table to find the same updates that that session just wrote out. It is possible to avoid such extra work by noticing whether the notifying session's server process PID (supplied in the notification event message) is the same as one's own session's PID (available from libpq). When they are the same, the notification event is one's own work bouncing back, and can be ignored.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 를 실행하는 클라이언트가 동일한 알림 채널 자체에서 청취 하는 것이 일반적입니다 . 이 경우 다른 모든 청취 세션과 마찬가지로 알림 이벤트를 다시받습니다. 응용 프로그램 논리에 따라 이로 인해 데이터베이스 테이블을 읽어 해당 세션이 방금 작성한 것과 동일한 업데이트를 찾는 등의 불필요한 작업이 발생할 수 있습니다. 통지 세션의 서버 프로세스 PID (알림 이벤트 메시지에 제공)가 자신의 세션 PID (libpq에서 사용 가능)와 동일한 지 여부를 알면 이러한 추가 작업을 피할 수 있습니다. 알림 이벤트가 동일하면 알림 이벤트가 자신의 작업을 수신 거부하고 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9caa8dc8a351442eebfc90a7900dd2df9e2e966" translate="yes" xml:space="preserve">
          <source>It is common to see slow queries running bad execution plans because multiple columns used in the query clauses are correlated. The planner normally assumes that multiple conditions are independent of each other, an assumption that does not hold when column values are correlated. Regular statistics, because of their per-individual-column nature, cannot capture any knowledge about cross-column correlation. However, PostgreSQL has the ability to compute &lt;em&gt;multivariate statistics&lt;/em&gt;, which can capture such information.</source>
          <target state="translated">query 절에 사용 된 여러 열이 서로 관련되어 있기 때문에 잘못된 실행 계획을 실행하는 느린 쿼리를 보는 것이 일반적입니다. 플래너는 일반적으로 여러 조건이 서로 독립적이라고 가정하며 열 값이 상관 될 때 유지되지 않는 가정입니다. 개인별 열 특성으로 인해 정기적 인 통계는 열 간 상관 관계에 대한 지식을 얻을 수 없습니다. 그러나 PostgreSQL에는 &lt;em&gt;다변량 통계&lt;/em&gt; 를 계산하는 기능이있어 이러한 정보를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="716e43860306866d146f9c899994b23176f3323e" translate="yes" xml:space="preserve">
          <source>It is difficult to formulate a general procedure for determining which indexes to create. There are a number of typical cases that have been shown in the examples throughout the previous sections. A good deal of experimentation is often necessary. The rest of this section gives some tips for that:</source>
          <target state="translated">생성 할 인덱스를 결정하기위한 일반적인 절차를 수립하기는 어렵습니다. 이전 섹션 전체에서 예제에 표시된 여러 가지 일반적인 사례가 있습니다. 많은 실험이 종종 필요합니다. 이 섹션의 나머지 부분에서는 이에 대한 팁을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8e2e75db678536414073cb564abf9bafb8f65d0c" translate="yes" xml:space="preserve">
          <source>It is easy to find your largest tables and indexes using this information:</source>
          <target state="translated">이 정보를 사용하여 가장 큰 테이블과 인덱스를 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f4af27f8aaeea1d69cd838327e07079c59b331" translate="yes" xml:space="preserve">
          <source>It is encrypted using the public key and put into the session key packet.</source>
          <target state="translated">공개 키를 사용하여 암호화되어 세션 키 패킷에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="c1facaa0d2b2d45958e470a68a811dfa56fbe0cc" translate="yes" xml:space="preserve">
          <source>It is especially fatal to use very small test data sets. While selecting 1000 out of 100000 rows could be a candidate for an index, selecting 1 out of 100 rows will hardly be, because the 100 rows probably fit within a single disk page, and there is no plan that can beat sequentially fetching 1 disk page.</source>
          <target state="translated">매우 작은 테스트 데이터 세트를 사용하는 것은 특히 치명적입니다. 100000 개의 행 중 1000 개를 선택하면 인덱스 후보가 될 수 있지만 100 개의 행 중 하나를 선택하는 것은 거의 불가능합니다. 100 개의 행이 단일 디스크 페이지에 맞을 가능성이 높으며 1 개의 디스크 페이지를 순차적으로 페치 할 수있는 계획이 없기 때문입니다. .</target>
        </trans-unit>
        <trans-unit id="19ad949d23432743231dc352c6a17b2b375d15f1" translate="yes" xml:space="preserve">
          <source>It is essential that the same parameters are passed in order to obtain matching XML data mappings and XML Schema documents.</source>
          <target state="translated">일치하는 XML 데이터 맵핑 및 XML 스키마 문서를 얻으려면 동일한 매개 변수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a50daa221b6ada829c86621c1e1031f8d10ee63" translate="yes" xml:space="preserve">
          <source>It is even possible for repeated executions of the same &lt;code&gt;LIMIT&lt;/code&gt; query to return different subsets of the rows of a table, if there is not an &lt;code&gt;ORDER BY&lt;/code&gt; to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.</source>
          <target state="translated">결정적 서브 세트의 선택을 강제 하는 &lt;code&gt;ORDER BY&lt;/code&gt; 가없는 경우 동일한 &lt;code&gt;LIMIT&lt;/code&gt; 쿼리 의 반복 된 실행이 테이블 행의 다른 서브 세트를 리턴 할 수도 있습니다. 다시, 이것은 버그가 아닙니다. 이 경우 결과의 결정 성은 단순히 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10042e013ab2c07aefb508d6fa86ca0af029f7db" translate="yes" xml:space="preserve">
          <source>It is frequently convenient to group users together to ease management of privileges: that way, privileges can be granted to, or revoked from, a group as a whole. In PostgreSQL this is done by creating a role that represents the group, and then granting &lt;em&gt;membership&lt;/em&gt; in the group role to individual user roles.</source>
          <target state="translated">권한을 쉽게 관리 할 수 ​​있도록 사용자를 그룹화하는 것이 편리합니다. 이렇게하면 그룹 전체에 권한을 부여하거나 취소 할 수 있습니다. PostgreSQL에서는 그룹을 나타내는 역할을 만든 다음 그룹 역할의 &lt;em&gt;멤버 자격&lt;/em&gt; 을 개별 사용자 역할에 부여 합니다.</target>
        </trans-unit>
        <trans-unit id="c7233cabce0e70bf9b6042d864213cd71aa539f4" translate="yes" xml:space="preserve">
          <source>It is generally recommended that the columns of a foreign table be declared with exactly the same data types, and collations if applicable, as the referenced columns of the remote table. Although &lt;code&gt;postgres_fdw&lt;/code&gt; is currently rather forgiving about performing data type conversions at need, surprising semantic anomalies may arise when types or collations do not match, due to the remote server interpreting &lt;code&gt;WHERE&lt;/code&gt; clauses slightly differently from the local server.</source>
          <target state="translated">일반적으로 외부 테이블의 열은 원격 테이블의 참조 열과 정확히 동일한 데이터 형식 및 데이터 정렬을 사용하여 선언하는 것이 좋습니다. &lt;code&gt;postgres_fdw&lt;/code&gt; 는 현재 필요한 데이터 유형 변환을 수행하는 것을 다소 용서 하지만 원격 서버가 &lt;code&gt;WHERE&lt;/code&gt; 절을 로컬 서버와 약간 다르게 해석하기 때문에 유형 또는 데이터 정렬이 일치하지 않으면 놀라운 의미 이상이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e59537e8306049dacf2891d27c403a8ccf0ae6a3" translate="yes" xml:space="preserve">
          <source>It is generally recommended to use &lt;code&gt;FOR UPDATE&lt;/code&gt; if the cursor is intended to be used with &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; or &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt;. Using &lt;code&gt;FOR UPDATE&lt;/code&gt; prevents other sessions from changing the rows between the time they are fetched and the time they are updated. Without &lt;code&gt;FOR UPDATE&lt;/code&gt;, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; command will have no effect if the row was changed since the cursor was created.</source>
          <target state="translated">커서를 &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; 또는 &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt; 와 함께 사용하려는 경우 일반적으로 &lt;code&gt;FOR UPDATE&lt;/code&gt; 를 사용하는 것이 좋습니다 . &lt;code&gt;FOR UPDATE&lt;/code&gt; 를 사용 하면 다른 세션이 페치 된 시간과 업데이트 된 시간 사이에서 행을 변경하지 못하게됩니다. 없이 &lt;code&gt;FOR UPDATE&lt;/code&gt; , 후속 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 커서가 생성 된 이후 행이 변경된 경우 명령은 아무런 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a83872fa85fd0323d70dd24a91d302ff7029d1c0" translate="yes" xml:space="preserve">
          <source>It is good practice to create a role that has the &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; privileges, but is not a superuser, and then use this role for all routine management of databases and roles. This approach avoids the dangers of operating as a superuser for tasks that do not really require it.</source>
          <target state="translated">이 역할 작성하는 것이 좋습니다 &lt;code&gt;CREATEDB&lt;/code&gt; 및 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한을하지만, 슈퍼 유저 아닌 다음 데이터베이스 및 역할의 모든 일상적인 관리를위한이 역할을 사용합니다. 이 접근 방식은 실제로 필요하지 않은 작업의 수퍼 유저로 작동 할 위험을 피합니다.</target>
        </trans-unit>
        <trans-unit id="de68fd3161d79a0dbb9addbaa913d55e1165d0a6" translate="yes" xml:space="preserve">
          <source>It is important for the command to return a zero exit status only if it succeeds. The command &lt;em&gt;will&lt;/em&gt; be asked for file names that are not present in the archive; it must return nonzero when so asked. Examples:</source>
          <target state="translated">명령이 성공한 경우에만 제로 종료 상태를 리턴하는 것이 중요합니다. 아카이브에없는 파일 이름을 묻는 명령 &lt;em&gt;이 표시됩니다&lt;/em&gt; . 요청시 0이 아닌 값을 반환해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="cf6c5b8023371ed1577875e84b0b18cba96de2de" translate="yes" xml:space="preserve">
          <source>It is important that the &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; string not appear in any key values, else &lt;code&gt;connectby&lt;/code&gt; may incorrectly report an infinite-recursion error. Note that if &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; is not provided, a default value of &lt;code&gt;~&lt;/code&gt; is used for recursion detection purposes.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt; 문자열이 키 값에 나타나지 않는 것이 중요 합니다. 그렇지 않으면 &lt;code&gt;connectby&lt;/code&gt; 가 무한 재귀 오류를 잘못보고 할 수 있습니다. 경우주의 &lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; 이&lt;/em&gt; 제공되지 않으며, 기본값 &lt;code&gt;~&lt;/code&gt; 이 재귀 감지 목적을 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ae60071a0616a68a075f0ef2a5eb0bf24ed27b" translate="yes" xml:space="preserve">
          <source>It is important that the administrator select appropriate settings for &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;. The best choices vary depending on business priorities. For example if the server is primarily tasked as a High Availability server, then you will want low delay settings, perhaps even zero, though that is a very aggressive setting. If the standby server is tasked as an additional server for decision support queries then it might be acceptable to set the maximum delay values to many hours, or even -1 which means wait forever for queries to complete.</source>
          <target state="translated">관리자가 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay에&lt;/a&gt; 대한 적절한 설정을 선택해야합니다 . 최선의 선택은 비즈니스 우선 순위에 따라 다릅니다. 예를 들어 서버가 주로 고 가용성 서버로 작업을 수행하는 경우 매우 공격적인 설정이지만 지연이 적은 설정 (아마도 0)을 원할 것입니다. 대기 서버가 의사 결정 지원 조회를위한 추가 서버로 태스크되는 경우 최대 지연 값을 여러 시간 또는 -1로 설정하는 것이 허용 될 수 있습니다. 이는 조회가 완료 될 때까지 영원히 대기 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="261ccf1229f9ce7bf8e5f6c3bd334b4a4c87db09" translate="yes" xml:space="preserve">
          <source>It is important that the archive command return zero exit status if and only if it succeeds. Upon getting a zero result, PostgreSQL will assume that the file has been successfully archived, and will remove or recycle it. However, a nonzero status tells PostgreSQL that the file was not archived; it will try again periodically until it succeeds.</source>
          <target state="translated">아카이브 명령이 성공한 경우에만 0 종료 상태를 리턴하는 것이 중요합니다. 결과가 0이되면 PostgreSQL은 파일이 성공적으로 아카이브되었다고 가정하고이를 제거하거나 재활용합니다. 그러나 0이 아닌 상태는 PostgreSQL에 파일이 아카이브되지 않았 음을 알려줍니다. 성공할 때까지 주기적으로 다시 시도합니다.</target>
        </trans-unit>
        <trans-unit id="696e699e4bfd8bcf4f4c70ae89306a775c1076ba" translate="yes" xml:space="preserve">
          <source>It is important that the command return nonzero exit status on failure. The command &lt;em&gt;will&lt;/em&gt; be called requesting files that are not present in the archive; it must return nonzero when so asked. This is not an error condition. An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">실패시 명령이 0이 아닌 종료 상태를 리턴하는 것이 중요합니다. 아카이브에없는 파일을 요청하는 명령 &lt;em&gt;이&lt;/em&gt; 호출 &lt;em&gt;됩니다&lt;/em&gt; . 요청시 0이 아닌 값을 반환해야합니다. 이것은 오류 조건이 아닙니다. 단, 신호 (데이터베이스 서버 종료의 일부로 사용되는 SIGTERM 이외) 또는 쉘 오류 (예 : 명령을 찾을 수 없음)로 명령이 종료 된 경우 복구가 중단되고 서버가 중단됩니다. 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23edc6be4b94044ef5894353c32ee9e7375bcbf5" translate="yes" xml:space="preserve">
          <source>It is important to note that the ranking functions do not use any global information, so it is impossible to produce a fair normalization to 1% or 100% as sometimes desired. Normalization option 32 (&lt;code&gt;rank/(rank+1)&lt;/code&gt;) can be applied to scale all ranks into the range zero to one, but of course this is just a cosmetic change; it will not affect the ordering of the search results.</source>
          <target state="translated">순위 함수는 전역 정보를 사용하지 않으므로 때때로 원하는대로 1 % 또는 100 %로 공정한 정규화를 생성하는 것이 불가능합니다. 정규화 옵션 32 ( &lt;code&gt;rank/(rank+1)&lt;/code&gt; )를 사용하여 모든 순위를 0에서 1까지의 범위로 조정할 수 있지만 물론 이것은 단지 외관상의 변화 일뿐입니다. 검색 결과의 순서에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52fc312b2cbf7e2b75157d95cff3456da87ba73a" translate="yes" xml:space="preserve">
          <source>It is important to note that the validation which is performed by pg_verifybackup does not and can not include every check which will be performed by a running server when attempting to make use of the backup. Even if you use this tool, you should still perform test restores and verify that the resulting databases work as expected and that they appear to contain the correct data. However, pg_verifybackup can detect many problems that commonly occur due to storage problems or user error.</source>
          <target state="translated">pg_verifybackup에 의해 수행되는 유효성 검사는 백업을 사용하려고 할 때 실행중인 서버에서 수행 할 모든 검사를 포함하지 않으며 포함 할 수도 없습니다. 이 도구를 사용하는 경우에도 테스트 복원을 수행하고 결과 데이터베이스가 예상대로 작동하고 올바른 데이터를 포함하는 것으로 보이는지 확인해야합니다. 그러나 pg_verifybackup은 스토리지 문제 또는 사용자 오류로 인해 일반적으로 발생하는 많은 문제를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a6953b33213a41a821ecf81913686f5a307e4e2" translate="yes" xml:space="preserve">
          <source>It is important to store the server's stdout and stderr output somewhere, as shown above. It will help for auditing purposes and to diagnose problems. (See &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt; for a more thorough discussion of log file handling.)</source>
          <target state="translated">위에 표시된 것처럼 서버의 stdout 및 stderr 출력을 어딘가에 저장하는 것이 중요합니다. 감사 목적으로 문제를 진단하는 데 도움이됩니다. 로그 파일 처리에 대한 자세한 내용 &lt;a href=&quot;logfile-maintenance&quot;&gt;은 24.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c277ac6ce904cf376b200217f724f1a32321205" translate="yes" xml:space="preserve">
          <source>It is important to understand before studying &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; that the fact that a key word is not reserved in PostgreSQL does not mean that the feature related to the word is not implemented. Conversely, the presence of a key word does not indicate the existence of a feature.</source>
          <target state="translated">&lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;표 C.1&lt;/a&gt; 을 공부하기 전에 PostgreSQL에서 키워드가 예약되어 있지 않다는 것이 단어와 관련된 기능이 구현되지 않았다는 것을 의미하지는 않습니다. 반대로 키워드의 존재는 기능의 존재를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2afb84d06182545308e408bb344e52041de5bb4d" translate="yes" xml:space="preserve">
          <source>It is important to understand that the &lt;code&gt;tsvector&lt;/code&gt; type itself does not perform any word normalization; it assumes the words it is given are normalized appropriately for the application. For example,</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 타입 자체는 워드 정규화를 수행하지 않는다는 것을 이해하는 것이 중요합니다 . 주어진 단어가 응용 프로그램에 적합하게 정규화되었다고 가정합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2fc0b9aee575bb88d3b3c3db08a354cd3df94678" translate="yes" xml:space="preserve">
          <source>It is important to understand the interaction between aggregates and SQL's &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses. The fundamental difference between &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; is this: &lt;code&gt;WHERE&lt;/code&gt; selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas &lt;code&gt;HAVING&lt;/code&gt; selects group rows after groups and aggregates are computed. Thus, the &lt;code&gt;WHERE&lt;/code&gt; clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the &lt;code&gt;HAVING&lt;/code&gt; clause always contains aggregate functions. (Strictly speaking, you are allowed to write a &lt;code&gt;HAVING&lt;/code&gt; clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the &lt;code&gt;WHERE&lt;/code&gt; stage.)</source>
          <target state="translated">집계와 SQL의 &lt;code&gt;WHERE&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절 사이의 상호 작용을 이해하는 것이 중요합니다 . &lt;code&gt;WHERE&lt;/code&gt; 와 &lt;code&gt;HAVING&lt;/code&gt; 의 근본적인 차이점 은 다음 과 같습니다. &lt;code&gt;WHERE&lt;/code&gt; 는 그룹 및 집계가 계산되기 전에 입력 행을 선택하고 (따라서 집계 계산에 들어가는 행을 제어 함) &lt;code&gt;HAVING&lt;/code&gt; 은 그룹 및 집계가 계산 된 후 그룹 행을 선택합니다. 따라서 &lt;code&gt;WHERE&lt;/code&gt; 절은 집계 함수를 포함하지 않아야합니다. 집계를 사용하여 집계에 입력 할 행을 결정하는 것은 의미가 없습니다. 반면에 &lt;code&gt;HAVING&lt;/code&gt; 절에는 항상 집계 함수가 포함됩니다. 엄밀히 말하면 집계를 사용하지 않는 &lt;code&gt;HAVING&lt;/code&gt; 절 을 작성할 수 있지만 거의 유용하지 않습니다. 동일한 조건을 &lt;code&gt;WHERE&lt;/code&gt; 단계 에서보다 효율적으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6f798bec767ce149f1b4884b54e8874f501f623" translate="yes" xml:space="preserve">
          <source>It is legitimate to create a &lt;code&gt;pg_cast&lt;/code&gt; entry in which the source and target types are the same, if the associated function takes more than one argument. Such entries represent &amp;ldquo;length coercion functions&amp;rdquo; that coerce values of the type to be legal for a particular type modifier value.</source>
          <target state="translated">연관된 함수가 둘 이상의 인수를 사용하는 경우 소스 및 대상 유형이 동일한 &lt;code&gt;pg_cast&lt;/code&gt; 항목 을 작성하는 것이 합법적 입니다. 이러한 항목은 특정 유형 수정 자 값에 적합한 유형의 값을 강제하는 &quot;길이 강제 변환 함수&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dbc1f490f7774fb666f596c4d1e1fe3642c52d33" translate="yes" xml:space="preserve">
          <source>It is likely that &lt;code&gt;pg_pltemplate&lt;/code&gt; will be removed in some future release of PostgreSQL, in favor of keeping this knowledge about procedural languages in their respective extension installation scripts.</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; 는 PostgreSQL의 향후 릴리스에서 제거 될 것입니다. 절차 언어에 대한 지식을 해당 확장 설치 스크립트에 유지하기 위해서입니다.</target>
        </trans-unit>
        <trans-unit id="6bb4f0fbbfb491190c393dc7c8ea60757b692676" translate="yes" xml:space="preserve">
          <source>It is normally not necessary to create casts between user-defined types and the standard string types (&lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char(n)&lt;/code&gt;, as well as user-defined types that are defined to be in the string category). PostgreSQL provides automatic I/O conversion casts for that. The automatic casts to string types are treated as assignment casts, while the automatic casts from string types are explicit-only. You can override this behavior by declaring your own cast to replace an automatic cast, but usually the only reason to do so is if you want the conversion to be more easily invokable than the standard assignment-only or explicit-only setting. Another possible reason is that you want the conversion to behave differently from the type's I/O function; but that is sufficiently surprising that you should think twice about whether it's a good idea. (A small number of the built-in types do indeed have different behaviors for conversions, mostly because of requirements of the SQL standard.)</source>
          <target state="translated">일반적으로 사용자 정의 형식과 표준 문자열 형식 ( &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; 및 &lt;code&gt;char(n)&lt;/code&gt; 사이에 캐스트를 만들 필요는 없습니다.문자열 카테고리에 있도록 정의 된 사용자 정의 유형뿐만 아니라). PostgreSQL은이를 위해 자동 I / O 변환 캐스트를 제공합니다. 문자열 유형으로의 자동 캐스트는 할당 캐스트로 취급되는 반면, 문자열 유형으로부터의 자동 캐스트는 명시 적 전용입니다. 자동 캐스트를 대체하기 위해 자신의 캐스트를 선언하여이 동작을 무시할 수 있지만 일반적으로 그렇게하는 유일한 이유는 변환이 표준 할당 전용 또는 명시 적 전용 설정보다 더 쉽게 호출 할 수 있기를 원하기 때문입니다. 또 다른 가능한 이유는 변환이 유형의 I / O 함수와 다르게 동작하기를 원하기 때문입니다. 그러나 그것이 좋은 생각인지에 대해 두 번 생각해야한다는 것은 놀랍습니다. (내장 된 소수의 유형은 실제로 전환에 대해 다른 동작을합니다.주로 SQL 표준의 요구 사항 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="f92a52d7559ea7c6c8c28ba12e1fa17dfea96688" translate="yes" xml:space="preserve">
          <source>It is not allowed to combine &lt;code&gt;connect&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;create_slot&lt;/code&gt;, or &lt;code&gt;copy_data&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 세트를 &lt;code&gt;false&lt;/code&gt; 로 설정 하고 &lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;create_slot&lt;/code&gt; 또는 &lt;code&gt;copy_data&lt;/code&gt; 세트를 &lt;code&gt;true&lt;/code&gt; 로 결합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="072c5ad8d293ff2ada18ad71b639cc19ab727e57" translate="yes" xml:space="preserve">
          <source>It is not currently allowed to &lt;code&gt;PREPARE&lt;/code&gt; a transaction that has executed any operations involving temporary tables or the session's temporary namespace, created any cursors &lt;code&gt;WITH HOLD&lt;/code&gt;, or executed &lt;code&gt;LISTEN&lt;/code&gt;, &lt;code&gt;UNLISTEN&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;. Those features are too tightly tied to the current session to be useful in a transaction to be prepared.</source>
          <target state="translated">현재 임시 테이블 또는 세션의 임시 네임 스페이스와 관련된 작업을 실행하거나, 커서로 &lt;code&gt;WITH HOLD&lt;/code&gt; 를 생성 했거나 &lt;code&gt;LISTEN&lt;/code&gt; , &lt;code&gt;UNLISTEN&lt;/code&gt; 또는 &lt;code&gt;NOTIFY&lt;/code&gt; 를 실행 한 트랜잭션 을 &lt;code&gt;PREPARE&lt;/code&gt; 할 수 없습니다 . 이러한 기능은 현재 세션과 너무 밀접하게 연결되어 있으므로 준비 할 트랜잭션에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="683c463d18b1311e371770a1d3375c3bacddce8d" translate="yes" xml:space="preserve">
          <source>It is not important to which database you connect here since the script file created by pg_dumpall will contain the appropriate commands to create and connect to the saved databases. An exception is that if you specified &lt;code&gt;--clean&lt;/code&gt;, you must connect to the &lt;code&gt;postgres&lt;/code&gt; database initially; the script will attempt to drop other databases immediately, and that will fail for the database you are connected to.</source>
          <target state="translated">pg_dumpall에 의해 생성 된 스크립트 파일에는 저장된 데이터베이스를 생성하고 연결하기위한 적절한 명령이 포함되므로 여기에서 어떤 데이터베이스를 연결하는지는 중요하지 않습니다. &lt;code&gt;--clean&lt;/code&gt; 을 지정한 경우 , &lt;code&gt;postgres&lt;/code&gt; 데이터베이스에 처음 연결해야합니다 . 스크립트는 다른 데이터베이스를 즉시 삭제하려고 시도하며 연결된 데이터베이스에 대해 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1b796566a4506096f72ab10f4b43942e3c90636a" translate="yes" xml:space="preserve">
          <source>It is not necessary to add the root certificate to &lt;code&gt;server.crt&lt;/code&gt;. Instead, clients must have the root certificate of the server's certificate chain.</source>
          <target state="translated">루트 인증서를 &lt;code&gt;server.crt&lt;/code&gt; 에 추가 할 필요는 없습니다 . 대신 클라이언트에는 서버 인증서 체인의 루트 인증서가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c4d12fc72842b14e61904a6ec6e02667bd4e3ff1" translate="yes" xml:space="preserve">
          <source>It is not necessary to be concerned about the amount of time it takes to make a base backup. However, if you normally run the server with &lt;code&gt;full_page_writes&lt;/code&gt; disabled, you might notice a drop in performance while the backup runs since &lt;code&gt;full_page_writes&lt;/code&gt; is effectively forced on during backup mode.</source>
          <target state="translated">기본 백업을 만드는 데 걸리는 시간에 대해 걱정할 필요는 없습니다. 그러나 일반적으로 &lt;code&gt;full_page_writes&lt;/code&gt; 가 비활성화 된 상태 에서 서버를 실행하면 백업 모드 중에 &lt;code&gt;full_page_writes&lt;/code&gt; 가 효과적으로 적용 되므로 백업이 실행되는 동안 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aca7caa9402f8a163da6c6daa7fb30a56a74a363" translate="yes" xml:space="preserve">
          <source>It is not necessary to create table constraints describing partition boundary condition for partitions. Instead, partition constraints are generated implicitly from the partition bound specification whenever there is need to refer to them.</source>
          <target state="translated">파티션의 파티션 경계 조건을 설명하는 테이블 제한 조건을 작성할 필요는 없습니다. 대신, 파티션 제약 조건은 참조가 필요할 때마다 파티션 바인딩 사양에서 암시 적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cf0a2da0ce7b363dca7ad51ebb38c128a6e8bc4b" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or for which the number of additional bytes of storage required is zero.</source>
          <target state="translated">병렬 스캔을 지원하지 않거나 필요한 추가 스토리지 바이트 수가 0 인 액세스 방법에 대해서는이 기능을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="81e24e9944e94aaaad52d26039e5ac57f4d46637" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or in cases where the shared memory space required needs no initialization.</source>
          <target state="translated">병렬 스캔을 지원하지 않거나 필요한 공유 메모리 공간이 초기화 될 필요가없는 경우 액세스 방법에 대해서는이 기능을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="57e901fbd76f488aaa546e02fcd890de2339da2b" translate="yes" xml:space="preserve">
          <source>It is not necessary to provide both of these functions. If one is not specified, the language-specific default behavior will be used if necessary. (To prevent a transformation in a certain direction from happening at all, you could also write a transform function that always errors out.)</source>
          <target state="translated">이 두 기능을 모두 제공 할 필요는 없습니다. 하나를 지정하지 않으면 필요한 경우 언어 별 기본 동작이 사용됩니다. 특정 방향으로의 변환이 전혀 발생하지 않도록 항상 오류가 발생하는 변환 함수를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c2adbe3f4bf051ef1858dcf0e81ceda3ba80d46" translate="yes" xml:space="preserve">
          <source>It is not necessary to replay the WAL entries all the way to the end. We could stop the replay at any point and have a consistent snapshot of the database as it was at that time. Thus, this technique supports &lt;em&gt;point-in-time recovery&lt;/em&gt;: it is possible to restore the database to its state at any time since your base backup was taken.</source>
          <target state="translated">WAL 항목을 끝까지 재생할 필요는 없습니다. 우리는 언제든지 재생을 중지하고 그 당시와 마찬가지로 데이터베이스의 일관된 스냅 샷을 만들 수 있습니다. 따라서이 기술은 &lt;em&gt;특정 시점 복구를&lt;/em&gt; 지원 합니다. 기본 백업을 수행 한 이후 언제든지 데이터베이스를 해당 상태로 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff889e8c8e60f8ff7137e71a9bfef2608859eeae" translate="yes" xml:space="preserve">
          <source>It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt.</source>
          <target state="translated">서버 상태를 얻기 위해 올바른 사용자 이름, 비밀번호 또는 데이터베이스 이름 값을 제공 할 필요는 없습니다. 그러나 잘못된 값을 제공하면 서버는 실패한 연결 시도를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="594a9711ffec0cdfe29afe713704c6029ca7c0e7" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the &lt;code&gt;sync&lt;/code&gt; mount option. The behavior of the &lt;code&gt;async&lt;/code&gt; option is sufficient, since PostgreSQL issues &lt;code&gt;fsync&lt;/code&gt; calls at appropriate times to flush the write caches. (This is analogous to how it works on a local file system.) However, it is strongly recommended to use the &lt;code&gt;sync&lt;/code&gt; export option on the NFS &lt;em&gt;server&lt;/em&gt; on systems where it exists (mainly Linux). Otherwise, an &lt;code&gt;fsync&lt;/code&gt; or equivalent on the NFS client is not actually guaranteed to reach permanent storage on the server, which could cause corruption similar to running with the parameter &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; off. The defaults of these mount and export options differ between vendors and versions, so it is recommended to check and perhaps specify them explicitly in any case to avoid any ambiguity.</source>
          <target state="translated">&lt;code&gt;sync&lt;/code&gt; 마운트 옵션 을 사용할 필요는 없습니다 . PostgreSQL 은 쓰기 캐시를 플러시하기 위해 적절한 시간에 &lt;code&gt;fsync&lt;/code&gt; 호출을 발행하기 때문에 &lt;code&gt;async&lt;/code&gt; 옵션 의 동작으로 충분 합니다. (이것은 로컬 파일 시스템에서 작동하는 방식과 유사합니다.) 그러나 NFS &lt;em&gt;서버&lt;/em&gt; 가 존재하는 시스템 (주로 Linux) 의 NFS &lt;em&gt;서버&lt;/em&gt; 에서 &lt;code&gt;sync&lt;/code&gt; export 옵션 을 사용하는 것이 좋습니다 . 그렇지 않으면, NFS 클라이언트에서 &lt;code&gt;fsync&lt;/code&gt; 또는 이와 동등한 기능이 실제로 서버의 영구 스토리지에 도달하는 것이 보장되지 않으므로 &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; 매개 변수로 실행하는 것과 유사한 손상이 발생할 수 있습니다&lt;em&gt;&lt;/em&gt;떨어져서. 이러한 마운트 및 내보내기 옵션의 기본값은 공급 업체와 버전에 따라 다르므로 모호성을 피하기 위해 경우에 따라 명시 적으로 확인하고 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c52dffeed651be2fa3f87bf20ee3f9a890f9417b" translate="yes" xml:space="preserve">
          <source>It is not possible to release a savepoint when the transaction is in an aborted state.</source>
          <target state="translated">트랜잭션이 중단 된 상태에서는 저장 점을 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfd22308dc33a27874305473df207d131e6a6cc4" translate="yes" xml:space="preserve">
          <source>It is not possible to specify an operator's lexical precedence in &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, because the parser's precedence behavior is hard-wired. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for precedence details.</source>
          <target state="translated">구문 분석기의 우선 순위 동작이 고정되어 있으므로 &lt;code&gt;CREATE OPERATOR&lt;/code&gt; 에서 연산자의 어휘 우선 순위를 지정할 수 없습니다 . 우선 순위에 대해서는 &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;4.1.6 항을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="623a5826c4c93a0ee1b0b35f75bc29bfa6d59c5f" translate="yes" xml:space="preserve">
          <source>It is not possible to turn a regular table into a partitioned table or vice versa. However, it is possible to add a regular or partitioned table containing data as a partition of a partitioned table, or remove a partition from a partitioned table turning it into a standalone table; see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to learn more about the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; and &lt;code&gt;DETACH PARTITION&lt;/code&gt; sub-commands.</source>
          <target state="translated">일반 테이블을 파티션 된 테이블로 또는 그 반대로 변환 할 수 없습니다. 그러나 데이터를 포함하는 일반 또는 파티션 된 테이블을 파티션 된 테이블의 파티션으로 추가하거나 파티션 된 테이블에서 파티션을 제거하여 독립형 테이블로 변환 할 수 있습니다. &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 및 &lt;code&gt;DETACH PARTITION&lt;/code&gt; 하위 명령에 대한 자세한 내용 은 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2662bc57686704e0177490490462c24f0b6b158d" translate="yes" xml:space="preserve">
          <source>It is often a good idea to also omit from the backup the files within the cluster's &lt;code&gt;pg_replslot/&lt;/code&gt; directory, so that replication slots that exist on the master do not become part of the backup. Otherwise, the subsequent use of the backup to create a standby may result in indefinite retention of WAL files on the standby, and possibly bloat on the master if hot standby feedback is enabled, because the clients that are using those replication slots will still be connecting to and updating the slots on the master, not the standby. Even if the backup is only intended for use in creating a new master, copying the replication slots isn't expected to be particularly useful, since the contents of those slots will likely be badly out of date by the time the new master comes on line.</source>
          <target state="translated">마스터에 존재하는 복제 슬롯이 백업의 일부가되지 않도록 클러스터의 &lt;code&gt;pg_replslot/&lt;/code&gt; 디렉토리에 있는 파일을 백업에서 생략하는 것이 좋습니다 . 그렇지 않으면, 백업을 사용하여 대기를 작성하면 대기에서 WAL 파일이 무기한 보유 될 수 있으며 핫 대기 피드백이 사용 가능한 경우 마스터에서 부 풀릴 수 있습니다. 해당 복제 슬롯을 사용하는 클라이언트는 계속 연결되어 있기 때문입니다. 대기가 아닌 마스터의 슬롯으로 업데이트합니다. 백업이 새 마스터를 생성 할 목적으로 만 사용 되더라도 복제 마스터를 복사하는 것은 새 마스터가 온라인 상태가 될 때까지 해당 슬롯의 내용이 오래되지 않기 때문에 특히 유용하지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="d49711f89af35705bbf2891f981f944c8b5260d9" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the function definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them.</source>
          <target state="translated">함수형 문자열을 일반적인 작은 따옴표 구문 대신 쓰기 위해 달러 인용 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;4.1.2.4&lt;/a&gt; 참조)을 사용하는 것이 종종 도움이됩니다 . 달러 따옴표가 없으면 함수 정의에서 작은 따옴표 나 백 슬래시는 두 배로 이스케이프 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="070ae03385b0624216e0f28d18b1063fb9896a1e" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the procedure definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the procedure definition must be escaped by doubling them.</source>
          <target state="translated">프로 시저 정의 문자열을 일반적인 작은 따옴표 구문 대신 쓰기 위해 달러 인용 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;4.1.2.4&lt;/a&gt; 참조)을 사용하는 것이 종종 도움이됩니다 . 달러 따옴표가 없으면 프로 시저 정의의 작은 따옴표 나 백 슬래시는 두 배로 이스케이프 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="1037cf4994d8c1ebf0e5d5f237e680d00560257d" translate="yes" xml:space="preserve">
          <source>It is often particularly handy to &lt;code&gt;LEFT JOIN&lt;/code&gt; to a &lt;code&gt;LATERAL&lt;/code&gt; subquery, so that source rows will appear in the result even if the &lt;code&gt;LATERAL&lt;/code&gt; subquery produces no rows for them. For example, if &lt;code&gt;get_product_names()&lt;/code&gt; returns the names of products made by a manufacturer, but some manufacturers in our table currently produce no products, we could find out which ones those are like this:</source>
          <target state="translated">그것은 종종 특히 편리 &lt;code&gt;LEFT JOIN&lt;/code&gt; A를 &lt;code&gt;LATERAL&lt;/code&gt; 짝수 경우 소스 행이 결과에 나타납니다 그래서, 하위 쿼리 &lt;code&gt;LATERAL&lt;/code&gt; 하위 쿼리가 그들을 위해 더 열을 생산하지 않습니다. 예를 들어, &lt;code&gt;get_product_names()&lt;/code&gt; 가 제조업체가 만든 제품의 이름을 반환하지만 현재 테이블의 일부 제조업체가 제품을 생산하지 않는 경우 다음과 같은 제품을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25dd81b9b45b03c00d03cc26e891361c1cfb5adf" translate="yes" xml:space="preserve">
          <source>It is often preferable to use unique index inference rather than naming a constraint directly using &lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt;&lt;code&gt;constraint_name&lt;/code&gt;. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when using &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; before dropping the index being replaced.</source>
          <target state="translated">&lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt; &lt;code&gt;constraint_name&lt;/code&gt; 을 사용하여 직접 제약 조건의 이름을 지정하는 대신 고유 한 인덱스 유추를 사용하는 것이 좋습니다 . 기본 인덱스가 겹치는 방식으로 다른 동등한 인덱스로 대체 될 때 (예 : 대체 인덱스를 삭제하기 전에 &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; 를 사용하는 경우) 추론이 계속 올바르게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f0921a8a84d9d3343d74c19f7c3f5f4b06b1c95a" translate="yes" xml:space="preserve">
          <source>It is possible for a &lt;code&gt;SELECT&lt;/code&gt; command running at the &lt;code&gt;READ COMMITTED&lt;/code&gt; transaction isolation level and using &lt;code&gt;ORDER BY&lt;/code&gt; and a locking clause to return rows out of order. This is because &lt;code&gt;ORDER BY&lt;/code&gt; is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the &lt;code&gt;SELECT&lt;/code&gt; unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; clause in a sub-query, for example</source>
          <target state="translated">&lt;code&gt;READ COMMITTED&lt;/code&gt; 트랜잭션 격리 수준 에서 실행되고 &lt;code&gt;ORDER BY&lt;/code&gt; 및 잠금 절을 사용하여 행을 순서대로 반환하지 않는 &lt;code&gt;SELECT&lt;/code&gt; 명령 이 가능합니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 가 먼저 적용 되기 때문 입니다. 이 명령은 결과를 정렬하지만 하나 이상의 행에서 잠금을 얻으려고 시도하는 것을 차단할 수 있습니다. 한 번 &lt;code&gt;SELECT&lt;/code&gt; 가 풀려, 주문 열 값의 일부 (그들은 원래 열 값의 측면에서 순서대로하지만) 순서가 될 나타나는 해당 행으로 이어지는, 수정되었을 수 있습니다. 예를 들어 &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; 절을 하위 쿼리 에 배치하면 필요에 따라 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="312a8769f42a09f432ff89ed107b0b0a082956d5" translate="yes" xml:space="preserve">
          <source>It is possible for both the client and server to provide SSL certificates to each other. It takes some extra configuration on each side, but this provides stronger verification of identity than the mere use of passwords. It prevents a computer from pretending to be the server just long enough to read the password sent by the client. It also helps prevent &amp;ldquo;man in the middle&amp;rdquo; attacks where a computer between the client and server pretends to be the server and reads and passes all data between the client and server.</source>
          <target state="translated">클라이언트와 서버 모두 SSL 인증서를 서로 제공 할 수 있습니다. 양쪽에 약간의 추가 구성이 필요하지만 이는 단순한 암호 사용보다 강력한 신원 확인을 제공합니다. 클라이언트가 보낸 암호를 읽을 수있을 정도로 컴퓨터가 서버 인 것처럼 가장하는 것을 방지합니다. 또한 클라이언트와 서버 사이의 컴퓨터가 서버 인 것처럼 &quot;중간자 공격&quot;을 방지하고 클라이언트와 서버 사이의 모든 데이터를 읽고 전달합니다.</target>
        </trans-unit>
        <trans-unit id="90f59c9a7c7c3d668eb0d91ba42953cad54439f7" translate="yes" xml:space="preserve">
          <source>It is possible for the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;SELECT&lt;/code&gt; statement) to also contain a &lt;code&gt;WITH&lt;/code&gt; clause. In such a case both sets of &lt;code&gt;with_query&lt;/code&gt; can be referenced within the &lt;code&gt;query&lt;/code&gt;, but the second one takes precedence since it is more closely nested.</source>
          <target state="translated">가능합니다 &lt;code&gt;query&lt;/code&gt; ( &lt;code&gt;SELECT&lt;/code&gt; 도 포함하는 문) &lt;code&gt;WITH&lt;/code&gt; 절. 이러한 경우 &lt;code&gt;with_query&lt;/code&gt; 의 두 세트를 &lt;code&gt;query&lt;/code&gt; 내에서 참조 할 수 있지만 두 번째 세트 는 더 밀접하게 중첩되므로 우선합니다.</target>
        </trans-unit>
        <trans-unit id="db7d99e745d7786411f8e352570962f202386c2e" translate="yes" xml:space="preserve">
          <source>It is possible for the parser to produce overlapping tokens from the same piece of text. As an example, a hyphenated word will be reported both as the entire word and as each component:</source>
          <target state="translated">파서는 동일한 텍스트 조각에서 겹치는 토큰을 생성 할 수 있습니다. 예를 들어, 하이픈으로 묶인 단어는 전체 단어와 각 구성 요소로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="2357da6f1597b1c38d9b19b97f4eaf9ba4d3b605" translate="yes" xml:space="preserve">
          <source>It is possible that the replication delay between servers exceeds the value of this parameter, in which case no delay is added. Note that the delay is calculated between the WAL time stamp as written on master and the current time on the standby. Delays in transfer because of network lag or cascading replication configurations may reduce the actual wait time significantly. If the system clocks on master and standby are not synchronized, this may lead to recovery applying records earlier than expected; but that is not a major issue because useful settings of this parameter are much larger than typical time deviations between servers.</source>
          <target state="translated">서버 간의 복제 지연이이 매개 변수의 값을 초과 할 수 있으며이 경우 지연이 추가되지 않습니다. 지연은 마스터에 기록 된 WAL 타임 스탬프와 대기 시간의 현재 시간 사이에 계산됩니다. 네트워크 지연 또는 계단식 복제 구성으로 인해 전송이 지연되면 실제 대기 시간이 크게 단축 될 수 있습니다. 마스터 및 대기의 시스템 시계가 동기화되지 않으면 예상보다 빨리 레코드를 적용하여 복구 할 수 있습니다. 그러나이 매개 변수의 유용한 설정이 서버 간의 일반적인 시간 편차보다 훨씬 크기 때문에 중요한 문제는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f9e86aaa136a99713e8aa37be86f1493657e5f36" translate="yes" xml:space="preserve">
          <source>It is possible to access the two component numbers of a &lt;code&gt;point&lt;/code&gt; as though the point were an array with indexes 0 and 1. For example, if &lt;code&gt;t.p&lt;/code&gt; is a &lt;code&gt;point&lt;/code&gt; column then &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; retrieves the X coordinate and &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; changes the Y coordinate. In the same way, a value of type &lt;code&gt;box&lt;/code&gt; or &lt;code&gt;lseg&lt;/code&gt; can be treated as an array of two &lt;code&gt;point&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; 인덱스 0과 1을 갖는 배열 인 것처럼 점 의 두 구성 요소 번호에 액세스 할 수 있습니다 . 예를 들어, &lt;code&gt;t.p&lt;/code&gt; 가 &lt;code&gt;point&lt;/code&gt; 열인 경우 &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; 는 X 좌표를 검색하고 &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; Y 좌표를 변경합니다. 같은 방식으로 &lt;code&gt;box&lt;/code&gt; 또는 &lt;code&gt;lseg&lt;/code&gt; 유형의 값 을 두 &lt;code&gt;point&lt;/code&gt; 값 의 배열로 취급 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d05975d6f7f169fef234fa65303a022ea6de537" translate="yes" xml:space="preserve">
          <source>It is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="translated">sysctl을 사용하여 &lt;code&gt;SHMMNI&lt;/code&gt; 를 제외한 모든 것을 즉시 변경할 수 있습니다 . 그러나 재부팅 후에도 값이 유지되도록 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 를 통해 선호하는 값을 설정하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7fd72ecc1dea1c97715f5cc99a51c3564620c9cb" translate="yes" xml:space="preserve">
          <source>It is possible to check the accuracy of the planner's estimates by using &lt;code&gt;EXPLAIN&lt;/code&gt;'s &lt;code&gt;ANALYZE&lt;/code&gt; option. With this option, &lt;code&gt;EXPLAIN&lt;/code&gt; actually executes the query, and then displays the true row counts and true run time accumulated within each plan node, along with the same estimates that a plain &lt;code&gt;EXPLAIN&lt;/code&gt; shows. For example, we might get a result like this:</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; 의 &lt;code&gt;ANALYZE&lt;/code&gt; 옵션 을 사용하여 플래너 추정값의 정확성을 확인할 수 있습니다. 이 옵션을 사용하면 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 실제로 쿼리를 실행 한 다음 일반 &lt;code&gt;EXPLAIN&lt;/code&gt; 이 표시 하는 것과 동일한 추정값과 함께 각 계획 노드 내에 누적 된 실제 행 수와 실제 런타임을 표시합니다. 예를 들어 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed45fb50f823ca992b140dff1d81be186a3aef4d" translate="yes" xml:space="preserve">
          <source>It is possible to control the query planner to some extent by using the explicit &lt;code&gt;JOIN&lt;/code&gt; syntax. To see why this matters, we first need some background.</source>
          <target state="translated">명시 적 &lt;code&gt;JOIN&lt;/code&gt; 구문 을 사용하여 쿼리 플래너를 어느 정도 제어 할 수 있습니다 . 이것이 왜 중요한지 보려면 먼저 배경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="21ffb53e2d68da0c7954b41e98f5975f4ecf8084" translate="yes" xml:space="preserve">
          <source>It is possible to create a foreign-data wrapper with no handler function, but foreign tables using such a wrapper can only be declared, not accessed.</source>
          <target state="translated">핸들러 함수없이 외부 데이터 랩퍼를 작성할 수 있지만 이러한 랩퍼를 사용하는 외부 테이블은 액세스 할 수없고 선언 만 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5bd3763bfcd5993518d08a6fc8f19894d8b599a" translate="yes" xml:space="preserve">
          <source>It is possible to create additional template databases, and indeed one can copy any database in a cluster by specifying its name as the template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. It is important to understand, however, that this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the source database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; during the copy operation, new connections to the source database are prevented.</source>
          <target state="translated">추가 템플리트 데이터베이스를 작성할 수 있으며 실제로 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 의 템플리트로 이름을 지정하여 클러스터의 모든 데이터베이스를 복사 할 수 있습니다 . 그러나 이것이 범용 &quot; &lt;code&gt;COPY DATABASE&lt;/code&gt; &quot;기능 으로 의도 된 것이 아님을 이해하는 것이 중요합니다 . 주요 제한 사항은 소스 데이터베이스를 복사하는 동안 다른 세션을 소스 데이터베이스에 연결할 수 없다는 것입니다. 시작할 때 다른 연결이 존재하면 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 가 실패합니다. 복사 작업 중에는 소스 데이터베이스에 대한 새로운 연결이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="e68d9c04db6c0169a67f695c187f5caec6e9c6fb" translate="yes" xml:space="preserve">
          <source>It is possible to dispense with &lt;code&gt;SET TRANSACTION&lt;/code&gt; by instead specifying the desired &lt;code&gt;transaction_modes&lt;/code&gt; in &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt;. But that option is not available for &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;BEGIN&lt;/code&gt; 또는 &lt;code&gt;START TRANSACTION&lt;/code&gt; 에서 원하는 &lt;code&gt;transaction_modes&lt;/code&gt; 를 지정하여 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 을 생략 할 수 있습니다 . 그러나 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 에는이 옵션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c6a819090253f862f39b7dcfdb25432b06b91898" translate="yes" xml:space="preserve">
          <source>It is possible to do a full text search without an index. A simple query to print the &lt;code&gt;title&lt;/code&gt; of each row that contains the word &lt;code&gt;friend&lt;/code&gt; in its &lt;code&gt;body&lt;/code&gt; field is:</source>
          <target state="translated">색인없이 전체 텍스트 검색을 수행 할 수 있습니다. 간단한 쿼리는 인쇄 &lt;code&gt;title&lt;/code&gt; 단어가 포함 된 각 행의 &lt;code&gt;friend&lt;/code&gt; 의에서 &lt;code&gt;body&lt;/code&gt; 필드입니다 :</target>
        </trans-unit>
        <trans-unit id="6f136c23eebfd4cd415f6012b712c4df1242fdcd" translate="yes" xml:space="preserve">
          <source>It is possible to have authentication without encryption overhead by using &lt;code&gt;NULL-SHA&lt;/code&gt; or &lt;code&gt;NULL-MD5&lt;/code&gt; ciphers. However, a man-in-the-middle could read and pass communications between client and server. Also, encryption overhead is minimal compared to the overhead of authentication. For these reasons NULL ciphers are not recommended.</source>
          <target state="translated">&lt;code&gt;NULL-SHA&lt;/code&gt; 또는 &lt;code&gt;NULL-MD5&lt;/code&gt; 암호 를 사용하여 암호화 오버 헤드없이 인증을받을 수 있습니다. 그러나 man-in-the-middle은 클라이언트와 서버 간의 통신을 읽고 전달할 수 있습니다. 또한 인증 오버 헤드에 비해 암호화 오버 헤드가 최소화됩니다. 이러한 이유로 NULL 암호는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3a0ba5698f2b4b4f4b4ee88ac329603107cde1d" translate="yes" xml:space="preserve">
          <source>It is possible to log to stderr without using the logging collector; the log messages will just go to wherever the server's stderr is directed. However, that method is only suitable for low log volumes, since it provides no convenient way to rotate log files. Also, on some platforms not using the logging collector can result in lost or garbled log output, because multiple processes writing concurrently to the same log file can overwrite each other's output.</source>
          <target state="translated">로깅 콜렉터를 사용하지 않고 stderr에 로그 할 수 있습니다. 로그 메시지는 서버의 stderr가 향하는 곳이면 어디든 갈 것입니다. 그러나이 방법은 로그 파일을 회전시키는 편리한 방법을 제공하지 않으므로 적은 로그 볼륨에만 적합합니다. 또한 로깅 콜렉터를 사용하지 않는 일부 플랫폼에서는 동일한 로그 파일에 동시에 쓰는 여러 프로세스가 서로의 출력을 겹쳐 쓸 수 있기 때문에 로그 출력이 손실되거나 깨질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d8f4459b3f7e90845c901d21d257a7423c267d0" translate="yes" xml:space="preserve">
          <source>It is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">커널의 동작을 수정하여 메모리를 &quot;오버 커밋&quot;하지 않도록 할 수 있습니다. 이 설정은 &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM 킬러&lt;/a&gt; 가 모두 호출되는 것을 막지는 못하지만 기회를 크게 낮추므로보다 강력한 시스템 동작으로 이어질 것입니다. 이는 &lt;code&gt;sysctl&lt;/code&gt; 을 통해 엄격한 오버 커밋 모드를 선택하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="36e9a78df914fad0648da0a65b3ec648ec904013" translate="yes" xml:space="preserve">
          <source>It is possible to nest dollar-quoted string constants by choosing different tags at each nesting level. This is most commonly used in writing function definitions. For example:</source>
          <target state="translated">각 중첩 수준에서 다른 태그를 선택하여 달러 인용 문자열 상수를 중첩 할 수 있습니다. 이것은 함수 정의를 작성할 때 가장 일반적으로 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0a345a5b07bad2c1307139346533842f66f7f85" translate="yes" xml:space="preserve">
          <source>It is possible to omit the &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; of a slice specifier; the missing bound is replaced by the lower or upper limit of the array's subscripts. For example:</source>
          <target state="translated">슬라이스 지정자의 &lt;code&gt;lower-bound&lt;/code&gt; 및 / 또는 &lt;code&gt;upper-bound&lt;/code&gt; 을 생략 할 수 있으며 ; 누락 된 경계는 배열 아래 첨자의 하한 또는 상한으로 대체됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0fbcc6e88bd4f468012c5b5e8934f903489fc504" translate="yes" xml:space="preserve">
          <source>It is possible to run &lt;code&gt;ANALYZE&lt;/code&gt; on specific tables and even just specific columns of a table, so the flexibility exists to update some statistics more frequently than others if your application requires it. In practice, however, it is usually best to just analyze the entire database, because it is a fast operation. &lt;code&gt;ANALYZE&lt;/code&gt; uses a statistically random sampling of the rows of a table rather than reading every single row.</source>
          <target state="translated">특정 테이블 및 테이블의 특정 열에서만 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행할 수 있으므로 응용 프로그램에 필요한 경우 다른 통계보다 더 자주 일부 통계를 업데이트 할 수있는 유연성이 있습니다. 그러나 실제로는 전체 데이터베이스가 빠른 작업이므로 전체 데이터베이스를 분석하는 것이 가장 좋습니다. &lt;code&gt;ANALYZE&lt;/code&gt; 는 모든 단일 행을 읽는 대신 테이블의 행을 통계적으로 무작위로 샘플링합니다.</target>
        </trans-unit>
        <trans-unit id="56b863d1457c5714b3cbf931bd78aab64ed29d7b" translate="yes" xml:space="preserve">
          <source>It is possible to set up more complex expression indexes wherein the configuration name is specified by another column, e.g.:</source>
          <target state="translated">구성 이름이 다른 열에 의해 지정된보다 복잡한 표현식 색인을 설정할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ab7995c28ab9203226049f19e6325626835b07f5" translate="yes" xml:space="preserve">
          <source>It is possible to use PostgreSQL's backup facilities to produce standalone hot backups. These are backups that cannot be used for point-in-time recovery, yet are typically much faster to backup and restore than pg_dump dumps. (They are also much larger than pg_dump dumps, so in some cases the speed advantage might be negated.)</source>
          <target state="translated">PostgreSQL의 백업 기능을 사용하여 독립형 핫 백업을 생성 할 수 있습니다. 이는 특정 시점 복구에는 사용할 수 없지만 일반적으로 pg_dump 덤프보다 백업 및 복원 속도가 훨씬 빠릅니다. (또한 pg_dump 덤프보다 훨씬 크기 때문에 속도 이점이 무시 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="793bdae387c6386aab767254ea0495efd0a0f102" translate="yes" xml:space="preserve">
          <source>It is possible to use SELinux's dynamic domain transition feature to switch the security label of the client process, the client domain, to a new context, if that is allowed by the security policy. The client domain needs the &lt;code&gt;setcurrent&lt;/code&gt; permission and also &lt;code&gt;dyntransition&lt;/code&gt; from the old to the new domain.</source>
          <target state="translated">보안 정책에서 허용하는 경우 SELinux의 동적 도메인 전환 기능을 사용하여 클라이언트 프로세스, 클라이언트 도메인의 보안 레이블을 새 컨텍스트로 전환 할 수 있습니다. 클라이언트 도메인은 필요 &lt;code&gt;setcurrent&lt;/code&gt; 허락도 &lt;code&gt;dyntransition&lt;/code&gt; 새로운 도메인으로 이전부터입니다.</target>
        </trans-unit>
        <trans-unit id="fea64923e6a1c45508b51b78c6ed3fd042a235d3" translate="yes" xml:space="preserve">
          <source>It is possible to use SSH to encrypt the network connection between clients and a PostgreSQL server. Done properly, this provides an adequately secure network connection, even for non-SSL-capable clients.</source>
          <target state="translated">SSH를 사용하여 클라이언트와 PostgreSQL 서버 간의 네트워크 연결을 암호화 할 수 있습니다. 올바르게 수행하면 SSL을 지원하지 않는 클라이언트에게도 적절한 보안 네트워크 연결이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="05887c55098593888d9b6548b102c0d07ee418cb" translate="yes" xml:space="preserve">
          <source>It is possible to use an NFS file system for storing the PostgreSQL data directory. PostgreSQL does nothing special for NFS file systems, meaning it assumes NFS behaves exactly like locally-connected drives. PostgreSQL does not use any functionality that is known to have nonstandard behavior on NFS, such as file locking.</source>
          <target state="translated">PostgreSQL 데이터 디렉토리를 저장하기 위해 NFS 파일 시스템을 사용할 수 있습니다. PostgreSQL은 NFS 파일 시스템에 대해 특별한 작업을 수행하지 않으므로 NFS가 로컬로 연결된 드라이브와 똑같이 작동한다고 가정합니다. PostgreSQL은 파일 잠금과 같이 NFS에서 비표준 동작을하는 것으로 알려진 기능을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d07d0d357ed59e4c40820ac16ee2111a412a9fe9" translate="yes" xml:space="preserve">
          <source>It is recommended that in a &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; call, the access method further verify that the target row actually does have an existing entry in the index, and report error if not. This is a good idea because the index tuple values passed to &lt;code&gt;aminsert&lt;/code&gt; will have been recomputed. If the index definition involves functions that are not really immutable, we might be checking the wrong area of the index. Checking that the target row is found in the recheck verifies that we are scanning for the same tuple values as were used in the original insertion.</source>
          <target state="translated">에하는 것이 좋습니다 &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; 의 전화, 액세스 방법이 더 목표 행이 실제로 기존 인덱스의 항목 및 보고서 오류 아니더라도을 가지고 있는지 확인하십시오. &lt;code&gt;aminsert&lt;/code&gt; 에 전달 된 인덱스 튜플 값 이 다시 계산 되므로이 방법 을 사용 하는 것이 좋습니다 . 인덱스 정의에 실제로 변경할 수없는 함수가 포함되어 있으면 인덱스의 잘못된 영역을 검사하는 것일 수 있습니다. 재확인에서 대상 행이 있는지 확인하면 원래 삽입에서 사용한 것과 동일한 튜플 값을 스캔하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="302398642319ebf3c5925fc78db8e53f6245f737" translate="yes" xml:space="preserve">
          <source>It is recommended that the file name used in &lt;code&gt;COPY&lt;/code&gt; always be specified as an absolute path. This is enforced by the server in the case of &lt;code&gt;COPY TO&lt;/code&gt;, but for &lt;code&gt;COPY FROM&lt;/code&gt; you do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 에 사용 된 파일 이름은 항상 절대 경로로 지정 하는 것이 좋습니다 . 이것은 &lt;code&gt;COPY TO&lt;/code&gt; 의 경우 서버에 의해 적용 되지만 &lt;code&gt;COPY FROM&lt;/code&gt; 의 경우 상대 경로로 지정된 파일에서 읽을 수있는 옵션이 있습니다. 경로는 클라이언트의 작업 디렉토리가 아닌 서버 프로세스의 작업 디렉토리 (일반적으로 클러스터의 데이터 디렉토리)를 기준으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="fc0e534ffa8e632dc4cfe7cd8ad98fc538520874" translate="yes" xml:space="preserve">
          <source>It is recommended that you use the pg_dump and pg_dumpall programs from the &lt;em&gt;newer&lt;/em&gt; version of PostgreSQL, to take advantage of enhancements that might have been made in these programs. Current releases of the dump programs can read data from any server version back to 7.0.</source>
          <target state="translated">&lt;em&gt;최신&lt;/em&gt; 버전의 PostgreSQL 에서 pg_dump 및 pg_dumpall 프로그램을 사용하여 이러한 프로그램에서 개선 된 기능을 활용하는 것이 좋습니다. 덤프 프로그램의 현재 릴리스는 모든 서버 버전에서 7.0으로 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c852fda272f66e174a3889edb42521ecc91c452" translate="yes" xml:space="preserve">
          <source>It is redundant to use the &lt;code&gt;clientcert&lt;/code&gt; option with &lt;code&gt;cert&lt;/code&gt; authentication because &lt;code&gt;cert&lt;/code&gt; authentication is effectively &lt;code&gt;trust&lt;/code&gt; authentication with &lt;code&gt;clientcert=verify-full&lt;/code&gt;.</source>
          <target state="translated">It is redundant to use the &lt;code&gt;clientcert&lt;/code&gt; option with &lt;code&gt;cert&lt;/code&gt; authentication because &lt;code&gt;cert&lt;/code&gt; authentication is effectively &lt;code&gt;trust&lt;/code&gt; authentication with &lt;code&gt;clientcert=verify-full&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="580dc3a7b05e5fa4e5a6d4851ec4e93eeb1cdf02" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be resent from the publisher.</source>
          <target state="translated">사용하기 안전 &lt;code&gt;off&lt;/code&gt; 논리적 복제 : 가입자가 때문에 동기화 누락의 거래를 중단되면 데이터가 게시자의 재전송 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5365d46a8cd20c8ffe5a596a1e9394f61f94500" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be sent again from the publisher.</source>
          <target state="translated">It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be sent again from the publisher.</target>
        </trans-unit>
        <trans-unit id="29f5d0a01be6a99ad6990afcd555514ae6b7efcb" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that &lt;code&gt;earthdistance&lt;/code&gt; and &lt;code&gt;cube&lt;/code&gt; be installed in the same schema, and that that schema be one for which CREATE privilege has not been and will not be granted to any untrusted users. Otherwise there are installation-time security hazards if &lt;code&gt;earthdistance&lt;/code&gt;'s schema contains objects defined by a hostile user. Furthermore, when using &lt;code&gt;earthdistance&lt;/code&gt;'s functions after installation, the entire search path should contain only trusted schemas.</source>
          <target state="translated">It is strongly recommended that &lt;code&gt;earthdistance&lt;/code&gt; and &lt;code&gt;cube&lt;/code&gt; be installed in the same schema, and that that schema be one for which CREATE privilege has not been and will not be granted to any untrusted users. Otherwise there are installation-time security hazards if &lt;code&gt;earthdistance&lt;/code&gt; 's schema contains objects defined by a hostile user. Furthermore, when using &lt;code&gt;earthdistance&lt;/code&gt; 's functions after installation, the entire search path should contain only trusted schemas.</target>
        </trans-unit>
        <trans-unit id="70a88889b7d21af89f699959f3df667165202cd6" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications generating &lt;code&gt;COPY&lt;/code&gt; data convert data newlines and carriage returns to the &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; sequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if the &lt;code&gt;COPY&lt;/code&gt; file is transferred across different machines (for example, from Unix to Windows or vice versa).</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 데이터를 생성하는 응용 프로그램은 데이터 줄 바꾸기 및 캐리지 리턴을 각각 &lt;code&gt;\n&lt;/code&gt; 및 &lt;code&gt;\r&lt;/code&gt; 시퀀스 로 변환 하는 것이 좋습니다 . 현재 백 슬래시 및 캐리지 리턴으로 데이터 캐리지 리턴을 표시하고 백 슬래시 및 뉴 라인으로 데이터 뉴 라인을 표시 할 수 있습니다. 그러나 다음 릴리스에서는 이러한 표현이 허용되지 않을 수 있습니다. 또한 &lt;code&gt;COPY&lt;/code&gt; 파일이 다른 시스템 (예 : Unix에서 Windows로 또는 그 반대로)으로 전송되는 경우 손상에 매우 취약합니다 .</target>
        </trans-unit>
        <trans-unit id="d870a88dee5f04bff258cb0a3da6e5856609ce9f" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;hstore&lt;/code&gt;. Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</source>
          <target state="translated">It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;hstore&lt;/code&gt; . Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</target>
        </trans-unit>
        <trans-unit id="027fad8c14749d5c9a12505629778b95ee9e9e46" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;ltree&lt;/code&gt;. Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</source>
          <target state="translated">It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;ltree&lt;/code&gt; . Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</target>
        </trans-unit>
        <trans-unit id="5d757720e64f735dd8e83c5c66b88db49094003f" translate="yes" xml:space="preserve">
          <source>It is typically used like this:</source>
          <target state="translated">일반적으로 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb6eae65d1260158a9aaaa3278cf273df69fbee7" translate="yes" xml:space="preserve">
          <source>It is unwise to leave transactions in the prepared state for a long time. This will interfere with the ability of &lt;code&gt;VACUUM&lt;/code&gt; to reclaim storage, and in extreme cases could cause the database to shut down to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;). Keep in mind also that the transaction continues to hold whatever locks it held. The intended usage of the feature is that a prepared transaction will normally be committed or rolled back as soon as an external transaction manager has verified that other databases are also prepared to commit.</source>
          <target state="translated">트랜잭션을 준비된 상태로 오랫동안 두는 것은 현명하지 않습니다. 이는 &lt;code&gt;VACUUM&lt;/code&gt; 이 스토리지를 재생 하는 기능을 방해하며, 극단적 인 경우 트랜잭션 ID 랩 어라운드를 방지하기 위해 데이터베이스가 종료 될 수 있습니다 ( &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절&lt;/a&gt; 참조 ). 또한 트랜잭션은 보유한 모든 잠금을 계속 보유합니다. 이 기능의 의도 된 용도는 외부 트랜잭션 관리자가 다른 데이터베이스도 커밋 할 준비가되었음을 확인하자마자 준비된 트랜잭션이 정상적으로 커밋되거나 롤백되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a307e2692a3d4dc03f3b0a5f0050741c926c9763" translate="yes" xml:space="preserve">
          <source>It is up to the database designer to define the channel names that will be used in a given database and what each one means. Commonly, the channel name is the same as the name of some table in the database, and the notify event essentially means, &amp;ldquo;I changed this table, take a look at it to see what's new&amp;rdquo;. But no such association is enforced by the &lt;code&gt;NOTIFY&lt;/code&gt; and &lt;code&gt;LISTEN&lt;/code&gt; commands. For example, a database designer could use several different channel names to signal different sorts of changes to a single table. Alternatively, the payload string could be used to differentiate various cases.</source>
          <target state="translated">주어진 데이터베이스에서 사용될 채널 이름과 각각의 의미를 정의하는 것은 데이터베이스 디자이너의 책임입니다. 일반적으로 채널 이름은 데이터베이스의 일부 테이블 이름과 동일하며 알림 이벤트는 기본적으로 &quot;이 테이블을 변경했습니다. 새로운 기능을 확인하려면이 테이블을 살펴보십시오&quot;를 의미합니다. 그러나 &lt;code&gt;NOTIFY&lt;/code&gt; 및 &lt;code&gt;LISTEN&lt;/code&gt; 명령으로 이러한 연관을 시행하지는 않습니다 . 예를 들어, 데이터베이스 디자이너는 여러 다른 채널 이름을 사용하여 단일 테이블에 대한 다양한 종류의 변경을 신호 할 수 있습니다. 또는 페이로드 문자열을 사용하여 다양한 경우를 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b6810a1ee6954d361d4c3ec546cf2001eccf7f" translate="yes" xml:space="preserve">
          <source>It is up to the specific dictionary how it treats stop words. For example, &lt;code&gt;ispell&lt;/code&gt; dictionaries first normalize words and then look at the list of stop words, while &lt;code&gt;Snowball&lt;/code&gt; stemmers first check the list of stop words. The reason for the different behavior is an attempt to decrease noise.</source>
          <target state="translated">중지 단어를 처리하는 방법은 특정 사전에 달려 있습니다. 예를 들어, &lt;code&gt;ispell&lt;/code&gt; 사전은 먼저 단어를 정규화 한 다음 중지 단어 목록을보고 &lt;code&gt;Snowball&lt;/code&gt; 형태소 분석기는 먼저 중지 단어 목록을 확인합니다. 다른 행동의 이유는 소음을 줄이기위한 시도입니다.</target>
        </trans-unit>
        <trans-unit id="ea9210befc0db8269a2ec074f163712e284e5a63" translate="yes" xml:space="preserve">
          <source>It is usually possible to compare values of related data types as well; for example &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;bigint&lt;/code&gt; will work. Some cases of this sort are implemented directly by &amp;ldquo;cross-type&amp;rdquo; comparison operators, but if no such operator is available, the parser will coerce the less-general type to the more-general type and apply the latter's comparison operator.</source>
          <target state="translated">It is usually possible to compare values of related data types as well; for example &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;bigint&lt;/code&gt; will work. Some cases of this sort are implemented directly by &amp;ldquo;cross-type&amp;rdquo; comparison operators, but if no such operator is available, the parser will coerce the less-general type to the more-general type and apply the latter's comparison operator.</target>
        </trans-unit>
        <trans-unit id="f04c713c711198819201fd61c74a6825a1ba7c14" translate="yes" xml:space="preserve">
          <source>It is usually wise to create the primary and standby servers so that they are as similar as possible, at least from the perspective of the database server. In particular, the path names associated with tablespaces will be passed across unmodified, so both primary and standby servers must have the same mount paths for tablespaces if that feature is used. Keep in mind that if &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; is executed on the primary, any new mount point needed for it must be created on the primary and all standby servers before the command is executed. Hardware need not be exactly the same, but experience shows that maintaining two identical systems is easier than maintaining two dissimilar ones over the lifetime of the application and system. In any case the hardware architecture must be the same &amp;mdash; shipping from, say, a 32-bit to a 64-bit system will not work.</source>
          <target state="translated">최소한 데이터베이스 서버의 관점에서 볼 때 가능한 한 유사하도록 기본 및 대기 서버를 작성하는 것이 좋습니다. 특히, 테이블 스페이스와 연관된 경로 이름은 수정되지 않은 상태로 전달되므로 해당 기능이 사용되는 경우 기본 서버와 대기 서버 모두 테이블 스페이스에 대해 동일한 마운트 경로를 가져야합니다. &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE 인&lt;/a&gt; 경우기본에서 실행되는 경우 명령을 실행하기 전에 기본 및 모든 대기 서버에서 필요한 새 마운트 지점을 작성해야합니다. 하드웨어가 정확히 동일 할 필요는 없지만, 경험에 따르면 응용 프로그램 및 시스템 수명 동안 2 개의 동일한 시스템을 유지 관리하는 것이 2 개의 다른 시스템을 유지 관리하는 것이 더 쉽다는 것이 밝혀졌습니다. 어쨌든 하드웨어 아키텍처는 동일해야합니다. 예를 들어 32 비트에서 64 비트 시스템으로의 배송은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ca150da1f7706a6be21716f546b65e3672dbc4a" translate="yes" xml:space="preserve">
          <source>It is very difficult to avoid such problems, because of SQL's general assumption that a null value is a valid value of every data type. Best practice therefore is to design a domain's constraints so that a null value is allowed, and then to apply column &lt;code&gt;NOT NULL&lt;/code&gt; constraints to columns of the domain type as needed, rather than directly to the domain type.</source>
          <target state="translated">널값이 모든 데이터 유형의 유효한 값이라는 SQL의 일반적인 가정 때문에 이러한 문제점을 피하는 것은 매우 어렵습니다. 따라서 가장 좋은 방법은 null 값이 허용되도록 도메인의 제약 조건을 디자인 한 다음 도메인 유형의 열에 필요 &lt;code&gt;NOT NULL&lt;/code&gt; 경우 도메인 유형의 열에 NOT NULL 열 제약 조건을 적용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ca67a8bc55b2440ee4642c5a3836e4f1be7ce5b" translate="yes" xml:space="preserve">
          <source>It is very difficult to enforce business rules regarding data integrity using Read Committed transactions because the view of the data is shifting with each statement, and even a single statement may not restrict itself to the statement's snapshot if a write conflict occurs.</source>
          <target state="translated">커밋 된 읽기 트랜잭션을 사용하여 데이터 무결성에 관한 비즈니스 규칙을 적용하는 것은 매우 어렵습니다. 데이터 뷰가 각 명령문마다 바뀌고 있기 때문에 쓰기 충돌이 발생할 경우 단일 명령문이라도 명령문의 스냅 샷으로 제한되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c946419a4ac69d8f0e7011290f8155362fae2bbd" translate="yes" xml:space="preserve">
          <source>It is very easy to use pgbench to produce completely meaningless numbers. Here are some guidelines to help you get useful results.</source>
          <target state="translated">pgbench를 사용하여 완전히 의미없는 숫자를 생성하는 것은 매우 쉽습니다. 유용한 결과를 얻는 데 도움이되는 몇 가지 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a18d874cf4b801c23ef52010af4733b69c843e7" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as a superuser or an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="translated">권한있는 정보를 쉽게 추출 할 수 있기 때문에 신뢰할 수있는 사용자 만 WAL 스트림을 읽을 수 있도록 복제 액세스 권한을 설정하는 것이 매우 중요합니다. 대기 서버는 수퍼 유저 또는 &lt;code&gt;REPLICATION&lt;/code&gt; 권한 이있는 계정으로 기본 서버를 인증해야합니다 . 복제에 대한 &lt;code&gt;REPLICATION&lt;/code&gt; 및 &lt;code&gt;LOGIN&lt;/code&gt; 권한을 가진 전용 사용자 계정을 만드는 것이 좋습니다 . &lt;code&gt;REPLICATION&lt;/code&gt; 권한은 매우 높은 권한을 부여 하지만 사용자는 &lt;code&gt;SUPERUSER&lt;/code&gt; 권한이 수행 하는 기본 시스템의 데이터를 수정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fee748fec5cbfe77ff2427ad0976951907c37cc5" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege or a superuser. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="translated">It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege or a superuser. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</target>
        </trans-unit>
        <trans-unit id="d630958bd06e172aebb494cef807db838ae776b4" translate="yes" xml:space="preserve">
          <source>It is very important to take care to avoid circular rules. For example, though each of the following two rule definitions are accepted by PostgreSQL, the &lt;code&gt;SELECT&lt;/code&gt; command would cause PostgreSQL to report an error because of recursive expansion of a rule:</source>
          <target state="translated">순환 규칙을 피하기 위해주의를 기울여야합니다. 예를 들어, PostgreSQL은 다음 두 가지 규칙 정의를 승인하지만 &lt;code&gt;SELECT&lt;/code&gt; 명령은 규칙의 재귀 확장으로 인해 PostgreSQL이 오류를보고하게합니다.</target>
        </trans-unit>
        <trans-unit id="5a1a313f5514df92e2599108b061f0b4f0a8e02d" translate="yes" xml:space="preserve">
          <source>It is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables.</source>
          <target state="translated">조인 쿼리에서 모든 열 이름을 한정하는 것이 좋은 스타일로 널리 간주되므로 중복 열 이름이 나중에 테이블 중 하나에 추가 되어도 쿼리가 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="906e585ddeae75bc90c0d2a785d10b4e23e5052c" translate="yes" xml:space="preserve">
          <source>It is wise to be conservative about marking casts as implicit. An overabundance of implicit casting paths can cause PostgreSQL to choose surprising interpretations of commands, or to be unable to resolve commands at all because there are multiple possible interpretations. A good rule of thumb is to make a cast implicitly invokable only for information-preserving transformations between types in the same general type category. For example, the cast from &lt;code&gt;int2&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; can reasonably be implicit, but the cast from &lt;code&gt;float8&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; should probably be assignment-only. Cross-type-category casts, such as &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt;, are best made explicit-only.</source>
          <target state="translated">캐스트를 암시 적으로 표시하는 것은 보수적 인 것이 좋습니다. 암시 적 캐스팅 경로가 너무 많으면 PostgreSQL이 놀라운 명령 해석을 선택하거나 여러 가지 해석이 가능하므로 명령을 전혀 해석하지 못할 수 있습니다. 일반적으로 동일한 일반 유형 범주에서 유형 간 정보 보존 변환에만 캐스트를 내재적으로 호출 할 수 없도록하는 것이 좋습니다. 예를 들어, &lt;code&gt;int2&lt;/code&gt; 에서 &lt;code&gt;int4&lt;/code&gt; 로의 캐스트 는 상당히 암시적일 수 있지만 &lt;code&gt;float8&lt;/code&gt; 에서 &lt;code&gt;int4&lt;/code&gt; 로의 캐스트는 할당 전용이어야합니다. 같은 십자가 형 범주 캐스트, &lt;code&gt;text&lt;/code&gt; 에 &lt;code&gt;int4&lt;/code&gt; 가장 명시 적으로 만 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="323e3c36d34b28b8ba0133e0d8df50cff77d9ca5" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. A useful alternative is to use Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;; then the server will check that the character conversion is possible.</source>
          <target state="translated">It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. A useful alternative is to use Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;; then the server will check that the character conversion is possible.</target>
        </trans-unit>
        <trans-unit id="7c5b3068c21100601581e786ee86ca3a3f0b7637" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. When the server encoding is UTF-8, then the Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;, should be used instead. (The alternative would be doing the UTF-8 encoding by hand and writing out the bytes, which would be very cumbersome.)</source>
          <target state="translated">특히 8 진 또는 16 진 이스케이프를 사용할 때 작성하는 바이트 시퀀스는 서버 문자 세트 인코딩에서 유효한 문자를 작성해야합니다. 서버 인코딩이 UTF-8 인 경우, &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;4.1.2.3 절에&lt;/a&gt; 설명 된 유니 코드 이스케이프 또는 대체 유니 코드 이스케이프 구문을 대신 사용해야합니다. (대체 UTF-8 인코딩을 직접 수행하고 바이트를 작성하는 것이 번거로울 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="570a15e9c9ce6ae9a6fe65bb5309393853fdf2d9" translate="yes" xml:space="preserve">
          <source>It joins two functions into a single &lt;code&gt;FROM&lt;/code&gt; target. &lt;code&gt;json_to_recordset()&lt;/code&gt; is instructed to return two columns, the first &lt;code&gt;integer&lt;/code&gt; and the second &lt;code&gt;text&lt;/code&gt;. The result of &lt;code&gt;generate_series()&lt;/code&gt; is used directly. The &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts the column values as integers.</source>
          <target state="translated">It joins two functions into a single &lt;code&gt;FROM&lt;/code&gt; target. &lt;code&gt;json_to_recordset()&lt;/code&gt; is instructed to return two columns, the first &lt;code&gt;integer&lt;/code&gt; and the second &lt;code&gt;text&lt;/code&gt; . The result of &lt;code&gt;generate_series()&lt;/code&gt; is used directly. The &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts the column values as integers.</target>
        </trans-unit>
        <trans-unit id="7e498293987ea55fea8d5b2403c8c230700d8887" translate="yes" xml:space="preserve">
          <source>It makes your SQL statements verbose, and you always have to remember to use &lt;code&gt;lower&lt;/code&gt; on both the column and the query value.</source>
          <target state="translated">그것은 자세한 SQL 문을 만들고, 당신은 항상 사용하는 것을 기억해야 &lt;code&gt;lower&lt;/code&gt; 열 및 쿼리 값 모두.</target>
        </trans-unit>
        <trans-unit id="ef32cc79ad6cb19406da947c5847a9365640d3e1" translate="yes" xml:space="preserve">
          <source>It may also be necessary to give the database server's operating system user permission to use huge pages by setting &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; via sysctl, and/or give permission to lock memory with &lt;code&gt;ulimit -l&lt;/code&gt;.</source>
          <target state="translated">sysctl을 통해 &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; 을 설정하여 데이터베이스 페이지의 운영 체제 사용자에게 방대한 페이지를 사용할 수있는 권한을 부여하거나 &lt;code&gt;ulimit -l&lt;/code&gt; 을 사용하여 메모리를 잠글 수있는 권한을 부여해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c230567f694e16c717ab914422a39d27766ee1c7" translate="yes" xml:space="preserve">
          <source>It may be advisable to avoid using type and table names that begin with underscore. While the server will change generated array type names to avoid collisions with user-given names, there is still risk of confusion, particularly with old client software that may assume that type names beginning with underscores always represent arrays.</source>
          <target state="translated">밑줄로 시작하는 유형 및 테이블 이름을 사용하지 않는 것이 좋습니다. 서버는 사용자가 지정한 이름과의 충돌을 피하기 위해 생성 된 배열 유형 이름을 변경하지만, 특히 밑줄로 시작하는 유형 이름이 항상 배열을 나타내는 것으로 가정 할 수있는 이전 클라이언트 소프트웨어와 혼동 될 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="914462b7eb826c460762b58dc586f5544963cc18" translate="yes" xml:space="preserve">
          <source>It may be useful to adjust this size to control the granularity of WAL log shipping or archiving. Also, in databases with a high volume of WAL, the sheer number of WAL files per directory can become a performance and management problem. Increasing the WAL file size will reduce the number of WAL files.</source>
          <target state="translated">WAL 로그 전달 또는 보관의 세분성을 제어하기 위해이 크기를 조정하는 것이 유용 할 수 있습니다. 또한 WAL이 많은 데이터베이스의 경우 디렉토리 당 많은 WAL 파일 수가 성능 및 관리 문제가 될 수 있습니다. WAL 파일 크기를 늘리면 WAL 파일 수가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="7c0fb5b044b855badd9b796e550a5309d125f9a8" translate="yes" xml:space="preserve">
          <source>It might, however, be necessary to modify the global &lt;code&gt;ulimit&lt;/code&gt; information in &lt;code&gt;/etc/security/limits&lt;/code&gt;, as the default hard limits for file sizes (&lt;code&gt;fsize&lt;/code&gt;) and numbers of files (&lt;code&gt;nofiles&lt;/code&gt;) might be too low.</source>
          <target state="translated">그러나 파일 크기 ( &lt;code&gt;fsize&lt;/code&gt; ) 및 파일 수 ( &lt;code&gt;nofiles&lt;/code&gt; ) 의 기본 하드 한계 가 너무 낮을 수 있으므로 &lt;code&gt;/etc/security/limits&lt;/code&gt; 에서 전역 &lt;code&gt;ulimit&lt;/code&gt; 정보 를 수정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="91b31f4b37ed5e598eb7def83710e2ca48bbe707" translate="yes" xml:space="preserve">
          <source>It should also be noted that because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities. These are not discussed here.</source>
          <target state="translated">It should also be noted that because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities. These are not discussed here.</target>
        </trans-unit>
        <trans-unit id="fff2052adc7cc9fd5e18f86ad66dfe1b9dfc242d" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="translated">또한 기본 WAL 형식은 많은 디스크 페이지 스냅 샷을 포함하므로 상당히 부피가 크다는 점에 유의해야합니다. 이러한 페이지 스냅 샷은 부분적으로 작성된 디스크 페이지를 수정해야 할 수 있으므로 응급 복구를 지원하도록 설계되었습니다. 시스템 하드웨어 및 소프트웨어에 따라 부분 쓰기의 위험은 무시할 정도로 작을 수 있습니다.이 경우 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 매개 변수를 사용하여 페이지 스냅 샷을 해제하여 아카이브 된 로그의 총 볼륨을 크게 줄일 수 있습니다 . (읽기의 참고 사항과 경고 &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;제 29 장&lt;/a&gt; 이렇게 전에.) PITR 작업에 대한 로그의 사용을 금지하지 않는 페이지 스냅 샷 끄기. 향후 개발 영역은 &lt;code&gt;full_page_writes&lt;/code&gt; 일 때에도 불필요한 페이지 사본을 제거하여 아카이브 된 WAL 데이터를 압축하는 것입니다.켜져 있습니다. 그 동안 관리자는 가능한 한 검사 점 간격 매개 변수를 늘려 WAL에 포함 된 페이지 스냅 숏 수를 줄이려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27800a360494c7320b8e3b3710d75e18bd41894b" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="translated">It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</target>
        </trans-unit>
        <trans-unit id="af922062ac86a130253f6b4fd50587d3a97630cd" translate="yes" xml:space="preserve">
          <source>It should be fairly clear why a btree index requires these laws to hold within a single data type: without them there is no ordering to arrange the keys with. Also, index searches using a comparison key of a different data type require comparisons to behave sanely across two data types. The extensions to three or more data types within a family are not strictly required by the btree index mechanism itself, but the planner relies on them for optimization purposes.</source>
          <target state="translated">btree 인덱스에 이러한 법칙이 단일 데이터 유형 내에 포함되어야하는 이유는 분명해야합니다. 규칙이 없으면 키를 정렬 할 순서가 없습니다. 또한 다른 데이터 유형의 비교 키를 사용하는 인덱스 검색에서는 두 데이터 유형에서 비교가 제대로 작동하지 않아야합니다. btree 인덱스 메커니즘 자체에서 패밀리 내 3 개 이상의 데이터 유형으로의 확장이 반드시 필요한 것은 아니지만 플래너는 최적화 목적으로 이들을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e49813f2476bbea73d4ff66119d7d7387c964091" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;code&gt;pg_cast&lt;/code&gt; does not represent every type conversion that the system knows how to perform; only those that cannot be deduced from some generic rule. For example, casting between a domain and its base type is not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;. Another important exception is that &amp;ldquo;automatic I/O conversion casts&amp;rdquo;, those performed using a data type's own I/O functions to convert to or from &lt;code&gt;text&lt;/code&gt; or other string types, are not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;.</source>
          <target state="translated">주목해야한다 &lt;code&gt;pg_cast&lt;/code&gt; 는 시스템이 수행하는 방법을 알고있는 모든 종류의 변환을 표현하지 않는다 일반적인 규칙에서 추론 할 수없는 것들만 예를 들어, 도메인과 기본 유형 간 캐스트는 &lt;code&gt;pg_cast&lt;/code&gt; 에 명시 적으로 표시되지 않습니다 . 또 다른 중요한 예외는 데이터 유형 자체의 I / O 함수를 사용하여 &lt;code&gt;text&lt;/code&gt; 또는 다른 문자열 유형 으로 변환하거나 텍스트 에서 다른 문자열 유형 으로 변환하는 &quot;자동 I / O 변환 캐스트&quot; 는 &lt;code&gt;pg_cast&lt;/code&gt; 에 명시 적으로 표시되지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3f75a2b78a5f5649b3ab9e555457464dd4adddae" translate="yes" xml:space="preserve">
          <source>It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used.</source>
          <target state="translated">점검 표현식이 true 또는 널값으로 평가되면 점검 제한 조건이 충족됨에 유의하십시오. 피연산자가 널이면 대부분의 표현식이 널값으로 평가되므로 제한 컬럼의 널값을 막지 않습니다. 열에 널값이 포함되지 않도록 다음 섹션에서 설명하는 널이 아닌 제한 조건을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02935ea4ceb5538c0d2002f169c21bb8e60788b3" translate="yes" xml:space="preserve">
          <source>It should be noted that database superusers can access all objects regardless of object privilege settings. This is comparable to the rights of &lt;code&gt;root&lt;/code&gt; in a Unix system. As with &lt;code&gt;root&lt;/code&gt;, it's unwise to operate as a superuser except when absolutely necessary.</source>
          <target state="translated">데이터베이스 수퍼 유저는 개체 권한 설정에 관계없이 모든 개체에 액세스 할 수 있습니다. 이것은 유닉스 시스템에서 &lt;code&gt;root&lt;/code&gt; 의 권한과 비슷 합니다. &lt;code&gt;root&lt;/code&gt; 와 마찬가지로 절대적으로 필요한 경우를 제외하고 수퍼 유저로 작동하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c98ab8e1a3d8f36aae75d2304e7a94b266eaa6f" translate="yes" xml:space="preserve">
          <source>It should be noted that except for &lt;code&gt;count&lt;/code&gt;, these functions return a null value when no rows are selected. In particular, &lt;code&gt;sum&lt;/code&gt; of no rows returns null, not zero as one might expect, and &lt;code&gt;array_agg&lt;/code&gt; returns null rather than an empty array when there are no input rows. The &lt;code&gt;coalesce&lt;/code&gt; function can be used to substitute zero or an empty array for null when necessary.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 를 제외하고 이러한 함수는 행을 선택하지 않으면 null 값을 반환합니다. 특히, 행이없는 &lt;code&gt;sum&lt;/code&gt; 는 예상대로 0이 아닌 null을 반환 하고 입력 행이 없으면 &lt;code&gt;array_agg&lt;/code&gt; 는 빈 배열이 아닌 null을 반환합니다. &lt;code&gt;coalesce&lt;/code&gt; 기능은 대체 제로는 null 빈 배열해야하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="fcddd727e8976d04c908eb345e29817691fb2925" translate="yes" xml:space="preserve">
          <source>It should be noted that log shipping is asynchronous, i.e., the WAL records are shipped after transaction commit. As a result, there is a window for data loss should the primary server suffer a catastrophic failure; transactions not yet shipped will be lost. The size of the data loss window in file-based log shipping can be limited by use of the &lt;code&gt;archive_timeout&lt;/code&gt; parameter, which can be set as low as a few seconds. However such a low setting will substantially increase the bandwidth required for file shipping. Streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) allows a much smaller window of data loss.</source>
          <target state="translated">로그 전달은 비동기 적입니다. 즉, 트랜잭션 커밋 후에 WAL 레코드가 전달됩니다. 결과적으로 주 서버에 치명적인 오류가 발생하면 데이터가 손실 될 수 있습니다. 아직 배송되지 않은 거래는 손실됩니다. 파일 기반 로그 전달에서 데이터 손실 창의 크기는 &lt;code&gt;archive_timeout&lt;/code&gt; 매개 변수 를 사용하여 제한 할 수 있습니다.이 매개 변수는 몇 초 정도로 낮게 설정할 수 있습니다. 그러나 이러한 낮은 설정은 파일 전송에 필요한 대역폭을 크게 증가시킵니다. 스트리밍 복제 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;섹션 26.2.5&lt;/a&gt; 참조 )는 훨씬 더 작은 데이터 손실 창을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3fca8a3246e56f8200631a2d48d923a7438a3af3" translate="yes" xml:space="preserve">
          <source>It should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="translated">It should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt; , as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</target>
        </trans-unit>
        <trans-unit id="3defdb9a09006209e803808debdc569c264d27e7" translate="yes" xml:space="preserve">
          <source>It won't use an index, unless you create a functional index using &lt;code&gt;lower&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; 를 사용하여 기능 색인을 작성하지 않으면 색인을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b722c9c9f3f75689f42f0b53f218a01c48008e8" translate="yes" xml:space="preserve">
          <source>It would be better to instead create child tables as follows:</source>
          <target state="translated">대신 다음과 같이 자식 테이블을 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3751c875e52c61621661f1961d94164268c168e" translate="yes" xml:space="preserve">
          <source>It's a matter of taste.</source>
          <target state="translated">맛의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="6308fac37b6f916e6aaeedec4f54478b5685b89a" translate="yes" xml:space="preserve">
          <source>It's advisable to create &lt;code&gt;ndistinct&lt;/code&gt; statistics objects only on combinations of columns that are actually used for grouping, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; cycles are just wasted.</source>
          <target state="translated">실제로 그룹화에 사용되며 그룹 수를 잘못 추정하여 잘못된 계획을 초래하는 열 조합에서만 &lt;code&gt;ndistinct&lt;/code&gt; 통계 개체 를 작성하는 것이 좋습니다 . 그렇지 않으면 &lt;code&gt;ANALYZE&lt;/code&gt; 사이클이 낭비됩니다.</target>
        </trans-unit>
        <trans-unit id="695d14c6506a71cfb6f8af1b5d18b963ae0d4f6f" translate="yes" xml:space="preserve">
          <source>It's advisable to create MCV statistics objects only on combinations of columns that are actually used in conditions together, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; and planning cycles are just wasted.</source>
          <target state="translated">실제로 조건에 함께 사용되며 그룹 수를 잘못 추정하면 계획이 잘못되는 열 조합에 대해서만 MCV 통계 개체를 만드는 것이 좋습니다. 그렇지 않으면 &lt;code&gt;ANALYZE&lt;/code&gt; 및 계획주기가 낭비됩니다.</target>
        </trans-unit>
        <trans-unit id="26d8635c1af4731c90f7caf11c20fceefa695a0b" translate="yes" xml:space="preserve">
          <source>It's also permissible to attach &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; to integer columns to reference character set encodings, which are not currently represented as catalog OIDs, but have a set of values known to &lt;code&gt;genbki.pl&lt;/code&gt;.</source>
          <target state="translated">현재 카탈로그 OID로 표시되지 않지만 &lt;code&gt;genbki.pl&lt;/code&gt; 으로 알려진 값 세트를 갖는 문자 세트 인코딩을 참조하기 위해 &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; 을 정수 열에 첨부 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="42cd973aeb3dbef0c62ad2e81081d6f4bf4973db" translate="yes" xml:space="preserve">
          <source>It's also possible to select no escape character by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;. This effectively disables the escape mechanism, which makes it impossible to turn off the special meaning of underscore and percent signs in the pattern.</source>
          <target state="translated">&lt;code&gt;ESCAPE ''&lt;/code&gt; 을 작성하여 이스케이프 문자를 선택하지 않을 수도 있습니다 . 이스케이프 메커니즘을 효과적으로 비활성화하여 패턴에서 밑줄 및 퍼센트 기호의 특수 의미를 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8646be546a98ef8ea063cb9eec163a8d4548ff24" translate="yes" xml:space="preserve">
          <source>It's essential that the data types and other properties of the columns declared in &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; match the actual remote table. Column names must match as well, unless you attach &lt;code&gt;column_name&lt;/code&gt; options to the individual columns to show how they are named in the remote table. In many cases, use of &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt; is preferable to constructing foreign table definitions manually.</source>
          <target state="translated">&lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; 에 선언 된 열의 데이터 유형 및 기타 속성은 실제 원격 테이블과 일치해야합니다. &lt;code&gt;column_name&lt;/code&gt; 옵션을 개별 열에 첨부 하여 원격 테이블에서 이름이 지정된 방법을 표시 하지 않는 한 열 이름도 일치해야 합니다. 많은 경우, 외부 테이블 정의를 수동으로 구성 하는 데 &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA를 사용하는&lt;/a&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a75f17e623d692c2b958fa72bc491d5871febb40" translate="yes" xml:space="preserve">
          <source>It's important to understand that the cost of an upper-level node includes the cost of all its child nodes. It's also important to realize that the cost only reflects things that the planner cares about. In particular, the cost does not consider the time spent transmitting result rows to the client, which could be an important factor in the real elapsed time; but the planner ignores it because it cannot change it by altering the plan. (Every correct plan will output the same row set, we trust.)</source>
          <target state="translated">상위 수준 노드 비용에는 모든 하위 노드 비용이 포함된다는 점을 이해해야합니다. 비용은 계획자가 관심을 갖는 것만 반영한다는 것을 인식하는 것이 중요합니다. 특히, 비용은 결과 행을 클라이언트에 전송하는 데 소요 된 시간을 고려하지 않으며, 이는 실제 경과 시간에서 중요한 요소가 될 수 있습니다. 그러나 계획자는 계획을 변경하여 변경할 수 없으므로 계획을 무시합니다. (올바른 계획은 동일한 행 집합을 출력 할 것입니다.)</target>
        </trans-unit>
        <trans-unit id="7c3ed76ba22932f8e0061fba8fda8ba6c6509eab" translate="yes" xml:space="preserve">
          <source>It's possible to control the statements in a transaction in a more granular fashion through the use of &lt;em&gt;savepoints&lt;/em&gt;. Savepoints allow you to selectively discard parts of the transaction, while committing the rest. After defining a savepoint with &lt;code&gt;SAVEPOINT&lt;/code&gt;, you can if needed roll back to the savepoint with &lt;code&gt;ROLLBACK TO&lt;/code&gt;. All the transaction's database changes between defining the savepoint and rolling back to it are discarded, but changes earlier than the savepoint are kept.</source>
          <target state="translated">&lt;em&gt;savepoints를&lt;/em&gt; 사용하여 트랜잭션의 명령문을보다 세분화 된 방식으로 제어 할 수 있습니다 . 저장 점을 사용하면 나머지 부분을 커미트하면서 트랜잭션의 일부를 선택적으로 버릴 수 있습니다. &lt;code&gt;SAVEPOINT&lt;/code&gt; 를 사용 하여 저장 점을 정의한 후 필요한 경우 &lt;code&gt;ROLLBACK TO&lt;/code&gt; 를 사용하여 저장 점으로 롤백 할 수 있습니다 . 저장 점 정의와 롤백 사이의 모든 트랜잭션 데이터베이스 변경 사항은 버려지지만 저장 점 이전의 변경 사항은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="af6b5757cbe3f9b4c6401b87c759f120734c17d1" translate="yes" xml:space="preserve">
          <source>It's recommended to run &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; before submitting catalog data patches. For convenience, you can simply change to &lt;code&gt;src/include/catalog/&lt;/code&gt; and run &lt;code&gt;make reformat-dat-files&lt;/code&gt;.</source>
          <target state="translated">카탈로그 데이터 패치를 제출하기 전에 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 을 실행하는 것이 좋습니다 . 편의상 간단히 &lt;code&gt;src/include/catalog/&lt;/code&gt; 하고 &lt;code&gt;make reformat-dat-files&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f13f984e4f7daa459e845c3a4715f4638313970" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches.</source>
          <target state="translated">키가 아닌 열을 인덱스, 특히 넓은 열에 추가하는 것은 보수적 인 것이 좋습니다. 인덱스 튜플이 인덱스 유형에 허용 된 최대 크기를 초과하면 데이터 삽입이 실패합니다. 어쨌든 키가 아닌 열은 인덱스 테이블의 데이터를 복제하고 인덱스 크기를 부풀려서 검색 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c646abb35ed677e4428cd5146fe3efa3d6f1d7" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. Furthermore, B-tree deduplication is never used with indexes that have a non-key column.</source>
          <target state="translated">It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. Furthermore, B-tree deduplication is never used with indexes that have a non-key column.</target>
        </trans-unit>
        <trans-unit id="08237634e67b792c41b6dc72d01cf498506db594" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key payload columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. And remember that there is little point in including payload columns in an index unless the table changes slowly enough that an index-only scan is likely to not need to access the heap. If the heap tuple must be visited anyway, it costs nothing more to get the column's value from there. Other restrictions are that expressions are not currently supported as included columns, and that only B-tree and GiST indexes currently support included columns.</source>
          <target state="translated">키가 아닌 페이로드 열을 인덱스, 특히 넓은 열에 추가하는 것은 보수적 인 것이 좋습니다. 인덱스 튜플이 인덱스 유형에 허용 된 최대 크기를 초과하면 데이터 삽입이 실패합니다. 어쨌든 키가 아닌 열은 인덱스 테이블의 데이터를 복제하고 인덱스 크기를 부풀려서 검색 속도가 느려질 수 있습니다. 또한 인덱스 전용 스캔이 힙에 액세스 할 필요가 없을 정도로 테이블이 느리게 변경되지 않는 한 인덱스에 페이로드 열을 포함시킬 점이 거의 없음을 기억하십시오. 어쨌든 힙 튜플을 방문 해야하는 경우 거기에서 열 값을 얻는 데 더 이상 비용이 들지 않습니다. 다른 제한 사항은 표현식이 현재 포함 된 열로 지원되지 않으며 B- 트리 및 GiST 인덱스 만 현재 포함 된 열을 지원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9682da0882fceeebec9d99753c1dc0306b85beab" translate="yes" xml:space="preserve">
          <source>It's worth noticing that the AND/OR/NOT operators mean something subtly different when they are within the arguments of a FOLLOWED BY operator than when they are not, because within FOLLOWED BY the exact position of the match is significant. For example, normally &lt;code&gt;!x&lt;/code&gt; matches only documents that do not contain &lt;code&gt;x&lt;/code&gt; anywhere. But &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; matches &lt;code&gt;y&lt;/code&gt; if it is not immediately after an &lt;code&gt;x&lt;/code&gt;; an occurrence of &lt;code&gt;x&lt;/code&gt; elsewhere in the document does not prevent a match. Another example is that &lt;code&gt;x &amp;amp; y&lt;/code&gt; normally only requires that &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; both appear somewhere in the document, but &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; requires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to match at the same place, immediately before a &lt;code&gt;z&lt;/code&gt;. Thus this query behaves differently from &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt;, which will match a document containing two separate sequences &lt;code&gt;x z&lt;/code&gt; and &lt;code&gt;y z&lt;/code&gt;. (This specific query is useless as written, since &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; could not match at the same place; but with more complex situations such as prefix-match patterns, a query of this form could be useful.)</source>
          <target state="translated">AND / OR / NOT 연산자는 FOLLOWED BY 내의 정확한 위치가 중요하기 때문에 FOLLOWED BY 연산자의 인수 내에있을 때와 그렇지 않은 경우에 미묘하게 다른 것을 의미한다는 점에 주목할 가치가 있습니다. 예를 들어, 일반적으로 &lt;code&gt;!x&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 포함하지 않은 문서에만 일치합니다 . 그러나 &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; 일치 &lt;code&gt;y&lt;/code&gt; 로 그것이 직후가 아닌 경우 &lt;code&gt;x&lt;/code&gt; ; 문서의 다른 곳에서 &lt;code&gt;x&lt;/code&gt; 가 발생 해도 일치하지 않습니다. 또 다른 예는 &lt;code&gt;x &amp;amp; y&lt;/code&gt; 는 일반적으로 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 문서의 어딘가에 나타나 도록 요구 하지만 &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 바로 직전 같은 위치에서 x 와 &lt;code&gt;y&lt;/code&gt; 를 찾습니다 . 따라서이 쿼리는 &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt; 와 다르게 동작합니다 . 이는 두 개의 개별 시퀀스 &lt;code&gt;x z&lt;/code&gt; 및 &lt;code&gt;y z&lt;/code&gt; 포함하는 문서와 일치합니다 . (이 특정 쿼리는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 같은 위치에서 일치 할 수 없기 때문에 쓸모가 없지만 접두사 일치 패턴과 같은보다 복잡한 상황에서는이 형식의 쿼리가 유용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ecdda59aea5ee67d7d854c969ccf7f4f4b4a4c54" translate="yes" xml:space="preserve">
          <source>Item</source>
          <target state="translated">Item</target>
        </trans-unit>
        <trans-unit id="036b57986556b399e1579aa78767ca4cf343c8b5" translate="yes" xml:space="preserve">
          <source>ItemIdData</source>
          <target state="translated">ItemIdData</target>
        </trans-unit>
        <trans-unit id="a2965a078eaef7ee13c972baa85b167370cde26a" translate="yes" xml:space="preserve">
          <source>ItemPointerData</source>
          <target state="translated">ItemPointerData</target>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="40f7cf3bbd8b78d82db16eda601698d7597b9ba5" translate="yes" xml:space="preserve">
          <source>J.5. Style Guide</source>
          <target state="translated">J.5. 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="7685fa01b8b7b34ce179631444878fcbce78fa81" translate="yes" xml:space="preserve">
          <source>J2451187</source>
          <target state="translated">J2451187</target>
        </trans-unit>
        <trans-unit id="1f1062dcbb83b59e4f6f5cb50ef505afac199e0d" translate="yes" xml:space="preserve">
          <source>JDBC</source>
          <target state="translated">JDBC</target>
        </trans-unit>
        <trans-unit id="eb5d2f4a58038c71155ddcf3cea35dc3c6d34501" translate="yes" xml:space="preserve">
          <source>JIT</source>
          <target state="translated">JIT</target>
        </trans-unit>
        <trans-unit id="6a623f63efe8bb915b0cd81dd3786e0511e1c1a1" translate="yes" xml:space="preserve">
          <source>JIT compilation is beneficial primarily for long-running CPU-bound queries. Frequently these will be analytical queries. For short queries the added overhead of performing JIT compilation will often be higher than the time it can save.</source>
          <target state="translated">JIT 컴파일은 주로 장기 실행 CPU 바인딩 쿼리에 유용합니다. 종종 이들은 분석적인 쿼리가 될 것입니다. 짧은 쿼리의 경우 JIT 컴파일 수행의 추가 오버 헤드가 종종 절약 할 수있는 시간보다 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="6f7646a5ebe2aff38f294e6e525f0ea1b56f8538" translate="yes" xml:space="preserve">
          <source>JOHAB</source>
          <target state="translated">JOHAB</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c731d9e245778a9537fc026bc57fb4f455f28593" translate="yes" xml:space="preserve">
          <source>JSON Functions and Operators</source>
          <target state="translated">JSON 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="95cc452498b3190abb79d4cdad349208be23c944" translate="yes" xml:space="preserve">
          <source>JSON Types</source>
          <target state="translated">JSON 유형</target>
        </trans-unit>
        <trans-unit id="f9bea7492dcebb5f109566d49e4bca935a7e0ff7" translate="yes" xml:space="preserve">
          <source>JSON Types: boolean</source>
          <target state="translated">JSON 유형 : 부울</target>
        </trans-unit>
        <trans-unit id="22aff2decb9f95af65f4e2a85c938a9901c03229" translate="yes" xml:space="preserve">
          <source>JSON Types: null</source>
          <target state="translated">JSON 유형 : null</target>
        </trans-unit>
        <trans-unit id="b89570edbe3781b5bd3ad2ae7d37f0bf110fdf05" translate="yes" xml:space="preserve">
          <source>JSON Types: number</source>
          <target state="translated">JSON 유형 : 숫자</target>
        </trans-unit>
        <trans-unit id="205b72d84addc780073dacc96aedf0a7c5c2d3cc" translate="yes" xml:space="preserve">
          <source>JSON Types: string</source>
          <target state="translated">JSON 유형 : 문자열</target>
        </trans-unit>
        <trans-unit id="6fb42476959dba43e5b647429008c3399be7120f" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">JSON constant &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="826d7973fb0fe99520474814c729759899e1f084" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;null&lt;/code&gt; (note that, unlike in SQL, comparison to &lt;code&gt;null&lt;/code&gt; works normally)</source>
          <target state="translated">JSON constant &lt;code&gt;null&lt;/code&gt; (note that, unlike in SQL, comparison to &lt;code&gt;null&lt;/code&gt; works normally)</target>
        </trans-unit>
        <trans-unit id="7b5978544d202bc2b880af72e00c6ff1ea552f31" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">JSON constant &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49c22c401963d3661a06e8b5108d657673586e05" translate="yes" xml:space="preserve">
          <source>JSON data is subject to the same concurrency-control considerations as any other data type when stored in a table. Although storing large documents is practicable, keep in mind that any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a manageable size in order to decrease lock contention among updating transactions. Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently.</source>
          <target state="translated">JSON 데이터는 테이블에 저장 될 때 다른 데이터 유형과 동일한 동시성 제어 고려 사항이 적용됩니다. 큰 문서를 저장하는 것이 가능하지만 모든 업데이트는 전체 행에서 행 수준 잠금을 얻습니다. 업데이트 트랜잭션 간의 잠금 경합을 줄이려면 JSON 문서를 관리 가능한 크기로 제한하는 것이 좋습니다. 이상적으로 JSON 문서는 각각 비즈니스 규칙이 지시하는 원자 데이텀을 나타내야하며 독립적으로 수정할 수있는 더 작은 데이텀으로 더 이상 세분화 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="062e2dcdb89d67da750325f5a32e496783b448b0" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">JSON 데이터 유형은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159에&lt;/a&gt; 지정된 JSON (JavaScript Object Notation) 데이터를 저장하기위한 것 입니다. 이러한 데이터는 &lt;code&gt;text&lt;/code&gt; 로 저장할 수도 있지만 JSON 데이터 유형은 JSON 규칙에 따라 저장된 각 값이 유효하도록하는 이점이 있습니다. 이러한 데이터 유형에 저장된 데이터에 사용할 수있는 여러 JSON 특정 함수 및 연산자도 있습니다. &lt;a href=&quot;functions-json&quot;&gt;섹션 9.15&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="3439d51ccc84271989a1fe8ee4c05702a949e43b" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt; , but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1b285244e0c7fb77cf325258e945007dbcb0bd79" translate="yes" xml:space="preserve">
          <source>JSON objects are better suited than arrays for testing containment or existence when there are many keys or elements involved, because unlike arrays they are internally optimized for searching, and do not need to be searched linearly.</source>
          <target state="translated">JSON 객체는 배열과 달리 검색에 내부적으로 최적화되어 있으며 선형으로 검색 할 필요가 없기 때문에 많은 키 또는 요소가 포함 된 경우 포함 또는 존재를 테스트하기 위해 배열보다 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="ff7a8b7bee4833026249925bb4a7e075a31995d4" translate="yes" xml:space="preserve">
          <source>JSON primitive type</source>
          <target state="translated">JSON 기본 유형</target>
        </trans-unit>
        <trans-unit id="21d0c78d1738d7a3274678ad613fc7038b9e1cd3" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding JSON item, or set of items, is returned. Path expressions are written in the SQL/JSON path language and can include arithmetic expressions and functions.</source>
          <target state="translated">JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding JSON item, or set of items, is returned. Path expressions are written in the SQL/JSON path language and can include arithmetic expressions and functions.</target>
        </trans-unit>
        <trans-unit id="196dea5dbe3d820f7bdbd4775445b07993543c68" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding SQL/JSON item is returned. Path expressions are written in the SQL/JSON path language and can also include arithmetic expressions and functions. Query functions treat the provided expression as a text string, so it must be enclosed in single quotes.</source>
          <target state="translated">JSON 쿼리 함수 및 연산자는 제공된 경로 표현식을 평가 를 위해 &lt;em&gt;경로 엔진&lt;/em&gt; 에 전달합니다 . 식이 쿼리 된 JSON 데이터와 일치하면 해당 SQL / JSON 항목이 반환됩니다. 경로 표현식은 SQL / JSON 경로 언어로 작성되며 산술 표현식 및 함수도 포함 할 수 있습니다. 쿼리 함수는 제공된 표현식을 텍스트 문자열로 취급하므로 작은 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="7af619b9c5342e6a889b85ca2cae08237b23f616" translate="yes" xml:space="preserve">
          <source>JSON: SQL/JSON Path Language</source>
          <target state="translated">JSON : SQL / JSON 경로 언어</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="ebeb4b5ab2f3409935c06be07e3191bf0a5dc6cf" translate="yes" xml:space="preserve">
          <source>Jan-08-1999</source>
          <target state="translated">Jan-08-1999</target>
        </trans-unit>
        <trans-unit id="521a936bf91733c55274b55367cc8ed71292693f" translate="yes" xml:space="preserve">
          <source>Jan-08-99</source>
          <target state="translated">Jan-08-99</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="d6e52d181e7ba4487fe8643d957277cd1cbf82c7" translate="yes" xml:space="preserve">
          <source>January 18 in &lt;code&gt;MDY&lt;/code&gt; mode; rejected in other modes</source>
          <target state="translated">&lt;code&gt;MDY&lt;/code&gt; 모드 에서 1 월 18 일 ; 다른 모드에서 거부</target>
        </trans-unit>
        <trans-unit id="d1fb4cc8c23271615e96e586a4e1801c1ac84f25" translate="yes" xml:space="preserve">
          <source>January 2, 2003 in &lt;code&gt;MDY&lt;/code&gt; mode; February 1, 2003 in &lt;code&gt;DMY&lt;/code&gt; mode; February 3, 2001 in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;MDY&lt;/code&gt; 모드 에서 2003 년 1 월 2 일 ; &lt;code&gt;DMY&lt;/code&gt; 모드 에서 2003 년 2 월 1 일 ; &lt;code&gt;YMD&lt;/code&gt; 모드 에서 2001 년 2 월 3 일</target>
        </trans-unit>
        <trans-unit id="397474e233d9068687b354fbdbc0b01176bcc2cc" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;MDY&lt;/code&gt; mode; August 1 in &lt;code&gt;DMY&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;MDY&lt;/code&gt; 모드 에서 1 월 8 일 ; &lt;code&gt;DMY&lt;/code&gt; 모드 에서 8 월 1 일</target>
        </trans-unit>
        <trans-unit id="2391ee88b9183f9c31234260c9722e2d62c959b0" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;YMD&lt;/code&gt; mode, else error</source>
          <target state="translated">&lt;code&gt;YMD&lt;/code&gt; 모드 에서 1 월 8 일 , 그렇지 않으면 오류</target>
        </trans-unit>
        <trans-unit id="347ee622c39fd3015013d75c9106e7b8164231b7" translate="yes" xml:space="preserve">
          <source>January 8 in any mode</source>
          <target state="translated">모든 모드에서 1 월 8 일</target>
        </trans-unit>
        <trans-unit id="682c812bf69e66e4c213bdbcc9a0930f43e82030" translate="yes" xml:space="preserve">
          <source>January 8, 1999</source>
          <target state="translated">1999 년 1 월 8 일</target>
        </trans-unit>
        <trans-unit id="4444d015dc1b7e202a7ab992a769c820f60f9019" translate="yes" xml:space="preserve">
          <source>January 8, 99 BC</source>
          <target state="translated">기원전 99 년 1 월 8 일</target>
        </trans-unit>
        <trans-unit id="07425bcd86481aaf19f3e5b4016da2c9f5e1cec4" translate="yes" xml:space="preserve">
          <source>January 8, except error in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">1 월 8 일 ( &lt;code&gt;YMD&lt;/code&gt; 모드 오류 제외)</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="21087b70eba36ef97c23b6fae1bc0502a8c7faff" translate="yes" xml:space="preserve">
          <source>Java Database Connectivity</source>
          <target state="translated">자바 데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="94e850a9fa9f98700106bfba6b5849640ea65567" translate="yes" xml:space="preserve">
          <source>JavaScript Object Notation</source>
          <target state="translated">자바 스크립트 객체 표기법</target>
        </trans-unit>
        <trans-unit id="66dc64282e7e424443c0ee036f6560a8429101fe" translate="yes" xml:space="preserve">
          <source>Jean-Luc Cooke Fortuna-based &lt;code&gt;/dev/random&lt;/code&gt; driver for Linux.</source>
          <target state="translated">Jean-Luc Cooke Linux 용 Fortuna 기반 &lt;code&gt;/dev/random&lt;/code&gt; 드라이버.</target>
        </trans-unit>
        <trans-unit id="076e3b3dd165a68d5a1635c764f91d575d41e991" translate="yes" xml:space="preserve">
          <source>Joe Conway</source>
          <target state="translated">조 콘웨이</target>
        </trans-unit>
        <trans-unit id="36223c3c072f8f4857df7670837893beb8c9ab05" translate="yes" xml:space="preserve">
          <source>John Gray &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">존 그레이 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="5253095e71e396147a5bb85865b313a4dfaabec4" translate="yes" xml:space="preserve">
          <source>Join queries of the kind seen thus far can also be written in this alternative form:</source>
          <target state="translated">지금까지 본 종류의 조인 쿼리도 다음과 같은 대체 형식으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d51427844afa7a67c043cae62a1e058c08bf8eb" translate="yes" xml:space="preserve">
          <source>Join selectivity estimation function for this operator</source>
          <target state="translated">이 연산자에 대한 결합 선택성 추정 기능</target>
        </trans-unit>
        <trans-unit id="60bbcdff104b8ef5971151f077f9a3a69bf41608" translate="yes" xml:space="preserve">
          <source>Joins of all types can be chained together, or nested: either or both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; can be joined tables. Parentheses can be used around &lt;code&gt;JOIN&lt;/code&gt; clauses to control the join order. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt; clauses nest left-to-right.</source>
          <target state="translated">모든 유형의 조인은 함께 체인 또는 중첩 될 수 있습니다. &lt;code&gt;T1&lt;/code&gt; 과 &lt;code&gt;T2&lt;/code&gt; 중 하나 또는 둘 다가 조인 테이블 일 수 있습니다. &lt;code&gt;JOIN&lt;/code&gt; 절을 괄호로 묶어 조인 순서를 제어 할 수 있습니다 . 괄호가 없으면 &lt;code&gt;JOIN&lt;/code&gt; 절은 왼쪽에서 오른쪽으로 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="b737558468d75ca55b2d9185c0b55eacaea627a0" translate="yes" xml:space="preserve">
          <source>Jul</source>
          <target state="translated">Jul</target>
        </trans-unit>
        <trans-unit id="a78c0406ce3eb63581cbacb7e7085ef4cbc36ad9" translate="yes" xml:space="preserve">
          <source>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</source>
          <target state="translated">율리우스 데이 (BC UTC 4714 년 11 월 24 일 이후의 정수일 UTC 자정)</target>
        </trans-unit>
        <trans-unit id="b597ea9fa797a2c2073652808359aeb10b763510" translate="yes" xml:space="preserve">
          <source>Julian date</source>
          <target state="translated">줄리안 데이트</target>
        </trans-unit>
        <trans-unit id="df97a42549e5c0e1753b985126565531cc9f3c56" translate="yes" xml:space="preserve">
          <source>July</source>
          <target state="translated">July</target>
        </trans-unit>
        <trans-unit id="6d90df3be4d0d43b08e3fb47f55e09b5b06dae3e" translate="yes" xml:space="preserve">
          <source>Jun</source>
          <target state="translated">Jun</target>
        </trans-unit>
        <trans-unit id="a9db906761699b31567727716eaa6fd19ae5f5d5" translate="yes" xml:space="preserve">
          <source>June</source>
          <target state="translated">June</target>
        </trans-unit>
        <trans-unit id="7b1ddc607d5041d94adba7779845219a639a5e00" translate="yes" xml:space="preserve">
          <source>Just as in a non-parallel plan, the driving table may be joined to one or more other tables using a nested loop, hash join, or merge join. The inner side of the join may be any kind of non-parallel plan that is otherwise supported by the planner provided that it is safe to run within a parallel worker. Depending on the join type, the inner side may also be a parallel plan.</source>
          <target state="translated">비 병렬 계획에서와 같이, 구동 테이블은 중첩 루프, 해시 조인 또는 병합 조인을 사용하여 하나 이상의 다른 테이블에 조인 될 수 있습니다. 조인의 내부는 병렬 작업자 내에서 실행하는 것이 안전하다면 플래너가 지원하는 모든 종류의 비평 행 계획 일 수 있습니다. 결합 유형에 따라 내부도 평행 평면 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce656c6d5efc6ceb90feb56120166673a499a99" translate="yes" xml:space="preserve">
          <source>Just as in a table, every output column of a &lt;code&gt;SELECT&lt;/code&gt; has a name. In a simple &lt;code&gt;SELECT&lt;/code&gt; this name is just used to label the column for display, but when the &lt;code&gt;SELECT&lt;/code&gt; is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write &lt;code&gt;AS&lt;/code&gt;&lt;code&gt;output_name&lt;/code&gt; after the column's expression. (You can omit &lt;code&gt;AS&lt;/code&gt;, but only if the desired output name does not match any PostgreSQL keyword (see &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;). For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as &lt;code&gt;?column?&lt;/code&gt;.</source>
          <target state="translated">테이블에서와 같이 &lt;code&gt;SELECT&lt;/code&gt; 의 모든 출력 열에 는 이름이 있습니다. 간단한 &lt;code&gt;SELECT&lt;/code&gt; 에서이 이름은 표시 할 열에 레이블을 지정하는 데 사용되지만 &lt;code&gt;SELECT&lt;/code&gt; 가 더 큰 쿼리의 하위 쿼리 인 경우 큰 쿼리 에서이 이름이 하위 테이블에서 생성 된 가상 테이블의 열 이름으로 표시됩니다. -질문. 출력 열에 사용할 이름을 지정하려면 열 표현식 뒤에 &lt;code&gt;AS&lt;/code&gt; &lt;code&gt;output_name&lt;/code&gt; 을 작성하십시오. 원하는 출력 이름이 PostgreSQL 키워드와 일치하지 않는 경우에만 &lt;code&gt;AS&lt;/code&gt; 를 생략 할 수 있습니다 ( &lt;a href=&quot;sql-keywords-appendix&quot;&gt;부록 C&lt;/a&gt; 참조 ). 향후 키워드 추가를 방지하기 위해 항상 &lt;code&gt;AS&lt;/code&gt; 를 작성하는 것이 좋습니다.또는 출력 이름을 큰 따옴표로 묶습니다.) 열 이름을 지정하지 않으면 PostgreSQL에서 이름을 자동으로 선택합니다. 열의 표현식이 단순 열 참조 인 경우 선택한 이름은 해당 열의 이름과 동일합니다. 보다 복잡한 경우에는 함수 또는 유형 이름이 사용되거나 시스템이 &lt;code&gt;?column?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643851cd97b3016db737a7445d565c8fa4d8baef" translate="yes" xml:space="preserve">
          <source>Just as with indexes, a foreign key constraint can be checked &amp;ldquo;in bulk&amp;rdquo; more efficiently than row-by-row. So it might be useful to drop foreign key constraints, load data, and re-create the constraints. Again, there is a trade-off between data load speed and loss of error checking while the constraint is missing.</source>
          <target state="translated">인덱스와 마찬가지로 외래 키 제약 조건을 행 단위보다&amp;ldquo;대량&amp;rdquo;으로보다 효율적으로 확인할 수 있습니다. 따라서 외래 키 제약 조건을 삭제하고 데이터를로드하며 제약 조건을 다시 만드는 것이 유용 할 수 있습니다. 다시 말하지만, 제약 조건이없는 동안 데이터로드 속도와 오류 검사 손실 사이에는 상충 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="22069315e577148c2b004f5dd6381d3b0deef8a4" translate="yes" xml:space="preserve">
          <source>Just-in-Time (JIT) compilation is the process of turning some form of interpreted program evaluation into a native program, and doing so at run time. For example, instead of using general-purpose code that can evaluate arbitrary SQL expressions to evaluate a particular SQL predicate like &lt;code&gt;WHERE a.col = 3&lt;/code&gt;, it is possible to generate a function that is specific to that expression and can be natively executed by the CPU, yielding a speedup.</source>
          <target state="translated">JIT (Just-In-Time) 컴파일은 일부 형태의 해석 된 프로그램 평가를 기본 프로그램으로 변환하고 런타임에 수행하는 프로세스입니다. 예를 들어, 임의의 SQL 표현식을 평가하여 &lt;code&gt;WHERE a.col = 3&lt;/code&gt; 과 같은 특정 SQL 술어를 평가할 수있는 범용 코드를 사용하는 대신 해당 표현식에 고유 한 함수를 생성 할 수 있습니다. CPU 속도가 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="7af7e7edb636e51ba6b7f08c539611e4a0057634" translate="yes" xml:space="preserve">
          <source>Just-in-Time Compilation (JIT)</source>
          <target state="translated">JIT (Just-In-Time) 컴파일</target>
        </trans-unit>
        <trans-unit id="299af5e109b0aae56134447e7dc2dcce5de37f34" translate="yes" xml:space="preserve">
          <source>Just-in-Time compilation</source>
          <target state="translated">적시 컴파일</target>
        </trans-unit>
        <trans-unit id="ffa7300d92e16f73d505ed4698fdd4e962ca51c4" translate="yes" xml:space="preserve">
          <source>KAME kame/sys/crypto</source>
          <target state="translated">KAME kame / sys / crypto</target>
        </trans-unit>
        <trans-unit id="6b88dae842421fa69ad059376e38f360417c6965" translate="yes" xml:space="preserve">
          <source>KOI8-R</source>
          <target state="translated">KOI8-R</target>
        </trans-unit>
        <trans-unit id="ad190609bef1a0712934b8949ffb7c06fbaa6862" translate="yes" xml:space="preserve">
          <source>KOI8-U</source>
          <target state="translated">KOI8-U</target>
        </trans-unit>
        <trans-unit id="8f29952f92109ac24c1d37762ea2beef09083c31" translate="yes" xml:space="preserve">
          <source>KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cd084d348b2278c1d6044754c142d3183367365" translate="yes" xml:space="preserve">
          <source>Keep in mind that all aggregate functions are evaluated before evaluating any &amp;ldquo;scalar&amp;rdquo; expressions in the &lt;code&gt;HAVING&lt;/code&gt; clause or &lt;code&gt;SELECT&lt;/code&gt; list. This means that, for example, a &lt;code&gt;CASE&lt;/code&gt; expression cannot be used to skip evaluation of an aggregate function; see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HAVING&lt;/code&gt; 절 또는 &lt;code&gt;SELECT&lt;/code&gt; 목록 에서&amp;ldquo;스칼라&amp;rdquo;표현식을 평가하기 전에 모든 집계 함수가 평가 됩니다. 예를 들어, &lt;code&gt;CASE&lt;/code&gt; 표현식을 사용하여 집계 함수의 평가를 건너 뛸 수 없습니다. &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;4.2.14 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a262b9c7138e1926e93240d562f76b55145fd596" translate="yes" xml:space="preserve">
          <source>Keep in mind that because &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; actually runs the query, any side-effects will happen as usual, even though whatever results the query might output are discarded in favor of printing the &lt;code&gt;EXPLAIN&lt;/code&gt; data. If you want to analyze a data-modifying query without changing your tables, you can roll the command back afterwards, for example:</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 가 실제로 쿼리를 실행 하기 때문에 &lt;code&gt;EXPLAIN&lt;/code&gt; 데이터 를 인쇄하기 위해 쿼리가 출력 할 수있는 결과가 무시 되더라도 부작용은 평소와 같이 발생 합니다. 테이블을 변경하지 않고 데이터 수정 쿼리를 분석하려는 경우 다음과 같이 명령을 나중에 롤백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b96c146884aa3a6a00a301b320c6680d6f4464" translate="yes" xml:space="preserve">
          <source>Keep in mind that by default, a regular expression can match just part of a string. It's usually wise to use &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;, as shown in the above example, to force the match to be to the entire system user name.</source>
          <target state="translated">기본적으로 정규식은 문자열의 일부와 만 일치 할 수 있습니다. 위의 예와 같이 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 를 사용 하여 일치를 전체 시스템 사용자 이름으로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c42b9dd519f94f2582e4a71f3f708e12c5a9653d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is important to specify the configuration name explicitly when creating &lt;code&gt;tsvector&lt;/code&gt; values inside triggers, so that the column's contents will not be affected by changes to &lt;code&gt;default_text_search_config&lt;/code&gt;. Failure to do this is likely to lead to problems such as search results changing after a dump and reload.</source>
          <target state="translated">트리거 내에 &lt;code&gt;tsvector&lt;/code&gt; 값을 작성할 때 구성 이름을 명시 적으로 지정하는 것이 중요 하므로 컬럼의 내용이 &lt;code&gt;default_text_search_config&lt;/code&gt; 에 대한 변경의 영향을받지 않습니다 . 이를 수행하지 않으면 덤프 및 재로드 후 검색 결과가 변경되는 등의 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3ea22672b214f2b49222df5e8cffc5ea2a095eb" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal.</source>
          <target state="translated">부분 인덱스를 설정하면 최소한 쿼리 플래너가 알고있는만큼, 특히 인덱스의 수익성이 높은시기를 알고 있음을 나타냅니다. 이 지식을 형성하려면 PostgreSQL의 인덱스 작동 방식에 대한 경험과 이해가 필요합니다. 대부분의 경우 일반 인덱스에 비해 부분 인덱스의 이점이 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="3bf0ca5e99386c2632aea1fa222371e26d7ffb9e" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal. There are cases where they are quite counterproductive, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX4&quot;&gt;Example 11.4&lt;/a&gt;.</source>
          <target state="translated">Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal. There are cases where they are quite counterproductive, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX4&quot;&gt;Example 11.4&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ef88fc4a4ab28c6433ccdb43fa109f84e6bdf441" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;hstore&lt;/code&gt; text format, when used for input, applies &lt;em&gt;before&lt;/em&gt; any required quoting or escaping. If you are passing an &lt;code&gt;hstore&lt;/code&gt; literal via a parameter, then no additional processing is needed. But if you're passing it as a quoted literal constant, then any single-quote characters and (depending on the setting of the &lt;code&gt;standard_conforming_strings&lt;/code&gt; configuration parameter) backslash characters need to be escaped correctly. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more on the handling of string constants.</source>
          <target state="translated">것을 명심 &lt;code&gt;hstore&lt;/code&gt; 의 입력에 사용되는 텍스트 형식이 적용 &lt;em&gt;되기 전에&lt;/em&gt; 어떠한 인용이나 탈출이 필요합니다. 매개 변수를 통해 &lt;code&gt;hstore&lt;/code&gt; 리터럴을 전달하는 경우 추가 처리가 필요하지 않습니다. 그러나 인용 된 리터럴 상수로 전달하는 경우 작은 따옴표 문자와 ( &lt;code&gt;standard_conforming_strings&lt;/code&gt; 구성 매개 변수 의 설정에 따라 ) 백 슬래시 문자를 올바르게 이스케이프해야합니다. 문자열 상수 처리에 대한 자세한 내용 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;은 4.1.2.1 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f96958d65d9c021639ce27dbbdb3f614f469552" translate="yes" xml:space="preserve">
          <source>Keep in mind that the delay parameters are compared to the elapsed time since the WAL data was received by the standby server. Thus, the grace period allowed to any one query on the standby is never more than the delay parameter, and could be considerably less if the standby has already fallen behind as a result of waiting for previous queries to complete, or as a result of being unable to keep up with a heavy update load.</source>
          <target state="translated">지연 매개 변수는 대기 서버가 WAL 데이터를 수신 한 이후의 경과 시간과 비교됩니다. 따라서 대기에서 하나의 쿼리에 허용되는 유예 기간은 지연 매개 변수를 넘지 않으며 이전 쿼리가 완료되기를 기다리는 결과 또는 대기 상태로 인해 대기가 이미 뒤쳐 졌을 경우 상당히 줄어들 수 있습니다. 과도한 업데이트로드를 유지할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="281e2d1f4654cd490bed6ab58e757285785a6b63" translate="yes" xml:space="preserve">
          <source>Keep in mind that the pattern argument of &lt;code&gt;like_regex&lt;/code&gt; is a JSON path string literal, written according to the rules given in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;. This means in particular that any backslashes you want to use in the regular expression must be doubled. For example, to match strings that contain only digits:</source>
          <target state="translated">&lt;code&gt;like_regex&lt;/code&gt; 의 패턴 인수는 8.14.6 &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;절에&lt;/a&gt; 주어진 규칙에 따라 작성된 JSON 경로 문자열 리터럴 이라는 것을 명심하십시오 . 이는 특히 정규식에 사용하려는 백 슬래시를 두 배로 늘려야 함을 의미합니다. 예를 들어 숫자 만 포함 된 문자열을 일치 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="752b636fa6947f13347177c43e220a338c0e1d06" translate="yes" xml:space="preserve">
          <source>Keep in mind that the statement is actually executed when the &lt;code&gt;ANALYZE&lt;/code&gt; option is used. Although &lt;code&gt;EXPLAIN&lt;/code&gt; will discard any output that a &lt;code&gt;SELECT&lt;/code&gt; would return, other side effects of the statement will happen as usual. If you wish to use &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;EXECUTE&lt;/code&gt; statement without letting the command affect your data, use this approach:</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 옵션을 사용 하면 명령문이 실제로 실행 됩니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 은 &lt;code&gt;SELECT&lt;/code&gt; 가 리턴 할 출력을 버리지 만 명령문의 다른 부작용은 평소와 같이 발생합니다. 당신이 사용하고자하는 경우 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 온 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 또는 &lt;code&gt;EXECUTE&lt;/code&gt; 이 방법을 사용하여 명령을 아무 말도없이 데이터를 문에 영향을</target>
        </trans-unit>
        <trans-unit id="1a83b7d50233b6c01f2847bb1d523d1444438ed5" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, any user can issue arbitrary queries under the identity of any user not electing to protect itself individually. This pattern is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">기본값을 유지하십시오. 모든 사용자는 공개 스키마에 암시 적으로 액세스합니다. 이는 스키마를 전혀 사용할 수없는 상황을 시뮬레이션하여 스키마를 인식하지 않는 환경에서 자연스럽게 전환합니다. 그러나 모든 사용자는 자신을 개별적으로 보호하지 않기로 선택한 사용자의 신분으로 임의 쿼리를 실행할 수 있습니다. 이 패턴은 데이터베이스에 단일 사용자 또는 상호 신뢰하는 사용자가있는 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b02debd129668317e39732d6dfb75d3b401f787" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, this is never a secure pattern. It is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, this is never a secure pattern. It is acceptable only when the database has a single user or a few mutually-trusting users.</target>
        </trans-unit>
        <trans-unit id="01c357ee3905e2cb6c0488939e3efd4649d18496" translate="yes" xml:space="preserve">
          <source>Keep the partitioning constraints simple, else the planner may not be able to prove that child tables might not need to be visited. Use simple equality conditions for list partitioning, or simple range tests for range partitioning, as illustrated in the preceding examples. A good rule of thumb is that partitioning constraints should contain only comparisons of the partitioning column(s) to constants using B-tree-indexable operators, because only B-tree-indexable column(s) are allowed in the partition key.</source>
          <target state="translated">파티셔닝 제한 조건을 단순하게 유지하십시오. 그렇지 않으면 플래너가 하위 테이블을 방문 할 필요가 없음을 입증하지 못할 수 있습니다. 앞의 예에서 설명한 것처럼 목록 파티셔닝에 간단한 동등 조건을 사용하거나 범위 파티셔닝에 간단한 범위 테스트를 사용하십시오. 일반적으로 파티션 키에는 B- 트리 인덱싱 가능 열만 허용되므로 파티셔닝 제약 조건에는 B- 트리 인덱싱 가능 연산자를 사용하여 파티션 열과 상수를 비교하는 것만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2032a298b60ea58db844215a572d895ea523039" translate="yes" xml:space="preserve">
          <source>Kernels can also have system-wide limits on some resources.</source>
          <target state="translated">커널은 일부 자원에 대한 시스템 전체 제한을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="59dfe7e6cfc40d95e215dd77804938b17f6c9f40" translate="yes" xml:space="preserve">
          <source>Key Word</source>
          <target state="translated">핵심어</target>
        </trans-unit>
        <trans-unit id="8e27223f630d5f11e0e66ca4d82327af33bd02f7" translate="yes" xml:space="preserve">
          <source>Key value of the row to start at</source>
          <target state="translated">시작할 행의 키 값</target>
        </trans-unit>
        <trans-unit id="fa701570481252ff476a0ecf4e2d51ece76ebca1" translate="yes" xml:space="preserve">
          <source>Key words and unquoted identifiers are case insensitive. Therefore:</source>
          <target state="translated">키워드 및 따옴표없는 식별자는 대소 문자를 구분하지 않습니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="dec66c5bf0f7fe4cc038ac871def8eb1ac31c146" translate="yes" xml:space="preserve">
          <source>Korean</source>
          <target state="translated">Korean</target>
        </trans-unit>
        <trans-unit id="2ceaa9727ea6aa546bde8ab43842a8c79efd8f8d" translate="yes" xml:space="preserve">
          <source>Korean (Hangul)</source>
          <target state="translated">한국어 (한글)</target>
        </trans-unit>
        <trans-unit id="2bfe4366aec039158c13cdff560c53552a6ab2f8" translate="yes" xml:space="preserve">
          <source>LATIN1 with Euro and accents</source>
          <target state="translated">유로와 악센트가있는 LATIN1</target>
        </trans-unit>
        <trans-unit id="a3f57123a6c2ff10f831d7d1652f96a64aa8ede6" translate="yes" xml:space="preserve">
          <source>LC_COLLATE for this database</source>
          <target state="translated">이 데이터베이스에 대한 LC_COLLATE</target>
        </trans-unit>
        <trans-unit id="ccd2341e80cefe881c6b471888b83c35d3eedb65" translate="yes" xml:space="preserve">
          <source>LC_CTYPE for this database</source>
          <target state="translated">이 데이터베이스의 LC_CTYPE</target>
        </trans-unit>
        <trans-unit id="d8343c683ae1584c96390fa627005bc1bb0719cd" translate="yes" xml:space="preserve">
          <source>LDAP</source>
          <target state="translated">LDAP</target>
        </trans-unit>
        <trans-unit id="d11fef55a0f4f7f77f5a743808a9e2af4cfab644" translate="yes" xml:space="preserve">
          <source>LDAP Authentication</source>
          <target state="translated">LDAP 인증</target>
        </trans-unit>
        <trans-unit id="3af0c4862ddb95641f4519deb20c9bd92b5a696b" translate="yes" xml:space="preserve">
          <source>LDAP URLs are currently only supported with OpenLDAP, not on Windows.</source>
          <target state="translated">LDAP URL은 현재 Windows가 아닌 OpenLDAP에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a78f006babbca44fb715e5663d9cdd5f718dd110" translate="yes" xml:space="preserve">
          <source>LDAP authentication can operate in two modes. In the first mode, which we will call the simple bind mode, the server will bind to the distinguished name constructed as &lt;code&gt;prefix&lt;/code&gt;&lt;code&gt;username&lt;/code&gt;&lt;code&gt;suffix&lt;/code&gt;. Typically, the &lt;code&gt;prefix&lt;/code&gt; parameter is used to specify &lt;code&gt;cn=&lt;/code&gt;, or &lt;code&gt;DOMAIN&lt;/code&gt;&lt;code&gt;\&lt;/code&gt; in an Active Directory environment. &lt;code&gt;suffix&lt;/code&gt; is used to specify the remaining part of the DN in a non-Active Directory environment.</source>
          <target state="translated">LDAP 인증은 두 가지 모드로 작동 할 수 있습니다. 단순 바인드 모드라고하는 첫 번째 모드에서 서버는 &lt;code&gt;prefix&lt;/code&gt; &lt;code&gt;username&lt;/code&gt; &lt;code&gt;suffix&lt;/code&gt; 로 구성된 고유 이름에 바인드합니다 . 일반적으로 &lt;code&gt;prefix&lt;/code&gt; 매개 변수는 Active Directory 환경에서 &lt;code&gt;cn=&lt;/code&gt; 또는 &lt;code&gt;DOMAIN&lt;/code&gt; &lt;code&gt;\&lt;/code&gt; 를 지정하는 데 사용됩니다 . &lt;code&gt;suffix&lt;/code&gt; 는 비 Active Directory 환경에서 DN의 나머지 부분을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd1b0f9c2859218ce1180337a2bd66b96113b2f" translate="yes" xml:space="preserve">
          <source>LIMIT and OFFSET</source>
          <target state="translated">제한 및 오프셋</target>
        </trans-unit>
        <trans-unit id="9c6023564f6507b3ea5cad8e472da23961b9afbb" translate="yes" xml:space="preserve">
          <source>LISTEN</source>
          <target state="translated">LISTEN</target>
        </trans-unit>
        <trans-unit id="9814f182fea16d601141a37a9089918cd74f5452" translate="yes" xml:space="preserve">
          <source>LISTEN &amp;mdash; listen for a notification</source>
          <target state="translated">LISTEN &amp;mdash; 알림 수신</target>
        </trans-unit>
        <trans-unit id="8d0c622ff5ca1933ba98627381a4a7d1db679d31" translate="yes" xml:space="preserve">
          <source>LLVM has support for optimizing generated code. Some of the optimizations are cheap enough to be performed whenever JIT is used, while others are only beneficial for longer-running queries. See &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes&lt;/a&gt; for more details about optimizations.</source>
          <target state="translated">LLVM은 생성 된 코드 최적화를 지원합니다. 일부 최적화는 JIT를 사용할 때마다 수행 할 수있을 정도로 저렴하며, 다른 최적화는 장기 실행 쿼리에만 유용합니다. 참조 &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes를&lt;/a&gt; 최적화에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="ca2a082afa739ad45f7209a3186244665643f398" translate="yes" xml:space="preserve">
          <source>LOAD &amp;mdash; load a shared library file</source>
          <target state="translated">LOAD &amp;mdash; 공유 라이브러리 파일을로드합니다</target>
        </trans-unit>
        <trans-unit id="c37eb4cb935a6017aaaaaab327837c7d9bbbc004" translate="yes" xml:space="preserve">
          <source>LOCK</source>
          <target state="translated">LOCK</target>
        </trans-unit>
        <trans-unit id="92d4fa824b1bf5ae650f5b90867eff13a3a5fe0a" translate="yes" xml:space="preserve">
          <source>LOCK &amp;mdash; lock a table</source>
          <target state="translated">LOCK &amp;mdash; 테이블을 잠급니다</target>
        </trans-unit>
        <trans-unit id="6b4bea52cbee20f8507b76217f199114a117089e" translate="yes" xml:space="preserve">
          <source>LSN</source>
          <target state="translated">LSN</target>
        </trans-unit>
        <trans-unit id="d1fca76fb082d22a2d8e514d1b3ce5e3ce9aa851" translate="yes" xml:space="preserve">
          <source>LSN: next byte after last byte of WAL record for last change to this page</source>
          <target state="translated">LSN :이 페이지를 마지막으로 변경하기 위해 WAL 레코드의 마지막 바이트 이후 다음 바이트</target>
        </trans-unit>
        <trans-unit id="f7d6ac021994cd293b3c94c2f6248d32ae9579b5" translate="yes" xml:space="preserve">
          <source>Lag times work automatically for physical replication. Logical decoding plugins may optionally emit tracking messages; if they do not, the tracking mechanism will simply display NULL lag.</source>
          <target state="translated">지연 시간은 물리적 복제를 위해 자동으로 작동합니다. 논리 디코딩 플러그인은 선택적으로 추적 메시지를 방출 할 수 있습니다. 그렇지 않은 경우 추적 메커니즘은 단순히 NULL 지연을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="5e9465d239944a0fa40232e75aff84b43ba97385" translate="yes" xml:space="preserve">
          <source>Language of messages</source>
          <target state="translated">메시지의 언어</target>
        </trans-unit>
        <trans-unit id="ce146ba97ccf4a9eb00c4f7b7284970bf1503949" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="translated">큰 개체 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;34 장&lt;/a&gt; 참조 )는 복제되지 않습니다. 일반 테이블에 데이터를 저장하는 것 외에는 해결 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6b0e78c3e5e8149e57bd763e4fa479405b51a85" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/13/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="translated">Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/13/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</target>
        </trans-unit>
        <trans-unit id="a24b3c46d4ed7dfe7397ec67ef490f12c7f2d62a" translate="yes" xml:space="preserve">
          <source>Last system OID in the database; useful particularly to pg_dump</source>
          <target state="translated">데이터베이스의 마지막 시스템 OID pg_dump에 특히 유용</target>
        </trans-unit>
        <trans-unit id="d8a8330f47a1d2121f7de4d246b07c539d85b887" translate="yes" xml:space="preserve">
          <source>Last time at which this table was analyzed by the autovacuum daemon</source>
          <target state="translated">이 테이블이 autovacuum 데몬에 의해 마지막으로 분석 된 시간</target>
        </trans-unit>
        <trans-unit id="b5daedfbaeb26dce099e49150d7deba8ed7dd63c" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually analyzed</source>
          <target state="translated">이 테이블을 수동으로 분석 한 마지막 시간</target>
        </trans-unit>
        <trans-unit id="d21dc8edf16ccb5721e0bc05e599292ce8cd64c2" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">이 테이블을 수동으로 진공 청소 한 마지막 시간 ( &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 계산하지 않음 )</target>
        </trans-unit>
        <trans-unit id="32d602dc6c753beae99504e742b35637bae47172" translate="yes" xml:space="preserve">
          <source>Last time at which this table was vacuumed by the autovacuum daemon</source>
          <target state="translated">autovacuum 데몬이이 테이블을 마지막으로 정리 한 시간</target>
        </trans-unit>
        <trans-unit id="a6160372ad225c352ec7ffd4f36cad1f43f752fb" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and flushed to disk, the initial value of this field being the first log location used when WAL receiver is started</source>
          <target state="translated">마지막으로 미리 쓰기 로그 위치가 이미 수신되어 디스크로 플러시되었습니다.이 필드의 초기 값은 WAL 수신자가 시작될 때 사용 된 첫 번째 로그 위치입니다.</target>
        </trans-unit>
        <trans-unit id="1c2624daf23aae1afae71faf67ded93dc5500054" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and written to disk, but not flushed. This should not be used for data integrity checks.</source>
          <target state="translated">Last write-ahead log location already received and written to disk, but not flushed. This should not be used for data integrity checks.</target>
        </trans-unit>
        <trans-unit id="6dd26aafa1fbdf96a846556c081c9e292557ed50" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location flushed to disk by this standby server</source>
          <target state="translated">이 대기 서버가 디스크에 플러시 한 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="3196ac97aabe6b93efdbd9d951f27185a4510ea9" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location received, the initial value of this field being 0</source>
          <target state="translated">마지막으로 미리 쓰기 로그 위치가 수신되었으며이 필드의 초기 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="7fce43ad04e1c6ea844b5017a38c520afa802611" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location replayed into the database on this standby server</source>
          <target state="translated">이 대기 서버의 데이터베이스로 재생 된 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="0d3835b7f40d0e6e66b1e74e7de916b14d4f990d" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location reported to origin WAL sender</source>
          <target state="translated">WAL 발신자에게보고 된 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="ac1ae56d16c8b53cb449a2ee572fbfc684cbf5dd" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location sent on this connection</source>
          <target state="translated">이 연결에서 전송 된 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="bafcffd5bbf934c91f7d04975d6317a745ba4820" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location written to disk by this standby server</source>
          <target state="translated">이 대기 서버가 디스크에 쓴 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="ba538f112903a51c4fdd1a1494e1875649a225bb" translate="yes" xml:space="preserve">
          <source>Latin/Arabic</source>
          <target state="translated">Latin/Arabic</target>
        </trans-unit>
        <trans-unit id="fd84929c694afd8b1b6d7503f4f8e1b23aed9285" translate="yes" xml:space="preserve">
          <source>Latin/Cyrillic</source>
          <target state="translated">Latin/Cyrillic</target>
        </trans-unit>
        <trans-unit id="e688538b3f17f5cc30931971a729f9f8fe4c1bdd" translate="yes" xml:space="preserve">
          <source>Latin/Greek</source>
          <target state="translated">Latin/Greek</target>
        </trans-unit>
        <trans-unit id="daa3f6da7a3a4e4229771dc7d3d5e346a4582850" translate="yes" xml:space="preserve">
          <source>Latin/Hebrew</source>
          <target state="translated">Latin/Hebrew</target>
        </trans-unit>
        <trans-unit id="d494f73e6e88daa7f95e93345a91fc4c8dc4fb69" translate="yes" xml:space="preserve">
          <source>Launch the main autoprewarm worker. This will normally happen automatically, but is useful if automatic prewarm was not configured at server startup time and you wish to start up the worker at a later time.</source>
          <target state="translated">주요 자동 예열 작업자를 시작하십시오. 이는 일반적으로 자동으로 발생하지만 서버 시작시 자동 사전 예열이 구성되어 있지 않고 나중에 작업자를 시작하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2c4136854685f9259aab343bbd1cc7a50348e3a5" translate="yes" xml:space="preserve">
          <source>Leaf page fragmentation</source>
          <target state="translated">리프 페이지 조각화</target>
        </trans-unit>
        <trans-unit id="5f877225069b04b69ebc49ed1c8ffc9db5e722b5" translate="yes" xml:space="preserve">
          <source>Leaf tuples of an SP-GiST tree contain values of the same data type as the indexed column. Leaf tuples at the root level will always contain the original indexed data value, but leaf tuples at lower levels might contain only a compressed representation, such as a suffix. In that case the operator class support functions must be able to reconstruct the original value using information accumulated from the inner tuples that are passed through to reach the leaf level.</source>
          <target state="translated">SP-GiST 트리의 리프 튜플에는 인덱싱 된 열과 동일한 데이터 형식의 값이 포함됩니다. 루트 수준의 리프 튜플에는 항상 원래의 인덱스 데이터 값이 포함되지만 하위 수준의 리프 튜플에는 접미사와 같은 압축 된 표현 만 포함될 수 있습니다. 이 경우 연산자 클래스 지원 함수는 전달 된 내부 튜플에서 누적 된 정보를 사용하여 리프 레벨에 도달하여 원래 값을 재구성 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5daa8198764e4eb159c9ea5a3939ed7ca08e926f" translate="yes" xml:space="preserve">
          <source>Least common multiple (the smallest strictly positive number that is an integral multiple of both inputs); returns &lt;code&gt;0&lt;/code&gt; if either input is zero; available for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="translated">Least common multiple (the smallest strictly positive number that is an integral multiple of both inputs); returns &lt;code&gt;0&lt;/code&gt; if either input is zero; available for &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;numeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9299c2aba089dc4590aa8606b111db26dae4554a" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of associated operator</source>
          <target state="translated">관련 연산자의 왼손 입력 데이터 유형</target>
        </trans-unit>
        <trans-unit id="ed906ae901de1e3195028f0570c5ad60b2810880" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of operator</source>
          <target state="translated">연산자의 왼쪽 입력 데이터 유형</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="d8b851cee953f8d81c31ec69468e0ec20c2888c1" translate="yes" xml:space="preserve">
          <source>Length of aggregation interval (in seconds). May be used only with &lt;code&gt;-l&lt;/code&gt; option. With this option, the log contains per-interval summary data, as described below.</source>
          <target state="translated">집계 간격 길이 (초) &lt;code&gt;-l&lt;/code&gt; 옵션 과 함께 만 사용할 수 있습니다. 이 옵션을 사용하면 아래에 설명 된대로 로그에 간격 별 요약 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="af6b0587a83fcd51886d616d3a32f3398d01980f" translate="yes" xml:space="preserve">
          <source>Length of binary string</source>
          <target state="translated">이진 문자열의 길이</target>
        </trans-unit>
        <trans-unit id="ccfe4a6f325c29c147887556a7714e5ddcdfe308" translate="yes" xml:space="preserve">
          <source>Length of each signature (index entry) in bits. It is rounded up to the nearest multiple of &lt;code&gt;16&lt;/code&gt;. The default is &lt;code&gt;80&lt;/code&gt; bits and the maximum is &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">각 서명 (인덱스 항목)의 길이 (비트)입니다. 가장 가까운 &lt;code&gt;16&lt;/code&gt; 의 배수로 올림됩니다 . 기본값은 &lt;code&gt;80&lt;/code&gt; 비트이고 최대 값은 &lt;code&gt;4096&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="12d4a8b76c20bac65c1a5a078f5f7a8e333266b4" translate="yes" xml:space="preserve">
          <source>Length or circumference</source>
          <target state="translated">길이 또는 둘레</target>
        </trans-unit>
        <trans-unit id="9d6ed670f3c04a36b7689b66ca5b25c4d52af652" translate="yes" xml:space="preserve">
          <source>Less likely to cause problems is the minimum size for shared memory segments (&lt;code&gt;SHMMIN&lt;/code&gt;), which should be at most approximately 32 bytes for PostgreSQL (it is usually just 1). The maximum number of segments system-wide (&lt;code&gt;SHMMNI&lt;/code&gt;) or per-process (&lt;code&gt;SHMSEG&lt;/code&gt;) are unlikely to cause a problem unless your system has them set to zero.</source>
          <target state="translated">공유 메모리 세그먼트 ( &lt;code&gt;SHMMIN&lt;/code&gt; ) 의 최소 ​​크기는 문제를 일으킬 가능성이 적으며 , PostgreSQL의 경우 최대 약 32 바이트 여야합니다 (일반적으로 1 임). 시스템 전체 ( &lt;code&gt;SHMMNI&lt;/code&gt; ) 또는 프로세스 당 ( &lt;code&gt;SHMSEG&lt;/code&gt; ) 최대 세그먼트 수는 시스템에서 세그먼트 를 0으로 설정하지 않으면 문제를 일으키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="e88e84c79a2349d1ad4055f51a25c693dabaf88a" translate="yes" xml:space="preserve">
          <source>Less-than comparison</source>
          <target state="translated">Less-than comparison</target>
        </trans-unit>
        <trans-unit id="1f01a7dce204970734b2b2a327ee36987199e47f" translate="yes" xml:space="preserve">
          <source>Less-than operator</source>
          <target state="translated">운영자 미만</target>
        </trans-unit>
        <trans-unit id="9f4307f8c5a910003114771823ca3aa6f1218371" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to comparison</source>
          <target state="translated">Less-than-or-equal-to comparison</target>
        </trans-unit>
        <trans-unit id="4576a6bc031e504cf481eb0d13f776e9d54832eb" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to operator</source>
          <target state="translated">같지 않은 연산자</target>
        </trans-unit>
        <trans-unit id="0ab7950f1f29b3334f76dd244ef5a7ba783b1b7f" translate="yes" xml:space="preserve">
          <source>Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table:</source>
          <target state="translated">해당 제품의 주문을 저장하는 테이블이 있다고 가정 해 봅시다. 주문 테이블에는 실제로 존재하는 제품 주문 만 포함되도록하고 싶습니다. 따라서 products 테이블을 참조하는 orders 테이블에 외래 키 제약 조건을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4bb0a1a761abe6883839cec3e71ca469d8a65b69" translate="yes" xml:space="preserve">
          <source>Let's assume you have filled the table with data and want to take a look at it:</source>
          <target state="translated">테이블에 데이터를 채우고 살펴보고 싶다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="6bb447a9045c7cc0d5a93bdb00100d8f10c020e2" translate="yes" xml:space="preserve">
          <source>Let's consider a real-life astronomical example. We'll expand query &lt;code&gt;supernovae&lt;/code&gt; using table-driven rewriting rules:</source>
          <target state="translated">실제 천문학적 예를 생각해 봅시다. 테이블 중심의 다시 쓰기 규칙을 사용하여 쿼리 &lt;code&gt;supernovae&lt;/code&gt; 을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="3450ae90635f5fd80bf01d11b0586d3e5b336518" translate="yes" xml:space="preserve">
          <source>Let's create two tables: A table &lt;code&gt;cities&lt;/code&gt; and a table &lt;code&gt;capitals&lt;/code&gt;. Naturally, capitals are also cities, so you want some way to show the capitals implicitly when you list all cities. If you're really clever you might invent some scheme like this:</source>
          <target state="translated">테이블 &lt;code&gt;cities&lt;/code&gt; 와 테이블 &lt;code&gt;capitals&lt;/code&gt; 두 개의 테이블을 만들어 봅시다 . 당연히 수도도 도시이므로 모든 도시를 나열 할 때 수도를 암시 적으로 표시 할 수있는 방법이 필요합니다. 당신이 정말 영리하다면 다음과 같은 계획을 발명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="002106d5520b7ff0cea15ef411a279196063cbfa" translate="yes" xml:space="preserve">
          <source>Let's look at that command in detail. First is the key word &lt;code&gt;UPDATE&lt;/code&gt; followed by the table name. As usual, the table name can be schema-qualified, otherwise it is looked up in the path. Next is the key word &lt;code&gt;SET&lt;/code&gt; followed by the column name, an equal sign, and the new column value. The new column value can be any scalar expression, not just a constant. For example, if you want to raise the price of all products by 10% you could use:</source>
          <target state="translated">해당 명령을 자세히 살펴 보겠습니다. 첫 번째는 키워드 &lt;code&gt;UPDATE&lt;/code&gt; 와 테이블 이름입니다. 일반적으로 테이블 이름은 스키마로 한정 될 수 있으며 그렇지 않은 경우 경로에서 조회됩니다. 다음은 키워드 &lt;code&gt;SET&lt;/code&gt; 뒤에 열 이름, 등호 및 새 열 값이옵니다. 새 열 값은 상수뿐만 아니라 모든 스칼라식이 될 수 있습니다. 예를 들어 모든 제품의 가격을 10 % 인상하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b99b3611a0c2fdc7f95a1799fb3492cd67f4e6" translate="yes" xml:space="preserve">
          <source>Let's look at the query from &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt; again, but this time with a MCV list created on the same set of columns (be sure to drop the functional dependencies, to make sure the planner uses the newly created statistics).</source>
          <target state="translated">&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;70.2.1 절의&lt;/a&gt; 쿼리를 다시 살펴 보지만 이번에는 동일한 열 세트에 작성된 MCV 목록을 사용하여 계획을 세웁니다 (계획자가 새로 작성된 통계를 사용하도록 기능 종속성을 삭제하십시오).</target>
        </trans-unit>
        <trans-unit id="1612ac24f2069dd66f65838fc7336fa0b28c41cb" translate="yes" xml:space="preserve">
          <source>Let's move on to an example with a range condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절 에 범위 조건이있는 예제로 넘어 갑시다 .</target>
        </trans-unit>
        <trans-unit id="e33f516fc6df811ac7dea3c6a71c77e25ecd5519" translate="yes" xml:space="preserve">
          <source>Let's start with a very simple query:</source>
          <target state="translated">매우 간단한 쿼리부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="944a02000a7cd912b7786576975c692505293e37" translate="yes" xml:space="preserve">
          <source>Let's start with an example: suppose we are trying to build a data model for cities. Each state has many cities, but only one capital. We want to be able to quickly retrieve the capital city for any particular state. This can be done by creating two tables, one for state capitals and one for cities that are not capitals. However, what happens when we want to ask for data about a city, regardless of whether it is a capital or not? The inheritance feature can help to resolve this problem. We define the &lt;code&gt;capitals&lt;/code&gt; table so that it inherits from &lt;code&gt;cities&lt;/code&gt;:</source>
          <target state="translated">예를 들어 보자. 도시를위한 데이터 모델을 구축하려고한다고 가정하자. 각 주에는 많은 도시가 있지만 하나의 수도 만 있습니다. 특정 주에 대한 수도를 신속하게 검색 할 수 있기를 원합니다. 이는 주 수도와 수도가 아닌 도시를위한 두 개의 테이블을 작성하여 수행 할 수 있습니다. 그러나 도시인지 여부에 관계없이 도시에 대한 데이터를 요청하려고하면 어떻게됩니까? 상속 기능은이 문제를 해결하는 데 도움이 될 수 있습니다. &lt;code&gt;cities&lt;/code&gt; 에서 상속 &lt;code&gt;capitals&lt;/code&gt; 테이블을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="8936905c2cce98cf23701c4834f7f639d90f7b6d" translate="yes" xml:space="preserve">
          <source>Let's try joining two tables, using the columns we have been discussing:</source>
          <target state="translated">논의한 열을 사용하여 두 개의 테이블을 조인 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="fc56b91f6d327225a18362ab13575f562f30c691" translate="yes" xml:space="preserve">
          <source>Lexemes that have positions can further be labeled with a &lt;em&gt;weight&lt;/em&gt;, which can be &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. &lt;code&gt;D&lt;/code&gt; is the default and hence is not shown on output:</source>
          <target state="translated">위치가있는 벡스에는 &lt;em&gt;가중치&lt;/em&gt; 가 추가 될 수 있으며 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;D&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;D&lt;/code&gt; 가 기본값이므로 출력에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4de4e82a8494674ff2932d2f3ecffa7e7aa91c37" translate="yes" xml:space="preserve">
          <source>Lexical Structure</source>
          <target state="translated">어휘 구조</target>
        </trans-unit>
        <trans-unit id="98b17490298c1db6b1bff4b00e76136ec7bbbbbf" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Comments</source>
          <target state="translated">어휘 구조 : 주석</target>
        </trans-unit>
        <trans-unit id="fba7d54766b9a41f8c00c3be52c20790571085f9" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Constants</source>
          <target state="translated">어휘 구조 : 상수</target>
        </trans-unit>
        <trans-unit id="0eb1a63288ed8a4eea2395df1dd364cf859d54a6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Identifiers and Key Words</source>
          <target state="translated">어휘 구조 : 식별자 및 핵심어</target>
        </trans-unit>
        <trans-unit id="195802f293c2f60e26c9b9d1cca1271d02591bfe" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operator Precedence</source>
          <target state="translated">어휘 구조 : 연산자 우선 순위</target>
        </trans-unit>
        <trans-unit id="f3025dccc066fa7289f006eb8ae5b580e53548c6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operators</source>
          <target state="translated">어휘 구조 : 연산자</target>
        </trans-unit>
        <trans-unit id="820a42a37bd5d5e7546df4a06a9fad64993321ea" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Special Characters</source>
          <target state="translated">어휘 구조 : 특수 문자</target>
        </trans-unit>
        <trans-unit id="aa1c47b9be01b70fcc0a9ce52958782af56ce40a" translate="yes" xml:space="preserve">
          <source>Library API</source>
          <target state="translated">라이브러리 API</target>
        </trans-unit>
        <trans-unit id="bc61796bcb48c2cc0906e22b19a382e56ac7241c" translate="yes" xml:space="preserve">
          <source>Licensed under the PostgreSQL License.</source>
          <target state="translated">PostgreSQL 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="70e96422ed9935802e683689abf5ed30f10484c2" translate="yes" xml:space="preserve">
          <source>Lightweight Directory Access Protocol</source>
          <target state="translated">경량 디렉토리 액세스 프로토콜</target>
        </trans-unit>
        <trans-unit id="706c7257274a3b242ba385122feaad6c90232d40" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;%/&lt;/code&gt;, but the output is &lt;code&gt;~&lt;/code&gt; (tilde) if the database is your default database.</source>
          <target state="translated">마찬가지로 &lt;code&gt;%/&lt;/code&gt; , 출력은 있지만 &lt;code&gt;~&lt;/code&gt; 데이터베이스가 기본 데이터베이스 인 경우 (물결).</target>
        </trans-unit>
        <trans-unit id="01c5b4c11e3825cd811354418a5a2a2256d5f14a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--locale&lt;/code&gt;, but only sets the locale in the specified category.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--locale&lt;/code&gt; 있지만 지정된 카테고리의 로케일을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="592d71b5f1a2fc02390509f112e2932ece3b2ce3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.**&lt;/code&gt;, but selects only the specified levels of the JSON hierarchy. Nesting levels are specified as integers. Level zero corresponds to the current object. To access the lowest nesting level, you can use the &lt;code&gt;last&lt;/code&gt; keyword. This is a PostgreSQL extension of the SQL/JSON standard.</source>
          <target state="translated">Like &lt;code&gt;.**&lt;/code&gt; , but selects only the specified levels of the JSON hierarchy. Nesting levels are specified as integers. Level zero corresponds to the current object. To access the lowest nesting level, you can use the &lt;code&gt;last&lt;/code&gt; keyword. This is a PostgreSQL extension of the SQL/JSON standard.</target>
        </trans-unit>
        <trans-unit id="7bcb9cac0fa5cedaf3e22ad3fe9503230b5e0b4b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;LIKE&lt;/code&gt;, the &lt;code&gt;SIMILAR TO&lt;/code&gt; operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string. Also like &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; uses &lt;code&gt;_&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; as wildcard characters denoting any single character and any string, respectively (these are comparable to &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;.*&lt;/code&gt; in POSIX regular expressions).</source>
          <target state="translated">마찬가지로 &lt;code&gt;LIKE&lt;/code&gt; 의 &lt;code&gt;SIMILAR TO&lt;/code&gt; 연산자는 패턴이 전체 문자열과 일치하는 경우에만 성공; 이것은 패턴이 문자열의 어느 부분과도 일치 할 수있는 일반적인 정규식 동작과 다릅니다. 또한 같은 &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;SIMILAR TO&lt;/code&gt; 의 사용 &lt;code&gt;_&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 단일 문자와 문자열을 나타내는 와일드 카드 문자로, 각각 (이들은 비교할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 및 &lt;code&gt;.*&lt;/code&gt; POSIX 정규 표현식에서).</target>
        </trans-unit>
        <trans-unit id="85a2ab4c0cd63cc27de88b6c0b7fbce75e30b6bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;aggfinalmodify&lt;/code&gt;, but for the &lt;code&gt;aggmfinalfn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;aggfinalmodify&lt;/code&gt; 와 비슷 하지만 &lt;code&gt;aggmfinalfn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059422d409e873d3ec537d586c30c482c509b6ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;penalty&lt;/code&gt;, the &lt;code&gt;picksplit&lt;/code&gt; function is crucial to good performance of the index. Designing suitable &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; implementations is where the challenge of implementing well-performing GiST indexes lies.</source>
          <target state="translated">마찬가지로 &lt;code&gt;penalty&lt;/code&gt; 의 &lt;code&gt;picksplit&lt;/code&gt; 의 기능은 인덱스의 좋은 성능에 매우 중요하다. 적절한 &lt;code&gt;penalty&lt;/code&gt; 및 &lt;code&gt;picksplit&lt;/code&gt; 구현을 설계 하는 것은 성능이 우수한 GiST 인덱스를 구현해야하는 과제입니다.</target>
        </trans-unit>
        <trans-unit id="2af7b72fbf0a8ccd43a00ff740a0fef8b75c0395" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pg_statistic&lt;/code&gt;, &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; should not be readable by the public, since the contents might be considered sensitive. (Example: most common combinations of values in columns might be quite interesting.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt;&lt;code&gt;pg_stats_ext&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; (after joining with &lt;code&gt;pg_statistic_ext&lt;/code&gt;) that only exposes information about those tables and columns that are readable by the current user.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 과 마찬가지로 , &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 는 내용이 민감한 것으로 간주 될 수 있으므로 공개적으로 읽을 수 없습니다. (예 : 열에서 가장 일반적인 값 조합은 매우 흥미로울 수 있습니다.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt; &lt;code&gt;pg_stats_ext&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 에서 공개적으로 읽을 수있는보기 ( &lt;code&gt;pg_statistic_ext&lt;/code&gt; 와 결합한 후 )는 현재 사용자가 읽을 수있는 테이블 및 열에 대한 정보 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1e283f20748a53829b82b5760d76e1b1a5f034e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plainto_tsquery&lt;/code&gt;, the &lt;code&gt;phraseto_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">마찬가지로 &lt;code&gt;plainto_tsquery&lt;/code&gt; 의 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 의 기능을 인식하지 않습니다 &lt;code&gt;tsquery&lt;/code&gt; 입력 연산자, 체중 레이블 또는 접두사 일치 라벨 :</target>
        </trans-unit>
        <trans-unit id="176fba135c7656c6b09a34f8083ee1cb69b4df0d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;code&gt;toptag&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; 하지만 결과를 생략합니다 &lt;code&gt;toptag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01344dcf6fdc7567e1ebfddcdc592af8624be340" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;em&gt;&lt;code&gt;toptag&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;em&gt; &lt;code&gt;toptag&lt;/code&gt; &lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="2a092e16f9fe5baae3ebd61fa16eca90ce0ed31e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits both tags.</source>
          <target state="translated">마찬가지로 &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; 하지만 결과를 생략 모두 태그입니다.</target>
        </trans-unit>
        <trans-unit id="79231c4789ce70fc6a3cc412988cea4a45cfbcbb" translate="yes" xml:space="preserve">
          <source>Like GiST and SP-GiST, GIN can support many different user-defined indexing strategies, and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQL includes a GIN operator class for arrays, which supports indexed queries using these operators:</source>
          <target state="translated">GiST 및 SP-GiST와 마찬가지로 GIN은 다양한 사용자 정의 인덱싱 전략을 지원할 수 있으며 GIN 인덱스를 사용할 수있는 특정 연산자는 인덱싱 전략에 따라 다릅니다. 예를 들어, PostgreSQL의 표준 배포에는 다음 연산자를 사용하여 인덱스 된 쿼리를 지원하는 배열에 대한 GIN 연산자 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd7904080c36090327450bf7ffd681d3be365b14" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST is meant to allow the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">GiST와 마찬가지로 SP-GiST는 데이터베이스 전문가가 아닌 데이터 유형의 도메인 전문가가 적절한 액세스 방법으로 사용자 지정 데이터 유형을 개발할 수 있도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="48b6f9b32591a18a649f1f0d5dc992087748dd36" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST supports &amp;ldquo;nearest-neighbor&amp;rdquo; searches. For SP-GiST operator classes that support distance ordering, the corresponding operator is specified in the &amp;ldquo;Ordering Operators&amp;rdquo; column in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">GiST와 마찬가지로 SP-GiST는 &quot;인접 이웃&quot;검색을 지원합니다. 거리 순서를 지원하는 SP-GiST 연산자 클래스의 경우 해당 연산자는 &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 65.1&lt;/a&gt; 의&amp;ldquo;주문 연산자&amp;rdquo;열에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="60e4d14adfb5f143c50beb7e0713788626061776" translate="yes" xml:space="preserve">
          <source>Like a &lt;code&gt;CASE&lt;/code&gt; expression, &lt;code&gt;COALESCE&lt;/code&gt; only evaluates the arguments that are needed to determine the result; that is, arguments to the right of the first non-null argument are not evaluated. This SQL-standard function provides capabilities similar to &lt;code&gt;NVL&lt;/code&gt; and &lt;code&gt;IFNULL&lt;/code&gt;, which are used in some other database systems.</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 표현식 과 마찬가지로 &lt;code&gt;COALESCE&lt;/code&gt; 는 결과를 판별하는 데 필요한 인수 만 평가합니다. 즉, 널이 아닌 첫 번째 인수의 오른쪽에있는 인수는 평가되지 않습니다. 이 SQL 표준 함수는 일부 다른 데이터베이스 시스템에서 사용되는 &lt;code&gt;NVL&lt;/code&gt; 및 &lt;code&gt;IFNULL&lt;/code&gt; 과 유사한 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="1b49279f338ded2bdf03d1fe2fa28270882b8852" translate="yes" xml:space="preserve">
          <source>Like all locks in PostgreSQL, a complete list of advisory locks currently held by any session can be found in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">PostgreSQL의 모든 잠금과 마찬가지로 현재 모든 세션에서 보유한 전체 자문 잠금 목록은 &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; 시스템보기 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41cf9a59f49a59843cd96e23e78a1ccf6b90562d" translate="yes" xml:space="preserve">
          <source>Like all statement-logging options, this option can add significant overhead.</source>
          <target state="translated">모든 명령문 로깅 옵션과 마찬가지로이 옵션은 상당한 오버 헤드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c02f2aa97036dbf7f53371e80651c744767251" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="translated">다른 PostgreSQL 클라이언트 응용 프로그램과 마찬가지로 pg_dump는 기본적으로 현재 운영 체제 사용자 이름과 동일한 데이터베이스 사용자 이름으로 연결됩니다. 이를 대체하려면 &lt;code&gt;-U&lt;/code&gt; 옵션을 지정 하거나 환경 변수 &lt;code&gt;PGUSER&lt;/code&gt; 를 설정하십시오 . pg_dump 연결에는 일반적인 클라이언트 인증 메커니즘 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 에서 설명 )이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab5911dcefb73651b71811a18cd1ea69e7e94d92" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="translated">Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt; . Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="c9db72f7082c44e13743d7b5d39d781324396c03" translate="yes" xml:space="preserve">
          <source>Like most other relational database products, PostgreSQL supports &lt;em&gt;aggregate functions&lt;/em&gt;. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt; (average), &lt;code&gt;max&lt;/code&gt; (maximum) and &lt;code&gt;min&lt;/code&gt; (minimum) over a set of rows.</source>
          <target state="translated">대부분의 다른 관계형 데이터베이스 제품과 마찬가지로 PostgreSQL은 &lt;em&gt;집계 함수를&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; . 집계 함수는 여러 입력 행에서 단일 결과를 계산합니다. 예를 들어 행 집합에 대해 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;avg&lt;/code&gt; (평균), &lt;code&gt;max&lt;/code&gt; (최대) 및 &lt;code&gt;min&lt;/code&gt; (최소) 을 계산하는 집계 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7b37131745c0548a8d7bb256942b653bac4d0f2" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are requested.</source>
          <target state="translated">내장 된 &lt;code&gt;SYSTEM&lt;/code&gt; 샘플링 방법 과 마찬가지로 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 는 블록 수준 샘플링을 수행하므로 샘플이 완전히 임의적이지는 않지만 특히 적은 수의 행만 요청하는 경우 클러스터링 효과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2764b8aec49f0a51f07f507803e713795f179f24" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_TIME&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are selected.</source>
          <target state="translated">내장 된 &lt;code&gt;SYSTEM&lt;/code&gt; 샘플링 방법 과 마찬가지로 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; 은 블록 레벨 샘플링을 수행하므로 샘플이 완전히 임의적이지는 않지만 특히 적은 수의 행만 선택된 경우 클러스터링 효과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3332deec758b17e6fd52517b579fa1eda61782d" translate="yes" xml:space="preserve">
          <source>Likewise, any sequence state changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="translated">Likewise, any sequence state changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</target>
        </trans-unit>
        <trans-unit id="0e207e275fe1f2f0794d071fcc2006657d41ca30" translate="yes" xml:space="preserve">
          <source>Likewise, if the output column is an array type and the JSON value is a JSON array, the elements of the JSON array are converted to elements of the output array by recursive application of these rules.</source>
          <target state="translated">마찬가지로 출력 열이 배열 유형이고 JSON 값이 JSON 배열 인 경우 JSON 규칙의 요소는 이러한 규칙을 반복적으로 적용하여 출력 배열의 요소로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c63c5f8682585854b3af24acfaa10cdf34814785" translate="yes" xml:space="preserve">
          <source>Likewise, it is the operator class's responsibility that inner tuples do not grow too large to fit on an index page; this limits the number of child nodes that can be used in one inner tuple, as well as the maximum size of a prefix value.</source>
          <target state="translated">마찬가지로 내부 튜플이 색인 페이지에 맞지 않을 정도로 커지지 않는 것은 운영자 클래스의 책임입니다. 이것은 하나의 내부 튜플에서 사용할 수있는 자식 노드의 수와 접두사 값의 최대 크기를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="55246b1bbd1c53d922bbe5662b502ad39d3e6a6a" translate="yes" xml:space="preserve">
          <source>Likewise, the current session's temporary-table schema, &lt;code&gt;pg_temp_nnn&lt;/code&gt;, is always searched if it exists. It can be explicitly listed in the path by using the alias &lt;code&gt;pg_temp&lt;/code&gt;. If it is not listed in the path then it is searched first (even before &lt;code&gt;pg_catalog&lt;/code&gt;). However, the temporary schema is only searched for relation (table, view, sequence, etc) and data type names. It is never searched for function or operator names.</source>
          <target state="translated">마찬가지로 현재 세션의 임시 테이블 스키마 &lt;code&gt;pg_temp_nnn&lt;/code&gt; 은 항상 존재하는 경우 검색됩니다. 별명 &lt;code&gt;pg_temp&lt;/code&gt; 를 사용하여 경로에 명시 적으로 나열 할 수 있습니다 . 경로에 나열되지 않으면 먼저 &lt;code&gt;pg_catalog&lt;/code&gt; 이전에도 검색 됩니다. 그러나 임시 스키마는 관계 (테이블, 뷰, 시퀀스 등) 및 데이터 유형 이름 만 검색합니다. 함수 또는 연산자 이름을 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23e122f77e2123c0711252ea9a852e626bde8b4c" translate="yes" xml:space="preserve">
          <source>Likewise, while an aggregate final function is normally expected not to modify its input values, sometimes it is impractical to avoid modifying the transition-state argument. Such behavior must be declared using the &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; parameter. The &lt;code&gt;READ_WRITE&lt;/code&gt; value indicates that the final function modifies the transition state in unspecified ways. This value prevents use of the aggregate as a window function, and it also prevents merging of transition states for aggregate calls that share the same input values and transition functions. The &lt;code&gt;SHAREABLE&lt;/code&gt; value indicates that the transition function cannot be applied after the final function, but multiple final-function calls can be performed on the ending transition state value. This value prevents use of the aggregate as a window function, but it allows merging of transition states. (That is, the optimization of interest here is not applying the same final function repeatedly, but applying different final functions to the same ending transition state value. This is allowed as long as none of the final functions are marked &lt;code&gt;READ_WRITE&lt;/code&gt;.)</source>
          <target state="translated">마찬가지로 집계 최종 함수는 일반적으로 입력 값을 수정하지 않아야하지만 때때로 전이 상태 인수를 수정하지 않는 것이 비현실적입니다. 이러한 동작은 &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; 매개 변수를 사용하여 선언해야합니다 . &lt;code&gt;READ_WRITE&lt;/code&gt; 의 값은 최종 함수 지정 방법 전이 상태를 수정하는 것을 나타낸다. 이 값은 집계를 창 함수로 사용하는 것을 방지하고 동일한 입력 값과 전환 함수를 공유하는 집계 호출에 대한 전환 상태의 병합을 방지합니다. &lt;code&gt;SHAREABLE&lt;/code&gt; 값은 최종 기능 후에 전환 기능을 적용 할 수 없지만 종료 전환 상태 값에 대해 여러 최종 기능 호출을 수행 할 수 있음을 나타냅니다. 이 값은 집계를 창 함수로 사용하지 못하지만 전환 상태를 병합 할 수 있습니다. (여기서 관심있는 최적화는 동일한 최종 함수를 반복적으로 적용하지 않고 동일한 최종 전이 상태 값에 다른 최종 함수를 적용합니다. 최종 함수가 &lt;code&gt;READ_WRITE&lt;/code&gt; 로 표시되지 않는 한 허용됩니다 .)</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="b47563cbfdd571c38564d5b781eea43887f5700d" translate="yes" xml:space="preserve">
          <source>Limits and compatibility notes for the &lt;code&gt;xml&lt;/code&gt; data type can be found in &lt;a href=&quot;xml-limits-conformance&quot;&gt;Section D.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 형식에 대한 제한 및 호환성 정보 는 &lt;a href=&quot;xml-limits-conformance&quot;&gt;섹션 D.3&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96d43f75faf24d1ca67c70ecd2f285a22f1af174" translate="yes" xml:space="preserve">
          <source>Line number of this rule in &lt;code&gt;pg_hba.conf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 에서이 규칙의 줄 번호</target>
        </trans-unit>
        <trans-unit id="958c1e90be0b1ef7a3ea1a3a2ab4b6c7d005a8b7" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file the current value was set at (null for values set from sources other than configuration files, or when examined by a user who is neither a superuser or a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;).</source>
          <target state="translated">구성 파일 내에서 현재 값이 설정되었습니다 (구성 파일 이외의 소스에서 설정 한 값의 경우 또는 수퍼 유저 또는 &lt;code&gt;pg_read_all_settings&lt;/code&gt; 의 구성원이 아닌 사용자가 검사 한 경우 널값 ).</target>
        </trans-unit>
        <trans-unit id="5b8f36e71eca1491bb5a406fd952255ee2d3703e" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file where the entry appears</source>
          <target state="translated">항목이 나타나는 구성 파일 내의 줄 번호</target>
        </trans-unit>
        <trans-unit id="883c97e9c14ffbedf2267734a54bef543950a75e" translate="yes" xml:space="preserve">
          <source>Line segments are output using the first syntax.</source>
          <target state="translated">선분은 첫 번째 구문을 사용하여 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="752729c6452eefd378564f7929186a93baad040b" translate="yes" xml:space="preserve">
          <source>Line segments are represented by pairs of points that are the endpoints of the segment. Values of type &lt;code&gt;lseg&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">선 세그먼트는 세그먼트의 끝점 인 점 쌍으로 표시됩니다. &lt;code&gt;lseg&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="16fbbc248c377444909f3461d6f0754204ffd781" translate="yes" xml:space="preserve">
          <source>Lines are represented by the linear equation &lt;code&gt;A&lt;/code&gt;x + &lt;code&gt;B&lt;/code&gt;y + &lt;code&gt;C&lt;/code&gt; = 0, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are not both zero. Values of type &lt;code&gt;line&lt;/code&gt; are input and output in the following form:</source>
          <target state="translated">선은 선형 방정식 &lt;code&gt;A&lt;/code&gt; x + &lt;code&gt;B&lt;/code&gt; y + &lt;code&gt;C&lt;/code&gt; = 0으로 표시되며 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 모두 0이 아닙니다. &lt;code&gt;line&lt;/code&gt; 유형의 값은 다음 형식으로 입력 및 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="c8eb4d4a92219b0c43b53ed882184405007c09a3" translate="yes" xml:space="preserve">
          <source>Lines being skipped are parsed normally to identify queries and backslash commands, but queries are not sent to the server, and backslash commands other than conditionals (&lt;code&gt;\if&lt;/code&gt;, &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, &lt;code&gt;\endif&lt;/code&gt;) are ignored. Conditional commands are checked only for valid nesting. Variable references in skipped lines are not expanded, and backquote expansion is not performed either.</source>
          <target state="translated">건너 뛴 행은 쿼리 및 백 슬래시 명령을 식별하기 위해 정상적으로 구문 분석되지만 쿼리는 서버로 전송되지 않으며 조건부 ( &lt;code&gt;\if&lt;/code&gt; , &lt;code&gt;\elif&lt;/code&gt; , &lt;code&gt;\else&lt;/code&gt; , &lt;code&gt;\endif&lt;/code&gt; ) 이외의 백 슬래시 명령 은 무시됩니다. 조건부 명령은 유효한 중첩에 대해서만 검사됩니다. 건너 뛴 줄의 변수 참조는 확장되지 않으며 역 따옴표 확장도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="292bae73b4b4a6866d3b72fe56f7981ef97aafd8" translate="yes" xml:space="preserve">
          <source>Lines in the file can be commented out, deleted, and reordered. For example:</source>
          <target state="translated">파일의 행은 주석 처리, 삭제 및 순서 변경이 가능합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f388e9f9cc02768dd9a283f46d4fc51473f089e" translate="yes" xml:space="preserve">
          <source>Linguistic &amp;mdash; Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="translated">Linguistic &amp;mdash; Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</target>
        </trans-unit>
        <trans-unit id="1a1f33913b1ca17a294498b513bfd39ae8063421" translate="yes" xml:space="preserve">
          <source>Linguistic - Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="translated">언어-Ispell 사전은 입력 단어를 정규화 된 형태로 줄이기 위해 노력합니다. 형태소 사전은 단어 엔딩을 제거합니다</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="77cec0c3e9d8d25a57ec1badeff796c61ca86f12" translate="yes" xml:space="preserve">
          <source>List Partitioning</source>
          <target state="translated">파티셔닝 목록</target>
        </trans-unit>
        <trans-unit id="0f3458dce5820aca7e890c4b2003d0e275648e05" translate="yes" xml:space="preserve">
          <source>List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command &lt;code&gt;\list&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 모든 데이터베이스를 나열한 다음 종료하십시오. 다른 비 연결 옵션은 무시됩니다. 이것은 메타 명령 &lt;code&gt;\list&lt;/code&gt; 와 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="4286624f672002892b2ca95ea48f927cd5f85422" translate="yes" xml:space="preserve">
          <source>List information about tables or indexes in a partition tree for a given partitioned table or partitioned index, with one row for each partition. Information provided includes the name of the partition, the name of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The value of level begins at &lt;code&gt;0&lt;/code&gt; for the input table or index in its role as the root of the partition tree, &lt;code&gt;1&lt;/code&gt; for its partitions, &lt;code&gt;2&lt;/code&gt; for their partitions, and so on.</source>
          <target state="translated">주어진 파티션 된 테이블 또는 파티션 된 인덱스의 파티션 트리에서 테이블 또는 인덱스에 대한 정보를 각 파티션마다 한 행씩 나열하십시오. 제공되는 정보에는 파티션 이름, 바로 위 부모 이름, 파티션이 리프인지 알려주는 부울 값 및 계층 구조의 레벨을 나타내는 정수가 포함됩니다. 레벨의 값은 파티션 트리의 루트 역할을하는 입력 테이블 또는 인덱스의 경우 &lt;code&gt;0&lt;/code&gt; 에서 시작 하고 파티션의 경우 &lt;code&gt;1&lt;/code&gt; , 파티션의 경우 &lt;code&gt;2&lt;/code&gt; 등으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f561011cb33daf6ca735d20bdacd8bd7a77bc262" translate="yes" xml:space="preserve">
          <source>List of database name(s) to which this rule applies</source>
          <target state="translated">이 규칙이 적용되는 데이터베이스 이름 목록</target>
        </trans-unit>
        <trans-unit id="c88853b59f7b2d53c0a2755574e42ba43712f76a" translate="yes" xml:space="preserve">
          <source>List of user and group name(s) to which this rule applies</source>
          <target state="translated">이 규칙이 적용되는 사용자 및 그룹 이름 목록</target>
        </trans-unit>
        <trans-unit id="d7af7e299822395c971e66ef8de74b892601d575" translate="yes" xml:space="preserve">
          <source>List text search configurations (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">텍스트 검색 구성을 나열하십시오 ( 자세한 내용은 &lt;code&gt;+&lt;/code&gt; 추가 ).</target>
        </trans-unit>
        <trans-unit id="75bf8723aef5bc601305334105eb67bae8708809" translate="yes" xml:space="preserve">
          <source>List text search dictionaries (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">텍스트 검색 사전을 나열하십시오 ( 자세한 내용은 &lt;code&gt;+&lt;/code&gt; 추가 ).</target>
        </trans-unit>
        <trans-unit id="f21d1140d1b1ac1f6965e01da259ebe5d03603ab" translate="yes" xml:space="preserve">
          <source>List text search parsers (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">텍스트 검색 파서를 나열하십시오 ( 자세한 내용은 &lt;code&gt;+&lt;/code&gt; 추가 ).</target>
        </trans-unit>
        <trans-unit id="a1e1b832b491c08ce8f5b18d1ec93b64f07d2462" translate="yes" xml:space="preserve">
          <source>List text search templates (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">텍스트 검색 템플릿을 나열합니다 ( 자세한 내용은 &lt;code&gt;+&lt;/code&gt; 추가 ).</target>
        </trans-unit>
        <trans-unit id="47ced8a7739926f8f4967c561a0debfd00799b0f" translate="yes" xml:space="preserve">
          <source>List the ancestor relations of the given partition, including the partition itself.</source>
          <target state="translated">파티션 자체를 포함하여 주어진 파티션의 상위 관계를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="1202ae63c3dc8af04c25238d78d5139577abc684" translate="yes" xml:space="preserve">
          <source>List the contents of a directory. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">디렉토리의 내용을 나열하십시오. 기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b401449c4e0d240387a616d5ffbd4a726f02619" translate="yes" xml:space="preserve">
          <source>List the databases in the server and show their names, owners, character set encodings, and access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only databases whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, database sizes, default tablespaces, and descriptions are also displayed. (Size information is only available for databases that the current user can connect to.)</source>
          <target state="translated">서버의 데이터베이스를 나열하고 이름, 소유자, 문자 세트 인코딩 및 액세스 권한을 표시하십시오. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 전용 데이터베이스가 나열됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가됩니다, 데이터베이스 크기, 기본 테이블 스페이스 및 설명도 표시됩니다. (크기 정보는 현재 사용자가 연결할 수있는 데이터베이스에만 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0247fd79dd91c3e0b751440d00b889937665ce82" translate="yes" xml:space="preserve">
          <source>List the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory</source>
          <target state="translated">&lt;code&gt;log_directory&lt;/code&gt; 디렉토리 에 로그 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="38872979f824f8456260bf7fc7dc4180d1627b73" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL archive status directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">WAL 아카이브 상태 디렉토리에 파일의 이름, 크기 및 마지막 수정 시간을 나열하십시오. &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원에게 액세스 권한이 부여되고 수퍼 유저가 아닌 다른 역할에게 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="216f390c14edafdef1abb92a2e408162ca22c8d7" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">WAL 디렉토리에있는 파일의 이름, 크기 및 마지막 수정 시간을 나열하십시오. &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원에게 액세스 권한이 부여되고 수퍼 유저가 아닌 다른 역할에게 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74056411fa2a679687b641cd39f5e9f62ea8d563" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the log directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">로그 디렉토리에 파일의 이름, 크기 및 마지막 수정 시간을 나열하십시오. &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원에게 액세스 권한이 부여되고 수퍼 유저가 아닌 다른 역할에게 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26197e7b4127b303329ad5784e3d755d4742f8bd" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the temporary directory for &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt; is not provided, the &lt;code&gt;pg_default&lt;/code&gt; tablespace is used. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; 의 임시 디렉토리에있는 파일의 이름, 크기 및 마지막 수정 시간을 나열하십시오 . 경우 &lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; 제공되지는 &lt;code&gt;pg_default&lt;/code&gt; 의 테이블 스페이스가 사용됩니다. &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원에게 액세스 권한이 부여되고 수퍼 유저가 아닌 다른 역할에게 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c759b89899d2c028e05b2457d4bdd0b88affd68" translate="yes" xml:space="preserve">
          <source>List the table of contents of the archive. The output of this operation can be used as input to the &lt;code&gt;-L&lt;/code&gt; option. Note that if filtering switches such as &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; are used with &lt;code&gt;-l&lt;/code&gt;, they will restrict the items listed.</source>
          <target state="translated">아카이브의 목차를 나열하십시오. 이 조작의 출력은 &lt;code&gt;-L&lt;/code&gt; 옵션 에 대한 입력으로 사용될 수 있습니다 . &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;-t&lt;/code&gt; 와 같은 필터링 스위치 를 &lt;code&gt;-l&lt;/code&gt; 과 함께 사용하는 경우 하면 나열된 항목이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c161fe12eda9cadc384d03d0ff29a932c7632490" translate="yes" xml:space="preserve">
          <source>Lists access methods. If &lt;code&gt;pattern&lt;/code&gt; is specified, only access methods whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each access method is listed with its associated handler function and description.</source>
          <target state="translated">액세스 방법을 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 액세스 방법 만 표시됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름을 추가하고, 각각의 액세스 방법은 연관된 핸들러 함수 및 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="b5da05aa6b417885b162fa263cf878dfa1640338" translate="yes" xml:space="preserve">
          <source>Lists aggregate functions, together with their return type and the data types they operate on. If &lt;code&gt;pattern&lt;/code&gt; is specified, only aggregates whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">집계 유형과 반환 유형 및 작동하는 데이터 유형을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 집계가 표시됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 패턴 또는 &lt;code&gt;S&lt;/code&gt; 를 공급 시스템 오브젝트를 포함 수정자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="ba7e4d85e717101a207e6ece8fa5eae17728be95" translate="yes" xml:space="preserve">
          <source>Lists collations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only collations whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each collation is listed with its associated description, if any. Note that only collations usable with the current database's encoding are shown, so the results may vary in different databases of the same installation.</source>
          <target state="translated">데이터 정렬을 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 데이터 정렬 만 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되어있는 경우, 각각의 조합은 관련 설명과 함께 나열됩니다. 현재 데이터베이스의 인코딩과 함께 사용할 수있는 데이터 정렬 만 표시되므로 동일한 설치의 데이터베이스마다 결과가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ed6b6d351ec0314d4901220593cc831623e426a" translate="yes" xml:space="preserve">
          <source>Lists conversions between character-set encodings. If &lt;code&gt;pattern&lt;/code&gt; is specified, only conversions whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">문자 집합 인코딩 간의 변환을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 변환이 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="b54152fa5b884f8f7bf428a2c5f3834496af64bd" translate="yes" xml:space="preserve">
          <source>Lists data types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only types whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each type is listed with its internal name and size, its allowed values if it is an &lt;code&gt;enum&lt;/code&gt; type, and its associated permissions. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">데이터 유형을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 유일한 유형이 나열됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 그것이 있다면 명령 이름을 추가하고, 각각의 유형은 내부 이름과 크기로 표시되어, 그 값이 허용 &lt;code&gt;enum&lt;/code&gt; 유형 및 연관된 권한. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed12c82d91396faa77acdf69ded0ffcf5a493ea" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\dg&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\du+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">데이터베이스 역할을 나열합니다. &quot;users&quot;및 &quot;groups&quot;의 개념이 &quot;roles&quot;로 통합 &lt;code&gt;\dg&lt;/code&gt; 명령은 이제 \ dg 와 같습니다 . 기본적으로 사용자가 만든 역할 만 표시됩니다. 시스템 역할을 포함 하도록 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오 . 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 그 역할은 패턴이 나열됩니다 일치합니다. &lt;code&gt;\du+&lt;/code&gt; 형식을 사용하면 각 역할에 대한 추가 정보가 표시됩니다. 현재 이것은 각 역할에 대한 설명을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e29d00c4605108f4d7ba7d0a5a262d70885a0257" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\du&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\dg+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">데이터베이스 역할을 나열합니다. &quot;users&quot;및 &quot;groups&quot;개념이 &quot;roles&quot;로 통합되었으므로이 명령은 이제 &lt;code&gt;\du&lt;/code&gt; 와 같습니다 . 기본적으로 사용자가 만든 역할 만 표시됩니다. 시스템 역할을 포함 하도록 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오 . 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 그 역할은 패턴이 나열됩니다 일치합니다. &lt;code&gt;\dg+&lt;/code&gt; 형식을 사용하면 각 역할에 대한 추가 정보가 표시됩니다. 현재 이것은 각 역할에 대한 설명을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d0e3c51687d883f635b713be9df17a17913ec4be" translate="yes" xml:space="preserve">
          <source>Lists default access privilege settings. An entry is shown for each role (and schema, if applicable) for which the default privilege settings have been changed from the built-in defaults. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose role name or schema name matches the pattern are listed.</source>
          <target state="translated">기본 액세스 권한 설정을 나열합니다. 기본 권한 설정이 기본 제공 기본값에서 변경된 각 역할 (및 해당되는 경우 스키마)에 대한 항목이 표시됩니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 그 역할 이름 또는 스키마 이름이 나열된 패턴과 일치하는 항목을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ee1fa4ed6c7126c1942282c2d9a97fd2fb17066c" translate="yes" xml:space="preserve">
          <source>Lists defined configuration settings. These settings can be role-specific, database-specific, or both. &lt;code&gt;role-pattern&lt;/code&gt; and &lt;code&gt;database-pattern&lt;/code&gt; are used to select specific roles and databases to list, respectively. If omitted, or if &lt;code&gt;*&lt;/code&gt; is specified, all settings are listed, including those not role-specific or database-specific, respectively.</source>
          <target state="translated">정의 된 구성 설정을 나열합니다. 이러한 설정은 역할 별, 데이터베이스 별 또는 둘 다일 수 있습니다. &lt;code&gt;role-pattern&lt;/code&gt; 및 &lt;code&gt;database-pattern&lt;/code&gt; 은 각각 나열 할 특정 역할 및 데이터베이스를 선택하는 데 사용됩니다. 생략하거나 &lt;code&gt;*&lt;/code&gt; 를 지정하면 역할 별 또는 데이터베이스 별이 아닌 설정을 포함하여 모든 설정이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="417307de73c4769c24d10a4a74f461c675665a71" translate="yes" xml:space="preserve">
          <source>Lists domains. If &lt;code&gt;pattern&lt;/code&gt; is specified, only domains whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description.</source>
          <target state="translated">도메인을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 도메인이 표시됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 권한 및 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="f274b8d8f8b448f365efc740c76106814f6e8672" translate="yes" xml:space="preserve">
          <source>Lists event triggers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those event triggers whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">이벤트 트리거를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 그 이벤트 트리거는 패턴이 나열됩니다 일치합니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="e79aeba25c72ede19da97f86bce69c0ff45f55b7" translate="yes" xml:space="preserve">
          <source>Lists foreign servers (mnemonic: &amp;ldquo;external servers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those servers whose name matches the pattern are listed. If the form &lt;code&gt;\des+&lt;/code&gt; is used, a full description of each server is shown, including the server's access privileges, type, version, options, and description.</source>
          <target state="translated">외부 서버를 나열합니다 (니모닉 : &quot;외부 서버&quot;). 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 해당 서버 이름이이 패턴이 표시됩니다 일치합니다. &lt;code&gt;\des+&lt;/code&gt; 형식을 사용하면 서버의 액세스 권한, 유형, 버전, 옵션 및 설명을 포함하여 각 서버에 대한 전체 설명이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="78b8f146a38943cc21434e0badfc06780b279a22" translate="yes" xml:space="preserve">
          <source>Lists foreign tables (mnemonic: &amp;ldquo;external tables&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose table name or schema name matches the pattern are listed. If the form &lt;code&gt;\det+&lt;/code&gt; is used, generic options and the foreign table description are also displayed.</source>
          <target state="translated">외부 테이블을 나열합니다 (니모닉 : &quot;외부 테이블&quot;). 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 그 테이블 이름이나 스키마 이름이 나열된 패턴과 일치하는 항목을 표시합니다. &lt;code&gt;\det+&lt;/code&gt; 형식을 사용하면 일반 옵션 및 외부 테이블 설명도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="841607b805a28257bffdea756495ef2cb699e228" translate="yes" xml:space="preserve">
          <source>Lists foreign-data wrappers (mnemonic: &amp;ldquo;external wrappers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those foreign-data wrappers whose name matches the pattern are listed. If the form &lt;code&gt;\dew+&lt;/code&gt; is used, the access privileges, options, and description of the foreign-data wrapper are also shown.</source>
          <target state="translated">외부 데이터 래퍼를 나열합니다 (니모닉 : &quot;외부 래퍼&quot;). 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우 만 외국 데이터 래퍼 이름이이 패턴이 표시됩니다 일치합니다. &lt;code&gt;\dew+&lt;/code&gt; 형식을 사용하면 외부 데이터 래퍼에 대한 액세스 권한, 옵션 및 설명도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c91d07a0e33c78c3a0a76bd7d8280b785bbd7664" translate="yes" xml:space="preserve">
          <source>Lists functions, together with their result data types, argument data types, and function types, which are classified as &amp;ldquo;agg&amp;rdquo; (aggregate), &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;procedure&amp;rdquo;, &amp;ldquo;trigger&amp;rdquo;, or &amp;ldquo;window&amp;rdquo;. To display only functions of specific type(s), add the corresponding letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; to the command. If &lt;code&gt;pattern&lt;/code&gt; is specified, only functions whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If the form &lt;code&gt;\df+&lt;/code&gt; is used, additional information about each function is shown, including volatility, parallel safety, owner, security classification, access privileges, language, source code and description.</source>
          <target state="translated">&amp;ldquo;agg&amp;rdquo;(집계),&amp;ldquo;normal&amp;rdquo;,&amp;ldquo;procedure&amp;rdquo;,&amp;ldquo;trigger&amp;rdquo;또는&amp;ldquo;window&amp;rdquo;로 분류 된 결과 데이터 유형, 인수 데이터 유형 및 함수 유형과 함께 함수를 나열합니다. 특정 유형의 기능 만 표시하려면 해당 문자 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;w&lt;/code&gt; 를 명령에 추가하십시오. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 기능이 표시됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 형태가 &lt;code&gt;\df+&lt;/code&gt; 휘발성, 병렬 안전, 소유자, 보안 분류, 액세스 권한, 언어, 소스 코드 및 설명을 포함하여 각 기능에 대한 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="24ae150e74e52548491a1b8532993c514778868d" translate="yes" xml:space="preserve">
          <source>Lists installed extensions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those extensions whose names match the pattern are listed. If the form &lt;code&gt;\dx+&lt;/code&gt; is used, all the objects belonging to each matching extension are listed.</source>
          <target state="translated">설치된 확장을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 그 확장 패턴이 나열됩니다 일치합니다. &lt;code&gt;\dx+&lt;/code&gt; 형식을 사용하면 일치하는 각 확장에 속하는 모든 개체가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="9786e0547a160a45eeaaa13b899d2ca350fd4bf0" translate="yes" xml:space="preserve">
          <source>Lists operator classes (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPCLASS&quot;&gt;Section 37.16.1&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator classes associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator classes associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator class is listed with its associated operator family and owner.</source>
          <target state="translated">Lists operator classes (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPCLASS&quot;&gt;Section 37.16.1&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator classes associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator classes associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator class is listed with its associated operator family and owner.</target>
        </trans-unit>
        <trans-unit id="dabc9d2416e57fbb1a6fc125515b7843848c40ff" translate="yes" xml:space="preserve">
          <source>Lists operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPFAMILY&quot;&gt;Section 37.16.5&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator families associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator family is listed with its owner.</source>
          <target state="translated">Lists operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPFAMILY&quot;&gt;Section 37.16.5&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator families associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator family is listed with its owner.</target>
        </trans-unit>
        <trans-unit id="02fc530a920ec71e97da7b47a26de17857efd30a" translate="yes" xml:space="preserve">
          <source>Lists operators associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-STRATEGIES&quot;&gt;Section 37.16.2&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only members of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only members of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator is listed with its sort operator family (if it is an ordering operator).</source>
          <target state="translated">Lists operators associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-STRATEGIES&quot;&gt;Section 37.16.2&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only members of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only members of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator is listed with its sort operator family (if it is an ordering operator).</target>
        </trans-unit>
        <trans-unit id="7b91d850ae0056bf60018b5ebefbaf56889e4bca" translate="yes" xml:space="preserve">
          <source>Lists operators with their operand and result types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only operators whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional information about each operator is shown, currently just the name of the underlying function.</source>
          <target state="translated">피연산자와 결과 유형으로 연산자를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 운영자가 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 연산자에 대한 자세한 정보는, 기본 함수의 현재 단지 이름을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="b6dce10f054bc4a066d94e91eb2653d58925f8ed" translate="yes" xml:space="preserve">
          <source>Lists partitioned relations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose name matches the pattern are listed. The modifiers &lt;code&gt;t&lt;/code&gt; (tables) and &lt;code&gt;i&lt;/code&gt; (indexes) can be appended to the command, filtering the kind of relations to list. By default, partitioned tables and indexes are listed.</source>
          <target state="translated">파티션 된 관계를 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 항목 만 나열됩니다. 수정 자 &lt;code&gt;t&lt;/code&gt; (테이블) 및 &lt;code&gt;i&lt;/code&gt; (인덱스)를 명령에 추가하여 목록에 대한 관계 종류를 필터링 할 수 있습니다. 기본적으로 파티션 된 테이블 및 인덱스가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="6639ac93b6964b1629641d3ad0795ccf6bdb89e2" translate="yes" xml:space="preserve">
          <source>Lists procedural languages. If &lt;code&gt;pattern&lt;/code&gt; is specified, only languages whose names match the pattern are listed. By default, only user-created languages are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each language is listed with its call handler, validator, access privileges, and whether it is a system object.</source>
          <target state="translated">절차 적 언어를 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 언어 만 나열됩니다. 기본적으로 사용자가 만든 언어 만 표시됩니다. 시스템 오브젝트를 포함 하도록 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오 . 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되어, 각 언어의 호출 핸들러, 검증, 접근 권한과 함께 나열하고는 시스템 개체가 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d159d89b43261dc04712aa39d984b98a29983107" translate="yes" xml:space="preserve">
          <source>Lists replication publications. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those publications whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the tables associated with each publication are shown as well.</source>
          <target state="translated">복제 게시를 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 발행물 만 나열됩니다. &lt;code&gt;+&lt;/code&gt; 가 명령 이름에 추가 되면 각 발행물과 연관된 테이블도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5edfb1ad4f7a1bcdc13378e73525d95e092cfe45" translate="yes" xml:space="preserve">
          <source>Lists replication subscriptions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those subscriptions whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional properties of the subscriptions are shown.</source>
          <target state="translated">복제 구독을 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 구독 만 나열됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 첨부되는 상기 구독 추가적인 특성이 도시되어있다.</target>
        </trans-unit>
        <trans-unit id="4fb239c1a080740cf10a3927b46a1262b5ea56d1" translate="yes" xml:space="preserve">
          <source>Lists schemas (namespaces). If &lt;code&gt;pattern&lt;/code&gt; is specified, only schemas whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description, if any.</source>
          <target state="translated">스키마 (네임 스페이스)를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 스키마가 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 권한 및 설명 (있는 경우)과 함께 표시된다.</target>
        </trans-unit>
        <trans-unit id="f82cdaaaa438cda917a1234e5b948d7815debbbb" translate="yes" xml:space="preserve">
          <source>Lists support functions associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only functions of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only functions of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, functions are displayed verbosely, with their actual parameter lists.</source>
          <target state="translated">Lists support functions associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only functions of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only functions of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, functions are displayed verbosely, with their actual parameter lists.</target>
        </trans-unit>
        <trans-unit id="aaa2ebfeff5215f2bad04d9af2cdf2d89c158023" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">관련 액세스 권한이있는 테이블, 뷰 및 시퀀스를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 테이블, 뷰 및 이름이 패턴과 일치하는 나열되어 시퀀스.</target>
        </trans-unit>
        <trans-unit id="bb59616e451459bc316da05ad410acee2d59778b" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If a &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">관련 액세스 권한이있는 테이블, 뷰 및 시퀀스를 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 테이블, 뷰 및 시퀀스 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="ef7de3f6c539d5dd5da460845cd3a63bfcafc2bd" translate="yes" xml:space="preserve">
          <source>Lists tablespaces. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tablespaces whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each tablespace is listed with its associated options, on-disk size, permissions and description.</source>
          <target state="translated">테이블 스페이스를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 테이블이 표시됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되는 각 테이블 스페이스 관련 옵션이 나열되어, 온 디스크 크기, 권한 및 설명입니다.</target>
        </trans-unit>
        <trans-unit id="762f36a63dc0b6ce665e3c2131b6edc15a3446da" translate="yes" xml:space="preserve">
          <source>Lists text search configurations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only configurations whose names match the pattern are shown. If the form &lt;code&gt;\dF+&lt;/code&gt; is used, a full description of each configuration is shown, including the underlying text search parser and the dictionary list for each parser token type.</source>
          <target state="translated">텍스트 검색 구성을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 구성이 표시됩니다. &lt;code&gt;\dF+&lt;/code&gt; 형식을 사용하는 경우 기본 텍스트 검색 파서 및 각 파서 토큰 유형의 사전 목록을 포함하여 각 구성에 대한 자세한 설명이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f6bb868ceb84c3b85646ce544e1a8e93f3c169f4" translate="yes" xml:space="preserve">
          <source>Lists text search dictionaries. If &lt;code&gt;pattern&lt;/code&gt; is specified, only dictionaries whose names match the pattern are shown. If the form &lt;code&gt;\dFd+&lt;/code&gt; is used, additional information is shown about each selected dictionary, including the underlying text search template and the option values.</source>
          <target state="translated">텍스트 검색 사전을 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 사전 만 표시됩니다. &lt;code&gt;\dFd+&lt;/code&gt; 형식을 사용하면 기본 텍스트 검색 템플릿 및 옵션 값을 포함하여 선택한 각 사전에 대한 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ba01d174c5c6cab6bd3b44d816241b168a44d553" translate="yes" xml:space="preserve">
          <source>Lists text search parsers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only parsers whose names match the pattern are shown. If the form &lt;code&gt;\dFp+&lt;/code&gt; is used, a full description of each parser is shown, including the underlying functions and the list of recognized token types.</source>
          <target state="translated">텍스트 검색 파서를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 파서가 표시됩니다. &lt;code&gt;\dFp+&lt;/code&gt; 형식을 사용하면 기본 함수 및 인식 된 토큰 유형 목록을 포함하여 각 파서에 대한 전체 설명이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="80703d2e971d1dc8cd3056fab4357086f4708060" translate="yes" xml:space="preserve">
          <source>Lists text search templates. If &lt;code&gt;pattern&lt;/code&gt; is specified, only templates whose names match the pattern are shown. If the form &lt;code&gt;\dFt+&lt;/code&gt; is used, additional information is shown about each template, including the underlying function names.</source>
          <target state="translated">텍스트 검색 템플릿을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 템플릿이 표시됩니다. &lt;code&gt;\dFt+&lt;/code&gt; 형식을 사용하면 기본 함수 이름을 포함하여 각 템플릿에 대한 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1d9024892b5e72795e533219deec09ad897119d7" translate="yes" xml:space="preserve">
          <source>Lists the ancestor relations of the given partition, including the relation itself. Returns no rows if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="translated">Lists the ancestor relations of the given partition, including the relation itself. Returns no rows if the relation does not exist or is not a partition or partitioned table.</target>
        </trans-unit>
        <trans-unit id="f51bd1ab303ee9de03bdc15a672decf5bfa818c0" translate="yes" xml:space="preserve">
          <source>Lists the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory.</source>
          <target state="translated">Lists the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory.</target>
        </trans-unit>
        <trans-unit id="78999412a6e9f781edbd7db90370d17b04826c4b" translate="yes" xml:space="preserve">
          <source>Lists the tables or indexes in the partition tree of the given partitioned table or partitioned index, with one row for each partition. Information provided includes the OID of the partition, the OID of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The level value is 0 for the input table or index, 1 for its immediate child partitions, 2 for their partitions, and so on. Returns no rows if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="translated">Lists the tables or indexes in the partition tree of the given partitioned table or partitioned index, with one row for each partition. Information provided includes the OID of the partition, the OID of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The level value is 0 for the input table or index, 1 for its immediate child partitions, 2 for their partitions, and so on. Returns no rows if the relation does not exist or is not a partition or partitioned table.</target>
        </trans-unit>
        <trans-unit id="f0a40588516c3a8604348670da0a879303a508a1" translate="yes" xml:space="preserve">
          <source>Lists type casts. If &lt;code&gt;pattern&lt;/code&gt; is specified, only casts whose source or target types match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">유형 캐스트를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 그 원본 또는 대상 유형의 패턴과 일치하는 나열되어 있습니다 캐스트. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="b23bce00d2c7c8d6375ab0cd2ad7f38f1f799075" translate="yes" xml:space="preserve">
          <source>Lists user mappings (mnemonic: &amp;ldquo;external users&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those mappings whose user names match the pattern are listed. If the form &lt;code&gt;\deu+&lt;/code&gt; is used, additional information about each mapping is shown.</source>
          <target state="translated">사용자 매핑을 나열합니다 (니모닉 : &quot;외부 사용자&quot;). 경우 &lt;code&gt;pattern&lt;/code&gt; 지정되고, 그 사용자 이름 만 매핑 패턴이 나열됩니다 일치합니다. &lt;code&gt;\deu+&lt;/code&gt; 형식을 사용하면 각 매핑에 대한 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fee8c64f75222b953355d11e92e46cafb863f042" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the function should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">함수에 대한 호출을 변환하는 목록이 적용되어야합니다. 변환은 SQL 유형과 언어 별 데이터 유형 사이를 변환합니다. &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM을&lt;/a&gt; 참조하십시오 . 절차 적 언어 구현에는 일반적으로 내장 유형에 대한 하드 코딩 된 지식이 있으므로 여기에 나열 할 필요는 없습니다. 절차 적 언어 구현이 유형을 처리하는 방법을 모르고 변환이 제공되지 않으면 데이터 유형 변환을위한 기본 동작으로 대체되지만 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c221c51fd4371df729302cc73086e8359e205a42" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the procedure should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">프로 시저 호출을 변환하는 목록이 적용되어야합니다. 변환은 SQL 유형과 언어 별 데이터 유형 사이를 변환합니다. &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM을&lt;/a&gt; 참조하십시오 . 절차 적 언어 구현에는 일반적으로 내장 유형에 대한 하드 코딩 된 지식이 있으므로 여기에 나열 할 필요는 없습니다. 절차 적 언어 구현이 유형을 처리하는 방법을 모르고 변환이 제공되지 않으면 데이터 유형 변환을위한 기본 동작으로 대체되지만 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0c4bdf42add57a2eabb9fb37aeb6c28158bad4b3" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">리터럴 &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df214b5bbf763eb7922bad89d00442e94abbaf1f" translate="yes" xml:space="preserve">
          <source>Loading an extension essentially amounts to running the extension's script file. The script will typically create new SQL objects such as functions, data types, operators and index support methods. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; additionally records the identities of all the created objects, so that they can be dropped again if &lt;code&gt;DROP EXTENSION&lt;/code&gt; is issued.</source>
          <target state="translated">확장을로드하면 확장의 스크립트 파일을 실행해야합니다. 스크립트는 일반적으로 함수, 데이터 유형, 연산자 및 색인 지원 메소드와 같은 새 SQL 오브젝트를 작성합니다. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 은 추가로 작성된 모든 오브젝트의 ID를 기록하므로 &lt;code&gt;DROP EXTENSION&lt;/code&gt; 이 발행 될 때 다시 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e93fcdb23625364e2abff318d75861520536fbf6" translate="yes" xml:space="preserve">
          <source>Loading an extension ordinarily requires the same privileges that would be required to create its component objects. For many extensions this means superuser privileges are needed. However, if the extension is marked &lt;em&gt;trusted&lt;/em&gt; in its control file, then it can be installed by any user who has &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. In this case the extension object itself will be owned by the calling user, but the contained objects will be owned by the bootstrap superuser (unless the extension's script explicitly assigns them to the calling user). This configuration gives the calling user the right to drop the extension, but not to modify individual objects within it.</source>
          <target state="translated">Loading an extension ordinarily requires the same privileges that would be required to create its component objects. For many extensions this means superuser privileges are needed. However, if the extension is marked &lt;em&gt;trusted&lt;/em&gt; in its control file, then it can be installed by any user who has &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. In this case the extension object itself will be owned by the calling user, but the contained objects will be owned by the bootstrap superuser (unless the extension's script explicitly assigns them to the calling user). This configuration gives the calling user the right to drop the extension, but not to modify individual objects within it.</target>
        </trans-unit>
        <trans-unit id="324780c29ae9b46671035da5fbfcca3eeeaa0b74" translate="yes" xml:space="preserve">
          <source>Loading an extension requires the same privileges that would be required to create its component objects. For most extensions this means superuser or database owner privileges are needed. The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, as well as the owner of any objects created by the extension's script.</source>
          <target state="translated">확장을로드하려면 해당 구성 요소 개체를 만드는 데 필요한 것과 동일한 권한이 필요합니다. 대부분의 확장에서 수퍼 유저 또는 데이터베이스 소유자 권한이 필요합니다. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 을 실행하는 사용자 는 이후의 권한 검사를 위해 확장의 소유자와 확장의 스크립트에 의해 생성 된 모든 개체의 소유자가됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff55ba6c7cc873988ea156302dfd04284604724" translate="yes" xml:space="preserve">
          <source>Locale Support</source>
          <target state="translated">로케일 지원</target>
        </trans-unit>
        <trans-unit id="1615ae9075efc2383f73fbc3997d85cdd39b60c0" translate="yes" xml:space="preserve">
          <source>Locale support is automatically initialized when a database cluster is created using &lt;code&gt;initdb&lt;/code&gt;. &lt;code&gt;initdb&lt;/code&gt; will initialize the database cluster with the locale setting of its execution environment by default, so if your system is already set to use the locale that you want in your database cluster then there is nothing else you need to do. If you want to use a different locale (or you are not sure which locale your system is set to), you can instruct &lt;code&gt;initdb&lt;/code&gt; exactly which locale to use by specifying the &lt;code&gt;--locale&lt;/code&gt; option. For example:</source>
          <target state="translated">로케일 지원은 데이터베이스 클러스터가 &lt;code&gt;initdb&lt;/code&gt; 를 사용하여 작성 될 때 자동으로 초기화 됩니다 . &lt;code&gt;initdb&lt;/code&gt; 는 기본적으로 실행 환경의 로케일 설정으로 데이터베이스 클러스터를 초기화하므로 시스템이 데이터베이스 클러스터에서 원하는 로케일을 사용하도록 이미 설정되어 있으면 다른 조치가 필요하지 않습니다. 다른 로케일을 사용하려는 경우 (또는 시스템이 어떤 로케일로 설정되어 있는지 확실하지 않은 경우) &lt;code&gt;--locale&lt;/code&gt; 옵션 을 지정하여 &lt;code&gt;initdb&lt;/code&gt; 에 사용할 로케일을 정확하게 지시 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9fc941160f1b0396956bfd39853ec712bd8d1fb" translate="yes" xml:space="preserve">
          <source>Localization</source>
          <target state="translated">Localization</target>
        </trans-unit>
        <trans-unit id="405016b1820c348aea5cd317a6502812cdf4ad22" translate="yes" xml:space="preserve">
          <source>Location of root page (zero if none)</source>
          <target state="translated">루트 페이지의 위치 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="24d45a6df98cb6f2c1180b96048b79a73fa5f768" translate="yes" xml:space="preserve">
          <source>Location of specified substring</source>
          <target state="translated">지정된 부분 문자열의 위치</target>
        </trans-unit>
        <trans-unit id="dbb39d513ae60400b7ebae4d62c9e5ac6f77044b" translate="yes" xml:space="preserve">
          <source>Location of specified substring (same as &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt;, but note the reversed argument order)</source>
          <target state="translated">지정된 하위 문자열의 &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt; 와 동일하지만 인수 순서가 역순 임)</target>
        </trans-unit>
        <trans-unit id="9c2e448b0989a5090dc489ea6de417d94cf811c0" translate="yes" xml:space="preserve">
          <source>LocationIndex</source>
          <target state="translated">LocationIndex</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="c804bf0349b9527944ec4a3fe74284d562dd49b7" translate="yes" xml:space="preserve">
          <source>Lock Management</source>
          <target state="translated">잠금 관리</target>
        </trans-unit>
        <trans-unit id="9f5be0c66691f0334e7d2037502bfeef360b9c5d" translate="yes" xml:space="preserve">
          <source>Lock mode of lockers (more than one if multitransaction), an array of &lt;code&gt;Key Share&lt;/code&gt;, &lt;code&gt;Share&lt;/code&gt;, &lt;code&gt;For No Key Update&lt;/code&gt;, &lt;code&gt;No Key Update&lt;/code&gt;, &lt;code&gt;For Update&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;.</source>
          <target state="translated">사물함 잠금 모드 (multitransaction 경우 하나 이상의)의 배열 &lt;code&gt;Key Share&lt;/code&gt; , &lt;code&gt;Share&lt;/code&gt; , &lt;code&gt;For No Key Update&lt;/code&gt; , &lt;code&gt;No Key Update&lt;/code&gt; , &lt;code&gt;For Update&lt;/code&gt; , &lt;code&gt;Update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9404601307758cbcb4a22750c03c625138fcfc8" translate="yes" xml:space="preserve">
          <source>Locking and Indexes</source>
          <target state="translated">잠금 및 색인</target>
        </trans-unit>
        <trans-unit id="8804d3dd97270b8420c7ca1e904a01e8634cbbf1" translate="yes" xml:space="preserve">
          <source>Locking the regular and/or predicate lock manager could have some impact on database performance if this view is very frequently accessed. The locks are held only for the minimum amount of time necessary to obtain data from the lock managers, but this does not completely eliminate the possibility of a performance impact.</source>
          <target state="translated">이보기에 자주 액세스하는 경우 일반 및 / 또는 술어 잠금 관리자를 잠그면 데이터베이스 성능에 영향을 줄 수 있습니다. 잠금은 잠금 관리자로부터 데이터를 얻는 데 필요한 최소 시간 동안 만 유지되지만 성능에 영향을 줄 가능성을 완전히 제거하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="737c6c38b2b84007c82ea914cea8efb3178d5fdf" translate="yes" xml:space="preserve">
          <source>Log File Maintenance</source>
          <target state="translated">로그 파일 유지 관리</target>
        </trans-unit>
        <trans-unit id="6d6b239b122bc0b05311eb6dfbfaaf45f232b9f3" translate="yes" xml:space="preserve">
          <source>Log Sequence Number, see &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;wal-internals&quot;&gt;WAL Internals&lt;/a&gt;.</source>
          <target state="translated">로그 시퀀스 번호는 &lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;wal-internals&quot;&gt;WAL 내부를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60c1e625e1e8d8bc204338911a42295c282dd7d9" translate="yes" xml:space="preserve">
          <source>Log file</source>
          <target state="translated">Log file</target>
        </trans-unit>
        <trans-unit id="4f0a509232d18cc09dfcbf97250e9485bbc40c4c" translate="yes" xml:space="preserve">
          <source>Log files contain human-readable text lines about events. Examples include login failures, long-running queries, etc.</source>
          <target state="translated">Log files contain human-readable text lines about events. Examples include login failures, long-running queries, etc.</target>
        </trans-unit>
        <trans-unit id="ac059a4497d87893d31436f7f08f37f59c88514b" translate="yes" xml:space="preserve">
          <source>Log record</source>
          <target state="translated">Log record</target>
        </trans-unit>
        <trans-unit id="d305d15801e1e955744206adafaf8f3e3d1bb78e" translate="yes" xml:space="preserve">
          <source>Log-Shipping Standby Servers</source>
          <target state="translated">로그 전달 대기 서버</target>
        </trans-unit>
        <trans-unit id="e22cd962d5d7b24a566d7837fcf6043185781e24" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt; to base &lt;em&gt;&lt;code&gt;b&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">Logarithm of &lt;em&gt; &lt;code&gt;x&lt;/code&gt; &lt;/em&gt; to base &lt;em&gt; &lt;code&gt;b&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="567a04e87e0264325ea2d8341bf4b0ffb622ca3f" translate="yes" xml:space="preserve">
          <source>Logged</source>
          <target state="translated">Logged</target>
        </trans-unit>
        <trans-unit id="668f966ac31eb810f98d105493f1c5cdc3067858" translate="yes" xml:space="preserve">
          <source>Logger (process)</source>
          <target state="translated">Logger (process)</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="translated">논리 AND</target>
        </trans-unit>
        <trans-unit id="2445214b8389f14bf2045be1111d0264af049737" translate="yes" xml:space="preserve">
          <source>Logical Decoding</source>
          <target state="translated">논리적 디코딩</target>
        </trans-unit>
        <trans-unit id="e7e803ba6df9ebf5f542bc2b7ce91db2dc559f7e" translate="yes" xml:space="preserve">
          <source>Logical NOT</source>
          <target state="translated">논리 NOT</target>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="translated">논리 OR</target>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">논리 연산자</target>
        </trans-unit>
        <trans-unit id="e81affcc4578ce875d0e0b75ca689bf2f32a90ae" translate="yes" xml:space="preserve">
          <source>Logical Operators: AND</source>
          <target state="translated">논리 연산자 : AND</target>
        </trans-unit>
        <trans-unit id="43e083b90a70b3c47c8f0041d3ea2af4e65c51e3" translate="yes" xml:space="preserve">
          <source>Logical Operators: NOT</source>
          <target state="translated">논리 연산자 : NOT</target>
        </trans-unit>
        <trans-unit id="d639dd9302fac485c5ef253dceb1e3f97c540d72" translate="yes" xml:space="preserve">
          <source>Logical Operators: OR</source>
          <target state="translated">논리 연산자 : OR</target>
        </trans-unit>
        <trans-unit id="87801dc1bcd5e1df0b7d1f2272c64ee5b039c930" translate="yes" xml:space="preserve">
          <source>Logical Repl.</source>
          <target state="translated">Logical Repl.</target>
        </trans-unit>
        <trans-unit id="b3d8aa18dbe5d539b67385e1079b7cb40cef477e" translate="yes" xml:space="preserve">
          <source>Logical Replication</source>
          <target state="translated">논리적 복제</target>
        </trans-unit>
        <trans-unit id="8922d517c58eafe0151a7cf981679470b4600e69" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="translated">논리 디코딩 구축하는 데 사용할 수있는 &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;동기 복제&lt;/a&gt; 에 대한 동기 복제와 같은 사용자 인터페이스 솔루션 &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;스트리밍 복제를&lt;/a&gt; . 이를 위해서는 스트리밍 복제 인터페이스 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;섹션 48.3&lt;/a&gt; 참조 )를 사용하여 데이터를 스트리밍해야합니다. 클라이언트는 스트리밍 복제 클라이언트와 마찬가지로 &lt;code&gt;Standby status update (F)&lt;/code&gt; ) 메시지 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;섹션 52.4&lt;/a&gt; 참조 ) 를 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="f503cf64b38f12bede3e30319a09deafda284c40" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="translated">Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</target>
        </trans-unit>
        <trans-unit id="7b10ab294a9b68fd1f46ed7bc6062a04492e6157" translate="yes" xml:space="preserve">
          <source>Logical group of the parameter</source>
          <target state="translated">매개 변수의 논리 그룹</target>
        </trans-unit>
        <trans-unit id="c580b15c66ecbba918b3e32fb395e268ced977ef" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="translated">논리적 복제를 통해 데이터베이스 서버는 데이터 수정 스트림을 다른 서버로 보낼 수 있습니다. PostgreSQL 논리 복제는 WAL에서 논리 데이터 수정 스트림을 구성합니다. 논리적 복제를 통해 개별 테이블의 데이터 변경 사항을 복제 할 수 있습니다. 논리적 복제에는 특정 서버를 마스터 또는 복제본으로 지정하지 않아도되지만 데이터가 여러 방향으로 흐를 수 있습니다. 논리적 복제에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;30 장을&lt;/a&gt; 참조하십시오 . 논리적 디코딩 인터페이스 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; )를 통해 타사 확장도 비슷한 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efdfc15536907810b351505bdffe988864a38656" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="translated">Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</target>
        </trans-unit>
        <trans-unit id="ed65fe8b9917e90ed44964dea1e1dc23e674a9f1" translate="yes" xml:space="preserve">
          <source>Logical replication behaves similarly to normal DML operations in that the data will be updated even if it was changed locally on the subscriber node. If incoming data violates any constraints the replication will stop. This is referred to as a &lt;em&gt;conflict&lt;/em&gt;. When replicating &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations, missing data will not produce a conflict and such operations will simply be skipped.</source>
          <target state="translated">논리적 복제는 데이터가 구독자 노드에서 로컬로 변경된 경우에도 데이터가 업데이트된다는 점에서 일반 DML 작업과 유사하게 작동합니다. 들어오는 데이터가 제약 조건을 위반하면 복제가 중지됩니다. 이를 &lt;em&gt;충돌&lt;/em&gt; 이라고합니다 . &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 작업을 복제 할 때 누락 된 데이터는 충돌을 일으키지 않으며 이러한 작업은 간단히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="686d57c78ae4b376c0e25252dd6b05a5049c2f9c" translate="yes" xml:space="preserve">
          <source>Logical replication currently has the following restrictions or missing functionality. These might be addressed in future releases.</source>
          <target state="translated">논리적 복제에는 현재 다음과 같은 제한이 있거나 기능이 없습니다. 향후 릴리스에서 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc5341d79f09d707679a0da10e711069ef1d9d1a" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="translated">논리적 복제는 물리적 스트리밍 복제와 유사한 아키텍처로 구축됩니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;26.2.5 절&lt;/a&gt; 참조 ). &quot;walsender&quot;및 &quot;apply&quot;프로세스로 구현됩니다. walsender 프로세스 는 WAL의 논리적 디코딩 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 에서 설명)을 시작 하고 표준 논리적 디코딩 플러그인 (pgoutput)을로드합니다. 플러그인은 WAL에서 읽은 변경 사항을 논리적 복제 프로토콜 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;52.5&lt;/a&gt; 참조 )로 변환하고 게시 사양에 따라 데이터를 필터링합니다. 그런 다음 데이터는 스트리밍 복제 프로토콜을 사용하여 적용 작업자에게 지속적으로 전송됩니다. 적용 작업자는 데이터를 로컬 테이블에 맵핑하고 수신 된 개별 변경 사항을 올바른 트랜잭션 순서로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="24f246c37056cfc3d645585b0f76929bd8ff75af" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="translated">Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</target>
        </trans-unit>
        <trans-unit id="435079a68c735c2e34e8587daebbc03ec2b4108b" translate="yes" xml:space="preserve">
          <source>Logical replication requires several configuration options to be set.</source>
          <target state="translated">논리적 복제에는 몇 가지 구성 옵션을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e84a093ac80e997279a156ad3e78ff218f69bfc7" translate="yes" xml:space="preserve">
          <source>Logical replication starts by copying a snapshot of the data on the publisher database. Once that is done, changes on the publisher are sent to the subscriber as they occur in real time. The subscriber applies data in the order in which commits were made on the publisher so that transactional consistency is guaranteed for the publications within any single subscription.</source>
          <target state="translated">논리적 데이터베이스 복제는 게시자 데이터베이스에서 데이터의 스냅 샷을 복사하여 시작됩니다. 이 작업이 완료되면 게시자의 변경 내용이 실시간으로 구독자에게 전송됩니다. 구독자는 단일 구독 내의 게시에 대해 트랜잭션 일관성이 보장되도록 게시자에 대해 커밋 된 순서대로 데이터를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="27b9470b0624c147b034592fe3f3a73182a2151c" translate="yes" xml:space="preserve">
          <source>Logical replication workers are taken from the pool defined by &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">논리적 복제 작업자는 &lt;code&gt;max_worker_processes&lt;/code&gt; 에 의해 정의 된 풀에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="a63c3a3aa22b3789bd62013d2f279dd236a57e8e" translate="yes" xml:space="preserve">
          <source>Londiste, Slony</source>
          <target state="translated">론 디스 테, 슬로 니</target>
        </trans-unit>
        <trans-unit id="7ed5823bb2b8c30b7d42594563eaf3c04e339fc5" translate="yes" xml:space="preserve">
          <source>Look at &lt;code&gt;xsyn_sample.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt;, for an example.</source>
          <target state="translated">예를 들어 &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; 설치된 &lt;code&gt;xsyn_sample.rules&lt;/code&gt; 를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="ca517b17b581321c398ee4798749fdb48a7ae7a7" translate="yes" xml:space="preserve">
          <source>Look at the new state of the data:</source>
          <target state="translated">데이터의 새로운 상태를보십시오 :</target>
        </trans-unit>
        <trans-unit id="30d58e04409362da5a524652a2e000a29c4e8c15" translate="yes" xml:space="preserve">
          <source>Look for the best match.</source>
          <target state="translated">가장 일치하는 것을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6a2e689d9886aec21b389565fdc3ad34371dc41e" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind constraints cannot contain &lt;em&gt;back references&lt;/em&gt; (see &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;Section 9.7.3.3&lt;/a&gt;), and all parentheses within them are considered non-capturing.</source>
          <target state="translated">Lookahead 및 Lookbehind 제약 조건에는 &lt;em&gt;역 참조가&lt;/em&gt; 포함될 수 없으며 ( &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;9.7.3.3&lt;/a&gt; 참조 ) 그 안의 모든 괄호는 캡처되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5078c384be6b302db7193d0145acae3ffddd4617" translate="yes" xml:space="preserve">
          <source>Looks up a replication origin by name and returns the internal ID. If no such replication origin is found an error is thrown.</source>
          <target state="translated">Looks up a replication origin by name and returns the internal ID. If no such replication origin is found an error is thrown.</target>
        </trans-unit>
        <trans-unit id="56e8f3a9171c421d0883280c2cd97e28c0e45385" translate="yes" xml:space="preserve">
          <source>Lookup a replication origin by name and return the internal id. If no corresponding replication origin is found an error is thrown.</source>
          <target state="translated">이름으로 복제 원점을 조회하고 내부 ID를 반환합니다. 해당 복제 기점이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="55e4cc0e110df2ac3459453907e4bd26c086ff4d" translate="yes" xml:space="preserve">
          <source>Lossiness causes performance degradation due to unnecessary fetches of table records that turn out to be false matches. Since random access to table records is slow, this limits the usefulness of GiST indexes. The likelihood of false matches depends on several factors, in particular the number of unique words, so using dictionaries to reduce this number is recommended.</source>
          <target state="translated">손실은 테이블 레코드의 불필요한 페치로 인해 성능이 저하되어 잘못된 일치로 판명됩니다. 테이블 레코드에 대한 임의 액세스가 느리기 때문에 GiST 인덱스의 유용성이 제한됩니다. 일치하지 않을 가능성은 여러 가지 요소, 특히 고유 단어 수에 따라 달라 지므로 사전을 사용하여이 수를 줄이는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1531c1daacaf1bc409855b8d1d0f55e08ee771dd" translate="yes" xml:space="preserve">
          <source>Low Value</source>
          <target state="translated">낮은 가치</target>
        </trans-unit>
        <trans-unit id="21ceb119d4d9e001890111b5576f7f16ef00c26f" translate="yes" xml:space="preserve">
          <source>Low level base backups can be made in a non-exclusive or an exclusive way. The non-exclusive method is recommended and the exclusive one is deprecated and will eventually be removed.</source>
          <target state="translated">저수준 기본 백업은 비 독점 또는 독점 방식으로 만들 수 있습니다. 비 독점적 방법이 권장되며 독점적 방법은 더 이상 사용되지 않으며 결국 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bddc7c31834ef546bcfbe24e4c18d4afaf657eb8" translate="yes" xml:space="preserve">
          <source>Lowest transaction ID that was still active. All transaction IDs less than &lt;code&gt;xmin&lt;/code&gt; are either committed and visible, or rolled back and dead.</source>
          <target state="translated">Lowest transaction ID that was still active. All transaction IDs less than &lt;code&gt;xmin&lt;/code&gt; are either committed and visible, or rolled back and dead.</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="ac4243ecb01964253411eb3c09a126fc164e78e2" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address</source>
          <target state="translated">MAC (미디어 액세스 제어) 주소</target>
        </trans-unit>
        <trans-unit id="566c47d211683b88f50af170e2aa6203ef55b10a" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address (EUI-64 format)</source>
          <target state="translated">MAC (Media Access Control) 주소 (EUI-64 형식)</target>
        </trans-unit>
        <trans-unit id="b3c62ec9e889671f1211f3670d9feb61fe45a931" translate="yes" xml:space="preserve">
          <source>MAC addresses</source>
          <target state="translated">MAC 주소</target>
        </trans-unit>
        <trans-unit id="22afa78dd9eba1a7e4c213c3623011af13b757a5" translate="yes" xml:space="preserve">
          <source>MAC addresses (EUI-64 format)</source>
          <target state="translated">MAC 주소 (EUI-64 형식)</target>
        </trans-unit>
        <trans-unit id="1c27d6be2a8de3b4e76dde98311054d012ea27ef" translate="yes" xml:space="preserve">
          <source>MCV (most-common values) list statistics, serialized as &lt;code&gt;pg_mcv_list&lt;/code&gt; type</source>
          <target state="translated">MCV (가장 일반적인 값) 목록 통계, &lt;code&gt;pg_mcv_list&lt;/code&gt; 유형으로 직렬화</target>
        </trans-unit>
        <trans-unit id="b773bed04a48de200b96981bb79467413a222066" translate="yes" xml:space="preserve">
          <source>MD5</source>
          <target state="translated">MD5</target>
        </trans-unit>
        <trans-unit id="43a2b4962eca5b9cc86e8c34c251b4aaf74d69de" translate="yes" xml:space="preserve">
          <source>MD5 crypt</source>
          <target state="translated">MD5 암호</target>
        </trans-unit>
        <trans-unit id="b7800f24354ba47ad5de45633c8b73e60e95cf0f" translate="yes" xml:space="preserve">
          <source>MD5 hash and SHA1</source>
          <target state="translated">MD5 해시 및 SHA1</target>
        </trans-unit>
        <trans-unit id="609399527c0412d282c04a9855b05c67f3f4ed44" translate="yes" xml:space="preserve">
          <source>MD5-based crypt</source>
          <target state="translated">MD5 기반 암호화</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="ab3eeea11f18e2650760cfbc2a9ee637afed8340" translate="yes" xml:space="preserve">
          <source>MOVE &amp;mdash; position a cursor</source>
          <target state="translated">MOVE &amp;mdash; 커서 위치</target>
        </trans-unit>
        <trans-unit id="29f17acbc2455f9f492968fd0bda5a0de71679d9" translate="yes" xml:space="preserve">
          <source>MSVC</source>
          <target state="translated">MSVC</target>
        </trans-unit>
        <trans-unit id="a967eb92e41a009b9209426313752a674c43be15" translate="yes" xml:space="preserve">
          <source>MVCC</source>
          <target state="translated">MVCC</target>
        </trans-unit>
        <trans-unit id="f7f38fb90552f61a802690d695bfa4d9b25df00e" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="translated">메시지 번역 카탈로그를 유지하려면 PostgreSQL이 선호하는 언어를 잘 사용하고 싶어하는 많은 자원 봉사자의 지속적인 노력이 필요합니다. 귀하의 언어로 된 메시지가 현재 이용 가능하지 않거나 완전히 번역되지 않은 경우 도움을 주시면 감사하겠습니다. 도움이 필요하면 &lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;54 장을&lt;/a&gt; 참조 하거나 개발자의 메일 링리스트에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7106741f20d440f998ee112429f77e03e33f6395" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="translated">Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</target>
        </trans-unit>
        <trans-unit id="94de303bbef8935622224c5db48199c807ab7d71" translate="yes" xml:space="preserve">
          <source>Maintenance</source>
          <target state="translated">Maintenance</target>
        </trans-unit>
        <trans-unit id="dce34191f69ff984184a7501bc8f6215cc2b1283" translate="yes" xml:space="preserve">
          <source>Maintenance commands - &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="translated">유지 관리 명령 &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="292d556449f6baefbefbc7a2798464550e97b523" translate="yes" xml:space="preserve">
          <source>Maintenance commands: &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="translated">Maintenance commands: &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="477597b3a5e3545e4aafdda2f2a69a40df682681" translate="yes" xml:space="preserve">
          <source>Major PostgreSQL releases regularly add new features that often change the layout of the system tables, but the internal data storage format rarely changes. pg_upgrade uses this fact to perform rapid upgrades by creating new system tables and simply reusing the old user data files. If a future major release ever changes the data storage format in a way that makes the old data format unreadable, pg_upgrade will not be usable for such upgrades. (The community will attempt to avoid such situations.)</source>
          <target state="translated">주요 PostgreSQL 릴리스는 정기적으로 시스템 테이블의 레이아웃을 변경하는 새로운 기능을 정기적으로 추가하지만 내부 데이터 스토리지 형식은 거의 변경되지 않습니다. pg_upgrade는이 사실을 사용하여 새 시스템 테이블을 작성하고 단순히 기존 사용자 데이터 파일을 재사용함으로써 빠른 업그레이드를 수행합니다. 향후 주요 릴리스에서 이전 데이터 형식을 읽을 수없는 방식으로 데이터 저장 형식을 변경하면 pg_upgrade를 이러한 업그레이드에 사용할 수 없습니다. (커뮤니티는 그러한 상황을 피하려고 시도 할 것입니다.)</target>
        </trans-unit>
        <trans-unit id="634be9b233dfc40349e54f6799f11f557bdc5c75" translate="yes" xml:space="preserve">
          <source>Make a base backup of the primary server (see &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;), and load this data onto the standby.</source>
          <target state="translated">기본 서버를 기본 백업하고 ( &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;섹션 25.3.2&lt;/a&gt; 참조 )이 데이터를 대기에로드하십시오.</target>
        </trans-unit>
        <trans-unit id="63a128e9fdffb0bd6c880f9009ba685205efe3c8" translate="yes" xml:space="preserve">
          <source>Make a password valid forever:</source>
          <target state="translated">비밀번호를 영원히 유효하게 만드십시오 :</target>
        </trans-unit>
        <trans-unit id="3d352bc98e86554b9f8e7bb50ec4f35c4891b735" translate="yes" xml:space="preserve">
          <source>Make sure both database servers are stopped using, on Unix, e.g.:</source>
          <target state="translated">유닉스에서 다음과 같은 두 데이터베이스 서버를 사용하여 중지했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b9eb7d5c96a8c5d308e0b19059ab781c2cbe473e" translate="yes" xml:space="preserve">
          <source>Make sure that your server keytab file is readable (and preferably only readable, not writable) by the PostgreSQL server account. (See also &lt;a href=&quot;postgres-user&quot;&gt;Section 18.1&lt;/a&gt;.) The location of the key file is specified by the &lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt; configuration parameter. The default is &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; (or whatever directory was specified as &lt;code&gt;sysconfdir&lt;/code&gt; at build time). For security reasons, it is recommended to use a separate keytab just for the PostgreSQL server rather than opening up permissions on the system keytab file.</source>
          <target state="translated">PostgreSQL 서버 계정으로 서버 키탭 파일을 읽을 수 있어야합니다 (쓰기 가능하지 않은 경우에만 읽을 수 있어야 함). 키 파일의 위치는 &lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt; 구성 매개 변수에 의해 지정됩니다 ( &lt;a href=&quot;postgres-user&quot;&gt;섹션 18.1&lt;/a&gt; 참조 ) . 기본값은 &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; (또는 빌드시 &lt;code&gt;sysconfdir&lt;/code&gt; 로 지정된 디렉토리 )입니다. 보안상의 이유로 시스템 키탭 파일에 대한 권한을 열지 않고 PostgreSQL 서버에 대해서만 별도의 키탭을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c85ef738c1ba87c2190fc933e484d7ebb7fc1d3b" translate="yes" xml:space="preserve">
          <source>Make sure that your session does not hold more locks than necessary when calling &lt;code&gt;pg_sleep&lt;/code&gt; or its variants. Otherwise other sessions might have to wait for your sleeping process, slowing down the entire system.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; 또는 그 변형을 호출 할 때 세션이 필요한 것보다 더 많은 잠금을 보유하지 않도록하십시오 . 그렇지 않으면 다른 세션이 수면 프로세스를 기다려야하므로 전체 시스템 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7b3ea8ab3afc4ab9fbece610d0afa1cdefe9215" translate="yes" xml:space="preserve">
          <source>Make sure the new binaries and support files are installed on all standby servers.</source>
          <target state="translated">새 바이너리 및 지원 파일이 모든 대기 서버에 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4be89cba4680b61369e645efc68f83ec81c167f1" translate="yes" xml:space="preserve">
          <source>Make sure the new standby data directories do &lt;em&gt;not&lt;/em&gt; exist or are empty. If initdb was run, delete the standby servers' new data directories.</source>
          <target state="translated">새 대기 데이터 디렉토리가 존재 하지 &lt;em&gt;않거나&lt;/em&gt; 비어 있는지 확인하십시오 . initdb가 실행 된 경우 대기 서버의 새 데이터 디렉토리를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="173d02f923c11447cf74a27c2960de0e28e12c9b" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; prompt for a password to give the database superuser. If you don't plan on using password authentication, this is not important. Otherwise you won't be able to use password authentication until you have a password set up.</source>
          <target state="translated">차종은 &lt;code&gt;initdb&lt;/code&gt; 에 암호가 데이터베이스 슈퍼 유저를 제공하는 프롬프트. 비밀번호 인증을 사용하지 않을 경우에는 중요하지 않습니다. 그렇지 않으면 비밀번호를 설정할 때까지 비밀번호 인증을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="792a9e540ae77e4ca51fdc9b34493d77aa427a96" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; read the database superuser's password from a file. The first line of the file is taken as the password.</source>
          <target state="translated">차종은 &lt;code&gt;initdb&lt;/code&gt; 에 파일에서 데이터베이스 수퍼 유저의 암호를 읽어 보시기 바랍니다. 파일의 첫 번째 줄이 비밀번호로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="272e7aa108f37caed38de50c7bbbc12a4eeb39f5" translate="yes" xml:space="preserve">
          <source>Makes a cube with upper right and lower left coordinates as defined by the two arrays, which must be of the same length.</source>
          <target state="translated">두 배열에 의해 정의 된대로 오른쪽 위와 왼쪽 아래의 좌표를 가진 큐브를 만듭니다. 길이는 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="7896b684cd247a71e6d914ea864835f0a201cfd2" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube, with the same values for both endpoints of the new coordinate. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">새 좌표의 두 끝점에 대해 동일한 값을 사용하여 기존 큐브에 차원을 추가하여 새 큐브를 만듭니다. 계산 된 값을 기준으로 큐브를 하나씩 빌드하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="43a84f11220bc7ec3aa6c412b1e43c3f1a62c52f" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">기존 큐브에 차원을 추가하여 새 큐브를 만듭니다. 계산 된 값을 기준으로 큐브를 하나씩 빌드하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cec244b05a82755211877f23eb89341a3e2a9049" translate="yes" xml:space="preserve">
          <source>Makes a new cube from an existing cube, using a list of dimension indexes from an array. Can be used to extract the endpoints of a single dimension, or to drop dimensions, or to reorder them as desired.</source>
          <target state="translated">배열의 차원 인덱스 목록을 사용하여 기존 큐브에서 새 큐브를 만듭니다. 단일 치수의 끝점을 추출하거나 치수를 삭제하거나 원하는대로 다시 정렬하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c70237aa382dcfcb4e30da44d32fffb86de7855" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube with both coordinates the same.</source>
          <target state="translated">두 좌표가 모두 같은 1 차원 큐브를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="36186a49b5b2bc93a1e3ef40c1a52eabef758439" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube.</source>
          <target state="translated">1 차원 큐브를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fa2638ba09b880989be4b7b3a19ea5c423840179" translate="yes" xml:space="preserve">
          <source>Makes a single-element array.</source>
          <target state="translated">Makes a single-element array.</target>
        </trans-unit>
        <trans-unit id="aae8d3b9540c85c4e0f867bbcd6f86be7f07d237" translate="yes" xml:space="preserve">
          <source>Makes a single-item &lt;code&gt;hstore&lt;/code&gt;.</source>
          <target state="translated">Makes a single-item &lt;code&gt;hstore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c491ded092df3548669d7b1b5d203277eaee1f2e" translate="yes" xml:space="preserve">
          <source>Makes a zero-volume cube using the coordinates defined by the array.</source>
          <target state="translated">배열에 의해 정의 된 좌표를 사용하여 볼륨이 0 인 큐브를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fefd6a2a56f64d38ec0468fc161189ce50419761" translate="yes" xml:space="preserve">
          <source>Making liberal use of views is a key aspect of good SQL database design. Views allow you to encapsulate the details of the structure of your tables, which might change as your application evolves, behind consistent interfaces.</source>
          <target state="translated">뷰를 자유롭게 사용하는 것은 좋은 SQL 데이터베이스 디자인의 핵심 요소입니다. 뷰를 사용하면 일관된 인터페이스 뒤에서 응용 프로그램이 발전함에 따라 변경 될 수있는 테이블 구조의 세부 정보를 캡슐화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f26b359ba37eb8a50cdf02456f39cff00b1155a4" translate="yes" xml:space="preserve">
          <source>Managing Databases</source>
          <target state="translated">데이터베이스 관리</target>
        </trans-unit>
        <trans-unit id="efd2c6be94610f9dd5980e65687b83de3d52e077" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources</source>
          <target state="translated">커널 리소스 관리</target>
        </trans-unit>
        <trans-unit id="9edd256f8994898f1394cd9f5902a2fe3a3418a1" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Huge Pages</source>
          <target state="translated">커널 리소스 관리 : Linux Huge Pages</target>
        </trans-unit>
        <trans-unit id="f84c08e43ab5092b16e87ebd218788d5283b9b4a" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Memory Overcommit</source>
          <target state="translated">커널 리소스 관리 : Linux 메모리 오버 커밋</target>
        </trans-unit>
        <trans-unit id="412c9a22726797c7f1da88a5ca11bb92ea162415" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Resource Limits</source>
          <target state="translated">커널 자원 관리 : 자원 제한</target>
        </trans-unit>
        <trans-unit id="fc3ccce80bea44ef80a6a994d4e4358186b901da" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Shared Memory and Semaphores</source>
          <target state="translated">커널 리소스 관리 : 공유 메모리 및 세마포어</target>
        </trans-unit>
        <trans-unit id="67cd2bd0c8dc97a476e8e47ebb9371727475113d" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: systemd RemoveIPC</source>
          <target state="translated">커널 리소스 관리 : systemd RemoveIPC</target>
        </trans-unit>
        <trans-unit id="67c48d67ef7ae304937a0a8de822ed104f4b2eb2" translate="yes" xml:space="preserve">
          <source>Manually set the WAL starting location by specifying the name of the next WAL segment file.</source>
          <target state="translated">다음 WAL 세그먼트 파일의 이름을 지정하여 WAL 시작 위치를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6ccaa7bcfd25bcb3a947594b5b5ad3594bebb3be" translate="yes" xml:space="preserve">
          <source>Manually set the next OID.</source>
          <target state="translated">다음 OID를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b11b4e5b2d203da27bc1c6504a10632af73bd3c8" translate="yes" xml:space="preserve">
          <source>Manually set the next and oldest multitransaction ID.</source>
          <target state="translated">다음 및 가장 오래된 다중 트랜잭션 ID를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="05fcb9c1e9b6c68d58ec688a6b55b68af75801bf" translate="yes" xml:space="preserve">
          <source>Manually set the next multitransaction offset.</source>
          <target state="translated">다음 다중 트랜잭션 오프셋을 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="14870c8a6c58f7f0c07765537e62008b75b3dc73" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID's epoch.</source>
          <target state="translated">다음 거래 ID의 에포크를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4f4f1e99ced530ddd1fa0f7dac805a0ddcf54b22" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID.</source>
          <target state="translated">다음 거래 ID를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="648bd7a8e83568d94a29f369df1e0064e881bb1c" translate="yes" xml:space="preserve">
          <source>Manually set the oldest and newest transaction IDs for which the commit time can be retrieved.</source>
          <target state="translated">커밋 시간을 검색 할 수있는 가장 오래된 최신 트랜잭션 ID를 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ff49c52c5651b25a87adf02de107946b0c6a1108" translate="yes" xml:space="preserve">
          <source>Manufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could do:</source>
          <target state="translated">현재 제품이없는 제조업체는 내부 결합이므로 결과에 나타나지 않습니다. 결과에 그러한 제조업체의 이름을 포함 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5d400bc2fffdc5a10db82b688a6346e4cf189544" translate="yes" xml:space="preserve">
          <source>Many database systems have the notion of a one to many table. Such a table usually sits between two indexed tables, for example:</source>
          <target state="translated">많은 데이터베이스 시스템에는 일대 다 테이블 개념이 있습니다. 이러한 테이블은 일반적으로 두 개의 인덱싱 된 테이블 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ffbad28eb7bf7f9a21d96e280ac0310171a900" translate="yes" xml:space="preserve">
          <source>Many developers consider explicitly listing the columns better style than relying on the order implicitly.</source>
          <target state="translated">많은 개발자는 순서에 암시 적으로 의존하는 것보다 열을 명시 적으로 더 나은 스타일로 나열하는 것을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="1cb82d9eaa9bf285209fa61fc5831409cba350d7" translate="yes" xml:space="preserve">
          <source>Many failover systems use just two systems, the primary and the standby, connected by some kind of heartbeat mechanism to continually verify the connectivity between the two and the viability of the primary. It is also possible to use a third system (called a witness server) to prevent some cases of inappropriate failover, but the additional complexity might not be worthwhile unless it is set up with sufficient care and rigorous testing.</source>
          <target state="translated">많은 장애 조치 시스템은 기본 및 대기의 두 시스템 만 사용하여 어떤 종류의 하트 비트 메커니즘으로 연결되어 두 시스템과 기본 시스템의 실행 가능성 사이의 연결을 지속적으로 확인합니다. 부적절한 장애 조치 (failover)의 경우를 방지하기 위해 세 번째 시스템 (감시 서버라고 함)을 사용할 수도 있지만 충분한주의와 엄격한 테스트로 설정하지 않으면 추가적인 복잡성은 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="de1e6960880fdbfac06a6878d8dd73d232d78b66" translate="yes" xml:space="preserve">
          <source>Many installations create their database clusters on file systems (volumes) other than the machine's &amp;ldquo;root&amp;rdquo; volume. If you choose to do this, it is not advisable to try to use the secondary volume's topmost directory (mount point) as the data directory. Best practice is to create a directory within the mount-point directory that is owned by the PostgreSQL user, and then create the data directory within that. This avoids permissions problems, particularly for operations such as pg_upgrade, and it also ensures clean failures if the secondary volume is taken offline.</source>
          <target state="translated">많은 설치는 시스템의 &quot;루트&quot;볼륨 이외의 파일 시스템 (볼륨)에 데이터베이스 클러스터를 만듭니다. 이 작업을 선택하면 보조 볼륨의 최상위 디렉토리 (마운트 포인트)를 데이터 디렉토리로 사용하지 않는 것이 좋습니다. 모범 사례는 PostgreSQL 사용자가 소유 한 마운트 지점 디렉토리 내에 디렉토리를 작성한 다음 그 디렉토리 내에 데이터 디렉토리를 작성하는 것입니다. 이렇게하면 특히 pg_upgrade와 같은 작업에서 권한 문제를 피할 수 있으며 보조 볼륨이 오프라인 상태가되면 정리 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7998a6e83c9395997d176b8166f6ac50148a21ee" translate="yes" xml:space="preserve">
          <source>Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;, the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead/lookbehind constraints, and the longest/shortest-match (rather than first-match) matching semantics.</source>
          <target state="translated">ARE 확장의 대부분은 Perl에서 빌려 왔지만, 일부 확장은 정리를 위해 변경되었으며 일부 Perl 확장은 없습니다. 비 호환성에는 &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\B&lt;/code&gt; , 후행 줄 바꿈에 대한 특수 처리 부족, 줄 바꿈 일치 일치의 영향을받는 항목에 대괄호 표현식 추가, 괄호 및 lookahead / lookbehind 제약 조건의 역 참조에 대한 제한 및 일치하는 시맨틱과 일치하는 최장 / 최단 일치 (일치 일치가 아님)</target>
        </trans-unit>
        <trans-unit id="c2510bd4f5c7e075d877a23b92664b0d94264d01" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a non-UTF8 database encoding. In general, it is best to avoid mixing Unicode escapes in JSON with a non-UTF8 database encoding, if possible.</source>
          <target state="translated">&lt;a href=&quot;functions-json&quot;&gt;섹션 9.15에&lt;/a&gt; 설명 된 많은 JSON 처리 함수는 유니 코드 이스케이프를 일반 문자로 변환하므로 입력이 &lt;code&gt;jsonb&lt;/code&gt; 가 아닌 &lt;code&gt;json&lt;/code&gt; 유형 인 경우에도 방금 설명한 것과 동일한 유형의 오류가 발생합니다 . &lt;code&gt;json&lt;/code&gt; 입력 함수가 이러한 검사를 수행하지 않는다는 사실은 UTF-8이 아닌 데이터베이스 인코딩에서 JSON 유니 코드 이스케이프의 간단한 저장 (처리없이)을 허용하지만 역사적인 아티팩트로 간주 될 수 있습니다. 일반적으로 JSON의 유니 코드 이스케이프를 가능한 비 UTF8 데이터베이스 인코딩과 혼합하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="80b59991b11e3266fbd513366535241df81a8cf9" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a database encoding that does not support the represented characters.</source>
          <target state="translated">Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt; . The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a database encoding that does not support the represented characters.</target>
        </trans-unit>
        <trans-unit id="b3ceba3684c41c44915004b6549907098b3d1192" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. Pgpool-II has this capability. Also, this can be implemented using the PL/Proxy tool set.</source>
          <target state="translated">위의 솔루션 중 다수는 여러 서버가 여러 쿼리를 처리하도록 허용하지만 단일 쿼리가 여러 서버를 사용하여 더 빨리 완료하는 것은 허용하지 않습니다. 이 솔루션을 사용하면 여러 서버가 단일 쿼리에서 동시에 작동 할 수 있습니다. 일반적으로 서버간에 데이터를 분할하고 각 서버가 쿼리의 일부를 실행하고 결과를 중앙 서버로 반환하여 결합되어 사용자에게 반환되도록합니다. Pgpool-II에는이 기능이 있습니다. 또한 PL / Proxy 도구 세트를 사용하여 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="014eb2b75bf8a185a68dd7926fad4b4f2fb6f6a5" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. This can be implemented using the PL/Proxy tool set.</source>
          <target state="translated">Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. This can be implemented using the PL/Proxy tool set.</target>
        </trans-unit>
        <trans-unit id="686c93751e24bfbb5a5a8babbdffa0304da95e5d" translate="yes" xml:space="preserve">
          <source>Many of the meta-commands act on the &lt;em&gt;current query buffer&lt;/em&gt;. This is simply a buffer holding whatever SQL command text has been typed but not yet sent to the server for execution. This will include previous input lines as well as any text appearing before the meta-command on the same line.</source>
          <target state="translated">많은 메타 명령이 &lt;em&gt;현재 쿼리 버퍼에서 작동&lt;/em&gt; 합니다. 이것은 입력 된 SQL 명령 텍스트를 보유하지만 아직 실행을 위해 서버로 전송되지 않은 버퍼입니다. 여기에는 이전 입력 줄과 같은 줄의 메타 명령 앞에 나타나는 텍스트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d0cfb05fe7e11967ff7a6d7fb5a62aee53e9651c" translate="yes" xml:space="preserve">
          <source>Many of these functions and operators will convert Unicode escapes in JSON strings to the appropriate single character. This is a non-issue if the input is type &lt;code&gt;jsonb&lt;/code&gt;, because the conversion was already done; but for &lt;code&gt;json&lt;/code&gt; input, this may result in throwing an error, as noted in &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="translated">이러한 많은 함수와 연산자는 JSON 문자열의 유니 코드 이스케이프를 적절한 단일 문자로 변환합니다. 변환이 이미 완료 되었기 때문에 입력이 &lt;code&gt;jsonb&lt;/code&gt; 유형 인 경우에는 문제가 아닙니다 . 그러나 &lt;code&gt;json&lt;/code&gt; 입력의 경우 &lt;a href=&quot;datatype-json&quot;&gt;8.14 절에&lt;/a&gt; 명시된 것처럼 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cd10805ee6287ed464e4a751e94e4711b1b75c0" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="translated">이러한 기능 중 다수는 복제 프로토콜에서 동등한 명령을 갖습니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;섹션 52.4&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c9991bbe3c7f8082ad3aa4aa507145ca5c59d4fc" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="translated">Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="09d54c9e108446dcc126d9b9edd300bc8f018b7c" translate="yes" xml:space="preserve">
          <source>Many of these operations are only sensible for one-dimensional arrays. Although they will accept input arrays of more dimensions, the data is treated as though it were a linear array in storage order.</source>
          <target state="translated">이러한 작업 중 많은 부분이 1 차원 배열에만 적합합니다. 더 많은 차원의 입력 배열을 허용하지만 데이터는 스토리지 순서의 선형 배열 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="747ffafd1658c72a0cfd879c2f486677fdad72db" translate="yes" xml:space="preserve">
          <source>Many people choose to use scripts to define their &lt;code&gt;archive_command&lt;/code&gt;, so that their &lt;code&gt;postgresql.conf&lt;/code&gt; entry looks very simple:</source>
          <target state="translated">많은 사람들 이 &lt;code&gt;postgresql.conf&lt;/code&gt; 항목이 매우 단순 해 보이 도록 스크립트를 사용하여 &lt;code&gt;archive_command&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="871adaf8d8928b9b6cb8b32ef8db751f5c6cf9e4" translate="yes" xml:space="preserve">
          <source>Many programs produce strange and occasionally perverse CSV files, so the file format is more a convention than a standard. Thus you might encounter some files that cannot be imported using this mechanism, and &lt;code&gt;COPY&lt;/code&gt; might produce files that other programs cannot process.</source>
          <target state="translated">많은 프로그램이 이상한 CSV 파일을 생성하기 때문에 파일 형식이 표준보다 더 관례입니다. 따라서이 메커니즘을 사용하여 가져올 수없는 파일이있을 수 있으며 &lt;code&gt;COPY&lt;/code&gt; 는 다른 프로그램이 처리 할 수없는 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c567b905d84b0a334ddbdf37ad683a15fc2dd4c4" translate="yes" xml:space="preserve">
          <source>Many routines are already defined within PostgreSQL itself, but user-defined ones can also be added.</source>
          <target state="translated">Many routines are already defined within PostgreSQL itself, but user-defined ones can also be added.</target>
        </trans-unit>
        <trans-unit id="aced3527162bd0f606c70ff2d552cd6071f17c5f" translate="yes" xml:space="preserve">
          <source>Many users consider it good practice to always list the column names.</source>
          <target state="translated">많은 사용자는 항상 열 이름을 나열하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9e8ae0f81b2286e5d586c06978958263d9a26d81" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using Snowball stemmer rules.</source>
          <target state="translated">Snowball 형태소 규칙을 사용하여 단어의 다른 변형을 정식 형태로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="8d7f24aaf39a33003cb1dd2dcc4e2ba52ecca563" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using an Ispell dictionary.</source>
          <target state="translated">Ispell 사전을 사용하여 단어의 다른 변형을 정식 형태로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="7153d307c4a8dd126f6b081d2a4d9f2c3be33e38" translate="yes" xml:space="preserve">
          <source>Map phrases to a single word using a thesaurus.</source>
          <target state="translated">동의어 사전을 사용하여 구를 한 단어로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="9b24aee355a7838c5529c7490a65bac5367e010b" translate="yes" xml:space="preserve">
          <source>Map synonyms to a single word using Ispell.</source>
          <target state="translated">Ispell을 사용하여 동의어를 한 단어로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="c4ba0822462e0c373aadd5360a69f205c2a7d036" translate="yes" xml:space="preserve">
          <source>Mar</source>
          <target state="translated">Mar</target>
        </trans-unit>
        <trans-unit id="433632ea5cd64cd163c3a390d5e531d33da3c5e5" translate="yes" xml:space="preserve">
          <source>March</source>
          <target state="translated">March</target>
        </trans-unit>
        <trans-unit id="531a1c0bf44a83aa6422d943626b2d77d47c5593" translate="yes" xml:space="preserve">
          <source>Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">마크 커크 우드 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b50963c78fd5ba0ee384ff4f9865fdb85cbddcd7" translate="yes" xml:space="preserve">
          <source>Mark a column as allowing, or not allowing, null values.</source>
          <target state="translated">열을 허용하거나 허용하지 않는 열로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="45379fe0fd98739ca8b200f2546c07f11e0483e4" translate="yes" xml:space="preserve">
          <source>Mark current scan position. The access method need only support one remembered scan position per scan.</source>
          <target state="translated">현재 스캔 위치를 표시하십시오. 액세스 방법은 스캔 당 하나의 기억 된 스캔 위치 만 지원하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d89c04496b47c6c7add6d623e145d05e0e90beea" translate="yes" xml:space="preserve">
          <source>Mark the current session as replaying from the given origin, allowing replay progress to be tracked. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to revert. Can only be used if no previous origin is configured.</source>
          <target state="translated">현재 세션을 지정된 오리진에서 재생 중으로 표시하여 재생 진행 상황을 추적 할 수 있습니다. &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; 을 사용 하여 되돌립니다. 이전 원점이 구성되지 않은 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c353ba22d4916c50376ffc56136935d3788b393" translate="yes" xml:space="preserve">
          <source>Mark the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has previously been configured using &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt;.</source>
          <target state="translated">주어진 LSN 및 타임 스탬프에서 커밋 된 트랜잭션을 재생하는 것으로 현재 트랜잭션을 표시하십시오. 복제 원점이 이전에 &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt; 사용하여 구성된 경우에만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8026198ec726c859996827cb2a33d945433d7db7" translate="yes" xml:space="preserve">
          <source>Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a8a93296bb3f7dbd2119f15415d0d529e99efc9" translate="yes" xml:space="preserve">
          <source>Marks the current session as replaying from the given origin, allowing replay progress to be tracked. Can only be used if no origin is currently selected. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to undo.</source>
          <target state="translated">Marks the current session as replaying from the given origin, allowing replay progress to be tracked. Can only be used if no origin is currently selected. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to undo.</target>
        </trans-unit>
        <trans-unit id="6f934292a8f9bb0e504a2267c5d57828e046b931" translate="yes" xml:space="preserve">
          <source>Marks the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has been selected using &lt;code&gt;pg_replication_origin_session_setup&lt;/code&gt;.</source>
          <target state="translated">Marks the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has been selected using &lt;code&gt;pg_replication_origin_session_setup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a85793fe091f4b79ea4b1cbe55645a43cdb25119" translate="yes" xml:space="preserve">
          <source>Marks the publication as one that replicates changes for all tables in the database, including tables created in the future.</source>
          <target state="translated">나중에 작성된 테이블을 포함하여 데이터베이스의 모든 테이블에 대한 변경 사항을 복제하는 발행물로 발행을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="48783f4e8092ded2db7efb72ccd9468e6f9f40fe" translate="yes" xml:space="preserve">
          <source>Master (server)</source>
          <target state="translated">Master (server)</target>
        </trans-unit>
        <trans-unit id="dbea724ab0ab5100a69e78a28b57720c1d6712f2" translate="yes" xml:space="preserve">
          <source>Master failure will never lose data</source>
          <target state="translated">마스터 실패는 데이터를 잃지 않을 것입니다</target>
        </trans-unit>
        <trans-unit id="b17d5df13d0871fd4cf3c5923d856a866da06d96" translate="yes" xml:space="preserve">
          <source>Match the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value to &lt;code&gt;NULL&lt;/code&gt;. In the default case where the null string is empty, this converts a quoted empty string into NULL. This option is allowed only in &lt;code&gt;COPY FROM&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">인용 된 경우에도 지정된 열의 값을 널 문자열과 일치시키고 일치하는 것이 있으면 값을 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 . 널 (null) 문자열이 비어있는 기본 경우 인용 된 빈 문자열을 NULL로 변환합니다. 이 옵션은 &lt;code&gt;COPY FROM&lt;/code&gt; 에서만 가능하며 &lt;code&gt;CSV&lt;/code&gt; 형식을 사용하는 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="53d751384b810e580b81b6af15ea342f4112abe1" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case insensitive</source>
          <target state="translated">대소 문자를 구분하지 않는 정규식과 일치</target>
        </trans-unit>
        <trans-unit id="50df7b2381b68eae63b34b5f24c7004fae5bf76b" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case sensitive</source>
          <target state="translated">대소 문자를 구분하는 정규식과 일치</target>
        </trans-unit>
        <trans-unit id="fccd01d6aebb595ebe777cc128bfd2f8fc6bb331" translate="yes" xml:space="preserve">
          <source>Materialized</source>
          <target state="translated">Materialized</target>
        </trans-unit>
        <trans-unit id="6c6539b1b3ecdc0ce5fd2e28965f4dde400d5218" translate="yes" xml:space="preserve">
          <source>Materialized view (relation)</source>
          <target state="translated">Materialized view (relation)</target>
        </trans-unit>
        <trans-unit id="7844bff419f63af9d9cad339e25621693c32f323" translate="yes" xml:space="preserve">
          <source>Materialized view definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">구체화 된 뷰 정의 (재구성 된 &lt;code&gt;SELECT&lt;/code&gt; 쿼리)</target>
        </trans-unit>
        <trans-unit id="1636e8b4d786c74d148e1a7dc19345ad47a2c025" translate="yes" xml:space="preserve">
          <source>Mathematical operators are provided for many PostgreSQL types. For types without standard mathematical conventions (e.g., date/time types) we describe the actual behavior in subsequent sections.</source>
          <target state="translated">많은 PostgreSQL 유형에 대해 수학 연산자가 제공됩니다. 표준 수학 규칙이없는 유형 (예 : 날짜 / 시간 유형)의 경우 후속 섹션에서 실제 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1001c24f338845a2ebfc01ab0741f854faa1aca1" translate="yes" xml:space="preserve">
          <source>Mathematical:  / 2</source>
          <target state="translated">Mathematical: / 2</target>
        </trans-unit>
        <trans-unit id="c3d70e9435a7845b6f93f885d627357ee254fe09" translate="yes" xml:space="preserve">
          <source>Mathematical: !</source>
          <target state="translated">수학 :!</target>
        </trans-unit>
        <trans-unit id="fdaf7cc1ab57d2149690173f829e4f0c4dd36551" translate="yes" xml:space="preserve">
          <source>Mathematical: !!</source>
          <target state="translated">수학적 : !!</target>
        </trans-unit>
        <trans-unit id="5e2823abc00a4631871d8a38e715d143884de402" translate="yes" xml:space="preserve">
          <source>Mathematical: !! 5</source>
          <target state="translated">Mathematical: !! 5</target>
        </trans-unit>
        <trans-unit id="b5aaa56c60d256db29a89bc57b92703c0f7cb305" translate="yes" xml:space="preserve">
          <source>Mathematical: #</source>
          <target state="translated">수학 : #</target>
        </trans-unit>
        <trans-unit id="181ffc47f204d3f9ba3ff486f0f30c0c0ef1d5b9" translate="yes" xml:space="preserve">
          <source>Mathematical: %</source>
          <target state="translated">수학적 : %</target>
        </trans-unit>
        <trans-unit id="ab7340ae469c4484dcc6f33a45b64f2dbe2c6ff3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;amp;</source>
          <target state="translated">수학 : &amp;amp;</target>
        </trans-unit>
        <trans-unit id="c195fef9b5d30c42138e890a55d18aa8f3e74af3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;gt;&amp;gt;</source>
          <target state="translated">수학 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="14a14395161c1fa4a496e90e3da92831d4e7dcdb" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;lt;&amp;lt;</source>
          <target state="translated">수학 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ddb29852cc33e3b226c0621b50ee13e25c0315f2" translate="yes" xml:space="preserve">
          <source>Mathematical: *</source>
          <target state="translated">수학 : *</target>
        </trans-unit>
        <trans-unit id="59ea67514b35bce8cb0c2fb98d96ab75e1042145" translate="yes" xml:space="preserve">
          <source>Mathematical: +</source>
          <target state="translated">수학 : +</target>
        </trans-unit>
        <trans-unit id="573654821f774c0055526f71d6224f85263be0a1" translate="yes" xml:space="preserve">
          <source>Mathematical: + 3.5</source>
          <target state="translated">Mathematical: + 3.5</target>
        </trans-unit>
        <trans-unit id="9634adf0f4c35060714ef3c74218c7741d96738c" translate="yes" xml:space="preserve">
          <source>Mathematical: -</source>
          <target state="translated">수학 :-</target>
        </trans-unit>
        <trans-unit id="bc7be2afb633a5ef91761e59ad8b5a5f36c92a00" translate="yes" xml:space="preserve">
          <source>Mathematical: /</source>
          <target state="translated">수학적 : /</target>
        </trans-unit>
        <trans-unit id="14509827aaea9ada84591d506dac7b95163f05fb" translate="yes" xml:space="preserve">
          <source>Mathematical: 0</source>
          <target state="translated">Mathematical: 0</target>
        </trans-unit>
        <trans-unit id="1dcad53763c2d6ad82f715b19ab8fec7ddeae22b" translate="yes" xml:space="preserve">
          <source>Mathematical: 1 &amp;lt;&amp;lt; 4</source>
          <target state="translated">Mathematical: 1 &amp;lt;&amp;lt; 4</target>
        </trans-unit>
        <trans-unit id="ca7f29cf58cb7d77da0870ecda08106919ba5797" translate="yes" xml:space="preserve">
          <source>Mathematical: 17 # 5</source>
          <target state="translated">Mathematical: 17 # 5</target>
        </trans-unit>
        <trans-unit id="aba60cec6fd188d73cb4b2c6daf41d7e269b2755" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 * 3</source>
          <target state="translated">Mathematical: 2 * 3</target>
        </trans-unit>
        <trans-unit id="a09b3f64871c9fa59aafabb2d8aac651ddf945f1" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 + 3</source>
          <target state="translated">Mathematical: 2 + 3</target>
        </trans-unit>
        <trans-unit id="46a2737a7e89745b3ae76fb70bc9a67e72cce41a" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 - 3</source>
          <target state="translated">Mathematical: 2 - 3</target>
        </trans-unit>
        <trans-unit id="4e4ae222002ab6c8851226d9e26b9eb6997461fb" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 ^ 3</source>
          <target state="translated">Mathematical: 2 ^ 3</target>
        </trans-unit>
        <trans-unit id="b1453f807f48dca3215386cb463d776ee41b48c5" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 ^ 3 ^ 3</source>
          <target state="translated">Mathematical: 2 ^ 3 ^ 3</target>
        </trans-unit>
        <trans-unit id="0910b16e152e2fe676e014eac4265186a97fa07e" translate="yes" xml:space="preserve">
          <source>Mathematical: 32 | 3</source>
          <target state="translated">Mathematical: 32 | 3</target>
        </trans-unit>
        <trans-unit id="7585f445437546f28802c19197028b4f366b5a52" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 !</source>
          <target state="translated">Mathematical: 5 !</target>
        </trans-unit>
        <trans-unit id="b13db5517bdad3caace02ad3155beb1c731b5ca2" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 % 4</source>
          <target state="translated">Mathematical: 5 % 4</target>
        </trans-unit>
        <trans-unit id="23a81ae0fa61623f6df83d0e9447d29d062d3a97" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 / 2</source>
          <target state="translated">Mathematical: 5 / 2</target>
        </trans-unit>
        <trans-unit id="d4f45fa3de4c530e7fd6305fbfcd48feef5d74a8" translate="yes" xml:space="preserve">
          <source>Mathematical: 5.0 / 2</source>
          <target state="translated">Mathematical: 5.0 / 2</target>
        </trans-unit>
        <trans-unit id="11e8ff6a5010dabe71633aac622636270030f6a1" translate="yes" xml:space="preserve">
          <source>Mathematical: 8 &amp;gt;&amp;gt; 2</source>
          <target state="translated">Mathematical: 8 &amp;gt;&amp;gt; 2</target>
        </trans-unit>
        <trans-unit id="1211cb8df037247151be58836d25635e55e30011" translate="yes" xml:space="preserve">
          <source>Mathematical: 91 &amp;amp; 15</source>
          <target state="translated">Mathematical: 91 &amp;amp; 15</target>
        </trans-unit>
        <trans-unit id="3196927fede8cfa3807fe6508ad4afd6a4dd5c10" translate="yes" xml:space="preserve">
          <source>Mathematical: @</source>
          <target state="translated">수학 : @</target>
        </trans-unit>
        <trans-unit id="ae31f2afe49c847bd7b50bc7534ffe77332ef912" translate="yes" xml:space="preserve">
          <source>Mathematical: @ -5.0</source>
          <target state="translated">Mathematical: @ -5.0</target>
        </trans-unit>
        <trans-unit id="1dadfd5f33c390a7d584396b6077f56229e94a33" translate="yes" xml:space="preserve">
          <source>Mathematical: ^</source>
          <target state="translated">수학 : ^</target>
        </trans-unit>
        <trans-unit id="20a199d0df7c3ce2a80fb78024a1d00c66d000a9" translate="yes" xml:space="preserve">
          <source>Mathematical: abs</source>
          <target state="translated">수학적 : abs</target>
        </trans-unit>
        <trans-unit id="df0e19fdb206e36a2205ad9d44520f7fee9d3470" translate="yes" xml:space="preserve">
          <source>Mathematical: acos</source>
          <target state="translated">수학적 : acos</target>
        </trans-unit>
        <trans-unit id="f1cae65774f5f13f2e415042ed98b64f1dc67f0f" translate="yes" xml:space="preserve">
          <source>Mathematical: acosd</source>
          <target state="translated">Mathematical: acosd</target>
        </trans-unit>
        <trans-unit id="f713fa364b0d2333d09caea3c059cdf323feaaae" translate="yes" xml:space="preserve">
          <source>Mathematical: acosh</source>
          <target state="translated">수학적 : acosh</target>
        </trans-unit>
        <trans-unit id="15392ccce532b37463508b07d4825a05d6fb2837" translate="yes" xml:space="preserve">
          <source>Mathematical: asin</source>
          <target state="translated">수학 : asin</target>
        </trans-unit>
        <trans-unit id="4629299dfc93830669825b7184510d53113981f0" translate="yes" xml:space="preserve">
          <source>Mathematical: asind</source>
          <target state="translated">Mathematical: asind</target>
        </trans-unit>
        <trans-unit id="3fe074bf9a455acf4922429fcb4f7cd46c3c843a" translate="yes" xml:space="preserve">
          <source>Mathematical: asinh</source>
          <target state="translated">수학 : asinh</target>
        </trans-unit>
        <trans-unit id="83a2bb5d54e23969b5a04d6c088114146c9dc45d" translate="yes" xml:space="preserve">
          <source>Mathematical: atan</source>
          <target state="translated">수학적 : 아탄</target>
        </trans-unit>
        <trans-unit id="c731e727bd85d0cc74cb9191f3962ed11a8f3b3b" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2</source>
          <target state="translated">수학적 : atan2</target>
        </trans-unit>
        <trans-unit id="5b918761ab75eba1fab60d1e4fd5336ac01d2bf8" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2d</source>
          <target state="translated">Mathematical: atan2d</target>
        </trans-unit>
        <trans-unit id="a929d56a5b59eb4bc6c164cae3d9675502095c0e" translate="yes" xml:space="preserve">
          <source>Mathematical: atand</source>
          <target state="translated">Mathematical: atand</target>
        </trans-unit>
        <trans-unit id="583724a9264d7b0976ad47dcd14d4ac28456738f" translate="yes" xml:space="preserve">
          <source>Mathematical: atanh</source>
          <target state="translated">수학적 : 아탄</target>
        </trans-unit>
        <trans-unit id="177cd0bc699b2203fdf2d4c75fe30163594d7b7e" translate="yes" xml:space="preserve">
          <source>Mathematical: cbrt</source>
          <target state="translated">수학적 : cbrt</target>
        </trans-unit>
        <trans-unit id="2693815a9d6a69c69854809a47650e0275c1e989" translate="yes" xml:space="preserve">
          <source>Mathematical: ceil</source>
          <target state="translated">수학적 : ceil</target>
        </trans-unit>
        <trans-unit id="d952c9a3323ba3a0a0aaeb01f24cc8dfd99821d9" translate="yes" xml:space="preserve">
          <source>Mathematical: ceiling</source>
          <target state="translated">수학적 : 천장</target>
        </trans-unit>
        <trans-unit id="9db09acf97836fbc07512e622eb6635d3a02dc78" translate="yes" xml:space="preserve">
          <source>Mathematical: cos</source>
          <target state="translated">수학 : cos</target>
        </trans-unit>
        <trans-unit id="85e771e6ddf496ad7e9555f4d093d90654ec2a2a" translate="yes" xml:space="preserve">
          <source>Mathematical: cosd</source>
          <target state="translated">Mathematical: cosd</target>
        </trans-unit>
        <trans-unit id="ae9e7e216cc8b38acc3988effacc0b9c9f145f6e" translate="yes" xml:space="preserve">
          <source>Mathematical: cosh</source>
          <target state="translated">수학 : 코쉬</target>
        </trans-unit>
        <trans-unit id="6bd28a5aa54b3401f41f88e5856f7384f5d30c00" translate="yes" xml:space="preserve">
          <source>Mathematical: cot</source>
          <target state="translated">수학적 : 간이 침대</target>
        </trans-unit>
        <trans-unit id="e063ca4c3718afe3730ed0658e8574f03540c88a" translate="yes" xml:space="preserve">
          <source>Mathematical: cotd</source>
          <target state="translated">Mathematical: cotd</target>
        </trans-unit>
        <trans-unit id="18ccdbc8bc11a04cc3a6bf245df208da8e2cae56" translate="yes" xml:space="preserve">
          <source>Mathematical: degrees</source>
          <target state="translated">수학적 :도</target>
        </trans-unit>
        <trans-unit id="aca19fd89939c16cdb0569b07e58a53ad9349a7b" translate="yes" xml:space="preserve">
          <source>Mathematical: div</source>
          <target state="translated">수학 : div</target>
        </trans-unit>
        <trans-unit id="8af560e7bf42dc0411068f58a59ae9f72df77793" translate="yes" xml:space="preserve">
          <source>Mathematical: e</source>
          <target state="translated">Mathematical: e</target>
        </trans-unit>
        <trans-unit id="1e46d6487f521a5afb4ed4dd6a23a59fc059e6e5" translate="yes" xml:space="preserve">
          <source>Mathematical: exp</source>
          <target state="translated">수학적 : 특급</target>
        </trans-unit>
        <trans-unit id="5d515a5291a2aa6b90f086dc95105de6456c2b72" translate="yes" xml:space="preserve">
          <source>Mathematical: factorial</source>
          <target state="translated">Mathematical: factorial</target>
        </trans-unit>
        <trans-unit id="573fe26c7738f0584a8c6cbc5489e02fe641fddb" translate="yes" xml:space="preserve">
          <source>Mathematical: floor</source>
          <target state="translated">수학적 : 바닥</target>
        </trans-unit>
        <trans-unit id="0875b243f27c954dcb0311da83af45540779329c" translate="yes" xml:space="preserve">
          <source>Mathematical: gcd</source>
          <target state="translated">Mathematical: gcd</target>
        </trans-unit>
        <trans-unit id="585a4c28147c569040ed981c6a2b550fc5404fd3" translate="yes" xml:space="preserve">
          <source>Mathematical: lcm</source>
          <target state="translated">Mathematical: lcm</target>
        </trans-unit>
        <trans-unit id="402d0cd4fdb985e3812799945b9fceb07540a0b6" translate="yes" xml:space="preserve">
          <source>Mathematical: ln</source>
          <target state="translated">수학 : ln</target>
        </trans-unit>
        <trans-unit id="85d8f0757c4bc05932d8f5d5e562c9da71c34f89" translate="yes" xml:space="preserve">
          <source>Mathematical: log</source>
          <target state="translated">수학적 : 로그</target>
        </trans-unit>
        <trans-unit id="c83ba153e80e1ad83154d81618c218abe75464e9" translate="yes" xml:space="preserve">
          <source>Mathematical: log10</source>
          <target state="translated">수학 : log10</target>
        </trans-unit>
        <trans-unit id="b72fa934be334bbd661a4dd4724fb9f4f43c1c9b" translate="yes" xml:space="preserve">
          <source>Mathematical: min_scale</source>
          <target state="translated">Mathematical: min_scale</target>
        </trans-unit>
        <trans-unit id="342c1a68d26670cf3f8565a0897aa5cb7ba34b4e" translate="yes" xml:space="preserve">
          <source>Mathematical: mod</source>
          <target state="translated">수학적 : mod</target>
        </trans-unit>
        <trans-unit id="1c34dfef32b83a1764b863b4bbe019d5862c9c11" translate="yes" xml:space="preserve">
          <source>Mathematical: pi</source>
          <target state="translated">수학적 : pi</target>
        </trans-unit>
        <trans-unit id="886814dcb54a703998bbc0cf8f2f8499a7b62fa5" translate="yes" xml:space="preserve">
          <source>Mathematical: power</source>
          <target state="translated">수학적 : 힘</target>
        </trans-unit>
        <trans-unit id="256f270ce3f202545798a4267069da319d55bdce" translate="yes" xml:space="preserve">
          <source>Mathematical: radians</source>
          <target state="translated">수학적 : 라디안</target>
        </trans-unit>
        <trans-unit id="fa28188b7b4ce61e7fd1e57eb3d3850d1782d895" translate="yes" xml:space="preserve">
          <source>Mathematical: random</source>
          <target state="translated">수학적 : 무작위</target>
        </trans-unit>
        <trans-unit id="38618634f79b9464f7b75f0213cc7c4516883f3f" translate="yes" xml:space="preserve">
          <source>Mathematical: round</source>
          <target state="translated">수학적 : 라운드</target>
        </trans-unit>
        <trans-unit id="d57a36e95bfa64f5eb46d773fdde749c2cb84fc4" translate="yes" xml:space="preserve">
          <source>Mathematical: scale</source>
          <target state="translated">수학적 : 스케일</target>
        </trans-unit>
        <trans-unit id="bf096078393c2c98a0b1e6c717f74e687f878163" translate="yes" xml:space="preserve">
          <source>Mathematical: setseed</source>
          <target state="translated">수학적 : setseed</target>
        </trans-unit>
        <trans-unit id="39f4ee6bf2c1ebbb6d092ca5116d3c60ea228290" translate="yes" xml:space="preserve">
          <source>Mathematical: sign</source>
          <target state="translated">수학 : 부호</target>
        </trans-unit>
        <trans-unit id="21776ac559594087e48aa9a00b1065f77ca338fd" translate="yes" xml:space="preserve">
          <source>Mathematical: sin</source>
          <target state="translated">수학적 : 죄</target>
        </trans-unit>
        <trans-unit id="e9237291333d54a9e72bd4303ce991cb654f9866" translate="yes" xml:space="preserve">
          <source>Mathematical: sind</source>
          <target state="translated">Mathematical: sind</target>
        </trans-unit>
        <trans-unit id="00e2992e6f676f0cd18285a72f0c1e9d55b0d240" translate="yes" xml:space="preserve">
          <source>Mathematical: sinh</source>
          <target state="translated">수학 : sinh</target>
        </trans-unit>
        <trans-unit id="aae7a6e9b70d02f4e993a9db74c8db3083ef0bfc" translate="yes" xml:space="preserve">
          <source>Mathematical: sqrt</source>
          <target state="translated">수학 : sqrt</target>
        </trans-unit>
        <trans-unit id="02a3ee3cf42cf2113efd88c1ad458433f9a69197" translate="yes" xml:space="preserve">
          <source>Mathematical: tan</source>
          <target state="translated">수학적 : 황갈색</target>
        </trans-unit>
        <trans-unit id="a12d29e8482347b79de73aeb0357bed2e637f2fc" translate="yes" xml:space="preserve">
          <source>Mathematical: tand</source>
          <target state="translated">Mathematical: tand</target>
        </trans-unit>
        <trans-unit id="43ac9c6f98336e23241f94c577f53cb99b066801" translate="yes" xml:space="preserve">
          <source>Mathematical: tanh</source>
          <target state="translated">수학적 : tanh</target>
        </trans-unit>
        <trans-unit id="4cead06e1e3ecd61366e9c73534c51a69696eb50" translate="yes" xml:space="preserve">
          <source>Mathematical: trim_scale</source>
          <target state="translated">Mathematical: trim_scale</target>
        </trans-unit>
        <trans-unit id="fd05d42d41de6870056e68c4ccd289ca842197c7" translate="yes" xml:space="preserve">
          <source>Mathematical: trunc</source>
          <target state="translated">수학 : 잘림</target>
        </trans-unit>
        <trans-unit id="b3fcfe03e83f0fd3f41685d5a0a35fa941c16d42" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket</source>
          <target state="translated">수학 : width_bucket</target>
        </trans-unit>
        <trans-unit id="102ae47fccbd9d1f7766efee6bfebf34706bb020" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket, array::timestamptz)</source>
          <target state="translated">Mathematical: width_bucket, array::timestamptz)</target>
        </trans-unit>
        <trans-unit id="dfa1e770f800f341e62dbc76cea5befa40e67f50" translate="yes" xml:space="preserve">
          <source>Mathematical: |</source>
          <target state="translated">수학 : |</target>
        </trans-unit>
        <trans-unit id="b18f08aa2ba95d26e5185b6a71ed15ce174e5b8f" translate="yes" xml:space="preserve">
          <source>Mathematical: |/</source>
          <target state="translated">수학 : | /</target>
        </trans-unit>
        <trans-unit id="b1d8eaf643a6e6b2e7be95b78f55ac71c3eeed5c" translate="yes" xml:space="preserve">
          <source>Mathematical: |/ 25.0</source>
          <target state="translated">Mathematical: |/ 25.0</target>
        </trans-unit>
        <trans-unit id="51e150fa17498f246e415139012baeb22d8f4d4a" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/</source>
          <target state="translated">수학 : || /</target>
        </trans-unit>
        <trans-unit id="6da4178d25c27664a5aeecdd5149efed87a71eaa" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/ 64.0</source>
          <target state="translated">Mathematical: ||/ 64.0</target>
        </trans-unit>
        <trans-unit id="3eacd2f34aae3951141d12b3b8bacb1b57ee7e7b" translate="yes" xml:space="preserve">
          <source>Mathematical: ~</source>
          <target state="translated">수학적 : ~</target>
        </trans-unit>
        <trans-unit id="28cbee48973403ffe3820780daffa38b195ca4b1" translate="yes" xml:space="preserve">
          <source>Mathematical: ~1</source>
          <target state="translated">Mathematical: ~1</target>
        </trans-unit>
        <trans-unit id="a95e85aed56318093b024674e217cae0bd30241d" translate="yes" xml:space="preserve">
          <source>Max</source>
          <target state="translated">Max</target>
        </trans-unit>
        <trans-unit id="eebfdb589d2a38f34e9a5e134f62af1ef891433d" translate="yes" xml:space="preserve">
          <source>Max Password Length</source>
          <target state="translated">최대 비밀번호 길이</target>
        </trans-unit>
        <trans-unit id="462156397b99eeccfdb0f5b4ea63ec4407a809bc" translate="yes" xml:space="preserve">
          <source>Maximum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">매개 변수의 최대 허용 값 (숫자가 아닌 값의 경우 널)</target>
        </trans-unit>
        <trans-unit id="f4c49a25b4f19cb0213949aa3e28ef3557be3a93" translate="yes" xml:space="preserve">
          <source>Maximum amount of time allowed to complete client authentication. If a would-be client has not completed the authentication protocol in this much time, the server closes the connection. This prevents hung clients from occupying a connection indefinitely. If this value is specified without units, it is taken as seconds. The default is one minute (&lt;code&gt;1m&lt;/code&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">클라이언트 인증을 완료 할 수있는 최대 시간입니다. 클라이언트가이 시간 내에 인증 프로토콜을 완료하지 않은 경우 서버는 연결을 닫습니다. 이로 인해 정지 된 클라이언트가 연결을 무기한으로 차지하지 못하게됩니다. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 기본값은 1 분 ( &lt;code&gt;1m&lt;/code&gt; )입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16d4343ca4b0ff10b386fabaeb90ec48c83feb93" translate="yes" xml:space="preserve">
          <source>Maximum depth to descend to, or zero for unlimited depth</source>
          <target state="translated">최대로 내려갈 최대 깊이 또는 무제한 깊이의 경우 0</target>
        </trans-unit>
        <trans-unit id="6e382e12a5004b51a9fb6db4c19fb4ad8b8e10a3" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphore identifiers (i.e., sets)</source>
          <target state="translated">세마포어 식별자의 최대 개수 (예 : 세트)</target>
        </trans-unit>
        <trans-unit id="0c59e3da96b0612eb2065c185976ccb89f3be9d6" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores per set</source>
          <target state="translated">세트당 최대 세마포어 수</target>
        </trans-unit>
        <trans-unit id="352ff6e41f28fb4dd9615ad5c6b893bc2f0820a2" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores system-wide</source>
          <target state="translated">시스템 전체의 최대 세마포어 수</target>
        </trans-unit>
        <trans-unit id="c815c1aa92e98505761f17e71fb912e2b0d50481" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments per process</source>
          <target state="translated">프로세스 당 최대 공유 메모리 세그먼트 수</target>
        </trans-unit>
        <trans-unit id="f5eb5768d25d1069e687fbff6c4cdff705aae7ad" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments system-wide</source>
          <target state="translated">시스템 전체의 최대 공유 메모리 세그먼트 수</target>
        </trans-unit>
        <trans-unit id="e4a5cf08c55be90a96549a51c4d65339bafeb337" translate="yes" xml:space="preserve">
          <source>Maximum number of synchronization workers per subscription. This parameter controls the amount of parallelism of the initial data copy during the subscription initialization or when new tables are added.</source>
          <target state="translated">구독 당 최대 동기화 작업자 수 이 매개 변수는 구독 초기화 중 또는 새 테이블이 추가 될 때 초기 데이터 사본의 병렬 처리량을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="cf9da86e68e4a7c2a1bc302b1edbdee46483b5d4" translate="yes" xml:space="preserve">
          <source>Maximum size of shared memory segment (bytes)</source>
          <target state="translated">공유 메모리 세그먼트의 최대 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="3bc5354a68835f6648f33d79497a82c72e86de3c" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow during automatic checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_size&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Maximum size to let the WAL grow during automatic checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt; , or a high &lt;code&gt;wal_keep_size&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</target>
        </trans-unit>
        <trans-unit id="d78433a672e983d650938d0f8874ea0c01c8e279" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow to between automatic WAL checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_segments&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">자동 WAL 체크 포인트 사이에서 WAL이 커질 수있는 최대 크기입니다. 이것은 소프트 한계입니다. 로드가 &lt;code&gt;wal_keep_segments&lt;/code&gt; 거나, &lt;code&gt;archive_command&lt;/code&gt; 실패 또는 높은 wal_keep_segments 설정 과 같은 특수한 상황에서는 WAL 크기가 &lt;code&gt;max_wal_size&lt;/code&gt; 를 초과 할 수 있습니다 . 이 값을 단위없이 지정하면 메가 바이트로 간주됩니다. 기본값은 1GB입니다. 이 매개 변수를 늘리면 응급 복구에 필요한 시간이 늘어날 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6663cd5d04ec15d3d8cb068011883bb72c21769" translate="yes" xml:space="preserve">
          <source>Maximum time between automatic WAL checkpoints. If this value is specified without units, it is taken as seconds. The valid range is between 30 seconds and one day. The default is five minutes (&lt;code&gt;5min&lt;/code&gt;). Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">자동 WAL 체크 포인트 사이의 최대 시간. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 유효한 범위는 30 초에서 1 일입니다. 기본값은 5 분 ( &lt;code&gt;5min&lt;/code&gt; )입니다. 이 매개 변수를 늘리면 응급 복구에 필요한 시간이 늘어날 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6f1ed8f82cbd62e299f9090b927f2f26026550f" translate="yes" xml:space="preserve">
          <source>Maximum time spent executing the statement, in milliseconds</source>
          <target state="translated">Maximum time spent executing the statement, in milliseconds</target>
        </trans-unit>
        <trans-unit id="4455b92ac909b4c5503624f3e50369ecbf4e7112" translate="yes" xml:space="preserve">
          <source>Maximum time spent in the statement, in milliseconds</source>
          <target state="translated">명령문에 소요 된 최대 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="80cb793c865edc2335fb8eab0406dd5a5723c352" translate="yes" xml:space="preserve">
          <source>Maximum time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">명령문 계획에 소요 된 최대 시간 (밀리 초) ( &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; 이 활성화 된 경우, 그렇지 않으면 0)</target>
        </trans-unit>
        <trans-unit id="e356bc07e535e04e9d9c3334c083fcc3488e0bee" translate="yes" xml:space="preserve">
          <source>Maximum value of semaphore</source>
          <target state="translated">세마포의 최대 값</target>
        </trans-unit>
        <trans-unit id="d73ff195380431a5bbd14d7218270378e35474ca" translate="yes" xml:space="preserve">
          <source>Maximum value of the sequence</source>
          <target state="translated">시퀀스의 최대 값</target>
        </trans-unit>
        <trans-unit id="c94f479833c5d401cffdfa7afe6c9c2d56448019" translate="yes" xml:space="preserve">
          <source>May</source>
          <target state="translated">May</target>
        </trans-unit>
        <trans-unit id="9a0ffa2f24694ff69c95e89a55aa229e9cda8b30" translate="yes" xml:space="preserve">
          <source>Mean time spent executing the statement, in milliseconds</source>
          <target state="translated">명령문 실행에 소요 된 평균 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="181d211e960e06792dfe28bfac1abd601a4c5a9d" translate="yes" xml:space="preserve">
          <source>Mean time spent in the statement, in milliseconds</source>
          <target state="translated">명령문에서 소요 된 평균 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="e1349b1d8078a8f519127952739b8b28f7e70925" translate="yes" xml:space="preserve">
          <source>Mean time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">문을 계획하는 데 소요 된 평균 시간 (밀리 초) ( &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; 이 활성화 된 경우, 그렇지 않으면 0)</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f0f833c6521b2d19b94ba8d0789e74dc9ccb5388" translate="yes" xml:space="preserve">
          <source>Measuring Executor Timing Overhead</source>
          <target state="translated">집행자 타이밍 오버 헤드 측정</target>
        </trans-unit>
        <trans-unit id="1c83efb5aa232017e707b79cbf793fdfcf4c42d0" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name is a named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules of an identifier, it must be enclosed in double quotes as a character string literal.</source>
          <target state="translated">지정된 키를 가진 개체 멤버를 반환하는 멤버 접근 자입니다. 키 이름이 &lt;code&gt;$&lt;/code&gt; 로 시작하는 명명 된 변수 이거나 식별자의 JavaScript 규칙을 충족하지 않는 경우 큰 따옴표로 문자열 리터럴로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="016eb9bcfce0ff8bda70ffdf100d2c6f5e38a6fe" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name matches some named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules for an identifier, it must be enclosed in double quotes to make it a string literal.</source>
          <target state="translated">지정된 키를 사용하여 개체 멤버를 반환하는 멤버 접근 자입니다. 키 이름이 &lt;code&gt;$&lt;/code&gt; 로 시작하는 일부 명명 된 변수와 일치 하거나 식별자에 대한 JavaScript 규칙을 충족하지 않는 경우 문자열 리터럴이되도록 큰 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="dc3e8f88c1e4c9777ada8c4e159672ef60421a6a" translate="yes" xml:space="preserve">
          <source>Merge join requires its input data to be sorted on the join keys. In this plan the &lt;code&gt;tenk1&lt;/code&gt; data is sorted by using an index scan to visit the rows in the correct order, but a sequential scan and sort is preferred for &lt;code&gt;onek&lt;/code&gt;, because there are many more rows to be visited in that table. (Sequential-scan-and-sort frequently beats an index scan for sorting many rows, because of the nonsequential disk access required by the index scan.)</source>
          <target state="translated">병합 결합에서는 입력 데이터를 결합 키에서 정렬해야합니다. 이 계획에서 &lt;code&gt;tenk1&lt;/code&gt; 데이터는 인덱스 스캔을 사용하여 올바른 순서로 행을 방문하여 정렬되지만 해당 테이블에 방문 할 행이 더 많으므로 &lt;code&gt;onek&lt;/code&gt; 에 대해 순차적 스캔 및 정렬이 선호됩니다 . (순차 스캔 및 정렬은 인덱스 스캔에 필요한 비 순차 디스크 액세스로 인해 많은 행을 정렬하기 위해 인덱스 스캔을 자주 능가합니다.)</target>
        </trans-unit>
        <trans-unit id="5df467aa951005c5f7e89731194b036d002c4227" translate="yes" xml:space="preserve">
          <source>Merge joins also have measurement artifacts that can confuse the unwary. A merge join will stop reading one input if it's exhausted the other input and the next key value in the one input is greater than the last key value of the other input; in such a case there can be no more matches and so no need to scan the rest of the first input. This results in not reading all of one child, with results like those mentioned for &lt;code&gt;LIMIT&lt;/code&gt;. Also, if the outer (first) child contains rows with duplicate key values, the inner (second) child is backed up and rescanned for the portion of its rows matching that key value. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; counts these repeated emissions of the same inner rows as if they were real additional rows. When there are many outer duplicates, the reported actual row count for the inner child plan node can be significantly larger than the number of rows that are actually in the inner relation.</source>
          <target state="translated">또한 병합 조인에는 측정 아티팩트가있어 경고를 혼란스럽게 할 수 있습니다. 병합 조인은 다른 입력이 소진되고 한 입력의 다음 키 값이 다른 입력의 마지막 키 값보다 큰 경우 한 입력 읽기를 중지합니다. 이러한 경우 더 이상 일치하는 항목이 없으므로 나머지 첫 번째 입력을 스캔 할 필요가 없습니다. 이로 인해 한 명의 자녀를 모두 읽지 못하고 &lt;code&gt;LIMIT&lt;/code&gt; 에 대해 언급 한 것과 같은 결과가 나타납니다 . 또한 외부 (첫 번째) 하위 항목에 중복 키 값이있는 행이 포함되어 있으면 내부 (두 번째) 하위 항목이 해당 키 값과 일치하는 행 부분을 백업하고 다시 스캔합니다. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 동일한 내부 열의 반복 배출을 실제 추가 열인 것처럼 계산합니다. 외부 복제본이 많은 경우 내부 하위 계획 노드에 대해보고 된 실제 행 수는 실제로 내부 관계에있는 행 수보다 훨씬 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6317b9601e7c09c328490aa43dfe87e04fe54d" translate="yes" xml:space="preserve">
          <source>Messages like this indicate that you contacted the server, and it is willing to talk to you, but not until you pass the authorization method specified in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file. Check the password you are providing, or check your Kerberos or ident software if the complaint mentions one of those authentication types.</source>
          <target state="translated">이와 같은 메시지는 서버에 접속했음을 나타내며 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일에 지정된 권한 부여 방법을 통과 할 때까지는 대화 할 의사가 없습니다 . 제공 한 비밀번호를 확인하거나 불만 사항에 해당 인증 유형 중 하나가 언급 된 경우 Kerberos 또는 ID 소프트웨어를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9c2097f911138f2466e5f32e8351dcd5fd749692" translate="yes" xml:space="preserve">
          <source>Meta-Commands</source>
          <target state="translated">Meta-Commands</target>
        </trans-unit>
        <trans-unit id="f693f5960d30f7053e205f6d9a4425df858962e1" translate="yes" xml:space="preserve">
          <source>Metaphone, like Soundex, is based on the idea of constructing a representative code for an input string. Two strings are then deemed similar if they have the same codes.</source>
          <target state="translated">Soundex와 같은 메타 폰은 입력 문자열에 대한 대표 코드를 구성한다는 아이디어를 기반으로합니다. 두 개의 문자열이 동일한 코드를 갖는 경우 두 개의 문자열이 유사한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c1b37b805340abcc2257db6a661352b683548e" translate="yes" xml:space="preserve">
          <source>Method used for forcing WAL updates out to disk. If &lt;code&gt;fsync&lt;/code&gt; is off then this setting is irrelevant, since WAL file updates will not be forced out at all. Possible values are:</source>
          <target state="translated">WAL 업데이트를 디스크에 적용하는 데 사용되는 방법입니다. &lt;code&gt;fsync&lt;/code&gt; 가 꺼져 있으면 WAL 파일 업데이트가 전혀 적용되지 않으므로이 설정은 관련이 없습니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="628dc441c2bafa1afab14e359fb44c6e901b8f85" translate="yes" xml:space="preserve">
          <source>Michael J. Fromberger</source>
          <target state="translated">마이클 제이 프롬 버거</target>
        </trans-unit>
        <trans-unit id="06fca8ee037d3a593497ab6d139577328dd86787" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C</source>
          <target state="translated">마이크로 소프트 비주얼 C</target>
        </trans-unit>
        <trans-unit id="f0e91d657447be038c5b83745dffb09499d6baf9" translate="yes" xml:space="preserve">
          <source>Military abbreviation for UTC</source>
          <target state="translated">UTC의 군사 약어</target>
        </trans-unit>
        <trans-unit id="7eb0cee888ab55b559592d38eec027e9118d7d35" translate="yes" xml:space="preserve">
          <source>Min</source>
          <target state="translated">Min</target>
        </trans-unit>
        <trans-unit id="0d47fa8c3e389b0763d87f2daa4ec6a50fb18dc1" translate="yes" xml:space="preserve">
          <source>Minimum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">매개 변수의 최소 허용 값 (숫자가 아닌 값의 경우 널)</target>
        </trans-unit>
        <trans-unit id="c5ae78e276525910ef27ff7ddf6b5c2559e2cb00" translate="yes" xml:space="preserve">
          <source>Minimum number of concurrent open transactions to require before performing the &lt;code&gt;commit_delay&lt;/code&gt; delay. A larger value makes it more probable that at least one other transaction will become ready to commit during the delay interval. The default is five transactions.</source>
          <target state="translated">&lt;code&gt;commit_delay&lt;/code&gt; 지연을 수행하기 전에 필요한 최소 동시 공개 트랜잭션 수 . 값이 클수록 지연 간격 동안 하나 이상의 다른 트랜잭션이 커밋 할 준비가 될 가능성이 높아집니다. 디폴트는 5 개의 트랜잭션입니다.</target>
        </trans-unit>
        <trans-unit id="0fb2ca68f01f33cc64d2c1311c2afe2326caa75d" translate="yes" xml:space="preserve">
          <source>Minimum scale (number of fractional decimal digits) needed to represent the supplied value precisely</source>
          <target state="translated">제공된 값을 정확하게 표현하는 데 필요한 최소 스케일 (소수 소수 자릿수)</target>
        </trans-unit>
        <trans-unit id="c373999e365b4d5993611993a45677502343dcde" translate="yes" xml:space="preserve">
          <source>Minimum size of shared memory segment (bytes)</source>
          <target state="translated">공유 메모리 세그먼트의 최소 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="78afeaf9c6ff0f3ee6d2c5532d4ad21e157dee73" translate="yes" xml:space="preserve">
          <source>Minimum time spent executing the statement, in milliseconds</source>
          <target state="translated">명령문 실행에 소요 된 최소 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="613154c6477db737a4ffc935d45b4f35e3a112f3" translate="yes" xml:space="preserve">
          <source>Minimum time spent in the statement, in milliseconds</source>
          <target state="translated">명령문에서 소요 된 최소 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="f3052f7c6782d78980f79d735a2525db3585b208" translate="yes" xml:space="preserve">
          <source>Minimum time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">명령문을 계획하는 데 소요 된 최소 시간 (밀리 초) ( &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; 이 활성화 된 경우, 그렇지 않으면 0)</target>
        </trans-unit>
        <trans-unit id="9119800734f587e7d9508436d6ce2f949b6a319c" translate="yes" xml:space="preserve">
          <source>Minimum value of the sequence</source>
          <target state="translated">시퀀스의 최소값</target>
        </trans-unit>
        <trans-unit id="f39b9975fa394daf9211460e65ad5e53c2e0737a" translate="yes" xml:space="preserve">
          <source>Minor releases never change the internal storage format and are always compatible with earlier and later minor releases of the same major version number. For example, version 10.1 is compatible with version 10.0 and version 10.6. Similarly, for example, 9.5.3 is compatible with 9.5.0, 9.5.1, and 9.5.6. To update between compatible versions, you simply replace the executables while the server is down and restart the server. The data directory remains unchanged &amp;mdash; minor upgrades are that simple.</source>
          <target state="translated">부 릴리스는 내부 저장소 형식을 변경하지 않으며 항상 동일한 주 버전 번호의 이전 및 이후 부 릴리스와 호환됩니다. 예를 들어, 버전 10.1은 버전 10.0 및 버전 10.6과 호환됩니다. 마찬가지로 예를 들어 9.5.3은 9.5.0, 9.5.1 및 9.5.6과 호환됩니다. 호환되는 버전간에 업데이트하려면 서버가 다운 된 상태에서 실행 파일을 교체하고 서버를 다시 시작하면됩니다. 데이터 디렉토리는 변경되지 않은 상태로 유지됩니다. 간단한 업그레이드는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c1792a6389bbff158897922be21e2febd6b41e73" translate="yes" xml:space="preserve">
          <source>Minor updates to this package were made by Bruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; in August/September of 2002. These include changing the precision from single precision to double precision and adding some new functions.</source>
          <target state="translated">이 패키지에 대한 약간의 업데이트 는 2002 년 8 월 / 9 월 에 Bruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; 에 의해 이루어졌습니다 . 여기에는 정밀도를 단 정밀도에서 배정 밀도로 변경하고 새로운 기능을 추가하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="026961d2894207df681418954ca48774a983ec15" translate="yes" xml:space="preserve">
          <source>Minus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">SQL / JSON 시퀀스를 반복하는 빼기 연산자</target>
        </trans-unit>
        <trans-unit id="dc6ddd468d33fb3431787f38241bee7260f00eb6" translate="yes" xml:space="preserve">
          <source>Minutes (in the time part)</source>
          <target state="translated">분 (시간 부분)</target>
        </trans-unit>
        <trans-unit id="dc12f1b1cf6a0bbb2272d3d7ce2040c69a7ecda0" translate="yes" xml:space="preserve">
          <source>Mixed Interval</source>
          <target state="translated">혼합 간격</target>
        </trans-unit>
        <trans-unit id="70c257e1738553c63bcb8eca3e2dc0f60349ef49" translate="yes" xml:space="preserve">
          <source>Mixing temporary and permanent relations in the same partition tree is not allowed. Hence, if the partitioned table is permanent, so must be its partitions and likewise if the partitioned table is temporary. When using temporary relations, all members of the partition tree have to be from the same session.</source>
          <target state="translated">동일한 파티션 트리에서 임시 관계와 영구 관계를 혼합 할 수 없습니다. 따라서 파티션 된 테이블이 영구적이면 파티션 된 테이블과 마찬가지로 파티션 된 테이블도 영구적이어야합니다. 임시 관계를 사용할 때 파티션 트리의 모든 구성원은 동일한 세션에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="b543d8b0cd27fd8c88c5dd290fcb9193a6d18588" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.26&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="translated">수정자를 모든 템플릿 패턴에 적용하여 동작을 변경할 수 있습니다. 예를 들어 &lt;code&gt;FMMonth&lt;/code&gt; 는 &lt;code&gt;FM&lt;/code&gt; 수정자를 사용하는 &lt;code&gt;Month&lt;/code&gt; 패턴입니다 . &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;표 9.26&lt;/a&gt; 은 날짜 / 시간 형식에 대한 수정 자 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="aa8e787d356e5a4bed4106486ef340d55a04bda6" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.27&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="translated">모든 템플릿 패턴에 수정자를 적용하여 동작을 변경할 수 있습니다. 예를 들어 &lt;code&gt;FMMonth&lt;/code&gt; 는 &lt;code&gt;FM&lt;/code&gt; 수정자가 있는 &lt;code&gt;Month&lt;/code&gt; 패턴입니다 . &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;표 9.27&lt;/a&gt; 은 날짜 / 시간 형식화에 대한 수정 자 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ca58f6edfb3451890686c36bc73c14bf67559162" translate="yes" xml:space="preserve">
          <source>Modify an existing record using the values from an &lt;code&gt;hstore&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 값을 사용하여 기존 레코드를 수정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f15aa8ca874492770383bfd8d9e19998f3752e1" translate="yes" xml:space="preserve">
          <source>Modifying Tables</source>
          <target state="translated">테이블 수정</target>
        </trans-unit>
        <trans-unit id="a72464d357e833dd19b1829bd5b00731edf82afe" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Column</source>
          <target state="translated">테이블 수정 : 열 추가</target>
        </trans-unit>
        <trans-unit id="b0a82b15be32cf23af7a5403931cbba2c3a6b302" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Constraint</source>
          <target state="translated">테이블 수정 : 구속 조건 추가</target>
        </trans-unit>
        <trans-unit id="8c76fff9cefc32ac15f30b5883253ecb9faf24b5" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Data Type</source>
          <target state="translated">테이블 수정 : 열의 데이터 유형 변경</target>
        </trans-unit>
        <trans-unit id="bad9bdb3a7e14e2048b20553d6893b9f2daeb0f9" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Default Value</source>
          <target state="translated">테이블 수정 : 열의 기본값 변경</target>
        </trans-unit>
        <trans-unit id="8649a9592e4298a7e8e6b1abb9ef2b90d9a5be2a" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Column</source>
          <target state="translated">테이블 수정 : 열 제거</target>
        </trans-unit>
        <trans-unit id="98650a2f5b97076e75384a35883a830ea83870d0" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Constraint</source>
          <target state="translated">테이블 수정 : 구속 조건 제거</target>
        </trans-unit>
        <trans-unit id="6ee7fe42d54596a2449882ee5313efaaa712af34" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Column</source>
          <target state="translated">테이블 수정 : 열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="dc81484063645f8a58302e10322fd29ad17f1b92" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Table</source>
          <target state="translated">테이블 수정 : 테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c1e625a012d4612de9e088d7c2a093342964bb1f" translate="yes" xml:space="preserve">
          <source>Modifying a partitioned table or a table with inheritance children fires statement-level triggers attached to the explicitly named table, but not statement-level triggers for its partitions or child tables. In contrast, row-level triggers are fired on the rows in affected partitions or child tables, even if they are not explicitly named in the query. If a statement-level trigger has been defined with transition relations named by a &lt;code&gt;REFERENCING&lt;/code&gt; clause, then before and after images of rows are visible from all affected partitions or child tables. In the case of inheritance children, the row images include only columns that are present in the table that the trigger is attached to. Currently, row-level triggers with transition relations cannot be defined on partitions or inheritance child tables.</source>
          <target state="translated">상속 된 자식이있는 테이블 또는 분할 된 테이블을 수정하면 명시 적으로 명명 된 테이블에 연결된 문 수준 트리거가 발생하지만 해당 파티션 또는 자식 테이블에 대한 문 수준 트리거는 실행되지 않습니다. 반대로 행 수준 트리거는 쿼리에서 명시 적으로 이름이 지정되지 않은 경우에도 영향을받는 파티션 또는 자식 테이블의 행에서 시작됩니다. 명령문 레벨 트리거가 &lt;code&gt;REFERENCING&lt;/code&gt; 절로 이름 지정된 전이 관계로 정의 된 경우, 행의 전후 이미지가 영향을받는 모든 파티션 또는 하위 테이블에서 볼 수 있습니다. 상속 하위의 경우 행 이미지에는 트리거가 첨부 된 테이블에 존재하는 열만 포함됩니다. 현재, 전환 관계가있는 행 레벨 트리거는 파티션 또는 상속 하위 테이블에서 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a03c6c23d3b223671b9d8eba84851fccb59e4a7" translate="yes" xml:space="preserve">
          <source>Module for storing (key, value) pairs</source>
          <target state="translated">(키, 값) 쌍을 저장하기위한 모듈</target>
        </trans-unit>
        <trans-unit id="8f46472981bee7fae7b3d41646aaa681175d3eb8" translate="yes" xml:space="preserve">
          <source>Modulo (remainder)</source>
          <target state="translated">모듈로 (나머지)</target>
        </trans-unit>
        <trans-unit id="0216fd9c439582b27771fa19ad3c81fdf577f4c0" translate="yes" xml:space="preserve">
          <source>Modulo (remainder); available for &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="translated">모듈로 (나머지); 사용할 수 &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; 및 &lt;code&gt;numeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58a0f28806f53fd75308c3f2a793267cf1428ae8" translate="yes" xml:space="preserve">
          <source>Modulus</source>
          <target state="translated">Modulus</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="6463498da98840aa3b093c82890614171c30b5ef" translate="yes" xml:space="preserve">
          <source>Monetary Types</source>
          <target state="translated">화폐 유형</target>
        </trans-unit>
        <trans-unit id="881c22df54316f0107467a0277ce497e98935f6d" translate="yes" xml:space="preserve">
          <source>Monetary Types: money</source>
          <target state="translated">통화 유형 : 돈</target>
        </trans-unit>
        <trans-unit id="a81434589757e654444719de434c44e9adc0c708" translate="yes" xml:space="preserve">
          <source>Monitoring</source>
          <target state="translated">Monitoring</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="ca09870a2f60b20cbbb11a8f1bfa5c112c7f2481" translate="yes" xml:space="preserve">
          <source>Months (in the date part)</source>
          <target state="translated">월 (일자 부분)</target>
        </trans-unit>
        <trans-unit id="b362fae8ba4022e7ee2c51f663135e4f46fe57f1" translate="yes" xml:space="preserve">
          <source>More about &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;dropdb&lt;/code&gt; can be found in &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; and &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; respectively.</source>
          <target state="translated">&lt;code&gt;createdb&lt;/code&gt; 및 &lt;code&gt;dropdb&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; 및 &lt;a href=&quot;app-dropdb&quot;&gt;dropdb에서&lt;/a&gt; 각각 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d8a150db9b3697af1b840b6b8689717b67bec26" translate="yes" xml:space="preserve">
          <source>More complex grouping operations than those described above are possible using the concept of &lt;em&gt;grouping sets&lt;/em&gt;. The data selected by the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses is grouped separately by each specified grouping set, aggregates computed for each group just as for simple &lt;code&gt;GROUP BY&lt;/code&gt; clauses, and then the results returned. For example:</source>
          <target state="translated">그룹화 개념을 사용하여 위에서 설명한 것보다 더 복잡한 그룹화 작업이 가능 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;FROM&lt;/code&gt; 및 &lt;code&gt;WHERE&lt;/code&gt; 절에 의해 선택된 데이터 는 지정된 각 그룹화 세트별로 개별적으로 그룹화되고 단순 &lt;code&gt;GROUP BY&lt;/code&gt; 절과 마찬가지로 각 그룹에 대해 집계 된 계산 결과가 리턴됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32d9dc5690a3f6016671ea3b2ef25dc790df4069" translate="yes" xml:space="preserve">
          <source>More complex usage can produce undesirable results in Read Committed mode. For example, consider a &lt;code&gt;DELETE&lt;/code&gt; command operating on data that is being both added and removed from its restriction criteria by another command, e.g., assume &lt;code&gt;website&lt;/code&gt; is a two-row table with &lt;code&gt;website.hits&lt;/code&gt; equaling &lt;code&gt;9&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;:</source>
          <target state="translated">더 복잡한 사용법은 읽기 커밋 모드에서 바람직하지 않은 결과를 생성 할 수 있습니다. 예를 들어, 고려 &lt;code&gt;DELETE&lt;/code&gt; , 예를 들어, 모두 다른 명령하여 제한 기준에서 추가 및 삭제되는 데이터에 명령의 운영을 가정 &lt;code&gt;website&lt;/code&gt; 있는 2 열 테이블 &lt;code&gt;website.hits&lt;/code&gt; 가 동등 해 &lt;code&gt;9&lt;/code&gt; 및 &lt;code&gt;10&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aa123892162b2a296320ac735b855a11c0d07673" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="translated">윈도우 함수에 대한 자세한 정보는에서 찾을 수 있습니다 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;섹션 4.2.8&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;섹션 9.21&lt;/a&gt; , &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;섹션 7.2.5&lt;/a&gt; , 그리고 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61e5e0cc940bc717e85dc5f00f1f583f6b05a316" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="translated">창 기능에 대한 자세한 내용은 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;섹션 4.2.8&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;섹션 9.22&lt;/a&gt; , &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;섹션 7.2.5&lt;/a&gt; 및 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 참조 페이지에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbf3214eaae892986b24caa3a28e76373d96aaab" translate="yes" xml:space="preserve">
          <source>More examples of using &lt;code&gt;jsonpath&lt;/code&gt; operators and methods within path expressions appear below in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;.</source>
          <target state="translated">경로 표현식 내에서 &lt;code&gt;jsonpath&lt;/code&gt; 연산자 및 메서드 를 사용하는 더 많은 예제는 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;섹션 9.16.2.2에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b706c980fab74ceb0b82c89e1d0e57333d172c3f" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="translated">적절한 입력 및 출력 기능을 포함한 더 많은 예는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;37.13 절에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2b364915a6606c0ca2495dd2cb97f36c000aeda" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="translated">적절한 입력 및 출력 기능을 포함한 더 많은 예제는 &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html&quot;&gt;섹션 37.13에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
