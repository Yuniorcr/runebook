<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="833c4d41d72807ff8bff00dc171b711add76bff2" translate="yes" xml:space="preserve">
          <source>This node's LSN at which &lt;code&gt;remote_lsn&lt;/code&gt; has been replicated. Used to flush commit records before persisting data to disk when using asynchronous commits.</source>
          <target state="translated">&lt;code&gt;remote_lsn&lt;/code&gt; 이 복제 된이 노드의 LSN 입니다. 비동기 커밋을 사용할 때 디스크에 데이터를 유지하기 전에 커밋 레코드를 플러시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="388063f0d1bc8c68724a848b5427707b09f5e0a2" translate="yes" xml:space="preserve">
          <source>This notation behaves differently depending on context; see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt; for details.</source>
          <target state="translated">이 표기법은 상황에 따라 다르게 작동합니다. 자세한 내용 &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;은 8.16.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff98e9774f8c6e6fad6dce4d14a177af4ff71408" translate="yes" xml:space="preserve">
          <source>This operator supports hash joins</source>
          <target state="translated">이 연산자는 해시 조인을 지원합니다</target>
        </trans-unit>
        <trans-unit id="2c90e947b03275ac339cbaa9aa960fdd656aa3ae" translate="yes" xml:space="preserve">
          <source>This operator supports merge joins</source>
          <target state="translated">이 연산자는 병합 조인을 지원합니다</target>
        </trans-unit>
        <trans-unit id="033a065728054a33c7f38b0e616194e5c2c3aaa5" translate="yes" xml:space="preserve">
          <source>This option allows running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 server, see the documentation of the &lt;code&gt;-j&lt;/code&gt; parameter for more details.</source>
          <target state="translated">이 옵션을 사용하면 9.2 이전 서버 에서 &lt;code&gt;pg_dump -j&lt;/code&gt; 를 실행할 수 있습니다 . 자세한 내용 은 &lt;code&gt;-j&lt;/code&gt; 매개 변수 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67692a76bdedd175ae4ea2832082e8bfa1d20815" translate="yes" xml:space="preserve">
          <source>This option always affects transfer of the data directory. Transfer of WAL files is only affected if the collection method is &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 항상 데이터 디렉토리 전송에 영향을줍니다. WAL 파일의 전송은 수집 방법이 &lt;code&gt;fetch&lt;/code&gt; 경우에만 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="66b9c3dfa7b75f649757901e5e89c1862e7c3ada" translate="yes" xml:space="preserve">
          <source>This option can be set by any user. Because of that, the libraries that can be loaded are restricted to those appearing in the &lt;code&gt;plugins&lt;/code&gt; subdirectory of the installation's standard library directory. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.) Entries in &lt;code&gt;local_preload_libraries&lt;/code&gt; can specify this directory explicitly, for example &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt;, or just specify the library name &amp;mdash; &lt;code&gt;mylib&lt;/code&gt; would have the same effect as &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 모든 사용자가 설정할 수 있습니다. 따라서로드 할 수있는 라이브러리 는 설치 표준 라이브러리 디렉토리의 &lt;code&gt;plugins&lt;/code&gt; 서브 디렉토리에 나타나는 라이브러리로 제한됩니다 . (&amp;ldquo;안전한&amp;rdquo;라이브러리 만 설치하는 것은 데이터베이스 관리자의 책임입니다.) &lt;code&gt;local_preload_libraries&lt;/code&gt; 의 항목은 이 디렉토리를 명시 적으로 지정하거나 ( 예 &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt; ) 라이브러리 이름 만 지정할 수 있습니다. &lt;code&gt;mylib&lt;/code&gt; 는 동일합니다 등의 효과 &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a0fc1ca8b2fbb1af9a9d77b22b8df428dc16da8" translate="yes" xml:space="preserve">
          <source>This option can only be used in combination with one or more &lt;code&gt;-c&lt;/code&gt; and/or &lt;code&gt;-f&lt;/code&gt; options. It causes psql to issue a &lt;code&gt;BEGIN&lt;/code&gt; command before the first such option and a &lt;code&gt;COMMIT&lt;/code&gt; command after the last one, thereby wrapping all the commands into a single transaction. This ensures that either all the commands complete successfully, or no changes are applied.</source>
          <target state="translated">이 옵션은 하나 이상의 &lt;code&gt;-c&lt;/code&gt; 및 / 또는 &lt;code&gt;-f&lt;/code&gt; 옵션 과 함께 사용해야 합니다. psql 은 첫 번째 옵션 이전에 &lt;code&gt;BEGIN&lt;/code&gt; 명령을 실행 하고 마지막 옵션 뒤에 &lt;code&gt;COMMIT&lt;/code&gt; 명령 을 발행하여 모든 명령을 단일 트랜잭션으로 랩핑합니다. 이렇게하면 모든 명령이 성공적으로 완료되거나 변경 사항이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd1e801996f18e878c7421f7a76634808df68609" translate="yes" xml:space="preserve">
          <source>This option can only be used together with &lt;code&gt;-X stream&lt;/code&gt;. It causes WAL streaming to use the specified replication slot. If the base backup is intended to be used as a streaming-replication standby using a replication slot, the standby should then use the same replication slot name as &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt;. This ensures that the primary server does not remove any necessary WAL data in the time between the end of the base backup and the start of streaming replication on the new standby.</source>
          <target state="translated">이 옵션은 &lt;code&gt;-X stream&lt;/code&gt; 과 함께 만 사용할 수 있습니다 . WAL 스트리밍이 지정된 복제 슬롯을 사용하도록합니다. 기본 백업이 복제 슬롯을 사용하는 스트리밍 복제 대기로 사용하려는 경우 대기는 &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt; 과 동일한 복제 슬롯 이름을 사용해야합니다 . 이렇게하면 기본 서버가 기본 백업이 끝나고 새 대기에서 스트리밍 복제가 시작될 때까지 필요한 WAL 데이터를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4af26bb42d56efbdd77ea30d507197b50c1c0a6e" translate="yes" xml:space="preserve">
          <source>This option can only be used together with &lt;code&gt;-X stream&lt;/code&gt;. It causes the WAL streaming to use the specified replication slot. If the base backup is intended to be used as a streaming replication standby using replication slots, it should then use the same replication slot name in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt;. That way, it is ensured that the server does not remove any necessary WAL data in the time between the end of the base backup and the start of streaming replication.</source>
          <target state="translated">이 옵션은 &lt;code&gt;-X stream&lt;/code&gt; 과 함께 만 사용할 수 있습니다 . WAL 스트리밍이 지정된 복제 슬롯을 사용하게합니다. 기본 백업을 복제 슬롯을 사용하여 스트리밍 복제 대기로 사용하려는 경우 &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt; 에서 동일한 복제 슬롯 이름을 사용해야합니다 . 이렇게하면 서버가 기본 백업 종료와 스트리밍 복제 시작 사이의 시간에 필요한 WAL 데이터를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dcf604d43dc6007ea78136bf7b33be7b4e62ae3" translate="yes" xml:space="preserve">
          <source>This option cannot be used to remove the support function altogether, since it must name a new support function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; if you need to do that.</source>
          <target state="translated">이 옵션은 새로운 지원 기능의 이름을 지정해야하기 때문에 지원 기능을 완전히 제거하는 데 사용할 수 없습니다. 필요한 경우 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd8d44929298a4cbf2c87cec1c31093bc64b155b" translate="yes" xml:space="preserve">
          <source>This option causes &lt;code&gt;pg_receivewal&lt;/code&gt; to not force WAL data to be flushed to disk. This is faster, but means that a subsequent operating system crash can leave the WAL segments corrupt. Generally, this option is useful for testing but should not be used when doing WAL archiving on a production deployment.</source>
          <target state="translated">이 옵션은 &lt;code&gt;pg_receivewal&lt;/code&gt; 이 WAL 데이터를 디스크로 강제로 플러시하지 않도록합니다. 이 속도는 빠르지 만 후속 운영 체제 충돌로 인해 WAL 세그먼트가 손상 될 수 있습니다. 일반적으로이 옵션은 테스트에 유용하지만 프로덕션 배포에서 WAL 보관을 수행 할 때는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0a83f03d78ff431f987c79d1993890ac0162fd03" translate="yes" xml:space="preserve">
          <source>This option causes creation of a replication slot named by the &lt;code&gt;--slot&lt;/code&gt; option before starting the backup. An error is raised if the slot already exists.</source>
          <target state="translated">이 옵션은 백업을 시작하기 전에 &lt;code&gt;--slot&lt;/code&gt; 옵션으로 이름 지정된 복제 슬롯을 생성 합니다. 슬롯이 이미 존재하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="019a3bff9bc43aecc3893ea645652e695f875fd1" translate="yes" xml:space="preserve">
          <source>This option controls the behavior of automatically updatable views. When this option is specified, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands on the view will be checked to ensure that new rows satisfy the view-defining condition (that is, the new rows are checked to ensure that they are visible through the view). If they are not, the update will be rejected. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is not specified, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands on the view are allowed to create rows that are not visible through the view. The following check options are supported:</source>
          <target state="translated">이 옵션은 자동으로 업데이트 가능한보기의 동작을 제어합니다. 이 옵션이 지정되면 새 행이보기 정의 조건을 충족하는지 확인하기 위해보기 에서 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 명령이 점검됩니다 (즉, 새 행이보기를 통해 표시되는지 확인). 그렇지 않으면 업데이트가 거부됩니다. 는 IF &lt;code&gt;CHECK OPTION&lt;/code&gt; 지정되지 않은, &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 뷰에 대한 명령은보기를 통해 볼 수 없습니다 행을 만들 수 있습니다. 다음 점검 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa12085b7bbeed5763de22cebaafe8cc79d4acb" translate="yes" xml:space="preserve">
          <source>This option controls whether &lt;code&gt;postgres_fdw&lt;/code&gt; allows foreign tables to be modified using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. It can be specified for a foreign table or a foreign server. A table-level option overrides a server-level option. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;postgres_fdw&lt;/code&gt; 가 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 명령을 사용하여 외부 테이블을 수정할 수 있는지 여부를 제어합니다 . 외부 테이블 또는 외부 서버에 지정할 수 있습니다. 테이블 수준 옵션은 서버 수준 옵션보다 우선합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c306234b370cc56fe65c31871921559cfe86c86e" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;COLLATE&lt;/code&gt; options are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;true&lt;/code&gt;. You might need to turn this off if the remote server has a different set of collation names than the local server does, which is likely to be the case if it's running on a different operating system.</source>
          <target state="translated">이 옵션은 &lt;code&gt;COLLATE&lt;/code&gt; 옵션 열 이 외부 서버에서 가져온 외부 테이블의 정의에 포함 되는지 여부를 제어합니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 원격 서버에 로컬 서버와 다른 데이터 정렬 이름 세트가있는 경우이 기능을 해제해야 할 수 있습니다. 다른 운영 체제에서 실행중인 경우 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a2c7892fe0f505a8ed2a71e7d9d8917529e89f4" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;DEFAULT&lt;/code&gt; expressions are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;false&lt;/code&gt;. If you enable this option, be wary of defaults that might get computed differently on the local server than they would be on the remote server; &lt;code&gt;nextval()&lt;/code&gt; is a common source of problems. The &lt;code&gt;IMPORT&lt;/code&gt; will fail altogether if an imported default expression uses a function or operator that does not exist locally.</source>
          <target state="translated">이 옵션 은 외부 서버에서 가져온 외부 테이블의 정의에 컬럼 &lt;code&gt;DEFAULT&lt;/code&gt; 표현식이 포함 되는지 여부를 제어합니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 이 옵션을 사용하면 로컬 서버에서 원격 서버와 다르게 계산 될 수있는 기본값에주의하십시오. &lt;code&gt;nextval()&lt;/code&gt; 은 일반적인 문제의 원인입니다. &lt;code&gt;IMPORT&lt;/code&gt; 는 수입 기본 표현 로컬 존재하지 않는 함수 나 연산자를 사용하는 경우 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c777fcd8f37f1faf36e546a259bf3994c8ebf0b0" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;NOT NULL&lt;/code&gt; constraints are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;NOT NULL&lt;/code&gt; 제한 조건 열 이 외부 서버에서 가져온 외부 테이블의 정의에 포함 되는지 여부를 제어합니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a4534428c01b535724cfe3334dea2585c43336e1" translate="yes" xml:space="preserve">
          <source>This option disables the use of dollar quoting for function bodies, and forces them to be quoted using SQL standard string syntax.</source>
          <target state="translated">이 옵션은 함수 본문에 달러 인용 사용을 비활성화하고 SQL 표준 문자열 구문을 사용하여 인용을 강제로 인용합니다.</target>
        </trans-unit>
        <trans-unit id="1e5b8577c4f91feed1cbbbf28c3713fcd0567f3a" translate="yes" xml:space="preserve">
          <source>This option dumps out the server's internal configuration variables, descriptions, and defaults in tab-delimited &lt;code&gt;COPY&lt;/code&gt; format. It is designed primarily for use by administration tools.</source>
          <target state="translated">이 옵션은 서버의 내부 구성 변수, 설명 및 기본값을 탭으로 구분 된 &lt;code&gt;COPY&lt;/code&gt; 형식으로 덤프 합니다. 주로 관리 도구에서 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="39d1d4f9b39a2419e5e71963676b76de7092eb75" translate="yes" xml:space="preserve">
          <source>This option has no effect on &lt;code&gt;-N&lt;/code&gt;/&lt;code&gt;--exclude-schema&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt;/&lt;code&gt;--exclude-table&lt;/code&gt;, or &lt;code&gt;--exclude-table-data&lt;/code&gt;. An exclude pattern failing to match any objects is not considered an error.</source>
          <target state="translated">이 옵션은 &lt;code&gt;-N&lt;/code&gt; / &lt;code&gt;--exclude-schema&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; / &lt;code&gt;--exclude-table&lt;/code&gt; 또는 &lt;code&gt;--exclude-table-data&lt;/code&gt; 에 영향을주지 않습니다 . 객체와 일치하지 않는 제외 패턴은 오류로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44b5c0279373253dcf944caef48c35c814e3748e" translate="yes" xml:space="preserve">
          <source>This option has the same effect as the option of the same name in &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;. See the description there.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt; 에서 같은 이름의 옵션과 동일한 효과를 갖습니다 . 거기에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e156f33e8e3c423b7dd6e39f40b8d2b97fdc7406" translate="yes" xml:space="preserve">
          <source>This option is a comma-separated list of names of PostgreSQL extensions that are installed, in compatible versions, on both the local and remote servers. Functions and operators that are immutable and belong to a listed extension will be considered shippable to the remote server. This option can only be specified for foreign servers, not per-table.</source>
          <target state="translated">이 옵션은 로컬 및 원격 서버 모두에 호환되는 버전으로 설치되는 쉼표로 구분 된 PostgreSQL 확장명 목록입니다. 변경할 수없고 나열된 확장에 속하는 기능과 연산자는 원격 서버로 배송 가능한 것으로 간주됩니다. 이 옵션은 테이블 당이 아닌 외부 서버에 대해서만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3ca03402c96b67aa550ad0869d48010fb66dab" translate="yes" xml:space="preserve">
          <source>This option is deprecated since it does not allow access to the full functionality of &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt;. It's usually better to set &lt;code&gt;listen_addresses&lt;/code&gt; directly.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt; 의 전체 기능에 대한 액세스를 허용하지 않으므로 더 이상 사용되지 않습니다 . 일반적으로 &lt;code&gt;listen_addresses&lt;/code&gt; 를 직접 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2b68d58ae84a3ecac214be2012e7c336871134f8" translate="yes" xml:space="preserve">
          <source>This option is effective only when restoring directly into a database, not when producing SQL script output.</source>
          <target state="translated">이 옵션은 SQL 스크립트 출력을 생성 할 때가 아니라 데이터베이스로 직접 복원 할 때만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="968dc4a560c532375e657416e7cf0bbd50ef3170" translate="yes" xml:space="preserve">
          <source>This option is for debugging problems that cause a server process to die abnormally. The ordinary strategy in this situation is to notify all other server processes that they must terminate and then reinitialize the shared memory and semaphores. This is because an errant server process could have corrupted some shared state before terminating. This option specifies that &lt;code&gt;postgres&lt;/code&gt; will not reinitialize shared data structures. A knowledgeable system programmer can then use a debugger to examine shared memory and semaphore state.</source>
          <target state="translated">이 옵션은 서버 프로세스가 비정상적으로 종료되는 문제를 디버깅하기위한 것입니다. 이 상황에서 일반적인 전략은 다른 모든 서버 프로세스에 공유 메모리와 세마포어를 종료 한 다음 다시 초기화해야한다는 것을 알리는 것입니다. 잘못된 서버 프로세스가 종료하기 전에 일부 공유 상태를 손상 시켰을 수 있기 때문입니다. 이 옵션은 &lt;code&gt;postgres&lt;/code&gt; 가 공유 데이터 구조를 다시 초기화하지 않도록 지정합니다 . 지식이 풍부한 시스템 프로그래머는 디버거를 사용하여 공유 메모리 및 세마포어 상태를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42927906afa65b972047e92608a8fe2f81b95297" translate="yes" xml:space="preserve">
          <source>This option is for debugging problems that cause a server process to die abnormally. The ordinary strategy in this situation is to notify all other server processes that they must terminate and then reinitialize the shared memory and semaphores. This is because an errant server process could have corrupted some shared state before terminating. This option specifies that &lt;code&gt;postgres&lt;/code&gt; will stop all other server processes by sending the signal &lt;code&gt;SIGSTOP&lt;/code&gt;, but will not cause them to terminate. This permits system programmers to collect core dumps from all server processes by hand.</source>
          <target state="translated">이 옵션은 서버 프로세스가 비정상적으로 종료되는 문제를 디버깅하기위한 것입니다. 이 상황에서 일반적인 전략은 다른 모든 서버 프로세스에 공유 메모리와 세마포어를 종료 한 다음 다시 초기화해야한다는 것을 알리는 것입니다. 잘못된 서버 프로세스가 종료하기 전에 일부 공유 상태를 손상 시켰을 수 있기 때문입니다. 이 옵션은 &lt;code&gt;postgres&lt;/code&gt; 가 &lt;code&gt;SIGSTOP&lt;/code&gt; 신호를 보내 다른 모든 서버 프로세스를 중지 하지만 종료 시키지는 않도록 지정합니다. 이를 통해 시스템 프로그래머는 모든 서버 프로세스에서 직접 코어 덤프를 수집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2fa6b1b1272f22fc7098675bb1c64f065394241" translate="yes" xml:space="preserve">
          <source>This option is for use by in-place upgrade utilities. Its use for other purposes is not recommended or supported. The behavior of the option may change in future releases without notice.</source>
          <target state="translated">이 옵션은 전체 업그레이드 유틸리티에서 사용됩니다. 다른 목적으로 사용하는 것은 권장되거나 지원되지 않습니다. 옵션의 동작은 향후 릴리스에서 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efc4bf4d899439505edd24a5ec7b6f3018597535" translate="yes" xml:space="preserve">
          <source>This option is incompatible with &lt;code&gt;--synchronous&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--synchronous&lt;/code&gt; 와 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1e4f9dc483d33770bfc633e073d626e91a285814" translate="yes" xml:space="preserve">
          <source>This option is like &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt;, but it describes the behavior of the moving-aggregate final function.</source>
          <target state="translated">이 옵션은 &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; 와 비슷 하지만 이동 집계 최종 함수의 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ae64748d4bfb71bb191824f72616015218279c62" translate="yes" xml:space="preserve">
          <source>This option is meant for other programs that interact with a server instance, such as &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;, to query configuration parameter values. User-facing applications should instead use &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; or the &lt;code&gt;pg_settings&lt;/code&gt; view.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; 과 같은 서버 인스턴스와 상호 작용하여 구성 매개 변수 값을 조회 하는 다른 프로그램에 사용 됩니다. 사용자 용 응용 프로그램은 &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; 또는 &lt;code&gt;pg_settings&lt;/code&gt; 뷰를 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="23fe24f85cebd351b3b05171efa5d22c8435d8a9" translate="yes" xml:space="preserve">
          <source>This option is never essential, since clusterdb will automatically prompt for a password if the server demands password authentication. However, clusterdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에서 비밀번호 인증이 필요한 경우 clusterdb가 비밀번호를 자동으로 프롬프트하므로이 옵션은 필수가 아닙니다. 그러나 clusterdb는 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f254a9b047ca402de17693af7a288974f935b320" translate="yes" xml:space="preserve">
          <source>This option is never essential, since createdb will automatically prompt for a password if the server demands password authentication. However, createdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에서 비밀번호 인증이 필요한 경우 createdb가 자동으로 비밀번호를 묻는 메시지를 표시하므로이 옵션은 반드시 필요한 것은 아닙니다. 그러나 createdb는 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="157ee8063fde732007da77e5a7853bb1478d9344" translate="yes" xml:space="preserve">
          <source>This option is never essential, since createuser will automatically prompt for a password if the server demands password authentication. However, createuser will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버가 비밀번호 인증을 요구하는 경우 createuser가 비밀번호를 자동으로 프롬프트하므로이 옵션은 필수가 아닙니다. 그러나 createuser는 서버가 비밀번호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a83ff3482275d0139a05f884462c1cbde3746882" translate="yes" xml:space="preserve">
          <source>This option is never essential, since dropdb will automatically prompt for a password if the server demands password authentication. However, dropdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버가 비밀번호 인증을 요구할 경우 dropdb가 비밀번호를 자동으로 프롬프트하므로이 옵션은 필수가 아닙니다. 그러나 dropdb는 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8e23fb76571b4a9d33af9f1ddf6f1f50ba682fde" translate="yes" xml:space="preserve">
          <source>This option is never essential, since dropuser will automatically prompt for a password if the server demands password authentication. However, dropuser will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에서 비밀번호 인증이 필요한 경우 dropuser가 비밀번호를 자동으로 프롬프트하므로이 옵션은 필수가 아닙니다. 그러나 dropuser는 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d7fdd419219d3924efcfbfee9fcca516b8868b92" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_basebackup will automatically prompt for a password if the server demands password authentication. However, pg_basebackup will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에서 비밀번호 인증이 필요한 경우 pg_basebackup에서 비밀번호를 자동으로 묻기 때문에이 옵션은 반드시 필요한 것은 아닙니다. 그러나 pg_basebackup은 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e876a82eec6b6016da4b2fff5952e7b1eae2117" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_dump will automatically prompt for a password if the server demands password authentication. However, pg_dump will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버가 비밀번호 인증을 요구하는 경우 pg_dump가 자동으로 비밀번호를 묻기 때문에이 옵션은 필수가 아닙니다. 그러나 pg_dump는 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="27e4143fa6008ebc17a6f2bd2303d88c172e5590" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_dumpall will automatically prompt for a password if the server demands password authentication. However, pg_dumpall will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버가 비밀번호 인증을 요구하는 경우 pg_dumpall이 자동으로 비밀번호를 묻는 메시지를 표시하므로이 옵션은 반드시 필요한 것은 아닙니다. 그러나 pg_dumpall은 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eb179ceeb157dc043c6e084a77ba22cf202bd214" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_receivewal will automatically prompt for a password if the server demands password authentication. However, pg_receivewal will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버가 비밀번호 인증을 요구하는 경우 pg_receivewal이 자동으로 비밀번호를 묻는 메시지를 표시하므로이 옵션은 반드시 필요한 것은 아닙니다. 그러나 pg_receivewal은 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f63e7019adc4bf629542d951d6d5ad2c631d4cd" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_recvlogical will automatically prompt for a password if the server demands password authentication. However, pg_recvlogical will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에서 비밀번호 인증이 필요한 경우 pg_recvlogical에서 비밀번호를 자동으로 묻기 때문에이 옵션은 반드시 필요한 것은 아닙니다. 그러나 pg_recvlogical은 서버가 암호를 원한다는 것을 알아 내기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c89398ef361ce35bb760f8007920d0c1cab1f07e" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_restore will automatically prompt for a password if the server demands password authentication. However, pg_restore will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에서 비밀번호 인증이 필요한 경우 pg_restore에서 비밀번호를 자동으로 묻기 때문에이 옵션은 반드시 필요한 것은 아닙니다. 그러나 pg_restore는 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95a2ae73f9f018a5089634f6a2f0aa09f43ae7cf" translate="yes" xml:space="preserve">
          <source>This option is never essential, since psql will automatically prompt for a password if the server demands password authentication. However, psql will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에서 비밀번호 인증이 필요한 경우 psql에서 비밀번호를 자동으로 프롬프트하므로이 옵션은 필수가 아닙니다. 그러나 psql은 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7a901f15557b845dee3a28d047b1c6eaa3bd5227" translate="yes" xml:space="preserve">
          <source>This option is never essential, since reindexdb will automatically prompt for a password if the server demands password authentication. However, reindexdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버가 비밀번호 인증을 요구하는 경우 reindexdb가 비밀번호를 자동으로 프롬프트하므로이 옵션은 반드시 필요한 것은 아닙니다. 그러나 reindexdb는 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dbc79a1fac3829f416356bb18d094f1758bd877c" translate="yes" xml:space="preserve">
          <source>This option is never essential, since vacuumdb will automatically prompt for a password if the server demands password authentication. However, vacuumdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에서 비밀번호 인증이 필요한 경우 vacuumdb가 자동으로 비밀번호를 묻는 메시지를 표시하므로이 옵션은 반드시 필요한 것은 아닙니다. 그러나 vacuumdb는 서버가 암호를 원한다는 것을 알기 위해 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dda9882d48af54bf77af6c2ab2fac746520d065c" translate="yes" xml:space="preserve">
          <source>This option is not allowed when using &lt;code&gt;--progress&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--progress&lt;/code&gt; 를 사용할 때 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cdca7882144557a657e3bff6adae96d14c901833" translate="yes" xml:space="preserve">
          <source>This option is not beneficial for a dump which is intended only for disaster recovery. It could be useful for a dump used to load a copy of the database for reporting or other read-only load sharing while the original database continues to be updated. Without it the dump may reflect a state which is not consistent with any serial execution of the transactions eventually committed. For example, if batch processing techniques are used, a batch may show as closed in the dump without all of the items which are in the batch appearing.</source>
          <target state="translated">이 옵션은 재난 복구 전용 덤프에는 유용하지 않습니다. 원래 데이터베이스가 계속 업데이트되는 동안보고 또는 기타 읽기 전용로드 공유를 위해 데이터베이스 사본을로드하는 데 사용되는 덤프에 유용 할 수 있습니다. 그것이 없으면 덤프는 결국 커밋 된 트랜잭션의 직렬 실행과 일치하지 않는 상태를 반영 할 수 있습니다. 예를 들어, 배치 처리 기술을 사용하는 경우 배치에있는 모든 항목이 나타나지 않고 배치에서 덤프가 닫힌 것으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1596ca6548e67cb8844cfbb65595e0b71113d97f" translate="yes" xml:space="preserve">
          <source>This option is obsolete but still accepted for backward compatibility.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않지만 이전 버전과의 호환성을 위해 여전히 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e30db5eac1f2738189322576d23177c26d58b051" translate="yes" xml:space="preserve">
          <source>This option is obsolete but still accepted for backwards compatibility.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않지만 이전 버전과의 호환성을 위해 여전히 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="227e2cf57ba512d3c77422f415b31285dea4085a" translate="yes" xml:space="preserve">
          <source>This option is only allowed if there is at least one &lt;code&gt;UNIQUE&lt;/code&gt; index on the materialized view which uses only column names and includes all rows; that is, it must not be an expression index or include a &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="translated">이 옵션은 구체화 된보기에 열 이름 만 사용하고 모든 행을 포함하는 하나 이상의 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스 가있는 경우에만 허용됩니다 . 즉, 표현식 색인이 아니거나 &lt;code&gt;WHERE&lt;/code&gt; 절을 포함해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4296d287e293665ac5a27dd6a9adf50943b9468" translate="yes" xml:space="preserve">
          <source>This option is only available for servers running PostgreSQL 12 and later.</source>
          <target state="translated">이 옵션은 PostgreSQL 12 이상을 실행하는 서버에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e60792d332e761d9c0448cb84d4e71c131b9f16f" translate="yes" xml:space="preserve">
          <source>This option is only available for servers running PostgreSQL 13 and later.</source>
          <target state="translated">이 옵션은 PostgreSQL 13 이상을 실행하는 서버에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b30b52665fa2ce02b72d1a4b69125f19a948988b" translate="yes" xml:space="preserve">
          <source>This option is only available for servers running PostgreSQL 9.6 and later.</source>
          <target state="translated">이 옵션은 PostgreSQL 9.6 이상을 실행하는 서버에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37e0bc099903a971ee1851f56b57d535fe28abb3" translate="yes" xml:space="preserve">
          <source>This option is only meaningful for the plain-text format. For the archive formats, you can specify the option when you call &lt;code&gt;pg_restore&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 일반 텍스트 형식에만 의미가 있습니다. 아카이브 형식의 경우 &lt;code&gt;pg_restore&lt;/code&gt; 를 호출 할 때 옵션을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32d675434a5906af1a52811945caa7f3758ed1a6" translate="yes" xml:space="preserve">
          <source>This option is relevant only when creating a data-only dump. It instructs pg_dump to include commands to temporarily disable triggers on the target tables while the data is reloaded. Use this if you have referential integrity checks or other triggers on the tables that you do not want to invoke during data reload.</source>
          <target state="translated">이 옵션은 데이터 전용 덤프를 만들 때만 관련이 있습니다. 데이터를 다시로드하는 동안 대상 테이블에서 트리거를 일시적으로 비활성화하는 명령을 포함하도록 pg_dump에 지시합니다. 데이터를 다시로드하는 동안 호출하지 않으려는 테이블에서 참조 무결성 검사 또는 기타 트리거가있는 경우이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e55f65ea72f8a90277e680e4be1296a1699e5d3e" translate="yes" xml:space="preserve">
          <source>This option is relevant only when creating a data-only dump. It instructs pg_dumpall to include commands to temporarily disable triggers on the target tables while the data is reloaded. Use this if you have referential integrity checks or other triggers on the tables that you do not want to invoke during data reload.</source>
          <target state="translated">이 옵션은 데이터 전용 덤프를 만들 때만 관련이 있습니다. 데이터를 다시로드하는 동안 대상 테이블에서 트리거를 일시적으로 비활성화하는 명령을 포함하도록 pg_dumpall에 지시합니다. 데이터를 다시로드하는 동안 호출하지 않으려는 테이블에서 참조 무결성 검사 또는 기타 트리거가있는 경우이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="36d07ffa5564debc3dc316ccc0efca57402fc186" translate="yes" xml:space="preserve">
          <source>This option is relevant only when dumping the contents of a table which has row security. By default, pg_dump will set &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; to off, to ensure that all data is dumped from the table. If the user does not have sufficient privileges to bypass row security, then an error is thrown. This parameter instructs pg_dump to set &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; to on instead, allowing the user to dump the parts of the contents of the table that they have access to.</source>
          <target state="translated">이 옵션은 행 보안이있는 테이블의 내용을 덤프 할 때만 관련이 있습니다. 기본적으로 pg_dump는 모든 데이터가 테이블에서 덤프되도록 &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; 를 off로 설정 합니다. 사용자에게 행 보안을 우회 할 수있는 권한이 없으면 오류가 발생합니다. 이 매개 변수는 pg_dump가 &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; 를 on 으로 설정하도록 지시 하여, 사용자가 액세스 할 수있는 테이블 내용의 일부를 덤프 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="a7d02ec8b27bc6590e144e516d9c202d42175dc3" translate="yes" xml:space="preserve">
          <source>This option is relevant only when performing a data-only restore. It instructs pg_restore to execute commands to temporarily disable triggers on the target tables while the data is reloaded. Use this if you have referential integrity checks or other triggers on the tables that you do not want to invoke during data reload.</source>
          <target state="translated">이 옵션은 데이터 전용 복원을 수행 할 때만 관련이 있습니다. 데이터를 다시로드하는 동안 대상 테이블에서 트리거를 일시적으로 비활성화하는 명령을 실행하도록 pg_restore에 지시합니다. 데이터를 다시로드하는 동안 호출하지 않으려는 테이블에서 참조 무결성 검사 또는 기타 트리거가있는 경우이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="215e331321ddcb53a6c0155b5517f0808745ff2d" translate="yes" xml:space="preserve">
          <source>This option is relevant only when restoring the contents of a table which has row security. By default, pg_restore will set &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; to off, to ensure that all data is restored in to the table. If the user does not have sufficient privileges to bypass row security, then an error is thrown. This parameter instructs pg_restore to set &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; to on instead, allowing the user to attempt to restore the contents of the table with row security enabled. This might still fail if the user does not have the right to insert the rows from the dump into the table.</source>
          <target state="translated">이 옵션은 행 보안이있는 테이블의 내용을 복원 할 때만 관련이 있습니다. 기본적으로 pg_restore는 모든 데이터가 테이블에 복원되도록 &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; 를 off로 설정 합니다. 사용자에게 행 보안을 우회 할 수있는 권한이 없으면 오류가 발생합니다. 이 매개 변수는 pg_restore에 &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; 를 on 으로 설정 하여 사용자가 행 보안이 활성화 된 테이블의 내용을 복원하도록합니다. 사용자에게 덤프의 행을 테이블에 삽입 할 권한이없는 경우에도 여전히 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="669c8d507812e76e70b7a6698088435172bcb4c4" translate="yes" xml:space="preserve">
          <source>This option is required.</source>
          <target state="translated">이 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e8e2f962f48b10705c69e42af3599ebbe139dded" translate="yes" xml:space="preserve">
          <source>This option is similar to, but for historical reasons not identical to, specifying &lt;code&gt;--section=data&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--section=data&lt;/code&gt; 를 지정하는 것과 비슷하지만 역사적 이유로 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fcf8c055342b65365f647de20886432a97a9fb3f" translate="yes" xml:space="preserve">
          <source>This option is the inverse of &lt;code&gt;--data-only&lt;/code&gt;. It is similar to, but for historical reasons not identical to, specifying &lt;code&gt;--section=pre-data --section=post-data&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--data-only&lt;/code&gt; 와 반대입니다 . &lt;code&gt;--section=pre-data --section=post-data&lt;/code&gt; 를 지정하는 것과 비슷하지만 역사적 이유로 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f0ef2836d01c5b66262cf8fb0f99f24d0487c16e" translate="yes" xml:space="preserve">
          <source>This option is useful to analyze a database that was newly populated from a restored dump or by &lt;code&gt;pg_upgrade&lt;/code&gt;. This option will try to create some statistics as fast as possible, to make the database usable, and then produce full statistics in the subsequent stages.</source>
          <target state="translated">이 옵션은 복원 된 덤프 또는 &lt;code&gt;pg_upgrade&lt;/code&gt; 에 의해 새로 채워진 데이터베이스를 분석하는 데 유용합니다 . 이 옵션은 가능한 빨리 일부 통계를 작성하여 데이터베이스를 사용 가능하게 한 후 후속 단계에서 전체 통계를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="077e267cb6b3ecfbfb03040a23b63baaeb817565" translate="yes" xml:space="preserve">
          <source>This option is useful when needing to synchronize the dump with a logical replication slot (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) or with a concurrent session.</source>
          <target state="translated">이 옵션은 덤프를 논리적 복제 슬롯 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 참조 ) 또는 동시 세션과 동기화해야 할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="7de6209f5a71b1972a88650d25f0745aff575b91" translate="yes" xml:space="preserve">
          <source>This option is useful when needing to synchronize the dump with a logical replication slot (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) or with a concurrent session.</source>
          <target state="translated">이 옵션은 덤프를 논리적 복제 슬롯 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 참조 ) 또는 동시 세션과 동기화해야 할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="3633c4f24d10d4cb48c93fba1de68cf9fa92f151" translate="yes" xml:space="preserve">
          <source>This option may not be used when the materialized view is not already populated.</source>
          <target state="translated">구체화 된보기가 아직 채워져 있지 않으면이 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3512c53edd5cba187313504c9c38bb9bebba16b9" translate="yes" xml:space="preserve">
          <source>This option prevents the creation of a temporary replication slot during the backup even if it's supported by the server.</source>
          <target state="translated">이 옵션은 서버에서 지원하는 경우에도 백업 중에 임시 복제 슬롯을 작성하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="a3c0cee7bd9ef9a16e32247c016aeb298ec61871" translate="yes" xml:space="preserve">
          <source>This option should be specified if the replication client of pg_receivewal is configured on the server as a synchronous standby, to ensure that timely feedback is sent to the server.</source>
          <target state="translated">이 옵션은 pg_receivewal의 복제 클라이언트가 서버에 동기 대기로 구성되어 적시에 피드백이 서버로 전송되도록하는 경우 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e2f9ae86d0526f44e2335b7a077c0c7bf363ea0" translate="yes" xml:space="preserve">
          <source>This option specifies the authentication method for local users via TCP/IP connections used in &lt;code&gt;pg_hba.conf&lt;/code&gt; (&lt;code&gt;host&lt;/code&gt; lines).</source>
          <target state="translated">이 옵션은 &lt;code&gt;pg_hba.conf&lt;/code&gt; ( &lt;code&gt;host&lt;/code&gt; 라인) 에서 사용되는 TCP / IP 연결을 통한 로컬 사용자의 인증 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="804c43ea411a36eef9c28b7d23a8aedda99cd7ef" translate="yes" xml:space="preserve">
          <source>This option specifies the authentication method for local users via Unix-domain socket connections used in &lt;code&gt;pg_hba.conf&lt;/code&gt; (&lt;code&gt;local&lt;/code&gt; lines).</source>
          <target state="translated">이 옵션은 &lt;code&gt;pg_hba.conf&lt;/code&gt; ( &lt;code&gt;local&lt;/code&gt; 라인) 에서 사용되는 Unix 도메인 소켓 연결을 통한 로컬 사용자의 인증 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="73ac8a9ea2f27acca3addec852f67d4b056e3a63" translate="yes" xml:space="preserve">
          <source>This option specifies the default authentication method for local users used in &lt;code&gt;pg_hba.conf&lt;/code&gt; (&lt;code&gt;host&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; lines). &lt;code&gt;initdb&lt;/code&gt; will prepopulate &lt;code&gt;pg_hba.conf&lt;/code&gt; entries using the specified authentication method for non-replication as well as replication connections.</source>
          <target state="translated">이 옵션은 &lt;code&gt;pg_hba.conf&lt;/code&gt; ( &lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;local&lt;/code&gt; 회선) 에서 사용되는 로컬 사용자의 기본 인증 방법을 지정합니다 . &lt;code&gt;initdb&lt;/code&gt; 는 복제 연결뿐만 아니라 비 복제를 위해 지정된 인증 방법을 사용하여 &lt;code&gt;pg_hba.conf&lt;/code&gt; 항목을 미리 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="33880c0202e463453735147893fedee96072b505" translate="yes" xml:space="preserve">
          <source>This option specifies the directory where the database cluster should be stored. This is the only information required by &lt;code&gt;initdb&lt;/code&gt;, but you can avoid writing it by setting the &lt;code&gt;PGDATA&lt;/code&gt; environment variable, which can be convenient since the database server (&lt;code&gt;postgres&lt;/code&gt;) can find the database directory later by the same variable.</source>
          <target state="translated">이 옵션은 데이터베이스 클러스터가 저장 될 디렉토리를 지정합니다. 이것은 &lt;code&gt;initdb&lt;/code&gt; 에 필요한 유일한 정보 이지만 &lt;code&gt;PGDATA&lt;/code&gt; 환경 변수 를 설정하여 작성하지 않아도됩니다 . 데이터베이스 서버 ( &lt;code&gt;postgres&lt;/code&gt; )는 나중에 동일한 변수로 데이터베이스 디렉토리를 찾을 수 있기 때문에 편리 합니다.</target>
        </trans-unit>
        <trans-unit id="2481fe81f534e308eab6b927c279c7c516c6f6c9" translate="yes" xml:space="preserve">
          <source>This option specifies the directory where the write-ahead log should be stored.</source>
          <target state="translated">이 옵션은 미리 쓰기 로그가 저장 될 디렉토리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e5ab029306c7aba204799ea5d9a25ae6a49ed455" translate="yes" xml:space="preserve">
          <source>This option specifies the number of rows &lt;code&gt;postgres_fdw&lt;/code&gt; should get in each fetch operation. It can be specified for a foreign table or a foreign server. The option specified on a table overrides an option specified for the server. The default is &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;postgres_fdw&lt;/code&gt; 가 각 페치 작업에서 가져야 하는 행 수를 지정합니다 . 외부 테이블 또는 외부 서버에 지정할 수 있습니다. 테이블에 지정된 옵션은 서버에 지정된 옵션보다 우선합니다. 기본값은 &lt;code&gt;100&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="647df7560822159475f98885467e55eb675890f8" translate="yes" xml:space="preserve">
          <source>This option specifies the target data directory that is synchronized with the source. The target server must be shut down cleanly before running pg_rewind</source>
          <target state="translated">이 옵션은 소스와 동기화되는 대상 데이터 디렉토리를 지정합니다. pg_rewind를 실행하기 전에 대상 서버를 깨끗하게 종료해야합니다</target>
        </trans-unit>
        <trans-unit id="ff01b505d4bc957630a4ef6552d6b1f3f78071f5" translate="yes" xml:space="preserve">
          <source>This option specifies whether the final function is a pure function that does not modify its arguments. &lt;code&gt;READ_ONLY&lt;/code&gt; indicates it does not; the other two values indicate that it may change the transition state value. See &lt;a href=&quot;sql-createaggregate#SQL-CREATEAGGREGATE-NOTES&quot;&gt;Notes&lt;/a&gt; below for more detail. The default is &lt;code&gt;READ_ONLY&lt;/code&gt;, except for ordered-set aggregates, for which the default is &lt;code&gt;READ_WRITE&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 최종 함수가 인수를 수정하지 않는 순수한 함수인지 여부를 지정합니다. &lt;code&gt;READ_ONLY&lt;/code&gt; 는 그렇지 않다는 것을 나타냅니다. 다른 두 값은 전환 상태 값을 변경할 수 있음을 나타냅니다. 자세한 내용은 아래 참고 &lt;a href=&quot;sql-createaggregate#SQL-CREATEAGGREGATE-NOTES&quot;&gt;사항을&lt;/a&gt; 참조하십시오 . 기본값은 &lt;code&gt;READ_WRITE&lt;/code&gt; 인 순서 집합 집계를 제외하고 기본값은 &lt;code&gt;READ_ONLY&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7f68a96aa921444e2d40ac76a43185ab6a9f312" translate="yes" xml:space="preserve">
          <source>This option will make no difference if there are no read-write transactions active when pg_dump is started. If read-write transactions are active, the start of the dump may be delayed for an indeterminate length of time. Once running, performance with or without the switch is the same.</source>
          <target state="translated">pg_dump가 시작될 때 활성화 된 읽기 / 쓰기 트랜잭션이없는 경우이 옵션은 아무런 차이가 없습니다. 읽기-쓰기 트랜잭션이 활성화되어 있으면 덤프 시작이 결정되지 않은 시간 동안 지연 될 수 있습니다. 일단 실행되면 스위치 유무에 관계없이 동일한 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a1a6fd10746c87d481fd1e3f7d6dfee998b43bb9" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a column of a foreign table, gives the column name to use for the column on the remote server. If this option is omitted, the column's name is used.</source>
          <target state="translated">외부 테이블의 열에 지정할 수있는이 옵션은 원격 서버의 열에 사용할 열 이름을 제공합니다. 이 옵션을 생략하면 열 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4af1de2d1bcdacfc86aa091d4dc53d1aa115b546" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign server, is a numeric value that is added to the estimated startup cost of any foreign-table scan on that server. This represents the additional overhead of establishing a connection, parsing and planning the query on the remote side, etc. The default value is &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">외부 서버에 지정할 수있는이 옵션은 해당 서버에서 외부 테이블 스캔의 예상 시작 비용에 추가되는 숫자 값입니다. 이는 연결 설정, 쿼리 구문 분석 및 원격 측 계획 등의 추가 오버 헤드를 나타냅니다. 기본값은 &lt;code&gt;100&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca3fd60b70e15baee78bd32e8d43582b1c2df725" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign server, is a numeric value that is used as extra cost per-tuple for foreign-table scans on that server. This represents the additional overhead of data transfer between servers. You might increase or decrease this number to reflect higher or lower network delay to the remote server. The default value is &lt;code&gt;0.01&lt;/code&gt;.</source>
          <target state="translated">외부 서버에 지정할 수있는이 옵션은 해당 서버에서 외부 테이블 스캔에 대한 추가 비용 당 튜플로 사용되는 숫자 값입니다. 이는 서버 간 데이터 전송의 추가 오버 헤드를 나타냅니다. 이 수를 늘리거나 줄여서 원격 서버에 대한 네트워크 지연이 높거나 낮음을 반영 할 수 있습니다. 기본값은 &lt;code&gt;0.01&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6db445412c679c14afee682db0f908555cd61891" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign table or a foreign server, controls whether &lt;code&gt;postgres_fdw&lt;/code&gt; issues remote &lt;code&gt;EXPLAIN&lt;/code&gt; commands to obtain cost estimates. A setting for a foreign table overrides any setting for its server, but only for that table. The default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">외부 테이블 또는 외부 서버에 지정할 수있는이 옵션은 &lt;code&gt;postgres_fdw&lt;/code&gt; 가 원격 &lt;code&gt;EXPLAIN&lt;/code&gt; 명령을 발행 하여 비용 견적을 얻을지 여부를 제어합니다 . 외부 테이블에 대한 설정은 해당 서버에 대한 모든 설정을 무시하지만 해당 테이블에 대해서만 설정됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b3bc87c793b518f8cb8ef921546c45361e5e8ae" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign table, gives the schema name to use for the foreign table on the remote server. If this option is omitted, the name of the foreign table's schema is used.</source>
          <target state="translated">외부 테이블에 지정할 수있는이 옵션은 원격 서버의 외부 테이블에 사용할 스키마 이름을 제공합니다. 이 옵션을 생략하면 외부 테이블 스키마의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9bf0730e389ac20110b162cce98c39dc1dadc6b" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign table, gives the table name to use for the foreign table on the remote server. If this option is omitted, the foreign table's name is used.</source>
          <target state="translated">외부 테이블에 지정할 수있는이 옵션은 원격 서버의 외부 테이블에 사용할 테이블 이름을 제공합니다. 이 옵션을 생략하면 외부 테이블의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03ad95dc874ed74ab0a774486c7f7e813aede7b9" translate="yes" xml:space="preserve">
          <source>This optional clause specifies the table access method to use to store the contents for the new materialized view; the method needs be an access method of type &lt;code&gt;TABLE&lt;/code&gt;. See &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; for more information. If this option is not specified, the default table access method is chosen for the new materialized view. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">이 선택적 절은 새로운 구체화 된 뷰의 내용을 저장하는 데 사용할 테이블 액세스 방법을 지정합니다. 메소드는 &lt;code&gt;TABLE&lt;/code&gt; 유형의 액세스 메소드 여야합니다 . 자세한 내용은 &lt;a href=&quot;tableam&quot;&gt;60 장&lt;/a&gt; 을 참조하십시오. 이 옵션을 지정하지 않으면 새 구체화 된보기에 기본 테이블 액세스 방법이 선택됩니다. 자세한 정보는 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55edaedc2635dc462befb01330512122e702699e" translate="yes" xml:space="preserve">
          <source>This optional clause specifies the table access method to use to store the contents for the new table; the method needs be an access method of type &lt;code&gt;TABLE&lt;/code&gt;. See &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; for more information. If this option is not specified, the default table access method is chosen for the new table. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">이 선택적 절은 새 테이블의 내용을 저장하는 데 사용할 테이블 액세스 방법을 지정합니다. 메소드는 &lt;code&gt;TABLE&lt;/code&gt; 유형의 액세스 메소드 여야합니다 . 자세한 내용은 &lt;a href=&quot;tableam&quot;&gt;60 장&lt;/a&gt; 을 참조하십시오. 이 옵션을 지정하지 않으면 새 테이블에 기본 테이블 액세스 방법이 선택됩니다. 자세한 정보는 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d07ee1bbba1bc08763833fec13cc7baed7c30f7" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies a shell command that will be executed at every restartpoint. The purpose of &lt;code&gt;archive_cleanup_command&lt;/code&gt; is to provide a mechanism for cleaning up old archived WAL files that are no longer needed by the standby server. Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point. That is the earliest file that must be &lt;em&gt;kept&lt;/em&gt; to allow a restore to be restartable, and so all files earlier than &lt;code&gt;%r&lt;/code&gt; may be safely removed. This information can be used to truncate the archive to just the minimum required to support restart from the current restore. The &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt; module is often used in &lt;code&gt;archive_cleanup_command&lt;/code&gt; for single-standby configurations, for example:</source>
          <target state="translated">이 선택적 매개 변수는 모든 재시작 지점에서 실행될 쉘 명령을 지정합니다. &lt;code&gt;archive_cleanup_command&lt;/code&gt; 의 목적 은 더 이상 대기 서버에 필요하지 않은 오래된 아카이브 WAL 파일을 정리하는 메커니즘을 제공하는 것입니다. 모든 &lt;code&gt;%r&lt;/code&gt; 유효한 마지막 재시작 포인트를 포함한 파일의 이름으로 대체됩니다. 복원을 다시 시작할 수 있도록 &lt;em&gt;유지&lt;/em&gt; 해야하는 가장 빠른 파일 이므로 &lt;code&gt;%r&lt;/code&gt; 이전의 모든 파일을 안전하게 제거 할 수 있습니다. 이 정보는 현재 복원에서 재시작을 지원하는 데 필요한 최소한의 수준으로 아카이브를 자르는 데 사용할 수 있습니다. &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup의&lt;/a&gt; 모듈은 자주 사용된다 &lt;code&gt;archive_cleanup_command&lt;/code&gt; 단일 대기 구성의 경우 :</target>
        </trans-unit>
        <trans-unit id="a1986f363d2c74bd434d8d6240e4cfb3cd3d030a" translate="yes" xml:space="preserve">
          <source>This overrides &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-SAMPLE&quot;&gt;log_min_duration_sample&lt;/a&gt;, meaning that queries with duration exceeding this setting are not subject to sampling and are always logged.</source>
          <target state="translated">이는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-SAMPLE&quot;&gt;log_min_duration_sample을&lt;/a&gt; 재정의합니다 . 즉, 기간이이 설정을 초과하는 쿼리는 샘플링 대상이 아니며 항상 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="a73490037361c0f29250fb41ec57cf1fa01ef705" translate="yes" xml:space="preserve">
          <source>This package has applications to astronomical databases as well. Astronomers will probably want to change &lt;code&gt;earth()&lt;/code&gt; to return a radius of &lt;code&gt;180/pi()&lt;/code&gt; so that distances are in degrees.</source>
          <target state="translated">이 패키지에는 천문 데이터베이스에 대한 응용 프로그램도 있습니다. 천문학 자들은 아마도 거리 &lt;code&gt;180/pi()&lt;/code&gt; 되도록 &lt;code&gt;earth()&lt;/code&gt; 를 180 / pi () 의 반경으로 돌려 주기를 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ccbc9227762cc1b1b338f8650f8f4de4947b9bb4" translate="yes" xml:space="preserve">
          <source>This page describes usage of cursors at the SQL command level. If you are trying to use cursors inside a PL/pgSQL function, the rules are different &amp;mdash; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-cursors.html&quot;&gt;Section 42.7&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 SQL 명령 레벨에서의 커서 사용법을 설명합니다. PL / pgSQL 함수 내에서 커서를 사용하려는 경우 규칙이 다릅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-cursors.html&quot;&gt;섹션 42.7&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="56562eeab71ceb4b4deb48e8b0753e859819b0d5" translate="yes" xml:space="preserve">
          <source>This page describes usage of cursors at the SQL command level. If you are trying to use cursors inside a PL/pgSQL function, the rules are different &amp;mdash; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-cursors.html#PLPGSQL-CURSOR-USING&quot;&gt;Section 42.7.3&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 SQL 명령 레벨에서의 커서 사용법을 설명합니다. PL / pgSQL 함수 내에서 커서를 사용하려고하면 규칙이 다릅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-cursors.html#PLPGSQL-CURSOR-USING&quot;&gt;섹션 42.7.3&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="547b9cb1aa4d24d0c574063f39b87dc0659b1ba0" translate="yes" xml:space="preserve">
          <source>This page describes usage of cursors at the SQL command level. If you are trying to use cursors inside a PL/pgSQL function, the rules are different &amp;mdash; see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-cursors.html&quot;&gt;Section 42.7&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 SQL 명령 레벨에서 커서 사용을 설명합니다. PL / pgSQL 함수 내에서 커서를 사용하려는 경우 규칙이 다릅니다 . &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-cursors.html&quot;&gt;섹션 42.7을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4868f00986f7826fff46f8caaf65132226af2073" translate="yes" xml:space="preserve">
          <source>This page describes usage of cursors at the SQL command level. If you are trying to use cursors inside a PL/pgSQL function, the rules are different &amp;mdash; see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-cursors.html#PLPGSQL-CURSOR-USING&quot;&gt;Section 42.7.3&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 SQL 명령 레벨에서 커서 사용을 설명합니다. PL / pgSQL 함수 내에서 커서를 사용하려는 경우 규칙이 다릅니다 . &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-cursors.html#PLPGSQL-CURSOR-USING&quot;&gt;섹션 42.7.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f12b1cf7624fdc2fc587dd45a6d547cd93a31157" translate="yes" xml:space="preserve">
          <source>This parameter adjusts the number of digits used for textual output of floating-point values, including &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, and geometric data types.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;float4&lt;/code&gt; , &lt;code&gt;float8&lt;/code&gt; 및 기하 데이터 유형을 포함하여 부동 소수점 값의 텍스트 출력에 사용되는 자릿수를 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="2c8c19d46b2082ce8ad9cb949c44fbf4a9d2bc51" translate="yes" xml:space="preserve">
          <source>This parameter can be changed at any time; the behavior for any one transaction is determined by the setting in effect when it commits. It is therefore possible, and useful, to have some transactions commit synchronously and others asynchronously. For example, to make a single multistatement transaction commit asynchronously when the default is the opposite, issue &lt;code&gt;SET LOCAL synchronous_commit TO OFF&lt;/code&gt; within the transaction.</source>
          <target state="translated">이 매개 변수는 언제든지 변경할 수 있습니다. 하나의 트랜잭션에 대한 동작은 커밋시 적용되는 설정에 따라 결정됩니다. 따라서 일부 트랜잭션은 동 기적으로 커밋하고 다른 트랜잭션은 비동기 적으로 커밋하는 것이 가능하고 유용합니다. 예를 들어, 기본값이 반대 일 때 단일 다중 명령문 트랜잭션 커밋을 비동기식으로 커미트 하려면 트랜잭션 내에서 &lt;code&gt;SET LOCAL synchronous_commit TO OFF&lt;/code&gt; 를 발행 하십시오.</target>
        </trans-unit>
        <trans-unit id="c374abd82fae67b6ad47305ef8df0f9c2c332166" translate="yes" xml:space="preserve">
          <source>This parameter can be changed at run time by superusers, but a setting done that way will only persist until the end of the client connection, so this method should be reserved for development purposes. The recommended way to set this parameter is in the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file.</source>
          <target state="translated">이 매개 변수는 수퍼 유저가 런타임에 변경할 수 있지만, 이렇게 설정된 설정은 클라이언트 연결이 끝날 때까지만 유지되므로이 방법은 개발 목적으로 예약해야합니다. 이 매개 변수를 설정하는 권장 방법은 &lt;code&gt;postgresql.conf&lt;/code&gt; 구성 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb2aeee56cb3f5ebc1b1a01c4c8dad28553fc839" translate="yes" xml:space="preserve">
          <source>This parameter can only be set at server start.</source>
          <target state="translated">이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548ece31c9a5607a8e7aaa0cea1df9acffd23d07" translate="yes" xml:space="preserve">
          <source>This parameter can only be set at server start. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3c2e150a470aea3c7b743c7181598f9938b94089" translate="yes" xml:space="preserve">
          <source>This parameter can only be set at server start. This setting has no effect if the server is not in standby mode.</source>
          <target state="translated">이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 서버가 대기 모드에 있지 않으면이 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01ece1ab64d1d476c41b0db27bab26dffaa5d23d" translate="yes" xml:space="preserve">
          <source>This parameter can only be set by superusers.</source>
          <target state="translated">이 매개 변수는 수퍼 유저 만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aea2a5594193af5a590a3ea36df84b74060812a5" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcd4c1beac4f16c5f89019faf29b34c84fa4d317" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. If this parameter is changed while the WAL receiver process is running, that process is signaled to shut down and expected to restart with the new setting (except if &lt;code&gt;primary_conninfo&lt;/code&gt; is an empty string). This setting has no effect if the server is not in standby mode.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . WAL 수신자 프로세스가 실행되는 동안이 매개 변수가 변경되면 해당 프로세스는 종료 신호를 받고 새 설정으로 다시 시작할 것으로 예상됩니다 ( &lt;code&gt;primary_conninfo&lt;/code&gt; 가 빈 문자열 인 경우 제외 ). 이 설정은 서버가 대기 모드가 아닌 경우에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc5df5bbc83b51e3d05d700128363b10537046bc" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. It is ignored unless &lt;code&gt;archive_mode&lt;/code&gt; was enabled at server start. If &lt;code&gt;archive_command&lt;/code&gt; is an empty string (the default) while &lt;code&gt;archive_mode&lt;/code&gt; is enabled, WAL archiving is temporarily disabled, but the server continues to accumulate WAL segment files in the expectation that a command will soon be provided. Setting &lt;code&gt;archive_command&lt;/code&gt; to a command that does nothing but return true, e.g. &lt;code&gt;/bin/true&lt;/code&gt; (&lt;code&gt;REM&lt;/code&gt; on Windows), effectively disables archiving, but also breaks the chain of WAL files needed for archive recovery, so it should only be used in unusual circumstances.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 서버 시작시 &lt;code&gt;archive_mode&lt;/code&gt; 가 활성화되어 있지 않으면 무시됩니다 . 경우 &lt;code&gt;archive_command&lt;/code&gt; 은 빈 문자열 (기본값) 동안이다 &lt;code&gt;archive_mode&lt;/code&gt; 가 활성화되어가, WAL 보관이 일시적으로 비활성화되어 있지만 서버는 명령이 곧 제공 될 것이라는 기대에 WAL 세그먼트 파일을 축적하고 있습니다. &lt;code&gt;archive_command&lt;/code&gt; 를 &lt;code&gt;/bin/true&lt;/code&gt; ( Windows의 &lt;code&gt;REM&lt;/code&gt; ) 와 같이 true 만 반환하는 명령으로 설정 하면 아카이브가 효과적으로 비활성화되지만 아카이브 복구에 필요한 WAL 파일 체인이 손상되므로 비정상적인 상황에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c874dee97d89cfa2b94fc70ed86e608ff9b3dc48" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. It is ignored unless &lt;code&gt;archive_mode&lt;/code&gt; was enabled at server start. If &lt;code&gt;archive_command&lt;/code&gt; is an empty string (the default) while &lt;code&gt;archive_mode&lt;/code&gt; is enabled, WAL archiving is temporarily disabled, but the server continues to accumulate WAL segment files in the expectation that a command will soon be provided. Setting &lt;code&gt;archive_command&lt;/code&gt; to a command that does nothing but return true, e.g., &lt;code&gt;/bin/true&lt;/code&gt; (&lt;code&gt;REM&lt;/code&gt; on Windows), effectively disables archiving, but also breaks the chain of WAL files needed for archive recovery, so it should only be used in unusual circumstances.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 서버 시작시 &lt;code&gt;archive_mode&lt;/code&gt; 를 활성화 하지 않으면 무시됩니다 . 경우 &lt;code&gt;archive_command&lt;/code&gt; 은 빈 문자열 (기본값) 동안이다 &lt;code&gt;archive_mode&lt;/code&gt; 가 활성화되어가, WAL 보관이 일시적으로 비활성화되어 있지만 서버는 명령이 곧 제공 될 것이라는 기대에 WAL 세그먼트 파일을 축적하고 있습니다. 설정 &lt;code&gt;archive_command&lt;/code&gt; 를 사실, 예를 들어, 반환 아무것도하지 않습니다하지만 명령에 &lt;code&gt;/bin/true&lt;/code&gt; ( &lt;code&gt;REM&lt;/code&gt; Windows에서)를 효과적으로 보관하지 않습니다,하지만 만 특별한 상황에서 사용해야하므로 또한, WAL의 체인이 아카이브 복구에 필요한 파일 나누기 .</target>
        </trans-unit>
        <trans-unit id="a0a1a0889c9528b4413a436f9a00fb8ec805219f" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;'%m [%p] '&lt;/code&gt; which logs a time stamp and the process ID.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 타임 스탬프와 프로세스 ID를 기록하는 &lt;code&gt;'%m [%p] '&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e07235f8bb7f2137e8d29b1c48712e024bfd7c79" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb9c9e485e73ed5f7ad6e8a64043056d9f542ea8" translate="yes" xml:space="preserve">
          <source>This parameter contains a comma-separated list of C function names. If an error is raised and the name of the internal C function where the error happens matches a value in the list, then a backtrace is written to the server log together with the error message. This can be used to debug specific areas of the source code.</source>
          <target state="translated">이 매개 변수는 쉼표로 구분 된 C 함수 이름 목록을 포함합니다. 오류가 발생하고 오류가 발생한 내부 C 함수의 이름이 목록의 값과 일치하면 역 추적이 오류 메시지와 함께 서버 로그에 기록됩니다. 이것은 소스 코드의 특정 영역을 디버그하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab121fa8e3ea34fd830e0e6103b67d7f977831b1" translate="yes" xml:space="preserve">
          <source>This parameter controls the default deferrable status of each new transaction. It currently has no effect on read-write transactions or those operating at isolation levels lower than &lt;code&gt;serializable&lt;/code&gt;. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 각 새 트랜잭션의 기본 지연 가능 상태를 제어합니다. 현재 읽기 / 쓰기 트랜잭션이나 &lt;code&gt;serializable&lt;/code&gt; 보다 낮은 격리 수준에서 작동하는 트랜잭션에는 영향을 미치지 않습니다 . 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86c77e7afe5c211d78ef603e06178e261dcf6c72" translate="yes" xml:space="preserve">
          <source>This parameter determines whether changes in a partitioned table (or on its partitions) contained in the publication will be published using the identity and schema of the partitioned table rather than that of the individual partitions that are actually changed; the latter is the default. Enabling this allows the changes to be replicated into a non-partitioned table or a partitioned table consisting of a different set of partitions.</source>
          <target state="translated">이 매개 변수는 게시에 포함 된 분할 된 테이블 (또는 해당 파티션)의 변경 사항이 실제로 변경된 개별 파티션이 아닌 분할 된 테이블의 ID와 스키마를 사용하여 게시되는지 여부를 결정합니다. 후자가 기본값입니다. 이를 활성화하면 변경 사항을 파티션되지 않은 테이블 또는 다른 파티션 세트로 구성된 파티션 된 테이블에 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b6ea430b61a904ec5971253ee54b2fa2eddfa5" translate="yes" xml:space="preserve">
          <source>This parameter determines whether the passphrase command set by &lt;code&gt;ssl_passphrase_command&lt;/code&gt; will also be called during a configuration reload if a key file needs a passphrase. If this parameter is off (the default), then &lt;code&gt;ssl_passphrase_command&lt;/code&gt; will be ignored during a reload and the SSL configuration will not be reloaded if a passphrase is needed. That setting is appropriate for a command that requires a TTY for prompting, which might not be available when the server is running. Setting this parameter to on might be appropriate if the passphrase is obtained from a file, for example.</source>
          <target state="translated">이 매개 변수 는 키 파일에 비밀번호 문구가 필요한 경우 구성 재로드 중에 &lt;code&gt;ssl_passphrase_command&lt;/code&gt; 에 의해 설정된 비밀번호 문구 명령이 호출되는지 여부를 판별합니다 . 이 매개 변수가 꺼져 있으면 (기본값), 재로드 중에 &lt;code&gt;ssl_passphrase_command&lt;/code&gt; 가 무시되고 암호 구가 필요한 경우 SSL 구성이 재로드되지 않습니다. 이 설정은 프롬프트에 TTY가 필요한 명령에 적합하며 서버가 실행 중일 때는 사용할 수 없습니다. 예를 들어 파일에서 비밀번호 문구를 얻는 경우이 매개 변수를 on으로 설정하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4f4eed730ec55ccc4eaff2dacaa08b0b2fcb82f" translate="yes" xml:space="preserve">
          <source>This parameter determines which DML operations will be published by the new publication to the subscribers. The value is comma-separated list of operations. The allowed operations are &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, and &lt;code&gt;truncate&lt;/code&gt;. The default is to publish all actions, and so the default value for this option is &lt;code&gt;'insert, update, delete, truncate'&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 새 게시에서 구독자에게 게시 할 DML 작업을 결정합니다. 값은 쉼표로 구분 된 작업 목록입니다. 허용되는 작업은 &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; 및 &lt;code&gt;truncate&lt;/code&gt; 입니다. 기본값은 모든 조치를 공개하는 것이므로이 옵션의 기본값은 &lt;code&gt;'insert, update, delete, truncate'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2c366805ffcbad04565bd73b6d69694df15ae916" translate="yes" xml:space="preserve">
          <source>This parameter enables &lt;code&gt;sepgsql&lt;/code&gt; to function in permissive mode, regardless of the system setting. The default is off. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이 매개 변수를 사용 하면 시스템 설정에 관계없이 &lt;code&gt;sepgsql&lt;/code&gt; 이 허용 모드에서 작동 할 수 있습니다 . 기본 설정은 꺼져 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8293e99f1916de3cd3eb1e1f2ed9f1e458fe46c" translate="yes" xml:space="preserve">
          <source>This parameter enables per-database user names. It is off by default. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이 매개 변수는 데이터베이스 별 사용자 이름을 사용합니다. 기본적으로 꺼져 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f5fcb1a1b2c04d28c8162ce15f61ea3ecacd8ad" translate="yes" xml:space="preserve">
          <source>This parameter enables the &lt;em&gt;logging collector&lt;/em&gt;, which is a background process that captures log messages sent to stderr and redirects them into log files. This approach is often more useful than logging to syslog, since some types of messages might not appear in syslog output. (One common example is dynamic-linker failure messages; another is error messages produced by scripts such as &lt;code&gt;archive_command&lt;/code&gt;.) This parameter can only be set at server start.</source>
          <target state="translated">이 매개 변수는 &lt;em&gt;로깅 콜렉터를&lt;/em&gt; 사용합니다 . 이는 로그 파일을 stderr로 전송 한 후 로그 파일로 경로 재지 정하는 백그라운드 프로세스입니다. 이 방식은 일부 유형의 메시지가 syslog 출력에 나타나지 않을 수 있으므로 syslog에 로깅하는 것보다 더 유용합니다. 하나의 일반적인 예는 동적 링커 실패 메시지이고 다른 하나는 &lt;code&gt;archive_command&lt;/code&gt; 와 같은 스크립트에 의해 생성 된 오류 메시지 입니다.이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b0de510e67bd8744ec5eabde4b996ce5f2b54bc" translate="yes" xml:space="preserve">
          <source>This parameter enables the printing of audit messages regardless of the system policy settings. The default is off, which means that messages will be printed according to the system settings.</source>
          <target state="translated">이 매개 변수는 시스템 정책 설정에 관계없이 감사 메시지를 인쇄 할 수 있습니다. 기본값은 꺼져 있습니다. 즉, 시스템 설정에 따라 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="38b076e09722f67dcc2931b6f7d49ce3816bbff6" translate="yes" xml:space="preserve">
          <source>This parameter forces all possible logging to be turned on, regardless of the system policy.</source>
          <target state="translated">이 매개 변수는 시스템 정책에 관계없이 가능한 모든 로깅을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5b77a5363fdf0aac9e0a3daf60d7960abab567a4" translate="yes" xml:space="preserve">
          <source>This parameter is intended for use with streaming replication deployments; however, if the parameter is specified it will be honored in all cases except crash recovery. &lt;code&gt;hot_standby_feedback&lt;/code&gt; will be delayed by use of this feature which could lead to bloat on the master; use both together with care.</source>
          <target state="translated">이 매개 변수는 스트리밍 복제 배포에 사용하기위한 것입니다. 그러나 매개 변수가 지정되면 응급 복구를 제외한 모든 경우에 적용됩니다. 이 기능을 사용하면 &lt;code&gt;hot_standby_feedback&lt;/code&gt; 이 지연되어 마스터가 팽창 할 수 있습니다. 조심스럽게 함께 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9661b0520a182dcd9a1573ee14abaaf7af72f4ef" translate="yes" xml:space="preserve">
          <source>This parameter is intended to be used to check for bugs in the WAL redo routines. When enabled, full-page images of any buffers modified in conjunction with the WAL record are added to the record. If the record is subsequently replayed, the system will first apply each record and then test whether the buffers modified by the record match the stored images. In certain cases (such as hint bits), minor variations are acceptable, and will be ignored. Any unexpected differences will result in a fatal error, terminating recovery.</source>
          <target state="translated">이 매개 변수는 WAL 재실행 루틴에서 버그를 확인하는 데 사용됩니다. 활성화되면 WAL 레코드와 함께 수정 된 버퍼의 전체 페이지 이미지가 레코드에 추가됩니다. 이후에 레코드가 재생되면 시스템은 먼저 각 레코드를 적용한 다음 레코드로 수정 된 버퍼가 저장된 이미지와 일치하는지 테스트합니다. 경우에 따라 (예 : 힌트 비트) 사소한 변형이 허용되며 무시됩니다. 예기치 않은 차이가 있으면 치명적인 오류가 발생하여 복구가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="79e45ac588c210513ee2f2dfb89a49d85d30136b" translate="yes" xml:space="preserve">
          <source>This parameter is irrelevant on Windows, which does not have Unix-domain sockets.</source>
          <target state="translated">이 매개 변수는 Unix 도메인 소켓이없는 Windows에서는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f6a521703b967c04e55a5a7440712a5d7f90432" translate="yes" xml:space="preserve">
          <source>This parameter is irrelevant on systems, notably Solaris as of Solaris 10, that ignore socket permissions entirely. There, one can achieve a similar effect by pointing &lt;code&gt;unix_socket_directories&lt;/code&gt; to a directory having search permission limited to the desired audience.</source>
          <target state="translated">이 매개 변수는 소켓 권한을 완전히 무시하는 시스템, 특히 Solaris 10부터 Solaris와는 관련이 없습니다. 거기에서 &lt;code&gt;unix_socket_directories&lt;/code&gt; 를 검색 권한이 원하는 대상으로 제한되는 디렉토리 로 지정하여 유사한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d64ae81fa444da28c76340e9acb4f864a787cd0" translate="yes" xml:space="preserve">
          <source>This parameter is irrelevant on systems, notably Solaris as of Solaris 10, that ignore socket permissions entirely. There, one can achieve a similar effect by pointing &lt;code&gt;unix_socket_directories&lt;/code&gt; to a directory having search permission limited to the desired audience. This parameter is also irrelevant on Windows, which does not have Unix-domain sockets.</source>
          <target state="translated">이 매개 변수는 소켓 권한을 완전히 무시하는 시스템, 특히 Solaris 10부터 Solaris와는 관련이 없습니다. 여기서, &lt;code&gt;unix_socket_directories&lt;/code&gt; 를 원하는 대상으로 제한된 검색 권한을 가진 디렉토리 로 지정하여 유사한 효과를 얻을 수 있습니다 . 이 매개 변수는 Unix 도메인 소켓이없는 Windows에서도 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3dd094f0736aa3ae7edd4ff5cd79706a00b54ce9" translate="yes" xml:space="preserve">
          <source>This parameter is normally on. When set to &lt;code&gt;off&lt;/code&gt;, it disables validation of the function body string during &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;. Disabling validation avoids side effects of the validation process and avoids false positives due to problems such as forward references. Set this parameter to &lt;code&gt;off&lt;/code&gt; before loading functions on behalf of other users; pg_dump does so automatically.</source>
          <target state="translated">이 매개 변수는 일반적으로 켜져 있습니다. &lt;code&gt;off&lt;/code&gt; 로 설정되면 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 동안 함수 본문 문자열의 유효성 검증을 사용하지 않습니다 . 유효성 검사를 비활성화하면 유효성 검사 프로세스의 부작용을 피하고 정방향 참조와 같은 문제로 인한 오탐을 방지합니다. 다른 사용자 대신 기능을로드하기 전에이 매개 변수를 &lt;code&gt;off&lt;/code&gt; 로 설정하십시오 . pg_dump는 자동으로 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="757f13945c2c0187d0950790cc03fde26586d7a4" translate="yes" xml:space="preserve">
          <source>This parameter is not supported on Windows, and must be zero.</source>
          <target state="translated">이 매개 변수는 Windows에서 지원되지 않으며 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="de5a8a2ca644671b2bea31a3c7534d0ee40e2165" translate="yes" xml:space="preserve">
          <source>This parameter is not supported on Windows. Any setting will be ignored.</source>
          <target state="translated">이 매개 변수는 Windows에서 지원되지 않습니다. 모든 설정은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b2763e8b9da5e6a86b4f3be45fa54afbb6338381" translate="yes" xml:space="preserve">
          <source>This parameter is only available if the &lt;code&gt;BTREE_BUILD_STATS&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">이 매개 변수는 PostgreSQL이 컴파일 될 때 &lt;code&gt;BTREE_BUILD_STATS&lt;/code&gt; 매크로가 정의 된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c80b12aeb2b9de43621c9a7ca80fead69181cd4d" translate="yes" xml:space="preserve">
          <source>This parameter is only available if the &lt;code&gt;LOCK_DEBUG&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">이 매개 변수는 PostgreSQL이 컴파일 될 때 &lt;code&gt;LOCK_DEBUG&lt;/code&gt; 매크로가 정의 된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c8a9b81edbcb0f5ee50f2aa2c3229e2b238c0d5" translate="yes" xml:space="preserve">
          <source>This parameter is required.</source>
          <target state="translated">이 매개 변수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="230b46508e1bcacd6e7909740fdc39adfae605d5" translate="yes" xml:space="preserve">
          <source>This parameter is useful in configurations where a node in recovery needs to control the amount of time to wait for new WAL data to be available. For example, in archive recovery, it is possible to make the recovery more responsive in the detection of a new WAL log file by reducing the value of this parameter. On a system with low WAL activity, increasing it reduces the amount of requests necessary to access WAL archives, something useful for example in cloud environments where the amount of times an infrastructure is accessed is taken into account.</source>
          <target state="translated">이 매개 변수는 복구중인 노드가 새 WAL 데이터가 사용 가능할 때까지 대기하는 시간을 제어해야하는 구성에 유용합니다. 예를 들어, 아카이브 복구에서이 매개 변수의 값을 줄임으로써 새 WAL 로그 파일을 감지 할 때 복구의 응답 성을 향상시킬 수 있습니다. WAL 활동이 적은 시스템에서 증가하면 WAL 아카이브에 액세스하는 데 필요한 요청의 양이 줄어 듭니다. 예를 들어 인프라에 액세스하는 횟수가 고려되는 클라우드 환경에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="60b8dda68ddec78bdd153122213269123706aba2" translate="yes" xml:space="preserve">
          <source>This parameter may be either &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;cascaded&lt;/code&gt;, and is equivalent to specifying &lt;code&gt;WITH [ CASCADED | LOCAL ] CHECK OPTION&lt;/code&gt; (see below). This option can be changed on existing views using &lt;a href=&quot;sql-alterview&quot;&gt;ALTER VIEW&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;local&lt;/code&gt; 이거나 &lt;code&gt;cascaded&lt;/code&gt; 일 수 있으며 &lt;code&gt;WITH [ CASCADED | LOCAL ] CHECK OPTION&lt;/code&gt; (아래 참조). 이 옵션은 &lt;a href=&quot;sql-alterview&quot;&gt;ALTER VIEW를&lt;/a&gt; 사용하여 기존 뷰에서 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8076b1a53637e369327b419272c25be1f35d885" translate="yes" xml:space="preserve">
          <source>This parameter specifies a list of standby servers using either of the following syntaxes:</source>
          <target state="translated">이 매개 변수는 다음 구문 중 하나를 사용하여 대기 서버 목록을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e3119205c74e3feadc21f1edb96559651e07399f" translate="yes" xml:space="preserve">
          <source>This parameter specifies a shell command that will be executed once only at the end of recovery. This parameter is optional. The purpose of the &lt;code&gt;recovery_end_command&lt;/code&gt; is to provide a mechanism for cleanup following replication or recovery. Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point, like in &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 복구 종료시 한 번만 실행될 쉘 명령을 지정합니다. 이 매개 변수는 선택 사항입니다. &lt;code&gt;recovery_end_command&lt;/code&gt; 의 목적은 복제 또는 복구 후 정리 메커니즘을 제공하는 것입니다. 모든 &lt;code&gt;%r&lt;/code&gt; 처럼 유효한 마지막 재시작 포인트가 들어있는 파일의 이름으로 대체됩니다 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc3d884be2df2669703142223fbc549ce1860529" translate="yes" xml:space="preserve">
          <source>This parameter specifies that recovery should end as soon as a consistent state is reached, i.e. as early as possible. When restoring from an online backup, this means the point where taking the backup ended.</source>
          <target state="translated">이 매개 변수는 일관된 상태에 도달하자마자 가능한 빨리 복구를 종료하도록 지정합니다. 온라인 백업에서 복원 할 때 이는 백업 수행이 종료 된 지점을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4aaac74b096ffa8fd2b689ffdb61db6bf8bb5409" translate="yes" xml:space="preserve">
          <source>This parameter specifies that recovery should end as soon as a consistent state is reached, i.e., as early as possible. When restoring from an online backup, this means the point where taking the backup ended.</source>
          <target state="translated">이 매개 변수는 일관된 상태에 도달하는 즉시, 즉 가능한 한 빨리 복구를 종료하도록 지정합니다. 온라인 백업에서 복원 할 때 이는 백업 수행이 종료 된 지점을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="038ead23d053aaeb92ffc414e5b17ac7f1401e33" translate="yes" xml:space="preserve">
          <source>This parameter specifies the LSN of the write-ahead log location up to which recovery will proceed. The precise stopping point is also influenced by &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive&lt;/a&gt;. This parameter is parsed using the system data type &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 복구가 진행될 때까지 미리 쓰기 로그 위치의 LSN을 지정합니다. 정확한 중지 지점도 &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive의&lt;/a&gt; 영향을받습니다 . 이 매개 변수는 시스템 데이터 유형 &lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="efffdc4221077284f352653adef6ab331dce1918" translate="yes" xml:space="preserve">
          <source>This parameter specifies the default table access method to use when creating tables or materialized views if the &lt;code&gt;CREATE&lt;/code&gt; command does not explicitly specify an access method, or when &lt;code&gt;SELECT ... INTO&lt;/code&gt; is used, which does not allow to specify a table access method. The default is &lt;code&gt;heap&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;CREATE&lt;/code&gt; 명령이 액세스 방법을 명시 적으로 지정하지 않거나 &lt;code&gt;SELECT ... INTO&lt;/code&gt; 를 사용하여 테이블 액세스 방법을 지정할 수 없는 경우 테이블 또는 구체화 된보기를 작성할 때 사용할 기본 테이블 액세스 방법을 지정합니다 . 기본값은 &lt;code&gt;heap&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5eccd6d9a8a05839ca4090c77807db10a5ab201b" translate="yes" xml:space="preserve">
          <source>This parameter specifies the named restore point (created with &lt;code&gt;pg_create_restore_point()&lt;/code&gt;) to which recovery will proceed.</source>
          <target state="translated">이 매개 변수 는 복구를 진행할 명명 된 복원 지점 ( &lt;code&gt;pg_create_restore_point()&lt;/code&gt; 작성 )을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="867f446a2e7adc40927cc70cf6283de855e50f8d" translate="yes" xml:space="preserve">
          <source>This parameter specifies the time stamp up to which recovery will proceed. The precise stopping point is also influenced by &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 복구가 진행될 시간 소인을 지정합니다. 정확한 중지 지점도 &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive의&lt;/a&gt; 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="8874d47b3d5a339b6f4f727528a118f988fbf4ff" translate="yes" xml:space="preserve">
          <source>This parameter specifies the transaction ID up to which recovery will proceed. Keep in mind that while transaction IDs are assigned sequentially at transaction start, transactions can complete in a different numeric order. The transactions that will be recovered are those that committed before (and optionally including) the specified one. The precise stopping point is also influenced by &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 복구가 진행될 트랜잭션 ID를 지정합니다. 트랜잭션 시작시 트랜잭션 ID가 순차적으로 할당되는 동안 트랜잭션은 다른 숫자 순서로 완료 될 수 있습니다. 복구 될 트랜잭션은 지정된 트랜잭션 전에 커밋 된 트랜잭션입니다 (선택 사항 포함). 정확한 중지 지점도 &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive의&lt;/a&gt; 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="8107ac8a053e104cbe77d39e7e4ed7f575d4cd68" translate="yes" xml:space="preserve">
          <source>This parses the document text in its parameter and returns true if the document is well-formed XML. (Note: this is an alias for the standard PostgreSQL function &lt;code&gt;xml_is_well_formed()&lt;/code&gt;. The name &lt;code&gt;xml_valid()&lt;/code&gt; is technically incorrect since validity and well-formedness have different meanings in XML.)</source>
          <target state="translated">매개 변수의 문서 텍스트를 구문 분석하고 문서가 올바른 형식의 XML 인 경우 true를 리턴합니다. (참고 : 이것은 표준 PostgreSQL 함수 &lt;code&gt;xml_is_well_formed()&lt;/code&gt; 의 별칭입니다 . &lt;code&gt;xml_valid()&lt;/code&gt; 는 XML에서 유효성과 형식이 다르기 때문에 기술적으로 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="55ccf48fdd4beed006b2ceea636ca3d5535efe1b" translate="yes" xml:space="preserve">
          <source>This problem can be fixed by creating a statistics object that directs &lt;code&gt;ANALYZE&lt;/code&gt; to calculate functional-dependency multivariate statistics on the two columns:</source>
          <target state="translated">이 문제는 &lt;code&gt;ANALYZE&lt;/code&gt; 가 두 열의 함수 종속 다변량 통계를 계산 하도록 지시하는 통계 오브젝트를 작성하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed38ced0d51c221c24b167e4e04cc1cf521a37be" translate="yes" xml:space="preserve">
          <source>This process collects statistical information about the &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;'s activities.</source>
          <target state="translated">이 프로세스는 &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;인스턴스&lt;/a&gt; 의 활동 에 대한 통계 정보를 수집합니다 .</target>
        </trans-unit>
        <trans-unit id="fc382ec8b1a79d496a545a65f41a47da71a48e61" translate="yes" xml:space="preserve">
          <source>This process is inherently nondeterministic, because of the randomized choices made during both the initial population selection and subsequent &amp;ldquo;mutation&amp;rdquo; of the best candidates. To avoid surprising changes of the selected plan, each run of the GEQO algorithm restarts its random number generator with the current &lt;a href=&quot;runtime-config-query#GUC-GEQO-SEED&quot;&gt;geqo_seed&lt;/a&gt; parameter setting. As long as &lt;code&gt;geqo_seed&lt;/code&gt; and the other GEQO parameters are kept fixed, the same plan will be generated for a given query (and other planner inputs such as statistics). To experiment with different search paths, try changing &lt;code&gt;geqo_seed&lt;/code&gt;.</source>
          <target state="translated">이 과정은 본질적으로 비결정론 적이다. 초기 모집단 선택과 최상의 후보의 &quot;돌연변이&quot;모두에서 무작위로 선택하기 때문이다. 선택한 계획의 놀라운 변경을 피하기 위해 각 GEQO 알고리즘 실행은 현재 &lt;a href=&quot;runtime-config-query#GUC-GEQO-SEED&quot;&gt;geqo_seed&lt;/a&gt; 매개 변수 설정으로 난수 생성기를 다시 시작 합니다. 만큼 &lt;code&gt;geqo_seed&lt;/code&gt; 다른 GEQO 파라미터가 고정 유지되는 동일한 계획은 주어진 쿼리 (통계 및 다른 계획 입력)에 대해 생성된다. 다른 검색 경로를 실험하려면 &lt;code&gt;geqo_seed&lt;/code&gt; 를 변경 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c97c4b9be9f2b4404173b6ba238590cba29edc4b" translate="yes" xml:space="preserve">
          <source>This produces a text array if there's a match, or &lt;code&gt;NULL&lt;/code&gt; if not, the same as &lt;code&gt;regexp_match()&lt;/code&gt; would do. Without the sub-select, this query would produce no output at all for table rows without a match, which is typically not the desired behavior.</source>
          <target state="translated">일치하는 경우 텍스트 배열을 생성하고 그렇지 않은 경우 &lt;code&gt;regexp_match()&lt;/code&gt; 와 동일한 경우 &lt;code&gt;NULL&lt;/code&gt; 을 생성 합니다 . 하위 선택이 없으면이 쿼리는 일치하지 않는 테이블 행에 대한 출력을 전혀 생성하지 않으며 일반적으로 원하는 동작이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bc14695b218efe7dec594359c6d20dcaf55f8c15" translate="yes" xml:space="preserve">
          <source>This provides the full power of the SQL query mechanism (&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;) for computing the rows to be inserted.</source>
          <target state="translated">이것은 삽입 될 행을 계산하기위한 SQL 쿼리 메커니즘 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;7 장&lt;/a&gt; ) 의 모든 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5e8d60ba924f5d2eca90b070e9581aa9a0f1247c" translate="yes" xml:space="preserve">
          <source>This provides the full power of the SQL query mechanism (&lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt;) for computing the rows to be inserted.</source>
          <target state="translated">이는 삽입 될 행을 계산하기위한 SQL 쿼리 메커니즘 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;7 장&lt;/a&gt; ) 의 모든 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d9d073846645e6925e79e0c3d11f6f147a90ca99" translate="yes" xml:space="preserve">
          <source>This query can use an index if one has been defined on the result of the &lt;code&gt;lower(col1)&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;lower(col1)&lt;/code&gt; 함수 의 결과에 인덱스가 정의 된 경우이 쿼리는 인덱스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="685680c205a35176edb0e50018d5cb6373c36816" translate="yes" xml:space="preserve">
          <source>This query could also be written</source>
          <target state="translated">이 쿼리를 작성할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="fbd78ff71b7c52624fbdd5dd58209049c5f353fd" translate="yes" xml:space="preserve">
          <source>This query effectively moves rows from &lt;code&gt;products&lt;/code&gt; to &lt;code&gt;products_log&lt;/code&gt;. The &lt;code&gt;DELETE&lt;/code&gt; in &lt;code&gt;WITH&lt;/code&gt; deletes the specified rows from &lt;code&gt;products&lt;/code&gt;, returning their contents by means of its &lt;code&gt;RETURNING&lt;/code&gt; clause; and then the primary query reads that output and inserts it into &lt;code&gt;products_log&lt;/code&gt;.</source>
          <target state="translated">이 쿼리는 효과적으로에서 행을 이동 &lt;code&gt;products&lt;/code&gt; 수 &lt;code&gt;products_log&lt;/code&gt; . &lt;code&gt;WITH&lt;/code&gt; 의 &lt;code&gt;DELETE&lt;/code&gt; 는 &lt;code&gt;products&lt;/code&gt; 에서 지정된 행을 삭제 하고 &lt;code&gt;RETURNING&lt;/code&gt; 절을 통해 내용을 리턴합니다 . 그런 다음 기본 쿼리는 해당 출력을 읽고 &lt;code&gt;products_log&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="022c5b0eea8d62f63af6a712dbf2b1ba8308d986" translate="yes" xml:space="preserve">
          <source>This query is called a &lt;em&gt;left outer join&lt;/em&gt; because the table mentioned on the left of the join operator will have each of its rows in the output at least once, whereas the table on the right will only have those rows output that match some row of the left table. When outputting a left-table row for which there is no right-table match, empty (null) values are substituted for the right-table columns.</source>
          <target state="translated">조인 연산자의 왼쪽에 언급 된 테이블에는 적어도 한 번 출력에 각 행이 있고 오른쪽 테이블에는 일부 행과 일치하는 행만 출력되므로이 쿼리를 &lt;em&gt;왼쪽 외부 조인&lt;/em&gt; 이라고합니다. 왼쪽 테이블. 오른쪽 테이블 일치가없는 왼쪽 테이블 행을 출력 할 때 빈 테이블 (널) 값이 오른쪽 테이블 열로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="177886fdfa19f957f8c9f12b4d04756d588aa024" translate="yes" xml:space="preserve">
          <source>This query produces a single composite-valued column, so we might get output like:</source>
          <target state="translated">이 쿼리는 단일 복합 값 열을 생성하므로 다음과 같은 출력을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff805b5878a400bc03d5c21def35ab5370b1a9c" translate="yes" xml:space="preserve">
          <source>This query retrieves the third quarter pay of all employees:</source>
          <target state="translated">이 쿼리는 모든 직원의 3 분기 급여를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f2463afc5c9099ca3f1d4275282addba1fd3ebec" translate="yes" xml:space="preserve">
          <source>This query shows all defined operator families and all the operators included in each family:</source>
          <target state="translated">이 쿼리는 정의 된 모든 운영자 제품군과 각 제품군에 포함 된 모든 운영자를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="54e5aac3750ebc9ffb7663de95bf9e99bb00e49b" translate="yes" xml:space="preserve">
          <source>This query will loop if the &lt;code&gt;link&lt;/code&gt; relationships contain cycles. Because we require a &amp;ldquo;depth&amp;rdquo; output, just changing &lt;code&gt;UNION ALL&lt;/code&gt; to &lt;code&gt;UNION&lt;/code&gt; would not eliminate the looping. Instead we need to recognize whether we have reached the same row again while following a particular path of links. We add two columns &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;cycle&lt;/code&gt; to the loop-prone query:</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 관계에 사이클이 포함되어 있으면이 쿼리가 반복됩니다 . &amp;ldquo;깊이&amp;rdquo;출력이 필요하기 때문에 &lt;code&gt;UNION ALL&lt;/code&gt; 을 &lt;code&gt;UNION&lt;/code&gt; 으로 변경해도 루핑이 제거되지는 않습니다. 대신 특정 링크 경로를 따라 가면서 동일한 행에 다시 도달했는지 여부를 인식해야합니다. 루프가 발생하기 쉬운 쿼리 에 두 개의 열 &lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;cycle&lt;/code&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="99e758d16683ea2408024769a36931bb47e964b5" translate="yes" xml:space="preserve">
          <source>This query will match any label path that:</source>
          <target state="translated">이 쿼리는 다음과 같은 모든 레이블 경로와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2fdf2ab9a1267601ff578f17895042ec3f81192c" translate="yes" xml:space="preserve">
          <source>This query will match any word in a &lt;code&gt;tsvector&lt;/code&gt; that begins with &amp;ldquo;super&amp;rdquo;.</source>
          <target state="translated">이 쿼리는 &quot;super&quot;로 시작 하는 &lt;code&gt;tsvector&lt;/code&gt; 의 단어와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="57af393c8374427869919ed9d1490df9f15189d7" translate="yes" xml:space="preserve">
          <source>This query will not use the custom operator. The parser will first see if there is a &lt;code&gt;mytext&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;mytext&lt;/code&gt; operator (&lt;a href=&quot;typeconv-oper#OP-RESOL-EXACT-UNKNOWN&quot;&gt;Step 2.a&lt;/a&gt;), which there is not; then it will consider the domain's base type &lt;code&gt;text&lt;/code&gt;, and see if there is a &lt;code&gt;text&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; operator (&lt;a href=&quot;typeconv-oper#OP-RESOL-EXACT-DOMAIN&quot;&gt;Step 2.b&lt;/a&gt;), which there is; so it resolves the &lt;code&gt;unknown&lt;/code&gt;-type literal as &lt;code&gt;text&lt;/code&gt; and uses the &lt;code&gt;text&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; operator. The only way to get the custom operator to be used is to explicitly cast the literal:</source>
          <target state="translated">이 쿼리는 사용자 지정 연산자를 사용하지 않습니다. 파서는 먼저 &lt;code&gt;mytext&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;mytext&lt;/code&gt; 연산자 가 있는지 확인합니다 ( &lt;a href=&quot;typeconv-oper#OP-RESOL-EXACT-UNKNOWN&quot;&gt;단계 2.a&lt;/a&gt; ). 그러면 도메인의 기본 유형 &lt;code&gt;text&lt;/code&gt; 를 고려하고 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 연산자 가 있는지 확인합니다 ( &lt;a href=&quot;typeconv-oper#OP-RESOL-EXACT-DOMAIN&quot;&gt;Step 2.b&lt;/a&gt; ). 그것을 해결되도록 &lt;code&gt;unknown&lt;/code&gt; 같은 리터 형 &lt;code&gt;text&lt;/code&gt; 및 사용 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 연산자. 사용자 정의 연산자를 사용하는 유일한 방법은 리터럴을 명시 적으로 캐스팅하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e1307cd9ebfbfd4618c4e4fa0b6171f2574b87f" translate="yes" xml:space="preserve">
          <source>This query will use the configuration set by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;.</source>
          <target state="translated">이 쿼리는 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config에&lt;/a&gt; 의해 설정된 구성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="772d10eaef65ba067a9a91fb64ad922fec135eca" translate="yes" xml:space="preserve">
          <source>This query would remove all direct and indirect subparts of a product.</source>
          <target state="translated">이 쿼리는 제품의 모든 직간접 하위를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="31069b011561af14dacd4c6e9f8a75852a903c9c" translate="yes" xml:space="preserve">
          <source>This record matches connection attempts made using TCP/IP, but only when the connection is made with GSSAPI encryption.</source>
          <target state="translated">이 레코드는 TCP / IP를 사용한 연결 시도와 일치하지만 GSSAPI 암호화로 연결 한 경우에만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c9fabd411db1c8bc15edbea94205d1cbeda901f1" translate="yes" xml:space="preserve">
          <source>This record matches connection attempts made using TCP/IP, but only when the connection is made with SSL encryption.</source>
          <target state="translated">이 레코드는 TCP / IP를 사용한 연결 시도와 일치하지만 SSL 암호화로 연결 한 경우에만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4881dcf03549dbbd4f3907276b28052ef74959c1" translate="yes" xml:space="preserve">
          <source>This record matches connection attempts made using TCP/IP. &lt;code&gt;host&lt;/code&gt; records match SSL or non-SSL connection attempts as well as GSSAPI encrypted or non-GSSAPI encrypted connection attempts.</source>
          <target state="translated">이 레코드는 TCP / IP를 사용한 연결 시도와 일치합니다. &lt;code&gt;host&lt;/code&gt; 레코드는 SSL 또는 비 SSL 연결 시도뿐만 아니라 GSSAPI 암호화 또는 비 GSSAPI 암호화 연결 시도와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="980501924f376459d15d0a5c5db8499b7255c1bb" translate="yes" xml:space="preserve">
          <source>This record matches connection attempts using Unix-domain sockets. Without a record of this type, Unix-domain socket connections are disallowed.</source>
          <target state="translated">이 레코드는 Unix 도메인 소켓을 사용한 연결 시도와 일치합니다. 이 유형의 레코드가 없으면 Unix 도메인 소켓 연결이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0feefb6f7cf4b291e2319a9344c59b819e8fd16b" translate="yes" xml:space="preserve">
          <source>This record type has the opposite behavior of &lt;code&gt;hostgssenc&lt;/code&gt;; it only matches connection attempts made over TCP/IP that do not use GSSAPI encryption.</source>
          <target state="translated">이 레코드 유형은 &lt;code&gt;hostgssenc&lt;/code&gt; 와 반대로 작동합니다 . GSSAPI 암호화를 사용하지 않는 TCP / IP를 통한 연결 시도와 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="42de4ec30f5134f52861e4d13f8e0897d5515f16" translate="yes" xml:space="preserve">
          <source>This record type has the opposite behavior of &lt;code&gt;hostssl&lt;/code&gt;; it only matches connection attempts made over TCP/IP that do not use SSL.</source>
          <target state="translated">이 레코드 유형은 &lt;code&gt;hostssl&lt;/code&gt; 과 반대되는 동작을 합니다 . SSL을 사용하지 않는 TCP / IP를 통한 연결 시도와 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bdac87a685f48979a0382e2f425d5422b1cea994" translate="yes" xml:space="preserve">
          <source>This reference page does not describe the embedded SQL language. See &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt; for more information on that topic.</source>
          <target state="translated">이 참조 페이지는 Embedded SQL 언어를 설명하지 않습니다. 해당 주제에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;35 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3fc02a75c04d8edd3f600f6578a82bc3af1af4c" translate="yes" xml:space="preserve">
          <source>This reference page does not describe the embedded SQL language. See &lt;a href=&quot;https://www.postgresql.org/docs/13/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt; for more information on that topic.</source>
          <target state="translated">이 참조 페이지는 Embedded SQL 언어를 설명하지 않습니다. 해당 주제에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/ecpg.html&quot;&gt;35 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9455758ac29d288f9d863b3b9a52a001aafdf9d3" translate="yes" xml:space="preserve">
          <source>This references a function that is responsible for executing &amp;ldquo;inline&amp;rdquo; anonymous code blocks (&lt;a href=&quot;sql-do&quot;&gt;DO&lt;/a&gt; blocks). Zero if inline blocks are not supported.</source>
          <target state="translated">이것은 &quot;인라인&quot;익명 코드 블록 ( &lt;a href=&quot;sql-do&quot;&gt;DO&lt;/a&gt; 블록) 을 실행하는 기능을 참조합니다 . 인라인 블록이 지원되지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="d1bdaa47f9aa6f846a6b5a2e5bd41bcbcff51ce1" translate="yes" xml:space="preserve">
          <source>This references a language validator function that is responsible for checking the syntax and validity of new functions when they are created. Zero if no validator is provided.</source>
          <target state="translated">새 함수가 작성 될 때 구문 및 유효성을 확인하는 언어 유효성 검증기 함수를 참조합니다. 유효성 검사기가 제공되지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="3578784aa58f3b4c597b7efb7e0f5cb34cc12bb9" translate="yes" xml:space="preserve">
          <source>This represents a not-null constraint.</source>
          <target state="translated">이는 널이 아닌 제한 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d0d26f9c2c294dc6bad121a60a45edf3f61c2846" translate="yes" xml:space="preserve">
          <source>This restriction applies only to cases where the planner would need to execute a user-defined operator on one or more values from &lt;code&gt;pg_statistic&lt;/code&gt;. Thus the planner is permitted to use generic statistical information, such as the fraction of null values or the number of distinct values in a column, regardless of access privileges.</source>
          <target state="translated">이 제한 사항은 플래너가 &lt;code&gt;pg_statistic&lt;/code&gt; 의 하나 이상의 값에 대해 사용자 정의 연산자를 실행해야하는 경우에만 적용됩니다 . 따라서 플래너는 액세스 권한에 관계없이 Null 값의 비율 또는 열의 고유 값 수와 같은 일반 통계 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c63585630ca8ea8585e254ea84b2de23abf28ba" translate="yes" xml:space="preserve">
          <source>This restriction is made to reduce ambiguity. There is still ambiguity if an &lt;code&gt;ORDER BY&lt;/code&gt; item is a simple name that could match either an output column name or a column from the table expression. The output column is used in such cases. This would only cause confusion if you use &lt;code&gt;AS&lt;/code&gt; to rename an output column to match some other table column's name.</source>
          <target state="translated">이 제한은 모호성을 줄이기 위해 만들어졌습니다. &lt;code&gt;ORDER BY&lt;/code&gt; 항목이 출력 열 이름 또는 테이블 표현식의 열과 일치 할 수있는 단순 이름 인 경우에도 여전히 모호합니다 . 이 경우 출력 열이 사용됩니다. &lt;code&gt;AS&lt;/code&gt; 를 사용 하여 다른 테이블 열의 이름과 일치하도록 출력 열의 이름을 바꾸는 경우에만 혼란이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="d4b4e7539fae825407db528c4ddfb962b1364a94" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;description&lt;/code&gt; if it is not null, otherwise &lt;code&gt;short_description&lt;/code&gt; if it is not null, otherwise &lt;code&gt;(none)&lt;/code&gt;.</source>
          <target state="translated">이 반환 &lt;code&gt;description&lt;/code&gt; 은하지 그렇지 않은 경우는 null 인 경우 &lt;code&gt;short_description&lt;/code&gt; 는 그렇지 않은 경우는 null되지 않는 경우 &lt;code&gt;(none)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56453523ba12fcdc5569aa80495dc2ebae8ffdff" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;true&lt;/code&gt; if the entered password is correct.</source>
          <target state="translated">입력 한 비밀번호가 올바른 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="5e450193561cf91ce82c2251b4755de760a2b210" translate="yes" xml:space="preserve">
          <source>This scheme has a number of advantages compared to a more straightforward approach such as allowing row values to span pages. Assuming that queries are usually qualified by comparisons against relatively small key values, most of the work of the executor will be done using the main row entry. The big values of TOASTed attributes will only be pulled out (if selected at all) at the time the result set is sent to the client. Thus, the main table is much smaller and more of its rows fit in the shared buffer cache than would be the case without any out-of-line storage. Sort sets shrink also, and sorts will more often be done entirely in memory. A little test showed that a table containing typical HTML pages and their URLs was stored in about half of the raw data size including the TOAST table, and that the main table contained only about 10% of the entire data (the URLs and some small HTML pages). There was no run time difference compared to an un-TOASTed comparison table, in which all the HTML pages were cut down to 7 kB to fit.</source>
          <target state="translated">이 체계는 행 값이 페이지에 걸쳐있는 것과 같은보다 직접적인 접근 방식과 비교할 때 여러 가지 장점이 있습니다. 쿼리가 일반적으로 상대적으로 작은 키 값과 비교하여 자격이 있다고 가정하면 실행 프로그램의 대부분의 작업은 기본 행 항목을 사용하여 수행됩니다. TOASTed 속성의 큰 값은 결과 집합이 클라이언트로 전송 될 때만 가져옵니다 (모두 선택하는 경우). 따라서 기본 테이블은 외부 저장 영역이없는 경우보다 훨씬 더 작고 더 많은 행이 공유 버퍼 캐시에 맞습니다. 정렬 세트도 축소되며 정렬은 메모리에서 더 자주 수행됩니다. 약간의 테스트에 따르면 일반적인 HTML 페이지와 해당 URL이 포함 된 테이블이 TOAST 테이블을 포함하여 원시 데이터 크기의 약 절반에 저장되어 있음을 보여주었습니다.기본 테이블에는 전체 데이터 (URL 및 일부 작은 HTML 페이지)의 약 10 % 만 포함되어 있습니다. TOAST되지 않은 비교표와 비교하여 모든 HTML 페이지가 7kB로 줄어든 런타임 차이는 없었습니다.</target>
        </trans-unit>
        <trans-unit id="931ae4ac07974a516a75c4a0fb5344d4de15b384" translate="yes" xml:space="preserve">
          <source>This script allows each iteration of the transaction to reference different, randomly-chosen rows. (This example also shows why it's important for each client session to have its own variables &amp;mdash; otherwise they'd not be independently touching different rows.)</source>
          <target state="translated">이 스크립트를 사용하면 트랜잭션을 반복 할 때마다 무작위로 선택된 다른 행을 참조 할 수 있습니다. (이 예제는 또한 각 클라이언트 세션이 자체 변수를 갖는 것이 중요한 이유를 보여줍니다. 그렇지 않으면 서로 다른 행을 독립적으로 건드리지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="a06cc7d2225d879e4baf3b5d87eff2d8fceb78b2" translate="yes" xml:space="preserve">
          <source>This script will attempt to verify that you have done all the configuration steps correctly, and then it will run the regression tests for the &lt;code&gt;sepgsql&lt;/code&gt; module.</source>
          <target state="translated">이 스크립트는 모든 구성 단계를 올바르게 수행했는지 확인한 다음 &lt;code&gt;sepgsql&lt;/code&gt; 모듈에 대한 회귀 테스트를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="b4abfec97901c9f5545ed7f9d531e3f594a60d05" translate="yes" xml:space="preserve">
          <source>This second example shows a multiplication table with rows sorted in reverse numerical order and columns with an independent, ascending numerical order.</source>
          <target state="translated">이 두 번째 예는 행을 역순으로 정렬 한 열과 독립적 인 오름차순으로 정렬 된 열이있는 곱셈표를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="70517dd03c7a023f4b63122ef2607a8bb09453ad" translate="yes" xml:space="preserve">
          <source>This section concerns limits that are not inherent in the libxml2 library, but apply to the current implementation in PostgreSQL.</source>
          <target state="translated">이 섹션은 libxml2 라이브러리에 내재되어 있지 않지만 PostgreSQL의 현재 구현에 적용되는 제한에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4e94a4091d1abb9ffbdb35b9bc5912877ddcba29" translate="yes" xml:space="preserve">
          <source>This section covers B-Tree index implementation details that may be of use to advanced users. See &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; in the source distribution for a much more detailed, internals-focused description of the B-Tree implementation.</source>
          <target state="translated">이 섹션에서는 고급 사용자가 사용할 수있는 B- 트리 인덱스 구현 세부 정보를 다룹니다. B-Tree 구현에 대한 훨씬 더 자세한 내부 중심 설명은 소스 배포의 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9c2d04552ba91a05718611a7d18eeefc7243226" translate="yes" xml:space="preserve">
          <source>This section covers implementation details and other tricks that are useful for implementers of SP-GiST operator classes to know.</source>
          <target state="translated">이 섹션에서는 구현 세부 사항 및 SP-GiST 운영자 클래스 구현자가 알아야 할 기타 트릭에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="82ea52fe608db7eb14abb1bc47e7a0d7e788e138" translate="yes" xml:space="preserve">
          <source>This section covers parameters that may be used when only inserting new rows. Parameters &lt;em&gt;exclusively&lt;/em&gt; used with the &lt;code&gt;ON CONFLICT&lt;/code&gt; clause are described separately.</source>
          <target state="translated">이 섹션에서는 새 행을 삽입 할 때만 사용할 수있는 매개 변수에 대해 설명합니다. &lt;code&gt;ON CONFLICT&lt;/code&gt; 절 과 함께 &lt;em&gt;독점적으로&lt;/em&gt; 사용되는 매개 변수 는 별도로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="e7807f695e34f4b1eac9463bb59bd4074598384a" translate="yes" xml:space="preserve">
          <source>This section describes a PostgreSQL-specific way to create an autoincrementing column. Another way is to use the SQL-standard identity column feature, described at &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 자동 증가 열을 생성하는 PostgreSQL 관련 방법에 대해 설명합니다. 다른 방법은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE에&lt;/a&gt; 설명 된 SQL 표준 ID 열 기능을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4f81e5e9f39108fa574970aa59c9663d6ba95ff1" translate="yes" xml:space="preserve">
          <source>This section describes additional functions and operators that are useful in connection with text search.</source>
          <target state="translated">이 섹션에서는 텍스트 검색과 관련하여 유용한 추가 기능 및 연산자에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c2ae13af2d3ddf62ac5901d20f9f9c54bb6f2eab" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating binary strings, that is values of type &lt;code&gt;bytea&lt;/code&gt;. Many of these are equivalent, in purpose and syntax, to the text-string functions described in the previous section.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;bytea&lt;/code&gt; 유형의 값인 이진 문자열을 검사하고 조작하기위한 함수와 연산자를 설명합니다 . 이들 중 대부분은 목적과 구문에서 이전 섹션에서 설명한 텍스트 문자열 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b2cbf42b02f5c651095d7686f2a3413bfe1a3d1d" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating bit strings, that is values of the types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;. (While only type &lt;code&gt;bit&lt;/code&gt; is mentioned in these tables, values of type &lt;code&gt;bit varying&lt;/code&gt; can be used interchangeably.) Bit strings support the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt;, as well as the operators shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;bit&lt;/code&gt; 및 &lt;code&gt;bit varying&lt;/code&gt; 유형의 값인 비트 문자열을 검사하고 조작하기위한 함수 및 연산자에 대해 설명합니다 . ( 이 테이블에는 유형 &lt;code&gt;bit&lt;/code&gt; 만 언급되어 있지만 &lt;code&gt;bit varying&lt;/code&gt; 유형의 값은 서로 바꿔서 사용할 수 있습니다.) 비트 문자열 은 &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14에&lt;/a&gt; 표시된 연산자뿐 아니라 &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1에&lt;/a&gt; 표시된 일반적인 비교 연산자를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="4a4f8d994f18d2a21002c3a9cf18de77dd441569" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating bit strings, that is values of the types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;. Aside from the usual comparison operators, the operators shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt; can be used. Bit string operands of &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; must be of equal length. When bit shifting, the original length of the string is preserved, as shown in the examples.</source>
          <target state="translated">이 섹션에서는 비트 문자열을 검사하고 조작하기위한 함수 및 연산자, 즉 &lt;code&gt;bit&lt;/code&gt; 및 &lt;code&gt;bit varying&lt;/code&gt; 유형의 값에 대해 설명합니다 . 일반적인 비교 연산자 외에도 &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;표 9.14에&lt;/a&gt; 표시된 연산자를 사용할 수 있습니다. 의 비트 문자열 피연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; 및 &lt;code&gt;#&lt;/code&gt; 은 길이가 같아야합니다. 비트 이동시 예제와 같이 문자열의 원래 길이가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4e0fe72449b8f5ee00166f169b410f0184155751" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating string values. Strings in this context include values of the types &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, and &lt;code&gt;text&lt;/code&gt;. Except where noted, these functions and operators are declared to accept and return type &lt;code&gt;text&lt;/code&gt;. They will interchangeably accept &lt;code&gt;character varying&lt;/code&gt; arguments. Values of type &lt;code&gt;character&lt;/code&gt; will be converted to &lt;code&gt;text&lt;/code&gt; before the function or operator is applied, resulting in stripping any trailing spaces in the &lt;code&gt;character&lt;/code&gt; value.</source>
          <target state="translated">이 섹션에서는 문자열 값을 검사하고 조작하기위한 함수와 연산자에 대해 설명합니다. 이 컨텍스트의 문자열에는 &lt;code&gt;character&lt;/code&gt; 유형 , &lt;code&gt;character varying&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 값이 포함됩니다 . 명시된 경우를 제외하고 이러한 함수와 연산자는 &lt;code&gt;text&lt;/code&gt; 유형을 허용하고 반환하도록 선언됩니다 . &lt;code&gt;character varying&lt;/code&gt; 인수를 서로 바꿔서 사용할 수 있습니다. &lt;code&gt;character&lt;/code&gt; 유형의 값은 함수 또는 연산자가 적용되기 전에 &lt;code&gt;text&lt;/code&gt; 로 변환되어 &lt;code&gt;character&lt;/code&gt; 값의 후행 공백이 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="87c3af132af71e9d06f2e69bc9cb2fabb82cfdae" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating string values. Strings in this context include values of the types &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, and &lt;code&gt;text&lt;/code&gt;. Unless otherwise noted, all of the functions listed below work on all of these types, but be wary of potential effects of automatic space-padding when using the &lt;code&gt;character&lt;/code&gt; type. Some functions also exist natively for the bit-string types.</source>
          <target state="translated">이 섹션에서는 문자열 값을 검사하고 조작하기위한 함수와 연산자에 대해 설명합니다. 이 컨텍스트의 문자열에는 &lt;code&gt;character&lt;/code&gt; 유형 , &lt;code&gt;character varying&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 값이 포함됩니다 . 달리 명시되지 않는 한, 아래에 나열된 모든 기능은 이러한 모든 유형에서 작동하지만 &lt;code&gt;character&lt;/code&gt; 유형을 사용할 때 자동 공백 채우기의 잠재적 영향에주의하십시오 . 비트 스트링 유형에 대해 일부 함수도 기본적으로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="33495850b72b20959dd4e9cc8d5ffd57ebaf33b2" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating values of type &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">이 절에서는 &lt;code&gt;bytea&lt;/code&gt; 유형의 값을 검사하고 조작하기위한 함수와 연산자에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="4e496c508c41ace731778c7db8e284ddab372720" translate="yes" xml:space="preserve">
          <source>This section describes functions for operating on &lt;em&gt;sequence objects&lt;/em&gt;, also called sequence generators or just sequences. Sequence objects are special single-row tables created with &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;. Sequence objects are commonly used to generate unique identifiers for rows of a table. The sequence functions, listed in &lt;a href=&quot;functions-sequence#FUNCTIONS-SEQUENCE-TABLE&quot;&gt;Table 9.50&lt;/a&gt;, provide simple, multiuser-safe methods for obtaining successive sequence values from sequence objects.</source>
          <target state="translated">이 섹션에서는 시퀀스 생성기 또는 시퀀스라고도 하는 &lt;em&gt;시퀀스 객체&lt;/em&gt; 에서 작동하는 기능에 대해 설명합니다 . 시퀀스 오브젝트는 &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE로&lt;/a&gt; 작성된 특수 단일 행 테이블입니다 . 시퀀스 객체는 일반적으로 테이블의 행에 대한 고유 식별자를 생성하는 데 사용됩니다. &lt;a href=&quot;functions-sequence#FUNCTIONS-SEQUENCE-TABLE&quot;&gt;Table 9.50에&lt;/a&gt; 나열된 시퀀스 함수 는 시퀀스 객체에서 연속적인 시퀀스 값을 얻기위한 간단한 다중 사용자 안전 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5bbad968fc5872c67f7bc619db0866c3845188b7" translate="yes" xml:space="preserve">
          <source>This section describes functions that possibly return more than one row. The most widely used functions in this class are series generating functions, as detailed in &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SERIES&quot;&gt;Table 9.61&lt;/a&gt; and &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;Table 9.62&lt;/a&gt;. Other, more specialized set-returning functions are described elsewhere in this manual. See &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;Section 7.2.1.4&lt;/a&gt; for ways to combine multiple set-returning functions.</source>
          <target state="translated">이 절에서는 둘 이상의 행을 리턴 할 수있는 함수에 대해 설명합니다. 이 클래스에서 가장 널리 사용되는 함수는 &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SERIES&quot;&gt;표 9.61&lt;/a&gt; 및 &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;표 9.62에&lt;/a&gt; 자세히 설명 된대로 시리즈 생성 함수 입니다. 보다 전문적인 다른 세트 리턴 기능은이 매뉴얼의 다른 곳에 설명되어 있습니다. 여러 세트 반환 기능을 결합하는 방법에 대해서는 &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;7.2.1.4 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dfa6ccb5fc708e17b3c2138c2ea27f1c67b607b" translate="yes" xml:space="preserve">
          <source>This section describes several specialized constructs for making multiple comparisons between groups of values. These forms are syntactically related to the subquery forms of the previous section, but do not involve subqueries. The forms involving array subexpressions are PostgreSQL extensions; the rest are SQL-compliant. All of the expression forms documented in this section return Boolean (true/false) results.</source>
          <target state="translated">이 섹션에서는 값 그룹간에 여러 비교를 수행하기위한 몇 가지 특수 구조를 설명합니다. 이러한 형식은 이전 섹션의 하위 쿼리 형식과 구문 상 관련이 있지만 하위 쿼리는 포함하지 않습니다. 배열 하위 표현식과 관련된 형식은 PostgreSQL 확장입니다. 나머지는 SQL을 준수합니다. 이 섹션에 설명 된 모든 표현식 양식은 부울 (참 / 거짓) 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57f85eb5e6f2d55d8369ac9b3abade0eafd046e8" translate="yes" xml:space="preserve">
          <source>This section describes the SQL-compliant conditional expressions available in PostgreSQL.</source>
          <target state="translated">이 섹션에서는 PostgreSQL에서 사용할 수있는 SQL 호환 조건식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5da57e6e3608b9fe086d7f3b55296f911c387483" translate="yes" xml:space="preserve">
          <source>This section describes the SQL-compliant subquery expressions available in PostgreSQL. All of the expression forms documented in this section return Boolean (true/false) results.</source>
          <target state="translated">이 섹션에서는 PostgreSQL에서 사용할 수있는 SQL 호환 하위 쿼리 표현식에 대해 설명합니다. 이 섹션에 설명 된 모든 표현식 양식은 부울 (참 / 거짓) 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="161fd87db311749fb3c7966d6e4c44e430dceb4a" translate="yes" xml:space="preserve">
          <source>This section describes the settings that apply only for the duration of the recovery. They must be reset for any subsequent recovery you wish to perform.</source>
          <target state="translated">이 섹션에서는 복구 기간 동안 만 적용되는 설정에 대해 설명합니다. 수행하려는 후속 복구에 대해 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec4289c6ae60dc86583f63bcfa1ab2282875f421" translate="yes" xml:space="preserve">
          <source>This section describes the storage format at the level of files and directories.</source>
          <target state="translated">이 섹션에서는 파일 및 디렉토리 수준의 저장소 형식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ba5d2422f445963cd3ce879f09ea9078bbeca96e" translate="yes" xml:space="preserve">
          <source>This section describes:</source>
          <target state="translated">이 섹션에서는 다음을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ece9977ad348713454c60a551c6e69fda61960b" translate="yes" xml:space="preserve">
          <source>This section discusses how to upgrade your database data from one PostgreSQL release to a newer one.</source>
          <target state="translated">이 섹션에서는 데이터베이스 데이터를 하나의 PostgreSQL 릴리스에서 최신 릴리스로 업그레이드하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="48ea0981b8339378a93a9c98caccd890ae95e94c" translate="yes" xml:space="preserve">
          <source>This section introduces multivariate variant of MCV (most-common values) lists, a straightforward extension of the per-column statistics described in &lt;a href=&quot;row-estimation-examples&quot;&gt;Section 70.1&lt;/a&gt;. These statistics address the limitation by storing individual values, but it is naturally more expensive, both in terms of building the statistics in &lt;code&gt;ANALYZE&lt;/code&gt;, storage and planning time.</source>
          <target state="translated">이 섹션에서는 &lt;a href=&quot;row-estimation-examples&quot;&gt;섹션 70.1에&lt;/a&gt; 설명 된 컬럼 별 통계의 간단한 확장 인 MCV (가장 일반적인 값) 목록의 다변량 변형을 소개 합니다. 이러한 통계는 개별 값을 저장하여 한계를 해결하지만 &lt;code&gt;ANALYZE&lt;/code&gt; 의 통계 작성 , 저장 및 계획 시간 측면에서 자연스럽게 더 비쌉니다 .</target>
        </trans-unit>
        <trans-unit id="b7347f9c564588e3c1f50679c373c1a34d851437" translate="yes" xml:space="preserve">
          <source>This section presents some of the resulting differences you may encounter.</source>
          <target state="translated">이 섹션에서는 발생할 수있는 몇 가지 차이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="987de3a2c28c06d130851059547cd1a57f333d64" translate="yes" xml:space="preserve">
          <source>This section provides an overview of TOAST (The Oversized-Attribute Storage Technique).</source>
          <target state="translated">이 섹션에서는 TOAST (대용량 속성 스토리지 기술)에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="22e2c735002756aac0cd53f48c77e94addceba8d" translate="yes" xml:space="preserve">
          <source>This section provides an overview of the page format used within PostgreSQL tables and indexes.&lt;a href=&quot;#ftn.id-1.10.21.8.2.2&quot;&gt;&lt;sup id=&quot;id-1.10.21.8.2.2&quot;&gt;[15]&lt;/sup&gt;&lt;/a&gt; Sequences and TOAST tables are formatted just like a regular table.</source>
          <target state="translated">이 섹션에서는 PostgreSQL 테이블 및 인덱스에서 사용되는 페이지 형식에 대한 개요를 제공합니다. &lt;a href=&quot;#ftn.id-1.10.21.8.2.2&quot;&gt;&lt;sup id=&quot;id-1.10.21.8.2.2&quot;&gt;[15]&lt;/sup&gt;&lt;/a&gt; 시퀀스 및 TOAST 테이블은 일반 테이블처럼 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b7ff27c909be2ddf359caa08cc7dd7e70850531" translate="yes" xml:space="preserve">
          <source>This sets only the minimum number of segments retained in &lt;code&gt;pg_wal&lt;/code&gt;; the system might need to retain more segments for WAL archival or to recover from a checkpoint. If &lt;code&gt;wal_keep_segments&lt;/code&gt; is zero (the default), the system doesn't keep any extra segments for standby purposes, so the number of old WAL segments available to standby servers is a function of the location of the previous checkpoint and status of WAL archiving. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이것은 &lt;code&gt;pg_wal&lt;/code&gt; 에 유지되는 최소 세그먼트 수만 설정합니다 . 시스템은 WAL 보관을 위해 더 많은 세그먼트를 유지하거나 검사 점에서 복구해야 할 수도 있습니다. 경우 &lt;code&gt;wal_keep_segments&lt;/code&gt; 가 제로 (기본값)는 대기 서버로 사용할 수 오래된 WAL 세그먼트의 수는 WAL 보관의 이전 체크 포인트 및 상태의 위치의 함수이기 때문에, 시스템은 대기 목적을 위해 여분의 세그먼트를 유지하지 않습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60c40705443d693c37c2a4350a7f0525d8e96e6c" translate="yes" xml:space="preserve">
          <source>This sets only the minimum size of segments retained in &lt;code&gt;pg_wal&lt;/code&gt;; the system might need to retain more segments for WAL archival or to recover from a checkpoint. If &lt;code&gt;wal_keep_size&lt;/code&gt; is zero (the default), the system doesn't keep any extra segments for standby purposes, so the number of old WAL segments available to standby servers is a function of the location of the previous checkpoint and status of WAL archiving. If this value is specified without units, it is taken as megabytes. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이것은 &lt;code&gt;pg_wal&lt;/code&gt; 에 유지되는 세그먼트의 최소 크기 만 설정합니다 . 시스템은 WAL 보관을 위해 더 많은 세그먼트를 유지하거나 체크 포인트에서 복구해야 할 수 있습니다. 경우 &lt;code&gt;wal_keep_size&lt;/code&gt; 가 제로 (기본값)는 대기 서버로 사용할 수 오래된 WAL 세그먼트의 수는 WAL 보관의 이전 체크 포인트 및 상태의 위치의 함수이기 때문에, 시스템은 대기 목적을 위해 여분의 세그먼트를 유지하지 않습니다. 이 값을 단위없이 지정하면 메가 바이트로 간주됩니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52a9b5608610577ceec8bb54f78e5c4867056fa3" translate="yes" xml:space="preserve">
          <source>This sets the number of workers that should be used to assist a parallel scan of this table. If not set, the system will determine a value based on the relation size. The actual number of workers chosen by the planner or by utility statements that use parallel scans may be less, for example due to the setting of &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;.</source>
          <target state="translated">이 테이블의 병렬 스캔을 지원하는 데 사용해야하는 작업자 수를 설정합니다. 설정하지 않으면 시스템은 관계 크기에 따라 값을 결정합니다. &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; 설정으로 인해 플래너 또는 병렬 스캔을 사용하는 유틸리티 명령문에 의해 선택된 실제 작업자 수는 더 적을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc2b98f968a25c7e42b52a06c47e3ef33cd30253" translate="yes" xml:space="preserve">
          <source>This setting constrains the total space used at any instant by all temporary files used by a given PostgreSQL process. It should be noted that disk space used for explicit temporary tables, as opposed to temporary files used behind-the-scenes in query execution, does &lt;em&gt;not&lt;/em&gt; count against this limit.</source>
          <target state="translated">이 설정은 특정 PostgreSQL 프로세스에서 사용하는 모든 임시 파일이 즉시 사용하는 총 공간을 제한합니다. 명시 적 임시 테이블에 사용되는 디스크 공간은 쿼리 실행시 비하인드 파일과 달리이 제한에 포함 되지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="139dfa45f922c9380ccf94aed30326869ecb29b0" translate="yes" xml:space="preserve">
          <source>This setting controls usage of the fast update technique described in &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt;. It is a Boolean parameter: &lt;code&gt;ON&lt;/code&gt; enables fast update, &lt;code&gt;OFF&lt;/code&gt; disables it. (Alternative spellings of &lt;code&gt;ON&lt;/code&gt; and &lt;code&gt;OFF&lt;/code&gt; are allowed as described in &lt;a href=&quot;config-setting&quot;&gt;Section 19.1&lt;/a&gt;.) The default is &lt;code&gt;ON&lt;/code&gt;.</source>
          <target state="translated">이 설정은 &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;섹션 66.4.1에&lt;/a&gt; 설명 된 빠른 업데이트 기술의 사용을 제어합니다 . 부울 매개 변수입니다. &lt;code&gt;ON&lt;/code&gt; 은 빠른 업데이트를 활성화하고 &lt;code&gt;OFF&lt;/code&gt; 는 비활성화합니다. ( &lt;a href=&quot;config-setting&quot;&gt;19.1 절에&lt;/a&gt; 설명 된대로 &lt;code&gt;ON&lt;/code&gt; 및 &lt;code&gt;OFF&lt;/code&gt; 의 다른 철자법 이 허용됩니다 .) 기본값은 &lt;code&gt;ON&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf3f9cd2ec6037cc1a1e53b4e2acfa5803c6cdf6" translate="yes" xml:space="preserve">
          <source>This setting controls usage of the fast update technique described in &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt;. It is a Boolean parameter: &lt;code&gt;ON&lt;/code&gt; enables fast update, &lt;code&gt;OFF&lt;/code&gt; disables it. The default is &lt;code&gt;ON&lt;/code&gt;.</source>
          <target state="translated">이 설정은 &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;섹션 66.4.1에&lt;/a&gt; 설명 된 빠른 업데이트 기술의 사용을 제어합니다 . 부울 매개 변수입니다. &lt;code&gt;ON&lt;/code&gt; 은 빠른 업데이트를 활성화하고 , &lt;code&gt;OFF&lt;/code&gt; 는 비활성화합니다. 기본값은 &lt;code&gt;ON&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88c5ee85f398c9445f5170ac51b66b98052f302e" translate="yes" xml:space="preserve">
          <source>This setting does not attempt to guarantee that an error will be generated under any particular circumstances. In fact, if the correct results can be generated from (for example) a cursor which has materialized a result set, no error will be generated even if the underlying rows in the referenced table have been vacuumed away. Some tables cannot safely be vacuumed early, and so will not be affected by this setting, such as system catalogs. For such tables this setting will neither reduce bloat nor create a possibility of a &amp;ldquo;snapshot too old&amp;rdquo; error on scanning.</source>
          <target state="translated">이 설정은 특정 상황에서 오류가 발생하는 것을 보증하지 않습니다. 실제로, 예를 들어 결과 세트를 구체화 한 커서에서 올바른 결과를 생성 할 수있는 경우 참조 된 테이블의 기본 행이 진공 처리 되어도 오류가 발생하지 않습니다. 일부 테이블은 안전하게 정리할 수 없으므로 시스템 카탈로그와 같은이 설정의 영향을받지 않습니다. 이러한 테이블의 경우이 설정으로 인해 부풀림 현상이 줄어들거나 스캔시 &quot;스냅 샷이 너무 오래되었습니다&quot;오류가 발생할 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a17178f6f108f66e558374c8c51711f31a5f8a53" translate="yes" xml:space="preserve">
          <source>This setting does not override the behavior of &lt;code&gt;old_snapshot_threshold&lt;/code&gt; on the primary; a snapshot on the standby which exceeds the primary's age threshold can become invalid, resulting in cancellation of transactions on the standby. This is because &lt;code&gt;old_snapshot_threshold&lt;/code&gt; is intended to provide an absolute limit on the time which dead rows can contribute to bloat, which would otherwise be violated because of the configuration of a standby.</source>
          <target state="translated">이 설정은 기본 에서 &lt;code&gt;old_snapshot_threshold&lt;/code&gt; 의 동작을 무시하지 않습니다 . 기본의 기간 임계 값을 초과하는 대기의 스냅 샷이 유효하지 않게되어 대기에서 트랜잭션이 취소 될 수 있습니다. 이는 &lt;code&gt;old_snapshot_threshold&lt;/code&gt; 가 데드 행이 팽창에 기여할 수있는 시간에 대한 절대 한계를 제공하기위한 것이므로 대기 구성으로 인해 위반 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75e909e2915702b5ef44ed6b9bc45b154af3c719" translate="yes" xml:space="preserve">
          <source>This setting has lower priority than &lt;code&gt;log_min_duration_statement&lt;/code&gt;, meaning that statements with durations exceeding &lt;code&gt;log_min_duration_statement&lt;/code&gt; are not subject to sampling and are always logged.</source>
          <target state="translated">이 설정은 &lt;code&gt;log_min_duration_statement&lt;/code&gt; 보다 우선 순위가 낮습니다 . 즉, 기간이 &lt;code&gt;log_min_duration_statement&lt;/code&gt; 를 초과하는 문 은 샘플링 대상이 아니며 항상 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="30bbbf8d25fa89c91c122a573c367986c6688ee4" translate="yes" xml:space="preserve">
          <source>This setting has no effect if &lt;code&gt;G&lt;/code&gt; is specified in &lt;code&gt;-I&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;G&lt;/code&gt; 가 &lt;code&gt;-I&lt;/code&gt; 에 지정된 경우이 설정은 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9fcceaeb0992bcd64acc1981c44ad2c4975f0743" translate="yes" xml:space="preserve">
          <source>This setting has no effect if no recovery target is set. If &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; is not enabled, a setting of &lt;code&gt;pause&lt;/code&gt; will act the same as &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">복구 대상이 설정되어 있지 않으면이 설정이 적용되지 않습니다. 경우 &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby는&lt;/a&gt; 사용할 수 없습니다의 설정 &lt;code&gt;pause&lt;/code&gt; 와 같은 역할을합니다 &lt;code&gt;shutdown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b54b0267f4e95220b4cbe85438dae82b1b7a7e5d" translate="yes" xml:space="preserve">
          <source>This setting has no effect if no recovery target is set. If &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; is not enabled, a setting of &lt;code&gt;pause&lt;/code&gt; will act the same as &lt;code&gt;shutdown&lt;/code&gt;. If the recovery target is reached while a promotion is ongoing, a setting of &lt;code&gt;pause&lt;/code&gt; will act the same as &lt;code&gt;promote&lt;/code&gt;.</source>
          <target state="translated">복구 대상이 설정되지 않은 경우이 설정은 적용되지 않습니다. &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; 가 활성화되지 않은 경우 &lt;code&gt;pause&lt;/code&gt; 설정은 &lt;code&gt;shutdown&lt;/code&gt; 과 동일하게 작동합니다 . 승격이 진행되는 동안 복구 대상에 도달하면 &lt;code&gt;pause&lt;/code&gt; 설정이 &lt;code&gt;promote&lt;/code&gt; 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="aff67729130b72538eec21d5c35d1c92d507ac67" translate="yes" xml:space="preserve">
          <source>This setting only affects log messages printed as a result of &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, &lt;a href=&quot;runtime-config-logging#GUC-LOG-DURATION&quot;&gt;log_duration&lt;/a&gt;, and related settings. Non-zero values of this setting add some overhead, particularly if parameters are sent in binary form, since then conversion to text is required.</source>
          <target state="translated">이 설정은 &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt; , &lt;a href=&quot;runtime-config-logging#GUC-LOG-DURATION&quot;&gt;log_duration&lt;/a&gt; 및 관련 설정 의 결과로 인쇄되는 로그 메시지에만 영향을줍니다 . 이 설정의 0이 아닌 값은 특히 매개 변수가 이진 형식으로 전송 된 경우 텍스트로의 변환이 필요하므로 약간의 오버 헤드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="243a6a2a0cf02294a9fc7bce185732812dc50642" translate="yes" xml:space="preserve">
          <source>This shell syntax can get tedious quickly. Therefore the wrapper program &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; is provided to simplify some tasks. For example:</source>
          <target state="translated">이 셸 구문은 지루할 수 있습니다. 따라서 일부 태스크를 단순화하기 위해 랩퍼 프로그램 &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; 이 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1732a07a9954b37aedbdc19948ece5c409757c1b" translate="yes" xml:space="preserve">
          <source>This shortest-precise output format is much faster to generate than the historical rounded format.</source>
          <target state="translated">이 가장 짧은 정확한 출력 형식은 과거 반올림 형식보다 생성 속도가 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="98021c2c2c1d427e7a19ee968ec54370a03719cc" translate="yes" xml:space="preserve">
          <source>This should be used if the view is intended to provide row-level security. See &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details.</source>
          <target state="translated">보기가 행 레벨 보안을 제공하려는 경우에 사용해야합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ba8bb8c29738e1638f51e3c6948a3404fcdfbaa0" translate="yes" xml:space="preserve">
          <source>This should be used if the view is intended to provide row-level security. See &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details.</source>
          <target state="translated">뷰가 행 수준 보안을 제공하려는 경우에 사용해야합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="207a8bf754b11f0d0bc92abd250767a3408a12a5" translate="yes" xml:space="preserve">
          <source>This should give:</source>
          <target state="translated">이것은 다음을 제공해야합니다 :</target>
        </trans-unit>
        <trans-unit id="8430336b76d6ed211113aaafd34defc44406bde4" translate="yes" xml:space="preserve">
          <source>This simple example is like an inner join on &lt;code&gt;col2&lt;/code&gt;, but it produces at most one output row for each &lt;code&gt;tab1&lt;/code&gt; row, even if there are several matching &lt;code&gt;tab2&lt;/code&gt; rows:</source>
          <target state="translated">이 간단한 예제는 &lt;code&gt;col2&lt;/code&gt; 의 내부 조인과 유사 하지만 , 일치하는 &lt;code&gt;tab2&lt;/code&gt; 행 이 여러 개인 경우에도 각 &lt;code&gt;tab1&lt;/code&gt; 행 에 대해 최대 하나의 출력 행을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="ef082c18dfaad5c1a6c1b5da836306677be5d419" translate="yes" xml:space="preserve">
          <source>This situation might arise from use of a view that contains a join; the view's &lt;code&gt;SELECT&lt;/code&gt; rule will be inserted in place of the view reference, yielding a query much like the above. Normally, the planner will try to collapse the subquery into the parent, yielding:</source>
          <target state="translated">이 상황은 조인이 포함 된 뷰를 사용하여 발생할 수 있습니다. 뷰의 &lt;code&gt;SELECT&lt;/code&gt; 규칙이 뷰 참조 대신 삽입되어 위와 유사한 쿼리가 생성됩니다. 일반적으로 플래너는 하위 쿼리를 상위 쿼리로 축소하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a39e33486ee442780bd96095dc0388345e0cdf9e" translate="yes" xml:space="preserve">
          <source>This solution requires that index scans be &amp;ldquo;synchronous&amp;rdquo;: we have to fetch each heap tuple immediately after scanning the corresponding index entry. This is expensive for a number of reasons. An &amp;ldquo;asynchronous&amp;rdquo; scan in which we collect many TIDs from the index, and only visit the heap tuples sometime later, requires much less index locking overhead and can allow a more efficient heap access pattern. Per the above analysis, we must use the synchronous approach for non-MVCC-compliant snapshots, but an asynchronous scan is workable for a query using an MVCC snapshot.</source>
          <target state="translated">이 솔루션은 인덱스 스캔이 &quot;동기식&quot;이어야합니다. 해당 인덱스 항목을 스캔 한 직후 각 힙 튜플을 가져와야합니다. 여러 가지 이유로 비싸다. 인덱스에서 많은 TID를 수집하고 언젠가 힙 튜플 만 방문하는 &quot;비동기&quot;스캔은 인덱스 잠금 오버 헤드가 훨씬 적고보다 효율적인 힙 액세스 패턴을 허용 할 수 있습니다. 위의 분석에 따라 비 MVCC 호환 스냅 샷에는 동기 방식을 사용해야하지만 MVCC 스냅 샷을 사용하는 쿼리에는 비동기 스캔을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58431f9279cf2f016596c7e33d4276e32dc1fc57" translate="yes" xml:space="preserve">
          <source>This sort of arrangement gives a unique name for each configuration file variation. This can help eliminate ambiguity when several servers have their configurations all stored in one place, such as in a version control repository. (Storing database configuration files under version control is another good practice to consider.)</source>
          <target state="translated">이러한 정렬은 각 구성 파일 변형에 고유 한 이름을 제공합니다. 이를 통해 여러 서버의 구성이 버전 관리 저장소와 같은 한 곳에 모두 저장되어있을 때 모호성을 제거 할 수 있습니다. (버전 제어하에 데이터베이스 구성 파일을 저장하는 것도 고려해야합니다.)</target>
        </trans-unit>
        <trans-unit id="9da156a75ef112b4defafc29639879cb4c7837ee" translate="yes" xml:space="preserve">
          <source>This specifies that the combination of values in the indicated columns is unique across the whole table, though any one of the columns need not be (and ordinarily isn't) unique.</source>
          <target state="translated">열 중 하나가 고유하지 않아도되지만 표시된 열의 값 조합이 전체 테이블에서 고유하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="50433f72840feb7b225965b424dc31d63bcc0468" translate="yes" xml:space="preserve">
          <source>This specifies whether the trigger function should be fired once for every row affected by the trigger event, or just once per SQL statement. If neither is specified, &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; is the default. Constraint triggers can only be specified &lt;code&gt;FOR EACH ROW&lt;/code&gt;.</source>
          <target state="translated">트리거 이벤트의 영향을받는 모든 행에 대해 트리거 함수를 실행해야하는지 또는 SQL 문당 한 번만 실행해야하는지 지정합니다. 어느 것도 지정하지 않으면 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 가 기본값입니다. 제약 조건 트리거는 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65ec2d513cde79958e874b751ab72a29f3d98df0" translate="yes" xml:space="preserve">
          <source>This standby's &lt;code&gt;xmin&lt;/code&gt; horizon reported by &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY-FEEDBACK&quot;&gt;hot_standby_feedback&lt;/a&gt;.</source>
          <target state="translated">이 대기의 &lt;code&gt;xmin&lt;/code&gt; 지평선은 &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY-FEEDBACK&quot;&gt;hot_standby_feedback에&lt;/a&gt; 의해보고되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a5eb77416f4fbff585a0d52973a7eb52599177c4" translate="yes" xml:space="preserve">
          <source>This statement is partially compatible with the &lt;code&gt;ALTER FUNCTION&lt;/code&gt; statement in the SQL standard. The standard allows more properties of a function to be modified, but does not provide the ability to rename a function, make a function a security definer, attach configuration parameter values to a function, or change the owner, schema, or volatility of a function. The standard also requires the &lt;code&gt;RESTRICT&lt;/code&gt; key word, which is optional in PostgreSQL.</source>
          <target state="translated">이 명령문은 SQL 표준 의 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 문과 부분적으로 호환됩니다 . 표준을 사용하면 함수의 더 많은 속성을 수정할 수 있지만 함수의 이름을 바꾸거나 함수를 보안 정의 자로 만들거나 함수에 구성 매개 변수 값을 첨부하거나 함수의 소유자, 스키마 또는 휘발성을 변경하는 기능은 제공하지 않습니다. . 이 표준에는 &lt;code&gt;RESTRICT&lt;/code&gt; 키워드 도 필요합니다 . PostgreSQL에서는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="bab59343a0c1e996fdb8d33ae8133f4f89f5db11" translate="yes" xml:space="preserve">
          <source>This statement is partially compatible with the &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; statement in the SQL standard. The standard allows more properties of a procedure to be modified, but does not provide the ability to rename a procedure, make a procedure a security definer, attach configuration parameter values to a procedure, or change the owner, schema, or volatility of a procedure. The standard also requires the &lt;code&gt;RESTRICT&lt;/code&gt; key word, which is optional in PostgreSQL.</source>
          <target state="translated">이 명령문은 SQL 표준 의 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 문과 부분적으로 호환됩니다 . 표준은 프로 시저의 더 많은 특성을 수정할 수 있지만 프로 시저의 이름을 바꾸거나 프로 시저를 보안 정의 자로 만들거나 프로 시저에 구성 매개 변수 값을 첨부하거나 프로 시저의 소유자, 스키마 또는 변동성을 변경하는 기능을 제공하지 않습니다. . 이 표준에는 &lt;code&gt;RESTRICT&lt;/code&gt; 키워드 도 필요합니다 . PostgreSQL에서는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="67eeb572930074f1aa2002423769801647479601" translate="yes" xml:space="preserve">
          <source>This statement is partially compatible with the &lt;code&gt;ALTER ROUTINE&lt;/code&gt; statement in the SQL standard. See under &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt; and &lt;a href=&quot;sql-alterprocedure&quot;&gt;ALTER PROCEDURE&lt;/a&gt; for more details. Allowing routine names to refer to aggregate functions is a PostgreSQL extension.</source>
          <target state="translated">이 명령문은 SQL 표준 의 &lt;code&gt;ALTER ROUTINE&lt;/code&gt; 문과 부분적으로 호환됩니다 . 자세한 내용은 &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt; 및 &lt;a href=&quot;sql-alterprocedure&quot;&gt;ALTER PROCEDURE&lt;/a&gt; 를 참조하십시오. 루틴 이름이 집계 함수를 참조하도록 허용하는 것은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="18979809699a0da3f5c4a5180cc7bf11bc2207bc" translate="yes" xml:space="preserve">
          <source>This syntax is also available in PostgreSQL.</source>
          <target state="translated">이 구문은 PostgreSQL에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90c440913cb92e8f17aef62117fa623f19d86749" translate="yes" xml:space="preserve">
          <source>This syntax is not as commonly used as the one above, but we show it here to help you understand the following topics.</source>
          <target state="translated">이 구문은 위의 구문만큼 일반적으로 사용되지 않지만 다음 주제를 이해하는 데 도움이되도록 여기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5b79ba66ac4c531cc13f46e2424e3fe201d124e6" translate="yes" xml:space="preserve">
          <source>This table sampling method accepts a single floating-point argument that is the maximum number of milliseconds to spend reading the table. This gives you direct control over how long the query takes, at the price that the size of the sample becomes hard to predict. The resulting sample will contain as many rows as could be read in the specified time, unless the whole table has been read first.</source>
          <target state="translated">이 테이블 샘플링 방법은 테이블을 읽는 데 소요되는 최대 밀리 초 수인 단일 부동 소수점 인수를 허용합니다. 따라서 샘플 크기를 예측하기 어려워지는 가격으로 쿼리 소요 시간을 직접 제어 할 수 있습니다. 전체 샘플을 먼저 읽지 않은 경우 결과 샘플에는 지정된 시간에 읽을 수있는만큼의 행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5d13a701183ff5565141456253121184e55459bd" translate="yes" xml:space="preserve">
          <source>This table sampling method accepts a single integer argument that is the maximum number of rows to read. The resulting sample will always contain exactly that many rows, unless the table does not contain enough rows, in which case the whole table is selected.</source>
          <target state="translated">이 테이블 샘플링 방법은 읽을 최대 행 수인 단일 정수 인수를 허용합니다. 테이블에 충분한 행이 포함되어 있지 않으면 전체 테이블이 선택되지 않는 한 결과 샘플에는 항상 정확히 많은 행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e5f2abc30d834e5b2c40918a5861662c490e2353" translate="yes" xml:space="preserve">
          <source>This technique can be used with &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints too; the indexes are created implicitly when the constraint is created. Example:</source>
          <target state="translated">이 기술은 &lt;code&gt;UNIQUE&lt;/code&gt; 및 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건 과 함께 사용할 수도 있습니다 . 제한 조건이 작성 될 때 인덱스가 내재적으로 작성됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="3d162e1cfd2d4961b90fb7a1a7999e3946102a8e" translate="yes" xml:space="preserve">
          <source>This tells the function handler how to invoke the function. It might be the actual source code of the function for interpreted languages, a link symbol, a file name, or just about anything else, depending on the implementation language/call convention.</source>
          <target state="translated">함수 핸들러에게 함수를 호출하는 방법을 알려줍니다. 구현 언어 / 통화 규칙에 따라 해석 언어, 링크 기호, 파일 이름 또는 그 밖의 다른 기능에 대한 함수의 실제 소스 코드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72d8bd7d6c5c610d060a644d5f6d4b8415bd748f" translate="yes" xml:space="preserve">
          <source>This term is also used to refer to some multi-step queries to mean that the data resulting from executing a given step is stored in memory (with the possibility of spilling to disk), so that it can be read multiple times by another step.</source>
          <target state="translated">이 용어는 특정 단계를 실행 한 결과 데이터가 메모리에 저장되어 (디스크로 유출 될 가능성이 있음) 다른 단계에서 여러 번 읽을 수 있음을 의미하는 일부 다단계 쿼리를 가리키는데도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42eb8ea69f4fadfd409e3ec9f1c7e2ee2c91d332" translate="yes" xml:space="preserve">
          <source>This term is sometimes used to refer to an instance or to a host.</source>
          <target state="translated">이 용어는 때때로 인스턴스 또는 호스트를 가리키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1dac95036f8bd7557b8674ac649d38c8259cd51f" translate="yes" xml:space="preserve">
          <source>This term is used in &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized view&lt;/a&gt;, to mean that the data derived from the view's query is stored on disk separately from the sources of that data.</source>
          <target state="translated">이 용어는 &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;구체화 된 뷰&lt;/a&gt; 에서 사용되며 뷰의 쿼리에서 파생 된 데이터가 해당 데이터의 소스와 별도로 디스크에 저장됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="952d3091870b548dd58edb38d79a5b0fc4d8774a" translate="yes" xml:space="preserve">
          <source>This terminates backup mode. On a primary, it also performs an automatic switch to the next WAL segment. On a standby, it is not possible to automatically switch WAL segments, so you may wish to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary to perform a manual switch. The reason for the switch is to arrange for the last WAL segment file written during the backup interval to be ready to archive.</source>
          <target state="translated">백업 모드가 종료됩니다. 기본에서는 다음 WAL 세그먼트로 자동 전환도 수행합니다. 대기에서는 WAL 세그먼트를 자동으로 전환 할 수 없으므로 기본에서 &lt;code&gt;pg_switch_wal&lt;/code&gt; 을 실행하여 수동 전환을 수행 할 수 있습니다. 전환 이유는 백업 간격 동안 작성된 마지막 WAL 세그먼트 파일을 아카이브 할 준비가되게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c97b686a9ecca6b8afcf92aa63be38096470c601" translate="yes" xml:space="preserve">
          <source>This timestamp could validly be rendered as either 2:30 UTC-4 or 1:30 UTC-5; the timestamp output code chooses the latter.</source>
          <target state="translated">이 타임 스탬프는 2:30 UTC-4 또는 1:30 UTC-5로 유효하게 렌더링 될 수 있습니다. 타임 스탬프 출력 코드는 후자를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="5bfd78cb22d7d6657a7d8e56f10eceb750ab13b4" translate="yes" xml:space="preserve">
          <source>This type of index is most useful when a table has many attributes and queries test arbitrary combinations of them. A traditional btree index is faster than a bloom index, but it can require many btree indexes to support all possible queries where one needs only a single bloom index. Note however that bloom indexes only support equality queries, whereas btree indexes can also perform inequality and range searches.</source>
          <target state="translated">이 유형의 인덱스는 테이블에 많은 속성이 있고 쿼리가 임의의 조합을 테스트 할 때 가장 유용합니다. 기존의 btree 인덱스는 bloom 인덱스보다 빠르지 만 하나의 bloom 인덱스 만 필요한 모든 가능한 쿼리를 지원하려면 많은 btree 인덱스가 필요할 수 있습니다. 그러나 블룸 인덱스는 동등 쿼리 만 지원하는 반면 btree 인덱스는 불평등 및 범위 검색을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47ad5551aa3274bc0c3233a9d21f8ee9873b817" translate="yes" xml:space="preserve">
          <source>This usually means just what it suggests: you tried to start another server on the same port where one is already running. However, if the kernel error message is not &lt;code&gt;Address already in use&lt;/code&gt; or some variant of that, there might be a different problem. For example, trying to start a server on a reserved port number might draw something like:</source>
          <target state="translated">이것은 일반적으로 제안하는 것을 의미합니다. 이미 실행중인 동일한 포트에서 다른 서버를 시작하려고했습니다. 그러나 커널 오류 메시지가 &lt;code&gt;Address already in use&lt;/code&gt; 가 아니 거나 변형 된 경우 다른 문제가있을 수 있습니다. 예를 들어, 예약 된 포트 번호에서 서버를 시작하려고하면 다음과 같은 결과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3923b38241d597877e4759e25323172e3016ea9a" translate="yes" xml:space="preserve">
          <source>This usually results in a better plan than planning the subquery separately. (For example, the outer &lt;code&gt;WHERE&lt;/code&gt; conditions might be such that joining X to A first eliminates many rows of A, thus avoiding the need to form the full logical output of the subquery.) But at the same time, we have increased the planning time; here, we have a five-way join problem replacing two separate three-way join problems. Because of the exponential growth of the number of possibilities, this makes a big difference. The planner tries to avoid getting stuck in huge join search problems by not collapsing a subquery if more than &lt;code&gt;from_collapse_limit&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; items would result in the parent query. You can trade off planning time against quality of plan by adjusting this run-time parameter up or down.</source>
          <target state="translated">이는 일반적으로 하위 쿼리를 별도로 계획하는 것보다 더 나은 계획을 만듭니다. 예를 들어 외부 &lt;code&gt;WHERE&lt;/code&gt; 조건은 X에 A를 결합하면 A의 많은 행이 제거되므로 하위 쿼리의 전체 논리 출력을 형성 할 필요가 없습니다. 그러나 동시에 계획 시간을 늘 렸습니다. ; 여기서, 우리는 2 개의 3 방향 조인 문제를 대체하는 5 방향 조인 문제가 있습니다. 가능성의 수가 기하 급수적으로 증가하기 때문에 큰 차이가 있습니다. 플래너는 &lt;code&gt;from_collapse_limit&lt;/code&gt; &lt;code&gt;FROM&lt;/code&gt; 항목 보다 많은 항목이 상위 쿼리를 생성 하는 경우 하위 쿼리를 축소하지 않으면 서 큰 조인 검색 문제에 빠지지 않도록 시도 합니다. 이 런타임 매개 변수를 위 또는 아래로 조정하여 계획 시간과 계획 시간을 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d3526fb85f461f5326ed5d5597e3881ab88546" translate="yes" xml:space="preserve">
          <source>This utility can only be run by the user who initialized the cluster because it requires read access to the data directory. You can specify the data directory on the command line, or use the environment variable &lt;code&gt;PGDATA&lt;/code&gt;. This utility supports the options &lt;code&gt;-V&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt;, which print the pg_controldata version and exit. It also supports options &lt;code&gt;-?&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt;, which output the supported arguments.</source>
          <target state="translated">이 유틸리티는 데이터 디렉토리에 대한 읽기 액세스가 필요하므로 클러스터를 초기화 한 사용자 만 실행할 수 있습니다. 명령 행에서 데이터 디렉토리를 지정하거나 환경 변수 &lt;code&gt;PGDATA&lt;/code&gt; 를 사용할 수 있습니다 . 이 유틸리티는 pg_controldata 버전을 인쇄하고 종료하는 &lt;code&gt;-V&lt;/code&gt; 및 &lt;code&gt;--version&lt;/code&gt; 옵션을 지원합니다 . 또한 옵션을 지원합니다 &lt;code&gt;-?&lt;/code&gt; 및 &lt;code&gt;--help&lt;/code&gt; , 어떤 출력 지원되는 인수를.</target>
        </trans-unit>
        <trans-unit id="23e7baae96eaae6ec7f8f90d39ec37038a1d3983" translate="yes" xml:space="preserve">
          <source>This utility can only be run by the user who installed the server, because it requires read-only access to the data directory.</source>
          <target state="translated">이 유틸리티는 데이터 디렉토리에 대한 읽기 전용 액세스가 필요하므로 서버를 설치 한 사용자 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c8b87fb5e6f05eb7f41b9abcb56cbe448e2808" translate="yes" xml:space="preserve">
          <source>This utility can only be run by the user who installed the server, because it requires read/write access to the data directory. For safety reasons, you must specify the data directory on the command line. &lt;code&gt;pg_resetwal&lt;/code&gt; does not use the environment variable &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">이 유틸리티는 데이터 디렉토리에 대한 읽기 / 쓰기 액세스가 필요하기 때문에 서버를 설치 한 사용자 만 실행할 수 있습니다. 안전상의 이유로 명령 행에서 데이터 디렉토리를 지정해야합니다. &lt;code&gt;pg_resetwal&lt;/code&gt; 은 환경 변수 &lt;code&gt;PGDATA&lt;/code&gt; 를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e50692fa3aa9f732d24bdd19e107158cb244fbb0" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">이 유틸리티는 대부분의 다른 PostgreSQL 유틸리티와 마찬가지로 libpq에서 지원하는 환경 변수도 사용합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;33.14 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="22f89c28349abae20f5bec16bf71f19805aa29b4" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;). However, it does not read &lt;code&gt;PGDATABASE&lt;/code&gt; when a database name is not supplied.</source>
          <target state="translated">이 유틸리티는 대부분의 다른 PostgreSQL 유틸리티와 마찬가지로 libpq에서 지원하는 환경 변수도 사용합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;33.14 절&lt;/a&gt; 참조 ). 그러나 데이터베이스 이름이 제공 되지 않으면 &lt;code&gt;PGDATABASE&lt;/code&gt; 를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ebba67bddc3774511062564b5b840a56795391c" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">대부분의 다른 PostgreSQL 유틸리티와 마찬가지로이 유틸리티는 libpq에서 지원하는 환경 변수도 사용합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;섹션 33.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ba59d34f5f61746151b52a91611a5ea9de2d786e" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;). However, it does not read &lt;code&gt;PGDATABASE&lt;/code&gt; when a database name is not supplied.</source>
          <target state="translated">대부분의 다른 PostgreSQL 유틸리티와 마찬가지로이 유틸리티는 libpq에서 지원하는 환경 변수도 사용합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;섹션 33.14&lt;/a&gt; 참조 ). 그러나 데이터베이스 이름이 제공 되지 않으면 &lt;code&gt;PGDATABASE&lt;/code&gt; 를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f64ddd714f65036056a8efca366deffd5cb8370" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">이 유틸리티는 대부분의 다른 PostgreSQL 유틸리티와 마찬가지로 libpq에서 지원하는 환경 변수를 사용합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;33.14 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6a43c517a861a8d1e9432380381094a29b0e1db6" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">대부분의 다른 PostgreSQL 유틸리티와 마찬가지로이 유틸리티는 libpq에서 지원하는 환경 변수를 사용합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;섹션 33.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="891e0f3b431a5b76a5e7675d6f5b4cfd398567dc" translate="yes" xml:space="preserve">
          <source>This value is the default.</source>
          <target state="translated">이 값이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6e84fec0574a10e039e309ea4e9bfbbae84d5f20" translate="yes" xml:space="preserve">
          <source>This variable can be set to the values &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;verbose&lt;/code&gt;, &lt;code&gt;terse&lt;/code&gt;, or &lt;code&gt;sqlstate&lt;/code&gt; to control the verbosity of error reports. (See also &lt;code&gt;\errverbose&lt;/code&gt;, for use when you want a verbose version of the error you just got.)</source>
          <target state="translated">이 변수는 &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;verbose&lt;/code&gt; , &lt;code&gt;terse&lt;/code&gt; 또는 &lt;code&gt;sqlstate&lt;/code&gt; 값 으로 설정하여 오류 보고서의 상세 정도를 제어 할 수 있습니다. ( 방금 얻은 오류의 자세한 버전을 원할 때 사용하려면 &lt;code&gt;\errverbose&lt;/code&gt; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b047288ac9be4f5ef83b6fcef3edce3028098d1c" translate="yes" xml:space="preserve">
          <source>This variable can be set to the values &lt;code&gt;never&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, or &lt;code&gt;always&lt;/code&gt; to control whether &lt;code&gt;CONTEXT&lt;/code&gt; fields are displayed in messages from the server. The default is &lt;code&gt;errors&lt;/code&gt; (meaning that context will be shown in error messages, but not in notice or warning messages). This setting has no effect when &lt;code&gt;VERBOSITY&lt;/code&gt; is set to &lt;code&gt;terse&lt;/code&gt; or &lt;code&gt;sqlstate&lt;/code&gt;. (See also &lt;code&gt;\errverbose&lt;/code&gt;, for use when you want a verbose version of the error you just got.)</source>
          <target state="translated">이 변수는 &lt;code&gt;never&lt;/code&gt; , &lt;code&gt;errors&lt;/code&gt; 또는 &lt;code&gt;always&lt;/code&gt; &lt;code&gt;CONTEXT&lt;/code&gt; 필드가 서버의 메시지에 표시 되는지 여부를 제어 하도록 값으로 설정 될 수 있습니다 . 기본값은 &lt;code&gt;errors&lt;/code&gt; (즉, 컨텍스트는 오류 메시지에 표시되지만 통지 또는 경고 메시지에는 표시되지 않음). &lt;code&gt;VERBOSITY&lt;/code&gt; 가 &lt;code&gt;terse&lt;/code&gt; 또는 &lt;code&gt;sqlstate&lt;/code&gt; 로 설정된 경우에는이 설정이 적용되지 않습니다 . ( 방금 얻은 오류의 자세한 버전을 원할 때 사용하려면 &lt;code&gt;\errverbose&lt;/code&gt; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8ec30cffc79914e7e50180450597583323f64746" translate="yes" xml:space="preserve">
          <source>This variable controls whether to raise an error in lieu of applying a row security policy. When set to &lt;code&gt;on&lt;/code&gt;, policies apply normally. When set to &lt;code&gt;off&lt;/code&gt;, queries fail which would otherwise apply at least one policy. The default is &lt;code&gt;on&lt;/code&gt;. Change to &lt;code&gt;off&lt;/code&gt; where limited row visibility could cause incorrect results; for example, pg_dump makes that change by default. This variable has no effect on roles which bypass every row security policy, to wit, superusers and roles with the &lt;code&gt;BYPASSRLS&lt;/code&gt; attribute.</source>
          <target state="translated">이 변수는 행 보안 정책을 적용하는 대신 오류 발생 여부를 제어합니다. &lt;code&gt;on&lt;/code&gt; 으로 설정하면 정책이 정상적으로 적용됩니다. &lt;code&gt;off&lt;/code&gt; 로 설정하면 쿼리가 실패하고 그렇지 않으면 하나 이상의 정책이 적용됩니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다. 제한된 행 가시성으로 인해 잘못된 결과가 발생할 수있는 경우 &lt;code&gt;off&lt;/code&gt; 변경하십시오 . 예를 들어, pg_dump는 기본적으로 변경합니다. 이 변수는 모든 행 보안 정책을 무시하고 &lt;code&gt;BYPASSRLS&lt;/code&gt; 속성 이있는 수퍼 유저 및 역할을 무시하는 역할에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3a6e57232329d24f7b297105fcb53de791463fcf" translate="yes" xml:space="preserve">
          <source>This variable is also not used when creating databases. By default, a new database inherits its tablespace setting from the template database it is copied from.</source>
          <target state="translated">이 변수는 데이터베이스를 작성할 때도 사용되지 않습니다. 기본적으로 새 데이터베이스는 복사 된 템플리트 데이터베이스에서 테이블 스페이스 설정을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="96dcd0eeb5a806520fa3d76a941adb54cde586df" translate="yes" xml:space="preserve">
          <source>This variable is not used for temporary tables; for them, &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; is consulted instead.</source>
          <target state="translated">이 변수는 임시 테이블에는 사용되지 않습니다. 그들을 위해, &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces이&lt;/a&gt; 대신 상담을한다.</target>
        </trans-unit>
        <trans-unit id="c9610b064ff12036d0dbbd211a65bbda376efe2c" translate="yes" xml:space="preserve">
          <source>This variable is the name of the JIT provider library to be used (see &lt;a href=&quot;jit-extensibility#JIT-PLUGGABLE&quot;&gt;Section 31.4.2&lt;/a&gt;). The default is &lt;code&gt;llvmjit&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">이 변수는 사용될 JIT 제공자 라이브러리의 이름입니다 ( &lt;a href=&quot;jit-extensibility#JIT-PLUGGABLE&quot;&gt;31.4.2 절&lt;/a&gt; 참조 ). 기본값은 &lt;code&gt;llvmjit&lt;/code&gt; 입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6364d91b8c705de69fb141059f0b5ecd041ff5d" translate="yes" xml:space="preserve">
          <source>This variable specifies one or more shared libraries that are to be preloaded at connection start. It contains a comma-separated list of library names, where each name is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. Whitespace between entries is ignored; surround a library name with double quotes if you need to include whitespace or commas in the name. The parameter value only takes effect at the start of the connection. Subsequent changes have no effect. If a specified library is not found, the connection attempt will fail.</source>
          <target state="translated">이 변수는 연결 시작시 사전로드 될 하나 이상의 공유 라이브러리를 지정합니다. 쉼표로 구분 된 라이브러리 이름 목록이 포함되어 있으며 각 이름은 &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; 명령 과 같이 해석됩니다 . 항목 사이의 공백은 무시됩니다. 이름에 공백이나 쉼표를 포함해야하는 경우 라이브러리 이름을 큰 따옴표로 묶으십시오. 매개 변수 값은 연결 시작시에만 적용됩니다. 후속 변경 사항은 적용되지 않습니다. 지정된 라이브러리를 찾을 수 없으면 연결 시도가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2cd177877be9e8c77ea886c4ef3d6df8ca9e8ff0" translate="yes" xml:space="preserve">
          <source>This variable specifies one or more shared libraries that are to be preloaded at connection start. It contains a comma-separated list of library names, where each name is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. Whitespace between entries is ignored; surround a library name with double quotes if you need to include whitespace or commas in the name. The parameter value only takes effect at the start of the connection. Subsequent changes have no effect. If a specified library is not found, the connection attempt will fail. Only superusers can change this setting.</source>
          <target state="translated">이 변수는 연결 시작시 사전로드 될 하나 이상의 공유 라이브러리를 지정합니다. 쉼표로 구분 된 라이브러리 이름 목록이 포함되어 있으며 각 이름은 &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; 명령 과 같이 해석됩니다 . 항목 사이의 공백은 무시됩니다. 이름에 공백이나 쉼표를 포함해야하는 경우 라이브러리 이름을 큰 따옴표로 묶으십시오. 매개 변수 값은 연결 시작시에만 적용됩니다. 후속 변경 사항은 적용되지 않습니다. 지정된 라이브러리를 찾을 수 없으면 연결 시도가 실패합니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9894de0e5352de9dfea84284d95098f1e2c92234" translate="yes" xml:space="preserve">
          <source>This variable specifies one or more shared libraries to be preloaded at server start. It contains a comma-separated list of library names, where each name is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. Whitespace between entries is ignored; surround a library name with double quotes if you need to include whitespace or commas in the name. This parameter can only be set at server start. If a specified library is not found, the server will fail to start.</source>
          <target state="translated">이 변수는 서버 시작시 사전로드 될 하나 이상의 공유 라이브러리를 지정합니다. 쉼표로 구분 된 라이브러리 이름 목록이 포함되어 있으며 각 이름은 &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; 명령 과 같이 해석됩니다 . 항목 사이의 공백은 무시됩니다. 이름에 공백이나 쉼표를 포함해야하는 경우 라이브러리 이름을 큰 따옴표로 묶으십시오. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 지정된 라이브러리를 찾을 수 없으면 서버가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6a915d9ae632e6aef6922feee6cf3ba5d4a2ff6" translate="yes" xml:space="preserve">
          <source>This variable specifies tablespaces in which to create temporary objects (temp tables and indexes on temp tables) when a &lt;code&gt;CREATE&lt;/code&gt; command does not explicitly specify a tablespace. Temporary files for purposes such as sorting large data sets are also created in these tablespaces.</source>
          <target state="translated">이 변수는 &lt;code&gt;CREATE&lt;/code&gt; 명령이 테이블 스페이스를 명시 적으로 지정하지 않을 때 임시 오브젝트 (임시 테이블 및 임시 테이블의 인덱스)를 작성할 테이블 스페이스를 지정합니다. 큰 데이터 세트 정렬과 같은 목적을위한 임시 파일도이 테이블 스페이스에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f5d218762619bb59129fccf6c7fc7392957b7115" translate="yes" xml:space="preserve">
          <source>This variable specifies the default tablespace in which to create objects (tables and indexes) when a &lt;code&gt;CREATE&lt;/code&gt; command does not explicitly specify a tablespace. It also determines the tablespace that a partitioned relation will direct future partitions to.</source>
          <target state="translated">이 변수는 &lt;code&gt;CREATE&lt;/code&gt; 명령이 테이블 스페이스를 명시 적으로 지정하지 않을 때 오브젝트 (테이블 및 인덱스)를 작성할 기본 테이블 스페이스를 지정합니다. 또한 파티션 된 관계가 향후 파티션을 지시 할 테이블 공간을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="aa9f42e1d0645607acfe05a083c6feee4e9b8b48" translate="yes" xml:space="preserve">
          <source>This variable specifies the order in which schemas are searched when an object (table, data type, function, etc.) is referenced by a simple name with no schema specified. When there are objects of identical names in different schemas, the one found first in the search path is used. An object that is not in any of the schemas in the search path can only be referenced by specifying its containing schema with a qualified (dotted) name.</source>
          <target state="translated">이 변수는 스키마가 지정되지 않은 단순한 이름으로 오브젝트 (테이블, 데이터 유형, 함수 등)가 참조 될 때 스키마가 검색되는 순서를 지정합니다. 다른 스키마에 동일한 이름의 개체가있는 경우 검색 경로에서 처음 찾은 개체가 사용됩니다. 검색 경로의 스키마에없는 오브젝트는 규정 된 (점으로 된) 이름으로 포함 스키마를 지정해야만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5053ca7743fcc4bdc3ab5765d75a2a61d6e73363" translate="yes" xml:space="preserve">
          <source>This variant of the &lt;code&gt;GRANT&lt;/code&gt; command gives specific privileges on a database object to one or more roles. These privileges are added to those already granted, if any.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; 명령 의이 변형은 데이터베이스 개체에 대한 특정 권한을 하나 이상의 역할에 부여합니다. 이러한 권한은 이미 부여 된 권한에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5fb709052776e6c45691491df6bfccba610d1b30" translate="yes" xml:space="preserve">
          <source>This variant of the &lt;code&gt;GRANT&lt;/code&gt; command grants membership in a role to one or more other roles. Membership in a role is significant because it conveys the privileges granted to a role to each of its members.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; 명령 의이 변형은 역할의 멤버 자격을 하나 이상의 다른 역할에 부여합니다. 역할의 구성원 자격은 역할에 부여 된 권한을 각 구성원에게 전달하기 때문에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d4d8e8957d26c9fb345fec5b62e4899e915fe79e" translate="yes" xml:space="preserve">
          <source>This view can be helpful for checking whether planned changes in the authentication configuration file will work, or for diagnosing a previous failure. Note that this view reports on the &lt;em&gt;current&lt;/em&gt; contents of the file, not on what was last loaded by the server.</source>
          <target state="translated">이보기는 인증 구성 파일의 계획된 변경이 작동하는지 확인하거나 이전 실패를 진단하는 데 도움이 될 수 있습니다. 이보기 는 서버가 마지막으로로드 한 내용이 아니라 파일 의 &lt;em&gt;현재&lt;/em&gt; 내용을 보고 합니다.</target>
        </trans-unit>
        <trans-unit id="ded4110d64c07701bd32e461534d6aff35fce772" translate="yes" xml:space="preserve">
          <source>This view is helpful for checking whether planned changes in the configuration files will work, or for diagnosing a previous failure. Note that this view reports on the &lt;em&gt;current&lt;/em&gt; contents of the files, not on what was last applied by the server. (The &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; view is usually sufficient to determine that.)</source>
          <target state="translated">이보기는 구성 파일의 계획된 변경이 작동하는지 확인하거나 이전 실패를 진단하는 데 도움이됩니다. 이보기 는 서버에서 마지막으로 적용한 내용이 아니라 파일 의 &lt;em&gt;현재&lt;/em&gt; 내용을 보고 합니다. 합니다 ( &lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; 의&lt;/a&gt; 뷰는 것을 결정하는 것이 충분하다.)</target>
        </trans-unit>
        <trans-unit id="b5f7617dee4bd0dacfc46b9c395f294c122bc12e" translate="yes" xml:space="preserve">
          <source>This view will support &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt;. All the columns from the &lt;code&gt;films&lt;/code&gt; table will be updatable, whereas the computed columns &lt;code&gt;country&lt;/code&gt; and &lt;code&gt;avg_rating&lt;/code&gt; will be read-only.</source>
          <target state="translated">이 뷰는 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 를 지원 합니다. &lt;code&gt;films&lt;/code&gt; 테이블 의 모든 열은 업데이트 할 수 있지만 계산 된 열 &lt;code&gt;country&lt;/code&gt; 및 &lt;code&gt;avg_rating&lt;/code&gt; 은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="5744bd9bfe826277ab362eee3d81a2f8763c59df" translate="yes" xml:space="preserve">
          <source>This way you can also use LDAP for connection parameter lookup as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ldap.html&quot;&gt;Section 33.17&lt;/a&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt; for more information on all the available connection options.</source>
          <target state="translated">이 방법으로 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ldap.html&quot;&gt;33.17 절에&lt;/a&gt; 설명 된대로 연결 매개 변수 조회에 LDAP를 사용할 수도 있습니다 . 사용 가능한 모든 연결 옵션에 대한 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;은 33.1.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b22d5c1a856e76f215fc30c2a78dfdff1f3c75c1" translate="yes" xml:space="preserve">
          <source>This way you can also use LDAP for connection parameter lookup as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ldap.html&quot;&gt;Section 33.17&lt;/a&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt; for more information on all the available connection options.</source>
          <target state="translated">이렇게하면 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ldap.html&quot;&gt;섹션 33.17에&lt;/a&gt; 설명 된대로 연결 매개 변수 조회에 LDAP를 사용할 수도 있습니다 . 사용 가능한 모든 연결 옵션에 대한 자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;섹션 33.1.2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fc85cb1dbf306614c53ff81c420fe96724ef4bd" translate="yes" xml:space="preserve">
          <source>This wiki page provides a brief overview, security design, architecture, administration and upcoming features.</source>
          <target state="translated">이 위키 페이지는 간략한 개요, 보안 설계, 아키텍처, 관리 및 향후 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a7facb549adad733a90a16ab11be82cd587ad267" translate="yes" xml:space="preserve">
          <source>This will also find related words such as &lt;code&gt;friends&lt;/code&gt; and &lt;code&gt;friendly&lt;/code&gt;, since all these are reduced to the same normalized lexeme.</source>
          <target state="translated">또한 &lt;code&gt;friends&lt;/code&gt; 및 &lt;code&gt;friendly&lt;/code&gt; 단어와 같은 관련 단어를 찾을 수 있습니다.이 단어 는 모두 같은 정규화 된 exeme로 축소되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0ac371241bbb2e0a4e09eb743c54a9583dbf830b" translate="yes" xml:space="preserve">
          <source>This will create a database named &lt;code&gt;korean&lt;/code&gt; that uses the character set &lt;code&gt;EUC_KR&lt;/code&gt;, and locale &lt;code&gt;ko_KR&lt;/code&gt;. Another way to accomplish this is to use this SQL command:</source>
          <target state="translated">문자 세트 &lt;code&gt;EUC_KR&lt;/code&gt; 및 로케일 &lt;code&gt;ko_KR&lt;/code&gt; 을 사용하는 &lt;code&gt;korean&lt;/code&gt; 데이터베이스가 작성 됩니다 . 이를 수행하는 또 다른 방법은이 SQL 명령을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fcc2d5a65486c9c94a37090b57dae833aa54736a" translate="yes" xml:space="preserve">
          <source>This will create a table with one row per left item, and an array of right items. Now this is pretty useless without some way of using the array; that's why there is an array enumerator. You can do</source>
          <target state="translated">왼쪽 항목 당 하나의 행과 오른쪽 항목의 배열이있는 테이블이 생성됩니다. 이제 이것은 배열을 사용하는 방법 없이는 쓸모가 없습니다. 그렇기 때문에 배열 열거자가 있습니다. 넌 할 수있어</target>
        </trans-unit>
        <trans-unit id="456202e5286a667b495d0d080a420980563fc127" translate="yes" xml:space="preserve">
          <source>This will create a view based on the &lt;code&gt;comedies&lt;/code&gt; view, showing only films with &lt;code&gt;kind = 'Comedy'&lt;/code&gt; and &lt;code&gt;classification = 'U'&lt;/code&gt;. Any attempt to &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; a row in the view will be rejected if the new row doesn't have &lt;code&gt;classification = 'U'&lt;/code&gt;, but the film &lt;code&gt;kind&lt;/code&gt; will not be checked.</source>
          <target state="translated">이렇게하면 &lt;code&gt;comedies&lt;/code&gt; 보기를 기준으로 보기 &lt;code&gt;kind = 'Comedy'&lt;/code&gt; 및 &lt;code&gt;classification = 'U'&lt;/code&gt; 영화 만 표시됩니다 . 새 행에 &lt;code&gt;classification = 'U'&lt;/code&gt; 가 없으면 뷰에서 행 을 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 하려는 시도 는 거부 되지만 필름 &lt;code&gt;kind&lt;/code&gt; 는 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7310496c1ef4e42c77607893ab0567ee3cd08f0" translate="yes" xml:space="preserve">
          <source>This will create a view containing the columns that are in the &lt;code&gt;film&lt;/code&gt; table at the time of view creation. Though &lt;code&gt;*&lt;/code&gt; was used to create the view, columns added later to the table will not be part of the view.</source>
          <target state="translated">뷰 생성시 &lt;code&gt;film&lt;/code&gt; 테이블에있는 열이 포함 된 뷰가 생성됩니다. 뷰를 만드는 데 &lt;code&gt;*&lt;/code&gt; 가 사용 되었지만 나중에 테이블에 추가 된 열은 뷰의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ec4f0e34512b88917e6ee4edf638401662483cd5" translate="yes" xml:space="preserve">
          <source>This will create a view that checks both the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;classification&lt;/code&gt; of new rows.</source>
          <target state="translated">그러면 새 행 의 &lt;code&gt;kind&lt;/code&gt; 와 &lt;code&gt;classification&lt;/code&gt; 를 모두 확인하는보기가 만들어 집니다.</target>
        </trans-unit>
        <trans-unit id="80307af5f039905f035882871ac20bb16cdaf4a5" translate="yes" xml:space="preserve">
          <source>This will fail if the current user has no permissions to terminate other connections. Required permissions are the same as with &lt;code&gt;pg_terminate_backend&lt;/code&gt;, described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.27.2&lt;/a&gt;. This will also fail if we are not able to terminate connections.</source>
          <target state="translated">현재 사용자에게 다른 연결을 종료 할 권한이 없으면 실패합니다. 필요한 권한은 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;섹션 9.27.2에&lt;/a&gt; 설명 된 &lt;code&gt;pg_terminate_backend&lt;/code&gt; 와 동일 합니다. 연결을 종료 할 수없는 경우에도 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d4e6c3b1ee3c6ae0ce592e53fe304140df76442d" translate="yes" xml:space="preserve">
          <source>This will match paths that contain the label &lt;code&gt;Europe&lt;/code&gt; and any label beginning with &lt;code&gt;Russia&lt;/code&gt; (case-insensitive), but not paths containing the label &lt;code&gt;Transportation&lt;/code&gt;. The location of these words within the path is not important. Also, when &lt;code&gt;%&lt;/code&gt; is used, the word can be matched to any underscore-separated word within a label, regardless of position.</source>
          <target state="translated">이는 &lt;code&gt;Europe&lt;/code&gt; 레이블이 포함 된 경로 와 &lt;code&gt;Russia&lt;/code&gt; (대소 문자 구분)로 시작 하는 레이블은 포함하지만 &lt;code&gt;Transportation&lt;/code&gt; 레이블은 포함하지 않는 경로 와 일치합니다 . 경로 내에서이 단어들의 위치는 중요하지 않습니다. 또한 &lt;code&gt;%&lt;/code&gt; 를 사용하면 위치에 관계없이 레이블 내에서 밑줄로 구분 된 단어와 단어를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7070480e63fc28db9b2bfc400f51e909df548e18" translate="yes" xml:space="preserve">
          <source>This will not work since the name &lt;code&gt;item&lt;/code&gt; is taken to be a table name, not a column name of &lt;code&gt;on_hand&lt;/code&gt;, per SQL syntax rules. You must write it like this:</source>
          <target state="translated">이름 &lt;code&gt;item&lt;/code&gt; 이 SQL 구문 규칙에 따라 &lt;code&gt;on_hand&lt;/code&gt; 의 열 이름이 아닌 테이블 이름으로 사용 되므로 작동 하지 않습니다 . 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc724810451e07ee1624d0d89bd9f99d8b85081f" translate="yes" xml:space="preserve">
          <source>This will produce a result something like:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc934f85b42e420c854cb082c555601046530eec" translate="yes" xml:space="preserve">
          <source>This will return a table of two columns and three rows. It's effectively equivalent to:</source>
          <target state="translated">두 개의 열과 세 개의 행으로 구성된 테이블이 반환됩니다. 효과적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00d87bb57d3abbae7f2092f201fbf64e1ef1e407" translate="yes" xml:space="preserve">
          <source>This will return all the items in the right hand table for an entry in the left hand table. This is a very common construct in SQL.</source>
          <target state="translated">왼쪽 테이블의 항목에 대해 오른쪽 테이블의 모든 항목을 반환합니다. 이것은 SQL에서 매우 일반적인 구조입니다.</target>
        </trans-unit>
        <trans-unit id="9684b1543ba00fa275566c42af863391caa86e12" translate="yes" xml:space="preserve">
          <source>This will return all values in the text column for which there is a continuous extent in the corresponding ordered trigram set that is sufficiently similar to the trigram set of &lt;code&gt;word&lt;/code&gt;, sorted from best match to worst. The index will be used to make this a fast operation even over very large data sets.</source>
          <target state="translated">이렇게하면 정렬 된 trigram 세트에 연속 범위가있는 text 열의 모든 값이 &lt;code&gt;word&lt;/code&gt; 의 trigram 세트와 충분히 유사하며 best match에서 최악으로 정렬됩니다. 인덱스는 매우 큰 데이터 세트에서도 빠른 작업을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9601b6fc7f3154db7fc5d9d05b2c9284f9d222e6" translate="yes" xml:space="preserve">
          <source>This will return all values in the text column that are sufficiently similar to &lt;code&gt;word&lt;/code&gt;, sorted from best match to worst. The index will be used to make this a fast operation even over very large data sets.</source>
          <target state="translated">그러면 텍스트 열에서 &lt;code&gt;word&lt;/code&gt; 와 충분히 비슷한 모든 값이 가장 일치하는 항목에서 최악의 항목으로 정렬됩니다. 인덱스는 매우 큰 데이터 세트에서도 빠른 작업을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e0c4ccba178d64fe3f5a4a8f9774cdd12a6ce9f" translate="yes" xml:space="preserve">
          <source>This will save the setting (but not set it immediately). In subsequent connections by this role it will appear as though &lt;code&gt;SET enable_indexscan TO off&lt;/code&gt; had been executed just before the session started. You can still alter this setting during the session; it will only be the default. To remove a role-specific default setting, use &lt;code&gt;ALTER ROLE rolename RESET varname&lt;/code&gt;. Note that role-specific defaults attached to roles without &lt;code&gt;LOGIN&lt;/code&gt; privilege are fairly useless, since they will never be invoked.</source>
          <target state="translated">설정이 저장되지만 즉시 설정되지는 않습니다. 이 역할에 의한 후속 연결에서는 세션이 시작되기 직전 &lt;code&gt;SET enable_indexscan TO off&lt;/code&gt; 가 실행 된 것처럼 나타납니다 . 세션 중에도이 설정을 변경할 수 있습니다. 기본값 일뿐입니다. 역할 별 기본 설정을 제거하려면 &lt;code&gt;ALTER ROLE rolename RESET varname&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;LOGIN&lt;/code&gt; 권한이없는 역할에 첨부 된 역할 별 기본값 은 호출되지 않으므로 상당히 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c957489b768ad1121e70ecf58707bd37aac80d87" translate="yes" xml:space="preserve">
          <source>This will save the setting (but not set it immediately). In subsequent connections to this database it will appear as though &lt;code&gt;SET geqo TO off;&lt;/code&gt; had been executed just before the session started. Note that users can still alter this setting during their sessions; it will only be the default. To undo any such setting, use &lt;code&gt;ALTER DATABASE dbname RESET varname&lt;/code&gt;.</source>
          <target state="translated">설정이 저장되지만 즉시 설정되지는 않습니다. 이 데이터베이스에 대한 후속 연결에서는 &lt;code&gt;SET geqo TO off;&lt;/code&gt; 처럼 나타납니다 . 세션이 시작되기 직전에 실행되었습니다. 사용자는 세션 중에도이 설정을 변경할 수 있습니다. 기본값 일뿐입니다. 이러한 설정을 취소하려면 &lt;code&gt;ALTER DATABASE dbname RESET varname&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e04d0ca6130cc2fa0f50fc16bc721bc9344ebb8a" translate="yes" xml:space="preserve">
          <source>This will succeed only if each existing entry in the column can be converted to the new type by an implicit cast. If a more complex conversion is needed, you can add a &lt;code&gt;USING&lt;/code&gt; clause that specifies how to compute the new values from the old.</source>
          <target state="translated">이는 열의 기존 항목이 내재 된 캐스트로 새 유형으로 변환 될 수있는 경우에만 성공합니다. 보다 복잡한 변환이 필요한 경우 이전 값에서 새 값을 계산하는 방법을 지정하는 &lt;code&gt;USING&lt;/code&gt; 절을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07f6af6a1757ce5004ed8f1bbb0c1ac5b13f2237" translate="yes" xml:space="preserve">
          <source>This will work too:</source>
          <target state="translated">이것도 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="2518d47395fb2d8240dcc264bbc1439e37da1fb7" translate="yes" xml:space="preserve">
          <source>This works OK as far as querying goes, but it gets ugly when you need to update several rows, for one thing.</source>
          <target state="translated">쿼리가 진행되는 한 정상적으로 작동하지만 여러 행을 업데이트해야 할 때 추악합니다.</target>
        </trans-unit>
        <trans-unit id="745e343b5d1e33e36d85f39d0c717159c4f6b58f" translate="yes" xml:space="preserve">
          <source>This works anywhere a table name is expected, including the table modification commands and the data access commands discussed in the following chapters. (For brevity we will speak of tables only, but the same ideas apply to other kinds of named objects, such as types and functions.)</source>
          <target state="translated">이것은 다음 장에서 논의 된 테이블 수정 명령 및 데이터 액세스 명령을 포함하여 테이블 이름이 필요한 모든 곳에서 작동합니다. (간단하게하기 위해 우리는 테이블에 대해서만 이야기하지만 유형과 함수와 같은 다른 종류의 명명 된 객체에도 동일한 아이디어가 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="2957424d9ef693c1b1a96a104ee978e9de4983b8" translate="yes" xml:space="preserve">
          <source>This works because PostgreSQL's implementation evaluates only as many rows of a &lt;code&gt;WITH&lt;/code&gt; query as are actually fetched by the parent query. Using this trick in production is not recommended, because other systems might work differently. Also, it usually won't work if you make the outer query sort the recursive query's results or join them to some other table, because in such cases the outer query will usually try to fetch all of the &lt;code&gt;WITH&lt;/code&gt; query's output anyway.</source>
          <target state="translated">이것은 PostgreSQL의 구현 이 실제로 부모 쿼리에 의해 가져온 &lt;code&gt;WITH&lt;/code&gt; 쿼리 의 많은 행만 평가하기 때문에 작동 합니다. 다른 시스템은 다르게 작동 할 수 있으므로 프로덕션 환경에서는이 트릭을 사용하지 않는 것이 좋습니다. 또한 외부 쿼리가 재귀 쿼리 결과를 정렬하거나 다른 테이블에 조인하면 일반적으로 작동하지 않습니다.이 경우 외부 쿼리는 일반적으로 모든 &lt;code&gt;WITH&lt;/code&gt; 쿼리의 출력 을 가져 오려고 시도하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3f4e84fb95c842771a51ab73c2b062507d6eff5c" translate="yes" xml:space="preserve">
          <source>This works in both regular SQL commands and meta-commands; there is more detail in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt;, below.</source>
          <target state="translated">이것은 일반 SQL 명령과 메타 명령 모두에서 작동합니다. 아래의 &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation에 대한&lt;/a&gt; 자세한 내용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="94c314a6fc9266b79d71f9330565442779b31db1" translate="yes" xml:space="preserve">
          <source>This works reasonably well, but has a number of drawbacks:</source>
          <target state="translated">이것은 합리적으로 잘 작동하지만 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb7380b7f7c690853b919f0af451d457543e80c8" translate="yes" xml:space="preserve">
          <source>This works similarly to the previous example.</source>
          <target state="translated">이것은 이전 예제와 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1e6ed82ca645f9e4d9f11c1613a5711464a40bfe" translate="yes" xml:space="preserve">
          <source>This works the same for all constraint types except not-null constraints. To drop a not null constraint use:</source>
          <target state="translated">null이 아닌 제약 조건을 제외한 모든 제약 조건 유형에 대해 동일하게 작동합니다. not null 제약 조건을 삭제하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6c526d5097db889159006cee4ad293de5eee6b33" translate="yes" xml:space="preserve">
          <source>This would be accomplished by the following query:</source>
          <target state="translated">이것은 다음 쿼리에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6009d7325db9d9fecfe7a5f56808293dedf32ff8" translate="yes" xml:space="preserve">
          <source>Though PostgreSQL provides nonblocking read/write access to table data, nonblocking read/write access is not currently offered for every index access method implemented in PostgreSQL. The various index types are handled as follows:</source>
          <target state="translated">PostgreSQL은 테이블 데이터에 대한 비 차단 읽기 / 쓰기 액세스를 제공하지만 현재 PostgreSQL에 구현 된 모든 인덱스 액세스 방법에 비 차단 읽기 / 쓰기 액세스가 제공되지는 않습니다. 다양한 색인 유형은 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b387dafa062f79d85fee46034cc439a5b198ed" translate="yes" xml:space="preserve">
          <source>Three different bits are used to store information about page-level visibility. The all-visible bit in the visibility map indicates that every tuple in the corresponding page of the relation is visible to every current and future transaction. The all-frozen bit in the visibility map indicates that every tuple in the page is frozen; that is, no future vacuum will need to modify the page until such time as a tuple is inserted, updated, deleted, or locked on that page. The page header's &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; bit has the same meaning as the all-visible bit in the visibility map, but is stored within the data page itself rather than in a separate data structure. These two bits will normally agree, but the page's all-visible bit can sometimes be set while the visibility map bit is clear after a crash recovery. The reported values can also disagree because of a change that occurs after &lt;code&gt;pg_visibility&lt;/code&gt; examines the visibility map and before it examines the data page. Any event that causes data corruption can also cause these bits to disagree.</source>
          <target state="translated">페이지 레벨 가시성에 대한 정보를 저장하는 데 세 가지 다른 비트가 사용됩니다. 가시성 맵의 모든 표시 가능 비트는 관계의 해당 페이지에있는 모든 튜플이 모든 현재 및 미래 트랜잭션에 표시됨을 나타냅니다. 가시성 맵의 고정 된 비트는 페이지의 모든 튜플이 고정되었음을 나타냅니다. 즉, 튜플이 해당 페이지에 삽입, 업데이트, 삭제 또는 잠길 때까지 이후 진공 상태에서 페이지를 수정할 필요가 없습니다. 페이지 헤더의 &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; 비트는 가시성 맵의 모든 표시 가능한 비트와 동일한 의미를 갖지만 별도의 데이터 구조가 아닌 데이터 페이지 자체에 저장됩니다. 이 두 비트는 일반적으로 동의하지만 크래시 복구 후 가시성 맵 비트가 명확한 동안 페이지의 모든 표시 가능한 비트를 설정할 수 있습니다. &lt;code&gt;pg_visibility&lt;/code&gt; 가 가시성 맵을 검사 한 후 데이터 페이지를 검사하기 전에 발생하는 변경으로 인해보고 된 값이 일치하지 않을 수도 있습니다 . 데이터가 손상되는 모든 이벤트는 이러한 비트가 일치하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eb05e9b0f9498e4b2b12babd625a604206f4c79" translate="yes" xml:space="preserve">
          <source>Through simulation of the evolutionary operations &lt;em&gt;recombination&lt;/em&gt;, &lt;em&gt;mutation&lt;/em&gt;, and &lt;em&gt;selection&lt;/em&gt; new generations of search points are found that show a higher average fitness than their ancestors.</source>
          <target state="translated">진화 연산 &lt;em&gt;재조합&lt;/em&gt; , &lt;em&gt;돌연변이&lt;/em&gt; 및 &lt;em&gt;선택의&lt;/em&gt; 시뮬레이션을 통해 조상보다 더 높은 평균 체력을 나타내는 새로운 세대의 검색 지점이 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="55c41901b0118a14f05a3e31103cd618a4a206c3" translate="yes" xml:space="preserve">
          <source>Through simulation of the evolutionary operations &lt;em&gt;recombination&lt;/em&gt;, &lt;em&gt;mutation&lt;/em&gt;, and &lt;em&gt;selection&lt;/em&gt; new generations of search points are found that show a higher average fitness than their ancestors. &lt;a href=&quot;geqo-intro2#GEQO-FIGURE&quot;&gt;Figure 59.1&lt;/a&gt; illustrates these steps.</source>
          <target state="translated">진화 작업의 시뮬레이션을 통해 &lt;em&gt;재조합&lt;/em&gt; , &lt;em&gt;돌연변이&lt;/em&gt; 및 &lt;em&gt;선택을&lt;/em&gt; 통해 조상보다 평균 적합성이 더 높은 새로운 세대의 검색 지점이 발견되었습니다. &lt;a href=&quot;geqo-intro2#GEQO-FIGURE&quot;&gt;그림 59.1&lt;/a&gt; 은 이러한 단계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c27dce1f6609095e9fe5fc64a23bbb9715cf9868" translate="yes" xml:space="preserve">
          <source>Throughout running a transaction, a server process holds an exclusive lock on the transaction's virtual transaction ID. If a permanent ID is assigned to the transaction (which normally happens only if the transaction changes the state of the database), it also holds an exclusive lock on the transaction's permanent transaction ID until it ends. When a process finds it necessary to wait specifically for another transaction to end, it does so by attempting to acquire share lock on the other transaction's ID (either virtual or permanent ID depending on the situation). That will succeed only when the other transaction terminates and releases its locks.</source>
          <target state="translated">트랜잭션을 실행하는 동안 서버 프로세스는 트랜잭션의 가상 트랜잭션 ID에 대한 독점 잠금을 보유합니다. 영구 ID가 트랜잭션에 할당되면 (일반적으로 트랜잭션이 데이터베이스의 상태를 변경하는 경우에만 발생) 트랜잭션이 끝날 때까지 트랜잭션의 영구 트랜잭션 ID에 독점 잠금을 유지합니다. 프로세스가 다른 트랜잭션이 종료 될 때까지 구체적으로 기다려야 할 경우 다른 트랜잭션의 ID (상황에 따라 가상 또는 영구 ID)에 대한 공유 잠금을 획득하려고 시도합니다. 다른 트랜잭션이 종료되고 잠금을 해제 할 때만 성공합니다.</target>
        </trans-unit>
        <trans-unit id="28362fc6bf38f9ce00db5bd7a58a7c2aea63ad0d" translate="yes" xml:space="preserve">
          <source>Thu, Thur, Thurs</source>
          <target state="translated">목 목 목</target>
        </trans-unit>
        <trans-unit id="76031ddf92450ba52c1e3945097079807a9065c2" translate="yes" xml:space="preserve">
          <source>Thursday</source>
          <target state="translated">Thursday</target>
        </trans-unit>
        <trans-unit id="e159393321d195e0b9a1e51cafce029229164b8f" translate="yes" xml:space="preserve">
          <source>Thus far, our queries have only accessed one table at a time. Queries can access multiple tables at once, or access the same table in such a way that multiple rows of the table are being processed at the same time. A query that accesses multiple rows of the same or different tables at one time is called a &lt;em&gt;join&lt;/em&gt; query. As an example, say you wish to list all the weather records together with the location of the associated city. To do that, we need to compare the &lt;code&gt;city&lt;/code&gt; column of each row of the &lt;code&gt;weather&lt;/code&gt; table with the &lt;code&gt;name&lt;/code&gt; column of all rows in the &lt;code&gt;cities&lt;/code&gt; table, and select the pairs of rows where these values match.</source>
          <target state="translated">지금까지 쿼리는 한 번에 하나의 테이블에만 액세스했습니다. 쿼리는 한 번에 여러 테이블에 액세스하거나 테이블의 여러 행이 동시에 처리되는 방식으로 동일한 테이블에 액세스 할 수 있습니다. 동일하거나 다른 테이블의 여러 행에 한 번에 액세스하는 쿼리를 &lt;em&gt;조인&lt;/em&gt; 쿼리 라고 합니다. 예를 들어, 모든 날씨 기록을 관련 도시의 위치와 함께 나열하고 싶다고 가정하십시오. 이를 위해서는 &lt;code&gt;weather&lt;/code&gt; 테이블 의 각 행의 &lt;code&gt;city&lt;/code&gt; 열과 &lt;code&gt;cities&lt;/code&gt; 테이블 의 모든 행 의 &lt;code&gt;name&lt;/code&gt; 열 을 비교하고 이러한 값이 일치하는 행 쌍을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="33d92a6f947116307ff818dcd12f8100aa0644a8" translate="yes" xml:space="preserve">
          <source>Thus, the &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; function is useful for finding the similarity to whole words, while &lt;code&gt;word_similarity(text, text)&lt;/code&gt; is more suitable for finding the similarity for parts of words.</source>
          <target state="translated">따라서 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; 함수는 전체 단어와의 유사성을 찾는 데 유용하지만 &lt;code&gt;word_similarity(text, text)&lt;/code&gt; 는 단어의 일부에 대한 유사성을 찾는 데 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="6c9c074c03b31acd5f7a7e20ed6e667b03762dad" translate="yes" xml:space="preserve">
          <source>Thus, the &lt;code&gt;strict_word_similarity&lt;/code&gt; function is useful for finding the similarity to whole words, while &lt;code&gt;word_similarity&lt;/code&gt; is more suitable for finding the similarity for parts of words.</source>
          <target state="translated">따라서 &lt;code&gt;strict_word_similarity&lt;/code&gt; 함수는 전체 단어와의 유사성을 찾는 데 유용하고 &lt;code&gt;word_similarity&lt;/code&gt; 는 단어의 일부에 대한 유사성을 찾는 데 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="ae8d95556da752362e5bc888aa863b02957f8964" translate="yes" xml:space="preserve">
          <source>Thus, these functions can be used directly when the input query produces &lt;code&gt;row_name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; columns of type &lt;code&gt;text&lt;/code&gt;, and you want 2, 3, or 4 output values columns. In all other ways they behave exactly as described above for the general &lt;code&gt;crosstab&lt;/code&gt; function.</source>
          <target state="translated">따라서 입력 쿼리가 &lt;code&gt;text&lt;/code&gt; 유형의 &lt;code&gt;row_name&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 열을 생성 하고 2, 3 또는 4 개의 출력 값 열을 원하는 경우 이러한 함수를 직접 사용할 수 있습니다 . 다른 모든 방법으로 일반 &lt;code&gt;crosstab&lt;/code&gt; 기능에 대해 위에서 설명한대로 정확하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="4db015abd914b1b3990881a3d9a556ca3470734a" translate="yes" xml:space="preserve">
          <source>Thus, we have created an integer column and arranged for its default values to be assigned from a sequence generator. A &lt;code&gt;NOT NULL&lt;/code&gt; constraint is applied to ensure that a null value cannot be inserted. (In most cases you would also want to attach a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint to prevent duplicate values from being inserted by accident, but this is not automatic.) Lastly, the sequence is marked as &amp;ldquo;owned by&amp;rdquo; the column, so that it will be dropped if the column or table is dropped.</source>
          <target state="translated">따라서 정수 열을 만들고 시퀀스 생성기에서 기본값을 할당하도록 정렬했습니다. &lt;code&gt;NOT NULL&lt;/code&gt; 의 제약 조건은 NULL 값을 삽입 할 수 없도록 적용됩니다. (대부분의 경우 실수로 중복 값이 ​​삽입되는 것을 방지하기 위해 &lt;code&gt;UNIQUE&lt;/code&gt; 또는 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건 을 연결하려고 하지만 자동은 아닙니다.) 마지막으로 시퀀스는 열의 &quot;소유&quot;로 표시되므로 열은 &quot;소유자&quot;로 표시됩니다. 열 또는 테이블이 삭제되면 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="824c19a1cbeb13e4af22007a250bca9cc9d5aa71" translate="yes" xml:space="preserve">
          <source>Time at which the last data page checksum failure was detected in this database (or on a shared object), or NULL if data checksums are not enabled.</source>
          <target state="translated">이 데이터베이스 (또는 공유 객체)에서 마지막 데이터 페이지 체크섬 오류가 감지 된 시간 또는 데이터 체크섬이 활성화되지 않은 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="31a4493404d403e4b069700b973d39eee08d905b" translate="yes" xml:space="preserve">
          <source>Time at which the transaction was prepared for commit</source>
          <target state="translated">트랜잭션이 커밋 준비된 시간</target>
        </trans-unit>
        <trans-unit id="c312600dc8a52a3cdeb07b3c4822cc0aa7fc3793" translate="yes" xml:space="preserve">
          <source>Time at which these statistics were last reset</source>
          <target state="translated">이 통계가 마지막으로 재설정 된 시간</target>
        </trans-unit>
        <trans-unit id="b42073a799486b6bcd7e2d53dba2eb7477ef1dac" translate="yes" xml:space="preserve">
          <source>Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written and flushed it (but not yet applied it). This can be used to gauge the delay that &lt;code&gt;synchronous_commit&lt;/code&gt; level &lt;code&gt;on&lt;/code&gt; incurred while committing if this server was configured as a synchronous standby.</source>
          <target state="translated">최근 WAL을 로컬에서 플러시하고이 대기 서버가 작성하여 플러시했다는 알림을 수신하는 데 아직 시간이 걸렸습니다 (아직 적용하지는 않음). 이 서버가 동기 대기로 구성된 경우 커미트하는 동안 &lt;code&gt;synchronous_commit&lt;/code&gt; 레벨 &lt;code&gt;on&lt;/code&gt; 발생하는 지연을 측정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0c7f5fcbdb1638dc5b20b8d46067760a93260d7" translate="yes" xml:space="preserve">
          <source>Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written it (but not yet flushed it or applied it). This can be used to gauge the delay that &lt;code&gt;synchronous_commit&lt;/code&gt; level &lt;code&gt;remote_write&lt;/code&gt; incurred while committing if this server was configured as a synchronous standby.</source>
          <target state="translated">최근 WAL을 로컬로 플러시하고이 대기 서버가 작성했지만 아직 플러시 또는 적용하지 않았다는 알림을받는 데 시간이 경과했습니다. 이 서버가 동기 대기로 구성된 경우 커미트하는 동안 &lt;code&gt;synchronous_commit&lt;/code&gt; 레벨 &lt;code&gt;remote_write&lt;/code&gt; 가 발생하는 지연을 측정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87f2fef0ff3885ece1737c889873c3a7dd9caea0" translate="yes" xml:space="preserve">
          <source>Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written, flushed and applied it. This can be used to gauge the delay that &lt;code&gt;synchronous_commit&lt;/code&gt; level &lt;code&gt;remote_apply&lt;/code&gt; incurred while committing if this server was configured as a synchronous standby.</source>
          <target state="translated">최근 WAL을 로컬로 플러시하고이 대기 서버가이를 플러시 및 적용했다는 알림을받는 데 시간이 경과했습니다. 이 서버가 동기 대기로 구성된 경우 커미트하는 동안 &lt;code&gt;synchronous_commit&lt;/code&gt; 레벨 &lt;code&gt;remote_apply&lt;/code&gt; 가 발생하는 지연을 측정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad92df2acc969fab807c3d10901a294d8ff7f754" translate="yes" xml:space="preserve">
          <source>Time is before 12:00</source>
          <target state="translated">시간은 12:00 이전</target>
        </trans-unit>
        <trans-unit id="43b71e95a19ea4a6f1b340ce357037e706d5a3cf" translate="yes" xml:space="preserve">
          <source>Time is on or after 12:00</source>
          <target state="translated">시간은 12:00 이후입니다</target>
        </trans-unit>
        <trans-unit id="9bd0601e2f87239d97d77738bf3ca024a85d5838" translate="yes" xml:space="preserve">
          <source>Time of last write-ahead log location reported to origin WAL sender</source>
          <target state="translated">원래 WAL 보낸 사람에게보고 된 마지막 미리 쓰기 로그 위치 시간</target>
        </trans-unit>
        <trans-unit id="689e239460d59d7671ce2c908f91fa122b359c25" translate="yes" xml:space="preserve">
          <source>Time of the last failed archival operation</source>
          <target state="translated">마지막으로 실패한 보관 작업 시간</target>
        </trans-unit>
        <trans-unit id="8cb8f733cf5d5d099965d55bbe98e4d1fa3e9d29" translate="yes" xml:space="preserve">
          <source>Time of the last successful archive operation</source>
          <target state="translated">마지막으로 성공한 아카이브 작업 시간</target>
        </trans-unit>
        <trans-unit id="21397053368fe3010616b276ed5043a12f8cb11f" translate="yes" xml:space="preserve">
          <source>Time spent reading data file blocks by backends in this database, in milliseconds</source>
          <target state="translated">이 데이터베이스에서 백엔드별로 데이터 파일 블록을 읽는 데 소요 된 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="9cb2109efc7cd77762a155d13e3d4c7d5ccbfbcd" translate="yes" xml:space="preserve">
          <source>Time spent reading data file blocks by backends in this database, in milliseconds (if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled, otherwise zero)</source>
          <target state="translated">이 데이터베이스의 백엔드에서 데이터 파일 블록을 읽는 데 소요 된 시간 (밀리 초) ( &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; 이 활성화 된 경우, 그렇지 않으면 0)</target>
        </trans-unit>
        <trans-unit id="555585fed0e713bf1b368cbbf5bba5754318a952" translate="yes" xml:space="preserve">
          <source>Time spent writing data file blocks by backends in this database, in milliseconds</source>
          <target state="translated">이 데이터베이스에서 백엔드별로 데이터 파일 블록을 쓰는 데 소요 된 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="f85753033657b7d08aa205efa2bc11551bdaa55d" translate="yes" xml:space="preserve">
          <source>Time spent writing data file blocks by backends in this database, in milliseconds (if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled, otherwise zero)</source>
          <target state="translated">이 데이터베이스에서 백엔드가 데이터 파일 블록을 쓰는 데 소요 된 시간 (밀리 초) ( &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; 이 활성화 된 경우, 그렇지 않으면 0)</target>
        </trans-unit>
        <trans-unit id="f7c6e9c6e492ee3767af155479b912c5dbab4797" translate="yes" xml:space="preserve">
          <source>Time stamp with milliseconds</source>
          <target state="translated">밀리 초가 포함 된 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="60f359c6300b47ebed0b97fcdfa3cace5afca052" translate="yes" xml:space="preserve">
          <source>Time stamp with milliseconds (as a Unix epoch)</source>
          <target state="translated">밀리 초 단위의 타임 스탬프 (유닉스 시대)</target>
        </trans-unit>
        <trans-unit id="4ac2d64d58668aa63843fa9aac25d77d00659a02" translate="yes" xml:space="preserve">
          <source>Time stamp without milliseconds</source>
          <target state="translated">밀리 초가없는 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="51bb8ad970c492c6e4e04fdc998b0e86ee08e582" translate="yes" xml:space="preserve">
          <source>Time when the &lt;code&gt;state&lt;/code&gt; was last changed</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 가 마지막으로 변경된 시간</target>
        </trans-unit>
        <trans-unit id="d762072c616665b71d7c55c79cd97af33543bb34" translate="yes" xml:space="preserve">
          <source>Time when the current transaction was started</source>
          <target state="translated">현재 거래가 시작된 시간</target>
        </trans-unit>
        <trans-unit id="11625d6eed69f1fabf53d97fbcee125227cacb32" translate="yes" xml:space="preserve">
          <source>Time when the currently active query was started, or if &lt;code&gt;state&lt;/code&gt; is not &lt;code&gt;active&lt;/code&gt;, when the last query was started</source>
          <target state="translated">현재 활성 쿼리가 시작된 시간 또는 &lt;code&gt;state&lt;/code&gt; 가 &lt;code&gt;active&lt;/code&gt; 이 아닌 경우 마지막 쿼리가 시작된 시간</target>
        </trans-unit>
        <trans-unit id="94633bb8d7222b0ec4b3348ef60e473c680e5d05" translate="yes" xml:space="preserve">
          <source>Time when the most recent query was started</source>
          <target state="translated">가장 최근 쿼리가 시작된 시간</target>
        </trans-unit>
        <trans-unit id="25af4b3f3521f87fcd782cc01e0d9b93c6165347" translate="yes" xml:space="preserve">
          <source>Time when this process was started</source>
          <target state="translated">이 과정이 시작된 시간</target>
        </trans-unit>
        <trans-unit id="933cb365f238bab1b9f23247a7559754209bd8c6" translate="yes" xml:space="preserve">
          <source>Time when this process was started, i.e., when the client connected to this WAL sender</source>
          <target state="translated">이 프로세스가 시작된 시간, 즉 클라이언트가이 WAL 발신자에 연결 한 시간</target>
        </trans-unit>
        <trans-unit id="559b0a476d9e562ad140be918c065bb024b1f003" translate="yes" xml:space="preserve">
          <source>Time when this process was started. For client backends, this is the time the client connected to the server.</source>
          <target state="translated">이 프로세스가 시작된 시간입니다. 클라이언트 백엔드의 경우 클라이언트가 서버에 연결 한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="cc12d0007d4c73cf73c1568b7bfdf5da27728eae" translate="yes" xml:space="preserve">
          <source>Time when this process' current transaction was started, or null if no transaction is active. If the current query is the first of its transaction, this column is equal to the &lt;code&gt;query_start&lt;/code&gt; column.</source>
          <target state="translated">이 프로세스의 현재 트랜잭션이 시작된 시간 또는 활성화 된 트랜잭션이 없으면 null입니다. 현재 쿼리가 트랜잭션의 첫 번째 쿼리 인 경우이 열은 &lt;code&gt;query_start&lt;/code&gt; 열과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbdc0abebabeabc5d4b770a667845ccc3c799e2b" translate="yes" xml:space="preserve">
          <source>Time zone abbreviation</source>
          <target state="translated">시간대 약어</target>
        </trans-unit>
        <trans-unit id="e460672f042e9a6f5cb5587fff9b633a5f807f4f" translate="yes" xml:space="preserve">
          <source>Time zone abbreviations defined in the configuration file override non-timezone meanings built into PostgreSQL. For example, the &lt;code&gt;Australia&lt;/code&gt; configuration file defines &lt;code&gt;SAT&lt;/code&gt; (for South Australian Standard Time). When this file is active, &lt;code&gt;SAT&lt;/code&gt; will not be recognized as an abbreviation for Saturday.</source>
          <target state="translated">구성 파일에 정의 된 시간대 약어는 PostgreSQL에 내장 된 시간대 이외의 의미를 무시합니다. 예를 들어 &lt;code&gt;Australia&lt;/code&gt; 구성 파일은 &lt;code&gt;SAT&lt;/code&gt; (남부 오스트레일리아 표준시)를 정의합니다 . 이 파일이 활성화되면 &lt;code&gt;SAT&lt;/code&gt; 가 토요일의 약어로 인식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37a9001f0d01c5209af64be7dc1968df4b54e043" translate="yes" xml:space="preserve">
          <source>Time zone name</source>
          <target state="translated">시간대 이름</target>
        </trans-unit>
        <trans-unit id="d9837496505fa39574debf57863d4c5a7a7e1fa2" translate="yes" xml:space="preserve">
          <source>Time zones, and time-zone conventions, are influenced by political decisions, not just earth geometry. Time zones around the world became somewhat standardized during the 1900s, but continue to be prone to arbitrary changes, particularly with respect to daylight-savings rules. PostgreSQL uses the widely-used IANA (Olson) time zone database for information about historical time zone rules. For times in the future, the assumption is that the latest known rules for a given time zone will continue to be observed indefinitely far into the future.</source>
          <target state="translated">시간대 및 시간대 규칙은 지구 지오메트리뿐만 아니라 정치적 결정의 영향을받습니다. 전 세계 시간대는 1900 년대에 다소 표준화되었지만 특히 일광 절약 규칙과 관련하여 임의의 변경이 계속 발생합니다. PostgreSQL은 널리 사용되는 IANA (Olson) 시간대 데이터베이스를 사용하여 과거 시간대 규칙에 대한 정보를 제공합니다. 앞으로 여러 시간대에 걸쳐, 주어진 시간대에 대해 알려진 최신 규칙은 앞으로도 무한정 계속 지켜 질 것이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="51e0ae72446d2bbeb8c3c3c8b1ad7cfa9371d4af" translate="yes" xml:space="preserve">
          <source>Timeline from which to read log records. The default is to use the value in &lt;code&gt;startseg&lt;/code&gt;, if that is specified; otherwise, the default is 1.</source>
          <target state="translated">로그 레코드를 읽을 타임 라인입니다. 기본값은 &lt;code&gt;startseg&lt;/code&gt; 에 지정된 값을 사용하는 것입니다 (지정된 경우). 그렇지 않으면 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="1a493fe5eba595d570a4b23a6ba4061eb25ab8ef" translate="yes" xml:space="preserve">
          <source>Timeline number of last write-ahead log location received and flushed to disk, the initial value of this field being the timeline number of the first log location used when WAL receiver is started</source>
          <target state="translated">디스크에 수신되어 플러시 된 마지막 미리 쓰기 로그 위치의 타임 라인 번호입니다.이 필드의 초기 값은 WAL 수신자가 시작될 때 사용 된 첫 번째 로그 위치의 타임 라인 번호입니다.</target>
        </trans-unit>
        <trans-unit id="ae2147bbbd74fc0ea70c9f9c1ab21cda42f12f26" translate="yes" xml:space="preserve">
          <source>Timers used on older PC hardware include the 8254 Programmable Interval Timer (PIT), the real-time clock (RTC), the Advanced Programmable Interrupt Controller (APIC) timer, and the Cyclone timer. These timers aim for millisecond resolution.</source>
          <target state="translated">구형 PC 하드웨어에 사용되는 타이머에는 8254 PIT (Programmable Interval Timer), RTC (Real-Time Clock), APIC (Advanced Programmable Interrupt Controller) 타이머 및 사이클론 타이머가 있습니다. 이 타이머는 밀리 초 해상도를 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="87f6f783967c5bb200b51b61ac60c7b2d206bb65" translate="yes" xml:space="preserve">
          <source>Timespan types</source>
          <target state="translated">타임스 팬 유형</target>
        </trans-unit>
        <trans-unit id="239e2086e6fe0c5571eca32707440c4ba53f1fcd" translate="yes" xml:space="preserve">
          <source>Timezone settings given as numbers or intervals are internally translated to POSIX timezone syntax. For example, after &lt;code&gt;SET TIME ZONE -7&lt;/code&gt;, &lt;code&gt;SHOW TIME ZONE&lt;/code&gt; would report &lt;code&gt;&amp;lt;-07&amp;gt;+07&lt;/code&gt;.</source>
          <target state="translated">숫자 또는 간격으로 제공된 시간대 설정은 내부적으로 POSIX 시간대 구문으로 변환됩니다. 예를 들어, 후 &lt;code&gt;SET TIME ZONE -7&lt;/code&gt; , &lt;code&gt;SHOW TIME ZONE&lt;/code&gt; 은 보고 할 것 &lt;code&gt;&amp;lt;-07&amp;gt;+07&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="7e007f7fc0996f8d4eac8a1e1e90b6f80a635659" translate="yes" xml:space="preserve">
          <source>To abort all changes:</source>
          <target state="translated">모든 변경 사항을 중단하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a1de6dbe0b98af8c297b94378a5d03d8bb0f5d29" translate="yes" xml:space="preserve">
          <source>To access a field of a composite column, one writes a dot and the field name, much like selecting a field from a table name. In fact, it's so much like selecting from a table name that you often have to use parentheses to keep from confusing the parser. For example, you might try to select some subfields from our &lt;code&gt;on_hand&lt;/code&gt; example table with something like:</source>
          <target state="translated">복합 열의 필드에 액세스하기 위해 테이블 ​​이름에서 필드를 선택하는 것처럼 점과 필드 이름을 씁니다. 실제로 테이블 이름에서 선택하는 것과 매우 유사하므로 파서를 혼동하지 않도록 괄호를 사용해야하는 경우가 많습니다. 예를 들어, &lt;code&gt;on_hand&lt;/code&gt; 예제 테이블에서 다음과 같은 일부 서브 필드를 선택하려고 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="017b192526f458780b51a75f9b3b25aefc868352" translate="yes" xml:space="preserve">
          <source>To access foreign data, you need to create a &lt;em&gt;foreign server&lt;/em&gt; object, which defines how to connect to a particular external data source according to the set of options used by its supporting foreign data wrapper. Then you need to create one or more &lt;em&gt;foreign tables&lt;/em&gt;, which define the structure of the remote data. A foreign table can be used in queries just like a normal table, but a foreign table has no storage in the PostgreSQL server. Whenever it is used, PostgreSQL asks the foreign data wrapper to fetch data from the external source, or transmit data to the external source in the case of update commands.</source>
          <target state="translated">외부 데이터에 액세스하려면 외부 데이터 래퍼가 지원하는 옵션 세트에 따라 특정 외부 데이터 소스에 연결하는 방법을 정의하는 &lt;em&gt;외부 서버&lt;/em&gt; 오브젝트 를 작성해야합니다 . 그런 다음 원격 데이터의 구조를 정의하는 하나 이상의 &lt;em&gt;외부 테이블&lt;/em&gt; 을 작성해야합니다 . 외부 테이블은 일반 테이블처럼 쿼리에 사용될 수 있지만 외부 테이블은 PostgreSQL 서버에 스토리지가 없습니다. PostgreSQL을 사용할 때마다 외부 데이터 래퍼에 외부 소스에서 데이터를 가져 오거나 업데이트 명령의 경우 외부 소스로 데이터를 전송하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="c882ff143aff4abbe56ed4decc5353a3e40be0c7" translate="yes" xml:space="preserve">
          <source>To achieve a similar effect when running a transaction at the &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level, you have to execute the &lt;code&gt;LOCK TABLE&lt;/code&gt; statement before executing any &lt;code&gt;SELECT&lt;/code&gt; or data modification statement. A &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction's view of data will be frozen when its first &lt;code&gt;SELECT&lt;/code&gt; or data modification statement begins. A &lt;code&gt;LOCK TABLE&lt;/code&gt; later in the transaction will still prevent concurrent writes &amp;mdash; but it won't ensure that what the transaction reads corresponds to the latest committed values.</source>
          <target state="translated">&lt;code&gt;REPEATABLE READ&lt;/code&gt; 또는 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 격리 수준 에서 트랜잭션을 실행할 때 비슷한 효과를 얻으려면 &lt;code&gt;SELECT&lt;/code&gt; 또는 데이터 수정 문을 실행하기 전에 &lt;code&gt;LOCK TABLE&lt;/code&gt; 문을 실행해야 합니다. &lt;code&gt;REPEATABLE READ&lt;/code&gt; 또는 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 처음 할 때 데이터의 트랜잭션 (transaction)의 견해는 동결됩니다 &lt;code&gt;SELECT&lt;/code&gt; 또는 데이터 수정 문이 시작됩니다. 나중에 트랜잭션 의 &lt;code&gt;LOCK TABLE&lt;/code&gt; 은 동시 쓰기를 방지하지만 트랜잭션이 읽은 내용이 커밋 된 최신 값과 일치하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b48da783d51f53cd43e5c00aa186c9d8deaec51" translate="yes" xml:space="preserve">
          <source>To add a (multicolumn) unique constraint to a table:</source>
          <target state="translated">테이블에 (다중 열) 고유 제한 조건을 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7c2dc11d3fbd2d572d80e9f7f2427e18b8265aab" translate="yes" xml:space="preserve">
          <source>To add a &lt;code&gt;NOT NULL&lt;/code&gt; constraint to a domain:</source>
          <target state="translated">도메인에 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건 을 추가하려면</target>
        </trans-unit>
        <trans-unit id="05f31d6bcf939e6d5e9a463994e90aee8d1e54a8" translate="yes" xml:space="preserve">
          <source>To add a Unix user account to your system, look for a command &lt;code&gt;useradd&lt;/code&gt; or &lt;code&gt;adduser&lt;/code&gt;. The user name postgres is often used, and is assumed throughout this book, but you can use another name if you like.</source>
          <target state="translated">시스템에 Unix 사용자 계정을 추가하려면 &lt;code&gt;useradd&lt;/code&gt; 또는 &lt;code&gt;adduser&lt;/code&gt; 명령을 찾으십시오 . postgres라는 사용자 이름이 자주 사용되며이 책 전체에서 사용되지만 원하는 경우 다른 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebfcefdd7e6dd46087f7db4f56ad55b502aa3b38" translate="yes" xml:space="preserve">
          <source>To add a check constraint only to a table and not to its children:</source>
          <target state="translated">점검 제한 조건을 해당 테이블의 하위 테이블이 아닌 테이블에만 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3438d5034c17e4d50c71f282c86de2e7e88a0e" translate="yes" xml:space="preserve">
          <source>To add a check constraint to a domain:</source>
          <target state="translated">도메인에 점검 제한 조건을 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b2e451d1684f5b60db7be22ba4fea7da5b7b7b9e" translate="yes" xml:space="preserve">
          <source>To add a check constraint to a table and all its children:</source>
          <target state="translated">테이블과 모든 해당 자식에 검사 제한 조건을 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="18521a2d32e7178b56eb305ab469851b96ca3009" translate="yes" xml:space="preserve">
          <source>To add a column and fill it with a value different from the default to be used later:</source>
          <target state="translated">열을 추가하고 나중에 사용할 기본값과 다른 값으로 채우려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="174131dc66d4970ba5125ca4661ff1a19109b4b9" translate="yes" xml:space="preserve">
          <source>To add a column of type &lt;code&gt;varchar&lt;/code&gt; to a table:</source>
          <target state="translated">&lt;code&gt;varchar&lt;/code&gt; 유형의 열을 테이블에 추가하려면</target>
        </trans-unit>
        <trans-unit id="9b1aeaa1dc1643fc190e738e9d094e62f17c2e7e" translate="yes" xml:space="preserve">
          <source>To add a column with a non-null default:</source>
          <target state="translated">널이 아닌 기본값으로 열을 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a1c2f4fa0ab2023d587d3b98db8f6427264ba706" translate="yes" xml:space="preserve">
          <source>To add a column, use a command like:</source>
          <target state="translated">열을 추가하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f37ab4f4bb9bd95a03c2a18bda2edd2159fb3ba" translate="yes" xml:space="preserve">
          <source>To add a constraint, the table constraint syntax is used. For example:</source>
          <target state="translated">제한 조건을 추가하기 위해 테이블 ​​제한 조건 구문이 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="552cd578dc1fe8e243759547fbc657cae049fb54" translate="yes" xml:space="preserve">
          <source>To add a foreign key constraint to a table with the least impact on other work:</source>
          <target state="translated">다른 작업에 미치는 영향을 최소화하면서 외래 키 제약 조건을 테이블에 추가하려면</target>
        </trans-unit>
        <trans-unit id="0ab66f0fba250760a2399696fd0b16e5bf040c43" translate="yes" xml:space="preserve">
          <source>To add a foreign key constraint to a table:</source>
          <target state="translated">테이블에 외래 키 제약 조건을 추가하려면</target>
        </trans-unit>
        <trans-unit id="d58a827d4f546e75e64876a110b2a9ae7702ffe0" translate="yes" xml:space="preserve">
          <source>To add a new attribute to a composite type:</source>
          <target state="translated">복합 유형에 새 속성을 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3411926179ac8624e69940712a6f3380af5e790a" translate="yes" xml:space="preserve">
          <source>To add a new attribute to a type:</source>
          <target state="translated">유형에 새 속성을 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="db77b529c04682a830e59457f320121602d467bb" translate="yes" xml:space="preserve">
          <source>To add a new child table to handle new data, create an empty child table just as the original children were created above:</source>
          <target state="translated">새 데이터를 처리하기 위해 새 자식 테이블을 추가하려면 원래 자식을 위에서 만든 것처럼 빈 자식 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9161ab2c4e67b5fb82cc744c9d3774972dec4893" translate="yes" xml:space="preserve">
          <source>To add a new value to an enum type in a particular sort position:</source>
          <target state="translated">특정 정렬 위치에서 열거 형에 새 값을 추가하려면</target>
        </trans-unit>
        <trans-unit id="a31abc40dd1208477736069bb4013695302376d8" translate="yes" xml:space="preserve">
          <source>To add a not-null constraint to a column:</source>
          <target state="translated">널이 아닌 제한 조건을 열에 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cb6a3f80db2bc2ad72d4c62c4940bdf89c57476e" translate="yes" xml:space="preserve">
          <source>To add a not-null constraint, which cannot be written as a table constraint, use this syntax:</source>
          <target state="translated">테이블 제약 조건으로 쓸 수없는 null이 아닌 제약 조건을 추가하려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6bad209cf083236dccc11fc40cf4f91317deadaf" translate="yes" xml:space="preserve">
          <source>To add a table to a publication, the invoking user must have ownership rights on the table. The &lt;code&gt;FOR ALL TABLES&lt;/code&gt; clause requires the invoking user to be a superuser.</source>
          <target state="translated">게시에 테이블을 추가하려면 호출하는 사용자에게 테이블에 대한 소유권이 있어야합니다. &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 절은 수퍼 유저로 호출하는 사용자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0ae21ae330630cd68145a9fe01a93dd7045defb6" translate="yes" xml:space="preserve">
          <source>To add an automatically named primary key constraint to a table, noting that a table can only ever have one primary key:</source>
          <target state="translated">테이블에 기본 키가 하나만있을 수 있다는 점에 유의하면서 자동으로 명명 된 기본 키 제약 조건을 테이블에 추가하려면</target>
        </trans-unit>
        <trans-unit id="afa12cb0c308a9db161baf8949e517c49dc4c5c8" translate="yes" xml:space="preserve">
          <source>To add an existing function to the &lt;code&gt;hstore&lt;/code&gt; extension:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 확장에 기존 기능을 추가하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="22b234bd9cd26b96824fe520230d7c5e449fc297" translate="yes" xml:space="preserve">
          <source>To add tables to a publication, the user must have ownership rights on the table. To create a publication that publishes all tables automatically, the user must be a superuser.</source>
          <target state="translated">게시에 테이블을 추가하려면 사용자에게 테이블에 대한 소유권이 있어야합니다. 모든 테이블을 자동으로 게시하는 게시를 만들려면 사용자가 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="83730299a560c3c0731431f81b51c2abe2442fdf" translate="yes" xml:space="preserve">
          <source>To address these difficulties, we recommend using date/time types that contain both date and time when using time zones. We do &lt;em&gt;not&lt;/em&gt; recommend using the type &lt;code&gt;time with time zone&lt;/code&gt; (though it is supported by PostgreSQL for legacy applications and for compliance with the SQL standard). PostgreSQL assumes your local time zone for any type containing only date or time.</source>
          <target state="translated">이러한 문제를 해결하려면 시간대를 사용할 때 날짜와 시간이 모두 포함 된 날짜 / 시간 유형을 사용하는 것이 좋습니다. &lt;code&gt;time with time zone&lt;/code&gt; 사용 하지 &lt;em&gt;않는&lt;/em&gt; 것이 좋습니다 (레거시 응용 프로그램 및 SQL 표준 준수를 위해 PostgreSQL에서 지원하지만). PostgreSQL은 날짜 또는 시간 만 포함하는 모든 유형의 현지 시간대를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b7065094627525a073a51f64da60efc6b8e9bee4" translate="yes" xml:space="preserve">
          <source>To adjust the search path that is automatically set for a function:</source>
          <target state="translated">기능에 자동으로 설정되는 검색 경로를 조정하려면</target>
        </trans-unit>
        <trans-unit id="454e8b704e7b145c0be218174873a9c9a43d4489" translate="yes" xml:space="preserve">
          <source>To adjust the search path that is automatically set for a procedure:</source>
          <target state="translated">절차에 대해 자동으로 설정된 검색 경로를 조정하려면</target>
        </trans-unit>
        <trans-unit id="43832a6258ef921e1a75d9d839da59e22b5679fa" translate="yes" xml:space="preserve">
          <source>To allow many users to use one database without interfering with each other.</source>
          <target state="translated">많은 사용자가 서로 간섭하지 않고 하나의 데이터베이스를 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="69f1ad561f1cfb2e35cd3c6eff1bf6db4e335624" translate="yes" xml:space="preserve">
          <source>To alter the default collation order or character set classes, use the &lt;code&gt;--lc-collate&lt;/code&gt; and &lt;code&gt;--lc-ctype&lt;/code&gt; options. Collation orders other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; also have a performance penalty. For these reasons it is important to choose the right locale when running &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">기본 데이터 정렬 순서 또는 문자 집합 클래스를 변경하려면 &lt;code&gt;--lc-collate&lt;/code&gt; 및 &lt;code&gt;--lc-ctype&lt;/code&gt; 옵션을 사용하십시오. &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;POSIX&lt;/code&gt; 이외의 데이터 정렬 주문 에도 성능이 저하됩니다. 이러한 이유로 &lt;code&gt;initdb&lt;/code&gt; 를 실행할 때 올바른 로케일을 선택하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="2add0ec4b26fbbc0bb9c1c7436006edf85689aa1" translate="yes" xml:space="preserve">
          <source>To alter the default encoding, use the &lt;code&gt;--encoding&lt;/code&gt;. More details can be found in &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;.</source>
          <target state="translated">기본 인코딩을 변경하려면 &lt;code&gt;--encoding&lt;/code&gt; 을 사용하십시오 . 자세한 내용은 &lt;a href=&quot;multibyte&quot;&gt;섹션 23.3을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1826e1649b94ce735f6431fdd9a17150394fd248" translate="yes" xml:space="preserve">
          <source>To alter the server you must be the owner of the server. Additionally to alter the owner, you must own the server and also be a direct or indirect member of the new owning role, and you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the server's foreign-data wrapper. (Note that superusers satisfy all these criteria automatically.)</source>
          <target state="translated">서버를 변경하려면 서버의 소유자 여야합니다. 또한 소유자를 변경하려면 서버를 소유하고 새 소유 역할의 직접 또는 간접 구성원이어야 하며 서버의 외부 데이터 래퍼에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한 이 있어야합니다 . (수퍼 유저는 이러한 모든 기준을 자동으로 충족합니다.)</target>
        </trans-unit>
        <trans-unit id="7ddeb73fb5d4e79b9c3c1e564a7ef4c6351feb67" translate="yes" xml:space="preserve">
          <source>To analyze a table, one must ordinarily be the table's owner or a superuser. However, database owners are allowed to analyze all tables in their databases, except shared catalogs. (The restriction for shared catalogs means that a true database-wide &lt;code&gt;ANALYZE&lt;/code&gt; can only be performed by a superuser.) &lt;code&gt;ANALYZE&lt;/code&gt; will skip over any tables that the calling user does not have permission to analyze.</source>
          <target state="translated">테이블을 분석하려면 일반적으로 테이블의 소유자 또는 수퍼 유저 여야합니다. 그러나 데이터베이스 소유자는 공유 카탈로그를 제외한 데이터베이스의 모든 테이블을 분석 할 수 있습니다. (공유 카탈로그에 대한 제한은 실제 데이터베이스 전체의 &lt;code&gt;ANALYZE&lt;/code&gt; 는 수퍼 유저 만 수행 할 수 있음을 의미합니다 .) &lt;code&gt;ANALYZE&lt;/code&gt; 는 호출하는 사용자에게 분석 권한이없는 테이블을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="3ceea8787427d383c0bca554922094f48e526fe4" translate="yes" xml:space="preserve">
          <source>To assign privileges, the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command is used. For example, if &lt;code&gt;joe&lt;/code&gt; is an existing role, and &lt;code&gt;accounts&lt;/code&gt; is an existing table, the privilege to update the table can be granted with:</source>
          <target state="translated">권한을 할당하기 위해 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 명령이 사용됩니다. 예를 들어 &lt;code&gt;joe&lt;/code&gt; 가 기존 역할이고 &lt;code&gt;accounts&lt;/code&gt; 가 기존 테이블 인 경우 테이블을 업데이트 할 권한을 다음과 같이 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="841afb234a29a395e3e0830fae028e72521f88ca" translate="yes" xml:space="preserve">
          <source>To attach a default column value to an updatable view:</source>
          <target state="translated">업데이트 가능한보기에 기본 열 값을 첨부하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c91056b552b812becaf03884b78b11880acaa830" translate="yes" xml:space="preserve">
          <source>To attach a default partition to a partitioned table:</source>
          <target state="translated">파티션 된 테이블에 기본 파티션을 첨부하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="903700b262c75e1e9a2686570b8d3d9a905f0191" translate="yes" xml:space="preserve">
          <source>To attach a partition to a hash-partitioned table:</source>
          <target state="translated">파티션을 해시 파티션 테이블에 첨부하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="816912ec3804829192e5b4b51ed04c4c04e0fc1d" translate="yes" xml:space="preserve">
          <source>To attach a partition to a list-partitioned table:</source>
          <target state="translated">파티션을 목록 파티션 된 테이블에 첨부하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="38cc90d5c14d343f7257c521bec65b2a2c788861" translate="yes" xml:space="preserve">
          <source>To attach a partition to a range-partitioned table:</source>
          <target state="translated">범위 파티션 된 테이블에 파티션을 첨부하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a338146ab7e1a8a6c29211a64020a73e715d047f" translate="yes" xml:space="preserve">
          <source>To avoid blocking concurrent transactions that obtain numbers from the same sequence, a &lt;code&gt;nextval&lt;/code&gt; operation is never rolled back; that is, once a value has been fetched it is considered used and will not be returned again. This is true even if the surrounding transaction later aborts, or if the calling query ends up not using the value. For example an &lt;code&gt;INSERT&lt;/code&gt; with an &lt;code&gt;ON CONFLICT&lt;/code&gt; clause will compute the to-be-inserted tuple, including doing any required &lt;code&gt;nextval&lt;/code&gt; calls, before detecting any conflict that would cause it to follow the &lt;code&gt;ON CONFLICT&lt;/code&gt; rule instead. Such cases will leave unused &amp;ldquo;holes&amp;rdquo; in the sequence of assigned values. Thus, PostgreSQL sequence objects &lt;em&gt;cannot be used to obtain &amp;ldquo;gapless&amp;rdquo; sequences&lt;/em&gt;.</source>
          <target state="translated">동일한 시퀀스에서 숫자를 얻는 동시 트랜잭션을 차단하지 않으려면 &lt;code&gt;nextval&lt;/code&gt; 조작이 롤백되지 않습니다. 즉, 일단 페치 된 값은 사용 된 것으로 간주되어 다시 리턴되지 않습니다. 주변 트랜잭션이 나중에 중단되거나 호출 쿼리가 값을 사용하지 않는 경우에도 마찬가지입니다. 예를 들어 &lt;code&gt;INSERT&lt;/code&gt; 와 &lt;code&gt;ON CONFLICT&lt;/code&gt; 절은 필요한 일을 포함에-삽입 될 튜플을 계산합니다 &lt;code&gt;nextval&lt;/code&gt; 가 따라 원인이 충돌 감지하기 전에 전화를 &lt;code&gt;ON CONFLICT&lt;/code&gt; 대신 규칙을. 이러한 경우 할당 된 값 순서에 따라 사용되지 않은 &quot;구멍&quot;이 남습니다. 따라서 PostgreSQL 시퀀스 객체&lt;em&gt;&quot;갭이없는&quot;시퀀스를 얻는 데 사용할 수 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="77db4bef2cb8a0ae44c281dac0dfd436dc1a536b" translate="yes" xml:space="preserve">
          <source>To avoid confusion with the non-slice case, it's best to use slice syntax for all dimensions, e.g., &lt;code&gt;[1:2][1:1]&lt;/code&gt;, not &lt;code&gt;[2][1:1]&lt;/code&gt;.</source>
          <target state="translated">슬라이스가 아닌 경우와 혼동되지 않도록 모든 차원에 슬라이스 구문을 사용하는 것이 가장 좋습니다 (예 &lt;code&gt;[1:2][1:1]&lt;/code&gt; 이 아닌 &lt;code&gt;[2][1:1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2abfccf591d4ddb924887ea39256c518691d084" translate="yes" xml:space="preserve">
          <source>To avoid flooding the I/O system with a burst of page writes, writing dirty buffers during a checkpoint is spread over a period of time. That period is controlled by &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt;, which is given as a fraction of the checkpoint interval. The I/O rate is adjusted so that the checkpoint finishes when the given fraction of &lt;code&gt;checkpoint_timeout&lt;/code&gt; seconds have elapsed, or before &lt;code&gt;max_wal_size&lt;/code&gt; is exceeded, whichever is sooner. With the default value of 0.5, PostgreSQL can be expected to complete each checkpoint in about half the time before the next checkpoint starts. On a system that's very close to maximum I/O throughput during normal operation, you might want to increase &lt;code&gt;checkpoint_completion_target&lt;/code&gt; to reduce the I/O load from checkpoints. The disadvantage of this is that prolonging checkpoints affects recovery time, because more WAL segments will need to be kept around for possible use in recovery. Although &lt;code&gt;checkpoint_completion_target&lt;/code&gt; can be set as high as 1.0, it is best to keep it less than that (perhaps 0.9 at most) since checkpoints include some other activities besides writing dirty buffers. A setting of 1.0 is quite likely to result in checkpoints not being completed on time, which would result in performance loss due to unexpected variation in the number of WAL segments needed.</source>
          <target state="translated">버스트 페이지 쓰기로 I / O 시스템이 넘치지 않도록 체크 포인트 동안 더티 버퍼 쓰기가 일정 기간 동안 분산됩니다. 이 기간은 &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt; 에 의해 제어되며 이는 검사 점 간격의 일부로 제공됩니다. 주어진 &lt;code&gt;checkpoint_timeout&lt;/code&gt; 초의 분율 이 경과하거나 &lt;code&gt;max_wal_size&lt;/code&gt; 를 초과 하기 전에 체크 포인트가 완료되도록 I / O 속도가 조정됩니다 . 기본값 0.5로 PostgreSQL은 다음 체크 포인트가 시작되기 전 약 절반의 시간 안에 각 체크 포인트를 완료 할 것으로 예상 할 수 있습니다. 정상 작동 중 최대 I / O 처리량에 매우 가까운 시스템에서 &lt;code&gt;checkpoint_completion_target&lt;/code&gt; 을 증가시킬 수 있습니다.체크 포인트에서 I / O로드를 줄입니다. 단점은 복구에 사용하기 위해 더 많은 WAL 세그먼트를 유지해야하기 때문에 검사 ​​점을 연장하면 복구 시간에 영향을 미친다는 것입니다. &lt;code&gt;checkpoint_completion_target&lt;/code&gt; 을 1.0으로 높게 설정할 수 있지만 , 검사 점에는 더티 버퍼를 작성하는 것 외에 다른 활동이 포함되므로이 값보다 낮게 유지하는 것이 가장 좋습니다 (최대 0.9). 1.0으로 설정하면 검사 점이 정시에 완료되지 않을 수 있으며, 필요한 WAL 세그먼트 수의 예상치 못한 변동으로 인해 성능 손실이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b5b7ab793933b28d259bd7231f552d4046ed360" translate="yes" xml:space="preserve">
          <source>To back up your database installation, type:</source>
          <target state="translated">데이터베이스 설치를 백업하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="f94848a530617c32c61eaedaa18cb50416b23aee" translate="yes" xml:space="preserve">
          <source>To be able to create a cast, you must own the source or the target data type and have &lt;code&gt;USAGE&lt;/code&gt; privilege on the other type. To create a binary-coercible cast, you must be superuser. (This restriction is made because an erroneous binary-coercible cast conversion can easily crash the server.)</source>
          <target state="translated">캐스트를 작성하려면 소스 또는 대상 데이터 유형을 소유 하고 다른 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권 이 있어야 합니다. 이진 강제 변환 캐스트를 만들려면 수퍼 유저 여야합니다. 이 제한은 잘못된 이진 강제 변환 변환으로 인해 서버가 쉽게 중단 될 수 있기 때문에 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="9403a03a717e8159d4311e7a77af5d9d4fb13286" translate="yes" xml:space="preserve">
          <source>To be able to create a collation, you must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the destination schema.</source>
          <target state="translated">데이터 정렬을 만들려면 대상 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="004ac46cbced6bb34d9fcdda47baad54a412d6db" translate="yes" xml:space="preserve">
          <source>To be able to create a composite type, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on all attribute types.</source>
          <target state="translated">복합 유형을 작성하려면 모든 속성 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="20b3394619973d7ff2a0ab6610243d2596213934" translate="yes" xml:space="preserve">
          <source>To be able to create a conversion, you must have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the function and &lt;code&gt;CREATE&lt;/code&gt; privilege on the destination schema.</source>
          <target state="translated">변환을 작성하려면 함수에 &lt;code&gt;EXECUTE&lt;/code&gt; 특권과 대상 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 특권이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="295a1d858678a24280b233e415d3074c116b7910" translate="yes" xml:space="preserve">
          <source>To be able to create a domain, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the underlying type.</source>
          <target state="translated">도메인을 만들려면 기본 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0e4637b6352c01797fe0bddb86f23c5c0081af1c" translate="yes" xml:space="preserve">
          <source>To be able to create a foreign table, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server, as well as &lt;code&gt;USAGE&lt;/code&gt; privilege on all column types used in the table.</source>
          <target state="translated">외국 테이블을 만들 수 있습니다, 당신은 있어야합니다 &lt;code&gt;USAGE&lt;/code&gt; 외국 서버에 권한뿐만 아니라 &lt;code&gt;USAGE&lt;/code&gt; 테이블에 사용 된 모든 열 유형에 대한 권한을.</target>
        </trans-unit>
        <trans-unit id="0ce885ed17ee0914c81250038c5ba73a1255a62b" translate="yes" xml:space="preserve">
          <source>To be able to create a function, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the argument types and the return type.</source>
          <target state="translated">함수를 작성하려면 인수 유형 및 리턴 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c3349946c487347d94244d5f0d2b8cbf6db2014c" translate="yes" xml:space="preserve">
          <source>To be able to create a procedure, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the argument types.</source>
          <target state="translated">프로 시저를 작성하려면 인수 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e8d0cffcf604ddb9a2b21dd6b9ecc772bbb4ea7" translate="yes" xml:space="preserve">
          <source>To be able to create a table, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on all column types or the type in the &lt;code&gt;OF&lt;/code&gt; clause, respectively.</source>
          <target state="translated">테이블을 작성하려면 모든 컬럼 유형 또는 &lt;code&gt;OF&lt;/code&gt; 절의 유형에 대해 각각 &lt;code&gt;USAGE&lt;/code&gt; 특권 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c3d9e2e6a7511d1edae30a9dff5bd26d7e819ca" translate="yes" xml:space="preserve">
          <source>To be able to create a transform, you must own and have &lt;code&gt;USAGE&lt;/code&gt; privilege on the type, have &lt;code&gt;USAGE&lt;/code&gt; privilege on the language, and own and have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the from-SQL and to-SQL functions, if specified.</source>
          <target state="translated">A는 변환 만들 수 있습니다, 당신은 소유하고 있어야합니다 &lt;code&gt;USAGE&lt;/code&gt; 이, 유형에 권한을 &lt;code&gt;USAGE&lt;/code&gt; 의 언어에 권한을, 그리고 자신과이 &lt;code&gt;EXECUTE&lt;/code&gt; 지정된 경우 SQL-에서와에-SQL 기능에 권한을.</target>
        </trans-unit>
        <trans-unit id="492ecbb35318f60a13457061cf57ee1399559558" translate="yes" xml:space="preserve">
          <source>To be able to create an aggregate function, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the argument types, the state type(s), and the return type, as well as &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the supporting functions.</source>
          <target state="translated">집계 함수를 작성하려면 인수 유형, 상태 유형 및 리턴 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권과 지원 함수에 대한 &lt;code&gt;EXECUTE&lt;/code&gt; 특권이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6ec21fb5fc656c37513106d994c36fd0ac97b19a" translate="yes" xml:space="preserve">
          <source>To be able to create an operator, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the argument types and the return type, as well as &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the underlying function. If a commutator or negator operator is specified, you must own these operators.</source>
          <target state="translated">연산자를 작성하려면 , 기본 함수에 대한 &lt;code&gt;EXECUTE&lt;/code&gt; 특권 뿐만 아니라 인수 유형 및 리턴 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권 이 있어야합니다 . 정류자 또는 음수 연산자가 지정된 경우 이러한 연산자를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="1576f76a79f37902dec9d1049cfafa4fa8226f10" translate="yes" xml:space="preserve">
          <source>To be able to drop a cast, you must own the source or the target data type. These are the same privileges that are required to create a cast.</source>
          <target state="translated">캐스트를 삭제하려면 소스 또는 대상 데이터 유형을 소유해야합니다. 캐스트를 작성하는 데 필요한 것과 동일한 권한입니다.</target>
        </trans-unit>
        <trans-unit id="f24771db16a8b952d2aba66eabbf00ce04304eb5" translate="yes" xml:space="preserve">
          <source>To be able to drop a transform, you must own the type and the language. These are the same privileges that are required to create a transform.</source>
          <target state="translated">변환을 제거하려면 유형과 언어를 소유해야합니다. 이들은 변환을 작성하는 데 필요한 동일한 권한입니다.</target>
        </trans-unit>
        <trans-unit id="6b5f4f9a5727d863fa1595ea99bd05f639d52879" translate="yes" xml:space="preserve">
          <source>To be useful, an index access method must also have one or more &lt;em&gt;operator families&lt;/em&gt; and &lt;em&gt;operator classes&lt;/em&gt; defined in &lt;a href=&quot;catalog-pg-opfamily&quot;&gt;&lt;code&gt;pg_opfamily&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;. These entries allow the planner to determine what kinds of query qualifications can be used with indexes of this access method. Operator families and classes are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;, which is prerequisite material for reading this chapter.</source>
          <target state="translated">유용하게 사용하려면 인덱스 액세스 메소드 에 &lt;a href=&quot;catalog-pg-opfamily&quot;&gt; &lt;code&gt;pg_opfamily&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;catalog-pg-amop&quot;&gt; &lt;code&gt;pg_amop&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;catalog-pg-amproc&quot;&gt; &lt;code&gt;pg_amproc&lt;/code&gt; 에&lt;/a&gt; 정의 된 하나 이상의 &lt;em&gt;연산자 제품군&lt;/em&gt; 및 &lt;em&gt;연산자 클래스가 &lt;/em&gt;있어야 합니다. 이러한 항목을 통해 플래너는이 액세스 방법의 인덱스에 사용할 수있는 쿼리 자격 종류를 결정할 수 있습니다. 오퍼레이터 패밀리와 클래스는 이 장을 읽기위한 필수 자료 인 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;섹션 37.16에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c0d2058fa7ce3c9ef9d1a489e052901ecfbd7ee" translate="yes" xml:space="preserve">
          <source>To be useful, an index access method must also have one or more &lt;em&gt;operator families&lt;/em&gt; and &lt;em&gt;operator classes&lt;/em&gt; defined in &lt;a href=&quot;catalog-pg-opfamily&quot;&gt;&lt;code&gt;pg_opfamily&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;. These entries allow the planner to determine what kinds of query qualifications can be used with indexes of this access method. Operator families and classes are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;, which is prerequisite material for reading this chapter.</source>
          <target state="translated">유용하게 사용하려면 인덱스 액세스 방법 에 &lt;a href=&quot;catalog-pg-opfamily&quot;&gt; &lt;code&gt;pg_opfamily&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;catalog-pg-amop&quot;&gt; &lt;code&gt;pg_amop&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;catalog-pg-amproc&quot;&gt; &lt;code&gt;pg_amproc&lt;/code&gt; 에&lt;/a&gt; 정의 된 하나 이상의 &lt;em&gt;연산자 패밀리&lt;/em&gt; 및 &lt;em&gt;연산자 클래스가 &lt;/em&gt;있어야 합니다. 이러한 항목을 통해 플래너는이 액세스 방법의 인덱스와 함께 사용할 수있는 쿼리 제한의 종류를 결정할 수 있습니다. 운영자 제품군 및 클래스는 이 장을 읽기위한 필수 자료 인 &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;섹션 37.16에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a4c4c99064dacb5bf122b1b529d83437bd93dc" translate="yes" xml:space="preserve">
          <source>To begin a SASL authentication exchange, the server sends an AuthenticationSASL message. It includes a list of SASL authentication mechanisms that the server can accept, in the server's preferred order.</source>
          <target state="translated">SASL 인증 교환을 시작하기 위해 서버는 AuthenticationSASL 메시지를 보냅니다. 서버가 선호하는 순서대로 서버가 승인 할 수있는 SASL 인증 메커니즘 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d863c4c1d2466cf7360c719b28ca35b233ce142" translate="yes" xml:space="preserve">
          <source>To begin a new transaction with the same snapshot as an already existing transaction, first export the snapshot from the existing transaction. That will return the snapshot identifier, for example:</source>
          <target state="translated">기존 트랜잭션과 동일한 스냅 샷으로 새 트랜잭션을 시작하려면 먼저 기존 트랜잭션에서 스냅 샷을 내 보냅니다. 예를 들어 스냅 샷 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5f67d1858f44978073928296e3d5bdf0c554243" translate="yes" xml:space="preserve">
          <source>To begin a transaction block:</source>
          <target state="translated">트랜잭션 블록을 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8d63fb8b018b45b6ca4678226dc5b5b97fddd13a" translate="yes" xml:space="preserve">
          <source>To build this module, include the option &lt;code&gt;--with-selinux&lt;/code&gt; in your PostgreSQL &lt;code&gt;configure&lt;/code&gt; command. Be sure that the &lt;code&gt;libselinux-devel&lt;/code&gt; RPM is installed at build time.</source>
          <target state="translated">이 모듈을 빌드하려면 PostgreSQL &lt;code&gt;configure&lt;/code&gt; 명령 에 &lt;code&gt;--with-selinux&lt;/code&gt; 옵션을 포함하십시오 . 빌드시 &lt;code&gt;libselinux-devel&lt;/code&gt; RPM이 설치되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7fa621baea0b3b0913b5bf5570b502c47b4a36d" translate="yes" xml:space="preserve">
          <source>To call a function (not a procedure), use &lt;code&gt;SELECT&lt;/code&gt; instead.</source>
          <target state="translated">프로 시저가 아닌 함수를 호출하려면 대신 &lt;code&gt;SELECT&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f5bfe5b3536a1a2fad1b91e3fc2b1b162c62c4bf" translate="yes" xml:space="preserve">
          <source>To cancel a running query, send the &lt;code&gt;SIGINT&lt;/code&gt; signal to the process running that command. To terminate a backend process cleanly, send &lt;code&gt;SIGTERM&lt;/code&gt; to that process. See also &lt;code&gt;pg_cancel_backend&lt;/code&gt; and &lt;code&gt;pg_terminate_backend&lt;/code&gt; in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.26.2&lt;/a&gt; for the SQL-callable equivalents of these two actions.</source>
          <target state="translated">실행중인 쿼리를 취소하려면 &lt;code&gt;SIGINT&lt;/code&gt; 신호를 해당 명령을 실행하는 프로세스로 보냅니다 . 백엔드 프로세스를 완전히 종료하려면 해당 프로세스 로 &lt;code&gt;SIGTERM&lt;/code&gt; 을 전송하십시오 . 참조 &lt;code&gt;pg_cancel_backend&lt;/code&gt; 및 &lt;code&gt;pg_terminate_backend&lt;/code&gt; 에서 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;제 9.26.2&lt;/a&gt; 이 두 행동의 SQL-호출 등가물을 위해.</target>
        </trans-unit>
        <trans-unit id="afc70d4ddd1752f4bd9d1625d9e107d9520e6ba4" translate="yes" xml:space="preserve">
          <source>To cancel a running query, send the &lt;code&gt;SIGINT&lt;/code&gt; signal to the process running that command. To terminate a backend process cleanly, send &lt;code&gt;SIGTERM&lt;/code&gt; to that process. See also &lt;code&gt;pg_cancel_backend&lt;/code&gt; and &lt;code&gt;pg_terminate_backend&lt;/code&gt; in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.27.2&lt;/a&gt; for the SQL-callable equivalents of these two actions.</source>
          <target state="translated">실행중인 쿼리를 취소하려면 해당 명령을 실행하는 프로세스에 &lt;code&gt;SIGINT&lt;/code&gt; 신호를 보냅니다 . 백엔드 프로세스를 완전히 종료하려면 해당 프로세스에 &lt;code&gt;SIGTERM&lt;/code&gt; 을 보냅니다 . 이 두 작업의 SQL 호출 가능 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;항목에 대해서는 섹션 9.27.2의 &lt;/a&gt; &lt;code&gt;pg_cancel_backend&lt;/code&gt; 및 &lt;code&gt;pg_terminate_backend&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7124694e949a1f4440b60306713bd6c20059c689" translate="yes" xml:space="preserve">
          <source>To change an index's fill factor (assuming that the index method supports it):</source>
          <target state="translated">색인의 채우기 비율을 변경하려면 (색인 방법이 색인을 지원한다고 가정) :</target>
        </trans-unit>
        <trans-unit id="6955113ac82d44bffe42ad325ae4781dcb416e27" translate="yes" xml:space="preserve">
          <source>To change an integer column containing Unix timestamps to &lt;code&gt;timestamp with time zone&lt;/code&gt; via a &lt;code&gt;USING&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 절을 통해 &lt;code&gt;timestamp with time zone&lt;/code&gt; Unix 시간 소인이 포함 된 정수 열을 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c297dad60dcd6cd314e12568c335bf0cd7fff41" translate="yes" xml:space="preserve">
          <source>To change options of a foreign table:</source>
          <target state="translated">외부 테이블의 옵션을 변경하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="99d1020f0ea652992c1f3cc6d0862f5775f34f3d" translate="yes" xml:space="preserve">
          <source>To change the owner of the aggregate function &lt;code&gt;myavg&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형 의 집계 함수 &lt;code&gt;myavg&lt;/code&gt; 의 소유자 를 &lt;code&gt;joe&lt;/code&gt; 로 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef10e3fcd3c6781c71305649cddcd491edef3899" translate="yes" xml:space="preserve">
          <source>To change the owner of the collation &lt;code&gt;en_US&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">데이터 정렬 &lt;code&gt;en_US&lt;/code&gt; 의 소유자 를 &lt;code&gt;joe&lt;/code&gt; 로 변경하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2210eee6a53d3f3138510ccb5b7192d71091c40" translate="yes" xml:space="preserve">
          <source>To change the owner of the conversion &lt;code&gt;iso_8859_1_to_utf8&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">변환 &lt;code&gt;iso_8859_1_to_utf8&lt;/code&gt; 의 소유자 를 &lt;code&gt;joe&lt;/code&gt; 로 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="9315eb7f46fb852d6250bffd8c242174b624ca93" translate="yes" xml:space="preserve">
          <source>To change the owner of the function &lt;code&gt;sqrt&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형의 &lt;code&gt;sqrt&lt;/code&gt; 함수 소유자 를 &lt;code&gt;joe&lt;/code&gt; 로 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="e02af5ff31aa7df16e74fe6528519fcbdbfdd4a0" translate="yes" xml:space="preserve">
          <source>To change the owner of the procedure &lt;code&gt;insert_data&lt;/code&gt; with two arguments of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형의 두 인수가있는 &lt;code&gt;insert_data&lt;/code&gt; 프로 시저의 소유자 를 &lt;code&gt;joe&lt;/code&gt; 로 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e3fa5d60b34896d63a2a5418d8361fead53b69f" translate="yes" xml:space="preserve">
          <source>To change the owner of the type &lt;code&gt;email&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;email&lt;/code&gt; 유형의 소유자 를 &lt;code&gt;joe&lt;/code&gt; 로 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ba22599c15d79141f2290f4581a20c44866aa92" translate="yes" xml:space="preserve">
          <source>To change the schema of the &lt;code&gt;hstore&lt;/code&gt; extension to &lt;code&gt;utils&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 확장 의 스키마 를 &lt;code&gt;utils&lt;/code&gt; 로 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a49ec78abaf3db529ca1802f32d2a37a26f5e05" translate="yes" xml:space="preserve">
          <source>To change the schema of the function &lt;code&gt;sqrt&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;maths&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형의 &lt;code&gt;sqrt&lt;/code&gt; 함수 스키마 를 &lt;code&gt;maths&lt;/code&gt; 로 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="961024d3f9ac4941122ab86c292598b33e9c7465" translate="yes" xml:space="preserve">
          <source>To change the schema of the procedure &lt;code&gt;insert_data&lt;/code&gt; with two arguments of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;accounting&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형의 두 인수가있는 &lt;code&gt;insert_data&lt;/code&gt; 프로 시저의 스키마 를 &lt;code&gt;accounting&lt;/code&gt; 으로 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1017843ce076fcbd256ae42991691e946e03d4f" translate="yes" xml:space="preserve">
          <source>To change the schema of the type &lt;code&gt;email&lt;/code&gt; to &lt;code&gt;customers&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;email&lt;/code&gt; 유형의 스키마 를 &lt;code&gt;customers&lt;/code&gt; 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="02fa2f5cd59b1c854d3ebaeb3ad99f4c5cde5f62" translate="yes" xml:space="preserve">
          <source>To change the types of two existing columns in one operation:</source>
          <target state="translated">한 번의 작업으로 두 개의 기존 열 유형을 변경하려면</target>
        </trans-unit>
        <trans-unit id="049a5efebaaac49c898beb6813a00487d2d41002" translate="yes" xml:space="preserve">
          <source>To check the total size of the data contained in &lt;code&gt;measurement&lt;/code&gt; table described in &lt;a href=&quot;ddl-partitioning#DDL-PARTITIONING-DECLARATIVE-EXAMPLE&quot;&gt;Section 5.11.2.1&lt;/a&gt;, one could use the following query:</source>
          <target state="translated">&lt;a href=&quot;ddl-partitioning#DDL-PARTITIONING-DECLARATIVE-EXAMPLE&quot;&gt;5.11.2.1 절에&lt;/a&gt; 설명 된 &lt;code&gt;measurement&lt;/code&gt; 테이블에 포함 된 데이터의 전체 크기를 확인 하기 위해 다음 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a3decf48834644b5c1569c04cccf33236b32d5a" translate="yes" xml:space="preserve">
          <source>To check whether a value is or is not null, use the predicates:</source>
          <target state="translated">값이 널인지 여부를 확인하려면 술어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6ba3615ed77c16bfcd03c7a57a0a7efbe26986a" translate="yes" xml:space="preserve">
          <source>To clean a single table &lt;code&gt;foo&lt;/code&gt; in a database named &lt;code&gt;xyzzy&lt;/code&gt;, and analyze a single column &lt;code&gt;bar&lt;/code&gt; of the table for the optimizer:</source>
          <target state="translated">&lt;code&gt;xyzzy&lt;/code&gt; 라는 데이터베이스에서 단일 테이블 &lt;code&gt;foo&lt;/code&gt; 를 정리 하고 최적화 프로그램에 대한 테이블 의 단일 열 &lt;code&gt;bar&lt;/code&gt; 를 분석 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="03d008a394089139c42aa272f11af61d21af849c" translate="yes" xml:space="preserve">
          <source>To clean a single table &lt;code&gt;onek&lt;/code&gt;, analyze it for the optimizer and print a detailed vacuum activity report:</source>
          <target state="translated">단일 테이블 &lt;code&gt;onek&lt;/code&gt; 를 청소하려면 옵티 마이저를 분석하고 자세한 진공 활동 보고서를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="0223c4eeb9d8178bcdc05a32e433b2a9dbbbd79a" translate="yes" xml:space="preserve">
          <source>To clean and analyze for the optimizer a database named &lt;code&gt;bigdb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;bigdb&lt;/code&gt; 라는 데이터베이스를 최적화 프로그램에 대해 정리하고 분석하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ebd0dab8ff9260010700d5784ae60c43d956fbb" translate="yes" xml:space="preserve">
          <source>To clean the database &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">데이터베이스 &lt;code&gt;test&lt;/code&gt; 를 정리하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="d36a88d4536d1564194241cddefae5029a567721" translate="yes" xml:space="preserve">
          <source>To cluster a single table &lt;code&gt;foo&lt;/code&gt; in a database named &lt;code&gt;xyzzy&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;xyzzy&lt;/code&gt; 라는 데이터베이스에서 단일 테이블 &lt;code&gt;foo&lt;/code&gt; 를 클러스터링하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cab04f1bb9371b8d93c069fac5fea1fc0c16730c" translate="yes" xml:space="preserve">
          <source>To cluster the database &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">데이터베이스 &lt;code&gt;test&lt;/code&gt; 를 클러스터링하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="8068924d6aaad9348ff2cc80e45e87a55218c74c" translate="yes" xml:space="preserve">
          <source>To combine multiple indexes, the system scans each needed index and prepares a &lt;em&gt;bitmap&lt;/em&gt; in memory giving the locations of table rows that are reported as matching that index's conditions. The bitmaps are then ANDed and ORed together as needed by the query. Finally, the actual table rows are visited and returned. The table rows are visited in physical order, because that is how the bitmap is laid out; this means that any ordering of the original indexes is lost, and so a separate sort step will be needed if the query has an &lt;code&gt;ORDER BY&lt;/code&gt; clause. For this reason, and because each additional index scan adds extra time, the planner will sometimes choose to use a simple index scan even though additional indexes are available that could have been used as well.</source>
          <target state="translated">여러 인덱스를 결합하기 위해 시스템은 필요한 각 인덱스를 스캔하고 해당 인덱스 조건과 일치하는 것으로보고되는 테이블 행의 위치를 ​​제공 하는 &lt;em&gt;비트 맵&lt;/em&gt; 을 메모리에 준비합니다 . 그런 다음 쿼리에서 필요에 따라 비트 맵을 AND로 AND OR합니다. 마지막으로 실제 테이블 행을 방문하여 리턴합니다. 비트 맵이 배치되는 방식이므로 테이블 행이 실제 순서대로 방문됩니다. 즉, 원래 인덱스의 순서가 손실되므로 쿼리에 &lt;code&gt;ORDER BY&lt;/code&gt; 절이 있으면 별도의 정렬 단계가 필요합니다 . 이러한 이유로 그리고 추가 인덱스 스캔마다 시간이 더 걸리기 때문에 플래너는 때때로 사용 가능한 추가 인덱스를 사용할 수있는 경우에도 간단한 인덱스 스캔을 사용하도록 선택합니다.</target>
        </trans-unit>
        <trans-unit id="00ca92af0e53c4377a2cb5350ec6b01f99364b8e" translate="yes" xml:space="preserve">
          <source>To commit a prepared transaction, you must be either the same user that executed the transaction originally, or a superuser. But you do not have to be in the same session that executed the transaction.</source>
          <target state="translated">준비된 트랜잭션을 커밋하려면 원래 트랜잭션을 실행 한 동일한 사용자이거나 수퍼 유저 여야합니다. 그러나 트랜잭션을 실행 한 동일한 세션에 있지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="6c2c489f97856e1040807fb30de91b1ff577ac3f" translate="yes" xml:space="preserve">
          <source>To commit the current transaction and make all changes permanent:</source>
          <target state="translated">현재 트랜잭션을 커밋하고 모든 변경 사항을 영구적으로 만들려면 :</target>
        </trans-unit>
        <trans-unit id="8722e0a102936bb4e4c8a1d09a997df3bf85a004" translate="yes" xml:space="preserve">
          <source>To complicate matters, some jurisdictions have used the same timezone abbreviation to mean different UTC offsets at different times; for example, in Moscow &lt;code&gt;MSK&lt;/code&gt; has meant UTC+3 in some years and UTC+4 in others. PostgreSQL interprets such abbreviations according to whatever they meant (or had most recently meant) on the specified date; but, as with the &lt;code&gt;EST&lt;/code&gt; example above, this is not necessarily the same as local civil time on that date.</source>
          <target state="translated">문제를 복잡하게하기 위해 일부 관할 구역에서는 동일한 시간대 약어를 사용하여 다른 시간에 다른 UTC 오프셋을 의미했습니다. 예를 들어, 모스크바에서 &lt;code&gt;MSK&lt;/code&gt; 는 몇 년 동안 UTC + 3을 의미하고 다른 것에서 는 UTC + 4를 의미했습니다. PostgreSQL은 이러한 약어를 지정된 날짜의 의미 또는 가장 최근의 의미에 따라 해석합니다. 그러나 위 의 &lt;code&gt;EST&lt;/code&gt; 예제 와 마찬가지로이 날짜의 현지 시민 시간과 반드시 ​​같을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e97a3d957963e8fcc423128adb2cd06a9c70b0e8" translate="yes" xml:space="preserve">
          <source>To configure a standby server to use pg_archivecleanup, put this into its &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file:</source>
          <target state="translated">pg_archivecleanup을 사용하도록 대기 서버를 구성하려면 다음을 &lt;code&gt;postgresql.conf&lt;/code&gt; 구성 파일에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="15b03f0e740dbe1dcdd3d494e8fe7ef028e5cebd" translate="yes" xml:space="preserve">
          <source>To configure the standby to use this slot, &lt;code&gt;primary_slot_name&lt;/code&gt; should be configured on the standby. Here is a simple example:</source>
          <target state="translated">이 슬롯을 사용하도록 대기를 구성하려면 대기에서 &lt;code&gt;primary_slot_name&lt;/code&gt; 을 구성해야합니다. 다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="6290ec10542845d0ddebfa7746333f2a489b6d0f" translate="yes" xml:space="preserve">
          <source>To connect to a particular database, a user must not only pass the &lt;code&gt;pg_hba.conf&lt;/code&gt; checks, but must have the &lt;code&gt;CONNECT&lt;/code&gt; privilege for the database. If you wish to restrict which users can connect to which databases, it's usually easier to control this by granting/revoking &lt;code&gt;CONNECT&lt;/code&gt; privilege than to put the rules in &lt;code&gt;pg_hba.conf&lt;/code&gt; entries.</source>
          <target state="translated">특정 데이터베이스에 연결하려면 사용자는 &lt;code&gt;pg_hba.conf&lt;/code&gt; 검사를 통과해야 할뿐만 아니라 데이터베이스에 대한 &lt;code&gt;CONNECT&lt;/code&gt; 권한이 있어야합니다. 어떤 사용자가 어떤 데이터베이스에 연결할 수 있는지 제한하려면 일반적으로 &lt;code&gt;pg_hba.conf&lt;/code&gt; 항목에 규칙을 두는 것보다 &lt;code&gt;CONNECT&lt;/code&gt; 권한 을 부여 / 취소하여이를 제어하는 ​​것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="1ebc848d3357434419fff443659c293fb158987a" translate="yes" xml:space="preserve">
          <source>To connect to this server using psql, specify this port with the -p option:</source>
          <target state="translated">psql을 사용하여이 서버에 연결하려면 -p 옵션과 함께이 포트를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="301edb0319104a266e632783cd094629d966049a" translate="yes" xml:space="preserve">
          <source>To convert a JSON value to the SQL type of an output column, the following rules are applied in sequence:</source>
          <target state="translated">JSON 값을 출력 열의 SQL 유형으로 변환하기 위해 다음 규칙이 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4410b5e31b45b8b22ca1d9903ef6943e81eb2ac0" translate="yes" xml:space="preserve">
          <source>To convert a column to a different data type, use a command like:</source>
          <target state="translated">열을 다른 데이터 형식으로 변환하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="54f9ec7b4c57109e2602a2ff40352802cb0d1e0f" translate="yes" xml:space="preserve">
          <source>To convert a traditional 48 bit MAC address in EUI-48 format to modified EUI-64 format to be included as the host portion of an IPv6 address, use &lt;code&gt;macaddr8_set7bit&lt;/code&gt; as shown:</source>
          <target state="translated">EUI-48 형식의 기존 48 비트 MAC 주소를 수정 된 EUI-64 형식으로 변환하여 IPv6 주소의 호스트 부분으로 포함하려면 &lt;code&gt;macaddr8_set7bit&lt;/code&gt; 과 같이 macaddr8_set7bit 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fef5624a1d1e08c22d86e5fbc6f1e0129dd604df" translate="yes" xml:space="preserve">
          <source>To copy a table completely, the short form using the &lt;code&gt;TABLE&lt;/code&gt; command can also be used:</source>
          <target state="translated">테이블을 완전히 복사하기 위해 &lt;code&gt;TABLE&lt;/code&gt; 명령을 사용하는 간단한 형식을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e75e99b9c752d67b15f22015a111ca5f58da271e" translate="yes" xml:space="preserve">
          <source>To copy data from a file into the &lt;code&gt;country&lt;/code&gt; table:</source>
          <target state="translated">파일에서 &lt;code&gt;country&lt;/code&gt; 테이블 로 데이터를 복사하려면 다음을 수행 하십시오.</target>
        </trans-unit>
        <trans-unit id="a1392415e4938e657b0920236ebe7bdc0d105f5e" translate="yes" xml:space="preserve">
          <source>To copy into a compressed file, you can pipe the output through an external compression program:</source>
          <target state="translated">압축 파일로 복사하기 위해 외부 압축 프로그램을 통해 출력을 파이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0e96672f8aca7577ebe018bf4d51d014d00c0c" translate="yes" xml:space="preserve">
          <source>To copy into a file just the countries whose names start with 'A':</source>
          <target state="translated">이름이 'A'로 시작하는 국가 만 파일로 복사하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c81ceaa4f7c9941558ec032310e1d81872cc8cae" translate="yes" xml:space="preserve">
          <source>To create a B-Tree index with deduplication disabled:</source>
          <target state="translated">중복 제거를 비활성화 한 상태에서 B- 트리 인덱스를 생성하려면 :</target>
        </trans-unit>
        <trans-unit id="9938c28d5e04efe3b2ed6d4b9e038b44b264feb1" translate="yes" xml:space="preserve">
          <source>To create a GIN index with fast updates disabled:</source>
          <target state="translated">빠른 업데이트가 비활성화 된 GIN 인덱스를 만들려면</target>
        </trans-unit>
        <trans-unit id="70b56f88ded64f4ee2c9afba4799fc0371abf06b" translate="yes" xml:space="preserve">
          <source>To create a GiST index on a point attribute so that we can efficiently use box operators on the result of the conversion function:</source>
          <target state="translated">변환 함수의 결과에서 상자 연산자를 효율적으로 사용할 수 있도록 점 속성에 GiST 색인을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b3aea2a10769e18a2aeada094ee0d0b98f9fa398" translate="yes" xml:space="preserve">
          <source>To create a backup of a local database where the tablespace in &lt;code&gt;/opt/ts&lt;/code&gt; is relocated to &lt;code&gt;./backup/ts&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/opt/ts&lt;/code&gt; 의 테이블 스페이스 가 &lt;code&gt;./backup/ts&lt;/code&gt; 로 재배치 되는 로컬 데이터베이스의 백업을 작성하려면 다음 을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="6459c1471fe7288d512cf1eb3beb6d53897abf59" translate="yes" xml:space="preserve">
          <source>To create a backup of a single-tablespace local database and compress this with bzip2:</source>
          <target state="translated">단일 테이블 스페이스 로컬 데이터베이스의 백업을 작성하고 bzip2로 압축하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3c249aecad18bf81babc126ff3cabfeb813ea5fd" translate="yes" xml:space="preserve">
          <source>To create a backup of the local server with one compressed tar file for each tablespace, and store it in the directory &lt;code&gt;backup&lt;/code&gt;, showing a progress report while running:</source>
          <target state="translated">각 테이블 스페이스에 대해 하나의 압축 된 tar 파일을 사용하여 로컬 서버의 백업을 작성하고이를 디렉토리 &lt;code&gt;backup&lt;/code&gt; 에 저장하여 실행 중에 진행률 보고서를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="4512427b0bf3312fa6a876ae68c686a59bfc1e1a" translate="yes" xml:space="preserve">
          <source>To create a base backup of the server at &lt;code&gt;mydbserver&lt;/code&gt; and store it in the local directory &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mydbserver&lt;/code&gt; 에서 서버의 기본 백업을 작성 하고 로컬 디렉토리 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 에 저장하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="eb53f87e549c2e3131e5b7c882b46686f7575ac8" translate="yes" xml:space="preserve">
          <source>To create a base backup of the server at &lt;code&gt;mydbserver&lt;/code&gt; and verify the integrity of the backup:</source>
          <target state="translated">&lt;code&gt;mydbserver&lt;/code&gt; 에서 서버의 기본 백업을 생성하고 백업의 무결성을 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="bb0df0e57b686171379ea519fb078ba09100debf" translate="yes" xml:space="preserve">
          <source>To create a base backup of the server at &lt;code&gt;mydbserver&lt;/code&gt;, move the manifest somewhere outside the backup directory, and verify the backup:</source>
          <target state="translated">&lt;code&gt;mydbserver&lt;/code&gt; 에서 서버의 기본 백업을 생성하려면 매니페스트를 백업 디렉토리 외부로 이동하고 백업을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1dd9c8299d9f5843b300e409173ef3b9254191b7" translate="yes" xml:space="preserve">
          <source>To create a collation from an existing collation:</source>
          <target state="translated">기존 데이터 정렬에서 데이터 정렬을 만들려면</target>
        </trans-unit>
        <trans-unit id="3c3ab8737c7f5d3cbae3bfe2663adcc61cd53c0e" translate="yes" xml:space="preserve">
          <source>To create a collation from the operating system locale &lt;code&gt;fr_FR.utf8&lt;/code&gt; (assuming the current database encoding is &lt;code&gt;UTF8&lt;/code&gt;):</source>
          <target state="translated">운영 체제 로케일 &lt;code&gt;fr_FR.utf8&lt;/code&gt; 에서 데이터 정렬을 작성하려면 (현재 데이터베이스 인코딩이 &lt;code&gt;UTF8&lt;/code&gt; 이라고 가정 ) :</target>
        </trans-unit>
        <trans-unit id="c6f995f6b55b09e4192f2da33dedebef3c0f9550" translate="yes" xml:space="preserve">
          <source>To create a collation using the ICU provider using German phone book sort order:</source>
          <target state="translated">독일어 전화 번호부 정렬 순서를 사용하여 ICU 공급자를 사용하여 데이터 정렬을 만들려면</target>
        </trans-unit>
        <trans-unit id="37400e312eb41c20789506b2aff48f51d113fb06" translate="yes" xml:space="preserve">
          <source>To create a conversion from encoding &lt;code&gt;UTF8&lt;/code&gt; to &lt;code&gt;LATIN1&lt;/code&gt; using &lt;code&gt;myfunc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;myfunc&lt;/code&gt; 를 사용하여 &lt;code&gt;UTF8&lt;/code&gt; 인코딩 에서 &lt;code&gt;LATIN1&lt;/code&gt; 로 변환을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="89d026413429cbe22fa30a37ce5992d4ad7a1deb" translate="yes" xml:space="preserve">
          <source>To create a database &lt;code&gt;music2&lt;/code&gt; with a different locale and a different character set encoding:</source>
          <target state="translated">다른 로케일과 다른 문자 세트 인코딩 으로 데이터베이스 &lt;code&gt;music2&lt;/code&gt; 를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ddf790c056f93f33fa0d0613c7b46f81031cf7b9" translate="yes" xml:space="preserve">
          <source>To create a database &lt;code&gt;music&lt;/code&gt; with a different locale:</source>
          <target state="translated">다른 로케일 로 데이터베이스 &lt;code&gt;music&lt;/code&gt; 을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="77c7a58e702554d6a54a59128c311148147ebec1" translate="yes" xml:space="preserve">
          <source>To create a database &lt;code&gt;sales&lt;/code&gt; owned by user &lt;code&gt;salesapp&lt;/code&gt; with a default tablespace of &lt;code&gt;salesspace&lt;/code&gt;:</source>
          <target state="translated">기본 테이블 스페이스 &lt;code&gt;salesapp&lt;/code&gt; 로 사용자 salesapp 가 소유 한 데이터베이스 &lt;code&gt;sales&lt;/code&gt; 를 작성하려면 다음 을 &lt;code&gt;salesspace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3228293205178b589ad42b9758471b3eb9d23e95" translate="yes" xml:space="preserve">
          <source>To create a database by copying &lt;code&gt;template0&lt;/code&gt;, use:</source>
          <target state="translated">&lt;code&gt;template0&lt;/code&gt; 을 복사하여 데이터베이스를 작성하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="98c1e5ccbfb7a38c808d162facd87b5b3f873eb5" translate="yes" xml:space="preserve">
          <source>To create a database, you must be a superuser or have the special &lt;code&gt;CREATEDB&lt;/code&gt; privilege. See &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">데이터베이스를 만들려면 수퍼 유저이거나 특별한 &lt;code&gt;CREATEDB&lt;/code&gt; 권한 이 있어야합니다 . &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d728f64aca75037086b1f8f773c55b39dbc706f2" translate="yes" xml:space="preserve">
          <source>To create a generated column, use the &lt;code&gt;GENERATED ALWAYS AS&lt;/code&gt; clause in &lt;code&gt;CREATE TABLE&lt;/code&gt;, for example:</source>
          <target state="translated">생성 된 열을 작성하려면 다음 과 같이 &lt;code&gt;CREATE TABLE&lt;/code&gt; 에서 &lt;code&gt;GENERATED ALWAYS AS&lt;/code&gt; 절을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe6d46bed46bf76a565070a6f714a6f85543fb8b" translate="yes" xml:space="preserve">
          <source>To create a new database, in this example named &lt;code&gt;mydb&lt;/code&gt;, you use the following command:</source>
          <target state="translated">&lt;code&gt;mydb&lt;/code&gt; 라는이 예제에서 새 데이터베이스를 작성하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="944120cb7dfcbcf00146c8068b87b4b7681b58f2" translate="yes" xml:space="preserve">
          <source>To create a new database:</source>
          <target state="translated">새 데이터베이스를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="164615fbd4052417b63e19f9e6150d9fa43cadd5" translate="yes" xml:space="preserve">
          <source>To create a new row, use the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command. The command requires the table name and column values. For example, consider the products table from &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt;:</source>
          <target state="translated">새 행을 작성하려면 &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; 명령을 사용하십시오 . 이 명령에는 테이블 이름과 열 값이 필요합니다. 예를 들어, &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;5 장의&lt;/a&gt; 제품 표를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b0381516c88992d8b9c8e464528fb80a6968228" translate="yes" xml:space="preserve">
          <source>To create a new row, use the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command. The command requires the table name and column values. For example, consider the products table from &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;Chapter 5&lt;/a&gt;:</source>
          <target state="translated">새 행을 작성하려면 &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; 명령을 사용하십시오 . 이 명령에는 테이블 이름과 열 값이 필요합니다. 예를 들어 &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;5 장의&lt;/a&gt; 제품 테이블을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e4a9625799af4fa2c817e41733ba1818843f4bc" translate="yes" xml:space="preserve">
          <source>To create a nondeterministic collation, specify the property &lt;code&gt;deterministic = false&lt;/code&gt; to &lt;code&gt;CREATE COLLATION&lt;/code&gt;, for example:</source>
          <target state="translated">비 결정적 데이터 정렬을 작성하려면 &lt;code&gt;deterministic = false&lt;/code&gt; 특성 을 &lt;code&gt;CREATE COLLATION&lt;/code&gt; 에 지정하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bece4672c16769d53407f8ac1fce152578224a4" translate="yes" xml:space="preserve">
          <source>To create a partial index that suits our example, use a command such as this:</source>
          <target state="translated">예제에 적합한 부분 인덱스를 만들려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="94c4a05ba1b161a82cb7f1cede5c13fa27ff0d31" translate="yes" xml:space="preserve">
          <source>To create a publication, the invoking user must have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the current database. (Of course, superusers bypass this check.)</source>
          <target state="translated">발행을 작성하려면 호출 사용자 에게 현재 데이터베이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 특권 이 있어야 합니다. 물론 슈퍼 유저는이 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="4e19fe1acbe2c89906009c9ae7f5b9b8e50b0116" translate="yes" xml:space="preserve">
          <source>To create a publication, the user must have the &lt;code&gt;CREATE&lt;/code&gt; privilege in the database.</source>
          <target state="translated">게시를 만들려면 사용자 에게 데이터베이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="82818a82b8737a5ccba600431c5567222d5f7217" translate="yes" xml:space="preserve">
          <source>To create a schema, the invoking user must have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the current database. (Of course, superusers bypass this check.)</source>
          <target state="translated">스키마를 작성하려면 호출 사용자 에게 현재 데이터베이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 이 있어야 합니다. 물론 슈퍼 유저는이 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5e16e57c628302c59115654ccf739b24bc40990c" translate="yes" xml:space="preserve">
          <source>To create a schema, use the &lt;a href=&quot;sql-createschema&quot;&gt;CREATE SCHEMA&lt;/a&gt; command. Give the schema a name of your choice. For example:</source>
          <target state="translated">스키마를 작성하려면 &lt;a href=&quot;sql-createschema&quot;&gt;CREATE SCHEMA&lt;/a&gt; 명령을 사용하십시오 . 스키마에 원하는 이름을 지정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c076c41c550c9d20ce9da7cb634e90253f684fe" translate="yes" xml:space="preserve">
          <source>To create a server certificate whose identity can be validated by clients, first create a certificate signing request (CSR) and a public/private key file:</source>
          <target state="translated">클라이언트가 ID를 확인할 수있는 서버 인증서를 만들려면 먼저 인증서 서명 요청 (CSR) 및 공개 / 개인 키 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7b7bd094f458984cd99ccbc500517389e47e3d27" translate="yes" xml:space="preserve">
          <source>To create a simple self-signed certificate for the server, valid for 365 days, use the following OpenSSL command, replacing &lt;code&gt;dbhost.yourdomain.com&lt;/code&gt; with the server's host name:</source>
          <target state="translated">365 일 동안 유효한 서버에 대한 자체 서명 된 간단한 인증서를 만들려면 &lt;code&gt;dbhost.yourdomain.com&lt;/code&gt; 을 서버의 호스트 이름으로 바꾸고 다음 OpenSSL 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdc276e86df85d79d1975e1aab1405440c49a4a5" translate="yes" xml:space="preserve">
          <source>To create a subscription, the user must be a superuser.</source>
          <target state="translated">구독을 만들려면 사용자가 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f62ecd7fc3b3c7cddbee7892269e1b205e56b9f5" translate="yes" xml:space="preserve">
          <source>To create a table alias, write</source>
          <target state="translated">테이블 별칭을 만들려면</target>
        </trans-unit>
        <trans-unit id="a36b6ab5a3c0f86da9166604c99b7556b78e53d3" translate="yes" xml:space="preserve">
          <source>To create a table, you use the aptly named &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; command. In this command you specify at least a name for the new table, the names of the columns and the data type of each column. For example:</source>
          <target state="translated">테이블을 작성하려면 적절하게 이름 지정된 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 명령 을 사용하십시오 . 이 명령에서는 최소한 새 테이블 이름, 열 이름 및 각 열의 데이터 유형을 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef7e4c5658e9c01ed12be2b853f9a21a21c0a775" translate="yes" xml:space="preserve">
          <source>To create a tablespace &lt;code&gt;dbspace&lt;/code&gt; at file system location &lt;code&gt;/data/dbs&lt;/code&gt;, first create the directory using operating system facilities and set the correct ownership:</source>
          <target state="translated">파일 시스템 위치 &lt;code&gt;/data/dbs&lt;/code&gt; 에서 테이블 스페이스 &lt;code&gt;dbspace&lt;/code&gt; 를 작성하려면 먼저 운영 체제 기능을 사용하여 디렉토리를 작성하고 올바른 소유권을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c90745ea9680b02fd1264be6b5adf41862e7bb1b" translate="yes" xml:space="preserve">
          <source>To create a tablespace owned by a different database user, use a command like this:</source>
          <target state="translated">다른 데이터베이스 사용자가 소유 한 테이블 스페이스를 작성하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="59a1849fe63b24cb0890dd29697e64e3955e0989" translate="yes" xml:space="preserve">
          <source>To create a transform for type &lt;code&gt;hstore&lt;/code&gt; and language &lt;code&gt;plpythonu&lt;/code&gt;, first set up the type and the language:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 및 언어 &lt;code&gt;plpythonu&lt;/code&gt; 유형에 대한 변환을 작성하려면 먼저 유형 및 언어를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="82e9f78b5e0935384e76288e143c8285785f8f57" translate="yes" xml:space="preserve">
          <source>To create a trigger on a table, the user must have the &lt;code&gt;TRIGGER&lt;/code&gt; privilege on the table. The user must also have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the trigger function.</source>
          <target state="translated">테이블에서 트리거를 작성하려면 사용자에게 테이블에 대한 &lt;code&gt;TRIGGER&lt;/code&gt; 특권이 있어야합니다. 사용자는 트리거 기능에 대한 &lt;code&gt;EXECUTE&lt;/code&gt; 특권 도 가지고 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ad55cc89474d269f7ab84efbc2f63c3cf2a776a" translate="yes" xml:space="preserve">
          <source>To create a unique B-tree index on the column &lt;code&gt;title&lt;/code&gt; in the table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">컬럼의 고유 B-tree 인덱스 만들려면 &lt;code&gt;title&lt;/code&gt; 테이블에서 &lt;code&gt;films&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5ac8384bf603c41e77fc0497788f00754dc4f97d" translate="yes" xml:space="preserve">
          <source>To create a unique B-tree index on the column &lt;code&gt;title&lt;/code&gt; with included columns &lt;code&gt;director&lt;/code&gt; and &lt;code&gt;rating&lt;/code&gt; in the table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">컬럼의 고유 B-tree 인덱스 만들려면 &lt;code&gt;title&lt;/code&gt; 에 포함 열을 가진 &lt;code&gt;director&lt;/code&gt; 및 &lt;code&gt;rating&lt;/code&gt; 테이블에서 &lt;code&gt;films&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2771d4c58e957e52b458e2099556c1af64484a04" translate="yes" xml:space="preserve">
          <source>To create a user &lt;code&gt;joe&lt;/code&gt; on the default database server with prompting for some additional attributes:</source>
          <target state="translated">추가 속성을 요구하는 프롬프트가있는 기본 데이터베이스 서버에서 사용자 &lt;code&gt;joe&lt;/code&gt; 를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="237677bf7f6116190203bde2a56293c2c9744671" translate="yes" xml:space="preserve">
          <source>To create a user &lt;code&gt;joe&lt;/code&gt; on the default database server:</source>
          <target state="translated">기본 데이터베이스 서버에서 사용자 &lt;code&gt;joe&lt;/code&gt; 를 작성하려면 다음 을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c626cd27d2903b041a265be4cbc4cd70ada6c091" translate="yes" xml:space="preserve">
          <source>To create an Ispell dictionary perform these steps:</source>
          <target state="translated">Ispell 사전을 만들려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7f623c21177eb05a9c2c99ce655edbf1921ade3c" translate="yes" xml:space="preserve">
          <source>To create an assignment cast from type &lt;code&gt;bigint&lt;/code&gt; to type &lt;code&gt;int4&lt;/code&gt; using the function &lt;code&gt;int4(bigint)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;int4(bigint)&lt;/code&gt; 함수를 사용하여 &lt;code&gt;bigint&lt;/code&gt; 유형에서 &lt;code&gt;int4&lt;/code&gt; 유형으로 캐스트를 작성하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e425065f3f16826d8585cb251e9294cec898cef" translate="yes" xml:space="preserve">
          <source>To create an index on the column &lt;code&gt;code&lt;/code&gt; in the table &lt;code&gt;films&lt;/code&gt; and have the index reside in the tablespace &lt;code&gt;indexspace&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;films&lt;/code&gt; 의 열 &lt;code&gt;code&lt;/code&gt; 에 대한 색인을 작성하고 색인을 테이블 &lt;code&gt;indexspace&lt;/code&gt; 색인 공간에 상주 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="51282a9a6eaf7d1d2c775ba39707e66f5cc8d2ab" translate="yes" xml:space="preserve">
          <source>To create an index on the expression &lt;code&gt;lower(title)&lt;/code&gt;, allowing efficient case-insensitive searches:</source>
          <target state="translated">&lt;code&gt;lower(title)&lt;/code&gt; 표현식에서 색인을 작성하여 대소 문자를 구분하지 않는 효율적인 검색을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="05080049ba907f8e2ebb4f8e83189ac4df6eae27" translate="yes" xml:space="preserve">
          <source>To create an index with non-default collation:</source>
          <target state="translated">기본이 아닌 데이터 정렬을 사용하여 인덱스를 만들려면</target>
        </trans-unit>
        <trans-unit id="ae5e619c87b8495a3c775c2e057cf9cc24726284" translate="yes" xml:space="preserve">
          <source>To create an index with non-default fill factor:</source>
          <target state="translated">기본 채우기 비율이 아닌 인덱스를 만들려면</target>
        </trans-unit>
        <trans-unit id="aa7ca2ae5a8ba1b87ad938de2374091c155e63c3" translate="yes" xml:space="preserve">
          <source>To create an index with non-default sort ordering of nulls:</source>
          <target state="translated">기본이 아닌 정렬 순서가 null 인 인덱스를 만들려면</target>
        </trans-unit>
        <trans-unit id="3bfa732afcdfdf06839ce25d42124ae300659f8e" translate="yes" xml:space="preserve">
          <source>To create an index without locking out writes to the table:</source>
          <target state="translated">테이블에 대한 쓰기를 잠그지 않고 인덱스를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5c56e64ec1ccb1bef0256a294be67b1b84c00ee6" translate="yes" xml:space="preserve">
          <source>To create binary I/O functions for an existing base type:</source>
          <target state="translated">기존 기본 유형에 대한 이진 I / O 함수를 생성하려면 :</target>
        </trans-unit>
        <trans-unit id="d53339e9d8aae8b8d5f4abfe2e3853a4dcdbc60c" translate="yes" xml:space="preserve">
          <source>To create functions in a procedural language, a user must have the &lt;code&gt;USAGE&lt;/code&gt; privilege for the language. By default, &lt;code&gt;USAGE&lt;/code&gt; is granted to &lt;code&gt;PUBLIC&lt;/code&gt; (i.e., everyone) for trusted languages. This can be revoked if desired.</source>
          <target state="translated">절차 언어로 함수를 작성하려면 사용자 에게 해당 언어에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권이 있어야합니다. 기본적으로 &lt;code&gt;USAGE&lt;/code&gt; 는 신뢰할 수있는 언어에 대해 &lt;code&gt;PUBLIC&lt;/code&gt; (모든 사람) 에게 부여 됩니다. 원하는 경우 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="128acbfc6605f02795881a6d5e5df2f768c7238b" translate="yes" xml:space="preserve">
          <source>To create or access objects in a schema, write a &lt;em&gt;qualified name&lt;/em&gt; consisting of the schema name and table name separated by a dot:</source>
          <target state="translated">스키마에서 오브젝트를 작성하거나 액세스하려면 스키마 이름과 테이블 이름으로 구성된 &lt;em&gt;규정 된 이름을&lt;/em&gt; 점으로 구분하여 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="319b11f872179f690e1c636d54351f3fcf40ca66" translate="yes" xml:space="preserve">
          <source>To create the database &lt;code&gt;demo&lt;/code&gt; using the default database server:</source>
          <target state="translated">기본 데이터베이스 서버 를 사용하여 데이터베이스 &lt;code&gt;demo&lt;/code&gt; 를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e89ca2b57992709dac0e0f7f21762ad921861100" translate="yes" xml:space="preserve">
          <source>To create the database &lt;code&gt;demo&lt;/code&gt; using the server on host &lt;code&gt;eden&lt;/code&gt;, port 5000, using the &lt;code&gt;template0&lt;/code&gt; template database, here is the command-line command and the underlying SQL command:</source>
          <target state="translated">&lt;code&gt;template0&lt;/code&gt; 템플리트 데이터베이스를 사용하여 호스트 &lt;code&gt;eden&lt;/code&gt; , 포트 5000 의 서버를 사용하여 데이터베이스 &lt;code&gt;demo&lt;/code&gt; 를 작성하려면 다음은 명령 행 명령 및 기본 SQL 명령입니다.</target>
        </trans-unit>
        <trans-unit id="7ed18302d2f5c67326d42076e0c535c3180f4594" translate="yes" xml:space="preserve">
          <source>To create the same user &lt;code&gt;joe&lt;/code&gt; using the server on host &lt;code&gt;eden&lt;/code&gt;, port 5000, with attributes explicitly specified, taking a look at the underlying command:</source>
          <target state="translated">속성이 명시 적으로 지정된 호스트 &lt;code&gt;eden&lt;/code&gt; , 포트 5000 의 서버를 사용하여 동일한 사용자 &lt;code&gt;joe&lt;/code&gt; 를 작성하려면 기본 명령을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="04dfb9f7e981bc2d21a15704ba7750b7d32766f0" translate="yes" xml:space="preserve">
          <source>To create the user &lt;code&gt;joe&lt;/code&gt; as a superuser, and assign a password immediately:</source>
          <target state="translated">사용자 &lt;code&gt;joe&lt;/code&gt; 를 수퍼 유저로 작성하고 즉시 비밀번호를 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="babc49c12d3facd66590239c46cb7e620e0bfd11" translate="yes" xml:space="preserve">
          <source>To deal with default (anonymous) namespaces, do something like this:</source>
          <target state="translated">기본 (익명) 네임 스페이스를 처리하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="344821e66e6da00575ec49ea28e499cd7bece96a" translate="yes" xml:space="preserve">
          <source>To deal with text in different Unicode normalization forms, it is also an option to use the functions/expressions &lt;code&gt;normalize&lt;/code&gt; and &lt;code&gt;is normalized&lt;/code&gt; to preprocess or check the strings, instead of using nondeterministic collations. There are different trade-offs for each approach.</source>
          <target state="translated">다른 유니 코드 정규화 형태의 텍스트를 다루는, 그것은 또한 기능을 사용하는 옵션입니다 / 표현은 &lt;code&gt;normalize&lt;/code&gt; 및 &lt;code&gt;is normalized&lt;/code&gt; 전처리 또는 대신에 결정적 데이터 정렬을 사용하는 문자열을 확인합니다. 각 접근 방식에는 서로 다른 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd9e4512d47fc711a9256823ffecbf1d45d4bd71" translate="yes" xml:space="preserve">
          <source>To deal with the case where &lt;code&gt;pg_control&lt;/code&gt; is corrupt, we should support the possibility of scanning existing log segments in reverse order &amp;mdash; newest to oldest &amp;mdash; in order to find the latest checkpoint. This has not been implemented yet. &lt;code&gt;pg_control&lt;/code&gt; is small enough (less than one disk page) that it is not subject to partial-write problems, and as of this writing there have been no reports of database failures due solely to the inability to read &lt;code&gt;pg_control&lt;/code&gt; itself. So while it is theoretically a weak spot, &lt;code&gt;pg_control&lt;/code&gt; does not seem to be a problem in practice.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; 이 손상된 경우를 처리 하기 위해 최신 검사 점을 찾기 위해 기존 로그 세그먼트를 최신 순서에서 가장 오래된 순서로 스캔 할 수 있도록 지원해야합니다. 아직 구현되지 않았습니다. &lt;code&gt;pg_control&lt;/code&gt; 은 하나의 디스크 페이지보다 작기 때문에 부분 쓰기 문제가 발생하지 않으며이 글을 쓰는 시점에서 &lt;code&gt;pg_control&lt;/code&gt; 자체 를 읽을 수 없기 때문에 데이터베이스 오류에 대한보고는 없었 습니다. 따라서 이론적으로 약점이지만 &lt;code&gt;pg_control&lt;/code&gt; 은 실제로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39c5bf42838c1568d98d59b59281df581edfb974" translate="yes" xml:space="preserve">
          <source>To deal with this problem, PostgreSQL has a notion of &lt;em&gt;timelines&lt;/em&gt;. Whenever an archive recovery completes, a new timeline is created to identify the series of WAL records generated after that recovery. The timeline ID number is part of WAL segment file names so a new timeline does not overwrite the WAL data generated by previous timelines. It is in fact possible to archive many different timelines. While that might seem like a useless feature, it's often a lifesaver. Consider the situation where you aren't quite sure what point-in-time to recover to, and so have to do several point-in-time recoveries by trial and error until you find the best place to branch off from the old history. Without timelines this process would soon generate an unmanageable mess. With timelines, you can recover to &lt;em&gt;any&lt;/em&gt; prior state, including states in timeline branches that you abandoned earlier.</source>
          <target state="translated">이 문제를 해결하기 위해 PostgreSQL에는 &lt;em&gt;타임 라인&lt;/em&gt; 이라는 개념이 있습니다. 아카이브 복구가 완료 될 때마다 해당 복구 후 생성 된 일련의 WAL 레코드를 식별하기 위해 새 타임 라인이 생성됩니다. 타임 라인 ID 번호는 WAL 세그먼트 파일 이름의 일부이므로 새 타임 라인은 이전 타임 라인에서 생성 된 WAL 데이터를 덮어 쓰지 않습니다. 실제로 다양한 타임 라인을 보관할 수 있습니다. 그것은 쓸모없는 기능처럼 보이지만 종종 생명의 은인입니다. 어떤 시점을 복구 할 지 확실하지 않은 상황을 고려하여 이전 기록에서 분기 할 최적의 장소를 찾을 때까지 시행 착오를 통해 여러 시점 복구를 수행해야합니다. 타임 라인이 없으면이 프로세스는 곧 관리 할 수없는 혼란을 야기 할 것입니다. 타임 라인을 사용하면 &lt;em&gt;어느&lt;/em&gt; 시점 &lt;em&gt;으로든&lt;/em&gt; 복구 할 수 있습니다&lt;em&gt;&lt;/em&gt; 이전에 포기한 타임 라인 지점의 주를 포함하여 이전 주.</target>
        </trans-unit>
        <trans-unit id="6d2134c754d1f2a6c1e2e46af69683b00472282e" translate="yes" xml:space="preserve">
          <source>To declare a cursor:</source>
          <target state="translated">커서를 선언하려면</target>
        </trans-unit>
        <trans-unit id="84af5092ab2a247997e10ca0d1bc473758fcfac3" translate="yes" xml:space="preserve">
          <source>To define a new thesaurus dictionary, use the &lt;code&gt;thesaurus&lt;/code&gt; template. For example:</source>
          <target state="translated">새 시소러스 사전을 정의하려면 &lt;code&gt;thesaurus&lt;/code&gt; 템플릿을 사용하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="986fed59a4009699f6854122fd2da5a9d70e789c" translate="yes" xml:space="preserve">
          <source>To define a tablespace, use the &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; command, for example::</source>
          <target state="translated">테이블 스페이스를 정의하려면 다음과 같이 &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3322b8a3e9208d1b84d64763aa4d498d5f5f9b90" translate="yes" xml:space="preserve">
          <source>To define a unique constraint for a group of columns, write it as a table constraint with the column names separated by commas:</source>
          <target state="translated">열 그룹에 대한 고유 제한 조건을 정의하려면 열 이름을 쉼표로 구분하여 테이블 제한 조건으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="13984f59bd22b2e9a275f04bd11f7f208d4ebb22" translate="yes" xml:space="preserve">
          <source>To destroy a group role, use &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;:</source>
          <target state="translated">그룹 역할을 제거하려면 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="64a4ab0af63189bc2f7d08c702da849479dd3444" translate="yes" xml:space="preserve">
          <source>To destroy the database &lt;code&gt;demo&lt;/code&gt; on the default database server:</source>
          <target state="translated">기본 데이터베이스 서버 에서 데이터베이스 &lt;code&gt;demo&lt;/code&gt; 를 제거하려면 다음 을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f03b9dc196b5135db2ccadd50b164e25c9e5713e" translate="yes" xml:space="preserve">
          <source>To destroy the database &lt;code&gt;demo&lt;/code&gt; using the server on host &lt;code&gt;eden&lt;/code&gt;, port 5000, with verification and a peek at the underlying command:</source>
          <target state="translated">기본 명령에서 확인 및 엿보기와 함께 호스트 &lt;code&gt;eden&lt;/code&gt; , 포트 5000 의 서버를 사용하여 데이터베이스 &lt;code&gt;demo&lt;/code&gt; 를 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="df964b5603cc1f31ca3e16e223d4d090f27c044b" translate="yes" xml:space="preserve">
          <source>To destroy two foreign tables, &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;distributors&lt;/code&gt;:</source>
          <target state="translated">두 개의 외국 테이블, &lt;code&gt;films&lt;/code&gt; 및 &lt;code&gt;distributors&lt;/code&gt; 를 파괴하려면 :</target>
        </trans-unit>
        <trans-unit id="5ec6a07ba428b18226f2b5a402d4961467e4a4ea" translate="yes" xml:space="preserve">
          <source>To destroy two statistics objects in different schemas, without failing if they don't exist:</source>
          <target state="translated">존재하지 않는 경우 실패하지 않고 다른 스키마에서 두 개의 통계 오브젝트를 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="81af71b34f901bb661a7e2f097b2993687db9cf7" translate="yes" xml:space="preserve">
          <source>To destroy two tables, &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;distributors&lt;/code&gt;:</source>
          <target state="translated">두 개의 테이블, &lt;code&gt;films&lt;/code&gt; 및 &lt;code&gt;distributors&lt;/code&gt; 를 파괴하려면 :</target>
        </trans-unit>
        <trans-unit id="b252fd181d3818b104f824d7c95b6854e6d1ece7" translate="yes" xml:space="preserve">
          <source>To detach a partition from a partitioned table:</source>
          <target state="translated">파티션 된 테이블에서 파티션을 분리하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0044107f538078feefff2c648b605c188ca65c2e" translate="yes" xml:space="preserve">
          <source>To determine the appropriate binary format for the actual tuple data you should consult the PostgreSQL source, in particular the &lt;code&gt;*send&lt;/code&gt; and &lt;code&gt;*recv&lt;/code&gt; functions for each column's data type (typically these functions are found in the &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; directory of the source distribution).</source>
          <target state="translated">실제 튜플 데이터에 적합한 이진 형식을 결정하려면 PostgreSQL 소스, 특히 각 열의 데이터 유형에 대한 &lt;code&gt;*send&lt;/code&gt; 및 &lt;code&gt;*recv&lt;/code&gt; 함수를 참조하십시오 (일반적으로 이러한 함수는 &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; 디렉토리에 있음) 소스 배포).</target>
        </trans-unit>
        <trans-unit id="e31d0944ab57fd8cade86828e515e67c0b9e0ae8" translate="yes" xml:space="preserve">
          <source>To determine the order of the concatenation, an &lt;code&gt;ORDER BY&lt;/code&gt; clause may be added to the aggregate call as described in &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt;. For example:</source>
          <target state="translated">연결 순서를 결정하기 위해 &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;4.2.7 절에&lt;/a&gt; 설명 된대로 &lt;code&gt;ORDER BY&lt;/code&gt; 절을 집계 호출에 추가 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cc82b13558ed0c2d82c9bba8c5ef830aa7a5ef2" translate="yes" xml:space="preserve">
          <source>To determine the set of existing roles, examine the &lt;code&gt;pg_roles&lt;/code&gt; system catalog, for example</source>
          <target state="translated">기존 역할 세트를 판별하려면 예를 들어 &lt;code&gt;pg_roles&lt;/code&gt; 시스템 카탈로그를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="0b4a4628e23a852dc21a12a35a6273456e5d0a74" translate="yes" xml:space="preserve">
          <source>To determine the set of existing tablespaces, examine the &lt;a href=&quot;catalog-pg-tablespace&quot;&gt;&lt;code&gt;pg_tablespace&lt;/code&gt;&lt;/a&gt; system catalog, for example</source>
          <target state="translated">기존 테이블 스페이스 세트를 판별하려면 예를 들어 &lt;a href=&quot;catalog-pg-tablespace&quot;&gt; &lt;code&gt;pg_tablespace&lt;/code&gt; &lt;/a&gt; 시스템 카탈로그를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="67be13fb22fe0a90f5bd44f329bd0f53bd1ebaeb" translate="yes" xml:space="preserve">
          <source>To determine whether JIT compilation should be used, the total estimated cost of a query (see &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt; and &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;) is used. The estimated cost of the query will be compared with the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;. If the cost is higher, JIT compilation will be performed. Two further decisions are then needed. Firstly, if the estimated cost is more than the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, short functions and operators used in the query will be inlined. Secondly, if the estimated cost is more than the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;, expensive optimizations are applied to improve the generated code. Each of these options increases the JIT compilation overhead, but can reduce query execution time considerably.</source>
          <target state="translated">JIT 컴파일 사용 여부를 결정하기 위해 쿼리의 총 예상 비용 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;제 70 장&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;섹션 19.7.2 참조&lt;/a&gt; )이 사용됩니다. 예상 쿼리 비용은 &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt; 설정과 비교됩니다 . 비용이 더 높으면 JIT 컴파일이 수행됩니다. 그런 다음 두 가지 추가 결정이 필요합니다. 먼저 예상 비용이 &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; 설정보다 큰 경우 쿼리에 사용 된 짧은 함수 및 연산자가 인라인됩니다. 둘째, 예상 비용이 &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; 설정보다 큰 경우생성 된 코드를 개선하기 위해 고가의 최적화가 적용됩니다. 이러한 각 옵션은 JIT 컴파일 오버 헤드를 증가 시키지만 쿼리 실행 시간을 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd4e4acd3d33ab5ee068584350285b4aee8a5f68" translate="yes" xml:space="preserve">
          <source>To determine whether JIT compilation should be used, the total estimated cost of a query (see &lt;a href=&quot;https://www.postgresql.org/docs/13/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt; and &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;) is used. The estimated cost of the query will be compared with the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;. If the cost is higher, JIT compilation will be performed. Two further decisions are then needed. Firstly, if the estimated cost is more than the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, short functions and operators used in the query will be inlined. Secondly, if the estimated cost is more than the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;, expensive optimizations are applied to improve the generated code. Each of these options increases the JIT compilation overhead, but can reduce query execution time considerably.</source>
          <target state="translated">JIT 컴파일을 사용해야하는지 여부를 결정하기 위해 쿼리의 총 예상 비용 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/planner-stats-details.html&quot;&gt;70 장&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;19.7.2 절 참조&lt;/a&gt; )이 사용됩니다. 쿼리의 예상 비용은 &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt; 설정과 비교됩니다 . 비용이 더 높으면 JIT 컴파일이 수행됩니다. 그런 다음 두 가지 추가 결정이 필요합니다. 첫째, 예상 비용이 &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; 설정보다 큰 경우 쿼리에 사용 된 짧은 함수와 연산자가 인라인됩니다. 둘째, 예상 비용이 &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; 설정보다 큰 경우, 생성 된 코드를 개선하기 위해 값 비싼 최적화가 적용됩니다. 이러한 각 옵션은 JIT 컴파일 오버 헤드를 증가 시키지만 쿼리 실행 시간을 상당히 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff46a0305932a1f3445ee6313f1d0daf52062e57" translate="yes" xml:space="preserve">
          <source>To disable automatic setting of &lt;code&gt;search_path&lt;/code&gt; for a function:</source>
          <target state="translated">함수에 대해 &lt;code&gt;search_path&lt;/code&gt; 의 자동 설정을 비활성화하려면</target>
        </trans-unit>
        <trans-unit id="77fbee93c3d08bf4bda4ad9e741740820f97d1d4" translate="yes" xml:space="preserve">
          <source>To disable automatic setting of &lt;code&gt;search_path&lt;/code&gt; for a procedure:</source>
          <target state="translated">프로 시저에 대해 &lt;code&gt;search_path&lt;/code&gt; 의 자동 설정을 사용하지 않으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0b6c666b2d88a7708fb69cf0c000987713ddc46b" translate="yes" xml:space="preserve">
          <source>To disable index scans by default in the database &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">데이터베이스 &lt;code&gt;test&lt;/code&gt; 에서 기본적으로 인덱스 스캔을 사용하지 않으려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="974aa31fe110ad158240e77cb25b55cdcd0f2bb8" translate="yes" xml:space="preserve">
          <source>To drop a column from a table:</source>
          <target state="translated">테이블에서 열을 삭제하려면</target>
        </trans-unit>
        <trans-unit id="7563d557973f5540735b227a3024deefab9a8f9a" translate="yes" xml:space="preserve">
          <source>To drop a role:</source>
          <target state="translated">역할을 삭제하려면</target>
        </trans-unit>
        <trans-unit id="ea1476cc270643bf4c0daffe9f6762c612c57a68" translate="yes" xml:space="preserve">
          <source>To drop a schema if it's empty (all objects in it have been dropped), use:</source>
          <target state="translated">비어있는 스키마를 삭제하려면 (스키마의 모든 객체가 삭제 된 경우) 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="98f5a15e760ae655ecd92960d3186ff62d5da1a9" translate="yes" xml:space="preserve">
          <source>To drop a schema including all contained objects, use:</source>
          <target state="translated">포함 된 모든 객체를 포함하여 스키마를 삭제하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae7da2be12d9a6b52a1340412503a9cc6c084b6b" translate="yes" xml:space="preserve">
          <source>To drop the cast from type &lt;code&gt;text&lt;/code&gt; to type &lt;code&gt;int&lt;/code&gt;:</source>
          <target state="translated">형에서 주조 놓습니다 &lt;code&gt;text&lt;/code&gt; 형식으로 &lt;code&gt;int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5d7ae6be69ee16ba6ee8e2f538a3a91b6b9353cc" translate="yes" xml:space="preserve">
          <source>To drop the collation named &lt;code&gt;german&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;german&lt;/code&gt; 라는 데이터 정렬을 삭제하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="765c47319b0ff7251415602face256f2933e7d23" translate="yes" xml:space="preserve">
          <source>To drop the conversion named &lt;code&gt;myname&lt;/code&gt;:</source>
          <target state="translated">변환 이름을 제거하려면 &lt;code&gt;myname&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5dd444bb871586a10018bf6ff6b8b8550a2c9a8" translate="yes" xml:space="preserve">
          <source>To drop the database and recreate it from the dump:</source>
          <target state="translated">데이터베이스를 삭제하고 덤프에서 다시 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="95246e041a3a0cc9fdc71cc859d3bf606b576692" translate="yes" xml:space="preserve">
          <source>To drop the policy called &lt;code&gt;p1&lt;/code&gt; on the table named &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;my_table&lt;/code&gt; 테이블에서 &lt;code&gt;p1&lt;/code&gt; 이라는 정책을 삭제하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a5bae2f9602e17d08d292952c8a5d8f7ac34691" translate="yes" xml:space="preserve">
          <source>To drop the rewrite rule &lt;code&gt;newrule&lt;/code&gt;:</source>
          <target state="translated">다시 쓰기 규칙 &lt;code&gt;newrule&lt;/code&gt; 을 삭제하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="110d9c4f62582ddf4909360dee5c526218c434e0" translate="yes" xml:space="preserve">
          <source>To drop the routine &lt;code&gt;foo&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형에 대한 루틴 &lt;code&gt;foo&lt;/code&gt; 를 삭제하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c536a04fe8d2446d8d61338be4ba1bab5c783796" translate="yes" xml:space="preserve">
          <source>To drop the transform for type &lt;code&gt;hstore&lt;/code&gt; and language &lt;code&gt;plpythonu&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 및 언어 &lt;code&gt;plpythonu&lt;/code&gt; 에 대한 변환을 삭제하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="5caa707f178a9cc755d7e779932a23df8fa2f1ca" translate="yes" xml:space="preserve">
          <source>To dump a database called &lt;code&gt;mydb&lt;/code&gt; into a SQL-script file:</source>
          <target state="translated">&lt;code&gt;mydb&lt;/code&gt; 라는 데이터베이스를 SQL 스크립트 파일로 덤프하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8121f62b8666545b2e2e99dedbccab51245f9807" translate="yes" xml:space="preserve">
          <source>To dump a database into a custom-format archive file:</source>
          <target state="translated">데이터베이스를 사용자 정의 형식 아카이브 파일로 덤프하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d437ca9f46ee2993ef3f0545d06bedd57d2c6b4f" translate="yes" xml:space="preserve">
          <source>To dump a database into a directory-format archive in parallel with 5 worker jobs:</source>
          <target state="translated">5 개의 작업자 작업과 동시에 데이터베이스를 디렉토리 형식 아카이브로 덤프하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="31fa398ad5cf2d5e038474c944b981aa565b1e44" translate="yes" xml:space="preserve">
          <source>To dump a database into a directory-format archive:</source>
          <target state="translated">데이터베이스를 디렉토리 형식 아카이브로 덤프하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ad76ea44a0ef53ad9ef9efb8caa4b902f280c164" translate="yes" xml:space="preserve">
          <source>To dump a single table named &lt;code&gt;mytab&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mytab&lt;/code&gt; 이라는 단일 테이블을 덤프하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d511ed087693f26bd4759bf8b1d27193b49e5e6" translate="yes" xml:space="preserve">
          <source>To dump all database objects except for tables whose names begin with &lt;code&gt;ts_&lt;/code&gt;:</source>
          <target state="translated">이름이 &lt;code&gt;ts_&lt;/code&gt; 로 시작하는 테이블을 제외한 모든 데이터베이스 오브젝트를 덤프하려면 다음 을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="5105a7d069d122946e3111a4bbe722d0a3cd0a79" translate="yes" xml:space="preserve">
          <source>To dump all databases:</source>
          <target state="translated">모든 데이터베이스를 덤프하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="999dcebdfcf4047b6459cc6ecf19931338457350" translate="yes" xml:space="preserve">
          <source>To dump all schemas whose names start with &lt;code&gt;east&lt;/code&gt; or &lt;code&gt;west&lt;/code&gt; and end in &lt;code&gt;gsm&lt;/code&gt;, excluding any schemas whose names contain the word &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">이름이 &lt;code&gt;test&lt;/code&gt; 라는 단어를 포함하는 스키마를 제외하고 이름이 &lt;code&gt;east&lt;/code&gt; 또는 &lt;code&gt;west&lt;/code&gt; 로 시작하고 &lt;code&gt;gsm&lt;/code&gt; 으로 끝나는 모든 스키마를 덤프하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="5301289a56ba7d9472a3d1bd5a043059fbfce396" translate="yes" xml:space="preserve">
          <source>To dump all tables whose names start with &lt;code&gt;emp&lt;/code&gt; in the &lt;code&gt;detroit&lt;/code&gt; schema, except for the table named &lt;code&gt;employee_log&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;employee_log&lt;/code&gt; 라는 이름의 테이블을 제외하고 이름 이 &lt;code&gt;detroit&lt;/code&gt; 스키마 에서 &lt;code&gt;emp&lt;/code&gt; 로 시작하는 모든 테이블을 덤프하려면 다음 을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f5c9b25307e1ce17bf381cf6cff0bda0e9cf7e6" translate="yes" xml:space="preserve">
          <source>To ease transition from the &lt;code&gt;md5&lt;/code&gt; method to the newer SCRAM method, if &lt;code&gt;md5&lt;/code&gt; is specified as a method in &lt;code&gt;pg_hba.conf&lt;/code&gt; but the user's password on the server is encrypted for SCRAM (see below), then SCRAM-based authentication will automatically be chosen instead.</source>
          <target state="translated">&lt;code&gt;md5&lt;/code&gt; 방법에서 최신 SCRAM 방법으로 쉽게 전환 할 수 있도록 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 방법으로 &lt;code&gt;md5&lt;/code&gt; 가 지정 되었지만 서버의 사용자 암호가 SCRAM에 대해 암호화 된 경우 (아래 참조) 대신 SCRAM 기반 인증이 자동으로 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="88489631fd89d19542342fc6ed140890035ad782" translate="yes" xml:space="preserve">
          <source>To enable WAL archiving, set the &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; configuration parameter to &lt;code&gt;replica&lt;/code&gt; or higher, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt;, and specify the shell command to use in the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; configuration parameter. In practice these settings will always be placed in the &lt;code&gt;postgresql.conf&lt;/code&gt; file. In &lt;code&gt;archive_command&lt;/code&gt;, &lt;code&gt;%p&lt;/code&gt; is replaced by the path name of the file to archive, while &lt;code&gt;%f&lt;/code&gt; is replaced by only the file name. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Use &lt;code&gt;%%&lt;/code&gt; if you need to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. The simplest useful command is something like:</source>
          <target state="translated">WAL 아카이브를 사용하려면 &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; 구성 매개 변수를 &lt;code&gt;replica&lt;/code&gt; 이상으로 설정하고 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; 를 &lt;code&gt;on&lt;/code&gt; 으로 설정 하고 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; 구성 매개 변수에 사용할 쉘 명령을 지정하십시오 . 실제로 이러한 설정은 항상 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일에 배치 됩니다. 에서는 &lt;code&gt;archive_command&lt;/code&gt; , &lt;code&gt;%p&lt;/code&gt; 하면서 아카이브 파일의 경로 이름으로 대체 &lt;code&gt;%f&lt;/code&gt; 파일명 만에 의해 대체된다. (경로 이름은 현재 작업 디렉토리, 즉 클러스터의 데이터 디렉토리와 관련이 있습니다.) 실제 &lt;code&gt;%&lt;/code&gt; 를 포함해야하는 경우 &lt;code&gt;%%&lt;/code&gt; 를 사용하십시오.명령에서 문자. 가장 간단한 유용한 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="163a2853661a9a827e1b4d5f0ebf9245d216aeaf" translate="yes" xml:space="preserve">
          <source>To enable automatic character set conversion, you have to tell PostgreSQL the character set (encoding) you would like to use in the client. There are several ways to accomplish this:</source>
          <target state="translated">자동 문자 집합 변환을 활성화하려면 PostgreSQL에 클라이언트에서 사용하려는 문자 집합 (인코딩)을 알려 주어야합니다. 이를 수행하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f220328ec4a4eaf272f16874cf3e03c4c355b3" translate="yes" xml:space="preserve">
          <source>To enable event logging in the database server, modify &lt;a href=&quot;runtime-config-logging#GUC-LOG-DESTINATION&quot;&gt;log_destination&lt;/a&gt; to include &lt;code&gt;eventlog&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">데이터베이스 서버에 이벤트 로깅을 사용하려면, 수정 &lt;a href=&quot;runtime-config-logging#GUC-LOG-DESTINATION&quot;&gt;의 log_destination를&lt;/a&gt; 포함하는 &lt;code&gt;eventlog&lt;/code&gt; 에 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 .</target>
        </trans-unit>
        <trans-unit id="a794df8102be7ea9270fd8cde81341bb2ca2e8b9" translate="yes" xml:space="preserve">
          <source>To enable messages to be translated to the user's preferred language, NLS must have been selected at build time (&lt;code&gt;configure --enable-nls&lt;/code&gt;). All other locale support is built in automatically.</source>
          <target state="translated">메시지를 사용자가 선호하는 언어로 번역하려면 빌드시 NLS를 선택해야합니다 ( &lt;code&gt;configure --enable-nls&lt;/code&gt; ). 다른 모든 로케일 지원은 자동으로 내장됩니다.</target>
        </trans-unit>
        <trans-unit id="33769b6666be88b23bc239c6978f70ef47bd7c0c" translate="yes" xml:space="preserve">
          <source>To enable this module, add &lt;code&gt;'$libdir/passwordcheck'&lt;/code&gt; to &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, then restart the server.</source>
          <target state="translated">이 모듈을 활성화하려면 &lt;code&gt;postgresql.conf&lt;/code&gt; 의&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; 에 &lt;code&gt;'$libdir/passwordcheck'&lt;/code&gt; 를 추가 한 다음 서버를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="49d847ac2d6554d00f1cf26dcadd69be9408d2b9" translate="yes" xml:space="preserve">
          <source>To ensure the integrity of the entire database structure, PostgreSQL makes sure that you cannot drop objects that other objects still depend on. For example, attempting to drop the products table we considered in &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-FK&quot;&gt;Section 5.4.5&lt;/a&gt;, with the orders table depending on it, would result in an error message like this:</source>
          <target state="translated">전체 데이터베이스 구조의 무결성을 보장하기 위해 PostgreSQL은 다른 객체가 여전히 의존하는 객체를 삭제할 수 없도록합니다. 예를 들어, &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-FK&quot;&gt;Section 5.4.5&lt;/a&gt; 에서 고려한 제품 테이블을 제거하려고 하면 orders 테이블과 함께 다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4eb94062de7d5c68db4eebe8d5792a4bae6fa4de" translate="yes" xml:space="preserve">
          <source>To establish a savepoint and later undo the effects of all commands executed after it was established:</source>
          <target state="translated">저장 점을 설정하고 나중에 설정 후 실행 된 모든 명령의 효과를 취소하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cc6a8d9f6b4e580d2ee11faae1f76e83795f9119" translate="yes" xml:space="preserve">
          <source>To establish and later destroy a savepoint:</source>
          <target state="translated">세이브 포인트를 설정하고 나중에 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4d022cb095a28d12057cc4d30c9ed630d8c4a81c" translate="yes" xml:space="preserve">
          <source>To examine a list of the currently outstanding locks in a database server, use the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view. For more information on monitoring the status of the lock manager subsystem, refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 서버에서 현재 미해결 된 잠금 목록을 확인하려면 &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; 시스템보기를 사용하십시오 . 잠금 관리자 서브 시스템의 상태 모니터링에 대한 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;제 27 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fad6ad49ad4e437a0cb62af93e6ae25b097ac33" translate="yes" xml:space="preserve">
          <source>To examine a list of the currently outstanding locks in a database server, use the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view. For more information on monitoring the status of the lock manager subsystem, refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 서버에서 현재 미해결 된 잠금 목록을 조사하려면 &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; 시스템 뷰를 사용하십시오 . 잠금 관리자 하위 시스템의 상태 모니터링에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/monitoring.html&quot;&gt;27 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee179a7e650337f5be46128f8c744f60566325a2" translate="yes" xml:space="preserve">
          <source>To examine the query plan PostgreSQL is using for a prepared statement, use &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;, for example</source>
          <target state="translated">PostgreSQL의 준비된 문에 사용하는 쿼리 계획을 조사하기 위해 사용 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 예를 들어,</target>
        </trans-unit>
        <trans-unit id="9ab98980692e8ae3b65879ae33d5792b980cffc7" translate="yes" xml:space="preserve">
          <source>To exclude data for all tables in the database, see &lt;code&gt;--schema-only&lt;/code&gt;.</source>
          <target state="translated">데이터베이스의 모든 테이블에 대한 데이터를 제외하려면 &lt;code&gt;--schema-only&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd00aea3b9256ff7a4422dd7af6985b4801677da" translate="yes" xml:space="preserve">
          <source>To exclude table data for only a subset of tables in the database, see &lt;code&gt;--exclude-table-data&lt;/code&gt;.</source>
          <target state="translated">데이터베이스에서 테이블의 서브 세트에 대해서만 테이블 데이터를 제외 시키려면 &lt;code&gt;--exclude-table-data&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6162526b00490b1f2f1658b53775455d6ca15472" translate="yes" xml:space="preserve">
          <source>To export a public key in ASCII-armor format:</source>
          <target state="translated">ASCII-armor 형식으로 공개 키를 내보내려면</target>
        </trans-unit>
        <trans-unit id="a23b559273ee4d257c470044a91813e890937385" translate="yes" xml:space="preserve">
          <source>To export a secret key in ASCII-armor format:</source>
          <target state="translated">ASCII-armor 형식으로 비밀 키를 내보내려면</target>
        </trans-unit>
        <trans-unit id="86f886ace5f866856fb04921712ddce243cc4f95" translate="yes" xml:space="preserve">
          <source>To facilitate controlled execution of such queries, GIN has a configurable soft upper limit on the number of rows returned: the &lt;code&gt;gin_fuzzy_search_limit&lt;/code&gt; configuration parameter. It is set to 0 (meaning no limit) by default. If a non-zero limit is set, then the returned set is a subset of the whole result set, chosen at random.</source>
          <target state="translated">이러한 쿼리의 제어 된 실행을 용이하게하기 위해 GIN에는 반환되는 행 수에 대해 구성 가능한 소프트 상한값 인 &lt;code&gt;gin_fuzzy_search_limit&lt;/code&gt; 구성 매개 변수가 있습니다. 기본적으로 0 (무제한 의미)으로 설정되어 있습니다. 0이 아닌 한계가 설정되면, 리턴 된 세트는 무작위로 선택된 전체 결과 세트의 서브 세트입니다.</target>
        </trans-unit>
        <trans-unit id="fabf2744d8a8f45bc9091582373665b13db0b3ab" translate="yes" xml:space="preserve">
          <source>To find an available OID for a new pre-loaded row, run the script &lt;code&gt;src/include/catalog/unused_oids&lt;/code&gt;. It prints inclusive ranges of unused OIDs (e.g., the output line &amp;ldquo;45-900&amp;rdquo; means OIDs 45 through 900 have not been allocated yet). Currently, OIDs 1-9999 are reserved for manual assignment; the &lt;code&gt;unused_oids&lt;/code&gt; script simply looks through the catalog headers and &lt;code&gt;.dat&lt;/code&gt; files to see which ones do not appear. You can also use the &lt;code&gt;duplicate_oids&lt;/code&gt; script to check for mistakes. (&lt;code&gt;genbki.pl&lt;/code&gt; will assign OIDs for any rows that didn't get one hand-assigned to them, and it will also detect duplicate OIDs at compile time.)</source>
          <target state="translated">사전로드 된 새 행에 사용 가능한 OID를 찾으려면 &lt;code&gt;src/include/catalog/unused_oids&lt;/code&gt; 스크립트를 실행하십시오 . 사용하지 않는 OID의 포괄적 인 범위를 인쇄합니다 (예 : 출력 라인 &quot;45-900&quot;은 OID 45-900이 아직 할당되지 않았 음을 의미합니다). 현재 OID 1-9999는 수동 할당을 위해 예약되어 있습니다. &lt;code&gt;unused_oids&lt;/code&gt; 의 스크립트는 단순히 카탈로그 헤더를 통해 보이는 &lt;code&gt;.dat&lt;/code&gt; 사람이 나타나지 않는 볼 수있는 파일입니다. &lt;code&gt;duplicate_oids&lt;/code&gt; 스크립트를 사용하여 실수를 확인할 수도 있습니다 . ( &lt;code&gt;genbki.pl&lt;/code&gt; 은 한 번에 할당하지 않은 행에 대해 OID를 할당하고 컴파일시 중복 된 OID도 감지합니다.)</target>
        </trans-unit>
        <trans-unit id="83324513227c6e220838375b162eb3efe60ff368" translate="yes" xml:space="preserve">
          <source>To find an available OID for a new pre-loaded row, run the script &lt;code&gt;src/include/catalog/unused_oids&lt;/code&gt;. It prints inclusive ranges of unused OIDs (e.g., the output line &lt;code&gt;45-900&lt;/code&gt; means OIDs 45 through 900 have not been allocated yet). Currently, OIDs 1&amp;ndash;9999 are reserved for manual assignment; the &lt;code&gt;unused_oids&lt;/code&gt; script simply looks through the catalog headers and &lt;code&gt;.dat&lt;/code&gt; files to see which ones do not appear. You can also use the &lt;code&gt;duplicate_oids&lt;/code&gt; script to check for mistakes. (&lt;code&gt;genbki.pl&lt;/code&gt; will assign OIDs for any rows that didn't get one hand-assigned to them, and it will also detect duplicate OIDs at compile time.)</source>
          <target state="translated">사전로드 된 새 행에 대해 사용 가능한 OID를 찾으려면 &lt;code&gt;src/include/catalog/unused_oids&lt;/code&gt; 스크립트를 실행하십시오 . 사용되지 않은 OID의 포함 범위를 인쇄합니다 (예 : 출력 라인 &lt;code&gt;45-900&lt;/code&gt; 은 OID 45-900 이 아직 할당되지 않았 음을 의미합니다). 현재 OID 1&amp;ndash;9999는 수동 할당을 위해 예약되어 있습니다. &lt;code&gt;unused_oids&lt;/code&gt; 의 스크립트는 단순히 카탈로그 헤더를 통해 보이는 &lt;code&gt;.dat&lt;/code&gt; 사람이 나타나지 않는 볼 수있는 파일입니다. &lt;code&gt;duplicate_oids&lt;/code&gt; 스크립트를 사용하여 실수를 확인할 수도 있습니다 . ( &lt;code&gt;genbki.pl&lt;/code&gt; 은 하나가 직접 할당되지 않은 행에 대해 OID를 할당하고 컴파일 타임에 중복 OID도 감지합니다.)</target>
        </trans-unit>
        <trans-unit id="e7b4d89e57b00cb717b3a45dca9a44135790f4f2" translate="yes" xml:space="preserve">
          <source>To force immediate reclamation of space occupied by a dropped column, you can execute one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that performs a rewrite of the whole table. This results in reconstructing each row with the dropped column replaced by a null value.</source>
          <target state="translated">삭제 된 열이 차지하는 공간을 즉시 교정하기 위해 전체 테이블을 다시 작성하는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식 중 하나를 실행할 수 있습니다 . 결과적으로 삭제 된 열이 널값으로 대체 된 각 행이 재구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e539dee4c479de5ce6227904539c51905413b8a2" translate="yes" xml:space="preserve">
          <source>To force the planner to follow the join order laid out by explicit &lt;code&gt;JOIN&lt;/code&gt;s, set the &lt;a href=&quot;runtime-config-query#GUC-JOIN-COLLAPSE-LIMIT&quot;&gt;join_collapse_limit&lt;/a&gt; run-time parameter to 1. (Other possible values are discussed below.)</source>
          <target state="translated">플래너가 명시 적 &lt;code&gt;JOIN&lt;/code&gt; 에 의해 배치 된 결합 순서를 따르도록하려면 &lt;a href=&quot;runtime-config-query#GUC-JOIN-COLLAPSE-LIMIT&quot;&gt;join_collapse_limit&lt;/a&gt; 런타임 매개 변수를 1로 설정하십시오 . 다른 가능한 값은 아래에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8b97e829e4f12bf390f60edd12090a6e21acdc24" translate="yes" xml:space="preserve">
          <source>To generate a new key:</source>
          <target state="translated">새 키를 생성하려면</target>
        </trans-unit>
        <trans-unit id="e2c066b392d0690f674361c2e00b7a60bde09ccb" translate="yes" xml:space="preserve">
          <source>To get &lt;code&gt;doc_num&lt;/code&gt; on every line, the solution is to use two invocations of &lt;code&gt;xpath_table&lt;/code&gt; and join the results:</source>
          <target state="translated">모든 줄에서 &lt;code&gt;doc_num&lt;/code&gt; 을 얻으려면 해결책은 &lt;code&gt;xpath_table&lt;/code&gt; 의 두 호출을 사용 하고 결과를 결합하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="69c96837968de4279f15cf969e5e70dc5b6c75e5" translate="yes" xml:space="preserve">
          <source>To get out of &lt;code&gt;psql&lt;/code&gt;, type:</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; 에서 나가려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="f841c80668fce3c31645a5d7959f701a568c379f" translate="yes" xml:space="preserve">
          <source>To get the start time of segments with such values instead, you have to filter out irrelevant segments before returning the start time, so the filter expression is applied to the previous step, and the path used in the condition is different:</source>
          <target state="translated">이러한 값을 가진 세그먼트의 시작 시간을 가져 오려면 시작 시간을 리턴하기 전에 관련없는 세그먼트를 필터링해야하므로 필터 표현식이 이전 단계에 적용되고 조건에 사용 된 경로가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a23cfe85547c2cef9463af3fca5fe0719f145cc1" translate="yes" xml:space="preserve">
          <source>To get the start times of segments with such values, you have to filter out irrelevant segments before returning the start times, so the filter expression is applied to the previous step, and the path used in the condition is different:</source>
          <target state="translated">이러한 값이있는 세그먼트의 시작 시간을 가져 오려면 시작 시간을 반환하기 전에 관련없는 세그먼트를 필터링해야하므로 필터 표현식이 이전 단계에 적용되고 조건에 사용 된 경로가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c348e1fb7d6b60d5bb3b8782cdcf8ec28351c7b2" translate="yes" xml:space="preserve">
          <source>To give a schema-qualified operator name in &lt;code&gt;com_op&lt;/code&gt; or the other optional arguments, use the &lt;code&gt;OPERATOR()&lt;/code&gt; syntax, for example:</source>
          <target state="translated">&lt;code&gt;com_op&lt;/code&gt; 또는 다른 선택적 인수 로 스키마 규정 연산자 이름을 지정 하려면 다음과 같이 &lt;code&gt;OPERATOR()&lt;/code&gt; 구문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="181dc64889b2ae0155da88752e6851b32114a550" translate="yes" xml:space="preserve">
          <source>To guarantee true serializability PostgreSQL uses &lt;em&gt;predicate locking&lt;/em&gt;, which means that it keeps locks which allow it to determine when a write would have had an impact on the result of a previous read from a concurrent transaction, had it run first. In PostgreSQL these locks do not cause any blocking and therefore can &lt;em&gt;not&lt;/em&gt; play any part in causing a deadlock. They are used to identify and flag dependencies among concurrent Serializable transactions which in certain combinations can lead to serialization anomalies. In contrast, a Read Committed or Repeatable Read transaction which wants to ensure data consistency may need to take out a lock on an entire table, which could block other users attempting to use that table, or it may use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; or &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; which not only can block other transactions but cause disk access.</source>
          <target state="translated">진정한 직렬화 가능성을 보장하기 위해 PostgreSQL은 &lt;em&gt;predicate locking을&lt;/em&gt; 사용합니다. 즉, 쓰기가 동시 트랜잭션의 이전 읽기 결과에 영향을 미쳤을 때이를 처음으로 실행 한 시점을 결정할 수 있도록 잠금을 유지합니다. PostgreSQL에서 이러한 잠금은 차단을 유발하지 않으므로 교착 상태를 유발하는 데 아무런 역할을 할 수 &lt;em&gt;없습니다&lt;/em&gt; . 특정 조합에서는 직렬화 이상을 초래할 수있는 동시 직렬화 가능 트랜잭션 간의 종속성을 식별하고 플래그를 지정하는 데 사용됩니다. 반대로, 데이터 일관성을 보장하려는 읽기 커밋 또는 반복 가능한 읽기 트랜잭션은 전체 테이블에 대한 잠금을 해제해야 할 수 있으며, 이로 인해 다른 사용자가 해당 테이블을 사용하려는 시도를 차단하거나 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 다른 트랜잭션을 차단할 수있을뿐만 아니라 디스크 액세스를 유발하는 공유 를 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="f68a15ec78f387befd6d0298f8810f1045e197b1" translate="yes" xml:space="preserve">
          <source>To illustrate the difference, if &lt;code&gt;x&lt;/code&gt; is an XML value, these two queries in an SQL:2006 environment would produce true and false, respectively:</source>
          <target state="translated">차이점을 설명하기 위해 &lt;code&gt;x&lt;/code&gt; 가 XML 값인 경우 SQL : 2006 환경에서이 두 쿼리는 각각 true와 false를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="33e38f50067618192123a7a6ea2a2035a90e4fb0" translate="yes" xml:space="preserve">
          <source>To illustrate the use of array types, we create this table:</source>
          <target state="translated">배열 유형의 사용을 설명하기 위해이 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7b5b94d4b187e4064dd8c2d93482d78bbe19ae50" translate="yes" xml:space="preserve">
          <source>To illustrate this, let's implement the following policy on the many-to-many relationship example above: when someone wants to remove a product that is still referenced by an order (via &lt;code&gt;order_items&lt;/code&gt;), we disallow it. If someone removes an order, the order items are removed as well:</source>
          <target state="translated">이를 설명하기 위해 위의 다 대다 관계 예에 대해 다음 정책을 구현해 봅시다. 누군가 order ( &lt;code&gt;order_items&lt;/code&gt; 를 통해 ) 여전히 주문에 의해 참조되는 제품을 제거하려는 경우 이를 허용하지 않습니다. 누군가 주문을 제거하면 주문 항목도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7f35959c3ce0c736cba407ce1950e3b7f93b092e" translate="yes" xml:space="preserve">
          <source>To implement an access method, an implementor will typically need to implement an AM-specific type of tuple table slot (see &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/executor/tuptable.h;hb=HEAD&quot;&gt;&lt;code&gt;src/include/executor/tuptable.h&lt;/code&gt;&lt;/a&gt;), which allows code outside the access method to hold references to tuples of the AM, and to access the columns of the tuple.</source>
          <target state="translated">액세스 방법을 구현하려면 구현자는 일반적으로 AM 특정 유형의 튜플 테이블 슬롯 ( &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/executor/tuptable.h;hb=HEAD&quot;&gt; &lt;code&gt;src/include/executor/tuptable.h&lt;/code&gt; &lt;/a&gt; 참조)을 구현해야합니다 .이를 통해 액세스 방법 외부의 코드가 AM의 튜플에 대한 참조를 보유 할 수 있습니다. 튜플의 열에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="ea65817bb743af7def6e62b531aec8b8c7c1a366" translate="yes" xml:space="preserve">
          <source>To implement full text searching there must be a function to create a &lt;code&gt;tsvector&lt;/code&gt; from a document and a &lt;code&gt;tsquery&lt;/code&gt; from a user query. Also, we need to return results in a useful order, so we need a function that compares documents with respect to their relevance to the query. It's also important to be able to display the results nicely. PostgreSQL provides support for all of these functions.</source>
          <target state="translated">전체 텍스트 검색을 구현하려면 생성하는 기능이 있어야 &lt;code&gt;tsvector&lt;/code&gt; 문서에서와 &lt;code&gt;tsquery&lt;/code&gt; 사용자 쿼리를. 또한 유용한 순서로 결과를 반환해야하므로 문서와 쿼리의 관련성을 비교하는 기능이 필요합니다. 결과를 멋지게 표시 할 수 있어야합니다. PostgreSQL은 이러한 모든 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f90b4fcb28ef9c823a8d7810618ebba2004bd7be" translate="yes" xml:space="preserve">
          <source>To implement sub-partitioning, specify the &lt;code&gt;PARTITION BY&lt;/code&gt; clause in the commands used to create individual partitions, for example:</source>
          <target state="translated">하위 파티션을 구현하려면 다음 과 같이 개별 파티션을 만드는 데 사용되는 명령에 &lt;code&gt;PARTITION BY&lt;/code&gt; 절을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="846839113d5d394eb45527ccc7c7a96f15b009ec" translate="yes" xml:space="preserve">
          <source>To implement transactional support in a manner that allows different table access methods be accessed within a single transaction, it likely is necessary to closely integrate with the machinery in &lt;code&gt;src/backend/access/transam/xlog.c&lt;/code&gt;.</source>
          <target state="translated">단일 트랜잭션 내에서 다른 테이블 액세스 방법에 액세스 할 수있는 방식으로 트랜잭션 지원을 구현하려면 &lt;code&gt;src/backend/access/transam/xlog.c&lt;/code&gt; 의 기계와 긴밀하게 통합해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0b8cb073edc0febf35e9cd737b45bb493e96aed" translate="yes" xml:space="preserve">
          <source>To import a log file into this table, use the &lt;code&gt;COPY FROM&lt;/code&gt; command:</source>
          <target state="translated">이 테이블로 로그 파일을 가져 오려면 &lt;code&gt;COPY FROM&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="28e732fd3da22b22756fa7755e21953801d94a6c" translate="yes" xml:space="preserve">
          <source>To improve such estimates, &lt;code&gt;ANALYZE&lt;/code&gt; can collect MCV lists on combinations of columns. Similarly to functional dependencies and n-distinct coefficients, it's impractical to do this for every possible column grouping. Even more so in this case, as the MCV list (unlike functional dependencies and n-distinct coefficients) does store the common column values. So data is collected only for those groups of columns appearing together in a statistics object defined with the &lt;code&gt;mcv&lt;/code&gt; option.</source>
          <target state="translated">이러한 추정치를 개선하기 위해 &lt;code&gt;ANALYZE&lt;/code&gt; 는 열 조합에서 MCV 목록을 수집 할 수 있습니다. 기능적 종속성 및 n- 고유 계수와 마찬가지로 가능한 모든 열 그룹화에 대해이를 수행하는 것은 비현실적입니다. 이 경우 MCV 목록 (기능적 종속성 및 n 고유 계수와 달리)이 공통 열 값을 저장하므로 더욱 그렇습니다. 따라서 &lt;code&gt;mcv&lt;/code&gt; 옵션으로 정의 된 통계 개체에 함께 나타나는 열 그룹에 대해서만 데이터가 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="726a8877a697c9a76f8ec5b5c68e9adbda1257f4" translate="yes" xml:space="preserve">
          <source>To improve such estimates, &lt;code&gt;ANALYZE&lt;/code&gt; can collect n-distinct statistics for groups of columns. As before, it's impractical to do this for every possible column grouping, so data is collected only for those groups of columns appearing together in a statistics object defined with the &lt;code&gt;ndistinct&lt;/code&gt; option. Data will be collected for each possible combination of two or more columns from the set of listed columns.</source>
          <target state="translated">이러한 추정치를 개선하기 위해 &lt;code&gt;ANALYZE&lt;/code&gt; 는 열 그룹에 대해 n 개의 고유 한 통계를 수집 할 수 있습니다. 이전과 같이 가능한 모든 열 그룹에 대해이 작업을 수행하는 것은 실용적이지 않으므로 &lt;code&gt;ndistinct&lt;/code&gt; 옵션으로 정의 된 통계 개체에 함께 표시되는 열 그룹에 대해서만 데이터가 수집됩니다 . 나열된 컬럼 세트에서 둘 이상의 컬럼 조합에 대해 데이터가 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="6fc7cc9bd907a538cf92f4185feaaa71d0884dc6" translate="yes" xml:space="preserve">
          <source>To include a literal &lt;code&gt;]&lt;/code&gt; in the list, make it the first character (after &lt;code&gt;^&lt;/code&gt;, if that is used). To include a literal &lt;code&gt;-&lt;/code&gt;, make it the first or last character, or the second endpoint of a range. To use a literal &lt;code&gt;-&lt;/code&gt; as the first endpoint of a range, enclose it in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; to make it a collating element (see below). With the exception of these characters, some combinations using &lt;code&gt;[&lt;/code&gt; (see next paragraphs), and escapes (AREs only), all other special characters lose their special significance within a bracket expression. In particular, &lt;code&gt;\&lt;/code&gt; is not special when following ERE or BRE rules, though it is special (as introducing an escape) in AREs.</source>
          <target state="translated">목록에 리터럴 &lt;code&gt;]&lt;/code&gt; 을 포함 시키려면 첫 번째 문자로 사용하십시오 ( &lt;code&gt;^&lt;/code&gt; 인 경우 뒤에 ). 리터럴 &lt;code&gt;-&lt;/code&gt; 을 포함하려면 첫 번째 또는 마지막 문자 또는 범위의 두 번째 끝점으로 만드십시오. 리터럴을 사용하려면 &lt;code&gt;-&lt;/code&gt; 범위의 제 1 종료점 같이 표로 &lt;code&gt;[.&lt;/code&gt; 및 &lt;code&gt;.]&lt;/code&gt; 그것을 조합 소자하도록 (아래 참조). 이러한 문자를 제외하고 &lt;code&gt;[&lt;/code&gt; (다음 단락 참조) 및 이스케이프 (ARE 만 해당)를 사용하는 일부 조합 은 다른 모든 특수 문자가 대괄호 표현식 내에서 특별한 의미를 잃습니다. 특히, &lt;code&gt;\&lt;/code&gt; 는 ERE 또는 BRE 규칙을 따를 때 특별하지 않지만 ARE에서는 특별합니다 (이스케이프를 도입 함).</target>
        </trans-unit>
        <trans-unit id="4184bf034050051b34f3bc62384d8d2db0c8c933" translate="yes" xml:space="preserve">
          <source>To include the escape character in the identifier literally, write it twice.</source>
          <target state="translated">식별자에 이스케이프 문자를 문자 그대로 포함하려면 두 번 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="e84215b046c65219d5ce30b242beef53ee6e7a36" translate="yes" xml:space="preserve">
          <source>To include the escape character in the string literally, write it twice.</source>
          <target state="translated">문자열에 이스케이프 문자를 포함 시키려면 두 번 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="78f88921a54fbd43b8bb79b923defafecfc3cd3f" translate="yes" xml:space="preserve">
          <source>To include whitespace in an argument you can quote it with single quotes. To include a single quote in an argument, write two single quotes within single-quoted text. Anything contained in single quotes is furthermore subject to C-like substitutions for &lt;code&gt;\n&lt;/code&gt; (new line), &lt;code&gt;\t&lt;/code&gt; (tab), &lt;code&gt;\b&lt;/code&gt; (backspace), &lt;code&gt;\r&lt;/code&gt; (carriage return), &lt;code&gt;\f&lt;/code&gt; (form feed), &lt;code&gt;\&lt;/code&gt;&lt;code&gt;digits&lt;/code&gt; (octal), and &lt;code&gt;\x&lt;/code&gt;&lt;code&gt;digits&lt;/code&gt; (hexadecimal). A backslash preceding any other character within single-quoted text quotes that single character, whatever it is.</source>
          <target state="translated">인수에 공백을 포함 시키려면 작은 따옴표로 공백을 인용 할 수 있습니다. 인수에 작은 따옴표를 포함 시키려면 작은 따옴표로 묶은 텍스트 안에 작은 따옴표를 두 개 쓰십시오. 작은 따옴표에 포함 된 것은 &lt;code&gt;\n&lt;/code&gt; (새 줄), &lt;code&gt;\t&lt;/code&gt; (탭), &lt;code&gt;\b&lt;/code&gt; (백 스페이스), &lt;code&gt;\r&lt;/code&gt; (캐리지 리턴), &lt;code&gt;\f&lt;/code&gt; (양식 공급), &lt;code&gt;\&lt;/code&gt; &lt;code&gt;digits&lt;/code&gt; ( 8 진수) 및 &lt;code&gt;\x&lt;/code&gt; &lt;code&gt;digits&lt;/code&gt; (16 진수)입니다. 작은 따옴표로 묶인 텍스트 내의 다른 문자 앞에 오는 백 슬래시는 해당 문자를 무엇이든 인용합니다.</target>
        </trans-unit>
        <trans-unit id="1f2cb44f0c5a3aa8e112ae7be973fd139113c473" translate="yes" xml:space="preserve">
          <source>To index the original phrase as well as the substitute, just include it in the right-hand part of the definition:</source>
          <target state="translated">대체 문구뿐만 아니라 원래 문구를 색인화하려면 정의의 오른쪽 부분에 문구를 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="95ef2591a1c7f1278d7f81a1fe53a76759cd33d8" translate="yes" xml:space="preserve">
          <source>To indicate that a type is an array, specify the type of the array elements using the &lt;code&gt;ELEMENT&lt;/code&gt; key word. For example, to define an array of 4-byte integers (&lt;code&gt;int4&lt;/code&gt;), specify &lt;code&gt;ELEMENT = int4&lt;/code&gt;. More details about array types appear below.</source>
          <target state="translated">유형이 배열임을 나타내려면 &lt;code&gt;ELEMENT&lt;/code&gt; 키워드를 사용하여 배열 요소의 유형을 지정하십시오 . 예를 들어, 4 바이트 정수 ( &lt;code&gt;int4&lt;/code&gt; ) 의 배열을 정의하려면 &lt;code&gt;ELEMENT = int4&lt;/code&gt; 지정하십시오 . 배열 유형에 대한 자세한 내용은 아래에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfac2991049d03ecd33ce1361a3f4d83513beefd" translate="yes" xml:space="preserve">
          <source>To indicate the delimiter to be used between values in the external representation of arrays of this type, &lt;code&gt;delimiter&lt;/code&gt; can be set to a specific character. The default delimiter is the comma (&lt;code&gt;,&lt;/code&gt;). Note that the delimiter is associated with the array element type, not the array type itself.</source>
          <target state="translated">이러한 유형의 배열의 외부 표현 값 사이에 사용되는 구분 기호를 나타 내기 위해, &lt;code&gt;delimiter&lt;/code&gt; 특정 문자로 설정할 수 있습니다. 기본 분리 문자는 쉼표 ( &lt;code&gt;,&lt;/code&gt; )입니다. 분리 문자는 배열 유형 자체가 아니라 배열 요소 유형과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="f9cbc2cc662f87e5cddcf234e0f6469fdfb69842" translate="yes" xml:space="preserve">
          <source>To inform the planner about functional dependencies, &lt;code&gt;ANALYZE&lt;/code&gt; can collect measurements of cross-column dependency. Assessing the degree of dependency between all sets of columns would be prohibitively expensive, so data collection is limited to those groups of columns appearing together in a statistics object defined with the &lt;code&gt;dependencies&lt;/code&gt; option. It is advisable to create &lt;code&gt;dependencies&lt;/code&gt; statistics only for column groups that are strongly correlated, to avoid unnecessary overhead in both &lt;code&gt;ANALYZE&lt;/code&gt; and later query planning.</source>
          <target state="translated">플래너에게 기능적 종속성에 대해 알리기 위해 &lt;code&gt;ANALYZE&lt;/code&gt; 는 교차 열 종속성의 측정 값을 수집 할 수 있습니다. 모든 열 집합 간의 종속성 정도를 평가하는 것은 엄청나게 비싸므로 데이터 수집은 &lt;code&gt;dependencies&lt;/code&gt; 옵션으로 정의 된 통계 개체에 함께 나타나는 열 그룹으로 제한됩니다 . &lt;code&gt;ANALYZE&lt;/code&gt; 및 이후 쿼리 계획 에서 불필요한 오버 헤드를 피하기 위해 서로 밀접하게 연관된 열 그룹에 대해서만 &lt;code&gt;dependencies&lt;/code&gt; 통계 를 작성 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5d0fceb23b95d26529865353175f08c16f67334c" translate="yes" xml:space="preserve">
          <source>To initialize a database cluster manually, run &lt;code&gt;initdb&lt;/code&gt; and specify the desired file system location of the database cluster with the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="translated">데이터베이스 클러스터를 수동으로 초기화하려면 &lt;code&gt;initdb&lt;/code&gt; 를 실행 하고 &lt;code&gt;-D&lt;/code&gt; 옵션 을 사용하여 데이터베이스 클러스터의 원하는 파일 시스템 위치를 지정합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40cf525f7b3d73ebe89741dbac88fd30351f8be3" translate="yes" xml:space="preserve">
          <source>To insert a percent sign into your prompt, write &lt;code&gt;%%&lt;/code&gt;. The default prompts are &lt;code&gt;'%/%R%# '&lt;/code&gt; for prompts 1 and 2, and &lt;code&gt;'&amp;gt;&amp;gt; '&lt;/code&gt; for prompt 3.</source>
          <target state="translated">프롬프트에 백분율 기호를 삽입하려면 &lt;code&gt;%%&lt;/code&gt; 를 쓰십시오 . 기본 프롬프트는 프롬프트 1과 2의 경우 &lt;code&gt;'%/%R%# '&lt;/code&gt; 이고 프롬프트 3 &lt;code&gt;'&amp;gt;&amp;gt; '&lt;/code&gt; 경우 '&amp;gt;&amp;gt;' 입니다.</target>
        </trans-unit>
        <trans-unit id="f6d883ec7d3bf5a2c0cbb45370c83314d637adfd" translate="yes" xml:space="preserve">
          <source>To insert a percent sign into your prompt, write &lt;code&gt;%%&lt;/code&gt;. The default prompts are &lt;code&gt;'%/%R%x%# '&lt;/code&gt; for prompts 1 and 2, and &lt;code&gt;'&amp;gt;&amp;gt; '&lt;/code&gt; for prompt 3.</source>
          <target state="translated">프롬프트에 백분율 기호를 삽입하려면 &lt;code&gt;%%&lt;/code&gt; 를 작성하십시오 . 기본 프롬프트는 프롬프트 1과 2의 경우 &lt;code&gt;'%/%R%x%# '&lt;/code&gt; 이고 프롬프트 3 &lt;code&gt;'&amp;gt;&amp;gt; '&lt;/code&gt; 경우 '&amp;gt;&amp;gt;' 입니다.</target>
        </trans-unit>
        <trans-unit id="e1ee9bbe110857fcf2f7841b805a4e345fe77366" translate="yes" xml:space="preserve">
          <source>To insert a row consisting entirely of default values:</source>
          <target state="translated">전체 기본값으로 구성된 행을 삽입하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d5156cf333413525236a7d8f0063c5f452f5f26a" translate="yes" xml:space="preserve">
          <source>To insert multiple rows using the multirow &lt;code&gt;VALUES&lt;/code&gt; syntax:</source>
          <target state="translated">여러 행 &lt;code&gt;VALUES&lt;/code&gt; 구문을 사용하여 여러 행을 삽입하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="74b9c8be569e80f1c859ef51f10adea40ff85de7" translate="yes" xml:space="preserve">
          <source>To insert the next value of the sequence into the &lt;code&gt;serial&lt;/code&gt; column, specify that the &lt;code&gt;serial&lt;/code&gt; column should be assigned its default value. This can be done either by excluding the column from the list of columns in the &lt;code&gt;INSERT&lt;/code&gt; statement, or through the use of the &lt;code&gt;DEFAULT&lt;/code&gt; key word.</source>
          <target state="translated">&lt;code&gt;serial&lt;/code&gt; 번호의 다음 순서 값을 일련 열에 삽입하려면 &lt;code&gt;serial&lt;/code&gt; 열에 기본값을 지정해야합니다. &lt;code&gt;INSERT&lt;/code&gt; 문의 열 목록에서 열을 제외 하거나 &lt;code&gt;DEFAULT&lt;/code&gt; 키워드를 사용 하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9325a56bbba931c18bc288d06702b77030782fe9" translate="yes" xml:space="preserve">
          <source>To inspect the currently available locales, use the query &lt;code&gt;SELECT * FROM pg_collation&lt;/code&gt;, or the command &lt;code&gt;\dOS+&lt;/code&gt; in psql.</source>
          <target state="translated">현재 사용 가능한 로케일을 검사하려면 &lt;code&gt;SELECT * FROM pg_collation&lt;/code&gt; 쿼리 또는 psql의 &lt;code&gt;\dOS+&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="396cd46392c72184b16377243ca319a056a0005a" translate="yes" xml:space="preserve">
          <source>To intersperse text output in between query results, use &lt;code&gt;\qecho&lt;/code&gt;.</source>
          <target state="translated">쿼리 결과간에 텍스트 출력을 &lt;code&gt;\qecho&lt;/code&gt; 하려면 \ qecho를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="11793d6d388c3ed014d8177be32ebeaaabfb3f69" translate="yes" xml:space="preserve">
          <source>To join the table &lt;code&gt;films&lt;/code&gt; with the table &lt;code&gt;distributors&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;distributors&lt;/code&gt; 와 테이블 &lt;code&gt;films&lt;/code&gt; 을 결합하려면 :</target>
        </trans-unit>
        <trans-unit id="628b8c5cdb42f7dc53d8569d2746c631140dbcd9" translate="yes" xml:space="preserve">
          <source>To learn more about the SQL/JSON standard, see &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SQLTR-19075-6&quot;&gt;[sqltr-19075-6]&lt;/a&gt;. For details on JSON types supported in PostgreSQL, see &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="translated">SQL / JSON 표준에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SQLTR-19075-6&quot;&gt;[sqltr-19075-6]을&lt;/a&gt; 참조하십시오 . PostgreSQL에서 지원되는 JSON 유형에 대한 자세한 내용 &lt;a href=&quot;datatype-json&quot;&gt;은 8.14 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa2a7ac21257e516bad1e8308a714c724e5e994e" translate="yes" xml:space="preserve">
          <source>To learn more about the SQL/JSON standard, see &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SQLTR-19075-6&quot;&gt;[sqltr-19075-6]&lt;/a&gt;. For details on JSON types supported in PostgreSQL, see &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="translated">SQL / JSON 표준에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SQLTR-19075-6&quot;&gt;[sqltr-19075-6]을&lt;/a&gt; 참조하십시오 . PostgreSQL에서 지원되는 JSON 유형에 대한 자세한 내용은 &lt;a href=&quot;datatype-json&quot;&gt;섹션 8.14를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="889344cf4fa47381ec5fba6605b2194e6f5635b8" translate="yes" xml:space="preserve">
          <source>To list keys:</source>
          <target state="translated">키를 나열하려면</target>
        </trans-unit>
        <trans-unit id="1746b8a797d81baecf4e64517cb9e2b4e171ea4d" translate="yes" xml:space="preserve">
          <source>To look up functions taking arguments or returning values of a specific data type, use your pager's search capability to scroll through the &lt;code&gt;\df&lt;/code&gt; output.</source>
          <target state="translated">인수를 사용하거나 특정 데이터 유형의 값을 리턴하는 함수를 찾으려면 호출기의 검색 기능을 사용하여 &lt;code&gt;\df&lt;/code&gt; 출력 을 스크롤하십시오 .</target>
        </trans-unit>
        <trans-unit id="f63105a6bdca6f2a502122ad5fab70a09773a1ea" translate="yes" xml:space="preserve">
          <source>To make a registration:</source>
          <target state="translated">등록하려면 :</target>
        </trans-unit>
        <trans-unit id="21a3f307d9fb66d4c9cdb328cd1d7f268094c295" translate="yes" xml:space="preserve">
          <source>To make effective use of the index-only scan feature, you might choose to create a &lt;em&gt;covering index&lt;/em&gt;, which is an index specifically designed to include the columns needed by a particular type of query that you run frequently. Since queries typically need to retrieve more columns than just the ones they search on, PostgreSQL allows you to create an index in which some columns are just &amp;ldquo;payload&amp;rdquo; and are not part of the search key. This is done by adding an &lt;code&gt;INCLUDE&lt;/code&gt; clause listing the extra columns. For example, if you commonly run queries like</source>
          <target state="translated">인덱스 전용 스캔 기능을 효과적으로 사용하기 위해 자주 실행하는 특정 유형의 쿼리에 필요한 열을 포함하도록 특별히 설계된 &lt;em&gt;인덱스&lt;/em&gt; 인 &lt;em&gt;커버링 인덱스&lt;/em&gt; 를 만들 수 있습니다 . 쿼리는 일반적으로 검색하는 것보다 많은 열을 검색해야하므로 PostgreSQL에서는 일부 열이 &quot;페이로드&quot;이고 검색 키의 일부가 아닌 인덱스를 만들 수 있습니다. 이는 여분의 열을 나열 하는 &lt;code&gt;INCLUDE&lt;/code&gt; 절 을 추가하여 수행됩니다 . 예를 들어 일반적으로</target>
        </trans-unit>
        <trans-unit id="5f2951feb65ad64d0c55b52fdde9cfe0496f2a09" translate="yes" xml:space="preserve">
          <source>To make it easier to build custom text search configurations, a configuration is built up from simpler database objects. PostgreSQL's text search facility provides four types of configuration-related database objects:</source>
          <target state="translated">사용자 정의 텍스트 검색 구성을보다 쉽게 ​​구축 할 수 있도록보다 간단한 데이터베이스 객체로 구성이 구성됩니다. PostgreSQL의 텍스트 검색 기능은 4 가지 유형의 구성 관련 데이터베이스 객체를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="32e1597b40ce1accf80ccac6a6e7b7c63bd5a013" translate="yes" xml:space="preserve">
          <source>To make it harder for people to break things, there is a limit of 100 on the number of dimensions of cubes. This is set in &lt;code&gt;cubedata.h&lt;/code&gt; if you need something bigger.</source>
          <target state="translated">사람들이 물건을 부수기 어렵게 만들기 위해 큐브 크기의 수는 100으로 제한됩니다. 더 큰 것이 필요한 경우 &lt;code&gt;cubedata.h&lt;/code&gt; 에 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="76612115b359bc164a8d942bcbc6e3a7da781870" translate="yes" xml:space="preserve">
          <source>To make the backup, you can use the pg_dumpall command from the version you are currently running; see &lt;a href=&quot;backup-dump#BACKUP-DUMP-ALL&quot;&gt;Section 25.1.2&lt;/a&gt; for more details. For best results, however, try to use the pg_dumpall command from PostgreSQL 12.1, since this version contains bug fixes and improvements over older versions. While this advice might seem idiosyncratic since you haven't installed the new version yet, it is advisable to follow it if you plan to install the new version in parallel with the old version. In that case you can complete the installation normally and transfer the data later. This will also decrease the downtime.</source>
          <target state="translated">백업하려면 현재 실행중인 버전에서 pg_dumpall 명령을 사용할 수 있습니다. 자세한 내용 은 &lt;a href=&quot;backup-dump#BACKUP-DUMP-ALL&quot;&gt;섹션 25.1.2&lt;/a&gt; 를 참조하십시오. 그러나 최상의 결과를 얻으려면 PostgreSQL 12.1의 pg_dumpall 명령을 사용하십시오.이 버전에는 이전 버전에 비해 버그 수정 및 개선 사항이 포함되어 있습니다. 새 버전을 아직 설치하지 않았으므로이 조언이 특유의 것처럼 보일 수 있지만 이전 버전과 병렬로 새 버전을 설치하려는 경우이를 따르는 것이 좋습니다. 이 경우 설치를 정상적으로 완료하고 나중에 데이터를 전송할 수 있습니다. 또한 다운 타임이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="10dbb8485ad8b8028e702262aa6a7b5834c5457f" translate="yes" xml:space="preserve">
          <source>To make the backup, you can use the pg_dumpall command from the version you are currently running; see &lt;a href=&quot;backup-dump#BACKUP-DUMP-ALL&quot;&gt;Section 25.1.2&lt;/a&gt; for more details. For best results, however, try to use the pg_dumpall command from PostgreSQL 13.1, since this version contains bug fixes and improvements over older versions. While this advice might seem idiosyncratic since you haven't installed the new version yet, it is advisable to follow it if you plan to install the new version in parallel with the old version. In that case you can complete the installation normally and transfer the data later. This will also decrease the downtime.</source>
          <target state="translated">백업을 만들기 위해 현재 실행중인 버전에서 pg_dumpall 명령을 사용할 수 있습니다. 자세한 내용 은 &lt;a href=&quot;backup-dump#BACKUP-DUMP-ALL&quot;&gt;섹션 25.1.2&lt;/a&gt; 를 참조하십시오. 그러나이 버전에는 이전 버전에 비해 버그 수정 및 개선 사항이 포함되어 있으므로 최상의 결과를 얻으려면 PostgreSQL 13.1의 pg_dumpall 명령을 사용하십시오. 아직 새 버전을 설치하지 않았기 때문에이 조언이 특이한 것처럼 보일 수 있지만 새 버전을 이전 버전과 병렬로 설치하려는 경우 따르는 것이 좋습니다. 이 경우 정상적으로 설치를 완료하고 나중에 데이터를 전송할 수 있습니다. 이렇게하면 가동 중지 시간도 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="e42d34197cf02a7569c42521d0a78b2a30e87e2d" translate="yes" xml:space="preserve">
          <source>To make these settings persist over reboots, modify &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;.</source>
          <target state="translated">재부팅시에도 이러한 설정을 유지하려면 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec5d47aae5aa8ab0f1d50656eb690fc96ff2b236" translate="yes" xml:space="preserve">
          <source>To make these settings persist over reboots, see &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;.</source>
          <target state="translated">이러한 설정을 재부팅 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 유지하려면 /etc/sysctl.conf를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16fb8688ad143822900835b4d9dfbd8b94a6f1bd" translate="yes" xml:space="preserve">
          <source>To make use of the backup, you will need to keep all the WAL segment files generated during and after the file system backup. To aid you in doing this, the base backup process creates a &lt;em&gt;backup history file&lt;/em&gt; that is immediately stored into the WAL archive area. This file is named after the first WAL segment file that you need for the file system backup. For example, if the starting WAL file is &lt;code&gt;0000000100001234000055CD&lt;/code&gt; the backup history file will be named something like &lt;code&gt;0000000100001234000055CD.007C9330.backup&lt;/code&gt;. (The second part of the file name stands for an exact position within the WAL file, and can ordinarily be ignored.) Once you have safely archived the file system backup and the WAL segment files used during the backup (as specified in the backup history file), all archived WAL segments with names numerically less are no longer needed to recover the file system backup and can be deleted. However, you should consider keeping several backup sets to be absolutely certain that you can recover your data.</source>
          <target state="translated">백업을 사용하려면 파일 시스템 백업 도중 및 이후에 생성 된 모든 WAL 세그먼트 파일을 유지해야합니다. 이를 수행하기 위해 기본 백업 프로세스 는 WAL 아카이브 영역에 즉시 저장 되는 &lt;em&gt;백업 히스토리 파일&lt;/em&gt; 을 작성합니다 . 이 파일은 파일 시스템 백업에 필요한 첫 번째 WAL 세그먼트 파일의 이름을 따서 명명됩니다. 예를 들어, 시작 WAL 파일이 &lt;code&gt;0000000100001234000055CD&lt;/code&gt; 인 경우 백업 기록 파일의 이름은 &lt;code&gt;0000000100001234000055CD.007C9330.backup&lt;/code&gt; 과 같습니다.. (파일 이름의 두 번째 부분은 WAL 파일 내에서 정확한 위치를 나타내며 일반적으로 무시할 수 있습니다.) 백업 중에 사용 된 파일 시스템 백업 및 WAL 세그먼트 파일을 안전하게 보관 한 후 (백업 기록에 지정된대로) 파일), 숫자가 적은 이름으로 보관 된 모든 WAL 세그먼트는 더 이상 파일 시스템 백업을 복구하는 데 필요하지 않으며 삭제할 수 있습니다. 그러나 데이터를 복구 할 수 있도록 여러 백업 세트를 유지하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="837f5c3ebb10e0d282d6e0a633fa9a3ba3bd9b54" translate="yes" xml:space="preserve">
          <source>To make use of this option the server must be built with GSSAPI support. Otherwise, the &lt;code&gt;hostgssenc&lt;/code&gt; record is ignored except for logging a warning that it cannot match any connections.</source>
          <target state="translated">이 옵션을 사용하려면 서버가 GSSAPI 지원으로 구축되어야합니다. 그렇지 않으면 &lt;code&gt;hostgssenc&lt;/code&gt; 레코드는 연결과 일치 할 수 없다는 경고를 기록하는 것을 제외하고는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="da85971aae5c8da752be674039f1e182750b7050" translate="yes" xml:space="preserve">
          <source>To make use of this option the server must be built with SSL support. Furthermore, SSL must be enabled by setting the &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; configuration parameter (see &lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt; for more information). Otherwise, the &lt;code&gt;hostssl&lt;/code&gt; record is ignored except for logging a warning that it cannot match any connections.</source>
          <target state="translated">이 옵션을 사용하려면 서버를 SSL 지원으로 빌드해야합니다. 또한 &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;SSL&lt;/a&gt; 구성 매개 변수 를 설정하여 SSL을 사용 가능하게해야합니다 ( 자세한 정보는 &lt;a href=&quot;ssl-tcp&quot;&gt;18.9 절&lt;/a&gt; 참조 ). 그렇지 않으면 &lt;code&gt;hostssl&lt;/code&gt; 레코드는 연결과 일치 할 수 없다는 경고를 기록하는 것을 제외하고는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3f4fbb22a44e979c8471b584d8cdd3143713ac75" translate="yes" xml:space="preserve">
          <source>To mark a column as not-null:</source>
          <target state="translated">열을 널이 아닌 것으로 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f74bd55605f3a01ec683a6cc2669467803377606" translate="yes" xml:space="preserve">
          <source>To mark a trigger as being dependent on an extension:</source>
          <target state="translated">트리거를 확장에 종속 된 것으로 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c90682a525c8ca51473c2dabbbd5e3caebbcf407" translate="yes" xml:space="preserve">
          <source>To mark the function &lt;code&gt;sqrt&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; as being dependent on the extension &lt;code&gt;mathlib&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; &lt;code&gt;mathlib&lt;/code&gt; 에 대한 함수 &lt;code&gt;sqrt&lt;/code&gt; 를 확장 mathlib 에 종속되는 것으로 표시하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a87f0d3b5cf6424cb45c1011ca70e93d95e07f0b" translate="yes" xml:space="preserve">
          <source>To mark the procedure &lt;code&gt;insert_data(integer, integer)&lt;/code&gt; as being dependent on the extension &lt;code&gt;myext&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;insert_data(integer, integer)&lt;/code&gt; 프로 시저를 &lt;code&gt;myext&lt;/code&gt; 확장에 종속 된 것으로 표시하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e51d812b2e54f1c7bfb9e394f6c2840143f55cf" translate="yes" xml:space="preserve">
          <source>To match a literal underscore or percent sign without matching other characters, the respective character in &lt;code&gt;pattern&lt;/code&gt; must be preceded by the escape character. The default escape character is the backslash but a different one can be selected by using the &lt;code&gt;ESCAPE&lt;/code&gt; clause. To match the escape character itself, write two escape characters.</source>
          <target state="translated">다른 문자와 일치하지 않고 리터럴 밑줄이나 퍼센트 기호를 일치 시키려면 &lt;code&gt;pattern&lt;/code&gt; 의 각 문자 앞에 이스케이프 문자가 와야합니다. 기본 이스케이프 문자는 백 슬래시이지만 &lt;code&gt;ESCAPE&lt;/code&gt; 절 을 사용하여 다른 문자를 선택할 수 있습니다 . 이스케이프 문자 자체와 일치 시키려면 두 개의 이스케이프 문자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e09584e2c2503d2bf224a496615b4861e94b3c2" translate="yes" xml:space="preserve">
          <source>To move a table to a different schema:</source>
          <target state="translated">테이블을 다른 스키마로 이동하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9d011ac99577ed35b95668f7ed24ce9848185382" translate="yes" xml:space="preserve">
          <source>To move a table to a different tablespace:</source>
          <target state="translated">테이블을 다른 테이블 스페이스로 이동하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="57daeef8cdb28166a441c43e57ab1dd9215bcf07" translate="yes" xml:space="preserve">
          <source>To move an index to a different tablespace:</source>
          <target state="translated">인덱스를 다른 테이블 스페이스로 이동하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="23d5f69d43a2751745b91c696b1be2d6f922bf4b" translate="yes" xml:space="preserve">
          <source>To move the domain into a different schema:</source>
          <target state="translated">도메인을 다른 스키마로 이동하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ea05678bf7924aa16dd7d33be9bf040afd714f48" translate="yes" xml:space="preserve">
          <source>To move the ordered-set aggregate &lt;code&gt;mypercentile&lt;/code&gt; with direct argument of type &lt;code&gt;float8&lt;/code&gt; and aggregated argument of type &lt;code&gt;integer&lt;/code&gt; into schema &lt;code&gt;myschema&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;float8&lt;/code&gt; 유형의 직접 인수 와 &lt;code&gt;integer&lt;/code&gt; 유형의 집계 인수를 사용 하여 정렬 된 집합 &lt;code&gt;mypercentile&lt;/code&gt; 을 스키마 &lt;code&gt;myschema&lt;/code&gt; 로 이동하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4d7dd7e920e4885b23e892227ca575284224505b" translate="yes" xml:space="preserve">
          <source>To organize database objects into logical groups to make them more manageable.</source>
          <target state="translated">데이터베이스 개체를 논리 그룹으로 구성하여 관리하기 쉽도록합니다.</target>
        </trans-unit>
        <trans-unit id="5f2fab70f4674d6404b7fc489c77334e4ba71503" translate="yes" xml:space="preserve">
          <source>To perform a WAL-logged data update using the generic WAL record facility, follow these steps:</source>
          <target state="translated">일반 WAL 레코드 기능을 사용하여 WAL 로깅 데이터 업데이트를 수행하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6ddc039b48dc0b7fc5e1030df7201c9c49ee4806" translate="yes" xml:space="preserve">
          <source>To pick an appropriate iteration count, consider that the original DES crypt was designed to have the speed of 4 hashes per second on the hardware of that time. Slower than 4 hashes per second would probably dampen usability. Faster than 100 hashes per second is probably too fast.</source>
          <target state="translated">적절한 반복 횟수를 선택하려면 원래 DES 암호화가 해당 시간의 하드웨어에서 초당 4 개의 해시 속도를 갖도록 설계되었다는 것을 고려하십시오. 초당 4 해시보다 느리면 사용성이 저하 될 수 있습니다. 초당 100 개보다 빠른 해시는 아마도 너무 빠를 것입니다.</target>
        </trans-unit>
        <trans-unit id="23bef6aee4ed8528c2ee117da497c8f55faa7e35" translate="yes" xml:space="preserve">
          <source>To prepare for remote access using &lt;code&gt;postgres_fdw&lt;/code&gt;:</source>
          <target state="translated">사용하여 원격 액세스를 준비하려면 &lt;code&gt;postgres_fdw&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="3a386c565eb5f05e54673a40938f1d71b0ca70e6" translate="yes" xml:space="preserve">
          <source>To present search results it is ideal to show a part of each document and how it is related to the query. Usually, search engines show fragments of the document with marked search terms. PostgreSQL provides a function &lt;code&gt;ts_headline&lt;/code&gt; that implements this functionality.</source>
          <target state="translated">검색 결과를 표시하려면 각 문서의 일부와 쿼리와의 관련성을 표시하는 것이 이상적입니다. 일반적으로 검색 엔진에는 표시된 검색어가 포함 된 문서 조각이 표시됩니다. PostgreSQL 은이 기능을 구현 하는 &lt;code&gt;ts_headline&lt;/code&gt; 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="91610d07afcd9d2407804f922d11df9315715c95" translate="yes" xml:space="preserve">
          <source>To prevent spoofing on TCP connections, either use SSL certificates and make sure that clients check the server's certificate, or use GSSAPI encryption (or both, if they're on separate connections).</source>
          <target state="translated">TCP 연결에서 스푸핑을 방지하려면 SSL 인증서를 사용하고 클라이언트가 서버의 인증서를 확인하거나 GSSAPI 암호화 (또는 별도의 연결에있는 경우 둘 다)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="42f51c2695b73fa0a4e3d791c3132ceaa8c8104e" translate="yes" xml:space="preserve">
          <source>To prevent spoofing with GSSAPI, the server must be configured to accept only &lt;code&gt;hostgssenc&lt;/code&gt; connections (&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;) and use &lt;code&gt;gss&lt;/code&gt; authentication with them. The TCP client must connect using &lt;code&gt;gssencmode=require&lt;/code&gt;.</source>
          <target state="translated">GSSAPI로 스푸핑을 방지하려면 서버가 &lt;code&gt;hostgssenc&lt;/code&gt; 연결 만 허용하고 ( &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;섹션 20.1&lt;/a&gt; ) &lt;code&gt;gss&lt;/code&gt; 인증을 사용 하도록 서버를 구성해야 합니다. TCP 클라이언트는 &lt;code&gt;gssencmode=require&lt;/code&gt; 를 사용하여 연결해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="a9ff680f80545ba63d8e750795a7c5531ae0e64d" translate="yes" xml:space="preserve">
          <source>To prevent spoofing with SSL, the server must be configured to accept only &lt;code&gt;hostssl&lt;/code&gt; connections (&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;) and have SSL key and certificate files (&lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt;). The TCP client must connect using &lt;code&gt;sslmode=verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt; and have the appropriate root certificate file installed (&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ssl.html#LIBQ-SSL-CERTIFICATES&quot;&gt;Section 33.18.1&lt;/a&gt;).</source>
          <target state="translated">SSL로 스푸핑을 방지하려면 서버가 &lt;code&gt;hostssl&lt;/code&gt; 연결 만 허용하고 ( &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;섹션 20.1&lt;/a&gt; ) SSL 키 및 인증서 파일을 갖도록 구성해야 합니다 ( &lt;a href=&quot;ssl-tcp&quot;&gt;섹션 18.9&lt;/a&gt; ). TCP 클라이언트는 &lt;code&gt;sslmode=verify-ca&lt;/code&gt; 또는 &lt;code&gt;verify-full&lt;/code&gt; 을 사용하여 연결 하고 적절한 루트 인증서 파일이 설치되어 있어야합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ssl.html#LIBQ-SSL-CERTIFICATES&quot;&gt;Section 33.18.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="72a7be887fc7e47acf6f1ec4ef9b556ceb37c5e4" translate="yes" xml:space="preserve">
          <source>To prevent spoofing with SSL, the server must be configured to accept only &lt;code&gt;hostssl&lt;/code&gt; connections (&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;) and have SSL key and certificate files (&lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt;). The TCP client must connect using &lt;code&gt;sslmode=verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt; and have the appropriate root certificate file installed (&lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ssl.html#LIBQ-SSL-CERTIFICATES&quot;&gt;Section 33.18.1&lt;/a&gt;).</source>
          <target state="translated">SSL을 사용한 스푸핑을 방지하려면 &lt;code&gt;hostssl&lt;/code&gt; 연결 만 허용하고 ( &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;섹션 20.1&lt;/a&gt; ) SSL 키 및 인증서 파일 ( &lt;a href=&quot;ssl-tcp&quot;&gt;섹션 18.9&lt;/a&gt; )을 갖도록 서버를 구성해야합니다 . TCP 클라이언트는 &lt;code&gt;sslmode=verify-ca&lt;/code&gt; 또는 &lt;code&gt;verify-full&lt;/code&gt; 을 사용하여 연결 해야하며 적절한 루트 인증서 파일이 설치되어 있어야합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ssl.html#LIBQ-SSL-CERTIFICATES&quot;&gt;섹션 33.18.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc27b676093ff9c2ed0caeb8bb451423cb6132ec" translate="yes" xml:space="preserve">
          <source>To prevent the operation from waiting for other transactions to commit, use either the &lt;code&gt;NOWAIT&lt;/code&gt; or &lt;code&gt;SKIP LOCKED&lt;/code&gt; option. With &lt;code&gt;NOWAIT&lt;/code&gt;, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. With &lt;code&gt;SKIP LOCKED&lt;/code&gt;, any selected rows that cannot be immediately locked are skipped. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue-like table. Note that &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; apply only to the row-level lock(s) &amp;mdash; the required &lt;code&gt;ROW SHARE&lt;/code&gt; table-level lock is still taken in the ordinary way (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;). You can use &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt; with the &lt;code&gt;NOWAIT&lt;/code&gt; option first, if you need to acquire the table-level lock without waiting.</source>
          <target state="translated">조작이 다른 트랜잭션이 커미트되기를 기다리지 못하게하려면 &lt;code&gt;NOWAIT&lt;/code&gt; 또는 &lt;code&gt;SKIP LOCKED&lt;/code&gt; 옵션을 사용하십시오. &lt;code&gt;NOWAIT&lt;/code&gt; 를 사용하면 선택된 행을 즉시 잠글 수없는 경우 명령문은 대기하지 않고 오류를보고합니다. &lt;code&gt;SKIP LOCKED&lt;/code&gt; 를 사용하면 즉시 잠글 수없는 선택된 행을 건너 뜁니다. 잠긴 행을 건너 뛰면 데이터가 일관되지 않으므로 일반 작업에는 적합하지 않지만 대기열과 같은 테이블에 액세스하는 여러 소비자와의 잠금 경합을 피하는 데 사용할 수 있습니다. 참고 &lt;code&gt;NOWAIT&lt;/code&gt; 와 &lt;code&gt;SKIP LOCKED&lt;/code&gt; (들) 행 수준 잠금에만 적용 - 필요한 &lt;code&gt;ROW SHARE&lt;/code&gt; 테이블 레벨 잠금은 여전히 ​​일반적인 방식으로 수행됩니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조 ). 대기하지 않고 테이블 레벨 잠금을 획득해야하는 경우 &lt;code&gt;NOWAIT&lt;/code&gt; 옵션 과 함께 &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt; 을 먼저 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b553159d4136d5984c4e16bd4d3e8a393e646772" translate="yes" xml:space="preserve">
          <source>To prevent the operation from waiting for other transactions to commit, use either the &lt;code&gt;NOWAIT&lt;/code&gt; or &lt;code&gt;SKIP LOCKED&lt;/code&gt; option. With &lt;code&gt;NOWAIT&lt;/code&gt;, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. With &lt;code&gt;SKIP LOCKED&lt;/code&gt;, any selected rows that cannot be immediately locked are skipped. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue-like table. Note that &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; apply only to the row-level lock(s) &amp;mdash; the required &lt;code&gt;ROW SHARE&lt;/code&gt; table-level lock is still taken in the ordinary way (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;). You can use &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt; with the &lt;code&gt;NOWAIT&lt;/code&gt; option first, if you need to acquire the table-level lock without waiting.</source>
          <target state="translated">조작이 다른 트랜잭션이 커미트 될 때까지 대기하지 않도록하려면 &lt;code&gt;NOWAIT&lt;/code&gt; 또는 &lt;code&gt;SKIP LOCKED&lt;/code&gt; 옵션을 사용하십시오. &lt;code&gt;NOWAIT&lt;/code&gt; 를 사용하면 선택한 행을 즉시 잠글 수없는 경우 명령문이 대기하지 않고 오류를보고합니다. &lt;code&gt;SKIP LOCKED&lt;/code&gt; 를 사용하면 즉시 잠글 수없는 선택된 행을 건너 뜁니다. 잠긴 행을 건너 뛰면 데이터에 대한 일관성없는보기가 제공되므로 일반 용도의 작업에는 적합하지 않지만 여러 소비자가 큐와 같은 테이블에 액세스하는 잠금 경합을 방지하는 데 사용할 수 있습니다. 참고 &lt;code&gt;NOWAIT&lt;/code&gt; 와 &lt;code&gt;SKIP LOCKED&lt;/code&gt; (들) 행 수준 잠금에만 적용 - 필요한 &lt;code&gt;ROW SHARE&lt;/code&gt; 테이블 수준 잠금은 여전히 ​​일반적인 방식으로 수행됩니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조 ). 기다리지 않고 테이블 수준 잠금을 획득해야하는 경우 &lt;code&gt;NOWAIT&lt;/code&gt; 옵션 과 함께 &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt; 을 먼저 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fafa62267d5a132b9de46d4638dc16e7682262f" translate="yes" xml:space="preserve">
          <source>To prevent unencrypted passwords from being sent across the network, written to the server log or otherwise stolen by a database administrator, PostgreSQL allows the user to supply pre-encrypted passwords. Many client programs make use of this functionality and encrypt the password before sending it to the server.</source>
          <target state="translated">암호화되지 않은 비밀번호가 네트워크를 통해 전송되거나 서버 로그에 기록되거나 데이터베이스 관리자가 도난 당하지 않도록 PostgreSQL을 통해 사용자는 사전 암호화 된 비밀번호를 제공 할 수 있습니다. 많은 클라이언트 프로그램은이 기능을 사용하고 암호를 서버로 보내기 전에 암호화합니다.</target>
        </trans-unit>
        <trans-unit id="750038db302e8d94eb0a926900beb6c3bdd93c4b" translate="yes" xml:space="preserve">
          <source>To prevent unprivileged users from exploiting the authentication rights of the unix user the postgres server is running as to escalate to superuser rights, only the superuser may set this option on a user mapping.</source>
          <target state="translated">권한이없는 사용자가 수퍼 유저 권한으로 에스컬레이션하기 위해 postgres 서버가 실행중인 유닉스 사용자의 인증 권한을 악용하는 것을 방지하기 위해 수퍼 유저 만 사용자 매핑에서이 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c451daeed477af5e11625a2ad40100dc2bdf1542" translate="yes" xml:space="preserve">
          <source>To print your current working directory, use &lt;code&gt;\! pwd&lt;/code&gt;.</source>
          <target state="translated">현재 작업 디렉토리를 인쇄하려면 &lt;code&gt;\! pwd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a131063e73631c22faf8847eb9eabb84d102d285" translate="yes" xml:space="preserve">
          <source>To process values of data type &lt;code&gt;xml&lt;/code&gt;, PostgreSQL offers the functions &lt;code&gt;xpath&lt;/code&gt; and &lt;code&gt;xpath_exists&lt;/code&gt;, which evaluate XPath 1.0 expressions, and the &lt;code&gt;XMLTABLE&lt;/code&gt; table function.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 유형의 값을 처리하기 위해 PostgreSQL은 XPath 1.0 표현식을 평가하는 &lt;code&gt;xpath&lt;/code&gt; 및 &lt;code&gt;xpath_exists&lt;/code&gt; 함수 와 &lt;code&gt;XMLTABLE&lt;/code&gt; 테이블 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98d5d2d83e0f32f0cf968b16a03133578932bc09" translate="yes" xml:space="preserve">
          <source>To produce a value of type &lt;code&gt;xml&lt;/code&gt; from character data, use the function &lt;code&gt;xmlparse&lt;/code&gt;:</source>
          <target state="translated">문자 데이터에서 &lt;code&gt;xml&lt;/code&gt; 유형의 값을 생성하려면 &lt;code&gt;xmlparse&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbc26abf86484eb02c81e19a75b343ee2d71adcb" translate="yes" xml:space="preserve">
          <source>To protect against loss of very old data due to &lt;em&gt;transaction ID wraparound&lt;/em&gt; or &lt;em&gt;multixact ID wraparound&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;트랜잭션 ID 랩 어라운드&lt;/em&gt; 또는 &lt;em&gt;multixact ID 랩 &lt;/em&gt;&lt;em&gt;어라운드&lt;/em&gt; 로 인한 매우 오래된 데이터의 손실을 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="aecbc3cb94c5315064318106fc3dd71a1faa9ab3" translate="yes" xml:space="preserve">
          <source>To protect password information stored as a user mapping option, the &lt;code&gt;umoptions&lt;/code&gt; column will read as null unless one of the following applies:</source>
          <target state="translated">사용자 매핑 옵션으로 저장된 비밀번호 정보를 보호하기 위해 &lt;code&gt;umoptions&lt;/code&gt; 열은 다음 중 하나가 적용되지 않으면 null로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="51b2cfa383e2f1702167bdd2ca292f075ce10dc7" translate="yes" xml:space="preserve">
          <source>To provide a concrete example, assume that the top node is a &lt;code&gt;MergeJoin&lt;/code&gt; node. Before any merge can be done two rows have to be fetched (one from each subplan). So the executor recursively calls itself to process the subplans (it starts with the subplan attached to &lt;code&gt;lefttree&lt;/code&gt;). The new top node (the top node of the left subplan) is, let's say, a &lt;code&gt;Sort&lt;/code&gt; node and again recursion is needed to obtain an input row. The child node of the &lt;code&gt;Sort&lt;/code&gt; might be a &lt;code&gt;SeqScan&lt;/code&gt; node, representing actual reading of a table. Execution of this node causes the executor to fetch a row from the table and return it up to the calling node. The &lt;code&gt;Sort&lt;/code&gt; node will repeatedly call its child to obtain all the rows to be sorted. When the input is exhausted (as indicated by the child node returning a NULL instead of a row), the &lt;code&gt;Sort&lt;/code&gt; code performs the sort, and finally is able to return its first output row, namely the first one in sorted order. It keeps the remaining rows stored so that it can deliver them in sorted order in response to later demands.</source>
          <target state="translated">구체적인 예를 제공하기 위해 맨 위 노드가 &lt;code&gt;MergeJoin&lt;/code&gt; 노드 라고 가정 하십시오. 병합을 수행하기 전에 두 개의 행을 가져와야합니다 (각 하위 계획에서 하나씩). 집행자가 반복적으로 하위 계획을 처리하기 위해 자신을 호출 그래서 (이 부착 된 하위 계획으로 시작 &lt;code&gt;lefttree&lt;/code&gt; ). 새로운 최상위 노드 (왼쪽 하위 계획의 최상위 노드)는 &lt;code&gt;Sort&lt;/code&gt; 노드이며 다시 입력 행을 얻기 위해 재귀가 필요하다고 가정합니다. &lt;code&gt;Sort&lt;/code&gt; 의 하위 노드 는 테이블의 실제 읽기를 나타내는 &lt;code&gt;SeqScan&lt;/code&gt; 노드 일 수 있습니다 . 이 노드를 실행하면 실행 프로그램이 테이블에서 행을 페치하여 호출 노드로 리턴합니다. &lt;code&gt;Sort&lt;/code&gt; node는 자식을 반복적으로 호출하여 정렬 될 모든 행을 얻습니다. 입력이 소진되면 (자식 노드가 행 대신 NULL을 리턴 함), &lt;code&gt;Sort&lt;/code&gt; 코드 는 정렬을 수행하고 마지막으로 첫 번째 출력 행, 즉 첫 번째 출력 행을 정렬 된 순서로 리턴 할 수 있습니다. 나머지 행을 저장하여 나중에 요구에 따라 정렬 된 순서로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f2f6c60f59be342f296675cbb6d7d227bbb0e5" translate="yes" xml:space="preserve">
          <source>To put our new schema in the path, we use:</source>
          <target state="translated">새로운 스키마를 경로에 넣으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d2ab4b8e95ce2374ac017800199c82360e8ede52" translate="yes" xml:space="preserve">
          <source>To put this together, assume we have tables &lt;code&gt;t1&lt;/code&gt;:</source>
          <target state="translated">이것을 합치려면 테이블 &lt;code&gt;t1&lt;/code&gt; 이 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8f25452daa9e8fa2f75b3821f5a1a4903c6db98" translate="yes" xml:space="preserve">
          <source>To query the current client encoding:</source>
          <target state="translated">현재 클라이언트 인코딩을 쿼리하려면</target>
        </trans-unit>
        <trans-unit id="9cf10f5f8dca749b86d683a9d81cf1278b14624d" translate="yes" xml:space="preserve">
          <source>To quit the session, type EOF (&lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;D&lt;/strong&gt;, usually). If you've entered any text since the last command entry terminator, then EOF will be taken as a command entry terminator, and another EOF will be needed to exit.</source>
          <target state="translated">세션을 종료하려면 EOF ( 보통 &lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;D&lt;/strong&gt; )를 입력하십시오. 마지막 명령 입력 터미네이터 이후에 텍스트를 입력 한 경우 EOF가 명령 입력 터미네이터로 사용되며 다른 EOF가 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d36fa75ce18b12e898c68aa49a95948a9fcf9202" translate="yes" xml:space="preserve">
          <source>To read the data you need to examine each attribute in turn. First check whether the field is NULL according to the null bitmap. If it is, go to the next. Then make sure you have the right alignment. If the field is a fixed width field, then all the bytes are simply placed. If it's a variable length field (attlen = -1) then it's a bit more complicated. All variable-length data types share the common header structure &lt;code&gt;struct varlena&lt;/code&gt;, which includes the total length of the stored value and some flag bits. Depending on the flags, the data can be either inline or in a TOAST table; it might be compressed, too (see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;).</source>
          <target state="translated">데이터를 읽으려면 각 속성을 차례로 검사해야합니다. 먼저 널 비트 맵에 따라 필드가 NULL인지 확인하십시오. 그렇다면 다음으로 이동하십시오. 그런 다음 올바른 정렬 상태인지 확인하십시오. 필드가 고정 너비 필드이면 모든 바이트가 단순히 배치됩니다. 가변 길이 필드 인 경우 (attlen = -1) 조금 더 복잡합니다. 모든 가변 길이 데이터 유형은 공통 헤더 구조 &lt;code&gt;struct varlena&lt;/code&gt; 를 공유합니다 . 여기에는 저장된 값의 총 길이와 일부 플래그 비트가 포함됩니다. 플래그에 따라 데이터는 인라인 또는 TOAST 테이블에있을 수 있습니다. 압축되었을 수도 있습니다 ( &lt;a href=&quot;storage-toast&quot;&gt;68.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f9866d0ae8c9c03df48b8c82014bb3ec303fe38d" translate="yes" xml:space="preserve">
          <source>To recover or reuse disk space occupied by updated or deleted rows.</source>
          <target state="translated">업데이트되거나 삭제 된 행이 차지하는 디스크 공간을 복구하거나 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="0ec6cf49dce03885d6924bd642450bf7ec8ca2bb" translate="yes" xml:space="preserve">
          <source>To recover successfully using continuous archiving (also called &amp;ldquo;online backup&amp;rdquo; by many database vendors), you need a continuous sequence of archived WAL files that extends back at least as far as the start time of your backup. So to get started, you should set up and test your procedure for archiving WAL files &lt;em&gt;before&lt;/em&gt; you take your first base backup. Accordingly, we first discuss the mechanics of archiving WAL files.</source>
          <target state="translated">연속 보관 (많은 데이터베이스 공급 업체의 &quot;온라인 백업&quot;이라고도 함)을 사용하여 성공적으로 복구하려면 최소한 백업 시작 시간까지 확장되는 연속 된 보관 된 WAL 파일 시퀀스가 ​​필요합니다. 따라서 시작하려면 첫 번째 기본 백업을 수행 &lt;em&gt;하기 전에&lt;/em&gt; WAL 파일 보관 절차를 설정하고 테스트해야합니다 . 따라서 먼저 WAL 파일 보관의 메커니즘에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d53b3ac0ed6d158f6c1a488d4a5b85260dfbebb1" translate="yes" xml:space="preserve">
          <source>To recreate a primary key constraint, without blocking updates while the index is rebuilt:</source>
          <target state="translated">인덱스를 다시 작성하는 동안 업데이트를 차단하지 않고 기본 키 제약 조건을 다시 만들려면</target>
        </trans-unit>
        <trans-unit id="f2cdf032afa04bfde3b56e7422c93b52014fb3ad" translate="yes" xml:space="preserve">
          <source>To refer to the JSON data to be queried (the &lt;em&gt;context item&lt;/em&gt;), use the &lt;code&gt;$&lt;/code&gt; sign in the path expression. It can be followed by one or more &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;accessor operators&lt;/a&gt;, which go down the JSON structure level by level to retrieve the content of context item. Each operator that follows deals with the result of the previous evaluation step.</source>
          <target state="translated">쿼리 할 JSON 데이터 ( &lt;em&gt;컨텍스트 항목&lt;/em&gt; ) 를 참조하려면 경로 표현식에서 &lt;code&gt;$&lt;/code&gt; 기호를 사용하십시오 . 그 뒤에 하나 이상의 &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;접근 자 연산자&lt;/a&gt; 가 올 수 있으며 , 컨텍스트 항목의 컨텐츠를 검색하기 위해 레벨별로 JSON 구조를 내려갑니다. 다음에 나오는 각 연산자는 이전 평가 단계의 결과를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="62d35a44cda58220e85434adb6b5a58ad9f84bd9" translate="yes" xml:space="preserve">
          <source>To refer to the JSON value being queried (the &lt;em&gt;context item&lt;/em&gt;), use the &lt;code&gt;$&lt;/code&gt; variable in the path expression. It can be followed by one or more &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;accessor operators&lt;/a&gt;, which go down the JSON structure level by level to retrieve sub-items of the context item. Each operator that follows deals with the result of the previous evaluation step.</source>
          <target state="translated">쿼리되는 JSON 값 ( &lt;em&gt;컨텍스트 항목&lt;/em&gt; ) 을 참조하려면 경로 표현식에서 &lt;code&gt;$&lt;/code&gt; 변수를 사용하십시오 . 그 뒤에는 하나 이상의 &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;접근 자 연산자&lt;/a&gt; 가 올 수 있으며 , 컨텍스트 항목의 하위 항목을 검색하기 위해 수준별로 JSON 구조 수준으로 내려갑니다. 다음 각 연산자는 이전 평가 단계의 결과를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b3f35bb3c3217f63e284e67100cd585c002369af" translate="yes" xml:space="preserve">
          <source>To register a Windows event log library with the operating system, issue this command:</source>
          <target state="translated">운영 체제에 Windows 이벤트 로그 라이브러리를 등록하려면 다음 명령을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="dcb97cb35602cb8d8e37b3f72ca29c284ab19a82" translate="yes" xml:space="preserve">
          <source>To reindex the database &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">데이터베이스 &lt;code&gt;test&lt;/code&gt; 를 다시 색인화하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="138f6f46f9b12919030644b082f862e4465c8a0a" translate="yes" xml:space="preserve">
          <source>To reindex the table &lt;code&gt;foo&lt;/code&gt; and the index &lt;code&gt;bar&lt;/code&gt; in a database named &lt;code&gt;abcd&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;abcd&lt;/code&gt; 라는 데이터베이스에서 테이블 &lt;code&gt;foo&lt;/code&gt; 와 색인 &lt;code&gt;bar&lt;/code&gt; 를 다시 색인화하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5057bddf51642163d4a618fef89da2f20efe141" translate="yes" xml:space="preserve">
          <source>To reload an archive file into a (freshly created) database named &lt;code&gt;newdb&lt;/code&gt;:</source>
          <target state="translated">아카이브 파일을 &lt;code&gt;newdb&lt;/code&gt; 라는 새로 생성 된 데이터베이스에 다시로드하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b7e0dad208d77313671288bf71252a8aeccebaa" translate="yes" xml:space="preserve">
          <source>To reload an archive file into the same database it was dumped from, discarding the current contents of that database:</source>
          <target state="translated">아카이브 된 파일을 덤프 된 동일한 데이터베이스에 다시로드하여 해당 데이터베이스의 현재 컨텐츠를 버립니다.</target>
        </trans-unit>
        <trans-unit id="27e3d3483ae6968cc1f2c3ce744fe6ae6e8dc36d" translate="yes" xml:space="preserve">
          <source>To reload database(s) from this file, you can use:</source>
          <target state="translated">이 파일에서 데이터베이스를 다시로드하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae1f253d1ca56a0ccbe7b45bc0b81811cbddeeaf" translate="yes" xml:space="preserve">
          <source>To reload such a script into a (freshly created) database named &lt;code&gt;newdb&lt;/code&gt;:</source>
          <target state="translated">이러한 스크립트를 &lt;code&gt;newdb&lt;/code&gt; 라는 (새로 생성 된) 데이터베이스에 다시로드하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bddc1307f67d5937507c3936d2f30649aec06219" translate="yes" xml:space="preserve">
          <source>To reload the dump into a new database called &lt;code&gt;newdb&lt;/code&gt;:</source>
          <target state="translated">덤프를 &lt;code&gt;newdb&lt;/code&gt; 라는 새 데이터베이스로 다시로드하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaf515c8d58cd92994dfa8743f12dbbc2da1e757" translate="yes" xml:space="preserve">
          <source>To remove a &lt;code&gt;NOT NULL&lt;/code&gt; constraint from a domain:</source>
          <target state="translated">도메인에서 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건 을 제거하려면</target>
        </trans-unit>
        <trans-unit id="43d57a60bc9ae4720c85f65f48b02b03c6794f87" translate="yes" xml:space="preserve">
          <source>To remove a check constraint from a domain:</source>
          <target state="translated">도메인에서 검사 제한 조건을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9a9e31afd39806417b7470fbbe1579d5f02a99b3" translate="yes" xml:space="preserve">
          <source>To remove a check constraint from a table and all its children:</source>
          <target state="translated">테이블 및 모든 해당 하위에서 점검 제한 조건을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0e497bf41a3189343b6ead8f2d75b97c2d5c2bcf" translate="yes" xml:space="preserve">
          <source>To remove a check constraint from one table only:</source>
          <target state="translated">하나의 테이블에서만 점검 제한 조건을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="828d46eba3a55278c8fef7d5b286efdc8ef06ffe" translate="yes" xml:space="preserve">
          <source>To remove a column, use a command like:</source>
          <target state="translated">열을 제거하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="38b773bd2feefcad9281dad1181f9587cfd50577" translate="yes" xml:space="preserve">
          <source>To remove a constraint you need to know its name. If you gave it a name then that's easy. Otherwise the system assigned a generated name, which you need to find out. The psql command &lt;code&gt;\d tablename&lt;/code&gt; can be helpful here; other interfaces might also provide a way to inspect table details. Then the command is:</source>
          <target state="translated">구속 조건을 제거하려면 해당 이름을 알아야합니다. 당신이 그것에 이름을 주면 그것은 쉽습니다. 그렇지 않으면 시스템이 생성 된 이름을 지정했으며,이를 찾아야합니다. psql 명령 &lt;code&gt;\d tablename&lt;/code&gt; 이 여기서 도움이 될 수 있습니다. 다른 인터페이스는 테이블 세부 사항을 검사하는 방법을 제공 할 수도 있습니다. 그런 다음 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d7bf31a2f8f86534f45191efcc458666b31374c" translate="yes" xml:space="preserve">
          <source>To remove a not-null constraint from a column:</source>
          <target state="translated">열에서 널이 아닌 제한 조건을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4f18a4496457502cea39c274b659cf7a0e3dd2ca" translate="yes" xml:space="preserve">
          <source>To remove an empty tablespace, use the &lt;a href=&quot;sql-droptablespace&quot;&gt;DROP TABLESPACE&lt;/a&gt; command.</source>
          <target state="translated">빈 테이블 스페이스를 제거하려면 &lt;a href=&quot;sql-droptablespace&quot;&gt;DROP TABLESPACE&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d6c89dfb4f37ed7623a88212bd89770872746a5" translate="yes" xml:space="preserve">
          <source>To remove an index, use the &lt;code&gt;DROP INDEX&lt;/code&gt; command. Indexes can be added to and removed from tables at any time.</source>
          <target state="translated">색인을 제거하려면 &lt;code&gt;DROP INDEX&lt;/code&gt; 명령을 사용하십시오 . 언제든지 테이블에 인덱스를 추가하거나 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="863c52a00c465065e0fd5b5b9e4219a452bdd2e6" translate="yes" xml:space="preserve">
          <source>To remove any default value, use:</source>
          <target state="translated">기본값을 제거하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4da4a9003d8a732be59d4e186cdb4572715ec792" translate="yes" xml:space="preserve">
          <source>To remove multiple aggregate functions in one command:</source>
          <target state="translated">하나의 명령으로 여러 집계 함수를 제거하려면</target>
        </trans-unit>
        <trans-unit id="9b21c46be28b23a3a07faf23f47b9607ffc3c2e4" translate="yes" xml:space="preserve">
          <source>To remove old data quickly, simply drop the child table that is no longer necessary:</source>
          <target state="translated">오래된 데이터를 빠르게 제거하려면 더 이상 필요하지 않은 자식 테이블을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="65fd62c46521a14a29fb65a65dedbdfbb6d6b06a" translate="yes" xml:space="preserve">
          <source>To remove schema &lt;code&gt;mystuff&lt;/code&gt; from the database, along with everything it contains:</source>
          <target state="translated">데이터베이스에서 스키마 &lt;code&gt;mystuff&lt;/code&gt; 를 데이터베이스와 함께 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="e78e623783230e4cc0e151a3cb51e4033af11214" translate="yes" xml:space="preserve">
          <source>To remove tablespace &lt;code&gt;mystuff&lt;/code&gt; from the system:</source>
          <target state="translated">시스템에서 테이블 스페이스 &lt;code&gt;mystuff&lt;/code&gt; 를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2a01c776d1c085c3540b493a34415d36ce80315" translate="yes" xml:space="preserve">
          <source>To remove the aggregate function &lt;code&gt;myavg&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형에 대한 집계 함수 &lt;code&gt;myavg&lt;/code&gt; 를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="18432f9ba2212a860ecc264cd27f66a7159842e5" translate="yes" xml:space="preserve">
          <source>To remove the child table from the inheritance hierarchy table but retain access to it as a table in its own right:</source>
          <target state="translated">상속 계층 구조 테이블에서 하위 테이블을 제거하고 자체 테이블에 대한 액세스 권한은 그대로 유지하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="886afd40ec1a253663f53b4cfe1afde02afa622c" translate="yes" xml:space="preserve">
          <source>To remove the data type &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="translated">데이터 유형 &lt;code&gt;box&lt;/code&gt; 를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="635ed4f05863a9f71083e43a22035c0726192374" translate="yes" xml:space="preserve">
          <source>To remove the domain &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="translated">도메인 제거하려면 &lt;code&gt;box&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="82d262101f6ede3cfc7b9b800d5bff7eebc905f2" translate="yes" xml:space="preserve">
          <source>To remove the extension &lt;code&gt;hstore&lt;/code&gt; from the current database:</source>
          <target state="translated">현재 데이터베이스에서 확장 &lt;code&gt;hstore&lt;/code&gt; 를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="494e3e330fb09e7b6316ea0f77db993749794bdb" translate="yes" xml:space="preserve">
          <source>To remove the hypothetical-set aggregate function &lt;code&gt;myrank&lt;/code&gt;, which takes an arbitrary list of ordering columns and a matching list of direct arguments:</source>
          <target state="translated">가정 된 집합 집계 함수 &lt;code&gt;myrank&lt;/code&gt; 를 제거하려면 순서 열의 임의 목록과 일치하는 직접 인수 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cbcb6cb74fb44eda858f0ac7e28a925c61f87522" translate="yes" xml:space="preserve">
          <source>To remove the sequence &lt;code&gt;serial&lt;/code&gt;:</source>
          <target state="translated">시퀀스 &lt;code&gt;serial&lt;/code&gt; 을 제거하려면 :</target>
        </trans-unit>
        <trans-unit id="1b7ff8809c902f7b43d3c36cc0a9d83ff1ce8a61" translate="yes" xml:space="preserve">
          <source>To remove these entries again:</source>
          <target state="translated">이러한 항목을 다시 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4108ee2cc9d5481b40105aec05235dc19894777f" translate="yes" xml:space="preserve">
          <source>To remove user &lt;code&gt;joe&lt;/code&gt; from the default database server:</source>
          <target state="translated">기본 데이터베이스 서버에서 &lt;code&gt;joe&lt;/code&gt; 사용자를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="72cfb1afee008e173ec2d90c24909e8d66dcffdd" translate="yes" xml:space="preserve">
          <source>To remove user &lt;code&gt;joe&lt;/code&gt; using the server on host &lt;code&gt;eden&lt;/code&gt;, port 5000, with verification and a peek at the underlying command:</source>
          <target state="translated">기본 명령에서 확인 및 검사와 함께 호스트 &lt;code&gt;eden&lt;/code&gt; , 포트 5000 의 서버를 사용하여 사용자 &lt;code&gt;joe&lt;/code&gt; 를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="e37544649a72b8a59f8c0b68b1aacebc069fd9f8" translate="yes" xml:space="preserve">
          <source>To rename a check constraint on a domain:</source>
          <target state="translated">도메인에서 검사 제한 조건의 이름을 바꾸려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b83e0f282dba779e1c589b71830e43ea103d9012" translate="yes" xml:space="preserve">
          <source>To rename a column:</source>
          <target state="translated">열 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="b5e5da677db2fffdfcf0e82e91bd6cc552c32de7" translate="yes" xml:space="preserve">
          <source>To rename a data type:</source>
          <target state="translated">데이터 유형의 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="7d71c65ad2b7649e53d418d1384b99760b8cbf7d" translate="yes" xml:space="preserve">
          <source>To rename a table:</source>
          <target state="translated">테이블 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="bebd170e762f96e494ba703054401a1292e6a4cd" translate="yes" xml:space="preserve">
          <source>To rename an enum value:</source>
          <target state="translated">열거 형 값의 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="3d7cb45901b32ab3bbca6ee1b7fd15872ac86082" translate="yes" xml:space="preserve">
          <source>To rename an existing column:</source>
          <target state="translated">기존 열의 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="385765b2179fde3d6b2824f89a1271dbcc7b0710" translate="yes" xml:space="preserve">
          <source>To rename an existing constraint:</source>
          <target state="translated">기존 구속 조건의 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="19c54adeb02c0368e819e3163324f15879d5d129" translate="yes" xml:space="preserve">
          <source>To rename an existing index:</source>
          <target state="translated">기존 색인의 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="14be6b17313dbc046405c1a325a71641d10beb04" translate="yes" xml:space="preserve">
          <source>To rename an existing rule:</source>
          <target state="translated">기존 규칙의 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="56da100cf20dd052a2da93853002e3fdb0762cc7" translate="yes" xml:space="preserve">
          <source>To rename an existing table:</source>
          <target state="translated">기존 테이블의 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="6bbd8f56914d76dfacdfc65adea299ab3845b458" translate="yes" xml:space="preserve">
          <source>To rename an existing trigger:</source>
          <target state="translated">기존 트리거의 이름을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="cdf19eae86ecfc217b5d5f46e0856386ad5eae2f" translate="yes" xml:space="preserve">
          <source>To rename the aggregate function &lt;code&gt;myavg&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;my_average&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형 의 집계 함수 &lt;code&gt;myavg&lt;/code&gt; 를 my_average 로 이름을 바꾸려면 다음 을 &lt;code&gt;my_average&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c57928390ad7de8bef0ca57d35d82c58caddbc" translate="yes" xml:space="preserve">
          <source>To rename the collation &lt;code&gt;de_DE&lt;/code&gt; to &lt;code&gt;german&lt;/code&gt;:</source>
          <target state="translated">데이터 정렬 &lt;code&gt;de_DE&lt;/code&gt; 의 이름 을 &lt;code&gt;german&lt;/code&gt; 바꾸려면 :</target>
        </trans-unit>
        <trans-unit id="a17ea574108719c0205b5d2e7a7cb84dbc9485ae" translate="yes" xml:space="preserve">
          <source>To rename the conversion &lt;code&gt;iso_8859_1_to_utf8&lt;/code&gt; to &lt;code&gt;latin1_to_unicode&lt;/code&gt;:</source>
          <target state="translated">변환의 이름을 변경하려면 &lt;code&gt;iso_8859_1_to_utf8&lt;/code&gt; 에 &lt;code&gt;latin1_to_unicode&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="294d57ccf76b0a74a2d7f7f68af3ab1df25411cd" translate="yes" xml:space="preserve">
          <source>To rename the function &lt;code&gt;sqrt&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;square_root&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형의 &lt;code&gt;sqrt&lt;/code&gt; 함수 이름 을 &lt;code&gt;square_root&lt;/code&gt; 로 바꾸려면 다음 을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe4158dd5c515d2058cc9b30dfc63ceb0718218d" translate="yes" xml:space="preserve">
          <source>To rename the materialized view &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">구체화 된 뷰 &lt;code&gt;foo&lt;/code&gt; 의 이름 을 &lt;code&gt;bar&lt;/code&gt; 로 바꾸려면 :</target>
        </trans-unit>
        <trans-unit id="bb76974774fa71ac10b20040500aca23ab2159c9" translate="yes" xml:space="preserve">
          <source>To rename the procedure &lt;code&gt;insert_data&lt;/code&gt; with two arguments of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;insert_record&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;insert_data&lt;/code&gt; 프로 시저의 이름을 &lt;code&gt;integer&lt;/code&gt; 유형의 두 인수 로 &lt;code&gt;insert_record&lt;/code&gt; 로 변경하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f62e25c88ab08cbb7e93b34f512b78b01a264d89" translate="yes" xml:space="preserve">
          <source>To rename the routine &lt;code&gt;foo&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;foobar&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형 의 루틴 &lt;code&gt;foo&lt;/code&gt; 를 &lt;code&gt;foobar&lt;/code&gt; 로 이름을 바꾸려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1263372069e771787275bba5c32ba81c76bacbb" translate="yes" xml:space="preserve">
          <source>To rename the view &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">뷰 &lt;code&gt;foo&lt;/code&gt; 의 이름 을 &lt;code&gt;bar&lt;/code&gt; 로 바꾸려면 :</target>
        </trans-unit>
        <trans-unit id="26bdd6f1e45a99315aafab5faba4caedc29cd14b" translate="yes" xml:space="preserve">
          <source>To reorder database items, it is first necessary to dump the table of contents of the archive:</source>
          <target state="translated">데이터베이스 항목을 재정렬하려면 먼저 아카이브의 목차를 덤프해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e91986eabef2675111d76504a2dca941d4323fb" translate="yes" xml:space="preserve">
          <source>To replace the current definition of an existing function, use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;. It is not possible to change the name or argument types of a function this way (if you tried, you would actually be creating a new, distinct function). Also, &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; will not let you change the return type of an existing function. To do that, you must drop and recreate the function. (When using &lt;code&gt;OUT&lt;/code&gt; parameters, that means you cannot change the types of any &lt;code&gt;OUT&lt;/code&gt; parameters except by dropping the function.)</source>
          <target state="translated">기존 함수의 현재 정의를 바꾸려면 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 을 사용하십시오 . 이 방법으로 함수의 이름 또는 인수 유형을 변경할 수 없습니다 (시도한 경우 실제로 새롭고 고유 한 함수를 작성하게됩니다). 또한 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 을 사용하면 기존 함수의 리턴 유형을 변경할 수 없습니다. 그렇게하려면 함수를 삭제했다가 다시 만들어야합니다. ( &lt;code&gt;OUT&lt;/code&gt; 파라미터를 사용 하는 경우 기능을 삭제 하지 않는 한 &lt;code&gt;OUT&lt;/code&gt; 파라미터 의 유형을 변경할 수 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="e07e56e3dea5794b7967ede7f52d55f75fb914f4" translate="yes" xml:space="preserve">
          <source>To replace the current definition of an existing procedure, use &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt;. It is not possible to change the name or argument types of a procedure this way (if you tried, you would actually be creating a new, distinct procedure).</source>
          <target state="translated">기존 프로 시저의 현재 정의를 바꾸려면 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 를 사용하십시오 . 이런 방식으로 프로 시저의 이름 또는 인수 유형을 변경할 수 없습니다 (시도한 경우 실제로 새롭고 고유 한 프로 시저를 작성하게됩니다).</target>
        </trans-unit>
        <trans-unit id="d4a3314b1af2194d4a9d0e3864d532cddd54f341" translate="yes" xml:space="preserve">
          <source>To represent lexemes containing whitespace or punctuation, surround them with quotes:</source>
          <target state="translated">공백이나 문장 부호가 포함 된 따옴표를 나타내려면 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="e9ee960ea9a62dbb00e555c52be286d5babe0b9b" translate="yes" xml:space="preserve">
          <source>To reproduce the build configuration of the current PostgreSQL installation, run the following command:</source>
          <target state="translated">현재 PostgreSQL 설치의 빌드 구성을 재현하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c852628026196abd448f5bcdf2f61ec1a2440fe6" translate="yes" xml:space="preserve">
          <source>To require the client to supply a trusted certificate, place certificates of the root certificate authorities (CAs) you trust in a file in the data directory, set the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; to the new file name, and add the authentication option &lt;code&gt;clientcert=verify-ca&lt;/code&gt; or &lt;code&gt;clientcert=verify-full&lt;/code&gt; to the appropriate &lt;code&gt;hostssl&lt;/code&gt; line(s) in &lt;code&gt;pg_hba.conf&lt;/code&gt;. A certificate will then be requested from the client during SSL connection startup. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ssl.html&quot;&gt;Section 33.18&lt;/a&gt; for a description of how to set up certificates on the client.)</source>
          <target state="translated">신뢰할 수있는 인증서를 제공하기 위해 클라이언트를 요구하려면, 당신은 데이터 디렉토리에있는 파일을 신뢰 루트 인증 기관 (CA)의 장소 인증서, 파라미터 설정 &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; 에서 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 새 파일 이름을, 인증 옵션 추가 &lt;code&gt;clientcert=verify-ca&lt;/code&gt; 또는 &lt;code&gt;clientcert=verify-full&lt;/code&gt; 해당하는 &lt;code&gt;hostssl&lt;/code&gt; 의 라인 (들)을 &lt;code&gt;pg_hba.conf&lt;/code&gt; . 그런 다음 SSL 연결 시작 중에 클라이언트에서 인증서를 요청합니다. ( 클라이언트에서 인증서를 설정하는 방법에 대한 설명은 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ssl.html&quot;&gt;33.18 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="2089cdf040a512976a9ff54157e13cd1f1bda41c" translate="yes" xml:space="preserve">
          <source>To require the client to supply a trusted certificate, place certificates of the root certificate authorities (CAs) you trust in a file in the data directory, set the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; to the new file name, and add the authentication option &lt;code&gt;clientcert=verify-ca&lt;/code&gt; or &lt;code&gt;clientcert=verify-full&lt;/code&gt; to the appropriate &lt;code&gt;hostssl&lt;/code&gt; line(s) in &lt;code&gt;pg_hba.conf&lt;/code&gt;. A certificate will then be requested from the client during SSL connection startup. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ssl.html&quot;&gt;Section 33.18&lt;/a&gt; for a description of how to set up certificates on the client.)</source>
          <target state="translated">클라이언트가 신뢰할 수있는 인증서를 제공하도록 요구하려면 신뢰할 수있는 루트 CA (인증 기관)의 인증서를 데이터 디렉터리의 파일에 &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;배치&lt;/a&gt; 하고 &lt;code&gt;postgresql.conf&lt;/code&gt; 의ssl_ca_file 매개 변수 를 새 파일 이름으로 설정하고 인증 옵션 &lt;code&gt;clientcert=verify-ca&lt;/code&gt; 추가합니다. = verify-ca 또는 &lt;code&gt;clientcert=verify-full&lt;/code&gt; 을 &lt;code&gt;hostssl&lt;/code&gt; 의 적절한 hostssl 줄에 추가 &lt;code&gt;pg_hba.conf&lt;/code&gt; . 그런 다음 SSL 연결 시작 중에 클라이언트에서 인증서를 요청합니다. ( 클라이언트에서 인증서를 설정하는 방법에 대한 설명은 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ssl.html&quot;&gt;섹션 33.18&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6aa65fcf4333fcf0b551df531e03fa872e27a539" translate="yes" xml:space="preserve">
          <source>To retrieve data from a table, the table is &lt;em&gt;queried&lt;/em&gt;. An SQL &lt;code&gt;SELECT&lt;/code&gt; statement is used to do this. The statement is divided into a select list (the part that lists the columns to be returned), a table list (the part that lists the tables from which to retrieve the data), and an optional qualification (the part that specifies any restrictions). For example, to retrieve all the rows of table &lt;code&gt;weather&lt;/code&gt;, type:</source>
          <target state="translated">테이블에서 데이터를 검색하기 위해 테이블이 &lt;em&gt;쿼리&lt;/em&gt; 됩니다. 이를 위해 SQL &lt;code&gt;SELECT&lt;/code&gt; 문이 사용됩니다. 명령문은 선택 목록 (반환 될 열을 나열하는 부분), 테이블 목록 (데이터를 검색 할 테이블을 나열하는 부분) 및 선택적 규정 (제한을 지정하는 부분)으로 나뉩니다. . 예를 들어, &lt;code&gt;weather&lt;/code&gt; 테이블의 모든 행을 검색하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="7bfba777df1f29aa913bd5d40ce1d4c73c765650" translate="yes" xml:space="preserve">
          <source>To retrieve the available track segments, you need to use the &lt;code&gt;.key&lt;/code&gt; accessor operator for all the preceding JSON objects:</source>
          <target state="translated">사용 가능한 트랙 세그먼트를 검색하려면 앞의 모든 JSON 객체에 &lt;code&gt;.key&lt;/code&gt; 접근 자 연산자 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ae19836eec0ecd61d32d5ba96b2322d307b8b7c9" translate="yes" xml:space="preserve">
          <source>To retrieve the available track segments, you need to use the &lt;code&gt;.key&lt;/code&gt; accessor operator to descend through surrounding JSON objects:</source>
          <target state="translated">사용 가능한 트랙 세그먼트를 검색하려면 &lt;code&gt;.key&lt;/code&gt; 접근 자 연산자를 사용하여 주변 JSON 개체를 통해 내려 가야 합니다.</target>
        </trans-unit>
        <trans-unit id="522d3e3911dd6d630d42f4c9f3f4511ffe28f774" translate="yes" xml:space="preserve">
          <source>To retrieve the contents of an array, you typically use the &lt;code&gt;[*]&lt;/code&gt; operator. For example, the following path will return the location coordinates for all the available track segments:</source>
          <target state="translated">배열의 내용을 검색하려면 일반적으로 &lt;code&gt;[*]&lt;/code&gt; 연산자를 사용합니다 . 예를 들어 다음 경로는 사용 가능한 모든 트랙 세그먼트의 위치 좌표를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb967f785473e839c4078f1c39fcb9477a78913b" translate="yes" xml:space="preserve">
          <source>To return the coordinates of the first segment only, you can specify the corresponding subscript in the &lt;code&gt;[]&lt;/code&gt; accessor operator. Note that the SQL/JSON arrays are 0-relative:</source>
          <target state="translated">첫 번째 세그먼트의 좌표 만 반환하려면 &lt;code&gt;[]&lt;/code&gt; 접근 자 연산자 에서 해당 첨자를 지정할 수 있습니다 . SQL / JSON 배열은 0을 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="2997dac29f70ddf8f3e7c83a1acb7272e5aecc0e" translate="yes" xml:space="preserve">
          <source>To return the coordinates of the first segment only, you can specify the corresponding subscript in the &lt;code&gt;[]&lt;/code&gt; accessor operator. Recall that JSON array indexes are 0-relative:</source>
          <target state="translated">첫 번째 세그먼트의 좌표 만 반환하려면 &lt;code&gt;[]&lt;/code&gt; 접근 자 연산자 에 해당 첨자를 지정할 수 있습니다 . JSON 배열 인덱스는 0에 상대적임을 상기하십시오.</target>
        </trans-unit>
        <trans-unit id="1ff702ac9e947fb4cd3f752235dd9e8f46729035" translate="yes" xml:space="preserve">
          <source>To return to the default encoding:</source>
          <target state="translated">기본 인코딩으로 돌아가려면</target>
        </trans-unit>
        <trans-unit id="39f7eef3c39aee4bb525459a86951007badf6cc0" translate="yes" xml:space="preserve">
          <source>To revoke a previously-granted privilege, use the fittingly named &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; command:</source>
          <target state="translated">이전에 부여 된 권한을 취소하려면 적절하게 명명 된 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="406cc6a0a28c1612b545a71cb3737c23188fdb8b" translate="yes" xml:space="preserve">
          <source>To revoke a privilege, use the fittingly named &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; command:</source>
          <target state="translated">권한을 취소하려면 적절한 이름의 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e18502fe2468ae34b02daa8dc891d75789cf38d6" translate="yes" xml:space="preserve">
          <source>To roll back a prepared transaction, you must be either the same user that executed the transaction originally, or a superuser. But you do not have to be in the same session that executed the transaction.</source>
          <target state="translated">준비된 트랜잭션을 롤백하려면 원래 트랜잭션을 실행 한 동일한 사용자이거나 수퍼 유저 여야합니다. 그러나 트랜잭션을 실행 한 동일한 세션에 있지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="e4ea9597dfb8955018f00e4ee84fd5fc8eae4064" translate="yes" xml:space="preserve">
          <source>To search for a value in an array, each value must be checked. This can be done manually, if you know the size of the array. For example:</source>
          <target state="translated">배열에서 값을 검색하려면 각 값을 확인해야합니다. 어레이의 크기를 알고있는 경우 수동으로 수행 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69b97083ddc183a0945aabca7a025e7b75b30250" translate="yes" xml:space="preserve">
          <source>To send a notification you can also use the function &lt;code&gt;pg_notify(text, text)&lt;/code&gt;. The function takes the channel name as the first argument and the payload as the second. The function is much easier to use than the &lt;code&gt;NOTIFY&lt;/code&gt; command if you need to work with non-constant channel names and payloads.</source>
          <target state="translated">알림을 보내려면 &lt;code&gt;pg_notify(text, text)&lt;/code&gt; 함수를 사용할 수도 있습니다 . 이 함수는 채널 이름을 첫 번째 인수로, 페이로드를 두 번째 인수로 사용합니다. 일정하지 않은 채널 이름과 페이로드로 작업해야하는 경우 &lt;code&gt;NOTIFY&lt;/code&gt; 명령 보다이 기능을 사용하는 것이 훨씬 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="0a86001d56e96cd630855718e6c84e4c20be116d" translate="yes" xml:space="preserve">
          <source>To set a new default for a column, use a command like:</source>
          <target state="translated">열에 대한 새 기본값을 설정하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d61997ef9694eace869cea24bbcc67002c9d4dc7" translate="yes" xml:space="preserve">
          <source>To set a variable, use the psql meta-command &lt;code&gt;\set&lt;/code&gt;. For example,</source>
          <target state="translated">변수를 설정하려면 psql meta-command &lt;code&gt;\set&lt;/code&gt; . 예를 들어</target>
        </trans-unit>
        <trans-unit id="1474ee12a3dc56b938508517724586f81f6e63ce" translate="yes" xml:space="preserve">
          <source>To set an element of an array constant to NULL, write &lt;code&gt;NULL&lt;/code&gt; for the element value. (Any upper- or lower-case variant of &lt;code&gt;NULL&lt;/code&gt; will do.) If you want an actual string value &amp;ldquo;NULL&amp;rdquo;, you must put double quotes around it.</source>
          <target state="translated">배열 상수 의 요소를 &lt;code&gt;NULL&lt;/code&gt; 로 설정하려면 요소 값에 NULL 을 쓰십시오 . (대문자의 대문자 또는 소문자 변형이 가능 &lt;code&gt;NULL&lt;/code&gt; .) 실제 문자열 값&amp;ldquo;NULL&amp;rdquo;을 원하면 큰 따옴표를 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="b72ae8178b03bffc3e97e1ff9f2d6120eb29fe1d" translate="yes" xml:space="preserve">
          <source>To set the transaction isolation level of a transaction, use the command &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">트랜잭션의 트랜잭션 분리 레벨을 설정하려면 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4100879263231dfae5d8c1d12f7f89131b8b4c4d" translate="yes" xml:space="preserve">
          <source>To set up a group role, first create the role:</source>
          <target state="translated">그룹 역할을 설정하려면 먼저 역할을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0840fa596df18f796bffaaea8cb71ad58fdfa8cf" translate="yes" xml:space="preserve">
          <source>To set up the standby server, restore the base backup taken from primary server (see &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;). Create a file &lt;code&gt;standby.signal&lt;/code&gt; in the standby's cluster data directory. Set &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; to a simple command to copy files from the WAL archive. If you plan to have multiple standby servers for high availability purposes, make sure that &lt;code&gt;recovery_target_timeline&lt;/code&gt; is set to &lt;code&gt;latest&lt;/code&gt; (the default), to make the standby server follow the timeline change that occurs at failover to another standby.</source>
          <target state="translated">대기 서버를 설정하려면 기본 서버에서 가져온 기본 백업을 복원하십시오 ( &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;25.3.4 절&lt;/a&gt; 참조 ). 대기의 클러스터 데이터 디렉토리에 &lt;code&gt;standby.signal&lt;/code&gt; 파일을 작성하십시오 . WAL 아카이브에서 파일을 복사하려면 &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 를 간단한 명령으로 설정하십시오 . 고 가용성을 위해 대기 서버를 여러 대 보유하려는 경우 &lt;code&gt;recovery_target_timeline&lt;/code&gt; 을 &lt;code&gt;latest&lt;/code&gt; (기본값)으로 설정하여 대기 서버가 다른 대기로 장애 조치시 발생하는 타임 라인 변경을 따르도록하십시오.</target>
        </trans-unit>
        <trans-unit id="5849cdcb821c47fc2718617bba0084cf85489ef6" translate="yes" xml:space="preserve">
          <source>To show the current search path, use the following command:</source>
          <target state="translated">현재 검색 경로를 표시하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c7b88e1f0fb39dd04eb638f67e6c58bab151183a" translate="yes" xml:space="preserve">
          <source>To show the plan for a simple query on a table with a single &lt;code&gt;integer&lt;/code&gt; column and 10000 rows:</source>
          <target state="translated">단일 &lt;code&gt;integer&lt;/code&gt; 열과 10000 개의 행이 있는 테이블에서 간단한 쿼리 계획을 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="290d88a25608fc889befd23db33e59b88bf74d38" translate="yes" xml:space="preserve">
          <source>To show the space used by TOAST tables, use a query like the following:</source>
          <target state="translated">TOAST 테이블에서 사용 된 공간을 표시하려면 다음과 같은 쿼리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eeb7477a4c4b89c5dfe00ff91f3aab61ad3c8fbd" translate="yes" xml:space="preserve">
          <source>To simplify typing, commands that consists of several words do not have to be quoted. Thus it is fine to type &lt;strong&gt;&lt;code&gt;\help alter table&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">입력을 단순화하기 위해 여러 단어로 구성된 명령을 인용 할 필요가 없습니다. 따라서 &lt;strong&gt; &lt;code&gt;\help alter table&lt;/code&gt; &lt;/strong&gt; 을 입력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a8d550c244dcf6d72fa7225070e337e07ebb8470" translate="yes" xml:space="preserve">
          <source>To solve this performance problem, PostgreSQL supports &lt;em&gt;index-only scans&lt;/em&gt;, which can answer queries from an index alone without any heap access. The basic idea is to return values directly out of each index entry instead of consulting the associated heap entry. There are two fundamental restrictions on when this method can be used:</source>
          <target state="translated">이 성능 문제를 해결하기 위해 PostgreSQL은 &lt;em&gt;인덱스 전용 스캔을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; .이 &lt;em&gt;스캔&lt;/em&gt; 은 힙 액세스없이 인덱스의 쿼리 &lt;em&gt;에만&lt;/em&gt; 응답 할 수 있습니다. 기본 아이디어는 연결된 힙 항목을 참조하는 대신 각 인덱스 항목에서 직접 값을 반환하는 것입니다. 이 방법을 사용할 수있는시기에는 두 가지 기본 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="142d0651fdf015e04d576467b1aca4229d0b4cfb" translate="yes" xml:space="preserve">
          <source>To solve this problem, PostgreSQL allows a transaction to &lt;em&gt;export&lt;/em&gt; the snapshot it is using. As long as the exporting transaction remains open, other transactions can &lt;em&gt;import&lt;/em&gt; its snapshot, and thereby be guaranteed that they see exactly the same view of the database that the first transaction sees. But note that any database changes made by any one of these transactions remain invisible to the other transactions, as is usual for changes made by uncommitted transactions. So the transactions are synchronized with respect to pre-existing data, but act normally for changes they make themselves.</source>
          <target state="translated">이 문제를 해결하기 위해 PostgreSQL은 트랜잭션 이 사용중인 스냅 샷 을 &lt;em&gt;내보내&lt;/em&gt; 도록 허용합니다 . 내보내기 트랜잭션이 열려있는 한 다른 트랜잭션은 스냅 샷을 &lt;em&gt;가져올&lt;/em&gt; 수 있으므로 첫 번째 트랜잭션과 동일한 데이터베이스 뷰를 볼 수 있습니다. 그러나 커밋되지 않은 트랜잭션에 의한 변경과 마찬가지로 이러한 트랜잭션 중 하나에 의해 수행 된 모든 데이터베이스 변경 내용은 다른 트랜잭션에 표시되지 않습니다. 따라서 트랜잭션은 기존 데이터와 관련하여 동기화되지만 변경 내용에 대해서는 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e123382d05d38fbf63b38f935a0571d58e1f08cc" translate="yes" xml:space="preserve">
          <source>To specify a different event source name (see &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt;), use the &lt;code&gt;/n&lt;/code&gt; and &lt;code&gt;/i&lt;/code&gt; options:</source>
          <target state="translated">다른 이벤트 소스 이름 ( &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; 참조 ) 을 지정하려면 &lt;code&gt;/n&lt;/code&gt; 및 &lt;code&gt;/i&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="565b2254b0db4b12b69a3f496fe0855d4e311ee0" translate="yes" xml:space="preserve">
          <source>To specify an upper-case or mixed-case name in &lt;code&gt;-t&lt;/code&gt; and related switches, you need to double-quote the name; else it will be folded to lower case (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt; below). But double quotes are special to the shell, so in turn they must be quoted. Thus, to dump a single table with a mixed-case name, you need something like</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 및 관련 스위치 에 대문자 또는 대소 문자 혼합 이름을 지정하려면 이름 을 큰 따옴표로 묶어야합니다. 그렇지 않으면 소문자로 접 힙니다 (아래 &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; 참조). 그러나 큰 따옴표는 쉘에 특별하므로 차례로 인용해야합니다. 따라서 대소 문자가 혼합 된 이름으로 단일 테이블을 덤프하려면 다음과 같은 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="333792e531c8f32efba6f6ddb4b9558b3b16db75" translate="yes" xml:space="preserve">
          <source>To specify an upper-case or mixed-case name in &lt;code&gt;-t&lt;/code&gt; and related switches, you need to double-quote the name; else it will be folded to lower case (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt;). But double quotes are special to the shell, so in turn they must be quoted. Thus, to dump a single table with a mixed-case name, you need something like</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 및 관련 스위치 에서 대문자 또는 대소 문자 이름을 지정하려면 이름 을 큰 따옴표로 묶어야합니다. 그렇지 않으면 소문자로 접 힙니다 ( &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;패턴&lt;/a&gt; 참조 ). 그러나 큰 따옴표는 쉘에 특별하므로 차례로 따옴표로 묶어야합니다. 따라서 대소 문자가 혼합 된 단일 테이블을 덤프하려면 다음과 같은 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b8a91bc31974f5e5387a73acf127cc171d44ea38" translate="yes" xml:space="preserve">
          <source>To specify which database server pg_dump should contact, use the command line options &lt;code&gt;-h host&lt;/code&gt; and &lt;code&gt;-p port&lt;/code&gt;. The default host is the local host or whatever your &lt;code&gt;PGHOST&lt;/code&gt; environment variable specifies. Similarly, the default port is indicated by the &lt;code&gt;PGPORT&lt;/code&gt; environment variable or, failing that, by the compiled-in default. (Conveniently, the server will normally have the same compiled-in default.)</source>
          <target state="translated">접속할 데이터베이스 서버 pg_dump를 지정하려면 명령 행 옵션 &lt;code&gt;-h host&lt;/code&gt; 및 &lt;code&gt;-p port&lt;/code&gt; 를 사용하십시오 . 기본 호스트는 로컬 호스트이거나 &lt;code&gt;PGHOST&lt;/code&gt; 환경 변수가 지정하는 것입니다. 마찬가지로, 기본 포트는 &lt;code&gt;PGPORT&lt;/code&gt; 환경 변수로 표시되거나 실패한 경우 컴파일 된 기본값으로 표시됩니다. 편리하게도 서버는 일반적으로 컴파일 된 기본값이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b8ff8afd5bb22ed648c2e1e515d2f8e282c556cb" translate="yes" xml:space="preserve">
          <source>To specify which rows are visible or modifiable according to a policy, an expression is required that returns a Boolean result. This expression will be evaluated for each row prior to any conditions or functions coming from the user's query. (The only exceptions to this rule are &lt;code&gt;leakproof&lt;/code&gt; functions, which are guaranteed to not leak information; the optimizer may choose to apply such functions ahead of the row-security check.) Rows for which the expression does not return &lt;code&gt;true&lt;/code&gt; will not be processed. Separate expressions may be specified to provide independent control over the rows which are visible and the rows which are allowed to be modified. Policy expressions are run as part of the query and with the privileges of the user running the query, although security-definer functions can be used to access data not available to the calling user.</source>
          <target state="translated">정책에 따라 표시하거나 수정할 수있는 행을 지정하려면 부울 결과를 반환하는식이 필요합니다. 이 표현식은 사용자의 쿼리에서 오는 조건이나 함수보다 먼저 각 행에 대해 평가됩니다. (이 규칙의 유일한 예외는 누수 &lt;code&gt;leakproof&lt;/code&gt; 기능이며 정보 누출 방지가 보장됩니다. 옵티마이 저는 행 보안 검사 전에 이러한 기능을 적용하도록 선택할 수 있습니다.)식이 &lt;code&gt;true&lt;/code&gt; 를 반환하지 않는 행처리되지 않습니다. 보이는 행과 수정 가능한 행을 독립적으로 제어 할 수 있도록 별도의 표현식을 지정할 수 있습니다. 정책 정의는 쿼리의 일부로, 쿼리를 실행하는 사용자의 권한으로 실행되지만 보안 정의 함수를 사용하여 호출하는 사용자가 사용할 수없는 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d640746b2c70f04616145411ddf1ea54e8f0eff4" translate="yes" xml:space="preserve">
          <source>To start &lt;code&gt;postgres&lt;/code&gt; in the background using default values, type:</source>
          <target state="translated">기본값을 사용하여 백그라운드에서 &lt;code&gt;postgres&lt;/code&gt; 를 시작하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="101c9345ec9b8869dda1a4c2ec2f4ff5869b5099" translate="yes" xml:space="preserve">
          <source>To start &lt;code&gt;postgres&lt;/code&gt; with a specific port, e.g. 1234:</source>
          <target state="translated">특정 포트로 &lt;code&gt;postgres&lt;/code&gt; 를 시작하려면 ( 예 : 1234) :</target>
        </trans-unit>
        <trans-unit id="0d1fa6d44b3018cfb38f5330bc5f7830f724bd55" translate="yes" xml:space="preserve">
          <source>To start &lt;code&gt;postgres&lt;/code&gt; with a specific port, e.g., 1234:</source>
          <target state="translated">특정 포트 (예 : 1234)로 &lt;code&gt;postgres&lt;/code&gt; 를 시작하려면 :</target>
        </trans-unit>
        <trans-unit id="f290a7625948bd090c0e63e75ca4290799de7fe3" translate="yes" xml:space="preserve">
          <source>To start a single-user mode server, use a command like</source>
          <target state="translated">단일 사용자 모드 서버를 시작하려면 다음과 같은 명령을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d719f25eade71e1fabc96df0f987f16d1127fb5e" translate="yes" xml:space="preserve">
          <source>To start in SSL mode, files containing the server certificate and private key must exist. By default, these files are expected to be named &lt;code&gt;server.crt&lt;/code&gt; and &lt;code&gt;server.key&lt;/code&gt;, respectively, in the server's data directory, but other names and locations can be specified using the configuration parameters &lt;a href=&quot;runtime-config-connection#GUC-SSL-CERT-FILE&quot;&gt;ssl_cert_file&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-SSL-KEY-FILE&quot;&gt;ssl_key_file&lt;/a&gt;.</source>
          <target state="translated">SSL 모드에서 시작하려면 서버 인증서 및 개인 키가 포함 된 파일이 있어야합니다. 기본적으로 이러한 파일은 서버의 데이터 디렉토리에서 각각 &lt;code&gt;server.crt&lt;/code&gt; 및 &lt;code&gt;server.key&lt;/code&gt; 로 이름이 지정되지만 구성 매개 변수 &lt;a href=&quot;runtime-config-connection#GUC-SSL-CERT-FILE&quot;&gt;ssl_cert_file&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-connection#GUC-SSL-KEY-FILE&quot;&gt;ssl_key_file을&lt;/a&gt; 사용하여 다른 이름 및 위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d7e48565791a62e0096773265d70badc454279d" translate="yes" xml:space="preserve">
          <source>To start the server in standby mode, create a file called &lt;code&gt;standby.signal&lt;/code&gt; in the data directory. The server will enter recovery and will not stop recovery when the end of archived WAL is reached, but will keep trying to continue recovery by connecting to the sending server as specified by the &lt;code&gt;primary_conninfo&lt;/code&gt; setting and/or by fetching new WAL segments using &lt;code&gt;restore_command&lt;/code&gt;. For this mode, the parameters from this section and &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-STANDBY&quot;&gt;Section 19.6.3&lt;/a&gt; are of interest. Parameters from &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;Section 19.5.5&lt;/a&gt; will also be applied but are typically not useful in this mode.</source>
          <target state="translated">대기 모드에서 서버를 시작하려면 데이터 디렉토리에 &lt;code&gt;standby.signal&lt;/code&gt; 이라는 파일을 작성하십시오 . 서버는 복구를 시작하고 아카이브 된 WAL의 끝에 도달하면 복구를 중지하지 않지만 &lt;code&gt;primary_conninfo&lt;/code&gt; 설정에 지정된대로 송신 서버에 연결 하거나 &lt;code&gt;restore_command&lt;/code&gt; 를 사용하여 새 WAL 세그먼트를 페치 하여 복구를 계속 시도합니다 . 이 모드의 경우이 섹션과 &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-STANDBY&quot;&gt;19.6.3&lt;/a&gt; 섹션의 매개 변수 가 중요합니다. &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;섹션 19.5.5의&lt;/a&gt; 파라미터 도 적용되지만이 모드에서는 일반적으로 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58559fc6e49f271c8ef253d540e88016fc097dd2" translate="yes" xml:space="preserve">
          <source>To start the server in targeted recovery mode, create a file called &lt;code&gt;recovery.signal&lt;/code&gt; in the data directory. If both &lt;code&gt;standby.signal&lt;/code&gt; and &lt;code&gt;recovery.signal&lt;/code&gt; files are created, standby mode takes precedence. Targeted recovery mode ends when the archived WAL is fully replayed, or when &lt;code&gt;recovery_target&lt;/code&gt; is reached. In this mode, the parameters from both this section and &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;Section 19.5.5&lt;/a&gt; will be used.</source>
          <target state="translated">대상 복구 모드에서 서버를 시작하려면 데이터 디렉토리에 &lt;code&gt;recovery.signal&lt;/code&gt; 이라는 파일을 작성하십시오 . 두 경우 &lt;code&gt;standby.signal&lt;/code&gt; 및 &lt;code&gt;recovery.signal&lt;/code&gt; 파일이 생성, 대기 모드가 우선합니다. 아카이브 된 WAL이 완전히 재생되거나 &lt;code&gt;recovery_target&lt;/code&gt; 에 도달 하면 대상 복구 모드가 종료됩니다 . 이 모드에서는이 섹션과 &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;19.5.5&lt;/a&gt; 섹션의 매개 변수 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d341372ce0cfe667939ee30d204c0837e61558e" translate="yes" xml:space="preserve">
          <source>To start the server using port 5433, and running without &lt;code&gt;fsync&lt;/code&gt;, use:</source>
          <target state="translated">포트 5433을 사용하고 &lt;code&gt;fsync&lt;/code&gt; 없이 실행하여 서버를 시작하려면 하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="741786fb73cdee8a94bd2c27689a09674c4f86b0" translate="yes" xml:space="preserve">
          <source>To start the server, waiting until the server is accepting connections:</source>
          <target state="translated">서버가 연결을 수락 할 때까지 서버를 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e232c4fd74a8cef6ce964e0f028fd1b8e4b0c9b" translate="yes" xml:space="preserve">
          <source>To stop the server, use:</source>
          <target state="translated">서버를 중지하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e14a268ee248e30a81dcc736a7cb520ff381afb" translate="yes" xml:space="preserve">
          <source>To stream the write-ahead log from the server at &lt;code&gt;mydbserver&lt;/code&gt; and store it in the local directory &lt;code&gt;/usr/local/pgsql/archive&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mydbserver&lt;/code&gt; 의 서버에서 미리 쓰기 로그를 스트리밍하여 로컬 디렉토리 &lt;code&gt;/usr/local/pgsql/archive&lt;/code&gt; 에 저장하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0c30744e41f4e0393724c62af8eb916c4e9f5d86" translate="yes" xml:space="preserve">
          <source>To sum the column &lt;code&gt;len&lt;/code&gt; of all films and group the results by &lt;code&gt;kind&lt;/code&gt;:</source>
          <target state="translated">모든 영화 의 열 &lt;code&gt;len&lt;/code&gt; 을 합산하고 결과를 &lt;code&gt;kind&lt;/code&gt; 그룹화 .</target>
        </trans-unit>
        <trans-unit id="a6a50b5a600cffd4f7b634f4dde62436d9843ce3" translate="yes" xml:space="preserve">
          <source>To sum the column &lt;code&gt;len&lt;/code&gt; of all films, group the results by &lt;code&gt;kind&lt;/code&gt; and show those group totals that are less than 5 hours:</source>
          <target state="translated">모든 영화 의 열 &lt;code&gt;len&lt;/code&gt; 을 합치려면 결과를 &lt;code&gt;kind&lt;/code&gt; 그룹화하십시오. 5 시간 미만의 그룹 총계를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="1a9fccec8e53d2c310f94aa58faf4ad93d29d232" translate="yes" xml:space="preserve">
          <source>To support &amp;ldquo;partial match&amp;rdquo; queries, an operator class must provide the &lt;code&gt;comparePartial&lt;/code&gt; method, and its &lt;code&gt;extractQuery&lt;/code&gt; method must set the &lt;code&gt;pmatch&lt;/code&gt; parameter when a partial-match query is encountered. See &lt;a href=&quot;gin-implementation#GIN-PARTIAL-MATCH&quot;&gt;Section 66.4.2&lt;/a&gt; for details.</source>
          <target state="translated">&quot;부분 일치&quot;쿼리를 지원하려면 연산자 클래스가 &lt;code&gt;comparePartial&lt;/code&gt; 메서드를 제공해야 하며 &lt;code&gt;extractQuery&lt;/code&gt; 메서드는 부분 일치 쿼리가 발생할 때 &lt;code&gt;pmatch&lt;/code&gt; 매개 변수를 설정해야합니다 . &lt;a href=&quot;gin-implementation#GIN-PARTIAL-MATCH&quot;&gt;섹션 66.4.2&lt;/a&gt; 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aca3788124b57b993c2721a04dc97e7cfe9aa1d6" translate="yes" xml:space="preserve">
          <source>To support matching of rows which include elements without a default B-tree operator class, the following operators are defined for composite type comparison: &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;*&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;*&amp;lt;&lt;/code&gt;, &lt;code&gt;*&amp;lt;=&lt;/code&gt;, &lt;code&gt;*&amp;gt;&lt;/code&gt;, and &lt;code&gt;*&amp;gt;=&lt;/code&gt;. These operators compare the internal binary representation of the two rows. Two rows might have a different binary representation even though comparisons of the two rows with the equality operator is true. The ordering of rows under these comparison operators is deterministic but not otherwise meaningful. These operators are used internally for materialized views and might be useful for other specialized purposes such as replication and B-Tree deduplication (see &lt;a href=&quot;btree-implementation#BTREE-DEDUPLICATION&quot;&gt;Section 63.4.2&lt;/a&gt;). They are not intended to be generally useful for writing queries, though.</source>
          <target state="translated">기본 B- 트리 연산자 클래스가없는 요소를 포함하는 행의 일치를 지원하기 위해 복합 유형 비교를 위해 &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;*&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;*&amp;lt;&lt;/code&gt; , &lt;code&gt;*&amp;lt;=&lt;/code&gt; , &lt;code&gt;*&amp;gt;&lt;/code&gt; 및 &lt;code&gt;*&amp;gt;=&lt;/code&gt; 연산자가 정의됩니다 . 이 연산자는 두 행의 내부 이진 표현을 비교합니다. 같음 연산자를 사용한 두 행의 비교가 참인 경우에도 두 행은 다른 이진 표현을 가질 수 있습니다. 이러한 비교 연산자 아래의 행 순서는 결정적이지만 다른 의미는 없습니다. 이러한 연산자는 구체화 된 뷰를 위해 내부적으로 사용되며 복제 및 B- 트리 중복 제거와 같은 기타 특수 목적에 유용 할 수 있습니다 ( &lt;a href=&quot;btree-implementation#BTREE-DEDUPLICATION&quot;&gt;섹션 63.4.2&lt;/a&gt; 참조).). 그러나 일반적으로 쿼리 작성에 유용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c766280bc71ea6c99fe469d91b62dcecd981191" translate="yes" xml:space="preserve">
          <source>To support matching of rows which include elements without a default B-tree operator class, the following operators are defined for composite type comparison: &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;*&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;*&amp;lt;&lt;/code&gt;, &lt;code&gt;*&amp;lt;=&lt;/code&gt;, &lt;code&gt;*&amp;gt;&lt;/code&gt;, and &lt;code&gt;*&amp;gt;=&lt;/code&gt;. These operators compare the internal binary representation of the two rows. Two rows might have a different binary representation even though comparisons of the two rows with the equality operator is true. The ordering of rows under these comparison operators is deterministic but not otherwise meaningful. These operators are used internally for materialized views and might be useful for other specialized purposes such as replication but are not intended to be generally useful for writing queries.</source>
          <target state="translated">기본 B- 트리 연산자 클래스가없는 요소를 포함하는 행의 일치를 지원하기 위해 복합 유형 비교를 위해 &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;*&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;*&amp;lt;&lt;/code&gt; , &lt;code&gt;*&amp;lt;=&lt;/code&gt; , &lt;code&gt;*&amp;gt;&lt;/code&gt; 및 &lt;code&gt;*&amp;gt;=&lt;/code&gt; 연산자가 정의됩니다 . 이 연산자는 두 행의 내부 이진 표현을 비교합니다. 항등 연산자를 사용한 두 행의 비교가 참이더라도 두 행은 서로 다른 이진 표현을 가질 수 있습니다. 이러한 비교 연산자에서 행의 순서는 결정적이지만 다른 의미는 없습니다. 이 연산자는 구체화 된 뷰에 내부적으로 사용되며 복제와 같은 다른 특수 목적에는 유용하지만 일반적으로 쿼리 작성에는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78257dbeaf1e3faf2c5d4978a0aec796a742cc0e" translate="yes" xml:space="preserve">
          <source>To terminate an individual session while allowing other sessions to continue, use &lt;code&gt;pg_terminate_backend()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.83&lt;/a&gt;) or send a SIGTERM signal to the child process associated with the session.</source>
          <target state="translated">다른 세션을 계속하면서 개별 세션을 종료하려면 &lt;code&gt;pg_terminate_backend()&lt;/code&gt; ( &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;표 9.83&lt;/a&gt; 참조 )를 사용하거나 세션과 연관된 하위 프로세스로 SIGTERM 신호를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="7094d9589b47d1412c9f6e48415db4d099361388" translate="yes" xml:space="preserve">
          <source>To terminate an individual session while allowing other sessions to continue, use &lt;code&gt;pg_terminate_backend()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.84&lt;/a&gt;) or send a SIGTERM signal to the child process associated with the session.</source>
          <target state="translated">다른 세션이 계속되도록 허용하면서 개별 세션을 종료하려면 &lt;code&gt;pg_terminate_backend()&lt;/code&gt; ( &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;표 9.84&lt;/a&gt; 참조 )를 사용하거나 세션과 관련된 자식 프로세스에 SIGTERM 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b948441d5404b9b545e1ffba5fe2679215c93a3d" translate="yes" xml:space="preserve">
          <source>To terminate the &lt;code&gt;postgres&lt;/code&gt; server normally, the signals &lt;code&gt;SIGTERM&lt;/code&gt;, &lt;code&gt;SIGINT&lt;/code&gt;, or &lt;code&gt;SIGQUIT&lt;/code&gt; can be used. The first will wait for all clients to terminate before quitting, the second will forcefully disconnect all clients, and the third will quit immediately without proper shutdown, resulting in a recovery run during restart.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 서버를 정상적으로 종료하기 위해 &lt;code&gt;SIGTERM&lt;/code&gt; , &lt;code&gt;SIGINT&lt;/code&gt; 또는 &lt;code&gt;SIGQUIT&lt;/code&gt; 신호를 사용할 수 있습니다. 첫 번째는 종료하기 전에 모든 클라이언트가 종료 될 때까지 대기하고, 두 번째는 모든 클라이언트를 강제로 연결 해제하며, 세 번째는 적절한 종료없이 즉시 종료되므로 재시작 중에 복구가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bff9e4861d994fa404b9d306224e5e46521976c6" translate="yes" xml:space="preserve">
          <source>To test the dictionary, you can try</source>
          <target state="translated">사전을 테스트하기 위해 시도해 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f7848817fe1c28c6bfbe8e65d2117ae56c0839fe" translate="yes" xml:space="preserve">
          <source>To test the dictionary, you can try:</source>
          <target state="translated">사전을 테스트하려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="c037e68aa2a278c5321043e5bd649588e1ed1409" translate="yes" xml:space="preserve">
          <source>To that end, SQL allows you to define constraints on columns and tables. Constraints give you as much control over the data in your tables as you wish. If a user attempts to store data in a column that would violate a constraint, an error is raised. This applies even if the value came from the default value definition.</source>
          <target state="translated">이를 위해 SQL을 사용하면 열과 테이블에 대한 제약 조건을 정의 할 수 있습니다. 제약 조건을 사용하면 원하는만큼 테이블의 데이터를 많이 제어 할 수 있습니다. 사용자가 제약 조건을 위반하는 열에 데이터를 저장하려고하면 오류가 발생합니다. 이는 값이 기본값 정의에서 나온 경우에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1cc21a302cf460d16fd25ba3a4c82bca11c0140f" translate="yes" xml:space="preserve">
          <source>To the database server it will then look as though you are really user &lt;code&gt;joe&lt;/code&gt; on host &lt;code&gt;foo.com&lt;/code&gt; connecting to &lt;code&gt;localhost&lt;/code&gt; in that context, and it will use whatever authentication procedure was configured for connections from this user and host. Note that the server will not think the connection is SSL-encrypted, since in fact it is not encrypted between the SSH server and the PostgreSQL server. This should not pose any extra security risk as long as they are on the same machine.</source>
          <target state="translated">데이터베이스 서버에서는 마치 해당 컨텍스트에서 &lt;code&gt;localhost&lt;/code&gt; 에 연결하는 호스트 &lt;code&gt;foo.com&lt;/code&gt; 의 사용자 &lt;code&gt;joe&lt;/code&gt; 인 것처럼 보이고이 사용자 및 호스트의 연결에 대해 구성된 인증 절차를 사용합니다. 서버는 실제로 SSH 서버와 PostgreSQL 서버간에 암호화되지 않기 때문에 연결이 SSL로 암호화 된 것으로 생각하지 않습니다. 동일한 시스템에있는 한 추가적인 보안 위험이 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d272ad6e12f47f5e40efbd76a7ae268c798205f5" translate="yes" xml:space="preserve">
          <source>To the database server it will then look as though you are user &lt;code&gt;joe&lt;/code&gt; on host &lt;code&gt;foo.com&lt;/code&gt; connecting to the &lt;code&gt;localhost&lt;/code&gt; bind address, and it will use whatever authentication procedure was configured for connections by that user to that bind address. Note that the server will not think the connection is SSL-encrypted, since in fact it is not encrypted between the SSH server and the PostgreSQL server. This should not pose any extra security risk because they are on the same machine.</source>
          <target state="translated">데이터베이스 서버 에서는 &lt;code&gt;localhost&lt;/code&gt; 바인드 주소에 연결하는 호스트 &lt;code&gt;foo.com&lt;/code&gt; 의 사용자 &lt;code&gt;joe&lt;/code&gt; 인 것처럼 보이며 해당 사용자가 해당 바인드 주소에 연결하도록 구성된 인증 절차를 사용합니다. 실제로 SSH 서버와 PostgreSQL 서버간에 암호화되지 않았기 때문에 서버는 연결이 SSL로 암호화되었다고 생각하지 않습니다. 동일한 시스템에 있기 때문에 추가 보안 위험이 발생해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="27fa29cd778cfa5bac13b40048f336e41ba246ff" translate="yes" xml:space="preserve">
          <source>To track the age of the oldest unfrozen XIDs in a database, &lt;code&gt;VACUUM&lt;/code&gt; stores XID statistics in the system tables &lt;code&gt;pg_class&lt;/code&gt; and &lt;code&gt;pg_database&lt;/code&gt;. In particular, the &lt;code&gt;relfrozenxid&lt;/code&gt; column of a table's &lt;code&gt;pg_class&lt;/code&gt; row contains the freeze cutoff XID that was used by the last aggressive &lt;code&gt;VACUUM&lt;/code&gt; for that table. All rows inserted by transactions with XIDs older than this cutoff XID are guaranteed to have been frozen. Similarly, the &lt;code&gt;datfrozenxid&lt;/code&gt; column of a database's &lt;code&gt;pg_database&lt;/code&gt; row is a lower bound on the unfrozen XIDs appearing in that database &amp;mdash; it is just the minimum of the per-table &lt;code&gt;relfrozenxid&lt;/code&gt; values within the database. A convenient way to examine this information is to execute queries such as:</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 데이터베이스에서 가장 오래된 고정되지 않은 XID의 수명을 추적하기 위해 시스템 테이블 &lt;code&gt;pg_class&lt;/code&gt; 및 &lt;code&gt;pg_database&lt;/code&gt; 에 XID 통계를 저장 합니다. 특히, 테이블의 &lt;code&gt;pg_class&lt;/code&gt; 행 의 &lt;code&gt;relfrozenxid&lt;/code&gt; 열에는 해당 테이블의 마지막 공격적인 &lt;code&gt;VACUUM&lt;/code&gt; 에서 사용 된 동결 컷오프 XID가 포함됩니다 . 이 컷오프 XID보다 오래된 XID가있는 트랜잭션에 의해 삽입 된 모든 행은 고정 된 것입니다. 마찬가지로, &lt;code&gt;datfrozenxid&lt;/code&gt; 데이터베이스의의 열 &lt;code&gt;pg_database&lt;/code&gt; 의 행이 낮은 해당 데이터베이스에 나타나는 고정되지 않은 XID를에 바인딩 된 - 그것은 테이블 당 단지 최소한 &lt;code&gt;relfrozenxid&lt;/code&gt; 데이터베이스 내의 값. 이 정보를 검사하는 편리한 방법은 다음과 같은 쿼리를 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bec719f5a6615a3436f6843fbf1b1db8f209ea62" translate="yes" xml:space="preserve">
          <source>To trigger failover of a log-shipping standby server, run &lt;code&gt;pg_ctl promote&lt;/code&gt;, call &lt;code&gt;pg_promote()&lt;/code&gt;, or create a trigger file with the file name and path specified by the &lt;code&gt;promote_trigger_file&lt;/code&gt;. If you're planning to use &lt;code&gt;pg_ctl promote&lt;/code&gt; or to call &lt;code&gt;pg_promote()&lt;/code&gt; to fail over, &lt;code&gt;promote_trigger_file&lt;/code&gt; is not required. If you're setting up the reporting servers that are only used to offload read-only queries from the primary, not for high availability purposes, you don't need to promote it.</source>
          <target state="translated">로그 전달 대기 서버의 장애 조치를 트리거하려면 &lt;code&gt;pg_ctl promote&lt;/code&gt; 를 실행 하고 &lt;code&gt;pg_promote()&lt;/code&gt; 호출 하거나 &lt;code&gt;promote_trigger_file&lt;/code&gt; 에 지정된 파일 이름 및 경로로 트리거 파일을 생성합니다 . &lt;code&gt;pg_ctl promote&lt;/code&gt; 를 사용 하거나 장애 조치를 위해 &lt;code&gt;pg_promote()&lt;/code&gt; 를 호출 하려는 경우 , &lt;code&gt;promote_trigger_file&lt;/code&gt; 이 필요하지 않습니다. 고 가용성 목적이 아닌 기본 쿼리에서 읽기 전용 쿼리를 오프로드하는 데만 사용되는보고 서버를 설정하는 경우에는 수준을 올릴 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab93659339e52adb4a11b32e33a244aa5b607ece" translate="yes" xml:space="preserve">
          <source>To trigger failover of a log-shipping standby server, run &lt;code&gt;pg_ctl promote&lt;/code&gt;, call &lt;code&gt;pg_promote&lt;/code&gt;, or create a trigger file with the file name and path specified by the &lt;code&gt;promote_trigger_file&lt;/code&gt;. If you're planning to use &lt;code&gt;pg_ctl promote&lt;/code&gt; or to call &lt;code&gt;pg_promote&lt;/code&gt; to fail over, &lt;code&gt;promote_trigger_file&lt;/code&gt; is not required. If you're setting up the reporting servers that are only used to offload read-only queries from the primary, not for high availability purposes, you don't need to promote it.</source>
          <target state="translated">로그 - 출하 대기 서버의 트리거 장애 조치를 실행 &lt;code&gt;pg_ctl promote&lt;/code&gt; , 전화 &lt;code&gt;pg_promote&lt;/code&gt; 를 , 또는 지정된 파일 이름과 경로 트리거 파일 생성 &lt;code&gt;promote_trigger_file&lt;/code&gt; 을 . &lt;code&gt;pg_ctl promote&lt;/code&gt; 를 사용 하거나 &lt;code&gt;pg_promote&lt;/code&gt; 를 호출 하여 장애 조치를 수행 &lt;code&gt;promote_trigger_file&lt;/code&gt; 경우 promote_trigger_file 이 필요하지 않습니다. 고 가용성 목적이 아닌 기본 서버에서 읽기 전용 쿼리를 오프로드하는 데만 사용되는보고 서버를 설정하는 경우이를 승격시킬 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8afd9598c39f6e70f137c025d2dd4395fe84fd38" translate="yes" xml:space="preserve">
          <source>To undo the effects of the commands executed after &lt;code&gt;my_savepoint&lt;/code&gt; was established:</source>
          <target state="translated">&lt;code&gt;my_savepoint&lt;/code&gt; 가 설정된 후 실행 된 명령의 효과를 취소하려면</target>
        </trans-unit>
        <trans-unit id="fdbbd3b7380f7c99f49bcfa3a98c5897db3e04c3" translate="yes" xml:space="preserve">
          <source>To unregister the event log library from the operating system, issue this command:</source>
          <target state="translated">운영 체제에서 이벤트 로그 라이브러리를 등록 취소하려면 다음 명령을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="04ca9b3d12432d00b33dc0196874addb1efae8ee" translate="yes" xml:space="preserve">
          <source>To update data statistics used by the PostgreSQL query planner.</source>
          <target state="translated">PostgreSQL 쿼리 플래너가 사용하는 데이터 통계를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="17b36c6a109313b445886e7e15a5a71d21fc608f" translate="yes" xml:space="preserve">
          <source>To update existing rows, use the &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; command. This requires three pieces of information:</source>
          <target state="translated">기존 행을 업데이트하려면 &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; 명령을 사용하십시오 . 여기에는 세 가지 정보가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bfdb73ad446ce465aedfcde295a04d6e546563ff" translate="yes" xml:space="preserve">
          <source>To update the &lt;code&gt;hstore&lt;/code&gt; extension to version 2.0:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 확장을 버전 2.0으로 업데이트하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5c75aa506204ac6f6a642540af590f22a822261f" translate="yes" xml:space="preserve">
          <source>To update the visibility map, which speeds up &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt;.</source>
          <target state="translated">가시성 맵을 업데이트하여 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;인덱스 전용 스캔&lt;/a&gt; 속도를 높 입니다.</target>
        </trans-unit>
        <trans-unit id="d9d6d4049d4d6f7a80e714c7b5defc7ca6ffbb75" translate="yes" xml:space="preserve">
          <source>To upgrade an existing installation from &lt;code&gt;md5&lt;/code&gt; to &lt;code&gt;scram-sha-256&lt;/code&gt;, after having ensured that all client libraries in use are new enough to support SCRAM, set &lt;code&gt;password_encryption = 'scram-sha-256'&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, make all users set new passwords, and change the authentication method specifications in &lt;code&gt;pg_hba.conf&lt;/code&gt; to &lt;code&gt;scram-sha-256&lt;/code&gt;.</source>
          <target state="translated">기존 설치를 &lt;code&gt;md5&lt;/code&gt; 에서 &lt;code&gt;scram-sha-256&lt;/code&gt; 으로 업그레이드하려면 사용중인 모든 클라이언트 라이브러리가 SCRAM을 지원할만큼 충분히 새로운 지 확인한 후 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;code&gt;password_encryption = 'scram-sha-256'&lt;/code&gt; 을 설정하고 모든 사용자를 새로 설정하십시오. &lt;code&gt;pg_hba.conf&lt;/code&gt; 의 인증 방법 사양 을 &lt;code&gt;scram-sha-256&lt;/code&gt; 으로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c1dafd2ac169280b07d90746edddfeb0fb7e3f0" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;ALTER POLICY&lt;/code&gt;, you must own the table that the policy applies to.</source>
          <target state="translated">&lt;code&gt;ALTER POLICY&lt;/code&gt; 를 사용하려면 정책이 적용되는 테이블을 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f6f185d569782026545f1b03aa2b8da54e54fce" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;ALTER RULE&lt;/code&gt;, you must own the table or view that the rule applies to.</source>
          <target state="translated">&lt;code&gt;ALTER RULE&lt;/code&gt; 을 사용하려면 규칙이 적용되는 테이블 또는 뷰를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="66f7c52e4029da55c8222ce24959b959b971e824" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt;, the user must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server, as well as &lt;code&gt;CREATE&lt;/code&gt; privilege on the target schema.</source>
          <target state="translated">&lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; 를 사용하려면 사용자 에게 외부 스키마에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권 과 대상 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 특권이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="530dbd614178074a579a490a0ab956d80ef8434a" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;ORDINALITY&lt;/code&gt; together with a column definition list, you must use the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax and put the column definition list inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;.</source>
          <target state="translated">사용하기 &lt;code&gt;ORDINALITY&lt;/code&gt; 열 정의 목록과 함께, 당신은 사용해야합니다 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 구문을하고 내부의 열 정의 목록에 넣어 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ca1d65da43222b484ff3cb107702a15116b7a77" translate="yes" xml:space="preserve">
          <source>To use BSD Authentication, the PostgreSQL user account (that is, the operating system user running the server) must first be added to the &lt;code&gt;auth&lt;/code&gt; group. The &lt;code&gt;auth&lt;/code&gt; group exists by default on OpenBSD systems.</source>
          <target state="translated">BSD 인증을 사용하려면 PostgreSQL 사용자 계정 (즉, 서버를 실행하는 운영 체제 사용자)을 먼저 &lt;code&gt;auth&lt;/code&gt; 그룹에 추가해야합니다 . &lt;code&gt;auth&lt;/code&gt; 그룹은 오픈 BSD 시스템에 기본적으로 존재한다.</target>
        </trans-unit>
        <trans-unit id="624d53b3d98397bc183e4f4a83d89ad1b366e0d6" translate="yes" xml:space="preserve">
          <source>To use a different policy for rows that are being added to the table compared to those rows that are visible, multiple policies can be combined. This pair of policies would allow all users to view all rows in the &lt;code&gt;users&lt;/code&gt; table, but only modify their own:</source>
          <target state="translated">표시되는 행과 비교하여 테이블에 추가되는 행에 대해 다른 정책을 사용하기 위해 여러 정책을 결합 할 수 있습니다. 이 정책 쌍을 사용하면 모든 사용자가 &lt;code&gt;users&lt;/code&gt; 테이블의 모든 행을 볼 수 있지만 자신 만 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5918c2e1e45dcb5d119151af6621e2293acc38e" translate="yes" xml:space="preserve">
          <source>To use cascading replication, set up the cascading standby so that it can accept replication connections (that is, set &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;, and configure &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;host-based authentication&lt;/a&gt;). You will also need to set &lt;code&gt;primary_conninfo&lt;/code&gt; in the downstream standby to point to the cascading standby.</source>
          <target state="translated">계단식 복제를 사용하려면 계단식 대기를 설정하여 복제 연결을 수락 할 수 있도록합니다 (즉, &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; 설정 및 &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;호스트 기반 인증&lt;/a&gt; 구성 ). 또한 계단식 대기를 가리 키도록 다운 스트림 대기에서 &lt;code&gt;primary_conninfo&lt;/code&gt; 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="204c9fc68f0716e2f79b30bbdabc1054f228c62c" translate="yes" xml:space="preserve">
          <source>To use colorized output, set the environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; as follows:</source>
          <target state="translated">색상 화 된 출력을 사용하려면 환경 변수 &lt;code&gt;PG_COLOR&lt;/code&gt; 를 다음과 같이 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e28d80b37aa18075f5d4cc483ffa5b0226809b8f" translate="yes" xml:space="preserve">
          <source>To use declarative partitioning in this case, use the following steps:</source>
          <target state="translated">이 경우 선언적 파티셔닝을 사용하려면 다음 단계를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c24fdd930cccd16791dba8614e06b7437b950109" translate="yes" xml:space="preserve">
          <source>To use pg_config, supply one or more of the following options:</source>
          <target state="translated">pg_config를 사용하려면 다음 옵션 중 하나 이상을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="8b164c8911c184b1eed541e609fde5b54cf0537e" translate="yes" xml:space="preserve">
          <source>To use streaming replication, set up a file-based log-shipping standby server as described in &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;. The step that turns a file-based log-shipping standby into streaming replication standby is setting the &lt;code&gt;primary_conninfo&lt;/code&gt; setting to point to the primary server. Set &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt; and authentication options (see &lt;code&gt;pg_hba.conf&lt;/code&gt;) on the primary so that the standby server can connect to the &lt;code&gt;replication&lt;/code&gt; pseudo-database on the primary server (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Section 26.2.5.1&lt;/a&gt;).</source>
          <target state="translated">스트리밍 복제를 사용하려면 &lt;a href=&quot;warm-standby&quot;&gt;26.2 절에&lt;/a&gt; 설명 된대로 파일 기반 로그 전달 대기 서버를 설정하십시오 . 파일 기반 로그 전달 대기를 스트리밍 복제 대기로 전환하는 단계는 &lt;code&gt;primary_conninfo&lt;/code&gt; 설정이 기본 서버를 가리 키도록 설정하는 것입니다. 대기 서버가 기본 서버 의 &lt;code&gt;replication&lt;/code&gt; 의사 데이터베이스에 연결할 수 있도록 기본 서버에서 &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt; 및 인증 옵션 ( &lt;code&gt;pg_hba.conf&lt;/code&gt; 참조 )을 설정 하십시오 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;26.2.5.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d41a57b888d94c07385a12eb346d75263c49a383" translate="yes" xml:space="preserve">
          <source>To use this facility, just write an &lt;code&gt;array_type_oid =&amp;gt; nnnn&lt;/code&gt; metadata field in the scalar type's &lt;code&gt;pg_type&lt;/code&gt; entry, specifying the OID to use for the array type. You may then omit the &lt;code&gt;typarray&lt;/code&gt; field, since it will be filled automatically with that OID.</source>
          <target state="translated">이 기능을 사용하려면 배열 유형에 사용할 OID를 지정하여 스칼라 유형의 &lt;code&gt;pg_type&lt;/code&gt; 항목에 &lt;code&gt;array_type_oid =&amp;gt; nnnn&lt;/code&gt; 메타 데이터 필드를 작성하십시오 . &lt;code&gt;typarray&lt;/code&gt; 필드는 해당 OID로 자동으로 채워 지므로 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed41221f827f590a776bd2d7b32a2a20c13339d7" translate="yes" xml:space="preserve">
          <source>To use this module, you must include &lt;code&gt;sepgsql&lt;/code&gt; in the &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; parameter in &lt;code&gt;postgresql.conf&lt;/code&gt;. The module will not function correctly if loaded in any other manner. Once the module is loaded, you should execute &lt;code&gt;sepgsql.sql&lt;/code&gt; in each database. This will install functions needed for security label management, and assign initial security labels.</source>
          <target state="translated">이 모듈을 사용하려면 &lt;code&gt;postgresql.conf&lt;/code&gt; 의 &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; 매개 변수에 &lt;code&gt;sepgsql&lt;/code&gt; 을 포함 시켜야 합니다 . 다른 방법으로로드하면 모듈이 올바르게 작동하지 않습니다. 모듈이로드되면 각 데이터베이스에서 &lt;code&gt;sepgsql.sql&lt;/code&gt; 을 실행해야 합니다. 보안 레이블 관리에 필요한 기능을 설치하고 초기 보안 레이블을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="5fe488ba1b87ef7cbcb5c901cbf44cb2fcec20d8" translate="yes" xml:space="preserve">
          <source>To use, create a &lt;code&gt;BEFORE INSERT&lt;/code&gt; (or optionally &lt;code&gt;BEFORE INSERT OR UPDATE&lt;/code&gt;) trigger using this function. Specify two trigger arguments: the name of the integer column to be modified, and the name of the sequence object that will supply values. (Actually, you can specify any number of pairs of such names, if you'd like to update more than one autoincrementing column.)</source>
          <target state="translated">사용하려면 이 함수를 사용하여 &lt;code&gt;BEFORE INSERT&lt;/code&gt; (또는 선택적으로 &lt;code&gt;BEFORE INSERT OR UPDATE&lt;/code&gt; ) 트리거를 생성하십시오. 두 개의 트리거 인수 (수정할 정수 열의 이름 및 값을 제공 할 시퀀스 오브젝트의 이름)를 지정하십시오. (실제로, 자동 증분 열을 두 개 이상 업데이트하려면 해당 이름 쌍을 몇 개나 지정할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b06330e3e364688bdf4415b2dee7148b99079ba6" translate="yes" xml:space="preserve">
          <source>To use, create a &lt;code&gt;BEFORE INSERT&lt;/code&gt; and/or &lt;code&gt;UPDATE&lt;/code&gt; trigger using this function. Specify a single trigger argument: the name of the text column to be modified.</source>
          <target state="translated">사용하려면 이 기능을 사용하여 &lt;code&gt;BEFORE INSERT&lt;/code&gt; 및 / 또는 &lt;code&gt;UPDATE&lt;/code&gt; 트리거를 생성하십시오. 단일 트리거 인수 (수정할 텍스트 열의 이름)를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="813ca35a99340fc74c82b99013f68fdb28a1bd3f" translate="yes" xml:space="preserve">
          <source>To use, create a &lt;code&gt;BEFORE UPDATE&lt;/code&gt; trigger using this function. Specify a single trigger argument: the name of the column to be modified. The column must be of type &lt;code&gt;timestamp&lt;/code&gt; or &lt;code&gt;timestamp with time zone&lt;/code&gt;.</source>
          <target state="translated">사용하려면 이 기능을 사용하여 &lt;code&gt;BEFORE UPDATE&lt;/code&gt; 트리거를 작성하십시오 . 단일 트리거 인수 (수정할 열 이름)를 지정하십시오. 열은 &lt;code&gt;timestamp&lt;/code&gt; 또는 &lt;code&gt;timestamp with time zone&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d651aa40a647d96848db306e9d4e53d2fd74d529" translate="yes" xml:space="preserve">
          <source>To vacuum a table, one must ordinarily be the table's owner or a superuser. However, database owners are allowed to vacuum all tables in their databases, except shared catalogs. (The restriction for shared catalogs means that a true database-wide &lt;code&gt;VACUUM&lt;/code&gt; can only be performed by a superuser.) &lt;code&gt;VACUUM&lt;/code&gt; will skip over any tables that the calling user does not have permission to vacuum.</source>
          <target state="translated">테이블을 정리하려면 일반적으로 테이블의 소유자 또는 수퍼 유저 여야합니다. 그러나 데이터베이스 소유자는 공유 카탈로그를 제외하고 데이터베이스의 모든 테이블을 정리할 수 있습니다. 공유 카탈로그에 대한 제한은 실제 데이터베이스 전체 &lt;code&gt;VACUUM&lt;/code&gt; 이 수퍼 유저 만 수행 할 수 있음을 의미합니다 . &lt;code&gt;VACUUM&lt;/code&gt; 은 호출하는 사용자에게 진공 권한이없는 테이블을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="f11c4d150da0b305c6b3a53698ddafc986a15372" translate="yes" xml:space="preserve">
          <source>To verify a backup while ignoring a file that was added manually to the backup directory, and also skipping checksum verification:</source>
          <target state="translated">백업 디렉터리에 수동으로 추가 된 파일을 무시하고 체크섬 확인을 건너 뛰면서 백업을 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="b12aef90b0765da4396291cbd68b40200f811baa" translate="yes" xml:space="preserve">
          <source>To write a composite value as a literal constant, enclose the field values within parentheses and separate them by commas. You can put double quotes around any field value, and must do so if it contains commas or parentheses. (More details appear &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;below&lt;/a&gt;.) Thus, the general format of a composite constant is the following:</source>
          <target state="translated">복합 값을 리터럴 상수로 쓰려면 필드 값을 괄호로 묶고 쉼표로 구분하십시오. 필드 값을 큰 따옴표로 묶을 수 있으며 쉼표 나 괄호가 포함 된 경우 큰 따옴표를 사용해야합니다. (자세한 내용은 &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;아래에 나와 있습니다&lt;/a&gt; .) 따라서 복합 상수의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36be791e0428b306325653957972a9f27bc7282d" translate="yes" xml:space="preserve">
          <source>To write an array value as a literal constant, enclose the element values within curly braces and separate them by commas. (If you know C, this is not unlike the C syntax for initializing structures.) You can put double quotes around any element value, and must do so if it contains commas or curly braces. (More details appear below.) Thus, the general format of an array constant is the following:</source>
          <target state="translated">배열 값을 리터럴 상수로 쓰려면 요소 값을 중괄호로 묶고 쉼표로 구분하십시오. (C를 알고 있다면 이것은 구조를 초기화하는 C 구문과 다릅니다.) 요소 값을 큰 따옴표로 묶을 수 있으며 쉼표 나 중괄호가 포함 된 경우 따옴표를 사용해야합니다. (자세한 내용은 아래에 나와 있습니다.) 따라서 배열 상수의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1573410db1a5214d17bb9421a6156f411884884" translate="yes" xml:space="preserve">
          <source>To write an operator class for a complex data type which has values included within another type, it's possible to use the inclusion support functions alongside the corresponding operators, as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;Table 67.3&lt;/a&gt;. It requires only a single additional function, which can be written in any language. More functions can be defined for additional functionality. All operators are optional. Some operators require other operators, as shown as dependencies on the table.</source>
          <target state="translated">다른 유형에 값이 포함 된 복합 데이터 유형에 대한 연산자 클래스를 작성하려면 &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;표 67.3에&lt;/a&gt; 표시된대로 해당 연산자와 함께 포함 지원 기능을 사용할 수 있습니다 . 모든 언어로 작성할 수있는 단일 추가 기능 만 필요합니다. 추가 기능을 위해 더 많은 기능을 정의 할 수 있습니다. 모든 연산자는 선택 사항입니다. 테이블에 대한 종속성으로 표시된 것처럼 일부 연산자에는 다른 연산자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c41930744b3f03d751f8aa722eaefe121e7c4135" translate="yes" xml:space="preserve">
          <source>To write an operator class for a data type that implements a totally ordered set, it is possible to use the minmax support functions alongside the corresponding operators, as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-MINMAX-TABLE&quot;&gt;Table 67.2&lt;/a&gt;. All operator class members (functions and operators) are mandatory.</source>
          <target state="translated">완전히 정렬 된 세트를 구현하는 데이터 유형에 대한 연산자 클래스를 작성하려면 &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-MINMAX-TABLE&quot;&gt;표 67.2에&lt;/a&gt; 표시된대로 해당 연산자와 함께 minmax 지원 기능을 사용할 수 있습니다 . 모든 연산자 클래스 멤버 (함수 및 연산자)는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="d4a3b1136e1641950f065b8d855140afc16cbb62" translate="yes" xml:space="preserve">
          <source>Toggles the display of output column name headings and row count footer. This command is equivalent to &lt;code&gt;\pset tuples_only&lt;/code&gt; and is provided for convenience.</source>
          <target state="translated">출력 열 이름 표제 및 행 수 바닥 글 표시를 토글합니다. 이 명령은 &lt;code&gt;\pset tuples_only&lt;/code&gt; 와 동일 하며 편의를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="db8eba10da49a68fddbc05012de430b49248b9b2" translate="yes" xml:space="preserve">
          <source>Tokens such as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; in the example above are examples of &lt;em&gt;key words&lt;/em&gt;, that is, words that have a fixed meaning in the SQL language. The tokens &lt;code&gt;MY_TABLE&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are examples of &lt;em&gt;identifiers&lt;/em&gt;. They identify names of tables, columns, or other database objects, depending on the command they are used in. Therefore they are sometimes simply called &amp;ldquo;names&amp;rdquo;. Key words and identifiers have the same lexical structure, meaning that one cannot know whether a token is an identifier or a key word without knowing the language. A complete list of key words can be found in &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;.</source>
          <target state="translated">위 예에서 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;VALUES&lt;/code&gt; 와 같은 토큰 은 &lt;em&gt;키워드의&lt;/em&gt; 예입니다. &lt;em&gt;즉&lt;/em&gt; , SQL 언어에서 고정 된 의미를 갖는 단어입니다. &lt;code&gt;MY_TABLE&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; 토큰 은 &lt;em&gt;식별자의&lt;/em&gt; 예입니다 . 이들은 사용되는 명령에 따라 테이블, 열 또는 기타 데이터베이스 개체의 이름을 식별합니다. 따라서 때때로 &quot;이름&quot;이라고도합니다. 키워드와 식별자는 어휘 구조가 동일하므로 언어를 몰라도 토큰이 식별자인지 키워드인지 알 수 없습니다. 키워드의 전체 목록은 &lt;a href=&quot;sql-keywords-appendix&quot;&gt;부록 C&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fdf6469a5fdbc62b046cf253917814a2537bbac" translate="yes" xml:space="preserve">
          <source>Too large or small integer and double constants, as well as integer arithmetic operators (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;) raise errors on overflows.</source>
          <target state="translated">정수 산술 연산자 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; ) 는 오버플로시 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d299b72cc8e4fe0852effc6e9ba7475bfceb97f7" translate="yes" xml:space="preserve">
          <source>Top-level transaction identifier of this backend, if any.</source>
          <target state="translated">이 백엔드의 최상위 트랜잭션 식별자입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="a230feca93e9b8afbf572850a80bd7ee57cef2d3" translate="yes" xml:space="preserve">
          <source>Total amount of WAL bytes generated by the statement</source>
          <target state="translated">문에 의해 생성 된 총 WAL 바이트 양</target>
        </trans-unit>
        <trans-unit id="d83687b2ce879fb045fc3cb3c8969197fea57f55" translate="yes" xml:space="preserve">
          <source>Total amount of data that will be streamed. This is estimated and reported as of the beginning of &lt;code&gt;streaming database files&lt;/code&gt; phase. Note that this is only an approximation since the database may change during &lt;code&gt;streaming database files&lt;/code&gt; phase and WAL log may be included in the backup later. This is always the same value as &lt;code&gt;backup_streamed&lt;/code&gt; once the amount of data streamed exceeds the estimated total size. If the estimation is disabled in pg_basebackup (i.e., &lt;code&gt;--no-estimate-size&lt;/code&gt; option is specified), this is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">스트리밍 될 총 데이터 양입니다. 이것은 &lt;code&gt;streaming database files&lt;/code&gt; 단계 의 시작 시점에 추정되고보고됩니다 . 이는 데이터베이스가 &lt;code&gt;streaming database files&lt;/code&gt; 단계에서 변경 될 수 있고 WAL 로그가 나중에 백업에 포함될 수 있기 때문에 이는 근사치 일뿐 입니다. 스트리밍되는 데이터 양이 예상 총 크기를 초과하면 이는 항상 &lt;code&gt;backup_streamed&lt;/code&gt; 와 동일한 값 입니다. pg_basebackup에서 추정이 비활성화 된 경우 (즉, &lt;code&gt;--no-estimate-size&lt;/code&gt; 옵션이 지정됨) 이는 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b94a11c6c4384bcb235fe450b134cbeae2334827" translate="yes" xml:space="preserve">
          <source>Total amount of data written to temporary files by queries in this database. All temporary files are counted, regardless of why the temporary file was created, and regardless of the &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; setting.</source>
          <target state="translated">이 데이터베이스의 쿼리로 임시 파일에 기록 된 총 데이터 양입니다. 임시 파일이 작성된 이유 및 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files에&lt;/a&gt; 관계없이 모든 임시 파일이 계산됩니다. 설정에 .</target>
        </trans-unit>
        <trans-unit id="048f9cb0c1fef49da291331aa694810bbf7c5eaf" translate="yes" xml:space="preserve">
          <source>Total amount of shared memory available (bytes or pages)</source>
          <target state="translated">사용 가능한 총 공유 메모리 양 (바이트 또는 페이지)</target>
        </trans-unit>
        <trans-unit id="c89a5c064950bd223dd4b0d4940f5906ef93b42c" translate="yes" xml:space="preserve">
          <source>Total amount of time that has been spent in the portion of checkpoint processing where files are synchronized to disk, in milliseconds</source>
          <target state="translated">파일이 디스크에 동기화되는 검사 점 처리 부분에서 소요 된 총 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="3e73c325b1deeb96ed9f601ced16f69bc748b945" translate="yes" xml:space="preserve">
          <source>Total amount of time that has been spent in the portion of checkpoint processing where files are written to disk, in milliseconds</source>
          <target state="translated">파일이 디스크에 기록되는 체크 포인트 처리 부분에서 소요 된 총 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="71415a93ebff8bf2944bf82c235b10d6a4874b3a" translate="yes" xml:space="preserve">
          <source>Total disk space used by indexes attached to the specified table</source>
          <target state="translated">지정된 테이블에 첨부 된 인덱스가 사용하는 총 디스크 공간</target>
        </trans-unit>
        <trans-unit id="a7f95b912814449591b52712042e3e25ade209c4" translate="yes" xml:space="preserve">
          <source>Total disk space used by the specified table, including all indexes and TOAST data</source>
          <target state="translated">모든 인덱스 및 TOAST 데이터를 포함하여 지정된 테이블에서 사용 된 총 디스크 공간</target>
        </trans-unit>
        <trans-unit id="1ee9b213fd39d43e6dff25c490fe089aa0f14ead" translate="yes" xml:space="preserve">
          <source>Total free space in bytes</source>
          <target state="translated">총 여유 공간 (바이트)</target>
        </trans-unit>
        <trans-unit id="57d76893f09fe684f4b71eeb58289be5bae9b545" translate="yes" xml:space="preserve">
          <source>Total free space in bytes (estimated)</source>
          <target state="translated">총 여유 공간 (바이트) (예상)</target>
        </trans-unit>
        <trans-unit id="a1b33dddd9dc06b94a7dc19125345a3ba04c6ba7" translate="yes" xml:space="preserve">
          <source>Total index size in bytes</source>
          <target state="translated">바이트 단위의 총 인덱스 크기</target>
        </trans-unit>
        <trans-unit id="f6e222d69efe669c5fefda27390cf10ca078aa0d" translate="yes" xml:space="preserve">
          <source>Total length of dead tuples in bytes</source>
          <target state="translated">데드 튜플의 총 길이 (바이트)</target>
        </trans-unit>
        <trans-unit id="d6a855ca8640e026c82ad34a21c2afe4864021a0" translate="yes" xml:space="preserve">
          <source>Total length of dead tuples in bytes (exact)</source>
          <target state="translated">데드 튜플의 총 길이 (바이트) (정확한)</target>
        </trans-unit>
        <trans-unit id="998db26f06b8a72881082a9b3df052ec2d49b9d8" translate="yes" xml:space="preserve">
          <source>Total length of live tuples in bytes</source>
          <target state="translated">바이트 단위의 총 라이브 튜플 길이</target>
        </trans-unit>
        <trans-unit id="5de5b16f6d80a5b30ec964c09c76bd5a80231924" translate="yes" xml:space="preserve">
          <source>Total length of live tuples in bytes (estimated)</source>
          <target state="translated">바이트 단위의 총 라이브 튜플 길이 (예상)</target>
        </trans-unit>
        <trans-unit id="6ccd38e7f39b55f68908c8f44a285a49297c5b87" translate="yes" xml:space="preserve">
          <source>Total number of WAL full page images generated by the statement</source>
          <target state="translated">문에 의해 생성 된 총 WAL 전체 페이지 이미지 수</target>
        </trans-unit>
        <trans-unit id="d1b5a1338a4346cf6785e1053f9330facfc3876a" translate="yes" xml:space="preserve">
          <source>Total number of WAL records generated by the statement</source>
          <target state="translated">문에 의해 생성 된 총 WAL 레코드 수</target>
        </trans-unit>
        <trans-unit id="c1ce6625b6e47aeee73d2c1b1b71597cc6a9a9eb" translate="yes" xml:space="preserve">
          <source>Total number of blocks to be processed in the current phase.</source>
          <target state="translated">현재 단계에서 처리 할 총 블록 수입니다.</target>
        </trans-unit>
        <trans-unit id="a3f02827d30602c98795371990fc0010531688f8" translate="yes" xml:space="preserve">
          <source>Total number of heap blocks in the table. This number is reported as of the beginning of &lt;code&gt;seq scanning heap&lt;/code&gt;.</source>
          <target state="translated">테이블의 총 힙 블록 수 이 숫자는 &lt;code&gt;seq scanning heap&lt;/code&gt; 시작시보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e4181d322bb75a54b26cb82d6a33040c9b04e2f" translate="yes" xml:space="preserve">
          <source>Total number of heap blocks in the table. This number is reported as of the beginning of the scan; blocks added later will not be (and need not be) visited by this &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">테이블의 총 힙 블록 수 이 번호는 스캔 시작시보고됩니다. 나중에 추가 된 블록은이 &lt;code&gt;VACUUM&lt;/code&gt; 에 의해 방문되지 않으며 방문 할 필요도 없습니다 .</target>
        </trans-unit>
        <trans-unit id="034537a9255995f3a8c4229411cb79c84839a103" translate="yes" xml:space="preserve">
          <source>Total number of heap blocks that will be sampled.</source>
          <target state="translated">샘플링 될 총 힙 블록 수입니다.</target>
        </trans-unit>
        <trans-unit id="139c9a494fed3d2e3c71e34a5377d33fc050686f" translate="yes" xml:space="preserve">
          <source>Total number of local block cache hits by the statement</source>
          <target state="translated">명령문에 의한 총 로컬 블록 캐시 적중 수</target>
        </trans-unit>
        <trans-unit id="0444ce0d25e58c3dd39f796bef3ec3b458f342a6" translate="yes" xml:space="preserve">
          <source>Total number of local blocks dirtied by the statement</source>
          <target state="translated">명령문에 의해 더러워진 총 로컬 블록 수</target>
        </trans-unit>
        <trans-unit id="fa8d6c141a66861c96281f0f98242227f5426245" translate="yes" xml:space="preserve">
          <source>Total number of local blocks read by the statement</source>
          <target state="translated">명령문이 읽은 총 로컬 블록 수</target>
        </trans-unit>
        <trans-unit id="c4c74b725d95cc43eb047faf06c7999e553ed6e3" translate="yes" xml:space="preserve">
          <source>Total number of local blocks written by the statement</source>
          <target state="translated">명령문에 의해 작성된 총 로컬 블록 수</target>
        </trans-unit>
        <trans-unit id="45b980cf18ac4474aa05feb6af93d1110cc5268b" translate="yes" xml:space="preserve">
          <source>Total number of lockers to wait for, when applicable.</source>
          <target state="translated">해당되는 경우 대기 할 총 로커 수입니다.</target>
        </trans-unit>
        <trans-unit id="52c88d84e12390f95fdf71590482ec7e55e73347" translate="yes" xml:space="preserve">
          <source>Total number of rows retrieved or affected by the statement</source>
          <target state="translated">명령문에 의해 검색되거나 영향을받는 총 행 수</target>
        </trans-unit>
        <trans-unit id="2c19070c91bef841456a88dfe27bbe57dee0681a" translate="yes" xml:space="preserve">
          <source>Total number of shared block cache hits by the statement</source>
          <target state="translated">명령문에 의한 총 공유 블록 캐시 적중 수</target>
        </trans-unit>
        <trans-unit id="a10785244a51d5a13cdcecb0439b9565a7085faf" translate="yes" xml:space="preserve">
          <source>Total number of shared blocks dirtied by the statement</source>
          <target state="translated">명령문에 의해 더러워진 총 공유 블록 수</target>
        </trans-unit>
        <trans-unit id="b53a3b5f4cb61c2d5cff8b511400281b57ffd420" translate="yes" xml:space="preserve">
          <source>Total number of shared blocks read by the statement</source>
          <target state="translated">명령문이 읽은 총 공유 블록 수</target>
        </trans-unit>
        <trans-unit id="80f7d9d3865345cc690816c3728dd14e4bb7e4b9" translate="yes" xml:space="preserve">
          <source>Total number of shared blocks written by the statement</source>
          <target state="translated">명령문에 의해 작성된 총 공유 블록 수</target>
        </trans-unit>
        <trans-unit id="0dec74abab5b22125ad8d3417834f7d11deb6460" translate="yes" xml:space="preserve">
          <source>Total number of tablespaces that will be streamed.</source>
          <target state="translated">스트리밍 될 총 테이블 스페이스 수입니다.</target>
        </trans-unit>
        <trans-unit id="6d52c8d86744555c33141f6cf6855a23715ba448" translate="yes" xml:space="preserve">
          <source>Total number of temp blocks read by the statement</source>
          <target state="translated">명령문이 읽은 총 임시 블록 수</target>
        </trans-unit>
        <trans-unit id="d68b8452834fec0662460159475cf3a49ba37364" translate="yes" xml:space="preserve">
          <source>Total number of temp blocks written by the statement</source>
          <target state="translated">명령문에 의해 작성된 총 임시 블록 수</target>
        </trans-unit>
        <trans-unit id="7fc7e0f8478eebbe50dca363939606b67ef16e62" translate="yes" xml:space="preserve">
          <source>Total number of tuples to be processed in the current phase.</source>
          <target state="translated">현재 단계에서 처리 될 총 튜플 수입니다.</target>
        </trans-unit>
        <trans-unit id="7a2e3368cba08aab3bbc52e0db6c41724c5181bc" translate="yes" xml:space="preserve">
          <source>Total time spent executing the statement, in milliseconds</source>
          <target state="translated">명령문 실행에 소요 된 총 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="68f2ac9e60d0e97728209a16e26e37eeb3dc266b" translate="yes" xml:space="preserve">
          <source>Total time spent in the statement, in milliseconds</source>
          <target state="translated">명세서에 소요 된 총 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="4dc28fb55c553e60327ba7c4192353b9fe9a42ae" translate="yes" xml:space="preserve">
          <source>Total time spent in this function and all other functions called by it, in milliseconds</source>
          <target state="translated">이 함수와이 함수가 호출 한 다른 모든 함수에 소요 된 총 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="128b607d292f1a55909a9645569d2e8961a6c971" translate="yes" xml:space="preserve">
          <source>Total time spent in this function itself, not including other functions called by it, in milliseconds</source>
          <target state="translated">이 함수 자체에서 소비 한 총 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="3de803593f31c4639f990558ee1a07af5052d1e1" translate="yes" xml:space="preserve">
          <source>Total time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">문을 계획하는 데 소요 된 총 시간 (밀리 초) ( &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; 이 활성화 된 경우, 그렇지 않으면 0)</target>
        </trans-unit>
        <trans-unit id="9fdfbad291288b3e0fb3447fb003299fb7e4adba" translate="yes" xml:space="preserve">
          <source>Total time the statement spent reading blocks, in milliseconds (if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled, otherwise zero)</source>
          <target state="translated">명령문이 블록을 읽는 데 &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;걸린&lt;/a&gt; 총 시간 (밀리 초) ( track_io_timing 이 사용 가능한 경우 0이 아닌 경우)</target>
        </trans-unit>
        <trans-unit id="b2bf126392434f87ab4af3802a7e86186f9be4fd" translate="yes" xml:space="preserve">
          <source>Total time the statement spent writing blocks, in milliseconds (if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled, otherwise zero)</source>
          <target state="translated">명령문이 블록을 작성하는 데 &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;걸린&lt;/a&gt; 총 시간 (밀리 초) ( track_io_timing 이 사용 가능한 경우 0이 아닌 경우)</target>
        </trans-unit>
        <trans-unit id="3b612e72ed8b42ec172f3e6dbff27929a0f89575" translate="yes" xml:space="preserve">
          <source>Traditional Chinese</source>
          <target state="translated">중국어 번체</target>
        </trans-unit>
        <trans-unit id="bb7f41346d8c75d2dd240c360bc90f8fc8bf4ce2" translate="yes" xml:space="preserve">
          <source>Traditional Chinese, Taiwanese</source>
          <target state="translated">대만어</target>
        </trans-unit>
        <trans-unit id="9af7edd2b08bdbc2ff56eb3fefef8426307788e0" translate="yes" xml:space="preserve">
          <source>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</source>
          <target state="translated">전통적인 Postgres 형식 : 1 년 2 개월 3 일 4 시간 5 분 6 초</target>
        </trans-unit>
        <trans-unit id="d71728de27860673275b28c16ef5e7f90331435b" translate="yes" xml:space="preserve">
          <source>Traditionally, implementing a new index access method meant a lot of difficult work. It was necessary to understand the inner workings of the database, such as the lock manager and Write-Ahead Log. The GiST interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GiST layer itself takes care of concurrency, logging and searching the tree structure.</source>
          <target state="translated">전통적으로 새로운 인덱스 액세스 방법을 구현하는 것은 많은 어려운 작업을 의미했습니다. 잠금 관리자 및 미리 쓰기 로그와 같은 데이터베이스의 내부 작업을 이해해야했습니다. GiST 인터페이스는 추상화 수준이 높기 때문에 액세스하는 데이터 유형의 의미를 구현하기 위해서만 액세스 메소드 구현자가 필요합니다. GiST 계층 자체는 동시성을 관리하고 트리 구조를 로깅 및 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e44f86c162c3284066aeae3888c8a4b415d14e56" translate="yes" xml:space="preserve">
          <source>Traditionally, the configuration and data files used by a database cluster are stored together within the cluster's data directory, commonly referred to as &lt;code&gt;PGDATA&lt;/code&gt; (after the name of the environment variable that can be used to define it). A common location for &lt;code&gt;PGDATA&lt;/code&gt; is &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt;. Multiple clusters, managed by different server instances, can exist on the same machine.</source>
          <target state="translated">일반적으로 데이터베이스 클러스터에서 사용하는 구성 및 데이터 파일은 일반적으로 &lt;code&gt;PGDATA&lt;/code&gt; 라고하는 클러스터의 데이터 디렉토리 내에 함께 저장됩니다 (정의 할 수있는 환경 변수 이름 뒤). &lt;code&gt;PGDATA&lt;/code&gt; 의 일반적인 위치 는 &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; 입니다. 다른 서버 인스턴스로 관리되는 여러 클러스터가 동일한 시스템에 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a7b7c1b33d161f45804730c70b75175dccd9883" translate="yes" xml:space="preserve">
          <source>Transaction</source>
          <target state="translated">Transaction</target>
        </trans-unit>
        <trans-unit id="06d8ffe65391f0da38d503880772215ed8a2200b" translate="yes" xml:space="preserve">
          <source>Transaction ID</source>
          <target state="translated">거래 ID</target>
        </trans-unit>
        <trans-unit id="20805c5f220ddf62c478af0fa328fd76b59b6fbd" translate="yes" xml:space="preserve">
          <source>Transaction ID (0 if none is assigned)</source>
          <target state="translated">거래 ID (할당되지 않은 경우 0)</target>
        </trans-unit>
        <trans-unit id="18878616c87726806d6badd68af497dae4b41656" translate="yes" xml:space="preserve">
          <source>Transaction ID of locker, or multixact ID if multitransaction</source>
          <target state="translated">로커의 트랜잭션 ID 또는 다중 트랜잭션 인 경우 멀티 액스 ID</target>
        </trans-unit>
        <trans-unit id="10ae26a42b974bab55e86677c8854e6023be47c7" translate="yes" xml:space="preserve">
          <source>Transaction IDs of lockers (more than one if multitransaction)</source>
          <target state="translated">로커의 트랜잭션 ID (다중 트랜잭션 인 경우 둘 이상)</target>
        </trans-unit>
        <trans-unit id="1b857f9c61d290e017488262bdfa776200c8930d" translate="yes" xml:space="preserve">
          <source>Transaction Identifier</source>
          <target state="translated">거래 식별자</target>
        </trans-unit>
        <trans-unit id="362cc7ebfcc8b6860ba84b6be6157ee564a4269e" translate="yes" xml:space="preserve">
          <source>Transaction Isolation</source>
          <target state="translated">거래 격리</target>
        </trans-unit>
        <trans-unit id="6e3fee17c38273e0e622dcdfde38cb6e3e451ec0" translate="yes" xml:space="preserve">
          <source>Transaction Isolation: Read Committed Isolation Level</source>
          <target state="translated">트랜잭션 격리 : 커밋 된 격리 수준 읽기</target>
        </trans-unit>
        <trans-unit id="0295f8efef0a16226ca1dadeb7b1cef90dbc2ba8" translate="yes" xml:space="preserve">
          <source>Transaction Isolation: Repeatable Read Isolation Level</source>
          <target state="translated">트랜잭션 격리 : 반복 가능한 읽기 격리 수준</target>
        </trans-unit>
        <trans-unit id="fdc308a16f76158b2289592e32f76f134ccb174a" translate="yes" xml:space="preserve">
          <source>Transaction Isolation: Serializable Isolation Level</source>
          <target state="translated">트랜잭션 격리 : 직렬화 가능한 격리 수준</target>
        </trans-unit>
        <trans-unit id="b163af0dec8e2d414f03eeaa5a4aa6c8443bd48e" translate="yes" xml:space="preserve">
          <source>Transaction Processing Performance Council</source>
          <target state="translated">거래 처리 수행위원회</target>
        </trans-unit>
        <trans-unit id="783653ce8aabc988ab1fbf0b7b77def9554206d6" translate="yes" xml:space="preserve">
          <source>Transaction identifiers are also 32-bit quantities. In a long-lived database it is possible for transaction IDs to wrap around. This is not a fatal problem given appropriate maintenance procedures; see &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt; for details. It is unwise, however, to depend on the uniqueness of transaction IDs over the long term (more than one billion transactions).</source>
          <target state="translated">트랜잭션 식별자도 32 비트 수량입니다. 오래 지속되는 데이터베이스에서는 트랜잭션 ID가 줄 바꿈 될 수 있습니다. 적절한 유지 관리 절차가 제공되는 경우 치명적인 문제는 아닙니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;24 장&lt;/a&gt; 을 참조하십시오. 그러나 장기적으로 트랜잭션 ID의 고유성 (10 억 개 이상의 트랜잭션)에 의존하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81482fe22076261a7285e457dec778b14a2c3695" translate="yes" xml:space="preserve">
          <source>Transaction identifiers are also 32-bit quantities. In a long-lived database it is possible for transaction IDs to wrap around. This is not a fatal problem given appropriate maintenance procedures; see &lt;a href=&quot;https://www.postgresql.org/docs/13/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt; for details. It is unwise, however, to depend on the uniqueness of transaction IDs over the long term (more than one billion transactions).</source>
          <target state="translated">트랜잭션 식별자도 32 비트 수량입니다. 수명이 긴 데이터베이스에서는 트랜잭션 ID가 래핑 될 수 있습니다. 이는 적절한 유지 보수 절차를 고려할 때 치명적 문제가 아닙니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/maintenance.html&quot;&gt;24 장&lt;/a&gt; 을 참조하십시오. 그러나 장기적으로 트랜잭션 ID의 고유성 (10 억 트랜잭션 이상)에 의존하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad3cae69d174599e4cc4c127a9de08ea538533e3" translate="yes" xml:space="preserve">
          <source>Transaction management commands</source>
          <target state="translated">트랜잭션 관리 명령</target>
        </trans-unit>
        <trans-unit id="244648d2a2b4c5e9f046005998c3282e5c7fd698" translate="yes" xml:space="preserve">
          <source>Transaction management commands that explicitly set non-read-only state:</source>
          <target state="translated">읽기 전용이 아닌 상태를 명시 적으로 설정하는 트랜잭션 관리 명령 :</target>
        </trans-unit>
        <trans-unit id="032a6a2e156459be12da14ed3e107d4113138cfd" translate="yes" xml:space="preserve">
          <source>Transaction management commands:</source>
          <target state="translated">트랜잭션 관리 명령 :</target>
        </trans-unit>
        <trans-unit id="7bae2f8d1524dbc31720a0e3939f64fa26db9b78" translate="yes" xml:space="preserve">
          <source>Transaction one attempts to acquire a row-level lock on the specified row, but it cannot: transaction two already holds such a lock. So it waits for transaction two to complete. Thus, transaction one is blocked on transaction two, and transaction two is blocked on transaction one: a deadlock condition. PostgreSQL will detect this situation and abort one of the transactions.</source>
          <target state="translated">트랜잭션 1은 지정된 행에서 행 레벨 잠금을 확보하려고 시도하지만 다음을 수행 할 수 없습니다. 트랜잭션 2는 이미 이러한 잠금을 보유합니다. 따라서 트랜잭션 2가 완료 될 때까지 기다립니다. 따라서 트랜잭션 1은 트랜잭션 2에서 차단되고 트랜잭션 2는 트랜잭션 1에서 교착 상태입니다. PostgreSQL은이 상황을 감지하고 트랜잭션 중 하나를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="2df50b58a3e87095cd42c2f4034bc6e5e6a2ae50" translate="yes" xml:space="preserve">
          <source>Transaction status &quot;hint bits&quot; written on the primary are not WAL-logged, so data on the standby will likely re-write the hints again on the standby. Thus, the standby server will still perform disk writes even though all users are read-only; no changes occur to the data values themselves. Users will still write large sort temporary files and re-generate relcache info files, so no part of the database is truly read-only during hot standby mode. Note also that writes to remote databases using dblink module, and other operations outside the database using PL functions will still be possible, even though the transaction is read-only locally.</source>
          <target state="translated">기본에 작성된 트랜잭션 상태 &quot;힌트 비트&quot;는 WAL로 기록되지 않으므로 대기의 데이터는 대기에서 힌트를 다시 다시 쓸 수 있습니다. 따라서 모든 사용자가 읽기 전용이더라도 대기 서버는 여전히 디스크 쓰기를 수행합니다. 데이터 값 자체에는 변화가 없습니다. 사용자는 여전히 많은 종류의 임시 파일을 작성하고 relcache info 파일을 다시 생성하므로 데이터베이스의 어떤 부분도 핫 스탠바이 모드 동안 실제로 읽기 전용이 아닙니다. 또한 트랜잭션이 로컬로 읽기 전용 인 경우에도 dblink 모듈을 사용하여 원격 데이터베이스에 쓰거나 PL 기능을 사용하여 데이터베이스 외부의 다른 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9115fef6aaf514e06f30c02d5ba3730bf585a59c" translate="yes" xml:space="preserve">
          <source>Transaction status: an empty string when not in a transaction block, or &lt;code&gt;*&lt;/code&gt; when in a transaction block, or &lt;code&gt;!&lt;/code&gt; when in a failed transaction block, or &lt;code&gt;?&lt;/code&gt; when the transaction state is indeterminate (for example, because there is no connection).</source>
          <target state="translated">트랜잭션 상태 : 트랜잭션 블록에없는 경우 빈 문자열 또는 트랜잭션 블록에있는 경우 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; 실패한 트랜잭션 블록에있을 때 또는 &lt;code&gt;?&lt;/code&gt; 트랜잭션 상태가 불확실한 경우 (예 : 연결이 없기 때문에)</target>
        </trans-unit>
        <trans-unit id="47ebfa32d50285675f9d154d8a4546223948507a" translate="yes" xml:space="preserve">
          <source>TransactionId</source>
          <target state="translated">TransactionId</target>
        </trans-unit>
        <trans-unit id="d071bbfced054416a7f289525ebee94bea79198f" translate="yes" xml:space="preserve">
          <source>Transactions in progress at the time of the snapshot. A transaction ID that is &lt;code&gt;xmin &amp;lt;= X &amp;lt; xmax&lt;/code&gt; and not in this list was already completed at the time of the snapshot, and thus is either visible or dead according to its commit status. This list does not include the transaction IDs of subtransactions.</source>
          <target state="translated">스냅 샷 시점에 진행중인 트랜잭션입니다. &lt;code&gt;xmin &amp;lt;= X &amp;lt; xmax&lt;/code&gt; 목록에없는 트랜잭션 ID 는 스냅 샷 시점에 이미 완료되었으므로 커밋 상태에 따라 표시되거나 사용되지 않습니다. 이 목록에는 서브 트랜잭션의 트랜잭션 ID가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a16fa9a914d72a0c50c04e0fc3597d3f514a314" translate="yes" xml:space="preserve">
          <source>Transactions per second (TPS)</source>
          <target state="translated">초당 트랜잭션 (TPS)</target>
        </trans-unit>
        <trans-unit id="01df28d63a600d976f605002c1c87ca85d599d36" translate="yes" xml:space="preserve">
          <source>Transactions started during hot standby may issue the following commands:</source>
          <target state="translated">상시 대기 중에 시작된 트랜잭션은 다음 명령을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cf9ced370da4876292141e53b2b552a9cf764b7" translate="yes" xml:space="preserve">
          <source>Transactions started during hot standby will never be assigned a transaction ID and cannot write to the system write-ahead log. Therefore, the following actions will produce error messages:</source>
          <target state="translated">상시 대기 중에 시작된 트랜잭션에는 트랜잭션 ID가 할당되지 않으며 시스템 미리 쓰기 로그에 쓸 수 없습니다. 따라서 다음 조치는 오류 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="479ffbbc1b67ed11701ba8d2dcae959b56067bd4" translate="yes" xml:space="preserve">
          <source>Transactions that last more than &lt;code&gt;limit&lt;/code&gt; milliseconds are counted and reported separately, as &lt;em&gt;late&lt;/em&gt;.</source>
          <target state="translated">거래보다 마지막으로 더 것을 &lt;code&gt;limit&lt;/code&gt; (밀리 초)는, 계산 별도로보고 &lt;em&gt;말&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd0b9585e0aac48b40c541fafaca4f31c93300a" translate="yes" xml:space="preserve">
          <source>Transition function</source>
          <target state="translated">전환 기능</target>
        </trans-unit>
        <trans-unit id="efa82358149d07c8578392dc98215d57f7bd3811" translate="yes" xml:space="preserve">
          <source>Translates a textual collation name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regcollation&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 데이터 정렬 이름을 OID로 변환합니다. 유사한 결과는 문자열을 &lt;code&gt;regcollation&lt;/code&gt; 유형으로 캐스팅하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름을 찾을 수없는 경우 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccc164c92dd7b3fef9b61d3c82842d6ee1da4302" translate="yes" xml:space="preserve">
          <source>Translates a textual function or procedure name (with argument types) to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regprocedure&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 함수 또는 프로 시저 이름 (인수 유형 포함)을 OID로 변환합니다. 유사한 결과는 문자열을 &lt;code&gt;regprocedure&lt;/code&gt; 유형으로 캐스팅하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름을 찾을 수없는 경우 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef72ee486a99d329e919f18b88ce76c0b03976ee" translate="yes" xml:space="preserve">
          <source>Translates a textual function or procedure name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regproc&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found or is ambiguous. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 함수 또는 프로 시저 이름을 OID로 변환합니다. 비슷한 결과는 문자열을 &lt;code&gt;regproc&lt;/code&gt; 유형으로 캐스팅하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름이 없거나 모호한 경우 오류가 발생하지 않고 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다. 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3df810a8802c3de4a8975fa62010e275f6693c7" translate="yes" xml:space="preserve">
          <source>Translates a textual operator name (with parameter types) to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regoperator&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 연산자 이름 (매개 변수 유형 포함)을 OID로 변환합니다. 비슷한 결과는 문자열을 &lt;code&gt;regoperator&lt;/code&gt; 유형으로 캐스팅하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름을 찾을 수없는 경우 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92746faa205cd6961adce584e99c5f21cb92c46c" translate="yes" xml:space="preserve">
          <source>Translates a textual operator name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regoper&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found or is ambiguous. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 연산자 이름을 OID로 변환합니다. 유사한 결과는 문자열을 &lt;code&gt;regoper&lt;/code&gt; 유형으로 캐스트하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름이 없거나 모호한 경우 오류가 발생하지 않고 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다. 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfb773d5eee2a49b6ea78ef980db2e7f30639736" translate="yes" xml:space="preserve">
          <source>Translates a textual relation name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regclass&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 관계 이름을 OID로 변환합니다. 비슷한 결과는 문자열을 &lt;code&gt;regclass&lt;/code&gt; 유형으로 캐스팅하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름을 찾을 수없는 경우 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="098dc5926b87a21bd111e9afaa29f8b1770028be" translate="yes" xml:space="preserve">
          <source>Translates a textual role name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regrole&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 역할 이름을 OID로 변환합니다. 비슷한 결과는 문자열을 &lt;code&gt;regrole&lt;/code&gt; 유형으로 캐스팅하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름을 찾을 수없는 경우 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb42818718f6870ecc3a5e4e2716f5845d22f9af" translate="yes" xml:space="preserve">
          <source>Translates a textual schema name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regnamespace&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 스키마 이름을 OID로 변환합니다. 유사한 결과는 문자열을 &lt;code&gt;regnamespace&lt;/code&gt; 유형으로 캐스팅하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름을 찾을 수없는 경우 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4723217fb81c0d95526fe2c01ae95fbd721b1761" translate="yes" xml:space="preserve">
          <source>Translates a textual type name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regtype&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="translated">텍스트 유형 이름을 OID로 변환합니다. 유사한 결과는 문자열을 &lt;code&gt;regtype&lt;/code&gt; 유형으로 캐스트하여 얻을 수 있습니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 그러나이 함수는 이름을 찾을 수없는 경우 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 또한 캐스트와 달리 숫자 OID를 입력으로 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59a6244fac8a9c9d9686484f98e57e4b38d7e551" translate="yes" xml:space="preserve">
          <source>Translates the given qualified MLS/MCS range into raw format if the mcstrans daemon is running.</source>
          <target state="translated">mcstrans 데몬이 실행중인 경우 지정된 정규화 된 MLS / MCS 범위를 원시 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="731119f8198322e42d9eac5b43c02d9adc999a6f" translate="yes" xml:space="preserve">
          <source>Translates the given raw MLS/MCS range into qualified format if the mcstrans daemon is running.</source>
          <target state="translated">mcstrans 데몬이 실행중인 경우 지정된 원시 MLS / MCS 범위를 규정 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ac26a7a94ea2e66490f932b6415a09ef6f2a913c" translate="yes" xml:space="preserve">
          <source>Translation</source>
          <target state="translated">Translation</target>
        </trans-unit>
        <trans-unit id="6ba02139a90ba90fe7b0f004a77e148246991531" translate="yes" xml:space="preserve">
          <source>Transmission Control Protocol (TCP) / Internet Protocol (IP)</source>
          <target state="translated">TCP (전송 제어 프로토콜) / IP (인터넷 프로토콜)</target>
        </trans-unit>
        <trans-unit id="0078eb875cd6a9009a98bbca564ba5b0c49f0742" translate="yes" xml:space="preserve">
          <source>Treat given time stamp &lt;em&gt;without time zone&lt;/em&gt; as located in the specified time zone</source>
          <target state="translated">지정된 &lt;em&gt;시간대&lt;/em&gt; 에있는 &lt;em&gt;시간대없이&lt;/em&gt; 지정된 타임 스탬프 &lt;em&gt;를 처리&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="525e69424eac00831ef279c5d86304725cc5771e" translate="yes" xml:space="preserve">
          <source>Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use &lt;code&gt;\i&lt;/code&gt; for that.)</source>
          <target state="translated">버퍼를 한 줄로 취급하는 것은 주로 메타 명령에 영향을 미칩니다. 메타 명령 이후 버퍼에있는 것은 여러 줄에 걸쳐 있더라도 메타 명령에 대한 인수로 간주됩니다. (따라서이 방법으로 메타 명령을 사용하는 스크립트를 만들 수 없습니다. &lt;code&gt;\i&lt;/code&gt; 를 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="22ea8d02160441883e871c64b4bf207437c3c434" translate="yes" xml:space="preserve">
          <source>Tree level of the root page</source>
          <target state="translated">루트 페이지의 트리 레벨</target>
        </trans-unit>
        <trans-unit id="d3f06a581b2b66fa7a3965ddeb6fb307f7be20ba" translate="yes" xml:space="preserve">
          <source>Trigger</source>
          <target state="translated">Trigger</target>
        </trans-unit>
        <trans-unit id="9451e7469c06f9b530822204de7004d1e937be5b" translate="yes" xml:space="preserve">
          <source>Trigger name (must be unique among triggers of same table)</source>
          <target state="translated">트리거 이름 (같은 테이블의 트리거 중에서 고유해야 함)</target>
        </trans-unit>
        <trans-unit id="e20ca83547dde923f083f9c8fa915e58f12e5b0e" translate="yes" xml:space="preserve">
          <source>Trigger name (must be unique)</source>
          <target state="translated">트리거 이름 (고유해야 함)</target>
        </trans-unit>
        <trans-unit id="1a556d389e53119654090ed90caa41185b3f9c1f" translate="yes" xml:space="preserve">
          <source>Trigger-Based Master-Standby Replication</source>
          <target state="translated">트리거 기반 마스터 대기 복제</target>
        </trans-unit>
        <trans-unit id="b403b55ee83f5cefbd6403b1202345b597667eeb" translate="yes" xml:space="preserve">
          <source>Trigger-Based Repl.</source>
          <target state="translated">트리거 기반 Repl.</target>
        </trans-unit>
        <trans-unit id="358d2d9b79bd7e7b52f1a586b3f6090ae9e39c21" translate="yes" xml:space="preserve">
          <source>Trigger-based replication systems such as Slony, Londiste and Bucardo won't run on the standby at all, though they will run happily on the primary server as long as the changes are not sent to standby servers to be applied. WAL replay is not trigger-based so you cannot relay from the standby to any system that requires additional database writes or relies on the use of triggers.</source>
          <target state="translated">Slony, Londiste 및 Bucardo와 같은 트리거 기반 복제 시스템은 대기에서 전혀 실행되지 않지만 변경 사항이 대기 서버로 전송되어 적용되지 않는 한 기본 서버에서 행복하게 실행됩니다. WAL 재생은 트리거 기반이 아니므로 대기 모드에서 추가 데이터베이스 쓰기가 필요하거나 트리거 사용에 의존하는 시스템으로 릴레이 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec9dd8da4cbb76e8113d156c57ac6bcb808fcaed" translate="yes" xml:space="preserve">
          <source>Triggers or rules will be needed to route rows to the desired child table, unless the application is explicitly aware of the partitioning scheme. Triggers may be complicated to write, and will be much slower than the tuple routing performed internally by declarative partitioning.</source>
          <target state="translated">애플리케이션이 파티셔닝 구성표를 명시 적으로 인식하지 않는 한 원하는 하위 테이블로 행을 라우팅하려면 트리거 또는 규칙이 필요합니다. 트리거는 쓰기가 복잡 할 수 있으며 선언적 파티셔닝에 의해 내부적으로 수행되는 튜플 라우팅보다 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="e5d696aa282753969e978fb0a8849d8e4a8fd3c1" translate="yes" xml:space="preserve">
          <source>Triggers that are specified to fire &lt;code&gt;INSTEAD OF&lt;/code&gt; the trigger event must be marked &lt;code&gt;FOR EACH ROW&lt;/code&gt;, and can only be defined on views. &lt;code&gt;BEFORE&lt;/code&gt; and &lt;code&gt;AFTER&lt;/code&gt; triggers on a view must be marked as &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거 이벤트 를 발생 시키도록 지정된 트리거는 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 로 표시되어야하며 보기에서만 정의 될 수 있습니다. &lt;code&gt;BEFORE&lt;/code&gt; 와 &lt;code&gt;AFTER&lt;/code&gt; 뷰에 대한 트리거는 다음과 같이 표시되어야합니다 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fc33655c302a2026e3c03ef9f67004fc688e0bc" translate="yes" xml:space="preserve">
          <source>Trigram matching is a very useful tool when used in conjunction with a full text index. In particular it can help to recognize misspelled input words that will not be matched directly by the full text search mechanism.</source>
          <target state="translated">트라이 그램 일치는 전체 텍스트 인덱스와 함께 사용될 때 매우 유용한 도구입니다. 특히 전체 텍스트 검색 메커니즘과 직접 일치하지 않는 철자가 틀린 입력 단어를 인식하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47b56bcac7cb1a1a1a2b8b071447953ef205236" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;member&lt;/code&gt; can grant membership in &lt;code&gt;roleid&lt;/code&gt; to others</source>
          <target state="translated">진정한 경우 &lt;code&gt;member&lt;/code&gt; 의 회원 자격을 부여 할 수있는 &lt;code&gt;roleid&lt;/code&gt; 다른 사람에게</target>
        </trans-unit>
        <trans-unit id="27b88e660e42da283a963fedfe7ddba5acc1eb37" translate="yes" xml:space="preserve">
          <source>True if GSSAPI authentication was used for this connection</source>
          <target state="translated">이 연결에 GSSAPI 인증이 사용 된 경우 true</target>
        </trans-unit>
        <trans-unit id="f0294acd5dcbc0ec5fe0501f3d6e4f6631feaea3" translate="yes" xml:space="preserve">
          <source>True if GSSAPI encryption is in use on this connection</source>
          <target state="translated">이 연결에서 GSSAPI 암호화를 사용중인 경우 true</target>
        </trans-unit>
        <trans-unit id="249fa4238b509d9384131b077e4a974fe52e87b7" translate="yes" xml:space="preserve">
          <source>True if SSL compression is in use, false if not, or NULL if SSL is not in use on this connection</source>
          <target state="translated">SSL 압축을 사용중인 경우 true, 그렇지 않은 경우 false 또는이 연결에서 SSL을 사용하지 않는 경우 NULL</target>
        </trans-unit>
        <trans-unit id="b09e7e431be1f0ef9d3f61bae90a5b84de49fc09" translate="yes" xml:space="preserve">
          <source>True if SSL is used on this connection</source>
          <target state="translated">이 연결에 SSL이 사용되면 true</target>
        </trans-unit>
        <trans-unit id="73fc59a0dc7300971fbdc23724099ed0b896857f" translate="yes" xml:space="preserve">
          <source>True if an on-line exclusive backup is still in progress.</source>
          <target state="translated">온라인 전용 백업이 여전히 진행 중이면 참입니다.</target>
        </trans-unit>
        <trans-unit id="012e79baddd407b1c921d97d791e3cf55a10cb4d" translate="yes" xml:space="preserve">
          <source>True if constraint trigger is deferrable</source>
          <target state="translated">제약 조건 트리거가 지연 가능한 경우 True</target>
        </trans-unit>
        <trans-unit id="8d2220de13bd9a2d96db7735aed49d6345d08164" translate="yes" xml:space="preserve">
          <source>True if constraint trigger is initially deferred</source>
          <target state="translated">제약 조건 트리거가 초기에 지연되면 참</target>
        </trans-unit>
        <trans-unit id="23d7a2135b9ce4e46ed5cd1464346506b9a106a5" translate="yes" xml:space="preserve">
          <source>True if currently observing daylight savings</source>
          <target state="translated">현재 일광 절약 시간을 준수하는 경우 참</target>
        </trans-unit>
        <trans-unit id="6c9e701104bae2b464c2020db78d7e9600016eaa" translate="yes" xml:space="preserve">
          <source>True if extension can be relocated to another schema</source>
          <target state="translated">확장을 다른 스키마로 재배치 할 수 있으면 참</target>
        </trans-unit>
        <trans-unit id="13194a8bcdf4e8395775186edb8919bbe57277d7" translate="yes" xml:space="preserve">
          <source>True if language is considered trusted</source>
          <target state="translated">언어가 신뢰할 수있는 것으로 간주되면 참</target>
        </trans-unit>
        <trans-unit id="f48edc9cc0d1d8a7aedf7f448e48a3a8e2dfdc7e" translate="yes" xml:space="preserve">
          <source>True if language may be created by a database owner</source>
          <target state="translated">데이터베이스 소유자가 언어를 작성할 수있는 경우 참</target>
        </trans-unit>
        <trans-unit id="64e3a4a3dce2e5bcd672ebfd09e86521c286718f" translate="yes" xml:space="preserve">
          <source>True if lock is held, false if lock is awaited</source>
          <target state="translated">잠금이 유지되면 true, 잠금이 대기되면 false</target>
        </trans-unit>
        <trans-unit id="3b6ef157f06387be075989a37f516c89a4bd0a37" translate="yes" xml:space="preserve">
          <source>True if lock was taken via fast path, false if taken via main lock table</source>
          <target state="translated">빠른 경로를 통해 잠금을 수행 한 경우 true, 기본 잠금 테이블을 통해 수행 된 경우 false</target>
        </trans-unit>
        <trans-unit id="ad71d91044693983ff02d60ae2955e48c5fc2452" translate="yes" xml:space="preserve">
          <source>True if locker is a multitransaction</source>
          <target state="translated">로커가 다중 트랜잭션 인 경우 참</target>
        </trans-unit>
        <trans-unit id="fda8e2d43deca4588633ff2520ae6d5cec5b396c" translate="yes" xml:space="preserve">
          <source>True if materialized view has (or recently had) any indexes</source>
          <target state="translated">구체화 된 뷰에 인덱스가 있거나 최근에있는 경우 참</target>
        </trans-unit>
        <trans-unit id="0f8da21d8e6ff2b7a2076689ef9d08e87aef74dd" translate="yes" xml:space="preserve">
          <source>True if materialized view is currently populated</source>
          <target state="translated">구체화 된 뷰가 현재 채워져 있으면 참</target>
        </trans-unit>
        <trans-unit id="99506ea5356b9ad791ad9c495955d35220b0a84f" translate="yes" xml:space="preserve">
          <source>True if only superusers are allowed to install this extension</source>
          <target state="translated">수퍼 유저 만이 확장을 설치할 수있는 경우 true</target>
        </trans-unit>
        <trans-unit id="7438a25765f88fed7fec2543e2f22ba8fa0da65d" translate="yes" xml:space="preserve">
          <source>True if only superusers are allowed to install this extension (but see &lt;code&gt;trusted&lt;/code&gt;)</source>
          <target state="translated">수퍼 유저 만이 확장을 설치할 수있는 경우 true (그러나 &lt;code&gt;trusted&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a35a480c8856109ea6f28e3f43d8363e78cf83fe" translate="yes" xml:space="preserve">
          <source>True if recovery is paused.</source>
          <target state="translated">복구가 일시 중지 된 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="f63f3a290f4cbaf52602d088d18db98a25a18728" translate="yes" xml:space="preserve">
          <source>True if recovery is still in progress.</source>
          <target state="translated">복구가 여전히 진행 중이면 true입니다.</target>
        </trans-unit>
        <trans-unit id="952d1d48ba36745c7442261d09e7833e6a695b65" translate="yes" xml:space="preserve">
          <source>True if relation is populated (this is true for all relations other than some materialized views)</source>
          <target state="translated">관계가 채워지면 참 (일부 구체화 된 뷰 이외의 모든 관계에 해당)</target>
        </trans-unit>
        <trans-unit id="8415173c3c9124dc63f70c0e4fc258f7f25295a4" translate="yes" xml:space="preserve">
          <source>True if row level security (when enabled) will also apply to table owner; see &lt;a href=&quot;catalog-pg-policy&quot;&gt;&lt;code&gt;pg_policy&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">행 레벨 보안 (사용 가능한 경우)이 테이블 소유자에게도 적용되는 경우 true입니다. &lt;a href=&quot;catalog-pg-policy&quot;&gt; &lt;code&gt;pg_policy&lt;/code&gt; &lt;/a&gt; 카탈로그 참조</target>
        </trans-unit>
        <trans-unit id="84b8ae8060dc19fffeb8070b76ac95ebd9162532" translate="yes" xml:space="preserve">
          <source>True if row security is enabled on the table</source>
          <target state="translated">테이블에서 행 보안이 사용 가능한 경우 true</target>
        </trans-unit>
        <trans-unit id="c016f5a7ce842e21ac5e05ef1d678380be642aaa" translate="yes" xml:space="preserve">
          <source>True if table has (or once had) rules</source>
          <target state="translated">테이블에 규칙이 있거나 한 번 있었다면 참</target>
        </trans-unit>
        <trans-unit id="86d78d4068510676f3b29858a7d35e8046be10f2" translate="yes" xml:space="preserve">
          <source>True if table has (or once had) rules; see &lt;a href=&quot;catalog-pg-rewrite&quot;&gt;&lt;code&gt;pg_rewrite&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">테이블에 규칙이 있거나 한 번 있었다면 참입니다. &lt;a href=&quot;catalog-pg-rewrite&quot;&gt; &lt;code&gt;pg_rewrite&lt;/code&gt; &lt;/a&gt; 카탈로그를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="bbd3dd1777eb1a65592ad8111a5ec7282e029b6a" translate="yes" xml:space="preserve">
          <source>True if table has (or once had) triggers</source>
          <target state="translated">테이블에 트리거가 있거나 한 번 트리거 된 경우 참</target>
        </trans-unit>
        <trans-unit id="232c6e9f5f95405c7928ec2722737febf663144a" translate="yes" xml:space="preserve">
          <source>True if table has (or once had) triggers; see &lt;a href=&quot;catalog-pg-trigger&quot;&gt;&lt;code&gt;pg_trigger&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">테이블에 트리거가 있거나 한 번 트리거 된 경우 true입니다. &lt;a href=&quot;catalog-pg-trigger&quot;&gt; &lt;code&gt;pg_trigger&lt;/code&gt; &lt;/a&gt; 카탈로그 참조</target>
        </trans-unit>
        <trans-unit id="66b69b4d62a4378bccf42a60097c0c71c291ce56" translate="yes" xml:space="preserve">
          <source>True if table has (or recently had) any indexes</source>
          <target state="translated">테이블에 인덱스가 있거나 최근에있는 경우 참</target>
        </trans-unit>
        <trans-unit id="e7bd1fe139d42d7b1519b72cb282ee9cb54850bb" translate="yes" xml:space="preserve">
          <source>True if table has row level security enabled; see &lt;a href=&quot;catalog-pg-policy&quot;&gt;&lt;code&gt;pg_policy&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">테이블에 행 레벨 보안이 사용 가능한 경우 true입니다. &lt;a href=&quot;catalog-pg-policy&quot;&gt; &lt;code&gt;pg_policy&lt;/code&gt; &lt;/a&gt; 카탈로그 참조</target>
        </trans-unit>
        <trans-unit id="955515f99b28aae950e8f042fb8a268a1914bd68" translate="yes" xml:space="preserve">
          <source>True if table or index has (or once had) any inheritance children</source>
          <target state="translated">테이블이나 인덱스에 상속 자식이 있거나있는 경우 참</target>
        </trans-unit>
        <trans-unit id="a519990c88d7093181aaba6f5c8906c338ebda6d" translate="yes" xml:space="preserve">
          <source>True if table or index is a partition</source>
          <target state="translated">테이블 또는 인덱스가 파티션 인 경우 참</target>
        </trans-unit>
        <trans-unit id="6faf5538e123802b74af773b1f794f3bde782ef0" translate="yes" xml:space="preserve">
          <source>True if the current role has superuser privileges.</source>
          <target state="translated">현재 역할에 수퍼 유저 권한이 있으면 true입니다.</target>
        </trans-unit>
        <trans-unit id="49c5deda46593d87b8da1a0a8664bee6e99c35a8" translate="yes" xml:space="preserve">
          <source>True if the extension can be installed by non-superusers with appropriate privileges</source>
          <target state="translated">적절한 권한을 가진 수퍼 유저가 아닌 사용자가 확장 프로그램을 설치할 수있는 경우 참</target>
        </trans-unit>
        <trans-unit id="42ccdc48d1316985de4ceff096fc1090b18ac5fc" translate="yes" xml:space="preserve">
          <source>True if the rule is an &lt;code&gt;INSTEAD&lt;/code&gt; rule</source>
          <target state="translated">규칙이 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙 인 경우 참</target>
        </trans-unit>
        <trans-unit id="cb4d292a249d96e18b80c58763a501bbad7d05de" translate="yes" xml:space="preserve">
          <source>True if the type is a preferred cast target within its &lt;code&gt;typcategory&lt;/code&gt;</source>
          <target state="translated">유형은 내 선호 캐스트 대상의 경우는 true &lt;code&gt;typcategory&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="c404ccf3e65aa528ab96ca3872357652195dd689" translate="yes" xml:space="preserve">
          <source>True if the type is defined, false if this is a placeholder entry for a not-yet-defined type. When &lt;code&gt;typisdefined&lt;/code&gt; is false, nothing except the type name, namespace, and OID can be relied on.</source>
          <target state="translated">형식이 정의되어 있으면 true이고 아직 정의되지 않은 형식의 자리 표시 자 항목 인 경우 false입니다. 때 &lt;code&gt;typisdefined&lt;/code&gt; 은 거짓, 유형 이름, 네임 스페이스 및 OID를 제외하고 아무것도에 의존 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf25c33cad22135a1491bee944b6f10caae211df" translate="yes" xml:space="preserve">
          <source>True if the value can be applied successfully</source>
          <target state="translated">값을 성공적으로 적용 할 수 있으면 true</target>
        </trans-unit>
        <trans-unit id="32b0c20ba6a36c06232673842b1188efcec879d2" translate="yes" xml:space="preserve">
          <source>True if this is a daylight-savings abbreviation</source>
          <target state="translated">일광 절약형 약어 인 경우에 해당</target>
        </trans-unit>
        <trans-unit id="36393d0a0fd9ddbaafe14fa3d4329cc46ba38ce7" translate="yes" xml:space="preserve">
          <source>True if this is a table and it has (or recently had) any indexes</source>
          <target state="translated">이것이 테이블이고 인덱스를 가지고 있거나 최근에 가지고 있다면 참</target>
        </trans-unit>
        <trans-unit id="26ed87abfb4393c79c8c847eb10dc8103b4a50c1" translate="yes" xml:space="preserve">
          <source>True if this is a temporary replication slot. Temporary slots are not saved to disk and are automatically dropped on error or when the session has finished.</source>
          <target state="translated">이것이 임시 복제 슬롯 인 경우에 해당됩니다. 임시 슬롯은 디스크에 저장되지 않으며 오류 또는 세션이 완료되면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ef96945409922985d107491ffa09903856c28a62" translate="yes" xml:space="preserve">
          <source>True if this is a trusted language, which means that it is believed not to grant access to anything outside the normal SQL execution environment. Only superusers can create functions in untrusted languages.</source>
          <target state="translated">이 언어가 신뢰할 수있는 언어 인 경우 true입니다. 즉, 일반 SQL 실행 환경 외부에 액세스 권한을 부여하지 않는 것으로 간주됩니다. 수퍼 유저 만 신뢰할 수없는 언어로 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c204724b18388c85e2216fcb59a67a33fb072e1d" translate="yes" xml:space="preserve">
          <source>True if this is the default conversion</source>
          <target state="translated">이것이 기본 변환 인 경우 참</target>
        </trans-unit>
        <trans-unit id="965b2818c43a8348e19c577671df21f2fc196f83" translate="yes" xml:space="preserve">
          <source>True if this operator class is the default for &lt;code&gt;opcintype&lt;/code&gt;</source>
          <target state="translated">이 연산자 클래스가 &lt;code&gt;opcintype&lt;/code&gt; 의 기본값 인 경우 true</target>
        </trans-unit>
        <trans-unit id="3bd82801197995cc7c2f18df7e169fd34abd4933" translate="yes" xml:space="preserve">
          <source>True if this slot is currently actively being used</source>
          <target state="translated">이 슬롯이 현재 활발하게 사용되고 있다면 true</target>
        </trans-unit>
        <trans-unit id="df76a619896b77be64d0f3cb65694575b20c8bda" translate="yes" xml:space="preserve">
          <source>True if this table is shared across all databases in the cluster. Only certain system catalogs (such as &lt;code&gt;pg_database&lt;/code&gt;) are shared.</source>
          <target state="translated">이 테이블이 클러스터의 모든 데이터베이스에서 공유되면 true입니다. 특정 시스템 카탈로그 (예 : &lt;code&gt;pg_database&lt;/code&gt; ) 만 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="00d7d10a299138dca72b8e64f880eb593bd8c0c1" translate="yes" xml:space="preserve">
          <source>True if this type is a preferred type within its type category, else false. The default is false. Be very careful about creating a new preferred type within an existing type category, as this could cause surprising changes in behavior.</source>
          <target state="translated">이 유형이 해당 유형 범주 내에서 선호되는 유형이면 true이고, 그렇지 않으면 false입니다. 기본값은 false입니다. 기존 유형 카테고리 내에서 새로운 기본 유형을 작성하는 데 매우주의하십시오. 이는 놀라운 동작 변경을 야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9def5bf7a41790ac3b8e30f1fc70c1fdbb898bec" translate="yes" xml:space="preserve">
          <source>True if this type's operations can use collation information. The default is false.</source>
          <target state="translated">이 유형의 작업에서 데이터 정렬 정보를 사용할 수 있으면 true입니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="e0ad09cb04969121b61e35716b0db046d9cadd81" translate="yes" xml:space="preserve">
          <source>True if this version of this extension is currently installed</source>
          <target state="translated">이 확장 버전이 현재 설치되어 있으면 true</target>
        </trans-unit>
        <trans-unit id="ab9af1736eb3931ab0baf9949ee8108e0d2bfebd" translate="yes" xml:space="preserve">
          <source>True if trigger is internally generated (usually, to enforce the constraint identified by &lt;code&gt;tgconstraint&lt;/code&gt;)</source>
          <target state="translated">트리거가 내부적으로 생성 된 경우 (일반적으로 &lt;code&gt;tgconstraint&lt;/code&gt; 로 식별 된 제한 조건을 적용하기 위해 ) true</target>
        </trans-unit>
        <trans-unit id="5ca548743e2786b08e3fd52b9381c1735b9c020c" translate="yes" xml:space="preserve">
          <source>True to pass extra dummy arguments to &lt;code&gt;aggfinalfn&lt;/code&gt;</source>
          <target state="translated">추가 더미 인수를 &lt;code&gt;aggfinalfn&lt;/code&gt; 에 전달하려면 True</target>
        </trans-unit>
        <trans-unit id="164596b2be84a485eca692d6a04580df3d74a2aa" translate="yes" xml:space="preserve">
          <source>True to pass extra dummy arguments to &lt;code&gt;aggmfinalfn&lt;/code&gt;</source>
          <target state="translated">추가 더미 인수를 &lt;code&gt;aggmfinalfn&lt;/code&gt; 에 전달하려면 true</target>
        </trans-unit>
        <trans-unit id="6d4ee65593919418e1bd8e29f7e952e96736cb58" translate="yes" xml:space="preserve">
          <source>Truncate the table &lt;code&gt;othertable&lt;/code&gt;, and cascade to any tables that reference &lt;code&gt;othertable&lt;/code&gt; via foreign-key constraints:</source>
          <target state="translated">테이블 &lt;code&gt;othertable&lt;/code&gt; 을 자르고 외래 키 제약 조건을 통해 &lt;code&gt;othertable&lt;/code&gt; 을 참조하는 테이블에 계단식으로 배열하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dc17db6052d197657f4b66cc0edb567325a2bbb" translate="yes" xml:space="preserve">
          <source>Truncate the tables &lt;code&gt;bigtable&lt;/code&gt; and &lt;code&gt;fattable&lt;/code&gt;:</source>
          <target state="translated">테이블 자르기 &lt;code&gt;bigtable&lt;/code&gt; 과 &lt;code&gt;fattable&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="00f1193a7fa78df4b4d56560c05dd84766a6e43f" translate="yes" xml:space="preserve">
          <source>Truncate to specified precision in the specified time zone; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TRUNC&quot;&gt;Section 9.9.2&lt;/a&gt;</source>
          <target state="translated">지정된 시간대에서 지정된 정밀도로 자릅니다. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TRUNC&quot;&gt;9.9.2 절&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="be6b9181b48ae3b21719c3424b9df5c25e4cf704" translate="yes" xml:space="preserve">
          <source>Truncate to specified precision; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TRUNC&quot;&gt;Section 9.9.2&lt;/a&gt;</source>
          <target state="translated">지정된 정밀도로 자릅니다. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TRUNC&quot;&gt;9.9.2 절&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="f15d827fb86d12905958801116bae0132b24288b" translate="yes" xml:space="preserve">
          <source>Truncates &lt;em&gt;&lt;code&gt;v&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;s&lt;/code&gt;&lt;/em&gt; decimal places</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;v&lt;/code&gt; &lt;/em&gt; 를 &lt;em&gt; &lt;code&gt;s&lt;/code&gt; &lt;/em&gt; 소수 자릿수로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="20d769e0b499920cf570c76fa726c85ce63bdb4b" translate="yes" xml:space="preserve">
          <source>Truncates the visibility map for the given relation. This function is useful if you believe that the visibility map for the relation is corrupt and wish to force rebuilding it. The first &lt;code&gt;VACUUM&lt;/code&gt; executed on the given relation after this function is executed will scan every page in the relation and rebuild the visibility map. (Until that is done, queries will treat the visibility map as containing all zeroes.)</source>
          <target state="translated">주어진 관계에 대한 가시성 맵을 자릅니다. 이 기능은 관계의 가시성 맵이 손상되었다고 생각하고 강제로 재 빌드하려는 경우에 유용합니다. 이 함수가 실행 된 후 주어진 관계에서 실행 된 첫 번째 &lt;code&gt;VACUUM&lt;/code&gt; 은 관계의 모든 페이지를 스캔하고 가시성 맵을 다시 작성합니다. (완료 될 때까지 쿼리는 가시성 맵을 모두 0을 포함하는 것으로 취급합니다.)</target>
        </trans-unit>
        <trans-unit id="f44660614a2ee1a0637096613f6651f9ec6d18c3" translate="yes" xml:space="preserve">
          <source>Truncates to integer (towards zero)</source>
          <target state="translated">정수로 자릅니다 (0 방향).</target>
        </trans-unit>
        <trans-unit id="9fc0100312a64373efd7c390d92763a84341669f" translate="yes" xml:space="preserve">
          <source>Trust Authentication</source>
          <target state="translated">트러스트 인증</target>
        </trans-unit>
        <trans-unit id="6525fd8384c1b1a98745cafdc4fe870534c5b3c9" translate="yes" xml:space="preserve">
          <source>Trust both system and database administrator.</source>
          <target state="translated">시스템 및 데이터베이스 관리자를 모두 신뢰하십시오.</target>
        </trans-unit>
        <trans-unit id="0303d1058ff834ee7d3f9e41bfb45de83313adee" translate="yes" xml:space="preserve">
          <source>Trusted procedures are similar to security definer functions or setuid commands. SELinux provides a feature to allow trusted code to run using a security label different from that of the client, generally for the purpose of providing highly controlled access to sensitive data (e.g. rows might be omitted, or the precision of stored values might be reduced). Whether or not a function acts as a trusted procedure is controlled by its security label and the operating system security policy. For example:</source>
          <target state="translated">신뢰할 수있는 절차는 보안 정의 자 기능 또는 setuid 명령과 유사합니다. SELinux는 일반적으로 민감한 데이터에 대한 고도로 제어 된 액세스를 제공하기 위해 신뢰할 수있는 코드가 클라이언트와 다른 보안 레이블을 사용하여 실행되도록하는 기능을 제공합니다 (예 : 행이 생략되거나 저장된 값의 정밀도가 감소 될 수 있음) . 기능이 신뢰할 수있는 절차로 작동하는지 여부는 보안 레이블과 운영 체제 보안 정책에 의해 제어됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16d4cf557b86ec41315e510d2c0a1e98aa461ec5" translate="yes" xml:space="preserve">
          <source>Trusted procedures are similar to security definer functions or setuid commands. SELinux provides a feature to allow trusted code to run using a security label different from that of the client, generally for the purpose of providing highly controlled access to sensitive data (e.g., rows might be omitted, or the precision of stored values might be reduced). Whether or not a function acts as a trusted procedure is controlled by its security label and the operating system security policy. For example:</source>
          <target state="translated">신뢰할 수있는 프로시 저는 보안 정의 자 기능 또는 setuid 명령과 유사합니다. SELinux는 일반적으로 민감한 데이터에 대한 고도로 제어 된 액세스를 제공하기 위해 클라이언트와 다른 보안 레이블을 사용하여 신뢰할 수있는 코드를 실행할 수있는 기능을 제공합니다 (예 : 행이 생략되거나 저장된 값의 정밀도가 감소 될 수 있음). ). 함수가 신뢰할 수있는 절차로 작동하는지 여부는 보안 레이블과 운영 체제 보안 정책에 의해 제어됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="dda25f309687ab89f219c2e9ed7108ec29e77f02" translate="yes" xml:space="preserve">
          <source>Try to parse WAL files stored in the specified directory, rather than in &lt;code&gt;pg_wal&lt;/code&gt;. This may be useful if the backup is stored in a separate location from the WAL archive.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; 이 아닌 지정된 디렉토리에 저장된 WAL 파일을 구문 분석하십시오 . 이는 백업이 WAL 아카이브와 별도의 위치에 저장되어있는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66a91624c0de6e82ae0fef2e1f06a35f0bd22897" translate="yes" xml:space="preserve">
          <source>Trying to update the same row twice in a single statement is not supported. Only one of the modifications takes place, but it is not easy (and sometimes not possible) to reliably predict which one. This also applies to deleting a row that was already updated in the same statement: only the update is performed. Therefore you should generally avoid trying to modify a single row twice in a single statement. In particular avoid writing &lt;code&gt;WITH&lt;/code&gt; sub-statements that could affect the same rows changed by the main statement or a sibling sub-statement. The effects of such a statement will not be predictable.</source>
          <target state="translated">단일 명령문에서 동일한 행을 두 번 업데이트하는 것은 지원되지 않습니다. 수정 중 하나만 발생하지만 어느 것을 확실하게 예측하는 것은 쉽지 않습니다 (때로는 불가능하지도 않습니다). 이는 동일한 명령문에서 이미 업데이트 된 행을 삭제하는 경우에도 적용됩니다. 업데이트 만 수행됩니다. 따라서 일반적으로 단일 명령문에서 단일 행을 두 번 수정하지 마십시오. 특히 기본 명령문 또는 형제 하위 명령문에 의해 변경된 동일한 행에 영향을 줄 수있는 &lt;code&gt;WITH&lt;/code&gt; 하위 명령문을 작성하지 마십시오 . 그러한 진술의 효과는 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b26f6753852a596fe51a0b24ba50ca61c0a5cc05" translate="yes" xml:space="preserve">
          <source>Tsearch2 Development Site &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/&lt;/a&gt;</source>
          <target state="translated">Tsearch2 개발 사이트 &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfb00a997a076b71d83b496d4907048db3c803c8" translate="yes" xml:space="preserve">
          <source>Tue, Tues</source>
          <target state="translated">화</target>
        </trans-unit>
        <trans-unit id="42e43b612a5dfae57ddf5929f0fb945ae83cbf61" translate="yes" xml:space="preserve">
          <source>Tuesday</source>
          <target state="translated">Tuesday</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="de9422afddf78236a21b50c7a1aae8eadf26c4b6" translate="yes" xml:space="preserve">
          <source>Tuple ID (TID) of locked row</source>
          <target state="translated">잠긴 행의 튜플 ID (TID)</target>
        </trans-unit>
        <trans-unit id="a288c729f3b11b14057ff94886b8d82b1b114cb1" translate="yes" xml:space="preserve">
          <source>Tuple Identifier</source>
          <target state="translated">튜플 식별자</target>
        </trans-unit>
        <trans-unit id="7f26ca0c5d69bec575e9ec24eeec65dfcec7bd62" translate="yes" xml:space="preserve">
          <source>Tuple deforming is the process of transforming an on-disk tuple (see &lt;a href=&quot;storage-page-layout#STORAGE-TUPLE-LAYOUT&quot;&gt;Section 68.6.1&lt;/a&gt;) into its in-memory representation. It can be accelerated by creating a function specific to the table layout and the number of columns to be extracted.</source>
          <target state="translated">튜플 변형은 온 디스크 튜플 ( &lt;a href=&quot;storage-page-layout#STORAGE-TUPLE-LAYOUT&quot;&gt;68.6.1&lt;/a&gt; 참조 )을 메모리 내 표현 으로 변환하는 프로세스입니다 . 테이블 레이아웃 및 추출 할 컬럼 수에 특정한 함수를 작성하여 가속화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e46b735d6cd66502b1333be16b366c854a2020" translate="yes" xml:space="preserve">
          <source>Tuple number targeted by the lock within the page, or null if the target is not a tuple</source>
          <target state="translated">페이지 내의 잠금이 대상으로하는 튜플 번호 또는 대상이 튜플이 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="ab650a1a4b8fdf3a4053ce8d277d335dd82e5447" translate="yes" xml:space="preserve">
          <source>Turkish</source>
          <target state="translated">Turkish</target>
        </trans-unit>
        <trans-unit id="f4049144a6e32c443901c30714628293045b3669" translate="yes" xml:space="preserve">
          <source>Turn off &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt;; there is no need to flush data to disk.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync를&lt;/a&gt; 끄십시오 . 디스크로 데이터를 플러시 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd6d343fd0c3083f0c7e90c0e461974b687534bf" translate="yes" xml:space="preserve">
          <source>Turn off &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;; there is no need to guard against partial page writes.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes를&lt;/a&gt; 끄십시오 . 부분 페이지 쓰기를 방지 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df8b7a87a09ca0a552f551d1eb119e7c2b44535c" translate="yes" xml:space="preserve">
          <source>Turn off &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;; there might be no need to force WAL writes to disk on every commit. This setting does risk transaction loss (though not data corruption) in case of a crash of the &lt;em&gt;database&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit을&lt;/a&gt; 끄십시오 . 모든 커밋마다 디스크에 WAL 쓰기를 강제 할 필요가 없습니다. 이 설정은 &lt;em&gt;데이터베이스&lt;/em&gt; 충돌시 트랜잭션이 손실 될 수 있습니다 (데이터 손상은 아님) .</target>
        </trans-unit>
        <trans-unit id="c25473f6f439ed3d685a7fc2f4053fbeaf6af493" translate="yes" xml:space="preserve">
          <source>Turn off printing of column names and result row count footers, etc. This is equivalent to &lt;code&gt;\t&lt;/code&gt; or &lt;code&gt;\pset tuples_only&lt;/code&gt;.</source>
          <target state="translated">열 이름 및 결과 행 수 바닥 글 등의 인쇄를 끄십시오. 이는 &lt;code&gt;\t&lt;/code&gt; 또는 &lt;code&gt;\pset tuples_only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c452943219408586e340ca7eae9dc9861f0212c" translate="yes" xml:space="preserve">
          <source>Turn on autocommit of transactions. In this mode, each SQL command is automatically committed unless it is inside an explicit transaction block. In the default mode, commands are committed only when &lt;code&gt;EXEC SQL COMMIT&lt;/code&gt; is issued.</source>
          <target state="translated">트랜잭션 자동 커밋을 켭니다. 이 모드에서 각 SQL 명령은 명시 적 트랜잭션 블록 내에 있지 않으면 자동으로 커미트됩니다. 기본 모드에서 명령은 &lt;code&gt;EXEC SQL COMMIT&lt;/code&gt; 가 발행 될 때만 커미트됩니다 .</target>
        </trans-unit>
        <trans-unit id="082802bc6506a1fb8c80b6b9796c7710bdeb3763" translate="yes" xml:space="preserve">
          <source>Turn on the expanded table formatting mode. This is equivalent to &lt;code&gt;\x&lt;/code&gt; or &lt;code&gt;\pset expanded&lt;/code&gt;.</source>
          <target state="translated">확장 테이블 형식화 모드를 켜십시오. 이것은 &lt;code&gt;\x&lt;/code&gt; 또는 &lt;code&gt;\pset expanded&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="11fbfd634f8b43b8d0336222eeb84c04d42fc674" translate="yes" xml:space="preserve">
          <source>Turning &lt;code&gt;deduplicate_items&lt;/code&gt; off via &lt;code&gt;ALTER INDEX&lt;/code&gt; prevents future insertions from triggering deduplication, but does not in itself make existing posting list tuples use the standard tuple representation.</source>
          <target state="translated">켜기 &lt;code&gt;deduplicate_items&lt;/code&gt; 을 통해 오프 &lt;code&gt;ALTER INDEX&lt;/code&gt; 는 중복 제거를 트리거에서 미래의 삽입을 방지 할 수 있지만 그 자체가 게시 목록 튜플 표준 튜플 표현을 사용하는 기존의하지에서 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ac524768d250e29de07aaee53faeda03896b32c" translate="yes" xml:space="preserve">
          <source>Turning &lt;code&gt;fastupdate&lt;/code&gt; off via &lt;code&gt;ALTER INDEX&lt;/code&gt; prevents future insertions from going into the list of pending index entries, but does not in itself flush previous entries. You might want to &lt;code&gt;VACUUM&lt;/code&gt; the table or call &lt;code&gt;gin_clean_pending_list&lt;/code&gt; function afterward to ensure the pending list is emptied.</source>
          <target state="translated">켜기 &lt;code&gt;fastupdate&lt;/code&gt; 을 통해 오프 &lt;code&gt;ALTER INDEX&lt;/code&gt; 는 계류중인 인덱스 항목의 목록에 들어 가지 미래 삽입을 방지 할 수 있지만 그 자체 플러시 이전 항목으로하지 않습니다. 보류중인 목록이 비워 졌는지 확인하기 위해 테이블 을 &lt;code&gt;VACUUM&lt;/code&gt; 하거나 &lt;code&gt;gin_clean_pending_list&lt;/code&gt; 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f12445322d4c10bb21d0f4cf2ccb90ed3605df43" translate="yes" xml:space="preserve">
          <source>Turning off this parameter does not affect use of WAL archiving for point-in-time recovery (PITR) (see &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;).</source>
          <target state="translated">이 매개 변수를 끄면 PITR (Point-In-Time Recovery)을위한 WAL 아카이빙 사용에는 영향을 미치지 않습니다 ( &lt;a href=&quot;continuous-archiving&quot;&gt;섹션 25.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1686b206d7cc35bb7f5514f93be0cb2800c13338" translate="yes" xml:space="preserve">
          <source>Turning this parameter off speeds normal operation, but might lead to either unrecoverable data corruption, or silent data corruption, after a system failure. The risks are similar to turning off &lt;code&gt;fsync&lt;/code&gt;, though smaller, and it should be turned off only based on the same circumstances recommended for that parameter.</source>
          <target state="translated">이 매개 변수를 끄면 정상 작동 속도가 빨라지지만 시스템 장애 후 복구 할 수없는 데이터 손상 또는 자동 데이터 손상이 발생할 수 있습니다. 위험은 &lt;code&gt;fsync&lt;/code&gt; 를 끄는 것과 비슷 하지만 해당 매개 변수에 권장되는 것과 동일한 환경에 따라 꺼야합니다.</target>
        </trans-unit>
        <trans-unit id="93c364b56baaa4f87c84df84869c49e931e78c4b" translate="yes" xml:space="preserve">
          <source>Turning this parameter on can reduce the WAL volume without increasing the risk of unrecoverable data corruption, but at the cost of some extra CPU spent on the compression during WAL logging and on the decompression during WAL replay.</source>
          <target state="translated">이 매개 변수를 켜면 복구 할 수없는 데이터 손상의 위험을 증가시키지 않으면 서 WAL 볼륨을 줄일 수 있지만 WAL 로깅 중 압축 및 WAL 재생 중 압축 해제에 일부 추가 CPU가 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="1fbf2fe24b1539aa2687ce60e2adbf515dad4763" translate="yes" xml:space="preserve">
          <source>Turns on HTML query output format. If the HTML format is already on, it is switched back to the default aligned text format. This command is for compatibility and convenience, but see &lt;code&gt;\pset&lt;/code&gt; about setting other output options.</source>
          <target state="translated">HTML 쿼리 출력 형식을 설정합니다. HTML 형식이 이미 켜져 있으면 기본 정렬 텍스트 형식으로 다시 전환됩니다. 이 명령은 호환성과 편의를위한 것이지만 다른 출력 옵션 설정에 대해서는 &lt;code&gt;\pset&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dd2e8d41b109545398675ecaa4d48e806818d15" translate="yes" xml:space="preserve">
          <source>Tutorial: Advanced Features</source>
          <target state="translated">튜토리얼 : 고급 기능</target>
        </trans-unit>
        <trans-unit id="462c9e67f015d8940f17ef1bf7e40741a0bcf586" translate="yes" xml:space="preserve">
          <source>Tutorial: Getting Started</source>
          <target state="translated">튜토리얼 : 시작하기</target>
        </trans-unit>
        <trans-unit id="2d479f44cf7a48c33abced080cd7b547c6bd3a7b" translate="yes" xml:space="preserve">
          <source>Tutorial: The SQL Language</source>
          <target state="translated">튜토리얼 : SQL 언어</target>
        </trans-unit>
        <trans-unit id="d96f74ad720891d7859b479263f4e39be9378130" translate="yes" xml:space="preserve">
          <source>Two GiST index operator classes are provided: &lt;code&gt;gist__int_ops&lt;/code&gt; (used by default) is suitable for small- to medium-size data sets, while &lt;code&gt;gist__intbig_ops&lt;/code&gt; uses a larger signature and is more suitable for indexing large data sets (i.e., columns containing a large number of distinct array values). The implementation uses an RD-tree data structure with built-in lossy compression.</source>
          <target state="translated">두 개의 GiST 인덱스 연산자 클래스가 제공됩니다. &lt;code&gt;gist__int_ops&lt;/code&gt; (기본적으로 사용됨)는 중소 규모 데이터 세트에 적합하고 &lt;code&gt;gist__intbig_ops&lt;/code&gt; 는 더 큰 서명을 사용하며 큰 데이터 세트 (예 : 별개의 배열 값). 구현시 손실 압축이 내장 된 RD- 트리 데이터 구조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fd21e98bab637ed7f2ea4e4b5c263e9096bd942d" translate="yes" xml:space="preserve">
          <source>Two functions are considered the same if they have the same names and &lt;em&gt;input&lt;/em&gt; argument types, ignoring any &lt;code&gt;OUT&lt;/code&gt; parameters. Thus for example these declarations conflict:</source>
          <target state="translated">&lt;code&gt;OUT&lt;/code&gt; 매개 변수를 무시하고 동일한 이름과 &lt;em&gt;입력&lt;/em&gt; 인수 유형 을 갖는 두 함수는 동일한 것으로 간주됩니다 . 따라서 예를 들어 이러한 선언은 충돌합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
