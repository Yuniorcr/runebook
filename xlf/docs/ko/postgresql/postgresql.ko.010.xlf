<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="1fc1fe1aaf9532782aa2ed49cabaa7db59b86f4e" translate="yes" xml:space="preserve">
          <source>If waiting is disabled, the requested action is triggered, but there is no feedback about its success. In that case, the server log file or an external monitoring system would have to be used to check the progress and success of the operation.</source>
          <target state="translated">대기가 비활성화되면 요청 된 작업이 트리거되지만 성공에 대한 피드백은 없습니다. 이 경우 서버 로그 파일 또는 외부 모니터링 시스템을 사용하여 작업 진행률과 성공 여부를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b03befc0afa9f43bd61408ea6224efc69f041cf" translate="yes" xml:space="preserve">
          <source>If we change the query's selectivity a bit, we might get a very different join plan:</source>
          <target state="translated">쿼리의 선택성을 약간 변경하면 매우 다른 조인 계획을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3514492aa3ac15aedee53bae788660dc8e748122" translate="yes" xml:space="preserve">
          <source>If we continuously feed the series of WAL files to another machine that has been loaded with the same base backup file, we have a &lt;em&gt;warm standby&lt;/em&gt; system: at any point we can bring up the second machine and it will have a nearly-current copy of the database.</source>
          <target state="translated">동일한 기본 백업 파일이로드 된 다른 머신에 일련의 WAL 파일을 지속적으로 공급하면 &lt;em&gt;웜 스탠바이&lt;/em&gt; 시스템이 있습니다. 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="a739f17951b6e075a348a61e8bb0affec3a10686" translate="yes" xml:space="preserve">
          <source>If we declared &lt;code&gt;cities&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt; to be &lt;code&gt;UNIQUE&lt;/code&gt; or a &lt;code&gt;PRIMARY KEY&lt;/code&gt;, this would not stop the &lt;code&gt;capitals&lt;/code&gt; table from having rows with names duplicating rows in &lt;code&gt;cities&lt;/code&gt;. And those duplicate rows would by default show up in queries from &lt;code&gt;cities&lt;/code&gt;. In fact, by default &lt;code&gt;capitals&lt;/code&gt; would have no unique constraint at all, and so could contain multiple rows with the same name. You could add a unique constraint to &lt;code&gt;capitals&lt;/code&gt;, but this would not prevent duplication compared to &lt;code&gt;cities&lt;/code&gt;.</source>
          <target state="translated">우리가 &lt;code&gt;cities&lt;/code&gt; 를 선언한다면 . &lt;code&gt;name&lt;/code&gt; 은 &lt;code&gt;UNIQUE&lt;/code&gt; 또는 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 이므로 &lt;code&gt;capitals&lt;/code&gt; 테이블이 &lt;code&gt;cities&lt;/code&gt; 에서 행을 복제하는 이름을 가진 행을 가지지 않습니다 . 중복 된 행은 기본적으로 &lt;code&gt;cities&lt;/code&gt; 쿼리에 표시됩니다 . 실제로 기본적으로 &lt;code&gt;capitals&lt;/code&gt; 는 고유 제한 조건이 없으므로 동일한 이름을 가진 여러 행을 포함 할 수 있습니다. &lt;code&gt;capitals&lt;/code&gt; 고유 한 제약 조건을 추가 할 수 있지만 &lt;code&gt;cities&lt;/code&gt; 비해 중복을 방지 할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="347337a04b51d83bd4c64fbb8fed60949423b25a" translate="yes" xml:space="preserve">
          <source>If we wanted to know what city (or cities) that reading occurred in, we might try:</source>
          <target state="translated">읽는 도시가 무엇인지 알고 싶다면 다음을 시도해보십시오.</target>
        </trans-unit>
        <trans-unit id="d101ff564aae9ba45b998f26d6b5819ae89be6cf" translate="yes" xml:space="preserve">
          <source>If we were to declare this index &lt;code&gt;UNIQUE&lt;/code&gt;, it would prevent creation of rows whose &lt;code&gt;col1&lt;/code&gt; values differ only in case, as well as rows whose &lt;code&gt;col1&lt;/code&gt; values are actually identical. Thus, indexes on expressions can be used to enforce constraints that are not definable as simple unique constraints.</source>
          <target state="translated">이 인덱스를 &lt;code&gt;UNIQUE&lt;/code&gt; 로 선언하면 &lt;code&gt;col1&lt;/code&gt; 값이 실제로 동일한 행뿐만 아니라 &lt;code&gt;col1&lt;/code&gt; 값이 다른 행만 작성할 수 없습니다 . 따라서 표현식의 인덱스를 사용하여 단순한 고유 제한 조건으로 정의 할 수없는 제한 조건을 시행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26385616d9682a5e8b9897f0b99ebecc8622b226" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">지속적으로 유지되는 일관성 보장이 아니라 행 삽입시 다른 행에 대해 일회성 검사를 원하는 경우 사용자 지정 &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;트리거&lt;/a&gt; 를 사용하여이를 구현할 수 있습니다. (이 방법은 pg_dump가 데이터를 다시로드 한 후에 트리거를 다시 설치하지 않으므로 덤프 / 다시로드 문제가 발생하지 않으므로 덤프 / 다시로드 중에 확인이 적용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="1a14ecb62361bc225683313f20ed64062f67ccd0" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">이미 큰 개체가 있거나 고아 인 것으로 의심되는 경우 &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; 모듈을 참조하여 정리하십시오. &lt;code&gt;lo_manage&lt;/code&gt; 트리거 에 대한 백스톱 으로 vacuumlo를 가끔 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f390f29503d5d3e24b107064bb2a33c6ee6ea964" translate="yes" xml:space="preserve">
          <source>If you are adding large amounts of data to an existing table, it might be a win to drop the indexes, load the table, and then recreate the indexes. Of course, the database performance for other users might suffer during the time the indexes are missing. One should also think twice before dropping a unique index, since the error checking afforded by the unique constraint will be lost while the index is missing.</source>
          <target state="translated">기존 테이블에 많은 양의 데이터를 추가하는 경우 인덱스를 삭제하고 테이블을로드 한 다음 인덱스를 다시 작성하는 것이 좋습니다. 물론 인덱스가 누락 된 동안 다른 사용자의 데이터베이스 성능이 저하 될 수 있습니다. 고유 제한 조건에 의해 제공된 오류 점검은 색인이 누락 된 동안 유실되므로 고유 색인을 삭제하기 전에 두 번 생각해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9e2dec1d154e8ddecdda1dfc7964b3ebcabb443" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">PostgreSQL을 직접 설치하는 경우 설치 지침은 &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;16 장&lt;/a&gt; 을 참조 하고 설치가 완료되면이 안내서로 돌아가십시오. 적절한 환경 변수 설정에 대한 섹션을 자세히 따르십시오.</target>
        </trans-unit>
        <trans-unit id="deb64bee8b7a2efcbeba6cf8a6dff70e83085729" translate="yes" xml:space="preserve">
          <source>If you are loading a freshly created table, the fastest method is to create the table, bulk load the table's data using &lt;code&gt;COPY&lt;/code&gt;, then create any indexes needed for the table. Creating an index on pre-existing data is quicker than updating it incrementally as each row is loaded.</source>
          <target state="translated">새로 작성된 테이블을로드하는 경우 가장 빠른 방법은 테이블을 작성하고 &lt;code&gt;COPY&lt;/code&gt; 를 사용하여 테이블의 데이터를 대량로드 한 다음 테이블에 필요한 인덱스를 작성하는 것입니다. 기존 데이터에 대한 인덱스를 만드는 것이 각 행이로드 될 때 점차적으로 업데이트하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d87d9e34c581612e87603daaced88774ab9fe111" translate="yes" xml:space="preserve">
          <source>If you are not planning to use prepared transactions, this parameter should be set to zero to prevent accidental creation of prepared transactions. If you are using prepared transactions, you will probably want &lt;code&gt;max_prepared_transactions&lt;/code&gt; to be at least as large as &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;, so that every session can have a prepared transaction pending.</source>
          <target state="translated">준비된 트랜잭션을 사용하지 않으려는 경우 실수로 준비된 트랜잭션이 작성되지 않도록이 매개 변수를 0으로 설정해야합니다. 준비된 트랜잭션을 사용 하는 경우 모든 세션이 준비된 트랜잭션 보류를 가질 수 있도록 &lt;code&gt;max_prepared_transactions&lt;/code&gt; 가 최소한 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; 만큼 커지길 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ca7f65648bc353887b727a182f8f612fdb9429de" translate="yes" xml:space="preserve">
          <source>If you are not sure whether PostgreSQL is already available or whether you can use it for your experimentation then you can install it yourself. Doing so is not hard and it can be a good exercise. PostgreSQL can be installed by any unprivileged user; no superuser (root) access is required.</source>
          <target state="translated">PostgreSQL이 이미 사용 가능한지 또는 실험에 사용할 수 있는지 확실하지 않은 경우 직접 설치할 수 있습니다. 그렇게하는 것은 어렵지 않으며 좋은 운동이 될 수 있습니다. 권한이없는 사용자는 PostgreSQL을 설치할 수 있습니다. 수퍼 유저 (루트) 액세스가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c854ded65666fb7e53665772a506fafbd718961" translate="yes" xml:space="preserve">
          <source>If you are running file-based log shipping (&quot;warm standby&quot;), you might need to wait until the next WAL file arrives, which could be as long as the &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary.</source>
          <target state="translated">파일 기반 로그 전달 ( &quot;warm standby&quot;)을 실행중인 경우 다음 WAL 파일이 도착할 때까지 기다려야 할 수 있습니다 .이 값은 기본 에서 &lt;code&gt;archive_timeout&lt;/code&gt; 설정일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="100df6210b436366664b5674494d353d329c78c1" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g. &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">구성 파일 전용 디렉토리를 사용하는 PostgreSQL 9.2 이전 클러스터를 업그레이드하는 경우 실제 데이터 디렉토리 위치를 pg_upgrade로 전달하고 구성 디렉토리 위치를 서버로 전달해야합니다 (예 : &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6433dfa1c8ec93408de2c79d0f13ec3cb038d812" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, change &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;replica&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;10 단계에&lt;/a&gt; 요약 된 방법을 사용하여 대기 서버를 업그레이드 하는 경우 이전 기본 및 대기 클러스터에 대해 pg_controldata를 실행하여 이전 대기 서버가 걸리는지 확인하십시오. &amp;ldquo;최신 체크 포인트 위치&amp;rdquo;값이 모든 클러스터에서 일치하는지 확인하십시오. (이전 대기 서버가 이전 기본 서버 이전에 종료되었거나 이전 대기 서버가 여전히 실행중인 경우 불일치가 발생합니다.) 또한 새 기본 클러스터 의 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 에서 &lt;code&gt;wal_level&lt;/code&gt; 을 &lt;code&gt;replica&lt;/code&gt; 로 변경 하십시오.</target>
        </trans-unit>
        <trans-unit id="4f73d78215cef8d2ef14222445477bdca411ef71" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;-X none&lt;/code&gt;, there is no guarantee that all WAL files required for the backup are archived at the end of backup.</source>
          <target state="translated">&lt;code&gt;-X none&lt;/code&gt; 을 사용 하는 경우 백업에 필요한 모든 WAL 파일이 백업 종료시 아카이브된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e87540bbfb46f5ca553285a02a78a4413f99dfe1" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g. &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">버전 별 설치 디렉토리 (예 : &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt; )를 사용하는 경우 이전 클러스터를 이동할 필요가 없습니다. 그래픽 설치 프로그램은 모두 버전 별 설치 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="afb6b5bbb35f9c84113d155adac8b2ce50841366" translate="yes" xml:space="preserve">
          <source>If you are using manual &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; commands, don't forget that you need to run them on each child table individually. A command like:</source>
          <target state="translated">수동 &lt;code&gt;VACUUM&lt;/code&gt; 또는 &lt;code&gt;ANALYZE&lt;/code&gt; 명령을 사용하는 경우 각 하위 테이블에서 개별적으로 명령을 실행해야합니다. 다음과 같은 명령 :</target>
        </trans-unit>
        <trans-unit id="657742cf08661b004524bce37cea4f60251b3473" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g. solid-state drives, might also be better modeled with a lower value for random_page_cost.</source>
          <target state="translated">90 %의 캐시 속도가 워크로드에 대해 잘못된 가정이라고 생각되면 random_page_cost를 증가시켜 실제 스토리지 읽기 비용을 더 잘 반영 할 수 있습니다. 따라서 데이터베이스가 총 서버 메모리보다 작은 경우와 같이 데이터가 캐시에 완전히있을 가능성이있는 경우 random_page_cost를 줄이는 것이 적절할 수 있습니다. 순차 드라이브 (예 : 솔리드 스테이트 드라이브)에 비해 랜덤 읽기 비용이 낮은 스토리지는 random_page_cost 값이 낮을수록 더 잘 모델링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de352785d4d320deb71e5335924b75625cf49620" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;\set&lt;/code&gt; without a second argument, the variable is set to an empty-string value. To unset (i.e., delete) a variable, use the command &lt;code&gt;\unset&lt;/code&gt;. To show the values of all variables, call &lt;code&gt;\set&lt;/code&gt; without any argument.</source>
          <target state="translated">두 번째 인수없이 &lt;code&gt;\set&lt;/code&gt; 을 호출 하면 변수가 빈 문자열 값으로 설정됩니다. 변수를 설정 해제 (즉, 삭제)하려면 &lt;code&gt;\unset&lt;/code&gt; 명령을 사용하십시오 . 모든 변수의 값을 표시하려면 인수없이 &lt;code&gt;\set&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="0259699cb6f3b30e1cd0e413c4e39248024e19a0" translate="yes" xml:space="preserve">
          <source>If you cannot free up additional space on the disk by deleting other things, you can move some of the database files to other file systems by making use of tablespaces. See &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt; for more information about that.</source>
          <target state="translated">다른 항목을 삭제하여 디스크의 추가 공간을 확보 할 수없는 경우 테이블 스페이스를 사용하여 일부 데이터베이스 파일을 다른 파일 시스템으로 이동할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;22.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6b2ee409cca3f880cf89818705f66642823737c" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;code&gt;COPY&lt;/code&gt;, it might help to use &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; to create a prepared &lt;code&gt;INSERT&lt;/code&gt; statement, and then use &lt;code&gt;EXECUTE&lt;/code&gt; as many times as required. This avoids some of the overhead of repeatedly parsing and planning &lt;code&gt;INSERT&lt;/code&gt;. Different interfaces provide this facility in different ways; look for &amp;ldquo;prepared statements&amp;rdquo; in the interface documentation.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 를 사용할 수없는 경우 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; 를 사용하여 준비된 &lt;code&gt;INSERT&lt;/code&gt; 문 을 작성한 후 &lt;code&gt;EXECUTE&lt;/code&gt; 를 필요한만큼 사용 하는 것이 도움이 될 수 있습니다 . 이렇게하면 &lt;code&gt;INSERT&lt;/code&gt; 반복 구문 분석 및 계획의 오버 헤드가 발생하지 않습니다 . 인터페이스마다 다른 방식으로이 기능을 제공합니다. 인터페이스 설명서에서 &quot;준비된 명령문&quot;을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="f74f5e82fb19007ba8087ea69c4af7c169641fbd" translate="yes" xml:space="preserve">
          <source>If you cannot, then better do crypto inside client application.</source>
          <target state="translated">당신이 할 수 없다면, 클라이언트 응용 프로그램 내부에서 암호화를하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6938a67160fbaea3812e5c1afc009d637ef7fc7" translate="yes" xml:space="preserve">
          <source>If you declare a column as &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt;, the implicitly generated index is case-sensitive. So it's useless for case-insensitive searches, and it won't enforce uniqueness case-insensitively.</source>
          <target state="translated">열을 &lt;code&gt;UNIQUE&lt;/code&gt; 또는 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 로 선언 하면 내재적으로 생성 된 인덱스는 대소 문자를 구분합니다. 따라서 대소 문자를 구분하지 않는 검색에는 쓸모가 없으며 대소 문자를 구분하지 않고 고유성을 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bab8b24944cb37a1a0e9e93c41e90f5a2cb6ccb4" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; start the new cluster, the old cluster was unmodified except that, when linking started, a &lt;code&gt;.old&lt;/code&gt; suffix was appended to &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;. To reuse the old cluster, remove the &lt;code&gt;.old&lt;/code&gt; suffix from &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;; you can then restart the old cluster.</source>
          <target state="translated">당신이 않았다면 &lt;em&gt;하지&lt;/em&gt; 시작 링크 할 때 새 클러스터를 시작, 기존 클러스터는 점을 제외하고 수정되지 않은했다,하는 &lt;code&gt;.old&lt;/code&gt; 로 접미사에 추가 된 &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; . 이전 클러스터를 재사용하려면 &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; 에서 &lt;code&gt;.old&lt;/code&gt; 접미 부를 제거하십시오 . 그런 다음 이전 클러스터를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b2adb362a08de49cfa1c83dea8a83d9bb2213c" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; use link mode, do not have or do not want to use rsync, or want an easier solution, skip the instructions in this section and simply recreate the standby servers once pg_upgrade completes and the new primary is running.</source>
          <target state="translated">당신이 않은 경우 &lt;em&gt;하지&lt;/em&gt; 링크 모드를 사용하지 않거나 rsync를 사용하지 않거나, 쉬운 솔루션을 원하는,이 섹션의 지침을 건너 뛰고 pg_upgrade이 완료 및 새 기본이 실행되면 대기 서버를 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="90981d7a01c90cf36de6cae3508f26abcc450f7b" translate="yes" xml:space="preserve">
          <source>If you did start the new cluster, it has written to shared files and it is unsafe to use the old cluster. The old cluster will need to be restored from backup in this case.</source>
          <target state="translated">새 클러스터를 시작한 경우 공유 파일에 기록되었으며 이전 클러스터를 사용하는 것이 안전하지 않습니다. 이 경우 이전 클러스터를 백업에서 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="47fd87d8debe284e9f481467ae1affc261e54ea8" translate="yes" xml:space="preserve">
          <source>If you do not like the output format for &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; values, try the functions &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, and &lt;code&gt;abbrev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 또는 &lt;code&gt;cidr&lt;/code&gt; 값 의 출력 형식이 마음에 들지 않으면 &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;text&lt;/code&gt; 및 &lt;code&gt;abbrev&lt;/code&gt; 함수를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="f96a8ec302a42bc03e998712a66f544972ee1509" translate="yes" xml:space="preserve">
          <source>If you do not succeed in adjusting the costs to be more appropriate, then you might have to resort to forcing index usage explicitly. You might also want to contact the PostgreSQL developers to examine the issue.</source>
          <target state="translated">비용을보다 적절하게 조정하는 데 성공하지 못하면 인덱스 사용을 명시 적으로 강제해야합니다. PostgreSQL 개발자에게 문의하여 문제를 조사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4cd7de986e411178ee91fc3fe47680a23518cd4" translate="yes" xml:space="preserve">
          <source>If you do not supply the database name then it will default to your user account name. You already discovered this scheme in the previous section using &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">데이터베이스 이름을 제공하지 않으면 기본적으로 사용자 계정 이름이 사용됩니다. 이전 섹션에서 &lt;code&gt;createdb&lt;/code&gt; 를 사용하여이 체계를 이미 발견했습니다 .</target>
        </trans-unit>
        <trans-unit id="be339a6a88d4d2b9b65bab603b8e3c0d2fd399fd" translate="yes" xml:space="preserve">
          <source>If you do not want to use your database anymore you can remove it. For example, if you are the owner (creator) of the database &lt;code&gt;mydb&lt;/code&gt;, you can destroy it using the following command:</source>
          <target state="translated">더 이상 데이터베이스를 사용하지 않으려면 제거 할 수 있습니다. 예를 들어, &lt;code&gt;mydb&lt;/code&gt; 데이터베이스의 소유자 (작성자) 인 경우 다음 명령을 사용하여 데이터베이스 를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e08381cd8f923213bb0bae5a2a61f673142186" translate="yes" xml:space="preserve">
          <source>If you don't have values for all the columns, you can omit some of them. In that case, the columns will be filled with their default values. For example:</source>
          <target state="translated">모든 열에 대한 값이없는 경우 일부 열을 생략 할 수 있습니다. 이 경우 열이 기본값으로 채워집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="404e82d0a58303983c4b5022b612f1fb6248be48" translate="yes" xml:space="preserve">
          <source>If you drop and then recreate a function, the new function is not the same entity as the old; you will have to drop existing rules, views, triggers, etc. that refer to the old function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; to change a function definition without breaking objects that refer to the function. Also, &lt;code&gt;ALTER FUNCTION&lt;/code&gt; can be used to change most of the auxiliary properties of an existing function.</source>
          <target state="translated">함수를 삭제 한 다음 다시 작성하면 새 함수는 이전 함수와 동일한 엔티티가 아닙니다. 기존 기능을 참조하는 기존 규칙,보기, 트리거 등을 삭제해야합니다. 함수를 참조하는 오브젝트를 손상시키지 않고 함수 정의를 변경 하려면 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 을 사용 하십시오. 또한 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 을 사용하여 기존 기능의 대부분의 보조 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be307ca6bbc030429d0d787ca8543b0973b17c65" translate="yes" xml:space="preserve">
          <source>If you encounter problems starting &lt;code&gt;psql&lt;/code&gt; then go back to the previous section. The diagnostics of &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;psql&lt;/code&gt; are similar, and if the former worked the latter should work as well.</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; 을 시작하는 데 문제가 발생 하면 이전 섹션으로 돌아가십시오. &lt;code&gt;createdb&lt;/code&gt; 및 &lt;code&gt;psql&lt;/code&gt; 의 진단 은 비슷하며 전자가 작동하면 후자가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b13cd3cf02514f3a86f3431f0fe84ad64d68a6f3" translate="yes" xml:space="preserve">
          <source>If you feel you need more introductory material, please visit the PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;web site&lt;/a&gt; for links to more resources.</source>
          <target state="translated">더 많은 소개 자료가 필요하다고 생각되면 PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;웹 사이트&lt;/a&gt; 를 방문하여 더 많은 리소스에 대한 링크를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="27223facca9dbba24447f51ca3cc46e2a4d4b2ed" translate="yes" xml:space="preserve">
          <source>If you get an &amp;ldquo;illegal system call&amp;rdquo; error, it is likely that shared memory or semaphores are not supported in your kernel at all. In that case your only option is to reconfigure the kernel to enable these features.</source>
          <target state="translated">&quot;잘못된 시스템 호출&quot;오류가 발생하면 커널에서 공유 메모리 또는 세마포어가 전혀 지원되지 않을 수 있습니다. 이 경우 유일한 기능은 이러한 기능을 사용하도록 커널을 재구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7aa554ad85b0e28436475081421e4e00eaf4dd3c" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; turned off, any backslashes you write in literal string constants will need to be doubled. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; 를 끈 경우 리터럴 문자열 상수로 쓰는 백 슬래시를 두 배로 늘려야합니다. 자세한 정보는 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;4.1.2.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f61cc65bca02db4eb1ea500b6eae076fd93f0491" translate="yes" xml:space="preserve">
          <source>If you have a dedicated database server with 1GB or more of RAM, a reasonable starting value for &lt;code&gt;shared_buffers&lt;/code&gt; is 25% of the memory in your system. There are some workloads where even larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; are effective, but because PostgreSQL also relies on the operating system cache, it is unlikely that an allocation of more than 40% of RAM to &lt;code&gt;shared_buffers&lt;/code&gt; will work better than a smaller amount. Larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; usually require a corresponding increase in &lt;code&gt;max_wal_size&lt;/code&gt;, in order to spread out the process of writing large quantities of new or changed data over a longer period of time.</source>
          <target state="translated">RAM이 1GB 이상인 전용 데이터베이스 서버가있는 경우 &lt;code&gt;shared_buffers&lt;/code&gt; 의 합리적인 시작 값은 시스템 메모리의 25 %입니다. &lt;code&gt;shared_buffers&lt;/code&gt; 에 대한 더 큰 설정 이 효과적인 워크로드가 있지만 PostgreSQL도 운영 체제 캐시에 의존하기 때문에 &lt;code&gt;shared_buffers&lt;/code&gt; 에 RAM의 40 % 이상이 더 적은 양보다 더 잘 할당되지는 않습니다 . &lt;code&gt;shared_buffers&lt;/code&gt; 에 대한 더 큰 설정은 일반적으로 더 많은 양의 새로운 또는 변경된 데이터를 작성하는 프로세스를 더 오랜 기간에 걸쳐 확산시키기 위해 &lt;code&gt;max_wal_size&lt;/code&gt; 의 해당 증가를 필요로합니다 .</target>
        </trans-unit>
        <trans-unit id="5955ce4878872fc7d42a5cf4a3feceaf0ce085c2" translate="yes" xml:space="preserve">
          <source>If you have a table that contains both billed and unbilled orders, where the unbilled orders take up a small fraction of the total table and yet those are the most-accessed rows, you can improve performance by creating an index on just the unbilled rows. The command to create the index would look like this:</source>
          <target state="translated">청구되지 않은 주문과 청구되지 않은 주문이 모두 포함 된 테이블이있는 경우, 청구되지 않은 주문이 전체 테이블의 일부를 차지하지만 가장 많이 액세스되는 행인 경우 청구되지 않은 행에 대해서만 색인을 작성하여 성능을 향상시킬 수 있습니다. 색인을 작성하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3db868f1aa52b4182eabc5a6aaef64ca58b29be3" translate="yes" xml:space="preserve">
          <source>If you have a table whose entire contents are deleted on a periodic basis, consider doing it with &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; rather than using &lt;code&gt;DELETE&lt;/code&gt; followed by &lt;code&gt;VACUUM&lt;/code&gt;. &lt;code&gt;TRUNCATE&lt;/code&gt; removes the entire content of the table immediately, without requiring a subsequent &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; to reclaim the now-unused disk space. The disadvantage is that strict MVCC semantics are violated.</source>
          <target state="translated">전체 내용이 주기적으로 삭제 된 테이블이있는 경우 &lt;code&gt;DELETE&lt;/code&gt; 와 &lt;code&gt;VACUUM&lt;/code&gt; 을 사용하지 말고 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE를&lt;/a&gt; 사용하여 수행 하십시오 . &lt;code&gt;TRUNCATE&lt;/code&gt; 는 현재 사용하지 않는 디스크 공간을 되찾기 위해 후속 &lt;code&gt;VACUUM&lt;/code&gt; 또는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 요구하지 않고 테이블의 전체 내용을 즉시 제거합니다 . 단점은 엄격한 MVCC 시맨틱이 위반된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="edada2f4a0ea8a1fe6f35435a51d724440a997b9" translate="yes" xml:space="preserve">
          <source>If you have a user account but it does not have the privileges required to create a database, you will see the following:</source>
          <target state="translated">사용자 계정이 있지만 데이터베이스를 작성하는 데 필요한 권한이없는 경우 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e1ffd7834998be91b2b3ef3885c4c95ac1fca94" translate="yes" xml:space="preserve">
          <source>If you have an embedded SQL C source file named &lt;code&gt;prog1.pgc&lt;/code&gt;, you can create an executable program using the following sequence of commands:</source>
          <target state="translated">&lt;code&gt;prog1.pgc&lt;/code&gt; 라는 내장 SQL C 소스 파일이있는 경우 다음 명령 시퀀스를 사용하여 실행 가능 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a617edae0e90918be65ecbfa41a4edb3f6fbb0d" translate="yes" xml:space="preserve">
          <source>If you have dug into the details of the file system layout of the database, you might be tempted to try to back up or restore only certain individual tables or databases from their respective files or directories. This will &lt;em&gt;not&lt;/em&gt; work because the information contained in these files is not usable without the commit log files, &lt;code&gt;pg_xact/*&lt;/code&gt;, which contain the commit status of all transactions. A table file is only usable with this information. Of course it is also impossible to restore only a table and the associated &lt;code&gt;pg_xact&lt;/code&gt; data because that would render all other tables in the database cluster useless. So file system backups only work for complete backup and restoration of an entire database cluster.</source>
          <target state="translated">데이터베이스의 파일 시스템 레이아웃에 대한 세부 사항을 파헤친 경우 해당 파일 또는 디렉토리에서 특정 개별 테이블 또는 데이터베이스 만 백업하거나 복원하려고 시도 할 수 있습니다. 이 의지 &lt;em&gt;하지&lt;/em&gt; (가) 로그 파일을 커밋하지 않고 작업은이 파일에 포함 된 정보는 사용할 수 없습니다 때문에 &lt;code&gt;pg_xact/*&lt;/code&gt; 는 모든 트랜잭션의 상태를 커밋이 포함되어있다. 이 정보만으로 테이블 파일을 사용할 수 있습니다. 물론 데이터베이스 클러스터의 다른 모든 테이블을 쓸모 없게 만들므로 테이블과 관련 &lt;code&gt;pg_xact&lt;/code&gt; 데이터 만 복원하는 것도 불가능합니다 . 따라서 파일 시스템 백업은 전체 데이터베이스 클러스터의 완전한 백업 및 복원에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b1fdfd0de9a85f5bba1c48c08c54c2308c8c0754" translate="yes" xml:space="preserve">
          <source>If you have not set up an external transaction manager to track prepared transactions and ensure they get closed out promptly, it is best to keep the prepared-transaction feature disabled by setting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; to zero. This will prevent accidental creation of prepared transactions that might then be forgotten and eventually cause problems.</source>
          <target state="translated">준비된 트랜잭션을 추적하고 즉시 닫히도록 외부 트랜잭션 관리자를 설정하지 않은 경우 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; 를 0 으로 설정하여 준비된 트랜잭션 기능을 사용하지 않는 것이 가장 좋습니다 . 이렇게하면 실수로 준비된 트랜잭션이 생성되지 않고 잊혀져 결국에는 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4113594099b8ceaba5516ae6559f67b321dd3f1a" translate="yes" xml:space="preserve">
          <source>If you have pattern matching needs that go beyond this, consider writing a user-defined function in Perl or Tcl.</source>
          <target state="translated">이 이상의 패턴 일치 요구가있는 경우 Perl 또는 Tcl에서 사용자 정의 함수 작성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aedcf3e1663bdb52e36d3e2d02ae7396863fa330" translate="yes" xml:space="preserve">
          <source>If you have relocated &lt;code&gt;pg_wal&lt;/code&gt; outside the data directories, rsync must be run on those directories too.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; 을 데이터 디렉토리 외부 로 재배치 한 경우 해당 디렉토리에서도 rsync를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="a07426ce8ecfc80c9d7a4edfcb98cf0ba611138f" translate="yes" xml:space="preserve">
          <source>If you have tablespaces, you will need to run a similar rsync command for each tablespace directory, e.g.:</source>
          <target state="translated">테이블 스페이스가있는 경우 각 테이블 스페이스 디렉토리에 대해 유사한 rsync 명령을 실행해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="74d92589027830b748d75a72665251c799371e5f" translate="yes" xml:space="preserve">
          <source>If you have the space to do so, copy the whole cluster data directory and any tablespaces to a temporary location in case you need them later. Note that this precaution will require that you have enough free space on your system to hold two copies of your existing database. If you do not have enough space, you should at least save the contents of the cluster's &lt;code&gt;pg_wal&lt;/code&gt; subdirectory, as it might contain logs which were not archived before the system went down.</source>
          <target state="translated">필요한 공간이 있으면 나중에 필요할 경우 전체 클러스터 데이터 디렉토리 및 테이블 스페이스를 임시 위치에 복사하십시오. 이 예방 조치를 수행하려면 시스템에 기존 데이터베이스의 두 사본을 보유 할 수있는 충분한 여유 공간이 있어야합니다. 공간이 충분하지 않으면 시스템이 다운되기 전에 아카이브되지 않은 로그를 포함 할 수 있으므로 적어도 클러스터의 &lt;code&gt;pg_wal&lt;/code&gt; 서브 디렉토리 의 내용을 저장해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c405c350a4bec28b591f01ed6531218b06904979" translate="yes" xml:space="preserve">
          <source>If you have to &amp;ldquo;hop&amp;rdquo; to the database server via some login host, one possible setup could look like this:</source>
          <target state="translated">일부 로그인 호스트를 통해 데이터베이스 서버에 &quot;홉&quot;해야하는 경우 가능한 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1467a82f0f1d2aed2302c816a743bd03ff5d6fe" translate="yes" xml:space="preserve">
          <source>If you have turned off &lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt; then the activity indicator is not updated; the process title is set only once when a new process is launched. On some platforms this saves a measurable amount of per-command overhead; on others it's insignificant.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt; 을 끄면 활동 표시기가 업데이트되지 않습니다. 프로세스 제목은 새 프로세스가 시작될 때 한 번만 설정됩니다. 일부 플랫폼에서는 측정 가능한 명령 당 오버 헤드가 줄어 듭니다. 다른 사람들에게는 그것은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cdc8af27dd93a99e3339ed60a27d59629c7d68fb" translate="yes" xml:space="preserve">
          <source>If you have unarchived WAL segment files that you saved in step 2, copy them into &lt;code&gt;pg_wal/&lt;/code&gt;. (It is best to copy them, not move them, so you still have the unmodified files if a problem occurs and you have to start over.)</source>
          <target state="translated">2 단계에서 저장 한 WAL 세그먼트 파일을 아카이브하지 않은 경우 &lt;code&gt;pg_wal/&lt;/code&gt; 복사하십시오 . (복사하지 말고 복사하는 것이 가장 좋습니다. 따라서 문제가 발생하여 다시 시작해야하는 경우 수정되지 않은 파일이 남아 있습니다.)</target>
        </trans-unit>
        <trans-unit id="f602421c44c7955b1682bc7b3fca54acb52d429c" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g. &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 를 수정 한 경우 원래 설정을 복원하십시오. 이전 클러스터와 일치하도록 새 클러스터의 다른 구성 파일 (예 : &lt;code&gt;postgresql.conf&lt;/code&gt; ) 을 조정해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9316b03fae64e8c508527fbd0a6b640ef4256fda" translate="yes" xml:space="preserve">
          <source>If you modify files in &lt;code&gt;.../share/timezonesets/&lt;/code&gt;, it is up to you to make backups &amp;mdash; a normal database dump will not include this directory.</source>
          <target state="translated">&lt;code&gt;.../share/timezonesets/&lt;/code&gt; 에서 파일을 수정 하면 백업을 수행하는 것은 사용자의 책임입니다. 일반적인 데이터베이스 덤프에는이 디렉토리가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a80020f6d5771b4994b2b6087bde0a758b0dbcc3" translate="yes" xml:space="preserve">
          <source>If you need to modify a table that already exists, see &lt;a href=&quot;ddl-alter&quot;&gt;Section 5.6&lt;/a&gt; later in this chapter.</source>
          <target state="translated">이미 존재하는 테이블을 수정해야 할 경우이 장의 뒷부분에 나오는 &lt;a href=&quot;ddl-alter&quot;&gt;5.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2efd34e960254e7fbc24d4c21228c55d47bceff1" translate="yes" xml:space="preserve">
          <source>If you need to re-create a standby server while transactions are waiting, make sure that the commands pg_start_backup() and pg_stop_backup() are run in a session with &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt;, otherwise those requests will wait forever for the standby to appear.</source>
          <target state="translated">트랜잭션이 대기중인 동안 대기 서버를 다시 작성해야하는 경우 pg_start_backup () 및 pg_stop_backup () 명령이 &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt; 세션에서 실행되는지 확인하십시오 . 그렇지 않으면 해당 요청이 대기가 나타날 때까지 영원히 대기합니다.</target>
        </trans-unit>
        <trans-unit id="335eb5a28fe752ac43ab7d0bdb87c591351c3327" translate="yes" xml:space="preserve">
          <source>If you no longer need a table, you can remove it using the &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; command. For example:</source>
          <target state="translated">더 이상 테이블이 필요하지 않으면 &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; 명령을 사용하여 테이블을 제거 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b094a7de4e477575e2b8864dd2a1871a2ac7be9" translate="yes" xml:space="preserve">
          <source>If you only need randomly-generated (version 4) UUIDs, consider using the &lt;code&gt;gen_random_uuid()&lt;/code&gt; function from the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module instead.</source>
          <target state="translated">임의로 생성 된 (버전 4) UUID 만 필요한 경우 &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; 모듈 에서 &lt;code&gt;gen_random_uuid()&lt;/code&gt; 함수를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="c7ec64742024abd88ac376b90c1b4516681087ea" translate="yes" xml:space="preserve">
          <source>If you really cannot keep as many synchronous standbys as requested then you should decrease the number of synchronous standbys that transaction commits must wait for responses from in &lt;code&gt;synchronous_standby_names&lt;/code&gt; (or disable it) and reload the configuration file on the primary server.</source>
          <target state="translated">요청 된 동기 대기 수를 실제로 유지할 수없는 경우 트랜잭션 커밋이 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 에서 응답을 대기 (또는 비활성화)하고 기본 서버에서 구성 파일을 다시로드 해야하는 동기 대기 수를 줄여야 합니다.</target>
        </trans-unit>
        <trans-unit id="afb9b1746ef64ef43e1c6a611287b8838f8bab6f" translate="yes" xml:space="preserve">
          <source>If you really need to do something like that, you can either write a custom operator or add explicit casts to your query:</source>
          <target state="translated">실제로 이와 같은 작업을 수행해야하는 경우 사용자 지정 연산자를 작성하거나 쿼리에 명시 적 캐스트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6cec6fc682547181945340072f15c49a175a52" translate="yes" xml:space="preserve">
          <source>If you require exact storage and calculations (such as for monetary amounts), use the &lt;code&gt;numeric&lt;/code&gt; type instead.</source>
          <target state="translated">정확한 저장 및 계산이 필요한 경우 (예 : 화폐 금액) &lt;code&gt;numeric&lt;/code&gt; 유형을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dda0ebbf2c21ed8ce369ceb9f7962ccab8e8d4c2" translate="yes" xml:space="preserve">
          <source>If you see a message similar to:</source>
          <target state="translated">다음과 유사한 메시지가 표시되는 경우 :</target>
        </trans-unit>
        <trans-unit id="5944bf42cb7e9bed827543dce0bb5da3eb25aaf4" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;select-only&lt;/code&gt; built-in (also &lt;code&gt;-S&lt;/code&gt;), only the &lt;code&gt;SELECT&lt;/code&gt; is issued.</source>
          <target state="translated">당신이 선택하면 &lt;code&gt;select-only&lt;/code&gt; 내장 (또한 &lt;code&gt;-S&lt;/code&gt; ) 만 &lt;code&gt;SELECT&lt;/code&gt; 가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="c440cbb3c75274ef5533f9dc20d09bc792bb4404" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;simple-update&lt;/code&gt; built-in (also &lt;code&gt;-N&lt;/code&gt;), steps 4 and 5 aren't included in the transaction. This will avoid update contention on these tables, but it makes the test case even less like TPC-B.</source>
          <target state="translated">&lt;code&gt;simple-update&lt;/code&gt; 기본 제공 (또한 &lt;code&gt;-N&lt;/code&gt; ) 을 선택하면 4 단계와 5 단계가 트랜잭션에 포함되지 않습니다. 이렇게하면 이러한 테이블에서 업데이트 경합이 발생하지 않지만 테스트 사례는 TPC-B와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="2410e185ebe01d4bbafd07fc62d71b97897582e4" translate="yes" xml:space="preserve">
          <source>If you set a nonempty value for &lt;code&gt;log_line_prefix&lt;/code&gt;, you should usually make its last character be a space, to provide visual separation from the rest of the log line. A punctuation character can be used too.</source>
          <target state="translated">&lt;code&gt;log_line_prefix&lt;/code&gt; 에 비어 있지 않은 값을 설정하면 일반적으로 마지막 로그 문자를 공백으로 만들어야 나머지 로그 라인과 시각적으로 분리 할 수 ​​있습니다. 문장 부호 문자도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="293043269744dfe0b2be9f58f146808d29c819d1" translate="yes" xml:space="preserve">
          <source>If you simply direct the stderr of &lt;code&gt;postgres&lt;/code&gt; into a file, you will have log output, but the only way to truncate the log file is to stop and restart the server. This might be acceptable if you are using PostgreSQL in a development environment, but few production servers would find this behavior acceptable.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 의 stderr을 파일로 보내면 로그 출력이 표시되지만 로그 파일을 자르는 유일한 방법은 서버를 중지했다가 다시 시작하는 것입니다. 개발 환경에서 PostgreSQL을 사용하는 경우이 방법이 적합 할 수 있지만이 동작이 허용되는 프로덕션 서버는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ce920b3e4b27527a0945161fb81196b0962a822" translate="yes" xml:space="preserve">
          <source>If you simply write:</source>
          <target state="translated">당신이 단순히 쓰는 경우 :</target>
        </trans-unit>
        <trans-unit id="86278d59973a9bff1da8685bc91d01d4bca2172c" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;prefix&lt;/code&gt;, that string is prepended to the query's column names to create the variable names to use:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 를 지정하면 해당 문자열은 쿼리의 열 이름 앞에 추가되어 사용할 변수 이름을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4293f633ad719b6229d97888e7c493efba01b4c4" translate="yes" xml:space="preserve">
          <source>If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the entire disk. In releases prior to 8.4, if no &lt;code&gt;%&lt;/code&gt; escapes were present, PostgreSQL would append the epoch of the new log file's creation time, but this is no longer the case.</source>
          <target state="translated">이스케이프없이 파일 이름을 지정하면 결국 전체 디스크를 채우지 않도록 로그 회전 유틸리티를 사용해야합니다. 8.4 이전의 릴리스에서 &lt;code&gt;%&lt;/code&gt; 이스케이프가 없으면 PostgreSQL은 새 로그 파일 작성 시간의 시대를 추가하지만 더 이상 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd2bed205787104a93fce03bc6421721af1bc122" translate="yes" xml:space="preserve">
          <source>If you specify columns, you probably have to escape the parentheses from the shell. (See examples below.)</source>
          <target state="translated">열을 지정하면 셸에서 괄호를 이스케이프해야 할 수도 있습니다. (아래 예 참조)</target>
        </trans-unit>
        <trans-unit id="c697983f7b5aa306c7f0f7a672c31b1b3cec3536" translate="yes" xml:space="preserve">
          <source>If you suspect corruption of an index on a user table, you can simply rebuild that index, or all indexes on the table, using &lt;code&gt;REINDEX INDEX&lt;/code&gt; or &lt;code&gt;REINDEX TABLE&lt;/code&gt;.</source>
          <target state="translated">사용자 테이블에서 인덱스의 손상이 의심되는 경우 &lt;code&gt;REINDEX INDEX&lt;/code&gt; 또는 &lt;code&gt;REINDEX TABLE&lt;/code&gt; 을 사용하여 해당 인덱스 또는 테이블의 모든 인덱스를 재 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="634ba98da8d49a37a8349e78baa14c6e91b78095" translate="yes" xml:space="preserve">
          <source>If you use link mode, the upgrade will be much faster (no file copying) and use less disk space, but you will not be able to access your old cluster once you start the new cluster after the upgrade. Link mode also requires that the old and new cluster data directories be in the same file system. (Tablespaces and &lt;code&gt;pg_wal&lt;/code&gt; can be on different file systems.) Clone mode provides the same speed and disk space advantages but does not cause the old cluster to be unusable once the new cluster is started. Clone mode also requires that the old and new data directories be in the same file system. This mode is only available on certain operating systems and file systems.</source>
          <target state="translated">링크 모드를 사용하면 업그레이드 속도가 훨씬 빨라지고 (파일 복사 안 됨) 디스크 공간이 줄어들지 만 업그레이드 후 새 클러스터를 시작하면 이전 클러스터에 액세스 할 수 없습니다. 또한 링크 모드에서는 이전 및 새 클러스터 데이터 디렉토리가 동일한 파일 시스템에 있어야합니다. (테이블 스페이스와 &lt;code&gt;pg_wal&lt;/code&gt; 은 다른 파일 시스템에 있을 수 있습니다.) 복제 모드는 동일한 속도 및 디스크 공간 이점을 제공하지만 새 클러스터가 시작된 후에는 이전 클러스터를 사용할 수 없습니다. 복제 모드에서는 이전 및 새 데이터 디렉토리가 동일한 파일 시스템에 있어야합니다. 이 모드는 특정 운영 체제 및 파일 시스템에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9e0a997d4a5f8ab6d05deb3608c7b48d1004eb" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_segments&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">파일 기반 연속 아카이브없이 스트리밍 복제를 사용하는 경우 서버는 대기가 수신하기 전에 이전 WAL 세그먼트를 재활용 할 수 있습니다. 이 경우 대기는 새 기본 백업에서 다시 초기화해야합니다. &lt;code&gt;wal_keep_segments&lt;/code&gt; 를 WAL 세그먼트가 너무 빨리 재순환되지 않도록 충분한 값 으로 설정 하거나 대기에 대한 복제 슬롯을 구성하여 이를 피할 수 있습니다 . 대기에서 액세스 할 수있는 WAL 아카이브를 설정 한 경우 대기는 항상 충분한 세그먼트를 보유한 경우 아카이브를 사용하여 따라 잡을 수 있으므로 이러한 솔루션은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="410c6fd96b75590acd8e3654ea56e9babc9667ce" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command.</source>
          <target state="translated">&lt;code&gt;\o&lt;/code&gt; 명령을 사용 하여 조회 출력을 재지 &lt;code&gt;\qecho&lt;/code&gt; 경우이 명령 대신 \ qecho 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dacf2afd67d1d9e6693b9e34a44e3f31343f07b9" translate="yes" xml:space="preserve">
          <source>If you used link mode and have Streaming Replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) or Log-Shipping (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) standby servers, you can follow these steps to quickly upgrade them. You will not be running pg_upgrade on the standby servers, but rather rsync on the primary. Do not start any servers yet.</source>
          <target state="translated">링크 모드를 사용하고 스트리밍 복제 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;26.2.5&lt;/a&gt; 참조 ) 또는 로그 전달 ( &lt;a href=&quot;warm-standby&quot;&gt;26.2&lt;/a&gt; 참조 ) 대기 서버가있는 경우 다음 단계에 따라 빠르게 업그레이드 할 수 있습니다. 대기 서버에서는 pg_upgrade를 실행하지 않고 기본 서버에서는 rsync를 실행합니다. 아직 서버를 시작하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="46579b8a1d951df62d56dbc7236dffbdfa323aee" translate="yes" xml:space="preserve">
          <source>If you want an empty string rather than NULL, write double quotes:</source>
          <target state="translated">NULL이 아닌 빈 문자열을 원하면 큰 따옴표를 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="e23816131f85edfcf8ebf4baf1b8f5a4f82e1a1c" translate="yes" xml:space="preserve">
          <source>If you want the digest as a hexadecimal string, use &lt;code&gt;encode()&lt;/code&gt; on the result. For example:</source>
          <target state="translated">16 진수 문자열로 다이제스트를 원하면 결과에 &lt;code&gt;encode()&lt;/code&gt; 를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7212923c1936242a3a328b31eba624a84bab3c5" translate="yes" xml:space="preserve">
          <source>If you want the system to behave as if it had no locale support, use the special locale name &lt;code&gt;C&lt;/code&gt;, or equivalently &lt;code&gt;POSIX&lt;/code&gt;.</source>
          <target state="translated">시스템이 로케일을 지원하지 않는 것처럼 작동하려면 특수 로케일 이름 &lt;code&gt;C&lt;/code&gt; 또는 이와 동등한 &lt;code&gt;POSIX&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f51609486b727fbe8393280c5551d1122917313" translate="yes" xml:space="preserve">
          <source>If you want to add a new method of making the data representation smaller, you must implement it in &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; and also teach &lt;code&gt;Catalog::ParseData()&lt;/code&gt; how to expand the data back into the full representation.</source>
          <target state="translated">데이터 표현을 더 작게 만드는 새로운 방법을 추가하려면 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 에서 구현하고 &lt;code&gt;Catalog::ParseData()&lt;/code&gt; 에 데이터를 다시 전체 표현으로 확장하는 방법을 가르쳐야 합니다.</target>
        </trans-unit>
        <trans-unit id="7f058b6974f7c4fc1a4fda33213fb953c4c820d2" translate="yes" xml:space="preserve">
          <source>If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.</source>
          <target state="translated">중요한 경우에 대해 이러한 유형을 사용하여 복잡한 계산을 수행하려는 경우, 특히 경계 사례 (무한도, 언더 플로)의 특정 동작에 의존하는 경우 구현을 신중하게 평가해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8d0dd9f6c3474fc520b6c68678cb5772392894d" translate="yes" xml:space="preserve">
          <source>If you want to have a double quote in the output you must precede it with a backslash, for example &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt;. Backslashes are not otherwise special outside of double-quoted strings. Within a double-quoted string, a backslash causes the next character to be taken literally, whatever it is (but this has no special effect unless the next character is a double quote or another backslash).</source>
          <target state="translated">출력에 큰 따옴표를 사용하려면 백 슬래시를 선행해야합니다 (예 : &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt; . 백 슬래시는 큰 따옴표로 묶인 문자열 외부에서 특별하지 않습니다. 큰 따옴표로 묶인 문자열 내에서 백 슬래시는 다음 문자를 문자 그대로 취합니다 (그러나 다음 문자가 큰 따옴표 나 다른 백 슬래시가 아닌 한 특별한 효과는 없습니다).</target>
        </trans-unit>
        <trans-unit id="b08912c8afafc035000c2b91395d4762ff623ba7" translate="yes" xml:space="preserve">
          <source>If you want to recover to some previous point in time (say, right before the junior DBA dropped your main transaction table), just specify the required &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;stopping point&lt;/a&gt;. You can specify the stop point, known as the &amp;ldquo;recovery target&amp;rdquo;, either by date/time, named restore point or by completion of a specific transaction ID. As of this writing only the date/time and named restore point options are very usable, since there are no tools to help you identify with any accuracy which transaction ID to use.</source>
          <target state="translated">주니어 DBA가 메인 트랜잭션 테이블을 삭제하기 직전의 이전 시점으로 복구하려면 필요한 &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;중지 지점을&lt;/a&gt; 지정하십시오 . 날짜 / 시간, 명명 된 복원 지점 또는 특정 트랜잭션 ID를 완료하여 &quot;복구 대상&quot;이라고하는 중지 지점을 지정할 수 있습니다. 이 글을 쓰는 시점에서 날짜 / 시간 및 명명 된 복원 지점 옵션 만 사용할 수 있습니다. 사용할 트랜잭션 ID를 정확하게 식별 할 수있는 도구가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f2799eac42b252d1fdead69c5594bb2d3a2059fa" translate="yes" xml:space="preserve">
          <source>If you want to run a parallel dump of a pre-9.2 server, you need to make sure that the database content doesn't change from between the time the master connects to the database until the last worker job has connected to the database. The easiest way to do this is to halt any data modifying processes (DDL and DML) accessing the database before starting the backup. You also need to specify the &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; parameter when running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 PostgreSQL server.</source>
          <target state="translated">9.2 이전 서버의 병렬 덤프를 실행하려면 마스터가 데이터베이스에 연결 한 시간부터 마지막 ​​작업자 작업이 데이터베이스에 연결될 때까지 데이터베이스 내용이 변경되지 않아야합니다. 가장 쉬운 방법은 백업을 시작하기 전에 데이터베이스에 액세스하는 데이터 수정 프로세스 (DDL 및 DML)를 중지하는 것입니다. 또한 9.2 이전 PostgreSQL 서버에 대해 &lt;code&gt;pg_dump -j&lt;/code&gt; 를 실행할 때 &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; 매개 변수 를 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1235d6c60bdf10ad9cf9d8bf29ece023d11255aa" translate="yes" xml:space="preserve">
          <source>If you want to see the lines on the screen as they are read you must set the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">읽을 때 화면에서 행을 보려면 &lt;code&gt;ECHO&lt;/code&gt; 변수 를 &lt;code&gt;all&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d777fa853e95af192514bf1aeb804e6308b39ad2" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g. &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">링크 모드를 사용하고 새 클러스터가 시작될 때 이전 클러스터를 수정하지 않으려면 복제 모드 사용을 고려하십시오. 사용할 수없는 경우 이전 클러스터의 사본을 작성하고 링크 모드에서 업그레이드하십시오. 이전 클러스터의 유효한 사본 을 작성하려면 서버가 실행중인 동안 &lt;code&gt;rsync&lt;/code&gt; 를 사용하여 이전 클러스터 의 더티 사본을 작성한 다음 이전 서버를 종료하고 &lt;code&gt;rsync --checksum&lt;/code&gt; 을 다시 실행 하여 사본을 변경하여 사본을 갱신하십시오. 일관된. ( &lt;code&gt;rsync&lt;/code&gt; 에는 1 초의 파일 수정 시간 단위 만 있기 때문에 &lt;code&gt;--checksum&lt;/code&gt; 이 필요 합니다.) &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;섹션 25.3.3에&lt;/a&gt; 설명 된대로 &lt;code&gt;postmaster.pid&lt;/code&gt; 와 같은 일부 파일을 제외 할 수 있습니다.. 파일 시스템이 파일 시스템 스냅 샷 또는 COW (Copy-On-Write) 파일 사본을 지원하는 경우 스냅 샷과 사본을 동시에 작성하거나 데이터베이스 서버가 작동 중지 된 상태에서 작성해야하지만이를 사용하여 이전 클러스터와 테이블 공간을 백업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548498a07974c2669fa7d265bb5ed01fd29f2726" translate="yes" xml:space="preserve">
          <source>If you want to use psql to connect to several servers of different major versions, it is recommended that you use the newest version of psql. Alternatively, you can keep around a copy of psql from each major version and be sure to use the version that matches the respective server. But in practice, this additional complication should not be necessary.</source>
          <target state="translated">psql을 사용하여 다른 주요 버전의 여러 서버에 연결하려면 최신 버전의 psql을 사용하는 것이 좋습니다. 또는 각 주요 버전의 psql 사본을 보관하고 해당 서버와 일치하는 버전을 사용해야합니다. 그러나 실제로이 추가 합병증은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c83197bfbed6d42e302edf49770400c3bb7ffc90" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, fill in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; with a libpq connection string, including the host name (or IP address) and any additional details needed to connect to the primary server. If the primary needs a password for authentication, the password needs to be specified in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; as well.</source>
          <target state="translated">스트리밍 복제를 사용 하려면 호스트 이름 (또는 IP 주소) 및 기본 서버에 연결하는 데 필요한 추가 세부 사항을 포함하여 libpq 연결 문자열 로 &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; 를 채우십시오 . 기본에 인증을 위해 암호가 필요한 경우 &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; 에도 암호를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8304e11449eef667491dd46bf0e842007ab0620d" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, set up authentication on the primary server to allow replication connections from the standby server(s); that is, create a role and provide a suitable entry or entries in &lt;code&gt;pg_hba.conf&lt;/code&gt; with the database field set to &lt;code&gt;replication&lt;/code&gt;. Also ensure &lt;code&gt;max_wal_senders&lt;/code&gt; is set to a sufficiently large value in the configuration file of the primary server. If replication slots will be used, ensure that &lt;code&gt;max_replication_slots&lt;/code&gt; is set sufficiently high as well.</source>
          <target state="translated">스트리밍 복제를 사용하려면 기본 서버에서 인증을 설정하여 대기 서버에서 복제 연결을 허용하십시오. 즉, 역할을 만들고 데이터베이스 필드가 &lt;code&gt;replication&lt;/code&gt; 으로 설정된 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 적절한 항목을 제공하십시오 . 또한 기본 서버의 구성 파일에서 &lt;code&gt;max_wal_senders&lt;/code&gt; 가 충분히 큰 값으로 설정되어 있는지 확인 하십시오 . 복제 슬롯을 사용하는 경우 &lt;code&gt;max_replication_slots&lt;/code&gt; 도 충분히 높게 설정되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d505643f0e154d892e49d0ce311315a8a63b86fd" translate="yes" xml:space="preserve">
          <source>If you wish to create a new superuser, you must connect as a superuser, not merely with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. Being a superuser implies the ability to bypass all access permission checks within the database, so superuserdom should not be granted lightly.</source>
          <target state="translated">새 수퍼 유저를 만들려면 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이 아닌 수퍼 유저로 연결해야합니다 . 수퍼 유저는 데이터베이스 내에서 모든 액세스 권한 검사를 무시할 수있는 능력을 의미하므로 수퍼 유저에게 가볍게 부여해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="dba6f63305bb053e32c8873d900ab4a929146d0b" translate="yes" xml:space="preserve">
          <source>If you wish to drop a role for which the default privileges have been altered, it is necessary to reverse the changes in its default privileges or use &lt;code&gt;DROP OWNED BY&lt;/code&gt; to get rid of the default privileges entry for the role.</source>
          <target state="translated">기본 권한이 변경된 역할을 삭제하려면 기본 권한의 변경 사항을 되돌 리거나 &lt;code&gt;DROP OWNED BY&lt;/code&gt; 를 사용 하여 역할의 기본 권한 항목을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe513e6fe150eda65f8a240b4c5ab71cf30d3ea3" translate="yes" xml:space="preserve">
          <source>If you wish to keep the configuration files elsewhere than the data directory, the &lt;code&gt;postgres&lt;/code&gt;&lt;code&gt;-D&lt;/code&gt; command-line option or &lt;code&gt;PGDATA&lt;/code&gt; environment variable must point to the directory containing the configuration files, and the &lt;code&gt;data_directory&lt;/code&gt; parameter must be set in &lt;code&gt;postgresql.conf&lt;/code&gt; (or on the command line) to show where the data directory is actually located. Notice that &lt;code&gt;data_directory&lt;/code&gt; overrides &lt;code&gt;-D&lt;/code&gt; and &lt;code&gt;PGDATA&lt;/code&gt; for the location of the data directory, but not for the location of the configuration files.</source>
          <target state="translated">구성 파일을 데이터 디렉토리 이외의 위치에 유지하려면 &lt;code&gt;postgres&lt;/code&gt; &lt;code&gt;-D&lt;/code&gt; 명령 행 옵션 또는 &lt;code&gt;PGDATA&lt;/code&gt; 환경 변수가 구성 파일이 포함 된 디렉토리를 &lt;code&gt;data_directory&lt;/code&gt; 야하며 data_directory 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; (또는 on 데이터 디렉토리가 실제로 위치한 위치를 표시합니다. 공지 사항이 &lt;code&gt;data_directory&lt;/code&gt; 오버라이드 (override) &lt;code&gt;-D&lt;/code&gt; 및 &lt;code&gt;PGDATA&lt;/code&gt; 데이터 디렉토리의 위치가 아니라 구성 파일의 위치.</target>
        </trans-unit>
        <trans-unit id="5e43ef9c20e530883e37f2ea188b5ba2ab7b89db" translate="yes" xml:space="preserve">
          <source>If you wish, you can specify the configuration file names and locations individually using the parameters &lt;code&gt;config_file&lt;/code&gt;, &lt;code&gt;hba_file&lt;/code&gt; and/or &lt;code&gt;ident_file&lt;/code&gt;. &lt;code&gt;config_file&lt;/code&gt; can only be specified on the &lt;code&gt;postgres&lt;/code&gt; command line, but the others can be set within the main configuration file. If all three parameters plus &lt;code&gt;data_directory&lt;/code&gt; are explicitly set, then it is not necessary to specify &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">원하는 경우 &lt;code&gt;config_file&lt;/code&gt; , &lt;code&gt;hba_file&lt;/code&gt; 및 / 또는 &lt;code&gt;ident_file&lt;/code&gt; 매개 변수를 사용하여 구성 파일 이름 및 위치를 개별적으로 지정할 수 있습니다 . &lt;code&gt;config_file&lt;/code&gt; 은 &lt;code&gt;postgres&lt;/code&gt; 명령 행 에서만 지정할 수 있지만 다른 구성은 기본 구성 파일 내에서 설정할 수 있습니다. 세 개의 매개 변수와 &lt;code&gt;data_directory&lt;/code&gt; 를 모두 명시 적으로 설정 한 경우 &lt;code&gt;-D&lt;/code&gt; 또는 &lt;code&gt;PGDATA&lt;/code&gt; 를 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="32daceaa2cf366c2fe6d0715c4458443ee88a963" translate="yes" xml:space="preserve">
          <source>If you're setting up the standby server for high availability purposes, set up WAL archiving, connections and authentication like the primary server, because the standby server will work as a primary server after failover.</source>
          <target state="translated">고 가용성을 위해 대기 서버를 설정하는 경우 장애 조치 후에 대기 서버가 기본 서버로 작동하므로 기본 서버와 같은 WAL 보관, 연결 및 인증을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c5ac9027a677c31c54f143f0fe38940b45904e3a" translate="yes" xml:space="preserve">
          <source>If you're using a WAL archive, its size can be minimized using the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; parameter to remove files that are no longer required by the standby server. The pg_archivecleanup utility is designed specifically to be used with &lt;code&gt;archive_cleanup_command&lt;/code&gt; in typical single-standby configurations, see &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt;. Note however, that if you're using the archive for backup purposes, you need to retain files needed to recover from at least the latest base backup, even if they're no longer needed by the standby.</source>
          <target state="translated">WAL 아카이브를 사용하는 경우 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; 매개 변수를 사용하여 WAL 아카이브의 크기를 최소화하여 더 이상 대기 서버에 필요하지 않은 파일을 제거 할 수 있습니다 . pg_archivecleanup 유틸리티는 일반적인 단일 대기 구성에서 &lt;code&gt;archive_cleanup_command&lt;/code&gt; 와 함께 사용하도록 특별히 설계되었습니다 ( &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt; 참조) . 그러나 백업 목적으로 아카이브를 사용하는 경우 대기에서 더 이상 필요하지 않더라도 최소한 최신 기본 백업에서 복구하는 데 필요한 파일을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="eede8f4eab7ac7c7f42522f0f50f00f83f33b103" translate="yes" xml:space="preserve">
          <source>If your application needs to use other forms of partitioning not listed above, alternative methods such as inheritance and &lt;code&gt;UNION ALL&lt;/code&gt; views can be used instead. Such methods offer flexibility but do not have some of the performance benefits of built-in declarative partitioning.</source>
          <target state="translated">애플리케이션이 위에 나열되지 않은 다른 형식의 파티셔닝을 사용해야하는 경우 상속 및 &lt;code&gt;UNION ALL&lt;/code&gt; 보기 와 같은 대체 방법을 대신 사용할 수 있습니다. 이러한 방법은 유연성을 제공하지만 내장 된 선언적 파티셔닝의 일부 성능 이점은 없습니다.</target>
        </trans-unit>
        <trans-unit id="693883e4d7e5062d3b1b4e420d1dcd21d56fe252" translate="yes" xml:space="preserve">
          <source>If your database cluster has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to restore the output of pg_dump into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">데이터베이스 클러스터에 &lt;code&gt;template1&lt;/code&gt; 데이터베이스에 로컬로 추가 된 것이 있으면 pg_dump의 출력을 진정으로 비어있는 데이터베이스로 복원하십시오. 그렇지 않으면 추가 된 객체의 중복 정의로 인해 오류가 발생할 수 있습니다. 로컬 추가없이 빈 데이터베이스를 만들려면 &lt;code&gt;template0&lt;/code&gt; 아닌 &lt;code&gt;template1&lt;/code&gt; 에서 복사하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfe8c7a1e0073145cfd43127c90a639a57c975f4" translate="yes" xml:space="preserve">
          <source>If your database is spread across multiple file systems, there might not be any way to obtain exactly-simultaneous frozen snapshots of all the volumes. For example, if your data files and WAL log are on different disks, or if tablespaces are on different file systems, it might not be possible to use snapshot backup because the snapshots &lt;em&gt;must&lt;/em&gt; be simultaneous. Read your file system documentation very carefully before trusting the consistent-snapshot technique in such situations.</source>
          <target state="translated">데이터베이스가 여러 파일 시스템에 분산 된 경우 모든 볼륨의 정확히 동시에 고정 된 스냅 샷을 얻을 수있는 방법이 없을 수 있습니다. 예를 들어, 데이터 파일과 WAL 로그가 다른 디스크에 있거나 테이블 공간이 다른 파일 시스템에있는 경우 스냅 샷 이 동시에 &lt;em&gt;이루어져야&lt;/em&gt; 하므로 스냅 샷 백업을 사용하지 못할 수 있습니다 . 이러한 상황에서 일관된 스냅 샷 기술을 신뢰하기 전에 파일 시스템 설명서를주의해서 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="89affde528d7a785d4590b760f08553f5fba2e5e" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g. &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">설치 디렉토리가 특정 버전이 아닌 경우 (예 : &lt;code&gt;/usr/local/pgsql&lt;/code&gt; ) , 현재 PostgreSQL 설치 디렉토리를 이동하여 새 PostgreSQL 설치를 방해하지 않도록해야합니다. 현재 PostgreSQL 서버가 종료되면 PostgreSQL 설치 디렉토리의 이름을 바꾸는 것이 안전합니다. 이전 디렉토리가 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; 이라고 가정하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd01544b621df2f2698aa331ec7e1d502c246c7e" translate="yes" xml:space="preserve">
          <source>If your installation has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to load the output of pg_restore into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">설치에 &lt;code&gt;template1&lt;/code&gt; 데이터베이스에 로컬로 추가 된 것이 있으면 pg_restore의 출력을 진정으로 비어있는 데이터베이스로로드하십시오. 그렇지 않으면 추가 된 객체의 중복 정의로 인해 오류가 발생할 수 있습니다. 로컬 추가없이 빈 데이터베이스를 만들려면 &lt;code&gt;template0&lt;/code&gt; 아닌 &lt;code&gt;template1&lt;/code&gt; 에서 복사하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb5ad20ebf8b8594ba828c2e14073cc42a290699" translate="yes" xml:space="preserve">
          <source>If your needs go beyond the capabilities of these conditional expressions, you might want to consider writing a server-side function in a more expressive programming language.</source>
          <target state="translated">이러한 조건식의 기능을 넘어서야하는 경우보다 표현적인 프로그래밍 언어로 서버 측 함수를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="092f5bf3a3fbeb060b8f061dfe4479d40fe497ca" translate="yes" xml:space="preserve">
          <source>If your site administrator has not set things up in the default way, you might have some more work to do. For example, if the database server machine is a remote machine, you will need to set the &lt;code&gt;PGHOST&lt;/code&gt; environment variable to the name of the database server machine. The environment variable &lt;code&gt;PGPORT&lt;/code&gt; might also have to be set. The bottom line is this: if you try to start an application program and it complains that it cannot connect to the database, you should consult your site administrator or, if that is you, the documentation to make sure that your environment is properly set up. If you did not understand the preceding paragraph then read the next section.</source>
          <target state="translated">사이트 관리자가 기본 방식으로 설정하지 않은 경우 추가 작업이 필요할 수 있습니다. 예를 들어, 데이터베이스 서버 시스템이 원격 시스템 인 경우 &lt;code&gt;PGHOST&lt;/code&gt; 환경 변수를 데이터베이스 서버 시스템의 이름으로 설정해야 합니다. 환경 변수 &lt;code&gt;PGPORT&lt;/code&gt; 도 설정해야합니다. 결론은 다음과 같습니다. 응용 프로그램을 시작하려고하는데 데이터베이스에 연결할 수 없다고 불평하는 경우, 사이트 관리자에게 문의하거나 해당하는 경우 문서를 참조하여 환경이 올바르게 설정되었는지 확인하십시오 . 이전 단락을 이해하지 못하면 다음 섹션을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="0e26c0628db89c4d17246b09878aa1c2d36a0d98" translate="yes" xml:space="preserve">
          <source>If your system supports per-user disk quotas, then the database will naturally be subject to whatever quota is placed on the user the server runs as. Exceeding the quota will have the same bad effects as running out of disk space entirely.</source>
          <target state="translated">시스템이 사용자 별 디스크 할당량을 지원하는 경우 데이터베이스는 당연히 서버가 실행되는 사용자의 할당량에 따라 달라집니다. 할당량을 초과하면 디스크 공간이 완전히 소진되는 것과 같은 나쁜 영향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="db517070c58b7073cbfea804db0649d1169a5342" translate="yes" xml:space="preserve">
          <source>If, after running &lt;code&gt;pg_upgrade&lt;/code&gt;, you wish to revert to the old cluster, there are several options:</source>
          <target state="translated">&lt;code&gt;pg_upgrade&lt;/code&gt; 를 실행 한 후 이전 클러스터로 되돌리려면 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1101febd9e8e65c65ae1f196aecd9bf8175188c4" translate="yes" xml:space="preserve">
          <source>If, partway through the transaction, we decide we do not want to commit (perhaps we just noticed that Alice's balance went negative), we can issue the command &lt;code&gt;ROLLBACK&lt;/code&gt; instead of &lt;code&gt;COMMIT&lt;/code&gt;, and all our updates so far will be canceled.</source>
          <target state="translated">트랜잭션을 도중에 커밋하지 않기로 결정한 경우 (아마도 Alice의 잔액이 마이너스가 된 것으로 &lt;code&gt;ROLLBACK&lt;/code&gt; ) &lt;code&gt;COMMIT&lt;/code&gt; 대신 ROLLBACK 명령을 실행할 수 있으며 지금까지의 모든 업데이트가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="f5024d286e4914e76d806049ed9ed5a9adde6b60" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables (but still update the indexes when modifying the tables). This is useful when recovering from damaged system indexes. This parameter cannot be changed after session start.</source>
          <target state="translated">시스템 테이블을 읽을 때는 시스템 인덱스를 무시하십시오 (그러나 테이블을 수정할 때는 인덱스를 업데이트하십시오). 손상된 시스템 인덱스에서 복구 할 때 유용합니다. 세션 시작 후에는이 매개 변수를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71db18d1300170d2010c351c48755c19862c8762" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables, but still update the indexes when modifying the tables. This is useful when recovering from damaged system indexes.</source>
          <target state="translated">시스템 테이블을 읽을 때는 시스템 인덱스를 무시하고 테이블을 수정할 때는 인덱스를 업데이트하십시오. 손상된 시스템 인덱스에서 복구 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="78fee1435d74666b84850cd5e82c18229351da5d" translate="yes" xml:space="preserve">
          <source>Ignored</source>
          <target state="translated">Ignored</target>
        </trans-unit>
        <trans-unit id="0bbd8cc216c54e73f7ea687a30b566c0b2c97cbb" translate="yes" xml:space="preserve">
          <source>Ignored for compatibility. Use of these keywords is deprecated; refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">호환성을 무시했습니다. 이 키워드는 더 이상 사용되지 않습니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b3a3e33cda0750b99611590eb50e57574fe1fbbc" translate="yes" xml:space="preserve">
          <source>Ignored for conformance with the SQL standard.</source>
          <target state="translated">SQL 표준 준수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="61522d42e0f29a20214f69c85ea7d7e480669670" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in the &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt; section.</source>
          <target state="translated">이러한 다양한 형식이 어떻게 보이는지에 대한 그림은 &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;예제&lt;/a&gt; 섹션 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf50e138c7fa8f736f41cea1cb795eaf265d80f2" translate="yes" xml:space="preserve">
          <source>Immediately after connecting as role &lt;code&gt;joe&lt;/code&gt;, a database session will have use of privileges granted directly to &lt;code&gt;joe&lt;/code&gt; plus any privileges granted to &lt;code&gt;admin&lt;/code&gt;, because &lt;code&gt;joe&lt;/code&gt;&amp;ldquo;inherits&amp;rdquo;&lt;code&gt;admin&lt;/code&gt;'s privileges. However, privileges granted to &lt;code&gt;wheel&lt;/code&gt; are not available, because even though &lt;code&gt;joe&lt;/code&gt; is indirectly a member of &lt;code&gt;wheel&lt;/code&gt;, the membership is via &lt;code&gt;admin&lt;/code&gt; which has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. After:</source>
          <target state="translated">즉시 역할로 연결 한 후 &lt;code&gt;joe&lt;/code&gt; , 데이터베이스 세션에 직접 부여 된 권한을 사용해야합니다 &lt;code&gt;joe&lt;/code&gt; 에게 부여 및 모든 권한 &lt;code&gt;admin&lt;/code&gt; 하기 때문에 &lt;code&gt;joe&lt;/code&gt; &quot;상속&quot; &lt;code&gt;admin&lt;/code&gt; 의 권한. 그러나 &lt;code&gt;joe&lt;/code&gt; 가 간접적으로 &lt;code&gt;wheel&lt;/code&gt; 의 멤버이지만 멤버가 &lt;code&gt;NOINHERIT&lt;/code&gt; 속성을 가진 &lt;code&gt;admin&lt;/code&gt; 을 통해 이루어 지기 때문에 &lt;code&gt;wheel&lt;/code&gt; 에 부여 된 권한 은 사용할 수 없습니다 . 후:</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="23167d1539b634954643857fda589f9a1f99fc34" translate="yes" xml:space="preserve">
          <source>Implementation language or call interface of this function</source>
          <target state="translated">이 함수의 구현 언어 또는 호출 인터페이스</target>
        </trans-unit>
        <trans-unit id="261a75d84276a41b101b0b0b2ac4d845072c8241" translate="yes" xml:space="preserve">
          <source>Implicit conversions should never have surprising or unpredictable outcomes.</source>
          <target state="translated">암시 적 변환에는 결코 놀라운 결과 나 예측할 수없는 결과가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="4a78c79f95926318ef6fec9862a700583e71fbd0" translate="yes" xml:space="preserve">
          <source>Implicit unit of the parameter</source>
          <target state="translated">매개 변수의 암시 적 단위</target>
        </trans-unit>
        <trans-unit id="60fa0aba1042461c4c2f1fe75e803d3f36549dc2" translate="yes" xml:space="preserve">
          <source>Import only foreign tables matching one of the given table names. Other tables existing in the foreign schema will be ignored.</source>
          <target state="translated">주어진 테이블 이름 중 하나와 일치하는 외부 테이블 만 가져옵니다. 외부 스키마에 존재하는 다른 테이블은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2775c7ad42c3e8d71ae7e18124278fff473728e1" translate="yes" xml:space="preserve">
          <source>Import operating system collations</source>
          <target state="translated">운영 체제 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="bd09d7d5cbde0f6a55b8befe57d5d6baee4d6f2b" translate="yes" xml:space="preserve">
          <source>Import table definitions from a remote schema &lt;code&gt;foreign_films&lt;/code&gt; on server &lt;code&gt;film_server&lt;/code&gt;, creating the foreign tables in local schema &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;film_server&lt;/code&gt; 서버 의 원격 스키마 &lt;code&gt;foreign_films&lt;/code&gt; 에서 테이블 정의를 가져 와서 로컬 스키마 &lt;code&gt;films&lt;/code&gt; 에 외부 테이블을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="40baa6b48d8c1dc060a4acaef47611a694c99ef3" translate="yes" xml:space="preserve">
          <source>Importing behavior can be customized with the following options (given in the &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command):</source>
          <target state="translated">&lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; 명령 에서 제공되는 다음 옵션을 사용하여 가져 오기 동작을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cdac824d2a40a7779c6dcbb8d843dee4847ebb5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;delta&lt;/code&gt; denote floating-point numbers. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, but not &lt;code&gt;delta&lt;/code&gt;, can be preceded by a certainty indicator.</source>
          <target state="translated">에서는 &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;표 F.26&lt;/a&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , 및 &lt;code&gt;delta&lt;/code&gt; 나타내고 부동 소수. &lt;code&gt;delta&lt;/code&gt; 가 아닌 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 앞에 확실성 표시기가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42729a410f5a9327e00095fef5d98f4dbb7419a2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; in the column for PostgreSQL we classify as &amp;ldquo;non-reserved&amp;rdquo; those key words that are explicitly known to the parser but are allowed as column or table names. Some key words that are otherwise non-reserved cannot be used as function or data type names and are marked accordingly. (Most of these words represent built-in functions or data types with special syntax. The function or type is still available but it cannot be redefined by the user.) Labeled &amp;ldquo;reserved&amp;rdquo; are those tokens that are not allowed as column or table names. Some reserved key words are allowable as names for functions or data types; this is also shown in the table. If not so marked, a reserved key word is only allowed as an &amp;ldquo;AS&amp;rdquo; column label name.</source>
          <target state="translated">PostgreSQL 열의 &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;표 C.1&lt;/a&gt; 에서는 파서에 명시 적으로 알려져 있지만 열 또는 테이블 이름으로 허용되는 키워드를 &quot;비 예약&quot;으로 분류합니다. 그렇지 않으면 예약되지 않은 일부 키워드는 함수 또는 데이터 유형 이름으로 사용할 수 없으며 그에 따라 표시됩니다. (대부분의 이러한 단어는 특수 구문이있는 내장 함수 또는 데이터 유형을 나타냅니다. 함수 또는 유형은 여전히 ​​사용 가능하지만 사용자가 다시 정의 할 수는 없습니다.) &quot;예약 됨&quot;이라는 레이블이 붙은 토큰은 열 또는 테이블 이름으로 사용할 수 없습니다. . 일부 예약 된 키워드는 함수 또는 데이터 유형의 이름으로 사용할 수 있습니다. 이것은 표에도 나와 있습니다. 그렇게 표시되지 않은 경우 예약 키워드는 &quot;AS&quot;열 레이블 이름으로 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fee127e33ba4c6342d0b89b7e063498409c73cb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN. If specified when not in &lt;code&gt;--start&lt;/code&gt; mode, an error is raised.</source>
          <target state="translated">에서 &lt;code&gt;--start&lt;/code&gt; 에 도달에게 지정된 LSN을 수신 할 때 모드, 자동으로 정상 종료 상태 0 복제 및 종료를 중지합니다. &lt;code&gt;--start&lt;/code&gt; 모드에 있지 않을 때 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3bfcd6bf2f68dc3b43c9cf872d41f5d653495d00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">에서 &lt;code&gt;--start&lt;/code&gt; 모드, 주어진 LSN에서 복제를 시작합니다. 이 효과에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;52.4 절의&lt;/a&gt; 설명서를 참조하십시오 . 다른 모드에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="12bbea7ca03f59c395276fdbf0ca262376507500" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, use the existing logical replication slot named &lt;code&gt;slot_name&lt;/code&gt;. In &lt;code&gt;--create-slot&lt;/code&gt; mode, create the slot with this name. In &lt;code&gt;--drop-slot&lt;/code&gt; mode, delete the slot with this name.</source>
          <target state="translated">에서 &lt;code&gt;--start&lt;/code&gt; 모드에서는 기존 논리 복제 슬롯 이름을 사용 &lt;code&gt;slot_name&lt;/code&gt; . 에서 &lt;code&gt;--create-slot&lt;/code&gt; 모드,이 이름 슬롯을 만들 수 있습니다. 에서 &lt;code&gt;--drop-slot&lt;/code&gt; 모드,이 이름 슬롯을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="18d7da29e783f36fa5dffa6644b2287183a78875" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CSV&lt;/code&gt; format, all characters are significant. A quoted value surrounded by white space, or any characters other than &lt;code&gt;DELIMITER&lt;/code&gt;, will include those characters. This can cause errors if you import data from a system that pads &lt;code&gt;CSV&lt;/code&gt; lines with white space out to some fixed width. If such a situation arises you might need to preprocess the &lt;code&gt;CSV&lt;/code&gt; file to remove the trailing white space, before importing the data into PostgreSQL.</source>
          <target state="translated">에서 &lt;code&gt;CSV&lt;/code&gt; 의 형식, 모든 문자가 중요합니다. 공백 또는 &lt;code&gt;DELIMITER&lt;/code&gt; 이외의 문자로 둘러싸인 인용 된 값 에는 해당 문자가 포함됩니다. 공백이있는 &lt;code&gt;CSV&lt;/code&gt; 행을 일정한 너비로 채우는 시스템에서 데이터를 가져 오는 경우 오류가 발생할 수 있습니다 . 이러한 상황이 발생하면 PostgreSQL로 데이터를 가져 오기 전에 &lt;code&gt;CSV&lt;/code&gt; 파일을 사전 처리 하여 후행 공백을 제거 해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0153f75e36e8f0039d3aa08af5bcc40422e9783b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;FROM&lt;/code&gt; items, both the standard and PostgreSQL allow &lt;code&gt;AS&lt;/code&gt; to be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.</source>
          <target state="translated">에서 &lt;code&gt;FROM&lt;/code&gt; 항목, 표준 및 PostgreSQL을 모두 허용 &lt;code&gt;AS&lt;/code&gt; 예약되지 않은 키워드입니다 별명 전에 생략 할 수있다. 그러나 이것은 구문상의 모호성 때문에 출력 열 이름에는 비실용적입니다.</target>
        </trans-unit>
        <trans-unit id="0a49988bfaefe7a720bbc33d73d20e3ed846b39f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of &lt;em&gt;peer groups&lt;/em&gt; before or after the current row's peer group, where a peer group is a set of rows that are equivalent in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. (There must be an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the window definition to use &lt;code&gt;GROUPS&lt;/code&gt; mode.)</source>
          <target state="translated">에서는 &lt;code&gt;GROUPS&lt;/code&gt; 의 모드에서는 &lt;code&gt;offset&lt;/code&gt; 다시 비 - 널, 음이 아닌 정수이고, 상기 선택 수단을 산출해야하는 프레임의 시작 또는 끝 지정된 수의 &lt;em&gt;피어 그룹&lt;/em&gt; 피어 그룹 A는 현재 행의 피어 그룹 전후 &lt;code&gt;ORDER BY&lt;/code&gt; 순서 와 동등한 행 세트 . &lt;code&gt;GROUPS&lt;/code&gt; 모드 를 사용하려면 창 정의에 &lt;code&gt;ORDER BY&lt;/code&gt; 절이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="948c542b2b357818bb888566376ebb0a4005a123" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; mode, these options require that the &lt;code&gt;ORDER BY&lt;/code&gt; clause specify exactly one column. The &lt;code&gt;offset&lt;/code&gt; specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the &lt;code&gt;offset&lt;/code&gt; expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. For example, if the ordering column is of type &lt;code&gt;date&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt;, one could write &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt;. The &lt;code&gt;offset&lt;/code&gt; is still required to be non-null and non-negative, though the meaning of &amp;ldquo;non-negative&amp;rdquo; depends on its data type.</source>
          <target state="translated">에서 &lt;code&gt;RANGE&lt;/code&gt; 의 모드 이러한 옵션은해야 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 정확히 하나의 열을 지정합니다. &lt;code&gt;offset&lt;/code&gt; 지정 현재 행에 해당 열의 값 또는 이전 프레임의 행을 다음의 값 사이의 최대 차이. 의 데이터 유형 &lt;code&gt;offset&lt;/code&gt; 식은 순서 열의 데이터 종류에 따라 달라진다. 숫자 순서 열의 경우 일반적으로 순서 열과 동일한 유형이지만 날짜 시간 순서 열의 경우 &lt;code&gt;interval&lt;/code&gt; 입니다. 예를 들어, 주문 열이 &lt;code&gt;date&lt;/code&gt; 또는 &lt;code&gt;timestamp&lt;/code&gt; 유형 인 경우 &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt; 쓸 수 있습니다. 그만큼 &lt;code&gt;offset&lt;/code&gt; &quot;음수가 아닌&quot;의 의미는 데이터 유형에 따라 다르지만 오프셋 은 여전히 ​​널이 아니며 음이 아닌 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1408d5e7e21bd209b1b9bfad149903cd4485729a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode, a &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame starts with the current row's first &lt;em&gt;peer&lt;/em&gt; row (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts as equivalent to the current row), while a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame ends with the current row's last peer row. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; simply means the current row.</source>
          <target state="translated">에서는 &lt;code&gt;RANGE&lt;/code&gt; 또는 &lt;code&gt;GROUPS&lt;/code&gt; 모드, &lt;code&gt;frame_start&lt;/code&gt; 의 &lt;code&gt;CURRENT ROW&lt;/code&gt; 현재 행의 첫 번째와 프레임 시작 수단 &lt;em&gt;피어&lt;/em&gt; (윈도우의 것을 로우 행 &lt;code&gt;ORDER BY&lt;/code&gt; , 현재 행과 동등 절 종류)가 잠시 &lt;code&gt;frame_end&lt;/code&gt; 의 &lt;code&gt;CURRENT ROW&lt;/code&gt; 가 프레임 단부 수단을 현재 행의 마지막 피어 행과 함께. 에서 &lt;code&gt;ROWS&lt;/code&gt; 의 모드, &lt;code&gt;CURRENT ROW&lt;/code&gt; 단순히 현재의 행을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="30675f2bd0c7573e3e074baf89463cecdcac064e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row.</source>
          <target state="translated">에서는 &lt;code&gt;ROWS&lt;/code&gt; 모드에서는 &lt;code&gt;offset&lt;/code&gt; NULL이 아닌 양의 정수를 산출하며, 상기 선택 수단이 상기 프레임의 시작 또는 끝 지정된 행수를 이전 또는 현재 행 후에.</target>
        </trans-unit>
        <trans-unit id="8f056c7130dbabcd038c08071d28f6253ddeb0d1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt;, each array element is compared to the searched value using &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics.</source>
          <target state="translated">에서는 &lt;code&gt;array_position&lt;/code&gt; 및 &lt;code&gt;array_positions&lt;/code&gt; 이용하여 검색된 값에, 각각의 어레이 소자는 비교 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 의미.</target>
        </trans-unit>
        <trans-unit id="58eb966bf75cf56a14e39b6e0b483088ba13994e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned if the value is not found.</source>
          <target state="translated">에서 &lt;code&gt;array_position&lt;/code&gt; , &lt;code&gt;NULL&lt;/code&gt; 은 값이없는 경우 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6fb1576a237f50776165c9127d1d61a80997b7ea" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_positions&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned only if the array is &lt;code&gt;NULL&lt;/code&gt;; if the value is not found in the array, an empty array is returned instead.</source>
          <target state="translated">에서 &lt;code&gt;array_positions&lt;/code&gt; , &lt;code&gt;NULL&lt;/code&gt; 이 배열 인 경우에만 반환 &lt;code&gt;NULL&lt;/code&gt; ; 배열에 값이 없으면 빈 배열이 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="42867f00aff6799a35548d7b4a45bb429b8b6f41" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;encrypt_iv&lt;/code&gt; and &lt;code&gt;decrypt_iv&lt;/code&gt;, the &lt;em&gt;&lt;code&gt;iv&lt;/code&gt;&lt;/em&gt; parameter is the initial value for the CBC mode; it is ignored for ECB. It is clipped or padded with zeroes if not exactly block size. It defaults to all zeroes in the functions without this parameter.</source>
          <target state="translated">에서는 &lt;code&gt;encrypt_iv&lt;/code&gt; 및 &lt;code&gt;decrypt_iv&lt;/code&gt; 상기 &lt;em&gt; &lt;code&gt;iv&lt;/code&gt; &lt;/em&gt; 파라미터는 CBC 모드 용 초기 값이고; ECB에서는 무시됩니다. 정확하게 블록 크기가 아닌 경우 0으로 클리핑되거나 채워집니다. 이 매개 변수가없는 함수의 기본값은 모두 0입니다.</target>
        </trans-unit>
        <trans-unit id="74b9c4f74b2383573102ae88dc002c3f78bfc6aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;init&lt;/code&gt; mode, this option analogously specifies the location of the &lt;code&gt;initdb&lt;/code&gt; executable.</source>
          <target state="translated">에서 &lt;code&gt;init&lt;/code&gt; 모드,이 옵션은 유사의 위치를 지정 &lt;code&gt;initdb&lt;/code&gt; 를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4b893445cf37926dce5c6e98df69fc0726a60722" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g. &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">에서는 &lt;code&gt;latex-longtable&lt;/code&gt; 포맷이 제어 좌측 정렬 된 데이터 타입을 포함하는 각 컬럼의 폭에 비례. 공백으로 구분 된 값 목록으로 지정됩니다 (예 : &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; ) . 지정되지 않은 출력 열은 마지막으로 지정된 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9860fa02b7dab9c5038f80534079df8148445840" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;logical&lt;/code&gt; level, the same information is logged as with &lt;code&gt;replica&lt;/code&gt;, plus information needed to allow extracting logical change sets from the WAL. Using a level of &lt;code&gt;logical&lt;/code&gt; will increase the WAL volume, particularly if many tables are configured for &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; and many &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements are executed.</source>
          <target state="translated">&lt;code&gt;logical&lt;/code&gt; 수준 에서는 &lt;code&gt;replica&lt;/code&gt; 와 동일한 정보와 WAL에서 논리적 변경 세트를 추출하는 데 필요한 정보가 기록됩니다 . &lt;code&gt;logical&lt;/code&gt; 레벨을 사용하면 특히 많은 테이블이 &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; 에 대해 구성 되고 많은 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 문이 실행되는 경우 WAL 볼륨이 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="19415b9e6aa0d531e04e643500bbdc24d23674cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, WAL-logging of some bulk operations can be safely skipped, which can make those operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations in which this optimization can be applied include:</source>
          <target state="translated">에서 &lt;code&gt;minimal&lt;/code&gt; 수준, 일부 대량 작업의 WAL 로깅 안전하게 할 수 있습니다 (더 빠르게 그 작업을 할 수있는 생략 &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;제 14.4.7을&lt;/a&gt; ). 이 최적화를 적용 할 수있는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61bcfc364ae05487e8e54b4d5f3e06b75ec150ff" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;psql&lt;/code&gt;, you will be greeted with the following message:</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; 에서는 다음 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d81bf71ad3ee9adb26530d123722b695887e96a2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the delimiter parameter is NULL, each character in the input string will become a separate element in the resulting array. If the delimiter is an empty string, then the entire input string is returned as a one-element array. Otherwise the input string is split at each occurrence of the delimiter string.</source>
          <target state="translated">에서는 &lt;code&gt;string_to_array&lt;/code&gt; 구분 파라미터가 NULL 인 경우, 상기 입력 문자열의 각 문자가 생성 된 어레이의 개별 요소가 될 것이다. 분리 문자가 빈 문자열이면 전체 입력 문자열이 단일 요소 배열로 리턴됩니다. 그렇지 않으면 입력 문자열이 구분자 문자열이 나타날 때마다 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="ecd995c62df4a3324cc5c0dfdf5609bb28cc962a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the null-string parameter is omitted or NULL, none of the substrings of the input will be replaced by NULL. In &lt;code&gt;array_to_string&lt;/code&gt;, if the null-string parameter is omitted or NULL, any null elements in the array are simply skipped and not represented in the output string.</source>
          <target state="translated">에서는 &lt;code&gt;string_to_array&lt;/code&gt; 널 문자열 파라미터가 NULL 또는 생략 된 경우, 상기 입력 문자열의 어느 것도 NULL로 대체되지 않는다. 에서는 &lt;code&gt;array_to_string&lt;/code&gt; 널 문자열 파라미터가 생략되거나 null이면, 어레이의 모든 요소는 널 스킵 단순히 출력 문자열로 표현되지 않는다.</target>
        </trans-unit>
        <trans-unit id="b1222507b269ef568691d0a9d753a3eda5a5d8e5" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_number&lt;/code&gt;, if non-data template patterns such as &lt;code&gt;L&lt;/code&gt; or &lt;code&gt;TH&lt;/code&gt; are used, the corresponding number of input characters are skipped, whether or not they match the template pattern, unless they are data characters (that is, digits, sign, decimal point, or comma). For example, &lt;code&gt;TH&lt;/code&gt; would skip two non-data characters.</source>
          <target state="translated">에서는 &lt;code&gt;to_number&lt;/code&gt; 같은 비 데이터 템플릿 패턴 경우, &lt;code&gt;L&lt;/code&gt; 또는 &lt;code&gt;TH&lt;/code&gt; 가 사용되며, 입력 문자의 해당 숫자들은 데이터 문자 (이며, 숫자, 기호, 소수점이 아니라면들은 템플릿 패턴과 일치하는지 여부를, 스킵 또는 쉼표). 예를 들어, &lt;code&gt;TH&lt;/code&gt; 는 두 개의 비 데이터 문자를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="da01a26180a4b78ca506a4e26d673346bc64efee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, an ISO 8601 week-numbering date (as distinct from a Gregorian date) can be specified in one of two ways:</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; (양력 날짜는 별개로)는 ISO 8601 일주일 번호 날짜 두 가지 방법 중 하나를 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f9d931e068d7388b5b9791ba73a39ccc4330b961" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g. &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g. &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; , 올해 형식 사양 이하 네 자리 숫자, 예를 들어, 경우 &lt;code&gt;YYY&lt;/code&gt; 를 예를 들면, 및 제공된 년 이하 네 자리 숫자보다 올해가 2020 년에 가장 가까운로 조정 될 것이다 &lt;code&gt;95&lt;/code&gt; 1995이된다.</target>
        </trans-unit>
        <trans-unit id="4dcc47dcfb30c72df039620b4818cb5cae63885b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;CC&lt;/code&gt; (century) field is accepted but ignored if there is a &lt;code&gt;YYY&lt;/code&gt;, &lt;code&gt;YYYY&lt;/code&gt; or &lt;code&gt;Y,YYY&lt;/code&gt; field. If &lt;code&gt;CC&lt;/code&gt; is used with &lt;code&gt;YY&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt; then the result is computed as that year in the specified century. If the century is specified but the year is not, the first year of the century is assumed.</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; 는 &lt;code&gt;CC&lt;/code&gt; (세기) 필드는 가능하지만,이 경우 무시됩니다 &lt;code&gt;YYY&lt;/code&gt; , &lt;code&gt;YYYY&lt;/code&gt; 또는 &lt;code&gt;Y,YYY&lt;/code&gt; 의 필드. 경우 &lt;code&gt;CC&lt;/code&gt; 가 사용됩니다 &lt;code&gt;YY&lt;/code&gt; 또는 &lt;code&gt;Y&lt;/code&gt; , 결과는 지정된 세기에 그 해로 계산됩니다. 세기가 지정되었지만 연도가 지정되지 않은 경우 세기의 첫해가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="34928f49bb5512bad729a0eba587c351c3b66a70" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; conversion has a restriction when processing years with more than 4 digits. You must use some non-digit character or template after &lt;code&gt;YYYY&lt;/code&gt;, otherwise the year is always interpreted as 4 digits. For example (with the year 20000): &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; will be interpreted as a 4-digit year; instead use a non-digit separator after the year, like &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; or &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; 상기 &lt;code&gt;YYYY&lt;/code&gt; 에 4 개 이상의 자리 년을 처리 할 때 변환은 제한이있다. &lt;code&gt;YYYY&lt;/code&gt; 뒤에 숫자가 아닌 문자 나 템플릿을 사용해야합니다 . 그렇지 않으면 연도는 항상 4 자리로 해석됩니다. 예를 들어 (20000 년) : &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; 는 4 자리 연도로 해석됩니다. 대신 &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; 또는 &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt; 와 같이 연도 이후에 숫자가 아닌 구분 기호를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="544ec57993b0d566b29bfdeb2a8cf47932beafef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, weekday names or numbers (&lt;code&gt;DAY&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and related field types) are accepted but are ignored for purposes of computing the result. The same is true for quarter (&lt;code&gt;Q&lt;/code&gt;) fields.</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; , 요일의 이름이나 숫자 ( &lt;code&gt;DAY&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; , 및 관련 분야 유형) 허용됩니다하지만 결과를 계산의 목적을 위해 무시됩니다. 분기 ( &lt;code&gt;Q&lt;/code&gt; ) 필드에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="8902e096eb8211a3103ef8a03507a1e1c0b7839c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt;, millisecond (&lt;code&gt;MS&lt;/code&gt;) or microsecond (&lt;code&gt;US&lt;/code&gt;) fields are used as the seconds digits after the decimal point. For example &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; is not 3 milliseconds, but 300, because the conversion treats it as 12 + 0.3 seconds. So, for the format &lt;code&gt;SS.MS&lt;/code&gt;, the input values &lt;code&gt;12.3&lt;/code&gt;, &lt;code&gt;12.30&lt;/code&gt;, and &lt;code&gt;12.300&lt;/code&gt; specify the same number of milliseconds. To get three milliseconds, one must write &lt;code&gt;12.003&lt;/code&gt;, which the conversion treats as 12 + 0.003 = 12.003 seconds.</source>
          <target state="translated">에서는 &lt;code&gt;to_timestamp&lt;/code&gt; , 밀리 세컨드 ( &lt;code&gt;MS&lt;/code&gt; ) 또는 마이크로 ( &lt;code&gt;US&lt;/code&gt; ) 필드는 소수점 이후의 초 디지트로서 사용된다. 예를 들어 &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; 는 3 밀리 초가 아니라 300입니다. 변환은 12 + 0.3 초로 처리하기 때문입니다. 따라서 &lt;code&gt;SS.MS&lt;/code&gt; 형식의 경우 입력 값 &lt;code&gt;12.3&lt;/code&gt; , &lt;code&gt;12.30&lt;/code&gt; 및 &lt;code&gt;12.300&lt;/code&gt; 은 동일한 밀리 초 수를 지정합니다. 3 밀리 초를 얻으려면 &lt;code&gt;12.003&lt;/code&gt; 을 작성해야 하며 변환은 12 + 0.003 = 12.003 초로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="64a9c48229747c676385712712a92e7a02f4a20e" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; followed by an alphanumeric character is either an escape or an error, while in previous releases, it was just another way of writing the alphanumeric. This should not be much of a problem because there was no reason to write such a sequence in earlier releases.</source>
          <target state="translated">ARE에서 &lt;code&gt;\&lt;/code&gt; 다음에 영숫자 문자가 이스케이프 또는 오류 인 반면, 이전 릴리스에서는 영숫자를 작성하는 또 다른 방법이었습니다. 이전 릴리스에서 이러한 시퀀스를 작성할 이유가 없었기 때문에 이는 큰 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fd039b2f7ce31cb27cef33f4f533a9fac0c1fbd" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; remains a special character within &lt;code&gt;[]&lt;/code&gt;, so a literal &lt;code&gt;\&lt;/code&gt; within a bracket expression must be written &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">ARE에서 &lt;code&gt;\&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; 내에 특수 문자로 남아 있으므로 대괄호 표현식 내의 리터럴 &lt;code&gt;\&lt;/code&gt; 는 &lt;code&gt;\\&lt;/code&gt; 로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb3ffc95899379ce4e17b50af19efa046a482415" translate="yes" xml:space="preserve">
          <source>In HTML format, this specifies attributes to be placed inside the &lt;code&gt;table&lt;/code&gt; tag. This could for example be &lt;code&gt;cellpadding&lt;/code&gt; or &lt;code&gt;bgcolor&lt;/code&gt;. Note that you probably don't want to specify &lt;code&gt;border&lt;/code&gt; here, as that is already taken care of by &lt;code&gt;\pset border&lt;/code&gt;. If no &lt;code&gt;value&lt;/code&gt; is given, the table attributes are unset.</source>
          <target state="translated">HTML 형식에서 이것은 &lt;code&gt;table&lt;/code&gt; 태그 안에 배치 될 속성을 지정합니다 . 예를 들어 &lt;code&gt;cellpadding&lt;/code&gt; 또는 &lt;code&gt;bgcolor&lt;/code&gt; 일 수 있습니다. &lt;code&gt;\pset border&lt;/code&gt; 가 이미 처리 했으므로 여기서 &lt;code&gt;border&lt;/code&gt; 를 지정하고 싶지 않을 수도 있습니다 . &lt;code&gt;value&lt;/code&gt; 을 지정 하지 않으면 테이블 속성이 설정 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="814a324a3771e36f5c269dff83adcdc2f6482fa5" translate="yes" xml:space="preserve">
          <source>In Linux 2.4 and later, the default virtual memory behavior is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="translated">Linux 2.4 이상에서 기본 가상 메모리 동작은 PostgreSQL에 최적이 아닙니다. 커널이 메모리 오버 커밋을 구현하는 방식으로 인해 PostgreSQL 또는 다른 프로세스의 메모리 요구로 인해 시스템에 가상 메모리가 부족한 경우 커널은 PostgreSQL 포스트 마스터 (마스터 서버 프로세스)를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9db993d9ed52b850a8119db5ab8d068b60a0509" translate="yes" xml:space="preserve">
          <source>In NetBSD 5.0 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">NetBSD 5.0 ​​이상에서 &lt;code&gt;sysctl&lt;/code&gt; 을 사용하여 IPC 매개 변수를 조정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33cf5a32119e2012e85b594bd01ed746ff893ad5" translate="yes" xml:space="preserve">
          <source>In OpenBSD 3.3 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">OpenBSD 3.3 이상에서 &lt;code&gt;sysctl&lt;/code&gt; 을 사용하여 IPC 매개 변수를 조정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d469c640f950b7673c7ae58a9ecc0f315265b7c1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.0, large objects did not have access privileges and were, therefore, always readable and writable by all users. Setting this variable to &lt;code&gt;on&lt;/code&gt; disables the new privilege checks, for compatibility with prior releases. The default is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">9.0 이전의 PostgreSQL 릴리스에서는 큰 객체에 액세스 권한이 없었으므로 모든 사용자가 항상 읽고 쓸 수있었습니다. 이 변수를 &lt;code&gt;on&lt;/code&gt; 으로 설정하면 이전 릴리스와의 호환성을 위해 새 권한 검사가 비활성화됩니다. 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22cd8a67509e8ca7db080a3ecd0b854c45395a98" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.3, &lt;code&gt;commit_delay&lt;/code&gt; behaved differently and was much less effective: it affected only commits, rather than all WAL flushes, and waited for the entire configured delay even if the WAL flush was completed sooner. Beginning in PostgreSQL 9.3, the first process that becomes ready to flush waits for the configured interval, while subsequent processes wait only until the leader completes the flush operation.</source>
          <target state="translated">9.3 이전의 PostgreSQL 릴리스에서는 &lt;code&gt;commit_delay&lt;/code&gt; 가 다르게 작동하고 훨씬 덜 효과적이었습니다. 모든 WAL 플러시가 아닌 커밋에만 영향을 미쳤으며 WAL 플러시가 더 빨리 완료된 경우에도 구성된 전체 지연을 기다렸습니다. PostgreSQL 9.3부터 플러시 준비가 된 첫 번째 프로세스는 구성된 간격 동안 대기하고 후속 프로세스는 리더가 플러시 작업을 완료 할 때까지만 대기합니다.</target>
        </trans-unit>
        <trans-unit id="b3a09d320c0eb1af5ebf6fc539b70645d7fbc828" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions 8.0 through 8.2, the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; would be canceled by releasing an earlier savepoint, or by successful exit from a PL/pgSQL exception block. This behavior has been changed because it was deemed unintuitive.</source>
          <target state="translated">PostgreSQL 버전 8.0에서 8.2까지 &lt;code&gt;SET LOCAL&lt;/code&gt; 의 효과 는 이전 저장 점을 해제하거나 PL / pgSQL 예외 블록을 성공적으로 종료하여 취소됩니다. 이 동작은 직관적이지 않은 것으로 간주되어 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="a2a2f1f614c98ca12a5b32b40e076079264d9c76" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was customary to avoid creating a shell type at all, by replacing the functions' forward references to the type name with the placeholder pseudo-type &lt;code&gt;opaque&lt;/code&gt;. The &lt;code&gt;cstring&lt;/code&gt; arguments and results also had to be declared as &lt;code&gt;opaque&lt;/code&gt; before 7.3. To support loading of old dump files, &lt;code&gt;CREATE TYPE&lt;/code&gt; will accept I/O functions declared using &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function declarations to use the correct types.</source>
          <target state="translated">7.3 이전의 PostgreSQL 버전에서는 형식 이름에 대한 함수의 순방향 참조를 자리 표시 자 pseudo-type &lt;code&gt;opaque&lt;/code&gt; 로 바꾸어 쉘 형식을 만드는 것을 피하는 것이 일반적이었습니다 . &lt;code&gt;cstring&lt;/code&gt; 인수 및 결과도로 선언했다 &lt;code&gt;opaque&lt;/code&gt; 7.3 전에. 기존 덤프 파일로드를 지원하기 위해 &lt;code&gt;CREATE TYPE&lt;/code&gt; 은 &lt;code&gt;opaque&lt;/code&gt; 를 사용하여 선언 된 I / O 함수를 허용 하지만, 올바른 유형을 사용하도록 통지를 발행하고 함수 선언을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b355acb666b0ad4cd57d90f2927cbffb2b6ed9ef" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare handler functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;language_handler&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">7.3 이전의 PostgreSQL 버전에서는 핸들러 함수를 &lt;code&gt;language_handler&lt;/code&gt; 가 아닌 플레이스 홀더 유형을 &lt;code&gt;opaque&lt;/code&gt; 로 리턴하는 것으로 선언해야했습니다 . 기존 덤프 파일의로드를 지원하기 위해 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 는 &lt;code&gt;opaque&lt;/code&gt; 반환으로 선언 된 함수를 허용 하지만 통지를 발행하고 함수의 선언 된 리턴 유형을 &lt;code&gt;language_handler&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="c16c4aa970c78b968d9f432a8088edb5d24051d5" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare trigger functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;trigger&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;trigger&lt;/code&gt;.</source>
          <target state="translated">7.3 이전의 PostgreSQL 버전에서는 트리거 함수를 &lt;code&gt;trigger&lt;/code&gt; 대신 플레이스 홀더 유형을 &lt;code&gt;opaque&lt;/code&gt; 리턴하는 것으로 선언해야했습니다 . 기존 덤프 파일로드를 지원하기 위해 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 는 &lt;code&gt;opaque&lt;/code&gt; 반환으로 선언 된 함수를 허용 하지만 통지를 발행하고 함수의 선언 된 리턴 유형을 &lt;code&gt;trigger&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="3c68aa880bfe2dcd90559cbb12f6681d9282ddb1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 9.4, freezing was implemented by actually replacing a row's insertion XID with &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which was visible in the row's &lt;code&gt;xmin&lt;/code&gt; system column. Newer versions just set a flag bit, preserving the row's original &lt;code&gt;xmin&lt;/code&gt; for possible forensic use. However, rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2) may still be found in databases pg_upgrade'd from pre-9.4 versions.</source>
          <target state="translated">9.4 이전의 PostgreSQL 버전에서는 행의 삽입 XID를 실제로 행의 &lt;code&gt;xmin&lt;/code&gt; 시스템 열에 표시되는 &lt;code&gt;FrozenTransactionId&lt;/code&gt; 로 대체하여 고정을 구현했습니다 . 최신 버전 은 가능한 한 법 의학적 사용을 위해 행의 원래 &lt;code&gt;xmin&lt;/code&gt; 을 유지하면서 플래그 비트를 설정했습니다 . 그러나 &lt;code&gt;xmin&lt;/code&gt; 이 &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2) 와 같은 행은 9.4 이전 버전의 pg_upgrade'd 데이터베이스에서 계속 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eadad43cc831b2ff40334680f58601d4f7a10c43" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a reference to a table name (or alias) in a query is effectively a reference to the composite value of the table's current row. For example, if we had a table &lt;code&gt;inventory_item&lt;/code&gt; as shown &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;above&lt;/a&gt;, we could write:</source>
          <target state="translated">PostgreSQL에서 쿼리의 테이블 이름 (또는 별칭)에 대한 참조는 실제로 테이블의 현재 행의 복합 값에 대한 참조입니다. 예를 들어 &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;위에&lt;/a&gt; 표시된 것처럼 &lt;code&gt;inventory_item&lt;/code&gt; 테이블이 있으면 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a86fbee986217732dc6e120d53c8e8d4a6c9100" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">PostgreSQL에서 테이블은 0 개 이상의 다른 테이블에서 상속 할 수 있으며 쿼리는 테이블의 모든 행 또는 테이블의 모든 행과 모든 하위 테이블을 참조 할 수 있습니다. 후자의 동작이 기본값입니다. 예를 들어 다음 쿼리는 주 수도를 포함하여 500 피트 이상의 고도에있는 모든 도시의 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="74efdce9636de27e76a8b8265ce6cb497dd89fdf" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a transaction is set up by surrounding the SQL commands of the transaction with &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; commands. So our banking transaction would actually look like:</source>
          <target state="translated">PostgreSQL에서 트랜잭션의 SQL 명령을 &lt;code&gt;BEGIN&lt;/code&gt; 및 &lt;code&gt;COMMIT&lt;/code&gt; 명령 으로 묶어 트랜잭션을 설정 합니다. 따라서 은행 거래는 실제로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba3eb2b425968ebc072af7dd5475bc71e9126bfd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL에서 행 의 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 는 이전 버전의 행을 즉시 제거하지 않습니다. 이 방법은 다중 버전 동시성 제어 (MVCC, &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조 ) 의 이점을 얻기 위해 필요합니다 . 행 버전이 다른 트랜잭션에 여전히 보이는 동안 삭제되지 않아야합니다. 그러나 결국 오래되거나 삭제 된 행 버전은 더 이상 트랜잭션에 관심이 없습니다. 디스크 공간 요구 사항이 무한대로 증가하지 않도록하려면 새 행에서 재사용 할 수 있도록 차지하는 공간을 다시 확보해야합니다. &lt;code&gt;VACUUM&lt;/code&gt; 을 실행하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbda6fce7f63ccb95f1398e8c5c8a9c6bb83f492" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e. PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">PostgreSQL에서는 4 가지 표준 트랜잭션 격리 수준 중 하나를 요청할 수 있지만 내부적으로 3 개의 개별 격리 수준 만 구현됩니다. 즉, PostgreSQL의 Uncommitted 모드는 Read Committed와 같이 작동합니다. 표준 격리 수준을 PostgreSQL의 다중 버전 동시성 제어 아키텍처에 매핑 할 수있는 유일한 방법이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="759eb406805a5a1c000f22431f41b882c8790352" translate="yes" xml:space="preserve">
          <source>In SCRAM without channel binding, the server chooses a random number that is transmitted to the client to be mixed with the user-supplied password in the transmitted password hash. While this prevents the password hash from being successfully retransmitted in a later session, it does not prevent a fake server between the real server and client from passing through the server's random value and successfully authenticating.</source>
          <target state="translated">채널 바인딩이없는 SCRAM에서 서버는 클라이언트로 전송 된 난수를 선택하여 전송 된 비밀번호 해시에서 사용자 제공 비밀번호와 혼합합니다. 이렇게하면 이후 세션에서 암호 해시가 성공적으로 재전송되지 않지만 실제 서버와 클라이언트 사이의 가짜 서버가 서버의 임의의 값을 통과하여 성공적으로 인증되는 것을 막을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bbe3d8277f59658a3be0c65846387947fe489961" translate="yes" xml:space="preserve">
          <source>In SQL:2006 and later, both directions of conversion between standard SQL data types and the XML Schema types are specified precisely. However, the rules are expressed using the types and semantics of XQuery/XPath, and have no direct application to the different data model of XPath 1.0.</source>
          <target state="translated">SQL : 2006 이상에서는 표준 SQL 데이터 유형과 XML 스키마 유형 간의 변환 방향이 모두 정확하게 지정됩니다. 그러나 규칙은 XQuery / XPath의 유형과 의미를 사용하여 표현되며 XPath 1.0의 다른 데이터 모델에 직접 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cddd15d85853fd05a956af5b4c400072d8cd616" translate="yes" xml:space="preserve">
          <source>In Solaris 10 and later, and OpenSolaris, the default shared memory and semaphore settings are good enough for most PostgreSQL applications. Solaris now defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="translated">Solaris 10 이상 및 OpenSolaris에서 기본 공유 메모리 및 세마포어 설정은 대부분의 PostgreSQL 응용 프로그램에 충분합니다. Solaris는 기본적으로 시스템 RAM의 1/4 인 &lt;code&gt;SHMMAX&lt;/code&gt; 로 설정됩니다. 이 설정을 추가로 조정하려면 &lt;code&gt;postgres&lt;/code&gt; 사용자 와 관련된 프로젝트 설정을 사용하십시오. 예를 들어, &lt;code&gt;root&lt;/code&gt; 다음을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2711fad286d67111c91bf5304258de9bff55609" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;BEFORE&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just before the function is or would be executed, so using &lt;code&gt;WHEN&lt;/code&gt; is not materially different from testing the same condition at the beginning of the trigger function. Note in particular that the &lt;code&gt;NEW&lt;/code&gt; row seen by the condition is the current value, as possibly modified by earlier triggers. Also, a &lt;code&gt;BEFORE&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition is not allowed to examine the system columns of the &lt;code&gt;NEW&lt;/code&gt; row (such as &lt;code&gt;ctid&lt;/code&gt;), because those won't have been set yet.</source>
          <target state="translated">A의 &lt;code&gt;BEFORE&lt;/code&gt; 트리거는 &lt;code&gt;WHEN&lt;/code&gt; 조건은 함수 또는 그렇게하여 실행된다 직전 평가 &lt;code&gt;WHEN&lt;/code&gt; 트리거 함수의 시작 부분에 동일한 조건을 테스트 실질적으로 다르지 않다. 특히 조건에 표시되는 &lt;code&gt;NEW&lt;/code&gt; 행은 이전 트리거에 의해 수정 될 수있는 현재 값입니다. 또한 &lt;code&gt;BEFORE&lt;/code&gt; 트리거의 &lt;code&gt;WHEN&lt;/code&gt; 조건은 아직 설정되지 않았기 때문에 &lt;code&gt;NEW&lt;/code&gt; 행 의 시스템 열 (예 : &lt;code&gt;ctid&lt;/code&gt; ) 을 검사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ce810944c17541339c741b40b793201537de044" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DELETE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the content of the deleted row. For example:</source>
          <target state="translated">A의 &lt;code&gt;DELETE&lt;/code&gt; , 사용할 수있는 데이터 &lt;code&gt;RETURNING&lt;/code&gt; 삭제 된 행의 내용이다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d3bf14e9dc0493ac82721df4faae7ba81c88992" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DROP FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support must be specified.</source>
          <target state="translated">A의 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 절 피연산자 데이터 타입 (들) 함수를 지원하기위한 지정해야한다.</target>
        </trans-unit>
        <trans-unit id="85532f42163c3739d7f5a6244714ead077b8baea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">A의 &lt;code&gt;FUNCTION&lt;/code&gt; 의 절 피연산자 데이터 타입 (들)는 함수에 대한 (또는 클래스의 데이터 타입 (B 트리 비교 기능 및 해시 함수에 대한) 입력 데이터 타입 (들) 함수와 다를 경우, 지지체 의도 B- 트리 정렬은 GiST, SP-GiST, GIN 및 BRIN 연산자 클래스의 기능 및 모든 기능을 지원합니다. 이러한 기본값은 정확하므로 크로스 데이터 유형 비교를 지원하는 B- 트리 정렬 지원 함수의 경우를 제외하고는 &lt;code&gt;op_type&lt;/code&gt; 을 &lt;code&gt;FUNCTION&lt;/code&gt; 절에 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6f9bb9a1e74c73e631d5463da369a9644506e4f0" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SELECT&lt;/code&gt; command, these two policies are combined using &lt;code&gt;OR&lt;/code&gt;, with the net effect being that all rows can be selected. In other command types, only the second policy applies, so that the effects are the same as before.</source>
          <target state="translated">A의 &lt;code&gt;SELECT&lt;/code&gt; 명령,이 두 가지 정책을 사용하여 결합 &lt;code&gt;OR&lt;/code&gt; 모든 행이 선택 될 수있는 그물 효과. 다른 명령 유형에서는 효과가 이전과 동일하도록 두 번째 정책 만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="300ce212406203fa6b094fb383bde2b25f44a159" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;pg_hba.conf&lt;/code&gt; record specifying certificate authentication, the authentication option &lt;code&gt;clientcert&lt;/code&gt; is assumed to be &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;, and it cannot be turned off since a client certificate is necessary for this method. What the &lt;code&gt;cert&lt;/code&gt; method adds to the basic &lt;code&gt;clientcert&lt;/code&gt; certificate validity test is a check that the &lt;code&gt;cn&lt;/code&gt; attribute matches the database user name.</source>
          <target state="translated">인증서 인증을 지정 하는 &lt;code&gt;pg_hba.conf&lt;/code&gt; 레코드에서 인증 옵션 &lt;code&gt;clientcert&lt;/code&gt; 는 &lt;code&gt;verify-ca&lt;/code&gt; 또는 &lt;code&gt;verify-full&lt;/code&gt; 로 간주 되며이 방법에는 클라이언트 인증서가 필요하므로 해제 할 수 없습니다. 무엇 &lt;code&gt;cert&lt;/code&gt; 방법은 기본에 추가 &lt;code&gt;clientcert&lt;/code&gt; 의 인증서 유효 검사하면하는 검사입니다 &lt;code&gt;cn&lt;/code&gt; 속성은 데이터베이스 사용자 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f05e815aa51edd32e8f243de544f1a7fed6f4907" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;to_char&lt;/code&gt; output template string, there are certain patterns that are recognized and replaced with appropriately-formatted data based on the given value. Any text that is not a template pattern is simply copied verbatim. Similarly, in an input template string (for the other functions), template patterns identify the values to be supplied by the input data string. If there are characters in the template string that are not template patterns, the corresponding characters in the input data string are simply skipped over (whether or not they are equal to the template string characters).</source>
          <target state="translated">A의 &lt;code&gt;to_char&lt;/code&gt; 출력 템플릿 문자열 인식 주어진 값에 기초하여 적절하게 포맷 된 데이터로 대체되는 특정 패턴이있다. 템플릿 패턴이 아닌 텍스트는 그대로 그대로 복사됩니다. 마찬가지로 입력 템플릿 문자열 (다른 기능의 경우)에서 템플릿 패턴은 입력 데이터 문자열이 제공 할 값을 식별합니다. 템플릿 문자열에 템플릿 패턴이 아닌 문자가있는 경우 입력 데이터 문자열의 해당 문자를 건너 뜁니다 (템플릿 문자열 문자와 같은지 여부).</target>
        </trans-unit>
        <trans-unit id="78e3bba2064f9d9c2fee2733a54ca75d990eba66" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;hash join&lt;/em&gt; (without the &quot;parallel&quot; prefix), the inner side is executed in full by every cooperating process to build identical copies of the hash table. This may be inefficient if the hash table is large or the plan is expensive. In a &lt;em&gt;parallel hash join&lt;/em&gt;, the inner side is a &lt;em&gt;parallel hash&lt;/em&gt; that divides the work of building a shared hash table over the cooperating processes.</source>
          <target state="translated">A의 &lt;em&gt;해시 조인&lt;/em&gt; (이하 &quot;평행&quot;접두어없이) 내측은 해시 테이블의 동일한 복사본을 만들 모든 협력 프로세스 전체에서 실행된다. 해시 테이블이 크거나 계획이 비싸면 비효율적 일 수 있습니다. (A)에 &lt;em&gt;평행 한 해시 조인&lt;/em&gt; , 내측은 인 &lt;em&gt;병렬 해시&lt;/em&gt; 분할하는 협력 과정을 통해 공유 해시 테이블을 구축하는 작업.</target>
        </trans-unit>
        <trans-unit id="3480286d445961d6181c445c4ffd40322b928fd9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;merge join&lt;/em&gt;, the inner side is always a non-parallel plan and therefore executed in full. This may be inefficient, especially if a sort must be performed, because the work and resulting data are duplicated in every cooperating process.</source>
          <target state="translated">A의 &lt;em&gt;병합 조인&lt;/em&gt; , 내측 항상 평행하지 않은 평면이므로 전체 실행. 작업 및 결과 데이터가 모든 협력 프로세스에서 복제되므로 특히 정렬을 수행해야하는 경우 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="400e7c200fdc3546ddf00f5c7ed10cb2ab42e4c0" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;nested loop join&lt;/em&gt;, the inner side is always non-parallel. Although it is executed in full, this is efficient if the inner side is an index scan, because the outer tuples and thus the loops that look up values in the index are divided over the cooperating processes.</source>
          <target state="translated">(A)에 &lt;em&gt;중첩 루프 조인&lt;/em&gt; , 내측 항상 비 - 평행하다. 전체가 실행 되더라도 외부 튜플과 인덱스의 값을 찾는 루프가 협력 프로세스로 나누어 져 있기 때문에 내부가 인덱스 스캔 인 경우에 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="dea6a7ade41e8f01fb686c080220d4159b567183" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel bitmap heap scan&lt;/em&gt;, one process is chosen as the leader. That process performs a scan of one or more indexes and builds a bitmap indicating which table blocks need to be visited. These blocks are then divided among the cooperating processes as in a parallel sequential scan. In other words, the heap scan is performed in parallel, but the underlying index scan is not.</source>
          <target state="translated">(A)에 &lt;em&gt;평행 한 비트 맵 힙 주사&lt;/em&gt; 한 프로세스는 리더로서 선택된다. 이 프로세스는 하나 이상의 인덱스를 스캔하고 방문해야 할 테이블 블록을 나타내는 비트 맵을 작성합니다. 이 블록들은 병렬 순차 스캔에서와 같이 협력 프로세스들 사이에서 분할된다. 즉, 힙 스캔은 병렬로 수행되지만 기본 인덱스 스캔은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8227deba10aefb19ed8caa11f69ff745de460ae7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other process can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">A의 &lt;em&gt;스캔 인덱스 평행&lt;/em&gt; 또는 &lt;em&gt;평행 인덱스 만 스캔&lt;/em&gt; , 협력 프로세스는 인덱스로부터 데이터를 판독 돌아가며. 현재 병렬 인덱스 스캔은 btree 인덱스에 대해서만 지원됩니다. 각 프로세스는 단일 인덱스 블록을 요구하며 해당 블록이 참조하는 모든 튜플을 스캔하고 반환합니다. 다른 프로세스는 동시에 다른 인덱스 블록에서 튜플을 반환 할 수 있습니다. 병렬 btree 스캔 결과는 각 작업자 프로세스 내에서 정렬 된 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9434bbdc8aace98fbdb811c879672bca3c9b835e" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel sequential scan&lt;/em&gt;, the table's blocks will be divided among the cooperating processes. Blocks are handed out one at a time, so that access to the table remains sequential.</source>
          <target state="translated">(A)에 &lt;em&gt;병렬로 순차 검색&lt;/em&gt; 테이블의 블록 협력 프로세스간에 분할된다. 블록은 한 번에 하나씩 전달되므로 테이블에 대한 액세스는 순차적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f3fefb800e2db94c9c9a41bf996e2bc5c5260e63" translate="yes" xml:space="preserve">
          <source>In a B-tree leaf page, &lt;code&gt;ctid&lt;/code&gt; points to a heap tuple. In an internal page, the block number part of &lt;code&gt;ctid&lt;/code&gt; points to another page in the index itself, while the offset part (the second number) is ignored and is usually 1.</source>
          <target state="translated">B- 트리 리프 페이지에서 &lt;code&gt;ctid&lt;/code&gt; 는 힙 튜플을 가리 킵니다. 내부 페이지에서 &lt;code&gt;ctid&lt;/code&gt; 의 블록 번호 부분은 인덱스 자체의 다른 페이지를 가리키는 반면 오프셋 부분 (두 번째 숫자)은 무시되며 보통 1입니다.</target>
        </trans-unit>
        <trans-unit id="d0a6087a10f85c3bb150e6308e3861061574aa67" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">동시 인덱스 빌드에서 인덱스는 실제로 하나의 트랜잭션으로 시스템 카탈로그에 입력 된 다음 두 개의 추가 트랜잭션에서 두 개의 테이블 스캔이 발생합니다. 각 테이블 스캔 전에 인덱스 빌드는 테이블을 수정 한 기존 트랜잭션이 종료 될 때까지 기다려야합니다. 두 번째 스캔 후 인덱스 빌드는 두 번째 스캔보다 우선 하는 스냅 샷 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조)이있는 트랜잭션이 종료 될 때까지 기다려야합니다 . 그런 다음 마지막으로 색인을 사용할 준비가되었음을 표시하고 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령을 종료합니다. 그럼에도 불구하고 인덱스는 쿼리에 즉시 사용 가능하지 않을 수 있습니다. 최악의 경우 인덱스 빌드 시작 이전의 트랜잭션이 존재하는 한 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4a542d58c1d654f7da71e85731698e5120795a1" translate="yes" xml:space="preserve">
          <source>In a default installation, none of the above parameters are set explicitly. Instead, the data directory is specified by the &lt;code&gt;-D&lt;/code&gt; command-line option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable, and the configuration files are all found within the data directory.</source>
          <target state="translated">기본 설치에서는 위의 매개 변수 중 어느 것도 명시 적으로 설정되지 않습니다. 대신, 데이터 디렉토리는 &lt;code&gt;-D&lt;/code&gt; 명령 행 옵션 또는 &lt;code&gt;PGDATA&lt;/code&gt; 환경 변수에 의해 지정되며 구성 파일은 모두 데이터 디렉토리 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ade0e33e559fe0711e0dbe8eb460618e29475014" translate="yes" xml:space="preserve">
          <source>In a dropped column's &lt;code&gt;pg_attribute&lt;/code&gt; entry, &lt;code&gt;atttypid&lt;/code&gt; is reset to zero, but &lt;code&gt;attlen&lt;/code&gt; and the other fields copied from &lt;code&gt;pg_type&lt;/code&gt; are still valid. This arrangement is needed to cope with the situation where the dropped column's data type was later dropped, and so there is no &lt;code&gt;pg_type&lt;/code&gt; row anymore. &lt;code&gt;attlen&lt;/code&gt; and the other fields can be used to interpret the contents of a row of the table.</source>
          <target state="translated">삭제 된 열의 &lt;code&gt;pg_attribute&lt;/code&gt; 항목에서 &lt;code&gt;atttypid&lt;/code&gt; 는 0으로 재설정되지만 &lt;code&gt;attlen&lt;/code&gt; 및 &lt;code&gt;pg_type&lt;/code&gt; 에서 복사 된 다른 필드 는 여전히 유효합니다. 삭제 된 열의 데이터 유형이 나중에 삭제 된 상황에 대처하기 위해이 배열이 필요하므로 더 이상 &lt;code&gt;pg_type&lt;/code&gt; 행이 없습니다. &lt;code&gt;attlen&lt;/code&gt; 및 기타 필드를 사용하여 테이블 행의 내용을 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="919410546242ad36460212f72d578356bff6291e" translate="yes" xml:space="preserve">
          <source>In a literal that has been determined to be &lt;code&gt;timestamp without time zone&lt;/code&gt;, PostgreSQL will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.</source>
          <target state="translated">&lt;code&gt;timestamp without time zone&lt;/code&gt; 것으로 확인 된 리터럴 에서 PostgreSQL은 모든 표준 시간대 표시를 자동으로 무시합니다. 즉, 결과 값은 입력 값의 날짜 / 시간 필드에서 파생되며 시간대에 맞게 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe8c5382c7df4fd888e297e6990fce336207e731" translate="yes" xml:space="preserve">
          <source>In a priority-based synchronous replication, the standbys whose names appear earlier in the list will be used as synchronous standbys. Standbys listed after these will take over the role of synchronous standby if one of current ones should fail.</source>
          <target state="translated">우선 순위 기반 동기식 복제에서는 목록에서 이름이 일찍 표시되는 대기가 동기식 대기로 사용됩니다. 다음에 나열된 대기는 현재 대기 중 하나가 실패하는 경우 동기 대기의 역할을 대신합니다.</target>
        </trans-unit>
        <trans-unit id="6be13ad3386e50cb4bfa2ce22e78dd04cec9a6ab" translate="yes" xml:space="preserve">
          <source>In a quorum-based synchronous replication, all the standbys appearing in the list will be used as candidates for synchronous standbys. Even if one of them should fail, the other standbys will keep performing the role of candidates of synchronous standby.</source>
          <target state="translated">쿼럼 기반 동기 복제에서는 목록에 나타나는 모든 대기가 동기 대기의 후보로 사용됩니다. 이들 중 하나가 실패하더라도 다른 대기는 동기 대기 후보의 역할을 계속 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a6cdb6331798b6847433d71683fa652dae3c0858" translate="yes" xml:space="preserve">
          <source>In a rule for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; on a view, you can add a &lt;code&gt;RETURNING&lt;/code&gt; clause that emits the view's columns. This clause will be used to compute the outputs if the rule is triggered by an &lt;code&gt;INSERT RETURNING&lt;/code&gt;, &lt;code&gt;UPDATE RETURNING&lt;/code&gt;, or &lt;code&gt;DELETE RETURNING&lt;/code&gt; command respectively. When the rule is triggered by a command without &lt;code&gt;RETURNING&lt;/code&gt;, the rule's &lt;code&gt;RETURNING&lt;/code&gt; clause will be ignored. The current implementation allows only unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules to contain &lt;code&gt;RETURNING&lt;/code&gt;; furthermore there can be at most one &lt;code&gt;RETURNING&lt;/code&gt; clause among all the rules for the same event. (This ensures that there is only one candidate &lt;code&gt;RETURNING&lt;/code&gt; clause to be used to compute the results.) &lt;code&gt;RETURNING&lt;/code&gt; queries on the view will be rejected if there is no &lt;code&gt;RETURNING&lt;/code&gt; clause in any available rule.</source>
          <target state="translated">뷰의 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 규칙 에서 뷰의 열을 생성 하는 &lt;code&gt;RETURNING&lt;/code&gt; 절을 추가 할 수 있습니다 . 이 절은 규칙이 각각 &lt;code&gt;INSERT RETURNING&lt;/code&gt; , &lt;code&gt;UPDATE RETURNING&lt;/code&gt; 또는 &lt;code&gt;DELETE RETURNING&lt;/code&gt; 명령 에 의해 트리거되는 경우 출력을 계산하는 데 사용됩니다 . &lt;code&gt;RETURNING&lt;/code&gt; 이 없는 명령에 의해 규칙이 트리거 되면 규칙의 &lt;code&gt;RETURNING&lt;/code&gt; 절이 무시됩니다. 현재 구현에서는 무조건 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙 만 &lt;code&gt;RETURNING&lt;/code&gt; 을 포함 할 수 있습니다 . 또한 최대 하나의 &lt;code&gt;RETURNING&lt;/code&gt; 이있을 수 있습니다.동일한 이벤트에 대한 모든 규칙 중 조항. 이렇게하면 결과를 계산하는 데 사용할 후보 &lt;code&gt;RETURNING&lt;/code&gt; 절이 하나만 있게됩니다. 사용 가능한 규칙에 &lt;code&gt;RETURNING&lt;/code&gt; 절이 없으면 뷰의 &lt;code&gt;RETURNING&lt;/code&gt; 쿼리가 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="b30170def17c750dae562bb19e988c5bae9da5a7" translate="yes" xml:space="preserve">
          <source>In a simple join query, such as:</source>
          <target state="translated">다음과 같은 간단한 조인 쿼리에서</target>
        </trans-unit>
        <trans-unit id="3e1f4464d1af94cd74998edaeff888eee6d91174" translate="yes" xml:space="preserve">
          <source>In a standby server that exists primarily for high availability, it's best to set the delay parameters relatively short, so that the server cannot fall far behind the primary due to delays caused by standby queries. However, if the standby server is meant for executing long-running queries, then a high or even infinite delay value may be preferable. Keep in mind however that a long-running query could cause other sessions on the standby server to not see recent changes on the primary, if it delays application of WAL records.</source>
          <target state="translated">주로 고 가용성을 위해 존재하는 대기 서버에서는 지연 매개 변수를 비교적 짧게 설정하는 것이 가장 좋습니다. 따라서 대기 쿼리로 인한 지연으로 인해 서버가 기본 서버보다 훨씬 떨어지지 않게됩니다. 그러나 대기 서버가 장기 실행 쿼리를 실행하기위한 것이면 높거나 무한한 지연 값이 바람직 할 수 있습니다. 그러나 장기 실행 쿼리로 인해 대기 서버의 다른 세션에서 기본 세션의 WAL 레코드 적용이 지연되는 경우 기본 세션의 최근 변경 사항을 보지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9a7bd917eb1db2204b6427584eda8a4fd3adfe" translate="yes" xml:space="preserve">
          <source>In a table definition, default values are listed after the column data type. For example:</source>
          <target state="translated">테이블 정의에서 기본값은 열 데이터 유형 뒤에 나열됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea0511eba225911c6d4bd1330fecc7bed6e9ecc3" translate="yes" xml:space="preserve">
          <source>In addition these settings can be preserved between reboots in the file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. Doing that is highly recommended.</source>
          <target state="translated">또한이 설정은 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 파일에서 재부팅 할 때에도 유지 될 수 있습니다 . 그렇게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="096299b269c3119f5fd70cea143f131c4bf07844" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;postgresql.conf&lt;/code&gt;, a PostgreSQL data directory contains a file &lt;code&gt;postgresql.auto.conf&lt;/code&gt;, which has the same format as &lt;code&gt;postgresql.conf&lt;/code&gt; but is intended to be edited automatically, not manually. This file holds settings provided through the &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command. This file is read whenever &lt;code&gt;postgresql.conf&lt;/code&gt; is, and its settings take effect in the same way. Settings in &lt;code&gt;postgresql.auto.conf&lt;/code&gt; override those in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 외에도 PostgreSQL 데이터 디렉토리에는 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 와 형식은 동일 하지만 수동이 아닌 자동으로 편집되도록 고안된 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일이 포함되어 있습니다. 이 파일은 &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; 명령을 통해 제공된 설정을 보유 합니다. 이 파일은 &lt;code&gt;postgresql.conf&lt;/code&gt; 가 있을 때마다 읽히고 설정은 같은 방식으로 적용됩니다. 의 설정 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 은 의 그 무시 &lt;code&gt;postgresql.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b72ebbfc32b5c7dc9d476e5e61c36ae4f704bc0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;public&lt;/code&gt; and user-created schemas, each database contains a &lt;code&gt;pg_catalog&lt;/code&gt; schema, which contains the system tables and all the built-in data types, functions, and operators. &lt;code&gt;pg_catalog&lt;/code&gt; is always effectively part of the search path. If it is not named explicitly in the path then it is implicitly searched &lt;em&gt;before&lt;/em&gt; searching the path's schemas. This ensures that built-in names will always be findable. However, you can explicitly place &lt;code&gt;pg_catalog&lt;/code&gt; at the end of your search path if you prefer to have user-defined names override built-in names.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 및 사용자 작성 스키마 외에도 각 데이터베이스에는 시스템 테이블과 모든 내장 데이터 유형, 함수 및 연산자 가 포함 된 &lt;code&gt;pg_catalog&lt;/code&gt; 스키마가 포함됩니다. &lt;code&gt;pg_catalog&lt;/code&gt; 는 항상 효과적으로 검색 경로의 일부입니다. 경로에서 명시 적으로 이름이 지정되지 않은 경우 경로의 스키마를 검색 &lt;em&gt;하기 전에&lt;/em&gt; 내재적으로 검색 됩니다. 이를 통해 내장 이름을 항상 찾을 수 있습니다. 그러나 사용자 정의 이름이 내장 이름보다 우선하도록하려면 검색 경로 끝에 &lt;code&gt;pg_catalog&lt;/code&gt; 를 명시 적으로 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f70bc34b6f3d01fe499b2933dfc1efba4688427d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;standard_conforming_strings&lt;/code&gt;, the configuration parameters &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; and &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote&lt;/a&gt; govern treatment of backslashes in string constants.</source>
          <target state="translated">뿐만 아니라 &lt;code&gt;standard_conforming_strings&lt;/code&gt; , 구성 매개 변수 &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote는&lt;/a&gt; 문자열 상수의 백 슬래시의 치료에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca198320ff48380e299bcbd7319925ded5a95535" translate="yes" xml:space="preserve">
          <source>In addition to individual parameter settings, the &lt;code&gt;postgresql.conf&lt;/code&gt; file can contain &lt;em&gt;include directives&lt;/em&gt;, which specify another file to read and process as if it were inserted into the configuration file at this point. This feature allows a configuration file to be divided into physically separate parts. Include directives simply look like:</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 파일에는 개별 매개 변수 설정 외에도 &lt;em&gt;include 지시문&lt;/em&gt; 이 포함될 수 있습니다. &lt;em&gt;이 지시문&lt;/em&gt; 은이 시점에서 구성 파일에 삽입 된 것처럼 읽고 처리 할 다른 파일을 지정합니다. 이 기능을 사용하면 구성 파일을 물리적으로 분리 된 부분으로 나눌 수 있습니다. 지시문 포함은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e670e7bf52fa0455274db822ce4cd6907d528db9" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the &lt;code&gt;numeric&lt;/code&gt; type allows the special value &lt;code&gt;NaN&lt;/code&gt;, meaning &amp;ldquo;not-a-number&amp;rdquo;. Any operation on &lt;code&gt;NaN&lt;/code&gt; yields another &lt;code&gt;NaN&lt;/code&gt;. When writing this value as a constant in an SQL command, you must put quotes around it, for example &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt;. On input, the string &lt;code&gt;NaN&lt;/code&gt; is recognized in a case-insensitive manner.</source>
          <target state="translated">일반 숫자 값 외에도 &lt;code&gt;numeric&lt;/code&gt; 유형은 &quot;숫자가 아님&quot;을 의미 하는 특수 값 &lt;code&gt;NaN&lt;/code&gt; 을 허용합니다 . &lt;code&gt;NaN&lt;/code&gt; 에 대한 작업 은 다른 &lt;code&gt;NaN&lt;/code&gt; 을 생성 합니다. SQL 명령에서이 값을 상수로 쓸 때 &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt; 과 같이 따옴표를 묶어야합니다 . 입력시 문자열 &lt;code&gt;NaN&lt;/code&gt; 은 대소 문자를 구분하지 않고 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="e4bbcc684e36efbca1c2d0b6de3932866401bc9a" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the floating-point types have several special values:</source>
          <target state="translated">일반 숫자 값 외에도 부동 소수점 유형에는 몇 가지 특수 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="19311d87cac186ad5be7afccb28d88535be2bd00" translate="yes" xml:space="preserve">
          <source>In addition to setting global defaults or attaching overrides at the database or role level, you can pass settings to PostgreSQL via shell facilities. Both the server and libpq client library accept parameter values via the shell.</source>
          <target state="translated">데이터베이스 또는 역할 수준에서 전역 기본값을 설정하거나 재정의를 첨부하는 것 외에도 셸 기능을 통해 설정을 PostgreSQL로 전달할 수 있습니다. 서버 및 libpq 클라이언트 라이브러리는 모두 쉘을 통해 매개 변수 값을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="a22166b5786a29ccaf8b6526c1e48730c5b76cde" translate="yes" xml:space="preserve">
          <source>In addition to simply finding the rows to be returned by a query, an index may be able to deliver them in a specific sorted order. This allows a query's &lt;code&gt;ORDER BY&lt;/code&gt; specification to be honored without a separate sorting step. Of the index types currently supported by PostgreSQL, only B-tree can produce sorted output &amp;mdash; the other index types return matching rows in an unspecified, implementation-dependent order.</source>
          <target state="translated">쿼리에서 반환 할 행을 찾는 것 외에도 인덱스는 특정 정렬 순서로 행을 전달할 수 있습니다. 이를 통해 별도의 정렬 단계없이 쿼리의 &lt;code&gt;ORDER BY&lt;/code&gt; 사양을 유지할 수 있습니다. 현재 PostgreSQL에서 지원하는 인덱스 유형 중 B- 트리 만 정렬 된 출력을 생성 할 수 있습니다. 다른 인덱스 유형은 지정되지 않은 구현 종속 순서로 일치하는 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ba1e6913eefc780040c670e81ceade68f518709" translate="yes" xml:space="preserve">
          <source>In addition to supporting ordinary index scans, some types of index may wish to support &lt;em&gt;parallel index scans&lt;/em&gt;, which allow multiple backends to cooperate in performing an index scan. The index access method should arrange things so that each cooperating process returns a subset of the tuples that would be performed by an ordinary, non-parallel index scan, but in such a way that the union of those subsets is equal to the set of tuples that would be returned by an ordinary, non-parallel index scan. Furthermore, while there need not be any global ordering of tuples returned by a parallel scan, the ordering of that subset of tuples returned within each cooperating backend must match the requested ordering. The following functions may be implemented to support parallel index scans:</source>
          <target state="translated">일반 인덱스 스캔을 지원하는 것 외에도 일부 유형의 인덱스는 &lt;em&gt;병렬 인덱스 스캔&lt;/em&gt; 을 지원 하여 여러 백엔드가 인덱스 스캔을 수행하는 데 협력 할 수 있습니다. 인덱스 액세스 방법은 각 협력 프로세스가 일반적인 비평 행 인덱스 스캔에 의해 수행 될 터플의 서브 세트를 리턴하지만 해당 서브 세트의 합집합이 터플 세트와 같은 방식으로 리턴하도록 항목을 배열해야합니다. 이는 병렬이 아닌 일반 인덱스 스캔에 의해 리턴됩니다. 또한, 병렬 스캔에 의해 리턴 된 튜플의 전체 순서는 필요하지 않지만, 각 협력 백엔드 내에서 리턴 된 해당 튜플 서브 세트의 순서는 요청 된 순서와 일치해야합니다. 병렬 인덱스 스캔을 지원하기 위해 다음 기능이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2240e6efaaf6aaec400aa311d695b65a5cb9013d" translate="yes" xml:space="preserve">
          <source>In addition to table and row locks, page-level share/exclusive locks are used to control read/write access to table pages in the shared buffer pool. These locks are released immediately after a row is fetched or updated. Application developers normally need not be concerned with page-level locks, but they are mentioned here for completeness.</source>
          <target state="translated">테이블 및 행 잠금 외에도 페이지 레벨 공유 / 독점 잠금은 공유 버퍼 풀의 테이블 페이지에 대한 읽기 / 쓰기 액세스를 제어하는 ​​데 사용됩니다. 이러한 잠금은 행을 가져 오거나 업데이트 한 직후 해제됩니다. 응용 프로그램 개발자는 일반적으로 페이지 수준 잠금에 대해 걱정할 필요는 없지만 완전성을 위해 여기에 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="87509ac7479eedd6c62071274770036abf56ee4c" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row.</source>
          <target state="translated">테이블 수준 잠금 외에도 행 수준 잠금이 있으며 PostgreSQL에서 자동으로 사용되는 컨텍스트와 함께 아래에 나열됩니다. 전체 행 수준 잠금 충돌 표는 &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;표 13.3&lt;/a&gt; 을 참조하십시오 . 트랜잭션은 다른 서브 트랜잭션에서도 동일한 행에서 충돌 잠금을 보유 할 수 있습니다. 그러나 그 이외의 두 트랜잭션은 동일한 행에서 충돌하는 잠금을 보유 할 수 없습니다. 행 수준 잠금은 데이터 쿼리에 영향을 미치지 않습니다. 같은 행에 대한 &lt;em&gt;기록기 및 로커&lt;/em&gt; 만 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="eefa082a90a01551ee9f7be83fe0ecef6e330ce1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">앞에서 언급 한 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 외에도 PostgreSQL은 수동으로 편집 한 두 개의 다른 구성 파일을 사용하여 클라이언트 인증을 제어합니다 (사용 방법은 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 에서 설명합니다 ). 기본적으로 세 가지 구성 파일은 모두 데이터베이스 클러스터의 데이터 디렉토리에 저장됩니다. 이 섹션에서 설명하는 매개 변수를 사용하면 구성 파일을 다른 곳에 배치 할 수 있습니다. 이렇게하면 관리가 쉬워 질 수 있습니다. 특히 구성 파일을 별도로 보관할 때 구성 파일을 올바르게 백업하는 것이 더 쉬운 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="06a5b24df3b5e27969bb36917a3a17ae8bb1189b" translate="yes" xml:space="preserve">
          <source>In addition to the SQL-standard &lt;a href=&quot;ddl-priv&quot;&gt;privilege system&lt;/a&gt; available through &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;, tables can have &lt;em&gt;row security policies&lt;/em&gt; that restrict, on a per-user basis, which rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as &lt;em&gt;Row-Level Security&lt;/em&gt;. By default, tables do not have any policies, so that if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating.</source>
          <target state="translated">&lt;a href=&quot;sql-grant&quot;&gt;GRANT를&lt;/a&gt; 통해 사용할 수 있는 SQL 표준 &lt;a href=&quot;ddl-priv&quot;&gt;권한 시스템&lt;/a&gt; 외에도 테이블에는 사용자별로 기준 쿼리를 반환하거나 데이터 수정 명령으로 삽입, 업데이트 또는 삭제할 수있는 &lt;em&gt;행 보안 정책&lt;/em&gt; 이 있습니다. 이 기능은 &lt;em&gt;행 수준 보안&lt;/em&gt; 이라고도 합니다. 기본적으로 테이블에는 정책이 없으므로 사용자가 SQL 권한 시스템에 따라 테이블에 대한 액세스 권한을 가지고 있으면 테이블 내의 모든 행을 쿼리하거나 업데이트 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58a68bf9280d646b1a85ebb074d2b6ecfecda3df" translate="yes" xml:space="preserve">
          <source>In addition to the format specifiers described above, the special sequence &lt;code&gt;%%&lt;/code&gt; may be used to output a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">위에서 설명한 형식 지정자 외에도 특수 시퀀스 &lt;code&gt;%%&lt;/code&gt; 를 사용하여 리터럴 &lt;code&gt;%&lt;/code&gt; 문자 를 출력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bfea922b7478af1fb30846a7ffdd145169e7fe7" translate="yes" xml:space="preserve">
          <source>In addition to the functions listed in this section, there are a number of functions related to the statistics system that also provide system information. See &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;Section 27.2.2&lt;/a&gt; for more information.</source>
          <target state="translated">이 섹션에 나열된 기능 외에도 시스템 정보를 제공하는 통계 시스템과 관련된 여러 기능이 있습니다. 자세한 정보는 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;27.2.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2dc53d9aa025a55feab0c728607a475dd6480573" translate="yes" xml:space="preserve">
          <source>In addition to the generic lookup mechanisms, there is a special convention that &lt;code&gt;PGNSP&lt;/code&gt; is replaced by the OID of the &lt;code&gt;pg_catalog&lt;/code&gt; schema, and &lt;code&gt;PGUID&lt;/code&gt; is replaced by the OID of the bootstrap superuser role. These usages are somewhat historical but so far there hasn't been a need to generalize them.</source>
          <target state="translated">일반 조회 메커니즘 외에도 &lt;code&gt;PGNSP&lt;/code&gt; 가 &lt;code&gt;pg_catalog&lt;/code&gt; 스키마 의 OID로 대체되고 &lt;code&gt;PGUID&lt;/code&gt; 가 부트 스트랩 수퍼 유저 역할 의 OID로 대체 된다는 특별한 규칙이 있습니다. 이러한 사용법은 다소 역사적이지만 지금까지 일반화 할 필요는 없었습니다.</target>
        </trans-unit>
        <trans-unit id="671caebf932d9cdddfa02cea4a21319996df3fc1" translate="yes" xml:space="preserve">
          <source>In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available.</source>
          <target state="translated">위에서 설명한 주요 구문 외에도 몇 가지 특수한 형식과 기타 구문 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfdcb8c233fbe99bb0dea34235cb119f257b9a78" translate="yes" xml:space="preserve">
          <source>In addition to the method-specific options listed below, there is one method-independent authentication option &lt;code&gt;clientcert&lt;/code&gt;, which can be specified in any &lt;code&gt;hostssl&lt;/code&gt; record. This option can be set to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. Both options require the client to present a valid (trusted) SSL certificate, while &lt;code&gt;verify-full&lt;/code&gt; additionally enforces that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the username or an applicable mapping. This behavior is similar to the &lt;code&gt;cert&lt;/code&gt; authentication method (see &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt;) but enables pairing the verification of client certificates with any authentication method that supports &lt;code&gt;hostssl&lt;/code&gt; entries.</source>
          <target state="translated">아래에 나열된 방법 별 옵션 외에도 방법 독립적 인 인증 옵션 &lt;code&gt;clientcert&lt;/code&gt; 가 있으며 , 이는 &lt;code&gt;hostssl&lt;/code&gt; 레코드에 지정할 수 있습니다 . 이 옵션은 &lt;code&gt;verify-ca&lt;/code&gt; 또는 &lt;code&gt;verify-full&lt;/code&gt; 로 설정할 수 있습니다 . 두 옵션 모두 클라이언트가 유효한 (신뢰할 수있는) SSL 인증서를 제시해야하지만 &lt;code&gt;verify-full&lt;/code&gt; 은 인증서 의 &lt;code&gt;cn&lt;/code&gt; (공통 이름)이 사용자 이름 또는 적용 가능한 매핑과 일치하도록 추가로 강제합니다 . 이 동작은 &lt;code&gt;cert&lt;/code&gt; 인증 방법 ( &lt;a href=&quot;auth-cert&quot;&gt;20.12 절&lt;/a&gt; 참조 )과 유사 하지만 클라이언트 인증서 확인을 &lt;code&gt;hostssl&lt;/code&gt; 을 지원하는 인증 방법과 쌍을 이룰 수 있습니다. 항목.</target>
        </trans-unit>
        <trans-unit id="ddf91010c34fa3b26374dd73b3df519e9da0fd2a" translate="yes" xml:space="preserve">
          <source>In addition to the operators shown in the table, the ordinary B-tree comparison operators (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, etc) are defined for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">표에 표시된 연산자 외에도 일반 B- 트리 비교 연산자 ( &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; 등)는 &lt;code&gt;tsvector&lt;/code&gt; 및 &lt;code&gt;tsquery&lt;/code&gt; 유형에 대해 정의됩니다 . 텍스트 검색에는 유용하지 않지만 예를 들어 이러한 유형의 열에 고유 인덱스를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c46db92025ad200f49ee2517827b67ca69ce01" translate="yes" xml:space="preserve">
          <source>In addition to the socket file itself, which is named &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; where &lt;code&gt;nnnn&lt;/code&gt; is the server's port number, an ordinary file named &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; will be created in each of the &lt;code&gt;unix_socket_directories&lt;/code&gt; directories. Neither file should ever be removed manually.</source>
          <target state="translated">소켓 파일 자체 ( &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; )( 여기서 &lt;code&gt;nnnn&lt;/code&gt; 은 서버의 포트 번호 &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; 이라는 일반 파일 이 각 &lt;code&gt;unix_socket_directories&lt;/code&gt; 디렉토리에 작성됩니다. 파일을 수동으로 제거해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f961899526c4ec4b91a471972a05e3809476d8c4" translate="yes" xml:space="preserve">
          <source>In addition to the system catalogs, PostgreSQL provides a number of built-in views. Some system views provide convenient access to some commonly used queries on the system catalogs. Other views provide access to internal server state.</source>
          <target state="translated">시스템 카탈로그 이외에도 PostgreSQL은 여러 내장 뷰를 제공합니다. 일부 시스템 뷰는 시스템 카탈로그에서 일반적으로 사용되는 일부 쿼리에 편리하게 액세스 할 수 있습니다. 다른보기는 내부 서버 상태에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e99de7dbe2b503398057fb045bf3c995d4ba6e3" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications of the form &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;DST&lt;/code&gt;, where &lt;code&gt;STD&lt;/code&gt; is a zone abbreviation, &lt;code&gt;offset&lt;/code&gt; is a numeric offset in hours west from UTC, and &lt;code&gt;DST&lt;/code&gt; is an optional daylight-savings zone abbreviation, assumed to stand for one hour ahead of the given offset. For example, if &lt;code&gt;EST5EDT&lt;/code&gt; were not already a recognized zone name, it would be accepted and would be functionally equivalent to United States East Coast time. In this syntax, a zone abbreviation can be a string of letters, or an arbitrary string surrounded by angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;). When a daylight-savings zone abbreviation is present, it is assumed to be used according to the same daylight-savings transition rules used in the IANA time zone database's &lt;code&gt;posixrules&lt;/code&gt; entry. In a standard PostgreSQL installation, &lt;code&gt;posixrules&lt;/code&gt; is the same as &lt;code&gt;US/Eastern&lt;/code&gt;, so that POSIX-style time zone specifications follow USA daylight-savings rules. If needed, you can adjust this behavior by replacing the &lt;code&gt;posixrules&lt;/code&gt; file.</source>
          <target state="translated">표준 시간대 이름과 약어 외에도 PostgreSQL은 &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 또는 &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;DST&lt;/code&gt; 형식의 POSIX 스타일 시간대 사양을 허용합니다 . 여기서 &lt;code&gt;STD&lt;/code&gt; 는 영역 약어이고 &lt;code&gt;offset&lt;/code&gt; 은 UTC에서 서쪽으로 몇 시간 단위로 숫자 오프셋이며 &lt;code&gt;DST&lt;/code&gt; 는 지정된 오프셋보다 1 시간 앞서있는 것으로 가정되는 일광 절약 영역 약어 (선택 사항). 예를 들어, &lt;code&gt;EST5EDT&lt;/code&gt; 가 아직 인식되는 영역 이름이 아닌 경우 미국 동부 해안 시간과 동일하게 적용됩니다. 이 구문에서 영역 약어는 문자 문자열이거나 꺾쇠 괄호 ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ). 일광 절약 영역 약어가 있으면 IANA 시간대 데이터베이스의 &lt;code&gt;posixrules&lt;/code&gt; 항목에 사용 된 것과 동일한 일광 절약 변환 규칙에 따라 사용되는 것으로 가정합니다 . 표준 PostgreSQL 설치에서 &lt;code&gt;posixrules&lt;/code&gt; 는 &lt;code&gt;US/Eastern&lt;/code&gt; 과 동일 하므로 POSIX 스타일 시간대 사양은 미국 일광 절약 규칙을 따릅니다. 필요한 경우 &lt;code&gt;posixrules&lt;/code&gt; 파일 을 교체하여이 동작을 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5639f9b8e3c76507298cdef9442456212dc91a3a" translate="yes" xml:space="preserve">
          <source>In addition to the typical B-tree search operators, &lt;code&gt;btree_gist&lt;/code&gt; also provides index support for &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (&amp;ldquo;not equals&amp;rdquo;). This may be useful in combination with an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt;, as described below.</source>
          <target state="translated">일반적인 B- 트리 검색 연산자 &lt;code&gt;btree_gist&lt;/code&gt; 는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에 대한 인덱스 지원 (&amp;ldquo;같지 않음&amp;rdquo;) 도 제공합니다 . 아래 설명과 같이 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;제외 제약 조건&lt;/a&gt; 과 함께 사용하면 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7456acfa95fcaf383cf25fda8119cc53ab8322a" translate="yes" xml:space="preserve">
          <source>In addition to the usual (&lt;em&gt;tight&lt;/em&gt;) RE syntax, in which all characters are significant, there is an &lt;em&gt;expanded&lt;/em&gt; syntax, available by specifying the embedded &lt;code&gt;x&lt;/code&gt; option. In the expanded syntax, white-space characters in the RE are ignored, as are all characters between a &lt;code&gt;#&lt;/code&gt; and the following newline (or the end of the RE). This permits paragraphing and commenting a complex RE. There are three exceptions to that basic rule:</source>
          <target state="translated">모든 문자가 중요한 일반적인 ( &lt;em&gt;긴급한&lt;/em&gt; ) RE 구문 외에도 Embedded &lt;code&gt;x&lt;/code&gt; 옵션 을 지정하여 사용할 수 있는 &lt;em&gt;확장 된&lt;/em&gt; 구문이 있습니다 . 확장 구문에서 &lt;code&gt;#&lt;/code&gt; 과 다음 줄 바꾸기 (또는 RE의 끝) 사이의 모든 문자와 마찬가지로 RE의 공백 문자는 무시됩니다 . 이를 통해 복잡한 RE를 단락하고 주석을 달 수 있습니다. 해당 기본 규칙에는 세 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da522f31f6ebf1b8a6e0efd3ead6600864945861" translate="yes" xml:space="preserve">
          <source>In addition to these facilities borrowed from &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; supports these pattern-matching metacharacters borrowed from POSIX regular expressions:</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 에서 빌린 이러한 기능 외에도 &lt;code&gt;SIMILAR TO&lt;/code&gt; 는 POSIX 정규식에서 빌린 다음 패턴 일치 메타 문자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d5ad168deb41cb8cd3104e11c297f4193822a79b" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined general-purpose or statistical aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as non-window aggregates and return a single row for the entire set.</source>
          <target state="translated">이러한 기능 외에도 모든 내장 또는 사용자 정의 범용 또는 통계 집계 (즉, 순서 집합 또는 가정 집합 집합이 아님)를 창 함수로 사용할 수 있습니다. 내장 집계 목록 은 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.20&lt;/a&gt; 을 참조하십시오 . 집계 함수는 &lt;code&gt;OVER&lt;/code&gt; 절이 호출을 따르는 경우에만 창 함수로 작동합니다 . 그렇지 않으면 비 창구 집계로 작동하고 전체 세트에 대해 단일 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b254c4c7b10faf7e76791fc77c4b40ffb55a623" translate="yes" xml:space="preserve">
          <source>In addition to these functions, the SQL &lt;code&gt;OVERLAPS&lt;/code&gt; operator is supported:</source>
          <target state="translated">이러한 기능 외에도 SQL &lt;code&gt;OVERLAPS&lt;/code&gt; 연산자가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="918debfa135a3ee3b32c08e005bfe3898a987217" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">이 목록 외에도 표현식으로 분류 할 수 있지만 일반적인 구문 규칙을 따르지 않는 많은 구성이 있습니다. 이것들은 일반적으로 함수 또는 연산자의 의미를 가지며 &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장의&lt;/a&gt; 적절한 위치에 설명되어 있습니다. 예는 &lt;code&gt;IS NULL&lt;/code&gt; 절입니다.</target>
        </trans-unit>
        <trans-unit id="1eea807026cd270d625f43d7ed3f99bcbf28a0f1" translate="yes" xml:space="preserve">
          <source>In addition, B-tree and hash indexes can be created for table columns of range types. For these index types, basically the only useful range operation is equality. There is a B-tree sort ordering defined for range values, with corresponding &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators, but the ordering is rather arbitrary and not usually useful in the real world. Range types' B-tree and hash support is primarily meant to allow sorting and hashing internally in queries, rather than creation of actual indexes.</source>
          <target state="translated">또한 범위 유형의 테이블 열에 대해 B- 트리 및 해시 인덱스를 만들 수 있습니다. 이러한 인덱스 유형의 경우 기본적으로 유일하게 유용한 범위 연산은 평등입니다. 해당 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자를 사용 하여 범위 값에 대해 정의 된 B- 트리 정렬 순서가 있지만 순서는 다소 임의적이며 일반적으로 현실에서는 유용하지 않습니다. 범위 유형의 B- 트리 및 해시 지원은 기본적으로 실제 인덱스를 작성하지 않고 쿼리에서 내부적으로 정렬 및 해싱을 허용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec168afc08cf14d67db79d5a556441966649b178" translate="yes" xml:space="preserve">
          <source>In addition, GIN must have a way to sort the key values stored in the index. The operator class can define the sort ordering by specifying a comparison method:</source>
          <target state="translated">또한 GIN에는 인덱스에 저장된 키 값을 정렬 할 수있는 방법이 있어야합니다. 연산자 클래스는 비교 방법을 지정하여 정렬 순서를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f602065328e166c6745869bc0a8f779ad09a07b" translate="yes" xml:space="preserve">
          <source>In addition, PostgreSQL provides the &lt;code&gt;text&lt;/code&gt; type, which stores strings of any length. Although the type &lt;code&gt;text&lt;/code&gt; is not in the SQL standard, several other SQL database management systems have it as well.</source>
          <target state="translated">또한 PostgreSQL은 모든 길이의 문자열을 저장 하는 &lt;code&gt;text&lt;/code&gt; 유형을 제공합니다 . 유형 &lt;code&gt;text&lt;/code&gt; 는 SQL 표준이 아니지만 다른 여러 SQL 데이터베이스 관리 시스템에도 있습니다.</target>
        </trans-unit>
        <trans-unit id="17853e1fa32c480ecb510d4ac68c8ac2c772dace" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;code&gt;cube&lt;/code&gt; GiST index can be used to find nearest neighbors using the metric operators &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; in &lt;code&gt;ORDER BY&lt;/code&gt; clauses. For example, the nearest neighbor of the 3-D point (0.5, 0.5, 0.5) could be found efficiently with:</source>
          <target state="translated">또한 &lt;code&gt;cube&lt;/code&gt; GiST 인덱스를 사용하여 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서 메트릭 연산자 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 을 사용하여 가장 가까운 이웃을 찾을 수 있습니다 . 예를 들어, 3D 점 (0.5, 0.5, 0.5)의 가장 가까운 이웃은 다음을 통해 효율적으로 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5ace0daf0d94ba630977ad9ab486e9b148c9ae" translate="yes" xml:space="preserve">
          <source>In addition, any range type that is meant to be used with GiST or SP-GiST indexes should define a subtype difference, or &lt;code&gt;subtype_diff&lt;/code&gt;, function. (The index will still work without &lt;code&gt;subtype_diff&lt;/code&gt;, but it is likely to be considerably less efficient than if a difference function is provided.) The subtype difference function takes two input values of the subtype, and returns their difference (i.e., &lt;code&gt;X&lt;/code&gt; minus &lt;code&gt;Y&lt;/code&gt;) represented as a &lt;code&gt;float8&lt;/code&gt; value. In our example above, the function &lt;code&gt;float8mi&lt;/code&gt; that underlies the regular &lt;code&gt;float8&lt;/code&gt; minus operator can be used; but for any other subtype, some type conversion would be necessary. Some creative thought about how to represent differences as numbers might be needed, too. To the greatest extent possible, the &lt;code&gt;subtype_diff&lt;/code&gt; function should agree with the sort ordering implied by the selected operator class and collation; that is, its result should be positive whenever its first argument is greater than its second according to the sort ordering.</source>
          <target state="translated">또한 GiST 또는 SP-GiST 인덱스와 함께 사용되는 모든 범위 유형은 하위 유형 차이 또는 &lt;code&gt;subtype_diff&lt;/code&gt; 함수를 정의해야 합니다. 인덱스는 여전히 &lt;code&gt;subtype_diff&lt;/code&gt; 없이 작동 하지만 차이 함수가 제공되는 경우보다 효율이 떨어질 수 있습니다. 하위 유형 차이 함수는 하위 유형의 두 입력 값을 가져 와서 그 차이 (예 : &lt;code&gt;X&lt;/code&gt; 빼기 &lt;code&gt;Y&lt;/code&gt; )를 리턴합니다. &lt;code&gt;float8&lt;/code&gt; 값 으로 표시됩니다 . 위의 예 에서 일반 &lt;code&gt;float8&lt;/code&gt; 의 기본이되는 &lt;code&gt;float8mi&lt;/code&gt; 함수빼기 연산자를 사용할 수 있습니다. 그러나 다른 하위 유형의 경우 일부 유형 변환이 필요합니다. 숫자가 필요할 때 차이를 표현하는 방법에 대한 창의적인 생각도 있습니다. &lt;code&gt;subtype_diff&lt;/code&gt; 함수는 가능한 한 선택된 연산자 클래스 및 데이터 정렬에 의해 암시 된 정렬 순서와 일치해야합니다. 즉, 정렬 순서에 따라 첫 번째 인수가 두 번째 인수보다 클 때마다 결과가 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="64cf011fc0c858e7c59c2382a3c5f7cd4046f0f4" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Some examples:</source>
          <target state="translated">또한 정수형 값을 &lt;code&gt;bit&lt;/code&gt; 유형으로 캐스트 할 수 있습니다 . 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="326abf040e9ce0b0f36784412502b6466458ab9f" translate="yes" xml:space="preserve">
          <source>In addition, the following functions are available to produce analogous mappings of entire schemas or the entire current database:</source>
          <target state="translated">또한 다음 함수를 사용하여 전체 스키마 또는 전체 현재 데이터베이스의 유사한 매핑을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63461f5526d594ea86f45b63caca8ffcfa146455" translate="yes" xml:space="preserve">
          <source>In addition, the system must not be running in single-user mode. Since the entire database system is running in single process in this situation, no background workers will be available.</source>
          <target state="translated">또한 시스템이 단일 사용자 모드에서 실행되어서는 안됩니다. 이 상황에서 전체 데이터베이스 시스템이 단일 프로세스로 실행되므로 백그라운드 작업자가 사용 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="860432a001dab9d2b568ed0f1f81316664226bda" translate="yes" xml:space="preserve">
          <source>In addition, the system view &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; can be used to view and change session-local values:</source>
          <target state="translated">또한 시스템 뷰 &lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt; 를 사용하여 세션 로컬 값을보고 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f9e194dfe6bf7349c8ee21bf8580964a36a952" translate="yes" xml:space="preserve">
          <source>In addition, triggers may be defined to fire for &lt;code&gt;TRUNCATE&lt;/code&gt;, though only &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 에만 &lt;code&gt;TRUNCATE&lt;/code&gt; 에 대해 트리거하도록 트리거를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4414e8f828cfe6654891bf2913265775446349f" translate="yes" xml:space="preserve">
          <source>In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The &lt;code&gt;ON DELETE&lt;/code&gt; clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the &lt;code&gt;ON UPDATE&lt;/code&gt; clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the &lt;code&gt;NO ACTION&lt;/code&gt; check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:</source>
          <target state="translated">또한 참조 된 열의 데이터가 변경되면이 테이블 열의 데이터에 대해 특정 작업이 수행됩니다. &lt;code&gt;ON DELETE&lt;/code&gt; 절은 참조 테이블의 참조 행이 삭제 될 때 수행 할 작업을 지정합니다. 마찬가지로 &lt;code&gt;ON UPDATE&lt;/code&gt; 절은 참조 된 테이블의 참조 된 열이 새 값으로 업데이트 될 때 수행 할 조치를 지정합니다. 행이 업데이트되었지만 참조 된 열이 실제로 변경되지 않은 경우 아무 작업도 수행되지 않습니다. 제한 조건이 연기 가능하다고 선언 되더라도 &lt;code&gt;NO ACTION&lt;/code&gt; 점검 이외의 참조 조치 는 지연 될 수 없습니다. 각 절에 대해 가능한 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b40467991cf35c44406fccb1f30c153b6ab6d3c" translate="yes" xml:space="preserve">
          <source>In addition, you can define your own range types; see &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more information.</source>
          <target state="translated">또한 고유 한 범위 유형을 정의 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2973b0fbaf7ec1930d4939e2d5982623781db68" translate="yes" xml:space="preserve">
          <source>In addition, you can find rows where the array has all values equal to 10000 with:</source>
          <target state="translated">또한 다음과 함께 배열의 모든 값이 10000 인 행을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f950ca6f038e5a1c55d020b4e0e3f34ce9c10d7" translate="yes" xml:space="preserve">
          <source>In all binary operations on differently-dimensioned cubes, I assume the lower-dimensional one to be a Cartesian projection, i. e., having zeroes in place of coordinates omitted in the string representation. The above examples are equivalent to:</source>
          <target state="translated">다른 차원의 큐브에 대한 모든 이진 연산에서, 저 차원 차원은 데카르트 투영이라고 가정합니다. 즉, 문자열 표현에서 생략 된 좌표 대신 0이 있습니다. 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1f9a66372442ec0201db0ed9f98b148d01d359a" translate="yes" xml:space="preserve">
          <source>In all but the simplest applications, there are various combinations of indexes that might be useful, and the database developer must make trade-offs to decide which indexes to provide. Sometimes multicolumn indexes are best, but sometimes it's better to create separate indexes and rely on the index-combination feature. For example, if your workload includes a mix of queries that sometimes involve only column &lt;code&gt;x&lt;/code&gt;, sometimes only column &lt;code&gt;y&lt;/code&gt;, and sometimes both columns, you might choose to create two separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, relying on index combination to process the queries that use both columns. You could also create a multicolumn index on &lt;code&gt;(x, y)&lt;/code&gt;. This index would typically be more efficient than index combination for queries involving both columns, but as discussed in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;, it would be almost useless for queries involving only &lt;code&gt;y&lt;/code&gt;, so it should not be the only index. A combination of the multicolumn index and a separate index on &lt;code&gt;y&lt;/code&gt; would serve reasonably well. For queries involving only &lt;code&gt;x&lt;/code&gt;, the multicolumn index could be used, though it would be larger and hence slower than an index on &lt;code&gt;x&lt;/code&gt; alone. The last alternative is to create all three indexes, but this is probably only reasonable if the table is searched much more often than it is updated and all three types of query are common. If one of the types of query is much less common than the others, you'd probably settle for creating just the two indexes that best match the common types.</source>
          <target state="translated">가장 단순한 응용 프로그램을 제외하고는 유용 할 수있는 다양한 색인 조합이 있으며 데이터베이스 개발자는 제공 할 색인을 결정하기 위해 절충해야합니다. 여러 열 인덱스가 가장 좋은 경우도 있지만 별도의 인덱스를 만들고 인덱스 조합 기능을 사용하는 것이 좋습니다. 예를 들어, 워크로드에 때때로 &lt;code&gt;x&lt;/code&gt; , 때로는 &lt;code&gt;y&lt;/code&gt; , 때로는 두 열만 포함하는 여러 쿼리가 포함 된 경우 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 에 두 개의 개별 인덱스를 작성하도록 선택 하고 인덱스 조합에 따라 두 열을 모두 사용하십시오. &lt;code&gt;(x, y)&lt;/code&gt; 에 여러 열 인덱스를 만들 수도 있습니다.. 이 인덱스는 일반적으로 두 열을 모두 포함하는 쿼리에 대해 인덱스 조합보다 효율적이지만 &lt;a href=&quot;indexes-multicolumn&quot;&gt;11.3 절&lt;/a&gt; 에서 논의한 것처럼 &lt;code&gt;y&lt;/code&gt; 만 포함하는 쿼리에는 거의 쓸모 가 없으므로 유일한 인덱스가 아니어야합니다. 다중 열 인덱스와 &lt;code&gt;y&lt;/code&gt; 의 개별 인덱스의 조합은 합리적으로 잘 작동합니다. &lt;code&gt;x&lt;/code&gt; 만 포함 된 쿼리의 경우 다중 열 인덱스를 사용할 수 있지만 &lt;code&gt;x&lt;/code&gt; 의 인덱스보다 크거나 느릴 수 있습니다.혼자. 마지막 대안은 세 개의 인덱스를 모두 작성하는 것이지만 테이블을 업데이트하는 것보다 훨씬 자주 검색하고 세 가지 유형의 쿼리가 공통 인 경우에만 적합합니다. 쿼리 유형 중 하나가 다른 유형보다 훨씬 덜 일반적인 경우 공통 유형과 가장 일치하는 두 개의 인덱스 만 작성하면됩니다.</target>
        </trans-unit>
        <trans-unit id="56df2ff3801249dc12f58c24112c401131ecca16" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_depend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">모든 경우에 &lt;code&gt;pg_depend&lt;/code&gt; 항목은 종속 객체를 삭제하지 않고 참조 된 객체를 삭제할 수 없음을 나타냅니다. 그러나, 식별 여러 subflavors있다 &lt;code&gt;deptype&lt;/code&gt; 는 :</target>
        </trans-unit>
        <trans-unit id="05533c0a7856fcfbbc14bb309ca83a1575bf0034" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_shdepend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">모든 경우에 &lt;code&gt;pg_shdepend&lt;/code&gt; 항목은 종속 객체를 삭제하지 않고 참조 된 객체를 삭제할 수 없음을 나타냅니다. 그러나, 식별 여러 subflavors있다 &lt;code&gt;deptype&lt;/code&gt; 는 :</target>
        </trans-unit>
        <trans-unit id="dbd9abe4557bc81e394c2c9fabde17d6899807f9" translate="yes" xml:space="preserve">
          <source>In all cases, the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node will have exactly one child plan, which is the portion of the plan that will be executed in parallel. If the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node is at the very top of the plan tree, then the entire query will execute in parallel. If it is somewhere else in the plan tree, then only the portion of the plan below it will run in parallel. In the example above, the query accesses only one table, so there is only one plan node other than the &lt;code&gt;Gather&lt;/code&gt; node itself; since that plan node is a child of the &lt;code&gt;Gather&lt;/code&gt; node, it will run in parallel.</source>
          <target state="translated">모든 경우에 &lt;code&gt;Gather&lt;/code&gt; 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 노드에는 정확히 하나의 하위 계획이 있으며 이는 계획의 일부로 병렬로 실행됩니다. &lt;code&gt;Gather&lt;/code&gt; 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 노드가 계획 트리의 맨 위에 있으면 전체 쿼리가 병렬로 실행됩니다. 계획 트리의 다른 곳에 있으면 계획의 아래 부분 만 병렬로 실행됩니다. 위의 예에서 쿼리는 하나의 테이블에만 액세스하므로 &lt;code&gt;Gather&lt;/code&gt; 노드 자체 이외의 계획 노드는 하나만 있습니다. 해당 계획 노드는 &lt;code&gt;Gather&lt;/code&gt; 노드 의 하위 노드이므로 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cf1068a339ca5023c2d3ccdb75130df4a1abc8" translate="yes" xml:space="preserve">
          <source>In all cases, the UTC offset associated with a timestamp can be specified explicitly, using either a numeric UTC offset or a time zone abbreviation that corresponds to a fixed UTC offset. The rule just given applies only when it is necessary to infer a UTC offset for a time zone in which the offset varies.</source>
          <target state="translated">모든 경우에, 타임 스탬프와 연관된 UTC 오프셋은 숫자 UTC 오프셋 또는 고정 UTC 오프셋에 해당하는 시간대 약어를 사용하여 명시 적으로 지정할 수 있습니다. 방금 주어진 규칙은 오프셋이 다른 시간대에 대해 UTC 오프셋을 유추해야하는 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="14ea16f2c03b44cd074521f1c44532d0da377b9a" translate="yes" xml:space="preserve">
          <source>In all cases, timezone names and abbreviations are recognized case-insensitively. (This is a change from PostgreSQL versions prior to 8.2, which were case-sensitive in some contexts but not others.)</source>
          <target state="translated">모든 경우에 시간대 이름과 약어는 대소 문자를 구분하지 않고 인식됩니다. (이것은 8.2 이전의 PostgreSQL 버전에서 변경된 것으로 일부 상황에서는 대소 문자를 구분하지만 다른 상황에서는 그렇지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e488767cd28888258245f00283eb8b0744ce50a3" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">에서 &lt;code&gt;ADD FUNCTION&lt;/code&gt; 절 피연산자 데이터 타입 (들)이 기능은 지원하고자하는 함수의 입력 데이터 타입 (들)와 다를 경우. B- 트리 비교 함수 및 해시 함수의 경우 함수의 입력 데이터 형식이 항상 올바른 형식이므로 &lt;code&gt;op_type&lt;/code&gt; 을 지정할 필요가 없습니다 . Gi-ST, SP-GiST 및 GIN 연산자 클래스의 B- 트리 정렬 지원 함수 및 모든 함수의 경우 함수와 함께 사용할 피연산자 데이터 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe60e9f5f727af57aa7582cb64633b2e4aa0e193" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;AFTER&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement. So when an &lt;code&gt;AFTER&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition does not return true, it is not necessary to queue an event nor to re-fetch the row at end of statement. This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows.</source>
          <target state="translated">에서 &lt;code&gt;AFTER&lt;/code&gt; 의 트리거는 &lt;code&gt;WHEN&lt;/code&gt; 조건은 행의 갱신이 발생 직후 평가하고, 이벤트가 문장의 끝에서 트리거를 발생하는 대기할지 여부를 결정합니다. 따라서 &lt;code&gt;AFTER&lt;/code&gt; 트리거의 &lt;code&gt;WHEN&lt;/code&gt; 조건이 true를 리턴하지 않으면, 이벤트를 큐에 넣거나 명령문 끝에서 행을 다시 페치 할 필요가 없습니다. 이로 인해 몇 개의 행에 대해 트리거 만 실행하면 많은 행을 수정하는 명령문에서 속도가 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d94f7fbda5ba6b714c8d7012a6a4025037bb6e" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as it was inserted. This is not so useful in trivial inserts, since it would just repeat the data provided by the client. But it can be very handy when relying on computed default values. For example, when using a &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;&lt;code&gt;serial&lt;/code&gt;&lt;/a&gt; column to provide unique identifiers, &lt;code&gt;RETURNING&lt;/code&gt; can return the ID assigned to a new row:</source>
          <target state="translated">에서 &lt;code&gt;INSERT&lt;/code&gt; , 사용할 수있는 데이터 &lt;code&gt;RETURNING&lt;/code&gt; 가 삽입되었을 때의 행이다. 이것은 클라이언트가 제공 한 데이터를 반복하기 때문에 간단한 삽입에는 그다지 유용하지 않습니다. 그러나 계산 된 기본값에 의존 할 때 매우 유용 할 수 있습니다. 예를 들어, 고유 식별자를 제공하기 위해 &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt; &lt;code&gt;serial&lt;/code&gt; &lt;/a&gt; 열을 사용하는 경우 &lt;code&gt;RETURNING&lt;/code&gt; 은 새 행에 지정된 ID를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b88536e851b3251cb15ede193475eddbb40caec" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. The operand data types can be omitted in the normal case where they are the same as the operator class's data type.</source>
          <target state="translated">에서 &lt;code&gt;OPERATOR&lt;/code&gt; 절, 오퍼레이터, 또는 피연산자 데이터 타입 (들) &lt;code&gt;NONE&lt;/code&gt; 은 A-단항 왼쪽 또는 오른쪽 단항 연산자를 의미한다. 피연산자 데이터 형식은 연산자 클래스의 데이터 형식과 동일한 일반적인 경우에는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3136757e2f5b87e470c589e7ef9c299933261292" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. Unlike the comparable syntax in &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt;, the operand data types must always be specified.</source>
          <target state="translated">에서 &lt;code&gt;OPERATOR&lt;/code&gt; 절, 오퍼레이터, 또는 피연산자 데이터 타입 (들) &lt;code&gt;NONE&lt;/code&gt; 은 A-단항 왼쪽 또는 오른쪽 단항 연산자를 의미한다. &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 의 비교 가능한 구문과 달리 피연산자 데이터 유형은 항상 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f4865a4556be6b18a0efd231e79cc53e7a18167" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the new content of the modified row. For example:</source>
          <target state="translated">에서 &lt;code&gt;UPDATE&lt;/code&gt; , 사용할 수있는 데이터 &lt;code&gt;RETURNING&lt;/code&gt; 수정 된 행의 새로운 콘텐츠이다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9d42b6946ae8752c916da7ef8c706a7f5db4d3a" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;amgetbitmap&lt;/code&gt; index scan, the access method does not keep an index pin on any of the returned tuples. Therefore it is only safe to use such scans with MVCC-compliant snapshots.</source>
          <target state="translated">에서 &lt;code&gt;amgetbitmap&lt;/code&gt; 의 인덱스 스캔, 액세스 방법은 반환 된 튜플의에 인덱스 핀을 유지하지 않습니다. 따라서 MVCC 호환 스냅 샷과 함께 이러한 스캔을 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="565ae755fcf3f7ba63623b03ac7404b46ed4ecef" translate="yes" xml:space="preserve">
          <source>In an abstract sense, a running PostgreSQL system produces an indefinitely long sequence of WAL records. The system physically divides this sequence into WAL &lt;em&gt;segment files&lt;/em&gt;, which are normally 16MB apiece (although the segment size can be altered during initdb). The segment files are given numeric names that reflect their position in the abstract WAL sequence. When not using WAL archiving, the system normally creates just a few segment files and then &amp;ldquo;recycles&amp;rdquo; them by renaming no-longer-needed segment files to higher segment numbers. It's assumed that segment files whose contents precede the last checkpoint are no longer of interest and can be recycled.</source>
          <target state="translated">추상적 의미에서 PostgreSQL 시스템을 실행하면 무한정 긴 WAL 레코드 시퀀스가 ​​생성됩니다. 시스템은이 시퀀스를 물리적 으로 16MB 크기의 WAL &lt;em&gt;세그먼트 파일&lt;/em&gt; 로 물리적으로 나눕니다 (initdb 동안 세그먼트 크기를 변경할 수는 있지만). 세그먼트 파일에는 추상 WAL 시퀀스에서의 위치를 ​​나타내는 숫자 이름이 제공됩니다. WAL 아카이빙을 사용하지 않는 경우, 시스템은 일반적으로 단지 몇 개의 세그먼트 파일을 만든 다음 더 이상 필요하지 않은 세그먼트 파일의 이름을 더 높은 세그먼트 번호로 바꾸어 &quot;재활용&quot;합니다. 내용이 마지막 체크 포인트 이전의 세그먼트 파일은 더 이상 관심이없고 재활용 될 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f8ac0a1e1d2b4929b34c74cce531be5f95182b00" translate="yes" xml:space="preserve">
          <source>In an exclusive backup, &lt;code&gt;pg_stop_backup&lt;/code&gt; removes the label file and, if it exists, the &lt;code&gt;tablespace_map&lt;/code&gt; file created by &lt;code&gt;pg_start_backup&lt;/code&gt;. In a non-exclusive backup, the contents of the &lt;code&gt;backup_label&lt;/code&gt; and &lt;code&gt;tablespace_map&lt;/code&gt; are returned in the result of the function, and should be written to files in the backup (and not in the data directory). There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the &lt;code&gt;pg_stop_backup&lt;/code&gt; will return immediately after the backup is completed without waiting for WAL to be archived. This behavior is only useful for backup software which independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. When this parameter is set to true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled; on the standby, this means that it will wait only when &lt;code&gt;archive_mode = always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.</source>
          <target state="translated">독점 백업에서 &lt;code&gt;pg_stop_backup&lt;/code&gt; 은 레이블 파일과 존재하는 경우 &lt;code&gt;pg_start_backup&lt;/code&gt; 에 의해 작성된 &lt;code&gt;tablespace_map&lt;/code&gt; 파일을 제거합니다 . 비 독점 백업에서 &lt;code&gt;backup_label&lt;/code&gt; 및 &lt;code&gt;tablespace_map&lt;/code&gt; 의 내용은 함수 결과로 리턴되며 백업의 파일 (데이터 디렉토리가 아닌)에 기록되어야합니다. &lt;code&gt;boolean&lt;/code&gt; 유형의 선택적 두 번째 매개 변수가 있습니다. false 인 경우 &lt;code&gt;pg_stop_backup&lt;/code&gt; WAL이 보관 될 때까지 기다리지 않고 백업이 완료되면 즉시 반환됩니다. 이 동작은 WAL 보관을 독립적으로 모니터링하는 백업 소프트웨어에만 유용합니다. 그렇지 않으면 백업 일관성을 유지하는 데 필요한 WAL이 누락되어 백업을 쓸모 없게 만들 수 있습니다. 이 매개 변수가 true로 설정되면 &lt;code&gt;pg_stop_backup&lt;/code&gt; 은 아카이브가 활성화 될 때 WAL이 아카이브 될 때까지 기다립니다. 대기에서 이는 &lt;code&gt;archive_mode = always&lt;/code&gt; 때만 대기 함을 의미합니다 . 기본에서 쓰기 활동이 적은 경우, 즉시 세그먼트 스위치를 트리거하기 위해 기본에서 &lt;code&gt;pg_switch_wal&lt;/code&gt; 을 실행하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7db342c2003b24a0078e3f7501e15f251fcabd3" translate="yes" xml:space="preserve">
          <source>In an index scan, the index access method is responsible for regurgitating the TIDs of all the tuples it has been told about that match the &lt;em&gt;scan keys&lt;/em&gt;. The access method is &lt;em&gt;not&lt;/em&gt; involved in actually fetching those tuples from the index's parent table, nor in determining whether they pass the scan's visibility test or other conditions.</source>
          <target state="translated">인덱스 스캔에서 인덱스 액세스 방법은 &lt;em&gt;스캔 키&lt;/em&gt; 와 일치한다고 알려주는 모든 튜플의 TID를 역류시키는 역할을 &lt;em&gt;합니다&lt;/em&gt; . 액세스 방법은 실제로 인덱스의 상위 테이블에서 해당 튜플을 가져 오거나 스캔의 가시성 테스트 또는 다른 조건을 통과하는지 여부를 결정하는 데 관여 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f28fd11104e5b0da0e35b4fc535d8db587de4795" translate="yes" xml:space="preserve">
          <source>In an unmodified installation, the file &lt;code&gt;Default&lt;/code&gt; contains all the non-conflicting time zone abbreviations for most of the world. Additional files &lt;code&gt;Australia&lt;/code&gt; and &lt;code&gt;India&lt;/code&gt; are provided for those regions: these files first include the &lt;code&gt;Default&lt;/code&gt; file and then add or modify abbreviations as needed.</source>
          <target state="translated">수정되지 않은 설치에서 &lt;code&gt;Default&lt;/code&gt; 파일 에는 대부분의 세계에서 충돌하지 않는 모든 시간대 약어가 포함됩니다. 추가 파일 &lt;code&gt;Australia&lt;/code&gt; 와 &lt;code&gt;India&lt;/code&gt; 는 해당 지역에 제공됩니다.이 파일에는 먼저 &lt;code&gt;Default&lt;/code&gt; 파일이 포함 된 다음 필요에 따라 약어를 추가 또는 수정합니다.</target>
        </trans-unit>
        <trans-unit id="6faf2b1db0e643ecf8d471d0c7a2c045089265e3" translate="yes" xml:space="preserve">
          <source>In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere.</source>
          <target state="translated">어쨌든, 프레임 끝까지의 거리는 파티션 끝까지의 거리에 의해 제한되므로, 파티션 끝 근처의 행에 대해 프레임이 다른 곳보다 적은 수의 행을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a8baad62a92191ed853f5bfffb689d16144b1a" translate="yes" xml:space="preserve">
          <source>In archive recovery or standby mode, the server periodically performs &lt;em&gt;restartpoints&lt;/em&gt;, which are similar to checkpoints in normal operation: the server forces all its state to disk, updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again, and then recycles any old log segment files in the &lt;code&gt;pg_wal&lt;/code&gt; directory. Restartpoints can't be performed more frequently than checkpoints in the master because restartpoints can only be performed at checkpoint records. A restartpoint is triggered when a checkpoint record is reached if at least &lt;code&gt;checkpoint_timeout&lt;/code&gt; seconds have passed since the last restartpoint, or if WAL size is about to exceed &lt;code&gt;max_wal_size&lt;/code&gt;. However, because of limitations on when a restartpoint can be performed, &lt;code&gt;max_wal_size&lt;/code&gt; is often exceeded during recovery, by up to one checkpoint cycle's worth of WAL. (&lt;code&gt;max_wal_size&lt;/code&gt; is never a hard limit anyway, so you should always leave plenty of headroom to avoid running out of disk space.)</source>
          <target state="translated">아카이브 복구 또는 대기 모드에서 서버는 정기적으로 &lt;em&gt;재시작 지점을&lt;/em&gt; 수행 &lt;em&gt;하는데&lt;/em&gt; , 이는 정상 작동 상태의 체크 포인트와 유사합니다. 서버는 모든 상태를 디스크로 강제하고 &lt;code&gt;pg_control&lt;/code&gt; 파일을 업데이트 하여 이미 처리 된 WAL 데이터를 다시 스캔 할 필요가 없음을 나타냅니다. 그런 다음 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리의 오래된 로그 세그먼트 파일을 재활용합니다 . 재시작 지점은 체크 포인트 레코드에서만 수행 할 수 있기 때문에 마스터의 체크 포인트보다 더 자주 다시 시작할 수 없습니다. 마지막 다시 시작 지점 이후 최소 &lt;code&gt;checkpoint_timeout&lt;/code&gt; 초가 지난 경우 또는 WAL 크기가 &lt;code&gt;max_wal_size&lt;/code&gt; 를 초과 하려고하는 경우 검사 점 레코드에 도달하면 다시 시작점이 트리거됩니다.. 그러나 재시작 지점을 수행 할 수있는시기에 대한 제한으로 인해 &lt;code&gt;max_wal_size&lt;/code&gt; 는 복구 중에 최대 1 개의 체크 포인트주기에 해당하는 WAL만큼 초과되는 경우가 많습니다. ( &lt;code&gt;max_wal_size&lt;/code&gt; 는 절대 하드 제한이 아니므로 디스크 공간이 부족하지 않도록 항상 충분한 여유 공간을 두어야합니다.)</target>
        </trans-unit>
        <trans-unit id="e983613b50e43472d70dff9ae2842d52027c35fe" translate="yes" xml:space="preserve">
          <source>In autocommit-off mode, you must explicitly abandon any failed transaction by entering &lt;code&gt;ABORT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;. Also keep in mind that if you exit the session without committing, your work will be lost.</source>
          <target state="translated">자동 커미트 오프 모드에서는 &lt;code&gt;ABORT&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK&lt;/code&gt; 을 입력하여 실패한 트랜잭션을 명시 적으로 포기해야합니다 . 또한 커밋하지 않고 세션을 종료하면 작업 내용이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="b247fa1a8bf50d6b99053c3d0eeaa42c7ba06baa" translate="yes" xml:space="preserve">
          <source>In both cases, the current row of &lt;code&gt;inventory_item&lt;/code&gt; is passed to the function as a single composite-valued argument. Even though &lt;code&gt;.*&lt;/code&gt; does nothing in such cases, using it is good style, since it makes clear that a composite value is intended. In particular, the parser will consider &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;c.*&lt;/code&gt; to refer to a table name or alias, not to a column name, so that there is no ambiguity; whereas without &lt;code&gt;.*&lt;/code&gt;, it is not clear whether &lt;code&gt;c&lt;/code&gt; means a table name or a column name, and in fact the column-name interpretation will be preferred if there is a column named &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;inventory_item&lt;/code&gt; 의 현재 행이 단일 복합 값 인수로 함수에 전달됩니다. 이러한 경우에 &lt;code&gt;.*&lt;/code&gt; 는 아무 것도 수행하지 않지만 복합 값이 의도 된 것임을 명확히하기 때문에 좋은 스타일을 사용하는 것이 좋습니다. 특히, 파서는 &lt;code&gt;c&lt;/code&gt; . 에서 &lt;code&gt;c.*&lt;/code&gt; 를 고려 하여 열 이름이 아닌 테이블 이름 또는 별명을 참조하므로 모호성이 없습니다. 반면없이 &lt;code&gt;.*&lt;/code&gt; , 있는지 명확하지 &lt;code&gt;c&lt;/code&gt; 테이블 이름 또는 열 이름을 의미하고, 실제로 열 이름 해석은 열 이름이 있다면 바람직 할 것이다 &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f76739639f03e7f45a4a9297ea3a846e096a82c7" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5db2bd59ec0063d8b571ff86647485295dec81a2" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 인 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba5e7fcf43f6a46fa23c849e18652c98a11d276" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 인 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6eaaf99e6c52738ae42a85a2ea51714fc0796916" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="94b403e1d0cfae4a4d06e5a4c5a48eb222d916e0" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e7c380013a6560b8ccf88c49ec21236d61ed865e" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려움이있는 경우 잠재적 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a390aa69b768b09463593395199c846120ecabb8" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 문제 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조 하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="93f46ad3e6977f8b4097e1a0c73d806eccff9805" translate="yes" xml:space="preserve">
          <source>In cases where you are accessing single rows randomly within a table, the actual order of the data in the table is unimportant. However, if you tend to access some data more than others, and there is an index that groups them together, you will benefit from using &lt;code&gt;CLUSTER&lt;/code&gt;. If you are requesting a range of indexed values from a table, or a single indexed value that has multiple rows that match, &lt;code&gt;CLUSTER&lt;/code&gt; will help because once the index identifies the table page for the first row that matches, all other rows that match are probably already on the same table page, and so you save disk accesses and speed up the query.</source>
          <target state="translated">테이블 내에서 단일 행에 무작위로 액세스하는 경우 테이블에있는 데이터의 실제 순서는 중요하지 않습니다. 그러나 다른 데이터보다 더 많은 데이터에 액세스하려는 경향이 있고이를 그룹화하는 인덱스가있는 경우 &lt;code&gt;CLUSTER&lt;/code&gt; 를 사용하면 도움이됩니다 . 테이블에서 일치하는 여러 행이있는 단일 인덱스 값 또는 인덱스 된 값의 범위를 요청하는 경우 인덱스가 일치 하는 첫 번째 행의 테이블 페이지를 식별하면 일치하는 다른 모든 행이 아마도 &lt;code&gt;CLUSTER&lt;/code&gt; 에 도움이됩니다. 이미 동일한 테이블 페이지에 있으므로 디스크 액세스를 저장하고 쿼리 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="74c2cf6ed852f4b751c92fd9888cb548968dc00d" translate="yes" xml:space="preserve">
          <source>In certain cases using advisory locking methods, especially in queries involving explicit ordering and &lt;code&gt;LIMIT&lt;/code&gt; clauses, care must be taken to control the locks acquired because of the order in which SQL expressions are evaluated. For example:</source>
          <target state="translated">권고 잠금 메소드를 사용하는 경우, 특히 명시 적 순서 지정 및 &lt;code&gt;LIMIT&lt;/code&gt; 절이 포함 된 쿼리 에서 SQL 표현식이 평가되는 순서로 인해 획득 된 잠금을 제어하도록주의를 기울여야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c672c01926d5e97ed50c99a3d3247bc55643b756" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt; does not allow to specify properties like a table's access method with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt;&lt;code&gt;USING method&lt;/code&gt;&lt;/a&gt; or the table's tablespace with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt;&lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS&lt;/a&gt; if necessary. Therefore, the default table access method is chosen for the new table. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">대조적으로 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; , &lt;code&gt;SELECT INTO&lt;/code&gt; 가 있는 테이블의 액세스 방법과 같은 속성을 지정할 수없는 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt; &lt;code&gt;USING method&lt;/code&gt; &lt;/a&gt; 하거나으로 테이블의 테이블 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt; &lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt; &lt;/a&gt; . 필요한 경우 &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS를&lt;/a&gt; 사용하십시오 . 따라서 새 테이블에 기본 테이블 액세스 방법이 선택됩니다. 자세한 정보는 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61279093682c79c9f5568d5da222628b6973c973" translate="yes" xml:space="preserve">
          <source>In contrast to a &lt;code&gt;setval&lt;/code&gt; call, a &lt;code&gt;RESTART&lt;/code&gt; operation on a sequence is transactional and blocks concurrent transactions from obtaining numbers from the same sequence. If that's not the desired mode of operation, &lt;code&gt;setval&lt;/code&gt; should be used.</source>
          <target state="translated">&lt;code&gt;setval&lt;/code&gt; 호출 과 달리 시퀀스 의 &lt;code&gt;RESTART&lt;/code&gt; 작업은 트랜잭션이며 동시 트랜잭션이 동일한 시퀀스에서 번호를 얻지 못하도록 차단합니다. 원하는 작동 모드가 아닌 경우 &lt;code&gt;setval&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8047479f58f45c6933e1e0d8cbc566b58e46ed0" translate="yes" xml:space="preserve">
          <source>In database jargon, PostgreSQL uses a client/server model. A PostgreSQL session consists of the following cooperating processes (programs):</source>
          <target state="translated">데이터베이스 전문 용어에서 PostgreSQL은 클라이언트 / 서버 모델을 사용합니다. PostgreSQL 세션은 다음과 같은 협력 프로세스 (프로그램)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4ebcdbe0c3b4b06ac68e78641d8a5ee88bcf9f9b" translate="yes" xml:space="preserve">
          <source>In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. (Note that checkpoints, which are managed by a separate, dedicated auxiliary process, are unaffected.) The default value is 100 buffers. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">각 라운드에서이 많은 버퍼는 백그라운드 라이터가 작성합니다. 이것을 0으로 설정하면 백그라운드 쓰기가 비활성화됩니다. (별도의 전용 보조 프로세스에 의해 관리되는 체크 포인트는 영향을받지 않습니다.) 기본값은 100 개의 버퍼입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccd9c3c470f6cf3a148b1b2c45132bef7b97eb77" translate="yes" xml:space="preserve">
          <source>In either case the data to be encrypted is processed as follows:</source>
          <target state="translated">두 경우 모두 암호화 할 데이터는 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="306aa7e6b40f133245f13ca709da9e87be03e6ed" translate="yes" xml:space="preserve">
          <source>In either input mode, if you type a semicolon that is not just before or part of a command entry terminator, it is considered a command separator. When you do type a command entry terminator, the multiple statements you've entered will be executed as a single transaction.</source>
          <target state="translated">입력 모드에서 명령 입력 종결 자 직전 또는 일부가 아닌 세미콜론을 입력하면 명령 구분자로 간주됩니다. 명령 입력 종결자를 입력하면 입력 한 여러 명령문이 단일 트랜잭션으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="52ebde367582fd620a8c225e745609692ba01e89" translate="yes" xml:space="preserve">
          <source>In either notation, parameters that have default values given in the function declaration need not be written in the call at all. But this is particularly useful in named notation, since any combination of parameters can be omitted; while in positional notation parameters can only be omitted from right to left.</source>
          <target state="translated">두 표기법 모두 함수 선언에 기본값이 지정된 매개 변수는 호출에 전혀 쓸 필요가 없습니다. 그러나 이는 매개 변수 조합을 생략 할 수 있으므로 명명 된 표기법에 특히 유용합니다. 위치 표기법에서 매개 변수는 오른쪽에서 왼쪽으로 만 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d831af293a1db32dece4f56906f01bbc94d110b4" translate="yes" xml:space="preserve">
          <source>In fact all the options that can be applied to a column description in &lt;code&gt;CREATE TABLE&lt;/code&gt; can be used here. Keep in mind however that the default value must satisfy the given constraints, or the &lt;code&gt;ADD&lt;/code&gt; will fail. Alternatively, you can add constraints later (see below) after you've filled in the new column correctly.</source>
          <target state="translated">실제로 &lt;code&gt;CREATE TABLE&lt;/code&gt; 의 열 설명에 적용 할 수있는 모든 옵션을 여기에서 사용할 수 있습니다. 그러나 기본값이 주어진 제한 조건을 만족해야합니다 . 그렇지 않으면 &lt;code&gt;ADD&lt;/code&gt; 가 실패합니다. 또는 새 열을 올바르게 입력 한 후 나중에 제약 조건을 추가 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="5989a14e7d9d5d4126144b5b3e9ac84c1a4ebc4b" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. To initialize a database cluster, use the command &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;, which is installed with PostgreSQL. The desired file system location of your database cluster is indicated by the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="translated">파일 시스템 용어로 데이터베이스 클러스터는 모든 데이터가 저장되는 단일 디렉토리입니다. 이것을 &lt;em&gt;데이터 디렉토리&lt;/em&gt; 또는 &lt;em&gt;데이터 영역이라고&lt;/em&gt; 합니다. 데이터를 저장하기로 선택한 곳은 전적으로 귀하에게 달려 있습니다. &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 또는 &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; 와 같은 위치가 많이 사용되지만 기본값은 없습니다 . 데이터베이스 클러스터를 초기화하려면 PostgreSQL과 함께 설치된 &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; 명령을 사용하십시오 . 데이터베이스 클러스터의 원하는 파일 시스템 위치는 &lt;code&gt;-D&lt;/code&gt; 옵션으로 표시됩니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="c6dec459ff41edebdbf286e5c7e7fa61bacc87ff" translate="yes" xml:space="preserve">
          <source>In general it is unsafe to access tables referenced in rebuild scripts until the rebuild scripts have run to completion; doing so could yield incorrect results or poor performance. Tables not referenced in rebuild scripts can be accessed immediately.</source>
          <target state="translated">일반적으로 재 빌드 스크립트가 완료 될 때까지 재 빌드 스크립트에서 참조되는 테이블에 액세스하는 것은 안전하지 않습니다. 그렇게하면 잘못된 결과 나 성능이 저하 될 수 있습니다. 재 구축 스크립트에서 참조되지 않은 테이블에 즉시 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d408ce8d9c6617962a7ddfab014057b11931d1" translate="yes" xml:space="preserve">
          <source>In general the array &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be subscripted is just a column reference or positional parameter. Also, multiple subscripts can be concatenated when the original array is multidimensional. For example:</source>
          <target state="translated">일반적으로 배열 &lt;code&gt;expression&lt;/code&gt; 괄호로 묶어야하지만 첨자식이 열 참조 또는 위치 매개 변수 인 경우 괄호를 생략 할 수 있습니다. 또한 원래 배열이 다차원 일 때 여러 첨자를 연결할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a233c74a23b1b0f950c13008071a2c4108299433" translate="yes" xml:space="preserve">
          <source>In general the row &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be selected from is just a table reference or positional parameter. For example:</source>
          <target state="translated">일반적으로 행 &lt;code&gt;expression&lt;/code&gt; 은 괄호로 묶어야하지만 선택할 표현식이 테이블 참조 또는 위치 매개 변수 인 경우 괄호를 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c0b63d62e29b9c5a3a626356a3b517fe18e88f9" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;amcheck&lt;/code&gt; can only prove the presence of corruption; it cannot prove its absence.</source>
          <target state="translated">일반적으로 &lt;code&gt;amcheck&lt;/code&gt; 는 손상이 있음을 증명할 수 있습니다. 그것의 부재를 증명할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e2bc9fd37cc10d6d4e2c0ce13c42250e4fbbee6" translate="yes" xml:space="preserve">
          <source>In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. However, two null values are never considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior conforms to the SQL standard, but we have heard that other SQL databases might not follow this rule. So be careful when developing applications that are intended to be portable.</source>
          <target state="translated">일반적으로, 테이블에 제한 조건에 포함 된 모든 열의 값이 동일한 행이 둘 이상 있으면 고유 제한 조건이 위반됩니다. 그러나이 비교에서 두 개의 널값은 동일한 것으로 간주되지 않습니다. 즉, 고유 제한 조건이있는 경우에도 제한된 열 중 하나 이상에 널값이 포함 된 중복 행을 저장할 수 있습니다. 이 동작은 SQL 표준을 준수하지만 다른 SQL 데이터베이스가이 규칙을 따르지 않을 수 있다고 들었습니다. 따라서 이식성이 뛰어난 응용 프로그램을 개발할 때는주의하십시오.</target>
        </trans-unit>
        <trans-unit id="2348b93b2ef61033a339bed35843085ef2b630c2" translate="yes" xml:space="preserve">
          <source>In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, it is probably best to label functions as &lt;code&gt;UNSAFE&lt;/code&gt;.</source>
          <target state="translated">일반적으로 함수가 제한되거나 안전하지 않을 때 안전하다고 레이블이 지정되거나 실제로 안전하지 않을 때 제한됨으로 레이블이 지정되면 병렬 쿼리에 사용될 때 오류가 발생하거나 잘못된 응답을 생성 할 수 있습니다. 시스템이 임의의 C 코드로부터 자신을 보호 할 방법이 없기 때문에 C 언어 함수는 이론적으로 잘못 레이블이 지정되면 완전히 정의되지 않은 동작을 나타낼 수 있지만, 대부분의 경우 결과는 다른 함수보다 나쁘지 않습니다. 의심 &lt;code&gt;UNSAFE&lt;/code&gt; 함수를 UNSAFE 로 레이블링하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a7edd5220f4e78ad60a17c1f93de6471bf8d5e1f" translate="yes" xml:space="preserve">
          <source>In general, if a table is grouped, columns that are not listed in &lt;code&gt;GROUP BY&lt;/code&gt; cannot be referenced except in aggregate expressions. An example with aggregate expressions is:</source>
          <target state="translated">일반적으로 테이블이 그룹화 된 경우 집계 표현식을 제외하고 &lt;code&gt;GROUP BY&lt;/code&gt; 에 나열되지 않은 열은 참조 할 수 없습니다. 집계 표현식의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1c3c9f3417fc6beedd0acdb2d294853319e6a73" translate="yes" xml:space="preserve">
          <source>In general, log shipping between servers running different major PostgreSQL release levels is not possible. It is the policy of the PostgreSQL Global Development Group not to make changes to disk formats during minor release upgrades, so it is likely that running different minor release levels on primary and standby servers will work successfully. However, no formal support for that is offered and you are advised to keep primary and standby servers at the same release level as much as possible. When updating to a new minor release, the safest policy is to update the standby servers first &amp;mdash; a new minor release is more likely to be able to read WAL files from a previous minor release than vice versa.</source>
          <target state="translated">일반적으로 다른 주요 PostgreSQL 릴리스 레벨을 실행하는 서버 간의 로그 전달은 불가능합니다. 부 릴리스 업그레이드 중에 디스크 형식을 변경하지 않는 것이 PostgreSQL 글로벌 개발 그룹의 정책이므로 주 서버와 대기 서버에서 다른 부 릴리스 레벨을 실행하면 성공적으로 작동 할 수 있습니다. 그러나 이에 대한 공식적인 지원은 제공되지 않으며 기본 및 대기 서버를 가능한 한 동일한 릴리스 레벨로 유지하는 것이 좋습니다. 새 부 릴리스로 업데이트 할 때 가장 안전한 정책은 대기 서버를 먼저 업데이트하는 것입니다. 새 부 릴리스는 이전 부 릴리스에서 WAL 파일을 읽을 가능성이 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="379f9f035821f16216f7bd05e1c59664a2c062ce" translate="yes" xml:space="preserve">
          <source>In general, most applications should prefer to store JSON data as &lt;code&gt;jsonb&lt;/code&gt;, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys.</source>
          <target state="translated">일반적으로 객체 키 순서에 대한 레거시 가정과 같은 특수한 요구가없는 한 대부분의 애플리케이션은 JSON 데이터를 &lt;code&gt;jsonb&lt;/code&gt; 로 저장하는 것을 선호 합니다.</target>
        </trans-unit>
        <trans-unit id="b5f07f22b350f8a6e38078060fd0e008a551cf3e" translate="yes" xml:space="preserve">
          <source>In general, refer to the documentation of a specific module for the recommended way to load that module.</source>
          <target state="translated">일반적으로 해당 모듈을로드하는 권장 방법은 특정 모듈의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee2e987300579f41179429fff2833d7671d0a6f4" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they are useful for GIN testing and as a base for developing other GIN operator classes. Also, for queries that test both a GIN-indexable column and a B-tree-indexable column, it might be more efficient to create a multicolumn GIN index that uses one of these operator classes than to create two separate indexes that would have to be combined via bitmap ANDing.</source>
          <target state="translated">일반적으로 이러한 연산자 클래스는 동등한 표준 B- 트리 인덱스 방법보다 성능이 우수하지 않으며 표준 B- 트리 코드의 주요 기능 중 하나 인 고유성을 강화하는 기능이 없습니다. 그러나 GIN 테스트에 유용하고 다른 GIN 연산자 클래스를 개발하기위한 기반으로 유용합니다. 또한 GIN 인덱싱 가능 열과 B- 트리 인덱싱 가능 열을 모두 테스트하는 쿼리의 경우 이러한 연산자 클래스 중 하나를 사용하는 여러 열 GIN 인덱스를 만드는 것이 두 개의 별도 인덱스를 만드는 것보다 더 효율적일 수 있습니다. 비트 맵 ANDing을 통해 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="d2aa893456da765ab903af76d8c63108ae26c6ce" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they provide some other features that are not available with a B-tree index, as described below. Also, these operator classes are useful when a multicolumn GiST index is needed, wherein some of the columns are of data types that are only indexable with GiST but other columns are just simple data types. Lastly, these operator classes are useful for GiST testing and as a base for developing other GiST operator classes.</source>
          <target state="translated">일반적으로 이러한 연산자 클래스는 동등한 표준 B- 트리 인덱스 방법보다 성능이 우수하지 않으며 표준 B- 트리 코드의 주요 기능 중 하나 인 고유성을 강화하는 기능이 없습니다. 그러나 아래 설명과 같이 B- 트리 인덱스에서 사용할 수없는 다른 기능도 제공합니다. 또한이 연산자 클래스는 다중 열 GiST 인덱스가 필요할 때 유용합니다. 여기서 일부 열은 GiST로만 인덱싱 할 수있는 데이터 형식이지만 다른 열은 단순한 데이터 형식입니다. 마지막으로,이 연산자 클래스는 GiST 테스트 및 다른 GiST 연산자 클래스 개발의 기반으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="050ef9f5f9df87b4cced8b5539a1b041812d5f42" translate="yes" xml:space="preserve">
          <source>In large tables, performance will be poor unless there is an index on the parent-key field.</source>
          <target state="translated">큰 테이블에서 부모 키 필드에 인덱스가 없으면 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="4765e35412cfd4a863f019aa0033f2c20c5f4705" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. An advantage of these methods is that they bound the space requirement for &lt;code&gt;pg_wal&lt;/code&gt;; there is currently no way to do this using replication slots.</source>
          <target state="translated">복제 슬롯을 사용하는 대신 &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; 를 사용하거나 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command를&lt;/a&gt; 사용하여 아카이브에 세그먼트를 저장 하여 기존 WAL 세그먼트가 제거되는 것을 방지 할 수 있습니다 . 그러나 이러한 방법으로 인해 필요한 것보다 많은 WAL 세그먼트가 유지되는 반면 복제 슬롯에는 필요한 것으로 알려진 수의 세그먼트 만 유지됩니다. 이 메소드의 장점은 &lt;code&gt;pg_wal&lt;/code&gt; 에 필요한 공간을 제한한다는 것입니다 . 현재 복제 슬롯을 사용하여이 작업을 수행 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="84baf4a0766c72c5ea2542a507182c8520343dbe" translate="yes" xml:space="preserve">
          <source>In macOS 10.2 and earlier, instead edit these commands in the file &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt;.</source>
          <target state="translated">macOS 10.2 이하에서는 &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt; 파일에서이 명령을 편집하십시오 .</target>
        </trans-unit>
        <trans-unit id="6203855ca7fcb59eaeec22abadb1b2a4087a8203" translate="yes" xml:space="preserve">
          <source>In many practical situations, this assumption is usually satisfied; for example, there might be a GUI in the application that only allows selecting compatible city and ZIP code values to use in a query. But if that's not the case, functional dependencies may not be a viable option.</source>
          <target state="translated">많은 실제 상황에서이 가정은 일반적으로 충족됩니다. 예를 들어, 응용 프로그램에 쿼리에 사용할 호환 가능한 도시 및 우편 번호 값만 선택할 수있는 GUI가있을 수 있습니다. 그러나 그렇지 않은 경우 기능적 종속성이 실행 가능한 옵션이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b1075485e703bf16e8ab73df82eb829ce78c033" translate="yes" xml:space="preserve">
          <source>In many situations, turning off &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; for noncritical transactions can provide much of the potential performance benefit of turning off &lt;code&gt;fsync&lt;/code&gt;, without the attendant risks of data corruption.</source>
          <target state="translated">많은 상황에서 중요하지 않은 트랜잭션에 대해 &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; 을 끄면 데이터 손상 위험없이 &lt;code&gt;fsync&lt;/code&gt; 를 끄면 잠재적 인 성능 이점을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="194f1c0784b754fb38f29c78dc946b25933f09f6" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;regexp_matches()&lt;/code&gt; should be used with the &lt;code&gt;g&lt;/code&gt; flag, since if you only want the first match, it's easier and more efficient to use &lt;code&gt;regexp_match()&lt;/code&gt;. However, &lt;code&gt;regexp_match()&lt;/code&gt; only exists in PostgreSQL version 10 and up. When working in older versions, a common trick is to place a &lt;code&gt;regexp_matches()&lt;/code&gt; call in a sub-select, for example:</source>
          <target state="translated">대부분의 경우, &lt;code&gt;regexp_matches()&lt;/code&gt; 는 &lt;code&gt;g&lt;/code&gt; 플래그 와 함께 사용해야합니다 . 첫 번째 일치 만 원하면 &lt;code&gt;regexp_match()&lt;/code&gt; 를 사용하는 것이 더 쉽고 효율적이기 때문 입니다. 그러나 &lt;code&gt;regexp_match()&lt;/code&gt; 는 PostgreSQL 버전 10 이상에서만 존재합니다. 이전 버전에서 작업 할 때 일반적인 트릭은 다음 과 같이 하위 선택에 &lt;code&gt;regexp_matches()&lt;/code&gt; 호출 을 배치하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d60a20da168de2a263b74b28aa44a9c52da8b217" translate="yes" xml:space="preserve">
          <source>In most cases a &lt;code&gt;DELETE&lt;/code&gt; command also needs to read data from columns in the relation that it is deleting from (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;DELETE&lt;/code&gt; policies. Thus the user must have access to the row(s) being deleted through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to delete the row(s) via a &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;DELETE&lt;/code&gt; 명령은 삭제할 관계의 열 (예 : &lt;code&gt;WHERE&lt;/code&gt; 절 또는 &lt;code&gt;RETURNING&lt;/code&gt; 절) 에서 데이터를 읽어야합니다 . 이 경우 관계에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한도 필요 하며 &lt;code&gt;DELETE&lt;/code&gt; 정책 외에 적절한 &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;ALL&lt;/code&gt; 정책이 적용됩니다 . 따라서 사용자는 &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;ALL&lt;/code&gt; 정책을 통해 행을 삭제할 수있는 권한이 부여 될뿐만 아니라 &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;ALL&lt;/code&gt; 정책을 통해 삭제되는 행에 액세스 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="82c5561a0275adcd2a2a51ebef8a40a5f37109da" translate="yes" xml:space="preserve">
          <source>In most database designs the majority of columns should be marked not null.</source>
          <target state="translated">대부분의 데이터베이스 디자인에서 대부분의 열은 null이 아닌 것으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="158c99420a44bba9aff343cb614d9616cbae7fa4" translate="yes" xml:space="preserve">
          <source>In most implementations of the &amp;ldquo;not-a-number&amp;rdquo; concept, &lt;code&gt;NaN&lt;/code&gt; is not considered equal to any other numeric value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow &lt;code&gt;numeric&lt;/code&gt; values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">&quot;숫자 가 아님 &quot;개념의 대부분의 구현에서 &lt;code&gt;NaN&lt;/code&gt; 은 다른 숫자 값 ( &lt;code&gt;NaN&lt;/code&gt; 포함 ) 과 동일하게 간주되지 않습니다 . 트리 기반 인덱스에서 &lt;code&gt;numeric&lt;/code&gt; 값을 정렬하고 사용할 수 있도록 PostgreSQL은 &lt;code&gt;NaN&lt;/code&gt; 값을 동일하고 &lt;code&gt;NaN&lt;/code&gt; 이 아닌 모든 값 보다 큰 것으로 간주 합니다.</target>
        </trans-unit>
        <trans-unit id="cd61e39655eeef5b9bf240531ec53c538d27ed8e" translate="yes" xml:space="preserve">
          <source>In named notation, each argument's name is specified using &lt;code&gt;=&amp;gt;&lt;/code&gt; to separate it from the argument expression. For example:</source>
          <target state="translated">명명 된 표기법에서 각 인수의 이름은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 를 사용 하여 인수 표현식과 구분 하여 지정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a49a039bda09447cda5b6ba6fb7b5f06a1662cb" translate="yes" xml:space="preserve">
          <source>In nearly all cases, you'll need some options to make a useful test. The most important options are &lt;code&gt;-c&lt;/code&gt; (number of clients), &lt;code&gt;-t&lt;/code&gt; (number of transactions), &lt;code&gt;-T&lt;/code&gt; (time limit), and &lt;code&gt;-f&lt;/code&gt; (specify a custom script file). See below for a full list.</source>
          <target state="translated">거의 모든 경우에 유용한 테스트를 수행하려면 몇 가지 옵션이 필요합니다. 가장 중요한 옵션은 &lt;code&gt;-c&lt;/code&gt; (클라이언트 수), &lt;code&gt;-t&lt;/code&gt; (트랜잭션 수), &lt;code&gt;-T&lt;/code&gt; (시간 제한) 및 &lt;code&gt;-f&lt;/code&gt; (사용자 지정 스크립트 파일 지정)입니다. 전체 목록은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fac5d16972792c7bd805065c712c623a51151c8c" translate="yes" xml:space="preserve">
          <source>In none of these cases is there any provision for schema-qualification; all objects created during bootstrap are expected to be in the &lt;code&gt;pg_catalog&lt;/code&gt; schema.</source>
          <target state="translated">이 중 어느 경우에도 스키마 검증에 대한 규정은 없습니다. 부트 스트랩 중에 생성 된 모든 객체는 &lt;code&gt;pg_catalog&lt;/code&gt; 스키마에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="909fab97f09523721a77cc835152b274f406d63c" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user - they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">일반 (복구하지 않음) 모드에서 해당 사용자가 여전히 연결되어있는 동안 로그인 기능이있는 역할에 대해 &lt;code&gt;DROP USER&lt;/code&gt; 또는 &lt;code&gt;DROP ROLE&lt;/code&gt; 을 발행 하면 연결된 사용자에게 아무런 변화가 없습니다. 그러나 사용자는 다시 연결할 수 없습니다. 이 동작은 복구에도 적용되므로 기본 의 &lt;code&gt;DROP USER&lt;/code&gt; 가 대기에서 해당 사용자의 연결을 끊지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1729ae1f718e0b63bffb08ae3066f0eb0e77ca2" translate="yes" xml:space="preserve">
          <source>In normal operation, &amp;ldquo;read-only&amp;rdquo; transactions are allowed to use &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt;, so Hot Standby sessions operate under slightly tighter restrictions than ordinary read-only sessions. It is possible that some of these restrictions might be loosened in a future release.</source>
          <target state="translated">정상 작동에서 &quot;읽기 전용&quot;트랜잭션은 &lt;code&gt;LISTEN&lt;/code&gt; 및 &lt;code&gt;NOTIFY&lt;/code&gt; 를 사용할 수 있으므로 핫 스탠바이 세션은 일반 읽기 전용 세션보다 약간 엄격한 제한 하에서 작동합니다. 다음 릴리스에서는 이러한 제한 중 일부가 완화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3560745e5e4a4c446630441931abacb2898af6f" translate="yes" xml:space="preserve">
          <source>In normal operation, psql provides a prompt with the name of the database to which psql is currently connected, followed by the string &lt;code&gt;=&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">정상적인 작동에서 psql은 psql이 현재 연결된 데이터베이스 이름과 프롬프트 &lt;code&gt;=&amp;gt;&lt;/code&gt; 를 프롬프트합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd286c2214fff2e0be18b3ddfb09dfdd0278ddbf" translate="yes" xml:space="preserve">
          <source>In older OpenBSD versions, you will need to build a custom kernel to change the IPC parameters. Make sure that the options &lt;code&gt;SYSVSHM&lt;/code&gt; and &lt;code&gt;SYSVSEM&lt;/code&gt; are enabled, too. (They are by default.) The following shows an example of how to set the various parameters in the kernel configuration file:</source>
          <target state="translated">이전 OpenBSD 버전에서는 IPC 매개 변수를 변경하기 위해 사용자 정의 커널을 빌드해야합니다. &lt;code&gt;SYSVSHM&lt;/code&gt; 및 &lt;code&gt;SYSVSEM&lt;/code&gt; 옵션 도 활성화 해야합니다 . (기본적으로 설정되어 있습니다.) 다음은 커널 구성 파일에서 다양한 매개 변수를 설정하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="43d5f374be9ab2b9f725372748b33884cde122b3" translate="yes" xml:space="preserve">
          <source>In older macOS versions, you will need to reboot to have changes in the shared memory parameters take effect. As of 10.5 it is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="translated">이전 macOS 버전에서는 공유 메모리 매개 변수의 변경 사항을 적용하려면 재부팅해야합니다. 10.5부터 sysctl을 사용하여 &lt;code&gt;SHMMNI&lt;/code&gt; 를 제외한 모든 것을 즉시 변경할 수 있습니다 . 그러나 재부팅 할 때마다 값이 유지되도록 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 를 통해 원하는 값을 설정하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="882a1a9442374dfd65845651f73b92d43f44074e" translate="yes" xml:space="preserve">
          <source>In order for the tunnel setup to succeed you must be allowed to connect via &lt;code&gt;ssh&lt;/code&gt; as &lt;code&gt;joe@foo.com&lt;/code&gt;, just as if you had attempted to use &lt;code&gt;ssh&lt;/code&gt; to create a terminal session.</source>
          <target state="translated">터널 설정이 성공 하려면 &lt;code&gt;ssh&lt;/code&gt; 를 사용하여 터미널 세션을 생성 한 것처럼 &lt;code&gt;ssh&lt;/code&gt; 를 통해 &lt;code&gt;joe@foo.com&lt;/code&gt; 으로 연결할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d646fc6f64023e87f7f5096950ae7ce2f2e80423" translate="yes" xml:space="preserve">
          <source>In order to access any schema object, &lt;code&gt;db_schema:search&lt;/code&gt; permission is required on the containing schema. When an object is referenced without schema qualification, schemas on which this permission is not present will not be searched (just as if the user did not have &lt;code&gt;USAGE&lt;/code&gt; privilege on the schema). If an explicit schema qualification is present, an error will occur if the user does not have the requisite permission on the named schema.</source>
          <target state="translated">스키마 객체에 액세스 하려면 포함하는 스키마에 &lt;code&gt;db_schema:search&lt;/code&gt; 권한이 필요합니다. 스키마 자격없이 개체를 참조하면이 권한이없는 스키마는 사용자 에게 스키마에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한 이없는 것처럼 검색되지 않습니다 . 명시 적 스키마 규정이 있으면 사용자에게 명명 된 스키마에 대한 필수 권한이없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="233299fd5dfd7550c24147ba5661abe08d2d0d86" translate="yes" xml:space="preserve">
          <source>In order to allow the PostgreSQL query planner to make reasonably informed decisions when optimizing queries, the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; data should be up-to-date for all tables used in the query. Normally the &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum daemon&lt;/a&gt; will take care of that automatically. But if a table has recently had substantial changes in its contents, you might need to do a manual &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; rather than wait for autovacuum to catch up with the changes.</source>
          <target state="translated">PostgreSQL 쿼리 플래너가 쿼리를 최적화 할 때 합리적인 정보에 근거한 결정을 내리 려면 쿼리에 사용 된 모든 테이블에 대해 &lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt; 데이터가 최신 상태 여야합니다. 일반적으로 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum 데몬&lt;/a&gt; 이 자동으로 처리합니다. 그러나 최근 테이블의 내용이 크게 변경된 경우 autovacuum이 변경 사항을 따라 잡을 때까지 기다리지 않고 수동 &lt;a href=&quot;sql-analyze&quot;&gt;분석&lt;/a&gt; 을 수행해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bbf891d4248cf5667df821377cc8cc7768e14e9" translate="yes" xml:space="preserve">
          <source>In order to be able to copy the initial table data, the role used for the replication connection must have the &lt;code&gt;SELECT&lt;/code&gt; privilege on a published table (or be a superuser).</source>
          <target state="translated">초기 테이블 데이터를 복사하려면 복제 연결에 사용 된 역할 에 게시 된 테이블에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 있어야 합니다 (또는 수퍼 유저).</target>
        </trans-unit>
        <trans-unit id="fcaf64f5cce00b8df1baf8d751f9011467d9dba7" translate="yes" xml:space="preserve">
          <source>In order to bootstrap the database system, a freshly initialized system always contains one predefined role. This role is always a &amp;ldquo;superuser&amp;rdquo;, and by default (unless altered when running &lt;code&gt;initdb&lt;/code&gt;) it will have the same name as the operating system user that initialized the database cluster. Customarily, this role will be named &lt;code&gt;postgres&lt;/code&gt;. In order to create more roles you first have to connect as this initial role.</source>
          <target state="translated">데이터베이스 시스템을 부트 스트랩하기 위해 새로 초기화 된 시스템에는 항상 하나의 사전 정의 된 역할이 포함됩니다. 이 역할은 항상&amp;ldquo;수퍼 유저&amp;rdquo;이며 기본적으로 ( &lt;code&gt;initdb&lt;/code&gt; 를 실행할 때 변경되지 않는 한 ) 데이터베이스 클러스터를 초기화 한 운영 체제 사용자와 이름이 같습니다. 일반적으로이 역할의 이름은 &lt;code&gt;postgres&lt;/code&gt; 입니다. 더 많은 역할을 만들려면 먼저이 초기 역할로 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0b6ace4aa733c9f867afeaddbd70b1a3a0b54f3" translate="yes" xml:space="preserve">
          <source>In order to calculate the union, intersection, or difference of two queries, the two queries must be &amp;ldquo;union compatible&amp;rdquo;, which means that they return the same number of columns and the corresponding columns have compatible data types, as described in &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;.</source>
          <target state="translated">두 쿼리의 합집합, 교집합 또는 차이를 계산하려면 두 쿼리가 &quot;유니언 호환 가능&quot;해야합니다. 즉, &lt;a href=&quot;typeconv-union-case&quot;&gt;10.5 절&lt;/a&gt; 에서 설명한대로 동일한 수의 열을 반환하고 해당 열은 호환 가능한 데이터 형식을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="4415b6dbba894170e74bcc6996dbfa1fb24cd8d1" translate="yes" xml:space="preserve">
          <source>In order to create a database, the PostgreSQL server must be up and running (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;).</source>
          <target state="translated">데이터베이스를 생성하려면 PostgreSQL 서버가 가동되어 실행 중이어야합니다 ( &lt;a href=&quot;server-start&quot;&gt;섹션 18.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3f22ae189397eeb8d6d5706a9610e0f700d2bec8" translate="yes" xml:space="preserve">
          <source>In order to emulate a case-insensitive collation as closely as possible, there are &lt;code&gt;citext&lt;/code&gt;-specific versions of a number of string-processing operators and functions. So, for example, the regular expression operators &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; exhibit the same behavior when applied to &lt;code&gt;citext&lt;/code&gt;: they both match case-insensitively. The same is true for &lt;code&gt;!~&lt;/code&gt; and &lt;code&gt;!~*&lt;/code&gt;, as well as for the &lt;code&gt;LIKE&lt;/code&gt; operators &lt;code&gt;~~&lt;/code&gt; and &lt;code&gt;~~*&lt;/code&gt;, and &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt;. If you'd like to match case-sensitively, you can cast the operator's arguments to &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">대소 문자를 구분하지 않는 데이터 정렬을 가능한 한 가깝게 에뮬레이트하기 위해 여러 문자열 처리 연산자 및 함수의 &lt;code&gt;citext&lt;/code&gt; 특정 버전이 있습니다. 예를 들어, 정규 표현식 연산자 인 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~*&lt;/code&gt; 는 &lt;code&gt;citext&lt;/code&gt; 에 적용 할 때 동일한 동작을 나타 냅니다 . 둘 다 대소 문자를 구분하지 않습니다. 동일은 마찬가지입니다 &lt;code&gt;!~&lt;/code&gt; 와 &lt;code&gt;!~*&lt;/code&gt; 뿐만 아니라에 대한 &lt;code&gt;LIKE&lt;/code&gt; 의 사업자 &lt;code&gt;~~&lt;/code&gt; 와 &lt;code&gt;~~*&lt;/code&gt; ,와 &lt;code&gt;!~~&lt;/code&gt; 와 &lt;code&gt;!~~*&lt;/code&gt; . 대소 문자를 구분하여 일치 시키려면 연산자의 인수를 &lt;code&gt;text&lt;/code&gt; 로 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13c4603c579f552910275f0bbcb4deae55ef3a7a" translate="yes" xml:space="preserve">
          <source>In order to function, this module must be loaded via &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">작동하려면 &lt;code&gt;postgresql.conf&lt;/code&gt; 의&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; 를 통해이 모듈을로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d81c2662b5a84aa8d5b82fab0b4d606e39ebda86" translate="yes" xml:space="preserve">
          <source>In order to measure the run-time cost of each node in the execution plan, the current implementation of &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; adds profiling overhead to query execution. As a result, running &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on a query can sometimes take significantly longer than executing the query normally. The amount of overhead depends on the nature of the query, as well as the platform being used. The worst case occurs for plan nodes that in themselves require very little time per execution, and on machines that have relatively slow operating system calls for obtaining the time of day.</source>
          <target state="translated">실행 계획에서 각 노드의 런타임 비용을 측정하기 위해 현재 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 구현은 쿼리 실행에 프로파일 링 오버 헤드를 추가합니다. 결과적으로 쿼리 에서 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 를 실행하면 쿼리를 정상적으로 실행하는 것보다 시간이 훨씬 오래 걸릴 수 있습니다. 오버 헤드의 양은 사용중인 플랫폼뿐만 아니라 쿼리의 특성에 따라 다릅니다. 최악의 경우는 실행 당 시간이 거의 필요하지 않은 계획 노드와 시간을 얻기 위해 운영 체제 호출이 상대적으로 느린 시스템에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ef25cb15d96bc5ee47cb922c3476dbfcb096c17" translate="yes" xml:space="preserve">
          <source>In order to prevent this, the following applies to all built-in selectivity estimation functions. When planning a query, in order to be able to use stored statistics, the current user must either have &lt;code&gt;SELECT&lt;/code&gt; privilege on the table or the involved columns, or the operator used must be &lt;code&gt;LEAKPROOF&lt;/code&gt; (more accurately, the function that the operator is based on). If not, then the selectivity estimator will behave as if no statistics are available, and the planner will proceed with default or fall-back assumptions.</source>
          <target state="translated">이를 방지하기 위해 다음은 모든 내장 선택성 추정 기능에 적용됩니다. 쿼리를 계획 할 때 저장된 통계를 사용하려면 현재 사용자 에게 테이블 또는 관련 열에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한이 있거나 사용 된 연산자가 &lt;code&gt;LEAKPROOF&lt;/code&gt; (보다 정확하게는 연산자의 기반이되는 기능) 여야합니다 . ). 그렇지 않은 경우 선택성 추정기는 사용 가능한 통계가없는 것처럼 작동하며 플래너는 기본 또는 폴백 가정을 진행합니다.</target>
        </trans-unit>
        <trans-unit id="6b9560d0a190cd0915dff71499a691135e350ab1" translate="yes" xml:space="preserve">
          <source>In ordinary usage, these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt;, although superusers can alter them on-the-fly within their own sessions. Typical usage might be:</source>
          <target state="translated">일반적인 사용에서 이러한 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정되어 있지만 수퍼 유저는 자체 세션 내에서 즉시 변경할 수 있습니다. 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70a9b455eedcd0013740b57c24d0da08e7b71441" translate="yes" xml:space="preserve">
          <source>In parameters that specify support function names, you can write a schema name if needed, for example &lt;code&gt;SFUNC = public.sum&lt;/code&gt;. Do not write argument types there, however &amp;mdash; the argument types of the support functions are determined from other parameters.</source>
          <target state="translated">지원 함수 이름을 지정하는 매개 변수에서 필요한 경우 스키마 이름을 작성할 수 있습니다 (예 : &lt;code&gt;SFUNC = public.sum&lt;/code&gt; . 그러나 여기에 인수 유형을 쓰지 마십시오. 지원 함수의 인수 유형은 다른 매개 변수에서 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e6503b355c17e530acb3ce1cf1b630a12d5c662a" translate="yes" xml:space="preserve">
          <source>In particular, if there's an index on &lt;code&gt;key&lt;/code&gt;, it will probably be used to fetch just the rows having &lt;code&gt;key = 123&lt;/code&gt;. On the other hand, in</source>
          <target state="translated">특히 &lt;code&gt;key&lt;/code&gt; 에 인덱스가 있으면 &lt;code&gt;key = 123&lt;/code&gt; 행만 가져 오는 데 사용됩니다 . 반면에</target>
        </trans-unit>
        <trans-unit id="e4a5dbfbe9955b3dd014a081adfefb7a2337bd07" translate="yes" xml:space="preserve">
          <source>In particular, when a superuser chooses to &lt;code&gt;SET ROLE&lt;/code&gt; to a non-superuser role, they lose their superuser privileges.</source>
          <target state="translated">특히, 수퍼 유저가 비 수퍼 유저 역할 로 &lt;code&gt;SET ROLE&lt;/code&gt; 을 설정 하면 수퍼 유저 권한이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="cc733581aa12ac8119d8135b89e36cf1d9d3b31b" translate="yes" xml:space="preserve">
          <source>In practice one usually relies on the search path for operators, so as not to have to write anything so ugly as that.</source>
          <target state="translated">실제로는 일반적으로 연산자의 검색 경로에 의존하므로 추악한 것을 작성하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="a48f8184fbeadfd296ca8b91bd2766492182e822" translate="yes" xml:space="preserve">
          <source>In practice the &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; query should always specify &lt;code&gt;ORDER BY 1&lt;/code&gt; to ensure that values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together. However, ordering of the categories within a group is not important. Also, it is essential to be sure that the order of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query's output matches the specified output column order.</source>
          <target state="translated">실제로 &lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt; 쿼리는 항상 &lt;code&gt;row_name&lt;/code&gt; 이 동일한 값을 가져 오도록 &lt;code&gt;ORDER BY 1&lt;/code&gt; 을 지정해야 합니다. 그러나 그룹 내의 범주 순서는 중요하지 않습니다. 또한 &lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt; 쿼리의 출력 순서가 지정된 출력 열 순서와 일치 하는지 확인해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1937c987be0e7b4e7465a2a7029e3f9255be3a60" translate="yes" xml:space="preserve">
          <source>In practice the SQL query should always specify &lt;code&gt;ORDER BY 1,2&lt;/code&gt; to ensure that the input rows are properly ordered, that is, values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together and correctly ordered within the row. Notice that &lt;code&gt;crosstab&lt;/code&gt; itself does not pay any attention to the second column of the query result; it's just there to be ordered by, to control the order in which the third-column values appear across the page.</source>
          <target state="translated">실제로 SQL 쿼리는 항상 &lt;code&gt;ORDER BY 1,2&lt;/code&gt; 를 지정 하여 입력 행이 올바르게 정렬되도록합니다. 즉, 동일한 &lt;code&gt;row_name&lt;/code&gt; 을 갖는 값 이 행 내에서 함께 올바르게 정렬됩니다. 공지 사항 &lt;code&gt;crosstab&lt;/code&gt; 쿼리 결과의 두 번째 열에 어떤 관심을 지불하지 않는 자체; 페이지에서 세 번째 열 값이 표시되는 순서를 제어하기 위해 순서대로 정렬하면됩니다.</target>
        </trans-unit>
        <trans-unit id="81fbb389dcb4a22896ff56ba2f6a26d52f9a0053" translate="yes" xml:space="preserve">
          <source>In practice, it might be best to check the newest child first, if most inserts go into that child. For simplicity, we have shown the trigger's tests in the same order as in other parts of this example.</source>
          <target state="translated">실제로 대부분의 인서트가 해당 어린이에 들어가면 최신 어린이를 먼저 확인하는 것이 가장 좋습니다. 간단하게하기 위해이 예제의 다른 부분과 동일한 순서로 트리거 테스트를 보여주었습니다.</target>
        </trans-unit>
        <trans-unit id="06e0b2a62cd9f4eb01f119bc558152c7a9b61c4c" translate="yes" xml:space="preserve">
          <source>In practice, these commands would be wrapped up in an extension.</source>
          <target state="translated">실제로 이러한 명령은 확장으로 싸여 있습니다.</target>
        </trans-unit>
        <trans-unit id="79f48feff09a5e6beb49de65d5ed928eb6a28410" translate="yes" xml:space="preserve">
          <source>In principle, cross-references from one initial catalog row to another could be written just by writing the preassigned OID of the referenced row in the referencing field. However, that is against project policy, because it is error-prone, hard to read, and subject to breakage if a newly-assigned OID is renumbered. Therefore &lt;code&gt;genbki.pl&lt;/code&gt; provides mechanisms to write symbolic references instead. The rules are as follows:</source>
          <target state="translated">원칙적으로, 참조 필드에 참조 된 행의 사전 할당 된 OID를 작성하여 하나의 초기 카탈로그 행에서 다른 초기 카탈로그 행으로의 상호 참조를 작성할 수 있습니다. 그러나 새로 할당 된 OID의 번호가 다시 매겨지면 오류가 발생하기 쉽고 읽기 어려우며 손상 될 수 있으므로 프로젝트 정책에 위배됩니다. 따라서 &lt;code&gt;genbki.pl&lt;/code&gt; 은 대신 기호 참조를 작성하는 메커니즘을 제공합니다. 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="760cef4da4decce6f6d9b7cb2f206b14f10f3fa4" translate="yes" xml:space="preserve">
          <source>In principle, index-only scans can be used with expression indexes. For example, given an index on &lt;code&gt;f(x)&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a table column, it should be possible to execute</source>
          <target state="translated">원칙적으로 인덱스 전용 스캔은 표현식 인덱스와 함께 사용할 수 있습니다. 예를 들어, 소정의 인덱스 &lt;code&gt;f(x)&lt;/code&gt; 여기서, &lt;code&gt;x&lt;/code&gt; 인 테이블 열, 그것을 실행하는 것이 가능해야</target>
        </trans-unit>
        <trans-unit id="50939af3586cb58faf973e37d044bc572b91198e" translate="yes" xml:space="preserve">
          <source>In principle, one can use &lt;code&gt;to_tsquery&lt;/code&gt; if you quote the argument:</source>
          <target state="translated">원칙적으로 인수를 인용하면 &lt;code&gt;to_tsquery&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25c4a2a950655d8b26ffa359e0be687cbb7c81cd" translate="yes" xml:space="preserve">
          <source>In principle, we could do an index-only scan on this index to satisfy a query like</source>
          <target state="translated">원칙적으로이 인덱스에 대해 인덱스 전용 스캔을 수행하여</target>
        </trans-unit>
        <trans-unit id="5a138e4bb79a7d66b0d4bfaffdffcdcbb5964acf" translate="yes" xml:space="preserve">
          <source>In prior releases of PostgreSQL, this was the default except for the &lt;code&gt;stop&lt;/code&gt; mode.</source>
          <target state="translated">PostgreSQL의 이전 릴리스에서는 &lt;code&gt;stop&lt;/code&gt; 모드를 제외하고 이것이 기본값이었습니다 .</target>
        </trans-unit>
        <trans-unit id="75324ba26fc4965d2196117750a2a1059aac25a6" translate="yes" xml:space="preserve">
          <source>In prompt 1 normally &lt;code&gt;=&lt;/code&gt;, but &lt;code&gt;@&lt;/code&gt; if the session is in an inactive branch of a conditional block, or &lt;code&gt;^&lt;/code&gt; if in single-line mode, or &lt;code&gt;!&lt;/code&gt; if the session is disconnected from the database (which can happen if &lt;code&gt;\connect&lt;/code&gt; fails). In prompt 2 &lt;code&gt;%R&lt;/code&gt; is replaced by a character that depends on why psql expects more input: &lt;code&gt;-&lt;/code&gt; if the command simply wasn't terminated yet, but &lt;code&gt;*&lt;/code&gt; if there is an unfinished &lt;code&gt;/* ... */&lt;/code&gt; comment, a single quote if there is an unfinished quoted string, a double quote if there is an unfinished quoted identifier, a dollar sign if there is an unfinished dollar-quoted string, or &lt;code&gt;(&lt;/code&gt; if there is an unmatched left parenthesis. In prompt 3 &lt;code&gt;%R&lt;/code&gt; doesn't produce anything.</source>
          <target state="translated">프롬프트 1에서 보통 &lt;code&gt;=&lt;/code&gt; 이지만 세션이 조건부 블록의 비활성 분기에 있으면 &lt;code&gt;@&lt;/code&gt; , 또는 단일 행 모드에 있으면 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; 세션이 데이터베이스에서 연결이 끊어진 경우 ( &lt;code&gt;\connect&lt;/code&gt; 가 실패하면 발생할 수 있음 ) 프롬프트 2에서 &lt;code&gt;%R&lt;/code&gt; 은 psql이 더 많은 입력을 요구하는 이유에 따라 다른 문자로 대체됩니다 &lt;code&gt;-&lt;/code&gt; 명령이 아직 종료되지 않았지만 &lt;code&gt;*&lt;/code&gt; 완료되지 않은 &lt;code&gt;/* ... */&lt;/code&gt; 주석이 있으면 작은 따옴표 미완성 된 따옴표로 묶인 문자열, 미완성 된 따옴표로 묶인 식별자가있는 경우 큰 따옴표, 미완성 된 달러로 인용 된 문자열이있는 경우 달러 기호 또는 &lt;code&gt;(&lt;/code&gt; 일치하지 않는 왼쪽 괄호가있는 경우 프롬프트 3 &lt;code&gt;%R&lt;/code&gt; 은 아무것도 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2a64129f0b1da1e51ed964ad4579c4ce899b50b" translate="yes" xml:space="preserve">
          <source>In releases prior to 9.6, this parameter also allowed the values &lt;code&gt;archive&lt;/code&gt; and &lt;code&gt;hot_standby&lt;/code&gt;. These are still accepted but mapped to &lt;code&gt;replica&lt;/code&gt;.</source>
          <target state="translated">9.6 이전 릴리스에서이 매개 변수는 값 &lt;code&gt;archive&lt;/code&gt; 및 &lt;code&gt;hot_standby&lt;/code&gt; 도 허용했습니다 . 이들은 여전히 ​​허용되지만 &lt;code&gt;replica&lt;/code&gt; 에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa88d3807e10330acdc1940359127a25a966338d" translate="yes" xml:space="preserve">
          <source>In short then, the most general recipe for removing a role that has been used to own objects is:</source>
          <target state="translated">간단히 말해 객체를 소유하는 데 사용 된 역할을 제거하는 가장 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d436b991362b7fed721dd789926c009b129d872d" translate="yes" xml:space="preserve">
          <source>In short, this is the difference between abbreviations and full names: abbreviations represent a specific offset from UTC, whereas many of the full names imply a local daylight-savings time rule, and so have two possible UTC offsets. As an example, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; represents noon local time in New York, which for this particular date was Eastern Daylight Time (UTC-4). So &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; specifies that same time instant. But &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; specifies noon Eastern Standard Time (UTC-5), regardless of whether daylight savings was nominally in effect on that date.</source>
          <target state="translated">간단히 말해 이것은 약어와 전체 이름의 차이입니다. 약어는 UTC와의 특정 오프셋을 나타내는 반면, 많은 전체 이름은 현지 일광 절약 시간제 규칙을 나타내므로 두 가지 가능한 UTC 오프셋이 있습니다. 예를 들어, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; 는 뉴욕의 정오 현지 시간을 나타내며이 날짜는 동부 일광 절약 시간 (UTC-4)입니다. 따라서 &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; 는 같은 시간 순간을 지정합니다. 그러나 &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; 는 일광 절약 시간이 명목상 해당 날짜에 적용되는지 여부에 관계없이 정오 동부 표준시 (UTC-5)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6f11576d9f6f09df7ddccd8a08208061f234c7e9" translate="yes" xml:space="preserve">
          <source>In short, when an RE contains both greedy and non-greedy subexpressions, the total match length is either as long as possible or as short as possible, according to the attribute assigned to the whole RE. The attributes assigned to the subexpressions only affect how much of that match they are allowed to &amp;ldquo;eat&amp;rdquo; relative to each other.</source>
          <target state="translated">요컨대, RE가 욕심과 비 욕심 하위 표현을 모두 포함하는 경우, 전체 일치 길이는 전체 RE에 할당 된 속성에 따라 가능한 한 길거나 짧습니다. 하위 표현식에 지정된 속성은 해당 항목이 서로 &quot;먹을&quot;수있는 일치 정도에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="aee830ec2c7b69b7f24b10ee81fb051f88d3ea9e" translate="yes" xml:space="preserve">
          <source>In short, while an index-only scan is possible given the two fundamental requirements, it will be a win only if a significant fraction of the table's heap pages have their all-visible map bits set. But tables in which a large fraction of the rows are unchanging are common enough to make this type of scan very useful in practice.</source>
          <target state="translated">간단히 말해, 두 가지 기본 요구 사항이 주어지면 인덱스 전용 스캔이 가능하지만 테이블 힙 페이지의 상당 부분에 모든 가시적 맵 비트가 설정되어있는 경우에만 승리 할 수 ​​있습니다. 그러나 대부분의 행이 변경되지 않은 테이블은 이러한 유형의 스캔을 실제로 유용하게 사용할 수있을만큼 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="81308d755ee35ef99db2fb46ff2f6ea4fdc54a8b" translate="yes" xml:space="preserve">
          <source>In simple cases, the concatenation operator discussed above is preferred over direct use of these functions. However, because the concatenation operator is overloaded to serve all three cases, there are situations where use of one of the functions is helpful to avoid ambiguity. For example consider:</source>
          <target state="translated">간단한 경우에, 위에서 논의 된 연결 연산자는 이러한 기능을 직접 사용하는 것보다 선호됩니다. 그러나 연결 연산자는 세 가지 경우 모두를 처리하기 위해 오버로드되므로 기능 중 하나를 사용하는 것이 모호성을 피하는 데 도움이되는 상황이 있습니다. 예를 들어 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5a889e9ac805b7a61b2cef1759227b4c01dc82" translate="yes" xml:space="preserve">
          <source>In some cases &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; shows additional execution statistics beyond the plan node execution times and row counts. For example, Sort and Hash nodes provide extra information:</source>
          <target state="translated">경우에 따라 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 는 계획 노드 실행 시간 및 행 수를 넘어서 추가 실행 통계를 표시합니다. 예를 들어, 정렬 및 해시 노드는 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e8c81b00bcb69c8ee6819bdd31891ee097641a10" translate="yes" xml:space="preserve">
          <source>In some cases it is possible for a single SQL command to fire more than one kind of trigger. For instance an &lt;code&gt;INSERT&lt;/code&gt; with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause may cause both insert and update operations, so it will fire both kinds of triggers as needed. The transition relations supplied to triggers are specific to their event type; thus an &lt;code&gt;INSERT&lt;/code&gt; trigger will see only the inserted rows, while an &lt;code&gt;UPDATE&lt;/code&gt; trigger will see only the updated rows.</source>
          <target state="translated">경우에 따라 단일 SQL 명령이 여러 종류의 트리거를 발생시킬 수 있습니다. 인스턴스의 &lt;code&gt;INSERT&lt;/code&gt; 와 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 의 필요에 따라 트리거 두 종류의 화재 있도록 절은 모두 삽입 및 업데이트 작업을 일으킬 수 있습니다. 트리거에 제공되는 전환 관계는 이벤트 유형에 따라 다릅니다. 따라서 &lt;code&gt;INSERT&lt;/code&gt; 트리거에는 삽입 된 행만 표시되고 &lt;code&gt;UPDATE&lt;/code&gt; 트리거에는 업데이트 된 행만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="200831069c2086edb298c7a6b5677910ac8d156b" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt;. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">어떤 경우에는 호출 방법에 따라 다른 열 세트를 리턴 할 수있는 테이블 함수를 정의하는 것이 유용합니다. 이를 지원하기 위해 테이블 ​​함수는 의사 유형 &lt;code&gt;record&lt;/code&gt; 를 리턴하는 것으로 선언 될 수 있습니다 . 이러한 함수가 쿼리에 사용될 때 시스템은 쿼리 구문 분석 및 계획 방법을 알 수 있도록 예상되는 행 구조를 쿼리 자체에 지정해야합니다. 이 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d89a4f32e25e9b6f4b0aae8fa4c3b33eb2b87fd" translate="yes" xml:space="preserve">
          <source>In some cases it might also be necessary to increase &lt;code&gt;SEMMAP&lt;/code&gt; to be at least on the order of &lt;code&gt;SEMMNS&lt;/code&gt;. If the system has this parameter (many do not), it defines the size of the semaphore resource map, in which each contiguous block of available semaphores needs an entry. When a semaphore set is freed it is either added to an existing entry that is adjacent to the freed block or it is registered under a new map entry. If the map is full, the freed semaphores get lost (until reboot). Fragmentation of the semaphore space could over time lead to fewer available semaphores than there should be.</source>
          <target state="translated">경우에 따라 &lt;code&gt;SEMMAP&lt;/code&gt; 을 &lt;code&gt;SEMMNS&lt;/code&gt; 이상으로 늘려야 할 수도 있습니다 . 시스템에이 매개 변수가있는 경우 (다수는 아님) 사용 가능한 세마포어의 각 연속 블록에 항목이 필요한 세마포어 자원 맵의 크기가 정의됩니다. 세마포어 세트가 해제되면 해제 된 블록에 인접한 기존 항목에 추가되거나 새 맵 항목 아래에 등록됩니다. 맵이 가득 차면 해제 된 세마포어가 손실됩니다 (재부팅 할 때까지). 세마포어 공간의 조각화는 시간이 지남에 따라 사용 가능한 세마포어 수가 적을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2c835a0ebddfd298ae5463818241acfed988912" translate="yes" xml:space="preserve">
          <source>In some cases several distinct distributions are needed which don't correlate with each other and this is when implicit seed parameter comes in handy:</source>
          <target state="translated">어떤 경우에는 서로 관련이없는 몇 가지 뚜렷한 분포가 필요하며 이는 암시 적 시드 매개 변수가 유용한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="b659c8baf607682082fc2a028333f1abc817539f" translate="yes" xml:space="preserve">
          <source>In some cases the join style is easier to write or faster to execute than the sub-select style.</source>
          <target state="translated">경우에 따라 결합 스타일이 하위 선택 스타일보다 작성하기가 더 빠르거나 실행하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="cc280a2801256511a801ad6396d782aaf11a1fd5" translate="yes" xml:space="preserve">
          <source>In some cases the planner will prefer a &amp;ldquo;simple&amp;rdquo; index scan plan:</source>
          <target state="translated">경우에 따라 플래너는 &quot;간단한&quot;인덱스 스캔 계획을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="0752bfbb1e8e2f35c9e16d26381cb349bc520d2f" translate="yes" xml:space="preserve">
          <source>In some cases you might wish to know which table a particular row originated from. There is a system column called &lt;code&gt;tableoid&lt;/code&gt; in each table which can tell you the originating table:</source>
          <target state="translated">경우에 따라 특정 행이 시작된 테이블을 알고 싶을 수도 있습니다. 각 테이블 에는 &lt;code&gt;tableoid&lt;/code&gt; 라는 시스템 열이 있으며,이 테이블은 원래 테이블을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="85aa180babf965f446d9b4ca6c81be1df71986fd" translate="yes" xml:space="preserve">
          <source>In some cases, a user will know that a given XPath query will return only a single result (perhaps a unique document identifier) &amp;mdash; if used alongside an XPath query returning multiple results, the single-valued result will appear only on the first row of the result. The solution to this is to use the key field as part of a join against a simpler XPath query. As an example:</source>
          <target state="translated">경우에 따라 사용자는 지정된 XPath 쿼리가 단일 결과 (아마도 고유 한 문서 식별자) 만 반환한다는 것을 알고 있습니다. 여러 결과를 반환하는 XPath 쿼리와 함께 사용하면 단일 값 결과가 첫 번째 행에만 나타납니다. 결과. 이에 대한 해결책은 간단한 XPath 쿼리에 대한 조인의 일부로 키 필드를 사용하는 것입니다. 예로서:</target>
        </trans-unit>
        <trans-unit id="ca377880ca6732de73ffe88d7d610d10f88a2a04" translate="yes" xml:space="preserve">
          <source>In some cases, an external storage product can be accessed either via NFS or a lower-level protocol such as iSCSI. In the latter case, the storage appears as a block device and any available file system can be created on it. That approach might relieve the DBA from having to deal with some of the idiosyncrasies of NFS, but of course the complexity of managing remote storage then happens at other levels.</source>
          <target state="translated">경우에 따라 NFS 또는 iSCSI와 같은 하위 수준 프로토콜을 통해 외부 저장소 제품에 액세스 할 수 있습니다. 후자의 경우 스토리지는 블록 장치로 표시되며 사용 가능한 파일 시스템을 만들 수 있습니다. 이러한 접근 방식은 DBA가 NFS의 특이성을 처리하지 않아도되지만 원격 스토리지 관리의 복잡성은 다른 수준에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4cdce5fe180ac016fd38728542336a4cccb6659d" translate="yes" xml:space="preserve">
          <source>In some cases, queries with visibly different texts might get merged into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry. Normally this will happen only for semantically equivalent queries, but there is a small chance of hash collisions causing unrelated queries to be merged into one entry. (This cannot happen for queries belonging to different users or databases, however.)</source>
          <target state="translated">경우에 따라 텍스트가 다른 쿼리는 단일 &lt;code&gt;pg_stat_statements&lt;/code&gt; 항목 으로 병합 될 수 있습니다 . 일반적으로 이는 의미 적으로 동등한 쿼리에 대해서만 발생하지만 해시 충돌로 인해 관련없는 쿼리가 하나의 항목으로 병합 될 가능성이 적습니다. 그러나 다른 사용자 나 데이터베이스에 속한 쿼리에는이 문제가 발생할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3587765c2705ba8328ac5e625d50c99ae816e4fe" translate="yes" xml:space="preserve">
          <source>In some contexts it is important to be sure that row security is not being applied. For example, when taking a backup, it could be disastrous if row security silently caused some rows to be omitted from the backup. In such a situation, you can set the &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; configuration parameter to &lt;code&gt;off&lt;/code&gt;. This does not in itself bypass row security; what it does is throw an error if any query's results would get filtered by a policy. The reason for the error can then be investigated and fixed.</source>
          <target state="translated">일부 상황에서는 행 보안이 적용되지 않는 것이 중요합니다. 예를 들어, 백업을 수행 할 때 행 보안으로 인해 일부 행이 백업에서 생략 된 경우 비참 할 수 있습니다. 이러한 상황에서는 &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; 구성 매개 변수를 &lt;code&gt;off&lt;/code&gt; 로 설정할 수 있습니다 . 이것은 그 자체로는 행 보안을 우회하지 않습니다. 쿼리 결과가 정책에 의해 필터링되면 오류가 발생합니다. 그런 다음 오류의 원인을 조사하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ce77934cf9885a03a2ac3b7887461d3a1cb010" translate="yes" xml:space="preserve">
          <source>In some contexts, backslashes must be doubled compared to what is shown above, because the generic string-literal parser will also reduce pairs of backslashes to one data character; see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;.</source>
          <target state="translated">일부 문맥에서, 일반 문자열 리터럴 파서는 백 슬래시 쌍을 하나의 데이터 문자로 줄이기 때문에 백 슬래시는 위에 표시된 것과 비교하여 두 배가되어야합니다. &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;섹션 4.1.2.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="ad2914b6fce7d3aa951198848f0bae1a566122fb" translate="yes" xml:space="preserve">
          <source>In some query plans, it is possible for a subplan node to be executed more than once. For example, the inner index scan will be executed once per outer row in the above nested-loop plan. In such cases, the &lt;code&gt;loops&lt;/code&gt; value reports the total number of executions of the node, and the actual time and rows values shown are averages per-execution. This is done to make the numbers comparable with the way that the cost estimates are shown. Multiply by the &lt;code&gt;loops&lt;/code&gt; value to get the total time actually spent in the node. In the above example, we spent a total of 0.220 milliseconds executing the index scans on &lt;code&gt;tenk2&lt;/code&gt;.</source>
          <target state="translated">일부 쿼리 계획에서는 하위 계획 노드가 두 번 이상 실행될 수 있습니다. 예를 들어, 내부 인덱스 스캔은 위의 중첩 루프 계획에서 외부 행당 한 번 실행됩니다. 이러한 경우 &lt;code&gt;loops&lt;/code&gt; 값은 노드의 총 실행 수를보고하며 표시된 실제 시간 및 행 값은 실행 당 평균입니다. 이것은 비용 추정치가 표시되는 방식과 숫자를 비교하기 위해 수행됩니다. &lt;code&gt;loops&lt;/code&gt; 값을 곱하면 실제로 노드에서 보낸 총 시간을 얻을 수 있습니다. 위의 예에서 &lt;code&gt;tenk2&lt;/code&gt; 에서 인덱스 스캔을 실행하는 데 총 0.220 밀리 초가 소요 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="225981494667f7eae039a8f3a624ead9ac2ba414" translate="yes" xml:space="preserve">
          <source>In some situations it is worthwhile to rebuild indexes periodically with the &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; command or a series of individual rebuilding steps.</source>
          <target state="translated">경우에 따라 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; 명령 또는 일련의 개별 재 구축 단계를 사용하여 정기적으로 색인을 재 구축하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e0f45ec00183e0785ecaf537d621d39641ace7" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">경우에 따라 쿼리를 실행할 수있는 각 가능한 방법을 검사하면 시간과 메모리 공간이 지나치게 많이 걸립니다. 특히 많은 조인 작업과 관련된 쿼리를 실행할 때 발생합니다. 합리적인 시간 내에 합리적인 (최상의 최적은 아님) 쿼리 계획을 결정하기 위해 PostgreSQL은 조인 수가 임계 값을 초과 할 때 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;제 59 장&lt;/a&gt; 참조) &lt;em&gt;Genetic Query Optimizer를&lt;/em&gt; 사용합니다 ( &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b44a40fdd52559ad494c2c8c248a6de473d41182" translate="yes" xml:space="preserve">
          <source>In standby mode, the server continuously applies WAL received from the master server. The standby server can read WAL from a WAL archive (see &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;) or directly from the master over a TCP connection (streaming replication). The standby server will also attempt to restore any WAL found in the standby cluster's &lt;code&gt;pg_wal&lt;/code&gt; directory. That typically happens after a server restart, when the standby replays again WAL that was streamed from the master before the restart, but you can also manually copy files to &lt;code&gt;pg_wal&lt;/code&gt; at any time to have them replayed.</source>
          <target state="translated">대기 모드에서 서버는 마스터 서버로부터받은 WAL을 지속적으로 적용합니다. 대기 서버는 WAL 아카이브 ( &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 참조 )에서 또는 TCP 연결을 통해 마스터에서 직접 WAL을 읽을 수 있습니다 (스트리밍 복제). 대기 서버는 또한 대기 클러스터의 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리 에있는 모든 WAL을 복원하려고 시도합니다 . 일반적으로 서버를 다시 시작한 후 대기가 다시 시작하기 전에 마스터에서 스트리밍 된 WAL을 다시 재생할 때 발생하지만 언제든지 수동으로 파일을 &lt;code&gt;pg_wal&lt;/code&gt; 에 복사 하여 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe531d3ac4f289af249052c7bd344a8eccac974a" translate="yes" xml:space="preserve">
          <source>In strict SQL, &lt;code&gt;GROUP BY&lt;/code&gt; can only group by columns of the source table but PostgreSQL extends this to also allow &lt;code&gt;GROUP BY&lt;/code&gt; to group by columns in the select list. Grouping by value expressions instead of simple column names is also allowed.</source>
          <target state="translated">엄격한 SQL에서 &lt;code&gt;GROUP BY&lt;/code&gt; 는 소스 테이블의 열을 기준으로 만 그룹화 할 수 있지만 PostgreSQL은이를 확장하여 &lt;code&gt;GROUP BY&lt;/code&gt; 가 선택 목록의 열을 기준으로 그룹화 할 수도 있습니다 . 간단한 열 이름 대신 값 표현식으로 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="925d63461b4ad93eaf09cda8debcd8a2f6185160" translate="yes" xml:space="preserve">
          <source>In such a column, all entries must use the symbolic format except when writing &lt;code&gt;0&lt;/code&gt; for InvalidOid. (If the column is declared &lt;code&gt;regproc&lt;/code&gt;, you can optionally write &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;.) &lt;code&gt;genbki.pl&lt;/code&gt; will warn about unrecognized names.</source>
          <target state="translated">이러한 열에서 InvalidOid에 &lt;code&gt;0&lt;/code&gt; 을 쓸 때를 제외하고 모든 항목은 기호 형식을 사용해야 합니다. (열이 선언되면 &lt;code&gt;regproc&lt;/code&gt; 를 , 선택적으로 쓸 수 있습니다 &lt;code&gt;-&lt;/code&gt; 대신 &lt;code&gt;0&lt;/code&gt; .) &lt;code&gt;genbki.pl&lt;/code&gt; 가 인식 할 수없는 이름에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="f44470ab677292f080ad629e5021dd422bb50329" translate="yes" xml:space="preserve">
          <source>In synchronous multimaster replication, each server can accept write requests, and modified data is transmitted from the original server to every other server before each transaction commits. Heavy write activity can cause excessive locking and commit delays, leading to poor performance. Read requests can be sent to any server. Some implementations use shared disk to reduce the communication overhead. Synchronous multimaster replication is best for mostly read workloads, though its big advantage is that any server can accept write requests &amp;mdash; there is no need to partition workloads between master and standby servers, and because the data changes are sent from one server to another, there is no problem with non-deterministic functions like &lt;code&gt;random()&lt;/code&gt;.</source>
          <target state="translated">동기식 다중 마스터 복제에서 각 서버는 쓰기 요청을 수락 할 수 있으며 수정 된 데이터는 각 트랜잭션이 커밋되기 전에 원본 서버에서 다른 모든 서버로 전송됩니다. 쓰기 작업이 많으면 과도한 잠금 및 커밋 지연이 발생하여 성능이 저하 될 수 있습니다. 읽기 요청은 모든 서버로 보낼 수 있습니다. 일부 구현에서는 공유 디스크를 사용하여 통신 오버 헤드를 줄입니다. 동기식 멀티 마스터 복제는 대부분의 읽기 워크로드에 가장 적합하지만 모든 서버가 쓰기 요청을 수락 할 수 있다는 장점이 있습니다. 마스터 서버와 대기 서버간에 워크로드를 분할 할 필요가 없으며 데이터 변경이 한 서버에서 다른 서버로 전송되기 때문입니다. &lt;code&gt;random()&lt;/code&gt; 과 같은 비 결정적 함수에는 문제가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7c4b878fdf07a28c13f143cacc8a5bb3f8880019" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.affix&lt;/code&gt; file every affix flag is described in the following format:</source>
          <target state="translated">에서 &lt;code&gt;.affix&lt;/code&gt; 의 파일마다 접사 플래그는 다음과 같은 형식으로 설명되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="08a1ad04eb220026fbfc94b398836d4cbc2cae8c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame options, the &lt;code&gt;offset&lt;/code&gt; must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the &lt;code&gt;offset&lt;/code&gt; depends on the frame mode:</source>
          <target state="translated">에서 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; 프레임 옵션의 &lt;code&gt;offset&lt;/code&gt; 모든 변수 집합 함수 또는 윈도우 함수를 함유하지 않은 식이어야한다. &lt;code&gt;offset&lt;/code&gt; 의 의미 는 프레임 모드에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="27bf78dd19410e50d81449e21eeb4a9c340ecbaa" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;prepared&lt;/code&gt; mode, pgbench reuses the parse analysis result starting from the second query iteration, so pgbench runs faster than in other modes.</source>
          <target state="translated">에서 &lt;code&gt;prepared&lt;/code&gt; 모드, pgbench 그렇게 pgbench 빠르게 실행 다른 모드에 비해, 두 번째 쿼리의 반복에서 시작하는 구문 분석 분석 결과를 다시 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7dd20a44a8914e7e3854e6b8cc2dd765d950b1b2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;template0&lt;/code&gt; database, it could be useful to create collations whose encoding does not match the database encoding, since they could match the encodings of databases later cloned from &lt;code&gt;template0&lt;/code&gt;. This would currently have to be done manually.</source>
          <target state="translated">에서 &lt;code&gt;template0&lt;/code&gt; 의 그들이 나중에에서 복제 된 데이터베이스의 인코딩과 일치 할 수 있기 때문에 데이터베이스, 누구의 인코딩 데이터베이스 인코딩과 일치하지 않는 데이터 정렬을 만드는 데 유용 할 수 &lt;code&gt;template0&lt;/code&gt; 를 . 이 작업은 현재 수동으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee7442c19df868ba3ec76972f6eb3be85838007a" translate="yes" xml:space="preserve">
          <source>In the ISO week-numbering system, it is possible for early-January dates to be part of the 52nd or 53rd week of the previous year, and for late-December dates to be part of the first week of the next year. For example, &lt;code&gt;2005-01-01&lt;/code&gt; is part of the 53rd week of year 2004, and &lt;code&gt;2006-01-01&lt;/code&gt; is part of the 52nd week of year 2005, while &lt;code&gt;2012-12-31&lt;/code&gt; is part of the first week of 2013. It's recommended to use the &lt;code&gt;isoyear&lt;/code&gt; field together with &lt;code&gt;week&lt;/code&gt; to get consistent results.</source>
          <target state="translated">ISO 주 번호 매기기 시스템에서 1 월 초 날짜는 전년도 52 주 또는 53 주에 속하고 12 월 말 날짜는 내년 첫 주에 속할 수 있습니다. 예를 들어 &lt;code&gt;2005-01-01&lt;/code&gt; 은 2004 년 53 번째 주에 속하고 &lt;code&gt;2006-01-01&lt;/code&gt; 은 2005 년 52 주에 속하고 &lt;code&gt;2012-12-31&lt;/code&gt; 은 2013 년 첫 주에 속합니다. 일관된 결과를 얻으려면 &lt;code&gt;isoyear&lt;/code&gt; 필드를 &lt;code&gt;week&lt;/code&gt; 와 함께 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e2cd521bd47287d9192e9d5c00cd5e2a6b143afe" translate="yes" xml:space="preserve">
          <source>In the PostgreSQL parser life is a bit more complicated. There are several different classes of tokens ranging from those that can never be used as an identifier to those that have absolutely no special status in the parser as compared to an ordinary identifier. (The latter is usually the case for functions specified by SQL.) Even reserved key words are not completely reserved in PostgreSQL, but can be used as column labels (for example, &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt;, even though &lt;code&gt;CHECK&lt;/code&gt; is a reserved key word).</source>
          <target state="translated">PostgreSQL 파서 수명은 조금 더 복잡합니다. 식별자로 사용할 수없는 토큰부터 일반 식별자와 비교할 때 파서에서 특별한 상태가없는 토큰에 이르기까지 여러 종류의 토큰이 있습니다. (후자는 일반적으로 SQL로 지정된 함수의 경우입니다.) 예약 된 키워드조차도 PostgreSQL에서 완전히 예약되지 않았지만 열 레이블로 사용될 수 있습니다 (예 : &lt;code&gt;CHECK&lt;/code&gt; 가 예약 된 키워드 임에도 불구하고 &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt; ). .</target>
        </trans-unit>
        <trans-unit id="c06a771ae535ebcc1c02437d6d6edcaa369ff63e" translate="yes" xml:space="preserve">
          <source>In the SQL and POSTGRES styles, day appears before month if DMY field ordering has been specified, otherwise month appears before day. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;Section 8.5.1&lt;/a&gt; for how this setting also affects interpretation of input values.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;Table 8.15&lt;/a&gt; shows examples.</source>
          <target state="translated">SQL 및 POSTGRES 스타일에서 DMY 필드 순서를 지정하면 월이 전날에 나타나고, 그렇지 않으면 월이 전날에 나타납니다. ( 이 설정이 입력 값 해석에 어떻게 영향을 미치는지에 대해서는 &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;8.5.1 절을&lt;/a&gt; 참조하십시오 .) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;표 8.15&lt;/a&gt; 는 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="84b70dca4dd2a2a4e41665aeb47157cc98221d20" translate="yes" xml:space="preserve">
          <source>In the SQL standard, sequences only have a &lt;code&gt;USAGE&lt;/code&gt; privilege, which controls the use of the &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression, which is equivalent to the function &lt;code&gt;nextval&lt;/code&gt; in PostgreSQL. The sequence privileges &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; are PostgreSQL extensions. The application of the sequence &lt;code&gt;USAGE&lt;/code&gt; privilege to the &lt;code&gt;currval&lt;/code&gt; function is also a PostgreSQL extension (as is the function itself).</source>
          <target state="translated">SQL 표준에서 시퀀스에는 &lt;code&gt;USAGE&lt;/code&gt; 권한 만 있으며 이는 PostgreSQL의 &lt;code&gt;nextval&lt;/code&gt; 함수와 동일한 &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 표현식 의 사용을 제어합니다 . &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 시퀀스 권한 은 PostgreSQL 확장입니다. &lt;code&gt;currval&lt;/code&gt; 함수에 시퀀스 &lt;code&gt;USAGE&lt;/code&gt; 권한을 적용하는 것도 PostgreSQL 확장입니다 (함수 자체도 마찬가지 임).</target>
        </trans-unit>
        <trans-unit id="9660d94d0a1b58a81d974d699a1bce336010b697" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of &lt;code&gt;user_name.table_name&lt;/code&gt;. This is how PostgreSQL will effectively behave if you create a per-user schema for every user.</source>
          <target state="translated">SQL 표준에는 다른 사용자가 소유 한 동일한 스키마의 오브젝트 개념이 존재하지 않습니다. 또한 일부 구현에서는 소유자와 이름이 다른 스키마를 만들 수 없습니다. 실제로 스키마와 사용자의 개념은 표준에 지정된 기본 스키마 지원 만 구현하는 데이터베이스 시스템에서 거의 동일합니다. 따라서 많은 사용자는 규정 된 이름이 실제로 &lt;code&gt;user_name.table_name&lt;/code&gt; 으로 구성되는 것으로 간주 합니다. 모든 사용자에 대해 사용자 별 스키마를 생성 할 경우 PostgreSQL이 효과적으로 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="bce55523e60490fd9a9b255e77d45bae3da990ba" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the optional key word &lt;code&gt;AS&lt;/code&gt; can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword). PostgreSQL is slightly more restrictive: &lt;code&gt;AS&lt;/code&gt; is required if the new column name matches any keyword at all, reserved or not. Recommended practice is to use &lt;code&gt;AS&lt;/code&gt; or double-quote output column names, to prevent any possible conflict against future keyword additions.</source>
          <target state="translated">SQL 표준에서, 선택적 컬럼 단어 &lt;code&gt;AS&lt;/code&gt; 는 새 컬럼 이름이 유효한 컬럼 이름 (즉, 예약 된 키워드와 동일하지 않음) 일 때마다 출력 컬럼 이름 앞에 생략 될 수 있습니다. PostgreSQL은 약간 더 제한적입니다. 새 열 이름이 키워드와 일치하거나 예약 여부에 관계없이 &lt;code&gt;AS&lt;/code&gt; 가 필요합니다. 향후 키워드 추가와의 충돌 가능성을 방지 하기 위해 &lt;code&gt;AS&lt;/code&gt; 또는 큰 따옴표 출력 열 이름을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60fb33ea7714daeb182a1d8cf938445a4efd08dd" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is a clear distinction between users and roles, and users do not automatically inherit privileges while roles do. This behavior can be obtained in PostgreSQL by giving roles being used as SQL roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, while giving roles being used as SQL users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. However, PostgreSQL defaults to giving all roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, for backward compatibility with pre-8.1 releases in which users always had use of permissions granted to groups they were members of.</source>
          <target state="translated">SQL 표준에는 사용자와 역할이 명확하게 구분되어 있으며 사용자는 역할을 수행하는 동안 자동으로 권한을 상속하지 않습니다. 이 동작은 SQL 역할로 사용되는 역할을 &lt;code&gt;INHERIT&lt;/code&gt; 속성으로 제공하고 SQL 사용자로 사용되는 역할은 &lt;code&gt;NOINHERIT&lt;/code&gt; 속성 으로 제공하여 PostgreSQL에서 얻을 수 있습니다 . 그러나 PostgreSQL은 기본적으로 모든 역할에 &lt;code&gt;INHERIT&lt;/code&gt; 속성을 부여하여 사용자가 항상 소속 그룹에 부여 된 권한을 사용하는 8.1 이전 버전과의 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4d55ecfda5316639c09ff6bb19e9602eb2f98338" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is one other transaction characteristic that can be set with these commands: the size of the diagnostics area. This concept is specific to embedded SQL, and therefore is not implemented in the PostgreSQL server.</source>
          <target state="translated">SQL 표준에는 진단 영역의 크기와 같은 명령으로 설정할 수있는 다른 트랜잭션 특성이 있습니다. 이 개념은 내장 SQL에만 적용되므로 PostgreSQL 서버에서는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed36ad7d98cb4d8fee32b855fb6fed744837b0e0" translate="yes" xml:space="preserve">
          <source>In the SQL-92 standard, an &lt;code&gt;ORDER BY&lt;/code&gt; clause can only use output column names or numbers, while a &lt;code&gt;GROUP BY&lt;/code&gt; clause can only use expressions based on input column names. PostgreSQL extends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity). PostgreSQL also allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.</source>
          <target state="translated">SQL-92 표준에서 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 출력 열 이름 또는 숫자 만 사용할 수 있는 반면 &lt;code&gt;GROUP BY&lt;/code&gt; 절은 입력 열 이름을 기반으로하는 표현식 만 사용할 수 있습니다. PostgreSQL은 이러한 각 절을 확장하여 다른 선택도 허용합니다 (그러나 모호한 경우 표준 해석을 사용합니다). PostgreSQL을 사용하면 두 절 모두에서 임의의 표현식을 지정할 수 있습니다. 식에 나타나는 이름은 항상 출력 열 이름이 아니라 입력 열 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b054bfec2bce610e705197d361e44d3c2768bb83" translate="yes" xml:space="preserve">
          <source>In the XQuery/XPath data model, a &lt;em&gt;document node&lt;/em&gt; can have either document form (i.e., exactly one top-level element, with only comments and processing instructions outside of it) or content form (with those constraints relaxed). Its equivalent in XPath 1.0, the &lt;em&gt;root node&lt;/em&gt;, can only be in document form. This is part of the reason an &lt;code&gt;xml&lt;/code&gt; value passed as the context item to any PostgreSQL XPath-based function must be in document form.</source>
          <target state="translated">XQuery / XPath 데이터 모델에서 &lt;em&gt;문서 노드&lt;/em&gt; 는 문서 형식 (즉, 주석과 처리 명령 만있는 최상위 요소 하나만 포함) 또는 콘텐츠 형식 (제약 조건이 완화 된)을 가질 수 있습니다. &lt;em&gt;루트 노드&lt;/em&gt; 인 XPath 1.0과 동일하며 문서 형식 만 가능합니다. 이는 PostgreSQL XPath 기반 함수에 컨텍스트 항목으로 전달 된 &lt;code&gt;xml&lt;/code&gt; 값이 문서 형식이어야 하는 이유 중 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="907c04147bb1d71b5f0459b5e753db080d794777" translate="yes" xml:space="preserve">
          <source>In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">위의 예에서는 매월 새 파티션을 작성하므로 필요한 DDL을 자동으로 생성하는 스크립트를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="652407089ebdeac3fe06a048bf54ac1385a35fc9" translate="yes" xml:space="preserve">
          <source>In the above example, the new password isn't actually echoed when typed, but we show what was typed for clarity. As you see, the password is encrypted before it is sent to the client.</source>
          <target state="translated">위의 예에서 입력 할 때 새 비밀번호는 실제로 에코되지 않지만 명확성을 위해 입력 된 비밀번호를 보여줍니다. 보시다시피, 암호는 클라이언트로 전송되기 전에 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="a28671e837ffe13c54dd539a74a6f7de604de65e" translate="yes" xml:space="preserve">
          <source>In the above output, the free space figures may not match the &lt;code&gt;pgstattuple&lt;/code&gt; output exactly, because the free space map gives us an exact figure, but is not guaranteed to be accurate to the byte.</source>
          <target state="translated">위의 출력 에서 사용 가능한 공간 맵은 정확한 그림을 제공하지만 바이트에 대해서는 정확하지 않기 때문에 &lt;code&gt;pgstattuple&lt;/code&gt; 출력과 정확하게 일치 하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfee998fb713aa32e0b0a461f86fb14fa87aa018" translate="yes" xml:space="preserve">
          <source>In the above queries, the second form is dangerous because the &lt;code&gt;LIMIT&lt;/code&gt; is not guaranteed to be applied before the locking function is executed. This might cause some locks to be acquired that the application was not expecting, and hence would fail to release (until it ends the session). From the point of view of the application, such locks would be dangling, although still viewable in &lt;code&gt;pg_locks&lt;/code&gt;.</source>
          <target state="translated">위의 쿼리에서 두 번째 형식은 잠금 기능이 실행되기 전에 &lt;code&gt;LIMIT&lt;/code&gt; 가 적용되지 않을 수 있으므로 위험합니다 . 이로 인해 응용 프로그램이 예상하지 못했던 일부 잠금이 획득되어 세션이 종료 될 때까지 해제되지 않을 수 있습니다. 응용 프로그램의 관점에서 볼 때 이러한 잠금은 &lt;code&gt;pg_locks&lt;/code&gt; 에서 여전히 볼 수 있지만 매달려 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0422400fe004db1267465196296a34921629ca1c" translate="yes" xml:space="preserve">
          <source>In the above query, the arguments &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are specified positionally, while &lt;code&gt;uppercase&lt;/code&gt; is specified by name. In this example, that adds little except documentation. With a more complex function having numerous parameters that have default values, named or mixed notation can save a great deal of writing and reduce chances for error.</source>
          <target state="translated">위의 쿼리에서 인수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 위치 적 으로 지정되고 &lt;code&gt;uppercase&lt;/code&gt; 는 이름으로 지정됩니다. 이 예제에서는 문서를 제외하고 거의 추가하지 않습니다. 명명 된 또는 혼합 표기법은 기본값을 갖는 수많은 매개 변수를 갖는보다 복잡한 함수를 사용하면 많은 양의 쓰기를 저장하고 오류 가능성을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12fe4f57925256d624bd6eb274cf2330b45da284" translate="yes" xml:space="preserve">
          <source>In the absence of fatal errors, pg_receivewal will run until terminated by the SIGINT signal (&lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;C&lt;/strong&gt;).</source>
          <target state="translated">치명적인 오류가 없으면 pg_receivewal은 SIGINT 신호 ( &lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;C&lt;/strong&gt; )에 의해 종료 될 때까지 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6c9650fa107be76e508c9f6a766e1575673cf8c" translate="yes" xml:space="preserve">
          <source>In the alternative format:</source>
          <target state="translated">다른 형식으로 :</target>
        </trans-unit>
        <trans-unit id="c2e1ceee33301b36828cf2caae1f68eec137b740" translate="yes" xml:space="preserve">
          <source>In the case of a parallel dump, the snapshot name defined by this option is used rather than taking a new snapshot.</source>
          <target state="translated">병렬 덤프의 경우이 옵션으로 정의 된 스냅 샷 이름이 새 스냅 샷을 생성하는 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a04ddae39deed0bb63ddc81c6701d5c2ad86b55" translate="yes" xml:space="preserve">
          <source>In the case of a partitioned table, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually a &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation.</source>
          <target state="translated">파티션 된 테이블의 경우 행을 업데이트하면 더 이상 포함하는 파티션의 파티션 제한 조건을 충족시키지 못할 수 있습니다. 이 경우, 파티션 트리에이 행이 파티션 제한 조건을 만족시키는 다른 파티션이 있으면 행이 해당 파티션으로 이동됩니다. 그러한 파티션이 없으면 오류가 발생합니다. 무대 뒤에서 행 이동은 실제로 &lt;code&gt;DELETE&lt;/code&gt; 및 &lt;code&gt;INSERT&lt;/code&gt; 작업입니다.</target>
        </trans-unit>
        <trans-unit id="5544906e3d293a0a9ad12a92567f1204d11f1dd6" translate="yes" xml:space="preserve">
          <source>In the case of an exclusion constraint, &lt;code&gt;conkey&lt;/code&gt; is only useful for constraint elements that are simple column references. For other cases, a zero appears in &lt;code&gt;conkey&lt;/code&gt; and the associated index must be consulted to discover the expression that is constrained. (&lt;code&gt;conkey&lt;/code&gt; thus has the same contents as &lt;code&gt;pg_index&lt;/code&gt;.&lt;code&gt;indkey&lt;/code&gt; for the index.)</source>
          <target state="translated">제외 제약 조건의 경우 &lt;code&gt;conkey&lt;/code&gt; 는 간단한 열 참조 인 제약 조건 요소에만 유용합니다. 다른 경우에는 &lt;code&gt;conkey&lt;/code&gt; 에 0이 나타나고 제한된 표현식을 찾기 위해 관련 인덱스를 참조해야합니다. ( &lt;code&gt;conkey&lt;/code&gt; 은 이와 같은 내용을 가지고 &lt;code&gt;pg_index&lt;/code&gt; . &lt;code&gt;indkey&lt;/code&gt; 인덱스를위한).</target>
        </trans-unit>
        <trans-unit id="e4fef774ebd3ff2e38db3236bd03a350ace1f35c" translate="yes" xml:space="preserve">
          <source>In the common case where you just want the whole matching substring or &lt;code&gt;NULL&lt;/code&gt; for no match, write something like</source>
          <target state="translated">전체 일치하는 부분 문자열을 원하거나 일치 하지 않는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 원하는 일반적인 경우 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d8de3d9b49ffb3cc570c884fc7d3dde953f8a262" translate="yes" xml:space="preserve">
          <source>In the context of &lt;code&gt;INSERT&lt;/code&gt;, entries of a &lt;code&gt;VALUES&lt;/code&gt; list can be &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the column default should be used here instead of specifying a value:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 컨텍스트 에서 &lt;code&gt;VALUES&lt;/code&gt; 목록의 항목을 &lt;code&gt;DEFAULT&lt;/code&gt; 로 설정하여 값을 지정하는 대신 열 기본값을 사용해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0a8a6bb89f9ea4433f27de55629e036adfed0508" translate="yes" xml:space="preserve">
          <source>In the current implementation, the fitness of each candidate join sequence is estimated by running the standard planner's join selection and cost estimation code from scratch. To the extent that different candidates use similar sub-sequences of joins, a great deal of work will be repeated. This could be made significantly faster by retaining cost estimates for sub-joins. The problem is to avoid expending unreasonable amounts of memory on retaining that state.</source>
          <target state="translated">현재 구현에서, 각 후보 조인 시퀀스의 적합성은 표준 플래너의 조인 선택 및 비용 추정 코드를 처음부터 실행함으로써 추정된다. 다른 후보들이 유사한 조인의 서브 시퀀스를 사용하는 한, 많은 작업이 반복 될 것입니다. 하위 조인에 대한 비용 추정치를 유지하여이를 훨씬 빠르게 만들 수 있습니다. 문제는 해당 상태를 유지하는 데 불합리한 메모리 양을 늘리지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b88d112fefbb18a9a94530a4a12e322eca2805d" translate="yes" xml:space="preserve">
          <source>In the default PostgreSQL configuration, the autovacuum daemon (see &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;) takes care of automatic analyzing of tables when they are first loaded with data, and as they change throughout regular operation. When autovacuum is disabled, it is a good idea to run &lt;code&gt;ANALYZE&lt;/code&gt; periodically, or just after making major changes in the contents of a table. Accurate statistics will help the planner to choose the most appropriate query plan, and thereby improve the speed of query processing. A common strategy for read-mostly databases is to run &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; once a day during a low-usage time of day. (This will not be sufficient if there is heavy update activity.)</source>
          <target state="translated">기본 PostgreSQL 구성에서 autovacuum 데몬 ( &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6&lt;/a&gt; 참조 )은 데이터가 처음로드 될 때와 정기적 인 작업에서 변경 될 때 자동으로 테이블을 분석합니다. autovacuum이 비활성화 된 경우 주기적으로 또는 테이블 내용을 크게 변경 한 직후에 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하는 것이 좋습니다 . 정확한 통계는 플래너가 가장 적합한 쿼리 계획을 선택하여 쿼리 처리 속도를 향상시키는 데 도움이됩니다. 읽기 전용 데이터베이스의 일반적인 전략은 사용량이 적은 시간대에 하루에 한 번 &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 및 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행 하는 것입니다. (업데이트 활동이 많은 경우에는 충분하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="4ce2b63a8b5343bbf7125e0114e2a04ce0d2bde8" translate="yes" xml:space="preserve">
          <source>In the default setup this returns:</source>
          <target state="translated">기본 설정에서 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="596bcd2b70e5eeabccdcbaf0d79d2c517c798e21" translate="yes" xml:space="preserve">
          <source>In the event of a binary upgrade, upward compatibility is maintained by having the new code recognize old-format data. This will entail a slight performance penalty when processing data that has not yet been modified by the new code. It is possible to force an upgrade of all values in a table column by doing an &lt;code&gt;UPDATE&lt;/code&gt; statement as follows:</source>
          <target state="translated">이진 업그레이드의 경우 새 코드가 이전 형식의 데이터를 인식하도록하여 호환성이 유지됩니다. 새 코드로 아직 수정되지 않은 데이터를 처리 할 때 약간의 성능 저하가 발생합니다. 다음과 같이 &lt;code&gt;UPDATE&lt;/code&gt; 문을 수행하여 테이블 열의 모든 값을 강제로 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a7ad5f630b85b752ae07e66abff996aa3b1a24" translate="yes" xml:space="preserve">
          <source>In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, either the longest possible match or the shortest possible match will be taken, depending on whether the RE is &lt;em&gt;greedy&lt;/em&gt; or &lt;em&gt;non-greedy&lt;/em&gt;.</source>
          <target state="translated">RE가 지정된 문자열의 둘 이상의 하위 문자열과 일치 할 수있는 경우 RE는 문자열에서 가장 빠른 시작과 일치합니다. 재생 에너지는, 그 시점에서 시작하는 하위 문자열 하나보다 더 일치 할 수 있다면 가장 긴 일치 또는 최단 경기 중 하나는 RE인지 여부에 따라 이동합니다 &lt;em&gt;욕심&lt;/em&gt; 또는 &lt;em&gt;비 욕심&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="474b9960977cbbea61dc4ac5b333f0b736c6264c" translate="yes" xml:space="preserve">
          <source>In the example above we see that the resulting &lt;code&gt;tsvector&lt;/code&gt; does not contain the words &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, or &lt;code&gt;it&lt;/code&gt;, the word &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt;, and the punctuation sign &lt;code&gt;-&lt;/code&gt; was ignored.</source>
          <target state="translated">이 예에서 우리는 결과로 볼 위에 &lt;code&gt;tsvector&lt;/code&gt; 이 단어가 포함되어 있지 않습니다 , &lt;code&gt;on&lt;/code&gt; , 또는 &lt;code&gt;it&lt;/code&gt; 단어의 &lt;code&gt;rats&lt;/code&gt; 되었다 &lt;code&gt;rat&lt;/code&gt; 와 문장 부호 &lt;code&gt;-&lt;/code&gt; 무시되었다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="200ce56337643046a5aa2dd5558bb50f57584421" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;WHERE&lt;/code&gt; clause is selecting rows by a column that is not grouped (the expression is only true for sales during the last four weeks), while the &lt;code&gt;HAVING&lt;/code&gt; clause restricts the output to groups with total gross sales over 5000. Note that the aggregate expressions do not necessarily need to be the same in all parts of the query.</source>
          <target state="translated">위의 예에서 &lt;code&gt;WHERE&lt;/code&gt; 절은 그룹화되지 않은 열 (행은 지난 4 주 동안의 판매에만 해당됨)로 행을 선택하는 반면 &lt;code&gt;HAVING&lt;/code&gt; 절은 총 총 판매액이 5000을 초과하는 그룹으로 출력을 제한합니다. 집계 표현식이 쿼리의 모든 부분에서 반드시 동일 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="31c0dc4f6c95bec1ccb804da7ba6806c38ecea92" translate="yes" xml:space="preserve">
          <source>In the example above, the working table has just a single row in each step, and it takes on the values from 1 through 100 in successive steps. In the 100th step, there is no output because of the &lt;code&gt;WHERE&lt;/code&gt; clause, and so the query terminates.</source>
          <target state="translated">위의 예에서 작업 테이블은 각 단계마다 단일 행을 가지며 연속 단계에서 1에서 100 사이의 값을 취합니다. 100 번째 단계에서는 &lt;code&gt;WHERE&lt;/code&gt; 절로 인해 출력이 없으므로 쿼리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="652a8b18a910fe23a9af73c94ce5d441558f1e6b" translate="yes" xml:space="preserve">
          <source>In the examples above, the parser sees an integer array on one side of the concatenation operator, and a constant of undetermined type on the other. The heuristic it uses to resolve the constant's type is to assume it's of the same type as the operator's other input &amp;mdash; in this case, integer array. So the concatenation operator is presumed to represent &lt;code&gt;array_cat&lt;/code&gt;, not &lt;code&gt;array_append&lt;/code&gt;. When that's the wrong choice, it could be fixed by casting the constant to the array's element type; but explicit use of &lt;code&gt;array_append&lt;/code&gt; might be a preferable solution.</source>
          <target state="translated">위의 예에서 파서는 연결 연산자의 한쪽에 정수 배열이 있고 다른쪽에는 결정되지 않은 상수가 있습니다. 상수 유형을 확인하는 데 사용하는 휴리스틱은 연산자의 다른 입력 (이 경우 정수 배열)과 동일한 유형이라고 가정합니다. 따라서 연결 연산자는 &lt;code&gt;array_cat&lt;/code&gt; 가 아닌 &lt;code&gt;array_append&lt;/code&gt; 를 나타내는 것으로 간주됩니다 . 이것이 잘못된 선택 일 경우, 상수를 배열의 요소 유형으로 캐스팅하여 수정 될 수 있습니다. 그러나 &lt;code&gt;array_append&lt;/code&gt; 를 명시 적으로 사용 하는 것이 바람직한 해결책 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb28c6ea0190f478c6d1ce0ce5ab123177f2281" translate="yes" xml:space="preserve">
          <source>In the examples above, the policy expressions consider only the current values in the row to be accessed or updated. This is the simplest and best-performing case; when possible, it's best to design row security applications to work this way. If it is necessary to consult other rows or other tables to make a policy decision, that can be accomplished using sub-&lt;code&gt;SELECT&lt;/code&gt;s, or functions that contain &lt;code&gt;SELECT&lt;/code&gt;s, in the policy expressions. Be aware however that such accesses can create race conditions that could allow information leakage if care is not taken. As an example, consider the following table design:</source>
          <target state="translated">위의 예에서 정책 표현식은 행의 현재 값만 액세스하거나 업데이트 할 것으로 간주합니다. 가장 단순하고 가장 성능이 좋은 경우입니다. 가능하면 행 보안 응용 프로그램을 설계하여 이러한 방식으로 작동하는 것이 가장 좋습니다. 정책 결정을 위해 다른 행이나 다른 테이블을 참조해야하는 경우 정책 표현식에서 하위 &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;SELECT&lt;/code&gt; 가 포함 된 함수를 사용하여 수행 할 수 있습니다 . 그러나 그러한 액세스는주의를 기울이지 않으면 정보 유출을 허용 할 수있는 경쟁 조건을 만들 수 있습니다. 예를 들어, 다음 테이블 디자인을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2808c388963b5d35c9a7c014fc0aef8465d89479" translate="yes" xml:space="preserve">
          <source>In the examples that follow, we assume that you have created a database named &lt;code&gt;mydb&lt;/code&gt;, as described in the previous chapter, and have been able to start psql.</source>
          <target state="translated">다음 예 에서는 이전 장에서 설명한대로 &lt;code&gt;mydb&lt;/code&gt; 라는 데이터베이스를 작성했으며 psql을 시작할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="4bb59306b891fbea63056e89cb36560d344851b8" translate="yes" xml:space="preserve">
          <source>In the first case, the RE as a whole is greedy because &lt;code&gt;Y*&lt;/code&gt; is greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the longest possible string starting there, i.e., &lt;code&gt;Y123&lt;/code&gt;. The output is the parenthesized part of that, or &lt;code&gt;123&lt;/code&gt;. In the second case, the RE as a whole is non-greedy because &lt;code&gt;Y*?&lt;/code&gt; is non-greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the shortest possible string starting there, i.e., &lt;code&gt;Y1&lt;/code&gt;. The subexpression &lt;code&gt;[0-9]{1,3}&lt;/code&gt; is greedy but it cannot change the decision as to the overall match length; so it is forced to match just &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">첫 번째 경우, &lt;code&gt;Y*&lt;/code&gt; 가 탐욕 스럽기 때문에 RE 전체가 탐욕 스럽다. &lt;code&gt;Y&lt;/code&gt; 에서 시작하여 일치 할 수 있으며 &lt;code&gt;Y123&lt;/code&gt; 에서 시작하는 가장 긴 문자열과 일치합니다 . 출력은 괄호로 묶은 부분 또는 &lt;code&gt;123&lt;/code&gt; 입니다. 두 번째 경우, 전체 RE는 &lt;code&gt;Y*?&lt;/code&gt; 욕심이 없습니다. &lt;code&gt;Y&lt;/code&gt; 에서 시작하여 일치 할 수 있으며 &lt;code&gt;Y1&lt;/code&gt; 에서 시작하는 가장 짧은 문자열과 일치합니다 . 하위 식 &lt;code&gt;[0-9]{1,3}&lt;/code&gt; 은 욕심이 많지만 전체 일치 길이에 대한 결정을 변경할 수는 없습니다. 따라서 &lt;code&gt;1&lt;/code&gt; 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0afff82ca92cc5d65344944313d08b5825c3e875" translate="yes" xml:space="preserve">
          <source>In the first place, &lt;em&gt;never&lt;/em&gt; believe any test that runs for only a few seconds. Use the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-T&lt;/code&gt; option to make the run last at least a few minutes, so as to average out noise. In some cases you could need hours to get numbers that are reproducible. It's a good idea to try the test run a few times, to find out if your numbers are reproducible or not.</source>
          <target state="translated">우선, 몇 초 동안 만 실행되는 테스트는 &lt;em&gt;절대&lt;/em&gt; 믿지 &lt;em&gt;마십시오&lt;/em&gt; . 사용 &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;-T&lt;/code&gt; 그래서 평균 출력 잡음으로, 마지막으로 적어도 몇 분 실행할 수 있도록하는 옵션을 선택합니다. 어떤 경우에는 재현 가능한 숫자를 얻기 위해 몇 시간이 필요할 수 있습니다. 테스트 실행을 몇 번 시도하여 숫자를 재현 할 수 있는지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d312d02ebaa05f528de247ffd592135c96644932" translate="yes" xml:space="preserve">
          <source>In the first string, the set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt;. In the second string, the ordered set of trigrams is &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;. The most similar extent of an ordered set of trigrams in the second string is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt;, and the similarity is &lt;code&gt;0.8&lt;/code&gt;.</source>
          <target state="translated">첫 번째 문자열에서 트라이 그램 세트는 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt; 입니다. 두 번째 문자열에서 순서가 지정된 trigram은 &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; . 두 번째 문자열에서 순서가 지정된 트리 그램의 가장 유사한 범위는 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt; 이고 유사성은 &lt;code&gt;0.8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56225072f8eae4ad3b64ee516719e58b357f9e0a" translate="yes" xml:space="preserve">
          <source>In the following explanation, a &lt;em&gt;byte&lt;/em&gt; is assumed to contain 8 bits. In addition, the term &lt;em&gt;item&lt;/em&gt; refers to an individual data value that is stored on a page. In a table, an item is a row; in an index, an item is an index entry.</source>
          <target state="translated">다음 설명에서 &lt;em&gt;바이트&lt;/em&gt; 는 8 비트를 포함한다고 가정합니다. 또한 &lt;em&gt;항목&lt;/em&gt; 이라는 용어 는 페이지에 저장된 개별 데이터 값을 나타냅니다. 테이블에서 항목은 행입니다. 색인에서 항목은 색인 항목입니다.</target>
        </trans-unit>
        <trans-unit id="fe808d43052245254bcdc480fec58d6c194f111b" translate="yes" xml:space="preserve">
          <source>In the following sections we will cover each of the above listed items in more detail to give a better understanding of PostgreSQL's internal control and data structures.</source>
          <target state="translated">다음 섹션에서는 PostgreSQL의 내부 제어 및 데이터 구조에 대한 이해를 돕기 위해 위에 나열된 각 항목에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f022f75654e730419aa401f110023452d899d615" translate="yes" xml:space="preserve">
          <source>In the following we describe the implementation of a &lt;em&gt;genetic algorithm&lt;/em&gt; to solve the join ordering problem in a manner that is efficient for queries involving large numbers of joins.</source>
          <target state="translated">다음에서는 많은 수의 조인을 포함하는 쿼리에 효율적인 방식으로 조인 순서 문제를 해결하기 위한 &lt;em&gt;유전자 알고리즘&lt;/em&gt; 의 구현에 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="294ebe645001a682897e9beebf5caf16a1bf1ca5" translate="yes" xml:space="preserve">
          <source>In the general case where more than one field needs to be checked to recognize a cycle, use an array of rows. For example, if we needed to compare fields &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;:</source>
          <target state="translated">사이클을 인식하기 위해 둘 이상의 필드를 점검해야하는 일반적인 경우에는 행 배열을 사용하십시오. 예를 들어, 필드 &lt;code&gt;f1&lt;/code&gt; 과 &lt;code&gt;f2&lt;/code&gt; 를 비교해야하는 경우 :</target>
        </trans-unit>
        <trans-unit id="919090babfd7b1e0453e16ae1bb909dd12feef28" translate="yes" xml:space="preserve">
          <source>In the old syntax for &lt;code&gt;CREATE AGGREGATE&lt;/code&gt;, the input data type is specified by a &lt;code&gt;basetype&lt;/code&gt; parameter rather than being written next to the aggregate name. Note that this syntax allows only one input parameter. To define a zero-argument aggregate function with this syntax, specify the &lt;code&gt;basetype&lt;/code&gt; as &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; (not &lt;code&gt;*&lt;/code&gt;). Ordered-set aggregates cannot be defined with the old syntax.</source>
          <target state="translated">&lt;code&gt;CREATE AGGREGATE&lt;/code&gt; 의 이전 구문 에서 입력 데이터 유형은 집계 이름 옆에 기록되지 않고 &lt;code&gt;basetype&lt;/code&gt; 유형 매개 변수로 지정됩니다 . 이 구문은 하나의 입력 매개 변수 만 허용합니다. 이 구문을 사용하여 &lt;code&gt;basetype&lt;/code&gt; 집계 함수를 정의하려면 기본 유형 을 &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; ( &lt;code&gt;*&lt;/code&gt; 아님) 로 지정하십시오 아님) . 정렬 된 집합은 이전 구문으로 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="405922ab6e8351d0cf2aca13f11379b1afd63c78" translate="yes" xml:space="preserve">
          <source>In the previous chapter we have covered the basics of using SQL to store and access your data in PostgreSQL. We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your data. Finally, we will look at some PostgreSQL extensions.</source>
          <target state="translated">이전 장에서는 SQL을 사용하여 PostgreSQL에서 데이터를 저장하고 액세스하는 기본 사항을 설명했습니다. 이제 관리를 단순화하고 데이터 손실 또는 손상을 방지하는 SQL의 고급 기능에 대해 설명합니다. 마지막으로 PostgreSQL 확장에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a8c0fa4c3a367177ef284ccecde1c150bc096697" translate="yes" xml:space="preserve">
          <source>In the previous example, we can apply the city name restriction in &lt;code&gt;WHERE&lt;/code&gt;, since it needs no aggregate. This is more efficient than adding the restriction to &lt;code&gt;HAVING&lt;/code&gt;, because we avoid doing the grouping and aggregate calculations for all rows that fail the &lt;code&gt;WHERE&lt;/code&gt; check.</source>
          <target state="translated">이전 예에서는 집계가 필요하지 않으므로 도시 이름 제한을 &lt;code&gt;WHERE&lt;/code&gt; 로 적용 할 수 있습니다 . &lt;code&gt;WHERE&lt;/code&gt; 검사에 실패한 모든 행에 대해 그룹화 및 집계 계산을 수행하지 않으므로 &lt;code&gt;HAVING&lt;/code&gt; 에 제한을 추가하는 것보다이 방법이 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="9f29ede0900e9fd39d495275c897cbd33557a707" translate="yes" xml:space="preserve">
          <source>In the previous sections we created tables without specifying any schema names. By default such tables (and other objects) are automatically put into a schema named &amp;ldquo;public&amp;rdquo;. Every new database contains such a schema. Thus, the following are equivalent:</source>
          <target state="translated">이전 섹션에서는 스키마 이름을 지정하지 않고 테이블을 만들었습니다. 기본적으로 이러한 테이블 (및 기타 개체)은 &quot;public&quot;이라는 스키마에 자동으로 저장됩니다. 모든 새 데이터베이스에는 이러한 스키마가 포함됩니다. 따라서 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0e8d742b91769afdfb8fcfcc89d91cd8ba42839b" translate="yes" xml:space="preserve">
          <source>In the remote sessions opened by &lt;code&gt;postgres_fdw&lt;/code&gt;, the &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; parameter is set to just &lt;code&gt;pg_catalog&lt;/code&gt;, so that only built-in objects are visible without schema qualification. This is not an issue for queries generated by &lt;code&gt;postgres_fdw&lt;/code&gt; itself, because it always supplies such qualification. However, this can pose a hazard for functions that are executed on the remote server via triggers or rules on remote tables. For example, if a remote table is actually a view, any functions used in that view will be executed with the restricted search path. It is recommended to schema-qualify all names in such functions, or else attach &lt;code&gt;SET search_path&lt;/code&gt; options (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;) to such functions to establish their expected search path environment.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 에 의해 열린 원격 세션 에서 &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; 매개 변수는 &lt;code&gt;pg_catalog&lt;/code&gt; 로 설정되어 내장 된 객체 만 스키마 검증없이 볼 수 있습니다. &lt;code&gt;postgres_fdw&lt;/code&gt; 자체에 의해 생성 된 쿼리는 항상 그러한 자격을 제공하기 때문에 문제가되지 않습니다 . 그러나 이는 원격 테이블의 트리거 또는 규칙을 통해 원격 서버에서 실행되는 기능에 위험을 초래할 수 있습니다. 예를 들어, 원격 테이블이 실제로 뷰인 경우 해당 뷰에 사용 된 모든 함수는 제한된 검색 경로로 실행됩니다. 이러한 함수에서 모든 이름을 스키마로 한정하거나 &lt;code&gt;SET search_path&lt;/code&gt; 옵션을 첨부하는 것이 좋습니다 ( &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 참조). 를 해당 함수에 하여 예상 검색 경로 환경을 설정하는 .</target>
        </trans-unit>
        <trans-unit id="251756f685410e433b657f5b30520cf41b101c14" translate="yes" xml:space="preserve">
          <source>In the same connection as before, issue the command:</source>
          <target state="translated">이전과 동일한 연결로 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9a85cd84a5c1ae886a05b3cc6a64ec7fb7c99a58" translate="yes" xml:space="preserve">
          <source>In the second form of &lt;code&gt;ALTER POLICY&lt;/code&gt;, the role list, &lt;code&gt;using_expression&lt;/code&gt;, and &lt;code&gt;check_expression&lt;/code&gt; are replaced independently if specified. When one of those clauses is omitted, the corresponding part of the policy is unchanged.</source>
          <target state="translated">&lt;code&gt;ALTER POLICY&lt;/code&gt; 의 두 번째 양식 에서 역할 목록, &lt;code&gt;using_expression&lt;/code&gt; 및 &lt;code&gt;check_expression&lt;/code&gt; 은 지정된 경우 독립적으로 바뀝니다. 이러한 조항 중 하나가 생략되면 정책의 해당 부분이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c142401003467ed2967cc5251153e2a0bab24fa" translate="yes" xml:space="preserve">
          <source>In the second mode, which we will call the search+bind mode, the server first binds to the LDAP directory with a fixed user name and password, specified with &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt;, and performs a search for the user trying to log in to the database. If no user and password is configured, an anonymous bind will be attempted to the directory. The search will be performed over the subtree at &lt;code&gt;ldapbasedn&lt;/code&gt;, and will try to do an exact match of the attribute specified in &lt;code&gt;ldapsearchattribute&lt;/code&gt;. Once the user has been found in this search, the server disconnects and re-binds to the directory as this user, using the password specified by the client, to verify that the login is correct. This mode is the same as that used by LDAP authentication schemes in other software, such as Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; and &lt;code&gt;pam_ldap&lt;/code&gt;. This method allows for significantly more flexibility in where the user objects are located in the directory, but will cause two separate connections to the LDAP server to be made.</source>
          <target state="translated">검색 + 바인드 모드를 호출하는 두 번째 모드에서 서버는 먼저 &lt;code&gt;ldapbinddn&lt;/code&gt; 및 &lt;code&gt;ldapbindpasswd&lt;/code&gt; 로 지정된 고정 사용자 이름 및 비밀번호를 사용하여 LDAP 디렉토리에 바인드 하고 로그인하려는 사용자를 검색합니다. 데이터 베이스. 사용자 및 비밀번호가 구성되지 않은 경우 디렉토리에 대한 익명 바인드가 시도됩니다. 검색은 &lt;code&gt;ldapbasedn&lt;/code&gt; 의 서브 트리에서 수행 되며 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 에 지정된 속성과 정확히 일치하도록 시도합니다.. 이 검색에서 사용자를 찾으면 서버는 클라이언트가 지정한 비밀번호를 사용하여 연결을 끊고이 사용자로 디렉토리에 다시 바인딩하여 로그인이 올바른지 확인합니다. 이 모드는 Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; 및 &lt;code&gt;pam_ldap&lt;/code&gt; 와 같은 다른 소프트웨어의 LDAP 인증 체계에서 사용하는 것과 동일 합니다. 이 방법을 사용하면 사용자 객체가 디렉토리에있는 위치에서 훨씬 더 융통성이 있지만 LDAP 서버에 대한 두 개의 개별 연결이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="138833bfe13a3d8412530f69bb62c741e625ccde" translate="yes" xml:space="preserve">
          <source>In the second query, we could not have written &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt;, because there is no single value for the column &lt;code&gt;y&lt;/code&gt; that could be associated with each group. The grouped-by columns can be referenced in the select list since they have a single value in each group.</source>
          <target state="translated">두 번째 쿼리에서는 각 그룹과 연관 될 수있는 열 &lt;code&gt;y&lt;/code&gt; 에 대한 단일 값이 없으므로 &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt; 쓸 수 없습니다 . 그룹화 기준 컬럼은 각 그룹에 단일 값이 있으므로 선택 목록에서 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f53fb06ae3c0e076406bae29678cb14017000e" translate="yes" xml:space="preserve">
          <source>In the standard, it is not necessary to issue &lt;code&gt;START TRANSACTION&lt;/code&gt; to start a transaction block: any SQL command implicitly begins a block. PostgreSQL's behavior can be seen as implicitly issuing a &lt;code&gt;COMMIT&lt;/code&gt; after each command that does not follow &lt;code&gt;START TRANSACTION&lt;/code&gt; (or &lt;code&gt;BEGIN&lt;/code&gt;), and it is therefore often called &amp;ldquo;autocommit&amp;rdquo;. Other relational database systems might offer an autocommit feature as a convenience.</source>
          <target state="translated">표준에서 트랜잭션 블록을 시작하기 위해 &lt;code&gt;START TRANSACTION&lt;/code&gt; 을 발행 할 필요는 없습니다 . SQL 명령은 암시 적으로 블록을 시작합니다. PostgreSQL의 동작은 &lt;code&gt;START TRANSACTION&lt;/code&gt; (또는 &lt;code&gt;BEGIN&lt;/code&gt; )을 따르지 않는 각 명령 후에 암시 적으로 &lt;code&gt;COMMIT&lt;/code&gt; 를 발행하는 것으로 볼 수 있으므로 종종 &quot;자동 커밋&quot;이라고합니다. 다른 관계형 데이터베이스 시스템은 편의상 자동 커밋 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="127829a1cca08de1cd77d4d1d0c73fe0bf22ed39" translate="yes" xml:space="preserve">
          <source>In the standard, the &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; clause is required; in PostgreSQL it is optional.</source>
          <target state="translated">표준에서 &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; 절이 필요합니다. PostgreSQL에서는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7f27aa8e0141e367b925aa8c528ef6250799f203" translate="yes" xml:space="preserve">
          <source>In the strict mode, the specified path must exactly match the structure of the queried JSON document to return an SQL/JSON item, so using this path expression will cause an error. To get the same result as in the lax mode, you have to explicitly unwrap the &lt;code&gt;segments&lt;/code&gt; array:</source>
          <target state="translated">엄격 모드에서 지정된 경로는 쿼리 된 JSON 문서의 구조와 정확히 일치해야 SQL / JSON 항목을 리턴하므로이 경로 표현식을 사용하면 오류가 발생합니다. lax 모드에서와 동일한 결과를 얻으려면 &lt;code&gt;segments&lt;/code&gt; 배열 을 명시 적으로 랩 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="351d4063e5553403441da5e92374ad1230527978" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; 구문 에서 키워드 &lt;code&gt;FUNCTION&lt;/code&gt; 및 &lt;code&gt;PROCEDURE&lt;/code&gt; 는 동일하지만 참조 된 함수는 어쨌든 프로 시저가 아닌 함수 여야합니다. 여기서 &lt;code&gt;PROCEDURE&lt;/code&gt; 키워드를 사용하는 것은 과거와 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78472b8a63814954829d3aaff5becf4efc83edf2" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE OPERATOR&lt;/code&gt; 구문 에서 키워드 &lt;code&gt;FUNCTION&lt;/code&gt; 및 &lt;code&gt;PROCEDURE&lt;/code&gt; 는 동일하지만 참조 된 함수는 어쨌든 프로 시저가 아닌 함수 여야합니다. 여기서 &lt;code&gt;PROCEDURE&lt;/code&gt; 키워드를 사용하는 것은 과거와 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57ba8dd34e548ca54ffce2f60f391e867e594c9e" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; 구문 에서 키워드 &lt;code&gt;FUNCTION&lt;/code&gt; 및 &lt;code&gt;PROCEDURE&lt;/code&gt; 는 동일하지만 참조 된 함수는 어쨌든 프로 시저가 아닌 함수 여야합니다. 여기서 &lt;code&gt;PROCEDURE&lt;/code&gt; 키워드를 사용하는 것은 과거와 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9e4c8cc0471f863f66674a10b7573f32e28c279" translate="yes" xml:space="preserve">
          <source>In the text form of a range, an inclusive lower bound is represented by &amp;ldquo;&lt;code&gt;[&lt;/code&gt;&amp;rdquo; while an exclusive lower bound is represented by &amp;ldquo;&lt;code&gt;(&lt;/code&gt;&amp;rdquo;. Likewise, an inclusive upper bound is represented by &amp;ldquo;&lt;code&gt;]&lt;/code&gt;&amp;rdquo;, while an exclusive upper bound is represented by &amp;ldquo;&lt;code&gt;)&lt;/code&gt;&amp;rdquo;. (See &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;Section 8.17.5&lt;/a&gt; for more details.)</source>
          <target state="translated">범위의 텍스트 형식에서 포함 하한은 &quot; &lt;code&gt;[&lt;/code&gt; &quot;로 표시되고 배타 하한은 &quot; &lt;code&gt;(&lt;/code&gt; &quot;로 표시됩니다 . 마찬가지로 포함 상한은 &quot; &lt;code&gt;]&lt;/code&gt; &quot;로 표시되고 배타적 상한은 &quot;&quot;로 표시됩니다. &quot;에 의해 &lt;code&gt;)&lt;/code&gt; &quot;. (자세한 내용 &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;은 8.17.5 절&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="87e71fe4fdbdcfebf301c0661fd38f3ccfa52a22" translate="yes" xml:space="preserve">
          <source>In the verbose input format, and in some fields of the more compact input formats, field values can have fractional parts; for example &lt;code&gt;'1.5 week'&lt;/code&gt; or &lt;code&gt;'01:02:03.45'&lt;/code&gt;. Such input is converted to the appropriate number of months, days, and seconds for storage. When this would result in a fractional number of months or days, the fraction is added to the lower-order fields using the conversion factors 1 month = 30 days and 1 day = 24 hours. For example, &lt;code&gt;'1.5 month'&lt;/code&gt; becomes 1 month and 15 days. Only seconds will ever be shown as fractional on output.</source>
          <target state="translated">자세한 입력 형식 및보다 간단한 입력 형식의 일부 필드에서 필드 값은 소수 부분을 가질 수 있습니다. 예를 들어 &lt;code&gt;'1.5 week'&lt;/code&gt; 또는 &lt;code&gt;'01:02:03.45'&lt;/code&gt; 입니다. 이러한 입력은 저장을 위해 적절한 월, 일 및 초 수로 변환됩니다. 이로 인해 소수의 월 또는 일이 발생하는 경우 전환 계수 1 개월 = 30 일 및 1 일 = 24 시간을 사용하여 분수가 하위 필드에 추가됩니다. 예를 들어 &lt;code&gt;'1.5 month'&lt;/code&gt; 은 1 개월 15 일이됩니다. 출력에서는 초만 분수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="352c1b7bd2689ed0c741aae1f8598e4432b2e419" translate="yes" xml:space="preserve">
          <source>In the world of measurements, 6.50 is not the same as 6.5. It may sometimes be critically different. The experimenters usually write down (and publish) the digits they trust. 6.50 is actually a fuzzy interval contained within a bigger and even fuzzier interval, 6.5, with their center points being (probably) the only common feature they share. We definitely do not want such different data items to appear the same.</source>
          <target state="translated">측정 세계에서 6.50은 6.5와 동일하지 않습니다. 때로는 비판적으로 다를 수 있습니다. 실험자들은 일반적으로 그들이 신뢰하는 숫자를 기록 (및 게시)합니다. 6.50은 실제로 더 큰 퍼지 간격 (6.5) 내에 포함 된 퍼지 간격으로, 중심점은 (아마도) 공유하는 유일한 공통 기능입니다. 우리는 분명히 다른 데이터 항목이 동일하게 표시되는 것을 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d16185ffce558efd6646fae1f89738ca57d3dd9c" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text string (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">이 표현에서 원하는 시간대 &lt;code&gt;zone&lt;/code&gt; 텍스트 문자열로 중 하나를 지정할 수 있습니다 (예를 들어, &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ) 또는 간격 (예를 들어, 같은 &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; ). 텍스트의 경우 표준 시간대 이름은 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3 섹션에&lt;/a&gt; 설명 된 방법 중 하나로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13d5bca14d2cfde080255e10973a28114214ea10" translate="yes" xml:space="preserve">
          <source>In this case the parser looks to see if there is an operator taking &lt;code&gt;text&lt;/code&gt; for both arguments. Since there is, it assumes that the second argument should be interpreted as type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">이 경우 파서는 두 인수 모두에 대해 &lt;code&gt;text&lt;/code&gt; 를 취하는 연산자가 있는지 확인합니다 . 이 때문에 두 번째 인수는 &lt;code&gt;text&lt;/code&gt; 유형으로 해석되어야한다고 가정 합니다 .</target>
        </trans-unit>
        <trans-unit id="d2822670753f6c1107e46ff79d0892389494ad1a" translate="yes" xml:space="preserve">
          <source>In this case there is no MCV information for &lt;code&gt;unique2&lt;/code&gt; because all the values appear to be unique, so we use an algorithm that relies only on the number of distinct values for both relations together with their null fractions:</source>
          <target state="translated">이 경우 &lt;code&gt;unique2&lt;/code&gt; 에 대한 MCV 정보가 없습니다. 모든 값이 고유 한 것으로 보이므로 두 관계에 대한 고유 값의 수와 null 비율 만 사용하는 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="454dfb68a36b15232f0a47fef88c353fb8b457de" translate="yes" xml:space="preserve">
          <source>In this case there is no initial hint for which type to use, since no types are specified in the query. So, the parser looks for all candidate operators and finds that there are candidates accepting both string-category and bit-string-category inputs. Since string category is preferred when available, that category is selected, and then the preferred type for strings, &lt;code&gt;text&lt;/code&gt;, is used as the specific type to resolve the unknown-type literals as.</source>
          <target state="translated">이 경우 쿼리에 형식이 지정되어 있지 않으므로 사용할 형식에 대한 초기 힌트가 없습니다. 따라서 파서는 모든 후보 연산자를 찾고 문자열 범주 및 비트 문자열 범주 입력을 모두 허용하는 후보가 있음을 찾습니다. 사용 가능한 경우 문자열 범주가 선호되므로 해당 범주가 선택된 다음 문자열에 대한 기본 유형 인 &lt;code&gt;text&lt;/code&gt; 가 알 수없는 유형 리터럴을 확인하는 특정 유형으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="643fc82591ff3cc1a1f002cde4bff205b2405706" translate="yes" xml:space="preserve">
          <source>In this case, a regular user cannot reference &lt;code&gt;customer.credit&lt;/code&gt; directly, but a trusted procedure &lt;code&gt;show_credit&lt;/code&gt; allows the user to print the credit card numbers of customers with some of the digits masked out.</source>
          <target state="translated">이 경우 일반 사용자는 &lt;code&gt;customer.credit&lt;/code&gt; 를 직접 참조 할 수 없지만 신뢰할 수있는 프로 시저 &lt;code&gt;show_credit&lt;/code&gt; 를 사용하면 일부 숫자가 마스킹 된 고객의 신용 카드 번호를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d737c289d22cb958cf827fb7f26271e5be10a1e7" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;altitude&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. State capitals have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">이 경우의 행 &lt;code&gt;capitals&lt;/code&gt; &lt;em&gt;상속&lt;/em&gt; 모든 열 ( &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;population&lt;/code&gt; , 그리고 &lt;code&gt;altitude&lt;/code&gt; 의에서) &lt;em&gt;부모&lt;/em&gt; , &lt;code&gt;cities&lt;/code&gt; . 열 &lt;code&gt;name&lt;/code&gt; 의 유형 은 &lt;code&gt;text&lt;/code&gt; , 가변 길이 문자열에 대한 기본 PostgreSQL의 유형입니다. 국가의 수도는 여분의 열이 &lt;code&gt;state&lt;/code&gt; , 그 프로그램의 상태를. PostgreSQL에서 테이블은 0 개 이상의 다른 테이블에서 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="613ba4c32d099503d94bd47a030a2a2ad44892dd" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;capitals&lt;/code&gt; table &lt;em&gt;inherits&lt;/em&gt; all the columns of its parent table, &lt;code&gt;cities&lt;/code&gt;. State capitals also have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state.</source>
          <target state="translated">이 경우, &lt;code&gt;capitals&lt;/code&gt; 테이블 &lt;em&gt;상속&lt;/em&gt; 부모 테이블의 모든 열 &lt;code&gt;cities&lt;/code&gt; . 국가의 수도는 여분의 열이 &lt;code&gt;state&lt;/code&gt; , 그 프로그램의 상태를.</target>
        </trans-unit>
        <trans-unit id="af318a98fb799d225d9e923e2e4473ff3043a3f6" translate="yes" xml:space="preserve">
          <source>In this configuration, the sample &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; above takes 115.9 ms. That's 1061 ns of timing overhead, again a small multiple of what's measured directly by this utility. That much timing overhead means the actual query itself is only taking a tiny fraction of the accounted for time, most of it is being consumed in overhead instead. In this configuration, any &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; totals involving many timed operations would be inflated significantly by timing overhead.</source>
          <target state="translated">이 구성에서 샘플 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 위 는 115.9ms가 걸립니다. 이는 1061ns의 타이밍 오버 헤드이며,이 유틸리티에서 직접 측정 한 것의 작은 배수입니다. 타이밍 오버 헤드가 너무 크다는 것은 실제 쿼리 자체가 시간을 거의 고려하지 않고 대부분 오버 헤드로 소비되고 있음을 의미합니다. 이 구성에서 많은 시간이 지정된 작업과 관련된 모든 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 총계는 타이밍 오버 헤드에 의해 크게 팽창됩니다.</target>
        </trans-unit>
        <trans-unit id="abed36bdd05542db8e718c1091a76817a77d802e" translate="yes" xml:space="preserve">
          <source>In this example above we were allowed to switch from the larger MCS range &lt;code&gt;c1.c1023&lt;/code&gt; to the smaller range &lt;code&gt;c1.c4&lt;/code&gt;, but switching back was denied.</source>
          <target state="translated">위의 예에서 우리는 더 큰 MCS 범위 &lt;code&gt;c1.c1023&lt;/code&gt; 에서 더 작은 범위 로 전환 할 수있었습니다 &lt;code&gt;c1.c4&lt;/code&gt; 로 전환 할 수 있었지만 다시 전환은 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7326012a121c41d2c47ed971d8505d7a7de76bf" translate="yes" xml:space="preserve">
          <source>In this example the Update node needs to consider three child tables as well as the originally-mentioned parent table. So there are four input scanning subplans, one per table. For clarity, the Update node is annotated to show the specific target tables that will be updated, in the same order as the corresponding subplans. (These annotations are new as of PostgreSQL 9.5; in prior versions the reader had to intuit the target tables by inspecting the subplans.)</source>
          <target state="translated">이 예에서 업데이트 노드는 원래 언급 된 상위 테이블뿐만 아니라 3 개의 하위 테이블을 고려해야합니다. 따라서 테이블 당 하나씩 4 개의 입력 스캐닝 하위 계획이 있습니다. 명확하게하기 위해 업데이트 노드에는 해당 하위 계획과 동일한 순서로 업데이트 될 특정 대상 테이블을 표시하도록 주석이 달립니다. (이 주석은 PostgreSQL 9.5부터 새로 추가되었습니다. 이전 버전에서는 독자가 하위 계획을 검사하여 대상 테이블을 작성해야했습니다.)</target>
        </trans-unit>
        <trans-unit id="90020459ceef361caea70168cdc85c26559a0eb6" translate="yes" xml:space="preserve">
          <source>In this example the join's output row count is the same as the product of the two scans' row counts, but that's not true in all cases because there can be additional &lt;code&gt;WHERE&lt;/code&gt; clauses that mention both tables and so can only be applied at the join point, not to either input scan. Here's an example:</source>
          <target state="translated">이 예에서 조인의 출력 행 수는 두 스캔의 행 수의 곱과 동일하지만 두 테이블을 모두 언급하는 추가 &lt;code&gt;WHERE&lt;/code&gt; 절이 있을 수 있으므로 조인 지점에서만 적용 할 수 있기 때문에 모든 경우에 해당되지 않습니다. 입력 스캔이 아닙니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f68e5dbd48ccbde70e786ec3f6ee97430aeb6b1e" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;(none)&lt;/code&gt;, null is returned, otherwise the value of &lt;code&gt;value&lt;/code&gt; is returned.</source>
          <target state="translated">이 예에서 &lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;(none)&lt;/code&gt; 이면 null이 반환되고, 그렇지 않으면 value &lt;code&gt;value&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6956c57a06842052520c448c372cfcf4ca7298a5" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, the two standbys &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; will be chosen as synchronous standbys because their names appear early in the list of standby names. &lt;code&gt;s3&lt;/code&gt; is a potential synchronous standby and will take over the role of synchronous standby when either of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; fails. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">이 예제에서 4 개의 대기 서버 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; 및 &lt;code&gt;s4&lt;/code&gt; 가 실행중인 경우 두 대기 &lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 는 이름이 대기 이름 목록의 초기에 나타나기 때문에 동기 대기로 선택됩니다. &lt;code&gt;s3&lt;/code&gt; 은 잠재적 인 동기 대기이며 &lt;code&gt;s1&lt;/code&gt; 또는 &lt;code&gt;s2&lt;/code&gt; 중 하나 가 실패하면 동기 대기의 역할을 대신 합니다. &lt;code&gt;s4&lt;/code&gt; 는 이름이 목록에 없기 때문에 비동기 대기입니다.</target>
        </trans-unit>
        <trans-unit id="5ecb1dc9291b661bf70c843bbe812e41c22f83de" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, transaction commits will wait for replies from at least any two standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; and &lt;code&gt;s3&lt;/code&gt;. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">이 예제에서 4 개의 대기 서버 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; 및 &lt;code&gt;s4&lt;/code&gt; 가 실행중인 경우 트랜잭션 커미트는 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; 및 &lt;code&gt;s3&lt;/code&gt; 중 적어도 두 개의 대기에서 응답을 기다립니다 . &lt;code&gt;s4&lt;/code&gt; 는 이름이 목록에 없기 때문에 비동기 대기입니다.</target>
        </trans-unit>
        <trans-unit id="52a2cd0a65091e20d376dc71b4672a80c22c4d96" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;TEMPLATE template0&lt;/code&gt; clause is required if the specified locale is different from the one in &lt;code&gt;template1&lt;/code&gt;. (If it is not, then specifying the locale explicitly is redundant.)</source>
          <target state="translated">이 예제 에서 지정된 로케일이 &lt;code&gt;template1&lt;/code&gt; 의 것과 다른 경우 &lt;code&gt;TEMPLATE template0&lt;/code&gt; 절이 필요합니다. . 그렇지 않은 경우 로케일을 명시 적으로 지정하면 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="8c5f7d8e9b592b4d5a3f718483f7acd727a00e09" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;len&lt;/code&gt; column is omitted and therefore it will have the default value:</source>
          <target state="translated">이 예에서 &lt;code&gt;len&lt;/code&gt; 열은 생략되므로 기본값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3694c54d9cfcf70eda6933c152be42b7c937c601" translate="yes" xml:space="preserve">
          <source>In this example, the columns &lt;code&gt;product_id&lt;/code&gt;, &lt;code&gt;p.name&lt;/code&gt;, and &lt;code&gt;p.price&lt;/code&gt; must be in the &lt;code&gt;GROUP BY&lt;/code&gt; clause since they are referenced in the query select list (but see below). The column &lt;code&gt;s.units&lt;/code&gt; does not have to be in the &lt;code&gt;GROUP BY&lt;/code&gt; list since it is only used in an aggregate expression (&lt;code&gt;sum(...)&lt;/code&gt;), which represents the sales of a product. For each product, the query returns a summary row about all sales of the product.</source>
          <target state="translated">이 예에서 &lt;code&gt;product_id&lt;/code&gt; , &lt;code&gt;p.name&lt;/code&gt; 및 &lt;code&gt;p.price&lt;/code&gt; 열 은 쿼리 선택 목록에서 참조되므로 &lt;code&gt;GROUP BY&lt;/code&gt; 절 에 있어야 합니다 (아래 참조). &lt;code&gt;s.units&lt;/code&gt; 열 은 제품의 판매량을 나타내는 집계 표현식 ( &lt;code&gt;sum(...)&lt;/code&gt; ) 에만 사용되므로 &lt;code&gt;GROUP BY&lt;/code&gt; 목록 에있을 필요는 없습니다 . 각 제품에 대해 쿼리는 제품의 모든 판매에 대한 요약 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08a0e2d4d5bc94672e2506daf9e09dfe471fae09" translate="yes" xml:space="preserve">
          <source>In this example, the data type of the second parameter is not specified, so it is inferred from the context in which &lt;code&gt;$2&lt;/code&gt; is used.</source>
          <target state="translated">이 예에서는 두 번째 매개 변수의 데이터 유형이 지정되지 않았으므로 &lt;code&gt;$2&lt;/code&gt; 가 사용되는 컨텍스트에서 추론 됩니다.</target>
        </trans-unit>
        <trans-unit id="9ecac118ba12d038d39cec07567975d6d66efcef" translate="yes" xml:space="preserve">
          <source>In this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do:</source>
          <target state="translated">이 예에서는 정렬 순서가 완전히 지정되지 않았으므로 샌프란시스코 행을 어느 순서로나 가져올 수 있습니다. 그러나 다음과 같은 경우 항상 위의 결과가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="afe2100b24dbf1294da5f781636d42d62e4bc563" translate="yes" xml:space="preserve">
          <source>In this example, the word &lt;code&gt;Brightest&lt;/code&gt; was recognized by the parser as an &lt;code&gt;ASCII word&lt;/code&gt; (alias &lt;code&gt;asciiword&lt;/code&gt;). For this token type the dictionary list is &lt;code&gt;english_ispell&lt;/code&gt; and &lt;code&gt;english_stem&lt;/code&gt;. The word was recognized by &lt;code&gt;english_ispell&lt;/code&gt;, which reduced it to the noun &lt;code&gt;bright&lt;/code&gt;. The word &lt;code&gt;supernovaes&lt;/code&gt; is unknown to the &lt;code&gt;english_ispell&lt;/code&gt; dictionary so it was passed to the next dictionary, and, fortunately, was recognized (in fact, &lt;code&gt;english_stem&lt;/code&gt; is a Snowball dictionary which recognizes everything; that is why it was placed at the end of the dictionary list).</source>
          <target state="translated">이 예에서 &lt;code&gt;Brightest&lt;/code&gt; 라는 단어 는 파서에서 &lt;code&gt;ASCII word&lt;/code&gt; (별칭 &lt;code&gt;asciiword&lt;/code&gt; ) 로 인식되었습니다 . 이 토큰 유형의 사전 목록은 &lt;code&gt;english_ispell&lt;/code&gt; 및 &lt;code&gt;english_stem&lt;/code&gt; 입니다. 이 단어는 &lt;code&gt;english_ispell&lt;/code&gt; 에 의해 인식되었으며 ,이를 명사 &lt;code&gt;bright&lt;/code&gt; 였습니다. 단어 &lt;code&gt;supernovaes&lt;/code&gt; 는 알 수없는입니다 &lt;code&gt;english_ispell&lt;/code&gt; 사전이 다행히 (사실, 인정되었다, 다음 사전에 전달하고, 그래서 &lt;code&gt;english_stem&lt;/code&gt; 이 모든 것을 인식하는 눈덩이 사전이며,이 사전 목록의 끝에 배치 된 이유입니다 ).</target>
        </trans-unit>
        <trans-unit id="3c50776020e0abdc78addf8fd7c7082700a16f21" translate="yes" xml:space="preserve">
          <source>In this example, transaction 82 was late, because its latency (6.173 ms) was over the 5 ms limit. The next two transactions were skipped, because they were already late before they were even started.</source>
          <target state="translated">이 예에서 지연 시간 (6.173ms)이 5ms 제한을 초과했기 때문에 트랜잭션 82가 늦었습니다. 다음 두 트랜잭션은 시작하기 전에 이미 늦었 기 때문에 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="630dd124cc8b0f85590f44f07e341462147cb0a6" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dit&lt;/code&gt; lists indexes and tables. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its physical size on disk and its associated description, if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">이 명령 그룹에서 문자 &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 각각 외부 테이블, 인덱스, 구체화 된 뷰, 시퀀스, 테이블 및 뷰를 나타냅니다. 이러한 문자 중 일부 또는 전부를 임의의 순서로 지정하여 이러한 유형의 개체 목록을 얻을 수 있습니다. 예를 들어, &lt;code&gt;\dit&lt;/code&gt; 는 인덱스와 테이블을 나열합니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되어, 각 개체는 디스크의 물리적 크기와 관련 설명 (있는 경우)로 나열됩니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 패턴과 일치하는 나열되어 객체. 기본적으로 사용자가 만든 개체 만 표시됩니다. 패턴 또는 &lt;code&gt;S&lt;/code&gt; 를 공급 시스템 객체를 포함하는 수정 자.</target>
        </trans-unit>
        <trans-unit id="76a2e5dcbe213e98e1493b7e930a93660a65d1fc" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">이 모듈에서 지구는 완전히 구형 인 것으로 가정합니다. (너무 정확하지 않은 경우 &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; 프로젝트 를 볼 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="fdbad3a8ee3be25a94e567ee2f1c55ff6b62875e" translate="yes" xml:space="preserve">
          <source>In this particular example, the correction from the MCV list is fairly small, because the column distribution is actually quite flat (the statistics showing these particular values as being more common than others are mostly due to sampling error). In a more typical case where some values are significantly more common than others, this complicated process gives a useful improvement in accuracy because the selectivity for the most common values is found exactly.</source>
          <target state="translated">이 특정 예에서 열 분포가 실제로 매우 평탄하기 때문에 MCV 목록의 수정은 상당히 작습니다 (이러한 특정 값을 다른 값보다 일반적으로 표시하는 통계는 대부분 샘플링 오류로 인한 것입니다). 일부 값이 다른 값보다 훨씬 더 일반적인 경우에이 복잡한 프로세스는 가장 일반적인 값의 선택성이 정확하게 발견되므로 정확도가 유용하게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="35b50273596d3b9b0a5ab879d1dff2a027177930" translate="yes" xml:space="preserve">
          <source>In this plan, we have a nested-loop join node with two table scans as inputs, or children. The indentation of the node summary lines reflects the plan tree structure. The join's first, or &amp;ldquo;outer&amp;rdquo;, child is a bitmap scan similar to those we saw before. Its cost and row count are the same as we'd get from &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; because we are applying the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; at that node. The &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; clause is not relevant yet, so it doesn't affect the row count of the outer scan. The nested-loop join node will run its second, or &amp;ldquo;inner&amp;rdquo; child once for each row obtained from the outer child. Column values from the current outer row can be plugged into the inner scan; here, the &lt;code&gt;t1.unique2&lt;/code&gt; value from the outer row is available, so we get a plan and costs similar to what we saw above for a simple &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case. (The estimated cost is actually a bit lower than what was seen above, as a result of caching that's expected to occur during the repeated index scans on &lt;code&gt;t2&lt;/code&gt;.) The costs of the loop node are then set on the basis of the cost of the outer scan, plus one repetition of the inner scan for each outer row (10 * 7.91, here), plus a little CPU time for join processing.</source>
          <target state="translated">이 계획에서는 입력으로 두 개의 테이블 스캔 또는 하위가있는 중첩 루프 조인 노드가 있습니다. 노드 요약 라인의 들여 쓰기는 계획 트리 구조를 반영합니다. 조인의 첫 번째 또는 &quot;외부&quot;자식은 이전에 본 것과 유사한 비트 맵 스캔입니다. 해당 노드에서 &lt;code&gt;WHERE&lt;/code&gt; 절 &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; 을 적용하기 때문에 비용과 행 수는 &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; 에서 얻을 수있는 것과 같습니다 . &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; 는 외부 스캔의 행 수에 영향을주지 않도록 절은, 아직 관련이 없습니다. 중첩 루프 결합 노드는 외부 하위에서 얻은 각 행에 대해 두 번째 또는 &quot;내부&quot;하위를 한 번 실행합니다. 현재 외부 행의 열 값을 내부 스캔에 꽂을 수 있습니다. 여기 &lt;code&gt;t1.unique2&lt;/code&gt; 외부 행의 값을 사용할 수 있으므로 간단한 &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case에 대해 위에서 본 것과 비슷한 계획과 비용이 발생합니다. ( &lt;code&gt;t2&lt;/code&gt; 에서 반복적 인 인덱스 스캔 중에 발생할 것으로 예상되는 캐싱의 결과로 예상 비용은 실제로 위에서 본 것보다 약간 낮습니다 .) 그런 다음 루프 노드의 비용은 외부 스캔, 각 외부 행에 대한 내부 스캔 반복 (10 * 7.91), 결합 처리를위한 약간의 CPU 시간.</target>
        </trans-unit>
        <trans-unit id="2a65ed7368072bf4eca944cd69c42b40f3442c1c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">이 구문에서 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;count&lt;/code&gt; 값은 표준에서 리터럴 상수, 매개 변수 또는 변수 이름이어야합니다. PostgreSQL 확장으로 다른 표현식도 허용되지만 모호성을 피하려면 일반적으로 괄호로 묶어야합니다. &lt;code&gt;FETCH&lt;/code&gt; 절 에서 &lt;code&gt;count&lt;/code&gt; 가 생략 되면 기본값은 1입니다. &lt;code&gt;ROW&lt;/code&gt; 및 &lt;code&gt;ROWS&lt;/code&gt; 와 &lt;code&gt;FIRST&lt;/code&gt; 및 &lt;code&gt;NEXT&lt;/code&gt; 는 이러한 절의 영향에 영향을 미치지 않는 노이즈 단어입니다. 표준에 따르면, &lt;code&gt;OFFSET&lt;/code&gt; 절이 둘 다 존재하는 경우 &lt;code&gt;FETCH&lt;/code&gt; 절 앞에 와야합니다 . 그러나 PostgreSQL은 laxer이며 어느 쪽이든 주문할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b9893e81c5b40e27434e52e7429139f563d867e" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">이 유형의 계획에서 테이블 행은 인덱스 순서로 페치되어 읽기 비용이 훨씬 많이 들지만 행 위치를 정렬하는 데 드는 추가 비용이 그다지 가치가 없습니다. 단일 행만 가져 오는 쿼리에 대해이 계획 유형이 가장 자주 나타납니다. &lt;code&gt;ORDER BY&lt;/code&gt; 조건을 만족 하는 ORDER BY 조건 이있는 쿼리에도 자주 사용됩니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 를 충족시키기 위해 추가 정렬 단계가 필요하지 않기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="84eb5898e8d8ec4083399d85009281a59b8ba4c6" translate="yes" xml:space="preserve">
          <source>In versions prior to PostgreSQL 9.6, this flag matched only tables, not any other type of relation.</source>
          <target state="translated">PostgreSQL 9.6 이전 버전에서이 플래그는 다른 유형의 관계가 아닌 테이블 만 일치했습니다.</target>
        </trans-unit>
        <trans-unit id="cccb2030fa433816cbfff6cfc31e7b85686eadc9" translate="yes" xml:space="preserve">
          <source>In writing your archive command, you should assume that the file names to be archived can be up to 64 characters long and can contain any combination of ASCII letters, digits, and dots. It is not necessary to preserve the original relative path (&lt;code&gt;%p&lt;/code&gt;) but it is necessary to preserve the file name (&lt;code&gt;%f&lt;/code&gt;).</source>
          <target state="translated">아카이브 명령을 작성할 때 아카이브 할 파일 이름의 길이는 최대 64 자이며 ASCII 문자, 숫자 및 점의 조합을 포함 할 수 있다고 가정해야합니다. 원래 상대 경로를 유지할 필요는 없습니다 ( &lt;code&gt;%p&lt;/code&gt; ) 되지만 파일 이름 ( &lt;code&gt;%f&lt;/code&gt; ) 은 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="faddf9df2a3466cccf3377b581482849c1fd5256" translate="yes" xml:space="preserve">
          <source>Inaccurate time keeping can result in system instability. Test any change to the clock source very carefully. Operating system defaults are sometimes made to favor reliability over best accuracy. And if you are using a virtual machine, look into the recommended time sources compatible with it. Virtual hardware faces additional difficulties when emulating timers, and there are often per operating system settings suggested by vendors.</source>
          <target state="translated">시간이 정확하지 않으면 시스템이 불안정해질 수 있습니다. 클럭 소스의 변경 사항을 매우 신중하게 테스트하십시오. 운영 체제 기본값은 때때로 최고 정확도보다 안정성을 선호합니다. 가상 머신을 사용하는 경우 가상 머신과 호환되는 권장 시간 소스를 살펴보십시오. 가상 하드웨어는 타이머를 에뮬레이션 할 때 추가적인 어려움에 직면하며 공급 업체가 제안한 운영 체제 별 설정이 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4bae0608aa0bb22c524d2d34a5bb2a1f5386f27" translate="yes" xml:space="preserve">
          <source>Incidentally, the &lt;code&gt;BEGIN&lt;/code&gt; key word is used for a different purpose in embedded SQL. You are advised to be careful about the transaction semantics when porting database applications.</source>
          <target state="translated">또한 &lt;code&gt;BEGIN&lt;/code&gt; 키워드는 Embedded SQL에서 다른 목적으로 사용됩니다. 데이터베이스 응용 프로그램을 이식 할 때 트랜잭션 의미론에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f56a8df3508e9ed5684baab06fa5e61cef26eebf" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;pg_trace.h&lt;/code&gt; if it is not already present in the module(s) containing the probe points, and insert &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; probe macros at the desired locations in the source code</source>
          <target state="translated">포함 &lt;code&gt;pg_trace.h&lt;/code&gt; 를 이미 모듈 (들)에 존재하는 프로브의 포인트를 포함하지 않으며, 삽입하면 &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; 의 소스 코드에서 원하는 위치에 프로브 매크로</target>
        </trans-unit>
        <trans-unit id="2d8b7df7f5c4b05fc8f7d8518fd909017b7c32d2" translate="yes" xml:space="preserve">
          <source>Include SQL commands to clean (drop) databases before recreating them. &lt;code&gt;DROP&lt;/code&gt; commands for roles and tablespaces are added as well.</source>
          <target state="translated">데이터베이스를 재 작성하기 전에 정리 (삭제)하는 SQL 명령을 포함하십시오. 역할 및 테이블 스페이스에 대한 &lt;code&gt;DROP&lt;/code&gt; 명령도 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="15af567ab13e6ebab28e457206713f05e4dcc212" translate="yes" xml:space="preserve">
          <source>Include actual startup time and time spent in each node in the output. The overhead of repeatedly reading the system clock can slow down the query significantly on some systems, so it may be useful to set this parameter to &lt;code&gt;FALSE&lt;/code&gt; when only actual row counts, and not exact times, are needed. Run time of the entire statement is always measured, even when node-level timing is turned off with this option. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">출력의 각 노드에서 소요 된 실제 시작 시간과 시간을 포함하십시오. 시스템 클럭을 반복해서 읽는 오버 헤드로 인해 일부 시스템에서 쿼리 속도가 크게 느려질 수 있으므로 정확한 시간이 아닌 실제 행 개수 만 필요한 경우이 매개 변수를 &lt;code&gt;FALSE&lt;/code&gt; 로 설정하면 유용 할 수 있습니다 . 이 옵션을 사용하여 노드 레벨 타이밍을 끄더라도 전체 명령문의 런타임은 항상 측정됩니다. 이 매개 변수는 &lt;code&gt;ANALYZE&lt;/code&gt; 일 때만 사용할 수 있습니다 가 활성화 된 사용할 수 있습니다. 기본값은 &lt;code&gt;TRUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69fd997380e1370b3a2e3a89721390495f72294b" translate="yes" xml:space="preserve">
          <source>Include files or directories can be used to logically separate portions of the database configuration, rather than having a single large &lt;code&gt;postgresql.conf&lt;/code&gt; file. Consider a company that has two database servers, each with a different amount of memory. There are likely elements of the configuration both will share, for things such as logging. But memory-related parameters on the server will vary between the two. And there might be server specific customizations, too. One way to manage this situation is to break the custom configuration changes for your site into three files. You could add this to the end of your &lt;code&gt;postgresql.conf&lt;/code&gt; file to include them:</source>
          <target state="translated">하나의 큰 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일이 아닌 포함 파일 또는 디렉토리를 사용하여 데이터베이스 구성의 일부를 논리적으로 분리 할 수 ​​있습니다 . 각각 다른 양의 메모리를 가진 두 개의 데이터베이스 서버가있는 회사를 생각해보십시오. 로깅과 같은 것들에 대해 둘 다 공유 할 구성 요소가있을 수 있습니다. 그러나 서버의 메모리 관련 매개 변수는 둘 사이에서 다릅니다. 또한 서버 별 사용자 정의가있을 수 있습니다. 이 상황을 관리하는 한 가지 방법은 사이트의 사용자 정의 구성 변경을 세 개의 파일로 나누는 것입니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 의 끝에 이것을 추가 하여 포함시킬 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="47b7156430746d586783036a5e783795b65f9965" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">버퍼 사용량에 대한 정보를 포함하십시오. 구체적으로, 적중, 읽기, 더티 및 기록 된 공유 블록 수, 적중, 읽기, 더티 및 기록 된 로컬 블록 수 및 읽고 쓴 임시 블록 수를 포함하십시오. A는 &lt;em&gt;공격&lt;/em&gt; 필요할 때 블록이 캐시에 이미 발견 되었기 때문에 읽기 피할 것을 의미합니다. 공유 블록에는 일반 테이블 및 인덱스의 데이터가 포함됩니다. 로컬 블록에는 임시 테이블 및 인덱스의 데이터가 포함됩니다. 임시 블록에는 정렬, 해시, 구체화 계획 노드 및 이와 유사한 경우에 사용되는 단기 작업 데이터가 포함됩니다. 블록의 수 &lt;em&gt;더러워은&lt;/em&gt; 이 쿼리에 의해 변경되었습니다 이전에 수정되지 않은 블록의 수를 나타냅니다; 블록의 수 동안&lt;em&gt; 쓰여진&lt;/em&gt;쿼리 처리 중에이 백엔드가 캐시에서 제거한 이전에 제거 된 블록 수를 나타냅니다. 상위 레벨 노드에 대해 표시된 블록 수에는 모든 하위 노드에서 사용되는 블록 수가 포함됩니다. 텍스트 형식에서는 0이 아닌 값만 인쇄됩니다. 이 매개 변수는 &lt;code&gt;ANALYZE&lt;/code&gt; 가 활성화 된 경우에만 사용할 수 있습니다. 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5cf950011b674c52ed53fd1187206feef3854c98" translate="yes" xml:space="preserve">
          <source>Include information on configuration parameters. Specifically, include options affecting query planning with value different from the built-in default value. This parameter defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">구성 매개 변수에 대한 정보를 포함하십시오. 특히 기본 제공 기본값과 다른 값으로 쿼리 계획에 영향을주는 옵션을 포함하십시오. 이 매개 변수의 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd7df900c420c99916abebaeb86bc9b9487e3ff6" translate="yes" xml:space="preserve">
          <source>Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row. This parameter defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">각 계획 노드의 예상 시작 및 총 비용, 예상 행 수 및 각 행의 예상 너비에 대한 정보를 포함하십시오. 이 매개 변수의 기본값은 &lt;code&gt;TRUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5b5e034a15e397016c3928803cda54f49c8fb74" translate="yes" xml:space="preserve">
          <source>Include large objects in the dump. This is the default behavior except when &lt;code&gt;--schema&lt;/code&gt;, &lt;code&gt;--table&lt;/code&gt;, or &lt;code&gt;--schema-only&lt;/code&gt; is specified. The &lt;code&gt;-b&lt;/code&gt; switch is therefore only useful to add large objects to dumps where a specific schema or table has been requested. Note that blobs are considered data and therefore will be included when &lt;code&gt;--data-only&lt;/code&gt; is used, but not when &lt;code&gt;--schema-only&lt;/code&gt; is.</source>
          <target state="translated">덤프에 큰 오브젝트를 포함하십시오. &lt;code&gt;--schema&lt;/code&gt; , &lt;code&gt;--table&lt;/code&gt; 또는 &lt;code&gt;--schema-only&lt;/code&gt; 가 지정된 경우를 제외하고는 기본 동작 입니다. 따라서 &lt;code&gt;-b&lt;/code&gt; 스위치는 특정 스키마 나 테이블이 요청 된 덤프에 큰 객체를 추가 할 때만 유용합니다. Blob은 데이터로 간주되므로 &lt;code&gt;--data-only&lt;/code&gt; 를 사용할 때는 포함 되지만 &lt;code&gt;--schema-only&lt;/code&gt; 는 사용할 때는 포함 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="08c7d11c8d4a8d10c948989b5a35951818754be1" translate="yes" xml:space="preserve">
          <source>Include summary information (e.g., totaled timing information) after the query plan. Summary information is included by default when &lt;code&gt;ANALYZE&lt;/code&gt; is used but otherwise is not included by default, but can be enabled using this option. Planning time in &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; includes the time required to fetch the plan from the cache and the time required for re-planning, if necessary.</source>
          <target state="translated">쿼리 계획 후 요약 정보 (예 : 총 타이밍 정보)를 포함하십시오. &lt;code&gt;ANALYZE&lt;/code&gt; 를 사용 하면 요약 정보가 기본적으로 포함 되지만 그렇지 않으면 기본적으로 포함되지 않지만이 옵션을 사용하여 활성화 할 수 있습니다. 계획 시간 &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; 의 에는 캐시에서 계획을 가져 오는 데 필요한 시간과 필요한 경우 다시 계획하는 데 필요한 시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d2256e3896ead62f77d423e731b976ceab4c8935" translate="yes" xml:space="preserve">
          <source>Includes the required write-ahead log files (WAL files) in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster directly in the extracted directory without the need to consult the log archive, thus making this a completely standalone backup.</source>
          <target state="translated">백업에 필요한 미리 쓰기 로그 파일 (WAL 파일)을 포함합니다. 여기에는 백업 중에 생성 된 모든 미리 쓰기 로그가 포함됩니다. 메소드 않는 한 &lt;code&gt;none&lt;/code&gt; 지정되지 않은, 따라서이 완전히 독립 백업하고, 로그 아카이브를 참조 할 필요없이 압축을 푼 디렉토리에 직접 전자 메일 관리자를 시작하는 것이 가능하다.</target>
        </trans-unit>
        <trans-unit id="bba52d333ab18b6249842b58dabb5827d455ee93" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), and application name. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="translated">&lt;code&gt;log_error_verbosity&lt;/code&gt; 에 &lt;code&gt;csvlog&lt;/code&gt; 를 포함하는 것은 &lt;code&gt;verbose&lt;/code&gt; 로 설정 되고 응용 프로그램 이름입니다. CSV 형식 로그 출력을 저장하기위한 샘플 테이블 정의는 다음과 같습니다. &lt;code&gt;log_destination&lt;/code&gt; 목록에 로그 파일을 데이터베이스 테이블로 가져 오는 편리한 방법을 제공합니다. 이 옵션은 밀리 초가 포함 된 타임 스탬프, 사용자 이름, 데이터베이스 이름, 프로세스 ID, 클라이언트 호스트 : 포트 번호, 세션 ID, 세션 별 라인 번호, 명령과 같은 열을 사용하여 쉼표로 구분 된 값 (CSV) 형식으로 로그 라인을 생성합니다. 태그, 세션 시작 시간, 가상 트랜잭션 ID, 일반 트랜잭션 ID, 오류 심각도, SQLSTATE 코드, 오류 메시지, 오류 메시지 세부 사항, 힌트, 오류가 발생한 내부 쿼리 (있는 경우), 오류 위치의 문자 수, 오류 컨텍스트, 오류를 &lt;code&gt;log_min_error_statement&lt;/code&gt; 사용자 쿼리 (있는 경우 log_min_error_statement에 의해 활성화 됨)), 오류 위치의 문자 수, PostgreSQL 소스 코드의 오류 위치 ( 경우</target>
        </trans-unit>
        <trans-unit id="4c47c86c8d425f70d8b2151c0d809c6c1813e865" translate="yes" xml:space="preserve">
          <source>Increase &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; and &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;; this reduces the frequency of checkpoints, but increases the storage requirements of &lt;code&gt;/pg_wal&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout을&lt;/a&gt; 늘리 십시오 . 이것은 체크 포인트의 빈도를 줄이지 만 &lt;code&gt;/pg_wal&lt;/code&gt; 의 스토리지 요구 사항을 증가 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="491d088ee8f4f607e5e1e928bb9bf8875f9a361a" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;code&gt;r&lt;/code&gt; in at least &lt;code&gt;n&lt;/code&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;code&gt;r&lt;/code&gt;. Lower-left coordinates are decreased by &lt;code&gt;r&lt;/code&gt; and upper-right coordinates are increased by &lt;code&gt;r&lt;/code&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;code&gt;r&lt;/code&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;code&gt;n&lt;/code&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;code&gt;r&lt;/code&gt; &amp;gt; 0), then extra dimensions are added to make &lt;code&gt;n&lt;/code&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="translated">최소 &lt;code&gt;n&lt;/code&gt; 치수 에서 지정된 반경 &lt;code&gt;r&lt;/code&gt; 만큼 큐브 크기를 증가시킵니다 . 반경이 음수이면 큐브가 대신 축소됩니다. 정의 된 모든 치수는 반지름 &lt;code&gt;r&lt;/code&gt; 에 의해 변경됩니다 . 왼쪽 아래 좌표가 &lt;code&gt;r&lt;/code&gt; 만큼 감소합니다 오른쪽 위 좌표는 &lt;code&gt;r&lt;/code&gt; 증가합니다 . 왼쪽 하단 좌표가 해당 오른쪽 상단 좌표 이상으로 증가하면 ( &lt;code&gt;r&lt;/code&gt; &amp;lt;0 인 경우에만 발생 ) 두 좌표가 평균으로 설정됩니다. 경우 &lt;code&gt;n&lt;/code&gt; 은 정의 된 치수의 수보다 크고 큐브가 확대되고있다 ( &lt;code&gt;r&lt;/code&gt; &amp;gt; 0), 그 다음 추가로 치수 메이크업에 추가 &lt;code&gt;n&lt;/code&gt; 전부; 추가 좌표의 초기 값으로 0이 사용됩니다. 이 기능은 근처 점을 검색하기 위해 점 주위에 경계 상자를 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f9c0442f572435bb8c34c7304c10e685fc7ac4b3" translate="yes" xml:space="preserve">
          <source>Increment an integer, making use of an argument name, in PL/pgSQL:</source>
          <target state="translated">PL / pgSQL에서 인수 이름을 사용하여 정수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="d5e6a1521753325e1f10aefe90f61ed951c60b45" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:</source>
          <target state="translated">Acme Corporation의 계정을 관리하는 영업 사원의 판매 수를 늘리고 업데이트 된 전체 행과 현재 시간을 로그 테이블에 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="016cda80a0391be204d7aeb8cae7ec5708da297f" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, using the &lt;code&gt;FROM&lt;/code&gt; clause syntax:</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절 구문을 사용하여 Acme Corporation의 계정을 관리하는 영업 사원의 판매 수를 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="9a4352e3ce439f57ce839ae2217c61914bab2036" translate="yes" xml:space="preserve">
          <source>Increment value of the sequence</source>
          <target state="translated">시퀀스의 증가 값</target>
        </trans-unit>
        <trans-unit id="0baba858aebf401bd8fc5997be9e51de35556b66" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 most recent WAL files are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="translated">독립적으로의 &lt;code&gt;max_wal_size&lt;/code&gt; , &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 가장 최근의 WAL 파일은 항상 유지됩니다. 또한 WAL 보관을 사용하는 경우 오래된 세그먼트는 보관 될 때까지 제거하거나 재활용 할 수 없습니다. WAL 보관이 WAL 생성 속도를 유지할 수 없거나 &lt;code&gt;archive_command&lt;/code&gt; 가 반복적으로 실패 하면 상황이 해결 될 때까지 오래된 WAL 파일이 &lt;code&gt;pg_wal&lt;/code&gt; 에 누적됩니다 . 복제 슬롯을 사용하는 느리거나 실패한 대기 서버는 동일한 효과를 갖습니다 (참조&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt; 26.2.6 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc7301cd0f493014b9a0674c1f9a1816640cb05f" translate="yes" xml:space="preserve">
          <source>Index Access Method: Basic API Structure for Indexes</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스의 기본 API 구조</target>
        </trans-unit>
        <trans-unit id="f78511aae833dc82a57faebbdb5be9d2b811c5ba" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Access Method Functions</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 액세스 방법 기능</target>
        </trans-unit>
        <trans-unit id="67844b6b086746a2175da308cd69b3a3322c8f8a" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Cost Estimation Functions</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 비용 추정 함수</target>
        </trans-unit>
        <trans-unit id="ed0cf00558f5f3be604eab3a16ea9444c680fa41" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Locking Considerations</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 잠금 고려 사항</target>
        </trans-unit>
        <trans-unit id="23bdd1e7799979f5184920ab721afb82ac1bc5bc" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Scanning</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 스캔</target>
        </trans-unit>
        <trans-unit id="1b3aa3923e02606cc47b91d3beb9e0be0fcf698b" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Uniqueness Checks</source>
          <target state="translated">인덱스 액세스 방법 : 인덱스 고유성 검사</target>
        </trans-unit>
        <trans-unit id="5ec145b22f866c8350ec8fde02299443b400da81" translate="yes" xml:space="preserve">
          <source>Index Storage Parameters</source>
          <target state="translated">인덱스 스토리지 매개 변수</target>
        </trans-unit>
        <trans-unit id="4e09dcdaddb1a9558501d09366dc72f53b93938b" translate="yes" xml:space="preserve">
          <source>Index Types</source>
          <target state="translated">색인 유형</target>
        </trans-unit>
        <trans-unit id="f19762ba6cf5f18bb6bfea402f2aaa7605c7a6d9" translate="yes" xml:space="preserve">
          <source>Index access method operator class is for</source>
          <target state="translated">인덱스 액세스 방법 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="aa270689b00c3b50db9d0d870a5d8e7c14e30f9d" translate="yes" xml:space="preserve">
          <source>Index access method operator family is for</source>
          <target state="translated">인덱스 액세스 방법 운영자 제품군</target>
        </trans-unit>
        <trans-unit id="7f91618c60dc341c28ac1a80ab4b5e00b3b36fa4" translate="yes" xml:space="preserve">
          <source>Index access method specific data. Different methods store different data. Empty in ordinary tables.</source>
          <target state="translated">인덱스 액세스 방법 별 데이터. 다른 방법은 다른 데이터를 저장합니다. 일반 테이블에서 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="31a6a8a40d18f374bed6deff03fed3f43968a4d7" translate="yes" xml:space="preserve">
          <source>Index access methods must handle concurrent updates of the index by multiple processes. The core PostgreSQL system obtains &lt;code&gt;AccessShareLock&lt;/code&gt; on the index during an index scan, and &lt;code&gt;RowExclusiveLock&lt;/code&gt; when updating the index (including plain &lt;code&gt;VACUUM&lt;/code&gt;). Since these lock types do not conflict, the access method is responsible for handling any fine-grained locking it might need. An exclusive lock on the index as a whole will be taken only during index creation, destruction, or &lt;code&gt;REINDEX&lt;/code&gt;.</source>
          <target state="translated">인덱스 액세스 방법은 여러 프로세스에 의한 인덱스의 동시 업데이트를 처리해야합니다. 핵심 PostgreSQL 시스템은 인덱스 스캔 중에 인덱스에서 &lt;code&gt;AccessShareLock&lt;/code&gt; 을 &lt;code&gt;RowExclusiveLock&lt;/code&gt; 하고 인덱스를 업데이트 할 때 RowExclusiveLock (일반 &lt;code&gt;VACUUM&lt;/code&gt; 포함 )을 얻습니다 . 이러한 잠금 유형은 충돌하지 않으므로 액세스 방법은 필요할 수있는 세밀한 잠금을 처리합니다. 인덱스 전체에 대한 독점 잠금은 인덱스 생성, 소멸 또는 &lt;code&gt;REINDEX&lt;/code&gt; 중에 만 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="411152cefe270170bdbd707fa7bb100f59936ac0" translate="yes" xml:space="preserve">
          <source>Index definition (a reconstructed &lt;code&gt;CREATE INDEX&lt;/code&gt; command)</source>
          <target state="translated">인덱스 정의 (재구성 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령)</target>
        </trans-unit>
        <trans-unit id="fdde6507a698ff6040826cbe9781cf5e41a80789" translate="yes" xml:space="preserve">
          <source>Index expressions are relatively expensive to maintain, because the derived expression(s) must be computed for each row upon insertion and whenever it is updated. However, the index expressions are &lt;em&gt;not&lt;/em&gt; recomputed during an indexed search, since they are already stored in the index. In both examples above, the system sees the query as just &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; and so the speed of the search is equivalent to any other simple index query. Thus, indexes on expressions are useful when retrieval speed is more important than insertion and update speed.</source>
          <target state="translated">인덱스 표현식은 삽입시 및 업데이트 될 때마다 각 행에 대해 파생 표현식을 계산해야하므로 유지 관리 비용이 상대적으로 비쌉니다. 그러나 인덱스 표현식은 인덱스 에 이미 저장되어 있으므로 인덱스 검색 중에 다시 계산 &lt;em&gt;되지 않습니다&lt;/em&gt; . 위의 두 예에서 시스템은 쿼리를 &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; 하므로 검색 속도는 다른 간단한 인덱스 쿼리와 같습니다. 따라서 식의 인덱스는 검색 속도가 삽입 및 업데이트 속도보다 중요 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="137221474050ee597f18d1d2a9bf5cc8c57090b0" translate="yes" xml:space="preserve">
          <source>Index-Only Scans and Covering Indexes</source>
          <target state="translated">인덱스 전용 스캔 및 커버링 인덱스</target>
        </trans-unit>
        <trans-unit id="fa0d50739fe1e6ebbc17d0c70d81ac62acbaf58d" translate="yes" xml:space="preserve">
          <source>Indexable Operators</source>
          <target state="translated">인덱서 블 연산자</target>
        </trans-unit>
        <trans-unit id="69a6a1b0f4ad606d0ae7c258868e72a29f0777ef" translate="yes" xml:space="preserve">
          <source>Indexed Data Type</source>
          <target state="translated">인덱싱 된 데이터 유형</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="0b07dd7c1e4d64ef5d5ba2561b6e35701b2906b6" translate="yes" xml:space="preserve">
          <source>Indexes and foreign key constraints apply to single tables and not to their inheritance children, hence they have some &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;caveats&lt;/a&gt; to be aware of.</source>
          <target state="translated">인덱스와 외래 키 제약 조건은 상속 자식이 아닌 단일 테이블에 적용되므로 몇 가지 &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;주의 사항이 있습니다.&lt;/a&gt; 해야 할 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e15643bd769ae7fcf2c35c27f2ab1732e1a9d5c1" translate="yes" xml:space="preserve">
          <source>Indexes can also be used to enforce uniqueness of a column's value, or the uniqueness of the combined values of more than one column.</source>
          <target state="translated">인덱스를 사용하여 열 값의 고유성 또는 둘 이상의 열의 결합 된 값의 고유성을 강화할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94aa2c39061285d86804bbba30d7e52d694f4564" translate="yes" xml:space="preserve">
          <source>Indexes can also benefit &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands with search conditions. Indexes can moreover be used in join searches. Thus, an index defined on a column that is part of a join condition can also significantly speed up queries with joins.</source>
          <target state="translated">인덱스는 검색 조건이있는 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 명령 에도 도움이 됩니다. 또한 인덱스는 조인 검색에 사용될 수 있습니다. 따라서 조인 조건의 일부인 열에 정의 된 인덱스는 조인을 사용하여 쿼리 속도를 크게 높일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68c16c2b91128e4f41955f5ff646c75a169f39bb" translate="yes" xml:space="preserve">
          <source>Indexes can be used by simple index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, and the optimizer. In a bitmap scan the output of several indexes can be combined via AND or OR rules, so it is difficult to associate individual heap row fetches with specific indexes when a bitmap scan is used. Therefore, a bitmap scan increments the &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_read&lt;/code&gt; count(s) for the index(es) it uses, and it increments the &lt;code&gt;pg_stat_all_tables&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt; count for the table, but it does not affect &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt;. The optimizer also accesses indexes to check for supplied constants whose values are outside the recorded range of the optimizer statistics because the optimizer statistics might be stale.</source>
          <target state="translated">간단한 인덱스 스캔, &quot;비트 맵&quot;인덱스 스캔 및 옵티 마이저에서 인덱스를 사용할 수 있습니다. 비트 맵 스캔에서 AND 또는 OR 규칙을 통해 여러 인덱스의 출력을 결합 할 수 있으므로 비트 맵 스캔을 사용할 때 개별 힙 행 페치를 특정 인덱스와 연관시키기가 어렵습니다. 따라서 비트 맵 스캔은 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 를 증가시킵니다 . 사용하는 인덱스에 대한 &lt;code&gt;idx_tup_read&lt;/code&gt; 카운트 및 &lt;code&gt;pg_stat_all_tables&lt;/code&gt; 를 증가시킵니다 . &lt;code&gt;idx_tup_fetch&lt;/code&gt; 는 테이블의 수이지만 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 에는 영향을 미치지 않습니다 . &lt;code&gt;idx_tup_fetch&lt;/code&gt; . 옵티마이 저는 또한 인덱스에 액세스하여 옵티 마이저 통계가 오래되었을 수 있으므로 값이 옵티 마이저 통계의 기록 된 범위를 벗어난 제공된 상수를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fe87987c8ecb565fcb320eb91d374313994665e6" translate="yes" xml:space="preserve">
          <source>Indexes can even concatenate columns:</source>
          <target state="translated">인덱스는 열을 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fee069b42975ecfc0bf523b8f7af8b0cf11b9bb" translate="yes" xml:space="preserve">
          <source>Indexes, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;UNIQUE&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)</source>
          <target state="translated">원래 테이블에 대한 인덱스, &lt;code&gt;PRIMARY KEY&lt;/code&gt; , &lt;code&gt;UNIQUE&lt;/code&gt; 및 &lt;code&gt;EXCLUDE&lt;/code&gt; 제약 조건이 새 테이블에 생성됩니다. 원본의 이름 지정 방법에 관계없이 새 색인 및 제약 조건의 이름은 기본 규칙에 따라 선택됩니다. (이 동작은 새 인덱스에 대한 중복 이름 오류를 방지합니다.)</target>
        </trans-unit>
        <trans-unit id="64accc47bb83e575341063f3658e1d1e7d2113e1" translate="yes" xml:space="preserve">
          <source>Indexing for &amp;ldquo;float ranges&amp;rdquo;</source>
          <target state="translated">&quot;부동 범위&quot;에 대한 인덱싱</target>
        </trans-unit>
        <trans-unit id="d165c70b9c7feb2704f3285d8d27cbb3a58c3a91" translate="yes" xml:space="preserve">
          <source>Indexing for multidimensional cubes</source>
          <target state="translated">다차원 큐브에 대한 인덱싱</target>
        </trans-unit>
        <trans-unit id="b91462559e819269659f845aa92e7f5041a36896" translate="yes" xml:space="preserve">
          <source>Indexing for tree-like structures</source>
          <target state="translated">나무 같은 구조에 대한 인덱싱</target>
        </trans-unit>
        <trans-unit id="610e7a10148c311249b3bbd57cd9833a58b8714d" translate="yes" xml:space="preserve">
          <source>Indicates how the cast is performed. &lt;code&gt;f&lt;/code&gt; means that the function specified in the &lt;code&gt;castfunc&lt;/code&gt; field is used. &lt;code&gt;i&lt;/code&gt; means that the input/output functions are used. &lt;code&gt;b&lt;/code&gt; means that the types are binary-coercible, thus no conversion is required.</source>
          <target state="translated">캐스트 수행 방법을 나타냅니다. &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;castfunc&lt;/code&gt; 필드에 지정된 기능 이 사용됨을 의미합니다. &lt;code&gt;i&lt;/code&gt; 는 입력 / 출력 기능이 사용됨을 의미합니다. &lt;code&gt;b&lt;/code&gt; 는 유형이 이진-강제이므로 변환이 필요하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c8e4b2b3e4731dd79133b34f9f993d48a44e51e7" translate="yes" xml:space="preserve">
          <source>Indicates not to recurse creating indexes on partitions, if the table is partitioned. The default is to recurse.</source>
          <target state="translated">테이블이 파티션 된 경우 파티션에서 인덱스 작성을 재귀하지 않도록 나타냅니다. 기본값은 재귀입니다.</target>
        </trans-unit>
        <trans-unit id="c934b82eb6dc908677ffc76af2256f04ecf84094" translate="yes" xml:space="preserve">
          <source>Indicates role to which this role will be added immediately as a new member. Multiple roles to which this role will be added as a member can be specified by writing multiple &lt;code&gt;-g&lt;/code&gt; switches.</source>
          <target state="translated">이 역할이 새 구성원으로 즉시 추가 될 역할을 나타냅니다. 이 역할이 구성원으로 추가 될 여러 역할은 여러 개의 &lt;code&gt;-g&lt;/code&gt; 스위치 를 작성하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bba08c6b0be5e0b5de1c5dd077ea609cb92072f0" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 배열 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7a2f7fb68c39785b7c61d53497fe5cf5bd1568bd" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9f46df9b9c0db2bde38cb75f71fb9153783611d4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 열거 형 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5&lt;/a&gt; 및 &lt;a href=&quot;datatype-enum&quot;&gt;섹션 8.7 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="46bd42bb48f3fa999abde7cc36ebf5b6f5ac5c8d" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any input data type.</source>
          <target state="translated">함수가 모든 입력 데이터 유형을 허용 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4e38b6c5ff227f9cc8a0278ba387f1ee54390caf" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">함수가 배열이 아닌 데이터 유형을 수용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;섹션 37.2.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="95d9465560cf78be64ef72d2e6367284edb5463f" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">함수가 모든 범위의 데이터 유형을 허용 함을 나타냅니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;37.2.5&lt;/a&gt; 및 &lt;a href=&quot;rangetypes&quot;&gt;8.17 섹션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="99e158daaace8eac02a3ccf2b3b765596ccc91e4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a null-terminated C string.</source>
          <target state="translated">함수가 널 종료 C 문자열을 승인하거나 리턴 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="54761c9282026639ec5c8540cc79ebf4ba11462a" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a server-internal data type.</source>
          <target state="translated">함수가 서버 내부 데이터 유형을 승인하거나 리턴 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89dc9ca8b4db982fb593e3e44e25350b25d82bea" translate="yes" xml:space="preserve">
          <source>Indicates that a function returns no value.</source>
          <target state="translated">함수가 값을 반환하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7d75608f451e28beb0733c0d6c1c5d589e592ee3" translate="yes" xml:space="preserve">
          <source>Indicates that data retrieved from the cursor should be unaffected by updates to the table(s) underlying the cursor that occur after the cursor is created. In PostgreSQL, this is the default behavior; so this key word has no effect and is only accepted for compatibility with the SQL standard.</source>
          <target state="translated">커서에서 검색된 데이터는 커서가 작성된 후 발생하는 커서의 기본이되는 테이블의 업데이트에 영향을받지 않아야 함을 나타냅니다. PostgreSQL에서는 이것이 기본 동작입니다. 따라서이 키워드는 효과가 없으며 SQL 표준과의 호환성을 위해서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="95cdb06015680fe563a8aa9dd541903933a11ad2" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in any context.</source>
          <target state="translated">어떤 컨텍스트에서도 캐스트를 내재적으로 호출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0390d2ebad5b8b8a226d9901a34d76e7770b71be" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in assignment contexts.</source>
          <target state="translated">할당 컨텍스트에서 캐스트를 암시 적으로 호출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3840502dacc9907db02fe8896c3bfeafcfa9e633" translate="yes" xml:space="preserve">
          <source>Indicates that the cast is an I/O conversion cast, performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type.</source>
          <target state="translated">캐스트가 소스 데이터 유형의 출력 함수를 호출하고 결과 문자열을 대상 데이터 유형의 입력 함수에 전달하여 수행되는 I / O 변환 캐스트임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01e358ef1ee49de64b80b741226b8d05654b1eb9" translate="yes" xml:space="preserve">
          <source>Indicates that the source type is binary-coercible to the target type, so no function is required to perform the cast.</source>
          <target state="translated">소스 유형이 대상 유형에 대해 2 진 변환 가능하므로 캐스트를 수행하는 기능이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f0180a78d5a13ddfb20f673dc1c1a653a0dbf1c" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a hash join.</source>
          <target state="translated">이 연산자가 해시 조인을 지원할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f8be265aa5381d640f66bb0fbb51979d62652fa" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a merge join.</source>
          <target state="translated">이 연산자가 병합 조인을 지원할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="88982366e025d973d9fdcbf523cd379f45035c49" translate="yes" xml:space="preserve">
          <source>Indicates what contexts the cast can be invoked in. &lt;code&gt;e&lt;/code&gt; means only as an explicit cast (using &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; syntax). &lt;code&gt;a&lt;/code&gt; means implicitly in assignment to a target column, as well as explicitly. &lt;code&gt;i&lt;/code&gt; means implicitly in expressions, as well as the other cases.</source>
          <target state="translated">캐스트를 호출 할 수있는 컨텍스트를 나타냅니다. &lt;code&gt;e&lt;/code&gt; 는 명시 적 캐스트 ( &lt;code&gt;CAST&lt;/code&gt; 또는 &lt;code&gt;::&lt;/code&gt; 구문 사용)로만 의미합니다 . 암시 적 목표 컬럼에 할당의 수단뿐만 아니라 명시 적으로. &lt;code&gt;i&lt;/code&gt; 다른 경우뿐만 아니라 표현에도 암묵적으로 의미한다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1335256027d947c4a5d7cbed371240e3fa5176d" translate="yes" xml:space="preserve">
          <source>Indirect TOAST pointers simply point at a non-indirect varlena value stored somewhere in memory. This case was originally created merely as a proof of concept, but it is currently used during logical decoding to avoid possibly having to create physical tuples exceeding 1 GB (as pulling all out-of-line field values into the tuple might do). The case is of limited use since the creator of the pointer datum is entirely responsible that the referenced data survives for as long as the pointer could exist, and there is no infrastructure to help with this.</source>
          <target state="translated">간접 TOAST 포인터는 단순히 메모리 어딘가에 저장된 비 간접 varlena 값을 가리 킵니다. 이 사례는 원래 개념 증명의 목적으로 만 작성되었지만 현재 1GB를 초과하는 물리적 튜플을 만들 필요가 없도록 논리적 디코딩 중에 사용됩니다 (모든 라인 외부 필드 값을 튜플로 가져 오는 것처럼). 포인터 데이텀의 작성자는 포인터가 존재할 수있는 한 참조 된 데이터가 존속 할 책임이 있으며,이를 지원할 인프라가 없기 때문에이 경우는 제한적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="749d2a57690cd8938d324488d8b64d9826db075f" translate="yes" xml:space="preserve">
          <source>Individual leaf tuples and inner tuples must fit on a single index page (8kB by default). Therefore, when indexing values of variable-length data types, long values can only be supported by methods such as radix trees, in which each level of the tree includes a prefix that is short enough to fit on a page, and the final leaf level includes a suffix also short enough to fit on a page. The operator class should set &lt;code&gt;longValuesOK&lt;/code&gt; to true only if it is prepared to arrange for this to happen. Otherwise, the SP-GiST core will reject any request to index a value that is too large to fit on an index page.</source>
          <target state="translated">개별 리프 튜플 및 내부 튜플은 단일 인덱스 페이지 (기본적으로 8kB)에 맞아야합니다. 따라서 가변 길이 데이터 형식의 값을 인덱싱 할 때 기수 트리와 같은 방법으로 만 긴 값을 지원할 수 있습니다. 트리의 각 수준에는 페이지에 맞출 수있을만큼 짧은 접두사와 최종 리프 수준이 포함됩니다. 페이지에 맞출 수있을만큼 짧은 접미사를 포함합니다. 연산자 클래스는 이를 수행 할 준비가되어있는 경우에만 &lt;code&gt;longValuesOK&lt;/code&gt; 를 true로 설정해야합니다 . 그렇지 않으면 SP-GiST 코어가 너무 커서 색인 페이지에 맞지 않는 값을 색인하기위한 요청을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="60182f316e9821f12c8e613a5f4a51ed0303f8be" translate="yes" xml:space="preserve">
          <source>Individual partitions are linked to the partitioned table with inheritance behind-the-scenes; however, it is not possible to use some of the generic features of inheritance (discussed below) with declaratively partitioned tables or their partitions. For example, a partition cannot have any parents other than the partitioned table it is a partition of, nor can a regular table inherit from a partitioned table making the latter its parent. That means partitioned tables and their partitions do not participate in inheritance with regular tables. Since a partition hierarchy consisting of the partitioned table and its partitions is still an inheritance hierarchy, all the normal rules of inheritance apply as described in &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; with some exceptions, most notably:</source>
          <target state="translated">개별 파티션은 무대 뒤에서 상속 된 파티션 된 테이블에 연결됩니다. 그러나 선언적으로 분할 된 테이블 또는 해당 분할 영역과 함께 일부 상속 기능 (아래에서 설명)을 사용할 수는 없습니다. 예를 들어, 파티션은 파티션 된 파티션 된 테이블 이외의 다른 부모를 가질 수 없으며, 일반 테이블은 파티션 된 테이블을 부모 테이블로 상속 할 수 없습니다. 이는 파티션 된 테이블 및 해당 파티션이 일반 테이블의 상속에 참여하지 않음을 의미합니다. 분할 된 테이블과 해당 파티션으로 구성된 파티션 계층 구조는 여전히 상속 계층 구조이므로 &lt;a href=&quot;ddl-inherit&quot;&gt;섹션 5.10에&lt;/a&gt; 설명 된대로 모든 일반적인 상속 규칙이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8da164cdd479d1b5a117c145f315adf86e0bbc9" translate="yes" xml:space="preserve">
          <source>Individual state files in &lt;code&gt;pg_twophase&lt;/code&gt; are protected by CRC-32.</source>
          <target state="translated">&lt;code&gt;pg_twophase&lt;/code&gt; 의 개별 상태 파일은 CRC-32에 의해 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="10dbe9c3ced898e42dd1884b1b4e3f1dc8f408e3" translate="yes" xml:space="preserve">
          <source>Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:</source>
          <target state="translated">정확하지 않은 값은 일부 값을 내부 형식으로 정확하게 변환 할 수없고 근사값으로 저장되므로 값을 저장하고 검색하면 약간의 차이가있을 수 있습니다. 이러한 오류를 관리하고 계산을 통해 전파되는 방식은 전체 수학 및 컴퓨터 과학 분야의 주제이며 다음 사항을 제외하고는 여기에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d7d8b040e79c74720337a20e81bb860b0667a32" translate="yes" xml:space="preserve">
          <source>Infinite line</source>
          <target state="translated">무한 라인</target>
        </trans-unit>
        <trans-unit id="6f943c69647f371e6d494b5d1c35aba8e91e86d6" translate="yes" xml:space="preserve">
          <source>Information about text search configuration objects can be obtained in psql using a set of commands:</source>
          <target state="translated">텍스트 검색 구성 객체에 대한 정보는 psql에서 일련의 명령을 사용하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="40def20f80d8ba48037f621df42aa0343e15ee73" translate="yes" xml:space="preserve">
          <source>Inheritance does not automatically propagate data from &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;COPY&lt;/code&gt; commands to other tables in the inheritance hierarchy. In our example, the following &lt;code&gt;INSERT&lt;/code&gt; statement will fail:</source>
          <target state="translated">상속은 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;COPY&lt;/code&gt; 명령의 데이터를 상속 계층의 다른 테이블로 자동 전파하지 않습니다 . 이 예에서 다음 &lt;code&gt;INSERT&lt;/code&gt; 문은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="48cefe4735516b5da581e0949fa06f740d2b885b" translate="yes" xml:space="preserve">
          <source>Inheritance is a concept from object-oriented databases. It opens up interesting new possibilities of database design.</source>
          <target state="translated">상속은 객체 지향 데이터베이스의 개념입니다. 데이터베이스 디자인의 새로운 가능성을 열어줍니다.</target>
        </trans-unit>
        <trans-unit id="ad5cfb3ab229a84f8bd5bd34780ce3d5e37a4e03" translate="yes" xml:space="preserve">
          <source>Inherited queries perform access permission checks on the parent table only. Thus, for example, granting &lt;code&gt;UPDATE&lt;/code&gt; permission on the &lt;code&gt;cities&lt;/code&gt; table implies permission to update rows in the &lt;code&gt;capitals&lt;/code&gt; table as well, when they are accessed through &lt;code&gt;cities&lt;/code&gt;. This preserves the appearance that the data is (also) in the parent table. But the &lt;code&gt;capitals&lt;/code&gt; table could not be updated directly without an additional grant. In a similar way, the parent table's row security policies (see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;) are applied to rows coming from child tables during an inherited query. A child table's policies, if any, are applied only when it is the table explicitly named in the query; and in that case, any policies attached to its parent(s) are ignored.</source>
          <target state="translated">상속 된 쿼리는 부모 테이블에 대해서만 액세스 권한 검사를 수행합니다. 따라서, 예를 들어, 부여 &lt;code&gt;UPDATE&lt;/code&gt; 의 상의 권한을 &lt;code&gt;cities&lt;/code&gt; 테이블은의 업데이트 행에 대한 허가를 의미 &lt;code&gt;capitals&lt;/code&gt; 그들이 통해 액세스 할 때뿐만 아니라 테이블을 &lt;code&gt;cities&lt;/code&gt; . 이렇게하면 부모 테이블에 데이터가있는 것처럼 보이게됩니다. 그러나 추가 보조금 없이는 &lt;code&gt;capitals&lt;/code&gt; 테이블을 직접 업데이트 할 수 없습니다. 비슷한 방식으로 부모 테이블의 행 보안 정책 ( &lt;a href=&quot;ddl-rowsecurity&quot;&gt;섹션 5.8&lt;/a&gt; 참조))는 상속 된 쿼리 중에 자식 테이블에서 오는 행에 적용됩니다. 자식 테이블의 정책 (있는 경우)은 쿼리에서 명시 적으로 명명 된 테이블 인 경우에만 적용됩니다. 이 경우 상위에 연결된 모든 정책은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1f25aac16509c63c647e201e6dca9b42be580c36" translate="yes" xml:space="preserve">
          <source>Initialization Options</source>
          <target state="translated">초기화 옵션</target>
        </trans-unit>
        <trans-unit id="02678e4e52eadddd5b615833652cf8428b2afe6a" translate="yes" xml:space="preserve">
          <source>Initialization option string for the template</source>
          <target state="translated">템플릿의 초기화 옵션 문자열</target>
        </trans-unit>
        <trans-unit id="6528a9644e65de4c79a52fdab1106b0b771a6d92" translate="yes" xml:space="preserve">
          <source>Initialize the new cluster using &lt;code&gt;initdb&lt;/code&gt;. Again, use compatible &lt;code&gt;initdb&lt;/code&gt; flags that match the old cluster. Many prebuilt installers do this step automatically. There is no need to start the new cluster.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 를 사용하여 새 클러스터를 초기화하십시오 . 다시, 이전 클러스터와 일치하는 호환 가능한 &lt;code&gt;initdb&lt;/code&gt; 플래그를 사용 하십시오. 많은 사전 빌드 된 설치 프로그램이이 단계를 자동으로 수행합니다. 새 클러스터를 시작할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a5c551f4615e330d270ad5f3b0629fcdfcd3de2" translate="yes" xml:space="preserve">
          <source>Inner tuples are more complex, since they are branching points in the search tree. Each inner tuple contains a set of one or more &lt;em&gt;nodes&lt;/em&gt;, which represent groups of similar leaf values. A node contains a downlink that leads either to another, lower-level inner tuple, or to a short list of leaf tuples that all lie on the same index page. Each node normally has a &lt;em&gt;label&lt;/em&gt; that describes it; for example, in a radix tree the node label could be the next character of the string value. (Alternatively, an operator class can omit the node labels, if it works with a fixed set of nodes for all inner tuples; see &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;Section 65.4.2&lt;/a&gt;.) Optionally, an inner tuple can have a &lt;em&gt;prefix&lt;/em&gt; value that describes all its members. In a radix tree this could be the common prefix of the represented strings. The prefix value is not necessarily really a prefix, but can be any data needed by the operator class; for example, in a quad-tree it can store the central point that the four quadrants are measured with respect to. A quad-tree inner tuple would then also contain four nodes corresponding to the quadrants around this central point.</source>
          <target state="translated">내부 튜플은 검색 트리의 분기점이므로 더 복잡합니다. 각 내부 튜플에는 유사한 리프 값 그룹을 나타내는 하나 이상의 &lt;em&gt;노드&lt;/em&gt; 집합이 포함 됩니다. 노드에는 다른 하위 레벨 내부 튜플 또는 모두 동일한 색인 페이지에있는 짧은 잎 튜플 목록으로 연결되는 다운 링크가 포함되어 있습니다. 각 노드에는 일반적으로 이를 설명 하는 &lt;em&gt;레이블&lt;/em&gt; 이 있습니다. 예를 들어 기수 트리에서 노드 레이블은 문자열 값의 다음 문자가 될 수 있습니다. (또는 모든 내부 튜플에 대해 고정 된 노드 세트와 함께 작동하는 경우 연산자 클래스는 노드 레이블을 생략 할 수 있습니다 ( &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;섹션 65.4.2&lt;/a&gt; 참조 ). 선택적으로 내부 튜플에는 &lt;em&gt;접두사&lt;/em&gt; 가있을 수 있습니다.&lt;em&gt;&lt;/em&gt;모든 구성원을 설명하는 가치. 기수 트리에서 이는 표현 된 문자열의 공통 접두사 일 수 있습니다. 접두사 값은 반드시 접두사 일 필요는 없지만 연산자 클래스에 필요한 데이터 일 수 있습니다. 예를 들어, 쿼드 트리에는 4 개의 사분면이 측정되는 중심점을 저장할 수 있습니다. 쿼드 트리 내부 튜플은이 중심점 주위의 사분면에 해당하는 4 개의 노드도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0029fb34c419096901cb17ee7f69f8d100b925e7" translate="yes" xml:space="preserve">
          <source>Input Ordering</source>
          <target state="translated">입력 주문</target>
        </trans-unit>
        <trans-unit id="c651bb8d20d59b648e5817a714d081c24490bd28" translate="yes" xml:space="preserve">
          <source>Input String</source>
          <target state="translated">입력 문자열</target>
        </trans-unit>
        <trans-unit id="c42fb65381608e452debc58ec5ce5a7de90ede68" translate="yes" xml:space="preserve">
          <source>Input conversion function (binary format), or 0 if none</source>
          <target state="translated">입력 변환 함수 (이진 형식) 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="6ede32a74b25d24d933316273b8d1a1c5b311742" translate="yes" xml:space="preserve">
          <source>Input conversion function (text format)</source>
          <target state="translated">입력 변환 기능 (텍스트 형식)</target>
        </trans-unit>
        <trans-unit id="445431b172a9cb689a043786c27d77bc63ec81f4" translate="yes" xml:space="preserve">
          <source>Input data is interpreted according to &lt;code&gt;ENCODING&lt;/code&gt; option or the current client encoding, and output data is encoded in &lt;code&gt;ENCODING&lt;/code&gt; or the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server.</source>
          <target state="translated">입력 데이터는 &lt;code&gt;ENCODING&lt;/code&gt; 옵션 또는 현재 클라이언트 인코딩 에 따라 해석되며 , 데이터가 클라이언트를 통과하지 않고 서버에서 직접 파일을 읽거나 파일을 작성하더라도 출력 데이터는 &lt;code&gt;ENCODING&lt;/code&gt; 또는 현재 클라이언트 인코딩으로 인코딩됩니다. .</target>
        </trans-unit>
        <trans-unit id="aa563adcb5d00e2fc3a73ea58d9fd1b265968174" translate="yes" xml:space="preserve">
          <source>Insert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column:</source>
          <target state="translated">분배자를 삽입하거나 기존의 제외 된 행 (행 삽입이 트리거되기 전에 일치하는 제한 컬럼이있는 행)이 존재하는 경우 삽입을 제안 된 행에 대해 아무 것도 수행하지 마십시오. 예에서는 &lt;code&gt;did&lt;/code&gt; 열에 나타나는 값을 제한하는 고유 인덱스가 정의되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1b0022e72f294401989398fe077aa7293c9d0864" translate="yes" xml:space="preserve">
          <source>Insert a new tuple into an existing index. The &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;isnull&lt;/code&gt; arrays give the key values to be indexed, and &lt;code&gt;heap_tid&lt;/code&gt; is the TID to be indexed. If the access method supports unique indexes (its &lt;code&gt;amcanunique&lt;/code&gt; flag is true) then &lt;code&gt;checkUnique&lt;/code&gt; indicates the type of uniqueness check to perform. This varies depending on whether the unique constraint is deferrable; see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt; for details. Normally the access method only needs the &lt;code&gt;heapRelation&lt;/code&gt; parameter when performing uniqueness checking (since then it will have to look into the heap to verify tuple liveness).</source>
          <target state="translated">기존 색인에 새 튜플을 삽입하십시오. &lt;code&gt;values&lt;/code&gt; 과 &lt;code&gt;isnull&lt;/code&gt; 배열은 인덱스 될 키 값을주고, &lt;code&gt;heap_tid&lt;/code&gt; 는 인덱싱 할 수있는 TID입니다. 액세스 방법이 고유 인덱스를 지원하는 경우 ( &lt;code&gt;amcanunique&lt;/code&gt; 플래그는 true) &lt;code&gt;checkUnique&lt;/code&gt; 는 수행 할 고유성 검사 유형을 나타냅니다. 이는 고유 제한 조건이 연기 가능한지 여부에 따라 다릅니다. 자세한 내용 &lt;a href=&quot;index-unique-checks&quot;&gt;은 61.5 절&lt;/a&gt; 을 참조하십시오. 일반적으로 액세스 방법에는 고유성 검사를 수행 할 때 &lt;code&gt;heapRelation&lt;/code&gt; 매개 변수 만 필요합니다 (따라서 튜플 라이브 니스를 확인하려면 힙을 조사해야합니다).</target>
        </trans-unit>
        <trans-unit id="0f674319e8780ea4807c4a4acfb9e949fb5f9a9e" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;distributors&lt;/code&gt;, returning the sequence number generated by the &lt;code&gt;DEFAULT&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 절에 의해 생성 된 시퀀스 번호를 리턴하여 단일 행을 테이블 &lt;code&gt;distributors&lt;/code&gt; 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="632c13df9b06de5c5de5b6f56617f6d898fc7280" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;films&lt;/code&gt; 단일 행을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="3892df53992670e16381ba584272763bbe059b7e" translate="yes" xml:space="preserve">
          <source>Insert new distributor if possible; otherwise &lt;code&gt;DO NOTHING&lt;/code&gt;. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column on a subset of rows where the &lt;code&gt;is_active&lt;/code&gt; Boolean column evaluates to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">가능하면 새 배포자를 삽입하십시오. 그렇지 않으면 &lt;code&gt;DO NOTHING&lt;/code&gt; 하지 마십시오 . 예에서는 &lt;code&gt;is_active&lt;/code&gt; 부울 열이 &lt;code&gt;true&lt;/code&gt; 로 평가되는 행의 하위 집합 에서 &lt;code&gt;did&lt;/code&gt; 열에 나타나는 값을 제한하는 고유 인덱스가 정의되었다고 가정 합니다 .</target>
        </trans-unit>
        <trans-unit id="db80c622e1c5ed5095a7dd936600840392c749b3" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. Note that the special &lt;code&gt;excluded&lt;/code&gt; table is used to reference values originally proposed for insertion:</source>
          <target state="translated">새 배포자를 적절하게 삽입하거나 업데이트하십시오. &lt;code&gt;did&lt;/code&gt; 열에 나타나는 값을 제한하는 고유 인덱스가 정의되었다고 가정합니다 . &lt;code&gt;excluded&lt;/code&gt; 특수 테이블은 원래 삽입을 위해 제안 된 값을 참조하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="449538b0ed8e6f507ea1c64d35164fae0d826023" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. &lt;code&gt;WHERE&lt;/code&gt; clause is used to limit the rows actually updated (any existing row not updated will still be locked, though):</source>
          <target state="translated">새 배포자를 적절하게 삽입하거나 업데이트하십시오. 예에서는 &lt;code&gt;did&lt;/code&gt; 열에 나타나는 값을 제한하는 고유 인덱스가 정의되었다고 가정합니다 . &lt;code&gt;WHERE&lt;/code&gt; 절은 실제로 업데이트 된 행을 제한하는 데 사용됩니다 (업데이트되지 않은 기존 행은 여전히 ​​잠겨 있음).</target>
        </trans-unit>
        <trans-unit id="ae6eaf6a32e43f0bf6ecef28e872215845bae1e6" translate="yes" xml:space="preserve">
          <source>Inserting</source>
          <target state="translated">Inserting</target>
        </trans-unit>
        <trans-unit id="0dd2b481ad724309af4e29174757be7f9ad67dd8" translate="yes" xml:space="preserve">
          <source>Inserting Data</source>
          <target state="translated">데이터 삽입</target>
        </trans-unit>
        <trans-unit id="a58e264f985643a8003e2d8ae2f19f1f44151747" translate="yes" xml:space="preserve">
          <source>Insertion into a GIN index can be slow due to the likelihood of many keys being inserted for each item. So, for bulk insertions into a table it is advisable to drop the GIN index and recreate it after finishing bulk insertion.</source>
          <target state="translated">각 항목에 많은 키를 삽입 할 가능성으로 인해 GIN 색인에 삽입하는 속도가 느려질 수 있습니다. 따라서 테이블에 대량 삽입하려면 대량 삽입을 마친 후에 GIN 색인을 삭제하고 다시 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a514639c0e9db066f2ca50c5677c9c0ad2871adb" translate="yes" xml:space="preserve">
          <source>Inside the crosstab grid, for each distinct value &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;colH&lt;/code&gt; and each distinct value &lt;code&gt;y&lt;/code&gt; of &lt;code&gt;colV&lt;/code&gt;, the cell located at the intersection &lt;code&gt;(x,y)&lt;/code&gt; contains the value of the &lt;code&gt;colD&lt;/code&gt; column in the query result row for which the value of &lt;code&gt;colH&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; and the value of &lt;code&gt;colV&lt;/code&gt; is &lt;code&gt;y&lt;/code&gt;. If there is no such row, the cell is empty. If there are multiple such rows, an error is reported.</source>
          <target state="translated">크로스 탭 그리드 내부 각 고유 값에 대한 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;colH&lt;/code&gt; 각 고유 값 &lt;code&gt;y&lt;/code&gt; 의 &lt;code&gt;colV&lt;/code&gt; , 교차점에 위치하는 셀 &lt;code&gt;(x,y)&lt;/code&gt; 의 값이 포함 된 &lt;code&gt;colD&lt;/code&gt; 가치있는 질의 결과 행 열 &lt;code&gt;colH&lt;/code&gt; 가 입니다 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;colV&lt;/code&gt; 값 은 &lt;code&gt;y&lt;/code&gt; 입니다. 그러한 행이 없으면 셀이 비어 있습니다. 이러한 행이 여러 개인 경우 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b00cb7892b66a87132bdd26b6401b8b521c81e40" translate="yes" xml:space="preserve">
          <source>Inspect the contents of the database to ensure you have recovered to the desired state. If not, return to step 1. If all is well, allow your users to connect by restoring &lt;code&gt;pg_hba.conf&lt;/code&gt; to normal.</source>
          <target state="translated">데이터베이스의 내용을 검사하여 원하는 상태로 복구했는지 확인하십시오. 그렇지 않은 경우 1 단계로 돌아가십시오. 모두 정상 이면 &lt;code&gt;pg_hba.conf&lt;/code&gt; 를 정상 으로 복원하여 사용자가 연결하도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb93c6938a2011d934988eab5986d385a4c4d0be" translate="yes" xml:space="preserve">
          <source>Inspecting the MCV list is possible using &lt;code&gt;pg_mcv_list_items&lt;/code&gt; set-returning function.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list_items&lt;/code&gt; 세트 복귀 기능을 사용하여 MCV리스트 검사가 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="ff17c423681bf713fcd55cb3b3eb644d120028a0" translate="yes" xml:space="preserve">
          <source>Inspired by the original &lt;code&gt;citext&lt;/code&gt; module by Donald Fraser.</source>
          <target state="translated">Donald Fraser 의 원본 &lt;code&gt;citext&lt;/code&gt; 모듈 에서 영감을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="e2f807d3934f67c59236ce54638758a511971353" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g. &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g. &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="translated">예를 들어, 새 클러스터로 기존 클러스터에서 사용하는 모든 사용자 정의 공유 객체 파일 (또는 DLL을)를 설치 &lt;code&gt;pgcrypto.so&lt;/code&gt; 가에서인지, &lt;code&gt;contrib&lt;/code&gt; 이나 다른 소스. 스키마 정의 (예 : &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt; )는 이전 클러스터에서 업그레이드되므로 설치하지 마십시오 . 또한 사용자 정의 전체 텍스트 검색 파일 (사전, 동의어, 동의어 사전, 중지 단어)도 새 클러스터에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="34a5a70619c2c19e2c9702b13c9847e5c653791a" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database:</source>
          <target state="translated">현재 데이터베이스에 &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; 확장을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f7a627a6509f6c7b363a56555a0d35366acc62" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;postgres_fdw&lt;/code&gt; extension using &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION을&lt;/a&gt; 사용하여 &lt;code&gt;postgres_fdw&lt;/code&gt; 확장을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="9684579d3e7c9b1f5825f61e639d95625abccadc" translate="yes" xml:space="preserve">
          <source>Install the new server's binaries and support files. pg_upgrade is included in a default installation.</source>
          <target state="translated">새 서버의 바이너리 및 지원 파일을 설치하십시오. pg_upgrade는 기본 설치에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2992c5a571b6edb98a5bf527c86c020a33e35d" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;섹션 16.4에&lt;/a&gt; 요약 된대로 새 버전의 PostgreSQL을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="90075fb521dd4d59c46ee65abf78d28b40851d8c" translate="yes" xml:space="preserve">
          <source>Install the same custom shared object files on the new standbys that you installed in the new primary cluster.</source>
          <target state="translated">새 기본 클러스터에 설치 한 새 대기에 동일한 사용자 정의 공유 오브젝트 파일을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="00a4641a5ec01b91ac5755c29e1f7d10ca370b2e" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_int&lt;/code&gt; extension creates a text search template &lt;code&gt;intdict_template&lt;/code&gt; and a dictionary &lt;code&gt;intdict&lt;/code&gt; based on it, with the default parameters. You can alter the parameters, for example</source>
          <target state="translated">&lt;code&gt;dict_int&lt;/code&gt; 확장을 설치하면 기본 매개 변수를 사용하여 텍스트 검색 템플리트 &lt;code&gt;intdict_template&lt;/code&gt; 및이를 기반으로 하는 사전 &lt;code&gt;intdict&lt;/code&gt; 가 작성됩니다. 예를 들어 매개 변수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88a4b249e71fce074c62157e59fbc27119675b0b" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_xsyn&lt;/code&gt; extension creates a text search template &lt;code&gt;xsyn_template&lt;/code&gt; and a dictionary &lt;code&gt;xsyn&lt;/code&gt; based on it, with default parameters. You can alter the parameters, for example</source>
          <target state="translated">&lt;code&gt;dict_xsyn&lt;/code&gt; 확장을 설치하면 기본 매개 변수를 사용하여 텍스트 검색 템플리트 &lt;code&gt;xsyn_template&lt;/code&gt; 및이를 기반으로 하는 사전 &lt;code&gt;xsyn&lt;/code&gt; 이 작성됩니다. 예를 들어 매개 변수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf52efd63633f939852f89750e72d737a7ef8451" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;unaccent&lt;/code&gt; extension creates a text search template &lt;code&gt;unaccent&lt;/code&gt; and a dictionary &lt;code&gt;unaccent&lt;/code&gt; based on it. The &lt;code&gt;unaccent&lt;/code&gt; dictionary has the default parameter setting &lt;code&gt;RULES='unaccent'&lt;/code&gt;, which makes it immediately usable with the standard &lt;code&gt;unaccent.rules&lt;/code&gt; file. If you wish, you can alter the parameter, for example</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 확장을 설치하면 텍스트 검색 템플릿이 &lt;code&gt;unaccent&lt;/code&gt; 없고 텍스트 기반 의 사전이 &lt;code&gt;unaccent&lt;/code&gt; 없습니다. &lt;code&gt;unaccent&lt;/code&gt; 사전은 기본 파라미터 설정이 &lt;code&gt;RULES='unaccent'&lt;/code&gt; 표준에 즉시 사용할 수 있습니다, &lt;code&gt;unaccent.rules&lt;/code&gt; 파일을. 원하는 경우 매개 변수를 변경할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="5b4ebcd87748b86d7b51facd78d76e7b88a0adf7" translate="yes" xml:space="preserve">
          <source>Instead of an expression, &lt;code&gt;*&lt;/code&gt; can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write &lt;code&gt;table_name.*&lt;/code&gt; as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with &lt;code&gt;AS&lt;/code&gt;; the output column names will be the same as the table columns' names.</source>
          <target state="translated">표현식 대신에 &lt;code&gt;*&lt;/code&gt; 를 선택된 행의 모든 ​​열에 대한 속기로 출력 목록에 쓸 수 있습니다. 또한 &lt;code&gt;table_name.*&lt;/code&gt; 을 해당 테이블에서 오는 열의 약어로 작성할 수 있습니다 . 이 경우 &lt;code&gt;AS&lt;/code&gt; 로 새 이름을 지정할 수 없습니다 . 출력 열 이름은 테이블 열 이름과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a6521c09d55a0d983da28cb3b1223e411f459cda" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;amgettuple&lt;/code&gt;, an index scan can be done with &lt;code&gt;amgetbitmap&lt;/code&gt; to fetch all tuples in one call. This can be noticeably more efficient than &lt;code&gt;amgettuple&lt;/code&gt; because it allows avoiding lock/unlock cycles within the access method. In principle &lt;code&gt;amgetbitmap&lt;/code&gt; should have the same effects as repeated &lt;code&gt;amgettuple&lt;/code&gt; calls, but we impose several restrictions to simplify matters. First of all, &lt;code&gt;amgetbitmap&lt;/code&gt; returns all tuples at once and marking or restoring scan positions isn't supported. Secondly, the tuples are returned in a bitmap which doesn't have any specific ordering, which is why &lt;code&gt;amgetbitmap&lt;/code&gt; doesn't take a &lt;code&gt;direction&lt;/code&gt; argument. (Ordering operators will never be supplied for such a scan, either.) Also, there is no provision for index-only scans with &lt;code&gt;amgetbitmap&lt;/code&gt;, since there is no way to return the contents of index tuples. Finally, &lt;code&gt;amgetbitmap&lt;/code&gt; does not guarantee any locking of the returned tuples, with implications spelled out in &lt;a href=&quot;index-locking&quot;&gt;Section 61.4&lt;/a&gt;.</source>
          <target state="translated">대신에 사용하는 &lt;code&gt;amgettuple&lt;/code&gt; 를 , 인덱스 스캔을 수행 할 수 있습니다 &lt;code&gt;amgetbitmap&lt;/code&gt; 한 전화에있는 모든 튜플을 가져. 액세스 방법 내에서 잠금 / 잠금 해제주기를 피할 수 있기 때문에 &lt;code&gt;amgettuple&lt;/code&gt; 보다 훨씬 효율적일 수 있습니다 . 기본적으로 &lt;code&gt;amgetbitmap&lt;/code&gt; 은 반복적 인 &lt;code&gt;amgettuple&lt;/code&gt; 호출 과 동일한 효과를 가져야 하지만 문제를 단순화하기 위해 몇 가지 제한을 적용합니다. 우선, &lt;code&gt;amgetbitmap&lt;/code&gt; 은 모든 튜플을 한 번에 반환하며 스캔 위치 표시 또는 복원은 지원되지 않습니다. 둘째, 튜플은 특정 순서가없는 비트 맵으로 반환되므로 &lt;code&gt;amgetbitmap&lt;/code&gt; 이 &lt;code&gt;direction&lt;/code&gt; 취하지 않는 이유논의. (주문 연산자는 이러한 스캔에도 제공되지 않습니다.) 또한 인덱스 튜플의 컨텐츠를 리턴 할 방법이 없으므로 &lt;code&gt;amgetbitmap&lt;/code&gt; 을 사용 하여 인덱스 전용 스캔을 제공 할 수 없습니다. 마지막으로, &lt;code&gt;amgetbitmap&lt;/code&gt; 은 반환 된 튜플의 잠금을 보장하지 않으며 &lt;a href=&quot;index-locking&quot;&gt;61.4 절에&lt;/a&gt; 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="d79849f61d583b44d9d0fdc8025d98ffb5bbfd35" translate="yes" xml:space="preserve">
          <source>Instead of writing &lt;code&gt;ONLY&lt;/code&gt; before the table name, you can write &lt;code&gt;*&lt;/code&gt; after the table name to explicitly specify that descendant tables are included. There is no real reason to use this syntax any more, because searching descendant tables is now always the default behavior. However, it is supported for compatibility with older releases.</source>
          <target state="translated">테이블 이름 &lt;code&gt;ONLY&lt;/code&gt; 쓰는 대신 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 쓰면 하위 테이블이 포함되도록 명시 적으로 지정할 수 있습니다. 하위 테이블 검색은 항상 기본 동작이므로이 구문을 더 이상 사용할 이유가 없습니다. 그러나 이전 릴리스와의 호환성을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4a1635249102b1ddea4769929b8a71df3f648e09" translate="yes" xml:space="preserve">
          <source>Institute of Electrical and Electronics Engineers</source>
          <target state="translated">전기 전자 공학회</target>
        </trans-unit>
        <trans-unit id="e877a09ab092ea6de15878a42ea4226bbdc6693d" translate="yes" xml:space="preserve">
          <source>Integer bit mask indicating which arguments are not being included in the current grouping set</source>
          <target state="translated">현재 그룹화 세트에 포함되지 않은 인수를 나타내는 정수 비트 마스크</target>
        </trans-unit>
        <trans-unit id="897c83dd3fcb5ef382c1b65917bd9be2f5323fd2" translate="yes" xml:space="preserve">
          <source>Inter-Process Communication</source>
          <target state="translated">프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="d85d227df828a06ee1ce26f9f247a35c482de85a" translate="yes" xml:space="preserve">
          <source>Interesting idea for picking passwords.</source>
          <target state="translated">비밀번호 선택에 대한 흥미로운 아이디어.</target>
        </trans-unit>
        <trans-unit id="457737863c2801b7971002cd15c9223e0c9b404e" translate="yes" xml:space="preserve">
          <source>Interfacing with monitoring software to report errors</source>
          <target state="translated">모니터링 소프트웨어와 인터페이스하여 오류보고</target>
        </trans-unit>
        <trans-unit id="bc34e531672634aab3b26d4017b45aa2bbc7b3db" translate="yes" xml:space="preserve">
          <source>Interfacing with other backup and recovery software</source>
          <target state="translated">다른 백업 및 복구 소프트웨어와 인터페이스</target>
        </trans-unit>
        <trans-unit id="087813fa40caa10b888af01dbc97f7437b81b67d" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set. (See &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; for diagrams showing SSL certificate usage.)</source>
          <target state="translated">클라이언트에 저장하지 않으려는 경우 (루트 및 중간 인증서가 &lt;code&gt;v3_ca&lt;/code&gt; 확장자 로 작성된 경우) 기존 루트 인증서에 연결되는 중간 인증서도 &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; 파일에 나타날 수 있습니다 . &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; 매개 변수 가 설정되어 있으면 CRL (인증서 해지 목록) 항목도 확인됩니다 . SSL 인증서 사용을 보여주는 다이어그램 은 &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6ed083a1fd80d11b5474ab6a44b299da8513f67" translate="yes" xml:space="preserve">
          <source>Internal data structures such as &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;pg_subtrans&lt;/code&gt;, &lt;code&gt;pg_multixact&lt;/code&gt;, &lt;code&gt;pg_serial&lt;/code&gt;, &lt;code&gt;pg_notify&lt;/code&gt;, &lt;code&gt;pg_stat&lt;/code&gt;, &lt;code&gt;pg_snapshots&lt;/code&gt; are not directly checksummed, nor are pages protected by full page writes. However, where such data structures are persistent, WAL records are written that allow recent changes to be accurately rebuilt at crash recovery and those WAL records are protected as discussed above.</source>
          <target state="translated">&lt;code&gt;pg_xact&lt;/code&gt; , &lt;code&gt;pg_subtrans&lt;/code&gt; , &lt;code&gt;pg_multixact&lt;/code&gt; , &lt;code&gt;pg_serial&lt;/code&gt; , &lt;code&gt;pg_notify&lt;/code&gt; , &lt;code&gt;pg_stat&lt;/code&gt; , &lt;code&gt;pg_snapshots&lt;/code&gt; 와 같은 내부 데이터 구조 는 직접 체크섬되지 않으며 페이지를 전체 페이지 쓰기로 보호하지 않습니다. 그러나 이러한 데이터 구조가 지속되는 경우 응급 복구시 최근 변경 내용을 정확하게 다시 작성할 수 있도록 WAL 레코드가 작성되며 이러한 WAL 레코드는 위에서 설명한대로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="210293c0eebe094c6cf4191095ebf7c83ba53d58" translate="yes" xml:space="preserve">
          <source>Internal hash code, computed from the statement's parse tree</source>
          <target state="translated">명령문의 구문 분석 트리에서 계산 된 내부 해시 코드</target>
        </trans-unit>
        <trans-unit id="e2daadb2e211983a80b38897bed9d140e91cd8e5" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;interval&lt;/code&gt; values are stored as months, days, and seconds. This is done because the number of days in a month varies, and a day can have 23 or 25 hours if a daylight savings time adjustment is involved. The months and days fields are integers while the seconds field can store fractions. Because intervals are usually created from constant strings or &lt;code&gt;timestamp&lt;/code&gt; subtraction, this storage method works well in most cases, but can cause unexpected results:</source>
          <target state="translated">내부 &lt;code&gt;interval&lt;/code&gt; 값은 월, 일 및 초로 저장됩니다. 이는 한 달의 일 수가 다르고 일광 절약 시간제 조정이 포함 된 경우 하루에 23 시간 또는 25 시간이있을 수 있기 때문에 수행됩니다. 월 및 일 필드는 정수이고 초 필드는 분수를 저장할 수 있습니다. 간격은 일반적으로 상수 문자열 또는 &lt;code&gt;timestamp&lt;/code&gt; 빼기 에서 만들어 지므로이 저장 방법은 대부분의 경우 잘 작동하지만 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d68b94ef37a16fd1db6257f62457d5c440b435" translate="yes" xml:space="preserve">
          <source>Internally, a GIN index contains a B-tree index constructed over keys, where each key is an element of one or more indexed items (a member of an array, for example) and where each tuple in a leaf page contains either a pointer to a B-tree of heap pointers (a &amp;ldquo;posting tree&amp;rdquo;), or a simple list of heap pointers (a &amp;ldquo;posting list&amp;rdquo;) when the list is small enough to fit into a single index tuple along with the key value. &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;Figure 66.1&lt;/a&gt; illustrates these components of a GIN index.</source>
          <target state="translated">내부적으로 GIN 인덱스는 키에 대해 구성된 B- 트리 인덱스를 포함합니다. 여기서 각 키는 하나 이상의 인덱싱 된 항목 (예 : 배열의 멤버)의 요소이며 리프 페이지의 각 튜플은 리스트가 키 값과 함께 단일 인덱스 튜플에 맞을만큼 작을 때 힙 포인터의 B- 트리 ( &quot;포스팅 트리&quot;) 또는 간단한 힙 포인터 목록 ( &quot;포스팅 목록&quot;). &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;그림 66.1&lt;/a&gt; 은 이러한 GIN 인덱스 구성 요소를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7c7cae0387037fdfc011139b31adb37771e499bb" translate="yes" xml:space="preserve">
          <source>Internally, all these types use the same representation (a 64-bit integer), and all are interchangeable. Multiple types are provided to control display formatting and to permit tighter validity checking of input that is supposed to denote one particular type of number.</source>
          <target state="translated">내부적으로 이러한 모든 유형은 동일한 표현 (64 비트 정수)을 사용하며 모두 호환 가능합니다. 디스플레이 형식을 제어하고 특정 유형의 숫자를 나타내는 입력의 유효성 검사를보다 엄격하게하기 위해 여러 유형이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="801996043d0146904ef0a7b7426c0b0decab6e65" translate="yes" xml:space="preserve">
          <source>Internally, an LSN is a 64-bit integer, representing a byte position in the write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 digits each, separated by a slash; for example, &lt;code&gt;16/B374D848&lt;/code&gt;. The &lt;code&gt;pg_lsn&lt;/code&gt; type supports the standard comparison operators, like &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. Two LSNs can be subtracted using the &lt;code&gt;-&lt;/code&gt; operator; the result is the number of bytes separating those write-ahead log locations.</source>
          <target state="translated">내부적으로 LSN은 미리 쓰기 로그 스트림에서 바이트 위치를 나타내는 64 비트 정수입니다. 슬래시로 구분하여 각각 최대 8 자리의 두 개의 16 진수로 인쇄됩니다. 예를 들어 &lt;code&gt;16/B374D848&lt;/code&gt; 입니다. &lt;code&gt;pg_lsn&lt;/code&gt; 의 유형은 표준 비교 연산자와 같은 지원 &lt;code&gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;code&gt;-&lt;/code&gt; 연산자를 사용하여 두 개의 LSN을 뺄 수 있습니다 . 결과는 미리 쓰기 로그 위치를 분리하는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="68baab823cf9c4d570311e278e9e088b97918aa9" translate="yes" xml:space="preserve">
          <source>Internals: BRIN Indexes</source>
          <target state="translated">내부 : BRIN 지수</target>
        </trans-unit>
        <trans-unit id="30d8bd593f993584038a1e0fe42a81f00b0963a3" translate="yes" xml:space="preserve">
          <source>Internals: Catalogs</source>
          <target state="translated">내부 : 카탈로그</target>
        </trans-unit>
        <trans-unit id="3af4bd3be7009ecb5492dd21a7a43e553ce2cd0e" translate="yes" xml:space="preserve">
          <source>Internals: GIN Indexes</source>
          <target state="translated">내부 : GIN 지수</target>
        </trans-unit>
        <trans-unit id="dc575f859035c87eddb3703eb9f32faa91a064d5" translate="yes" xml:space="preserve">
          <source>Internals: Genetic Query Optimizer</source>
          <target state="translated">내부 : 유전자 쿼리 최적화 프로그램</target>
        </trans-unit>
        <trans-unit id="2fdd0d171f1a82304db06140f5b0e0b132641e9d" translate="yes" xml:space="preserve">
          <source>Internals: GiST Indexes</source>
          <target state="translated">내부 : GiST 지수</target>
        </trans-unit>
        <trans-unit id="3353317a88b7d0fe5733c291ee0c6066760bb027" translate="yes" xml:space="preserve">
          <source>Internals: Index Access Method</source>
          <target state="translated">내부 : 색인 액세스 방법</target>
        </trans-unit>
        <trans-unit id="2cfa78663fb409507ad30892f6c62ca88915c849" translate="yes" xml:space="preserve">
          <source>Internals: Physical Storage</source>
          <target state="translated">내부 : 물리적 저장</target>
        </trans-unit>
        <trans-unit id="72bd21b653073da0193a18c2b147b4e07c551c2d" translate="yes" xml:space="preserve">
          <source>Internals: SP-GiST Indexes</source>
          <target state="translated">내부 : SP-GiST 인덱스</target>
        </trans-unit>
        <trans-unit id="9a4222dfc9fdc77f19f92dba6e20438075629f39" translate="yes" xml:space="preserve">
          <source>International Electrotechnical Commission</source>
          <target state="translated">국제 전자 기술위원회</target>
        </trans-unit>
        <trans-unit id="efd83bf4b70a77811c228aa3f499876839b1a079" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization</source>
          <target state="translated">국제 표준화기구</target>
        </trans-unit>
        <trans-unit id="2bafd8d16b13f2565f9ae12e4063fa2d0cddcfb9" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">새로운 EAN13 디스플레이 형식으로 표시 될 국제 표준 도서 번호</target>
        </trans-unit>
        <trans-unit id="08b688b4eb6cf112f11ba47bac6e099bfb8d453f" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the old short display format</source>
          <target state="translated">기존의 짧은 표시 형식으로 표시 될 국제 표준 도서 번호</target>
        </trans-unit>
        <trans-unit id="ebb2e09bb43f37cc7a01fd763ee8d3845536f4c8" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">새로운 EAN13 디스플레이 형식으로 표시 될 국제 표준 음악 번호</target>
        </trans-unit>
        <trans-unit id="ef34d5e58a9ceadea54e7a66e1ff9112f05b0da0" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the old short display format</source>
          <target state="translated">기존의 짧은 표시 형식으로 표시 될 국제 표준 음악 번호</target>
        </trans-unit>
        <trans-unit id="8dd6340c1b5827c9a707b92916af32dcdcd785bc" translate="yes" xml:space="preserve">
          <source>International Standard Serial Number</source>
          <target state="translated">국제 표준 일련 번호</target>
        </trans-unit>
        <trans-unit id="4e1c1c5e087cdba177b1e3d204777d49f8f64412" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">새로운 EAN13 디스플레이 형식으로 표시 될 국제 표준 일련 번호</target>
        </trans-unit>
        <trans-unit id="105b56360755198078a6d52573dd0840458a5750" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the old short display format</source>
          <target state="translated">기존의 짧은 표시 형식으로 표시 될 국제 표준 일련 번호</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="8fa33d4271f21b38b9499a714668d1694939db92" translate="yes" xml:space="preserve">
          <source>Interpreting Results</source>
          <target state="translated">결과 해석</target>
        </trans-unit>
        <trans-unit id="27d548cba7b30ac38c7cf5611fd348dac11ee53d" translate="yes" xml:space="preserve">
          <source>Interpreting the actual data can only be done with information obtained from other tables, mostly &lt;code&gt;pg_attribute&lt;/code&gt;. The key values needed to identify field locations are &lt;code&gt;attlen&lt;/code&gt; and &lt;code&gt;attalign&lt;/code&gt;. There is no way to directly get a particular attribute, except when there are only fixed width fields and no null values. All this trickery is wrapped up in the functions &lt;em&gt;heap_getattr&lt;/em&gt;, &lt;em&gt;fastgetattr&lt;/em&gt; and &lt;em&gt;heap_getsysattr&lt;/em&gt;.</source>
          <target state="translated">실제 데이터 해석은 다른 테이블에서 얻은 정보 (주로 &lt;code&gt;pg_attribute&lt;/code&gt; ) 로만 수행 할 수 있습니다 . 필드 위치를 식별하는 데 필요한 키 값이된다 &lt;code&gt;attlen&lt;/code&gt; 및 &lt;code&gt;attalign&lt;/code&gt; . 고정 너비 필드 만 있고 널값이없는 경우를 제외하고는 특정 속성을 직접 가져올 수있는 방법이 없습니다. 이 모든 속임수는 &lt;em&gt;heap_getattr&lt;/em&gt; , &lt;em&gt;fastgetattr&lt;/em&gt; 및 &lt;em&gt;heap_getsysattr&lt;/em&gt; 함수에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24238f9afeb08c45bbce6cbe5bfc823ad38ca9fd" translate="yes" xml:space="preserve">
          <source>Intersects?</source>
          <target state="translated">Intersects?</target>
        </trans-unit>
        <trans-unit id="4e15cd1f984843596070878cf276c50b3a281208" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</source>
          <target state="translated">간격에서 &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; 에 &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264b54df84208c3c82823ada24d9901903b36609" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;y&lt;/code&gt; 까지의 간격</target>
        </trans-unit>
        <trans-unit id="d6c942376df50e42c9c8ec0a3deb9eba3459225b" translate="yes" xml:space="preserve">
          <source>Interval values can also be written as ISO 8601 time intervals, using either the &amp;ldquo;format with designators&amp;rdquo; of the standard's section 4.4.3.2 or the &amp;ldquo;alternative format&amp;rdquo; of section 4.4.3.3. The format with designators looks like this:</source>
          <target state="translated">간격 값은 표준 섹션 4.4.3.2의 &quot;지정자가있는 형식&quot;또는 섹션 4.4.3.3의 &quot;대체 형식&quot;을 사용하여 ISO 8601 시간 간격으로 기록 될 수도 있습니다. 부호가있는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e96fd04cfd40c6866ae4fadc2523f325bbca5474" translate="yes" xml:space="preserve">
          <source>Intuitively, the larger the &lt;code&gt;parameter&lt;/code&gt;, the more frequently values close to &lt;code&gt;min&lt;/code&gt; are accessed, and the less frequently values close to &lt;code&gt;max&lt;/code&gt; are accessed. The closer to 0 &lt;code&gt;parameter&lt;/code&gt; is, the flatter (more uniform) the access distribution. A crude approximation of the distribution is that the most frequent 1% values in the range, close to &lt;code&gt;min&lt;/code&gt;, are drawn &lt;code&gt;parameter&lt;/code&gt;% of the time. The &lt;code&gt;parameter&lt;/code&gt; value must be strictly positive.</source>
          <target state="translated">직관적으로 &lt;code&gt;parameter&lt;/code&gt; 가 클수록 &lt;code&gt;min&lt;/code&gt; 에 가까운 값에 더 자주 액세스하고 &lt;code&gt;max&lt;/code&gt; 에 가까운 값에 덜 액세스합니다. 0에 가까워 &lt;code&gt;parameter&lt;/code&gt; 상기 편평 (균일) 액세스 분포이다. 분포의 대략적인 근사값은 &lt;code&gt;min&lt;/code&gt; 에 가까운 범위에서 가장 빈번한 1 % 값 이 시간의 &lt;code&gt;parameter&lt;/code&gt; %로 그려진다 는 것입니다. &lt;code&gt;parameter&lt;/code&gt; 값은 엄격하게 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d4c4d2a44d0c1732fb4957da686a2c8c6fd4c621" translate="yes" xml:space="preserve">
          <source>Inverse transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">이동 집계 모드에 대한 역 전이 기능 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="28b7eaaae619dbbc89f335962aef4470def2f3e3" translate="yes" xml:space="preserve">
          <source>Invoke &lt;code&gt;VACUUM&lt;/code&gt; on the standard tables.</source>
          <target state="translated">표준 테이블에서 &lt;code&gt;VACUUM&lt;/code&gt; 을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3018fd4dab61ebc08a8223638bc64040a2d9e057" translate="yes" xml:space="preserve">
          <source>Is above (allows touching)?</source>
          <target state="translated">위가 (만져도됩니까)?</target>
        </trans-unit>
        <trans-unit id="da6fc6925748c3c1aaf71338cad9d5f477a2383e" translate="yes" xml:space="preserve">
          <source>Is below (allows touching)?</source>
          <target state="translated">아래에 있습니까 (만질 수 있습니까)?</target>
        </trans-unit>
        <trans-unit id="ea56f04ac22e5eca73342cefd404d9c1b002af61" translate="yes" xml:space="preserve">
          <source>Is horizontal?</source>
          <target state="translated">수평입니까?</target>
        </trans-unit>
        <trans-unit id="c9fe9c5adbc8c22895dcd6a5a3619390deb9964a" translate="yes" xml:space="preserve">
          <source>Is perpendicular?</source>
          <target state="translated">수직입니까?</target>
        </trans-unit>
        <trans-unit id="fefaf9d6dfa31078880e5655df30026e38004358" translate="yes" xml:space="preserve">
          <source>Is strictly above?</source>
          <target state="translated">엄밀히 위입니까?</target>
        </trans-unit>
        <trans-unit id="a05cc4a278817fbe41225c1212990f7a42609499" translate="yes" xml:space="preserve">
          <source>Is strictly below?</source>
          <target state="translated">아래는 엄격합니까?</target>
        </trans-unit>
        <trans-unit id="b70722f5747da5b37c94b2e21f108653a4a0d9d2" translate="yes" xml:space="preserve">
          <source>Is strictly left of?</source>
          <target state="translated">엄격하게 남았습니까?</target>
        </trans-unit>
        <trans-unit id="c41dadb911bf56e59cfeff92444afa779a0c9714" translate="yes" xml:space="preserve">
          <source>Is strictly right of?</source>
          <target state="translated">엄격히 맞습니까?</target>
        </trans-unit>
        <trans-unit id="0992b021bae889bee0f11abcbb95dee7929e73aa" translate="yes" xml:space="preserve">
          <source>Is the collation deterministic?</source>
          <target state="translated">데이터 정렬이 결정적입니까?</target>
        </trans-unit>
        <trans-unit id="8a25c1b43d537dd1a7d2ddd1e8080433f5e3eacd" translate="yes" xml:space="preserve">
          <source>Is the constraint deferrable?</source>
          <target state="translated">제약이 지연 될 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fef490f8fe9dee88c33c6a89d30667da1bd2fb9a" translate="yes" xml:space="preserve">
          <source>Is the constraint deferred by default?</source>
          <target state="translated">제약 조건이 기본적으로 지연됩니까?</target>
        </trans-unit>
        <trans-unit id="db516f5dadc3d5e25dea043648eeea3321f5ccdb" translate="yes" xml:space="preserve">
          <source>Is the page dirty?</source>
          <target state="translated">페이지가 더럽습니까?</target>
        </trans-unit>
        <trans-unit id="7a5b28f2abec65dff2a005cef1bab93ce79757ac" translate="yes" xml:space="preserve">
          <source>Is the policy permissive or restrictive?</source>
          <target state="translated">정책이 허용 또는 제한적인가?</target>
        </trans-unit>
        <trans-unit id="272dd553360faca6d08c14d4f1b40a013a88fc82" translate="yes" xml:space="preserve">
          <source>Is vertical?</source>
          <target state="translated">수직입니까?</target>
        </trans-unit>
        <trans-unit id="04fa9226f0713bae8b60402f090506b8771675ec" translate="yes" xml:space="preserve">
          <source>Isolation Level</source>
          <target state="translated">격리 수준</target>
        </trans-unit>
        <trans-unit id="5ef461ce76cd9304ad8686fa89152e4b6011f931" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries support splitting compound words; a useful feature. Notice that the affix file should specify a special flag using the &lt;code&gt;compoundwords controlled&lt;/code&gt; statement that marks dictionary words that can participate in compound formation:</source>
          <target state="translated">Ispell 사전은 복합 단어 분리를 지원합니다. 유용한 기능입니다. 접미사 파일은 복합어 구성에 참여할 수있는 사전 단어를 표시 하는 &lt;code&gt;compoundwords controlled&lt;/code&gt; 명령문을 사용하여 특수 플래그를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a44764c80f1ba0b240d3f5d527b95ad90a01a872" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries usually recognize a limited set of words, so they should be followed by another broader dictionary; for example, a Snowball dictionary, which recognizes everything.</source>
          <target state="translated">Ispell 사전은 일반적으로 제한된 단어 세트를 인식하므로 더 넓은 사전을 따라야합니다. 예를 들어 모든 것을 인식하는 Snowball 사전입니다.</target>
        </trans-unit>
        <trans-unit id="d78243d5b6a6182e6f2ddf831b4aabfb7caae3f0" translate="yes" xml:space="preserve">
          <source>Issues a verification prompt before doing anything destructive.</source>
          <target state="translated">파괴적인 일을하기 전에 확인 프롬프트를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="f4c1344e1b107a94e97cb2d1c0387b09d48b1998" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ABORT&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">트랜잭션 블록 외부에서 &lt;code&gt;ABORT&lt;/code&gt; 를 발행 하면 경고가 발생하고 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51092034eb6099bfab57ce2cf44c57b972ed851c" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;BEGIN&lt;/code&gt; when already inside a transaction block will provoke a warning message. The state of the transaction is not affected. To nest transactions within a transaction block, use savepoints (see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;).</source>
          <target state="translated">이미 트랜잭션 블록 내에있을 때 &lt;code&gt;BEGIN&lt;/code&gt; 을 발행 하면 경고 메시지가 나타납니다. 트랜잭션 상태는 영향을받지 않습니다. 트랜잭션 블록 내에 트랜잭션을 중첩 시키려면 저장 점을 사용하십시오 ( &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1c66e92badb172759ea8ab0365668fbc4bfcd29b" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;COMMIT&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message. &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; when not inside a transaction is an error.</source>
          <target state="translated">트랜잭션 내부에 있지 않을 때 &lt;code&gt;COMMIT&lt;/code&gt; 를 발행 해도 아무런 해가 없지만 경고 메시지가 나타납니다. 트랜잭션 내에 있지 않을 때 &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; 은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d8f2914a3de77623d7fcc2d76c1402e19f0682c2" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;END&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message.</source>
          <target state="translated">트랜잭션 내부에 있지 않을 때 &lt;code&gt;END&lt;/code&gt; 를 발행 해도 아무런 해가 없지만 경고 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9a3f1f230232d57deb86f9d1d1a7e859eaa17234" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ROLLBACK&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect. &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; outside of a transaction block is an error.</source>
          <target state="translated">트랜잭션 블록 외부에서 &lt;code&gt;ROLLBACK&lt;/code&gt; 을 발행 하면 경고가 표시되고 그렇지 않으면 영향을 미치지 않습니다. 트랜잭션 블록 외부의 &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1dd72b5f30a56642ade69ef87bd0dd32591ebc8c" translate="yes" xml:space="preserve">
          <source>It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, &lt;code&gt;EXCEPT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, &lt;code&gt;OFFSET&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;FOR&lt;/code&gt; locking clauses can be used with &lt;code&gt;TABLE&lt;/code&gt;; the &lt;code&gt;WHERE&lt;/code&gt; clause and any form of aggregation cannot be used.</source>
          <target state="translated">복잡한 쿼리의 일부에서 최상위 명령 또는 공간 절약형 구문 변형으로 사용할 수 있습니다. 만 &lt;code&gt;WITH&lt;/code&gt; 은 , &lt;code&gt;UNION&lt;/code&gt; 은 , &lt;code&gt;INTERSECT&lt;/code&gt; 는 , &lt;code&gt;EXCEPT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; , &lt;code&gt;OFFSET&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; 및 &lt;code&gt;FOR&lt;/code&gt; 사용할 수 있습니다 절을 잠금 &lt;code&gt;TABLE&lt;/code&gt; ; &lt;code&gt;WHERE&lt;/code&gt; 의 조항 및 집계의 형태는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="985845c593d43702ba4580f789c62a95ef3e445a" translate="yes" xml:space="preserve">
          <source>It can return 2 special key IDs:</source>
          <target state="translated">두 개의 특수 키 ID를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06e730d80da388853db0ab9a33a7b2a082e1e65" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="translated">복제 모드 연결을 작성하므로 &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt; 과 동일한 제한 조건과 논리적 복제에 대한 제한 조건이 적용됩니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ee4e1383f1e9f315e70a9d76f0a1946de5a791a1" translate="yes" xml:space="preserve">
          <source>It does not matter which order the opposite corners of a cube are entered in. The &lt;code&gt;cube&lt;/code&gt; functions automatically swap values if needed to create a uniform &amp;ldquo;lower left &amp;mdash; upper right&amp;rdquo; internal representation. When the corners coincide, &lt;code&gt;cube&lt;/code&gt; stores only one corner along with an &amp;ldquo;is point&amp;rdquo; flag to avoid wasting space.</source>
          <target state="translated">큐브의 반대쪽 모서리를 입력 한 순서는 중요하지 않습니다. &lt;code&gt;cube&lt;/code&gt; 기능은 균일 한 &quot;왼쪽 아래-오른쪽 위&quot;내부 표현을 작성해야하는 경우 값을 자동으로 교환합니다. 모서리가 일치하면 &lt;code&gt;cube&lt;/code&gt; 는 공간 낭비를 피하기 위해 &quot;is point&quot;플래그와 함께 하나의 모서리 만 저장합니다.</target>
        </trans-unit>
        <trans-unit id="aeb260c8d10781feddd45ff6a16008fdceb285b4" translate="yes" xml:space="preserve">
          <source>It does so by first creating all possible &lt;em&gt;paths&lt;/em&gt; leading to the same result. For example if there is an index on a relation to be scanned, there are two paths for the scan. One possibility is a simple sequential scan and the other possibility is to use the index. Next the cost for the execution of each path is estimated and the cheapest path is chosen. The cheapest path is expanded into a complete plan that the executor can use.</source>
          <target state="translated">먼저 가능한 모든 &lt;em&gt;경로를&lt;/em&gt; 만들어 동일한 결과를 얻습니다. 예를 들어 스캔 할 관계에 대한 인덱스가있는 경우 스캔 경로는 두 가지입니다. 하나는 간단한 순차 스캔이고 다른 하나는 인덱스를 사용하는 것입니다. 다음으로 각 경로의 실행 비용이 추정되고 가장 저렴한 경로가 선택됩니다. 가장 저렴한 경로는 실행자가 사용할 수있는 완전한 계획으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="22062c54b59724e3ba4ff79971e8d1516ebd1cef" translate="yes" xml:space="preserve">
          <source>It does this by skipping pages that have only visible tuples according to the visibility map (if a page has the corresponding VM bit set, then it is assumed to contain no dead tuples). For such pages, it derives the free space value from the free space map, and assumes that the rest of the space on the page is taken up by live tuples.</source>
          <target state="translated">가시성 맵에 따라 표시되는 튜플 만있는 페이지를 건너 뛰어이를 수행합니다 (페이지에 해당 VM 비트 세트가 있으면 사용 가능한 튜플이없는 것으로 가정). 이러한 페이지의 경우 여유 공간 맵에서 여유 공간 값을 파생시키고 페이지의 나머지 공간이 라이브 튜플에 의해 사용된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="289bb6de0c119ae341fea7727f0ae465a6ffb7a2" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;not&lt;/em&gt; recommended that you override this behavior by changing the session-level settings of these parameters; that is likely to cause &lt;code&gt;postgres_fdw&lt;/code&gt; to malfunction.</source>
          <target state="translated">되어 &lt;em&gt;있지&lt;/em&gt; 이러한 매개 변수의 세션 수준 설정을 변경하여이 동작을 오버라이드 (override)하는 것을 추천합니다; &lt;code&gt;postgres_fdw&lt;/code&gt; 가 오작동 할 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1927f65da9f3267669c003e30b5762ebad0dc5a9" translate="yes" xml:space="preserve">
          <source>It is a good idea to save the database server's log output somewhere, rather than just discarding it via &lt;code&gt;/dev/null&lt;/code&gt;. The log output is invaluable when diagnosing problems. However, the log output tends to be voluminous (especially at higher debug levels) so you won't want to save it indefinitely. You need to &lt;em&gt;rotate&lt;/em&gt; the log files so that new log files are started and old ones removed after a reasonable period of time.</source>
          <target state="translated">데이터베이스 서버의 로그 출력을 &lt;code&gt;/dev/null&lt;/code&gt; 을 통해 버리지 않고 어딘가에 저장하는 것이 좋습니다 . 문제점 진단시 로그 출력은 매우 중요합니다. 그러나 로그 출력은 방대한 양 (특히 더 높은 디버그 레벨에서)이되기 때문에 무기한 저장하지 않으려 고합니다. 새 로그 파일이 시작되고 적절한 시간이 지나면 이전 로그 파일이 제거되도록 로그 파일 을 &lt;em&gt;회전&lt;/em&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="45d3adbb3df378f5fff436872f95f728d888325a" translate="yes" xml:space="preserve">
          <source>It is advantageous if the log is located on a different disk from the main database files. This can be achieved by moving the &lt;code&gt;pg_wal&lt;/code&gt; directory to another location (while the server is shut down, of course) and creating a symbolic link from the original location in the main data directory to the new location.</source>
          <target state="translated">로그가 기본 데이터베이스 파일과 다른 디스크에 있으면 유리합니다. 이것은 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리를 다른 위치 (물론 서버가 종료 된 상태)로 옮기고 기본 데이터 디렉토리의 원래 위치에서 새 위치로 심볼릭 링크를 만들어서 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25c2883a31f29210a79363008b59988d33c5a31b" translate="yes" xml:space="preserve">
          <source>It is advisable to set &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; to a reasonably large value (but not more than the amount of RAM you can dedicate to the &lt;code&gt;CLUSTER&lt;/code&gt; operation) before clustering.</source>
          <target state="translated">클러스터링하기 전에 &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 을 상당히 큰 값 (그러나 &lt;code&gt;CLUSTER&lt;/code&gt; 조작에 전용 할 수있는 RAM의 양을 초과하지 않음)으로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f4c2ed49f12a870b96cb954dbc625ee0c439a239" translate="yes" xml:space="preserve">
          <source>It is advisable to test your proposed archive command to ensure that it indeed does not overwrite an existing file, &lt;em&gt;and that it returns nonzero status in this case&lt;/em&gt;. The example command above for Unix ensures this by including a separate &lt;code&gt;test&lt;/code&gt; step. On some Unix platforms, &lt;code&gt;cp&lt;/code&gt; has switches such as &lt;code&gt;-i&lt;/code&gt; that can be used to do the same thing less verbosely, but you should not rely on these without verifying that the right exit status is returned. (In particular, GNU &lt;code&gt;cp&lt;/code&gt; will return status zero when &lt;code&gt;-i&lt;/code&gt; is used and the target file already exists, which is &lt;em&gt;not&lt;/em&gt; the desired behavior.)</source>
          <target state="translated">제안 된 아카이브 명령을 테스트하여 실제로 기존 파일을 덮어 쓰지 &lt;em&gt;않고이 경우 0이 아닌 상태를 리턴&lt;/em&gt; 하는지 확인하는 것이 좋습니다 . 위의 Unix 명령 예제는 별도의 &lt;code&gt;test&lt;/code&gt; 단계를 포함하여이를 보장합니다 . 일부 유닉스 플랫폼에서 &lt;code&gt;cp&lt;/code&gt; 는 &lt;code&gt;-i&lt;/code&gt; 와 같은 스위치를 사용하여 같은 일을 덜 자세하게 수행하는 데 사용할 수 있지만 올바른 종료 상태가 반환되는지 확인하지 않고 스위치에 의존해서는 안됩니다. (특히, GNU &lt;code&gt;cp&lt;/code&gt; 는 &lt;code&gt;-i&lt;/code&gt; 를 사용하고 대상 파일이 이미 존재하는 경우 상태 0을 반환 합니다. 이는 바람직한 동작 이 &lt;em&gt;아닙니다&lt;/em&gt; .)</target>
        </trans-unit>
        <trans-unit id="5ccc1a490a09faccece314c281e5a4bacdabe99b" translate="yes" xml:space="preserve">
          <source>It is also important to consider the overhead of partitioning during query planning and execution. The query planner is generally able to handle partition hierarchies with up to a few thousand partitions fairly well, provided that typical queries allow the query planner to prune all but a small number of partitions. Planning times become longer and memory consumption becomes higher when more partitions remain after the planner performs partition pruning. This is particularly true for the &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. Another reason to be concerned about having a large number of partitions is that the server's memory consumption may grow significantly over a period of time, especially if many sessions touch large numbers of partitions. That's because each partition requires its metadata to be loaded into the local memory of each session that touches it.</source>
          <target state="translated">쿼리 계획 및 실행 중에 파티셔닝 오버 헤드를 고려해야합니다. 일반적인 쿼리로 인해 쿼리 플래너가 소수의 파티션을 제외한 모든 파티션을 프룬 (prune) 할 수 있다면 쿼리 플래너는 일반적으로 최대 수천 개의 파티션으로 파티션 계층 구조를 상당히 잘 처리 할 수 ​​있습니다. 플래너가 파티션 정리를 수행 한 후 더 많은 파티션이 남아 있으면 계획 시간이 길어지고 메모리 소비가 높아집니다. 이것은 특히 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 에 해당됩니다.명령. 많은 수의 파티션을 보유해야하는 또 다른 이유는 특히 많은 세션이 많은 수의 파티션에 닿는 경우 서버의 메모리 소비가 일정 기간 동안 크게 증가 할 수 있기 때문입니다. 각 파티션은 메타 데이터를 해당 세션과 접촉하는 각 세션의 로컬 메모리에로드해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b8a8c0ea8274eada7feb8d1cce002d08a07341cc" translate="yes" xml:space="preserve">
          <source>It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word &lt;code&gt;ARRAY&lt;/code&gt; followed by a parenthesized (not bracketed) subquery. For example:</source>
          <target state="translated">하위 쿼리 결과에서 배열을 구성 할 수도 있습니다. 이 형식에서, 배열 생성자는 키워드 &lt;code&gt;ARRAY&lt;/code&gt; 와 괄호로 묶인 (괄호로 묶이지 않은) 서브 쿼리로 작성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21db650c844a5c99fb809ce100bf6bab36b3a9c1" translate="yes" xml:space="preserve">
          <source>It is also possible to create a chain of trust that includes intermediate certificates:</source>
          <target state="translated">중간 인증서를 포함하는 신뢰 체인을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bbde7dfe5218957bc7115e4bb121f93797376d5" translate="yes" xml:space="preserve">
          <source>It is also possible to implement record-based log shipping using this alternative method, though this requires custom development, and changes will still only become visible to hot standby queries after a full WAL file has been shipped.</source>
          <target state="translated">이 대체 방법을 사용하여 레코드 기반 로그 전달을 구현할 수도 있지만, 이는 사용자 정의 개발이 필요하며 전체 WAL 파일이 제공된 후에도 변경 사항은 여전히 ​​대기 모드 쿼리에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a889ddd9646ac2e435b2d44d186929390a588c8e" translate="yes" xml:space="preserve">
          <source>It is also possible to insert the result of a query (which might be no rows, one row, or many rows):</source>
          <target state="translated">쿼리 결과를 삽입 할 수도 있습니다 (행이 없거나 한 행 또는 여러 행일 수 있음).</target>
        </trans-unit>
        <trans-unit id="23dc30a3752f1a0512f87d6b42f04212daedc525" translate="yes" xml:space="preserve">
          <source>It is also possible to make a backup while the server is stopped. In this case, you obviously cannot use &lt;code&gt;pg_start_backup&lt;/code&gt; or &lt;code&gt;pg_stop_backup&lt;/code&gt;, and you will therefore be left to your own devices to keep track of which backup is which and how far back the associated WAL files go. It is generally better to follow the continuous archiving procedure above.</source>
          <target state="translated">서버가 중지 된 동안 백업을 만들 수도 있습니다. 이 경우 분명히 &lt;code&gt;pg_start_backup&lt;/code&gt; 또는 &lt;code&gt;pg_stop_backup&lt;/code&gt; 을 사용할 수 없으므로 관련 WAL 파일의 백업 및 백업 위치를 추적하기 위해 자신의 장치에 맡겨야합니다. 일반적으로 위의 연속 보관 절차를 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6383187f9793f49474de63c9c18fca5ed6c8c44d" translate="yes" xml:space="preserve">
          <source>It is also possible to pass a page to &lt;code&gt;bt_page_items&lt;/code&gt; as a &lt;code&gt;bytea&lt;/code&gt; value. A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. So the last example could also be rewritten like this:</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 값 으로 페이지를 &lt;code&gt;bt_page_items&lt;/code&gt; 에 전달할 수도 있습니다 . &lt;code&gt;get_raw_page&lt;/code&gt; 로 얻은 페이지 이미지 는 인수로 전달되어야합니다. 따라서 마지막 예제는 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f6da252a14d7892790fa503a4f493737f34471" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type cast using a function-like syntax:</source>
          <target state="translated">함수형 구문을 사용하여 유형 캐스트를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da0d70336d913c862f76912f7ff4b7d2cecbbfee" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type coercion using a function-like syntax:</source>
          <target state="translated">함수와 같은 구문을 사용하여 유형 강제 변환을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce33e1d5683bd1e633283bcca0d2a1c2815c050" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific database rather than to a role; see &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt;. If there is a conflict, database-role-specific settings override role-specific ones, which in turn override database-specific ones.</source>
          <target state="translated">세션 기본값을 역할이 아닌 특정 데이터베이스에 연결할 수도 있습니다. &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE를&lt;/a&gt; 참조하십시오 . 충돌이 발생하면 데이터베이스 역할 별 설정이 역할 별 설정보다 우선하며, 이로 인해 데이터베이스 별 설정이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="752073224562183bf86377a6f918beef1da4c653" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific role rather than to a database; see &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. Role-specific settings override database-specific ones if there is a conflict.</source>
          <target state="translated">세션 기본값을 데이터베이스가 아닌 특정 역할에 연결할 수도 있습니다. &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE을&lt;/a&gt; 참조하십시오 . 충돌이 발생하면 역할 별 설정이 데이터베이스 별 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="c7b08ca18ddba24ea9814754a2d56bec9634faff" translate="yes" xml:space="preserve">
          <source>It is also possible to use arbitrary expressions in the &lt;code&gt;ORDER BY&lt;/code&gt; clause, including columns that do not appear in the &lt;code&gt;SELECT&lt;/code&gt; output list. Thus the following statement is valid:</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 출력 목록에 나타나지 않는 열을 포함 하여 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서 임의의 표현식을 사용할 수도 있습니다 . 따라서 다음 진술은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f4e580c8b0c33e188baa71c64a617a90c70459e7" translate="yes" xml:space="preserve">
          <source>It is also possible to use logical replication methods to create a standby server with the updated version of PostgreSQL. This is possible because logical replication supports replication between different major versions of PostgreSQL. The standby can be on the same computer or a different computer. Once it has synced up with the master server (running the older version of PostgreSQL), you can switch masters and make the standby the master and shut down the older database instance. Such a switch-over results in only several seconds of downtime for an upgrade.</source>
          <target state="translated">논리적 복제 방법을 사용하여 업데이트 된 PostgreSQL 버전으로 대기 서버를 생성 할 수도 있습니다. 논리적 복제는 다른 주요 버전의 PostgreSQL 간의 복제를 지원하기 때문에 가능합니다. 대기는 동일한 컴퓨터 또는 다른 컴퓨터에있을 수 있습니다. 마스터 서버와 동기화되면 (이전 버전의 PostgreSQL 실행) 마스터를 전환하고 대기를 마스터로 만들고 이전 데이터베이스 인스턴스를 종료 할 수 있습니다. 이러한 전환으로 인해 업그레이드시 다운 타임이 몇 초에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="2f14f1cce0e64f81899ff66a139003d88acce025" translate="yes" xml:space="preserve">
          <source>It is an error to mix configuration options for simple bind with options for search+bind.</source>
          <target state="translated">단순 바인드에 대한 구성 옵션과 검색 + 바인드 옵션을 혼합하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a93dfee21deef6822077b576885ec96bea313d5" translate="yes" xml:space="preserve">
          <source>It is best not to use SIGKILL to shut down the server. Doing so will prevent the server from releasing shared memory and semaphores. Furthermore, SIGKILL kills the &lt;code&gt;postgres&lt;/code&gt; process without letting it relay the signal to its subprocesses, so it might be necessary to kill the individual subprocesses by hand as well.</source>
          <target state="translated">서버를 종료하기 위해 SIGKILL을 사용하지 않는 것이 가장 좋습니다. 그렇게하면 서버가 공유 메모리와 세마포어를 해제하지 못하게됩니다. 또한 SIGKILL 은 신호를 하위 프로세스로 릴레이하지 않고 &lt;code&gt;postgres&lt;/code&gt; 프로세스를 종료 하므로 개별 하위 프로세스도 수동으로 종료해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03425b40ae836e9eabd64694b0fe5bdd09ab82f4" translate="yes" xml:space="preserve">
          <source>It is best not to use parallelism when restoring from an archive made with this option, because pg_restore will not know exactly which partition(s) a given archive data item will load data into. This could result in inefficiency due to lock conflicts between parallel jobs, or perhaps even reload failures due to foreign key constraints being set up before all the relevant data is loaded.</source>
          <target state="translated">pg_restore는 지정된 아카이브 데이터 항목이 데이터를로드 할 파티션을 정확하게 알지 못하므로이 옵션으로 만든 아카이브에서 복원 할 때 병렬 처리를 사용하지 않는 것이 가장 좋습니다. 이로 인해 병렬 작업 간의 잠금 충돌로 인해 비 효율성이 발생하거나 관련 데이터를 모두로드하기 전에 외래 키 제약 조건이 설정되어 다시로드 오류가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e38adf41282f06a6bcba53d9fb2cad2cffe8b4" translate="yes" xml:space="preserve">
          <source>It is common for a client that executes &lt;code&gt;NOTIFY&lt;/code&gt; to be listening on the same notification channel itself. In that case it will get back a notification event, just like all the other listening sessions. Depending on the application logic, this could result in useless work, for example, reading a database table to find the same updates that that session just wrote out. It is possible to avoid such extra work by noticing whether the notifying session's server process PID (supplied in the notification event message) is the same as one's own session's PID (available from libpq). When they are the same, the notification event is one's own work bouncing back, and can be ignored.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 를 실행하는 클라이언트가 동일한 알림 채널 자체에서 청취 하는 것이 일반적입니다 . 이 경우 다른 모든 청취 세션과 마찬가지로 알림 이벤트를 다시받습니다. 응용 프로그램 논리에 따라 이로 인해 데이터베이스 테이블을 읽어 해당 세션이 방금 작성한 것과 동일한 업데이트를 찾는 등의 불필요한 작업이 발생할 수 있습니다. 통지 세션의 서버 프로세스 PID (알림 이벤트 메시지에 제공)가 자신의 세션 PID (libpq에서 사용 가능)와 동일한 지 여부를 알면 이러한 추가 작업을 피할 수 있습니다. 알림 이벤트가 동일하면 알림 이벤트가 자신의 작업을 수신 거부하고 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9caa8dc8a351442eebfc90a7900dd2df9e2e966" translate="yes" xml:space="preserve">
          <source>It is common to see slow queries running bad execution plans because multiple columns used in the query clauses are correlated. The planner normally assumes that multiple conditions are independent of each other, an assumption that does not hold when column values are correlated. Regular statistics, because of their per-individual-column nature, cannot capture any knowledge about cross-column correlation. However, PostgreSQL has the ability to compute &lt;em&gt;multivariate statistics&lt;/em&gt;, which can capture such information.</source>
          <target state="translated">query 절에 사용 된 여러 열이 서로 관련되어 있기 때문에 잘못된 실행 계획을 실행하는 느린 쿼리를 보는 것이 일반적입니다. 플래너는 일반적으로 여러 조건이 서로 독립적이라고 가정하며 열 값이 상관 될 때 유지되지 않는 가정입니다. 개인별 열 특성으로 인해 정기적 인 통계는 열 간 상관 관계에 대한 지식을 얻을 수 없습니다. 그러나 PostgreSQL에는 &lt;em&gt;다변량 통계&lt;/em&gt; 를 계산하는 기능이있어 이러한 정보를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="716e43860306866d146f9c899994b23176f3323e" translate="yes" xml:space="preserve">
          <source>It is difficult to formulate a general procedure for determining which indexes to create. There are a number of typical cases that have been shown in the examples throughout the previous sections. A good deal of experimentation is often necessary. The rest of this section gives some tips for that:</source>
          <target state="translated">생성 할 인덱스를 결정하기위한 일반적인 절차를 수립하기는 어렵습니다. 이전 섹션 전체에서 예제에 표시된 여러 가지 일반적인 사례가 있습니다. 많은 실험이 종종 필요합니다. 이 섹션의 나머지 부분에서는 이에 대한 팁을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8e2e75db678536414073cb564abf9bafb8f65d0c" translate="yes" xml:space="preserve">
          <source>It is easy to find your largest tables and indexes using this information:</source>
          <target state="translated">이 정보를 사용하여 가장 큰 테이블과 인덱스를 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f4af27f8aaeea1d69cd838327e07079c59b331" translate="yes" xml:space="preserve">
          <source>It is encrypted using the public key and put into the session key packet.</source>
          <target state="translated">공개 키를 사용하여 암호화되어 세션 키 패킷에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="c1facaa0d2b2d45958e470a68a811dfa56fbe0cc" translate="yes" xml:space="preserve">
          <source>It is especially fatal to use very small test data sets. While selecting 1000 out of 100000 rows could be a candidate for an index, selecting 1 out of 100 rows will hardly be, because the 100 rows probably fit within a single disk page, and there is no plan that can beat sequentially fetching 1 disk page.</source>
          <target state="translated">매우 작은 테스트 데이터 세트를 사용하는 것은 특히 치명적입니다. 100000 개의 행 중 1000 개를 선택하면 인덱스 후보가 될 수 있지만 100 개의 행 중 하나를 선택하는 것은 거의 불가능합니다. 100 개의 행이 단일 디스크 페이지에 맞을 가능성이 높으며 1 개의 디스크 페이지를 순차적으로 페치 할 수있는 계획이 없기 때문입니다. .</target>
        </trans-unit>
        <trans-unit id="19ad949d23432743231dc352c6a17b2b375d15f1" translate="yes" xml:space="preserve">
          <source>It is essential that the same parameters are passed in order to obtain matching XML data mappings and XML Schema documents.</source>
          <target state="translated">일치하는 XML 데이터 맵핑 및 XML 스키마 문서를 얻으려면 동일한 매개 변수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a50daa221b6ada829c86621c1e1031f8d10ee63" translate="yes" xml:space="preserve">
          <source>It is even possible for repeated executions of the same &lt;code&gt;LIMIT&lt;/code&gt; query to return different subsets of the rows of a table, if there is not an &lt;code&gt;ORDER BY&lt;/code&gt; to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.</source>
          <target state="translated">결정적 서브 세트의 선택을 강제 하는 &lt;code&gt;ORDER BY&lt;/code&gt; 가없는 경우 동일한 &lt;code&gt;LIMIT&lt;/code&gt; 쿼리 의 반복 된 실행이 테이블 행의 다른 서브 세트를 리턴 할 수도 있습니다. 다시, 이것은 버그가 아닙니다. 이 경우 결과의 결정 성은 단순히 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10042e013ab2c07aefb508d6fa86ca0af029f7db" translate="yes" xml:space="preserve">
          <source>It is frequently convenient to group users together to ease management of privileges: that way, privileges can be granted to, or revoked from, a group as a whole. In PostgreSQL this is done by creating a role that represents the group, and then granting &lt;em&gt;membership&lt;/em&gt; in the group role to individual user roles.</source>
          <target state="translated">권한을 쉽게 관리 할 수 ​​있도록 사용자를 그룹화하는 것이 편리합니다. 이렇게하면 그룹 전체에 권한을 부여하거나 취소 할 수 있습니다. PostgreSQL에서는 그룹을 나타내는 역할을 만든 다음 그룹 역할의 &lt;em&gt;멤버 자격&lt;/em&gt; 을 개별 사용자 역할에 부여 합니다.</target>
        </trans-unit>
        <trans-unit id="c7233cabce0e70bf9b6042d864213cd71aa539f4" translate="yes" xml:space="preserve">
          <source>It is generally recommended that the columns of a foreign table be declared with exactly the same data types, and collations if applicable, as the referenced columns of the remote table. Although &lt;code&gt;postgres_fdw&lt;/code&gt; is currently rather forgiving about performing data type conversions at need, surprising semantic anomalies may arise when types or collations do not match, due to the remote server interpreting &lt;code&gt;WHERE&lt;/code&gt; clauses slightly differently from the local server.</source>
          <target state="translated">일반적으로 외부 테이블의 열은 원격 테이블의 참조 열과 정확히 동일한 데이터 형식 및 데이터 정렬을 사용하여 선언하는 것이 좋습니다. &lt;code&gt;postgres_fdw&lt;/code&gt; 는 현재 필요한 데이터 유형 변환을 수행하는 것을 다소 용서 하지만 원격 서버가 &lt;code&gt;WHERE&lt;/code&gt; 절을 로컬 서버와 약간 다르게 해석하기 때문에 유형 또는 데이터 정렬이 일치하지 않으면 놀라운 의미 이상이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e59537e8306049dacf2891d27c403a8ccf0ae6a3" translate="yes" xml:space="preserve">
          <source>It is generally recommended to use &lt;code&gt;FOR UPDATE&lt;/code&gt; if the cursor is intended to be used with &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; or &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt;. Using &lt;code&gt;FOR UPDATE&lt;/code&gt; prevents other sessions from changing the rows between the time they are fetched and the time they are updated. Without &lt;code&gt;FOR UPDATE&lt;/code&gt;, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; command will have no effect if the row was changed since the cursor was created.</source>
          <target state="translated">커서를 &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; 또는 &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt; 와 함께 사용하려는 경우 일반적으로 &lt;code&gt;FOR UPDATE&lt;/code&gt; 를 사용하는 것이 좋습니다 . &lt;code&gt;FOR UPDATE&lt;/code&gt; 를 사용 하면 다른 세션이 페치 된 시간과 업데이트 된 시간 사이에서 행을 변경하지 못하게됩니다. 없이 &lt;code&gt;FOR UPDATE&lt;/code&gt; , 후속 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 커서가 생성 된 이후 행이 변경된 경우 명령은 아무런 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a83872fa85fd0323d70dd24a91d302ff7029d1c0" translate="yes" xml:space="preserve">
          <source>It is good practice to create a role that has the &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; privileges, but is not a superuser, and then use this role for all routine management of databases and roles. This approach avoids the dangers of operating as a superuser for tasks that do not really require it.</source>
          <target state="translated">이 역할 작성하는 것이 좋습니다 &lt;code&gt;CREATEDB&lt;/code&gt; 및 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한을하지만, 슈퍼 유저 아닌 다음 데이터베이스 및 역할의 모든 일상적인 관리를위한이 역할을 사용합니다. 이 접근 방식은 실제로 필요하지 않은 작업의 수퍼 유저로 작동 할 위험을 피합니다.</target>
        </trans-unit>
        <trans-unit id="de68fd3161d79a0dbb9addbaa913d55e1165d0a6" translate="yes" xml:space="preserve">
          <source>It is important for the command to return a zero exit status only if it succeeds. The command &lt;em&gt;will&lt;/em&gt; be asked for file names that are not present in the archive; it must return nonzero when so asked. Examples:</source>
          <target state="translated">명령이 성공한 경우에만 제로 종료 상태를 리턴하는 것이 중요합니다. 아카이브에없는 파일 이름을 묻는 명령 &lt;em&gt;이 표시됩니다&lt;/em&gt; . 요청시 0이 아닌 값을 반환해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="cf6c5b8023371ed1577875e84b0b18cba96de2de" translate="yes" xml:space="preserve">
          <source>It is important that the &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; string not appear in any key values, else &lt;code&gt;connectby&lt;/code&gt; may incorrectly report an infinite-recursion error. Note that if &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; is not provided, a default value of &lt;code&gt;~&lt;/code&gt; is used for recursion detection purposes.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt; 문자열이 키 값에 나타나지 않는 것이 중요 합니다. 그렇지 않으면 &lt;code&gt;connectby&lt;/code&gt; 가 무한 재귀 오류를 잘못보고 할 수 있습니다. 경우주의 &lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; 이&lt;/em&gt; 제공되지 않으며, 기본값 &lt;code&gt;~&lt;/code&gt; 이 재귀 감지 목적을 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ae60071a0616a68a075f0ef2a5eb0bf24ed27b" translate="yes" xml:space="preserve">
          <source>It is important that the administrator select appropriate settings for &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;. The best choices vary depending on business priorities. For example if the server is primarily tasked as a High Availability server, then you will want low delay settings, perhaps even zero, though that is a very aggressive setting. If the standby server is tasked as an additional server for decision support queries then it might be acceptable to set the maximum delay values to many hours, or even -1 which means wait forever for queries to complete.</source>
          <target state="translated">관리자가 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay에&lt;/a&gt; 대한 적절한 설정을 선택해야합니다 . 최선의 선택은 비즈니스 우선 순위에 따라 다릅니다. 예를 들어 서버가 주로 고 가용성 서버로 작업을 수행하는 경우 매우 공격적인 설정이지만 지연이 적은 설정 (아마도 0)을 원할 것입니다. 대기 서버가 의사 결정 지원 조회를위한 추가 서버로 태스크되는 경우 최대 지연 값을 여러 시간 또는 -1로 설정하는 것이 허용 될 수 있습니다. 이는 조회가 완료 될 때까지 영원히 대기 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="261ccf1229f9ce7bf8e5f6c3bd334b4a4c87db09" translate="yes" xml:space="preserve">
          <source>It is important that the archive command return zero exit status if and only if it succeeds. Upon getting a zero result, PostgreSQL will assume that the file has been successfully archived, and will remove or recycle it. However, a nonzero status tells PostgreSQL that the file was not archived; it will try again periodically until it succeeds.</source>
          <target state="translated">아카이브 명령이 성공한 경우에만 0 종료 상태를 리턴하는 것이 중요합니다. 결과가 0이되면 PostgreSQL은 파일이 성공적으로 아카이브되었다고 가정하고이를 제거하거나 재활용합니다. 그러나 0이 아닌 상태는 PostgreSQL에 파일이 아카이브되지 않았 음을 알려줍니다. 성공할 때까지 주기적으로 다시 시도합니다.</target>
        </trans-unit>
        <trans-unit id="696e699e4bfd8bcf4f4c70ae89306a775c1076ba" translate="yes" xml:space="preserve">
          <source>It is important that the command return nonzero exit status on failure. The command &lt;em&gt;will&lt;/em&gt; be called requesting files that are not present in the archive; it must return nonzero when so asked. This is not an error condition. An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">실패시 명령이 0이 아닌 종료 상태를 리턴하는 것이 중요합니다. 아카이브에없는 파일을 요청하는 명령 &lt;em&gt;이&lt;/em&gt; 호출 &lt;em&gt;됩니다&lt;/em&gt; . 요청시 0이 아닌 값을 반환해야합니다. 이것은 오류 조건이 아닙니다. 단, 신호 (데이터베이스 서버 종료의 일부로 사용되는 SIGTERM 이외) 또는 쉘 오류 (예 : 명령을 찾을 수 없음)로 명령이 종료 된 경우 복구가 중단되고 서버가 중단됩니다. 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23edc6be4b94044ef5894353c32ee9e7375bcbf5" translate="yes" xml:space="preserve">
          <source>It is important to note that the ranking functions do not use any global information, so it is impossible to produce a fair normalization to 1% or 100% as sometimes desired. Normalization option 32 (&lt;code&gt;rank/(rank+1)&lt;/code&gt;) can be applied to scale all ranks into the range zero to one, but of course this is just a cosmetic change; it will not affect the ordering of the search results.</source>
          <target state="translated">순위 함수는 전역 정보를 사용하지 않으므로 때때로 원하는대로 1 % 또는 100 %로 공정한 정규화를 생성하는 것이 불가능합니다. 정규화 옵션 32 ( &lt;code&gt;rank/(rank+1)&lt;/code&gt; )를 사용하여 모든 순위를 0에서 1까지의 범위로 조정할 수 있지만 물론 이것은 단지 외관상의 변화 일뿐입니다. 검색 결과의 순서에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a6953b33213a41a821ecf81913686f5a307e4e2" translate="yes" xml:space="preserve">
          <source>It is important to store the server's stdout and stderr output somewhere, as shown above. It will help for auditing purposes and to diagnose problems. (See &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt; for a more thorough discussion of log file handling.)</source>
          <target state="translated">위에 표시된 것처럼 서버의 stdout 및 stderr 출력을 어딘가에 저장하는 것이 중요합니다. 감사 목적으로 문제를 진단하는 데 도움이됩니다. 로그 파일 처리에 대한 자세한 내용 &lt;a href=&quot;logfile-maintenance&quot;&gt;은 24.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c277ac6ce904cf376b200217f724f1a32321205" translate="yes" xml:space="preserve">
          <source>It is important to understand before studying &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; that the fact that a key word is not reserved in PostgreSQL does not mean that the feature related to the word is not implemented. Conversely, the presence of a key word does not indicate the existence of a feature.</source>
          <target state="translated">&lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;표 C.1&lt;/a&gt; 을 공부하기 전에 PostgreSQL에서 키워드가 예약되어 있지 않다는 것이 단어와 관련된 기능이 구현되지 않았다는 것을 의미하지는 않습니다. 반대로 키워드의 존재는 기능의 존재를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2afb84d06182545308e408bb344e52041de5bb4d" translate="yes" xml:space="preserve">
          <source>It is important to understand that the &lt;code&gt;tsvector&lt;/code&gt; type itself does not perform any word normalization; it assumes the words it is given are normalized appropriately for the application. For example,</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 타입 자체는 워드 정규화를 수행하지 않는다는 것을 이해하는 것이 중요합니다 . 주어진 단어가 응용 프로그램에 적합하게 정규화되었다고 가정합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2fc0b9aee575bb88d3b3c3db08a354cd3df94678" translate="yes" xml:space="preserve">
          <source>It is important to understand the interaction between aggregates and SQL's &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses. The fundamental difference between &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; is this: &lt;code&gt;WHERE&lt;/code&gt; selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas &lt;code&gt;HAVING&lt;/code&gt; selects group rows after groups and aggregates are computed. Thus, the &lt;code&gt;WHERE&lt;/code&gt; clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the &lt;code&gt;HAVING&lt;/code&gt; clause always contains aggregate functions. (Strictly speaking, you are allowed to write a &lt;code&gt;HAVING&lt;/code&gt; clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the &lt;code&gt;WHERE&lt;/code&gt; stage.)</source>
          <target state="translated">집계와 SQL의 &lt;code&gt;WHERE&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절 사이의 상호 작용을 이해하는 것이 중요합니다 . &lt;code&gt;WHERE&lt;/code&gt; 와 &lt;code&gt;HAVING&lt;/code&gt; 의 근본적인 차이점 은 다음 과 같습니다. &lt;code&gt;WHERE&lt;/code&gt; 는 그룹 및 집계가 계산되기 전에 입력 행을 선택하고 (따라서 집계 계산에 들어가는 행을 제어 함) &lt;code&gt;HAVING&lt;/code&gt; 은 그룹 및 집계가 계산 된 후 그룹 행을 선택합니다. 따라서 &lt;code&gt;WHERE&lt;/code&gt; 절은 집계 함수를 포함하지 않아야합니다. 집계를 사용하여 집계에 입력 할 행을 결정하는 것은 의미가 없습니다. 반면에 &lt;code&gt;HAVING&lt;/code&gt; 절에는 항상 집계 함수가 포함됩니다. 엄밀히 말하면 집계를 사용하지 않는 &lt;code&gt;HAVING&lt;/code&gt; 절 을 작성할 수 있지만 거의 유용하지 않습니다. 동일한 조건을 &lt;code&gt;WHERE&lt;/code&gt; 단계 에서보다 효율적으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6f798bec767ce149f1b4884b54e8874f501f623" translate="yes" xml:space="preserve">
          <source>It is legitimate to create a &lt;code&gt;pg_cast&lt;/code&gt; entry in which the source and target types are the same, if the associated function takes more than one argument. Such entries represent &amp;ldquo;length coercion functions&amp;rdquo; that coerce values of the type to be legal for a particular type modifier value.</source>
          <target state="translated">연관된 함수가 둘 이상의 인수를 사용하는 경우 소스 및 대상 유형이 동일한 &lt;code&gt;pg_cast&lt;/code&gt; 항목 을 작성하는 것이 합법적 입니다. 이러한 항목은 특정 유형 수정 자 값에 적합한 유형의 값을 강제하는 &quot;길이 강제 변환 함수&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dbc1f490f7774fb666f596c4d1e1fe3642c52d33" translate="yes" xml:space="preserve">
          <source>It is likely that &lt;code&gt;pg_pltemplate&lt;/code&gt; will be removed in some future release of PostgreSQL, in favor of keeping this knowledge about procedural languages in their respective extension installation scripts.</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; 는 PostgreSQL의 향후 릴리스에서 제거 될 것입니다. 절차 언어에 대한 지식을 해당 확장 설치 스크립트에 유지하기 위해서입니다.</target>
        </trans-unit>
        <trans-unit id="6bb4f0fbbfb491190c393dc7c8ea60757b692676" translate="yes" xml:space="preserve">
          <source>It is normally not necessary to create casts between user-defined types and the standard string types (&lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char(n)&lt;/code&gt;, as well as user-defined types that are defined to be in the string category). PostgreSQL provides automatic I/O conversion casts for that. The automatic casts to string types are treated as assignment casts, while the automatic casts from string types are explicit-only. You can override this behavior by declaring your own cast to replace an automatic cast, but usually the only reason to do so is if you want the conversion to be more easily invokable than the standard assignment-only or explicit-only setting. Another possible reason is that you want the conversion to behave differently from the type's I/O function; but that is sufficiently surprising that you should think twice about whether it's a good idea. (A small number of the built-in types do indeed have different behaviors for conversions, mostly because of requirements of the SQL standard.)</source>
          <target state="translated">일반적으로 사용자 정의 형식과 표준 문자열 형식 ( &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; 및 &lt;code&gt;char(n)&lt;/code&gt; 사이에 캐스트를 만들 필요는 없습니다.문자열 카테고리에 있도록 정의 된 사용자 정의 유형뿐만 아니라). PostgreSQL은이를 위해 자동 I / O 변환 캐스트를 제공합니다. 문자열 유형으로의 자동 캐스트는 할당 캐스트로 취급되는 반면, 문자열 유형으로부터의 자동 캐스트는 명시 적 전용입니다. 자동 캐스트를 대체하기 위해 자신의 캐스트를 선언하여이 동작을 무시할 수 있지만 일반적으로 그렇게하는 유일한 이유는 변환이 표준 할당 전용 또는 명시 적 전용 설정보다 더 쉽게 호출 할 수 있기를 원하기 때문입니다. 또 다른 가능한 이유는 변환이 유형의 I / O 함수와 다르게 동작하기를 원하기 때문입니다. 그러나 그것이 좋은 생각인지에 대해 두 번 생각해야한다는 것은 놀랍습니다. (내장 된 소수의 유형은 실제로 전환에 대해 다른 동작을합니다.주로 SQL 표준의 요구 사항 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="f92a52d7559ea7c6c8c28ba12e1fa17dfea96688" translate="yes" xml:space="preserve">
          <source>It is not allowed to combine &lt;code&gt;connect&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;create_slot&lt;/code&gt;, or &lt;code&gt;copy_data&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 세트를 &lt;code&gt;false&lt;/code&gt; 로 설정 하고 &lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;create_slot&lt;/code&gt; 또는 &lt;code&gt;copy_data&lt;/code&gt; 세트를 &lt;code&gt;true&lt;/code&gt; 로 결합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="072c5ad8d293ff2ada18ad71b639cc19ab727e57" translate="yes" xml:space="preserve">
          <source>It is not currently allowed to &lt;code&gt;PREPARE&lt;/code&gt; a transaction that has executed any operations involving temporary tables or the session's temporary namespace, created any cursors &lt;code&gt;WITH HOLD&lt;/code&gt;, or executed &lt;code&gt;LISTEN&lt;/code&gt;, &lt;code&gt;UNLISTEN&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;. Those features are too tightly tied to the current session to be useful in a transaction to be prepared.</source>
          <target state="translated">현재 임시 테이블 또는 세션의 임시 네임 스페이스와 관련된 작업을 실행하거나, 커서로 &lt;code&gt;WITH HOLD&lt;/code&gt; 를 생성 했거나 &lt;code&gt;LISTEN&lt;/code&gt; , &lt;code&gt;UNLISTEN&lt;/code&gt; 또는 &lt;code&gt;NOTIFY&lt;/code&gt; 를 실행 한 트랜잭션 을 &lt;code&gt;PREPARE&lt;/code&gt; 할 수 없습니다 . 이러한 기능은 현재 세션과 너무 밀접하게 연결되어 있으므로 준비 할 트랜잭션에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="683c463d18b1311e371770a1d3375c3bacddce8d" translate="yes" xml:space="preserve">
          <source>It is not important to which database you connect here since the script file created by pg_dumpall will contain the appropriate commands to create and connect to the saved databases. An exception is that if you specified &lt;code&gt;--clean&lt;/code&gt;, you must connect to the &lt;code&gt;postgres&lt;/code&gt; database initially; the script will attempt to drop other databases immediately, and that will fail for the database you are connected to.</source>
          <target state="translated">pg_dumpall에 의해 생성 된 스크립트 파일에는 저장된 데이터베이스를 생성하고 연결하기위한 적절한 명령이 포함되므로 여기에서 어떤 데이터베이스를 연결하는지는 중요하지 않습니다. &lt;code&gt;--clean&lt;/code&gt; 을 지정한 경우 , &lt;code&gt;postgres&lt;/code&gt; 데이터베이스에 처음 연결해야합니다 . 스크립트는 다른 데이터베이스를 즉시 삭제하려고 시도하며 연결된 데이터베이스에 대해 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1b796566a4506096f72ab10f4b43942e3c90636a" translate="yes" xml:space="preserve">
          <source>It is not necessary to add the root certificate to &lt;code&gt;server.crt&lt;/code&gt;. Instead, clients must have the root certificate of the server's certificate chain.</source>
          <target state="translated">루트 인증서를 &lt;code&gt;server.crt&lt;/code&gt; 에 추가 할 필요는 없습니다 . 대신 클라이언트에는 서버 인증서 체인의 루트 인증서가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c4d12fc72842b14e61904a6ec6e02667bd4e3ff1" translate="yes" xml:space="preserve">
          <source>It is not necessary to be concerned about the amount of time it takes to make a base backup. However, if you normally run the server with &lt;code&gt;full_page_writes&lt;/code&gt; disabled, you might notice a drop in performance while the backup runs since &lt;code&gt;full_page_writes&lt;/code&gt; is effectively forced on during backup mode.</source>
          <target state="translated">기본 백업을 만드는 데 걸리는 시간에 대해 걱정할 필요는 없습니다. 그러나 일반적으로 &lt;code&gt;full_page_writes&lt;/code&gt; 가 비활성화 된 상태 에서 서버를 실행하면 백업 모드 중에 &lt;code&gt;full_page_writes&lt;/code&gt; 가 효과적으로 적용 되므로 백업이 실행되는 동안 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aca7caa9402f8a163da6c6daa7fb30a56a74a363" translate="yes" xml:space="preserve">
          <source>It is not necessary to create table constraints describing partition boundary condition for partitions. Instead, partition constraints are generated implicitly from the partition bound specification whenever there is need to refer to them.</source>
          <target state="translated">파티션의 파티션 경계 조건을 설명하는 테이블 제한 조건을 작성할 필요는 없습니다. 대신, 파티션 제약 조건은 참조가 필요할 때마다 파티션 바인딩 사양에서 암시 적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cf0a2da0ce7b363dca7ad51ebb38c128a6e8bc4b" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or for which the number of additional bytes of storage required is zero.</source>
          <target state="translated">병렬 스캔을 지원하지 않거나 필요한 추가 스토리지 바이트 수가 0 인 액세스 방법에 대해서는이 기능을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="81e24e9944e94aaaad52d26039e5ac57f4d46637" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or in cases where the shared memory space required needs no initialization.</source>
          <target state="translated">병렬 스캔을 지원하지 않거나 필요한 공유 메모리 공간이 초기화 될 필요가없는 경우 액세스 방법에 대해서는이 기능을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="57e901fbd76f488aaa546e02fcd890de2339da2b" translate="yes" xml:space="preserve">
          <source>It is not necessary to provide both of these functions. If one is not specified, the language-specific default behavior will be used if necessary. (To prevent a transformation in a certain direction from happening at all, you could also write a transform function that always errors out.)</source>
          <target state="translated">이 두 기능을 모두 제공 할 필요는 없습니다. 하나를 지정하지 않으면 필요한 경우 언어 별 기본 동작이 사용됩니다. 특정 방향으로의 변환이 전혀 발생하지 않도록 항상 오류가 발생하는 변환 함수를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c2adbe3f4bf051ef1858dcf0e81ceda3ba80d46" translate="yes" xml:space="preserve">
          <source>It is not necessary to replay the WAL entries all the way to the end. We could stop the replay at any point and have a consistent snapshot of the database as it was at that time. Thus, this technique supports &lt;em&gt;point-in-time recovery&lt;/em&gt;: it is possible to restore the database to its state at any time since your base backup was taken.</source>
          <target state="translated">WAL 항목을 끝까지 재생할 필요는 없습니다. 우리는 언제든지 재생을 중지하고 그 당시와 마찬가지로 데이터베이스의 일관된 스냅 샷을 만들 수 있습니다. 따라서이 기술은 &lt;em&gt;특정 시점 복구를&lt;/em&gt; 지원 합니다. 기본 백업을 수행 한 이후 언제든지 데이터베이스를 해당 상태로 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff889e8c8e60f8ff7137e71a9bfef2608859eeae" translate="yes" xml:space="preserve">
          <source>It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt.</source>
          <target state="translated">서버 상태를 얻기 위해 올바른 사용자 이름, 비밀번호 또는 데이터베이스 이름 값을 제공 할 필요는 없습니다. 그러나 잘못된 값을 제공하면 서버는 실패한 연결 시도를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="594a9711ffec0cdfe29afe713704c6029ca7c0e7" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the &lt;code&gt;sync&lt;/code&gt; mount option. The behavior of the &lt;code&gt;async&lt;/code&gt; option is sufficient, since PostgreSQL issues &lt;code&gt;fsync&lt;/code&gt; calls at appropriate times to flush the write caches. (This is analogous to how it works on a local file system.) However, it is strongly recommended to use the &lt;code&gt;sync&lt;/code&gt; export option on the NFS &lt;em&gt;server&lt;/em&gt; on systems where it exists (mainly Linux). Otherwise, an &lt;code&gt;fsync&lt;/code&gt; or equivalent on the NFS client is not actually guaranteed to reach permanent storage on the server, which could cause corruption similar to running with the parameter &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; off. The defaults of these mount and export options differ between vendors and versions, so it is recommended to check and perhaps specify them explicitly in any case to avoid any ambiguity.</source>
          <target state="translated">&lt;code&gt;sync&lt;/code&gt; 마운트 옵션 을 사용할 필요는 없습니다 . PostgreSQL 은 쓰기 캐시를 플러시하기 위해 적절한 시간에 &lt;code&gt;fsync&lt;/code&gt; 호출을 발행하기 때문에 &lt;code&gt;async&lt;/code&gt; 옵션 의 동작으로 충분 합니다. (이것은 로컬 파일 시스템에서 작동하는 방식과 유사합니다.) 그러나 NFS &lt;em&gt;서버&lt;/em&gt; 가 존재하는 시스템 (주로 Linux) 의 NFS &lt;em&gt;서버&lt;/em&gt; 에서 &lt;code&gt;sync&lt;/code&gt; export 옵션 을 사용하는 것이 좋습니다 . 그렇지 않으면, NFS 클라이언트에서 &lt;code&gt;fsync&lt;/code&gt; 또는 이와 동등한 기능이 실제로 서버의 영구 스토리지에 도달하는 것이 보장되지 않으므로 &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; 매개 변수로 실행하는 것과 유사한 손상이 발생할 수 있습니다&lt;em&gt;&lt;/em&gt;떨어져서. 이러한 마운트 및 내보내기 옵션의 기본값은 공급 업체와 버전에 따라 다르므로 모호성을 피하기 위해 경우에 따라 명시 적으로 확인하고 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c52dffeed651be2fa3f87bf20ee3f9a890f9417b" translate="yes" xml:space="preserve">
          <source>It is not possible to release a savepoint when the transaction is in an aborted state.</source>
          <target state="translated">트랜잭션이 중단 된 상태에서는 저장 점을 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfd22308dc33a27874305473df207d131e6a6cc4" translate="yes" xml:space="preserve">
          <source>It is not possible to specify an operator's lexical precedence in &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, because the parser's precedence behavior is hard-wired. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for precedence details.</source>
          <target state="translated">구문 분석기의 우선 순위 동작이 고정되어 있으므로 &lt;code&gt;CREATE OPERATOR&lt;/code&gt; 에서 연산자의 어휘 우선 순위를 지정할 수 없습니다 . 우선 순위에 대해서는 &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;4.1.6 항을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="623a5826c4c93a0ee1b0b35f75bc29bfa6d59c5f" translate="yes" xml:space="preserve">
          <source>It is not possible to turn a regular table into a partitioned table or vice versa. However, it is possible to add a regular or partitioned table containing data as a partition of a partitioned table, or remove a partition from a partitioned table turning it into a standalone table; see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to learn more about the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; and &lt;code&gt;DETACH PARTITION&lt;/code&gt; sub-commands.</source>
          <target state="translated">일반 테이블을 파티션 된 테이블로 또는 그 반대로 변환 할 수 없습니다. 그러나 데이터를 포함하는 일반 또는 파티션 된 테이블을 파티션 된 테이블의 파티션으로 추가하거나 파티션 된 테이블에서 파티션을 제거하여 독립형 테이블로 변환 할 수 있습니다. &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 및 &lt;code&gt;DETACH PARTITION&lt;/code&gt; 하위 명령에 대한 자세한 내용 은 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2662bc57686704e0177490490462c24f0b6b158d" translate="yes" xml:space="preserve">
          <source>It is often a good idea to also omit from the backup the files within the cluster's &lt;code&gt;pg_replslot/&lt;/code&gt; directory, so that replication slots that exist on the master do not become part of the backup. Otherwise, the subsequent use of the backup to create a standby may result in indefinite retention of WAL files on the standby, and possibly bloat on the master if hot standby feedback is enabled, because the clients that are using those replication slots will still be connecting to and updating the slots on the master, not the standby. Even if the backup is only intended for use in creating a new master, copying the replication slots isn't expected to be particularly useful, since the contents of those slots will likely be badly out of date by the time the new master comes on line.</source>
          <target state="translated">마스터에 존재하는 복제 슬롯이 백업의 일부가되지 않도록 클러스터의 &lt;code&gt;pg_replslot/&lt;/code&gt; 디렉토리에 있는 파일을 백업에서 생략하는 것이 좋습니다 . 그렇지 않으면, 백업을 사용하여 대기를 작성하면 대기에서 WAL 파일이 무기한 보유 될 수 있으며 핫 대기 피드백이 사용 가능한 경우 마스터에서 부 풀릴 수 있습니다. 해당 복제 슬롯을 사용하는 클라이언트는 계속 연결되어 있기 때문입니다. 대기가 아닌 마스터의 슬롯으로 업데이트합니다. 백업이 새 마스터를 생성 할 목적으로 만 사용 되더라도 복제 마스터를 복사하는 것은 새 마스터가 온라인 상태가 될 때까지 해당 슬롯의 내용이 오래되지 않기 때문에 특히 유용하지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="d49711f89af35705bbf2891f981f944c8b5260d9" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the function definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them.</source>
          <target state="translated">함수형 문자열을 일반적인 작은 따옴표 구문 대신 쓰기 위해 달러 인용 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;4.1.2.4&lt;/a&gt; 참조)을 사용하는 것이 종종 도움이됩니다 . 달러 따옴표가 없으면 함수 정의에서 작은 따옴표 나 백 슬래시는 두 배로 이스케이프 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="070ae03385b0624216e0f28d18b1063fb9896a1e" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the procedure definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the procedure definition must be escaped by doubling them.</source>
          <target state="translated">프로 시저 정의 문자열을 일반적인 작은 따옴표 구문 대신 쓰기 위해 달러 인용 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;4.1.2.4&lt;/a&gt; 참조)을 사용하는 것이 종종 도움이됩니다 . 달러 따옴표가 없으면 프로 시저 정의의 작은 따옴표 나 백 슬래시는 두 배로 이스케이프 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="1037cf4994d8c1ebf0e5d5f237e680d00560257d" translate="yes" xml:space="preserve">
          <source>It is often particularly handy to &lt;code&gt;LEFT JOIN&lt;/code&gt; to a &lt;code&gt;LATERAL&lt;/code&gt; subquery, so that source rows will appear in the result even if the &lt;code&gt;LATERAL&lt;/code&gt; subquery produces no rows for them. For example, if &lt;code&gt;get_product_names()&lt;/code&gt; returns the names of products made by a manufacturer, but some manufacturers in our table currently produce no products, we could find out which ones those are like this:</source>
          <target state="translated">그것은 종종 특히 편리 &lt;code&gt;LEFT JOIN&lt;/code&gt; A를 &lt;code&gt;LATERAL&lt;/code&gt; 짝수 경우 소스 행이 결과에 나타납니다 그래서, 하위 쿼리 &lt;code&gt;LATERAL&lt;/code&gt; 하위 쿼리가 그들을 위해 더 열을 생산하지 않습니다. 예를 들어, &lt;code&gt;get_product_names()&lt;/code&gt; 가 제조업체가 만든 제품의 이름을 반환하지만 현재 테이블의 일부 제조업체가 제품을 생산하지 않는 경우 다음과 같은 제품을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25dd81b9b45b03c00d03cc26e891361c1cfb5adf" translate="yes" xml:space="preserve">
          <source>It is often preferable to use unique index inference rather than naming a constraint directly using &lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt;&lt;code&gt;constraint_name&lt;/code&gt;. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when using &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; before dropping the index being replaced.</source>
          <target state="translated">&lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt; &lt;code&gt;constraint_name&lt;/code&gt; 을 사용하여 직접 제약 조건의 이름을 지정하는 대신 고유 한 인덱스 유추를 사용하는 것이 좋습니다 . 기본 인덱스가 겹치는 방식으로 다른 동등한 인덱스로 대체 될 때 (예 : 대체 인덱스를 삭제하기 전에 &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; 를 사용하는 경우) 추론이 계속 올바르게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f0921a8a84d9d3343d74c19f7c3f5f4b06b1c95a" translate="yes" xml:space="preserve">
          <source>It is possible for a &lt;code&gt;SELECT&lt;/code&gt; command running at the &lt;code&gt;READ COMMITTED&lt;/code&gt; transaction isolation level and using &lt;code&gt;ORDER BY&lt;/code&gt; and a locking clause to return rows out of order. This is because &lt;code&gt;ORDER BY&lt;/code&gt; is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the &lt;code&gt;SELECT&lt;/code&gt; unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; clause in a sub-query, for example</source>
          <target state="translated">&lt;code&gt;READ COMMITTED&lt;/code&gt; 트랜잭션 격리 수준 에서 실행되고 &lt;code&gt;ORDER BY&lt;/code&gt; 및 잠금 절을 사용하여 행을 순서대로 반환하지 않는 &lt;code&gt;SELECT&lt;/code&gt; 명령 이 가능합니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 가 먼저 적용 되기 때문 입니다. 이 명령은 결과를 정렬하지만 하나 이상의 행에서 잠금을 얻으려고 시도하는 것을 차단할 수 있습니다. 한 번 &lt;code&gt;SELECT&lt;/code&gt; 가 풀려, 주문 열 값의 일부 (그들은 원래 열 값의 측면에서 순서대로하지만) 순서가 될 나타나는 해당 행으로 이어지는, 수정되었을 수 있습니다. 예를 들어 &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; 절을 하위 쿼리 에 배치하면 필요에 따라 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="312a8769f42a09f432ff89ed107b0b0a082956d5" translate="yes" xml:space="preserve">
          <source>It is possible for both the client and server to provide SSL certificates to each other. It takes some extra configuration on each side, but this provides stronger verification of identity than the mere use of passwords. It prevents a computer from pretending to be the server just long enough to read the password sent by the client. It also helps prevent &amp;ldquo;man in the middle&amp;rdquo; attacks where a computer between the client and server pretends to be the server and reads and passes all data between the client and server.</source>
          <target state="translated">클라이언트와 서버 모두 SSL 인증서를 서로 제공 할 수 있습니다. 양쪽에 약간의 추가 구성이 필요하지만 이는 단순한 암호 사용보다 강력한 신원 확인을 제공합니다. 클라이언트가 보낸 암호를 읽을 수있을 정도로 컴퓨터가 서버 인 것처럼 가장하는 것을 방지합니다. 또한 클라이언트와 서버 사이의 컴퓨터가 서버 인 것처럼 &quot;중간자 공격&quot;을 방지하고 클라이언트와 서버 사이의 모든 데이터를 읽고 전달합니다.</target>
        </trans-unit>
        <trans-unit id="90f59c9a7c7c3d668eb0d91ba42953cad54439f7" translate="yes" xml:space="preserve">
          <source>It is possible for the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;SELECT&lt;/code&gt; statement) to also contain a &lt;code&gt;WITH&lt;/code&gt; clause. In such a case both sets of &lt;code&gt;with_query&lt;/code&gt; can be referenced within the &lt;code&gt;query&lt;/code&gt;, but the second one takes precedence since it is more closely nested.</source>
          <target state="translated">가능합니다 &lt;code&gt;query&lt;/code&gt; ( &lt;code&gt;SELECT&lt;/code&gt; 도 포함하는 문) &lt;code&gt;WITH&lt;/code&gt; 절. 이러한 경우 &lt;code&gt;with_query&lt;/code&gt; 의 두 세트를 &lt;code&gt;query&lt;/code&gt; 내에서 참조 할 수 있지만 두 번째 세트 는 더 밀접하게 중첩되므로 우선합니다.</target>
        </trans-unit>
        <trans-unit id="db7d99e745d7786411f8e352570962f202386c2e" translate="yes" xml:space="preserve">
          <source>It is possible for the parser to produce overlapping tokens from the same piece of text. As an example, a hyphenated word will be reported both as the entire word and as each component:</source>
          <target state="translated">파서는 동일한 텍스트 조각에서 겹치는 토큰을 생성 할 수 있습니다. 예를 들어, 하이픈으로 묶인 단어는 전체 단어와 각 구성 요소로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="2357da6f1597b1c38d9b19b97f4eaf9ba4d3b605" translate="yes" xml:space="preserve">
          <source>It is possible that the replication delay between servers exceeds the value of this parameter, in which case no delay is added. Note that the delay is calculated between the WAL time stamp as written on master and the current time on the standby. Delays in transfer because of network lag or cascading replication configurations may reduce the actual wait time significantly. If the system clocks on master and standby are not synchronized, this may lead to recovery applying records earlier than expected; but that is not a major issue because useful settings of this parameter are much larger than typical time deviations between servers.</source>
          <target state="translated">서버 간의 복제 지연이이 매개 변수의 값을 초과 할 수 있으며이 경우 지연이 추가되지 않습니다. 지연은 마스터에 기록 된 WAL 타임 스탬프와 대기 시간의 현재 시간 사이에 계산됩니다. 네트워크 지연 또는 계단식 복제 구성으로 인해 전송이 지연되면 실제 대기 시간이 크게 단축 될 수 있습니다. 마스터 및 대기의 시스템 시계가 동기화되지 않으면 예상보다 빨리 레코드를 적용하여 복구 할 수 있습니다. 그러나이 매개 변수의 유용한 설정이 서버 간의 일반적인 시간 편차보다 훨씬 크기 때문에 중요한 문제는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f9e86aaa136a99713e8aa37be86f1493657e5f36" translate="yes" xml:space="preserve">
          <source>It is possible to access the two component numbers of a &lt;code&gt;point&lt;/code&gt; as though the point were an array with indexes 0 and 1. For example, if &lt;code&gt;t.p&lt;/code&gt; is a &lt;code&gt;point&lt;/code&gt; column then &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; retrieves the X coordinate and &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; changes the Y coordinate. In the same way, a value of type &lt;code&gt;box&lt;/code&gt; or &lt;code&gt;lseg&lt;/code&gt; can be treated as an array of two &lt;code&gt;point&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; 인덱스 0과 1을 갖는 배열 인 것처럼 점 의 두 구성 요소 번호에 액세스 할 수 있습니다 . 예를 들어, &lt;code&gt;t.p&lt;/code&gt; 가 &lt;code&gt;point&lt;/code&gt; 열인 경우 &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; 는 X 좌표를 검색하고 &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; Y 좌표를 변경합니다. 같은 방식으로 &lt;code&gt;box&lt;/code&gt; 또는 &lt;code&gt;lseg&lt;/code&gt; 유형의 값 을 두 &lt;code&gt;point&lt;/code&gt; 값 의 배열로 취급 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fd72ecc1dea1c97715f5cc99a51c3564620c9cb" translate="yes" xml:space="preserve">
          <source>It is possible to check the accuracy of the planner's estimates by using &lt;code&gt;EXPLAIN&lt;/code&gt;'s &lt;code&gt;ANALYZE&lt;/code&gt; option. With this option, &lt;code&gt;EXPLAIN&lt;/code&gt; actually executes the query, and then displays the true row counts and true run time accumulated within each plan node, along with the same estimates that a plain &lt;code&gt;EXPLAIN&lt;/code&gt; shows. For example, we might get a result like this:</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; 의 &lt;code&gt;ANALYZE&lt;/code&gt; 옵션 을 사용하여 플래너 추정값의 정확성을 확인할 수 있습니다. 이 옵션을 사용하면 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 실제로 쿼리를 실행 한 다음 일반 &lt;code&gt;EXPLAIN&lt;/code&gt; 이 표시 하는 것과 동일한 추정값과 함께 각 계획 노드 내에 누적 된 실제 행 수와 실제 런타임을 표시합니다. 예를 들어 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed45fb50f823ca992b140dff1d81be186a3aef4d" translate="yes" xml:space="preserve">
          <source>It is possible to control the query planner to some extent by using the explicit &lt;code&gt;JOIN&lt;/code&gt; syntax. To see why this matters, we first need some background.</source>
          <target state="translated">명시 적 &lt;code&gt;JOIN&lt;/code&gt; 구문 을 사용하여 쿼리 플래너를 어느 정도 제어 할 수 있습니다 . 이것이 왜 중요한지 보려면 먼저 배경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="21ffb53e2d68da0c7954b41e98f5975f4ecf8084" translate="yes" xml:space="preserve">
          <source>It is possible to create a foreign-data wrapper with no handler function, but foreign tables using such a wrapper can only be declared, not accessed.</source>
          <target state="translated">핸들러 함수없이 외부 데이터 랩퍼를 작성할 수 있지만 이러한 랩퍼를 사용하는 외부 테이블은 액세스 할 수없고 선언 만 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5bd3763bfcd5993518d08a6fc8f19894d8b599a" translate="yes" xml:space="preserve">
          <source>It is possible to create additional template databases, and indeed one can copy any database in a cluster by specifying its name as the template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. It is important to understand, however, that this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the source database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; during the copy operation, new connections to the source database are prevented.</source>
          <target state="translated">추가 템플리트 데이터베이스를 작성할 수 있으며 실제로 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 의 템플리트로 이름을 지정하여 클러스터의 모든 데이터베이스를 복사 할 수 있습니다 . 그러나 이것이 범용 &quot; &lt;code&gt;COPY DATABASE&lt;/code&gt; &quot;기능 으로 의도 된 것이 아님을 이해하는 것이 중요합니다 . 주요 제한 사항은 소스 데이터베이스를 복사하는 동안 다른 세션을 소스 데이터베이스에 연결할 수 없다는 것입니다. 시작할 때 다른 연결이 존재하면 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 가 실패합니다. 복사 작업 중에는 소스 데이터베이스에 대한 새로운 연결이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="e68d9c04db6c0169a67f695c187f5caec6e9c6fb" translate="yes" xml:space="preserve">
          <source>It is possible to dispense with &lt;code&gt;SET TRANSACTION&lt;/code&gt; by instead specifying the desired &lt;code&gt;transaction_modes&lt;/code&gt; in &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt;. But that option is not available for &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;BEGIN&lt;/code&gt; 또는 &lt;code&gt;START TRANSACTION&lt;/code&gt; 에서 원하는 &lt;code&gt;transaction_modes&lt;/code&gt; 를 지정하여 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 을 생략 할 수 있습니다 . 그러나 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 에는이 옵션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c6a819090253f862f39b7dcfdb25432b06b91898" translate="yes" xml:space="preserve">
          <source>It is possible to do a full text search without an index. A simple query to print the &lt;code&gt;title&lt;/code&gt; of each row that contains the word &lt;code&gt;friend&lt;/code&gt; in its &lt;code&gt;body&lt;/code&gt; field is:</source>
          <target state="translated">색인없이 전체 텍스트 검색을 수행 할 수 있습니다. 간단한 쿼리는 인쇄 &lt;code&gt;title&lt;/code&gt; 단어가 포함 된 각 행의 &lt;code&gt;friend&lt;/code&gt; 의에서 &lt;code&gt;body&lt;/code&gt; 필드입니다 :</target>
        </trans-unit>
        <trans-unit id="6f136c23eebfd4cd415f6012b712c4df1242fdcd" translate="yes" xml:space="preserve">
          <source>It is possible to have authentication without encryption overhead by using &lt;code&gt;NULL-SHA&lt;/code&gt; or &lt;code&gt;NULL-MD5&lt;/code&gt; ciphers. However, a man-in-the-middle could read and pass communications between client and server. Also, encryption overhead is minimal compared to the overhead of authentication. For these reasons NULL ciphers are not recommended.</source>
          <target state="translated">&lt;code&gt;NULL-SHA&lt;/code&gt; 또는 &lt;code&gt;NULL-MD5&lt;/code&gt; 암호 를 사용하여 암호화 오버 헤드없이 인증을받을 수 있습니다. 그러나 man-in-the-middle은 클라이언트와 서버 간의 통신을 읽고 전달할 수 있습니다. 또한 인증 오버 헤드에 비해 암호화 오버 헤드가 최소화됩니다. 이러한 이유로 NULL 암호는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3a0ba5698f2b4b4f4b4ee88ac329603107cde1d" translate="yes" xml:space="preserve">
          <source>It is possible to log to stderr without using the logging collector; the log messages will just go to wherever the server's stderr is directed. However, that method is only suitable for low log volumes, since it provides no convenient way to rotate log files. Also, on some platforms not using the logging collector can result in lost or garbled log output, because multiple processes writing concurrently to the same log file can overwrite each other's output.</source>
          <target state="translated">로깅 콜렉터를 사용하지 않고 stderr에 로그 할 수 있습니다. 로그 메시지는 서버의 stderr가 향하는 곳이면 어디든 갈 것입니다. 그러나이 방법은 로그 파일을 회전시키는 편리한 방법을 제공하지 않으므로 적은 로그 볼륨에만 적합합니다. 또한 로깅 콜렉터를 사용하지 않는 일부 플랫폼에서는 동일한 로그 파일에 동시에 쓰는 여러 프로세스가 서로의 출력을 겹쳐 쓸 수 있기 때문에 로그 출력이 손실되거나 깨질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e9a78df914fad0648da0a65b3ec648ec904013" translate="yes" xml:space="preserve">
          <source>It is possible to nest dollar-quoted string constants by choosing different tags at each nesting level. This is most commonly used in writing function definitions. For example:</source>
          <target state="translated">각 중첩 수준에서 다른 태그를 선택하여 달러 인용 문자열 상수를 중첩 할 수 있습니다. 이것은 함수 정의를 작성할 때 가장 일반적으로 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0a345a5b07bad2c1307139346533842f66f7f85" translate="yes" xml:space="preserve">
          <source>It is possible to omit the &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; of a slice specifier; the missing bound is replaced by the lower or upper limit of the array's subscripts. For example:</source>
          <target state="translated">슬라이스 지정자의 &lt;code&gt;lower-bound&lt;/code&gt; 및 / 또는 &lt;code&gt;upper-bound&lt;/code&gt; 을 생략 할 수 있으며 ; 누락 된 경계는 배열 아래 첨자의 하한 또는 상한으로 대체됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0fbcc6e88bd4f468012c5b5e8934f903489fc504" translate="yes" xml:space="preserve">
          <source>It is possible to run &lt;code&gt;ANALYZE&lt;/code&gt; on specific tables and even just specific columns of a table, so the flexibility exists to update some statistics more frequently than others if your application requires it. In practice, however, it is usually best to just analyze the entire database, because it is a fast operation. &lt;code&gt;ANALYZE&lt;/code&gt; uses a statistically random sampling of the rows of a table rather than reading every single row.</source>
          <target state="translated">특정 테이블 및 테이블의 특정 열에서만 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행할 수 있으므로 응용 프로그램에 필요한 경우 다른 통계보다 더 자주 일부 통계를 업데이트 할 수있는 유연성이 있습니다. 그러나 실제로는 전체 데이터베이스가 빠른 작업이므로 전체 데이터베이스를 분석하는 것이 가장 좋습니다. &lt;code&gt;ANALYZE&lt;/code&gt; 는 모든 단일 행을 읽는 대신 테이블의 행을 통계적으로 무작위로 샘플링합니다.</target>
        </trans-unit>
        <trans-unit id="56b863d1457c5714b3cbf931bd78aab64ed29d7b" translate="yes" xml:space="preserve">
          <source>It is possible to set up more complex expression indexes wherein the configuration name is specified by another column, e.g.:</source>
          <target state="translated">구성 이름이 다른 열에 의해 지정된보다 복잡한 표현식 색인을 설정할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ab7995c28ab9203226049f19e6325626835b07f5" translate="yes" xml:space="preserve">
          <source>It is possible to use PostgreSQL's backup facilities to produce standalone hot backups. These are backups that cannot be used for point-in-time recovery, yet are typically much faster to backup and restore than pg_dump dumps. (They are also much larger than pg_dump dumps, so in some cases the speed advantage might be negated.)</source>
          <target state="translated">PostgreSQL의 백업 기능을 사용하여 독립형 핫 백업을 생성 할 수 있습니다. 이는 특정 시점 복구에는 사용할 수 없지만 일반적으로 pg_dump 덤프보다 백업 및 복원 속도가 훨씬 빠릅니다. (또한 pg_dump 덤프보다 훨씬 크기 때문에 속도 이점이 무시 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="793bdae387c6386aab767254ea0495efd0a0f102" translate="yes" xml:space="preserve">
          <source>It is possible to use SELinux's dynamic domain transition feature to switch the security label of the client process, the client domain, to a new context, if that is allowed by the security policy. The client domain needs the &lt;code&gt;setcurrent&lt;/code&gt; permission and also &lt;code&gt;dyntransition&lt;/code&gt; from the old to the new domain.</source>
          <target state="translated">보안 정책에서 허용하는 경우 SELinux의 동적 도메인 전환 기능을 사용하여 클라이언트 프로세스, 클라이언트 도메인의 보안 레이블을 새 컨텍스트로 전환 할 수 있습니다. 클라이언트 도메인은 필요 &lt;code&gt;setcurrent&lt;/code&gt; 허락도 &lt;code&gt;dyntransition&lt;/code&gt; 새로운 도메인으로 이전부터입니다.</target>
        </trans-unit>
        <trans-unit id="fea64923e6a1c45508b51b78c6ed3fd042a235d3" translate="yes" xml:space="preserve">
          <source>It is possible to use SSH to encrypt the network connection between clients and a PostgreSQL server. Done properly, this provides an adequately secure network connection, even for non-SSL-capable clients.</source>
          <target state="translated">SSH를 사용하여 클라이언트와 PostgreSQL 서버 간의 네트워크 연결을 암호화 할 수 있습니다. 올바르게 수행하면 SSL을 지원하지 않는 클라이언트에게도 적절한 보안 네트워크 연결이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="05887c55098593888d9b6548b102c0d07ee418cb" translate="yes" xml:space="preserve">
          <source>It is possible to use an NFS file system for storing the PostgreSQL data directory. PostgreSQL does nothing special for NFS file systems, meaning it assumes NFS behaves exactly like locally-connected drives. PostgreSQL does not use any functionality that is known to have nonstandard behavior on NFS, such as file locking.</source>
          <target state="translated">PostgreSQL 데이터 디렉토리를 저장하기 위해 NFS 파일 시스템을 사용할 수 있습니다. PostgreSQL은 NFS 파일 시스템에 대해 특별한 작업을 수행하지 않으므로 NFS가 로컬로 연결된 드라이브와 똑같이 작동한다고 가정합니다. PostgreSQL은 파일 잠금과 같이 NFS에서 비표준 동작을하는 것으로 알려진 기능을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d07d0d357ed59e4c40820ac16ee2111a412a9fe9" translate="yes" xml:space="preserve">
          <source>It is recommended that in a &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; call, the access method further verify that the target row actually does have an existing entry in the index, and report error if not. This is a good idea because the index tuple values passed to &lt;code&gt;aminsert&lt;/code&gt; will have been recomputed. If the index definition involves functions that are not really immutable, we might be checking the wrong area of the index. Checking that the target row is found in the recheck verifies that we are scanning for the same tuple values as were used in the original insertion.</source>
          <target state="translated">에하는 것이 좋습니다 &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; 의 전화, 액세스 방법이 더 목표 행이 실제로 기존 인덱스의 항목 및 보고서 오류 아니더라도을 가지고 있는지 확인하십시오. &lt;code&gt;aminsert&lt;/code&gt; 에 전달 된 인덱스 튜플 값 이 다시 계산 되므로이 방법 을 사용 하는 것이 좋습니다 . 인덱스 정의에 실제로 변경할 수없는 함수가 포함되어 있으면 인덱스의 잘못된 영역을 검사하는 것일 수 있습니다. 재확인에서 대상 행이 있는지 확인하면 원래 삽입에서 사용한 것과 동일한 튜플 값을 스캔하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="302398642319ebf3c5925fc78db8e53f6245f737" translate="yes" xml:space="preserve">
          <source>It is recommended that the file name used in &lt;code&gt;COPY&lt;/code&gt; always be specified as an absolute path. This is enforced by the server in the case of &lt;code&gt;COPY TO&lt;/code&gt;, but for &lt;code&gt;COPY FROM&lt;/code&gt; you do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 에 사용 된 파일 이름은 항상 절대 경로로 지정 하는 것이 좋습니다 . 이것은 &lt;code&gt;COPY TO&lt;/code&gt; 의 경우 서버에 의해 적용 되지만 &lt;code&gt;COPY FROM&lt;/code&gt; 의 경우 상대 경로로 지정된 파일에서 읽을 수있는 옵션이 있습니다. 경로는 클라이언트의 작업 디렉토리가 아닌 서버 프로세스의 작업 디렉토리 (일반적으로 클러스터의 데이터 디렉토리)를 기준으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="fc0e534ffa8e632dc4cfe7cd8ad98fc538520874" translate="yes" xml:space="preserve">
          <source>It is recommended that you use the pg_dump and pg_dumpall programs from the &lt;em&gt;newer&lt;/em&gt; version of PostgreSQL, to take advantage of enhancements that might have been made in these programs. Current releases of the dump programs can read data from any server version back to 7.0.</source>
          <target state="translated">&lt;em&gt;최신&lt;/em&gt; 버전의 PostgreSQL 에서 pg_dump 및 pg_dumpall 프로그램을 사용하여 이러한 프로그램에서 개선 된 기능을 활용하는 것이 좋습니다. 덤프 프로그램의 현재 릴리스는 모든 서버 버전에서 7.0으로 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="580dc3a7b05e5fa4e5a6d4851ec4e93eeb1cdf02" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be resent from the publisher.</source>
          <target state="translated">사용하기 안전 &lt;code&gt;off&lt;/code&gt; 논리적 복제 : 가입자가 때문에 동기화 누락의 거래를 중단되면 데이터가 게시자의 재전송 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="70a88889b7d21af89f699959f3df667165202cd6" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications generating &lt;code&gt;COPY&lt;/code&gt; data convert data newlines and carriage returns to the &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; sequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if the &lt;code&gt;COPY&lt;/code&gt; file is transferred across different machines (for example, from Unix to Windows or vice versa).</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 데이터를 생성하는 응용 프로그램은 데이터 줄 바꾸기 및 캐리지 리턴을 각각 &lt;code&gt;\n&lt;/code&gt; 및 &lt;code&gt;\r&lt;/code&gt; 시퀀스 로 변환 하는 것이 좋습니다 . 현재 백 슬래시 및 캐리지 리턴으로 데이터 캐리지 리턴을 표시하고 백 슬래시 및 뉴 라인으로 데이터 뉴 라인을 표시 할 수 있습니다. 그러나 다음 릴리스에서는 이러한 표현이 허용되지 않을 수 있습니다. 또한 &lt;code&gt;COPY&lt;/code&gt; 파일이 다른 시스템 (예 : Unix에서 Windows로 또는 그 반대로)으로 전송되는 경우 손상에 매우 취약합니다 .</target>
        </trans-unit>
        <trans-unit id="5d757720e64f735dd8e83c5c66b88db49094003f" translate="yes" xml:space="preserve">
          <source>It is typically used like this:</source>
          <target state="translated">일반적으로 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb6eae65d1260158a9aaaa3278cf273df69fbee7" translate="yes" xml:space="preserve">
          <source>It is unwise to leave transactions in the prepared state for a long time. This will interfere with the ability of &lt;code&gt;VACUUM&lt;/code&gt; to reclaim storage, and in extreme cases could cause the database to shut down to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;). Keep in mind also that the transaction continues to hold whatever locks it held. The intended usage of the feature is that a prepared transaction will normally be committed or rolled back as soon as an external transaction manager has verified that other databases are also prepared to commit.</source>
          <target state="translated">트랜잭션을 준비된 상태로 오랫동안 두는 것은 현명하지 않습니다. 이는 &lt;code&gt;VACUUM&lt;/code&gt; 이 스토리지를 재생 하는 기능을 방해하며, 극단적 인 경우 트랜잭션 ID 랩 어라운드를 방지하기 위해 데이터베이스가 종료 될 수 있습니다 ( &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절&lt;/a&gt; 참조 ). 또한 트랜잭션은 보유한 모든 잠금을 계속 보유합니다. 이 기능의 의도 된 용도는 외부 트랜잭션 관리자가 다른 데이터베이스도 커밋 할 준비가되었음을 확인하자마자 준비된 트랜잭션이 정상적으로 커밋되거나 롤백되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a307e2692a3d4dc03f3b0a5f0050741c926c9763" translate="yes" xml:space="preserve">
          <source>It is up to the database designer to define the channel names that will be used in a given database and what each one means. Commonly, the channel name is the same as the name of some table in the database, and the notify event essentially means, &amp;ldquo;I changed this table, take a look at it to see what's new&amp;rdquo;. But no such association is enforced by the &lt;code&gt;NOTIFY&lt;/code&gt; and &lt;code&gt;LISTEN&lt;/code&gt; commands. For example, a database designer could use several different channel names to signal different sorts of changes to a single table. Alternatively, the payload string could be used to differentiate various cases.</source>
          <target state="translated">주어진 데이터베이스에서 사용될 채널 이름과 각각의 의미를 정의하는 것은 데이터베이스 디자이너의 책임입니다. 일반적으로 채널 이름은 데이터베이스의 일부 테이블 이름과 동일하며 알림 이벤트는 기본적으로 &quot;이 테이블을 변경했습니다. 새로운 기능을 확인하려면이 테이블을 살펴보십시오&quot;를 의미합니다. 그러나 &lt;code&gt;NOTIFY&lt;/code&gt; 및 &lt;code&gt;LISTEN&lt;/code&gt; 명령으로 이러한 연관을 시행하지는 않습니다 . 예를 들어, 데이터베이스 디자이너는 여러 다른 채널 이름을 사용하여 단일 테이블에 대한 다양한 종류의 변경을 신호 할 수 있습니다. 또는 페이로드 문자열을 사용하여 다양한 경우를 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b6810a1ee6954d361d4c3ec546cf2001eccf7f" translate="yes" xml:space="preserve">
          <source>It is up to the specific dictionary how it treats stop words. For example, &lt;code&gt;ispell&lt;/code&gt; dictionaries first normalize words and then look at the list of stop words, while &lt;code&gt;Snowball&lt;/code&gt; stemmers first check the list of stop words. The reason for the different behavior is an attempt to decrease noise.</source>
          <target state="translated">중지 단어를 처리하는 방법은 특정 사전에 달려 있습니다. 예를 들어, &lt;code&gt;ispell&lt;/code&gt; 사전은 먼저 단어를 정규화 한 다음 중지 단어 목록을보고 &lt;code&gt;Snowball&lt;/code&gt; 형태소 분석기는 먼저 중지 단어 목록을 확인합니다. 다른 행동의 이유는 소음을 줄이기위한 시도입니다.</target>
        </trans-unit>
        <trans-unit id="f04c713c711198819201fd61c74a6825a1ba7c14" translate="yes" xml:space="preserve">
          <source>It is usually wise to create the primary and standby servers so that they are as similar as possible, at least from the perspective of the database server. In particular, the path names associated with tablespaces will be passed across unmodified, so both primary and standby servers must have the same mount paths for tablespaces if that feature is used. Keep in mind that if &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; is executed on the primary, any new mount point needed for it must be created on the primary and all standby servers before the command is executed. Hardware need not be exactly the same, but experience shows that maintaining two identical systems is easier than maintaining two dissimilar ones over the lifetime of the application and system. In any case the hardware architecture must be the same &amp;mdash; shipping from, say, a 32-bit to a 64-bit system will not work.</source>
          <target state="translated">최소한 데이터베이스 서버의 관점에서 볼 때 가능한 한 유사하도록 기본 및 대기 서버를 작성하는 것이 좋습니다. 특히, 테이블 스페이스와 연관된 경로 이름은 수정되지 않은 상태로 전달되므로 해당 기능이 사용되는 경우 기본 서버와 대기 서버 모두 테이블 스페이스에 대해 동일한 마운트 경로를 가져야합니다. &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE 인&lt;/a&gt; 경우기본에서 실행되는 경우 명령을 실행하기 전에 기본 및 모든 대기 서버에서 필요한 새 마운트 지점을 작성해야합니다. 하드웨어가 정확히 동일 할 필요는 없지만, 경험에 따르면 응용 프로그램 및 시스템 수명 동안 2 개의 동일한 시스템을 유지 관리하는 것이 2 개의 다른 시스템을 유지 관리하는 것이 더 쉽다는 것이 밝혀졌습니다. 어쨌든 하드웨어 아키텍처는 동일해야합니다. 예를 들어 32 비트에서 64 비트 시스템으로의 배송은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ca150da1f7706a6be21716f546b65e3672dbc4a" translate="yes" xml:space="preserve">
          <source>It is very difficult to avoid such problems, because of SQL's general assumption that a null value is a valid value of every data type. Best practice therefore is to design a domain's constraints so that a null value is allowed, and then to apply column &lt;code&gt;NOT NULL&lt;/code&gt; constraints to columns of the domain type as needed, rather than directly to the domain type.</source>
          <target state="translated">널값이 모든 데이터 유형의 유효한 값이라는 SQL의 일반적인 가정 때문에 이러한 문제점을 피하는 것은 매우 어렵습니다. 따라서 가장 좋은 방법은 null 값이 허용되도록 도메인의 제약 조건을 디자인 한 다음 도메인 유형의 열에 필요 &lt;code&gt;NOT NULL&lt;/code&gt; 경우 도메인 유형의 열에 NOT NULL 열 제약 조건을 적용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ca67a8bc55b2440ee4642c5a3836e4f1be7ce5b" translate="yes" xml:space="preserve">
          <source>It is very difficult to enforce business rules regarding data integrity using Read Committed transactions because the view of the data is shifting with each statement, and even a single statement may not restrict itself to the statement's snapshot if a write conflict occurs.</source>
          <target state="translated">커밋 된 읽기 트랜잭션을 사용하여 데이터 무결성에 관한 비즈니스 규칙을 적용하는 것은 매우 어렵습니다. 데이터 뷰가 각 명령문마다 바뀌고 있기 때문에 쓰기 충돌이 발생할 경우 단일 명령문이라도 명령문의 스냅 샷으로 제한되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c946419a4ac69d8f0e7011290f8155362fae2bbd" translate="yes" xml:space="preserve">
          <source>It is very easy to use pgbench to produce completely meaningless numbers. Here are some guidelines to help you get useful results.</source>
          <target state="translated">pgbench를 사용하여 완전히 의미없는 숫자를 생성하는 것은 매우 쉽습니다. 유용한 결과를 얻는 데 도움이되는 몇 가지 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a18d874cf4b801c23ef52010af4733b69c843e7" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as a superuser or an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="translated">권한있는 정보를 쉽게 추출 할 수 있기 때문에 신뢰할 수있는 사용자 만 WAL 스트림을 읽을 수 있도록 복제 액세스 권한을 설정하는 것이 매우 중요합니다. 대기 서버는 수퍼 유저 또는 &lt;code&gt;REPLICATION&lt;/code&gt; 권한 이있는 계정으로 기본 서버를 인증해야합니다 . 복제에 대한 &lt;code&gt;REPLICATION&lt;/code&gt; 및 &lt;code&gt;LOGIN&lt;/code&gt; 권한을 가진 전용 사용자 계정을 만드는 것이 좋습니다 . &lt;code&gt;REPLICATION&lt;/code&gt; 권한은 매우 높은 권한을 부여 하지만 사용자는 &lt;code&gt;SUPERUSER&lt;/code&gt; 권한이 수행 하는 기본 시스템의 데이터를 수정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d630958bd06e172aebb494cef807db838ae776b4" translate="yes" xml:space="preserve">
          <source>It is very important to take care to avoid circular rules. For example, though each of the following two rule definitions are accepted by PostgreSQL, the &lt;code&gt;SELECT&lt;/code&gt; command would cause PostgreSQL to report an error because of recursive expansion of a rule:</source>
          <target state="translated">순환 규칙을 피하기 위해주의를 기울여야합니다. 예를 들어, PostgreSQL은 다음 두 가지 규칙 정의를 승인하지만 &lt;code&gt;SELECT&lt;/code&gt; 명령은 규칙의 재귀 확장으로 인해 PostgreSQL이 오류를보고하게합니다.</target>
        </trans-unit>
        <trans-unit id="5a1a313f5514df92e2599108b061f0b4f0a8e02d" translate="yes" xml:space="preserve">
          <source>It is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables.</source>
          <target state="translated">조인 쿼리에서 모든 열 이름을 한정하는 것이 좋은 스타일로 널리 간주되므로 중복 열 이름이 나중에 테이블 중 하나에 추가 되어도 쿼리가 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="906e585ddeae75bc90c0d2a785d10b4e23e5052c" translate="yes" xml:space="preserve">
          <source>It is wise to be conservative about marking casts as implicit. An overabundance of implicit casting paths can cause PostgreSQL to choose surprising interpretations of commands, or to be unable to resolve commands at all because there are multiple possible interpretations. A good rule of thumb is to make a cast implicitly invokable only for information-preserving transformations between types in the same general type category. For example, the cast from &lt;code&gt;int2&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; can reasonably be implicit, but the cast from &lt;code&gt;float8&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; should probably be assignment-only. Cross-type-category casts, such as &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt;, are best made explicit-only.</source>
          <target state="translated">캐스트를 암시 적으로 표시하는 것은 보수적 인 것이 좋습니다. 암시 적 캐스팅 경로가 너무 많으면 PostgreSQL이 놀라운 명령 해석을 선택하거나 여러 가지 해석이 가능하므로 명령을 전혀 해석하지 못할 수 있습니다. 일반적으로 동일한 일반 유형 범주에서 유형 간 정보 보존 변환에만 캐스트를 내재적으로 호출 할 수 없도록하는 것이 좋습니다. 예를 들어, &lt;code&gt;int2&lt;/code&gt; 에서 &lt;code&gt;int4&lt;/code&gt; 로의 캐스트 는 상당히 암시적일 수 있지만 &lt;code&gt;float8&lt;/code&gt; 에서 &lt;code&gt;int4&lt;/code&gt; 로의 캐스트는 할당 전용이어야합니다. 같은 십자가 형 범주 캐스트, &lt;code&gt;text&lt;/code&gt; 에 &lt;code&gt;int4&lt;/code&gt; 가장 명시 적으로 만 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="7c5b3068c21100601581e786ee86ca3a3f0b7637" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. When the server encoding is UTF-8, then the Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;, should be used instead. (The alternative would be doing the UTF-8 encoding by hand and writing out the bytes, which would be very cumbersome.)</source>
          <target state="translated">특히 8 진 또는 16 진 이스케이프를 사용할 때 작성하는 바이트 시퀀스는 서버 문자 세트 인코딩에서 유효한 문자를 작성해야합니다. 서버 인코딩이 UTF-8 인 경우, &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;4.1.2.3 절에&lt;/a&gt; 설명 된 유니 코드 이스케이프 또는 대체 유니 코드 이스케이프 구문을 대신 사용해야합니다. (대체 UTF-8 인코딩을 직접 수행하고 바이트를 작성하는 것이 번거로울 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="7e498293987ea55fea8d5b2403c8c230700d8887" translate="yes" xml:space="preserve">
          <source>It makes your SQL statements verbose, and you always have to remember to use &lt;code&gt;lower&lt;/code&gt; on both the column and the query value.</source>
          <target state="translated">그것은 자세한 SQL 문을 만들고, 당신은 항상 사용하는 것을 기억해야 &lt;code&gt;lower&lt;/code&gt; 열 및 쿼리 값 모두.</target>
        </trans-unit>
        <trans-unit id="ef32cc79ad6cb19406da947c5847a9365640d3e1" translate="yes" xml:space="preserve">
          <source>It may also be necessary to give the database server's operating system user permission to use huge pages by setting &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; via sysctl, and/or give permission to lock memory with &lt;code&gt;ulimit -l&lt;/code&gt;.</source>
          <target state="translated">sysctl을 통해 &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; 을 설정하여 데이터베이스 페이지의 운영 체제 사용자에게 방대한 페이지를 사용할 수있는 권한을 부여하거나 &lt;code&gt;ulimit -l&lt;/code&gt; 을 사용하여 메모리를 잠글 수있는 권한을 부여해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c230567f694e16c717ab914422a39d27766ee1c7" translate="yes" xml:space="preserve">
          <source>It may be advisable to avoid using type and table names that begin with underscore. While the server will change generated array type names to avoid collisions with user-given names, there is still risk of confusion, particularly with old client software that may assume that type names beginning with underscores always represent arrays.</source>
          <target state="translated">밑줄로 시작하는 유형 및 테이블 이름을 사용하지 않는 것이 좋습니다. 서버는 사용자가 지정한 이름과의 충돌을 피하기 위해 생성 된 배열 유형 이름을 변경하지만, 특히 밑줄로 시작하는 유형 이름이 항상 배열을 나타내는 것으로 가정 할 수있는 이전 클라이언트 소프트웨어와 혼동 될 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="914462b7eb826c460762b58dc586f5544963cc18" translate="yes" xml:space="preserve">
          <source>It may be useful to adjust this size to control the granularity of WAL log shipping or archiving. Also, in databases with a high volume of WAL, the sheer number of WAL files per directory can become a performance and management problem. Increasing the WAL file size will reduce the number of WAL files.</source>
          <target state="translated">WAL 로그 전달 또는 보관의 세분성을 제어하기 위해이 크기를 조정하는 것이 유용 할 수 있습니다. 또한 WAL이 많은 데이터베이스의 경우 디렉토리 당 많은 WAL 파일 수가 성능 및 관리 문제가 될 수 있습니다. WAL 파일 크기를 늘리면 WAL 파일 수가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="7c0fb5b044b855badd9b796e550a5309d125f9a8" translate="yes" xml:space="preserve">
          <source>It might, however, be necessary to modify the global &lt;code&gt;ulimit&lt;/code&gt; information in &lt;code&gt;/etc/security/limits&lt;/code&gt;, as the default hard limits for file sizes (&lt;code&gt;fsize&lt;/code&gt;) and numbers of files (&lt;code&gt;nofiles&lt;/code&gt;) might be too low.</source>
          <target state="translated">그러나 파일 크기 ( &lt;code&gt;fsize&lt;/code&gt; ) 및 파일 수 ( &lt;code&gt;nofiles&lt;/code&gt; ) 의 기본 하드 한계 가 너무 낮을 수 있으므로 &lt;code&gt;/etc/security/limits&lt;/code&gt; 에서 전역 &lt;code&gt;ulimit&lt;/code&gt; 정보 를 수정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fff2052adc7cc9fd5e18f86ad66dfe1b9dfc242d" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="translated">또한 기본 WAL 형식은 많은 디스크 페이지 스냅 샷을 포함하므로 상당히 부피가 크다는 점에 유의해야합니다. 이러한 페이지 스냅 샷은 부분적으로 작성된 디스크 페이지를 수정해야 할 수 있으므로 응급 복구를 지원하도록 설계되었습니다. 시스템 하드웨어 및 소프트웨어에 따라 부분 쓰기의 위험은 무시할 정도로 작을 수 있습니다.이 경우 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 매개 변수를 사용하여 페이지 스냅 샷을 해제하여 아카이브 된 로그의 총 볼륨을 크게 줄일 수 있습니다 . (읽기의 참고 사항과 경고 &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;제 29 장&lt;/a&gt; 이렇게 전에.) PITR 작업에 대한 로그의 사용을 금지하지 않는 페이지 스냅 샷 끄기. 향후 개발 영역은 &lt;code&gt;full_page_writes&lt;/code&gt; 일 때에도 불필요한 페이지 사본을 제거하여 아카이브 된 WAL 데이터를 압축하는 것입니다.켜져 있습니다. 그 동안 관리자는 가능한 한 검사 점 간격 매개 변수를 늘려 WAL에 포함 된 페이지 스냅 숏 수를 줄이려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af922062ac86a130253f6b4fd50587d3a97630cd" translate="yes" xml:space="preserve">
          <source>It should be fairly clear why a btree index requires these laws to hold within a single data type: without them there is no ordering to arrange the keys with. Also, index searches using a comparison key of a different data type require comparisons to behave sanely across two data types. The extensions to three or more data types within a family are not strictly required by the btree index mechanism itself, but the planner relies on them for optimization purposes.</source>
          <target state="translated">btree 인덱스에 이러한 법칙이 단일 데이터 유형 내에 포함되어야하는 이유는 분명해야합니다. 규칙이 없으면 키를 정렬 할 순서가 없습니다. 또한 다른 데이터 유형의 비교 키를 사용하는 인덱스 검색에서는 두 데이터 유형에서 비교가 제대로 작동하지 않아야합니다. btree 인덱스 메커니즘 자체에서 패밀리 내 3 개 이상의 데이터 유형으로의 확장이 반드시 필요한 것은 아니지만 플래너는 최적화 목적으로 이들을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e49813f2476bbea73d4ff66119d7d7387c964091" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;code&gt;pg_cast&lt;/code&gt; does not represent every type conversion that the system knows how to perform; only those that cannot be deduced from some generic rule. For example, casting between a domain and its base type is not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;. Another important exception is that &amp;ldquo;automatic I/O conversion casts&amp;rdquo;, those performed using a data type's own I/O functions to convert to or from &lt;code&gt;text&lt;/code&gt; or other string types, are not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;.</source>
          <target state="translated">주목해야한다 &lt;code&gt;pg_cast&lt;/code&gt; 는 시스템이 수행하는 방법을 알고있는 모든 종류의 변환을 표현하지 않는다 일반적인 규칙에서 추론 할 수없는 것들만 예를 들어, 도메인과 기본 유형 간 캐스트는 &lt;code&gt;pg_cast&lt;/code&gt; 에 명시 적으로 표시되지 않습니다 . 또 다른 중요한 예외는 데이터 유형 자체의 I / O 함수를 사용하여 &lt;code&gt;text&lt;/code&gt; 또는 다른 문자열 유형 으로 변환하거나 텍스트 에서 다른 문자열 유형 으로 변환하는 &quot;자동 I / O 변환 캐스트&quot; 는 &lt;code&gt;pg_cast&lt;/code&gt; 에 명시 적으로 표시되지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3f75a2b78a5f5649b3ab9e555457464dd4adddae" translate="yes" xml:space="preserve">
          <source>It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used.</source>
          <target state="translated">점검 표현식이 true 또는 널값으로 평가되면 점검 제한 조건이 충족됨에 유의하십시오. 피연산자가 널이면 대부분의 표현식이 널값으로 평가되므로 제한 컬럼의 널값을 막지 않습니다. 열에 널값이 포함되지 않도록 다음 섹션에서 설명하는 널이 아닌 제한 조건을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02935ea4ceb5538c0d2002f169c21bb8e60788b3" translate="yes" xml:space="preserve">
          <source>It should be noted that database superusers can access all objects regardless of object privilege settings. This is comparable to the rights of &lt;code&gt;root&lt;/code&gt; in a Unix system. As with &lt;code&gt;root&lt;/code&gt;, it's unwise to operate as a superuser except when absolutely necessary.</source>
          <target state="translated">데이터베이스 수퍼 유저는 개체 권한 설정에 관계없이 모든 개체에 액세스 할 수 있습니다. 이것은 유닉스 시스템에서 &lt;code&gt;root&lt;/code&gt; 의 권한과 비슷 합니다. &lt;code&gt;root&lt;/code&gt; 와 마찬가지로 절대적으로 필요한 경우를 제외하고 수퍼 유저로 작동하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c98ab8e1a3d8f36aae75d2304e7a94b266eaa6f" translate="yes" xml:space="preserve">
          <source>It should be noted that except for &lt;code&gt;count&lt;/code&gt;, these functions return a null value when no rows are selected. In particular, &lt;code&gt;sum&lt;/code&gt; of no rows returns null, not zero as one might expect, and &lt;code&gt;array_agg&lt;/code&gt; returns null rather than an empty array when there are no input rows. The &lt;code&gt;coalesce&lt;/code&gt; function can be used to substitute zero or an empty array for null when necessary.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 를 제외하고 이러한 함수는 행을 선택하지 않으면 null 값을 반환합니다. 특히, 행이없는 &lt;code&gt;sum&lt;/code&gt; 는 예상대로 0이 아닌 null을 반환 하고 입력 행이 없으면 &lt;code&gt;array_agg&lt;/code&gt; 는 빈 배열이 아닌 null을 반환합니다. &lt;code&gt;coalesce&lt;/code&gt; 기능은 대체 제로는 null 빈 배열해야하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="fcddd727e8976d04c908eb345e29817691fb2925" translate="yes" xml:space="preserve">
          <source>It should be noted that log shipping is asynchronous, i.e., the WAL records are shipped after transaction commit. As a result, there is a window for data loss should the primary server suffer a catastrophic failure; transactions not yet shipped will be lost. The size of the data loss window in file-based log shipping can be limited by use of the &lt;code&gt;archive_timeout&lt;/code&gt; parameter, which can be set as low as a few seconds. However such a low setting will substantially increase the bandwidth required for file shipping. Streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) allows a much smaller window of data loss.</source>
          <target state="translated">로그 전달은 비동기 적입니다. 즉, 트랜잭션 커밋 후에 WAL 레코드가 전달됩니다. 결과적으로 주 서버에 치명적인 오류가 발생하면 데이터가 손실 될 수 있습니다. 아직 배송되지 않은 거래는 손실됩니다. 파일 기반 로그 전달에서 데이터 손실 창의 크기는 &lt;code&gt;archive_timeout&lt;/code&gt; 매개 변수 를 사용하여 제한 할 수 있습니다.이 매개 변수는 몇 초 정도로 낮게 설정할 수 있습니다. 그러나 이러한 낮은 설정은 파일 전송에 필요한 대역폭을 크게 증가시킵니다. 스트리밍 복제 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;섹션 26.2.5&lt;/a&gt; 참조 )는 훨씬 더 작은 데이터 손실 창을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3defdb9a09006209e803808debdc569c264d27e7" translate="yes" xml:space="preserve">
          <source>It won't use an index, unless you create a functional index using &lt;code&gt;lower&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; 를 사용하여 기능 색인을 작성하지 않으면 색인을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b722c9c9f3f75689f42f0b53f218a01c48008e8" translate="yes" xml:space="preserve">
          <source>It would be better to instead create child tables as follows:</source>
          <target state="translated">대신 다음과 같이 자식 테이블을 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3751c875e52c61621661f1961d94164268c168e" translate="yes" xml:space="preserve">
          <source>It's a matter of taste.</source>
          <target state="translated">맛의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="6308fac37b6f916e6aaeedec4f54478b5685b89a" translate="yes" xml:space="preserve">
          <source>It's advisable to create &lt;code&gt;ndistinct&lt;/code&gt; statistics objects only on combinations of columns that are actually used for grouping, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; cycles are just wasted.</source>
          <target state="translated">실제로 그룹화에 사용되며 그룹 수를 잘못 추정하여 잘못된 계획을 초래하는 열 조합에서만 &lt;code&gt;ndistinct&lt;/code&gt; 통계 개체 를 작성하는 것이 좋습니다 . 그렇지 않으면 &lt;code&gt;ANALYZE&lt;/code&gt; 사이클이 낭비됩니다.</target>
        </trans-unit>
        <trans-unit id="695d14c6506a71cfb6f8af1b5d18b963ae0d4f6f" translate="yes" xml:space="preserve">
          <source>It's advisable to create MCV statistics objects only on combinations of columns that are actually used in conditions together, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; and planning cycles are just wasted.</source>
          <target state="translated">실제로 조건에 함께 사용되며 그룹 수를 잘못 추정하면 계획이 잘못되는 열 조합에 대해서만 MCV 통계 개체를 만드는 것이 좋습니다. 그렇지 않으면 &lt;code&gt;ANALYZE&lt;/code&gt; 및 계획주기가 낭비됩니다.</target>
        </trans-unit>
        <trans-unit id="26d8635c1af4731c90f7caf11c20fceefa695a0b" translate="yes" xml:space="preserve">
          <source>It's also permissible to attach &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; to integer columns to reference character set encodings, which are not currently represented as catalog OIDs, but have a set of values known to &lt;code&gt;genbki.pl&lt;/code&gt;.</source>
          <target state="translated">현재 카탈로그 OID로 표시되지 않지만 &lt;code&gt;genbki.pl&lt;/code&gt; 으로 알려진 값 세트를 갖는 문자 세트 인코딩을 참조하기 위해 &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; 을 정수 열에 첨부 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="42cd973aeb3dbef0c62ad2e81081d6f4bf4973db" translate="yes" xml:space="preserve">
          <source>It's also possible to select no escape character by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;. This effectively disables the escape mechanism, which makes it impossible to turn off the special meaning of underscore and percent signs in the pattern.</source>
          <target state="translated">&lt;code&gt;ESCAPE ''&lt;/code&gt; 을 작성하여 이스케이프 문자를 선택하지 않을 수도 있습니다 . 이스케이프 메커니즘을 효과적으로 비활성화하여 패턴에서 밑줄 및 퍼센트 기호의 특수 의미를 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8646be546a98ef8ea063cb9eec163a8d4548ff24" translate="yes" xml:space="preserve">
          <source>It's essential that the data types and other properties of the columns declared in &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; match the actual remote table. Column names must match as well, unless you attach &lt;code&gt;column_name&lt;/code&gt; options to the individual columns to show how they are named in the remote table. In many cases, use of &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt; is preferable to constructing foreign table definitions manually.</source>
          <target state="translated">&lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; 에 선언 된 열의 데이터 유형 및 기타 속성은 실제 원격 테이블과 일치해야합니다. &lt;code&gt;column_name&lt;/code&gt; 옵션을 개별 열에 첨부 하여 원격 테이블에서 이름이 지정된 방법을 표시 하지 않는 한 열 이름도 일치해야 합니다. 많은 경우, 외부 테이블 정의를 수동으로 구성 하는 데 &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA를 사용하는&lt;/a&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a75f17e623d692c2b958fa72bc491d5871febb40" translate="yes" xml:space="preserve">
          <source>It's important to understand that the cost of an upper-level node includes the cost of all its child nodes. It's also important to realize that the cost only reflects things that the planner cares about. In particular, the cost does not consider the time spent transmitting result rows to the client, which could be an important factor in the real elapsed time; but the planner ignores it because it cannot change it by altering the plan. (Every correct plan will output the same row set, we trust.)</source>
          <target state="translated">상위 수준 노드 비용에는 모든 하위 노드 비용이 포함된다는 점을 이해해야합니다. 비용은 계획자가 관심을 갖는 것만 반영한다는 것을 인식하는 것이 중요합니다. 특히, 비용은 결과 행을 클라이언트에 전송하는 데 소요 된 시간을 고려하지 않으며, 이는 실제 경과 시간에서 중요한 요소가 될 수 있습니다. 그러나 계획자는 계획을 변경하여 변경할 수 없으므로 계획을 무시합니다. (올바른 계획은 동일한 행 집합을 출력 할 것입니다.)</target>
        </trans-unit>
        <trans-unit id="7c3ed76ba22932f8e0061fba8fda8ba6c6509eab" translate="yes" xml:space="preserve">
          <source>It's possible to control the statements in a transaction in a more granular fashion through the use of &lt;em&gt;savepoints&lt;/em&gt;. Savepoints allow you to selectively discard parts of the transaction, while committing the rest. After defining a savepoint with &lt;code&gt;SAVEPOINT&lt;/code&gt;, you can if needed roll back to the savepoint with &lt;code&gt;ROLLBACK TO&lt;/code&gt;. All the transaction's database changes between defining the savepoint and rolling back to it are discarded, but changes earlier than the savepoint are kept.</source>
          <target state="translated">&lt;em&gt;savepoints를&lt;/em&gt; 사용하여 트랜잭션의 명령문을보다 세분화 된 방식으로 제어 할 수 있습니다 . 저장 점을 사용하면 나머지 부분을 커미트하면서 트랜잭션의 일부를 선택적으로 버릴 수 있습니다. &lt;code&gt;SAVEPOINT&lt;/code&gt; 를 사용 하여 저장 점을 정의한 후 필요한 경우 &lt;code&gt;ROLLBACK TO&lt;/code&gt; 를 사용하여 저장 점으로 롤백 할 수 있습니다 . 저장 점 정의와 롤백 사이의 모든 트랜잭션 데이터베이스 변경 사항은 버려지지만 저장 점 이전의 변경 사항은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="af6b5757cbe3f9b4c6401b87c759f120734c17d1" translate="yes" xml:space="preserve">
          <source>It's recommended to run &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; before submitting catalog data patches. For convenience, you can simply change to &lt;code&gt;src/include/catalog/&lt;/code&gt; and run &lt;code&gt;make reformat-dat-files&lt;/code&gt;.</source>
          <target state="translated">카탈로그 데이터 패치를 제출하기 전에 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 을 실행하는 것이 좋습니다 . 편의상 간단히 &lt;code&gt;src/include/catalog/&lt;/code&gt; 하고 &lt;code&gt;make reformat-dat-files&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f13f984e4f7daa459e845c3a4715f4638313970" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches.</source>
          <target state="translated">키가 아닌 열을 인덱스, 특히 넓은 열에 추가하는 것은 보수적 인 것이 좋습니다. 인덱스 튜플이 인덱스 유형에 허용 된 최대 크기를 초과하면 데이터 삽입이 실패합니다. 어쨌든 키가 아닌 열은 인덱스 테이블의 데이터를 복제하고 인덱스 크기를 부풀려서 검색 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08237634e67b792c41b6dc72d01cf498506db594" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key payload columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. And remember that there is little point in including payload columns in an index unless the table changes slowly enough that an index-only scan is likely to not need to access the heap. If the heap tuple must be visited anyway, it costs nothing more to get the column's value from there. Other restrictions are that expressions are not currently supported as included columns, and that only B-tree and GiST indexes currently support included columns.</source>
          <target state="translated">키가 아닌 페이로드 열을 인덱스, 특히 넓은 열에 추가하는 것은 보수적 인 것이 좋습니다. 인덱스 튜플이 인덱스 유형에 허용 된 최대 크기를 초과하면 데이터 삽입이 실패합니다. 어쨌든 키가 아닌 열은 인덱스 테이블의 데이터를 복제하고 인덱스 크기를 부풀려서 검색 속도가 느려질 수 있습니다. 또한 인덱스 전용 스캔이 힙에 액세스 할 필요가 없을 정도로 테이블이 느리게 변경되지 않는 한 인덱스에 페이로드 열을 포함시킬 점이 거의 없음을 기억하십시오. 어쨌든 힙 튜플을 방문 해야하는 경우 거기에서 열 값을 얻는 데 더 이상 비용이 들지 않습니다. 다른 제한 사항은 표현식이 현재 포함 된 열로 지원되지 않으며 B- 트리 및 GiST 인덱스 만 현재 포함 된 열을 지원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9682da0882fceeebec9d99753c1dc0306b85beab" translate="yes" xml:space="preserve">
          <source>It's worth noticing that the AND/OR/NOT operators mean something subtly different when they are within the arguments of a FOLLOWED BY operator than when they are not, because within FOLLOWED BY the exact position of the match is significant. For example, normally &lt;code&gt;!x&lt;/code&gt; matches only documents that do not contain &lt;code&gt;x&lt;/code&gt; anywhere. But &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; matches &lt;code&gt;y&lt;/code&gt; if it is not immediately after an &lt;code&gt;x&lt;/code&gt;; an occurrence of &lt;code&gt;x&lt;/code&gt; elsewhere in the document does not prevent a match. Another example is that &lt;code&gt;x &amp;amp; y&lt;/code&gt; normally only requires that &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; both appear somewhere in the document, but &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; requires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to match at the same place, immediately before a &lt;code&gt;z&lt;/code&gt;. Thus this query behaves differently from &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt;, which will match a document containing two separate sequences &lt;code&gt;x z&lt;/code&gt; and &lt;code&gt;y z&lt;/code&gt;. (This specific query is useless as written, since &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; could not match at the same place; but with more complex situations such as prefix-match patterns, a query of this form could be useful.)</source>
          <target state="translated">AND / OR / NOT 연산자는 FOLLOWED BY 내의 정확한 위치가 중요하기 때문에 FOLLOWED BY 연산자의 인수 내에있을 때와 그렇지 않은 경우에 미묘하게 다른 것을 의미한다는 점에 주목할 가치가 있습니다. 예를 들어, 일반적으로 &lt;code&gt;!x&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 포함하지 않은 문서에만 일치합니다 . 그러나 &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; 일치 &lt;code&gt;y&lt;/code&gt; 로 그것이 직후가 아닌 경우 &lt;code&gt;x&lt;/code&gt; ; 문서의 다른 곳에서 &lt;code&gt;x&lt;/code&gt; 가 발생 해도 일치하지 않습니다. 또 다른 예는 &lt;code&gt;x &amp;amp; y&lt;/code&gt; 는 일반적으로 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 문서의 어딘가에 나타나 도록 요구 하지만 &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 바로 직전 같은 위치에서 x 와 &lt;code&gt;y&lt;/code&gt; 를 찾습니다 . 따라서이 쿼리는 &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt; 와 다르게 동작합니다 . 이는 두 개의 개별 시퀀스 &lt;code&gt;x z&lt;/code&gt; 및 &lt;code&gt;y z&lt;/code&gt; 포함하는 문서와 일치합니다 . (이 특정 쿼리는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 같은 위치에서 일치 할 수 없기 때문에 쓸모가 없지만 접두사 일치 패턴과 같은보다 복잡한 상황에서는이 형식의 쿼리가 유용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ecdda59aea5ee67d7d854c969ccf7f4f4b4a4c54" translate="yes" xml:space="preserve">
          <source>Item</source>
          <target state="translated">Item</target>
        </trans-unit>
        <trans-unit id="036b57986556b399e1579aa78767ca4cf343c8b5" translate="yes" xml:space="preserve">
          <source>ItemIdData</source>
          <target state="translated">ItemIdData</target>
        </trans-unit>
        <trans-unit id="a2965a078eaef7ee13c972baa85b167370cde26a" translate="yes" xml:space="preserve">
          <source>ItemPointerData</source>
          <target state="translated">ItemPointerData</target>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="40f7cf3bbd8b78d82db16eda601698d7597b9ba5" translate="yes" xml:space="preserve">
          <source>J.5. Style Guide</source>
          <target state="translated">J.5. 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="7685fa01b8b7b34ce179631444878fcbce78fa81" translate="yes" xml:space="preserve">
          <source>J2451187</source>
          <target state="translated">J2451187</target>
        </trans-unit>
        <trans-unit id="1f1062dcbb83b59e4f6f5cb50ef505afac199e0d" translate="yes" xml:space="preserve">
          <source>JDBC</source>
          <target state="translated">JDBC</target>
        </trans-unit>
        <trans-unit id="eb5d2f4a58038c71155ddcf3cea35dc3c6d34501" translate="yes" xml:space="preserve">
          <source>JIT</source>
          <target state="translated">JIT</target>
        </trans-unit>
        <trans-unit id="6a623f63efe8bb915b0cd81dd3786e0511e1c1a1" translate="yes" xml:space="preserve">
          <source>JIT compilation is beneficial primarily for long-running CPU-bound queries. Frequently these will be analytical queries. For short queries the added overhead of performing JIT compilation will often be higher than the time it can save.</source>
          <target state="translated">JIT 컴파일은 주로 장기 실행 CPU 바인딩 쿼리에 유용합니다. 종종 이들은 분석적인 쿼리가 될 것입니다. 짧은 쿼리의 경우 JIT 컴파일 수행의 추가 오버 헤드가 종종 절약 할 수있는 시간보다 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="6f7646a5ebe2aff38f294e6e525f0ea1b56f8538" translate="yes" xml:space="preserve">
          <source>JOHAB</source>
          <target state="translated">JOHAB</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c731d9e245778a9537fc026bc57fb4f455f28593" translate="yes" xml:space="preserve">
          <source>JSON Functions and Operators</source>
          <target state="translated">JSON 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="95cc452498b3190abb79d4cdad349208be23c944" translate="yes" xml:space="preserve">
          <source>JSON Types</source>
          <target state="translated">JSON 유형</target>
        </trans-unit>
        <trans-unit id="f9bea7492dcebb5f109566d49e4bca935a7e0ff7" translate="yes" xml:space="preserve">
          <source>JSON Types: boolean</source>
          <target state="translated">JSON 유형 : 부울</target>
        </trans-unit>
        <trans-unit id="22aff2decb9f95af65f4e2a85c938a9901c03229" translate="yes" xml:space="preserve">
          <source>JSON Types: null</source>
          <target state="translated">JSON 유형 : null</target>
        </trans-unit>
        <trans-unit id="b89570edbe3781b5bd3ad2ae7d37f0bf110fdf05" translate="yes" xml:space="preserve">
          <source>JSON Types: number</source>
          <target state="translated">JSON 유형 : 숫자</target>
        </trans-unit>
        <trans-unit id="205b72d84addc780073dacc96aedf0a7c5c2d3cc" translate="yes" xml:space="preserve">
          <source>JSON Types: string</source>
          <target state="translated">JSON 유형 : 문자열</target>
        </trans-unit>
        <trans-unit id="49c22c401963d3661a06e8b5108d657673586e05" translate="yes" xml:space="preserve">
          <source>JSON data is subject to the same concurrency-control considerations as any other data type when stored in a table. Although storing large documents is practicable, keep in mind that any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a manageable size in order to decrease lock contention among updating transactions. Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently.</source>
          <target state="translated">JSON 데이터는 테이블에 저장 될 때 다른 데이터 유형과 동일한 동시성 제어 고려 사항이 적용됩니다. 큰 문서를 저장하는 것이 가능하지만 모든 업데이트는 전체 행에서 행 수준 잠금을 얻습니다. 업데이트 트랜잭션 간의 잠금 경합을 줄이려면 JSON 문서를 관리 가능한 크기로 제한하는 것이 좋습니다. 이상적으로 JSON 문서는 각각 비즈니스 규칙이 지시하는 원자 데이텀을 나타내야하며 독립적으로 수정할 수있는 더 작은 데이텀으로 더 이상 세분화 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="062e2dcdb89d67da750325f5a32e496783b448b0" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">JSON 데이터 유형은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159에&lt;/a&gt; 지정된 JSON (JavaScript Object Notation) 데이터를 저장하기위한 것 입니다. 이러한 데이터는 &lt;code&gt;text&lt;/code&gt; 로 저장할 수도 있지만 JSON 데이터 유형은 JSON 규칙에 따라 저장된 각 값이 유효하도록하는 이점이 있습니다. 이러한 데이터 유형에 저장된 데이터에 사용할 수있는 여러 JSON 특정 함수 및 연산자도 있습니다. &lt;a href=&quot;functions-json&quot;&gt;섹션 9.15&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="1b285244e0c7fb77cf325258e945007dbcb0bd79" translate="yes" xml:space="preserve">
          <source>JSON objects are better suited than arrays for testing containment or existence when there are many keys or elements involved, because unlike arrays they are internally optimized for searching, and do not need to be searched linearly.</source>
          <target state="translated">JSON 객체는 배열과 달리 검색에 내부적으로 최적화되어 있으며 선형으로 검색 할 필요가 없기 때문에 많은 키 또는 요소가 포함 된 경우 포함 또는 존재를 테스트하기 위해 배열보다 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="ff7a8b7bee4833026249925bb4a7e075a31995d4" translate="yes" xml:space="preserve">
          <source>JSON primitive type</source>
          <target state="translated">JSON 기본 유형</target>
        </trans-unit>
        <trans-unit id="196dea5dbe3d820f7bdbd4775445b07993543c68" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding SQL/JSON item is returned. Path expressions are written in the SQL/JSON path language and can also include arithmetic expressions and functions. Query functions treat the provided expression as a text string, so it must be enclosed in single quotes.</source>
          <target state="translated">JSON 쿼리 함수 및 연산자는 제공된 경로 표현식을 평가 를 위해 &lt;em&gt;경로 엔진&lt;/em&gt; 에 전달합니다 . 식이 쿼리 된 JSON 데이터와 일치하면 해당 SQL / JSON 항목이 반환됩니다. 경로 표현식은 SQL / JSON 경로 언어로 작성되며 산술 표현식 및 함수도 포함 할 수 있습니다. 쿼리 함수는 제공된 표현식을 텍스트 문자열로 취급하므로 작은 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="7af619b9c5342e6a889b85ca2cae08237b23f616" translate="yes" xml:space="preserve">
          <source>JSON: SQL/JSON Path Language</source>
          <target state="translated">JSON : SQL / JSON 경로 언어</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="ebeb4b5ab2f3409935c06be07e3191bf0a5dc6cf" translate="yes" xml:space="preserve">
          <source>Jan-08-1999</source>
          <target state="translated">Jan-08-1999</target>
        </trans-unit>
        <trans-unit id="521a936bf91733c55274b55367cc8ed71292693f" translate="yes" xml:space="preserve">
          <source>Jan-08-99</source>
          <target state="translated">Jan-08-99</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="d6e52d181e7ba4487fe8643d957277cd1cbf82c7" translate="yes" xml:space="preserve">
          <source>January 18 in &lt;code&gt;MDY&lt;/code&gt; mode; rejected in other modes</source>
          <target state="translated">&lt;code&gt;MDY&lt;/code&gt; 모드 에서 1 월 18 일 ; 다른 모드에서 거부</target>
        </trans-unit>
        <trans-unit id="d1fb4cc8c23271615e96e586a4e1801c1ac84f25" translate="yes" xml:space="preserve">
          <source>January 2, 2003 in &lt;code&gt;MDY&lt;/code&gt; mode; February 1, 2003 in &lt;code&gt;DMY&lt;/code&gt; mode; February 3, 2001 in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;MDY&lt;/code&gt; 모드 에서 2003 년 1 월 2 일 ; &lt;code&gt;DMY&lt;/code&gt; 모드 에서 2003 년 2 월 1 일 ; &lt;code&gt;YMD&lt;/code&gt; 모드 에서 2001 년 2 월 3 일</target>
        </trans-unit>
        <trans-unit id="397474e233d9068687b354fbdbc0b01176bcc2cc" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;MDY&lt;/code&gt; mode; August 1 in &lt;code&gt;DMY&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;MDY&lt;/code&gt; 모드 에서 1 월 8 일 ; &lt;code&gt;DMY&lt;/code&gt; 모드 에서 8 월 1 일</target>
        </trans-unit>
        <trans-unit id="2391ee88b9183f9c31234260c9722e2d62c959b0" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;YMD&lt;/code&gt; mode, else error</source>
          <target state="translated">&lt;code&gt;YMD&lt;/code&gt; 모드 에서 1 월 8 일 , 그렇지 않으면 오류</target>
        </trans-unit>
        <trans-unit id="347ee622c39fd3015013d75c9106e7b8164231b7" translate="yes" xml:space="preserve">
          <source>January 8 in any mode</source>
          <target state="translated">모든 모드에서 1 월 8 일</target>
        </trans-unit>
        <trans-unit id="682c812bf69e66e4c213bdbcc9a0930f43e82030" translate="yes" xml:space="preserve">
          <source>January 8, 1999</source>
          <target state="translated">1999 년 1 월 8 일</target>
        </trans-unit>
        <trans-unit id="4444d015dc1b7e202a7ab992a769c820f60f9019" translate="yes" xml:space="preserve">
          <source>January 8, 99 BC</source>
          <target state="translated">기원전 99 년 1 월 8 일</target>
        </trans-unit>
        <trans-unit id="07425bcd86481aaf19f3e5b4016da2c9f5e1cec4" translate="yes" xml:space="preserve">
          <source>January 8, except error in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">1 월 8 일 ( &lt;code&gt;YMD&lt;/code&gt; 모드 오류 제외)</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="21087b70eba36ef97c23b6fae1bc0502a8c7faff" translate="yes" xml:space="preserve">
          <source>Java Database Connectivity</source>
          <target state="translated">자바 데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="94e850a9fa9f98700106bfba6b5849640ea65567" translate="yes" xml:space="preserve">
          <source>JavaScript Object Notation</source>
          <target state="translated">자바 스크립트 객체 표기법</target>
        </trans-unit>
        <trans-unit id="66dc64282e7e424443c0ee036f6560a8429101fe" translate="yes" xml:space="preserve">
          <source>Jean-Luc Cooke Fortuna-based &lt;code&gt;/dev/random&lt;/code&gt; driver for Linux.</source>
          <target state="translated">Jean-Luc Cooke Linux 용 Fortuna 기반 &lt;code&gt;/dev/random&lt;/code&gt; 드라이버.</target>
        </trans-unit>
        <trans-unit id="076e3b3dd165a68d5a1635c764f91d575d41e991" translate="yes" xml:space="preserve">
          <source>Joe Conway</source>
          <target state="translated">조 콘웨이</target>
        </trans-unit>
        <trans-unit id="36223c3c072f8f4857df7670837893beb8c9ab05" translate="yes" xml:space="preserve">
          <source>John Gray &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">존 그레이 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5253095e71e396147a5bb85865b313a4dfaabec4" translate="yes" xml:space="preserve">
          <source>Join queries of the kind seen thus far can also be written in this alternative form:</source>
          <target state="translated">지금까지 본 종류의 조인 쿼리도 다음과 같은 대체 형식으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d51427844afa7a67c043cae62a1e058c08bf8eb" translate="yes" xml:space="preserve">
          <source>Join selectivity estimation function for this operator</source>
          <target state="translated">이 연산자에 대한 결합 선택성 추정 기능</target>
        </trans-unit>
        <trans-unit id="60bbcdff104b8ef5971151f077f9a3a69bf41608" translate="yes" xml:space="preserve">
          <source>Joins of all types can be chained together, or nested: either or both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; can be joined tables. Parentheses can be used around &lt;code&gt;JOIN&lt;/code&gt; clauses to control the join order. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt; clauses nest left-to-right.</source>
          <target state="translated">모든 유형의 조인은 함께 체인 또는 중첩 될 수 있습니다. &lt;code&gt;T1&lt;/code&gt; 과 &lt;code&gt;T2&lt;/code&gt; 중 하나 또는 둘 다가 조인 테이블 일 수 있습니다. &lt;code&gt;JOIN&lt;/code&gt; 절을 괄호로 묶어 조인 순서를 제어 할 수 있습니다 . 괄호가 없으면 &lt;code&gt;JOIN&lt;/code&gt; 절은 왼쪽에서 오른쪽으로 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="b737558468d75ca55b2d9185c0b55eacaea627a0" translate="yes" xml:space="preserve">
          <source>Jul</source>
          <target state="translated">Jul</target>
        </trans-unit>
        <trans-unit id="a78c0406ce3eb63581cbacb7e7085ef4cbc36ad9" translate="yes" xml:space="preserve">
          <source>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</source>
          <target state="translated">율리우스 데이 (BC UTC 4714 년 11 월 24 일 이후의 정수일 UTC 자정)</target>
        </trans-unit>
        <trans-unit id="b597ea9fa797a2c2073652808359aeb10b763510" translate="yes" xml:space="preserve">
          <source>Julian date</source>
          <target state="translated">줄리안 데이트</target>
        </trans-unit>
        <trans-unit id="df97a42549e5c0e1753b985126565531cc9f3c56" translate="yes" xml:space="preserve">
          <source>July</source>
          <target state="translated">July</target>
        </trans-unit>
        <trans-unit id="6d90df3be4d0d43b08e3fb47f55e09b5b06dae3e" translate="yes" xml:space="preserve">
          <source>Jun</source>
          <target state="translated">Jun</target>
        </trans-unit>
        <trans-unit id="a9db906761699b31567727716eaa6fd19ae5f5d5" translate="yes" xml:space="preserve">
          <source>June</source>
          <target state="translated">June</target>
        </trans-unit>
        <trans-unit id="7b1ddc607d5041d94adba7779845219a639a5e00" translate="yes" xml:space="preserve">
          <source>Just as in a non-parallel plan, the driving table may be joined to one or more other tables using a nested loop, hash join, or merge join. The inner side of the join may be any kind of non-parallel plan that is otherwise supported by the planner provided that it is safe to run within a parallel worker. Depending on the join type, the inner side may also be a parallel plan.</source>
          <target state="translated">비 병렬 계획에서와 같이, 구동 테이블은 중첩 루프, 해시 조인 또는 병합 조인을 사용하여 하나 이상의 다른 테이블에 조인 될 수 있습니다. 조인의 내부는 병렬 작업자 내에서 실행하는 것이 안전하다면 플래너가 지원하는 모든 종류의 비평 행 계획 일 수 있습니다. 결합 유형에 따라 내부도 평행 평면 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce656c6d5efc6ceb90feb56120166673a499a99" translate="yes" xml:space="preserve">
          <source>Just as in a table, every output column of a &lt;code&gt;SELECT&lt;/code&gt; has a name. In a simple &lt;code&gt;SELECT&lt;/code&gt; this name is just used to label the column for display, but when the &lt;code&gt;SELECT&lt;/code&gt; is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write &lt;code&gt;AS&lt;/code&gt;&lt;code&gt;output_name&lt;/code&gt; after the column's expression. (You can omit &lt;code&gt;AS&lt;/code&gt;, but only if the desired output name does not match any PostgreSQL keyword (see &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;). For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as &lt;code&gt;?column?&lt;/code&gt;.</source>
          <target state="translated">테이블에서와 같이 &lt;code&gt;SELECT&lt;/code&gt; 의 모든 출력 열에 는 이름이 있습니다. 간단한 &lt;code&gt;SELECT&lt;/code&gt; 에서이 이름은 표시 할 열에 레이블을 지정하는 데 사용되지만 &lt;code&gt;SELECT&lt;/code&gt; 가 더 큰 쿼리의 하위 쿼리 인 경우 큰 쿼리 에서이 이름이 하위 테이블에서 생성 된 가상 테이블의 열 이름으로 표시됩니다. -질문. 출력 열에 사용할 이름을 지정하려면 열 표현식 뒤에 &lt;code&gt;AS&lt;/code&gt; &lt;code&gt;output_name&lt;/code&gt; 을 작성하십시오. 원하는 출력 이름이 PostgreSQL 키워드와 일치하지 않는 경우에만 &lt;code&gt;AS&lt;/code&gt; 를 생략 할 수 있습니다 ( &lt;a href=&quot;sql-keywords-appendix&quot;&gt;부록 C&lt;/a&gt; 참조 ). 향후 키워드 추가를 방지하기 위해 항상 &lt;code&gt;AS&lt;/code&gt; 를 작성하는 것이 좋습니다.또는 출력 이름을 큰 따옴표로 묶습니다.) 열 이름을 지정하지 않으면 PostgreSQL에서 이름을 자동으로 선택합니다. 열의 표현식이 단순 열 참조 인 경우 선택한 이름은 해당 열의 이름과 동일합니다. 보다 복잡한 경우에는 함수 또는 유형 이름이 사용되거나 시스템이 &lt;code&gt;?column?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643851cd97b3016db737a7445d565c8fa4d8baef" translate="yes" xml:space="preserve">
          <source>Just as with indexes, a foreign key constraint can be checked &amp;ldquo;in bulk&amp;rdquo; more efficiently than row-by-row. So it might be useful to drop foreign key constraints, load data, and re-create the constraints. Again, there is a trade-off between data load speed and loss of error checking while the constraint is missing.</source>
          <target state="translated">인덱스와 마찬가지로 외래 키 제약 조건을 행 단위보다&amp;ldquo;대량&amp;rdquo;으로보다 효율적으로 확인할 수 있습니다. 따라서 외래 키 제약 조건을 삭제하고 데이터를로드하며 제약 조건을 다시 만드는 것이 유용 할 수 있습니다. 다시 말하지만, 제약 조건이없는 동안 데이터로드 속도와 오류 검사 손실 사이에는 상충 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="22069315e577148c2b004f5dd6381d3b0deef8a4" translate="yes" xml:space="preserve">
          <source>Just-in-Time (JIT) compilation is the process of turning some form of interpreted program evaluation into a native program, and doing so at run time. For example, instead of using general-purpose code that can evaluate arbitrary SQL expressions to evaluate a particular SQL predicate like &lt;code&gt;WHERE a.col = 3&lt;/code&gt;, it is possible to generate a function that is specific to that expression and can be natively executed by the CPU, yielding a speedup.</source>
          <target state="translated">JIT (Just-In-Time) 컴파일은 일부 형태의 해석 된 프로그램 평가를 기본 프로그램으로 변환하고 런타임에 수행하는 프로세스입니다. 예를 들어, 임의의 SQL 표현식을 평가하여 &lt;code&gt;WHERE a.col = 3&lt;/code&gt; 과 같은 특정 SQL 술어를 평가할 수있는 범용 코드를 사용하는 대신 해당 표현식에 고유 한 함수를 생성 할 수 있습니다. CPU 속도가 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="7af7e7edb636e51ba6b7f08c539611e4a0057634" translate="yes" xml:space="preserve">
          <source>Just-in-Time Compilation (JIT)</source>
          <target state="translated">JIT (Just-In-Time) 컴파일</target>
        </trans-unit>
        <trans-unit id="299af5e109b0aae56134447e7dc2dcce5de37f34" translate="yes" xml:space="preserve">
          <source>Just-in-Time compilation</source>
          <target state="translated">적시 컴파일</target>
        </trans-unit>
        <trans-unit id="ffa7300d92e16f73d505ed4698fdd4e962ca51c4" translate="yes" xml:space="preserve">
          <source>KAME kame/sys/crypto</source>
          <target state="translated">KAME kame / sys / crypto</target>
        </trans-unit>
        <trans-unit id="6b88dae842421fa69ad059376e38f360417c6965" translate="yes" xml:space="preserve">
          <source>KOI8-R</source>
          <target state="translated">KOI8-R</target>
        </trans-unit>
        <trans-unit id="ad190609bef1a0712934b8949ffb7c06fbaa6862" translate="yes" xml:space="preserve">
          <source>KOI8-U</source>
          <target state="translated">KOI8-U</target>
        </trans-unit>
        <trans-unit id="8f29952f92109ac24c1d37762ea2beef09083c31" translate="yes" xml:space="preserve">
          <source>KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cd084d348b2278c1d6044754c142d3183367365" translate="yes" xml:space="preserve">
          <source>Keep in mind that all aggregate functions are evaluated before evaluating any &amp;ldquo;scalar&amp;rdquo; expressions in the &lt;code&gt;HAVING&lt;/code&gt; clause or &lt;code&gt;SELECT&lt;/code&gt; list. This means that, for example, a &lt;code&gt;CASE&lt;/code&gt; expression cannot be used to skip evaluation of an aggregate function; see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HAVING&lt;/code&gt; 절 또는 &lt;code&gt;SELECT&lt;/code&gt; 목록 에서&amp;ldquo;스칼라&amp;rdquo;표현식을 평가하기 전에 모든 집계 함수가 평가 됩니다. 예를 들어, &lt;code&gt;CASE&lt;/code&gt; 표현식을 사용하여 집계 함수의 평가를 건너 뛸 수 없습니다. &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;4.2.14 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a262b9c7138e1926e93240d562f76b55145fd596" translate="yes" xml:space="preserve">
          <source>Keep in mind that because &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; actually runs the query, any side-effects will happen as usual, even though whatever results the query might output are discarded in favor of printing the &lt;code&gt;EXPLAIN&lt;/code&gt; data. If you want to analyze a data-modifying query without changing your tables, you can roll the command back afterwards, for example:</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 가 실제로 쿼리를 실행 하기 때문에 &lt;code&gt;EXPLAIN&lt;/code&gt; 데이터 를 인쇄하기 위해 쿼리가 출력 할 수있는 결과가 무시 되더라도 부작용은 평소와 같이 발생 합니다. 테이블을 변경하지 않고 데이터 수정 쿼리를 분석하려는 경우 다음과 같이 명령을 나중에 롤백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b96c146884aa3a6a00a301b320c6680d6f4464" translate="yes" xml:space="preserve">
          <source>Keep in mind that by default, a regular expression can match just part of a string. It's usually wise to use &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;, as shown in the above example, to force the match to be to the entire system user name.</source>
          <target state="translated">기본적으로 정규식은 문자열의 일부와 만 일치 할 수 있습니다. 위의 예와 같이 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 를 사용 하여 일치를 전체 시스템 사용자 이름으로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c42b9dd519f94f2582e4a71f3f708e12c5a9653d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is important to specify the configuration name explicitly when creating &lt;code&gt;tsvector&lt;/code&gt; values inside triggers, so that the column's contents will not be affected by changes to &lt;code&gt;default_text_search_config&lt;/code&gt;. Failure to do this is likely to lead to problems such as search results changing after a dump and reload.</source>
          <target state="translated">트리거 내에 &lt;code&gt;tsvector&lt;/code&gt; 값을 작성할 때 구성 이름을 명시 적으로 지정하는 것이 중요 하므로 컬럼의 내용이 &lt;code&gt;default_text_search_config&lt;/code&gt; 에 대한 변경의 영향을받지 않습니다 . 이를 수행하지 않으면 덤프 및 재로드 후 검색 결과가 변경되는 등의 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3ea22672b214f2b49222df5e8cffc5ea2a095eb" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal.</source>
          <target state="translated">부분 인덱스를 설정하면 최소한 쿼리 플래너가 알고있는만큼, 특히 인덱스의 수익성이 높은시기를 알고 있음을 나타냅니다. 이 지식을 형성하려면 PostgreSQL의 인덱스 작동 방식에 대한 경험과 이해가 필요합니다. 대부분의 경우 일반 인덱스에 비해 부분 인덱스의 이점이 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="ef88fc4a4ab28c6433ccdb43fa109f84e6bdf441" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;hstore&lt;/code&gt; text format, when used for input, applies &lt;em&gt;before&lt;/em&gt; any required quoting or escaping. If you are passing an &lt;code&gt;hstore&lt;/code&gt; literal via a parameter, then no additional processing is needed. But if you're passing it as a quoted literal constant, then any single-quote characters and (depending on the setting of the &lt;code&gt;standard_conforming_strings&lt;/code&gt; configuration parameter) backslash characters need to be escaped correctly. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more on the handling of string constants.</source>
          <target state="translated">것을 명심 &lt;code&gt;hstore&lt;/code&gt; 의 입력에 사용되는 텍스트 형식이 적용 &lt;em&gt;되기 전에&lt;/em&gt; 어떠한 인용이나 탈출이 필요합니다. 매개 변수를 통해 &lt;code&gt;hstore&lt;/code&gt; 리터럴을 전달하는 경우 추가 처리가 필요하지 않습니다. 그러나 인용 된 리터럴 상수로 전달하는 경우 작은 따옴표 문자와 ( &lt;code&gt;standard_conforming_strings&lt;/code&gt; 구성 매개 변수 의 설정에 따라 ) 백 슬래시 문자를 올바르게 이스케이프해야합니다. 문자열 상수 처리에 대한 자세한 내용 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;은 4.1.2.1 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f96958d65d9c021639ce27dbbdb3f614f469552" translate="yes" xml:space="preserve">
          <source>Keep in mind that the delay parameters are compared to the elapsed time since the WAL data was received by the standby server. Thus, the grace period allowed to any one query on the standby is never more than the delay parameter, and could be considerably less if the standby has already fallen behind as a result of waiting for previous queries to complete, or as a result of being unable to keep up with a heavy update load.</source>
          <target state="translated">지연 매개 변수는 대기 서버가 WAL 데이터를 수신 한 이후의 경과 시간과 비교됩니다. 따라서 대기에서 하나의 쿼리에 허용되는 유예 기간은 지연 매개 변수를 넘지 않으며 이전 쿼리가 완료되기를 기다리는 결과 또는 대기 상태로 인해 대기가 이미 뒤쳐 졌을 경우 상당히 줄어들 수 있습니다. 과도한 업데이트로드를 유지할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="281e2d1f4654cd490bed6ab58e757285785a6b63" translate="yes" xml:space="preserve">
          <source>Keep in mind that the pattern argument of &lt;code&gt;like_regex&lt;/code&gt; is a JSON path string literal, written according to the rules given in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;. This means in particular that any backslashes you want to use in the regular expression must be doubled. For example, to match strings that contain only digits:</source>
          <target state="translated">&lt;code&gt;like_regex&lt;/code&gt; 의 패턴 인수는 8.14.6 &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;절에&lt;/a&gt; 주어진 규칙에 따라 작성된 JSON 경로 문자열 리터럴 이라는 것을 명심하십시오 . 이는 특히 정규식에 사용하려는 백 슬래시를 두 배로 늘려야 함을 의미합니다. 예를 들어 숫자 만 포함 된 문자열을 일치 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="752b636fa6947f13347177c43e220a338c0e1d06" translate="yes" xml:space="preserve">
          <source>Keep in mind that the statement is actually executed when the &lt;code&gt;ANALYZE&lt;/code&gt; option is used. Although &lt;code&gt;EXPLAIN&lt;/code&gt; will discard any output that a &lt;code&gt;SELECT&lt;/code&gt; would return, other side effects of the statement will happen as usual. If you wish to use &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;EXECUTE&lt;/code&gt; statement without letting the command affect your data, use this approach:</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 옵션을 사용 하면 명령문이 실제로 실행 됩니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 은 &lt;code&gt;SELECT&lt;/code&gt; 가 리턴 할 출력을 버리지 만 명령문의 다른 부작용은 평소와 같이 발생합니다. 당신이 사용하고자하는 경우 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 온 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 또는 &lt;code&gt;EXECUTE&lt;/code&gt; 이 방법을 사용하여 명령을 아무 말도없이 데이터를 문에 영향을</target>
        </trans-unit>
        <trans-unit id="1a83b7d50233b6c01f2847bb1d523d1444438ed5" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, any user can issue arbitrary queries under the identity of any user not electing to protect itself individually. This pattern is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">기본값을 유지하십시오. 모든 사용자는 공개 스키마에 암시 적으로 액세스합니다. 이는 스키마를 전혀 사용할 수없는 상황을 시뮬레이션하여 스키마를 인식하지 않는 환경에서 자연스럽게 전환합니다. 그러나 모든 사용자는 자신을 개별적으로 보호하지 않기로 선택한 사용자의 신분으로 임의 쿼리를 실행할 수 있습니다. 이 패턴은 데이터베이스에 단일 사용자 또는 상호 신뢰하는 사용자가있는 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="01c357ee3905e2cb6c0488939e3efd4649d18496" translate="yes" xml:space="preserve">
          <source>Keep the partitioning constraints simple, else the planner may not be able to prove that child tables might not need to be visited. Use simple equality conditions for list partitioning, or simple range tests for range partitioning, as illustrated in the preceding examples. A good rule of thumb is that partitioning constraints should contain only comparisons of the partitioning column(s) to constants using B-tree-indexable operators, because only B-tree-indexable column(s) are allowed in the partition key.</source>
          <target state="translated">파티셔닝 제한 조건을 단순하게 유지하십시오. 그렇지 않으면 플래너가 하위 테이블을 방문 할 필요가 없음을 입증하지 못할 수 있습니다. 앞의 예에서 설명한 것처럼 목록 파티셔닝에 간단한 동등 조건을 사용하거나 범위 파티셔닝에 간단한 범위 테스트를 사용하십시오. 일반적으로 파티션 키에는 B- 트리 인덱싱 가능 열만 허용되므로 파티셔닝 제약 조건에는 B- 트리 인덱싱 가능 연산자를 사용하여 파티션 열과 상수를 비교하는 것만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2032a298b60ea58db844215a572d895ea523039" translate="yes" xml:space="preserve">
          <source>Kernels can also have system-wide limits on some resources.</source>
          <target state="translated">커널은 일부 자원에 대한 시스템 전체 제한을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59dfe7e6cfc40d95e215dd77804938b17f6c9f40" translate="yes" xml:space="preserve">
          <source>Key Word</source>
          <target state="translated">핵심어</target>
        </trans-unit>
        <trans-unit id="8e27223f630d5f11e0e66ca4d82327af33bd02f7" translate="yes" xml:space="preserve">
          <source>Key value of the row to start at</source>
          <target state="translated">시작할 행의 키 값</target>
        </trans-unit>
        <trans-unit id="fa701570481252ff476a0ecf4e2d51ece76ebca1" translate="yes" xml:space="preserve">
          <source>Key words and unquoted identifiers are case insensitive. Therefore:</source>
          <target state="translated">키워드 및 따옴표없는 식별자는 대소 문자를 구분하지 않습니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="dec66c5bf0f7fe4cc038ac871def8eb1ac31c146" translate="yes" xml:space="preserve">
          <source>Korean</source>
          <target state="translated">Korean</target>
        </trans-unit>
        <trans-unit id="2ceaa9727ea6aa546bde8ab43842a8c79efd8f8d" translate="yes" xml:space="preserve">
          <source>Korean (Hangul)</source>
          <target state="translated">한국어 (한글)</target>
        </trans-unit>
        <trans-unit id="2bfe4366aec039158c13cdff560c53552a6ab2f8" translate="yes" xml:space="preserve">
          <source>LATIN1 with Euro and accents</source>
          <target state="translated">유로와 악센트가있는 LATIN1</target>
        </trans-unit>
        <trans-unit id="a3f57123a6c2ff10f831d7d1652f96a64aa8ede6" translate="yes" xml:space="preserve">
          <source>LC_COLLATE for this database</source>
          <target state="translated">이 데이터베이스에 대한 LC_COLLATE</target>
        </trans-unit>
        <trans-unit id="ccd2341e80cefe881c6b471888b83c35d3eedb65" translate="yes" xml:space="preserve">
          <source>LC_CTYPE for this database</source>
          <target state="translated">이 데이터베이스의 LC_CTYPE</target>
        </trans-unit>
        <trans-unit id="d8343c683ae1584c96390fa627005bc1bb0719cd" translate="yes" xml:space="preserve">
          <source>LDAP</source>
          <target state="translated">LDAP</target>
        </trans-unit>
        <trans-unit id="d11fef55a0f4f7f77f5a743808a9e2af4cfab644" translate="yes" xml:space="preserve">
          <source>LDAP Authentication</source>
          <target state="translated">LDAP 인증</target>
        </trans-unit>
        <trans-unit id="3af0c4862ddb95641f4519deb20c9bd92b5a696b" translate="yes" xml:space="preserve">
          <source>LDAP URLs are currently only supported with OpenLDAP, not on Windows.</source>
          <target state="translated">LDAP URL은 현재 Windows가 아닌 OpenLDAP에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a78f006babbca44fb715e5663d9cdd5f718dd110" translate="yes" xml:space="preserve">
          <source>LDAP authentication can operate in two modes. In the first mode, which we will call the simple bind mode, the server will bind to the distinguished name constructed as &lt;code&gt;prefix&lt;/code&gt;&lt;code&gt;username&lt;/code&gt;&lt;code&gt;suffix&lt;/code&gt;. Typically, the &lt;code&gt;prefix&lt;/code&gt; parameter is used to specify &lt;code&gt;cn=&lt;/code&gt;, or &lt;code&gt;DOMAIN&lt;/code&gt;&lt;code&gt;\&lt;/code&gt; in an Active Directory environment. &lt;code&gt;suffix&lt;/code&gt; is used to specify the remaining part of the DN in a non-Active Directory environment.</source>
          <target state="translated">LDAP 인증은 두 가지 모드로 작동 할 수 있습니다. 단순 바인드 모드라고하는 첫 번째 모드에서 서버는 &lt;code&gt;prefix&lt;/code&gt; &lt;code&gt;username&lt;/code&gt; &lt;code&gt;suffix&lt;/code&gt; 로 구성된 고유 이름에 바인드합니다 . 일반적으로 &lt;code&gt;prefix&lt;/code&gt; 매개 변수는 Active Directory 환경에서 &lt;code&gt;cn=&lt;/code&gt; 또는 &lt;code&gt;DOMAIN&lt;/code&gt; &lt;code&gt;\&lt;/code&gt; 를 지정하는 데 사용됩니다 . &lt;code&gt;suffix&lt;/code&gt; 는 비 Active Directory 환경에서 DN의 나머지 부분을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd1b0f9c2859218ce1180337a2bd66b96113b2f" translate="yes" xml:space="preserve">
          <source>LIMIT and OFFSET</source>
          <target state="translated">제한 및 오프셋</target>
        </trans-unit>
        <trans-unit id="9c6023564f6507b3ea5cad8e472da23961b9afbb" translate="yes" xml:space="preserve">
          <source>LISTEN</source>
          <target state="translated">LISTEN</target>
        </trans-unit>
        <trans-unit id="9814f182fea16d601141a37a9089918cd74f5452" translate="yes" xml:space="preserve">
          <source>LISTEN &amp;mdash; listen for a notification</source>
          <target state="translated">LISTEN &amp;mdash; 알림 수신</target>
        </trans-unit>
        <trans-unit id="8d0c622ff5ca1933ba98627381a4a7d1db679d31" translate="yes" xml:space="preserve">
          <source>LLVM has support for optimizing generated code. Some of the optimizations are cheap enough to be performed whenever JIT is used, while others are only beneficial for longer-running queries. See &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes&lt;/a&gt; for more details about optimizations.</source>
          <target state="translated">LLVM은 생성 된 코드 최적화를 지원합니다. 일부 최적화는 JIT를 사용할 때마다 수행 할 수있을 정도로 저렴하며, 다른 최적화는 장기 실행 쿼리에만 유용합니다. 참조 &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes를&lt;/a&gt; 최적화에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="ca2a082afa739ad45f7209a3186244665643f398" translate="yes" xml:space="preserve">
          <source>LOAD &amp;mdash; load a shared library file</source>
          <target state="translated">LOAD &amp;mdash; 공유 라이브러리 파일을로드합니다</target>
        </trans-unit>
        <trans-unit id="c37eb4cb935a6017aaaaaab327837c7d9bbbc004" translate="yes" xml:space="preserve">
          <source>LOCK</source>
          <target state="translated">LOCK</target>
        </trans-unit>
        <trans-unit id="92d4fa824b1bf5ae650f5b90867eff13a3a5fe0a" translate="yes" xml:space="preserve">
          <source>LOCK &amp;mdash; lock a table</source>
          <target state="translated">LOCK &amp;mdash; 테이블을 잠급니다</target>
        </trans-unit>
        <trans-unit id="6b4bea52cbee20f8507b76217f199114a117089e" translate="yes" xml:space="preserve">
          <source>LSN</source>
          <target state="translated">LSN</target>
        </trans-unit>
        <trans-unit id="d1fca76fb082d22a2d8e514d1b3ce5e3ce9aa851" translate="yes" xml:space="preserve">
          <source>LSN: next byte after last byte of WAL record for last change to this page</source>
          <target state="translated">LSN :이 페이지를 마지막으로 변경하기 위해 WAL 레코드의 마지막 바이트 이후 다음 바이트</target>
        </trans-unit>
        <trans-unit id="f7d6ac021994cd293b3c94c2f6248d32ae9579b5" translate="yes" xml:space="preserve">
          <source>Lag times work automatically for physical replication. Logical decoding plugins may optionally emit tracking messages; if they do not, the tracking mechanism will simply display NULL lag.</source>
          <target state="translated">지연 시간은 물리적 복제를 위해 자동으로 작동합니다. 논리 디코딩 플러그인은 선택적으로 추적 메시지를 방출 할 수 있습니다. 그렇지 않은 경우 추적 메커니즘은 단순히 NULL 지연을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="5e9465d239944a0fa40232e75aff84b43ba97385" translate="yes" xml:space="preserve">
          <source>Language of messages</source>
          <target state="translated">메시지의 언어</target>
        </trans-unit>
        <trans-unit id="ce146ba97ccf4a9eb00c4f7b7284970bf1503949" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="translated">큰 개체 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;34 장&lt;/a&gt; 참조 )는 복제되지 않습니다. 일반 테이블에 데이터를 저장하는 것 외에는 해결 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a24b3c46d4ed7dfe7397ec67ef490f12c7f2d62a" translate="yes" xml:space="preserve">
          <source>Last system OID in the database; useful particularly to pg_dump</source>
          <target state="translated">데이터베이스의 마지막 시스템 OID pg_dump에 특히 유용</target>
        </trans-unit>
        <trans-unit id="d8a8330f47a1d2121f7de4d246b07c539d85b887" translate="yes" xml:space="preserve">
          <source>Last time at which this table was analyzed by the autovacuum daemon</source>
          <target state="translated">이 테이블이 autovacuum 데몬에 의해 마지막으로 분석 된 시간</target>
        </trans-unit>
        <trans-unit id="b5daedfbaeb26dce099e49150d7deba8ed7dd63c" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually analyzed</source>
          <target state="translated">이 테이블을 수동으로 분석 한 마지막 시간</target>
        </trans-unit>
        <trans-unit id="d21dc8edf16ccb5721e0bc05e599292ce8cd64c2" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">이 테이블을 수동으로 진공 청소 한 마지막 시간 ( &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 계산하지 않음 )</target>
        </trans-unit>
        <trans-unit id="32d602dc6c753beae99504e742b35637bae47172" translate="yes" xml:space="preserve">
          <source>Last time at which this table was vacuumed by the autovacuum daemon</source>
          <target state="translated">autovacuum 데몬이이 테이블을 마지막으로 정리 한 시간</target>
        </trans-unit>
        <trans-unit id="a6160372ad225c352ec7ffd4f36cad1f43f752fb" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and flushed to disk, the initial value of this field being the first log location used when WAL receiver is started</source>
          <target state="translated">마지막으로 미리 쓰기 로그 위치가 이미 수신되어 디스크로 플러시되었습니다.이 필드의 초기 값은 WAL 수신자가 시작될 때 사용 된 첫 번째 로그 위치입니다.</target>
        </trans-unit>
        <trans-unit id="6dd26aafa1fbdf96a846556c081c9e292557ed50" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location flushed to disk by this standby server</source>
          <target state="translated">이 대기 서버가 디스크에 플러시 한 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="3196ac97aabe6b93efdbd9d951f27185a4510ea9" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location received, the initial value of this field being 0</source>
          <target state="translated">마지막으로 미리 쓰기 로그 위치가 수신되었으며이 필드의 초기 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="7fce43ad04e1c6ea844b5017a38c520afa802611" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location replayed into the database on this standby server</source>
          <target state="translated">이 대기 서버의 데이터베이스로 재생 된 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="0d3835b7f40d0e6e66b1e74e7de916b14d4f990d" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location reported to origin WAL sender</source>
          <target state="translated">WAL 발신자에게보고 된 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="ac1ae56d16c8b53cb449a2ee572fbfc684cbf5dd" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location sent on this connection</source>
          <target state="translated">이 연결에서 전송 된 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="bafcffd5bbf934c91f7d04975d6317a745ba4820" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location written to disk by this standby server</source>
          <target state="translated">이 대기 서버가 디스크에 쓴 마지막 미리 쓰기 로그 위치</target>
        </trans-unit>
        <trans-unit id="ba538f112903a51c4fdd1a1494e1875649a225bb" translate="yes" xml:space="preserve">
          <source>Latin/Arabic</source>
          <target state="translated">Latin/Arabic</target>
        </trans-unit>
        <trans-unit id="fd84929c694afd8b1b6d7503f4f8e1b23aed9285" translate="yes" xml:space="preserve">
          <source>Latin/Cyrillic</source>
          <target state="translated">Latin/Cyrillic</target>
        </trans-unit>
        <trans-unit id="e688538b3f17f5cc30931971a729f9f8fe4c1bdd" translate="yes" xml:space="preserve">
          <source>Latin/Greek</source>
          <target state="translated">Latin/Greek</target>
        </trans-unit>
        <trans-unit id="daa3f6da7a3a4e4229771dc7d3d5e346a4582850" translate="yes" xml:space="preserve">
          <source>Latin/Hebrew</source>
          <target state="translated">Latin/Hebrew</target>
        </trans-unit>
        <trans-unit id="d494f73e6e88daa7f95e93345a91fc4c8dc4fb69" translate="yes" xml:space="preserve">
          <source>Launch the main autoprewarm worker. This will normally happen automatically, but is useful if automatic prewarm was not configured at server startup time and you wish to start up the worker at a later time.</source>
          <target state="translated">주요 자동 예열 작업자를 시작하십시오. 이는 일반적으로 자동으로 발생하지만 서버 시작시 자동 사전 예열이 구성되어 있지 않고 나중에 작업자를 시작하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2c4136854685f9259aab343bbd1cc7a50348e3a5" translate="yes" xml:space="preserve">
          <source>Leaf page fragmentation</source>
          <target state="translated">리프 페이지 조각화</target>
        </trans-unit>
        <trans-unit id="5f877225069b04b69ebc49ed1c8ffc9db5e722b5" translate="yes" xml:space="preserve">
          <source>Leaf tuples of an SP-GiST tree contain values of the same data type as the indexed column. Leaf tuples at the root level will always contain the original indexed data value, but leaf tuples at lower levels might contain only a compressed representation, such as a suffix. In that case the operator class support functions must be able to reconstruct the original value using information accumulated from the inner tuples that are passed through to reach the leaf level.</source>
          <target state="translated">SP-GiST 트리의 리프 튜플에는 인덱싱 된 열과 동일한 데이터 형식의 값이 포함됩니다. 루트 수준의 리프 튜플에는 항상 원래의 인덱스 데이터 값이 포함되지만 하위 수준의 리프 튜플에는 접미사와 같은 압축 된 표현 만 포함될 수 있습니다. 이 경우 연산자 클래스 지원 함수는 전달 된 내부 튜플에서 누적 된 정보를 사용하여 리프 레벨에 도달하여 원래 값을 재구성 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9299c2aba089dc4590aa8606b111db26dae4554a" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of associated operator</source>
          <target state="translated">관련 연산자의 왼손 입력 데이터 유형</target>
        </trans-unit>
        <trans-unit id="ed906ae901de1e3195028f0570c5ad60b2810880" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of operator</source>
          <target state="translated">연산자의 왼쪽 입력 데이터 유형</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="d8b851cee953f8d81c31ec69468e0ec20c2888c1" translate="yes" xml:space="preserve">
          <source>Length of aggregation interval (in seconds). May be used only with &lt;code&gt;-l&lt;/code&gt; option. With this option, the log contains per-interval summary data, as described below.</source>
          <target state="translated">집계 간격 길이 (초) &lt;code&gt;-l&lt;/code&gt; 옵션 과 함께 만 사용할 수 있습니다. 이 옵션을 사용하면 아래에 설명 된대로 로그에 간격 별 요약 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="af6b0587a83fcd51886d616d3a32f3398d01980f" translate="yes" xml:space="preserve">
          <source>Length of binary string</source>
          <target state="translated">이진 문자열의 길이</target>
        </trans-unit>
        <trans-unit id="ccfe4a6f325c29c147887556a7714e5ddcdfe308" translate="yes" xml:space="preserve">
          <source>Length of each signature (index entry) in bits. It is rounded up to the nearest multiple of &lt;code&gt;16&lt;/code&gt;. The default is &lt;code&gt;80&lt;/code&gt; bits and the maximum is &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">각 서명 (인덱스 항목)의 길이 (비트)입니다. 가장 가까운 &lt;code&gt;16&lt;/code&gt; 의 배수로 올림됩니다 . 기본값은 &lt;code&gt;80&lt;/code&gt; 비트이고 최대 값은 &lt;code&gt;4096&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="12d4a8b76c20bac65c1a5a078f5f7a8e333266b4" translate="yes" xml:space="preserve">
          <source>Length or circumference</source>
          <target state="translated">길이 또는 둘레</target>
        </trans-unit>
        <trans-unit id="9d6ed670f3c04a36b7689b66ca5b25c4d52af652" translate="yes" xml:space="preserve">
          <source>Less likely to cause problems is the minimum size for shared memory segments (&lt;code&gt;SHMMIN&lt;/code&gt;), which should be at most approximately 32 bytes for PostgreSQL (it is usually just 1). The maximum number of segments system-wide (&lt;code&gt;SHMMNI&lt;/code&gt;) or per-process (&lt;code&gt;SHMSEG&lt;/code&gt;) are unlikely to cause a problem unless your system has them set to zero.</source>
          <target state="translated">공유 메모리 세그먼트 ( &lt;code&gt;SHMMIN&lt;/code&gt; ) 의 최소 ​​크기는 문제를 일으킬 가능성이 적으며 , PostgreSQL의 경우 최대 약 32 바이트 여야합니다 (일반적으로 1 임). 시스템 전체 ( &lt;code&gt;SHMMNI&lt;/code&gt; ) 또는 프로세스 당 ( &lt;code&gt;SHMSEG&lt;/code&gt; ) 최대 세그먼트 수는 시스템에서 세그먼트 를 0으로 설정하지 않으면 문제를 일으키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="1f01a7dce204970734b2b2a327ee36987199e47f" translate="yes" xml:space="preserve">
          <source>Less-than operator</source>
          <target state="translated">운영자 미만</target>
        </trans-unit>
        <trans-unit id="4576a6bc031e504cf481eb0d13f776e9d54832eb" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to operator</source>
          <target state="translated">같지 않은 연산자</target>
        </trans-unit>
        <trans-unit id="0ab7950f1f29b3334f76dd244ef5a7ba783b1b7f" translate="yes" xml:space="preserve">
          <source>Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table:</source>
          <target state="translated">해당 제품의 주문을 저장하는 테이블이 있다고 가정 해 봅시다. 주문 테이블에는 실제로 존재하는 제품 주문 만 포함되도록하고 싶습니다. 따라서 products 테이블을 참조하는 orders 테이블에 외래 키 제약 조건을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4bb0a1a761abe6883839cec3e71ca469d8a65b69" translate="yes" xml:space="preserve">
          <source>Let's assume you have filled the table with data and want to take a look at it:</source>
          <target state="translated">테이블에 데이터를 채우고 살펴보고 싶다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="6bb447a9045c7cc0d5a93bdb00100d8f10c020e2" translate="yes" xml:space="preserve">
          <source>Let's consider a real-life astronomical example. We'll expand query &lt;code&gt;supernovae&lt;/code&gt; using table-driven rewriting rules:</source>
          <target state="translated">실제 천문학적 예를 생각해 봅시다. 테이블 중심의 다시 쓰기 규칙을 사용하여 쿼리 &lt;code&gt;supernovae&lt;/code&gt; 을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="3450ae90635f5fd80bf01d11b0586d3e5b336518" translate="yes" xml:space="preserve">
          <source>Let's create two tables: A table &lt;code&gt;cities&lt;/code&gt; and a table &lt;code&gt;capitals&lt;/code&gt;. Naturally, capitals are also cities, so you want some way to show the capitals implicitly when you list all cities. If you're really clever you might invent some scheme like this:</source>
          <target state="translated">테이블 &lt;code&gt;cities&lt;/code&gt; 와 테이블 &lt;code&gt;capitals&lt;/code&gt; 두 개의 테이블을 만들어 봅시다 . 당연히 수도도 도시이므로 모든 도시를 나열 할 때 수도를 암시 적으로 표시 할 수있는 방법이 필요합니다. 당신이 정말 영리하다면 다음과 같은 계획을 발명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="002106d5520b7ff0cea15ef411a279196063cbfa" translate="yes" xml:space="preserve">
          <source>Let's look at that command in detail. First is the key word &lt;code&gt;UPDATE&lt;/code&gt; followed by the table name. As usual, the table name can be schema-qualified, otherwise it is looked up in the path. Next is the key word &lt;code&gt;SET&lt;/code&gt; followed by the column name, an equal sign, and the new column value. The new column value can be any scalar expression, not just a constant. For example, if you want to raise the price of all products by 10% you could use:</source>
          <target state="translated">해당 명령을 자세히 살펴 보겠습니다. 첫 번째는 키워드 &lt;code&gt;UPDATE&lt;/code&gt; 와 테이블 이름입니다. 일반적으로 테이블 이름은 스키마로 한정 될 수 있으며 그렇지 않은 경우 경로에서 조회됩니다. 다음은 키워드 &lt;code&gt;SET&lt;/code&gt; 뒤에 열 이름, 등호 및 새 열 값이옵니다. 새 열 값은 상수뿐만 아니라 모든 스칼라식이 될 수 있습니다. 예를 들어 모든 제품의 가격을 10 % 인상하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b99b3611a0c2fdc7f95a1799fb3492cd67f4e6" translate="yes" xml:space="preserve">
          <source>Let's look at the query from &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt; again, but this time with a MCV list created on the same set of columns (be sure to drop the functional dependencies, to make sure the planner uses the newly created statistics).</source>
          <target state="translated">&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;70.2.1 절의&lt;/a&gt; 쿼리를 다시 살펴 보지만 이번에는 동일한 열 세트에 작성된 MCV 목록을 사용하여 계획을 세웁니다 (계획자가 새로 작성된 통계를 사용하도록 기능 종속성을 삭제하십시오).</target>
        </trans-unit>
        <trans-unit id="1612ac24f2069dd66f65838fc7336fa0b28c41cb" translate="yes" xml:space="preserve">
          <source>Let's move on to an example with a range condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절 에 범위 조건이있는 예제로 넘어 갑시다 .</target>
        </trans-unit>
        <trans-unit id="e33f516fc6df811ac7dea3c6a71c77e25ecd5519" translate="yes" xml:space="preserve">
          <source>Let's start with a very simple query:</source>
          <target state="translated">매우 간단한 쿼리부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="944a02000a7cd912b7786576975c692505293e37" translate="yes" xml:space="preserve">
          <source>Let's start with an example: suppose we are trying to build a data model for cities. Each state has many cities, but only one capital. We want to be able to quickly retrieve the capital city for any particular state. This can be done by creating two tables, one for state capitals and one for cities that are not capitals. However, what happens when we want to ask for data about a city, regardless of whether it is a capital or not? The inheritance feature can help to resolve this problem. We define the &lt;code&gt;capitals&lt;/code&gt; table so that it inherits from &lt;code&gt;cities&lt;/code&gt;:</source>
          <target state="translated">예를 들어 보자. 도시를위한 데이터 모델을 구축하려고한다고 가정하자. 각 주에는 많은 도시가 있지만 하나의 수도 만 있습니다. 특정 주에 대한 수도를 신속하게 검색 할 수 있기를 원합니다. 이는 주 수도와 수도가 아닌 도시를위한 두 개의 테이블을 작성하여 수행 할 수 있습니다. 그러나 도시인지 여부에 관계없이 도시에 대한 데이터를 요청하려고하면 어떻게됩니까? 상속 기능은이 문제를 해결하는 데 도움이 될 수 있습니다. &lt;code&gt;cities&lt;/code&gt; 에서 상속 &lt;code&gt;capitals&lt;/code&gt; 테이블을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="8936905c2cce98cf23701c4834f7f639d90f7b6d" translate="yes" xml:space="preserve">
          <source>Let's try joining two tables, using the columns we have been discussing:</source>
          <target state="translated">논의한 열을 사용하여 두 개의 테이블을 조인 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="fc56b91f6d327225a18362ab13575f562f30c691" translate="yes" xml:space="preserve">
          <source>Lexemes that have positions can further be labeled with a &lt;em&gt;weight&lt;/em&gt;, which can be &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. &lt;code&gt;D&lt;/code&gt; is the default and hence is not shown on output:</source>
          <target state="translated">위치가있는 벡스에는 &lt;em&gt;가중치&lt;/em&gt; 가 추가 될 수 있으며 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;D&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;D&lt;/code&gt; 가 기본값이므로 출력에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4de4e82a8494674ff2932d2f3ecffa7e7aa91c37" translate="yes" xml:space="preserve">
          <source>Lexical Structure</source>
          <target state="translated">어휘 구조</target>
        </trans-unit>
        <trans-unit id="98b17490298c1db6b1bff4b00e76136ec7bbbbbf" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Comments</source>
          <target state="translated">어휘 구조 : 주석</target>
        </trans-unit>
        <trans-unit id="fba7d54766b9a41f8c00c3be52c20790571085f9" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Constants</source>
          <target state="translated">어휘 구조 : 상수</target>
        </trans-unit>
        <trans-unit id="0eb1a63288ed8a4eea2395df1dd364cf859d54a6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Identifiers and Key Words</source>
          <target state="translated">어휘 구조 : 식별자 및 핵심어</target>
        </trans-unit>
        <trans-unit id="195802f293c2f60e26c9b9d1cca1271d02591bfe" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operator Precedence</source>
          <target state="translated">어휘 구조 : 연산자 우선 순위</target>
        </trans-unit>
        <trans-unit id="f3025dccc066fa7289f006eb8ae5b580e53548c6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operators</source>
          <target state="translated">어휘 구조 : 연산자</target>
        </trans-unit>
        <trans-unit id="820a42a37bd5d5e7546df4a06a9fad64993321ea" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Special Characters</source>
          <target state="translated">어휘 구조 : 특수 문자</target>
        </trans-unit>
        <trans-unit id="aa1c47b9be01b70fcc0a9ce52958782af56ce40a" translate="yes" xml:space="preserve">
          <source>Library API</source>
          <target state="translated">라이브러리 API</target>
        </trans-unit>
        <trans-unit id="bc61796bcb48c2cc0906e22b19a382e56ac7241c" translate="yes" xml:space="preserve">
          <source>Licensed under the PostgreSQL License.</source>
          <target state="translated">PostgreSQL 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="70e96422ed9935802e683689abf5ed30f10484c2" translate="yes" xml:space="preserve">
          <source>Lightweight Directory Access Protocol</source>
          <target state="translated">경량 디렉토리 액세스 프로토콜</target>
        </trans-unit>
        <trans-unit id="706c7257274a3b242ba385122feaad6c90232d40" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;%/&lt;/code&gt;, but the output is &lt;code&gt;~&lt;/code&gt; (tilde) if the database is your default database.</source>
          <target state="translated">마찬가지로 &lt;code&gt;%/&lt;/code&gt; , 출력은 있지만 &lt;code&gt;~&lt;/code&gt; 데이터베이스가 기본 데이터베이스 인 경우 (물결).</target>
        </trans-unit>
        <trans-unit id="01c5b4c11e3825cd811354418a5a2a2256d5f14a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--locale&lt;/code&gt;, but only sets the locale in the specified category.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--locale&lt;/code&gt; 있지만 지정된 카테고리의 로케일을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7bcb9cac0fa5cedaf3e22ad3fe9503230b5e0b4b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;LIKE&lt;/code&gt;, the &lt;code&gt;SIMILAR TO&lt;/code&gt; operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string. Also like &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; uses &lt;code&gt;_&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; as wildcard characters denoting any single character and any string, respectively (these are comparable to &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;.*&lt;/code&gt; in POSIX regular expressions).</source>
          <target state="translated">마찬가지로 &lt;code&gt;LIKE&lt;/code&gt; 의 &lt;code&gt;SIMILAR TO&lt;/code&gt; 연산자는 패턴이 전체 문자열과 일치하는 경우에만 성공; 이것은 패턴이 문자열의 어느 부분과도 일치 할 수있는 일반적인 정규식 동작과 다릅니다. 또한 같은 &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;SIMILAR TO&lt;/code&gt; 의 사용 &lt;code&gt;_&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 단일 문자와 문자열을 나타내는 와일드 카드 문자로, 각각 (이들은 비교할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 및 &lt;code&gt;.*&lt;/code&gt; POSIX 정규 표현식에서).</target>
        </trans-unit>
        <trans-unit id="85a2ab4c0cd63cc27de88b6c0b7fbce75e30b6bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;aggfinalmodify&lt;/code&gt;, but for the &lt;code&gt;aggmfinalfn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;aggfinalmodify&lt;/code&gt; 와 비슷 하지만 &lt;code&gt;aggmfinalfn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059422d409e873d3ec537d586c30c482c509b6ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;penalty&lt;/code&gt;, the &lt;code&gt;picksplit&lt;/code&gt; function is crucial to good performance of the index. Designing suitable &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; implementations is where the challenge of implementing well-performing GiST indexes lies.</source>
          <target state="translated">마찬가지로 &lt;code&gt;penalty&lt;/code&gt; 의 &lt;code&gt;picksplit&lt;/code&gt; 의 기능은 인덱스의 좋은 성능에 매우 중요하다. 적절한 &lt;code&gt;penalty&lt;/code&gt; 및 &lt;code&gt;picksplit&lt;/code&gt; 구현을 설계 하는 것은 성능이 우수한 GiST 인덱스를 구현해야하는 과제입니다.</target>
        </trans-unit>
        <trans-unit id="2af7b72fbf0a8ccd43a00ff740a0fef8b75c0395" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pg_statistic&lt;/code&gt;, &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; should not be readable by the public, since the contents might be considered sensitive. (Example: most common combinations of values in columns might be quite interesting.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt;&lt;code&gt;pg_stats_ext&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; (after joining with &lt;code&gt;pg_statistic_ext&lt;/code&gt;) that only exposes information about those tables and columns that are readable by the current user.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 과 마찬가지로 , &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 는 내용이 민감한 것으로 간주 될 수 있으므로 공개적으로 읽을 수 없습니다. (예 : 열에서 가장 일반적인 값 조합은 매우 흥미로울 수 있습니다.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt; &lt;code&gt;pg_stats_ext&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 에서 공개적으로 읽을 수있는보기 ( &lt;code&gt;pg_statistic_ext&lt;/code&gt; 와 결합한 후 )는 현재 사용자가 읽을 수있는 테이블 및 열에 대한 정보 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1e283f20748a53829b82b5760d76e1b1a5f034e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plainto_tsquery&lt;/code&gt;, the &lt;code&gt;phraseto_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">마찬가지로 &lt;code&gt;plainto_tsquery&lt;/code&gt; 의 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 의 기능을 인식하지 않습니다 &lt;code&gt;tsquery&lt;/code&gt; 입력 연산자, 체중 레이블 또는 접두사 일치 라벨 :</target>
        </trans-unit>
        <trans-unit id="176fba135c7656c6b09a34f8083ee1cb69b4df0d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;code&gt;toptag&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; 하지만 결과를 생략합니다 &lt;code&gt;toptag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a092e16f9fe5baae3ebd61fa16eca90ce0ed31e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits both tags.</source>
          <target state="translated">마찬가지로 &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; 하지만 결과를 생략 모두 태그입니다.</target>
        </trans-unit>
        <trans-unit id="79231c4789ce70fc6a3cc412988cea4a45cfbcbb" translate="yes" xml:space="preserve">
          <source>Like GiST and SP-GiST, GIN can support many different user-defined indexing strategies, and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQL includes a GIN operator class for arrays, which supports indexed queries using these operators:</source>
          <target state="translated">GiST 및 SP-GiST와 마찬가지로 GIN은 다양한 사용자 정의 인덱싱 전략을 지원할 수 있으며 GIN 인덱스를 사용할 수있는 특정 연산자는 인덱싱 전략에 따라 다릅니다. 예를 들어, PostgreSQL의 표준 배포에는 다음 연산자를 사용하여 인덱스 된 쿼리를 지원하는 배열에 대한 GIN 연산자 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd7904080c36090327450bf7ffd681d3be365b14" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST is meant to allow the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">GiST와 마찬가지로 SP-GiST는 데이터베이스 전문가가 아닌 데이터 유형의 도메인 전문가가 적절한 액세스 방법으로 사용자 지정 데이터 유형을 개발할 수 있도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="48b6f9b32591a18a649f1f0d5dc992087748dd36" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST supports &amp;ldquo;nearest-neighbor&amp;rdquo; searches. For SP-GiST operator classes that support distance ordering, the corresponding operator is specified in the &amp;ldquo;Ordering Operators&amp;rdquo; column in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">GiST와 마찬가지로 SP-GiST는 &quot;인접 이웃&quot;검색을 지원합니다. 거리 순서를 지원하는 SP-GiST 연산자 클래스의 경우 해당 연산자는 &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 65.1&lt;/a&gt; 의&amp;ldquo;주문 연산자&amp;rdquo;열에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="60e4d14adfb5f143c50beb7e0713788626061776" translate="yes" xml:space="preserve">
          <source>Like a &lt;code&gt;CASE&lt;/code&gt; expression, &lt;code&gt;COALESCE&lt;/code&gt; only evaluates the arguments that are needed to determine the result; that is, arguments to the right of the first non-null argument are not evaluated. This SQL-standard function provides capabilities similar to &lt;code&gt;NVL&lt;/code&gt; and &lt;code&gt;IFNULL&lt;/code&gt;, which are used in some other database systems.</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 표현식 과 마찬가지로 &lt;code&gt;COALESCE&lt;/code&gt; 는 결과를 판별하는 데 필요한 인수 만 평가합니다. 즉, 널이 아닌 첫 번째 인수의 오른쪽에있는 인수는 평가되지 않습니다. 이 SQL 표준 함수는 일부 다른 데이터베이스 시스템에서 사용되는 &lt;code&gt;NVL&lt;/code&gt; 및 &lt;code&gt;IFNULL&lt;/code&gt; 과 유사한 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="1b49279f338ded2bdf03d1fe2fa28270882b8852" translate="yes" xml:space="preserve">
          <source>Like all locks in PostgreSQL, a complete list of advisory locks currently held by any session can be found in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">PostgreSQL의 모든 잠금과 마찬가지로 현재 모든 세션에서 보유한 전체 자문 잠금 목록은 &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; 시스템보기 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41cf9a59f49a59843cd96e23e78a1ccf6b90562d" translate="yes" xml:space="preserve">
          <source>Like all statement-logging options, this option can add significant overhead.</source>
          <target state="translated">모든 명령문 로깅 옵션과 마찬가지로이 옵션은 상당한 오버 헤드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c02f2aa97036dbf7f53371e80651c744767251" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="translated">다른 PostgreSQL 클라이언트 응용 프로그램과 마찬가지로 pg_dump는 기본적으로 현재 운영 체제 사용자 이름과 동일한 데이터베이스 사용자 이름으로 연결됩니다. 이를 대체하려면 &lt;code&gt;-U&lt;/code&gt; 옵션을 지정 하거나 환경 변수 &lt;code&gt;PGUSER&lt;/code&gt; 를 설정하십시오 . pg_dump 연결에는 일반적인 클라이언트 인증 메커니즘 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 에서 설명 )이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9db72f7082c44e13743d7b5d39d781324396c03" translate="yes" xml:space="preserve">
          <source>Like most other relational database products, PostgreSQL supports &lt;em&gt;aggregate functions&lt;/em&gt;. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt; (average), &lt;code&gt;max&lt;/code&gt; (maximum) and &lt;code&gt;min&lt;/code&gt; (minimum) over a set of rows.</source>
          <target state="translated">대부분의 다른 관계형 데이터베이스 제품과 마찬가지로 PostgreSQL은 &lt;em&gt;집계 함수를&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; . 집계 함수는 여러 입력 행에서 단일 결과를 계산합니다. 예를 들어 행 집합에 대해 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;avg&lt;/code&gt; (평균), &lt;code&gt;max&lt;/code&gt; (최대) 및 &lt;code&gt;min&lt;/code&gt; (최소) 을 계산하는 집계 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7b37131745c0548a8d7bb256942b653bac4d0f2" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are requested.</source>
          <target state="translated">내장 된 &lt;code&gt;SYSTEM&lt;/code&gt; 샘플링 방법 과 마찬가지로 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 는 블록 수준 샘플링을 수행하므로 샘플이 완전히 임의적이지는 않지만 특히 적은 수의 행만 요청하는 경우 클러스터링 효과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2764b8aec49f0a51f07f507803e713795f179f24" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_TIME&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are selected.</source>
          <target state="translated">내장 된 &lt;code&gt;SYSTEM&lt;/code&gt; 샘플링 방법 과 마찬가지로 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; 은 블록 레벨 샘플링을 수행하므로 샘플이 완전히 임의적이지는 않지만 특히 적은 수의 행만 선택된 경우 클러스터링 효과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e207e275fe1f2f0794d071fcc2006657d41ca30" translate="yes" xml:space="preserve">
          <source>Likewise, if the output column is an array type and the JSON value is a JSON array, the elements of the JSON array are converted to elements of the output array by recursive application of these rules.</source>
          <target state="translated">마찬가지로 출력 열이 배열 유형이고 JSON 값이 JSON 배열 인 경우 JSON 규칙의 요소는 이러한 규칙을 반복적으로 적용하여 출력 배열의 요소로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c63c5f8682585854b3af24acfaa10cdf34814785" translate="yes" xml:space="preserve">
          <source>Likewise, it is the operator class's responsibility that inner tuples do not grow too large to fit on an index page; this limits the number of child nodes that can be used in one inner tuple, as well as the maximum size of a prefix value.</source>
          <target state="translated">마찬가지로 내부 튜플이 색인 페이지에 맞지 않을 정도로 커지지 않는 것은 운영자 클래스의 책임입니다. 이것은 하나의 내부 튜플에서 사용할 수있는 자식 노드의 수와 접두사 값의 최대 크기를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="55246b1bbd1c53d922bbe5662b502ad39d3e6a6a" translate="yes" xml:space="preserve">
          <source>Likewise, the current session's temporary-table schema, &lt;code&gt;pg_temp_nnn&lt;/code&gt;, is always searched if it exists. It can be explicitly listed in the path by using the alias &lt;code&gt;pg_temp&lt;/code&gt;. If it is not listed in the path then it is searched first (even before &lt;code&gt;pg_catalog&lt;/code&gt;). However, the temporary schema is only searched for relation (table, view, sequence, etc) and data type names. It is never searched for function or operator names.</source>
          <target state="translated">마찬가지로 현재 세션의 임시 테이블 스키마 &lt;code&gt;pg_temp_nnn&lt;/code&gt; 은 항상 존재하는 경우 검색됩니다. 별명 &lt;code&gt;pg_temp&lt;/code&gt; 를 사용하여 경로에 명시 적으로 나열 할 수 있습니다 . 경로에 나열되지 않으면 먼저 &lt;code&gt;pg_catalog&lt;/code&gt; 이전에도 검색 됩니다. 그러나 임시 스키마는 관계 (테이블, 뷰, 시퀀스 등) 및 데이터 유형 이름 만 검색합니다. 함수 또는 연산자 이름을 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23e122f77e2123c0711252ea9a852e626bde8b4c" translate="yes" xml:space="preserve">
          <source>Likewise, while an aggregate final function is normally expected not to modify its input values, sometimes it is impractical to avoid modifying the transition-state argument. Such behavior must be declared using the &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; parameter. The &lt;code&gt;READ_WRITE&lt;/code&gt; value indicates that the final function modifies the transition state in unspecified ways. This value prevents use of the aggregate as a window function, and it also prevents merging of transition states for aggregate calls that share the same input values and transition functions. The &lt;code&gt;SHAREABLE&lt;/code&gt; value indicates that the transition function cannot be applied after the final function, but multiple final-function calls can be performed on the ending transition state value. This value prevents use of the aggregate as a window function, but it allows merging of transition states. (That is, the optimization of interest here is not applying the same final function repeatedly, but applying different final functions to the same ending transition state value. This is allowed as long as none of the final functions are marked &lt;code&gt;READ_WRITE&lt;/code&gt;.)</source>
          <target state="translated">마찬가지로 집계 최종 함수는 일반적으로 입력 값을 수정하지 않아야하지만 때때로 전이 상태 인수를 수정하지 않는 것이 비현실적입니다. 이러한 동작은 &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; 매개 변수를 사용하여 선언해야합니다 . &lt;code&gt;READ_WRITE&lt;/code&gt; 의 값은 최종 함수 지정 방법 전이 상태를 수정하는 것을 나타낸다. 이 값은 집계를 창 함수로 사용하는 것을 방지하고 동일한 입력 값과 전환 함수를 공유하는 집계 호출에 대한 전환 상태의 병합을 방지합니다. &lt;code&gt;SHAREABLE&lt;/code&gt; 값은 최종 기능 후에 전환 기능을 적용 할 수 없지만 종료 전환 상태 값에 대해 여러 최종 기능 호출을 수행 할 수 있음을 나타냅니다. 이 값은 집계를 창 함수로 사용하지 못하지만 전환 상태를 병합 할 수 있습니다. (여기서 관심있는 최적화는 동일한 최종 함수를 반복적으로 적용하지 않고 동일한 최종 전이 상태 값에 다른 최종 함수를 적용합니다. 최종 함수가 &lt;code&gt;READ_WRITE&lt;/code&gt; 로 표시되지 않는 한 허용됩니다 .)</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="b47563cbfdd571c38564d5b781eea43887f5700d" translate="yes" xml:space="preserve">
          <source>Limits and compatibility notes for the &lt;code&gt;xml&lt;/code&gt; data type can be found in &lt;a href=&quot;xml-limits-conformance&quot;&gt;Section D.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 형식에 대한 제한 및 호환성 정보 는 &lt;a href=&quot;xml-limits-conformance&quot;&gt;섹션 D.3&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96d43f75faf24d1ca67c70ecd2f285a22f1af174" translate="yes" xml:space="preserve">
          <source>Line number of this rule in &lt;code&gt;pg_hba.conf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 에서이 규칙의 줄 번호</target>
        </trans-unit>
        <trans-unit id="958c1e90be0b1ef7a3ea1a3a2ab4b6c7d005a8b7" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file the current value was set at (null for values set from sources other than configuration files, or when examined by a user who is neither a superuser or a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;).</source>
          <target state="translated">구성 파일 내에서 현재 값이 설정되었습니다 (구성 파일 이외의 소스에서 설정 한 값의 경우 또는 수퍼 유저 또는 &lt;code&gt;pg_read_all_settings&lt;/code&gt; 의 구성원이 아닌 사용자가 검사 한 경우 널값 ).</target>
        </trans-unit>
        <trans-unit id="5b8f36e71eca1491bb5a406fd952255ee2d3703e" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file where the entry appears</source>
          <target state="translated">항목이 나타나는 구성 파일 내의 줄 번호</target>
        </trans-unit>
        <trans-unit id="883c97e9c14ffbedf2267734a54bef543950a75e" translate="yes" xml:space="preserve">
          <source>Line segments are output using the first syntax.</source>
          <target state="translated">선분은 첫 번째 구문을 사용하여 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="752729c6452eefd378564f7929186a93baad040b" translate="yes" xml:space="preserve">
          <source>Line segments are represented by pairs of points that are the endpoints of the segment. Values of type &lt;code&gt;lseg&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">선 세그먼트는 세그먼트의 끝점 인 점 쌍으로 표시됩니다. &lt;code&gt;lseg&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="16fbbc248c377444909f3461d6f0754204ffd781" translate="yes" xml:space="preserve">
          <source>Lines are represented by the linear equation &lt;code&gt;A&lt;/code&gt;x + &lt;code&gt;B&lt;/code&gt;y + &lt;code&gt;C&lt;/code&gt; = 0, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are not both zero. Values of type &lt;code&gt;line&lt;/code&gt; are input and output in the following form:</source>
          <target state="translated">선은 선형 방정식 &lt;code&gt;A&lt;/code&gt; x + &lt;code&gt;B&lt;/code&gt; y + &lt;code&gt;C&lt;/code&gt; = 0으로 표시되며 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 모두 0이 아닙니다. &lt;code&gt;line&lt;/code&gt; 유형의 값은 다음 형식으로 입력 및 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="c8eb4d4a92219b0c43b53ed882184405007c09a3" translate="yes" xml:space="preserve">
          <source>Lines being skipped are parsed normally to identify queries and backslash commands, but queries are not sent to the server, and backslash commands other than conditionals (&lt;code&gt;\if&lt;/code&gt;, &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, &lt;code&gt;\endif&lt;/code&gt;) are ignored. Conditional commands are checked only for valid nesting. Variable references in skipped lines are not expanded, and backquote expansion is not performed either.</source>
          <target state="translated">건너 뛴 행은 쿼리 및 백 슬래시 명령을 식별하기 위해 정상적으로 구문 분석되지만 쿼리는 서버로 전송되지 않으며 조건부 ( &lt;code&gt;\if&lt;/code&gt; , &lt;code&gt;\elif&lt;/code&gt; , &lt;code&gt;\else&lt;/code&gt; , &lt;code&gt;\endif&lt;/code&gt; ) 이외의 백 슬래시 명령 은 무시됩니다. 조건부 명령은 유효한 중첩에 대해서만 검사됩니다. 건너 뛴 줄의 변수 참조는 확장되지 않으며 역 따옴표 확장도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="292bae73b4b4a6866d3b72fe56f7981ef97aafd8" translate="yes" xml:space="preserve">
          <source>Lines in the file can be commented out, deleted, and reordered. For example:</source>
          <target state="translated">파일의 행은 주석 처리, 삭제 및 순서 변경이 가능합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a1f33913b1ca17a294498b513bfd39ae8063421" translate="yes" xml:space="preserve">
          <source>Linguistic - Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="translated">언어-Ispell 사전은 입력 단어를 정규화 된 형태로 줄이기 위해 노력합니다. 형태소 사전은 단어 엔딩을 제거합니다</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="77cec0c3e9d8d25a57ec1badeff796c61ca86f12" translate="yes" xml:space="preserve">
          <source>List Partitioning</source>
          <target state="translated">파티셔닝 목록</target>
        </trans-unit>
        <trans-unit id="0f3458dce5820aca7e890c4b2003d0e275648e05" translate="yes" xml:space="preserve">
          <source>List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command &lt;code&gt;\list&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 모든 데이터베이스를 나열한 다음 종료하십시오. 다른 비 연결 옵션은 무시됩니다. 이것은 메타 명령 &lt;code&gt;\list&lt;/code&gt; 와 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="4286624f672002892b2ca95ea48f927cd5f85422" translate="yes" xml:space="preserve">
          <source>List information about tables or indexes in a partition tree for a given partitioned table or partitioned index, with one row for each partition. Information provided includes the name of the partition, the name of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The value of level begins at &lt;code&gt;0&lt;/code&gt; for the input table or index in its role as the root of the partition tree, &lt;code&gt;1&lt;/code&gt; for its partitions, &lt;code&gt;2&lt;/code&gt; for their partitions, and so on.</source>
          <target state="translated">주어진 파티션 된 테이블 또는 파티션 된 인덱스의 파티션 트리에서 테이블 또는 인덱스에 대한 정보를 각 파티션마다 한 행씩 나열하십시오. 제공되는 정보에는 파티션 이름, 바로 위 부모 이름, 파티션이 리프인지 알려주는 부울 값 및 계층 구조의 레벨을 나타내는 정수가 포함됩니다. 레벨의 값은 파티션 트리의 루트 역할을하는 입력 테이블 또는 인덱스의 경우 &lt;code&gt;0&lt;/code&gt; 에서 시작 하고 파티션의 경우 &lt;code&gt;1&lt;/code&gt; , 파티션의 경우 &lt;code&gt;2&lt;/code&gt; 등으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f561011cb33daf6ca735d20bdacd8bd7a77bc262" translate="yes" xml:space="preserve">
          <source>List of database name(s) to which this rule applies</source>
          <target state="translated">이 규칙이 적용되는 데이터베이스 이름 목록</target>
        </trans-unit>
        <trans-unit id="c88853b59f7b2d53c0a2755574e42ba43712f76a" translate="yes" xml:space="preserve">
          <source>List of user and group name(s) to which this rule applies</source>
          <target state="translated">이 규칙이 적용되는 사용자 및 그룹 이름 목록</target>
        </trans-unit>
        <trans-unit id="d7af7e299822395c971e66ef8de74b892601d575" translate="yes" xml:space="preserve">
          <source>List text search configurations (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">텍스트 검색 구성을 나열하십시오 ( 자세한 내용은 &lt;code&gt;+&lt;/code&gt; 추가 ).</target>
        </trans-unit>
        <trans-unit id="75bf8723aef5bc601305334105eb67bae8708809" translate="yes" xml:space="preserve">
          <source>List text search dictionaries (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">텍스트 검색 사전을 나열하십시오 ( 자세한 내용은 &lt;code&gt;+&lt;/code&gt; 추가 ).</target>
        </trans-unit>
        <trans-unit id="f21d1140d1b1ac1f6965e01da259ebe5d03603ab" translate="yes" xml:space="preserve">
          <source>List text search parsers (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">텍스트 검색 파서를 나열하십시오 ( 자세한 내용은 &lt;code&gt;+&lt;/code&gt; 추가 ).</target>
        </trans-unit>
        <trans-unit id="a1e1b832b491c08ce8f5b18d1ec93b64f07d2462" translate="yes" xml:space="preserve">
          <source>List text search templates (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">텍스트 검색 템플릿을 나열합니다 ( 자세한 내용은 &lt;code&gt;+&lt;/code&gt; 추가 ).</target>
        </trans-unit>
        <trans-unit id="47ced8a7739926f8f4967c561a0debfd00799b0f" translate="yes" xml:space="preserve">
          <source>List the ancestor relations of the given partition, including the partition itself.</source>
          <target state="translated">파티션 자체를 포함하여 주어진 파티션의 상위 관계를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="1202ae63c3dc8af04c25238d78d5139577abc684" translate="yes" xml:space="preserve">
          <source>List the contents of a directory. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">디렉토리의 내용을 나열하십시오. 기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b401449c4e0d240387a616d5ffbd4a726f02619" translate="yes" xml:space="preserve">
          <source>List the databases in the server and show their names, owners, character set encodings, and access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only databases whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, database sizes, default tablespaces, and descriptions are also displayed. (Size information is only available for databases that the current user can connect to.)</source>
          <target state="translated">서버의 데이터베이스를 나열하고 이름, 소유자, 문자 세트 인코딩 및 액세스 권한을 표시하십시오. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 전용 데이터베이스가 나열됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가됩니다, 데이터베이스 크기, 기본 테이블 스페이스 및 설명도 표시됩니다. (크기 정보는 현재 사용자가 연결할 수있는 데이터베이스에만 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0247fd79dd91c3e0b751440d00b889937665ce82" translate="yes" xml:space="preserve">
          <source>List the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory</source>
          <target state="translated">&lt;code&gt;log_directory&lt;/code&gt; 디렉토리 에 로그 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="38872979f824f8456260bf7fc7dc4180d1627b73" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL archive status directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">WAL 아카이브 상태 디렉토리에 파일의 이름, 크기 및 마지막 수정 시간을 나열하십시오. &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원에게 액세스 권한이 부여되고 수퍼 유저가 아닌 다른 역할에게 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="216f390c14edafdef1abb92a2e408162ca22c8d7" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">WAL 디렉토리에있는 파일의 이름, 크기 및 마지막 수정 시간을 나열하십시오. &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원에게 액세스 권한이 부여되고 수퍼 유저가 아닌 다른 역할에게 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74056411fa2a679687b641cd39f5e9f62ea8d563" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the log directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">로그 디렉토리에 파일의 이름, 크기 및 마지막 수정 시간을 나열하십시오. &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원에게 액세스 권한이 부여되고 수퍼 유저가 아닌 다른 역할에게 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26197e7b4127b303329ad5784e3d755d4742f8bd" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the temporary directory for &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt; is not provided, the &lt;code&gt;pg_default&lt;/code&gt; tablespace is used. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; 의 임시 디렉토리에있는 파일의 이름, 크기 및 마지막 수정 시간을 나열하십시오 . 경우 &lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; 제공되지는 &lt;code&gt;pg_default&lt;/code&gt; 의 테이블 스페이스가 사용됩니다. &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원에게 액세스 권한이 부여되고 수퍼 유저가 아닌 다른 역할에게 권한이 부여 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c759b89899d2c028e05b2457d4bdd0b88affd68" translate="yes" xml:space="preserve">
          <source>List the table of contents of the archive. The output of this operation can be used as input to the &lt;code&gt;-L&lt;/code&gt; option. Note that if filtering switches such as &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; are used with &lt;code&gt;-l&lt;/code&gt;, they will restrict the items listed.</source>
          <target state="translated">아카이브의 목차를 나열하십시오. 이 조작의 출력은 &lt;code&gt;-L&lt;/code&gt; 옵션 에 대한 입력으로 사용될 수 있습니다 . &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;-t&lt;/code&gt; 와 같은 필터링 스위치 를 &lt;code&gt;-l&lt;/code&gt; 과 함께 사용하는 경우 하면 나열된 항목이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c161fe12eda9cadc384d03d0ff29a932c7632490" translate="yes" xml:space="preserve">
          <source>Lists access methods. If &lt;code&gt;pattern&lt;/code&gt; is specified, only access methods whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each access method is listed with its associated handler function and description.</source>
          <target state="translated">액세스 방법을 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 액세스 방법 만 표시됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름을 추가하고, 각각의 액세스 방법은 연관된 핸들러 함수 및 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="b5da05aa6b417885b162fa263cf878dfa1640338" translate="yes" xml:space="preserve">
          <source>Lists aggregate functions, together with their return type and the data types they operate on. If &lt;code&gt;pattern&lt;/code&gt; is specified, only aggregates whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">집계 유형과 반환 유형 및 작동하는 데이터 유형을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 집계가 표시됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 패턴 또는 &lt;code&gt;S&lt;/code&gt; 를 공급 시스템 오브젝트를 포함 수정자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="ba7e4d85e717101a207e6ece8fa5eae17728be95" translate="yes" xml:space="preserve">
          <source>Lists collations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only collations whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each collation is listed with its associated description, if any. Note that only collations usable with the current database's encoding are shown, so the results may vary in different databases of the same installation.</source>
          <target state="translated">데이터 정렬을 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 데이터 정렬 만 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되어있는 경우, 각각의 조합은 관련 설명과 함께 나열됩니다. 현재 데이터베이스의 인코딩과 함께 사용할 수있는 데이터 정렬 만 표시되므로 동일한 설치의 데이터베이스마다 결과가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ed6b6d351ec0314d4901220593cc831623e426a" translate="yes" xml:space="preserve">
          <source>Lists conversions between character-set encodings. If &lt;code&gt;pattern&lt;/code&gt; is specified, only conversions whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">문자 집합 인코딩 간의 변환을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 변환이 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="b54152fa5b884f8f7bf428a2c5f3834496af64bd" translate="yes" xml:space="preserve">
          <source>Lists data types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only types whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each type is listed with its internal name and size, its allowed values if it is an &lt;code&gt;enum&lt;/code&gt; type, and its associated permissions. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">데이터 유형을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 유일한 유형이 나열됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 그것이 있다면 명령 이름을 추가하고, 각각의 유형은 내부 이름과 크기로 표시되어, 그 값이 허용 &lt;code&gt;enum&lt;/code&gt; 유형 및 연관된 권한. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed12c82d91396faa77acdf69ded0ffcf5a493ea" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\dg&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\du+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">데이터베이스 역할을 나열합니다. &quot;users&quot;및 &quot;groups&quot;의 개념이 &quot;roles&quot;로 통합 &lt;code&gt;\dg&lt;/code&gt; 명령은 이제 \ dg 와 같습니다 . 기본적으로 사용자가 만든 역할 만 표시됩니다. 시스템 역할을 포함 하도록 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오 . 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 그 역할은 패턴이 나열됩니다 일치합니다. &lt;code&gt;\du+&lt;/code&gt; 형식을 사용하면 각 역할에 대한 추가 정보가 표시됩니다. 현재 이것은 각 역할에 대한 설명을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e29d00c4605108f4d7ba7d0a5a262d70885a0257" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\du&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\dg+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">데이터베이스 역할을 나열합니다. &quot;users&quot;및 &quot;groups&quot;개념이 &quot;roles&quot;로 통합되었으므로이 명령은 이제 &lt;code&gt;\du&lt;/code&gt; 와 같습니다 . 기본적으로 사용자가 만든 역할 만 표시됩니다. 시스템 역할을 포함 하도록 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오 . 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 그 역할은 패턴이 나열됩니다 일치합니다. &lt;code&gt;\dg+&lt;/code&gt; 형식을 사용하면 각 역할에 대한 추가 정보가 표시됩니다. 현재 이것은 각 역할에 대한 설명을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d0e3c51687d883f635b713be9df17a17913ec4be" translate="yes" xml:space="preserve">
          <source>Lists default access privilege settings. An entry is shown for each role (and schema, if applicable) for which the default privilege settings have been changed from the built-in defaults. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose role name or schema name matches the pattern are listed.</source>
          <target state="translated">기본 액세스 권한 설정을 나열합니다. 기본 권한 설정이 기본 제공 기본값에서 변경된 각 역할 (및 해당되는 경우 스키마)에 대한 항목이 표시됩니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 그 역할 이름 또는 스키마 이름이 나열된 패턴과 일치하는 항목을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ee1fa4ed6c7126c1942282c2d9a97fd2fb17066c" translate="yes" xml:space="preserve">
          <source>Lists defined configuration settings. These settings can be role-specific, database-specific, or both. &lt;code&gt;role-pattern&lt;/code&gt; and &lt;code&gt;database-pattern&lt;/code&gt; are used to select specific roles and databases to list, respectively. If omitted, or if &lt;code&gt;*&lt;/code&gt; is specified, all settings are listed, including those not role-specific or database-specific, respectively.</source>
          <target state="translated">정의 된 구성 설정을 나열합니다. 이러한 설정은 역할 별, 데이터베이스 별 또는 둘 다일 수 있습니다. &lt;code&gt;role-pattern&lt;/code&gt; 및 &lt;code&gt;database-pattern&lt;/code&gt; 은 각각 나열 할 특정 역할 및 데이터베이스를 선택하는 데 사용됩니다. 생략하거나 &lt;code&gt;*&lt;/code&gt; 를 지정하면 역할 별 또는 데이터베이스 별이 아닌 설정을 포함하여 모든 설정이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="417307de73c4769c24d10a4a74f461c675665a71" translate="yes" xml:space="preserve">
          <source>Lists domains. If &lt;code&gt;pattern&lt;/code&gt; is specified, only domains whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description.</source>
          <target state="translated">도메인을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 도메인이 표시됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 권한 및 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="f274b8d8f8b448f365efc740c76106814f6e8672" translate="yes" xml:space="preserve">
          <source>Lists event triggers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those event triggers whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">이벤트 트리거를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 그 이벤트 트리거는 패턴이 나열됩니다 일치합니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="e79aeba25c72ede19da97f86bce69c0ff45f55b7" translate="yes" xml:space="preserve">
          <source>Lists foreign servers (mnemonic: &amp;ldquo;external servers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those servers whose name matches the pattern are listed. If the form &lt;code&gt;\des+&lt;/code&gt; is used, a full description of each server is shown, including the server's access privileges, type, version, options, and description.</source>
          <target state="translated">외부 서버를 나열합니다 (니모닉 : &quot;외부 서버&quot;). 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 해당 서버 이름이이 패턴이 표시됩니다 일치합니다. &lt;code&gt;\des+&lt;/code&gt; 형식을 사용하면 서버의 액세스 권한, 유형, 버전, 옵션 및 설명을 포함하여 각 서버에 대한 전체 설명이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="78b8f146a38943cc21434e0badfc06780b279a22" translate="yes" xml:space="preserve">
          <source>Lists foreign tables (mnemonic: &amp;ldquo;external tables&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose table name or schema name matches the pattern are listed. If the form &lt;code&gt;\det+&lt;/code&gt; is used, generic options and the foreign table description are also displayed.</source>
          <target state="translated">외부 테이블을 나열합니다 (니모닉 : &quot;외부 테이블&quot;). 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 그 테이블 이름이나 스키마 이름이 나열된 패턴과 일치하는 항목을 표시합니다. &lt;code&gt;\det+&lt;/code&gt; 형식을 사용하면 일반 옵션 및 외부 테이블 설명도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="841607b805a28257bffdea756495ef2cb699e228" translate="yes" xml:space="preserve">
          <source>Lists foreign-data wrappers (mnemonic: &amp;ldquo;external wrappers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those foreign-data wrappers whose name matches the pattern are listed. If the form &lt;code&gt;\dew+&lt;/code&gt; is used, the access privileges, options, and description of the foreign-data wrapper are also shown.</source>
          <target state="translated">외부 데이터 래퍼를 나열합니다 (니모닉 : &quot;외부 래퍼&quot;). 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우 만 외국 데이터 래퍼 이름이이 패턴이 표시됩니다 일치합니다. &lt;code&gt;\dew+&lt;/code&gt; 형식을 사용하면 외부 데이터 래퍼에 대한 액세스 권한, 옵션 및 설명도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c91d07a0e33c78c3a0a76bd7d8280b785bbd7664" translate="yes" xml:space="preserve">
          <source>Lists functions, together with their result data types, argument data types, and function types, which are classified as &amp;ldquo;agg&amp;rdquo; (aggregate), &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;procedure&amp;rdquo;, &amp;ldquo;trigger&amp;rdquo;, or &amp;ldquo;window&amp;rdquo;. To display only functions of specific type(s), add the corresponding letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; to the command. If &lt;code&gt;pattern&lt;/code&gt; is specified, only functions whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If the form &lt;code&gt;\df+&lt;/code&gt; is used, additional information about each function is shown, including volatility, parallel safety, owner, security classification, access privileges, language, source code and description.</source>
          <target state="translated">&amp;ldquo;agg&amp;rdquo;(집계),&amp;ldquo;normal&amp;rdquo;,&amp;ldquo;procedure&amp;rdquo;,&amp;ldquo;trigger&amp;rdquo;또는&amp;ldquo;window&amp;rdquo;로 분류 된 결과 데이터 유형, 인수 데이터 유형 및 함수 유형과 함께 함수를 나열합니다. 특정 유형의 기능 만 표시하려면 해당 문자 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;w&lt;/code&gt; 를 명령에 추가하십시오. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 기능이 표시됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 형태가 &lt;code&gt;\df+&lt;/code&gt; 휘발성, 병렬 안전, 소유자, 보안 분류, 액세스 권한, 언어, 소스 코드 및 설명을 포함하여 각 기능에 대한 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="24ae150e74e52548491a1b8532993c514778868d" translate="yes" xml:space="preserve">
          <source>Lists installed extensions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those extensions whose names match the pattern are listed. If the form &lt;code&gt;\dx+&lt;/code&gt; is used, all the objects belonging to each matching extension are listed.</source>
          <target state="translated">설치된 확장을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 그 확장 패턴이 나열됩니다 일치합니다. &lt;code&gt;\dx+&lt;/code&gt; 형식을 사용하면 일치하는 각 확장에 속하는 모든 개체가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="7b91d850ae0056bf60018b5ebefbaf56889e4bca" translate="yes" xml:space="preserve">
          <source>Lists operators with their operand and result types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only operators whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional information about each operator is shown, currently just the name of the underlying function.</source>
          <target state="translated">피연산자와 결과 유형으로 연산자를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 운영자가 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 연산자에 대한 자세한 정보는, 기본 함수의 현재 단지 이름을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="b6dce10f054bc4a066d94e91eb2653d58925f8ed" translate="yes" xml:space="preserve">
          <source>Lists partitioned relations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose name matches the pattern are listed. The modifiers &lt;code&gt;t&lt;/code&gt; (tables) and &lt;code&gt;i&lt;/code&gt; (indexes) can be appended to the command, filtering the kind of relations to list. By default, partitioned tables and indexes are listed.</source>
          <target state="translated">파티션 된 관계를 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 항목 만 나열됩니다. 수정 자 &lt;code&gt;t&lt;/code&gt; (테이블) 및 &lt;code&gt;i&lt;/code&gt; (인덱스)를 명령에 추가하여 목록에 대한 관계 종류를 필터링 할 수 있습니다. 기본적으로 파티션 된 테이블 및 인덱스가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="6639ac93b6964b1629641d3ad0795ccf6bdb89e2" translate="yes" xml:space="preserve">
          <source>Lists procedural languages. If &lt;code&gt;pattern&lt;/code&gt; is specified, only languages whose names match the pattern are listed. By default, only user-created languages are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each language is listed with its call handler, validator, access privileges, and whether it is a system object.</source>
          <target state="translated">절차 적 언어를 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 언어 만 나열됩니다. 기본적으로 사용자가 만든 언어 만 표시됩니다. 시스템 오브젝트를 포함 하도록 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오 . 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되어, 각 언어의 호출 핸들러, 검증, 접근 권한과 함께 나열하고는 시스템 개체가 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d159d89b43261dc04712aa39d984b98a29983107" translate="yes" xml:space="preserve">
          <source>Lists replication publications. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those publications whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the tables associated with each publication are shown as well.</source>
          <target state="translated">복제 게시를 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 발행물 만 나열됩니다. &lt;code&gt;+&lt;/code&gt; 가 명령 이름에 추가 되면 각 발행물과 연관된 테이블도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5edfb1ad4f7a1bcdc13378e73525d95e092cfe45" translate="yes" xml:space="preserve">
          <source>Lists replication subscriptions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those subscriptions whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional properties of the subscriptions are shown.</source>
          <target state="translated">복제 구독을 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 구독 만 나열됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 첨부되는 상기 구독 추가적인 특성이 도시되어있다.</target>
        </trans-unit>
        <trans-unit id="4fb239c1a080740cf10a3927b46a1262b5ea56d1" translate="yes" xml:space="preserve">
          <source>Lists schemas (namespaces). If &lt;code&gt;pattern&lt;/code&gt; is specified, only schemas whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description, if any.</source>
          <target state="translated">스키마 (네임 스페이스)를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 스키마가 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 권한 및 설명 (있는 경우)과 함께 표시된다.</target>
        </trans-unit>
        <trans-unit id="aaa2ebfeff5215f2bad04d9af2cdf2d89c158023" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">관련 액세스 권한이있는 테이블, 뷰 및 시퀀스를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 테이블, 뷰 및 이름이 패턴과 일치하는 나열되어 시퀀스.</target>
        </trans-unit>
        <trans-unit id="bb59616e451459bc316da05ad410acee2d59778b" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If a &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">관련 액세스 권한이있는 테이블, 뷰 및 시퀀스를 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 테이블, 뷰 및 시퀀스 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="ef7de3f6c539d5dd5da460845cd3a63bfcafc2bd" translate="yes" xml:space="preserve">
          <source>Lists tablespaces. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tablespaces whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each tablespace is listed with its associated options, on-disk size, permissions and description.</source>
          <target state="translated">테이블 스페이스를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 테이블이 표시됩니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되는 각 테이블 스페이스 관련 옵션이 나열되어, 온 디스크 크기, 권한 및 설명입니다.</target>
        </trans-unit>
        <trans-unit id="762f36a63dc0b6ce665e3c2131b6edc15a3446da" translate="yes" xml:space="preserve">
          <source>Lists text search configurations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only configurations whose names match the pattern are shown. If the form &lt;code&gt;\dF+&lt;/code&gt; is used, a full description of each configuration is shown, including the underlying text search parser and the dictionary list for each parser token type.</source>
          <target state="translated">텍스트 검색 구성을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 구성이 표시됩니다. &lt;code&gt;\dF+&lt;/code&gt; 형식을 사용하는 경우 기본 텍스트 검색 파서 및 각 파서 토큰 유형의 사전 목록을 포함하여 각 구성에 대한 자세한 설명이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f6bb868ceb84c3b85646ce544e1a8e93f3c169f4" translate="yes" xml:space="preserve">
          <source>Lists text search dictionaries. If &lt;code&gt;pattern&lt;/code&gt; is specified, only dictionaries whose names match the pattern are shown. If the form &lt;code&gt;\dFd+&lt;/code&gt; is used, additional information is shown about each selected dictionary, including the underlying text search template and the option values.</source>
          <target state="translated">텍스트 검색 사전을 나열합니다. &lt;code&gt;pattern&lt;/code&gt; 이 지정된 경우 이름이 패턴과 일치하는 사전 만 표시됩니다. &lt;code&gt;\dFd+&lt;/code&gt; 형식을 사용하면 기본 텍스트 검색 템플릿 및 옵션 값을 포함하여 선택한 각 사전에 대한 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ba01d174c5c6cab6bd3b44d816241b168a44d553" translate="yes" xml:space="preserve">
          <source>Lists text search parsers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only parsers whose names match the pattern are shown. If the form &lt;code&gt;\dFp+&lt;/code&gt; is used, a full description of each parser is shown, including the underlying functions and the list of recognized token types.</source>
          <target state="translated">텍스트 검색 파서를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 파서가 표시됩니다. &lt;code&gt;\dFp+&lt;/code&gt; 형식을 사용하면 기본 함수 및 인식 된 토큰 유형 목록을 포함하여 각 파서에 대한 전체 설명이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="80703d2e971d1dc8cd3056fab4357086f4708060" translate="yes" xml:space="preserve">
          <source>Lists text search templates. If &lt;code&gt;pattern&lt;/code&gt; is specified, only templates whose names match the pattern are shown. If the form &lt;code&gt;\dFt+&lt;/code&gt; is used, additional information is shown about each template, including the underlying function names.</source>
          <target state="translated">텍스트 검색 템플릿을 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정, 이름이 패턴과 일치하는 경우에만 템플릿이 표시됩니다. &lt;code&gt;\dFt+&lt;/code&gt; 형식을 사용하면 기본 함수 이름을 포함하여 각 템플릿에 대한 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a40588516c3a8604348670da0a879303a508a1" translate="yes" xml:space="preserve">
          <source>Lists type casts. If &lt;code&gt;pattern&lt;/code&gt; is specified, only casts whose source or target types match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">유형 캐스트를 나열합니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 그 원본 또는 대상 유형의 패턴과 일치하는 나열되어 있습니다 캐스트. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되고, 각각의 오브젝트는 그 연관된 설명과 함께 나열되어있다.</target>
        </trans-unit>
        <trans-unit id="b23bce00d2c7c8d6375ab0cd2ad7f38f1f799075" translate="yes" xml:space="preserve">
          <source>Lists user mappings (mnemonic: &amp;ldquo;external users&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those mappings whose user names match the pattern are listed. If the form &lt;code&gt;\deu+&lt;/code&gt; is used, additional information about each mapping is shown.</source>
          <target state="translated">사용자 매핑을 나열합니다 (니모닉 : &quot;외부 사용자&quot;). 경우 &lt;code&gt;pattern&lt;/code&gt; 지정되고, 그 사용자 이름 만 매핑 패턴이 나열됩니다 일치합니다. &lt;code&gt;\deu+&lt;/code&gt; 형식을 사용하면 각 매핑에 대한 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fee8c64f75222b953355d11e92e46cafb863f042" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the function should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">함수에 대한 호출을 변환하는 목록이 적용되어야합니다. 변환은 SQL 유형과 언어 별 데이터 유형 사이를 변환합니다. &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM을&lt;/a&gt; 참조하십시오 . 절차 적 언어 구현에는 일반적으로 내장 유형에 대한 하드 코딩 된 지식이 있으므로 여기에 나열 할 필요는 없습니다. 절차 적 언어 구현이 유형을 처리하는 방법을 모르고 변환이 제공되지 않으면 데이터 유형 변환을위한 기본 동작으로 대체되지만 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c221c51fd4371df729302cc73086e8359e205a42" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the procedure should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">프로 시저 호출을 변환하는 목록이 적용되어야합니다. 변환은 SQL 유형과 언어 별 데이터 유형 사이를 변환합니다. &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM을&lt;/a&gt; 참조하십시오 . 절차 적 언어 구현에는 일반적으로 내장 유형에 대한 하드 코딩 된 지식이 있으므로 여기에 나열 할 필요는 없습니다. 절차 적 언어 구현이 유형을 처리하는 방법을 모르고 변환이 제공되지 않으면 데이터 유형 변환을위한 기본 동작으로 대체되지만 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0c4bdf42add57a2eabb9fb37aeb6c28158bad4b3" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">리터럴 &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df214b5bbf763eb7922bad89d00442e94abbaf1f" translate="yes" xml:space="preserve">
          <source>Loading an extension essentially amounts to running the extension's script file. The script will typically create new SQL objects such as functions, data types, operators and index support methods. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; additionally records the identities of all the created objects, so that they can be dropped again if &lt;code&gt;DROP EXTENSION&lt;/code&gt; is issued.</source>
          <target state="translated">확장을로드하면 확장의 스크립트 파일을 실행해야합니다. 스크립트는 일반적으로 함수, 데이터 유형, 연산자 및 색인 지원 메소드와 같은 새 SQL 오브젝트를 작성합니다. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 은 추가로 작성된 모든 오브젝트의 ID를 기록하므로 &lt;code&gt;DROP EXTENSION&lt;/code&gt; 이 발행 될 때 다시 삭제할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
