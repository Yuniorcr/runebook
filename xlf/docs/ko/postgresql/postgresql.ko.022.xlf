<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="a096978b727394f0a665fb7212a971c3ee9889e1" translate="yes" xml:space="preserve">
          <source>The implemented SASL mechanisms at the moment are &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; and its variant with channel binding &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. They are described in detail in RFC 7677 and RFC 5802.</source>
          <target state="translated">현재 구현 된 SASL 메커니즘은 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 및 채널 바인딩 &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; 를 포함한 변형입니다 . RFC 7677 및 RFC 5802에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3994c1cc646c4ef5a61a7d412fe3e39d9a284414" translate="yes" xml:space="preserve">
          <source>The index access costs should be computed using the parameters used by &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt;: a sequential disk block fetch has cost &lt;code&gt;seq_page_cost&lt;/code&gt;, a nonsequential fetch has cost &lt;code&gt;random_page_cost&lt;/code&gt;, and the cost of processing one index row should usually be taken as &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt;. In addition, an appropriate multiple of &lt;code&gt;cpu_operator_cost&lt;/code&gt; should be charged for any comparison operators invoked during index processing (especially evaluation of the indexquals themselves).</source>
          <target state="translated">인덱스 액세스 비용에 의해 사용되는 파라미터를 사용하여 계산한다 &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt; : 순차 디스크 블록을 페치하면 비용 갖는다 &lt;code&gt;seq_page_cost&lt;/code&gt; 를 페치 비 순차 A는 선정 갖는다 &lt;code&gt;random_page_cost&lt;/code&gt; 를 , 하나 개의 인덱스 행 처리의 비용은 일반적으로해야 &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt; 로 간주하십시오 . 또한 인덱스 처리 중 호출 된 비교 연산자 (특히 인덱스 자체 평가)에 대해 적절한 &lt;code&gt;cpu_operator_cost&lt;/code&gt; 배수를 청구 해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fef8227d6c9875a9adfc4cf6467a2aea1121c60" translate="yes" xml:space="preserve">
          <source>The index access path being considered. All fields except cost and selectivity values are valid.</source>
          <target state="translated">고려중인 인덱스 액세스 경로 비용 및 선택성 값을 제외한 모든 필드가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="47ab406c0502c2ff0920580c5626f87c7d3ac514" translate="yes" xml:space="preserve">
          <source>The index automatically uses the collation of the underlying column. So a query of the form</source>
          <target state="translated">인덱스는 기본 열의 데이터 정렬을 자동으로 사용합니다. 그래서 형식의 쿼리</target>
        </trans-unit>
        <trans-unit id="d40d5a355329bb21744bf91012270d4b7eadd19f" translate="yes" xml:space="preserve">
          <source>The index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command.</source>
          <target state="translated">색인은 표현식 열을 포함하거나 부분 색인을 가질 수 없습니다. 또한 기본 정렬 순서를 가진 b- 트리 인덱스 여야합니다. 이 제한 사항은 색인이 일반 &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;ADD UNIQUE&lt;/code&gt; 명령으로 작성된 색인과 동등한 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="78493f3623537c9a38e59ae58540f722627b962f" translate="yes" xml:space="preserve">
          <source>The index construction and maintenance functions that an index access method must provide in &lt;code&gt;IndexAmRoutine&lt;/code&gt; are:</source>
          <target state="translated">인덱스 액세스 방법이 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 에서 제공해야하는 인덱스 구성 및 유지 보수 기능 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3039446ce33001ce11d9ef4cc9e239f9e80ff013" translate="yes" xml:space="preserve">
          <source>The index is being built by the access method-specific code. In this phase, access methods that support progress reporting fill in their own progress data, and the subphase is indicated in this column. Typically, &lt;code&gt;blocks_total&lt;/code&gt; and &lt;code&gt;blocks_done&lt;/code&gt; will contain progress data, as well as potentially &lt;code&gt;tuples_total&lt;/code&gt; and &lt;code&gt;tuples_done&lt;/code&gt;.</source>
          <target state="translated">인덱스는 액세스 방법 별 코드로 작성됩니다. 이 단계에서는 진행률보고를 지원하는 액세스 방법이 자체 진행 데이터를 채우고 하위 열이이 열에 표시됩니다. 일반적으로 &lt;code&gt;blocks_total&lt;/code&gt; 및 &lt;code&gt;blocks_done&lt;/code&gt; 에는 잠재적으로 &lt;code&gt;tuples_total&lt;/code&gt; 및 &lt;code&gt;tuples_done&lt;/code&gt; 뿐만 아니라 진행률 데이터도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8974784c29c6386bf1253069fdf16bf07fbf780" translate="yes" xml:space="preserve">
          <source>The index is created with a signature length of 80 bits, with attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4 bits. We could have omitted the &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;col1&lt;/code&gt;, and &lt;code&gt;col2&lt;/code&gt; specifications since those have the default values.</source>
          <target state="translated">인덱스는 서명 길이가 80 비트이고 속성 i1 및 i2가 2 비트에 매핑되고 속성 i3이 4 비트에 매핑되어 만들어집니다. &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;col1&lt;/code&gt; 및 &lt;code&gt;col2&lt;/code&gt; 스펙은 기본값을 가지므로 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f53b14842204c3afdf4a8da34fde71ed13d02632" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator class.</source>
          <target state="translated">연산자 클래스와 연관된 연산자의 색인 메소드 전략 번호입니다.</target>
        </trans-unit>
        <trans-unit id="62c3a3b1a4517180b23038b6d08f465908556b8b" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator family.</source>
          <target state="translated">운영자 제품군과 연관된 운영자에 대한 색인 메소드의 전략 번호입니다.</target>
        </trans-unit>
        <trans-unit id="4a128fb2d5e95c4a7976acace79bbc58b6fb276b" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator class.</source>
          <target state="translated">연산자 클래스와 연관된 함수에 대한 색인 메소드의 지원 함수 번호입니다.</target>
        </trans-unit>
        <trans-unit id="8c74967c2b0a4ae3a48c94ba4d59d1361af52eba" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator family.</source>
          <target state="translated">연산자 패밀리와 연관된 함수에 대한 색인 메소드의 지원 함수 번호입니다.</target>
        </trans-unit>
        <trans-unit id="dfbc9f2ec43f190a4f4b92d5261f2d63618ce86e" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the regular expression and then looking these up in the index. The more trigrams that can be extracted from the regular expression, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">인덱스 검색은 정규식에서 트라이 그램을 추출한 다음 인덱스에서 찾아 보는 방식으로 작동합니다. 정규식에서 추출 할 수있는 트라이 그램이 많을수록 인덱스 검색이 더 효과적입니다. B- 트리 기반 검색과 달리 검색 문자열을 고정 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="76d1075d790db56a70c52b9e9529c4e67b5fd660" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the search string and then looking these up in the index. The more trigrams in the search string, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">인덱스 검색은 검색 문자열에서 트라이 그램을 추출한 다음 인덱스에서 찾아 보는 방식으로 작동합니다. 검색 문자열에 트라이 그램이 많을수록 인덱스 검색이 더 효과적입니다. B- 트리 기반 검색과 달리 검색 문자열을 고정 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ef045e734746214c8ad4568acd243c24cf2fcf6" translate="yes" xml:space="preserve">
          <source>The index supporting a unique, primary key, referential integrity, or exclusion constraint</source>
          <target state="translated">고유 한 기본 키, 참조 무결성 또는 제외 제약 조건을 지원하는 인덱스</target>
        </trans-unit>
        <trans-unit id="b1f015828c180dda3ed4f3bdc55e0086cb7fcc71" translate="yes" xml:space="preserve">
          <source>The index supporting this constraint, if it's a unique, primary key, foreign key, or exclusion constraint; else 0</source>
          <target state="translated">고유, 기본 키, 외래 키 또는 제외 제약 조건 인 경우이 제약 조건을 지원하는 인덱스입니다. 그렇지 않으면 0</target>
        </trans-unit>
        <trans-unit id="6c3b8559bb8c83cd05e198719da39b30d3fb1043" translate="yes" xml:space="preserve">
          <source>The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value.</source>
          <target state="translated">인덱스 유형은 인덱스 전용 스캔을 지원해야합니다. B- 트리 인덱스는 항상 그렇습니다. GiST 및 SP-GiST 인덱스는 일부 연산자 클래스에 대해서는 인덱스 전용 스캔을 지원하지만 다른 연산자 클래스는 지원하지 않습니다. 다른 인덱스 유형은 지원되지 않습니다. 기본 요구 사항은 인덱스가 각 인덱스 항목의 원래 데이터 값을 실제로 저장하거나 재구성 할 수 있어야한다는 것입니다. 반례로서, GIN 색인은 각 색인 항목이 일반적으로 원래 데이터 값의 일부만 보유하므로 색인 전용 스캔을 지원할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6836c640c52510a0b02e594ca8bbfc9b8103067" translate="yes" xml:space="preserve">
          <source>The indicated database user name was not found.</source>
          <target state="translated">표시된 데이터베이스 사용자 이름을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20e3988dff010547d05b25cba96f92a2ac547dbd" translate="yes" xml:space="preserve">
          <source>The individual elements of a &lt;code&gt;CUBE&lt;/code&gt; or &lt;code&gt;ROLLUP&lt;/code&gt; clause may be either individual expressions, or sublists of elements in parentheses. In the latter case, the sublists are treated as single units for the purposes of generating the individual grouping sets. For example:</source>
          <target state="translated">&lt;code&gt;CUBE&lt;/code&gt; 또는 &lt;code&gt;ROLLUP&lt;/code&gt; 절의 개별 요소는 개별 표현식이거나 괄호 안에있는 요소의 서브리스트 일 수 있습니다. 후자의 경우, 서브 그룹은 개별 그룹화 세트를 생성하기 위해 단일 단위로 취급됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="478f53ba771627a25e2c5229ba6d54c52bd271c5" translate="yes" xml:space="preserve">
          <source>The individual tables can be added and removed dynamically using &lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;. Both the &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; operations are transactional; so the table will start or stop replicating at the correct snapshot once the transaction has committed.</source>
          <target state="translated">&lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION을&lt;/a&gt; 사용하여 개별 테이블을 동적으로 추가 및 제거 할 수 있습니다 . 모두 &lt;code&gt;ADD TABLE&lt;/code&gt; 및 &lt;code&gt;DROP TABLE&lt;/code&gt; 의 작업은 트랜잭션이다; 트랜잭션이 커밋되면 테이블이 올바른 스냅 샷에서 복제를 시작하거나 중지합니다.</target>
        </trans-unit>
        <trans-unit id="55f0b3e0f4002ca62cb368b92a46147d06514b6c" translate="yes" xml:space="preserve">
          <source>The information passed to the client for a notification event includes the notification channel name, the notifying session's server process PID, and the payload string, which is an empty string if it has not been specified.</source>
          <target state="translated">알림 이벤트를 위해 클라이언트에 전달 된 정보에는 알림 채널 이름, 알림 세션의 서버 프로세스 PID 및 페이로드 문자열 (지정되지 않은 경우 빈 문자열)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="044f2cd515098f5f363f2857b2c2afc07209265a" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="translated">정보 스키마 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;36 장&lt;/a&gt; )는 시스템보기의 기능과 겹치는 대체보기 세트를 제공합니다. 정보 스키마는 SQL 표준이지만 여기에 설명 된보기는 PostgreSQL에 따라 다르므로 필요한 정보를 모두 제공하는 경우 정보 스키마를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0c18c9f5485d75a93a8e5be63c2bfb9df98cb595" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="translated">정보 스키마 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;36 장&lt;/a&gt; )는 시스템보기의 기능과 겹치는 대체보기 집합을 제공합니다. 정보 스키마는 SQL 표준 인 반면 여기에 설명 된 뷰는 PostgreSQL 전용이므로 필요한 모든 정보를 제공하는 경우 일반적으로 정보 스키마를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1f201ea8f38230c6e8acfb095bb89803ef41bb1b" translate="yes" xml:space="preserve">
          <source>The information to implement this module was collected from several sites, including:</source>
          <target state="translated">이 모듈을 구현하기위한 정보는 다음을 포함한 여러 사이트에서 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ffbbc2df15378d40a94e42b70d5fb5af1458af3" translate="yes" xml:space="preserve">
          <source>The initial access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">초기 액세스 권한 자세한 내용 &lt;a href=&quot;ddl-priv&quot;&gt;은 5.7 절&lt;/a&gt; 을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="8a1054b1ac592ae44e2cf9b51ca38fb26634ef49" translate="yes" xml:space="preserve">
          <source>The initial data in existing subscribed tables are snapshotted and copied in a parallel instance of a special kind of apply process. This process will create its own temporary replication slot and copy the existing data. Once existing data is copied, the worker enters synchronization mode, which ensures that the table is brought up to a synchronized state with the main apply process by streaming any changes that happened during the initial data copy using standard logical replication. Once the synchronization is done, the control of the replication of the table is given back to the main apply process where the replication continues as normal.</source>
          <target state="translated">기존의 가입 된 테이블의 초기 데이터는 특별한 종류의 적용 프로세스의 병렬 인스턴스에서 스냅 샷되고 복사됩니다. 이 프로세스는 자체 임시 복제 슬롯을 생성하고 기존 데이터를 복사합니다. 기존 데이터가 복사되면 작업자는 동기화 모드로 전환되어 표준 논리 복제를 사용하여 초기 데이터 복사 중에 발생한 모든 변경 사항을 스트리밍하여 테이블이 기본 적용 프로세스와 동기화 된 상태가되도록합니다. 동기화가 완료되면 테이블 복제 제어는 복제가 정상적으로 계속되는 기본 적용 프로세스로 다시 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="257568e0871ee2fb3ae1bd84f534adce4db0bec5" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value, when using moving-aggregate mode. This works the same as &lt;code&gt;initial_condition&lt;/code&gt;.</source>
          <target state="translated">이동 집계 모드를 사용할 때 상태 값의 초기 설정입니다. 이것은 &lt;code&gt;initial_condition&lt;/code&gt; 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="eb62c8458668a0689948660586a0f8259374a819" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value. This must be a string constant in the form accepted for the data type &lt;code&gt;state_data_type&lt;/code&gt;. If not specified, the state value starts out null.</source>
          <target state="translated">상태 값의 초기 설정입니다. &lt;code&gt;state_data_type&lt;/code&gt; 데이터 유형에 허용되는 형식의 문자열 상수 여야합니다 . 지정하지 않으면 상태 값이 null로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d82c96a461d121c75c52d8ce64285a1d86e2ab14" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state for moving-aggregate mode. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">이동 집계 모드에 대한 전환 상태의 초기 값입니다. 외부 문자열 표현의 초기 값을 포함하는 텍스트 필드입니다. 이 필드가 널인 경우, 전이 상태 값은 널로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="dfef147dfd625c38da29727096d66edbe7450de5" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">전환 상태의 초기 값입니다. 외부 문자열 표현의 초기 값을 포함하는 텍스트 필드입니다. 이 필드가 널인 경우, 전이 상태 값은 널로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6e8d9c8e49727d756d0711797450f963975e284e" translate="yes" xml:space="preserve">
          <source>The initially assigned data type of a numeric constant is just a starting point for the type resolution algorithms. In most cases the constant will be automatically coerced to the most appropriate type depending on context. When necessary, you can force a numeric value to be interpreted as a specific data type by casting it. For example, you can force a numeric value to be treated as type &lt;code&gt;real&lt;/code&gt; (&lt;code&gt;float4&lt;/code&gt;) by writing:</source>
          <target state="translated">숫자 상수의 초기에 할당 된 데이터 유형은 유형 분석 알고리즘의 시작점 일뿐입니다. 대부분의 경우 상수는 상황에 따라 가장 적합한 유형으로 자동 강제됩니다. 필요한 경우 숫자 값을 캐스트하여 특정 데이터 유형으로 해석하도록 할 수 있습니다. 예를 들어 다음과 같이 작성하여 숫자 값을 &lt;code&gt;real&lt;/code&gt; 유형 ( &lt;code&gt;float4&lt;/code&gt; ) 으로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4532069877c3839fd18c7cafdf1b166d436f334" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;UNION&lt;/code&gt; is resolved as emitting type &lt;code&gt;text&lt;/code&gt;, according to the rules given above. Then the outer &lt;code&gt;UNION&lt;/code&gt; has inputs of types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;, leading to the observed error. The problem can be fixed by ensuring that the leftmost &lt;code&gt;UNION&lt;/code&gt; has at least one input of the desired result type.</source>
          <target state="translated">내부 &lt;code&gt;UNION&lt;/code&gt; 은 위에 주어진 규칙에 따라 방출 유형 &lt;code&gt;text&lt;/code&gt; 로 해석됩니다 . 그런 다음 외부 &lt;code&gt;UNION&lt;/code&gt; 에는 &lt;code&gt;text&lt;/code&gt; 및 &lt;code&gt;integer&lt;/code&gt; 유형의 입력이 있으므로 관찰 된 오류가 발생합니다. 맨 왼쪽 &lt;code&gt;UNION&lt;/code&gt; 에 원하는 결과 유형의 입력이 하나 이상 있는지 확인하여 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="752b1c95a1eae331cb7a120fbc2cbc7b360efa2f" translate="yes" xml:space="preserve">
          <source>The input for a range value must follow one of the following patterns:</source>
          <target state="translated">범위 값의 입력은 다음 패턴 중 하나를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="5db960d2928db992e514ea865af6ec0e73cf5806" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is missing, the netmask is 32 for IPv4 and 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="translated">이 유형의 입력 형식은 &lt;code&gt;address/y&lt;/code&gt; 입니다. 여기서 &lt;code&gt;address&lt;/code&gt; 는 IPv4 또는 IPv6 주소이고 &lt;code&gt;y&lt;/code&gt; 는 넷 마스크의 비트 수입니다. 는 IF &lt;code&gt;/y&lt;/code&gt; 부분 누락 값이 단지 하나의 호스트를 나타내고 있으므로, 넷 마스크하고 IPv4와 IPv6 대 32 대 128이다. 디스플레이에서 &lt;code&gt;/y&lt;/code&gt; 넷 마스크가 단일 호스트를 지정하면 부분이 억제된다.</target>
        </trans-unit>
        <trans-unit id="a8be18b330a3d96f66997a77713b943e9dcae523" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is omitted, the netmask is taken to be 32 for IPv4 or 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="translated">이 유형의 입력 형식은 &lt;code&gt;address/y&lt;/code&gt; 입니다. 여기서 &lt;code&gt;address&lt;/code&gt; 는 IPv4 또는 IPv6 주소이고 &lt;code&gt;y&lt;/code&gt; 는 넷 마스크의 비트 수입니다. 는 IF &lt;code&gt;/y&lt;/code&gt; 부분은 생략 값이 단지 하나의 호스트를 나타내고 있으므로, 넷 마스크는 IPv6의 IPv4의 32 또는 128으로 취해진 다. 디스플레이 에서 넷 마스크가 단일 호스트를 지정하면 &lt;code&gt;/y&lt;/code&gt; 부분이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1496dddf6a6d3aece3a51059d08e155ea1323eea" translate="yes" xml:space="preserve">
          <source>The input/output syntax for the JSON data types is as specified in RFC 7159.</source>
          <target state="translated">JSON 데이터 유형의 입력 / 출력 구문은 RFC 7159에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b76175a8e4e44a6929b2bbc612975f4e90fb8f" translate="yes" xml:space="preserve">
          <source>The instance handles all key features of a DBMS: read and write access to files and shared memory, assurance of the ACID properties, &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connections&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt;, privilege verification, crash recovery, replication, etc.</source>
          <target state="translated">인스턴스 처리하는 DBMS의 모든 주요 기능 : 읽기 및 파일에 대한 쓰기 액세스와 ACID 속성의 메모리, 확신을 공유, &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;연결&lt;/a&gt; 에 &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;클라이언트 프로세스&lt;/a&gt; , 권한 검증, 응급 복구, 복제 등</target>
        </trans-unit>
        <trans-unit id="03aa7e8fbd88e7f3d34658426c4782d01d3a8689" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="translated">&lt;code&gt;pause&lt;/code&gt; 설정 의 용도 는 데이터베이스에 대해 조회를 실행하여이 복구 대상이 복구에 가장 바람직한 지점인지 확인하는 것입니다. 일시 중지 된 상태는 &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; ( &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;표 9.86&lt;/a&gt; 참조 ) 을 사용하여 재개 할 수 있으며 , 이로 인해 복구가 종료됩니다. 이 복구 대상이 원하는 중지 지점이 아닌 경우 서버를 종료하고 복구 대상 설정을 이후 대상으로 변경 한 후 다시 시작하여 복구를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="1eb808aeb9bcf9fecdcdeaa1957208268bb0812e" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="translated">&lt;code&gt;pause&lt;/code&gt; 설정 의 용도 는 데이터베이스에 대해 쿼리를 실행하여이 복구 대상이 복구에 가장 바람직한 지점인지 확인하는 것입니다. 일시 중지 된 상태는 &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; 을 사용하여 재개 할 수 있으며 ( &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;표 9.87&lt;/a&gt; 참조 ) 그러면 복구가 종료됩니다. 이 복구 대상이 원하는 중지 지점이 아닌 경우 서버를 종료하고 복구 대상 설정을 이후 대상으로 변경 한 다음 다시 시작하여 복구를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="eae9a7b2978d9149a7d3a255f37f5ad888745278" translate="yes" xml:space="preserve">
          <source>The intended use of this setting is that logical replication systems set it to &lt;code&gt;replica&lt;/code&gt; when they are applying replicated changes. The effect of that will be that triggers and rules (that have not been altered from their default configuration) will not fire on the replica. See the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; clauses &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; and &lt;code&gt;ENABLE RULE&lt;/code&gt; for more information.</source>
          <target state="translated">이 설정의 사용 목적은 논리적 복제 시스템으로 설정한다는 것이다 &lt;code&gt;replica&lt;/code&gt; 가 복제 된 변경 사항을 적용 할 때. 그 결과 기본 구성에서 변경되지 않은 트리거 및 규칙이 복제본에서 실행되지 않습니다. 자세한 정보는 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 절 &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; 및 &lt;code&gt;ENABLE RULE&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e73e54c88ad65514d99a46ba805b5445c9c890d2" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow administrators to reduce the I/O impact of these commands on concurrent database activity. There are many situations where it is not important that maintenance commands like &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; finish quickly; however, it is usually very important that these commands do not significantly interfere with the ability of the system to perform other database operations. Cost-based vacuum delay provides a way for administrators to achieve this.</source>
          <target state="translated">이 기능의 목적은 관리자가 동시 데이터베이스 활동에 대한 이러한 명령의 I / O 영향을 줄일 수 있도록하는 것입니다. &lt;code&gt;VACUUM&lt;/code&gt; 및 &lt;code&gt;ANALYZE&lt;/code&gt; 와 같은 유지 관리 명령이 빨리 끝나는 것이 중요하지 않은 상황이 많이 있습니다. 그러나 일반적으로 이러한 명령이 시스템이 다른 데이터베이스 작업을 수행하는 기능을 크게 방해하지 않는 것이 매우 중요합니다. 비용 기반 진공 지연은 관리자가이를 달성 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3ce7c282b1076520793e0399674bfd41329343fd" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow debugging or performance-measurement libraries to be loaded into specific sessions without an explicit &lt;code&gt;LOAD&lt;/code&gt; command being given. For example, &lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt; could be enabled for all sessions under a given user name by setting this parameter with &lt;code&gt;ALTER ROLE SET&lt;/code&gt;. Also, this parameter can be changed without restarting the server (but changes only take effect when a new session is started), so it is easier to add new modules this way, even if they should apply to all sessions.</source>
          <target state="translated">이 기능의 목적은 명시적인 &lt;code&gt;LOAD&lt;/code&gt; 명령을 제공 하지 않고 디버깅 또는 성능 측정 라이브러리를 특정 세션에로드 할 수 있도록하는 것입니다. 예를 들어, &lt;code&gt;ALTER ROLE SET&lt;/code&gt; 로이 매개 변수를 설정하여 지정된 사용자 이름으로 모든 세션에 대해 &lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt; 을 사용할 수 있습니다 . 또한이 매개 변수는 서버를 다시 시작하지 않고 변경할 수 있지만 변경 사항은 새 세션이 시작될 때만 적용되므로 모든 세션에 적용해야하더라도이 방법으로 새 ​​모듈을 추가하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a2719b729cd7a399352ec70d46ec3bef1938f299" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow unprivileged users to load debugging or performance-measurement libraries into specific sessions without requiring an explicit &lt;code&gt;LOAD&lt;/code&gt; command. To that end, it would be typical to set this parameter using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable on the client or by using &lt;code&gt;ALTER ROLE SET&lt;/code&gt;.</source>
          <target state="translated">이 기능의 목적은 권한이없는 사용자가 명시적인 &lt;code&gt;LOAD&lt;/code&gt; 명령 없이 디버깅 또는 성능 측정 라이브러리를 특정 세션에로드 할 수 있도록하는 것 입니다. 이를 위해 클라이언트 에서 &lt;code&gt;PGOPTIONS&lt;/code&gt; 환경 변수를 사용하거나 &lt;code&gt;ALTER ROLE SET&lt;/code&gt; 을 사용 하여이 매개 변수를 설정하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="410143821cb3667d869f89c45a8792b1a3405b2c" translate="yes" xml:space="preserve">
          <source>The interface was changed in version 8.4, to reflect the new FSM implementation introduced in the same version.</source>
          <target state="translated">동일한 버전에서 도입 된 새로운 FSM 구현을 반영하기 위해 버전 8.4에서 인터페이스가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="e6f5b2286acbba014ef24a9c86063e430de3bd3b" translate="yes" xml:space="preserve">
          <source>The internal representation of one value of an SQL data type.</source>
          <target state="translated">SQL 데이터 유형의 한 값에 대한 내부 표현입니다.</target>
        </trans-unit>
        <trans-unit id="2585564a6c8456926cf3442c468ac844142dcda1" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type (&lt;code&gt;xid&lt;/code&gt;) is 32 bits wide and wraps around every 4 billion transactions. However, these functions export a 64-bit format that is extended with an &amp;ldquo;epoch&amp;rdquo; counter so it will not wrap around during the life of an installation. The data type used by these functions, &lt;code&gt;txid_snapshot&lt;/code&gt;, stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;.</source>
          <target state="translated">내부 트랜잭션 ID 유형 ( &lt;code&gt;xid&lt;/code&gt; )은 32 비트 너비이며 40 억 건마다 처리됩니다. 그러나 이러한 기능은 &quot;에포크 (epoch)&quot;카운터로 확장 된 64 비트 형식을 내보내므로 설치 기간 동안 줄 바꿈되지 않습니다. 이 함수가 사용하는 데이터 유형 인 &lt;code&gt;txid_snapshot&lt;/code&gt; 은 특정 시점에 트랜잭션 ID 가시성에 대한 정보를 저장합니다. 구성 요소는 &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;표 9.75에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5975b3720301fef7c0533cfc1f13765af09e30a8" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type &lt;code&gt;xid&lt;/code&gt; is 32 bits wide and wraps around every 4 billion transactions. However, the functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; use a 64-bit type &lt;code&gt;xid8&lt;/code&gt; that does not wrap around during the life of an installation, and can be converted to &lt;code&gt;xid&lt;/code&gt; by casting if required. The data type &lt;code&gt;pg_snapshot&lt;/code&gt; stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;. &lt;code&gt;pg_snapshot&lt;/code&gt;'s textual representation is &lt;code&gt;xmin:xmax:xip_list&lt;/code&gt;. For example &lt;code&gt;10:20:10,14,15&lt;/code&gt; means &lt;code&gt;xmin=10, xmax=20, xip_list=10, 14, 15&lt;/code&gt;.</source>
          <target state="translated">내부 트랜잭션 ID 유형 &lt;code&gt;xid&lt;/code&gt; 는 32 비트 폭이며 40 억 트랜잭션마다 랩핑합니다. 그러나 &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;표 9.74에&lt;/a&gt; 표시된 기능 은 설치 기간 동안 랩핑되지 않는 64 비트 유형 &lt;code&gt;xid8&lt;/code&gt; 을 사용하며 필요한 경우 캐스트 를 통해 &lt;code&gt;xid&lt;/code&gt; 로 변환 할 수 있습니다 . 데이터 유형 &lt;code&gt;pg_snapshot&lt;/code&gt; 은 특정 시점의 트랜잭션 ID 가시성에 대한 정보를 저장합니다. 해당 구성 요소는 &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT-PARTS&quot;&gt;표 9.75에&lt;/a&gt; 설명되어 있습니다. &lt;code&gt;pg_snapshot&lt;/code&gt; 의 텍스트 표현은 &lt;code&gt;xmin:xmax:xip_list&lt;/code&gt; 입니다. 예를 들어 &lt;code&gt;10:20:10,14,15&lt;/code&gt; 는 &lt;code&gt;xmin=10, xmax=20, xip_list=10, 14, 15&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ed88f1a587353da5320c94618461fa62d026126f" translate="yes" xml:space="preserve">
          <source>The inverse operation, producing a character string value from &lt;code&gt;xml&lt;/code&gt;, uses the function &lt;code&gt;xmlserialize&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 에서 문자열 값을 생성하는 역 연산 은 &lt;code&gt;xmlserialize&lt;/code&gt; 함수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7d6e11429a0e8345e13107b3c0d526111bff86da" translate="yes" xml:space="preserve">
          <source>The isolation level of a transaction determines what data the transaction can see when other transactions are running concurrently:</source>
          <target state="translated">트랜잭션의 격리 수준에 따라 다른 트랜잭션이 동시에 실행될 때 트랜잭션이 볼 수있는 데이터가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e2ee987ab1ca440434d3e02dd908e8550d18dae5" translate="yes" xml:space="preserve">
          <source>The items themselves are stored in space allocated backwards from the end of unallocated space. The exact structure varies depending on what the table is to contain. Tables and sequences both use a structure named &lt;code&gt;HeapTupleHeaderData&lt;/code&gt;, described below.</source>
          <target state="translated">항목 자체는 할당되지 않은 공간의 끝에서 뒤로 할당 된 공간에 저장됩니다. 정확한 구조는 테이블에 포함 할 내용에 따라 다릅니다. 테이블과 시퀀스는 모두 아래에 설명 된 &lt;code&gt;HeapTupleHeaderData&lt;/code&gt; 라는 구조를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="e475eb2d988c6851551d574040f066c9556a439f" translate="yes" xml:space="preserve">
          <source>The join condition of an inner join can be written either in the &lt;code&gt;WHERE&lt;/code&gt; clause or in the &lt;code&gt;JOIN&lt;/code&gt; clause. For example, these table expressions are equivalent:</source>
          <target state="translated">내부 조인의 조인 조건은 &lt;code&gt;WHERE&lt;/code&gt; 절 또는 &lt;code&gt;JOIN&lt;/code&gt; 절 에 기록 될 수 있습니다 . 예를 들어, 다음 테이블 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="61d61ab7e2b00d48bd33fdcfe38f2676100e3a4c" translate="yes" xml:space="preserve">
          <source>The join condition specified with &lt;code&gt;ON&lt;/code&gt; can also contain conditions that do not relate directly to the join. This can prove useful for some queries but needs to be thought out carefully. For example:</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; 으로 지정된 조인 조건 에는 조인과 직접 관련되지 않은 조건도 포함될 수 있습니다. 이것은 일부 쿼리에 유용 할 수 있지만 신중하게 고려해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3614aab2546a7b09e20ddc9fc01ce0160043ffc8" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator.</source>
          <target state="translated">이 연산자에 대한 결합 선택성 추정 기능.</target>
        </trans-unit>
        <trans-unit id="d643834432c9495e055ac02fd710963d0e899ceb" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">이 연산자에 대한 결합 선택성 추정 기능. 기존 선택성 추정기를 제거하려면 NONE을 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="105b61ba49be801d77c8efa5f2d2e79da5107648" translate="yes" xml:space="preserve">
          <source>The journal that keeps track of the changes in the &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; as user- and system-invoked operations take place. It comprises many individual &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; written sequentially to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</source>
          <target state="translated">사용자 및 시스템 호출 작업이 발생할 때 &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;데이터베이스 클러스터&lt;/a&gt; 의 변경 사항을 추적하는 저널입니다 . &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL 파일에&lt;/a&gt; 순차적으로 &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;기록 된&lt;/a&gt; 많은 개별 WAL 레코드 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e444824ca1c6f24ef2a354622bc8815bf038f6fd" translate="yes" xml:space="preserve">
          <source>The key and parent-key fields can be any data type, but they must be the same type. Note that the &lt;em&gt;&lt;code&gt;start_with&lt;/code&gt;&lt;/em&gt; value must be entered as a text string, regardless of the type of the key field.</source>
          <target state="translated">키 및 상위 키 필드는 모든 데이터 유형이 될 수 있지만 동일한 유형이어야합니다. 있습니다 &lt;em&gt; &lt;code&gt;start_with&lt;/code&gt; 의&lt;/em&gt; 값에 관계없이 키 필드의 유형, 텍스트 문자열로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ed049b1b7aaa3ba51ad6c118d926aadc8da74a8" translate="yes" xml:space="preserve">
          <source>The key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses. Multiple fields can be specified if the index method supports multicolumn indexes.</source>
          <target state="translated">인덱스의 키 필드는 열 이름으로 지정되거나 괄호 안에 쓰여진 표현식으로 지정됩니다. index 메소드가 다중 컬럼 인덱스를 지원하는 경우 다중 필드를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d640126eef92261555823243becabed1414b9599" translate="yes" xml:space="preserve">
          <source>The key part of a catalog header file is a C structure definition describing the layout of each row of the catalog. This begins with a &lt;code&gt;CATALOG&lt;/code&gt; macro, which so far as the C compiler is concerned is just shorthand for &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt;. Each field in the struct gives rise to a catalog column. Fields can be annotated using the BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, for example to define a default value for a field or mark it as nullable or not nullable. The &lt;code&gt;CATALOG&lt;/code&gt; line can also be annotated, with some other BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, to define other properties of the catalog as a whole, such as whether it is a shared relation.</source>
          <target state="translated">카탈로그 헤더 파일의 주요 부분은 카탈로그의 각 행의 레이아웃을 설명하는 C 구조 정의입니다. 이것은 &lt;code&gt;CATALOG&lt;/code&gt; 매크로로 시작 하는데, C 컴파일러에 관한 한 &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt; 의 줄임말입니다 . 구조체의 각 필드는 카탈로그 열을 발생시킵니다. &lt;code&gt;genbki.h&lt;/code&gt; 에 설명 된 BKI 속성 매크로를 사용하여 필드에 주석을 달 수 있습니다 ( 예 : 필드의 기본값을 정의하거나 널 입력 가능 또는 널 입력 불가능으로 표시). &lt;code&gt;CATALOG&lt;/code&gt; 광고도에 기재된 다른 BKI 속성 매크로, 주석 될 수 &lt;code&gt;genbki.h&lt;/code&gt; 등이 공유 관계인지 같이 전체 카탈로그의 다른 속성을 정의.</target>
        </trans-unit>
        <trans-unit id="84768082ee997613deb3f74ec096a132ad1ca977" translate="yes" xml:space="preserve">
          <source>The key part of all this is to set up a recovery configuration that describes how you want to recover and how far the recovery should run. The one thing that you absolutely must specify is the &lt;code&gt;restore_command&lt;/code&gt;, which tells PostgreSQL how to retrieve archived WAL file segments. Like the &lt;code&gt;archive_command&lt;/code&gt;, this is a shell command string. It can contain &lt;code&gt;%f&lt;/code&gt;, which is replaced by the name of the desired log file, and &lt;code&gt;%p&lt;/code&gt;, which is replaced by the path name to copy the log file to. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Write &lt;code&gt;%%&lt;/code&gt; if you need to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. The simplest useful command is something like:</source>
          <target state="translated">이 모든 것의 핵심은 복구 방법과 복구 실행 거리를 설명하는 복구 구성을 설정하는 것입니다. 절대적으로 지정해야하는 것은 &lt;code&gt;restore_command&lt;/code&gt; 입니다 . PostgreSQL은 아카이브 된 WAL 파일 세그먼트를 검색하는 방법을 알려줍니다. &lt;code&gt;archive_command&lt;/code&gt; 와 마찬가지로 이것은 쉘 명령 문자열입니다. 여기에는 원하는 로그 파일 이름으로 대체되는 &lt;code&gt;%f&lt;/code&gt; 와 로그 파일 을 복사 할 경로 이름으로 대체되는 &lt;code&gt;%p&lt;/code&gt; 가 포함될 수 있습니다 . (경로 이름은 현재 작업 디렉토리, 즉 클러스터의 데이터 디렉토리와 관련이 있습니다.) 명령에 실제 &lt;code&gt;%&lt;/code&gt; 문자 를 포함해야하는 경우 &lt;code&gt;%%&lt;/code&gt; 를 쓰십시오 . 가장 간단한 유용한 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ce0e2cb46720b77226f610a445bda26007f0b40" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;COLUMN&lt;/code&gt; is noise and can be omitted.</source>
          <target state="translated">키워드 &lt;code&gt;COLUMN&lt;/code&gt; 은 노이즈이므로 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b5ac0f06c70f1fb5409349bf24004b2a55d2f18" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not only external ones.</source>
          <target state="translated">키워드 &lt;code&gt;EXTERNAL&lt;/code&gt; 은 SQL 준수에 허용되지만 SQL과 달리이 기능은 외부 기능뿐만 아니라 모든 기능에 적용되므로 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7b66b886be54f4dad1fc59336fb968283aedd583" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all procedures not only external ones.</source>
          <target state="translated">키워드 &lt;code&gt;EXTERNAL&lt;/code&gt; 은 SQL 준수에 허용되지만 SQL과 달리이 기능은 외부 프로 시저뿐만 아니라 모든 프로 시저에 적용되므로 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="f14ab28890a5b7ef2546dae62a05463965282a2c" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ILIKE&lt;/code&gt; can be used instead of &lt;code&gt;LIKE&lt;/code&gt; to make the match case-insensitive according to the active locale. This is not in the SQL standard but is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 대신 키워드 &lt;code&gt;ILIKE&lt;/code&gt; 를 사용 하여 활성 로케일에 따라 대소 문자를 구분하지 않습니다. 이것은 SQL 표준이 아니지만 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="56bcc837725f3c99bfbefa9f4ad797df653bb446" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;PUBLIC&lt;/code&gt; indicates that the privileges are to be granted to all roles, including those that might be created later. &lt;code&gt;PUBLIC&lt;/code&gt; can be thought of as an implicitly defined group that always includes all roles. Any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;PUBLIC&lt;/code&gt; 은 나중에 작성 될 수있는 역할을 포함하여 모든 역할에 권한이 부여됨을 나타냅니다. &lt;code&gt;PUBLIC&lt;/code&gt; 은 항상 모든 역할을 포함하는 암시 적으로 정의 된 그룹으로 생각할 수 있습니다. 특정 역할에는 직접 부여 된 권한, 현재 구성원 인 모든 역할에 부여 된 권한 및 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 된 권한의 합계가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="099dc57512200b2d79974967fc17d8da0e67f388" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ROW&lt;/code&gt; is optional when there is more than one expression in the list.</source>
          <target state="translated">키워드 &lt;code&gt;ROW&lt;/code&gt; 는 목록에 둘 이상의 표현식이있는 경우 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="f75dcd3d9f2023dad0df5e4baecf4f11764e4ecf" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;INSENSITIVE&lt;/code&gt;, and &lt;code&gt;SCROLL&lt;/code&gt; can appear in any order.</source>
          <target state="translated">키워드 &lt;code&gt;BINARY&lt;/code&gt; , &lt;code&gt;INSENSITIVE&lt;/code&gt; 및 &lt;code&gt;SCROLL&lt;/code&gt; 은 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933ba0b83729a47d657b68dbaf9310c7b7c42eff" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are the preferred (SQL-compliant) method for writing Boolean constants in SQL queries. But you can also use the string representations by following the generic string-literal constant syntax described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;, for example &lt;code&gt;'yes'::boolean&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;TRUE&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; 는 SQL 쿼리에서 부울 상수를 작성하는 데 선호되는 (SQL 호환) 방법입니다. 그러나 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;4.1.2.7 절에&lt;/a&gt; 설명 된 일반 문자열 리터럴 상수 구문 ( 예 : &lt;code&gt;'yes'::boolean&lt;/code&gt; )에 따라 문자열 표현을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="301ce5b56290e04645decb19cd60fcc9e64d775e" translate="yes" xml:space="preserve">
          <source>The keytab file is generated by the Kerberos software; see the Kerberos documentation for details. The following example is for MIT-compatible Kerberos 5 implementations:</source>
          <target state="translated">키탭 파일은 Kerberos 소프트웨어에 의해 생성됩니다. 자세한 내용은 Kerberos 설명서를 참조하십시오. 다음 예제는 MIT 호환 Kerberos 5 구현을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="77aaa5ebf06bbbd98db8e2f5ba28cce520375eb5" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;ANY&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt;&lt;code&gt;num_sync&lt;/code&gt; listed standbys. For example, a setting of &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to proceed as soon as at least any three standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; reply.</source>
          <target state="translated">키워드 &lt;code&gt;ANY&lt;/code&gt; 는 &lt;code&gt;num_sync&lt;/code&gt; 와 함께 쿼럼 기반 동기 복제를 지정하고 WAL 레코드가 &lt;em&gt;최소한 &lt;/em&gt; &lt;code&gt;num_sync&lt;/code&gt; 로 나열된 대기에 복제 될 때까지 트랜잭션 커밋을 대기시킵니다. 예를 들어, &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; 하면 적어도 세 개의 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; 및 &lt;code&gt;s4&lt;/code&gt; 대기가 응답 하자마자 각 커밋이 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f98af4e22fce388807986209bcfe098613dae4c1" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;FIRST&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;code&gt;num_sync&lt;/code&gt; synchronous standbys chosen based on their priorities. For example, a setting of &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to wait for replies from three higher-priority standbys chosen from standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt;. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby. The keyword &lt;code&gt;FIRST&lt;/code&gt; is optional.</source>
          <target state="translated">키워드 &lt;code&gt;FIRST&lt;/code&gt; 는 &lt;code&gt;num_sync&lt;/code&gt; 와 함께 우선 순위 기반 동기 복제를 지정하고 WAL 레코드가 우선 순위에 따라 선택된 &lt;code&gt;num_sync&lt;/code&gt; 동기 대기 로 복제 될 때까지 트랜잭션 커미트를 대기 시킵니다 . 예를 들어, &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; 하면 각 커밋이 대기 서버 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; 및 &lt;code&gt;s4&lt;/code&gt; 에서 선택한 우선 순위가 높은 대기 3 개의 응답을 기다립니다.. 이름이 목록의 앞에 표시되는 대기에는 우선 순위가 더 높으며 동기로 간주됩니다. 이 목록의 뒷부분에 나오는 다른 대기 서버는 잠재적 인 동기 대기를 나타냅니다. 현재 동기 대기 중 하나라도 어떤 이유로 든 연결이 끊어지면 바로 다음 우선 순위 대기로 대체됩니다. 키워드 &lt;code&gt;FIRST&lt;/code&gt; 는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="c6753d4b26b83ec9737507aab616ad0a90dffe5e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write and will be stored on disk.</source>
          <target state="translated">키워드 &lt;code&gt;STORED&lt;/code&gt; 는 열이 쓰기시 계산되고 디스크에 저장됨을 나타 내기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="436779e1054adc0e89a0677ecb406409dda7f240" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write. (The computed value will be presented to the foreign-data wrapper for storage and must be returned on reading.)</source>
          <target state="translated">쓰기시 열이 계산됨을 나타내려면 키워드 &lt;code&gt;STORED&lt;/code&gt; 가 필요합니다. (계산 된 값은 저장을 위해 외부 데이터 래퍼에 제공되며 읽기시 반환되어야합니다.)</target>
        </trans-unit>
        <trans-unit id="5edd7a55d1b24539fc9cfa0bcf24706822731dd3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; must be specified to choose the stored kind of generated column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">저장된 종류의 생성 된 열을 선택하려면 키워드 &lt;code&gt;STORED&lt;/code&gt; 를 지정해야합니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e643395261c7f81c30fc2a4e61b7aaf97e975625" translate="yes" xml:space="preserve">
          <source>The label provider associated with this label.</source>
          <target state="translated">이 레이블과 연관된 레이블 제공자입니다.</target>
        </trans-unit>
        <trans-unit id="468c79531b62d3d36755c25fe6c2c2d1c6c04f9c" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SE-Linux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="translated">레이블 공급자는 지정된 레이블이 유효한지 여부와 해당 레이블을 지정된 개체에 할당 할 수 있는지 여부를 결정합니다. 주어진 라벨의 의미는 마찬가지로 라벨 제공자의 재량에 따릅니다. PostgreSQL은 레이블 제공자가 보안 레이블을 해석해야하는지 여부에 제한이 없습니다. 단지 그것들을 저장하는 메커니즘을 제공합니다. 실제로이 기능은 SE-Linux와 같은 레이블 기반의 필수 액세스 제어 (MAC) 시스템과 통합 할 수 있도록 고안되었습니다. 이러한 시스템은 사용자 및 그룹과 같은 기존의 DAC (임의 액세스 제어) 개념이 아니라 개체 레이블을 기반으로 모든 액세스 제어 결정을 내립니다.</target>
        </trans-unit>
        <trans-unit id="8eaf1d04fc556db25e421838f63ccbd315696008" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SELinux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="translated">레이블 공급자는 지정된 레이블이 유효한지 여부와 해당 레이블을 지정된 개체에 할당 할 수 있는지 여부를 결정합니다. 주어진 레이블의 의미도 마찬가지로 레이블 공급자의 재량에 따릅니다. PostgreSQL은 레이블 공급자가 보안 레이블을 해석해야하는지 여부 또는 방법에 제한을 두지 않습니다. 단지 그것들을 저장하기위한 메커니즘을 제공합니다. 실제로이 기능은 SELinux와 같은 레이블 기반 MAC (필수 액세스 제어) 시스템과의 통합을 허용하기위한 것입니다. 이러한 시스템은 사용자 및 그룹과 같은 기존 DAC (임의 액세스 제어) 개념이 아닌 개체 레이블을 기반으로 모든 액세스 제어 결정을 내립니다.</target>
        </trans-unit>
        <trans-unit id="e2fab09475b65e9983ce79215513aca004922a64" translate="yes" xml:space="preserve">
          <source>The lag times reported in the &lt;code&gt;pg_stat_replication&lt;/code&gt; view are measurements of the time taken for recent WAL to be written, flushed and replayed and for the sender to know about it. These times represent the commit delay that was (or would have been) introduced by each synchronous commit level, if the remote server was configured as a synchronous standby. For an asynchronous standby, the &lt;code&gt;replay_lag&lt;/code&gt; column approximates the delay before recent transactions became visible to queries. If the standby server has entirely caught up with the sending server and there is no more WAL activity, the most recently measured lag times will continue to be displayed for a short time and then show NULL.</source>
          <target state="translated">&lt;code&gt;pg_stat_replication&lt;/code&gt; 보기에 보고 된 지연 시간은 최근 WAL이 기록, 플러시 및 재생되고 발신자가 알 수있는 시간을 측정 한 것입니다. 이 시간은 원격 서버가 동기 대기로 구성된 경우 각 동기 커미트 레벨에 의해 도입되었거나 커밋 된 커미트 지연을 나타냅니다. 비동기 대기의 경우 &lt;code&gt;replay_lag&lt;/code&gt; 열은 최근 트랜잭션이 쿼리에 표시되기 전의 지연 시간과 비슷합니다. 대기 서버가 전송 서버를 완전히 따라 잡았고 더 이상 WAL 활동이 없으면 가장 최근에 측정 된 지연 시간이 잠시 동안 계속 표시되고 NULL을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="eb0c7351bd920c1bdbdffe727ba791d1a927eafe" translate="yes" xml:space="preserve">
          <source>The largest part of shared memory is known as &lt;em&gt;shared buffers&lt;/em&gt; and is used to mirror part of data files, organized into pages. When a page is modified, it is called a dirty page until it is written back to the file system.</source>
          <target state="translated">공유 메모리의 가장 큰 부분은 공유 &lt;em&gt;버퍼&lt;/em&gt; 로 알려져 있으며 페이지로 구성된 데이터 파일의 일부를 미러링하는 데 사용됩니다. 페이지가 수정되면 파일 시스템에 다시 기록 될 때까지 더티 페이지라고합니다.</target>
        </trans-unit>
        <trans-unit id="bee0490b803b85b6819bd67e0eb5d37f8061673f" translate="yes" xml:space="preserve">
          <source>The largest statistics target among the columns being analyzed determines the number of table rows sampled to prepare the statistics. Increasing the target causes a proportional increase in the time and space needed to do &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">분석중인 열 중 가장 큰 통계 대상이 통계를 준비하기 위해 샘플링 된 테이블 행 수를 결정합니다. 목표를 늘리면 &lt;code&gt;ANALYZE&lt;/code&gt; 필요한 시간과 공간이 비례 적으로 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="08ac6817284c2739892a594416144a19a2fc3c3b" translate="yes" xml:space="preserve">
          <source>The last example shows that the checks include whether namespaces are correctly matched.</source>
          <target state="translated">마지막 예는 검사에 네임 스페이스가 올바르게 일치하는지 여부가 포함되어 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b141d1efe06f21d25a717b844dfa4141ae98f099" translate="yes" xml:space="preserve">
          <source>The last five parameters are pass-by-reference outputs:</source>
          <target state="translated">마지막 5 개의 매개 변수는 기준 별 출력입니다.</target>
        </trans-unit>
        <trans-unit id="640860dcca4728ae99db3adc4362cf72e26f4370" translate="yes" xml:space="preserve">
          <source>The last line could also be:</source>
          <target state="translated">마지막 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a268591c13ee52793b16cb868a71b9f235920223" translate="yes" xml:space="preserve">
          <source>The last line is useful in verifying that the client is trying to connect to the right place. If there is in fact no server running there, the kernel error message will typically be either &lt;code&gt;Connection refused&lt;/code&gt; or &lt;code&gt;No such file or directory&lt;/code&gt;, as illustrated. (It is important to realize that &lt;code&gt;Connection refused&lt;/code&gt; in this context does &lt;em&gt;not&lt;/em&gt; mean that the server got your connection request and rejected it. That case will produce a different message, as shown in &lt;a href=&quot;client-authentication-problems&quot;&gt;Section 20.15&lt;/a&gt;.) Other error messages such as &lt;code&gt;Connection timed out&lt;/code&gt; might indicate more fundamental problems, like lack of network connectivity.</source>
          <target state="translated">마지막 줄은 클라이언트가 올바른 위치에 연결을 시도하고 있는지 확인하는 데 유용합니다. 실제로 실행중인 서버가없는 경우 커널 오류 메시지는 일반적 으로 그림 &lt;code&gt;No such file or directory&lt;/code&gt; &lt;code&gt;Connection refused&lt;/code&gt; 되었거나 해당 파일 또는 디렉토리가 없습니다 . (그것은 그 깨닫는 것이 중요하다 &lt;code&gt;Connection refused&lt;/code&gt; 않는이 상황에서를 &lt;em&gt;하지&lt;/em&gt; 서버가 연결 요청을했고, 그것을 거부 것을 의미한다. 같이 그 경우, 다른 메시지를 생성합니다 &lt;a href=&quot;client-authentication-problems&quot;&gt;섹션 20.15&lt;/a&gt; .) 같은 다른 오류 메시지 &lt;code&gt;Connection timed out&lt;/code&gt; 힘을 네트워크 연결 부족과 같은 더 근본적인 문제를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cca952ade3d373926896de08f3f6cd0f1c245369" translate="yes" xml:space="preserve">
          <source>The last line printed out by &lt;code&gt;psql&lt;/code&gt; is the prompt, and it indicates that &lt;code&gt;psql&lt;/code&gt; is listening to you and that you can type SQL queries into a work space maintained by &lt;code&gt;psql&lt;/code&gt;. Try out these commands:</source>
          <target state="translated">에 의해 인쇄 된 마지막 줄 &lt;code&gt;psql&lt;/code&gt; 프로그램은 프롬프트이며, 그 표시 &lt;code&gt;psql&lt;/code&gt; 프로그램이 당신을 듣고 당신이에 의해 유지되는 작업 공간에 SQL 쿼리를 입력 할 수 있다는 것입니다 &lt;code&gt;psql&lt;/code&gt; 의 . 다음 명령을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="4a2bf24f5739dd825710ff53126984ef2f6e0852" translate="yes" xml:space="preserve">
          <source>The last modification time of the file as reported by the server at the time of the backup. Unlike the other fields stored in the backup, this field is not used by &lt;a href=&quot;app-pgverifybackup&quot;&gt;pg_verifybackup&lt;/a&gt;. It is included only for informational purposes.</source>
          <target state="translated">백업시 서버에서보고 한 파일의 마지막 수정 시간. 백업에 저장된 다른 필드와 달리이 필드는 &lt;a href=&quot;app-pgverifybackup&quot;&gt;pg_verifybackup에서&lt;/a&gt; 사용되지 않습니다 . 정보 제공 목적으로 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="eb5a300b26673b4a75043297a6f146dcd49c5439" translate="yes" xml:space="preserve">
          <source>The last sequence value written to disk. If caching is used, this value can be greater than the last value handed out from the sequence. Null if the sequence has not been read from yet. Also, if the current user does not have &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence, the value is null.</source>
          <target state="translated">디스크에 기록 된 마지막 시퀀스 값. 캐싱을 사용하는 경우이 값은 시퀀스에서 마지막으로 전달 된 값보다 클 수 있습니다. 시퀀스를 아직 읽지 않은 경우 널입니다. 또한 현재 사용자 에게 시퀀스에 대한 &lt;code&gt;USAGE&lt;/code&gt; 또는 &lt;code&gt;SELECT&lt;/code&gt; 권한이없는 경우 값은 null입니다.</target>
        </trans-unit>
        <trans-unit id="3ddb6dca4d033d643b4947fa1e0c4bfe448712f8" translate="yes" xml:space="preserve">
          <source>The last six input formats shown above are not part of any standard.</source>
          <target state="translated">위에 표시된 마지막 6 개의 입력 형식은 표준의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8146be3b6220418f9831589eda3884a4555e4dfa" translate="yes" xml:space="preserve">
          <source>The last two states are seen only when &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; is non-negative. If &lt;code&gt;restart_lsn&lt;/code&gt; is NULL, this field is null.</source>
          <target state="translated">마지막 두 상태는 &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; 가 음수가 아닌 경우에만 표시됩니다 . 경우 &lt;code&gt;restart_lsn&lt;/code&gt; 은 NULL이며,이 필드는 null입니다.</target>
        </trans-unit>
        <trans-unit id="5fe313657b9f725a4a4c3652ad1d9e1c661ac0d8" translate="yes" xml:space="preserve">
          <source>The latter is syntactically valid, but it represents a call of a single-argument aggregate function with two &lt;code&gt;ORDER BY&lt;/code&gt; keys (the second one being rather useless since it's a constant).</source>
          <target state="translated">후자는 구문 상 유효하지만 두 개의 &lt;code&gt;ORDER BY&lt;/code&gt; 키 를 사용하는 단일 인수 집계 함수의 호출을 나타냅니다 (두 번째는 상수이므로 다소 쓸모가 없습니다).</target>
        </trans-unit>
        <trans-unit id="ec920275f2c822a2a5adceef23c754e25dadccba" translate="yes" xml:space="preserve">
          <source>The lax mode facilitates matching of a JSON document structure and path expression if the JSON data does not conform to the expected schema. If an operand does not match the requirements of a particular operation, it can be automatically wrapped as an SQL/JSON array or unwrapped by converting its elements into an SQL/JSON sequence before performing this operation. Besides, comparison operators automatically unwrap their operands in the lax mode, so you can compare SQL/JSON arrays out-of-the-box. An array of size 1 is considered equal to its sole element. Automatic unwrapping is not performed only when:</source>
          <target state="translated">lax 모드는 JSON 데이터가 예상 스키마를 준수하지 않는 경우 JSON 문서 구조 및 경로 표현식의 일치를 용이하게합니다. 피연산자가 특정 오퍼레이션의 요구 사항과 일치하지 않으면이 오퍼레이션을 수행하기 전에 해당 요소를 SQL / JSON 시퀀스로 변환하여 자동으로 SQL / JSON 배열로 랩핑하거나 랩핑 해제 할 수 있습니다. 또한 비교 연산자는 lax 모드에서 피연산자를 자동으로 랩 해제하므로 SQL / JSON 배열을 기본적으로 비교할 수 있습니다. 크기가 1 인 배열은 유일한 요소로 간주됩니다. 다음과 같은 경우에만 자동 언 래핑이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c52a670d06775855c2164b78f437c77c8a3136cd" translate="yes" xml:space="preserve">
          <source>The least downtime can be achieved by installing the new server in a different directory and running both the old and the new servers in parallel, on different ports. Then you can use something like:</source>
          <target state="translated">새 서버를 다른 디렉토리에 설치하고 이전 서버와 새 서버를 서로 다른 포트에서 병렬로 실행하여 가동 중지 시간을 최소화 할 수 있습니다. 그런 다음 다음과 같은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="082fd8f2f5ff84b43f58645d6265cd8d6ba42c18" translate="yes" xml:space="preserve">
          <source>The left-hand side is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. Furthermore, the subquery cannot return more than one row. (If it returns zero rows, the result is taken to be null.) The left-hand side is evaluated and compared row-wise to the single subquery result row.</source>
          <target state="translated">왼쪽 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;은 4.2.13 절&lt;/a&gt; 에서 설명한 것처럼 행 생성자 입니다. 오른쪽은 괄호로 묶인 하위 쿼리이며 왼쪽 행에식이있는 수만큼 정확하게 열을 반환해야합니다. 또한 부속 조회는 둘 이상의 행을 리턴 할 수 없습니다. (행이 0을 리턴하면 결과는 널로 간주됩니다.) 왼쪽이 평가되어 단일 서브 쿼리 결과 행과 행 단위로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="f44070270517992cebfd8a7909698b4367aa0cae" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ALL&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for all subquery rows (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for any subquery row. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">이 형식의 &lt;code&gt;ALL&lt;/code&gt; 의 왼쪽 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;은 4.2.13 절에&lt;/a&gt; 설명 된대로 행 생성자 입니다. 오른쪽은 괄호로 묶인 하위 쿼리이며 왼쪽 행에식이있는 수만큼 정확하게 열을 반환해야합니다. 주어진 &lt;code&gt;operator&lt;/code&gt; 사용하여 왼쪽 표현식을 평가하고 하위 쿼리 결과의 각 행과 행 단위로 비교합니다 . 하위 쿼리가 행을 반환하지 않는 경우를 포함하여 모든 하위 쿼리 행에 대해 비교가 true를 반환하면 &lt;code&gt;ALL&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 하위 쿼리 행에 대해 비교가 false를 반환하면 결과는 &quot;false&quot;입니다. 하위 쿼리 행과의 비교가 false를 반환하지 않으면 결과는 NULL이되고 하나 이상의 비교에서 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3a495b6469d287a27574f63256e96477ed641f86" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ANY&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for any subquery row. The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for every subquery row (including the case where the subquery returns no rows). The result is NULL if no comparison with a subquery row returns true, and at least one comparison returns NULL.</source>
          <target state="translated">이 형식의 &lt;code&gt;ANY&lt;/code&gt; 의 왼쪽 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;은 4.2.13 절에&lt;/a&gt; 설명 된대로 행 생성자 입니다. 오른쪽은 괄호로 묶인 하위 쿼리이며 왼쪽 행에식이있는 수만큼 정확하게 열을 반환해야합니다. 주어진 &lt;code&gt;operator&lt;/code&gt; 사용하여 왼쪽 표현식을 평가하고 하위 쿼리 결과의 각 행과 행 단위로 비교합니다 . 하위 쿼리 행에 대해 비교가 true를 반환하면 &lt;code&gt;ANY&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 하위 쿼리가 행을 반환하지 않는 경우를 포함하여 모든 하위 쿼리 행에 대해 비교가 false를 반환하면 결과는 &quot;false&quot;입니다. 하위 쿼리 행과의 비교가 true를 반환하지 않으면 결과는 NULL이되고 하나 이상의 비교가 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="afdaf261917f03fc0c447e59e3d5a8be456d89c2" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">이 형식의 &lt;code&gt;IN&lt;/code&gt; 의 왼쪽 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;은 4.2.13 절에&lt;/a&gt; 설명 된대로 행 생성자 입니다. 오른쪽은 괄호로 묶인 하위 쿼리이며 왼쪽 행에식이있는 수만큼 정확하게 열을 반환해야합니다. 왼쪽 표현식이 평가되고 하위 쿼리 결과의 각 행과 행 단위로 비교됩니다. 동일한 하위 쿼리 행이 있으면 &lt;code&gt;IN&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 동일한 행이 없으면 하위 쿼리가 행을 반환하지 않는 경우를 포함하여 결과는 &quot;false&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a1d433de59d411f27b86b3382eba3a1fea3e9e5d" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;NOT IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">이 형식의 &lt;code&gt;NOT IN&lt;/code&gt; 의 왼쪽 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;은 4.2.13 절에&lt;/a&gt; 설명 된대로 행 생성자 입니다. 오른쪽은 괄호로 묶인 하위 쿼리이며 왼쪽 행에식이있는 수만큼 정확하게 열을 반환해야합니다. 왼쪽 표현식이 평가되고 하위 쿼리 결과의 각 행과 행 단위로 비교됩니다. 부질의 서브 쿼리 행만 발견되면 (서브 쿼리가 행을 리턴하지 않는 경우 포함) &lt;code&gt;NOT IN&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 동일한 행이 있으면 결과는 &quot;false&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4585d75ed76ee1f40b5daa39dfcad2d39fb7784d" translate="yes" xml:space="preserve">
          <source>The left-of/right-of/adjacent operators always return false when an empty range is involved; that is, an empty range is not considered to be either before or after any other range.</source>
          <target state="translated">left / of / right / of / adjacent 연산자는 빈 범위가 포함 된 경우 항상 false를 반환합니다. 즉, 빈 범위는 다른 범위 전후에있는 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f5d1e6e1b59ebb3b7a2ceefdc5f69123a880bd7" translate="yes" xml:space="preserve">
          <source>The length of a &lt;code&gt;tsvector&lt;/code&gt; (lexemes + positions) must be less than 1 megabyte</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; ( Lexemes + Positions) 의 길이는 1MB보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="fb55102e4d77862d8595a399532f60d05305a61a" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2 kilobytes</source>
          <target state="translated">각 용어의 길이는 2KB 미만이어야합니다.</target>
        </trans-unit>
        <trans-unit id="72cf9ee51b093da890b7dcc27caaf482e19db7ab" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2K bytes</source>
          <target state="translated">각 exeme의 길이는 2K 바이트보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="07e3cb5f7b40e6d63b3d5d01d67980671a6f7bf1" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="translated">라이브러리 파일 이름은 일반적으로 베어 파일 이름으로 제공되며, 이는 서버의 라이브러리 검색 경로 ( &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path에&lt;/a&gt; 의해 설정 됨 )에서 검색됩니다 . 또는 전체 경로 이름으로 제공 될 수 있습니다. 두 경우 모두 플랫폼의 표준 공유 라이브러리 파일 이름 확장자는 생략 할 수 있습니다. 이 주제에 대한 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;37.10.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca07c214a1fa57e76fa5efc5dc421655af5b85fc" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="translated">라이브러리 파일 이름은 일반적으로 서버의 라이브러리 검색 경로 ( &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path로&lt;/a&gt; 설정 ) 에서 찾는 베어 파일 이름으로 제공됩니다 . 또는 전체 경로 이름으로 지정할 수 있습니다. 두 경우 모두 플랫폼의 표준 공유 라이브러리 파일 이름 확장자를 생략 할 수 있습니다. 이 주제에 대한 자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;섹션 37.10.1&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb9d5172bb2076ce6b62f3e5058e20954eddcb55" translate="yes" xml:space="preserve">
          <source>The libxml2 library does seem to always return node-sets to PostgreSQL with their members in the same relative order they had in the input document. Its documentation does not commit to this behavior, and an XPath 1.0 expression cannot control it.</source>
          <target state="translated">libxml2 라이브러리는 항상 입력 문서에서와 동일한 상대 순서로 멤버와 함께 노드 세트를 PostgreSQL에 반환하는 것으로 보입니다. 설명서에서이 동작을 수행하지 않으므로 XPath 1.0 식으로 제어 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e92855a9b20ea0f884a230e63ef7768d88fd5352" translate="yes" xml:space="preserve">
          <source>The limitations of pg_restore are detailed below.</source>
          <target state="translated">pg_restore의 제한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87e598717783e82b1e191a7f90cf401c4ee0b779" translate="yes" xml:space="preserve">
          <source>The line number inside the current statement, starting from &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">부터 현재 문 내부의 줄 번호, &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d10565a24d6154d743d122e032098869756ae365" translate="yes" xml:space="preserve">
          <source>The list below shows the available lock modes and the contexts in which they are used automatically by PostgreSQL. You can also acquire any of these locks explicitly with the command &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt;. Remember that all of these lock modes are table-level locks, even if the name contains the word &amp;ldquo;row&amp;rdquo;; the names of the lock modes are historical. To some extent the names reflect the typical usage of each lock mode &amp;mdash; but the semantics are all the same. The only real difference between one lock mode and another is the set of lock modes with which each conflicts (see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;). Two transactions cannot hold locks of conflicting modes on the same table at the same time. (However, a transaction never conflicts with itself. For example, it might acquire &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock and later acquire &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock on the same table.) Non-conflicting lock modes can be held concurrently by many transactions. Notice in particular that some lock modes are self-conflicting (for example, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock cannot be held by more than one transaction at a time) while others are not self-conflicting (for example, an &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock can be held by multiple transactions).</source>
          <target state="translated">아래 목록은 사용 가능한 잠금 모드와 PostgreSQL에서 자동으로 사용되는 컨텍스트를 보여줍니다. &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt; 명령을 사용하여 이러한 잠금을 명시 적으로 얻을 수도 있습니다 . 이름에 &quot;row&quot;라는 단어가 포함되어 있더라도 이러한 잠금 모드는 모두 테이블 수준 잠금입니다. 잠금 모드의 이름은 과거입니다. 어느 정도 이름은 각 잠금 모드의 일반적인 사용법을 반영하지만 의미는 모두 동일합니다. 한 잠금 모드와 다른 잠금 모드의 유일한 차이점은 각 잠금 모드와 충돌하는 잠금 모드 세트입니다 ( &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;표 13.2&lt;/a&gt; 참조 ). 두 트랜잭션은 동시에 같은 테이블에서 충돌 모드 잠금을 보유 할 수 없습니다. 그러나 트랜잭션은 절대로 자신과 충돌하지 않습니다. 예를 들어 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금을 획득 한 후 나중에 획득 할 수 있습니다. &lt;code&gt;ACCESS SHARE&lt;/code&gt; 동일한 테이블에서 ACCESS SHARE 잠금.) 많은 트랜잭션이 충돌하지 않는 잠금 모드를 동시에 보유 할 수 있습니다. 특히 일부 잠금 모드는 자체 충돌합니다 (예 : &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금은 한 번에 둘 이상의 트랜잭션에 의해 보류 될 수 없음). 반면 다른 모드는 자체 충돌하지 않습니다 (예 : &lt;code&gt;ACCESS SHARE&lt;/code&gt; 잠금은 여러 거래).</target>
        </trans-unit>
        <trans-unit id="4e69c1b0ac656b6b15e1946ebe2102bdb20487dd" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="translated">내장 함수 목록은 &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장에&lt;/a&gt; 있습니다. 다른 기능은 사용자가 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98078b1844b2f5121863d76d0e6ccd8659c9a105" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="translated">내장 함수 목록은 &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;9 장에&lt;/a&gt; 있습니다. 사용자가 다른 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="034ee84c98b899e3f08ab6a22f176f2b0b9c945d" translate="yes" xml:space="preserve">
          <source>The list of output expressions after &lt;code&gt;SELECT&lt;/code&gt; can be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard. PostgreSQL allows it to be consistent with allowing zero-column tables. However, an empty list is not allowed when &lt;code&gt;DISTINCT&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 후 출력 표현식 목록이 비어 있으면 열이 0 인 결과 테이블이 생성됩니다. SQL 표준에 따라 유효한 구문이 아닙니다. PostgreSQL을 사용하면 열이없는 테이블을 허용 할 수 있습니다. 그러나 &lt;code&gt;DISTINCT&lt;/code&gt; 를 사용 하면 빈 목록이 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8494c9c3de42f371358e2a2e5b1c91631cba7c4b" translate="yes" xml:space="preserve">
          <source>The listing file consists of a header and one line for each item, e.g.:</source>
          <target state="translated">리스팅 파일은 각 항목에 대해 헤더와 한 줄로 구성됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="c073ed3743a7cc8517210053a4e46a167f30e3ab" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;1.2&lt;/code&gt; is of type &lt;code&gt;numeric&lt;/code&gt;, and the &lt;code&gt;integer&lt;/code&gt; value &lt;code&gt;1&lt;/code&gt; can be cast implicitly to &lt;code&gt;numeric&lt;/code&gt;, so that type is used.</source>
          <target state="translated">리터럴 &lt;code&gt;1.2&lt;/code&gt; 는 &lt;code&gt;numeric&lt;/code&gt; 유형 이며 &lt;code&gt;integer&lt;/code&gt; 값 &lt;code&gt;1&lt;/code&gt; 은 암시 적으로 &lt;code&gt;numeric&lt;/code&gt; 으로 캐스트 될 수 있으므로 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="81389809d8e329e135cb6738d28db71cfa07fe84" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to archive a completed WAL file segment. Any &lt;code&gt;%p&lt;/code&gt; in the string is replaced by the path name of the file to archive, and any &lt;code&gt;%f&lt;/code&gt; is replaced by only the file name. (The path name is relative to the working directory of the server, i.e., the cluster's data directory.) Use &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. It is important for the command to return a zero exit status only if it succeeds. For more information see &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;Section 25.3.1&lt;/a&gt;.</source>
          <target state="translated">완료된 WAL 파일 세그먼트를 아카이브하기 위해 실행할 로컬 쉘 명령. 모든 &lt;code&gt;%p&lt;/code&gt; 문자열은 아카이브 파일의 경로 이름으로 대체되고, 어떤 &lt;code&gt;%f&lt;/code&gt; 파일 이름 만로 대체됩니다. 경로 이름은 서버의 작업 디렉토리, 즉 클러스터의 데이터 디렉토리와 관련이 있습니다. 명령에 실제 &lt;code&gt;%&lt;/code&gt; 문자 를 포함 시키려면 &lt;code&gt;%%&lt;/code&gt; 를 사용하십시오 . 명령이 성공한 경우에만 제로 종료 상태를 리턴하는 것이 중요합니다. 자세한 정보는 &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;섹션 25.3.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c6814fd70a4837bf3123c78d06664813ae5c2c3" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to retrieve an archived segment of the WAL file series. This parameter is required for archive recovery, but optional for streaming replication. Any &lt;code&gt;%f&lt;/code&gt; in the string is replaced by the name of the file to retrieve from the archive, and any &lt;code&gt;%p&lt;/code&gt; is replaced by the copy destination path name on the server. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point. That is the earliest file that must be kept to allow a restore to be restartable, so this information can be used to truncate the archive to just the minimum required to support restarting from the current restore. &lt;code&gt;%r&lt;/code&gt; is typically only used by warm-standby configurations (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">WAL 파일 시리즈의 아카이브 된 세그먼트를 검색하기 위해 실행하는 로컬 쉘 명령. 이 매개 변수는 아카이브 복구에 필요하지만 스트리밍 복제에는 선택 사항입니다. 모든 &lt;code&gt;%f&lt;/code&gt; 문자열은 아카이브에서 검색 할 파일의 이름으로 대체되고, 어떤 &lt;code&gt;%p&lt;/code&gt; 서버에서 복사 대상 경로 이름으로 대체됩니다. (경로 이름은 현재 작업 디렉토리, 즉 클러스터의 데이터 디렉토리와 관련이 있습니다.) &lt;code&gt;%r&lt;/code&gt; 은 마지막 유효한 재시작 지점을 포함하는 파일 이름으로 바뀝니다. 즉, 복원을 재시작 할 수 있도록 유지해야하는 가장 초기 파일이므로이 정보를 사용하여 현재 복원에서 재시작을 지원하는 데 필요한 최소한의 수준으로 아카이브를자를 수 있습니다. &lt;code&gt;%r&lt;/code&gt; 일반적으로 warm-standby 구성에서만 사용됩니다 ( &lt;a href=&quot;warm-standby&quot;&gt;26.2 절&lt;/a&gt; 참조 ). 실제 &lt;code&gt;%&lt;/code&gt; 문자 를 포함 시키려면 &lt;code&gt;%%&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="1eefb4d9f04f196c0b255cf3b0eec2ac11926c27" translate="yes" xml:space="preserve">
          <source>The locale settings influence the following SQL features:</source>
          <target state="translated">로케일 설정은 다음 SQL 기능에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="7a32d4357c6c565a2645be6e8f5dcd4ff20db468" translate="yes" xml:space="preserve">
          <source>The location must be an existing, empty directory that is owned by the PostgreSQL operating system user. All objects subsequently created within the tablespace will be stored in files underneath this directory. The location must not be on removable or transient storage, as the cluster might fail to function if the tablespace is missing or lost.</source>
          <target state="translated">위치는 PostgreSQL 운영 체제 사용자가 소유 한 기존의 빈 디렉토리 여야합니다. 이후에 테이블 스페이스 내에 작성된 모든 오브젝트는이 디렉토리 아래의 파일에 저장됩니다. 테이블 스페이스가 없거나 손실 된 경우 클러스터가 작동하지 않을 수 있으므로 위치는 이동식 또는 임시 스토리지에 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="b667dea533a6876f6f89e862e7e520ec6a41f7d3" translate="yes" xml:space="preserve">
          <source>The location of the history file can be set explicitly via the &lt;code&gt;HISTFILE&lt;/code&gt; psql variable or the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable.</source>
          <target state="translated">히스토리 파일의 위치는 &lt;code&gt;HISTFILE&lt;/code&gt; psql 변수 또는 &lt;code&gt;PSQL_HISTORY&lt;/code&gt; 환경 변수 를 통해 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9e8edabe8e574f621a1a9a4ab6a0372f27514c2" translate="yes" xml:space="preserve">
          <source>The lock mode specifies which locks this lock conflicts with. Lock modes are described in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">잠금 모드는이 잠금이 충돌하는 잠금을 지정합니다. 잠금 모드는 &lt;a href=&quot;explicit-locking&quot;&gt;13.3 절&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e9f2a01b63d9d65afbfe49635022cefcf4e76a" translate="yes" xml:space="preserve">
          <source>The locking clause has the general form</source>
          <target state="translated">잠금 절은 일반적인 형식을가집니다</target>
        </trans-unit>
        <trans-unit id="91a41283b7fcf940c9ed38d5616364c7bd0504f5" translate="yes" xml:space="preserve">
          <source>The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.</source>
          <target state="translated">리턴 된 행을 개별 테이블 행으로 명확하게 식별 할 수없는 컨텍스트에서는 잠금 절을 사용할 수 없습니다. 예를 들어 집계와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5be2e9c7a10ee3339b74248910b8189ec3602ecb" translate="yes" xml:space="preserve">
          <source>The logging collector is designed to never lose messages. This means that in case of extremely high load, server processes could be blocked while trying to send additional log messages when the collector has fallen behind. In contrast, syslog prefers to drop messages if it cannot write them, which means it may fail to log some messages in such cases but it will not block the rest of the system.</source>
          <target state="translated">로깅 수집기는 메시지를 잃지 않도록 설계되었습니다. 이는로드가 매우 높은 경우 콜렉터가 실패했을 때 추가 로그 메시지를 보내려고 시도하는 동안 서버 프로세스가 차단 될 수 있음을 의미합니다. 반대로 syslog는 메시지를 작성할 수없는 경우 메시지를 삭제하는 것을 선호하므로 이러한 경우 일부 메시지를 기록하지 못할 수 있지만 나머지 시스템은 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e54879093a2f0566d1aa83e68c13d2dd946cc6fd" translate="yes" xml:space="preserve">
          <source>The logical replication apply process currently only fires row triggers, not statement triggers. The initial table synchronization, however, is implemented like a &lt;code&gt;COPY&lt;/code&gt; command and thus fires both row and statement triggers for &lt;code&gt;INSERT&lt;/code&gt;.</source>
          <target state="translated">논리적 복제 적용 프로세스는 현재 명령문 트리거가 아닌 행 트리거 만 실행합니다. 그러나 초기 테이블 동기화는 &lt;code&gt;COPY&lt;/code&gt; 명령 처럼 구현 되므로 &lt;code&gt;INSERT&lt;/code&gt; 에 대한 행 및 명령문 트리거를 모두 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="497c1b112de3cb7224f97eec3f477dda0c464f33" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all points less than the upper bound are included in the range. Likewise, if the upper bound of the range is omitted, then all points greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range.</source>
          <target state="translated">범위의 하한을 생략 할 수 있습니다. 즉, 상한보다 작은 모든 점이 범위에 포함됩니다. 마찬가지로, 범위의 상한을 생략하면, 하한보다 큰 모든 점이 범위에 포함됩니다. 하한과 상한을 모두 생략하면 요소 유형의 모든 값이 범위에있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="57c98e1829ac48ed92032df563adc8eac7513b47" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all values less than the upper bound are included in the range, e.g., &lt;code&gt;(,3]&lt;/code&gt;. Likewise, if the upper bound of the range is omitted, then all values greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range. Specifying a missing bound as inclusive is automatically converted to exclusive, e.g., &lt;code&gt;[,]&lt;/code&gt; is converted to &lt;code&gt;(,)&lt;/code&gt;. You can think of these missing values as +/-infinity, but they are special range type values and are considered to be beyond any range element type's +/-infinity values.</source>
          <target state="translated">범위의 하한을 생략 할 수 있습니다. 즉, 상한보다 작은 모든 값이 범위에 포함됩니다 &lt;code&gt;(,3]&lt;/code&gt; 예 : (, 3]) . 마찬가지로 범위의 상한이 생략되면 다음보다 큰 모든 값이 범위에는 하한이 포함됩니다. 하한과 상한을 모두 생략하면 요소 유형의 모든 값이 범위에있는 것으로 간주됩니다. 누락 된 경계를 포함으로 지정하면 자동으로 제외로 변환됩니다. 예 : &lt;code&gt;[,]&lt;/code&gt; 가 변환됩니다. 에 &lt;code&gt;(,)&lt;/code&gt; . 당신은 +/- 무한대이 누락 된 값을 생각할 수 있지만, 특별한 범위의 값을 입력하고 모든 범위의 요소 유형의 +/- 무한대 값 이상으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bb8fcfd48d2a42926444acc296752b10019e69" translate="yes" xml:space="preserve">
          <source>The machine used is an Intel Mobile Core i3.</source>
          <target state="translated">사용 된 기계는 Intel Mobile Core i3입니다.</target>
        </trans-unit>
        <trans-unit id="a9f59ce368a2e8f66b6b7f102badc5b6a6bb9471" translate="yes" xml:space="preserve">
          <source>The magic that makes the two loosely coupled servers work together is simply a &lt;code&gt;restore_command&lt;/code&gt; used on the standby that, when asked for the next WAL file, waits for it to become available from the primary. Normal recovery processing would request a file from the WAL archive, reporting failure if the file was unavailable. For standby processing it is normal for the next WAL file to be unavailable, so the standby must wait for it to appear. For files ending in &lt;code&gt;.history&lt;/code&gt; there is no need to wait, and a non-zero return code must be returned. A waiting &lt;code&gt;restore_command&lt;/code&gt; can be written as a custom script that loops after polling for the existence of the next WAL file. There must also be some way to trigger failover, which should interrupt the &lt;code&gt;restore_command&lt;/code&gt;, break the loop and return a file-not-found error to the standby server. This ends recovery and the standby will then come up as a normal server.</source>
          <target state="translated">느슨하게 연결된 두 서버를 함께 작동시키는 마술 은 대기에서 사용 되는 &lt;code&gt;restore_command&lt;/code&gt; 입니다. 다음 WAL 파일을 요청할 때 기본 서버에서 사용할 수있을 때까지 대기합니다. 정상적인 복구 처리는 WAL 아카이브에서 파일을 요청하여 파일을 사용할 수없는 경우 실패를보고합니다. 대기 처리의 경우 다음 WAL 파일을 사용할 수없는 것이 정상이므로 대기 파일이 표시 될 때까지 대기해야합니다. &lt;code&gt;.history&lt;/code&gt; 로 끝나는 파일의 경우 기다릴 필요가 없으며 0이 아닌 리턴 코드가 리턴되어야합니다. 대기중인 &lt;code&gt;restore_command&lt;/code&gt; 는 다음 WAL 파일이 있는지 폴링 한 후 반복되는 사용자 정의 스크립트로 작성할 수 있습니다. 장애 조치를 트리거 할 수있는 방법도 있어야합니다. &lt;code&gt;restore_command&lt;/code&gt; 는 루프를 중단하고 파일을 찾을 수 없음 오류를 대기 서버에 리턴합니다. 복구가 종료되고 대기 서버가 일반 서버로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ce18091b48e231b7d70d5b7f47f40d4962ad395e" translate="yes" xml:space="preserve">
          <source>The main advantage of using the MVCC model of concurrency control rather than locking is that in MVCC locks acquired for querying (reading) data do not conflict with locks acquired for writing data, and so reading never blocks writing and writing never blocks reading. PostgreSQL maintains this guarantee even when providing the strictest level of transaction isolation through the use of an innovative &lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt; (SSI) level.</source>
          <target state="translated">잠금보다는 MVCC 동시성 제어 모델을 사용하는 주요 이점은 데이터를 쿼리 (읽기)하기 위해 획득 한 MVCC 잠금이 데이터 쓰기를 위해 획득 한 잠금과 충돌하지 않기 때문에 읽기는 쓰기를 차단하지 않고 쓰기가 읽기를 차단하지 않는다는 것입니다. PostgreSQL은 혁신적인 SSI ( &lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt; ) 수준을 사용하여 가장 엄격한 수준의 트랜잭션 격리를 제공 할 때도 이러한 보증을 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="44c8536b44aa283079c384b9a03db01c74d90dd9" translate="yes" xml:space="preserve">
          <source>The main disadvantage of this approach is that searches must scan the list of pending entries in addition to searching the regular index, and so a large list of pending entries will slow searches significantly. Another disadvantage is that, while most updates are fast, an update that causes the pending list to become &amp;ldquo;too large&amp;rdquo; will incur an immediate cleanup cycle and thus be much slower than other updates. Proper use of autovacuum can minimize both of these problems.</source>
          <target state="translated">이 방법의 가장 큰 단점은 일반 색인을 검색 할뿐만 아니라 보류중인 항목 목록을 검색해야하기 때문에 보류중인 항목이 많으면 검색 속도가 크게 느려집니다. 또 다른 단점은 대부분의 업데이트가 빠르지 만 보류중인 목록이 &quot;너무 크게&quot;업데이트되면 즉시 정리주기가 발생하여 다른 업데이트보다 훨씬 느리다는 것입니다. autovacuum을 올바르게 사용하면 이러한 문제를 최소화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ddd5b9589c157b509c992d47b1a2271d0f14677" translate="yes" xml:space="preserve">
          <source>The main limitation of the single-parameter form of &lt;code&gt;crosstab&lt;/code&gt; is that it treats all values in a group alike, inserting each value into the first available column. If you want the value columns to correspond to specific categories of data, and some groups might not have data for some of the categories, that doesn't work well. The two-parameter form of &lt;code&gt;crosstab&lt;/code&gt; handles this case by providing an explicit list of the categories corresponding to the output columns.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 단일 매개 변수 형식의 주요 제한 사항은 그룹의 모든 값을 동일하게 취급하여 사용 가능한 첫 번째 열에 각 값을 삽입한다는 것입니다. 값 열이 특정 데이터 범주에 해당하고 일부 그룹에 일부 범주에 대한 데이터가없는 경우 제대로 작동하지 않을 수 있습니다. &lt;code&gt;crosstab&lt;/code&gt; 의 두 매개 변수 형식은 출력 열에 해당하는 범주의 명시 적 목록을 제공하여이 경우를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c0c0e4e09c0e4b312acc4efbfbf35b08e17ec465" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server has no free replication slots. Using a replication slot is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="translated">이 옵션의 주요 목적은 서버에 여유 복제 슬롯이 없을 때 기본 백업을 수행 할 수 있도록하는 것입니다. 복제 슬롯을 사용하는 것은 백업 중에 필요한 WAL이 서버에서 제거되는 것을 방지하기 때문에 거의 항상 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="778d9031e427ea1e84edd5ec78787ba6c076cbf5" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server is out of free replication slots. Using replication slots is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="translated">이 옵션의 주요 목적은 서버에 사용 가능한 복제 슬롯이 없을 때 기본 백업을 수행하는 것입니다. 백업 중에 서버에서 필요한 WAL을 제거 할 수 없으므로 복제 슬롯을 사용하는 것이 거의 항상 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="29caa328c42873be4b6687bd164a1f6cd134599f" translate="yes" xml:space="preserve">
          <source>The main reason for providing the option to specify multiple changes in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; is that multiple table scans or rewrites can thereby be combined into a single pass over the table.</source>
          <target state="translated">단일 &lt;code&gt;ALTER TABLE&lt;/code&gt; 에서 여러 변경 사항을 지정하는 옵션을 제공하는 주된 이유 는 여러 테이블 스캔 또는 재 작성이 테이블을 통한 단일 패스로 결합 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cb4b3004c02ae1c44498a4d45ad098f017583f6e" translate="yes" xml:space="preserve">
          <source>The main reason not to use &lt;code&gt;FOR UPDATE&lt;/code&gt; with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; is if you need the cursor to be scrollable, or to be insensitive to the subsequent updates (that is, continue to show the old data). If this is a requirement, pay close heed to the caveats shown above.</source>
          <target state="translated">&lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 와 함께 &lt;code&gt;FOR UPDATE&lt;/code&gt; 를 사용하지 않는 주된 이유 는 커서를 스크롤하거나 후속 업데이트에 둔감해야하는 경우 (즉, 이전 데이터를 계속 표시) 때문입니다. 이것이 요구 사항이라면 위의 경고에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="4a8b7d5e4956ce1f0f4b5a2c51be8faff6d42ee8" translate="yes" xml:space="preserve">
          <source>The majority of the information defining an operator family is not in its &lt;code&gt;pg_opfamily&lt;/code&gt; row, but in the associated rows in &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">운영자 제품군을 정의하는 대부분의 정보는 &lt;code&gt;pg_opfamily&lt;/code&gt; 행이 아니라 &lt;a href=&quot;catalog-pg-amop&quot;&gt; &lt;code&gt;pg_amop&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;catalog-pg-amproc&quot;&gt; &lt;code&gt;pg_amproc&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt; 의 연관된 행에 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e832e692fdd3f5ebc26e5d5addbf853c3e6115" translate="yes" xml:space="preserve">
          <source>The mandatory &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the list of columns in the output table. Each entry describes a single column. See the syntax summary above for the format. The column name and type are required; the path, default and nullability clauses are optional.</source>
          <target state="translated">필수 &lt;code&gt;COLUMNS&lt;/code&gt; 절은 출력 테이블의 열 목록을 지정합니다. 각 항목은 단일 열을 설명합니다. 형식은 위의 구문 요약을 참조하십시오. 열 이름과 유형이 필요합니다. path, default 및 nullability 절은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="1ed034d07246f2d9a932c645c69a5fd7f25b6f13" translate="yes" xml:space="preserve">
          <source>The map is conservative in the sense that we make sure that whenever a bit is set, we know the condition is true, but if a bit is not set, it might or might not be true. Visibility map bits are only set by vacuum, but are cleared by any data-modifying operations on a page.</source>
          <target state="translated">비트가 설정 될 때마다 조건이 참임을 알 수 있지만 비트가 설정되지 않은 경우에는 사실 일 수도 있고 그렇지 않을 수도 있다는 점에서 맵은 보수적입니다. 가시성 맵 비트는 진공에 의해서만 설정되지만 페이지의 데이터 수정 작업에 의해 지워집니다.</target>
        </trans-unit>
        <trans-unit id="08696b64b531889519840be43314b0f033492f9a" translate="yes" xml:space="preserve">
          <source>The match distance in a &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator cannot be more than 16,384</source>
          <target state="translated">&lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; ( &lt;code&gt;tsquery&lt;/code&gt; BY) tsquery 연산자 의 일치 거리는 16,384를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0adc4fae7a170393939bebd8f752ad648c1e97c9" translate="yes" xml:space="preserve">
          <source>The matching code in the C module could then follow this skeleton:</source>
          <target state="translated">C 모듈의 일치하는 코드는 다음 골격을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="628cd5529e4eb158401ec35941dd337c440c275a" translate="yes" xml:space="preserve">
          <source>The maximum allowed precision when explicitly specified in the type declaration is 1000; &lt;code&gt;NUMERIC&lt;/code&gt; without a specified precision is subject to the limits described in &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt;.</source>
          <target state="translated">형식 선언에 명시 적으로 지정된 경우 허용되는 최대 정밀도는 1000입니다. 지정된 정밀도가없는 &lt;code&gt;NUMERIC&lt;/code&gt; 에는 &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;표 8.2에&lt;/a&gt; 설명 된 제한이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f276734cd29218873896bf82d393e1b3527b68e3" translate="yes" xml:space="preserve">
          <source>The maximum number of buffers that can be registered for a generic WAL record is &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt;. An error will be thrown if this limit is exceeded.</source>
          <target state="translated">일반 WAL 레코드에 등록 할 수있는 최대 버퍼 수는 &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt; 입니다. 이 한계를 초과하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62795c0abeb86c3cb2f44c4d31a9efa4ab1b021c" translate="yes" xml:space="preserve">
          <source>The maximum number of columns for a table is further reduced as the tuple being stored must fit in a single 8192-byte heap page. For example, excluding the tuple header, a tuple made up of 1600 &lt;code&gt;int&lt;/code&gt; columns would consume 6400 bytes and could be stored in a heap page, but a tuple of 1600 &lt;code&gt;bigint&lt;/code&gt; columns would consume 12800 bytes and would therefore not fit inside a heap page. Variable-length fields of types such as &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; can have their values stored out of line in the table's TOAST table when the values are large enough to require it. Only an 18-byte pointer must remain inside the tuple in the table's heap. For shorter length variable-length fields, either a 4-byte or 1-byte field header is used and the value is stored inside the heap tuple.</source>
          <target state="translated">저장되는 튜플이 단일 8192 바이트 힙 페이지에 맞아야하므로 테이블의 최대 열 수가 줄어 듭니다. 예를 들어, 튜플 헤더를 제외하고 1600 &lt;code&gt;int&lt;/code&gt; 열로 구성된 튜플 은 6400 바이트를 소비하고 힙 페이지에 저장 될 수 있지만 &lt;code&gt;bigint&lt;/code&gt; 열의 튜플은 12800 바이트를 소비하므로 힙 페이지에 맞지 않습니다. &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 와 같은 유형의 가변 길이 필드값이 필요한만큼 테이블의 TOAST 테이블에 값을 저장하지 않아도됩니다. 테이블 힙의 튜플 내부에는 18 바이트 포인터 만 남아 있어야합니다. 더 짧은 길이의 가변 길이 필드의 경우 4 바이트 또는 1 바이트 필드 헤더가 사용되며 값은 힙 튜플 안에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="5febb5cd9beb7e14dc02349a0fabc85e580c54fa" translate="yes" xml:space="preserve">
          <source>The maximum number of commands to store in the command history (default 500). If set to a negative value, no limit is applied.</source>
          <target state="translated">명령 기록에 저장할 최대 명령 수 (기본값 500). 음수 값으로 설정하면 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db38918ed0ba22959c7e085e2da67d6ae9e85522" translate="yes" xml:space="preserve">
          <source>The maximum number of entries in the array fields can be controlled on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; run-time parameter.</source>
          <target state="translated">배열 필드의 최대 항목 수는 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 명령을 사용하여 열별로 또는 &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; 런타임 매개 변수를 설정하여 전체적으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3e538107920d935aeb7ce10873e4d969580a999" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">반환 할 최대 행 수입니다. 자세한 내용은 &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 조항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="758de2e2b468c97aa92a9251f6473d290c2c8830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="translated">반환 할 최대 행 수입니다. 자세한 내용은 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 문서의 &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT 절&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="196f6ebe76be64ba3b271dddfbd4d6c8ae41617e" translate="yes" xml:space="preserve">
          <source>The maximum number of seconds to wait when attempting connection before returning that the server is not responding. Setting to 0 disables. The default is 3 seconds.</source>
          <target state="translated">서버가 응답하지 않음을 리턴하기 전에 연결을 시도 할 때까지 대기하는 최대 시간 (초)입니다. 0으로 설정하면 비활성화됩니다. 기본값은 3 초입니다.</target>
        </trans-unit>
        <trans-unit id="3aa8188a6b3b3fb92b1108055edfe63bc9db8999" translate="yes" xml:space="preserve">
          <source>The maximum time that a table can go unvacuumed is two billion transactions minus the &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; value at the time of the last aggressive vacuum. If it were to go unvacuumed for longer than that, data loss could result. To ensure that this does not happen, autovacuum is invoked on any table that might contain unfrozen rows with XIDs older than the age specified by the configuration parameter &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;. (This will happen even if autovacuum is disabled.)</source>
          <target state="translated">테이블이 진공 상태가되지 않을 수있는 최대 시간은 20 억 건의 트랜잭션에서 마지막 공격적인 진공 시간의 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 값을 뺀 값입니다. 그 이상으로 진공 청소기를 사용하지 않으면 데이터가 손실 될 수 있습니다. 이러한 상황이 발생하지 않도록 구성 매개 변수 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age에&lt;/a&gt; 의해 지정된 기간보다 오래된 XID를 가진 고정되지 않은 행을 포함 할 수있는 테이블에서 autovacuum이 호출됩니다 . (이것은 autovacuum이 비활성화 된 경우에도 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="a2f6e9f6c92be1d6e4dbdfb81636d51c2482b4e7" translate="yes" xml:space="preserve">
          <source>The maximum transfer rate of data transferred from the server. Values are in kilobytes per second. Use a suffix of &lt;code&gt;M&lt;/code&gt; to indicate megabytes per second. A suffix of &lt;code&gt;k&lt;/code&gt; is also accepted, and has no effect. Valid values are between 32 kilobytes per second and 1024 megabytes per second.</source>
          <target state="translated">서버에서 전송 된 데이터의 최대 전송률. 값은 초당 킬로바이트입니다. &lt;code&gt;M&lt;/code&gt; 의 접미사를 사용하여 초당 메가 바이트를 표시하십시오. &lt;code&gt;k&lt;/code&gt; 접미사 도 허용되며 아무런 영향을 미치지 않습니다. 유효한 값은 초당 32 킬로바이트와 초당 1024MB입니다.</target>
        </trans-unit>
        <trans-unit id="aad15d96db29ca223b68ad77ebaeeab386249ae0" translate="yes" xml:space="preserve">
          <source>The meaning of the fields is as follows:</source>
          <target state="translated">필드의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd3a4582b6d44983f8eaba4187d7e09c6429edc7" translate="yes" xml:space="preserve">
          <source>The meaning of this parameter, and its default value, changed in PostgreSQL 12; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt; for further discussion.</source>
          <target state="translated">이 매개 변수의 의미와 기본값은 PostgreSQL 12에서 변경되었습니다. 자세한 논의는 &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;8.1.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7b63395362512b01d4281cff1f264dd9fa16bd8" translate="yes" xml:space="preserve">
          <source>The meanings of &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, and &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; are the same as in &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;. An aggregate will not be considered for parallelization if it is marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (which is the default!) or &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;. Note that the parallel-safety markings of the aggregate's support functions are not consulted by the planner, only the marking of the aggregate itself.</source>
          <target state="translated">&lt;code&gt;PARALLEL SAFE&lt;/code&gt; , &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 및 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 의 의미는 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 과 동일 합니다. &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (기본값) 또는 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 로 표시된 집계는 병렬화로 간주되지 않습니다 . 집계 지원 기능의 병렬 안전 표시는 플래너가 참조하지 않고 집계 자체의 표시 만 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9104f9afa808fa94ea8a0bf0c8363adf4ab748e" translate="yes" xml:space="preserve">
          <source>The mechanism that converts &lt;code&gt;(+-)&lt;/code&gt; to regular ranges isn't completely accurate in determining the number of significant digits for the boundaries. For example, it adds an extra digit to the lower boundary if the resulting interval includes a power of ten:</source>
          <target state="translated">&lt;code&gt;(+-)&lt;/code&gt; 를 일반 범위 로 변환하는 메커니즘 은 경계의 유효 자릿수를 결정하는 데 완전히 정확하지 않습니다. 예를 들어, 결과 간격에 10의 거듭 제곱이 포함 된 경우 아래쪽 경계에 추가 숫자가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="221c60f17786086e4d1d8637638f0c8d9f6223fa" translate="yes" xml:space="preserve">
          <source>The members of a group role can use the privileges of the role in two ways. First, every member of a group can explicitly do &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; to temporarily &amp;ldquo;become&amp;rdquo; the group role. In this state, the database session has access to the privileges of the group role rather than the original login role, and any database objects created are considered owned by the group role not the login role. Second, member roles that have the &lt;code&gt;INHERIT&lt;/code&gt; attribute automatically have use of the privileges of roles of which they are members, including any privileges inherited by those roles. As an example, suppose we have done:</source>
          <target state="translated">그룹 역할의 구성원은 두 가지 방식으로 역할의 권한을 사용할 수 있습니다. 먼저, 그룹의 모든 구성원이 &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 을 명시 적으로 수행 하여 그룹 역할을 일시적으로 &quot;수용&quot; 할 수 있습니다 . 이 상태에서 데이터베이스 세션은 원래 로그인 역할이 아닌 그룹 역할의 권한에 액세스 할 수 있으며 작성된 모든 데이터베이스 오브젝트는 로그인 역할이 아닌 그룹 역할이 소유 한 것으로 간주됩니다. 둘째, &lt;code&gt;INHERIT&lt;/code&gt; 속성 이있는 구성원 역할은 해당 역할에 의해 상속 된 권한을 포함하여 자신이 구성원 인 역할의 권한을 자동으로 사용합니다. 예를 들어, 다음을 수행했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="c531d86ffa3bb917e6ad2f8783d407b8d81b1be4" translate="yes" xml:space="preserve">
          <source>The mentioned transformations and compilations are normally done automatically using the &lt;em&gt;makefiles&lt;/em&gt; shipped with the PostgreSQL source distribution.</source>
          <target state="translated">언급 된 변환 및 컴파일은 일반적으로 PostgreSQL 소스 배포와 함께 제공된 &lt;em&gt;makefile을&lt;/em&gt; 사용하여 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8cd29d65e9431541c4a7e3d8e7bf9c8ca5af8963" translate="yes" xml:space="preserve">
          <source>The message is encrypted with a symmetric key.</source>
          <target state="translated">메시지는 대칭 키로 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="bb36ba49fd3ad58b447d4a645799893632a3669c" translate="yes" xml:space="preserve">
          <source>The message is public-key encrypted, but the key ID has been removed. That means you will need to try all your secret keys on it to see which one decrypts it. &lt;code&gt;pgcrypto&lt;/code&gt; itself does not produce such messages.</source>
          <target state="translated">메시지가 공개 키로 암호화되었지만 키 ID가 제거되었습니다. 즉, 암호를 해독 할 비밀 키를 모두 확인해야합니다. &lt;code&gt;pgcrypto&lt;/code&gt; 자체는 그러한 메시지를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80b9ed75dbe3c0d3f0a0153cbc3b5f5a6c2e4216" translate="yes" xml:space="preserve">
          <source>The metasyntax forms described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt; do not exist in XQuery.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;섹션 9.7.3.4에&lt;/a&gt; 설명 된 메타 구문 양식 은 XQuery에 없습니다.</target>
        </trans-unit>
        <trans-unit id="5167d97b5af2d410349f4f14e2833acb2e09f087" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ANY&lt;/code&gt; specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt; the requested number of synchronous standbys in the list.</source>
          <target state="translated">방법 &lt;code&gt;ANY&lt;/code&gt; 는 쿼럼 기반 동기 복제를 지정하고 WAL 레코드가 목록에서 요청 된 동기 대기 수 &lt;em&gt;이상&lt;/em&gt; 으로 복제 될 때까지 트랜잭션 커밋을 대기 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f49f419e2b9a22a4fc79b879fb7d7ed163340aa2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;FIRST&lt;/code&gt; specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to the requested number of synchronous standbys chosen based on their priorities. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby.</source>
          <target state="translated">&lt;code&gt;FIRST&lt;/code&gt; 메소드 는 우선 순위 기반 동기식 복제를 지정하고 WAL 레코드가 우선 순위에 따라 선택된 요청 된 동기 대기 수로 복제 될 때까지 트랜잭션 커미트를 대기시킵니다. 이름이 목록의 앞에 표시되는 대기에는 우선 순위가 더 높으며 동기로 간주됩니다. 이 목록의 뒷부분에 나오는 다른 대기 서버는 잠재적 인 동기 대기를 나타냅니다. 현재 동기 대기 중 하나라도 어떤 이유로 든 연결이 끊어지면 바로 다음 우선 순위 대기로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3b4f76e9dc87199736499aa89b071e2462e85235" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;md5&lt;/code&gt; uses a custom less secure challenge-response mechanism. It prevents password sniffing and avoids storing passwords on the server in plain text but provides no protection if an attacker manages to steal the password hash from the server. Also, the MD5 hash algorithm is nowadays no longer considered secure against determined attacks.</source>
          <target state="translated">방법 &lt;code&gt;md5&lt;/code&gt; 는 덜 안전한 사용자 지정 챌린지 응답 메커니즘을 사용합니다. 암호 스니핑을 방지하고 서버에 암호를 일반 텍스트로 저장하지 않지만 공격자가 서버에서 암호 해시를 훔칠 경우 보호 기능을 제공하지 않습니다. 또한 MD5 해시 알고리즘은 현재 더 이상 결정된 공격에 대한 보안으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbe98735c0b460f287d0e1fc8bbe8558da46b394" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;password&lt;/code&gt; sends the password in clear-text and is therefore vulnerable to password &amp;ldquo;sniffing&amp;rdquo; attacks. It should always be avoided if possible. If the connection is protected by SSL encryption then &lt;code&gt;password&lt;/code&gt; can be used safely, though. (Though SSL certificate authentication might be a better choice if one is depending on using SSL).</source>
          <target state="translated">방법 &lt;code&gt;password&lt;/code&gt; 는 암호를 일반 텍스트로 보내므로 암호 &quot;스니핑&quot;공격에 취약합니다. 가능하면 항상 피해야합니다. 연결이 SSL 암호화로 보호되면 &lt;code&gt;password&lt;/code&gt; 를 안전하게 사용할 수 있습니다. (SSL 사용에 의존하는 경우 SSL 인증서 인증이 더 나은 선택 일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="c4e1d81897ac3ef5344a09ff3085827106ec9fad" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;scram-sha-256&lt;/code&gt; performs SCRAM-SHA-256 authentication, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt;. It is a challenge-response scheme that prevents password sniffing on untrusted connections and supports storing passwords on the server in a cryptographically hashed form that is thought to be secure.</source>
          <target state="translated">방법 &lt;code&gt;scram-sha-256&lt;/code&gt; 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677에&lt;/a&gt; 설명 된 대로 SCRAM-SHA-256 인증을 수행합니다 . 신뢰할 수없는 연결에서 비밀번호 스니핑을 방지하고 안전한 것으로 생각되는 암호화 된 해시 형식으로 서버에 비밀번호 저장을 지원하는 챌린지 응답 방식입니다.</target>
        </trans-unit>
        <trans-unit id="4d38dbf255ad283e492b192c046e51eef7da09c0" translate="yes" xml:space="preserve">
          <source>The method a client application must use to detect notification events depends on which PostgreSQL application programming interface it uses. With the libpq library, the application issues &lt;code&gt;LISTEN&lt;/code&gt; as an ordinary SQL command, and then must periodically call the function &lt;code&gt;PQnotifies&lt;/code&gt; to find out whether any notification events have been received. Other interfaces such as libpgtcl provide higher-level methods for handling notify events; indeed, with libpgtcl the application programmer should not even issue &lt;code&gt;LISTEN&lt;/code&gt; or &lt;code&gt;UNLISTEN&lt;/code&gt; directly. See the documentation for the interface you are using for more details.</source>
          <target state="translated">클라이언트 응용 프로그램이 알림 이벤트를 탐지하는 데 사용해야하는 방법은 사용하는 PostgreSQL 응용 프로그램 프로그래밍 인터페이스에 따라 다릅니다. libpq 라이브러리를 사용하면 응용 프로그램 은 일반 SQL 명령으로 &lt;code&gt;LISTEN&lt;/code&gt; 을 발행 한 다음 주기적으로 &lt;code&gt;PQnotifies&lt;/code&gt; 함수를 호출하여 통지 이벤트가 수신되었는지 여부를 확인해야합니다. libpgtcl과 같은 다른 인터페이스는 알림 이벤트를 처리하기위한 고급 방법을 제공합니다. 실제로 libpgtcl을 사용하면 응용 프로그램 프로그래머는 &lt;code&gt;LISTEN&lt;/code&gt; 을 발행해서는 안됩니다. 직접 또는 &lt;code&gt;UNLISTEN&lt;/code&gt; 을 발행 . 자세한 내용은 사용중인 인터페이스 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="820cf6d702543aba9dfe85b2f79f3d6774753e9a" translate="yes" xml:space="preserve">
          <source>The method described in this section has been obsoleted by the use of stored generated columns, as described in &lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;Section 12.2.2&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서 설명하는 방법은 다음과 같이 저장된 생성 열을 사용하여 폐기되었습니다. &lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt; 12.2.2 단원&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="318a555813c808d85dcecb5209b3a3a236dc9ab5" translate="yes" xml:space="preserve">
          <source>The method for triggering failover is an important part of planning and design. One potential option is the &lt;code&gt;restore_command&lt;/code&gt; command. It is executed once for each WAL file, but the process running the &lt;code&gt;restore_command&lt;/code&gt; is created and dies for each file, so there is no daemon or server process, and signals or a signal handler cannot be used. Therefore, the &lt;code&gt;restore_command&lt;/code&gt; is not suitable to trigger failover. It is possible to use a simple timeout facility, especially if used in conjunction with a known &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary. However, this is somewhat error prone since a network problem or busy primary server might be sufficient to initiate failover. A notification mechanism such as the explicit creation of a trigger file is ideal, if this can be arranged.</source>
          <target state="translated">장애 조치를 트리거하는 방법은 계획 및 설계에서 중요한 부분입니다. 잠재적 인 옵션 중 하나는 &lt;code&gt;restore_command&lt;/code&gt; 명령입니다. 각 WAL 파일에 대해 한 번 실행되지만 &lt;code&gt;restore_command&lt;/code&gt; 를 실행하는 프로세스 가 작성되고 각 파일에 대해 종료되므로 데몬 또는 서버 프로세스가 없으며 신호 또는 신호 핸들러를 사용할 수 없습니다. 따라서 의 &lt;code&gt;restore_command&lt;/code&gt; 는 장애 조치를 트리거하기에 적합하지 않습니다. 특히 알려진 &lt;code&gt;archive_timeout&lt;/code&gt; 과 함께 사용되는 경우 간단한 시간 종료 기능을 사용할 수 있습니다.기본 설정. 그러나 네트워크 문제 또는 사용중인 주 서버가 장애 조치를 시작하기에 충분할 수 있기 때문에 다소 오류가 발생하기 쉽습니다. 명시 적으로 트리거 파일을 생성하는 등의 알림 메커니즘이 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="9ecf9a698c1e522b9c1de1bf5af789211b8be7ed" translate="yes" xml:space="preserve">
          <source>The millennium</source>
          <target state="translated">밀레니엄</target>
        </trans-unit>
        <trans-unit id="d49286ea0d415b0aad37189b731269fb41a33f65" translate="yes" xml:space="preserve">
          <source>The minute component of the time zone offset</source>
          <target state="translated">시간대 오프셋의 분 구성 요소</target>
        </trans-unit>
        <trans-unit id="70c1dd6d1f4cd9d65c5ea9908ee66b76d8b0f4e4" translate="yes" xml:space="preserve">
          <source>The minutes field (0 - 59)</source>
          <target state="translated">분 필드 (0-59)</target>
        </trans-unit>
        <trans-unit id="8e27da07ae7efc7685d90ec013484c3ec2a72626" translate="yes" xml:space="preserve">
          <source>The minutes field (0&amp;ndash;59)</source>
          <target state="translated">분 필드 (0&amp;ndash;59)</target>
        </trans-unit>
        <trans-unit id="f58bb99f67c9dd4fa543f324ba0a954d9aeea2c7" translate="yes" xml:space="preserve">
          <source>The missing positions 1,2,4 are because of stop words. Ranks calculated for documents with and without stop words are quite different:</source>
          <target state="translated">누락 된 위치 1,2,4는 정지 단어 때문입니다. 중지 단어가 있거나없는 문서에 대해 계산 된 순위는 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7efece902ce6baec1dac421e4950dc636bcb9bc8" translate="yes" xml:space="preserve">
          <source>The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot precede positional arguments. For example:</source>
          <target state="translated">혼합 표기법은 위치 표기법과 명명 된 표기법을 결합합니다. 그러나 이미 언급했듯이 명명 된 인수는 위치 인수 앞에 올 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dfdfde6fd27332a6600ccf2d0ac2ce0c45f7420f" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">함수, 프로 시저의 모드 또는 집계 인수 : &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다. 참고 &lt;code&gt;ALTER EXTENSION&lt;/code&gt; 는 실제로 어떤 관심을 지불하지 않는 &lt;code&gt;OUT&lt;/code&gt; 의 경우에만 입력 인수는 함수의 정체성을 결정하는 데 필요하기 때문에, 인수. 따라서 &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 및 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 를 나열하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="68b58e6626dcfa87dd99931a1610596ebfd41322" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">함수, 프로 시저의 모드 또는 집계 인수 : &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다. 참고 &lt;code&gt;COMMENT&lt;/code&gt; 를 실제로 어떤 관심을 지불하지 않는 &lt;code&gt;OUT&lt;/code&gt; 의 경우에만 입력 인수는 함수의 정체성을 결정하는 데 필요하기 때문에, 인수. 따라서 &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 및 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 를 나열하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="d48b93746498257a59bb7fe4e61442dbe73691fd" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">함수, 프로 시저의 모드 또는 집계 인수 : &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다. 참고 &lt;code&gt;SECURITY LABEL&lt;/code&gt; 실제로 어떤 관심을 지불하지 않는 &lt;code&gt;OUT&lt;/code&gt; 의 경우에만 입력 인수는 함수의 정체성을 결정하는 데 필요하기 때문에, 인수. 따라서 &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 및 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 를 나열하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="45f33dca690dafc673c0eaa64fba7b4d58d74383" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. (Aggregate functions do not support &lt;code&gt;OUT&lt;/code&gt; arguments.) If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only the last argument can be marked &lt;code&gt;VARIADIC&lt;/code&gt;.</source>
          <target state="translated">인수의 모드 : &lt;code&gt;IN&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 집계 함수는 &lt;code&gt;OUT&lt;/code&gt; 인수를 지원하지 않습니다 . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다. 마지막 인수 만 &lt;code&gt;VARIADIC&lt;/code&gt; 로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4568485f8330f08f8282bc3a9f4e6ab0835ae883" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;.</source>
          <target state="translated">인수의 모드 : &lt;code&gt;IN&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d77ba6d205a4cdad089faf693afa61d51e9631c2" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. (&lt;code&gt;OUT&lt;/code&gt; arguments are currently not supported for procedures. Use &lt;code&gt;INOUT&lt;/code&gt; instead.)</source>
          <target state="translated">인수의 모드 : &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다. ( &lt;code&gt;OUT&lt;/code&gt; 인수는 현재 프로 시저에서 지원되지 않습니다. 대신 &lt;code&gt;INOUT&lt;/code&gt; 을 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="38c566bf6c299177523daede4805416a31c75adc" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">인수의 모드 : &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다. 참고 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 실제로 어떤 관심을 지불하지 않는 &lt;code&gt;OUT&lt;/code&gt; 의 경우에만 입력 인수는 함수의 정체성을 결정하는 데 필요하기 때문에, 인수. 따라서 &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 및 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 를 나열하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="0c0698969a82046af9f337be0b0bf94de3d24ca9" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">인수의 모드 : &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다. 참고 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 실제로 어떤 관심을 지불하지 않는 &lt;code&gt;OUT&lt;/code&gt; 의 경우에만 입력 인수는 함수의 정체성을 결정하는 데 필요하기 때문에, 인수. 따라서 &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 및 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 를 나열하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="6f4ca0b892fae54672225fff5e45afe9a23bd3fa" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only &lt;code&gt;OUT&lt;/code&gt; arguments can follow a &lt;code&gt;VARIADIC&lt;/code&gt; one. Also, &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments cannot be used together with the &lt;code&gt;RETURNS TABLE&lt;/code&gt; notation.</source>
          <target state="translated">인수의 모드 : &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;INOUT&lt;/code&gt; 또는 &lt;code&gt;VARIADIC&lt;/code&gt; . 생략하면 기본값은 &lt;code&gt;IN&lt;/code&gt; 입니다. &lt;code&gt;OUT&lt;/code&gt; 인수 만 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 뒤에 올 수 있습니다 . 또한 &lt;code&gt;OUT&lt;/code&gt; 및 &lt;code&gt;INOUT&lt;/code&gt; 인수는 &lt;code&gt;RETURNS TABLE&lt;/code&gt; 표기법 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="51a81b68008882e6907064e5a6c6b245cdf62054" translate="yes" xml:space="preserve">
          <source>The modification of data that is already in the database is referred to as updating. You can update individual rows, all the rows in a table, or a subset of all rows. Each column can be updated separately; the other columns are not affected.</source>
          <target state="translated">이미 데이터베이스에있는 데이터의 수정을 업데이트라고합니다. 개별 행, 테이블의 모든 행 또는 모든 행의 서브 세트를 업데이트 할 수 있습니다. 각 열은 별도로 업데이트 할 수 있습니다. 다른 열은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="853b75e3f66e460231939e7956e83ee3b696375d" translate="yes" xml:space="preserve">
          <source>The module also provides a data type &lt;code&gt;lo&lt;/code&gt;, which is really just a domain of the &lt;code&gt;oid&lt;/code&gt; type. This is useful for differentiating database columns that hold large object references from those that are OIDs of other things. You don't have to use the &lt;code&gt;lo&lt;/code&gt; type to use the trigger, but it may be convenient to use it to keep track of which columns in your database represent large objects that you are managing with the trigger. It is also rumored that the ODBC driver gets confused if you don't use &lt;code&gt;lo&lt;/code&gt; for BLOB columns.</source>
          <target state="translated">이 모듈은 또한 데이터 유형 &lt;code&gt;lo&lt;/code&gt; 를 제공하는데 , 이는 실제로 &lt;code&gt;oid&lt;/code&gt; 유형 의 도메인 일뿐 입니다. 이는 큰 오브젝트 참조를 보유하는 데이터베이스 컬럼을 다른 것의 OID 인 데이터베이스 컬럼과 구별하는 데 유용합니다. 트리거를 사용 하기 위해 &lt;code&gt;lo&lt;/code&gt; 유형을 사용할 필요는 없지만 데이터베이스에서 어떤 열이 트리거로 관리하는 큰 오브젝트를 나타내는 지 추적하는 데 편리 할 수 ​​있습니다. BLOB 열에 &lt;code&gt;lo&lt;/code&gt; 를 사용하지 않으면 ODBC 드라이버가 혼동된다는 소문도 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ca0d62d96cb007036c4e8c71ad66419c59e2b5" translate="yes" xml:space="preserve">
          <source>The module must be loaded by adding &lt;code&gt;pg_stat_statements&lt;/code&gt; to &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, because it requires additional shared memory. This means that a server restart is needed to add or remove the module.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 의&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; 에 &lt;code&gt;pg_stat_statements&lt;/code&gt; 를 추가하여 모듈을로드해야합니다 . 추가 공유 메모리가 필요하기 때문입니다. 즉, 모듈을 추가하거나 제거하려면 서버를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="d72e93f82e4421713f65eb6d758581a8fbe9cccf" translate="yes" xml:space="preserve">
          <source>The module provides a C function &lt;code&gt;pg_buffercache_pages&lt;/code&gt; that returns a set of records, plus a view &lt;code&gt;pg_buffercache&lt;/code&gt; that wraps the function for convenient use.</source>
          <target state="translated">이 모듈은 레코드 세트를 리턴 하는 C 함수 &lt;code&gt;pg_buffercache_pages&lt;/code&gt; 와 편리한 사용을 위해 함수를 랩핑하는 &lt;code&gt;pg_buffercache&lt;/code&gt; 보기 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="32a787e9d3c71749ae7c7075bc8cc6c86f32c2a0" translate="yes" xml:space="preserve">
          <source>The module provides no SQL-accessible functions. To use it, simply load it into the server. You can load it into an individual session:</source>
          <target state="translated">이 모듈은 SQL 액세스 기능을 제공하지 않습니다. 사용하려면 간단히 서버에로드하십시오. 개별 세션에로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b136900f1dbee2d882f7a554d2840c344beb60e" translate="yes" xml:space="preserve">
          <source>The module requires additional shared memory proportional to &lt;code&gt;pg_stat_statements.max&lt;/code&gt;. Note that this memory is consumed whenever the module is loaded, even if &lt;code&gt;pg_stat_statements.track&lt;/code&gt; is set to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;pg_stat_statements.max&lt;/code&gt; 에 비례하는 추가 공유 메모리가 필요합니다 . 이 메모리는 &lt;code&gt;pg_stat_statements.track&lt;/code&gt; 이 &lt;code&gt;none&lt;/code&gt; 으로 설정되어 있어도 모듈이로드 될 때마다 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9ad875208f4afcd97973304af9fd6ef485a5b48" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="translated">구독에 대한 모니터링 정보는 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; &lt;/a&gt; 에서 볼 수 있습니다 . 이보기에는 모든 구독 작업자에 대해 하나의 행이 포함됩니다. 구독에는 상태에 따라 0 개 이상의 활성 구독 작업자가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96530f50681b8674942f17d7870b9786b275bddf" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="translated">구독에 대한 모니터링 정보는 &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; &lt;/a&gt; 에서 볼 수 있습니다 . 이보기에는 모든 서브 스크립 션 작업자에 대해 하나의 행이 있습니다. 구독 상태에 따라 구독에 0 명 이상의 활성 구독 작업자가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f2efea26fbea2f4a0f53659ea7db3de7f00c25" translate="yes" xml:space="preserve">
          <source>The most common reason for conflict between standby queries and WAL replay is &amp;ldquo;early cleanup&amp;rdquo;. Normally, PostgreSQL allows cleanup of old row versions when there are no transactions that need to see them to ensure correct visibility of data according to MVCC rules. However, this rule can only be applied for transactions executing on the master. So it is possible that cleanup on the master will remove row versions that are still visible to a transaction on the standby.</source>
          <target state="translated">대기 쿼리와 WAL 재생간에 충돌이 발생하는 가장 일반적인 이유는 &quot;조기 정리&quot;입니다. 일반적으로 PostgreSQL을 사용하면 MVCC 규칙에 따라 데이터를 올바르게 표시 할 수있는 트랜잭션이 없을 때 이전 행 버전을 정리할 수 있습니다. 그러나이 규칙은 마스터에서 실행되는 트랜잭션에만 적용 할 수 있습니다. 따라서 마스터에서 정리하면 대기 트랜잭션에서 여전히 볼 수있는 행 버전이 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731bbf4edb90976573e528f87d62ab4f72b17368" translate="yes" xml:space="preserve">
          <source>The most critical part of the display is the estimated statement execution cost, which is the planner's guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches). Actually two numbers are shown: the start-up cost before the first row can be returned, and the total cost to return all the rows. For most queries the total cost is what matters, but in contexts such as a subquery in &lt;code&gt;EXISTS&lt;/code&gt;, the planner will choose the smallest start-up cost instead of the smallest total cost (since the executor will stop after getting one row, anyway). Also, if you limit the number of rows to return with a &lt;code&gt;LIMIT&lt;/code&gt; clause, the planner makes an appropriate interpolation between the endpoint costs to estimate which plan is really the cheapest.</source>
          <target state="translated">디스플레이에서 가장 중요한 부분은 예상 명령문 실행 비용으로, 명령문을 실행하는 데 걸리는 시간을 계획하는 사람의 추정치입니다 (임의의 비용 단위로 측정되지만 일반적으로 디스크 페이지 반입을 의미 함). 실제로 두 개의 숫자가 표시됩니다. 첫 번째 행 이전의 시작 비용과 모든 행을 반환하는 총 비용. 대부분의 쿼리에서 총 비용은 중요하지만 &lt;code&gt;EXISTS&lt;/code&gt; 의 하위 쿼리와 같은 컨텍스트 에서 플래너는 가장 작은 총 비용 대신 가장 작은 시작 비용을 선택합니다 (어쨌든 한 행을 얻은 후 실행 프로그램이 중지되므로). 또한 &lt;code&gt;LIMIT&lt;/code&gt; 로 리턴 할 행 수를 제한하는 경우 조항에서 플래너는 엔드 포인트 비용을 적절히 보간하여 어떤 계획이 실제로 가장 저렴한지를 추정합니다.</target>
        </trans-unit>
        <trans-unit id="413b816a60a8ce6de7ad09a5ffb4362dd48af1ec" translate="yes" xml:space="preserve">
          <source>The most fundamental way to set these parameters is to edit the file &lt;code&gt;postgresql.conf&lt;/code&gt;, which is normally kept in the data directory. A default copy is installed when the database cluster directory is initialized. An example of what this file might look like is:</source>
          <target state="translated">이러한 매개 변수를 설정하는 가장 기본적인 방법은 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일을 편집하는 것입니다. postgresql.conf 는 일반적으로 데이터 디렉토리에 보관됩니다. 데이터베이스 클러스터 디렉토리가 초기화 될 때 기본 사본이 설치됩니다. 이 파일의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e306bed63f3a1d9eca423326fcf07e6b9edcc6b0" translate="yes" xml:space="preserve">
          <source>The most important disk monitoring task of a database administrator is to make sure the disk doesn't become full. A filled data disk will not result in data corruption, but it might prevent useful activity from occurring. If the disk holding the WAL files grows full, database server panic and consequent shutdown might occur.</source>
          <target state="translated">데이터베이스 관리자의 가장 중요한 디스크 모니터링 작업은 디스크가 가득 차지 않도록하는 것입니다. 채워진 데이터 디스크는 데이터 손상을 일으키지 않지만 유용한 활동이 발생하지 못하게 할 수 있습니다. WAL 파일을 보유한 디스크가 가득 차면 데이터베이스 서버 패닉이 발생하여 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="877dc37c3736494355fb75407dc41fe0e6f84483" translate="yes" xml:space="preserve">
          <source>The most interesting options are probably &lt;code&gt;compress-algo&lt;/code&gt; and &lt;code&gt;unicode-mode&lt;/code&gt;. The rest should have reasonable defaults.</source>
          <target state="translated">가장 흥미로운 옵션은 아마도 &lt;code&gt;compress-algo&lt;/code&gt; 및 &lt;code&gt;unicode-mode&lt;/code&gt; 일 것 입니다. 나머지는 합리적인 기본값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="9a6d131c4243d30d96e0db292f1623b359a016fb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">이 &lt;em&gt;기능&lt;/em&gt; 에 사용할 &lt;em&gt;플래너 지원 기능&lt;/em&gt; 의 이름 (선택적으로 스키마 규정) . 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;은 37.11 절&lt;/a&gt; 을 참조하십시오. 이 옵션을 사용하려면 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1902fa4c4f3be48a1f8af8f713baf8e7dfa86fb2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">a의 이름 (검증을 거친 스키마) &lt;em&gt;계획 지원 기능은&lt;/em&gt; 이 기능을 사용합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;섹션 37.11&lt;/a&gt; 을 참조하십시오. 이 옵션을 사용하려면 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="14b6fcb4c63d755a00d7e0670d638ed746023a2d" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a domain to be created.</source>
          <target state="translated">만들 도메인의 이름 (선택적으로 스키마로 한정)</target>
        </trans-unit>
        <trans-unit id="38611bfc887263be7f78673bf7d9d5cdb57c578a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator class.</source>
          <target state="translated">연산자 클래스에 대한 색인 메소드 지원 함수 인 함수의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="5902522e953f867bcf2f16270ac0968cc20f9546" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator family. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">연산자 패밀리에 대한 색인 메소드 지원 함수 인 함수의 이름 (선택적으로 스키마 규정). 인수 목록이 지정되지 않은 경우 이름은 스키마에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="d845c7a3b53e4177570415c0bc3bcd5b3195e4e2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence to be altered.</source>
          <target state="translated">변경할 시퀀스의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="86f2ddbdf403f4ceac3ce1673bf568f23dd1ad99" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence.</source>
          <target state="translated">시퀀스의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="ac3e3dd701383980ee625dc0305504430477533a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a specific table or materialized view to vacuum. If the specified table is a partitioned table, all of its leaf partitions are vacuumed.</source>
          <target state="translated">진공화할 특정 테이블 또는 구체화 된 뷰의 이름 (선택적으로 스키마 규정). 지정된 테이블이 파티션 된 테이블 인 경우 모든 리프 파티션이 진공 청소기로 청소됩니다.</target>
        </trans-unit>
        <trans-unit id="53bb17c6184a24ee8382a2d75581d17a4a86859a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a table to truncate. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is truncated. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are truncated. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">자를 테이블의 이름 (선택적으로 스키마 규정). 테이블 이름 앞에 &lt;code&gt;ONLY&lt;/code&gt; 를 지정 하면 해당 테이블 만 잘립니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은 테이블과 그 모든 자손 테이블 (있는 경우) 잘립니다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e64f1d6069ef5fc5ed6316b39d72b0e2b06f901" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a type to be created.</source>
          <target state="translated">작성할 유형의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="f9bf344cdc87b1adaf5636fb2ebcad9f1ddba5b6" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a view to be created.</source>
          <target state="translated">작성할보기의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="b639552e986e941a3c10c2544ec995a239ffb6e3" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing &lt;code&gt;btree&lt;/code&gt; operator family that describes the sort ordering associated with an ordering operator.</source>
          <target state="translated">순서화 연산자와 연관된 정렬 순서를 설명 하는 기존 &lt;code&gt;btree&lt;/code&gt; 연산자 제품군 의 이름 (선택적으로 스키마 규정) .</target>
        </trans-unit>
        <trans-unit id="34900785f9149eeefbc60e92cda94ca173cd04e7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing aggregate function.</source>
          <target state="translated">기존 집계 함수의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="578ce1660a308750d3e750170be95b160d2b4eaa" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing collation.</source>
          <target state="translated">기존 데이터 정렬의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="f41ad29e0b7f082d84fd62fd8cb20d2acca4d7fc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing conversion.</source>
          <target state="translated">기존 전환의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="3906d435eac2789ae790437fa866de097132bd5f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing domain.</source>
          <target state="translated">기존 도메인의 이름 (선택적으로 스키마로 한정)</target>
        </trans-unit>
        <trans-unit id="d79e2ff622e47d59db15f73c173411091fa8fabb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing function. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">기존 함수의 이름 (선택적으로 스키마 한정)입니다. 인수 목록이 지정되지 않은 경우 이름은 스키마에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="e19891aa77a7fd37f7b714112d5a229b9e2c2c1e" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing materialized view.</source>
          <target state="translated">기존 구체화 된보기의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="d3c124f08f1d17279d8902cee277b8d4f1a183ad" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator class.</source>
          <target state="translated">기존 연산자 클래스의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="38e2880de321890fbbcce2e9729e127a62b40b76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator family.</source>
          <target state="translated">기존 운영자 제품군의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="054a0dca285caf1e015006f488ef65a3eecedbf4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator.</source>
          <target state="translated">기존 연산자의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="77adb5998ee2e3aabde213dad5e54fd26872e3dc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing procedure. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">기존 프로 시저의 이름 (선택적으로 스키마 규정). 인수 목록이 지정되지 않은 경우 이름은 스키마에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="f544776c8e3c1cef33633f466a66f32aea31c3fe" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table or view. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is scanned. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are scanned. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">기존 테이블 또는 뷰의 이름 (선택적으로 스키마 한정)입니다. 테이블 이름 앞에 &lt;code&gt;ONLY&lt;/code&gt; 를 지정 하면 해당 테이블 만 스캔됩니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은 테이블과 그 모든 자손 테이블 (있는 경우)을 검사합니다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed47b49b5a2826cdd529f07291a0b91365295e5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">변경할 기존 테이블의 이름 (선택적으로 스키마 한정)입니다. 테이블 이름 앞에 &lt;code&gt;ONLY&lt;/code&gt; 를 지정 하면 해당 테이블 만 변경됩니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은 테이블과 그 모든 자손 테이블 (있는 경우) 변경된다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e39d635b5a89d3591bd7fd7ce4ecbe9ffd4c1d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to lock. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is locked. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are locked. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">잠글 기존 테이블의 이름 (선택적으로 스키마 규정). 테이블 이름 앞에 &lt;code&gt;ONLY&lt;/code&gt; 를 지정 하면 해당 테이블 만 잠 깁니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은 테이블과 그 모든 자손 테이블 (있는 경우) 잠겨 있습니다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b428f5695f116b2abd1edd43a6b7f791e930f67" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table.</source>
          <target state="translated">기존 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="d6bac31933d004e229772d4577bb5205aa40d1b4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search configuration.</source>
          <target state="translated">기존 텍스트 검색 구성의 이름 (선택적으로 스키마로 한정)</target>
        </trans-unit>
        <trans-unit id="c30fa81fa2fa2992c5e25e7be26425ba28f70618" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search dictionary.</source>
          <target state="translated">기존 텍스트 검색 사전의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="6764c434bb1917335a8e7ae9bad93f1fcc49fc17" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search parser.</source>
          <target state="translated">기존 텍스트 검색 파서의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="dcc71c03641d807db453dbb54b0a2fce72902867" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search template.</source>
          <target state="translated">기존 텍스트 검색 템플릿의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="c07fc33a37601af59ca6761edf035f64fe688e76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing view.</source>
          <target state="translated">기존보기의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="5f3b87270ccb7b31876399c63171eeddc6c5acd0" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an index to remove.</source>
          <target state="translated">제거 할 인덱스의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="4d1a15fbadbb463eba7072f8d97b36fff8e4db35" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator class.</source>
          <target state="translated">연산자 클래스와 연관된 연산자의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="f55c07895028de262598e75436d631175b201a69" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator family.</source>
          <target state="translated">운영자 제품군과 연관된 운영자의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="b2bd7b76dedcec38eb17eed38f1b959f8bd417a7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the aggregate function to create.</source>
          <target state="translated">작성할 집계 함수의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="a93a4bd4bc9034a1432f189ca88e837333dc130b" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the data type to remove.</source>
          <target state="translated">제거 할 데이터 유형의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="985217a7a1fa0c3a567eb7244b6b8b146f2c7b30" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the foreign table to drop.</source>
          <target state="translated">제거 할 외부 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="c10f31992b2571e70d614bb2d060a79ba59a8a33" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the function to create.</source>
          <target state="translated">작성할 함수의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="83e9847814c3ba939cbc4f420e1c3c7c00a69552" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to be created.</source>
          <target state="translated">작성할 구체화 된보기의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="2255582209b1f3da815e53122bc13a8a7b84cf00" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to refresh.</source>
          <target state="translated">새로 고칠 구체화 된보기의 이름 (선택적으로 스키마 규정)입니다.</target>
        </trans-unit>
        <trans-unit id="2db1fb74b2f868165f2c5564d755e2f43c24353f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to remove.</source>
          <target state="translated">제거 할 구체화 된보기의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="9df0359ba8b94b06eb25b013152842f292a7b4df" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure to create.</source>
          <target state="translated">작성할 프로 시저의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="4cd07bcb956404ed169f912452a4480e70e115e4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure.</source>
          <target state="translated">프로 시저의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="2a4c2e1b22bdcbf405362b9ae17fa1fbce426df2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the sequence to be created.</source>
          <target state="translated">작성 될 순서의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="048a9ab4e359ce8b95a4959e9df97e30c4e65d60" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be altered.</source>
          <target state="translated">변경할 통계 개체의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="f52881167770a0af5eb7409ca2185b9c04bac337" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be created.</source>
          <target state="translated">작성할 통계 오브젝트의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="4b423cb4d9cc1b2bcdad9b8dd172fb72d89e4e2c" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to drop.</source>
          <target state="translated">제거 할 통계 오브젝트의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="b61d21dada065f46c4c7b2b7d604e26966040dc1" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table containing the column(s) the statistics are computed on.</source>
          <target state="translated">통계가 계산되는 열을 포함하는 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="8defd757e6f0ae34c512e774b626ccf674726eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table for which the trigger is defined.</source>
          <target state="translated">트리거가 정의 된 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="4d5698a39cc31b5f7b88bdd408f67f5c7638f5d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view that the rule applies to.</source>
          <target state="translated">규칙이 적용되는 테이블 또는 뷰의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="b756bc816e4bf98b49581640b12dbf571a3be447" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view the rule applies to.</source>
          <target state="translated">규칙이 적용되는 테이블 또는 뷰의 이름 (선택적으로 스키마 한정)입니다.</target>
        </trans-unit>
        <trans-unit id="1babb726cd58996c0c81dade9eb62f3731eca7ef" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table that the policy is on.</source>
          <target state="translated">정책이있는 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="66f5ae5d2b295f1ee2b970f57d5d9ecd6bf021d8" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table the policy applies to.</source>
          <target state="translated">정책이 적용되는 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="2163decbe5c6781dc3c30049b04dc6fe3b754ccd" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to be created.</source>
          <target state="translated">작성할 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="7faaacd9226a4e88c9e4c1c3c739210417e124ce" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to delete rows from. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are deleted from the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also deleted from any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">행을 삭제할 테이블의 이름 (선택적으로 스키마 규정). 경우 &lt;code&gt;ONLY&lt;/code&gt; 테이블 이름 앞에 지정, 일치하는 행은 지정된 테이블에서 삭제됩니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은, 일치하는 행은 지정된 테이블에서 상속하는 모든 테이블에서 삭제됩니다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a919fb8f51d9d6b6757a121c98308d8b2e355a9" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to drop.</source>
          <target state="translated">제거 할 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="805225c1106f83d7720b93b38e959f1241d2a307" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to update. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are updated in the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also updated in any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">업데이트 할 테이블의 이름 (선택적으로 스키마 한정)입니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 테이블 이름 앞에 지정, 일치하는 행은 지정된 테이블에 업데이트됩니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은, 일치하는 행은 지정된 테이블에서 상속하는 모든 테이블에 업데이트됩니다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56ec5e8966f4a00d4b5c2a7c99ee7bd04c931eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table, view, or foreign table the trigger is for.</source>
          <target state="translated">트리거가 사용되는 테이블, 뷰 또는 외부 테이블의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="72a54509c9fcd2a9291f8a3e62487b349d23e646" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the view to remove.</source>
          <target state="translated">제거 할보기의 이름 (선택적으로 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="359f50eaf29e3eca920ffd05f6355f20cb0c9f2e" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a specific table to analyze. If omitted, all regular tables, partitioned tables, and materialized views in the current database are analyzed (but not foreign tables). If the specified table is a partitioned table, both the inheritance statistics of the partitioned table as a whole and statistics of the individual partitions are updated.</source>
          <target state="translated">분석 할 특정 테이블의 이름 (아마도 스키마 한정)입니다. 생략하면 현재 데이터베이스의 모든 일반 테이블, 파티션 된 테이블 및 구체화 된 뷰가 분석되지만 외부 테이블은 분석되지 않습니다. 지정된 테이블이 파티션 된 테이블 인 경우 파티션 된 테이블의 전체 상속 통계와 개별 파티션의 통계가 모두 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a0cd47e6e1a9ee5389b9c55e40402c5ad699bfc0" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a table.</source>
          <target state="translated">테이블의 이름 (아마도 스키마 한정)</target>
        </trans-unit>
        <trans-unit id="36578a59c82b2f2c476f7f18ac9898c7cebf4713" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing domain to alter.</source>
          <target state="translated">변경할 기존 도메인의 이름 (아마도 스키마 한정)</target>
        </trans-unit>
        <trans-unit id="c76b8e93831ffb6b044097c12ef94efed652a62a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing foreign table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">변경할 기존 외부 테이블의 이름 (아마도 스키마로 한정된)입니다. 테이블 이름 앞에 &lt;code&gt;ONLY&lt;/code&gt; 를 지정 하면 해당 테이블 만 변경됩니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은 테이블과 그 모든 자손 테이블 (있는 경우) 변경된다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6c50c1390116c899b9f1d7b2719134752e51ac" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing index to alter.</source>
          <target state="translated">변경할 기존 인덱스의 이름 (아마도 스키마 한정)</target>
        </trans-unit>
        <trans-unit id="f3966882870cfe613d0a8e73355b9179fb2c810a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing type to alter.</source>
          <target state="translated">변경할 기존 유형의 이름 (아마도 스키마 한정)</target>
        </trans-unit>
        <trans-unit id="06da0274ecfe82f800f0ab5a5f38a984e49a92a1" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of the table to be indexed.</source>
          <target state="translated">색인화 할 테이블의 이름 (아마도 스키마 규정).</target>
        </trans-unit>
        <trans-unit id="a158ac6caffff3f341ed81dff98d22b9af284fcf" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;test1_id_index&lt;/code&gt; can be chosen freely, but you should pick something that enables you to remember later what the index was for.</source>
          <target state="translated">이름 &lt;code&gt;test1_id_index&lt;/code&gt; 는 자유롭게 선택할 수 있지만 나중에 인덱스의 내용을 기억할 수있는 항목을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="27865390113cdcda66f400351749779a6e670188" translate="yes" xml:space="preserve">
          <source>The name can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). Only printable ASCII characters may be used in the &lt;code&gt;cluster_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;). No name is shown if this parameter is set to the empty string &lt;code&gt;''&lt;/code&gt; (which is the default). This parameter can only be set at server start.</source>
          <target state="translated">이름은 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 자 (표준 빌드에서 64 자) 미만의 문자열 일 수 있습니다 . &lt;code&gt;cluster_name&lt;/code&gt; 값 에는 인쇄 가능한 ASCII 문자 만 사용할 수 있습니다 . 다른 문자는 물음표 ( &lt;code&gt;?&lt;/code&gt; ) 로 바뀝니다 . 이 매개 변수가 빈 문자열 &lt;code&gt;''&lt;/code&gt; (기본값) 로 설정되면 이름이 표시되지 않습니다 . 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be2813c09731c2a742fdb24fc852c07e13e3ed7" translate="yes" xml:space="preserve">
          <source>The name of a &lt;code&gt;table_name&lt;/code&gt; column. Used to infer arbiter indexes. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on &lt;code&gt;index_column_name&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 열의 이름입니다 . 중재자 인덱스를 유추하는 데 사용됩니다. &lt;code&gt;CREATE INDEX&lt;/code&gt; 형식을 따릅니다 . &lt;code&gt;index_column_name&lt;/code&gt; 에 대한 &lt;code&gt;SELECT&lt;/code&gt; 특권 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="347e4a2b8b46492f607cf8e79afee93d1d470e6b" translate="yes" xml:space="preserve">
          <source>The name of a b-tree operator class for the subtype.</source>
          <target state="translated">하위 유형에 대한 b- 트리 연산자 클래스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="84001d19bb8ee2bc0f3fd3214b7948ea87315d70" translate="yes" xml:space="preserve">
          <source>The name of a base-type property to be modified; see above for possible values.</source>
          <target state="translated">수정할 기본 유형 속성의 이름입니다. 가능한 값은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3e4c963309e1915e51f2989fadcd94d4d9264511" translate="yes" xml:space="preserve">
          <source>The name of a column in the new materialized view. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">새로운 구체화 된보기의 열 이름입니다. 열 이름을 제공하지 않으면 쿼리의 출력 열 이름에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="38a996c1d10563af1a139319a2d1ffd30fc57281" translate="yes" xml:space="preserve">
          <source>The name of a column in the new table. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">새 테이블의 열 이름입니다. 열 이름을 제공하지 않으면 쿼리의 출력 열 이름에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="88674d0aca3396b42507d5f644ff534993edea22" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) When referencing a column with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;, do not include the table's name in the specification of a target column. For example, &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; is invalid (this follows the general behavior for &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 으로 명명 된 테이블의 열 이름입니다 . 필요한 경우 서브 필드 이름 또는 배열 첨자로 컬럼 이름을 규정 할 수 있습니다. (복합 열의 일부 필드에만 삽입하면 다른 필드는 널로 남습니다.) &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 로 열을 참조 할 때 대상 열 스펙에 테이블 이름을 포함시키지 마십시오 . 예를 들어, &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; 이 유효하지 않습니다 (이는 &lt;code&gt;UPDATE&lt;/code&gt; 의 일반적인 동작을 따릅니다 ).</target>
        </trans-unit>
        <trans-unit id="37965fca46dac2ae8978b3ba3784bd4c0e6d710a" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. Do not include the table's name in the specification of a target column &amp;mdash; for example, &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 으로 명명 된 테이블의 열 이름입니다 . 필요한 경우 서브 필드 이름 또는 배열 첨자로 컬럼 이름을 규정 할 수 있습니다. 대상 열 스펙에 테이블 이름을 포함하지 마십시오. 예를 들어, &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; 은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43b0ac7767512f2c3828414a44343ffbdea05c48" translate="yes" xml:space="preserve">
          <source>The name of a column of the table.</source>
          <target state="translated">테이블의 열 이름입니다.</target>
        </trans-unit>
        <trans-unit id="66eab6eba8b42b05c2deccc82d07f73f07802b19" translate="yes" xml:space="preserve">
          <source>The name of a column to be created in the new table.</source>
          <target state="translated">새 테이블에서 작성 될 열의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b107b21b5ebe28c88ce9e0df68fea5f76d67283a" translate="yes" xml:space="preserve">
          <source>The name of a database to create.</source>
          <target state="translated">작성할 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2836c4dd7800c0b2de8f3f3ed8ae3591f1a8fd6b" translate="yes" xml:space="preserve">
          <source>The name of a difference function for the subtype.</source>
          <target state="translated">하위 유형에 대한 차이 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="cc2b3b4a893c2c09d0bead8670c584d57f2b3d8a" translate="yes" xml:space="preserve">
          <source>The name of a function that converts an array of modifier(s) for the type into internal form.</source>
          <target state="translated">형식에 대한 수정 자 배열을 내부 형식으로 변환하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9cfae7f4211e6fa9e0eeadb788b0238e1401f532" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external binary form to its internal form.</source>
          <target state="translated">데이터를 형식의 외부 이진 형식에서 내부 형식으로 변환하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b8ec9150353430f953f8a2508fb1cc00d06ec3ad" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external textual form to its internal form.</source>
          <target state="translated">데이터를 형식의 외부 텍스트 형식에서 내부 형식으로 변환하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e45bf619f83208134b19be3fe39ffa394657e429" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external binary form.</source>
          <target state="translated">데이터를 형식의 내부 형식에서 외부 이진 형식으로 변환하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ec568fe6711779cbc4fe49c405863a46d77641d0" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external textual form.</source>
          <target state="translated">데이터를 형식의 내부 형식에서 외부 텍스트 형식으로 변환하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a4232581838ec7343a99a8c7be95b2e49c198605" translate="yes" xml:space="preserve">
          <source>The name of a function that converts the internal form of the type's modifier(s) to external textual form.</source>
          <target state="translated">형식 수정 자의 내부 형식을 외부 텍스트 형식으로 변환하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4ebc5121bc2fa18e076b2f1de0b2de537a76ba61" translate="yes" xml:space="preserve">
          <source>The name of a function that performs statistical analysis for the data type.</source>
          <target state="translated">데이터 유형에 대한 통계 분석을 수행하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8693551fac54570d94fac46289d20bd3cbf6ee4e" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">함수, 프로 시저 또는 집계 인수의 이름 참고 &lt;code&gt;ALTER EXTENSION&lt;/code&gt; 만을 인수 데이터 유형이 함수의 정체성을 결정하는 데 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fe30dcb3f4583c58770f03da94374abd82c96ab" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">함수, 프로 시저 또는 집계 인수의 이름 참고 &lt;code&gt;COMMENT&lt;/code&gt; 를 유일한 인수 데이터 유형이 함수의 정체성을 결정하는 데 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="037ed7ab4666d9436acdd62556426330fa27de4d" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">함수, 프로 시저 또는 집계 인수의 이름 참고 &lt;code&gt;SECURITY LABEL&lt;/code&gt; 유일한 인수 데이터 유형이 함수의 정체성을 결정하는 데 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85d26a05a8c2a48486d4d983a4308017ec19fa06" translate="yes" xml:space="preserve">
          <source>The name of a role whose objects will be dropped, and whose privileges will be revoked.</source>
          <target state="translated">개체가 삭제되고 권한이 취소 될 역할의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2d651ee55d17fde141e789374afa64231439951d" translate="yes" xml:space="preserve">
          <source>The name of a role. The ownership of all the objects within the current database, and of all shared objects (databases, tablespaces), owned by this role will be reassigned to &lt;code&gt;new_role&lt;/code&gt;.</source>
          <target state="translated">역할의 이름입니다. 이 역할이 소유 한 현재 데이터베이스 내의 모든 오브젝트 및 모든 공유 오브젝트 (데이터베이스, 테이블 스페이스)의 소유권이 &lt;code&gt;new_role&lt;/code&gt; 에 재 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a41f912a967bc6187a0ff565790395916fca2f2a" translate="yes" xml:space="preserve">
          <source>The name of a rule to create. This must be distinct from the name of any other rule for the same table. Multiple rules on the same table and same event type are applied in alphabetical name order.</source>
          <target state="translated">만들 규칙의 이름입니다. 동일한 테이블에 대한 다른 규칙의 이름과 구별되어야합니다. 동일한 테이블 및 동일한 이벤트 유형에 대한 여러 규칙이 알파벳 이름 순서로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="16dbd653daa2713c731e96ec7016300d7b0623c9" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="translated">런타임 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 및 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 참조 페이지에 설명되어 있습니다. 또한 표시 할 수 있지만 설정할 수없는 몇 가지 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aee34bf395a3fa67b708559214834f0819e94a8b" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="translated">런타임 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 과 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 참조 페이지에 설명되어 있습니다. 또한 표시 할 수 있지만 설정할 수없는 몇 가지 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdb5b09a2e8ba40ee029ef0bb0deb2b715d29f64" translate="yes" xml:space="preserve">
          <source>The name of a schema to be created. If this is omitted, the &lt;code&gt;user_name&lt;/code&gt; is used as the schema name. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">작성할 스키마의 이름입니다. 이를 생략하면 &lt;code&gt;user_name&lt;/code&gt; 이 스키마 이름으로 사용됩니다. 시스템 스키마 용으로 예약되어 있으므로 이름은 &lt;code&gt;pg_&lt;/code&gt; 로 시작할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="19552fb60b57524fdf3c4ba971f713deaf575934" translate="yes" xml:space="preserve">
          <source>The name of a schema.</source>
          <target state="translated">스키마의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bec37b1bb0aae7199fe140e94c49fd869d890cc2" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns.</source>
          <target state="translated">분석 할 특정 열의 이름입니다. 모든 열이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f4dd69da6250801b1a99f96f4fc7a1fc3fc7a5ca" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns. If a column list is specified, &lt;code&gt;ANALYZE&lt;/code&gt; must also be specified.</source>
          <target state="translated">분석 할 특정 열의 이름입니다. 모든 열이 기본값입니다. 열 목록이 지정된 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d277ce7dc1369544c960227202849bca34e3070" translate="yes" xml:space="preserve">
          <source>The name of a standby server for this purpose is the &lt;code&gt;application_name&lt;/code&gt; setting of the standby, as set in the standby's connection information. In case of a physical replication standby, this should be set in the &lt;code&gt;primary_conninfo&lt;/code&gt; setting; the default is the setting of &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; if set, else &lt;code&gt;walreceiver&lt;/code&gt;. For logical replication, this can be set in the connection information of the subscription, and it defaults to the subscription name. For other replication stream consumers, consult their documentation.</source>
          <target state="translated">이를위한 대기 서버의 이름은 대기 연결 정보에 설정된 대기 의 &lt;code&gt;application_name&lt;/code&gt; 설정입니다. 물리적 복제 대기의 경우 &lt;code&gt;primary_conninfo&lt;/code&gt; 설정 에서 설정해야 합니다. 설정된 경우 기본값은 &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name의&lt;/a&gt; 설정이며 그렇지 &lt;code&gt;walreceiver&lt;/code&gt; 경우 walreceiver 입니다. 논리적 복제의 경우 구독의 연결 정보에서이를 설정할 수 있으며 기본적으로 구독 이름입니다. 다른 복제 스트림 소비자는 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8bcdb2c75dca6dff745c6b72d3eafa935add170" translate="yes" xml:space="preserve">
          <source>The name of a subscription to be dropped.</source>
          <target state="translated">제거 할 구독의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="10c04b3f0b50c7a796c21e054204f49c5305809f" translate="yes" xml:space="preserve">
          <source>The name of a subscription whose properties are to be altered.</source>
          <target state="translated">등록 정보를 변경할 구독의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a917fa888db788a84ebf308d993302ba69b3956f" translate="yes" xml:space="preserve">
          <source>The name of a table column to be covered by the computed statistics. At least two column names must be given; the order of the column names is insignificant.</source>
          <target state="translated">계산 된 통계에 포함되는 테이블 열의 이름입니다. 최소한 두 개의 열 이름을 지정해야합니다. 열 이름의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="547022940eaa9d3307e6377842b21fffa3dea285" translate="yes" xml:space="preserve">
          <source>The name of a table storage parameter.</source>
          <target state="translated">테이블 스토리지 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="25f3d061a48202d36e2eddaaf0e7e422750642c9" translate="yes" xml:space="preserve">
          <source>The name of a tablespace to be created. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">작성할 테이블 스페이스의 이름입니다. 이름은 시스템 테이블 스페이스 용으로 예약되어 있으므로 &lt;code&gt;pg_&lt;/code&gt; 로 시작할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f526639651b0458136ca498c2f2f2ac4fbd6800d" translate="yes" xml:space="preserve">
          <source>The name of a tablespace.</source>
          <target state="translated">테이블 스페이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3f86890bb22a9b09c6fb6202e966b0cb90e86399" translate="yes" xml:space="preserve">
          <source>The name of a template-specific option to be set for this dictionary.</source>
          <target state="translated">이 사전에 설정할 템플릿 별 옵션의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d2fc4bb5096ba459cde4afbb76fdac536da62aa5" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be consulted for the specified token type(s). If multiple dictionaries are listed, they are consulted in the specified order.</source>
          <target state="translated">지정된 토큰 유형에 대해 참조 할 텍스트 검색 사전의 이름입니다. 여러 사전이 나열되면 지정된 순서대로 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ade2843219f0c75eecbdfb9ad26e157949ac15" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be replaced in the mapping.</source>
          <target state="translated">맵핑에서 대체 할 텍스트 검색 사전의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c2e4d9635ee5eae77abbb98d0d04f44a7382134a" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be substituted for &lt;code&gt;old_dictionary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old_dictionary&lt;/code&gt; 로 대체 할 텍스트 검색 사전의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="e536a7c03f29f8cbc17f3a583238f110ae4c9ca6" translate="yes" xml:space="preserve">
          <source>The name of a token type that is emitted by the configuration's parser.</source>
          <target state="translated">구성 파서가 생성 한 토큰 유형의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e42ab0f9b2f16ce7c6531f791e195b576f9b5e7b" translate="yes" xml:space="preserve">
          <source>The name of a variable used to filter events. This makes it possible to restrict the firing of the trigger to a subset of the cases in which it is supported. Currently the only supported &lt;code&gt;filter_variable&lt;/code&gt; is &lt;code&gt;TAG&lt;/code&gt;.</source>
          <target state="translated">이벤트를 필터링하는 데 사용되는 변수의 이름입니다. 이를 통해 트리거 발생을 지원되는 경우의 하위 세트로 트리거 할 수 있습니다. 현재 유일하게 지원되는 &lt;code&gt;filter_variable&lt;/code&gt; 은 &lt;code&gt;TAG&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbbf80f6f4c468a122711e341fba3efb95ed9b4e" translate="yes" xml:space="preserve">
          <source>The name of an argument.</source>
          <target state="translated">인수의 이름</target>
        </trans-unit>
        <trans-unit id="e982fa6e95b8aff320484711c377b6849476a259" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">인수의 이름 참고 &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; 만 인수 데이터 유형이 집계 함수의 ID를 결정하기 위해 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56b0baceffec189e51468368e1573f50c02b2801" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">인수의 이름 참고 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 만을 인수 데이터 유형이 함수의 정체성을 결정하는 데 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da880762c1ed4640b76217347360561ae983a357" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">인수의 이름 참고 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 만 인수 데이터 유형이 절차의 정체성을 결정하는 데 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0681d59ee9000bab536592eb7b8ddac88b06215c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">인수의 이름 참고 &lt;code&gt;DROP AGGREGATE&lt;/code&gt; 가 유일한 인수 데이터 유형이 집계 함수의 ID를 결정하기 위해 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f97c790620d0347b2dc1f2b503ffe310415155c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">인수의 이름 참고 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 만을 인수 데이터 유형이 함수의 정체성을 결정하는 데 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75484c7635e6405e3d0e3238f7f514ab40e45aaa" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">인수의 이름 참고 &lt;code&gt;DROP PROCEDURE&lt;/code&gt; 는 단지 인수 데이터 유형이 절차의 정체성을 결정하는 데 필요하기 때문에 실제로 인수 이름에 어떤 관심을 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6264b5b03c956e34b1a101cf23f2e7ebcfb44a8b" translate="yes" xml:space="preserve">
          <source>The name of an argument. Some languages (including SQL and PL/pgSQL) let you use the name in the function body. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability (see &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt;). In any case, the name of an output argument is significant, because it defines the column name in the result row type. (If you omit the name for an output argument, the system will choose a default column name.)</source>
          <target state="translated">인수의 이름 일부 언어 (SQL 및 PL / pgSQL 포함)를 사용하면 함수 본문에서 이름을 사용할 수 있습니다. 다른 언어의 경우 입력 인수의 이름은 함수 자체에 관한 한 추가 문서 일뿐입니다. 그러나 가독성을 높이기 위해 함수를 호출 할 때 입력 인수 이름을 사용할 수 있습니다 ( &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;4.3 단원&lt;/a&gt; 참조 ). 어쨌든 출력 인수의 이름은 결과 행 유형에서 열 이름을 정의하므로 중요합니다. (출력 인수의 이름을 생략하면 시스템은 기본 열 이름을 선택합니다.)</target>
        </trans-unit>
        <trans-unit id="375094d89a9e7c5813b8961536891f0759815217" translate="yes" xml:space="preserve">
          <source>The name of an argument. This is currently only useful for documentation purposes. If omitted, the argument has no name.</source>
          <target state="translated">인수의 이름 이것은 현재 문서화 목적으로 만 유용합니다. 생략하면 인수 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed524d1ea7eb8aeebc2ae58ea9eeac500ae4de68" translate="yes" xml:space="preserve">
          <source>The name of an attribute (column) for the composite type.</source>
          <target state="translated">복합 유형의 속성 이름 (열).</target>
        </trans-unit>
        <trans-unit id="6a17e927a8bc128615b789bf21656b4af0a59747" translate="yes" xml:space="preserve">
          <source>The name of an existing access method.</source>
          <target state="translated">기존 액세스 방법의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ebcda1893633e936b520a2a0321ab231b1b0ba97" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to be associated with a column of a composite type, or with a range type.</source>
          <target state="translated">복합 유형의 열 또는 범위 유형과 연관 될 기존 데이터 정렬의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6a99a7164db5effbf0ea0eafd9c39dd9aa197443" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to copy. The new collation will have the same properties as the existing one, but it will be an independent object.</source>
          <target state="translated">복사 할 기존 데이터 정렬의 이름입니다. 새 데이터 정렬은 기존 데이터 정렬과 동일한 속성을 갖지만 독립적 인 개체입니다.</target>
        </trans-unit>
        <trans-unit id="af62875da4376911af8fd6633488eb76e3df9aa2" translate="yes" xml:space="preserve">
          <source>The name of an existing data type that the new type will have the same representation as. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from that type, unless overridden by explicit specification elsewhere in this &lt;code&gt;CREATE TYPE&lt;/code&gt; command.</source>
          <target state="translated">새 유형이 나타내는 기존 데이터 유형의 이름입니다. 이 &lt;code&gt;CREATE TYPE&lt;/code&gt; 명령의 다른 곳에서 명시적인 스펙으로 대체되지 않는 한 &lt;code&gt;internallength&lt;/code&gt; , &lt;code&gt;passedbyvalue&lt;/code&gt; , &lt;code&gt;alignment&lt;/code&gt; 및 &lt;code&gt;storage&lt;/code&gt; 값은 해당 유형에서 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="269f93ea4a18405eca9d42f3c25429fa59f4bc3d" translate="yes" xml:space="preserve">
          <source>The name of an existing data type to become a column of the composite type.</source>
          <target state="translated">복합 유형의 열이 될 기존 데이터 유형의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9a63f99fdd0bce011ca8d049908cd4539b298e7c" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign server to use for the foreign table. For details on defining a server, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</source>
          <target state="translated">외부 테이블에 사용할 기존 외부 서버의 이름입니다. 서버 정의에 대한 자세한 내용은 &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2454ed01e6d27ce51d6d152286d9f4044a0971f" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign-data wrapper.</source>
          <target state="translated">기존 외부 데이터 랩퍼의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="215bb96ed8aefedc59bc2785aaa4809857f9f3b1" translate="yes" xml:space="preserve">
          <source>The name of an existing index.</source>
          <target state="translated">기존 색인의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dcfd6d7a1b6a134c08f28bb84b429370f63f9bf9" translate="yes" xml:space="preserve">
          <source>The name of an existing policy to alter.</source>
          <target state="translated">변경할 기존 정책의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d3e43edda0ed2c669ea64ea4de1cacab37227192" translate="yes" xml:space="preserve">
          <source>The name of an existing procedural language. For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="translated">기존 절차 언어의 이름입니다. 이전 버전과의 호환성을 위해 이름을 작은 따옴표로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc811803ec9f6996f00764f5d9b3a696bbe0492" translate="yes" xml:space="preserve">
          <source>The name of an existing publication whose definition is to be altered.</source>
          <target state="translated">정의를 변경할 기존 발행물의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e43f43145062802662e910809c0dbf5106a36151" translate="yes" xml:space="preserve">
          <source>The name of an existing publication.</source>
          <target state="translated">기존 출판물의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="51d243f6e89c7e39326aaa5f0f4dbaf017f84cd3" translate="yes" xml:space="preserve">
          <source>The name of an existing role of which the current role is a member. If &lt;code&gt;FOR ROLE&lt;/code&gt; is omitted, the current role is assumed.</source>
          <target state="translated">현재 역할이 구성원 인 기존 역할의 이름입니다. 경우 &lt;code&gt;FOR ROLE&lt;/code&gt; 생략되면, 현재의 역할을 가정한다.</target>
        </trans-unit>
        <trans-unit id="55490c4e62932d1546a037c62cdff84638b0e3d3" translate="yes" xml:space="preserve">
          <source>The name of an existing role to grant or revoke privileges for. This parameter, and all the other parameters in &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt;, act as described under &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;, except that one is setting permissions for a whole class of objects rather than specific named objects.</source>
          <target state="translated">권한을 부여하거나 취소 할 기존 역할의 이름입니다. 이 매개 변수 및 &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt; 의 다른 모든 매개 변수는 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 또는 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE에&lt;/a&gt; 설명 된대로 작동 합니다. 단, 특정 이름 지정된 오브젝트가 아닌 전체 오브젝트 클래스에 대한 권한을 설정하고 있다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c635ecbb1c53d1706cdab235bd6da7bb6c713113" translate="yes" xml:space="preserve">
          <source>The name of an existing rule to alter.</source>
          <target state="translated">변경할 기존 규칙의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="313ea254effb62079628babb9fa1cbd9eaa5bbb0" translate="yes" xml:space="preserve">
          <source>The name of an existing schema.</source>
          <target state="translated">기존 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="5f4188f167a8cf646d3b7406994faa33188bb313" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when setting privileges for schemas, since schemas can't be nested.</source>
          <target state="translated">기존 스키마의 이름입니다. 지정된 경우 나중에 해당 스키마에서 생성되는 객체에 대한 기본 권한이 변경됩니다. 경우 &lt;code&gt;IN SCHEMA&lt;/code&gt; 생략, 전역 기본 권한이 변경된다. &lt;code&gt;IN SCHEMA&lt;/code&gt; 는 스키마에 대한 권한을 설정할 때 허용되지 않습니다. 스키마는 중첩 될 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cc48699243fdc0b302f46f2ff91dbd816b03aa4b" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when using &lt;code&gt;ON SCHEMAS&lt;/code&gt; as schemas can't be nested.</source>
          <target state="translated">기존 스키마의 이름 지정된 경우 나중에 해당 스키마에서 생성 된 객체에 대한 기본 권한이 변경됩니다. 경우 &lt;code&gt;IN SCHEMA&lt;/code&gt; 생략, 전역 기본 권한이 변경된다. &lt;code&gt;ON SCHEMAS&lt;/code&gt; 를 중첩 할 수 없으므로 ON SCHEMAS 를 사용하는 경우 &lt;code&gt;IN SCHEMA&lt;/code&gt; 가 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="02ea513b553c81e6e8bfffc28bfc183407ce6f92" translate="yes" xml:space="preserve">
          <source>The name of an existing server for which the user mapping is to be created.</source>
          <target state="translated">사용자 맵핑이 작성 될 기존 서버의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="94ab6bc9007ffe24527bb571f8caf6972fd6e32c" translate="yes" xml:space="preserve">
          <source>The name of an existing server.</source>
          <target state="translated">기존 서버의 이름</target>
        </trans-unit>
        <trans-unit id="7b99635b20ef9c6fbf704b3d5683df0c76ea50a5" translate="yes" xml:space="preserve">
          <source>The name of an existing tablespace.</source>
          <target state="translated">기존 테이블 스페이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1fba9536f8e094817879340972f3fc186e59ac3a" translate="yes" xml:space="preserve">
          <source>The name of an existing text search configuration to copy.</source>
          <target state="translated">복사 할 기존 텍스트 검색 구성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e62d3905f77c5380a51ef346837f8bb973da087a" translate="yes" xml:space="preserve">
          <source>The name of an existing trigger to alter.</source>
          <target state="translated">변경할 기존 트리거의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="39eaed243c343dcf7cbdeda1eb27256bd699e984" translate="yes" xml:space="preserve">
          <source>The name of an existing user that is mapped to foreign server. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. When &lt;code&gt;PUBLIC&lt;/code&gt; is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.</source>
          <target state="translated">외부 서버에 맵핑 된 기존 사용자의 이름 &lt;code&gt;CURRENT_USER&lt;/code&gt; 및 &lt;code&gt;USER&lt;/code&gt; 는 현재 사용자의 이름과 일치합니다. &lt;code&gt;PUBLIC&lt;/code&gt; 을 지정 하면 사용자 별 맵핑이 적용되지 않는 소위 공용 맵핑이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7ff3e30c52fed6a21d64c778f1c3cb5bfde69e2e" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter.</source>
          <target state="translated">색인 방법 별 스토리지 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="391b7b7e4f5957c20764197abfbac06a778f9581" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; below for details.</source>
          <target state="translated">인덱스 메소드 별 스토리지 매개 변수의 이름입니다. 자세한 내용은 아래의 &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;인덱스 저장 매개 변수&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="094d120f87047ccaf9df626ee5c7800b9676897f" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; for details.</source>
          <target state="translated">색인 방법 별 스토리지 매개 변수의 이름입니다. 자세한 내용은 &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;인덱스 스토리지 매개 변수&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b4f0f37a4747ead833ac927d954e2f698dfd533d" translate="yes" xml:space="preserve">
          <source>The name of an index.</source>
          <target state="translated">인덱스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="905bf1ebfe51e20690887bb37e5649f46c622ebf" translate="yes" xml:space="preserve">
          <source>The name of an installed extension.</source>
          <target state="translated">설치된 확장의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="31791bd4a497bca0b376ada0235a5c621eadda59" translate="yes" xml:space="preserve">
          <source>The name of an object to be added to or removed from the extension. Names of tables, aggregates, domains, foreign tables, functions, operators, operator classes, operator families, procedures, routines, sequences, text search objects, types, and views can be schema-qualified.</source>
          <target state="translated">확장에 추가하거나 제거 할 개체의 이름입니다. 테이블, 집계, 도메인, 외부 테이블, 함수, 연산자, 연산자 클래스, 연산자 패밀리, 프로 시저, 루틴, 시퀀스, 텍스트 검색 오브젝트, 유형 및 뷰의 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="649c7c5351f25263eb73a851a860d7f29c995641" translate="yes" xml:space="preserve">
          <source>The name of an open cursor to close.</source>
          <target state="translated">닫을 열린 커서의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="cd55222991d683c14fbae3099b3d272c1928bd18" translate="yes" xml:space="preserve">
          <source>The name of an operator class parameter. See below for details.</source>
          <target state="translated">연산자 클래스 매개 변수의 이름입니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b92d299708f5e6b56970b9d25ff76f34c8756f5" translate="yes" xml:space="preserve">
          <source>The name of an operator class. See below for details.</source>
          <target state="translated">연산자 클래스의 이름입니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4bf28d916074af135f4ae230a1fccbd417f00476" translate="yes" xml:space="preserve">
          <source>The name of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax. This is effectively another way of declaring a named &lt;code&gt;OUT&lt;/code&gt; parameter, except that &lt;code&gt;RETURNS TABLE&lt;/code&gt; also implies &lt;code&gt;RETURNS SETOF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RETURNS TABLE&lt;/code&gt; 구문 에서 출력 열의 이름입니다 . 이것은 &lt;code&gt;RETURNS TABLE&lt;/code&gt; 도 &lt;code&gt;RETURNS SETOF&lt;/code&gt; 를 의미한다는 점을 제외하고 는 명명 된 &lt;code&gt;OUT&lt;/code&gt; 매개 변수 를 선언하는 또 다른 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="7860b7ca240f288c9e09edb9a6f18857751787c5" translate="yes" xml:space="preserve">
          <source>The name of next WAL segment file should be larger than any WAL segment file name currently existing in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory. These names are also in hexadecimal and have three parts. The first part is the &amp;ldquo;timeline ID&amp;rdquo; and should usually be kept the same. For example, if &lt;code&gt;00000001000000320000004A&lt;/code&gt; is the largest entry in &lt;code&gt;pg_wal&lt;/code&gt;, use &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; or higher.</source>
          <target state="translated">다음 WAL 세그먼트 파일의 이름 은 데이터 디렉토리 아래의 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리에 현재 존재하는 WAL 세그먼트 파일 이름보다 커야합니다 . 이 이름도 16 진수이며 세 부분으로 구성됩니다. 첫 번째 부분은 &quot;타임 라인 ID&quot;이며 일반적으로 동일하게 유지해야합니다. 예를 들어, &lt;code&gt;00000001000000320000004A&lt;/code&gt; 가 &lt;code&gt;pg_wal&lt;/code&gt; 에서 가장 큰 항목 인 경우 &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; 이상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d8e7a2287904ed813d9d1d342dd594453e6a492a" translate="yes" xml:space="preserve">
          <source>The name of the access method to be created.</source>
          <target state="translated">작성할 액세스 방법의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a1d2d753926a3554219bc61e5340b3472157868a" translate="yes" xml:space="preserve">
          <source>The name of the attribute to add, alter, or drop.</source>
          <target state="translated">추가, 변경 또는 제거 할 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5c7d389a37d0c9ede9dd1bea0952aff86a55c92e" translate="yes" xml:space="preserve">
          <source>The name of the canonicalization function for the range type.</source>
          <target state="translated">범위 유형에 대한 정규화 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="243c7e9e7dd348f6643caec550e3f500eb8cc280" translate="yes" xml:space="preserve">
          <source>The name of the collation to use for the index. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed. Indexes with non-default collations can be useful for queries that involve expressions using non-default collations.</source>
          <target state="translated">색인에 사용할 데이터 정렬의 이름입니다. 기본적으로 인덱스는 인덱스 할 열에 대해 선언 된 데이터 정렬 또는 인덱스 할 표현식의 결과 데이터 정렬을 사용합니다. 기본이 아닌 데이터 정렬을 사용하는 인덱스는 기본이 아닌 데이터 정렬을 사용하는 식과 관련된 쿼리에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77f1c321d574cf562cfe00eca4e768698060a618" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified.</source>
          <target state="translated">데이터 정렬의 이름입니다. 데이터 정렬 이름은 스키마로 한정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb886814d1ec273ae0613d250c7095ff800d469" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified. If it is not, the collation is defined in the current schema. The collation name must be unique within that schema. (The system catalogs can contain collations with the same name for other encodings, but these are ignored if the database encoding does not match.)</source>
          <target state="translated">데이터 정렬의 이름입니다. 데이터 정렬 이름은 스키마로 한정 될 수 있습니다. 그렇지 않으면 데이터 정렬이 현재 스키마에 정의됩니다. 데이터 정렬 이름은 해당 스키마 내에서 고유해야합니다. (시스템 카탈로그에는 다른 인코딩과 동일한 이름의 데이터 정렬이 포함될 수 있지만 데이터베이스 인코딩이 일치하지 않으면 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="9f63d4696a4bbfab6f19c7c4c3231039f6a920b8" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified.</source>
          <target state="translated">전환의 이름입니다. 변환 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a0e15e0eec7998677fce35d40af5b0838f2cb6f" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified. If it is not, the conversion is defined in the current schema. The conversion name must be unique within a schema.</source>
          <target state="translated">전환의 이름입니다. 변환 이름은 스키마로 규정 될 수 있습니다. 그렇지 않으면 변환이 현재 스키마에 정의됩니다. 변환 이름은 스키마 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9574a7a1218329dadec3b5ae9047230517d66aa" translate="yes" xml:space="preserve">
          <source>The name of the current database.</source>
          <target state="translated">현재 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="1d7349ab2501bed854162775079bf683be5a7fac" translate="yes" xml:space="preserve">
          <source>The name of the cursor</source>
          <target state="translated">커서의 이름</target>
        </trans-unit>
        <trans-unit id="b6d5b083913d1c8495981451aeb22d6a26cea7b8" translate="yes" xml:space="preserve">
          <source>The name of the cursor to be created.</source>
          <target state="translated">작성할 커서의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="88e407c8ddef33e57e58fe4ab21cafbf53e15168" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be deleted is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;DELETE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 조건 에서 사용할 커서의 이름입니다 . 삭제할 행은이 커서에서 가장 최근에 가져온 행입니다. 커서는 &lt;code&gt;DELETE&lt;/code&gt; 의 대상 테이블 에서 그룹화되지 않은 쿼리 여야 합니다. 참고 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 부울 조건과 함께 지정 될 수 없습니다. &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 와 함께 커서를 사용하는 데 대한 자세한 정보는 &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="38020942de5ae8771a5e3d0b598b6d0ab023caec" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be updated is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;UPDATE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 조건 에서 사용할 커서의 이름입니다 . 업데이트 될 행은이 커서에서 가장 최근에 가져온 것입니다. 커서는 &lt;code&gt;UPDATE&lt;/code&gt; 대상 테이블 에서 그룹화되지 않은 쿼리 여야 합니다. 참고 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 부울 조건과 함께 지정 될 수 없습니다. &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 와 함께 커서를 사용하는 데 대한 자세한 정보는 &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a37403f5a4aea39da3b7fe089d21ee355979a3e1" translate="yes" xml:space="preserve">
          <source>The name of the data type of the transform.</source>
          <target state="translated">변환의 데이터 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="af7361a3be8ca4eab2c0f2265411cfd60f5af420" translate="yes" xml:space="preserve">
          <source>The name of the database the configuration variable should be set in.</source>
          <target state="translated">구성 변수를 설정해야하는 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="84b00afcd962f475515c1915126400e90b5a9818" translate="yes" xml:space="preserve">
          <source>The name of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">이 슬롯과 연관된 데이터베이스의 이름 또는 널입니다. 논리 슬롯 만 연관된 데이터베이스를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2a89c928e3a93a0e913b45ef5c9ea96a08977f60" translate="yes" xml:space="preserve">
          <source>The name of the database to remove.</source>
          <target state="translated">제거 할 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0fd3bf3f6aa3e86ff6150d84d8e17149c266ae35" translate="yes" xml:space="preserve">
          <source>The name of the database whose attributes are to be altered.</source>
          <target state="translated">속성을 변경할 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0944e5dfd14965f192e2a8ef7a09d183046338d3" translate="yes" xml:space="preserve">
          <source>The name of the database you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">현재 연결된 데이터베이스의 이름입니다. 데이터베이스 (프로그램 시작 포함)에 연결할 때마다 설정되지만 변경하거나 설정 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11232ebb2f1cf69c5f3c6cd470c6a4d13d479f8e" translate="yes" xml:space="preserve">
          <source>The name of the element type that the range type will represent ranges of.</source>
          <target state="translated">범위 유형이 범위를 나타내는 요소 유형의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2c439c06e3cc89c7e2b7094efdc072f8eaa5f405" translate="yes" xml:space="preserve">
          <source>The name of the end function for the parser.</source>
          <target state="translated">파서의 종료 함수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4682e028a8481b8dc70802bb5909c69f9733e336" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="translated">주어진 함수에 대한 호출을 트리거하는 이벤트의 이름입니다. 이벤트 이름에 대한 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;은 39.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48923e41b7df203b0e79b78492f062da75beedf7" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="translated">지정된 함수에 대한 호출을 트리거하는 이벤트의 이름입니다. 이벤트 이름에 대한 자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/13/event-trigger-definition.html&quot;&gt;섹션 39.1&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28c26a8cf1a6172d4db73edd5254e5a34f8a5967" translate="yes" xml:space="preserve">
          <source>The name of the event trigger to remove.</source>
          <target state="translated">제거 할 이벤트 트리거의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="850574c01fb5268b0342a8b6bb42720569d55e9d" translate="yes" xml:space="preserve">
          <source>The name of the existing operator family to add this operator class to. If not specified, a family named the same as the operator class is used (creating it, if it doesn't already exist).</source>
          <target state="translated">이 연산자 클래스를 추가 할 기존 연산자 제품군의 이름입니다. 지정하지 않으면 연산자 클래스와 동일한 패밀리가 사용됩니다 (아직없는 경우 작성).</target>
        </trans-unit>
        <trans-unit id="e1cc11f5fc0531b3a520c5755578268d661fb876" translate="yes" xml:space="preserve">
          <source>The name of the extension that the function is to depend on.</source>
          <target state="translated">함수가 의존하는 확장명.</target>
        </trans-unit>
        <trans-unit id="6af23b7fd50d16bb7de156bad92b5bd09f67edbf" translate="yes" xml:space="preserve">
          <source>The name of the extension that the index is to depend on.</source>
          <target state="translated">색인이 의존하는 확장자의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0076c726a59acb3194ce3e4e3b9519a8daeff897" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A materialized view that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="translated">구체화 된 뷰가 의존하는 (또는 &lt;code&gt;NO&lt;/code&gt; 가 지정된 경우 더 이상 의존하지 않는) 확장의 이름입니다 . 확장에 종속 된 것으로 표시된 구체화 된 뷰는 확장이 삭제 될 때 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="dc831ae12120e6fd5fdd21a20fd1a1e7bd573e67" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on.</source>
          <target state="translated">구체화 된 뷰가 의존하는 확장의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4f55051df080e15b2a3119833fb2677544739012" translate="yes" xml:space="preserve">
          <source>The name of the extension that the procedure is to depend on.</source>
          <target state="translated">절차가 의존하는 확장자의 이름.</target>
        </trans-unit>
        <trans-unit id="eb5ffaeae34b0a924ba5f2135444604598a2a8e1" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A trigger that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="translated">트리거가 종속되는 (또는 &lt;code&gt;NO&lt;/code&gt; 가 지정된 경우 더 이상 종속되지 않는) 확장의 이름입니다 . 확장에 종속 된 것으로 표시된 트리거는 확장이 삭제 될 때 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="0a35573e050ab73e125502a3b5564abce7fd88f9" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on.</source>
          <target state="translated">트리거가 의존하는 확장의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="88e9cf7b26c10377ec9b042f69222e5d8682e8ed" translate="yes" xml:space="preserve">
          <source>The name of the extension to be installed. PostgreSQL will create the extension using details from the file &lt;code&gt;SHAREDIR/extension/&lt;/code&gt;&lt;code&gt;extension_name&lt;/code&gt;&lt;code&gt;.control&lt;/code&gt;.</source>
          <target state="translated">설치할 확장명입니다. PostgreSQL은 &lt;code&gt;SHAREDIR/extension/&lt;/code&gt; &lt;code&gt;extension_name&lt;/code&gt; &lt;code&gt;.control&lt;/code&gt; 파일의 세부 정보를 사용하여 확장을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d6fa04f440c0a0fbd9ef5c8562fd34285144f5e9" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed, when using moving-aggregate mode. This works the same as &lt;code&gt;ffunc&lt;/code&gt;, except that its first argument's type is &lt;code&gt;mstate_data_type&lt;/code&gt; and extra dummy arguments are specified by writing &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;. The aggregate result type determined by &lt;code&gt;mffunc&lt;/code&gt; or &lt;code&gt;mstate_data_type&lt;/code&gt; must match that determined by the aggregate's regular implementation.</source>
          <target state="translated">이동 집계 모드를 사용할 때 모든 입력 행을 통과 한 후 집계 결과를 계산하기 위해 호출 된 최종 함수의 이름입니다. 이 같은 작업 &lt;code&gt;ffunc&lt;/code&gt; 첫 번째 인수의 유형 인 것을 제외하고, &lt;code&gt;mstate_data_type&lt;/code&gt; 을 여분의 더미 인수를 작성하여 지정 &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; 을 . &lt;code&gt;mffunc&lt;/code&gt; 또는 &lt;code&gt;mstate_data_type&lt;/code&gt; 에 의해 결정된 집계 결과 유형 은 집계의 일반 구현에 의해 결정된 결과 유형 과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5f06809f2c728bd2159e0f8d844d66eca27a10c" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed. For a normal aggregate, this function must take a single argument of type &lt;code&gt;state_data_type&lt;/code&gt;. The return data type of the aggregate is defined as the return type of this function. If &lt;code&gt;ffunc&lt;/code&gt; is not specified, then the ending state value is used as the aggregate's result, and the return type is &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">모든 입력 행을 통과 한 후 집계 결과를 계산하기 위해 호출 된 최종 함수의 이름입니다. 정규 집계의 경우이 함수는 &lt;code&gt;state_data_type&lt;/code&gt; 유형의 단일 인수를 가져와야 합니다. 집계의 리턴 데이터 유형은이 함수의 리턴 유형으로 정의됩니다. 경우 &lt;code&gt;ffunc&lt;/code&gt; 지정되어 있지 않은 경우, 종료 상태 값은 집계의 결과로 사용되며, 반환 형식이다 &lt;code&gt;state_data_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72c35b2edf9735176f859431671ff1f17e5d197c" translate="yes" xml:space="preserve">
          <source>The name of the foreign server to be created.</source>
          <target state="translated">작성할 외부 서버의 이름</target>
        </trans-unit>
        <trans-unit id="c3a096f51b1b0afdadcf653b248a2d3f34aa4744" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper that manages the server.</source>
          <target state="translated">서버를 관리하는 외부 데이터 랩퍼의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d54745f11f4179244c18fb9a79fb68702588d241" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper to be created.</source>
          <target state="translated">작성할 외부 데이터 랩퍼의 이름.</target>
        </trans-unit>
        <trans-unit id="1fdbb3b7aa9f05df80cfbaca84874bb5ff3faf75" translate="yes" xml:space="preserve">
          <source>The name of the forward state transition function to be called for each input row in moving-aggregate mode. This is exactly like the regular transition function, except that its first argument and result are of type &lt;code&gt;mstate_data_type&lt;/code&gt;, which might be different from &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">이동 집계 모드에서 각 입력 행에 대해 호출 될 정방향 상태 전이 함수의 이름입니다. 이것은 첫 번째 인자와 결과가 형의 것을 제외하고, 정확하게 정규 전환 기능처럼 &lt;code&gt;mstate_data_type&lt;/code&gt; 다를 수 있습니다, &lt;code&gt;state_data_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="644a4d91bed7658870a145ab3141d930ef90e912" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the SQL environment to the language. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;internal&lt;/code&gt;. The actual argument will be of the type for the transform, and the function should be coded as if it were. (But it is not allowed to declare an SQL-level function returning &lt;code&gt;internal&lt;/code&gt; without at least one argument of type &lt;code&gt;internal&lt;/code&gt;.) The actual return value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">유형을 SQL 환경에서 언어로 변환하기위한 함수의 이름입니다. &lt;code&gt;internal&lt;/code&gt; 유형 과 return 유형 &lt;code&gt;internal&lt;/code&gt; 의 인수 하나를 가져와야합니다 . 실제 인수는 변환 유형이며 함수는 마치 마치 마치 코드화되어야합니다. (그러나이 돌아가는 SQL 수준의 기능을 선언 할 수 없습니다 &lt;code&gt;internal&lt;/code&gt; 유형 중 하나 개 이상을 인수하지 않고 &lt;code&gt;internal&lt;/code&gt; .) 실제 반환 값은 언어 구현에 뭔가 특별한 것입니다. 인수 목록이 지정되지 않은 경우 함수 이름은 스키마에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="72f3b32f063bc50605b229238d27a5869c6aa7b9" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the language to the SQL environment. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return the type that is the type for the transform. The actual argument value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">유형을 언어에서 SQL 환경으로 변환하기위한 함수의 이름입니다. &lt;code&gt;internal&lt;/code&gt; 유형의 인수 하나를 가져 와서 변환 유형 인 유형을 리턴 해야합니다 . 실제 인수 값은 언어 구현에 따라 다릅니다. 인수 목록이 지정되지 않은 경우 함수 이름은 스키마에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="67cb877b3731a337b10795d0e7186566d6a3d1e1" translate="yes" xml:space="preserve">
          <source>The name of the get-next-token function for the parser.</source>
          <target state="translated">파서의 get-next-token 함수 이름.</target>
        </trans-unit>
        <trans-unit id="6d1ebf156ba07f5a77467c8ec4ff708f33b3fc16" translate="yes" xml:space="preserve">
          <source>The name of the group (role) to modify.</source>
          <target state="translated">수정할 그룹 (역할)의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2ed53b580ba0bc8625e75a9560c3a6e88d077a4d" translate="yes" xml:space="preserve">
          <source>The name of the headline function for the parser (a function that summarizes a set of tokens).</source>
          <target state="translated">파서의 헤드 라인 함수 이름 (토큰 세트를 요약하는 함수)</target>
        </trans-unit>
        <trans-unit id="a3a747073ce359aa3857b433256c5b13312b5a04" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator class is for.</source>
          <target state="translated">연산자 클래스의 색인 액세스 메소드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ed18a236c732efe90dba559278f7adbf5db0ca9c" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator family is for.</source>
          <target state="translated">운영자 제품군에 대한 색인 액세스 방법의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c45cc6bfca0d231f36cbda7b1370cd41ed1d67b6" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator class is for.</source>
          <target state="translated">이 연산자 클래스의 색인 메소드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="615794124cec123ffa046fc334d0b7cb274ccdc2" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator family is for.</source>
          <target state="translated">이 연산자 제품군의 색인 방법 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4bb90538453113f1fb57ae8f2d37c35f322febf6" translate="yes" xml:space="preserve">
          <source>The name of the index method to be used. Choices are &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, and &lt;code&gt;brin&lt;/code&gt;. The default method is &lt;code&gt;btree&lt;/code&gt;.</source>
          <target state="translated">사용할 색인 메소드의 이름입니다. 선택은 &lt;code&gt;btree&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;gist&lt;/code&gt; , &lt;code&gt;spgist&lt;/code&gt; , &lt;code&gt;gin&lt;/code&gt; , 그리고 &lt;code&gt;brin&lt;/code&gt; . 기본 방법은 &lt;code&gt;btree&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb830e2432e53c927391aeee88f93bb4667bcae4" translate="yes" xml:space="preserve">
          <source>The name of the index to be created. No schema name can be included here; the index is always created in the same schema as its parent table. If the name is omitted, PostgreSQL chooses a suitable name based on the parent table's name and the indexed column name(s).</source>
          <target state="translated">작성할 색인의 이름입니다. 여기에는 스키마 이름을 포함 할 수 없습니다. 색인은 항상 상위 테이블과 동일한 스키마에 작성됩니다. 이름이 생략되면 PostgreSQL은 상위 테이블의 이름과 색인화 된 열 이름을 기반으로 적합한 이름을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="a4663fb986b280170b92707494282c81c2899c4f" translate="yes" xml:space="preserve">
          <source>The name of the init function for the template.</source>
          <target state="translated">템플릿의 init 함수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f00fd5139904e6694b429785636163e14a782210" translate="yes" xml:space="preserve">
          <source>The name of the inverse state transition function to be used in moving-aggregate mode. This function has the same argument and result types as &lt;code&gt;msfunc&lt;/code&gt;, but it is used to remove a value from the current aggregate state, rather than add a value to it. The inverse transition function must have the same strictness attribute as the forward state transition function.</source>
          <target state="translated">이동 집계 모드에서 사용될 역 상태 전이 함수의 이름. 이 함수는 &lt;code&gt;msfunc&lt;/code&gt; 와 동일한 인수 및 결과 유형을 갖지만 값을 추가하지 않고 현재 집계 상태에서 값을 제거하는 데 사용됩니다. 역 전이 함수는 정방향 상태 전이 함수와 동일한 엄격 속성을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="3d95c2fd2534c7b2ce3a1746cb2c27650d29fdc4" translate="yes" xml:space="preserve">
          <source>The name of the language of the transform.</source>
          <target state="translated">변환 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="26a3e76d4aff5006209caa326a5bf1517ad79006" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">함수가 구현되는 언어의 이름. &lt;code&gt;sql&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; 또는 사용자 정의 절차 언어의 이름 (예 : &lt;code&gt;plpgsql&lt;/code&gt; )일 수 있습니다. 작은 따옴표로 이름을 묶으면 더 이상 사용되지 않으며 대소 문자가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="c42d1caf7aebd169681e8521779ebec6bdd5b337" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">함수가 구현 된 언어의 이름입니다. &lt;code&gt;sql&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; 또는 사용자 정의 절차 언어의 이름 (예 : &lt;code&gt;plpgsql&lt;/code&gt; )일 수 있습니다. 이름을 작은 따옴표로 묶는 것은 더 이상 사용되지 않으며 대소 문자가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b5713bc5c339abbdacc15961df416377c21c0e3" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">프로 시저가 구현되는 언어의 이름. &lt;code&gt;sql&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; 또는 사용자 정의 절차 언어의 이름 (예 : &lt;code&gt;plpgsql&lt;/code&gt; )일 수 있습니다. 작은 따옴표로 이름을 묶으면 더 이상 사용되지 않으며 대소 문자가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6442a7baa7c6ad1af9dfd2863b84c1d799ed57dc" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">프로 시저가 구현되는 언어의 이름입니다. &lt;code&gt;sql&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; 또는 사용자 정의 프로 시저 언어의 이름 (예 : &lt;code&gt;plpgsql&lt;/code&gt; )이 될 수 있습니다. 이름을 작은 따옴표로 묶는 것은 더 이상 사용되지 않으며 대소 문자가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="86f56142098dd6b61f4dc395fb22e1f6084da31b" translate="yes" xml:space="preserve">
          <source>The name of the lexize function for the template.</source>
          <target state="translated">템플릿의 lexize 함수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="78bf3c88f1577390b2b7639c878108066bdde80d" translate="yes" xml:space="preserve">
          <source>The name of the lextypes function for the parser (a function that returns information about the set of token types it produces).</source>
          <target state="translated">파서에 대한 lextypes 함수의 이름 (생성하는 토큰 유형 세트에 대한 정보를 리턴하는 함수).</target>
        </trans-unit>
        <trans-unit id="99c5d2489b4f3028ca831f4f9b0e7e15704ecdca" translate="yes" xml:space="preserve">
          <source>The name of the new procedural language. The name must be unique among the languages in the database.</source>
          <target state="translated">새로운 절차 언어의 이름. 이름은 데이터베이스의 언어 중에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf36b4ea435ecc1c1aaf6ed21ca9df2c4c0596b3" translate="yes" xml:space="preserve">
          <source>The name of the new publication.</source>
          <target state="translated">새로운 출판물의 이름.</target>
        </trans-unit>
        <trans-unit id="dc580686d337370d500fabd6d8d4233f2a645d1a" translate="yes" xml:space="preserve">
          <source>The name of the new role.</source>
          <target state="translated">새로운 역할의 이름.</target>
        </trans-unit>
        <trans-unit id="9deb527e5d18a4a607e93b3c59b44924e3848af5" translate="yes" xml:space="preserve">
          <source>The name of the new subscription.</source>
          <target state="translated">새 구독의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="84ca9243f0b08a6130478bf4d0fddd3954c72484" translate="yes" xml:space="preserve">
          <source>The name of the object to be commented. Names of tables, aggregates, collations, conversions, domains, foreign tables, functions, indexes, operators, operator classes, operator families, procedures, routines, sequences, statistics, text search objects, types, and views can be schema-qualified. When commenting on a column, &lt;code&gt;relation_name&lt;/code&gt; must refer to a table, view, composite type, or foreign table.</source>
          <target state="translated">주석을 추가 할 객체의 이름입니다. 테이블, 집계, 데이터 정렬, 변환, 도메인, 외부 테이블, 함수, 인덱스, 연산자, 연산자 클래스, 연산자 패밀리, 프로 시저, 루틴, 시퀀스, 통계, 텍스트 검색 오브젝트, 유형 및 뷰의 이름은 스키마로 규정 될 수 있습니다. 열에 주석을 달 때 &lt;code&gt;relation_name&lt;/code&gt; 은 테이블, 뷰, 복합 유형 또는 외부 테이블을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ad7f76d8fb02cb1c406ee55180e013d61f5632a" translate="yes" xml:space="preserve">
          <source>The name of the object to be labeled. Names of tables, aggregates, domains, foreign tables, functions, procedures, routines, sequences, types, and views can be schema-qualified.</source>
          <target state="translated">레이블이 지정된 개체의 이름입니다. 테이블, 집계, 도메인, 외부 테이블, 함수, 프로 시저, 루틴, 시퀀스, 유형 및 뷰의 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73d0a54fa511d10e86523f09232c08b9e6d5db1" translate="yes" xml:space="preserve">
          <source>The name of the object to which this label applies, as text.</source>
          <target state="translated">이 레이블이 적용되는 객체의 이름을 텍스트로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="42c399b3a656097491cae7892f14f5784153a41c" translate="yes" xml:space="preserve">
          <source>The name of the operator class to be created. The name can be schema-qualified.</source>
          <target state="translated">작성할 연산자 클래스의 이름입니다. 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c9b852f5483728a82051e673011a9205c74fef8" translate="yes" xml:space="preserve">
          <source>The name of the operator family to be created. The name can be schema-qualified.</source>
          <target state="translated">작성할 운영자 제품군의 이름입니다. 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa3dee6563b812e00d9ce856987f40752c4ba957" translate="yes" xml:space="preserve">
          <source>The name of the operator to be defined. See above for allowable characters. The name can be schema-qualified, for example &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt;. If not, then the operator is created in the current schema. Two operators in the same schema can have the same name if they operate on different data types. This is called &lt;em&gt;overloading&lt;/em&gt;.</source>
          <target state="translated">정의 할 연산자의 이름입니다. 허용되는 문자는 위를 참조하십시오. 이름은 스키마로 규정 될 수 있습니다 (예 : &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt; . 그렇지 않으면 연산자가 현재 스키마에 작성됩니다. 동일한 스키마의 두 연산자가 다른 데이터 유형에서 작동하는 경우 동일한 이름을 가질 수 있습니다. 이것을 &lt;em&gt;오버로딩&lt;/em&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="89042cdb5d6d0a5c95dd63eb06cd01f0a55a975c" translate="yes" xml:space="preserve">
          <source>The name of the policy</source>
          <target state="translated">정책의 이름</target>
        </trans-unit>
        <trans-unit id="b729bdecc076d261a6f2aa96bf01271915d37a2a" translate="yes" xml:space="preserve">
          <source>The name of the policy to be created. This must be distinct from the name of any other policy for the table.</source>
          <target state="translated">작성할 정책의 이름입니다. 이것은 테이블에 대한 다른 정책의 이름과 구별되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e268e30430f81e017c4a875eccb62cdf9b012871" translate="yes" xml:space="preserve">
          <source>The name of the policy to drop.</source>
          <target state="translated">제거 할 정책의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e49a87c2d393345ad07affbe76b904f4fe401c81" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to deallocate.</source>
          <target state="translated">할당 해제 할 준비된 명령문의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="96c3920c719f442187d159c204dd3612ea686ae5" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to execute.</source>
          <target state="translated">실행할 준비된 명령문의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="655476f7c7223e1c8c574d3f749ecc5208b3f1a9" translate="yes" xml:space="preserve">
          <source>The name of the procedural language the code is written in. If omitted, the default is &lt;code&gt;plpgsql&lt;/code&gt;.</source>
          <target state="translated">코드가 작성된 절차 언어의 이름입니다. 생략하면 기본값은 &lt;code&gt;plpgsql&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03668e7125b4437e3ffadf3e4e590be0e7efc658" translate="yes" xml:space="preserve">
          <source>The name of the provider with which this label is to be associated. The named provider must be loaded and must consent to the proposed labeling operation. If exactly one provider is loaded, the provider name may be omitted for brevity.</source>
          <target state="translated">이 레이블과 연관 될 제공자의 이름입니다. 명명 된 공급자를로드해야하며 제안 된 라벨 작업에 동의해야합니다. 정확히 하나의 공급자가로드 된 경우 간략하게 제공하기 위해 공급자 이름을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4982a7a5e8149f1e3c35391b81b9f53d77cb4f02" translate="yes" xml:space="preserve">
          <source>The name of the role that will be made the new owner of the affected objects.</source>
          <target state="translated">영향을받는 개체의 새 소유자가 될 역할의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d91a150acbfef5a5067b673c038cee51df98a783" translate="yes" xml:space="preserve">
          <source>The name of the role to remove.</source>
          <target state="translated">제거 할 역할의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f2c76cbbaae9ad7b16ccf9e7e0922d982cd4547e" translate="yes" xml:space="preserve">
          <source>The name of the role whose attributes are to be altered.</source>
          <target state="translated">속성을 변경할 역할의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a2cca4e02caca1d1f07a5556d0d3f7be637865d7" translate="yes" xml:space="preserve">
          <source>The name of the rule to drop.</source>
          <target state="translated">제거 할 규칙의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fc701ae189d9b3d813db243f4da26ea0b33711ef" translate="yes" xml:space="preserve">
          <source>The name of the savepoint to destroy.</source>
          <target state="translated">파괴 할 세이브 포인트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4816861b05e3da72c531801eafbb94d541e0e94f" translate="yes" xml:space="preserve">
          <source>The name of the schema in which to install the extension's objects, given that the extension allows its contents to be relocated. The named schema must already exist. If not specified, and the extension's control file does not specify a schema either, the current default object creation schema is used.</source>
          <target state="translated">확장 기능으로 컨텐츠를 재배치 할 수있는 경우 확장 기능을 설치할 스키마의 이름입니다. 명명 된 스키마가 이미 존재해야합니다. 지정하지 않고 확장의 제어 파일이 스키마를 지정하지 않으면 현재 기본 오브젝트 작성 스키마가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42eda784d25f0da5728fd9204f655f7fcdcb985b" translate="yes" xml:space="preserve">
          <source>The name of the schema to which the table will be moved.</source>
          <target state="translated">테이블이 이동 될 스키마의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="baf4061d3be604bdc194c1f14606449bf4b0f2d6" translate="yes" xml:space="preserve">
          <source>The name of the shared memory allocation. NULL for unused memory and &lt;code&gt;&amp;lt;anonymous&amp;gt;&lt;/code&gt; for anonymous allocations.</source>
          <target state="translated">공유 메모리 할당의 이름입니다. 사용되지 않은 메모리의 경우 NULL이고 익명 할당의 경우 &lt;code&gt;&amp;lt;anonymous&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac04d5a0b8ecbdd03c9da31af0a4b7d10ec89b66" translate="yes" xml:space="preserve">
          <source>The name of the source data type of the cast.</source>
          <target state="translated">캐스트의 소스 데이터 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2294ddf1df955220bbac238988facccf0c6a0592" translate="yes" xml:space="preserve">
          <source>The name of the specific index, table, or database to be reindexed. Index and table names can be schema-qualified. Presently, &lt;code&gt;REINDEX DATABASE&lt;/code&gt; and &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; can only reindex the current database, so their parameter must match the current database's name.</source>
          <target state="translated">재색 인화 할 특정 색인, 테이블 또는 데이터베이스의 이름입니다. 인덱스 및 테이블 이름은 스키마로 규정 될 수 있습니다. 현재 &lt;code&gt;REINDEX DATABASE&lt;/code&gt; 및 &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; 은 현재 데이터베이스 만 재 인덱싱 할 수 있으므로 해당 매개 변수는 현재 데이터베이스의 이름과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1371535897b887a5106cddf678bff07e0c5f80a9" translate="yes" xml:space="preserve">
          <source>The name of the start function for the parser.</source>
          <target state="translated">파서의 시작 함수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="015f67e7eaa6c3588c5e9952c547a024ac10153d" translate="yes" xml:space="preserve">
          <source>The name of the state transition function to be called for each input row. For a normal &lt;code&gt;N&lt;/code&gt;-argument aggregate function, the &lt;code&gt;sfunc&lt;/code&gt; must take &lt;code&gt;N&lt;/code&gt;+1 arguments, the first being of type &lt;code&gt;state_data_type&lt;/code&gt; and the rest matching the declared input data type(s) of the aggregate. The function must return a value of type &lt;code&gt;state_data_type&lt;/code&gt;. This function takes the current state value and the current input data value(s), and returns the next state value.</source>
          <target state="translated">각 입력 행에 대해 호출 될 상태 전이 함수의 이름입니다. 정상적인 &lt;code&gt;N&lt;/code&gt; - 인수 집계 함수의 경우 스 &lt;code&gt;sfunc&lt;/code&gt; 는 &lt;code&gt;N&lt;/code&gt; +1 인수를 취해야 합니다. 첫 번째는 &lt;code&gt;state_data_type&lt;/code&gt; 유형 이고 나머지는 집계의 선언 된 입력 데이터 유형과 일치합니다. 함수는 &lt;code&gt;state_data_type&lt;/code&gt; 유형의 값을 리턴해야합니다 . 이 함수는 현재 상태 값과 현재 입력 데이터 값을 가져 와서 다음 상태 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98dfcac96a79ab8d2309606485d5d666ca4e2daa" translate="yes" xml:space="preserve">
          <source>The name of the table and column to update</source>
          <target state="translated">업데이트 할 테이블 및 열 이름</target>
        </trans-unit>
        <trans-unit id="86a9a516ee162e483fd6f8fbe8dac2f83cc35633" translate="yes" xml:space="preserve">
          <source>The name of the table on which this trigger acts.</source>
          <target state="translated">이 트리거가 작동하는 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="df029c5f6289a56399018c193966351757b130e4" translate="yes" xml:space="preserve">
          <source>The name of the table to attach as a new partition or to detach from this table.</source>
          <target state="translated">새 파티션으로 첨부하거나이 테이블에서 분리 할 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="910f7a94c4794ba13cd804620ae6f535c8697348" translate="yes" xml:space="preserve">
          <source>The name of the tablespace that will be associated with the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the template database's tablespace. This tablespace will be the default tablespace used for objects created in this database. See &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; for more information.</source>
          <target state="translated">새 데이터베이스와 연관 될 테이블 스페이스의 이름 또는 템플리트 데이터베이스의 테이블 스페이스를 사용하는 &lt;code&gt;DEFAULT&lt;/code&gt; 입니다. 이 테이블 스페이스는이 데이터베이스에서 작성된 오브젝트에 사용되는 기본 테이블 스페이스입니다. 자세한 내용은 &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2adc75b40aac253d8d3fd83763a5999e795d523d" translate="yes" xml:space="preserve">
          <source>The name of the tablespace to which the table will be moved.</source>
          <target state="translated">테이블이 이동 될 테이블 스페이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ed5faf3ddd011b5c76e052594331ee12feb17ee5" translate="yes" xml:space="preserve">
          <source>The name of the target data type of the cast.</source>
          <target state="translated">캐스트의 대상 데이터 유형의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f5d196df67f8715141577ca0dfa1d0026e0d7817" translate="yes" xml:space="preserve">
          <source>The name of the template from which to create the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default template (&lt;code&gt;template1&lt;/code&gt;).</source>
          <target state="translated">새 데이터베이스를 작성할 템플리트의 이름 또는 기본 템플리트 ( &lt;code&gt;template1&lt;/code&gt; ) 를 사용하는 &lt;code&gt;DEFAULT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38cd3261917960f8e539d80ae266a773e2ca894a" translate="yes" xml:space="preserve">
          <source>The name of the text search configuration to be created. The name can be schema-qualified.</source>
          <target state="translated">작성할 텍스트 검색 구성의 이름입니다. 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7715676ee8a2df410a7d9b5d6a75ed5f4bbb933b" translate="yes" xml:space="preserve">
          <source>The name of the text search dictionary to be created. The name can be schema-qualified.</source>
          <target state="translated">작성할 텍스트 검색 사전의 이름입니다. 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08a42806dfcb8f125b19f0057086523042a36ad3" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to be created. The name can be schema-qualified.</source>
          <target state="translated">작성할 텍스트 검색 구문 분석기의 이름입니다. 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ce45ce2160196c06edff30b966c8ad75ac789f" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to use for this configuration.</source>
          <target state="translated">이 구성에 사용할 텍스트 검색 파서의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="84cb2dc1f232e52ae9a92c0bb4186a0059e53aa7" translate="yes" xml:space="preserve">
          <source>The name of the text search template that will define the basic behavior of this dictionary.</source>
          <target state="translated">이 사전의 기본 동작을 정의 할 텍스트 검색 템플릿의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1584a807877a42990d603d823d759977f3901ddc" translate="yes" xml:space="preserve">
          <source>The name of the text search template to be created. The name can be schema-qualified.</source>
          <target state="translated">작성할 텍스트 검색 템플리트의 이름입니다. 이름은 스키마로 규정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0987d8df78c216eed09875fd5ebec69f27a40ed" translate="yes" xml:space="preserve">
          <source>The name of the trigger to remove.</source>
          <target state="translated">제거 할 트리거의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="afd08ce0efd0e1d1a3450afd63d3251269afcb61" translate="yes" xml:space="preserve">
          <source>The name of the user who will own the tablespace. If omitted, defaults to the user executing the command. Only superusers can create tablespaces, but they can assign ownership of tablespaces to non-superusers.</source>
          <target state="translated">테이블 스페이스를 소유 할 사용자의 이름입니다. 생략하면 기본적으로 명령을 실행하는 사용자가됩니다. 수퍼 유저 만 테이블 스페이스를 작성할 수 있지만 테이블 스페이스 소유권을 비 수퍼 유저에게 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c1d8e2ccb4524cb644f6e39612aee840de9a90d" translate="yes" xml:space="preserve">
          <source>The name or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="translated">연결할 RADIUS 서버의 이름 또는 IP 주소입니다. 이 매개 변수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="21389222271889edde6e7b3bd3c9fdd837bca670" translate="yes" xml:space="preserve">
          <source>The name parameter will be MD5-hashed, so the cleartext cannot be derived from the generated UUID. The generation of UUIDs by this method has no random or environment-dependent element and is therefore reproducible.</source>
          <target state="translated">name 매개 변수는 MD5로 해시되므로 일반 텍스트는 생성 된 UUID에서 파생 될 수 없습니다. 이 방법으로 UUID를 생성하는 것은 임의적이거나 환경 의존적 인 요소가 없으므로 재현 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ee74a07e23c9dea72df5a27b777fb65b403c0393" translate="yes" xml:space="preserve">
          <source>The name stems from the fact that this table should not be readable by the public since it contains passwords. &lt;a href=&quot;view-pg-user&quot;&gt;&lt;code&gt;pg_user&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_shadow&lt;/code&gt; that blanks out the password field.</source>
          <target state="translated">이름은 암호가 포함되어 있기 때문에이 테이블을 일반인이 읽을 수 없어야한다는 사실에서 유래합니다. &lt;a href=&quot;view-pg-user&quot;&gt; &lt;code&gt;pg_user&lt;/code&gt; &lt;/a&gt; 는 pg_shadow 에서 공개적으로 읽을 수있는보기로 , 비밀번호 필드 를 비 &lt;code&gt;pg_shadow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d07e8a1b061fb282161f125ed44c357f0d17c75" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This must be distinct from the name of any other trigger for the same table. The name cannot be schema-qualified &amp;mdash; the trigger inherits the schema of its table. For a constraint trigger, this is also the name to use when modifying the trigger's behavior using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">새 트리거를 부여 할 이름입니다. 이는 동일한 테이블에 대한 다른 트리거 이름과 구별되어야합니다. 이름은 스키마로 한정 될 수 없습니다. 트리거는 테이블의 스키마를 상속합니다. 제약 조건 트리거의 경우 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 를 사용하여 트리거 동작을 수정할 때 사용할 이름이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="7b32b1efee504dab33e5254f802082429e271272" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This name must be unique within the database.</source>
          <target state="translated">새 트리거를 부여 할 이름입니다. 이 이름은 데이터베이스 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="11fed6031dec77608082f3fa5b2080d3486c35aa" translate="yes" xml:space="preserve">
          <source>The name to give to the new savepoint.</source>
          <target state="translated">새 저장 점에 부여 할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="cf734951b344df7b211da487949af76d60fe726b" translate="yes" xml:space="preserve">
          <source>The names of opclasses and opfamilies are only unique within an access method, so they are represented by &lt;code&gt;access_method_name&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;object_name&lt;/code&gt;.</source>
          <target state="translated">opclass 및 opfamilies의 이름은 액세스 방법 내에서만 고유하므로 &lt;code&gt;access_method_name&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;object_name&lt;/code&gt; 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d60acc58684395b40a907774a02224d52b1340e7" translate="yes" xml:space="preserve">
          <source>The naming of output columns here is different from that done in the &lt;code&gt;FROM&lt;/code&gt; clause (see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;). It is possible to rename the same column twice, but the name assigned in the select list is the one that will be passed on.</source>
          <target state="translated">여기서 출력 열의 이름은 &lt;code&gt;FROM&lt;/code&gt; 절 에서 수행 한 것과 다릅니다 ( &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;섹션 7.2.1.2&lt;/a&gt; 참조 ). 동일한 열의 이름을 두 번 바꿀 수 있지만 선택 목록에 지정된 이름은 전달 될 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8c0fc2cb480be9bb9c51a4bc9a223616db655fd1" translate="yes" xml:space="preserve">
          <source>The negator of this operator.</source>
          <target state="translated">이 연산자의 부정 자.</target>
        </trans-unit>
        <trans-unit id="c48796461ad5a772c7e7652201b09a6a57e675ec" translate="yes" xml:space="preserve">
          <source>The new column is initially filled with whatever default value is given (null if you don't specify a &lt;code&gt;DEFAULT&lt;/code&gt; clause).</source>
          <target state="translated">새 열은 처음에 지정된 기본값으로 채워집니다 ( &lt;code&gt;DEFAULT&lt;/code&gt; 절을 지정하지 않으면 널임).</target>
        </trans-unit>
        <trans-unit id="99a5a709438ce00d416364163ad8901072e9ceb4" translate="yes" xml:space="preserve">
          <source>The new comment, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the comment.</source>
          <target state="translated">문자열 리터럴로 작성된 새 주석. 주석을 삭제하려면 &lt;code&gt;NULL&lt;/code&gt; 또는 NULL</target>
        </trans-unit>
        <trans-unit id="91d67a443bb1c7292a967c48bc783941c67a9238" translate="yes" xml:space="preserve">
          <source>The new connection can re-use connection parameters from the previous connection; not only database name, user, host, and port, but other settings such as &lt;code&gt;sslmode&lt;/code&gt;. By default, parameters are re-used in the positional syntax, but not when a &lt;code&gt;conninfo&lt;/code&gt; string is given. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. If parameters are re-used, then any parameter not explicitly specified as a positional parameter or in the &lt;code&gt;conninfo&lt;/code&gt; string is taken from the existing connection's parameters. An exception is that if the &lt;code&gt;host&lt;/code&gt; setting is changed from its previous value using the positional syntax, any &lt;code&gt;hostaddr&lt;/code&gt; setting present in the existing connection's parameters is dropped. When the command neither specifies nor reuses a particular parameter, the libpq default is used.</source>
          <target state="translated">새 연결은 이전 연결의 연결 매개 변수를 다시 사용할 수 있습니다. 데이터베이스 이름, 사용자, 호스트 및 포트뿐만 아니라 &lt;code&gt;sslmode&lt;/code&gt; 와 같은 기타 설정 . 기본적으로 매개 변수는 위치 구문에서 재사용되지만 &lt;code&gt;conninfo&lt;/code&gt; 문자열이 제공 되는 경우에는 사용되지 않습니다 . &lt;code&gt;-reuse-previous=on&lt;/code&gt; 또는 &lt;code&gt;-reuse-previous=off&lt;/code&gt; 의 첫 번째 인수를 전달하면 해당 기본값이 무시됩니다. 매개 변수가 다시 사용되면 위치 매개 변수 또는 &lt;code&gt;conninfo&lt;/code&gt; 문자열 에 명시 적으로 지정되지 않은 매개 변수 는 기존 연결의 매개 변수에서 가져옵니다. 단 , 위치 구문을 사용하여 &lt;code&gt;host&lt;/code&gt; 설정이 이전 값에서 변경되면 모든 &lt;code&gt;hostaddr&lt;/code&gt; 기존 연결의 매개 변수에있는 설정이 삭제됩니다. 명령이 특정 매개 변수를 지정하거나 재사용하지 않는 경우 libpq 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="510132e01b735c3f8d5397d2880131961e5b0f83" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed and removed from the query buffer. Whatever remains in the query buffer is redisplayed. Type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer.</source>
          <target state="translated">쿼리 버퍼의 새 내용은 psql의 일반 규칙에 따라 다시 구문 분석되어 전체 버퍼를 한 줄로 처리합니다. 완전한 쿼리는 즉시 실행됩니다. 즉, 쿼리 버퍼에 세미콜론이 포함되거나 끝나는 경우 해당 지점까지의 모든 것이 실행되고 쿼리 버퍼에서 제거됩니다. 쿼리 버퍼에 남아있는 것은 모두 다시 표시됩니다. 세미콜론 또는 &lt;code&gt;\g&lt;/code&gt; 를 입력 하여 보내거나 &lt;code&gt;\r&lt;/code&gt; 을 입력하여 쿼리 버퍼를 지워 취소합니다.</target>
        </trans-unit>
        <trans-unit id="d0eef4b2f503cdd8ca575c4d5c2db5edd06b1406" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed. Whatever remains will wait in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer. Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use &lt;code&gt;\i&lt;/code&gt; for that.)</source>
          <target state="translated">그런 다음 쿼리 버퍼의 새로운 내용은 psql의 일반 규칙에 따라 다시 구문 분석되어 전체 버퍼를 한 줄로 처리합니다. 완전한 쿼리는 즉시 실행됩니다. 즉, 쿼리 버퍼에 세미콜론이 포함되거나 세미콜론으로 끝나는 경우 해당 시점까지의 모든 것이 실행됩니다. 남아있는 것은 쿼리 버퍼에서 대기합니다. 세미콜론 또는 &lt;code&gt;\g&lt;/code&gt; 를 입력 하여 보내거나 &lt;code&gt;\r&lt;/code&gt; 을 입력하여 쿼리 버퍼를 지우면 취소됩니다. 버퍼를 단일 행으로 취급하면 주로 메타 명령에 영향을 미칩니다. 메타 명령 후 버퍼에있는 모든 내용은 여러 줄에 걸쳐 있어도 메타 명령의 인수로 간주됩니다. (따라서 메타 명령을 사용하는 스크립트를 이런 식으로 만들 수 없습니다.이를 위해 &lt;code&gt;\i&lt;/code&gt; 를 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8c2269882cf52ae9f068a61edc3b778c3a536ff9" translate="yes" xml:space="preserve">
          <source>The new declaration of the tables would look like this:</source>
          <target state="translated">테이블의 새로운 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abb08cd78d70403e2ed01ba829b0b0e107ad79e1" translate="yes" xml:space="preserve">
          <source>The new default tablespace of the database.</source>
          <target state="translated">데이터베이스의 새로운 기본 테이블 스페이스.</target>
        </trans-unit>
        <trans-unit id="bd696aa29e06c8bdaa37006c64334315b20f98b5" translate="yes" xml:space="preserve">
          <source>The new name for the constraint.</source>
          <target state="translated">제약 조건의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1897f67b69c5b7376acb8d806a5382da72697a70" translate="yes" xml:space="preserve">
          <source>The new name for the domain.</source>
          <target state="translated">도메인의 새 이름입니다.</target>
        </trans-unit>
        <trans-unit id="212f3ea5ee1a7012ae1ea00ecf4feddc77a325c7" translate="yes" xml:space="preserve">
          <source>The new name for the foreign server.</source>
          <target state="translated">외부 서버의 새 이름</target>
        </trans-unit>
        <trans-unit id="10044e9774ec8f7e4eeef4126404d9a4c8740bba" translate="yes" xml:space="preserve">
          <source>The new name for the foreign-data wrapper.</source>
          <target state="translated">외부 데이터 랩퍼의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="c11d926987759462d0f175b4415bf3358d9ff337" translate="yes" xml:space="preserve">
          <source>The new name for the index.</source>
          <target state="translated">색인의 새 이름입니다.</target>
        </trans-unit>
        <trans-unit id="33305417939d3b3756d6c5255331fe9d857743c1" translate="yes" xml:space="preserve">
          <source>The new name for the materialized view.</source>
          <target state="translated">구체화 된보기의 새 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d0bd51a33ddf1dfa219e2e91d0e8c933e6563371" translate="yes" xml:space="preserve">
          <source>The new name for the policy.</source>
          <target state="translated">정책의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="20931af42c3c5e46457e70a88b633cec676d6b34" translate="yes" xml:space="preserve">
          <source>The new name for the publication.</source>
          <target state="translated">출판물의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="afd5b43d5185c06c93949d1324710b679e0f98bd" translate="yes" xml:space="preserve">
          <source>The new name for the rule.</source>
          <target state="translated">규칙의 새 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b48d77b2ef95f7c457090bcbbe943d0c70311b15" translate="yes" xml:space="preserve">
          <source>The new name for the sequence.</source>
          <target state="translated">시퀀스의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fc2f67f3244cee265dae6b633cc864544be564aa" translate="yes" xml:space="preserve">
          <source>The new name for the statistics object.</source>
          <target state="translated">통계 개체의 새 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5e567bc00743ec90ea48cd87ca4d4d39aaaf2a0e" translate="yes" xml:space="preserve">
          <source>The new name for the subscription.</source>
          <target state="translated">구독의 새 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bb15ea9a2978ce58ebb2c54bd4908c64b61e3ec5" translate="yes" xml:space="preserve">
          <source>The new name for the trigger.</source>
          <target state="translated">트리거의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="db155d6348c19b7d3227f389aca4111ed1c5bd26" translate="yes" xml:space="preserve">
          <source>The new name for the type.</source>
          <target state="translated">유형의 새 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c523989c2e7068afb2501bed469e5428f5fdb7a8" translate="yes" xml:space="preserve">
          <source>The new name for the view.</source>
          <target state="translated">뷰의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f2b9a6bf2f60ce509d60ec6a402dbd4fb867b9c2" translate="yes" xml:space="preserve">
          <source>The new name of the aggregate function.</source>
          <target state="translated">집계 함수의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="aedc4948fc467788ca8aa2ca7751c93796b91571" translate="yes" xml:space="preserve">
          <source>The new name of the attribute to be renamed.</source>
          <target state="translated">이름을 바꿀 속성의 새 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e113491ed22e052f8e080471ba08c58dedb8ea64" translate="yes" xml:space="preserve">
          <source>The new name of the collation.</source>
          <target state="translated">데이터 정렬의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4c4b7b49d6b58b2034ea06105277cd50556d40cb" translate="yes" xml:space="preserve">
          <source>The new name of the conversion.</source>
          <target state="translated">전환의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7bd49806ce97a6cf0ae2db0f7447c28e5ce8134f" translate="yes" xml:space="preserve">
          <source>The new name of the database.</source>
          <target state="translated">데이터베이스의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="75a4aa01c626eb3410b405c18307300931670062" translate="yes" xml:space="preserve">
          <source>The new name of the event trigger.</source>
          <target state="translated">이벤트 트리거의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e4d75585a773a6cebff31b74551567f8918ab64f" translate="yes" xml:space="preserve">
          <source>The new name of the function.</source>
          <target state="translated">함수의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="2911d96c910b5a17b53eadc422fecbb845a71e4b" translate="yes" xml:space="preserve">
          <source>The new name of the group.</source>
          <target state="translated">그룹의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="01ed3bb6171bf404a649ad2b2a5598d4f2218b1d" translate="yes" xml:space="preserve">
          <source>The new name of the language</source>
          <target state="translated">언어의 새로운 이름</target>
        </trans-unit>
        <trans-unit id="5629a006f70e9712f7f3f90081ef5ec794958fe9" translate="yes" xml:space="preserve">
          <source>The new name of the operator class.</source>
          <target state="translated">연산자 클래스의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="cac8082223d146caa1279e011dcbd9499e966dea" translate="yes" xml:space="preserve">
          <source>The new name of the operator family.</source>
          <target state="translated">운영자 제품군의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="b633cb5bdc25233c7a8bdbb49f3cdbe73d120c26" translate="yes" xml:space="preserve">
          <source>The new name of the procedure.</source>
          <target state="translated">절차의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="3a9dddb1e76ff061e88bc3524aee453d2bee494e" translate="yes" xml:space="preserve">
          <source>The new name of the role.</source>
          <target state="translated">역할의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="2cf77fbb7b0d27045bc13b02630747a959116461" translate="yes" xml:space="preserve">
          <source>The new name of the schema. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">스키마의 새로운 이름. 새 이름은 시스템 스키마 용으로 예약되어 있으므로 &lt;code&gt;pg_&lt;/code&gt; 로 시작할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a8efb3edcac41dbb05c4e401ddd6f8995c994227" translate="yes" xml:space="preserve">
          <source>The new name of the tablespace. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">테이블 스페이스의 새로운 이름. 새 이름은 시스템 테이블 스페이스 용으로 예약되어 있으므로 &lt;code&gt;pg_&lt;/code&gt; 로 시작할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5bc002f16673653b0690b28fc66ef20f059c3d17" translate="yes" xml:space="preserve">
          <source>The new name of the text search configuration.</source>
          <target state="translated">텍스트 검색 구성의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="61d4e96018e9afca4b18c94ddcebcfce618c7e91" translate="yes" xml:space="preserve">
          <source>The new name of the text search dictionary.</source>
          <target state="translated">텍스트 검색 사전의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b0ee20d36931a187480bdf33645d746804cd8021" translate="yes" xml:space="preserve">
          <source>The new name of the text search parser.</source>
          <target state="translated">텍스트 검색 파서의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1aa4447ea683fc5f23d92a99564476e94e7ba4f8" translate="yes" xml:space="preserve">
          <source>The new name of the text search template.</source>
          <target state="translated">텍스트 검색 템플릿의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1cf431c1643a8759a28879f52b1cc3af8c233902" translate="yes" xml:space="preserve">
          <source>The new operator family is initially empty. It should be populated by issuing subsequent &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; commands to add contained operator classes, and optionally &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; commands to add &amp;ldquo;loose&amp;rdquo; operators and their corresponding support functions.</source>
          <target state="translated">새 운영자 제품군은 처음에 비어 있습니다. 후속 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 명령을 발행하여 포함 된 연산자 클래스를 추가하고 선택적으로 &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 명령을 발행하여 &quot;느슨한&quot;연산자 및 해당 지원 기능을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4c637105948973c0a153e08837179c7cca26481" translate="yes" xml:space="preserve">
          <source>The new owner of the aggregate function.</source>
          <target state="translated">집계 함수의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="6e427a5a254b743496752784773d8f681fc927a5" translate="yes" xml:space="preserve">
          <source>The new owner of the collation.</source>
          <target state="translated">데이터 정렬의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="696c05a86f35e15f1b9049294a231e9c92db726b" translate="yes" xml:space="preserve">
          <source>The new owner of the conversion.</source>
          <target state="translated">전환의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="8c3476b50bc477a63585319a4ee66bd132d319a7" translate="yes" xml:space="preserve">
          <source>The new owner of the database.</source>
          <target state="translated">데이터베이스의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="d33f9460834c9ae8c6bbf2129c64d4ae9c681396" translate="yes" xml:space="preserve">
          <source>The new owner of the function. Note that if the function is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">함수의 새로운 소유자. 함수가 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 로 표시 되면 이후에 새 소유자로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="df4e6318da1bb722216c2b84ac2c4e660006a7bf" translate="yes" xml:space="preserve">
          <source>The new owner of the language</source>
          <target state="translated">언어의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="f528312a4f330c09f0db9a04fb7594d8a6881296" translate="yes" xml:space="preserve">
          <source>The new owner of the large object</source>
          <target state="translated">큰 개체의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="042ac141d75c40bbad49229676115d2c3f46dc44" translate="yes" xml:space="preserve">
          <source>The new owner of the operator class.</source>
          <target state="translated">연산자 클래스의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="690e510771eb7df59bdf5e81e98ce1c088ae0a0a" translate="yes" xml:space="preserve">
          <source>The new owner of the operator family.</source>
          <target state="translated">운영자 제품군의 새로운 소유자.</target>
        </trans-unit>
        <trans-unit id="9786082232a6fabf8fef79154a67d7d246e8ac12" translate="yes" xml:space="preserve">
          <source>The new owner of the operator.</source>
          <target state="translated">운영자의 새로운 소유자.</target>
        </trans-unit>
        <trans-unit id="3597f21e2766a9a6fcb13ac8067e53ff7ef13d45" translate="yes" xml:space="preserve">
          <source>The new owner of the procedure. Note that if the procedure is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">절차의 새로운 소유자. 프로 시저가 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 로 표시 되면 이후에 새 소유자로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="69d41d917f1d5469eff45e378f228e62ac815b74" translate="yes" xml:space="preserve">
          <source>The new owner of the schema.</source>
          <target state="translated">스키마의 새로운 소유자.</target>
        </trans-unit>
        <trans-unit id="db70ea94e40096f71c45b13de8eea08d1af85b1d" translate="yes" xml:space="preserve">
          <source>The new owner of the tablespace.</source>
          <target state="translated">테이블 스페이스의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="e5c9278160aed343baae5e000f62f65dff7fc448" translate="yes" xml:space="preserve">
          <source>The new owner of the text search configuration.</source>
          <target state="translated">텍스트 검색 구성의 새로운 소유자</target>
        </trans-unit>
        <trans-unit id="aa73a2e5e347d201842eebdd89d547d089c6c8be" translate="yes" xml:space="preserve">
          <source>The new owner of the text search dictionary.</source>
          <target state="translated">텍스트 검색 사전의 새로운 소유자.</target>
        </trans-unit>
        <trans-unit id="edb8e480bb54a06edf443d08eda6114457bafd19" translate="yes" xml:space="preserve">
          <source>The new role will automatically inherit privileges of roles it is a member of. This is the default.</source>
          <target state="translated">새 역할은 자신이 속한 역할의 권한을 자동으로 상속합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9a32a2a68f765041e1e9d89874f5db158ceae654" translate="yes" xml:space="preserve">
          <source>The new role will not automatically inherit privileges of roles it is a member of.</source>
          <target state="translated">새 역할은 자신이 속한 역할의 권한을 자동으로 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9261c055206b3b24159966bd5e49b879f7e13689" translate="yes" xml:space="preserve">
          <source>The new schema for the aggregate function.</source>
          <target state="translated">집계 함수에 대한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="4dc45ae2528649758dd2b3da76e3b1bde5aae0c1" translate="yes" xml:space="preserve">
          <source>The new schema for the collation.</source>
          <target state="translated">데이터 정렬을위한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="fa5c853ff4ce0885678abb91184961581c7c86e8" translate="yes" xml:space="preserve">
          <source>The new schema for the conversion.</source>
          <target state="translated">변환을위한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="94f971cb399c2e27724257d01667804b12528aea" translate="yes" xml:space="preserve">
          <source>The new schema for the domain.</source>
          <target state="translated">도메인의 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="ffcd3334bad17af07bda4b5f314843b54c035a01" translate="yes" xml:space="preserve">
          <source>The new schema for the extension.</source>
          <target state="translated">확장을위한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="892a2ed0bb951cfb6e7f263bc8da7d70f88d788a" translate="yes" xml:space="preserve">
          <source>The new schema for the function.</source>
          <target state="translated">함수의 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="f75cbb7e0424884c76eaf66a88fc00d8e62673a7" translate="yes" xml:space="preserve">
          <source>The new schema for the materialized view.</source>
          <target state="translated">구체화 된 뷰의 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="f6752ffe51d8560507628fd3fa3becd8329772f1" translate="yes" xml:space="preserve">
          <source>The new schema for the operator class.</source>
          <target state="translated">연산자 클래스의 새 스키마</target>
        </trans-unit>
        <trans-unit id="91c91f016c0e190b6282eebefe2a49a89e2c716c" translate="yes" xml:space="preserve">
          <source>The new schema for the operator family.</source>
          <target state="translated">운영자 제품군의 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="a28f607105e64dc0674bab3c516a94057914430b" translate="yes" xml:space="preserve">
          <source>The new schema for the operator.</source>
          <target state="translated">운영자를위한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="5b76b1ebef9ac79184347fc03689e8ad83b75ad3" translate="yes" xml:space="preserve">
          <source>The new schema for the procedure.</source>
          <target state="translated">절차에 대한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="e1ef41d9bc55a3a445826b83357df117508b85c8" translate="yes" xml:space="preserve">
          <source>The new schema for the sequence.</source>
          <target state="translated">시퀀스의 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="051afa3d07978a274fc9c7a36c2e3cc09b60a787" translate="yes" xml:space="preserve">
          <source>The new schema for the statistics object.</source>
          <target state="translated">통계 오브젝트의 새 스키마</target>
        </trans-unit>
        <trans-unit id="b33b53d7a11df09b3be2d48051dd92657dd5246a" translate="yes" xml:space="preserve">
          <source>The new schema for the text search configuration.</source>
          <target state="translated">텍스트 검색 구성을위한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="ef261ca400ba6b8c404f8ae1051c9ddf74db7470" translate="yes" xml:space="preserve">
          <source>The new schema for the text search dictionary.</source>
          <target state="translated">텍스트 검색 사전에 대한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="6ee901249db3b5665acf6e566a8134c2dd5623bb" translate="yes" xml:space="preserve">
          <source>The new schema for the text search parser.</source>
          <target state="translated">텍스트 검색 파서의 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="0a8618e7f7d0e904983cf7fb40badda672a564d7" translate="yes" xml:space="preserve">
          <source>The new schema for the text search template.</source>
          <target state="translated">텍스트 검색 템플릿의 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="2dae7eeaa9912635729239a107cfdb2251e22f7c" translate="yes" xml:space="preserve">
          <source>The new schema for the type.</source>
          <target state="translated">유형에 대한 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="9da42308b2dd3741e38d355739234da9161529c8" translate="yes" xml:space="preserve">
          <source>The new schema for the view.</source>
          <target state="translated">뷰의 새로운 스키마.</target>
        </trans-unit>
        <trans-unit id="10efc2ba412402b38cf8661a03b9c2fa3f9344e1" translate="yes" xml:space="preserve">
          <source>The new security label, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the security label.</source>
          <target state="translated">문자열 리터럴로 작성된 새 보안 레이블. 또는 보안 레이블을 삭제하려면 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e179748e50d17a45a45be3da432d0626ce9f1871" translate="yes" xml:space="preserve">
          <source>The new server can now be safely started, and then any rsync'ed standby servers.</source>
          <target state="translated">이제 새 서버를 안전하게 시작한 다음 rsync의 대기 서버를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cccbe82fdca6cb05f61febaafdcdbee82d07beb" translate="yes" xml:space="preserve">
          <source>The new user will be a superuser.</source>
          <target state="translated">새로운 사용자는 수퍼 유저가됩니다.</target>
        </trans-unit>
        <trans-unit id="c54c521c104ba07a131d94a8006311919b30f264" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create databases.</source>
          <target state="translated">새로운 사용자는 데이터베이스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45b0936a7b0d005278d7069b144bbda44325062" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create new roles (that is, this user will have &lt;code&gt;CREATEROLE&lt;/code&gt; privilege).</source>
          <target state="translated">새 사용자는 새 역할을 만들 수 있습니다 (즉,이 사용자에게는 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이 있음).</target>
        </trans-unit>
        <trans-unit id="f77c7b82b1f36620c7d5c97f31d6b3e8156045cd" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to log in (that is, the user name can be used as the initial session user identifier). This is the default.</source>
          <target state="translated">새 사용자는 로그인 할 수 있습니다 (즉, 사용자 이름을 초기 세션 사용자 식별자로 사용할 수 있음). 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="20d6f51c275f9b74aaf81f7d6a5623641aaaf3e3" translate="yes" xml:space="preserve">
          <source>The new user will have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">새 사용자에게는 &lt;code&gt;REPLICATION&lt;/code&gt; 권한 이 있으며 , 이는 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 문서에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ea6c8532360a87549f7c059f52122ef9c601695" translate="yes" xml:space="preserve">
          <source>The new user will not be a superuser. This is the default.</source>
          <target state="translated">새로운 사용자는 수퍼 유저가 아닙니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="72c465f76c8179666632ce0c6f15419c4133425d" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create databases. This is the default.</source>
          <target state="translated">새로운 사용자는 데이터베이스를 만들 수 없습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="32dd0b63f5a01c58c0731e9846c0b6a55a21f4f0" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create new roles. This is the default.</source>
          <target state="translated">새 사용자는 새 역할을 만들 수 없습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="87cc74c8ed55ae4e670446b51aab48e450dbc14b" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to log in. (A role without login privilege is still useful as a means of managing database permissions.)</source>
          <target state="translated">새 사용자는 로그인 할 수 없습니다. 로그인 권한이없는 역할은 여전히 ​​데이터베이스 권한을 관리하는 수단으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a13d7c8eff958866dd3c2de41dd7c33e5dff939b" translate="yes" xml:space="preserve">
          <source>The new user will not have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">새 사용자에게는 &lt;code&gt;REPLICATION&lt;/code&gt; 권한 이 없습니다.이 권한은 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 설명서에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="127849b8d3eea48eada06bb9a69ad7d49b073868" translate="yes" xml:space="preserve">
          <source>The new value for a table storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">테이블 스토리지 매개 변수의 새 값 매개 변수에 따라 숫자 또는 단어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c290b36401426b8422b4d66e484cd2e82d3b87ce" translate="yes" xml:space="preserve">
          <source>The new value for an index-method-specific storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">인덱스 방법 별 스토리지 매개 변수의 새 값입니다. 매개 변수에 따라 숫자 또는 단어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c34da01d538b4bb95a9dcedad6f42505d9964bfa" translate="yes" xml:space="preserve">
          <source>The new value of the column</source>
          <target state="translated">열의 새로운 가치</target>
        </trans-unit>
        <trans-unit id="9cc0b73abbe4bf474235a0a153fa246959f47339" translate="yes" xml:space="preserve">
          <source>The new value to be added to an enum type's list of values, or the new name to be given to an existing value. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">열거 형 유형의 값 목록에 추가 할 새 값 또는 기존 값에 부여 할 새 이름입니다. 모든 열거 형 리터럴과 마찬가지로 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="3abd3f485b5c74bf1e64463613b4fb3d9ef53408" translate="yes" xml:space="preserve">
          <source>The new value to use for a template-specific option. If the equal sign and value are omitted, then any previous setting for the option is removed from the dictionary, allowing the default to be used.</source>
          <target state="translated">템플릿 별 옵션에 사용할 새 값입니다. 등호와 값을 생략하면 옵션의 이전 설정이 사전에서 제거되어 기본값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54266d9e3dff5c3d85bb17314ebcd06db8a0c4e2" translate="yes" xml:space="preserve">
          <source>The next example shows how to obtain the union of the tables &lt;code&gt;distributors&lt;/code&gt; and &lt;code&gt;actors&lt;/code&gt;, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key word &lt;code&gt;ALL&lt;/code&gt; is omitted.</source>
          <target state="translated">다음 예제는 테이블 &lt;code&gt;distributors&lt;/code&gt; 와 &lt;code&gt;actors&lt;/code&gt; 의 합집합을 얻는 방법을 보여 주며 결과를 각 테이블에서 문자 W로 시작하는 결과로 제한합니다. 별개의 행만 필요하므로 키워드 &lt;code&gt;ALL&lt;/code&gt; 은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="0b983bad83edd443b7b8ce4de658661eaff249f8" translate="yes" xml:space="preserve">
          <source>The next step is to set the session to use the new configuration, which was created in the &lt;code&gt;public&lt;/code&gt; schema:</source>
          <target state="translated">다음 단계는 &lt;code&gt;public&lt;/code&gt; 스키마 에서 생성 된 새 구성을 사용하도록 세션을 설정하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="69b04f7d07fe975427e0f7bf99be4fe924c78cc6" translate="yes" xml:space="preserve">
          <source>The non-default GIN operator class &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports indexing the &lt;code&gt;@&amp;gt;&lt;/code&gt; operator only. An example of creating an index with this operator class is:</source>
          <target state="translated">기본이 아닌 GIN 연산자 클래스 인 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 는 &lt;code&gt;@&amp;gt;&lt;/code&gt; 연산자의 색인 만 지원합니다 . 이 연산자 클래스로 색인을 작성하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d49459b2ff80f4c26bb14ba35712908d50a4f44" translate="yes" xml:space="preserve">
          <source>The normal PostgreSQL query optimizer performs a &lt;em&gt;near-exhaustive search&lt;/em&gt; over the space of alternative strategies. This algorithm, first introduced in IBM's System R database, produces a near-optimal join order, but can take an enormous amount of time and memory space when the number of joins in the query grows large. This makes the ordinary PostgreSQL query optimizer inappropriate for queries that join a large number of tables.</source>
          <target state="translated">일반적인 PostgreSQL 쿼리 옵티마이 저는 대체 전략의 공간에 대해 &lt;em&gt;거의 완전한 검색&lt;/em&gt; 을 수행합니다 . IBM의 System R 데이터베이스에 처음 도입 된이 알고리즘은 거의 최적의 결합 순서를 생성하지만 쿼리의 결합 수가 증가하면 시간과 메모리 공간이 많이 소요될 수 있습니다. 따라서 일반적인 PostgreSQL 쿼리 최적화 프로그램은 많은 수의 테이블을 조인하는 쿼리에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddb0abe82fae0bb47141f78e86913e1352bb274e" translate="yes" xml:space="preserve">
          <source>The notations &lt;code&gt;varchar(n)&lt;/code&gt; and &lt;code&gt;char(n)&lt;/code&gt; are aliases for &lt;code&gt;character varying(n)&lt;/code&gt; and &lt;code&gt;character(n)&lt;/code&gt;, respectively. &lt;code&gt;character&lt;/code&gt; without length specifier is equivalent to &lt;code&gt;character(1)&lt;/code&gt;. If &lt;code&gt;character varying&lt;/code&gt; is used without length specifier, the type accepts strings of any size. The latter is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;varchar(n)&lt;/code&gt; 및 &lt;code&gt;char(n)&lt;/code&gt; 표기법 은 각각 &lt;code&gt;character varying(n)&lt;/code&gt; 및 &lt;code&gt;character(n)&lt;/code&gt; 별명입니다 . 길이 지정자가없는 &lt;code&gt;character&lt;/code&gt; 는 &lt;code&gt;character(1)&lt;/code&gt; 과 같습니다 . &lt;code&gt;character varying&lt;/code&gt; 지정이 길이 지정자없이 사용되는 경우 유형은 모든 크기의 문자열을 허용합니다. 후자는 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="fbc61286b42787c186b2be652915f7206bb4ed7e" translate="yes" xml:space="preserve">
          <source>The number of &lt;em&gt;key columns&lt;/em&gt; in the index, not counting any &lt;em&gt;included columns&lt;/em&gt;, which are merely stored and do not participate in the index semantics</source>
          <target state="translated">인덱스 시맨틱에 참여하지 않고 단순히 저장되고 &lt;em&gt;포함 된 컬럼을&lt;/em&gt; 계산하지 않는 인덱스 의 &lt;em&gt;키 컬럼&lt;/em&gt; 수&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32236378278e06cdc1ed2783abcf03baa463efaf" translate="yes" xml:space="preserve">
          <source>The number of WAL segment files in &lt;code&gt;pg_wal&lt;/code&gt; directory depends on &lt;code&gt;min_wal_size&lt;/code&gt;, &lt;code&gt;max_wal_size&lt;/code&gt; and the amount of WAL generated in previous checkpoint cycles. When old log segment files are no longer needed, they are removed or recycled (that is, renamed to become future segments in the numbered sequence). If, due to a short-term peak of log output rate, &lt;code&gt;max_wal_size&lt;/code&gt; is exceeded, the unneeded segment files will be removed until the system gets back under this limit. Below that limit, the system recycles enough WAL files to cover the estimated need until the next checkpoint, and removes the rest. The estimate is based on a moving average of the number of WAL files used in previous checkpoint cycles. The moving average is increased immediately if the actual usage exceeds the estimate, so it accommodates peak usage rather than average usage to some extent. &lt;code&gt;min_wal_size&lt;/code&gt; puts a minimum on the amount of WAL files recycled for future usage; that much WAL is always recycled for future use, even if the system is idle and the WAL usage estimate suggests that little WAL is needed.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; 디렉토리 의 WAL 세그먼트 파일 수는 &lt;code&gt;min_wal_size&lt;/code&gt; , &lt;code&gt;max_wal_size&lt;/code&gt; 및 이전 검사 점주기에서 생성 된 WAL의 양에 따라 다릅니다 . 오래된 로그 세그먼트 파일이 더 이상 필요하지 않으면 제거되거나 재활용됩니다 (즉, 번호가 매겨진 순서에서 향후 세그먼트가되도록 이름이 바)). 단기 최대 로그 출력 속도로 &lt;code&gt;max_wal_size&lt;/code&gt; 를 초과하면 시스템이이 제한값 아래로 돌아올 때까지 불필요한 세그먼트 파일이 제거됩니다. 이 한계 아래에서 시스템은 다음 체크 포인트까지 예상 요구를 충족하기에 충분한 WAL 파일을 재활용하고 나머지는 제거합니다. 추정치는 이전 검사 점주기에서 사용 된 WAL 파일 수의 이동 평균을 기반으로합니다. 실제 사용량이 추정치를 초과하면 이동 평균이 즉시 증가하므로 어느 정도 평균 사용량보다는 최대 사용량을 수용합니다. &lt;code&gt;min_wal_size&lt;/code&gt; 는 향후 사용을 위해 재활용되는 WAL 파일의 양을 최소로 설정합니다. 시스템이 유휴 상태이고 WAL 사용량 추정에 따르면 WAL이 거의 필요하지 않더라도 나중에 사용하기 위해 많은 WAL이 항상 재활용됩니다.</target>
        </trans-unit>
        <trans-unit id="e63ffb99c780c2d3b3feec330c071c01fcbaec0d" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written to WAL such that this slot is not in danger of getting in state &quot;lost&quot;. It is NULL for lost slots, as well as if &lt;code&gt;max_slot_wal_keep_size&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">이 슬롯이 &quot;손실&quot;상태가 될 위험이 없도록 WAL에 쓸 수있는 바이트 수입니다. 손실 된 슬롯과 &lt;code&gt;max_slot_wal_keep_size&lt;/code&gt; 가 &lt;code&gt;-1&lt;/code&gt; 인 경우 NULL 입니다 .</target>
        </trans-unit>
        <trans-unit id="8748e9fef55cda632ea0102b0e063bbbb95c6586" translate="yes" xml:space="preserve">
          <source>The number of columns in partition key</source>
          <target state="translated">파티션 키의 열 수</target>
        </trans-unit>
        <trans-unit id="edbeec849445e687cd12eea0389ae4b06b732e80" translate="yes" xml:space="preserve">
          <source>The number of direct ancestors this column has. A column with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">이 열에있는 직계 조상의 수 조상 수가 아닌 열은 삭제하거나 이름을 바꿀 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d7208773dc180e0dd7b3e10265b4f310a20ba88e" translate="yes" xml:space="preserve">
          <source>The number of direct inheritance ancestors this constraint has. A constraint with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">이 제약 조건이 갖는 직접적인 상속 조상의 수 조상 수가 아닌 제약 조건은 삭제하거나 이름을 바꿀 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8301961997733ca48d253481eefaad3008a00674" translate="yes" xml:space="preserve">
          <source>The number of dirty buffers written in each round is based on the number of new buffers that have been needed by server processes during recent rounds. The average recent need is multiplied by &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; to arrive at an estimate of the number of buffers that will be needed during the next round. Dirty buffers are written until there are that many clean, reusable buffers available. (However, no more than &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; buffers will be written per round.) Thus, a setting of 1.0 represents a &amp;ldquo;just in time&amp;rdquo; policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">각 라운드에서 작성된 더티 버퍼 수는 최근 라운드 동안 서버 프로세스에 필요한 새 버퍼 수를 기반으로합니다. 최근 평균 &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; 에 bgwriter_lru_multiplier 를 곱하여 다음 라운드 동안 필요한 버퍼 수를 추정합니다. 더티 버퍼는 사용 가능한 깨끗하고 재사용 가능한 버퍼가 많을 때까지 기록됩니다. (그러나 &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; 이하버퍼는 라운드 당 기록됩니다.) 따라서 1.0으로 설정하면 필요한 것으로 예상되는 버퍼 수를 정확히 기록하는 &quot;정시&quot;정책을 나타냅니다. 값이 클수록 수요가 급증하는 것을 막을 수있는 반면 값이 작을수록 의도적으로 서버 프로세스에서 쓰기를 수행합니다. 기본값은 2.0입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d25f5401af5c842168f311144ea17e37058d652" translate="yes" xml:space="preserve">
          <source>The number of distinct nonnull data values in the column. A value greater than zero is the actual number of distinct values. A value less than zero is the negative of a multiplier for the number of rows in the table; for example, a column in which about 80% of the values are nonnull and each nonnull value appears about twice on average could be represented by &lt;code&gt;stadistinct&lt;/code&gt; = -0.4. A zero value means the number of distinct values is unknown.</source>
          <target state="translated">열에서 고유 한 널이 아닌 데이터 값의 수입니다. 0보다 큰 값은 실제 고유 값 수입니다. 0보다 작은 값은 테이블의 행 수에 대한 승수의 음수입니다. 예를 들어, 값의 약 80 %가 널이 &lt;code&gt;stadistinct&lt;/code&gt; 각 널이 아닌 값이 평균 약 2 배인 컬럼 은 stadistinct = -0.4 로 표시 될 수 있습니다 . 0 값은 고유 값의 수를 알 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8289805730489472578e3f27b2f1d288c0d7dec6" translate="yes" xml:space="preserve">
          <source>The number of iterations of the S2K algorithm to use. It must be a value between 1024 and 65011712, inclusive.</source>
          <target state="translated">사용할 S2K 알고리즘의 반복 횟수입니다. 1024에서 65011712 사이의 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9f0e73558363d09e86314a049abfbcf61eaf5cbd" translate="yes" xml:space="preserve">
          <source>The number of lexemes must be less than 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">욕구의 수는 2 &lt;sup&gt;64&lt;/sup&gt; 보다 작아야합니다&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d2adf53592a4a37e557ef19975d87459fecab27a" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before reporting an authentication failure. The default is 0.</source>
          <target state="translated">인증 실패를보고하기 전에 대기 할 시간 (밀리 초)입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4848e62664c3602823768b8a292b1248da926aa5" translate="yes" xml:space="preserve">
          <source>The number of nodes (lexemes + operators) in a &lt;code&gt;tsquery&lt;/code&gt; must be less than 32,768</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 의 노드 수 ( lexemes + operator)는 32,768보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="e36ab63c8c21311a28348db0c90c93619e02161d" translate="yes" xml:space="preserve">
          <source>The number of query cancels and the reason for them can be viewed using the &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; system view on the standby server. The &lt;code&gt;pg_stat_database&lt;/code&gt; system view also contains summary information.</source>
          <target state="translated">대기중인 서버 에서 &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; 시스템보기를 사용하여 쿼리 취소 횟수 및 이유를 확인할 수 있습니다 . &lt;code&gt;pg_stat_database&lt;/code&gt; 의 시스템 뷰는 요약 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d730ed06cd7648c33a05712cd3d40df8021dd41" translate="yes" xml:space="preserve">
          <source>The number of repetitions of the index scan that should be factored into the cost estimates. This will typically be greater than one when considering a parameterized scan for use in the inside of a nestloop join. Note that the cost estimates should still be for just one scan; a larger &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; means that it may be appropriate to allow for some caching effects across multiple scans.</source>
          <target state="translated">비용 추정치에 반영되어야하는 인덱스 스캔 반복 횟수입니다. 네스트 루프 조인 내부에서 사용하기 위해 매개 변수화 된 스캔을 고려할 때 일반적으로 1보다 큽니다. 비용 추정치는 여전히 한 번의 스캔에 대해서만 이루어져야합니다. &lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt; 가 크면 여러 스캔에서 일부 캐싱 효과를 허용하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166b286d18f619fbe9f6a3ea1bb840802689109b" translate="yes" xml:space="preserve">
          <source>The number of rows returned or affected by the last SQL query, or 0 if the query failed or did not report a row count.</source>
          <target state="translated">마지막 SQL 쿼리에 의해 반환되거나 영향을받는 행 수 또는 쿼리가 실패했거나 행 수를보고하지 않은 경우 0</target>
        </trans-unit>
        <trans-unit id="1d69a3b171c0833334cc425ee7e0d762adec494e" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">행 반환을 시작하기 전에 건너 뛸 행 수입니다. 자세한 내용은 &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 조항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94382b43faed8152ee9a457cefa14e2d7062f389" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="translated">행 반환을 시작하기 전에 건너 뛸 행 수입니다. 자세한 내용은 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 문서의 &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT 절&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aade2c0dad75a39b57c1da4c3274b381a44640e8" translate="yes" xml:space="preserve">
          <source>The number of the ISO 8601 week-numbering week of the year. By definition, ISO weeks start on Mondays and the first week of a year contains January 4 of that year. In other words, the first Thursday of a year is in week 1 of that year.</source>
          <target state="translated">해당 연도의 ISO 8601 주 번호 매기기 주 수입니다. 정의에 따르면 ISO주는 월요일에 시작되며 첫 번째 주에는 해당 연도의 1 월 4 일이 포함됩니다. 다시 말해, 첫 번째 목요일은 그 해의 1 주차입니다.</target>
        </trans-unit>
        <trans-unit id="4cb2d1007085e9fe567cf2f04104acbb29523d8d" translate="yes" xml:space="preserve">
          <source>The number of the column</source>
          <target state="translated">열의 수</target>
        </trans-unit>
        <trans-unit id="17b9b1cbc38db2adfa96c6b3cafb442db5c59e27" translate="yes" xml:space="preserve">
          <source>The number of the column. Ordinary columns are numbered from 1 up. System columns, such as &lt;code&gt;ctid&lt;/code&gt;, have (arbitrary) negative numbers.</source>
          <target state="translated">열의 번호입니다. 일반 열은 1부터 번호가 매겨집니다. &lt;code&gt;ctid&lt;/code&gt; 와 같은 시스템 열에 는 (임의의) 음수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5de13da859bcae07a08d4b002774933f9c4b34a" translate="yes" xml:space="preserve">
          <source>The number of the described column</source>
          <target state="translated">기술 된 열의 수</target>
        </trans-unit>
        <trans-unit id="8054a525924b0216f44b2c15796e49dd9491e9dd" translate="yes" xml:space="preserve">
          <source>The numbers provided by &lt;code&gt;BUFFERS&lt;/code&gt; help to identify which parts of the query are the most I/O-intensive.</source>
          <target state="translated">&lt;code&gt;BUFFERS&lt;/code&gt; 가 제공 한 숫자 는 쿼리에서 어느 부분이 가장 I / O 집약적인지 식별하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a9a9a7a626d48ccbaac2fc53aad8be63a44035" translate="yes" xml:space="preserve">
          <source>The numerical, unique, sequentially-assigned identifier that each transaction receives when it first causes a database modification. Frequently abbreviated as &lt;em&gt;xid&lt;/em&gt;. When stored on disk, xids are only 32-bits wide, so only approximately four billion write transaction IDs can be generated; to permit the system to run for longer than that, &lt;em&gt;epochs&lt;/em&gt; are used, also 32 bits wide. When the counter reaches the maximum xid value, it starts over at &lt;code&gt;3&lt;/code&gt; (values under that are reserved) and the epoch value is incremented by one. In some contexts, the epoch and xid values are considered together as a single 64-bit value.</source>
          <target state="translated">각 트랜잭션이 처음 데이터베이스 수정을 유발할 때 수신하는 숫자의 고유 한 순차적 할당 식별자입니다. &lt;em&gt;xid&lt;/em&gt; 로 자주 축약됩니다 . 디스크에 저장 될 때 xid의 너비는 32 비트에 불과하므로 약 40 억 개의 쓰기 트랜잭션 ID 만 생성 할 수 있습니다. 시스템이 그보다 오래 실행될 수 있도록 32 비트 폭의 &lt;em&gt;epoch&lt;/em&gt; 가 사용됩니다. 카운터가 최대 xid 값에 도달하면 &lt;code&gt;3&lt;/code&gt; (예약 된 값 미만) 에서 다시 시작 하고 epoch 값이 1 씩 증가합니다. 일부 컨텍스트에서 epoch 및 xid 값은 함께 단일 64 비트 값으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="23f1e0aeb5175fc6ed920199dd580b15702c2054" translate="yes" xml:space="preserve">
          <source>The object which describes a WAL range always has three keys:</source>
          <target state="translated">WAL 범위를 설명하는 개체에는 항상 세 개의 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f439f1411e4ff73cafff6f9e11f463408382ecb" translate="yes" xml:space="preserve">
          <source>The object which describes a single file contains either a &lt;code&gt;Path&lt;/code&gt; key or an &lt;code&gt;Encoded-Path&lt;/code&gt; key. Normally, the &lt;code&gt;Path&lt;/code&gt; key will be present. The associated string value is the path of the file relative to the root of the backup directory. Files located in a user-defined tablespace will have paths whose first two components are &lt;code&gt;pg_tblspc&lt;/code&gt; and the OID of the tablespace. If the path is not a string that is legal in UTF-8, or if the user requests that encoded paths be used for all files, then the &lt;code&gt;Encoded-Path&lt;/code&gt; key will be present instead. This stores the same data, but it is encoded as a string of hexadecimal digits. Each pair of hexadecimal digits in the string represents a single octet.</source>
          <target state="translated">단일 파일을 설명하는 개체는 &lt;code&gt;Path&lt;/code&gt; 키 또는 &lt;code&gt;Encoded-Path&lt;/code&gt; 키를 포함합니다. 일반적으로 &lt;code&gt;Path&lt;/code&gt; 키가 있습니다. 연관된 문자열 값은 백업 디렉토리의 루트에 상대적인 파일의 경로입니다. 사용자 정의 테이블 스페이스에있는 파일에는 처음 두 구성 요소가 &lt;code&gt;pg_tblspc&lt;/code&gt; 및 테이블 스페이스의 OID 인 경로가 있습니다 . 경로가 UTF-8에서 유효한 문자열이 아니거나 사용자가 인코딩 된 경로를 모든 파일에 사용하도록 요청하면 &lt;code&gt;Encoded-Path&lt;/code&gt; 키가 대신 표시됩니다. 동일한 데이터를 저장하지만 16 진수 문자열로 인코딩됩니다. 문자열의 각 16 진수 쌍은 단일 옥텟을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3001cae2699919156e01018ff603c7cc3b34ddd4" translate="yes" xml:space="preserve">
          <source>The object's key-value pairs, represented as an array of objects containing three fields: &lt;code&gt;&quot;key&quot;&lt;/code&gt;, &lt;code&gt;&quot;value&quot;&lt;/code&gt;, and &lt;code&gt;&quot;id&quot;&lt;/code&gt;; &lt;code&gt;&quot;id&quot;&lt;/code&gt; is a unique identifier of the object the key-value pair belongs to</source>
          <target state="translated">객체의 키-값 쌍, &lt;code&gt;&quot;key&quot;&lt;/code&gt; , &lt;code&gt;&quot;value&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;id&quot;&lt;/code&gt; 의 세 필드를 포함하는 객체의 배열로 표현됩니다 . &lt;code&gt;&quot;id&quot;&lt;/code&gt; 는 키-값 쌍이 속한 개체의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="c96b4217f4ff70cb5052589aed86a75a58ea381a" translate="yes" xml:space="preserve">
          <source>The obsolete options &lt;code&gt;SORT1&lt;/code&gt;, &lt;code&gt;SORT2&lt;/code&gt;, &lt;code&gt;LTCMP&lt;/code&gt;, and &lt;code&gt;GTCMP&lt;/code&gt; were formerly used to specify the names of sort operators associated with a merge-joinable operator. This is no longer necessary, since information about associated operators is found by looking at B-tree operator families instead. If one of these options is given, it is ignored except for implicitly setting &lt;code&gt;MERGES&lt;/code&gt; true.</source>
          <target state="translated">더 이상 사용되지 않는 옵션 &lt;code&gt;SORT1&lt;/code&gt; , &lt;code&gt;SORT2&lt;/code&gt; , &lt;code&gt;LTCMP&lt;/code&gt; 및 &lt;code&gt;GTCMP&lt;/code&gt; 는 이전에 병합 결합 연산자와 연관된 정렬 연산자의 이름을 지정하는 데 사용되었습니다. 대신 B- 트리 연산자 패밀리를보고 연관된 연산자에 대한 정보를 찾을 수 있으므로 더 이상 필요하지 않습니다. 이러한 옵션 중 하나가 제공되면 &lt;code&gt;MERGES&lt;/code&gt; 를 암시 적으로 true로 설정하는 것을 제외하고는 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="c4bf61bc0ae75f599a4b04ad0336e82b98b0a3d1" translate="yes" xml:space="preserve">
          <source>The octet with decimal value 92 (backslash) is doubled in the output. Details are in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;Table 8.8&lt;/a&gt;.</source>
          <target state="translated">10 진수 값 92 (백 슬래시)의 옥텟이 출력에서 ​​두 배가됩니다. 자세한 내용은 &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;표 8.8에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed338423cb1bcb126644c1e6c22121f438859be7" translate="yes" xml:space="preserve">
          <source>The offset at which the allocation starts. NULL for anonymous allocations and unused memory.</source>
          <target state="translated">할당이 시작되는 오프셋입니다. 익명 할당 및 사용되지 않은 메모리의 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="1bf48e5f27220de9fe763df392dfdaead2007f3b" translate="yes" xml:space="preserve">
          <source>The offset fields specify the hours, and optionally minutes and seconds, difference from UTC. They have the format &lt;code&gt;hh&lt;/code&gt;[&lt;code&gt;:&lt;/code&gt;&lt;code&gt;mm&lt;/code&gt;[&lt;code&gt;:&lt;/code&gt;&lt;code&gt;ss&lt;/code&gt;]] optionally with a leading sign (&lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;). The positive sign is used for zones &lt;em&gt;west&lt;/em&gt; of Greenwich. (Note that this is the opposite of the ISO-8601 sign convention used elsewhere in PostgreSQL.) &lt;code&gt;hh&lt;/code&gt; can have one or two digits; &lt;code&gt;mm&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; (if used) must have two.</source>
          <target state="translated">오프셋 필드는 UTC와의 차이 인 시간, 선택적으로 분 및 초를 지정합니다. 선택적으로 선행 기호 ( &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; ) 와 함께 &lt;code&gt;hh&lt;/code&gt; [ &lt;code&gt;:&lt;/code&gt; &lt;code&gt;mm&lt;/code&gt; [ &lt;code&gt;:&lt;/code&gt; &lt;code&gt;ss&lt;/code&gt; ]] 형식을 갖습니다 . 양수 부호는 그리니치 &lt;em&gt;서쪽&lt;/em&gt; 구역에 사용됩니다 . (이는 PostgreSQL의 다른 곳에서 사용되는 ISO-8601 기호 규칙과 반대입니다.) &lt;code&gt;hh&lt;/code&gt; 는 한 자리 또는 두 자리를 가질 수 있습니다. &lt;code&gt;mm&lt;/code&gt; 및 &lt;code&gt;ss&lt;/code&gt; (사용 된 경우)에는 2 개가 있어야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51b42992b2dbbebe4441f992b139d475f2a6576d" translate="yes" xml:space="preserve">
          <source>The old indexes are dropped. The &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; session locks for the indexes and the table are released.</source>
          <target state="translated">이전 인덱스가 삭제됩니다. &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 의 인덱스 및 테이블에 대한 세션 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="aff5f1b14035796efdcabc3055a299cc4fcb8ba7" translate="yes" xml:space="preserve">
          <source>The old indexes have &lt;code&gt;pg_index.indisready&lt;/code&gt; switched to &amp;ldquo;false&amp;rdquo; to prevent any new tuple insertions, after waiting for running queries that might reference the old index to complete.</source>
          <target state="translated">기존 인덱스를 완료하기 위해 쿼리를 실행할 때까지 기다린 후 새 인덱스 삽입을 방지하기 위해 이전 인덱스는 &lt;code&gt;pg_index.indisready&lt;/code&gt; 를 &quot;false&quot;로 전환했습니다.</target>
        </trans-unit>
        <trans-unit id="05be6eb32947b010e242b9b77a81ac45522407a1" translate="yes" xml:space="preserve">
          <source>The oldest transaction affecting the system catalogs that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove catalog tuples deleted by any later transaction.</source>
          <target state="translated">이 슬롯에 데이터베이스를 보유해야하는 시스템 카탈로그에 영향을주는 가장 오래된 트랜잭션입니다. &lt;code&gt;VACUUM&lt;/code&gt; 은 이후 트랜잭션에서 삭제 된 카탈로그 튜플을 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5faf9118a5f5509db65f9f3d1a55a7c88d7b4faa" translate="yes" xml:space="preserve">
          <source>The oldest transaction that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove tuples deleted by any later transaction.</source>
          <target state="translated">이 슬롯에 데이터베이스를 보유해야하는 가장 오래된 트랜잭션입니다. &lt;code&gt;VACUUM&lt;/code&gt; 은 이후 트랜잭션에서 삭제 된 튜플을 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f97ff854cd0196d6cae74ec459d42c99253ddda9" translate="yes" xml:space="preserve">
          <source>The only feature of AREs that is actually incompatible with POSIX EREs is that &lt;code&gt;\&lt;/code&gt; does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the &lt;code&gt;***&lt;/code&gt; syntax of directors likewise is outside the POSIX syntax for both BREs and EREs.</source>
          <target state="translated">실제로 POSIX ERE와 호환되지 않는 ARE의 유일한 기능은 &lt;code&gt;\&lt;/code&gt; 가 대괄호 표현식 내에서 특별한 의미를 잃지 않는다는 것입니다. 다른 모든 ARE 기능은 POSIX ERE에서 불법이거나 정의되지 않았거나 지정되지 않은 효과가있는 구문을 사용합니다. 디렉터 의 &lt;code&gt;***&lt;/code&gt; 구문도 마찬가지로 BRE 및 ERE의 POSIX 구문 외부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a1895f6d1a24facb26fe1c49448d16cf40a3e4a" translate="yes" xml:space="preserve">
          <source>The only firm requirement for using NFS with PostgreSQL is that the file system is mounted using the &lt;code&gt;hard&lt;/code&gt; option. With the &lt;code&gt;hard&lt;/code&gt; option, processes can &amp;ldquo;hang&amp;rdquo; indefinitely if there are network problems, so this configuration will require a careful monitoring setup. The &lt;code&gt;soft&lt;/code&gt; option will interrupt system calls in case of network problems, but PostgreSQL will not repeat system calls interrupted in this way, so any such interruption will result in an I/O error being reported.</source>
          <target state="translated">PostgreSQL에서 NFS를 사용하기위한 유일한 요구 사항은 파일 시스템이 &lt;code&gt;hard&lt;/code&gt; 옵션을 사용하여 마운트되어야한다는 것입니다. &lt;code&gt;hard&lt;/code&gt; 옵션을 사용하면 네트워크 문제가있는 경우 프로세스가 무한정 &quot;중지&quot;될 수 있으므로이 구성에는 신중한 모니터링 설정이 필요합니다. &lt;code&gt;soft&lt;/code&gt; 옵션은 네트워크 문제가있는 경우에 시스템 호출을 중단하지만, 그러한 중단이 I / O 오류가보고되는 결과 있도록 PostgreSQL은 반복 시스템 호출은이 방법으로 중단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a396e16c5e2752bf51d263513d40dc846694333b" translate="yes" xml:space="preserve">
          <source>The only parameter required by the &lt;code&gt;synonym&lt;/code&gt; template is &lt;code&gt;SYNONYMS&lt;/code&gt;, which is the base name of its configuration file &amp;mdash; &lt;code&gt;my_synonyms&lt;/code&gt; in the above example. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; (where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory). The file format is just one line per word to be substituted, with the word followed by its synonym, separated by white space. Blank lines and trailing spaces are ignored.</source>
          <target state="translated">에 의해 필요한 유일한 매개 변수 &lt;code&gt;synonym&lt;/code&gt; 템플릿은 &lt;code&gt;SYNONYMS&lt;/code&gt; - 구성 파일의 기본 이름입니다 &lt;code&gt;my_synonyms&lt;/code&gt; 위의 예이다. 파일의 전체 이름은 &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; (여기서 &lt;code&gt;$SHAREDIR&lt;/code&gt; 은 PostgreSQL 설치의 공유 데이터 디렉토리를 나타냄). 파일 형식은 대체 할 단어 당 한 줄이며, 단어 뒤에 동의어가 있으며 공백으로 구분됩니다. 빈 줄과 후행 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a030d7c4538742e2439ddd895553830f470ea35b" translate="yes" xml:space="preserve">
          <source>The operations that occur on both primary and standby servers are normal continuous archiving and recovery tasks. The only point of contact between the two database servers is the archive of WAL files that both share: primary writing to the archive, standby reading from the archive. Care must be taken to ensure that WAL archives from separate primary servers do not become mixed together or confused. The archive need not be large if it is only required for standby operation.</source>
          <target state="translated">기본 및 대기 서버에서 발생하는 작업은 일반적인 연속 보관 및 복구 작업입니다. 두 데이터베이스 서버 간의 유일한 연락 지점은 아카이브에 대한 기본 쓰기, 아카이브에서 대기 읽기와 같은 WAL 파일의 아카이브입니다. 별도의 주 서버에서 WAL 아카이브가 혼합되거나 혼동되지 않도록주의해야합니다. 아카이브는 대기 작업에만 필요한 경우 크지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="78a77532759d107a293f71b3071e91121689e001" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;!=&lt;/code&gt; is mapped to &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; on input, so these two names are always equivalent.</source>
          <target state="translated">연산자 &lt;code&gt;!=&lt;/code&gt; 는 입력시 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에 매핑되므로이 두 이름은 항상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7680d70684ff5657bfcc4e3b94f75e49715485f1" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific.</source>
          <target state="translated">연산자 &lt;code&gt;~~&lt;/code&gt; 는 &lt;code&gt;LIKE&lt;/code&gt; 와 같고 &lt;code&gt;~~*&lt;/code&gt; 는 &lt;code&gt;ILIKE&lt;/code&gt; 에 해당합니다 . 이 또한 &lt;code&gt;!~~&lt;/code&gt; 와 &lt;code&gt;!~~*&lt;/code&gt; 대표 사업자 &lt;code&gt;NOT LIKE&lt;/code&gt; 및 &lt;code&gt;NOT ILIKE&lt;/code&gt; 을 각각은. 이러한 연산자는 모두 PostgreSQL에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bd4509fc82896a3a7a34fb1c8f105531cc74d101" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific. You may see these operator names in &lt;code&gt;EXPLAIN&lt;/code&gt; output and similar places, since the parser actually translates &lt;code&gt;LIKE&lt;/code&gt; et al. to these operators.</source>
          <target state="translated">&lt;code&gt;~~&lt;/code&gt; 연산자 는 &lt;code&gt;LIKE&lt;/code&gt; 에 해당 하고 &lt;code&gt;~~*&lt;/code&gt; 는 &lt;code&gt;ILIKE&lt;/code&gt; 에 해당합니다 . 이 또한 &lt;code&gt;!~~&lt;/code&gt; 와 &lt;code&gt;!~~*&lt;/code&gt; 대표 사업자 &lt;code&gt;NOT LIKE&lt;/code&gt; 및 &lt;code&gt;NOT ILIKE&lt;/code&gt; 을 각각은. 이러한 모든 연산자는 PostgreSQL에 고유합니다. 파서가 실제로 &lt;code&gt;LIKE&lt;/code&gt; 등을 번역하기 때문에 &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 및 유사한 위치 에서 이러한 연산자 이름을 볼 수 있습니다 . 이 연산자들에게.</target>
        </trans-unit>
        <trans-unit id="1d017a3795e4c2a850feefb2cba71cdbcd408d49" translate="yes" xml:space="preserve">
          <source>The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on the type &lt;code&gt;int4&lt;/code&gt; would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for values of type &lt;code&gt;int4&lt;/code&gt;. In practice the default operator class for the column's data type is usually sufficient. The main reason for having operator classes is that for some data types, there could be more than one meaningful index behavior. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when making an index. The operator class determines the basic sort ordering (which can then be modified by adding sort options &lt;code&gt;COLLATE&lt;/code&gt;, &lt;code&gt;ASC&lt;/code&gt;/&lt;code&gt;DESC&lt;/code&gt; and/or &lt;code&gt;NULLS FIRST&lt;/code&gt;/&lt;code&gt;NULLS LAST&lt;/code&gt;).</source>
          <target state="translated">연산자 클래스는 해당 열의 색인에서 사용할 연산자를 식별합니다. 예를 들어, &lt;code&gt;int4&lt;/code&gt; 유형의 B- 트리 인덱스 는 &lt;code&gt;int4_ops&lt;/code&gt; 클래스를 사용합니다 . 이 연산자 클래스에는 &lt;code&gt;int4&lt;/code&gt; 유형의 값에 대한 비교 함수가 포함됩니다. 실제로는 열의 데이터 유형에 대한 기본 연산자 클래스로 충분합니다. 연산자 클래스가있는 주된 이유는 일부 데이터 유형의 경우 의미있는 인덱스 동작이 두 개 이상있을 수 있기 때문입니다. 예를 들어 복소수 데이터 유형을 절대 값 또는 실수로 정렬 할 수 있습니다. 데이터 유형에 대해 두 개의 연산자 클래스를 정의한 다음 색인 작성시 적절한 클래스를 선택하여이를 수행 할 수 있습니다. 연산자 클래스는 기본 정렬 순서를 결정합니다 (정렬 옵션 &lt;code&gt;COLLATE&lt;/code&gt; , &lt;code&gt;ASC&lt;/code&gt; / &lt;code&gt;DESC&lt;/code&gt; 및 / 또는 &lt;code&gt;NULLS FIRST&lt;/code&gt; / &lt;code&gt;NULLS LAST&lt;/code&gt; 를 추가하여 수정할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="79d3ccfc646e039879a5fc434785db86b4443933" translate="yes" xml:space="preserve">
          <source>The operator classes &lt;code&gt;text_pattern_ops&lt;/code&gt;, &lt;code&gt;varchar_pattern_ops&lt;/code&gt;, and &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; support B-tree indexes on the types &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; respectively. The difference from the default operator classes is that the values are compared strictly character by character rather than according to the locale-specific collation rules. This makes these operator classes suitable for use by queries involving pattern matching expressions (&lt;code&gt;LIKE&lt;/code&gt; or POSIX regular expressions) when the database does not use the standard &amp;ldquo;C&amp;rdquo; locale. As an example, you might index a &lt;code&gt;varchar&lt;/code&gt; column like this:</source>
          <target state="translated">연산자 클래스 &lt;code&gt;text_pattern_ops&lt;/code&gt; , &lt;code&gt;varchar_pattern_ops&lt;/code&gt; 및 &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; 는 각각 &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 유형의 B- 트리 인덱스를 지원 합니다. 기본 연산자 클래스와의 차이점은 로케일 별 데이터 정렬 규칙이 아닌 문자별로 값이 엄격하게 비교된다는 것입니다. 이것은 데이터베이스가 표준&amp;ldquo;C&amp;rdquo;로케일을 사용하지 않을 때 패턴 연산자 표현식 ( &lt;code&gt;LIKE&lt;/code&gt; 또는 POSIX 정규 표현식) 과 관련된 쿼리에서 이러한 연산자 클래스를 사용하기에 적합합니다 . 예를 들어 다음 과 같이 &lt;code&gt;varchar&lt;/code&gt; 열을 인덱싱 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33bad4a7b35adf68e8d48de054b950c2d1ec9c35" translate="yes" xml:space="preserve">
          <source>The operator family this entry is for</source>
          <target state="translated">이 항목의 운영자 제품군</target>
        </trans-unit>
        <trans-unit id="223e98e65916141080aa613ffd5f9982aa449061" translate="yes" xml:space="preserve">
          <source>The operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">연산자 이름은 다음 목록에서 최대 &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1 (기본적으로 63) 문자입니다.</target>
        </trans-unit>
        <trans-unit id="e93319af4ff4ab58e4fcfce194629f2f03f458a1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; are equivalent to PostgreSQL's built-in operators of the same names, except that they work only on integer arrays that do not contain nulls, while the built-in operators work for any array type. This restriction makes them faster than the built-in operators in many cases.</source>
          <target state="translated">연산자는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;@&lt;/code&gt; 동등한 PostgreSQL을에 내장 된 같은 이름의 운영자, 그들이 널 (null)를 포함하지 않는 정수 배열에서만 작동한다는 점을 제외하면서 내장 된 모든 배열 유형에 대한 사업자 작동합니다. 이 제한은 많은 경우 내장 연산자보다 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="a0d063cd8a5cd2a97ff1408a1433cc81fe5925af" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; have analogues &lt;code&gt;^&amp;lt;@&lt;/code&gt;, &lt;code&gt;^@&amp;gt;&lt;/code&gt;, &lt;code&gt;^@&lt;/code&gt;, &lt;code&gt;^~&lt;/code&gt;, which are the same except they do not use indexes. These are useful only for testing purposes.</source>
          <target state="translated">&lt;code&gt;&amp;lt;@&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 연산자 에는 유사 항목 &lt;code&gt;^&amp;lt;@&lt;/code&gt; , &lt;code&gt;^@&amp;gt;&lt;/code&gt; , &lt;code&gt;^@&lt;/code&gt; , &lt;code&gt;^~&lt;/code&gt; 가 있으며 인덱스를 사용하지 않는 것 외에는 동일합니다. 이들은 테스트 목적으로 만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fbca8888a118f48ef45503ea9b2b65638278cb3a" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operand without affecting the result. But see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.</source>
          <target state="translated">&lt;code&gt;AND&lt;/code&gt; 와 &lt;code&gt;OR&lt;/code&gt; 연산자 는 교환 형이므로 결과에 영향을주지 않고 왼쪽과 오른쪽 피연산자를 전환 할 수 있습니다. 그러나 하위 표현식 평가 순서에 대한 자세한 내용은 &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;4.2.14 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab3b948d9f1df6a05c6208cb2087918561197bec" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operands without affecting the result. (However, it is not guaranteed that the left operand is evaluated before the right operand. See &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.)</source>
          <target state="translated">연산자 &lt;code&gt;AND&lt;/code&gt; 및 &lt;code&gt;OR&lt;/code&gt; 은 교환 적입니다. 즉, 결과에 영향을주지 않고 왼쪽 및 오른쪽 피연산자를 전환 할 수 있습니다. (그러나 왼쪽 피연산자가 오른쪽 피연산자보다 먼저 평가된다는 보장은 없습니다. 하위 표현식 평가 순서에 대한 자세한 내용은 &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;섹션 4.2.14&lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="afda15b721563ddc4ee8a5707f908cf503dfae35" translate="yes" xml:space="preserve">
          <source>The operators provided by the &lt;code&gt;hstore&lt;/code&gt; module are shown in &lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;Table F.7&lt;/a&gt;, the functions in &lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;Table F.8&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 모듈에서 제공하는 연산자 는 &lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;표 F.8&lt;/a&gt; 의 기능인 &lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;표 F.7&lt;/a&gt; 에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="43de536c659d022d6659ab7d7ed96e1f9a44966b" translate="yes" xml:space="preserve">
          <source>The operators should not be defined by SQL functions. A SQL function is likely to be inlined into the calling query, which will prevent the optimizer from recognizing that the query matches an index.</source>
          <target state="translated">연산자는 SQL 함수로 정의되어서는 안됩니다. SQL 함수가 호출 쿼리에 인라인 될 가능성이 있으며, 이로 인해 옵티마이 저가 쿼리가 인덱스와 일치 함을 인식하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7779f9394f3c14857d843cdc250d88697a649fe" translate="yes" xml:space="preserve">
          <source>The optimal value for this option depends on the hardware setup of the server, of the client, and of the network. Factors include the number of CPU cores and the disk setup. A good place to start is the number of CPU cores on the server, but values larger than that can also lead to faster restore times in many cases. Of course, values that are too high will lead to decreased performance because of thrashing.</source>
          <target state="translated">이 옵션의 최적 값은 서버, 클라이언트 및 네트워크의 하드웨어 설정에 따라 다릅니다. CPU 코어 수 및 디스크 설정과 같은 요소가 있습니다. 시작하기에 좋은 곳은 서버의 CPU 코어 수이지만 그보다 큰 값은 많은 경우에 더 빠른 복원 시간을 초래할 수도 있습니다. 물론 값이 너무 높으면 스 래싱으로 인해 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="d0eb1545843db39f7e5b62a874b3d76a7289a03a" translate="yes" xml:space="preserve">
          <source>The optimizer can also use a B-tree index for queries involving the pattern matching operators &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;&lt;em&gt;if&lt;/em&gt; the pattern is a constant and is anchored to the beginning of the string &amp;mdash; for example, &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; or &lt;code&gt;col ~ '^foo'&lt;/code&gt;, but not &lt;code&gt;col LIKE '%bar'&lt;/code&gt;. However, if your database does not use the C locale you will need to create the index with a special operator class to support indexing of pattern-matching queries; see &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; below. It is also possible to use B-tree indexes for &lt;code&gt;ILIKE&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt;, but only if the pattern starts with non-alphabetic characters, i.e., characters that are not affected by upper/lower case conversion.</source>
          <target state="translated">최적화는 일치 사업자 패턴과 관련된 질의에 대한 B-tree 인덱스를 사용할 수 &lt;code&gt;LIKE&lt;/code&gt; 와 &lt;code&gt;~&lt;/code&gt; 를&lt;em&gt;하는 경우&lt;/em&gt; 예를 들어, 위해 - 패턴이 일정하고 문자열의 시작 부분에 고정되어 &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; 또는 &lt;code&gt;col ~ '^foo'&lt;/code&gt; 이지만 &lt;code&gt;col LIKE '%bar'&lt;/code&gt; 아닙니다 . 그러나 데이터베이스가 C 로케일을 사용하지 않는 경우 패턴 일치 조회의 색인 작성을 지원하기 위해 특수 연산자 클래스로 색인을 작성해야합니다. 아래 &lt;a href=&quot;indexes-opclass&quot;&gt;11.10 절을&lt;/a&gt; 참조하십시오 . &lt;code&gt;ILIKE&lt;/code&gt; 및 &lt;code&gt;~*&lt;/code&gt; B- 트리 인덱스를 사용할 수도 있습니다.패턴이 알파벳이 아닌 문자, 즉 대소 문자 변환에 영향을받지 않는 문자로 시작하는 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8627270becb595b05140641f72d8445a0f79aa4e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;STORED&lt;/code&gt; is not standard but is also used by other SQL implementations. The SQL standard does not specify the storage of generated columns.</source>
          <target state="translated">&lt;code&gt;STORED&lt;/code&gt; 옵션 은 표준은 아니지만 다른 SQL 구현에서도 사용됩니다. SQL 표준은 생성 된 열의 스토리지를 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a815faad2e87479a66432f285e1a514f8c1d46e0" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, any database name in the connection string will be ignored.</source>
          <target state="translated">이 옵션은 다른 클라이언트 응용 프로그램과의 일관성을 위해 &lt;code&gt;--dbname&lt;/code&gt; 이라고 부르지 만 pg_basebackup은 클러스터의 특정 데이터베이스에 연결하지 않기 때문에 연결 문자열의 모든 데이터베이스 이름이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="734d38a3ce131eec63febbaae7def3c5bde63bbb" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">다른 클라이언트 응용 프로그램과의 일관성을 유지하기 위해이 옵션을 &lt;code&gt;--dbname&lt;/code&gt; 이라고 하지만 pg_basebackup은 클러스터의 특정 데이터베이스에 연결되지 않으므로 연결 문자열의 데이터베이스 이름은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0db5016ffe3da0ce1e6c9b806713d2a3baee1dd9" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_dumpall needs to connect to many databases, the database name in the connection string will be ignored. Use the &lt;code&gt;-l&lt;/code&gt; option to specify the name of the database used for the initial connection, which will dump global objects and discover what other databases should be dumped.</source>
          <target state="translated">다른 클라이언트 응용 프로그램과의 일관성을 유지하기 &lt;code&gt;--dbname&lt;/code&gt; 옵션을 --dbname 이라고 하지만 pg_dumpall은 많은 데이터베이스에 연결해야하기 때문에 연결 문자열의 데이터베이스 이름은 무시됩니다. 사용 &lt;code&gt;-l&lt;/code&gt; 전역 개체를 덤프 및 다른 데이터베이스 덤프되어야 하는지를 발견 할 초기 연결에 사용되는 데이터베이스의 이름을 지정하는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b6f402f5f677410d43632fdfdda39802e1f95c15" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_receivewal doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">다른 클라이언트 응용 프로그램과의 일관성을 위해이 옵션을 &lt;code&gt;--dbname&lt;/code&gt; 이라고 하지만 pg_receivewal은 클러스터의 특정 데이터베이스에 연결되지 않으므로 연결 문자열의 데이터베이스 이름은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c64ec896dfd3c50e33366b062eb4c419c8b0b7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;CYCLE&lt;/code&gt; key word can be used to enable the sequence to wrap around when the &lt;code&gt;maxvalue&lt;/code&gt; or &lt;code&gt;minvalue&lt;/code&gt; has been reached by an ascending or descending sequence respectively. If the limit is reached, the next number generated will be the &lt;code&gt;minvalue&lt;/code&gt; or &lt;code&gt;maxvalue&lt;/code&gt;, respectively.</source>
          <target state="translated">선택적 &lt;code&gt;CYCLE&lt;/code&gt; 키 워드는 랩 어라운드 할 때 시퀀스를 활성화하는데 사용될 수있다 &lt;code&gt;maxvalue&lt;/code&gt; 또는 &lt;code&gt;minvalue&lt;/code&gt; 오름차순 또는 내림차순 순서 각각 도달되었다. 한계에 도달하면 다음에 생성되는 숫자는 각각 &lt;code&gt;minvalue&lt;/code&gt; 또는 &lt;code&gt;maxvalue&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2bdec9ebdf4b00fd140bf7dd49f116ee6c5a4a50" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;GROUP BY&lt;/code&gt; clause has the general form</source>
          <target state="translated">선택적 &lt;code&gt;GROUP BY&lt;/code&gt; 절은 일반적인 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9c06d7f3daaeb4524eeb820424e28a6752ac9545" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;HAVING&lt;/code&gt; clause has the general form</source>
          <target state="translated">선택적 &lt;code&gt;HAVING&lt;/code&gt; 절은 일반적인 형식입니다.</target>
        </trans-unit>
        <trans-unit id="e76a720d25d7bf8d3cf5b4abaa11a67203b026f7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause specifies a list of columns which will be included in the index as &lt;em&gt;non-key&lt;/em&gt; columns. A non-key column cannot be used in an index scan search qualification, and it is disregarded for purposes of any uniqueness or exclusion constraint enforced by the index. However, an index-only scan can return the contents of non-key columns without having to visit the index's table, since they are available directly from the index entry. Thus, addition of non-key columns allows index-only scans to be used for queries that otherwise could not use them.</source>
          <target state="translated">선택적 &lt;code&gt;INCLUDE&lt;/code&gt; 절은 색인 &lt;em&gt;에 키가 아닌&lt;/em&gt; 열로 포함될 열 목록을 지정합니다 . 키가 아닌 열은 인덱스 스캔 검색 규정에 사용할 수 없으며 인덱스에 의해 시행되는 고유성 또는 제외 제한 조건의 목적으로 무시됩니다. 그러나 인덱스 전용 스캔은 인덱스 항목에서 직접 사용할 수 있으므로 인덱스 테이블을 방문하지 않고도 키가 아닌 열의 컨텐츠를 리턴 할 수 있습니다. 따라서 키가 아닌 열을 추가하면 인덱스 전용 검색을 사용하여 쿼리를 사용할 수없는 쿼리에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aa8e8dd6edbe127a1d3d92fe785e89d8eca0bac" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new foreign table automatically inherits all columns. Parent tables can be plain tables or foreign tables. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">선택적 &lt;code&gt;INHERITS&lt;/code&gt; 절은 새 외부 테이블이 모든 열을 자동으로 상속하는 테이블 목록을 지정합니다. 부모 테이블은 일반 테이블 또는 외부 테이블 일 수 있습니다. 자세한 내용은 비슷한 형식의 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d357ec942143a3e86ce2ca9c6595bccf9733322e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.</source>
          <target state="translated">선택적 &lt;code&gt;INHERITS&lt;/code&gt; 절은 새 테이블이 모든 열을 자동으로 상속하는 테이블 목록을 지정합니다. 부모 테이블은 일반 테이블 또는 외부 테이블 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="935c04d83e4414228c1da5a13e9997ce0d9aed17" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LANGUAGE&lt;/code&gt; clause can be written either before or after the code block.</source>
          <target state="translated">선택적 &lt;code&gt;LANGUAGE&lt;/code&gt; 절은 코드 블록 앞이나 뒤에 쓰여질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b362bf605fea7a639d64d32d41debf1c9b97b1a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ON CONFLICT&lt;/code&gt; clause specifies an alternative action to raising a unique violation or exclusion constraint violation error. For each individual row proposed for insertion, either the insertion proceeds, or, if an &lt;em&gt;arbiter&lt;/em&gt; constraint or index specified by &lt;em&gt;&lt;code&gt;conflict_target&lt;/code&gt;&lt;/em&gt; is violated, the alternative &lt;em&gt;&lt;code&gt;conflict_action&lt;/code&gt;&lt;/em&gt; is taken. &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; simply avoids inserting a row as its alternative action. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; updates the existing row that conflicts with the row proposed for insertion as its alternative action.</source>
          <target state="translated">선택적 &lt;code&gt;ON CONFLICT&lt;/code&gt; 절은 고유 위반 또는 제외 제한 조건 위반 오류를 발생시키는 대체 조치를 지정합니다. 삽입을 제안 된 각 개별 행에 대해 삽입이 진행되거나 &lt;em&gt; &lt;code&gt;conflict_target&lt;/code&gt; &lt;/em&gt; 에 의해 지정된 &lt;em&gt;중재자&lt;/em&gt; 제한 조건 또는 색인 이 위반되는 경우 대체 &lt;em&gt; &lt;code&gt;conflict_action&lt;/code&gt; &lt;/em&gt; 이 수행됩니다. &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 행을 대체 조치로 삽입하지 않습니다. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 는 대체 조치로 삽입하도록 제안 된 행과 충돌하는 기존 행을 업데이트합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5dd05dee5b8b79438a7ed8440a1b3f1d3a71ea3" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ORDER BY&lt;/code&gt; clause has this general form:</source>
          <target state="translated">선택적 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 다음과 같은 일반적인 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7116353ef7e307ca01f79a625c49cbb834ed45dc" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;PARTITION BY&lt;/code&gt; clause specifies a strategy of partitioning the table. The table thus created is called a &lt;em&gt;partitioned&lt;/em&gt; table. The parenthesized list of columns or expressions forms the &lt;em&gt;partition key&lt;/em&gt; for the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be altered when building PostgreSQL), but for list partitioning, the partition key must consist of a single column or expression.</source>
          <target state="translated">선택적 &lt;code&gt;PARTITION BY&lt;/code&gt; 절은 테이블 파티셔닝 전략을 지정합니다. 이렇게 생성 된 테이블을 &lt;em&gt;분할 된&lt;/em&gt; 테이블 이라고 합니다. 괄호 안에있는 열 또는 표현식 목록은 테이블 의 &lt;em&gt;파티션 키&lt;/em&gt; 를 형성 합니다. 범위 또는 해시 파티셔닝을 사용하는 경우 파티션 키는 여러 열 또는 표현식을 포함 할 수 있지만 (최대 32 개이지만 PostgreSQL을 빌드 할 때이 제한을 변경할 수 있음), 파티셔닝 키의 경우 파티션 키가 단일 열 또는 표현식으로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6243054cea2c976be92eb3f4ea9df686539e824" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RECURSIVE&lt;/code&gt; modifier changes &lt;code&gt;WITH&lt;/code&gt; from a mere syntactic convenience into a feature that accomplishes things not otherwise possible in standard SQL. Using &lt;code&gt;RECURSIVE&lt;/code&gt;, a &lt;code&gt;WITH&lt;/code&gt; query can refer to its own output. A very simple example is this query to sum the integers from 1 through 100:</source>
          <target state="translated">옵션 &lt;code&gt;RECURSIVE&lt;/code&gt; 의 수정은 변화 &lt;code&gt;WITH&lt;/code&gt; 표준 SQL에서, 그렇지 않으면 불가능한 일을 수행 기능에 단순한 구문에서 편리. 사용 &lt;code&gt;RECURSIVE&lt;/code&gt; 을 하는 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 자신의 출력을 참조 할 수 있습니다. 매우 간단한 예는 1에서 100 사이의 정수를 합하는이 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="fadff698169cd4951ccc6a878ef428bb081f97f0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;REPEATABLE&lt;/code&gt; clause specifies a &lt;code&gt;seed&lt;/code&gt; number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and &lt;code&gt;argument&lt;/code&gt; values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. If &lt;code&gt;REPEATABLE&lt;/code&gt; is not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept &lt;code&gt;REPEATABLE&lt;/code&gt;, and will always produce new samples on each use.</source>
          <target state="translated">선택적 &lt;code&gt;REPEATABLE&lt;/code&gt; 절 은 샘플링 방법에서 난수를 생성하는 데 사용할 &lt;code&gt;seed&lt;/code&gt; 번호 또는 표현식을 지정합니다 . 시드 값은 null이 아닌 부동 소수점 값일 수 있습니다. 테이블이 변경되지 않은 경우 동일한 시드 및 &lt;code&gt;argument&lt;/code&gt; 값 을 지정하는 두 개의 쿼리는 동일한 테이블 샘플을 선택합니다. 그러나 다른 시드 값은 일반적으로 다른 샘플을 생성합니다. 경우 &lt;code&gt;REPEATABLE&lt;/code&gt; 는 다음 부여되어 있지 않은 새로운 무작위 표본은 시스템에서 생성 된 종자에 따라, 각 쿼리 선택됩니다. 일부 애드온 샘플링 방법은 &lt;code&gt;REPEATABLE&lt;/code&gt; 을 허용하지 않으며 항상 사용할 때마다 새로운 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8777d7f8d07792d4f3e98ee0b8208d63db9f0b46" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;DELETE&lt;/code&gt; to compute and return value(s) based on each row actually deleted. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;USING&lt;/code&gt;, can be computed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;RETURNING&lt;/code&gt; 절은 &lt;code&gt;DELETE&lt;/code&gt; 가 실제로 삭제 된 각 행을 기반으로 값을 계산하고 리턴하게합니다. &lt;code&gt;USING&lt;/code&gt; 에서 언급 한 테이블의 열 및 / 또는 다른 테이블의 열을 사용하는 모든 표현식을 계산할 수 있습니다. &lt;code&gt;RETURNING&lt;/code&gt; 목록 의 구문 은 &lt;code&gt;SELECT&lt;/code&gt; 출력 목록의 구문과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3578c21272426a6d018e36dbe114df05af571e18" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;INSERT&lt;/code&gt; to compute and return value(s) based on each row actually inserted (or updated, if an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause was used). This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number. However, any expression using the table's columns is allowed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;. Only rows that were successfully inserted or updated will be returned. For example, if a row was locked but not updated because an &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; clause &lt;code&gt;condition&lt;/code&gt; was not satisfied, the row will not be returned.</source>
          <target state="translated">선택적 &lt;code&gt;RETURNING&lt;/code&gt; 절은 &lt;code&gt;INSERT&lt;/code&gt; 가 실제로 삽입 된 (또는 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절이 사용 된 경우 업데이트 된) 각 행을 기반으로 값을 계산하고 리턴하게합니다 . 이것은 일련 번호와 같이 기본적으로 제공된 값을 얻는 데 주로 유용합니다. 그러나 테이블의 열을 사용하는 모든 표현식이 허용됩니다. &lt;code&gt;RETURNING&lt;/code&gt; 목록 의 구문 은 &lt;code&gt;SELECT&lt;/code&gt; 출력 목록의 구문과 동일합니다 . 성공적으로 삽입 또는 업데이트 된 행만 반환됩니다. 예를 들어, &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; 절 &lt;code&gt;condition&lt;/code&gt; 이 충족 되지 않아 행이 잠겨 있지만 업데이트 되지 않은 경우 행이 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26fec39eb66cc8ba300ea17034aad6e1ab719ea0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;UPDATE&lt;/code&gt; to compute and return value(s) based on each row actually updated. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;FROM&lt;/code&gt;, can be computed. The new (post-update) values of the table's columns are used. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;RETURNING&lt;/code&gt; 절은 &lt;code&gt;UPDATE&lt;/code&gt; 가 실제로 업데이트 된 각 행을 기반으로 값을 계산하고 리턴하게합니다. 테이블의 열 및 / 또는 &lt;code&gt;FROM&lt;/code&gt; 에 언급 된 다른 테이블의 열을 사용하는 모든 표현식을 계산할 수 있습니다. 테이블 열의 새로운 (업데이트 후) 값이 사용됩니다. &lt;code&gt;RETURNING&lt;/code&gt; 목록 의 구문 은 &lt;code&gt;SELECT&lt;/code&gt; 출력 목록의 구문과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7038a19db2dc16317b16f8d00a20421d7087db41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt; clause has the general form</source>
          <target state="translated">선택적 &lt;code&gt;WHERE&lt;/code&gt; 절은 일반적인 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7792c91023d2f01afcab3c87bb09f61e0ba95957" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses in the table expression specify a pipeline of successive transformations performed on the table derived in the &lt;code&gt;FROM&lt;/code&gt; clause. All these transformations produce a virtual table that provides the rows that are passed to the select list to compute the output rows of the query.</source>
          <target state="translated">테이블 표현식 의 선택적 &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절은 &lt;code&gt;FROM&lt;/code&gt; 절 에서 파생 된 테이블에서 수행되는 연속 변환의 파이프 라인을 지정합니다 . 이러한 모든 변환은 쿼리의 출력 행을 계산하기 위해 선택 목록으로 전달되는 행을 제공하는 가상 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8a3824e49e923ca91de9f24e0e18785c61620d57" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WINDOW&lt;/code&gt; clause has the general form</source>
          <target state="translated">선택적 &lt;code&gt;WINDOW&lt;/code&gt; 절은 일반적인 형식입니다.</target>
        </trans-unit>
        <trans-unit id="0734bf4cc1224dac3864d0137b3f27ef1692d40c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITH&lt;/code&gt; clause specifies &lt;em&gt;storage parameters&lt;/em&gt; for the index. Each index method has its own set of allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods all accept this parameter:</source>
          <target state="translated">선택적인 &lt;code&gt;WITH&lt;/code&gt; 절 은 인덱스의 &lt;em&gt;스토리지 매개 변수&lt;/em&gt; 를 지정합니다 . 각 인덱스 메소드에는 고유 한 허용 스토리지 매개 변수 세트가 있습니다. B- 트리, 해시, GiST 및 SP-GiST 색인 메소드는 모두이 매개 변수를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="a2ab89e063673dbb227b7d91abdf56f04b8f9bc9" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause gives a comma-separated list of namespace definitions, where each &lt;code&gt;namespace_uri&lt;/code&gt; is a &lt;code&gt;text&lt;/code&gt; expression and each &lt;code&gt;namespace_name&lt;/code&gt; is a simple identifier. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="translated">선택적 &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 절은 쉼표로 구분 된 네임 스페이스 정의 목록을 제공합니다. 여기서 각 &lt;code&gt;namespace_uri&lt;/code&gt; 는 &lt;code&gt;text&lt;/code&gt; 표현식이고 각 &lt;code&gt;namespace_name&lt;/code&gt; 은 간단한 식별자입니다. 문서에 사용되는 XML 네임 스페이스와 해당 별칭을 지정합니다. 기본 네임 스페이스 사양은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="058389bedd0ce52c16be7bfd9114242b91506b69" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause is a comma-separated list of namespaces. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="translated">선택적 &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 절은 쉼표로 구분 된 네임 스페이스 목록입니다. 문서에 사용 된 XML 네임 스페이스와 해당 별명을 지정합니다. 기본 네임 스페이스 사양은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57ded7b498b198ec6bfc70d87458a99fd28a21d6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;analyze_function&lt;/code&gt; performs type-specific statistics collection for columns of the data type. By default, &lt;code&gt;ANALYZE&lt;/code&gt; will attempt to gather statistics using the type's &amp;ldquo;equals&amp;rdquo; and &amp;ldquo;less-than&amp;rdquo; operators, if there is a default b-tree operator class for the type. For non-scalar types this behavior is likely to be unsuitable, so it can be overridden by specifying a custom analysis function. The analysis function must be declared to take a single argument of type &lt;code&gt;internal&lt;/code&gt;, and return a &lt;code&gt;boolean&lt;/code&gt; result. The detailed API for analysis functions appears in &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;analyze_function&lt;/code&gt; 은 데이터 유형의 열에 대해 유형별 통계 콜렉션을 수행합니다. 기본적으로 &lt;code&gt;ANALYZE&lt;/code&gt; 는 유형에 대한 기본 b- 트리 연산자 클래스가있는 경우 유형의 &quot;같음&quot;및 &quot;보다 작음&quot;연산자를 사용하여 통계 수집을 시도합니다. 스칼라가 아닌 유형의 경우이 동작이 적합하지 않을 수 있으므로 사용자 정의 분석 함수를 지정하여이를 무시할 수 있습니다. &lt;code&gt;internal&lt;/code&gt; 유형의 단일 인수를 사용 하고 &lt;code&gt;boolean&lt;/code&gt; 결과를 반환하도록 분석 함수를 선언해야합니다 . 분석 기능에 대한 자세한 API는 &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt; 에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="7747a49a90a7a4edd6982d5e13265f6731caae73" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;canonical&lt;/code&gt; function must take one argument of the range type being defined, and return a value of the same type. This is used to convert range values to a canonical form, when applicable. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information. Creating a &lt;code&gt;canonical&lt;/code&gt; function is a bit tricky, since it must be defined before the range type can be declared. To do this, you must first create a shell type, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the function can be declared using the shell type as argument and result, and finally the range type can be declared using the same name. This automatically replaces the shell type entry with a valid range type.</source>
          <target state="translated">선택적 &lt;code&gt;canonical&lt;/code&gt; 함수는 정의되는 범위 유형의 인수 하나를 가져 와서 동일한 유형의 값을 리턴해야합니다. 적용 가능한 경우 범위 값을 표준 형식으로 변환하는 데 사용됩니다. 자세한 정보는 &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;8.17.8 절&lt;/a&gt; 을 참조하십시오. &lt;code&gt;canonical&lt;/code&gt; 함수 작성 은 범위 유형을 선언하기 전에 정의해야하므로 약간 까다 롭습니다. 이렇게하려면 먼저 이름과 소유자 이외의 속성이없는 자리 표시 자 유형 인 셸 유형을 만들어야합니다. &lt;code&gt;CREATE TYPE name&lt;/code&gt; 명령을 실행하면됩니다.추가 매개 변수가 없습니다. 그런 다음 셸 유형을 인수 및 결과로 사용하여 함수를 선언 할 수 있으며, 마지막으로 동일한 이름을 사용하여 범위 유형을 선언 할 수 있습니다. 그러면 쉘 유형 항목이 유효한 범위 유형으로 자동 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e405c33bd06f9fd7d49a367fa9d3ceab7c5a9a0c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flag&lt;/code&gt; string may include one or more of the characters &lt;code&gt;i&lt;/code&gt; for case-insensitive match, &lt;code&gt;m&lt;/code&gt; to allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines, &lt;code&gt;s&lt;/code&gt; to allow &lt;code&gt;.&lt;/code&gt; to match a newline, and &lt;code&gt;q&lt;/code&gt; to quote the whole pattern (reducing the behavior to a simple substring match).</source>
          <target state="translated">옵션 &lt;code&gt;flag&lt;/code&gt; 문자열은 문자 중 하나 이상을 포함 할 수있다 &lt;code&gt;i&lt;/code&gt; 대소 문자를 구별 일치를 위해 &lt;code&gt;m&lt;/code&gt; 있도록 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 줄 바꿈에 일치하도록 &lt;code&gt;s&lt;/code&gt; 있도록 &lt;code&gt;.&lt;/code&gt; 줄 바꿈과 일치시키고 &lt;code&gt;q&lt;/code&gt; 를 사용하여 전체 패턴을 인용하십시오 (행동을 단순한 하위 문자열 일치로 줄임).</target>
        </trans-unit>
        <trans-unit id="6929038d2d7ee1cd89d49d3d8b27997b9126c9d2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">선택적 &lt;code&gt;frame_clause&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a0ad788554501dd9d4e6143a34e5057b31ec466" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; defines the &lt;em&gt;window frame&lt;/em&gt; for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the &lt;em&gt;current row&lt;/em&gt;). The &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">선택적 &lt;code&gt;frame_clause&lt;/code&gt; 는 &lt;em&gt;프레임&lt;/em&gt; 에 의존하는 윈도우 함수에 대한 &lt;em&gt;윈도우 프레임&lt;/em&gt; 을 정의합니다 (모두는 아님). 창 프레임은 쿼리의 각 행 ( &lt;em&gt;현재 행&lt;/em&gt; 이라고 함)에 대한 관련 행 세트입니다 . &lt;code&gt;frame_clause&lt;/code&gt; 이 중 하나가 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="78c603df9d8f5aec2127eee4c089f14a6a63935b" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;like_option&lt;/code&gt; clauses specify which additional properties of the original table to copy. Specifying &lt;code&gt;INCLUDING&lt;/code&gt; copies the property, specifying &lt;code&gt;EXCLUDING&lt;/code&gt; omits the property. &lt;code&gt;EXCLUDING&lt;/code&gt; is the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are:</source>
          <target state="translated">선택적 &lt;code&gt;like_option&lt;/code&gt; 절은 복사 할 원본 테이블의 추가 특성을 지정합니다. &lt;code&gt;INCLUDING&lt;/code&gt; 을 지정 하면 속성이 복사되고 &lt;code&gt;EXCLUDING&lt;/code&gt; 을 지정 하면 속성이 생략됩니다. &lt;code&gt;EXCLUDING&lt;/code&gt; 이 기본값입니다. 동일한 종류의 객체에 대해 여러 사양을 지정한 경우 마지막 사양이 사용됩니다. 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b1514641d42b559d683d1926252a8c2e4d381f2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;receive_function&lt;/code&gt; converts the type's external binary representation to the internal representation. If this function is not supplied, the type cannot participate in binary input. The binary representation should be chosen to be cheap to convert to internal form, while being reasonably portable. (For example, the standard integer data types use network byte order as the external binary representation, while the internal representation is in the machine's native byte order.) The receive function should perform adequate checking to ensure that the value is valid. The receive function can be declared as taking one argument of type &lt;code&gt;internal&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is a pointer to a &lt;code&gt;StringInfo&lt;/code&gt; buffer holding the received byte string; the optional arguments are the same as for the text input function. The receive function must return a value of the data type itself. Usually, a receive function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain receive functions, which might need to reject NULL inputs.) Similarly, the optional &lt;code&gt;send_function&lt;/code&gt; converts from the internal representation to the external binary representation. If this function is not supplied, the type cannot participate in binary output. The send function must be declared as taking one argument of the new data type. The send function must return type &lt;code&gt;bytea&lt;/code&gt;. Send functions are not invoked for NULL values.</source>
          <target state="translated">선택적인 &lt;code&gt;receive_function&lt;/code&gt; 은 유형의 외부 이진 표현을 내부 표현으로 변환합니다. 이 기능을 제공하지 않으면 형식이 이진 입력에 참여할 수 없습니다. 이진 표현은 합리적인 형태로 이식 가능하지만 내부 형식으로 변환하기에 저렴하도록 선택해야합니다. 예를 들어 표준 정수 데이터 형식은 네트워크 바이트 순서를 외부 이진 표현으로 사용하지만 내부 표현은 컴퓨터의 기본 바이트 순서로 사용됩니다. 수신 함수는 값이 유효한지 확인하기 위해 적절한 검사를 수행해야합니다. receive 함수는 &lt;code&gt;internal&lt;/code&gt; 유형의 인수 하나를 사용 하거나 &lt;code&gt;internal&lt;/code&gt; , &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; 유형의 인수를 세 개로 선언 할 수 있습니다.. 첫 번째 인수는 수신 된 바이트 문자열을 보유 하는 &lt;code&gt;StringInfo&lt;/code&gt; 버퍼에 대한 포인터입니다 . 선택적 인수는 텍스트 입력 기능과 동일합니다. receive 함수는 데이터 유형 자체의 값을 리턴해야합니다. 일반적으로 수신 함수는 STRICT로 선언해야합니다. 그렇지 않은 경우 NULL 입력 값을 읽을 때 NULL 첫 번째 매개 변수와 함께 호출됩니다. 이 경우 오류가 발생하지 않는 한 함수는 여전히 NULL을 반환해야합니다. (이 경우는 주로 도메인 수신 기능을 지원하기위한 것으로 NULL 입력을 거부해야 할 수도 있습니다.) 마찬가지로 선택적 &lt;code&gt;send_function&lt;/code&gt; 내부 표현에서 외부 이진 표현으로 변환합니다. 이 기능을 제공하지 않으면 유형이 이진 출력에 참여할 수 없습니다. send 함수는 새로운 데이터 타입의 인수 하나를 취하는 것으로 선언되어야합니다. send 함수는 &lt;code&gt;bytea&lt;/code&gt; 유형을 리턴해야합니다 . 널 (NULL) 값에 대해서는 송신 함수가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d7acb9837f1f10a2e0445707407528f679ac86a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;sequence_options&lt;/code&gt; clause can be used to override the options of the sequence. See &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; for details.</source>
          <target state="translated">선택적 &lt;code&gt;sequence_options&lt;/code&gt; 절을 사용하여 시퀀스 옵션을 대체 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7bcdb21e727a9ca38cf42b2a6d25b5e2872506f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;subtype_diff&lt;/code&gt; function must take two values of the &lt;code&gt;subtype&lt;/code&gt; type as argument, and return a &lt;code&gt;double precision&lt;/code&gt; value representing the difference between the two given values. While this is optional, providing it allows much greater efficiency of GiST indexes on columns of the range type. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information.</source>
          <target state="translated">선택적인 &lt;code&gt;subtype_diff&lt;/code&gt; 함수는 &lt;code&gt;subtype&lt;/code&gt; 타입 유형 의 두 값을 인수로 가져 와서 주어진 두 값의 차이를 나타내는 &lt;code&gt;double precision&lt;/code&gt; 값을 리턴해야 합니다. 이 옵션은 선택 사항이지만 범위 유형의 열에서 GiST 인덱스의 효율성을 크게 향상시킵니다. 자세한 정보는 &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;8.17.8 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1325ceadd1cae01690d39e7c916f8ac8cf741797" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;type_modifier_input_function&lt;/code&gt; and &lt;code&gt;type_modifier_output_function&lt;/code&gt; are needed if the type supports modifiers, that is optional constraints attached to a type declaration, such as &lt;code&gt;char(5)&lt;/code&gt; or &lt;code&gt;numeric(30,2)&lt;/code&gt;. PostgreSQL allows user-defined types to take one or more simple constants or identifiers as modifiers. However, this information must be capable of being packed into a single non-negative integer value for storage in the system catalogs. The &lt;code&gt;type_modifier_input_function&lt;/code&gt; is passed the declared modifier(s) in the form of a &lt;code&gt;cstring&lt;/code&gt; array. It must check the values for validity (throwing an error if they are wrong), and if they are correct, return a single non-negative &lt;code&gt;integer&lt;/code&gt; value that will be stored as the column &amp;ldquo;typmod&amp;rdquo;. Type modifiers will be rejected if the type does not have a &lt;code&gt;type_modifier_input_function&lt;/code&gt;. The &lt;code&gt;type_modifier_output_function&lt;/code&gt; converts the internal integer typmod value back to the correct form for user display. It must return a &lt;code&gt;cstring&lt;/code&gt; value that is the exact string to append to the type name; for example &lt;code&gt;numeric&lt;/code&gt;'s function might return &lt;code&gt;(30,2)&lt;/code&gt;. It is allowed to omit the &lt;code&gt;type_modifier_output_function&lt;/code&gt;, in which case the default display format is just the stored typmod integer value enclosed in parentheses.</source>
          <target state="translated">유형이 수정자를 지원하는 경우 선택적 &lt;code&gt;type_modifier_input_function&lt;/code&gt; 및 &lt;code&gt;type_modifier_output_function&lt;/code&gt; 이 필요합니다. 즉 &lt;code&gt;char(5)&lt;/code&gt; 또는 &lt;code&gt;numeric(30,2)&lt;/code&gt; 와 같은 유형 선언에 첨부 된 선택적 제한 조건 입니다. PostgreSQL은 사용자 정의 유형이 하나 이상의 간단한 상수 또는 식별자를 수정 자로 사용할 수 있습니다. 그러나이 정보는 시스템 카탈로그에 저장하기 위해 음이 아닌 단일 정수 값으로 압축 될 수 있어야합니다. &lt;code&gt;type_modifier_input_function&lt;/code&gt; 에는은 (가)의 형태로 발 개질제 선언 전달 &lt;code&gt;cstring&lt;/code&gt; 배열. 유효성에 대한 값을 확인하고 (잘못된 경우 오류가 발생 함) 올바른 경우 음이 아닌 단일 값을 리턴해야합니다. &lt;code&gt;integer&lt;/code&gt; 열 &quot;typmod&quot;로 저장 될 정수 값. 유형에 &lt;code&gt;type_modifier_input_function&lt;/code&gt; 이 없으면 유형 수정자가 거부됩니다 . &lt;code&gt;type_modifier_output_function&lt;/code&gt; 사용자 디스플레이의 올바른 폼 내부 typmod를 정수 값 다시 변환한다. 형식 이름에 추가 할 정확한 문자열 인 &lt;code&gt;cstring&lt;/code&gt; 값을 반환해야합니다 . 예를 들어 &lt;code&gt;numeric&lt;/code&gt; 의 함수는 &lt;code&gt;(30,2)&lt;/code&gt; 를 리턴 할 수 있습니다 . &lt;code&gt;type_modifier_output_function&lt;/code&gt; 을 생략 할 수 있습니다 .이 경우 기본 표시 형식은 괄호로 묶인 저장된 typmod 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="af1ecc2cb7dfd4fb66fffd97bf916a5a132fb429" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; changes the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;.</source>
          <target state="translated">선택적 절인 &lt;code&gt;AS data_type&lt;/code&gt; 은 시퀀스의 데이터 유형을 변경합니다. 유효한 유형은 &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; 및 &lt;code&gt;bigint&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6491ae8d81a26646c521265ecd71bb3dba07346" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; specifies the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;. &lt;code&gt;bigint&lt;/code&gt; is the default. The data type determines the default minimum and maximum values of the sequence.</source>
          <target state="translated">선택적 절 &lt;code&gt;AS data_type&lt;/code&gt; 은 시퀀스의 데이터 유형을 지정합니다. 유효한 유형은 &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; 및 &lt;code&gt;bigint&lt;/code&gt; 입니다. &lt;code&gt;bigint&lt;/code&gt; 가 기본값입니다. 데이터 유형에 따라 시퀀스의 기본 최소값 및 최대 값이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="4ef52006c6e494bfa443e060a826bdc36541e6b7" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;CACHE cache&lt;/code&gt; specifies how many sequence numbers are to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache), and this is also the default.</source>
          <target state="translated">선택적 절인 &lt;code&gt;CACHE cache&lt;/code&gt; 는 더 빠른 액세스를 위해 사전 할당되고 메모리에 저장되는 시퀀스 번호 수를 지정합니다. 최소값은 1 (한 번에 하나의 값만 생성 될 수 있습니다 (즉, 캐시 없음))이며 기본값이기도합니다.</target>
        </trans-unit>
        <trans-unit id="e1922af2324c94734b798d29c69dd1e6a8cd6788" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; specifies which value is added to the current sequence value to create a new value. A positive value will make an ascending sequence, a negative one a descending sequence. The default value is 1.</source>
          <target state="translated">선택적 절 &lt;code&gt;INCREMENT BY increment&lt;/code&gt; 는 현재 값에 추가 될 값을 지정하여 새 값을 만듭니다. 양수 값은 오름차순, 음수는 내림차순을 만듭니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="129d57b7ace9b8671169f53fc01dbaf732d5dd2a" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, the defaults of the maximum value of the data type and -1 for ascending and descending sequences, respectively, will be used. If neither option is specified, the current maximum value will be maintained.</source>
          <target state="translated">선택적 절 &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; 는 시퀀스의 최대 값을 결정합니다. 경우 &lt;code&gt;NO MAXVALUE&lt;/code&gt; 가 지정되면, 데이터 유형의 최대 값의 기본값과 -1 오름차순 순서 내림차순 각각 사용될 것이다. 옵션을 지정하지 않으면 현재 최대 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="636d2219bc9ef5ee8fa4e79b4cd4c563ed5f1551" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If this clause is not supplied or &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, then default values will be used. The default for an ascending sequence is the maximum value of the data type. The default for a descending sequence is -1.</source>
          <target state="translated">선택적 절 &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; 는 시퀀스의 최대 값을 결정합니다. 이 절이 제공되지 않거나 &lt;code&gt;NO MAXVALUE&lt;/code&gt; 가 지정되면 기본값이 사용됩니다. 오름차순의 기본값은 데이터 유형의 최대 값입니다. 내림차순의 기본값은 -1입니다.</target>
        </trans-unit>
        <trans-unit id="c5eb2614e0e305c391d790e5028cc9a0dac1d3fe" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, the defaults of 1 and the minimum value of the data type for ascending and descending sequences, respectively, will be used. If neither option is specified, the current minimum value will be maintained.</source>
          <target state="translated">선택적 절 &lt;code&gt;MINVALUE minvalue&lt;/code&gt; 는 시퀀스가 ​​생성 할 수있는 최소값을 결정합니다. 경우 &lt;code&gt;NO MINVALUE&lt;/code&gt; 가 지정되는 하나의 디폴트 오름차순 및 내림차순 시퀀스에 대한 데이터 유형의 최소 값이 각각 사용될 것이다. 옵션을 지정하지 않으면 현재 최소값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e9e2bcb7eb75a3afb340c5c1fc227a8406ff8640" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If this clause is not supplied or &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, then defaults will be used. The default for an ascending sequence is 1. The default for a descending sequence is the minimum value of the data type.</source>
          <target state="translated">선택적 절 &lt;code&gt;MINVALUE minvalue&lt;/code&gt; 는 시퀀스가 ​​생성 할 수있는 최소값을 결정합니다. 이 절이 제공되지 않거나 &lt;code&gt;NO MINVALUE&lt;/code&gt; 가 지정되면 기본값이 사용됩니다. 오름차순의 기본값은 1입니다. 내림차순의 기본값은 데이터 유형의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="fcd2de5b18440bca469ca6adbeb6f5f5db2e6405" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; changes the current value of the sequence. This is similar to calling the &lt;code&gt;setval&lt;/code&gt; function with &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;: the specified value will be returned by the &lt;em&gt;next&lt;/em&gt; call of &lt;code&gt;nextval&lt;/code&gt;. Writing &lt;code&gt;RESTART&lt;/code&gt; with no &lt;code&gt;restart&lt;/code&gt; value is equivalent to supplying the start value that was recorded by &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; or last set by &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt;.</source>
          <target state="translated">선택적 절인 &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; 는 시퀀스의 현재 값을 변경합니다. 이것은 &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 로 &lt;code&gt;setval&lt;/code&gt; 함수 를 호출하는 것과 비슷합니다 . 지정된 값은 &lt;code&gt;nextval&lt;/code&gt; 의 &lt;em&gt;다음&lt;/em&gt; 호출에 의해 반환됩니다 . &lt;code&gt;restart&lt;/code&gt; 값 없이 &lt;code&gt;RESTART&lt;/code&gt; 를 작성 하는 것은 &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; 에 의해 기록 되었거나 &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt; 에 의해 마지막으로 설정된 시작 값을 제공하는 것과 같습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fb28acc2fa41aa8ead28a09cd415f780a8cadf0" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; allows the sequence to begin anywhere. The default starting value is &lt;code&gt;minvalue&lt;/code&gt; for ascending sequences and &lt;code&gt;maxvalue&lt;/code&gt; for descending ones.</source>
          <target state="translated">선택 품목 인 &lt;code&gt;START WITH start&lt;/code&gt; 를 사용하면 시퀀스를 어디에서나 시작할 수 있습니다. 기본 시작 값은 &lt;code&gt;minvalue&lt;/code&gt; 시퀀스 및 상승에 대한 &lt;code&gt;maxvalue&lt;/code&gt; 사람을 내림차순.</target>
        </trans-unit>
        <trans-unit id="eb785729e5f5d903e46bb6918c0a11aa04baffd1" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; changes the recorded start value of the sequence. This has no effect on the &lt;em&gt;current&lt;/em&gt; sequence value; it simply sets the value that future &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; commands will use.</source>
          <target state="translated">선택 품목 인 &lt;code&gt;START WITH start&lt;/code&gt; 는 시퀀스의 기록 된 시작 값을 변경합니다. &lt;em&gt;현재&lt;/em&gt; 시퀀스 값 에는 영향을 미치지 않습니다 . 차후 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 명령이 사용할 값을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1713a9e1e99f66c0bcfe7df0c08c776ea8b0c311" translate="yes" xml:space="preserve">
          <source>The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways.</source>
          <target state="translated">선택적 constraint 절은 삽입 또는 업데이트 작업이 성공하기 위해 새 행 또는 업데이트 된 행이 충족해야하는 제약 조건 (테스트)을 지정합니다. 제한 조건은 다양한 방법으로 테이블에서 유효한 값 세트를 정의하는 데 도움이되는 SQL 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="e18e0d61bcb7c9d71d791c91de29bb60405c83c7" translate="yes" xml:space="preserve">
          <source>The optional flag &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; indicates that values of this data type are passed by value, rather than by reference. Types passed by value must be fixed-length, and their internal representation cannot be larger than the size of the &lt;code&gt;Datum&lt;/code&gt; type (4 bytes on some machines, 8 bytes on others).</source>
          <target state="translated">선택적 플래그 &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; 는이 데이터 유형의 값이 참조가 아닌 값으로 전달됨을 나타냅니다. 값으로 전달되는 유형은 고정 길이 여야하며 내부 표현은 &lt;code&gt;Datum&lt;/code&gt; 유형 의 크기 (일부 시스템에서는 4 바이트, 다른 시스템에서는 8 바이트) 보다 클 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="96f5588e1c2e2855ea8548eee4502bfe5b21503f" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;code&gt;PATTERN&lt;/code&gt; can be the name of a text search object, optionally schema-qualified. If &lt;code&gt;PATTERN&lt;/code&gt; is omitted then information about all visible objects will be displayed. &lt;code&gt;PATTERN&lt;/code&gt; can be a regular expression and can provide &lt;em&gt;separate&lt;/em&gt; patterns for the schema and object names. The following examples illustrate this:</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;PATTERN&lt;/code&gt; 은 텍스트 검색 오브젝트의 이름이 될 수 있으며 선택적으로 스키마 규정이 될 수 있습니다. 경우 &lt;code&gt;PATTERN&lt;/code&gt; 보이는 모든 개체에 대한 다음 정보를 생략 표시됩니다. &lt;code&gt;PATTERN&lt;/code&gt; 은 정규식 일 수 있으며 스키마 및 객체 이름에 &lt;em&gt;별도의&lt;/em&gt; 패턴을 제공 할 수 있습니다 . 다음 예제는이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="de01abc64ad555117df4d2eb14da2dc8395e780a" translate="yes" xml:space="preserve">
          <source>The optional third argument of the function is an array of namespace mappings. This array should be a two-dimensional &lt;code&gt;text&lt;/code&gt; array with the length of the second axis being equal to 2 (i.e., it should be an array of arrays, each of which consists of exactly 2 elements). The first element of each array entry is the namespace name (alias), the second the namespace URI. It is not required that aliases provided in this array be the same as those being used in the XML document itself (in other words, both in the XML document and in the &lt;code&gt;xpath&lt;/code&gt; function context, aliases are &lt;em&gt;local&lt;/em&gt;).</source>
          <target state="translated">함수의 선택적 세 번째 인수는 네임 스페이스 매핑의 배열입니다. 이 배열은 두 번째 축의 길이가 2 인 2 차원 &lt;code&gt;text&lt;/code&gt; 배열이어야합니다 (즉, 각각 정확히 2 개의 요소로 구성된 배열 배열이어야 함). 각 배열 항목의 첫 번째 요소는 네임 스페이스 이름 (별칭)이고 두 번째는 네임 스페이스 URI입니다. 이 배열에 제공된 별명은 XML 문서 자체에서 사용되는 별명과 동일 할 필요는 없습니다 (즉, XML 문서 및 &lt;code&gt;xpath&lt;/code&gt; 함수 컨텍스트에서 별명은 &lt;em&gt;로컬&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="3d0c8a9e2cea5113636abde4ca21364d5044faa7" translate="yes" xml:space="preserve">
          <source>The optional user-defined method are:</source>
          <target state="translated">선택적 사용자 정의 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7c4a4f219f0aa64d3de98d0b070691b60ede2a2" translate="yes" xml:space="preserve">
          <source>The optional user-defined method is:</source>
          <target state="translated">선택적 사용자 정의 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84a938a7941f222eb580e7e8263bbd7142209820" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--docdir&lt;/code&gt;, &lt;code&gt;--pkgincludedir&lt;/code&gt;, &lt;code&gt;--localedir&lt;/code&gt;, &lt;code&gt;--mandir&lt;/code&gt;, &lt;code&gt;--sharedir&lt;/code&gt;, &lt;code&gt;--sysconfdir&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, &lt;code&gt;--cppflags&lt;/code&gt;, &lt;code&gt;--cflags&lt;/code&gt;, &lt;code&gt;--cflags_sl&lt;/code&gt;, &lt;code&gt;--ldflags&lt;/code&gt;, &lt;code&gt;--ldflags_sl&lt;/code&gt;, and &lt;code&gt;--libs&lt;/code&gt; were added in PostgreSQL 8.1. The option &lt;code&gt;--htmldir&lt;/code&gt; was added in PostgreSQL 8.4. The option &lt;code&gt;--ldflags_ex&lt;/code&gt; was added in PostgreSQL 9.0.</source>
          <target state="translated">옵션은 &lt;code&gt;--docdir&lt;/code&gt; , &lt;code&gt;--pkgincludedir&lt;/code&gt; , &lt;code&gt;--localedir&lt;/code&gt; , &lt;code&gt;--mandir&lt;/code&gt; , &lt;code&gt;--sharedir&lt;/code&gt; , &lt;code&gt;--sysconfdir&lt;/code&gt; , &lt;code&gt;--cc&lt;/code&gt; , &lt;code&gt;--cppflags&lt;/code&gt; , &lt;code&gt;--cflags&lt;/code&gt; , &lt;code&gt;--cflags_sl&lt;/code&gt; , &lt;code&gt;--ldflags&lt;/code&gt; , &lt;code&gt;--ldflags_sl&lt;/code&gt; , 및 &lt;code&gt;--libs&lt;/code&gt; 는 PostgreSQL의 8.1에 추가되었습니다. &lt;code&gt;--htmldir&lt;/code&gt; 옵션 은 PostgreSQL 8.4에서 추가되었습니다. &lt;code&gt;--ldflags_ex&lt;/code&gt; 옵션 이 PostgreSQL 9.0에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="fabb800956bbdc09009ffd9f1b017eb0d6e1abef" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;-O&lt;/code&gt;, and &lt;code&gt;-T&lt;/code&gt; correspond to options of the underlying SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;; see there for more information about them.</source>
          <target state="translated">옵션 &lt;code&gt;-D&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;-O&lt;/code&gt; 및 &lt;code&gt;-T&lt;/code&gt; 기본 SQL 명령의 옵션에 해당 &lt;a href=&quot;sql-createdatabase&quot;&gt;DATABASE를 만들&lt;/a&gt; ; 그들에 대한 자세한 내용은 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b59022ce6b09c2f629170565a77c3c19be85bd9c" translate="yes" xml:space="preserve">
          <source>The options can appear in any order.</source>
          <target state="translated">옵션은 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83b4362928db8b9651a7b14a89534a668d30b89b" translate="yes" xml:space="preserve">
          <source>The options described here are used mainly for debugging purposes, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them in a production database setup. They are listed here only for use by PostgreSQL system developers. Furthermore, these options might change or be removed in a future release without notice.</source>
          <target state="translated">여기에 설명 된 옵션은 주로 디버깅 목적으로 사용되며 경우에 따라 심각하게 손상된 데이터베이스의 복구를 지원하기 위해 사용됩니다. 프로덕션 데이터베이스 설정에서 사용할 이유가 없습니다. PostgreSQL 시스템 개발자 만 사용할 수 있도록 여기에 나열되어 있습니다. 또한 이러한 옵션은 향후 릴리스에서 예고없이 변경되거나 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8dd3a92af0a56bfda8d9752b838ef4b2d6a4df2" translate="yes" xml:space="preserve">
          <source>The order 3501 might be among the billed or unbilled orders.</source>
          <target state="translated">주문 3501은 청구 된 주문 또는 청구되지 않은 주문 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abcd49a17f5a3270a489cdc6cf5f6ae4822bbd01" translate="yes" xml:space="preserve">
          <source>The order doesn't matter. It does not necessarily determine in which order the constraints are checked.</source>
          <target state="translated">순서는 중요하지 않습니다. 구속 조건을 점검 할 순서를 반드시 결정하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4885441a3f0959533bfa66d30ac9b400042a2243" translate="yes" xml:space="preserve">
          <source>The order of evaluation of subexpressions is not defined. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.</source>
          <target state="translated">하위 표현식의 평가 순서는 정의되어 있지 않습니다. 특히, 연산자 또는 함수의 입력이 반드시 왼쪽에서 오른쪽으로 또는 다른 고정 된 순서로 평가 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="89519eed893d527079231a8a6443c77bf1a65103" translate="yes" xml:space="preserve">
          <source>The order of the pairs is not significant (and may not be reproduced on output). Whitespace between pairs or around the &lt;code&gt;=&amp;gt;&lt;/code&gt; sign is ignored. Double-quote keys and values that include whitespace, commas, &lt;code&gt;=&lt;/code&gt;s or &lt;code&gt;&amp;gt;&lt;/code&gt;s. To include a double quote or a backslash in a key or value, escape it with a backslash.</source>
          <target state="translated">쌍의 순서는 중요하지 않으며 출력시 재현되지 않을 수 있습니다. 쌍 사이 또는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호 주위의 공백 은 무시됩니다. 공백, 쉼표, &lt;code&gt;=&lt;/code&gt; s 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; s 를 포함하는 큰 따옴표 키와 값 . 키나 값에 큰 따옴표 나 백 슬래시를 포함 시키려면 백 슬래시로 이스케이프 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="6a0d0d4551f2d45fd2b79524bceb16c2da137ff6" translate="yes" xml:space="preserve">
          <source>The ordering of the values in an enum type is the order in which the values were listed when the type was created. All standard comparison operators and related aggregate functions are supported for enums. For example:</source>
          <target state="translated">열거 형 형식의 값 순서는 형식을 만들 때 값이 나열된 순서입니다. 열거 형에 대해 모든 표준 비교 연산자 및 관련 집계 함수가 지원됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a1c45805d8830616db8f03a352b425367265a0b" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the index column.</source>
          <target state="translated">서수는 인덱스 열의 서수 (왼쪽에서 오른쪽) 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="542906884bd50e7620583567769e2555be971b00" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">서수는 출력 열의 서수 (왼쪽에서 오른쪽) 위치를 나타냅니다. 이 기능을 사용하면 고유 이름이없는 열을 기준으로 순서를 정의 할 수 있습니다. 항상 &lt;code&gt;AS&lt;/code&gt; 절을 사용하여 출력 열에 이름을 지정할 수 있으므로 절대적으로 필요한 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b06b3bbd9847482f4b77272cbdd9dddfd2293b02" translate="yes" xml:space="preserve">
          <source>The ordinary qualified-column-name syntax &lt;code&gt;table_name&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt; can be understood as applying &lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;field selection&lt;/a&gt; to the composite value of the table's current row. (For efficiency reasons, it's not actually implemented that way.)</source>
          <target state="translated">정규화 된 컬럼 이름 구문 &lt;code&gt;table_name&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;column_name&lt;/code&gt; 은 &lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;필드 선택&lt;/a&gt; 을 테이블의 현재 행의 복합 값에 적용하는 것으로 이해 될 수 있습니다 . 효율성상의 이유로 실제로는 그렇게 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="26d29240df565151bc026ac25aff13ab3efc3c48" translate="yes" xml:space="preserve">
          <source>The origin node's LSN up to which data has been replicated.</source>
          <target state="translated">데이터가 복제 된 원본 노드의 LSN</target>
        </trans-unit>
        <trans-unit id="0c0890af1d3eba99328b2705ec2de494e2103157" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="translated">다른 절은 선택적 연산자 최적화 절을 지정합니다. 그 의미는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;37.15 절에&lt;/a&gt; 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9473f0f0dfb8c5d74bfb5c710889c3c431764eb1" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="translated">다른 절은 선택적 연산자 최적화 절을 지정합니다. 그 의미는 &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper-optimization.html&quot;&gt;섹션 37.15에&lt;/a&gt; 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="968a2d78a8c8100f337e33a5ce08a9f2a42bbad9" translate="yes" xml:space="preserve">
          <source>The other locale categories can be changed whenever desired by setting the server configuration parameters that have the same name as the locale categories (see &lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;Section 19.11.2&lt;/a&gt; for details). The values that are chosen by &lt;code&gt;initdb&lt;/code&gt; are actually only written into the configuration file &lt;code&gt;postgresql.conf&lt;/code&gt; to serve as defaults when the server is started. If you remove these assignments from &lt;code&gt;postgresql.conf&lt;/code&gt; then the server will inherit the settings from its execution environment.</source>
          <target state="translated">다른 로캘 범주는 원하는 로캘 범주와 이름이 같은 서버 구성 매개 변수를 설정하여 원할 때마다 변경할 수 있습니다 (자세한 내용 &lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;은 19.11.2 단원&lt;/a&gt; 참조). &lt;code&gt;initdb&lt;/code&gt; 가 선택한 값 은 실제로 서버가 시작될 때 기본값 으로 사용되도록 구성 파일 &lt;code&gt;postgresql.conf&lt;/code&gt; 에만 작성됩니다 . &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 이러한 할당을 제거 하면 서버는 실행 환경에서 설정을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="c995e27c615e98c0f723cb03133efd117f67f54f" translate="yes" xml:space="preserve">
          <source>The other locale settings &lt;a href=&quot;runtime-config-client#GUC-LC-MESSAGES&quot;&gt;lc_messages&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-LC-TIME&quot;&gt;lc_time&lt;/a&gt; are not fixed per database and are not set by this command. If you want to make them the default for a specific database, you can use &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt;.</source>
          <target state="translated">기타 로케일 설정 &lt;a href=&quot;runtime-config-client#GUC-LC-MESSAGES&quot;&gt;lc_messages&lt;/a&gt; , &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; , &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-client#GUC-LC-TIME&quot;&gt;lc_time&lt;/a&gt; 은 데이터베이스별로 고정되지 않으며이 명령으로 설정되지 않습니다. 특정 데이터베이스의 기본값으로 설정하려면 &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f628b39443abf4900d7c741215add2d55c377a2" translate="yes" xml:space="preserve">
          <source>The other required settings have default values that are sufficient for a basic setup.</source>
          <target state="translated">다른 필수 설정에는 기본 설정에 충분한 기본값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="37e3a8e885deb65cc32448cece3ed8b5de192c3e" translate="yes" xml:space="preserve">
          <source>The other three operators are defined in terms of &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; in the obvious way, and must act consistently with them.</source>
          <target state="translated">다른 세 연산자는 명백한 방식으로 &lt;code&gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 로 정의되며 해당 연산자 와 일관되게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="cca1af5395645eeb86ba526f8d241c5ba5b41b07" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;Table F.23&lt;/a&gt;.</source>
          <target state="translated">출력 열은 &lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;표 F.23에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2061781f2ae71dd3ed97908a6bff9dc965e50b4d" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;Table F.22&lt;/a&gt;.</source>
          <target state="translated">출력 열은 &lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;표 F.22에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9d41f9345eb262fbbccef45f4cf925c1a6818ef" translate="yes" xml:space="preserve">
          <source>The output columns are:</source>
          <target state="translated">출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddee20dbbcf56a7d470d5e18264fdb853ffab834" translate="yes" xml:space="preserve">
          <source>The output format of the date/time types can be set to one of the four styles ISO 8601, SQL (Ingres), traditional POSTGRES (Unix date format), or German. The default is the ISO format. (The SQL standard requires the use of the ISO 8601 format. The name of the &amp;ldquo;SQL&amp;rdquo; output format is a historical accident.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;Table 8.14&lt;/a&gt; shows examples of each output style. The output of the &lt;code&gt;date&lt;/code&gt; and &lt;code&gt;time&lt;/code&gt; types is generally only the date or time part in accordance with the given examples. However, the POSTGRES style outputs date-only values in ISO format.</source>
          <target state="translated">날짜 / 시간 유형의 출력 형식은 ISO 8601, SQL (Ingres), 전통적인 POSTGRES (Unix 날짜 형식) 또는 독일어의 네 가지 스타일 중 하나로 설정할 수 있습니다. 기본값은 ISO 형식입니다. SQL 표준은 ISO 8601 형식을 사용해야합니다.&amp;ldquo;SQL&amp;rdquo;출력 형식의 이름은 역사적 사고입니다. &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;표 8.14&lt;/a&gt; 는 각 출력 스타일의 예를 보여줍니다. &lt;code&gt;date&lt;/code&gt; 및 &lt;code&gt;time&lt;/code&gt; 유형 의 출력 은 일반적으로 주어진 예에 따라 날짜 또는 시간 부분 일뿐입니다. 그러나 POSTGRES 스타일은 ISO 형식의 날짜 전용 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ca0d537c6aa930d0ccd3e11ab06cbea4823708c4" translate="yes" xml:space="preserve">
          <source>The output format of the interval type can be set to one of the four styles &lt;code&gt;sql_standard&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;postgres_verbose&lt;/code&gt;, or &lt;code&gt;iso_8601&lt;/code&gt;, using the command &lt;code&gt;SET intervalstyle&lt;/code&gt;. The default is the &lt;code&gt;postgres&lt;/code&gt; format. &lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;Table 8.18&lt;/a&gt; shows examples of each output style.</source>
          <target state="translated">간격 유형의 출력 형식은 &lt;code&gt;SET intervalstyle&lt;/code&gt; 명령을 사용하여 &lt;code&gt;sql_standard&lt;/code&gt; , &lt;code&gt;postgres&lt;/code&gt; , &lt;code&gt;postgres_verbose&lt;/code&gt; 또는 &lt;code&gt;iso_8601&lt;/code&gt; 의 네 가지 스타일 중 하나로 설정할 수 있습니다 . 기본값은 &lt;code&gt;postgres&lt;/code&gt; 형식입니다. &lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;표 8.18&lt;/a&gt; 은 각 출력 스타일의 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="46e4d541f5041111722fb3ba79a2c654be039359" translate="yes" xml:space="preserve">
          <source>The output is a multiline string, with one line per node in the binary tree within the page. Only those nodes that are not zero are printed. The so-called &quot;next&quot; pointer, which points to the next slot to be returned from the page, is also printed.</source>
          <target state="translated">출력은 페이지 내의 이진 트리에서 노드 당 한 줄씩 여러 줄 문자열입니다. 0이 아닌 노드 만 인쇄됩니다. 페이지에서 반환 될 다음 슬롯을 가리키는 소위 &quot;다음&quot;포인터도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ad08831002285835cd9adfadf104f64de7aa0e5d" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;command&lt;/code&gt;, similar to ordinary &amp;ldquo;back-tick&amp;rdquo; substitution.</source>
          <target state="translated">일반적인 &quot;back-tick&quot;대체와 유사한 &lt;code&gt;command&lt;/code&gt; 출력 .</target>
        </trans-unit>
        <trans-unit id="f5a340fab5cd2f5c7335b7c6ceb29826d0789ea6" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;pg_config --configure&lt;/code&gt; contains shell quotation marks so arguments with spaces are represented correctly. Therefore, using &lt;code&gt;eval&lt;/code&gt; is required for proper results.</source>
          <target state="translated">&lt;code&gt;pg_config --configure&lt;/code&gt; 의 출력은 쉘 인용 부호를 포함하므로 공백이있는 인수가 올바르게 표시됩니다. 따라서 적절한 결과를 얻으려면 &lt;code&gt;eval&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a81f92d4917ee9ed4622690e19a83d472fca1d6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;iso_8601&lt;/code&gt; style matches the &amp;ldquo;format with designators&amp;rdquo; described in section 4.4.3.2 of the ISO 8601 standard.</source>
          <target state="translated">&lt;code&gt;iso_8601&lt;/code&gt; 스타일 의 출력은 ISO 8601 표준의 4.4.3.2 섹션에 설명 된 &quot;지정자가있는 형식&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2ff8c3f12c0cc1fd0eb9b2845008220be0844b33" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter was set to &lt;code&gt;ISO&lt;/code&gt;.</source>
          <target state="translated">의 출력 &lt;code&gt;postgres&lt;/code&gt; 스타일은시의 PostgreSQL의 출력은 이전 8.4 출시와 일치 &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle의의&lt;/a&gt; 매개 변수로 설정 &lt;code&gt;ISO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1546f3a4ad8e76189b8c8e44c823160ec87aa0b6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres_verbose&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;code&gt;DateStyle&lt;/code&gt; parameter was set to non-&lt;code&gt;ISO&lt;/code&gt; output.</source>
          <target state="translated">의 출력 &lt;code&gt;postgres_verbose&lt;/code&gt; 스타일은 PostgreSQL을 때의 출력 전에 8.4 릴리스 일치 &lt;code&gt;DateStyle&lt;/code&gt; 의 된 파라미터 이외로 설정된 &lt;code&gt;ISO&lt;/code&gt; 의 출력.</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="7d18635316d58c0f1b2d1367a93ab0ee048d2342" translate="yes" xml:space="preserve">
          <source>The overall file layout is: open square bracket, one or more sets of curly braces each of which represents a catalog row, close square bracket. Write a comma after each closing curly brace.</source>
          <target state="translated">전체 파일 레이아웃은 다음과 같습니다. 열린 대괄호, 각각 하나 이상의 중괄호 세트가 카탈로그 행, 대괄호를 나타냅니다. 닫는 중괄호 뒤에 쉼표를 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="8de7f224fb0466b959b163b48657edcd9f526ad8" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can alter user mappings for that server for any user. Also, a user can alter a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">외부 서버의 소유자는 모든 사용자에 대해 해당 서버의 사용자 맵핑을 변경할 수 있습니다. 또한 서버에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권이 사용자에게 부여 된 경우 사용자는 자신의 사용자 이름에 대한 사용자 맵핑을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70e088bcc4a224d8f310f80a737853c522321de9" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can create user mappings for that server for any user. Also, a user can create a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">외부 서버의 소유자는 모든 사용자에 대해 해당 서버에 대한 사용자 맵핑을 작성할 수 있습니다. 또한 서버에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권이 사용자에게 부여 된 경우 사용자는 자신의 사용자 이름에 대한 사용자 맵핑을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85f81248211a9e60d13a1c97f497ca0b1b6a21d0" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can drop user mappings for that server for any user. Also, a user can drop a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">외부 서버의 소유자는 모든 사용자에 대해 해당 서버의 사용자 맵핑을 삭제할 수 있습니다. 또한 서버에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한이 사용자에게 부여 된 경우 사용자는 자신의 사용자 이름에 대한 사용자 매핑을 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6963c00112713ecda93817baf7fc7475ab9e7155" translate="yes" xml:space="preserve">
          <source>The papal bull of February 1582 decreed that 10 days should be dropped from October 1582 so that 15 October should follow immediately after 4 October. This was observed in Italy, Poland, Portugal, and Spain. Other Catholic countries followed shortly after, but Protestant countries were reluctant to change, and the Greek Orthodox countries didn't change until the start of the 20th century. The reform was observed by Great Britain and its dominions (including what is now the USA) in 1752. Thus 2 September 1752 was followed by 14 September 1752. This is why Unix systems that have the &lt;code&gt;cal&lt;/code&gt; program produce the following:</source>
          <target state="translated">1582 년 2 월의 교황 황소는 10 월 15 일이 10 월 4 일 직후에 이어 지도록 1582 년 10 월부터 10 일을 철회해야한다고 결정했다. 이것은 이탈리아, 폴란드, 포르투갈 및 스페인에서 관찰되었습니다. 다른 가톨릭 국가들도 곧 뒤를 따랐지만 개신교 국가들은 변화하기를 꺼려했으며 그리스 정교회 국가들은 20 세기 초까지 변하지 않았습니다. 개혁은 1752년 9월 2일 14 년 9 월 1752으로 이어졌습니다 따라서 영국과 1752 년 (지금 무엇을 미국 포함)의 영토에 의해 관찰 된이 유닉스 시스템 이유는 &lt;code&gt;cal&lt;/code&gt; 프로그램은 다음 생산 :</target>
        </trans-unit>
        <trans-unit id="265188275c6e5e56d9f827410bd00598d6ffb2ea" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; enables monitoring of the current command being executed by any server process.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; 매개 변수를 사용하면 서버 프로세스에서 실행중인 현재 명령을 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1be1796cec7a4cb2472b6d31337e6a73b1f4697" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; controls whether statistics are collected about table and index accesses.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; 매개 변수 는 테이블 및 인덱스 액세스에 대한 통계 수집 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="c3e68d3468b41bd94198c06d139a59af78cfd7be" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; enables tracking of usage of user-defined functions.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; 매개 변수 를 사용하면 사용자 정의 함수 사용을 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8df18f4279a1a3adf31a5aebfa3bc87053f75fc7" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; enables monitoring of block read and write times.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; 매개 변수를 사용하면 블록 읽기 및 쓰기 시간을 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc99094ae896ae637595cea62c377dc56ce6f9fd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;count&lt;/code&gt; specifies the maximum number of rows to return, while &lt;code&gt;start&lt;/code&gt; specifies the number of rows to skip before starting to return rows. When both are specified, &lt;code&gt;start&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;count&lt;/code&gt; rows to be returned.</source>
          <target state="translated">The parameter &lt;code&gt;count&lt;/code&gt; specifies the maximum number of rows to return, while &lt;code&gt;start&lt;/code&gt; specifies the number of rows to skip before starting to return rows. When both are specified, &lt;code&gt;start&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;count&lt;/code&gt; rows to be returned.</target>
        </trans-unit>
        <trans-unit id="d547546da964747acd19cdd9eb1f2bdf8c4f57e8" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;nulls&lt;/code&gt;&lt;/em&gt; determines whether null values should be included in the output. If true, null values in columns are represented as:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;nulls&lt;/code&gt; &lt;/em&gt; 매개 변수 는 출력에 null 값을 포함할지 여부를 결정합니다. true 인 경우 열의 널값은 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0b194e705f492d2a9e697965a54eb7bc8ec38435" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;targetns&lt;/code&gt;&lt;/em&gt; specifies the desired XML namespace of the result. If no particular namespace is wanted, an empty string should be passed.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;targetns&lt;/code&gt; &lt;/em&gt; 매개 변수 는 결과의 원하는 XML 네임 스페이스를 지정합니다. 특정 네임 스페이스를 원하지 않으면 빈 문자열을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="9da16630f92a321b59e356eb1f16f45959c31e24" translate="yes" xml:space="preserve">
          <source>The parameter data type(s) of the function.</source>
          <target state="translated">함수의 파라미터 데이터 타입.</target>
        </trans-unit>
        <trans-unit id="5d10e331ebaa600753d0a6fe423faa9e38a0555a" translate="yes" xml:space="preserve">
          <source>The parameter is the name of a table. The result is a set of records, with one row for each locked row within the table. The output columns are shown in &lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;Table F.20&lt;/a&gt;.</source>
          <target state="translated">매개 변수는 테이블의 이름입니다. 결과는 테이블 내의 각 잠긴 행에 대해 하나의 행이있는 레코드 세트입니다. 출력 열은 &lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;표 F.20&lt;/a&gt; 에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c2a6968b73a82456119add43eff37f88e4a3336" translate="yes" xml:space="preserve">
          <source>The parameter name</source>
          <target state="translated">매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="10634e221a9f53cda3c36547bc9c020dce985fe4" translate="yes" xml:space="preserve">
          <source>The parameter symbols used to replace constants in representative query texts start from the next number after the highest &lt;code&gt;$&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; parameter in the original query text, or &lt;code&gt;$1&lt;/code&gt; if there was none. It's worth noting that in some cases there may be hidden parameter symbols that affect this numbering. For example, PL/pgSQL uses hidden parameter symbols to insert values of function local variables into queries, so that a PL/pgSQL statement like &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; would have representative text like &lt;code&gt;SELECT i + $2&lt;/code&gt;.</source>
          <target state="translated">대표 조회 텍스트에서 상수를 대체하는 데 사용되는 매개 변수 기호 는 원래 조회 텍스트에서 가장 높은 &lt;code&gt;$&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 매개 변수 다음에 오는 다음 숫자부터 시작합니다 ( 없는 경우 &lt;code&gt;$1&lt;/code&gt; . 경우에 따라이 번호 지정에 영향을주는 숨겨진 매개 변수 기호가있을 수 있습니다. 예를 들어, PL / pgSQL은 숨겨진 매개 변수 기호를 사용하여 함수 로컬 변수의 값을 쿼리에 삽입하므로 &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; 와 같은 PL / pgSQL 문 은 &lt;code&gt;SELECT i + $2&lt;/code&gt; 와 같은 대표적인 텍스트를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="61c677b727193bb37a9911ff1962107228c69d5b" translate="yes" xml:space="preserve">
          <source>The parameter value</source>
          <target state="translated">매개 변수 값</target>
        </trans-unit>
        <trans-unit id="bbcaadaf51c94b64fefad474400e1f3834e2ed35" translate="yes" xml:space="preserve">
          <source>The parameters can appear in any order, not only that illustrated above, and most are optional. You must register two or more functions (using &lt;code&gt;CREATE FUNCTION&lt;/code&gt;) before defining the type. The support functions &lt;code&gt;input_function&lt;/code&gt; and &lt;code&gt;output_function&lt;/code&gt; are required, while the functions &lt;code&gt;receive_function&lt;/code&gt;, &lt;code&gt;send_function&lt;/code&gt;, &lt;code&gt;type_modifier_input_function&lt;/code&gt;, &lt;code&gt;type_modifier_output_function&lt;/code&gt; and &lt;code&gt;analyze_function&lt;/code&gt; are optional. Generally these functions have to be coded in C or another low-level language.</source>
          <target state="translated">매개 변수는 위에 예시 된 것뿐만 아니라 임의의 순서로 나타날 수 있으며 대부분 선택적입니다. 유형을 정의하기 전에 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 을 사용하여 둘 이상의 기능을 등록해야합니다 . 지원 함수 &lt;code&gt;input_function&lt;/code&gt; 및 &lt;code&gt;output_function&lt;/code&gt; 이 필요하지만 &lt;code&gt;receive_function&lt;/code&gt; , &lt;code&gt;send_function&lt;/code&gt; , &lt;code&gt;type_modifier_input_function&lt;/code&gt; , &lt;code&gt;type_modifier_output_function&lt;/code&gt; 및 &lt;code&gt;analyze_function&lt;/code&gt; 함수 는 선택 사항입니다. 일반적으로 이러한 기능은 C 또는 다른 저급 언어로 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="35c28a20bb52660d5ea22014191009de5ae11925" translate="yes" xml:space="preserve">
          <source>The parameters for the &lt;code&gt;MOVE&lt;/code&gt; command are identical to those of the &lt;code&gt;FETCH&lt;/code&gt; command; refer to &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; for details on syntax and usage.</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; 명령 의 매개 변수 는 &lt;code&gt;FETCH&lt;/code&gt; 명령 의 매개 변수와 동일합니다 . 구문과 사용법에 대한 자세한 내용은 &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c486bfa67e493a85ca76bb0a5dfe71e780089bca" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; can be written in any order, not just the order illustrated above.</source>
          <target state="translated">&lt;code&gt;CREATE AGGREGATE&lt;/code&gt; 의 매개 변수는 위에서 설명한 순서뿐만 아니라 임의의 순서로 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f868092f1804769e10c18a42faa0f07b1980df" translate="yes" xml:space="preserve">
          <source>The parameters representing table and field names are copied as-is into the SQL queries that &lt;code&gt;connectby&lt;/code&gt; generates internally. Therefore, include double quotes if the names are mixed-case or contain special characters. You may also need to schema-qualify the table name.</source>
          <target state="translated">테이블 및 필드 이름을 나타내는 매개 변수는 &lt;code&gt;connectby&lt;/code&gt; 가 내부적으로 생성 하는 SQL 쿼리에있는 그대로 복사됩니다 . 따라서 이름이 대소 문자를 혼합하거나 특수 문자를 포함하는 경우 큰 따옴표를 포함하십시오. 테이블 이름을 스키마로 한정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7230bb5c0f71b8c1dd5a14e1c76f97c166b31063" translate="yes" xml:space="preserve">
          <source>The parentheses are required here to show that &lt;code&gt;compositecol&lt;/code&gt; is a column name not a table name, or that &lt;code&gt;mytable&lt;/code&gt; is a table name not a schema name in the second case.</source>
          <target state="translated">여기서 괄호는 &lt;code&gt;compositecol&lt;/code&gt; 이 테이블 이름이 아닌 열 이름이거나 &lt;code&gt;mytable&lt;/code&gt; 이 두 번째 경우 스키마 이름이 아닌 테이블 이름 임을 나타 내기 위해 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="3872d508fa039522a5d3058284138f504197106f" translate="yes" xml:space="preserve">
          <source>The parentheses in the last example are required. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more about arrays.</source>
          <target state="translated">마지막 예에서 괄호가 필요합니다. 배열에 대한 자세한 내용 &lt;a href=&quot;arrays&quot;&gt;은 8.15 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba38ce516ae1d7c833e7896243109df28d306a9d" translate="yes" xml:space="preserve">
          <source>The parentheses or brackets indicate whether the lower and upper bounds are exclusive or inclusive, as described previously. Notice that the final pattern is &lt;code&gt;empty&lt;/code&gt;, which represents an empty range (a range that contains no points).</source>
          <target state="translated">괄호 또는 괄호는 앞에서 설명한대로 하한과 상한이 배타적 또는 포괄적인지 여부를 나타냅니다. 마지막 패턴은 &lt;code&gt;empty&lt;/code&gt; . 이는 비어있는 범위 (점을 포함하지 않는 범위)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="09b446449a4319a7ef9115b3be9989109d17ce7e" translate="yes" xml:space="preserve">
          <source>The parser has to check the query string (which arrives as plain text) for valid syntax. If the syntax is correct a &lt;em&gt;parse tree&lt;/em&gt; is built up and handed back; otherwise an error is returned. The parser and lexer are implemented using the well-known Unix tools bison and flex.</source>
          <target state="translated">구문 분석기는 유효한 구문을 위해 쿼리 문자열 (일반 텍스트로 도착)을 확인해야합니다. 구문이 올 바르면 &lt;em&gt;구문 분석 트리&lt;/em&gt; 가 작성되어 전달됩니다. 그렇지 않으면 오류가 반환됩니다. 파서와 어휘 분석기는 잘 알려진 Unix 도구 인 bison과 flex를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff5674ed423bd0fd40e474001e355555798b1f1" translate="yes" xml:space="preserve">
          <source>The parser initially marks the constants as being of type &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; respectively. There is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator in the system catalogs, but there is a &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator. The query will therefore succeed if a cast from &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt; is available and is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which in fact it is. The parser will apply the implicit cast and resolve the query as if it had been written</source>
          <target state="translated">파서는 처음에 상수를 각각 &lt;code&gt;integer&lt;/code&gt; 과 &lt;code&gt;numeric&lt;/code&gt; 형으로 표시합니다 . 시스템 카탈로그 에는 &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 연산자가 없지만 &lt;code&gt;numeric&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 연산자가 있습니다. 따라서 &lt;code&gt;integer&lt;/code&gt; 에서 &lt;code&gt;numeric&lt;/code&gt; 로 캐스트를 사용할 수 있고 &lt;code&gt;AS IMPLICIT&lt;/code&gt; 로 표시 되면 실제로 쿼리가 성공합니다 . 파서는 암시 적 캐스트를 적용하고 마치 작성된 것처럼 쿼리를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="25f13c18d68a86fdbefd4291a356d75813cdb2e5" translate="yes" xml:space="preserve">
          <source>The parser is defined in the file &lt;code&gt;gram.y&lt;/code&gt; and consists of a set of &lt;em&gt;grammar rules&lt;/em&gt; and &lt;em&gt;actions&lt;/em&gt; that are executed whenever a rule is fired. The code of the actions (which is actually C code) is used to build up the parse tree.</source>
          <target state="translated">파서는 &lt;code&gt;gram.y&lt;/code&gt; 파일에 정의되어 있으며 &lt;em&gt;규칙&lt;/em&gt; 이 실행될 때마다 실행 되는 일련의 &lt;em&gt;문법 규칙&lt;/em&gt; 과 &lt;em&gt;작업으로&lt;/em&gt; 구성됩니다 . 액션 코드 (실제로 C 코드)는 구문 분석 트리를 구축하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1857339fc15ab225bd01ccd9d926ca70975b0fc9" translate="yes" xml:space="preserve">
          <source>The parser learns from the &lt;code&gt;pg_cast&lt;/code&gt; catalog that &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary-compatible, meaning that one can be passed to a function that accepts the other without doing any physical conversion. Therefore, no type conversion call is really inserted in this case.</source>
          <target state="translated">파서는 &lt;code&gt;pg_cast&lt;/code&gt; 카탈로그에서 &lt;code&gt;text&lt;/code&gt; 와 &lt;code&gt;varchar&lt;/code&gt; 가 이진 호환 가능하다는 것을 알게됩니다. 즉, 물리적 변환을 수행하지 않고 다른 함수를 받아 들일 수있는 함수로 전달할 수 있습니다. 따라서이 경우 형식 변환 호출이 실제로 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e756c19d42be08cb71cc09834d6f8f8f843f91e" translate="yes" xml:space="preserve">
          <source>The parser stage creates a parse tree using only fixed rules about the syntactic structure of SQL. It does not make any lookups in the system catalogs, so there is no possibility to understand the detailed semantics of the requested operations. After the parser completes, the &lt;em&gt;transformation process&lt;/em&gt; takes the tree handed back by the parser as input and does the semantic interpretation needed to understand which tables, functions, and operators are referenced by the query. The data structure that is built to represent this information is called the &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="translated">파서 단계는 SQL의 구문 구조에 대한 고정 규칙 만 사용하여 구문 분석 트리를 작성합니다. 시스템 카탈로그에서 조회를 수행하지 않으므로 요청 된 조작의 자세한 의미를 이해할 가능성이 없습니다. 구문 분석기가 완료된 후 &lt;em&gt;변환 프로세스&lt;/em&gt; 는 구문 분석기가 입력 한 트리를 입력으로 가져와 쿼리에서 참조하는 테이블, 함수 및 연산자를 이해하는 데 필요한 의미 론적 해석을 수행합니다. 이 정보를 나타 내기 위해 구축 된 데이터 구조를 &lt;em&gt;쿼리 트리&lt;/em&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="ebdbb42aa00d24e0d513d01a8c9b666b615ba1dd" translate="yes" xml:space="preserve">
          <source>The parser's notion of a &amp;ldquo;letter&amp;rdquo; is determined by the database's locale setting, specifically &lt;code&gt;lc_ctype&lt;/code&gt;. Words containing only the basic ASCII letters are reported as a separate token type, since it is sometimes useful to distinguish them. In most European languages, token types &lt;code&gt;word&lt;/code&gt; and &lt;code&gt;asciiword&lt;/code&gt; should be treated alike.</source>
          <target state="translated">&amp;ldquo;letter&amp;rdquo;에 대한 파서의 개념은 데이터베이스의 로케일 설정, 특히 &lt;code&gt;lc_ctype&lt;/code&gt; 에 의해 결정됩니다 . 기본 ASCII 문자 만 포함하는 단어는 별도의 토큰 유형으로보고되는데, 때로는이를 구별하는 것이 유용하기 때문입니다. 대부분의 유럽 언어에서 토큰 유형 &lt;code&gt;word&lt;/code&gt; 와 &lt;code&gt;asciiword&lt;/code&gt; 는 동일하게 취급해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c43fc6c8c7c3f14d277b633b89dfade64caf03b" translate="yes" xml:space="preserve">
          <source>The part of PostgreSQL that is devoted to determining (&lt;em&gt;planning&lt;/em&gt;) the most efficient way to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;. Also known as &lt;em&gt;query optimizer&lt;/em&gt;, &lt;em&gt;optimizer&lt;/em&gt;, or simply &lt;em&gt;planner&lt;/em&gt;.</source>
          <target state="translated">The part of PostgreSQL that is devoted to determining (&lt;em&gt;planning&lt;/em&gt;) the most efficient way to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;. Also known as &lt;em&gt;query optimizer&lt;/em&gt;, &lt;em&gt;optimizer&lt;/em&gt;, or simply &lt;em&gt;planner&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="7a4e5a431eb644b141f3790b8cfbc5fd53514f52" translate="yes" xml:space="preserve">
          <source>The partial transaction isolation provided by Read Committed mode is adequate for many applications, and this mode is fast and simple to use; however, it is not sufficient for all cases. Applications that do complex queries and updates might require a more rigorously consistent view of the database than Read Committed mode provides.</source>
          <target state="translated">읽기 커밋 모드에서 제공하는 부분 트랜잭션 격리는 많은 응용 프로그램에 적합하며이 모드는 사용이 빠르고 간단합니다. 그러나 모든 경우에 충분하지는 않습니다. 복잡한 쿼리 및 업데이트를 수행하는 응용 프로그램은 커밋 된 읽기 모드가 제공하는 것보다 훨씬 일관된 데이터베이스 뷰를 요구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9b101fa3ff04c41a301e2ea58c51b731736d02" translate="yes" xml:space="preserve">
          <source>The partition bound specification for a new partition. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on the syntax of the same.</source>
          <target state="translated">새 파티션에 대한 파티션 바운드 사양입니다. 참조 &lt;a href=&quot;sql-createtable&quot;&gt;표를 CREATE&lt;/a&gt; 같은 구문에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="a843f1857d3445c37bfb25c214ac7c60e2eda3b2" translate="yes" xml:space="preserve">
          <source>The password is always stored encrypted in the system catalogs. The &lt;code&gt;ENCRYPTED&lt;/code&gt; keyword has no effect, but is accepted for backwards compatibility. The method of encryption is determined by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;. If the presented password string is already in MD5-encrypted or SCRAM-encrypted format, then it is stored as-is regardless of &lt;code&gt;password_encryption&lt;/code&gt; (since the system cannot decrypt the specified encrypted password string, to encrypt it in a different format). This allows reloading of encrypted passwords during dump/restore.</source>
          <target state="translated">비밀번호는 항상 시스템 카탈로그에 암호화되어 저장됩니다. &lt;code&gt;ENCRYPTED&lt;/code&gt; 키워드는 효과가 없지만, 이전 버전과의 호환성을 위해 허용됩니다. 암호화 방법은 구성 매개 변수 &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption에&lt;/a&gt; 의해 결정됩니다 . 제시된 암호 문자열을 MD5 암호화 또는 스크 램은 암호화 된 형식으로 이미 있다면, 그것은 관계없이 그대로 저장됩니다 &lt;code&gt;password_encryption&lt;/code&gt; (시스템이 지정된 암호화 된 암호 문자열 해독, 다른 형식으로 암호화 할 수 없기 때문에). 이를 통해 덤프 / 복원 중에 암호화 된 비밀번호를 다시로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a56dd735da3ef3f125939acf3298322bea99f6" translate="yes" xml:space="preserve">
          <source>The path at your site might be different. Contact your site administrator or check the installation instructions to correct the situation.</source>
          <target state="translated">사이트의 경로가 다를 수 있습니다. 상황을 수정하려면 사이트 관리자에게 문의하거나 설치 지침을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ae4a259e6f096215a3bc76dbbbf4ab5a1fa7063f" translate="yes" xml:space="preserve">
          <source>The path expression contains &lt;code&gt;type()&lt;/code&gt; or &lt;code&gt;size()&lt;/code&gt; methods that return the type and the number of elements in the array, respectively.</source>
          <target state="translated">경로 표현식에는 배열의 요소 유형과 개수를 각각 반환하는 &lt;code&gt;type()&lt;/code&gt; 또는 &lt;code&gt;size()&lt;/code&gt; 메서드가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="665f879c5dd1bad744ce39b38be0ec7bfa475f6e" translate="yes" xml:space="preserve">
          <source>The path name of the input or output file. An input file name can be an absolute or relative path, but an output file name must be an absolute path. Windows users might need to use an &lt;code&gt;E''&lt;/code&gt; string and double any backslashes used in the path name.</source>
          <target state="translated">입력 또는 출력 파일의 경로 이름 입력 파일 이름은 절대 또는 상대 경로 일 수 있지만 출력 파일 이름은 절대 경로 여야합니다. Windows 사용자는 &lt;code&gt;E''&lt;/code&gt; 문자열을 사용하고 경로 이름에 사용 된 백 슬래시를 두 배로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="acfece2d4d4a40c54bd9f721a413e8f8e6ea9b4c" translate="yes" xml:space="preserve">
          <source>The pattern characters &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;G&lt;/code&gt; represent the sign, currency symbol, decimal point, and thousands separator characters defined by the current locale (see &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; and &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;). The pattern characters period and comma represent those exact characters, with the meanings of decimal point and thousands separator, regardless of locale.</source>
          <target state="translated">패턴 문자 &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; 는 현재 로케일에 의해 정의 된 부호, 통화 기호, 소수점 및 천 단위 구분 기호 문자를 나타 &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;냅니다&lt;/a&gt; ( lc_monetary 및 &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt; 참조 ). 패턴 문자 마침표와 쉼표는 로케일에 관계없이 소수점과 천 단위 구분 기호의 의미로 정확한 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0f3ba6e11e445232d30834cd144281a86bebafa9" translate="yes" xml:space="preserve">
          <source>The pattern matching operators of all three kinds do not support nondeterministic collations. If required, apply a different collation to the expression to work around this limitation.</source>
          <target state="translated">세 종류의 패턴 일치 연산자는 비 결정적 데이터 정렬을 지원하지 않습니다. 필요한 경우 표현식에 다른 데이터 정렬을 적용하여이 제한을 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="53ad7762f98479cbca28b8363660cbfe1cf95173" translate="yes" xml:space="preserve">
          <source>The payload of the notifications consists of the table name, a letter to indicate which type of operation was performed, and column name/value pairs for primary key columns. Each part is separated from the next by a comma. For ease of parsing using regular expressions, table and column names are always wrapped in double quotes, and data values are always wrapped in single quotes. Embedded quotes are doubled.</source>
          <target state="translated">알림의 페이로드는 테이블 이름, 수행 된 작업 유형을 나타내는 문자 및 기본 키 열의 열 이름 / 값 쌍으로 구성됩니다. 각 부분은 쉼표로 다음 부분과 구분됩니다. 정규식을 사용하여 쉽게 구문 분석 할 수 있도록 테이블 및 열 이름은 항상 큰 따옴표로 묶고 데이터 값은 항상 작은 따옴표로 묶습니다. 포함 된 따옴표는 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="99b6bf90a9bb8e6d618127a1a2c46cd208469261" translate="yes" xml:space="preserve">
          <source>The peer authentication method works by obtaining the client's operating system user name from the kernel and using it as the allowed database user name (with optional user name mapping). This method is only supported on local connections.</source>
          <target state="translated">피어 인증 방법은 커널에서 클라이언트의 운영 체제 사용자 이름을 가져 와서 허용되는 데이터베이스 사용자 이름으로 사용합니다 (선택적인 사용자 이름 매핑 사용). 이 방법은 로컬 연결에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="919e0066d8303b60f8d9dce39383d269124b1827" translate="yes" xml:space="preserve">
          <source>The per-index statistics are particularly useful to determine which indexes are being used and how effective they are.</source>
          <target state="translated">인덱스 별 통계는 사용중인 인덱스와 효과를 확인하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2b32037bdcf53d4293fda5e00a43bb07b50f376a" translate="yes" xml:space="preserve">
          <source>The performance of an R-tree index can largely depend on the initial order of input values. It may be very helpful to sort the input table on the &lt;code&gt;seg&lt;/code&gt; column; see the script &lt;code&gt;sort-segments.pl&lt;/code&gt; for an example.</source>
          <target state="translated">R- 트리 인덱스의 성능은 입력 값의 초기 순서에 크게 좌우 될 수 있습니다. &lt;code&gt;seg&lt;/code&gt; 열 에서 입력 테이블을 정렬하는 것이 매우 도움이 될 수 있습니다 . 예제는 &lt;code&gt;sort-segments.pl&lt;/code&gt; 스크립트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="794af340a68964153b03ef2b6d22753d285cf9d8" translate="yes" xml:space="preserve">
          <source>The period (&lt;code&gt;.&lt;/code&gt;) is used in numeric constants, and to separate schema, table, and column names.</source>
          <target state="translated">마침표 ( &lt;code&gt;.&lt;/code&gt; )는 숫자 상수에 사용되며 스키마, 테이블 및 열 이름을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="1dd06a0691afe3884d57662cd23df0c2e7cc6503" translate="yes" xml:space="preserve">
          <source>The pg_config utility prints configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries.</source>
          <target state="translated">pg_config 유틸리티는 현재 설치된 PostgreSQL 버전의 구성 매개 변수를 인쇄합니다. 예를 들어, 필요한 헤더 파일 및 라이브러리를 쉽게 찾을 수 있도록 PostgreSQL에 인터페이스하려는 소프트웨어 패키지에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="38257de71aaf3c94498314a3023e95f97988a3ee" translate="yes" xml:space="preserve">
          <source>The phenomena which are prohibited at various levels are:</source>
          <target state="translated">다양한 수준에서 금지되는 현상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23f998eae14382a70d2324fb449ffb907b06c285" translate="yes" xml:space="preserve">
          <source>The phrases &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;ILIKE&lt;/code&gt;, &lt;code&gt;NOT LIKE&lt;/code&gt;, and &lt;code&gt;NOT ILIKE&lt;/code&gt; are generally treated as operators in PostgreSQL syntax; for example they can be used in &lt;code&gt;expression&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt; ANY (&lt;code&gt;subquery&lt;/code&gt;) constructs, although an &lt;code&gt;ESCAPE&lt;/code&gt; clause cannot be included there. In some obscure cases it may be necessary to use the underlying operator names instead.</source>
          <target state="translated">The phrases &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;ILIKE&lt;/code&gt; , &lt;code&gt;NOT LIKE&lt;/code&gt; , and &lt;code&gt;NOT ILIKE&lt;/code&gt; are generally treated as operators in PostgreSQL syntax; for example they can be used in &lt;code&gt;expression&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; ANY ( &lt;code&gt;subquery&lt;/code&gt; ) constructs, although an &lt;code&gt;ESCAPE&lt;/code&gt; clause cannot be included there. In some obscure cases it may be necessary to use the underlying operator names instead.</target>
        </trans-unit>
        <trans-unit id="eb2bc77065c28244748a514edbbf72d360f29dfc" translate="yes" xml:space="preserve">
          <source>The physical location of the row version within its table. Note that although the &lt;code&gt;ctid&lt;/code&gt; can be used to locate the row version very quickly, a row's &lt;code&gt;ctid&lt;/code&gt; will change if it is updated or moved by &lt;code&gt;VACUUM FULL&lt;/code&gt;. Therefore &lt;code&gt;ctid&lt;/code&gt; is useless as a long-term row identifier. A primary key should be used to identify logical rows.</source>
          <target state="translated">테이블 내에서 행 버전의 실제 위치입니다. &lt;code&gt;ctid&lt;/code&gt; 를 사용하여 행 버전을 매우 빠르게 찾을 수 있지만 &lt;code&gt;VACUUM FULL&lt;/code&gt; 에 의해 행 또는 &lt;code&gt;ctid&lt;/code&gt; 가 업데이트되거나 이동되면 행의 ctid 가 변경됩니다 . 따라서 &lt;code&gt;ctid&lt;/code&gt; 는 장기 행 식별자로 쓸모가 없습니다. 논리 키를 식별하려면 기본 키를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed43e04d92b420464b4279a7468ab8888b8672c6" translate="yes" xml:space="preserve">
          <source>The planner assumes that the two conditions are independent, so that the individual selectivities of the clauses can be multiplied together:</source>
          <target state="translated">플래너는 두 조건이 독립적이라고 가정하여 절의 개별 선택성을 함께 곱할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f8b19a5896d87add8af3e241d28d22aabc60ce5" translate="yes" xml:space="preserve">
          <source>The planner cannot automatically determine whether a user-defined function or aggregate is parallel safe, parallel restricted, or parallel unsafe, because this would require predicting every operation which the function could possibly perform. In general, this is equivalent to the Halting Problem and therefore impossible. Even for simple functions where it could conceivably be done, we do not try, since this would be expensive and error-prone. Instead, all user-defined functions are assumed to be parallel unsafe unless otherwise marked. When using &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; or &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt;, markings can be set by specifying &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, or &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; as appropriate. When using &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;, the &lt;code&gt;PARALLEL&lt;/code&gt; option can be specified with &lt;code&gt;SAFE&lt;/code&gt;, &lt;code&gt;RESTRICTED&lt;/code&gt;, or &lt;code&gt;UNSAFE&lt;/code&gt; as the corresponding value.</source>
          <target state="translated">플래너는 사용자 정의 함수 또는 집계가 병렬 안전, 병렬 제한 또는 병렬 안전하지 않은지 자동으로 판별 할 수 없습니다. 이는 기능이 수행 할 수있는 모든 조작을 예측해야하기 때문입니다. 일반적으로 이는 정지 문제와 동일하므로 불가능합니다. 생각할 수있는 간단한 기능 일지라도 비용이 많이 들고 오류가 발생하기 쉽기 때문에 시도하지 않습니다. 대신 별도의 표시가없는 한 모든 사용자 정의 함수는 안전하지 않은 것으로 가정합니다. &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 또는 &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION을&lt;/a&gt; 사용할 때 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; , &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 또는 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 를 적절히 지정하여 표시를 설정할 수 있습니다 . 사용할 때&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; , &lt;code&gt;PARALLEL&lt;/code&gt; 옵션은 &lt;code&gt;SAFE&lt;/code&gt; , &lt;code&gt;RESTRICTED&lt;/code&gt; 또는 &lt;code&gt;UNSAFE&lt;/code&gt; 를 해당 값으로 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b371bcb4f76e8388ab2f98830da7c42b56f6e59" translate="yes" xml:space="preserve">
          <source>The planner classifies operations involved in a query as either &lt;em&gt;parallel safe&lt;/em&gt;, &lt;em&gt;parallel restricted&lt;/em&gt;, or &lt;em&gt;parallel unsafe&lt;/em&gt;. A parallel safe operation is one which does not conflict with the use of parallel query. A parallel restricted operation is one which cannot be performed in a parallel worker, but which can be performed in the leader while parallel query is in use. Therefore, parallel restricted operations can never occur below a &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node, but can occur elsewhere in a plan which contains such a node. A parallel unsafe operation is one which cannot be performed while parallel query is in use, not even in the leader. When a query contains anything which is parallel unsafe, parallel query is completely disabled for that query.</source>
          <target state="translated">플래너는 쿼리와 관련된 작업을 &lt;em&gt;병렬 안전&lt;/em&gt; , &lt;em&gt;병렬 제한&lt;/em&gt; 또는 &lt;em&gt;병렬 안전하지 않은 것으로 분류&lt;/em&gt; 합니다. 병렬 안전 작업은 병렬 쿼리 사용과 충돌하지 않는 작업입니다. 병렬 제한 작업은 병렬 작업자에서 수행 할 수 없지만 병렬 쿼리를 사용하는 동안 리더에서 수행 할 수있는 작업입니다. 따라서 병렬 제한된 작업은 &lt;code&gt;Gather&lt;/code&gt; 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 아래에서 발생할 수 없습니다.노드, 그러나 그러한 노드를 포함하는 계획의 다른 곳에서 발생할 수 있습니다. 병렬 안전하지 않은 작업은 병렬 쿼리가 사용 중일 때는 수행 할 수없고 리더에서도 수행 할 수없는 작업입니다. 쿼리에 병렬 안전하지 않은 항목이 포함 된 경우 해당 쿼리에 대해 병렬 쿼리가 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="41ec537c1145f33dc399ea4d0d8e72c677f37799" translate="yes" xml:space="preserve">
          <source>The planner estimates the selectivity for each condition individually, arriving at the same 1% estimates as above. Then it assumes that the conditions are independent, and so it multiplies their selectivities, producing a final selectivity estimate of just 0.01%. This is a significant underestimate, as the actual number of rows matching the conditions (100) is two orders of magnitude higher.</source>
          <target state="translated">플래너는 각 조건에 대한 선택성을 개별적으로 추정하여 위와 동일한 1 % 추정치에 도달합니다. 그런 다음 조건이 독립적이라고 가정하여 선택성을 곱하여 최종 선택도 추정치가 0.01 %에 불과합니다. 조건 (100)과 일치하는 실제 행 수가 2 배 더 크기 때문에 이것은 과소 평가 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="12ef35e8963b60e1a1f66c8c5c86ede0e85c0b68" translate="yes" xml:space="preserve">
          <source>The planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for the operator &lt;code&gt;&amp;lt;&lt;/code&gt; in &lt;code&gt;pg_operator&lt;/code&gt;. This is held in the column &lt;code&gt;oprrest&lt;/code&gt;, and the entry in this case is &lt;code&gt;scalarltsel&lt;/code&gt;. The &lt;code&gt;scalarltsel&lt;/code&gt; function retrieves the histogram for &lt;code&gt;unique1&lt;/code&gt; from &lt;code&gt;pg_statistic&lt;/code&gt;. For manual queries it is more convenient to look in the simpler &lt;code&gt;pg_stats&lt;/code&gt; view:</source>
          <target state="translated">플래너는 검사 &lt;code&gt;WHERE&lt;/code&gt; 오퍼레이터에 대한 선택성 기능까지 절 조건 및 외관 &lt;code&gt;&amp;lt;&lt;/code&gt; 에서 &lt;code&gt;pg_operator&lt;/code&gt; . 이것은 열 &lt;code&gt;oprrest&lt;/code&gt; 에 유지 되며이 경우 항목은 &lt;code&gt;scalarltsel&lt;/code&gt; 입니다. &lt;code&gt;scalarltsel&lt;/code&gt; 의 기능에 대한 히스토그램 검색 &lt;code&gt;unique1&lt;/code&gt; 에서 &lt;code&gt;pg_statistic&lt;/code&gt; 를 . 수동 쿼리의 경우 더 간단한 &lt;code&gt;pg_stats&lt;/code&gt; 보기 를 보는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="55eece76171cb5150093319bc0d23d3c3262a30e" translate="yes" xml:space="preserve">
          <source>The planner examines the condition and determines the selectivity of this clause to be 1%. By comparing this estimate and the actual number of rows, we see that the estimate is very accurate (in fact exact, as the table is very small). Changing the &lt;code&gt;WHERE&lt;/code&gt; condition to use the &lt;code&gt;b&lt;/code&gt; column, an identical plan is generated. But observe what happens if we apply the same condition on both columns, combining them with &lt;code&gt;AND&lt;/code&gt;:</source>
          <target state="translated">플래너는 조건을 검사하고이 절의 선택성을 1 %로 결정합니다. 이 추정값과 실제 행 수를 비교하면 추정값이 매우 정확하다는 것을 알 수 있습니다 (사실 테이블이 매우 작으므로 정확함). &lt;code&gt;b&lt;/code&gt; 열 을 사용 하도록 &lt;code&gt;WHERE&lt;/code&gt; 조건을 변경하면 동일한 계획이 생성됩니다. 그러나 두 열에 동일한 조건을 적용하고 &lt;code&gt;AND&lt;/code&gt; 와 결합하면 어떻게되는지 관찰하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a1338924ef7e4d51c210a157253f9f111c3a5a5" translate="yes" xml:space="preserve">
          <source>The planner may implement an &lt;code&gt;ORDER BY&lt;/code&gt; clause in several ways. The above example shows that such an ordering clause may be implemented implicitly. The planner may also add an explicit &lt;code&gt;sort&lt;/code&gt; step:</source>
          <target state="translated">The planner may implement an &lt;code&gt;ORDER BY&lt;/code&gt; clause in several ways. The above example shows that such an ordering clause may be implemented implicitly. The planner may also add an explicit &lt;code&gt;sort&lt;/code&gt; step:</target>
        </trans-unit>
        <trans-unit id="ccbe97e96812fba17e36b64c7a8a14a6a5fc672b" translate="yes" xml:space="preserve">
          <source>The planner thinks (quite correctly) that this sample table is too small to bother with an index scan, so we have a plain sequential scan in which all the rows got rejected by the filter condition. But if we force an index scan to be used, we see:</source>
          <target state="translated">플래너는이 샘플 테이블이 너무 작아 인덱스 스캔을 방해 할 수 없다고 생각합니다. 따라서 모든 행이 필터 조건에 의해 거부되는 일반 순차 스캔이 있습니다. 그러나 인덱스 스캔을 강제로 사용하면 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e657fb9f6d61f80be4eb7b46475ad5f607f9e2a" translate="yes" xml:space="preserve">
          <source>The planner will consider satisfying an &lt;code&gt;ORDER BY&lt;/code&gt; specification either by scanning an available index that matches the specification, or by scanning the table in physical order and doing an explicit sort. For a query that requires scanning a large fraction of the table, an explicit sort is likely to be faster than using an index because it requires less disk I/O due to following a sequential access pattern. Indexes are more useful when only a few rows need be fetched. An important special case is &lt;code&gt;ORDER BY&lt;/code&gt; in combination with &lt;code&gt;LIMIT&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;: an explicit sort will have to process all the data to identify the first &lt;code&gt;n&lt;/code&gt; rows, but if there is an index matching the &lt;code&gt;ORDER BY&lt;/code&gt;, the first &lt;code&gt;n&lt;/code&gt; rows can be retrieved directly, without scanning the remainder at all.</source>
          <target state="translated">플래너는 스펙과 일치하는 사용 가능한 인덱스를 스캔하거나 테이블을 물리적 순서로 스캔하고 명시 적 정렬을 수행하여 &lt;code&gt;ORDER BY&lt;/code&gt; 스펙을 충족시키는 것을 고려할 것 입니다. 테이블의 많은 부분을 스캔해야하는 쿼리의 경우 순차적 액세스 패턴을 따르기 때문에 디스크 I / O가 덜 필요하므로 인덱스를 사용하는 것보다 명시적인 정렬이 더 빠를 수 있습니다. 인덱스는 몇 개의 행만 페치해야 할 때 더 유용합니다. 중요한 특수한 경우는 &lt;code&gt;LIMIT&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 과 함께 &lt;code&gt;ORDER BY&lt;/code&gt; 입니다 . 명시 적 정렬은 첫 번째 &lt;code&gt;n&lt;/code&gt; 행 을 식별하기 위해 모든 데이터를 처리해야 하지만 &lt;code&gt;ORDER BY&lt;/code&gt; 와 일치하는 인덱스가 있으면 첫 번째 &lt;code&gt;n&lt;/code&gt; 나머지를 전혀 스캔하지 않고 행을 직접 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f13fe03a32c9bbc1e61cf84d9ac188afb139c0ce" translate="yes" xml:space="preserve">
          <source>The planner will merge sub-queries into upper queries if the resulting &lt;code&gt;FROM&lt;/code&gt; list would have no more than this many items. Smaller values reduce planning time but might yield inferior query plans. The default is eight. For more information see &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.</source>
          <target state="translated">결과 &lt;code&gt;FROM&lt;/code&gt; 목록에이 항목을 초과하지 않는 경우 플래너는 하위 쿼리를 상위 쿼리로 병합 합니다. 값이 작을수록 계획 시간이 줄어들지 만 쿼리 계획이 열등 할 수 있습니다. 기본값은 8입니다. 자세한 정보는 &lt;a href=&quot;explicit-joins&quot;&gt;14.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e54dd315c563119cab38a459210d1e25c17b541" translate="yes" xml:space="preserve">
          <source>The planner will rewrite explicit &lt;code&gt;JOIN&lt;/code&gt; constructs (except &lt;code&gt;FULL JOIN&lt;/code&gt;s) into lists of &lt;code&gt;FROM&lt;/code&gt; items whenever a list of no more than this many items would result. Smaller values reduce planning time but might yield inferior query plans.</source>
          <target state="translated">플래너는 명시 적 &lt;code&gt;JOIN&lt;/code&gt; 구문 ( &lt;code&gt;FULL JOIN&lt;/code&gt; 제외 ) &lt;code&gt;FROM&lt;/code&gt; 항목 수 이하의 목록이 생성 될 때마다 FROM 항목 목록 으로 다시 작성 합니다. 값이 작을수록 계획 시간이 줄어들지 만 쿼리 계획이 열등 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51459135e7da0626e3461453ee190521c7ca83f8" translate="yes" xml:space="preserve">
          <source>The planner's information about the query being processed.</source>
          <target state="translated">처리중인 쿼리에 대한 플래너 정보.</target>
        </trans-unit>
        <trans-unit id="1577e921445112f0dec558626039eff4a0e20d9e" translate="yes" xml:space="preserve">
          <source>The planner's search procedure actually works with data structures called &lt;em&gt;paths&lt;/em&gt;, which are simply cut-down representations of plans containing only as much information as the planner needs to make its decisions. After the cheapest path is determined, a full-fledged &lt;em&gt;plan tree&lt;/em&gt; is built to pass to the executor. This represents the desired execution plan in sufficient detail for the executor to run it. In the rest of this section we'll ignore the distinction between paths and plans.</source>
          <target state="translated">플래너의 검색 절차는 실제로 &lt;em&gt;paths&lt;/em&gt; 라는 데이터 구조와 함께 작동 하는데, 이는 플래너가 결정을 내리는 데 필요한만큼의 정보 만 포함하는 계획을 간단히 표현한 것입니다. 가장 저렴한 경로가 결정되면 본격적인 &lt;em&gt;계획 트리&lt;/em&gt; 가 실행기로 전달됩니다. 이는 실행 프로그램이이를 실행하기에 충분한 세부 실행 계획을 나타냅니다. 이 섹션의 나머지 부분에서는 경로와 계획의 차이점을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="4a55c4b471813d250b09c8e9cf01cec1bc297015" translate="yes" xml:space="preserve">
          <source>The planner/optimizer starts by generating plans for scanning each individual relation (table) used in the query. The possible plans are determined by the available indexes on each relation. There is always the possibility of performing a sequential scan on a relation, so a sequential scan plan is always created. Assume an index is defined on a relation (for example a B-tree index) and a query contains the restriction &lt;code&gt;relation.attribute OPR constant&lt;/code&gt;. If &lt;code&gt;relation.attribute&lt;/code&gt; happens to match the key of the B-tree index and &lt;code&gt;OPR&lt;/code&gt; is one of the operators listed in the index's &lt;em&gt;operator class&lt;/em&gt;, another plan is created using the B-tree index to scan the relation. If there are further indexes present and the restrictions in the query happen to match a key of an index, further plans will be considered. Index scan plans are also generated for indexes that have a sort ordering that can match the query's &lt;code&gt;ORDER BY&lt;/code&gt; clause (if any), or a sort ordering that might be useful for merge joining (see below).</source>
          <target state="translated">플래너 / 최적화 기는 쿼리에 사용 된 각 개별 관계 (테이블)를 스캔하기위한 계획을 생성하여 시작합니다. 가능한 계획은 각 관계에서 사용 가능한 색인에 의해 결정됩니다. 관계에 대해 순차 스캔을 수행 할 가능성이 항상 있으므로 순차 스캔 계획이 항상 작성됩니다. 인덱스가 관계 (예 : B- 트리 인덱스)에 정의되어 있고 쿼리에 제한 &lt;code&gt;relation.attribute OPR constant&lt;/code&gt; 가 포함되어 있다고 가정하십시오 . 경우 &lt;code&gt;relation.attribute&lt;/code&gt; 는 B- 트리 인덱스의 키에 맞게 발생하고 &lt;code&gt;OPR&lt;/code&gt; 은 인덱스의에 나와있는 사업자 중 하나 인 &lt;em&gt;연산자 클래스&lt;/em&gt;B- 트리 인덱스를 사용하여 관계를 스캔하는 다른 계획이 작성됩니다. 인덱스가 더 있고 쿼리의 제한이 인덱스의 키와 일치하는 경우 추가 계획이 고려됩니다. 쿼리의 &lt;code&gt;ORDER BY&lt;/code&gt; 절 (있는 경우) 과 일치 할 수 있는 정렬 순서 또는 병합 조인에 유용 할 수있는 정렬 순서가있는 인덱스에 대해서도 인덱스 스캔 계획이 생성됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="af6fcc949e29ec6b5395bb9895c598ac00851a39" translate="yes" xml:space="preserve">
          <source>The policy above implicitly provides a &lt;code&gt;WITH CHECK&lt;/code&gt; clause identical to its &lt;code&gt;USING&lt;/code&gt; clause, so that the constraint applies both to rows selected by a command (so a manager cannot &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; existing rows belonging to a different manager) and to rows modified by a command (so rows belonging to a different manager cannot be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">위의 정책 은 &lt;code&gt;USING&lt;/code&gt; 절과 동일한 &lt;code&gt;WITH CHECK&lt;/code&gt; 절을 내재적으로 제공 하므로 제한 조건이 명령에 의해 선택된 행 (관리자 가 다른 관리자에 속하는 기존 행을 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 할 수 없음 )과 수정 된 행 모두에 적용됩니다. 명령에 의해 (따라서 다른 관리자에 속하는 행은 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 를 통해 작성할 수 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="332f3ca0119d1ff928cc3032c43d7a8c6d076ef7" translate="yes" xml:space="preserve">
          <source>The port number at which the database server is listening.</source>
          <target state="translated">데이터베이스 서버가 청취중인 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="3946be524d4d21ed59a4396709c558221452e965" translate="yes" xml:space="preserve">
          <source>The port number on the RADIUS servers to connect to. If no port is specified, the default port &lt;code&gt;1812&lt;/code&gt; will be used.</source>
          <target state="translated">연결할 RADIUS 서버의 포트 번호입니다. 포트를 지정하지 않으면 기본 포트 &lt;code&gt;1812&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e70d1aceb09cc5ddba7934344393827032e6f65c" translate="yes" xml:space="preserve">
          <source>The port numbers to connect to on the RADIUS servers. If no port is specified, the default RADIUS port (&lt;code&gt;1812&lt;/code&gt;) will be used.</source>
          <target state="translated">The port numbers to connect to on the RADIUS servers. If no port is specified, the default RADIUS port ( &lt;code&gt;1812&lt;/code&gt; ) will be used.</target>
        </trans-unit>
        <trans-unit id="d78397caeb854681d204384441be23fbf5963377" translate="yes" xml:space="preserve">
          <source>The possible privileges are:</source>
          <target state="translated">가능한 권한은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f40d6965a9bc397fb0c918307a4356333c6e9be1" translate="yes" xml:space="preserve">
          <source>The possible types of qualified join are:</source>
          <target state="translated">가능한 조인 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="150d329b119d4f11b9ac2cd02c8c0d218611bacb" translate="yes" xml:space="preserve">
          <source>The potential for bloat in non-B-tree indexes has not been well researched. It is a good idea to periodically monitor the index's physical size when using any non-B-tree index type.</source>
          <target state="translated">B- 트리가 아닌 인덱스에서 부 풀리는 가능성에 대해서는 잘 연구되지 않았습니다. B 트리가 아닌 인덱스 유형을 사용하는 경우 인덱스의 물리적 크기를 정기적으로 모니터링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d757a72d029cfb4caba9e0b1db29785724f4d19a" translate="yes" xml:space="preserve">
          <source>The preceding statement is not true on Microsoft Windows: there, any changes in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file are immediately applied by subsequent new connections.</source>
          <target state="translated">위의 설명은 Microsoft Windows에서 사실이 아닙니다. &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일의 모든 변경 사항은 후속 새 연결에 의해 즉시 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="252c412e1c63dfae47e051caef322b62e83bb886" translate="yes" xml:space="preserve">
          <source>The precise rule that is applied in such cases is that an invalid timestamp that appears to fall within a jump-forward daylight savings transition is assigned the UTC offset that prevailed in the time zone just before the transition, while an ambiguous timestamp that could fall on either side of a jump-back transition is assigned the UTC offset that prevailed just after the transition. In most time zones this is equivalent to saying that &amp;ldquo;the standard-time interpretation is preferred when in doubt&amp;rdquo;.</source>
          <target state="translated">이러한 경우에 적용되는 정확한 규칙은 앞으로 진행되는 일광 절약 시간 전이에 해당하는 유효하지 않은 타임 스탬프에 전환 직전 시간대에 우선했던 UTC 오프셋이 할당되고, 그에 따른 모호한 타임 스탬프가 할당된다는 것입니다. 점프 백 전환의 양쪽에는 전환 직후의 UTC 오프셋이 할당됩니다. 대부분의 시간대에서 이는&amp;ldquo;의심 할 때는 표준 시간 해석이 선호됩니다&amp;rdquo;라고 말하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28bfcc19c7bbea45feb0d0e7674c45c3d0b2a8ce" translate="yes" xml:space="preserve">
          <source>The precision must be positive, the scale zero or positive. Alternatively:</source>
          <target state="translated">정밀도는 양수, 스케일은 0 또는 양수 여야합니다. 또는</target>
        </trans-unit>
        <trans-unit id="3ffc8a93a54e6689bf8eb9af624f2ca2cef390c0" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="translated">사전 정의 된 집계 함수는 &lt;a href=&quot;functions-aggregate&quot;&gt;9.20 절에&lt;/a&gt; 설명되어 있습니다. 다른 집계 함수는 사용자가 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a2c0ac127cccc7aaf6bb36feba44f57ab9026a" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="translated">The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;. Other aggregate functions can be added by the user.</target>
        </trans-unit>
        <trans-unit id="85290651a145a4790c306bf3090be3ac088ff86f" translate="yes" xml:space="preserve">
          <source>The preferred key type is &amp;ldquo;DSA and Elgamal&amp;rdquo;.</source>
          <target state="translated">선호하는 키 유형은 &quot;DSA 및 Elgamal&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="9dcad895255c51069330af5d11a7861de5e972db" translate="yes" xml:space="preserve">
          <source>The preferred way of creating any of the standard procedural languages is just:</source>
          <target state="translated">표준 절차 언어를 작성하는 기본 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d193e74c38ebc3f88cf6c96d5dc626c1a851ce8" translate="yes" xml:space="preserve">
          <source>The preferred way to add and remove members of roles that are being used as groups is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">그룹으로 사용중인 역할 구성원을 추가하고 제거하는 기본 방법은 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 및 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="56dfc8a10ef1e4c4eee74088145c35840ecca451" translate="yes" xml:space="preserve">
          <source>The prefixes used for hyphenation were also compiled from:</source>
          <target state="translated">하이픈에 사용되는 접두사도 다음에서 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="21fd2dec3de8b8ad1e5f622c8c13eab56cd148d6" translate="yes" xml:space="preserve">
          <source>The presence of &lt;code&gt;HAVING&lt;/code&gt; turns a query into a grouped query even if there is no &lt;code&gt;GROUP BY&lt;/code&gt; clause. This is the same as what happens when the query contains aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause. All the selected rows are considered to form a single group, and the &lt;code&gt;SELECT&lt;/code&gt; list and &lt;code&gt;HAVING&lt;/code&gt; clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the &lt;code&gt;HAVING&lt;/code&gt; condition is true, zero rows if it is not true.</source>
          <target state="translated">의 존재 &lt;code&gt;HAVING&lt;/code&gt; 더가없는 경우에도 회전을 그룹화 된 쿼리에 검색어를 &lt;code&gt;GROUP BY&lt;/code&gt; 일 절. 이는 쿼리에 집계 함수가 포함되어 있지만 &lt;code&gt;GROUP BY&lt;/code&gt; 절이 없는 경우 발생하는 것과 동일 합니다. 선택된 모든 행은 단일 그룹을 구성하는 것으로 간주되며 &lt;code&gt;SELECT&lt;/code&gt; 목록 및 &lt;code&gt;HAVING&lt;/code&gt; 절은 집계 함수 내에서만 테이블 열을 참조 할 수 있습니다. &lt;code&gt;HAVING&lt;/code&gt; 조건이 true 인 경우 이러한 쿼리는 단일 행을 생성하고 그렇지 않으면 0 개의 행을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="48e01dab4eaf7172ed513c36aea408ac9dcff0a1" translate="yes" xml:space="preserve">
          <source>The previous example with &lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; was an oversimplification of what &lt;code&gt;scalarltsel&lt;/code&gt; really does; now that we have seen an example of the use of MCVs, we can fill in some more detail. The example was correct as far as it went, because since &lt;code&gt;unique1&lt;/code&gt; is a unique column it has no MCVs (obviously, no value is any more common than any other value). For a non-unique column, there will normally be both a histogram and an MCV list, and &lt;em&gt;the histogram does not include the portion of the column population represented by the MCVs&lt;/em&gt;. We do things this way because it allows more precise estimation. In this situation &lt;code&gt;scalarltsel&lt;/code&gt; directly applies the condition (e.g., &amp;ldquo;&amp;lt; 1000&amp;rdquo;) to each value of the MCV list, and adds up the frequencies of the MCVs for which the condition is true. This gives an exact estimate of the selectivity within the portion of the table that is MCVs. The histogram is then used in the same way as above to estimate the selectivity in the portion of the table that is not MCVs, and then the two numbers are combined to estimate the overall selectivity. For example, consider</source>
          <target state="translated">&lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; 이전 예는 &lt;code&gt;scalarltsel&lt;/code&gt; 실제로 수행 하는 작업을 지나치게 단순화 한 것입니다 . 이제 우리는 MCV 사용의 예를 보았으므로 좀 더 자세하게 채울 수 있습니다. &lt;code&gt;unique1&lt;/code&gt; 은 고유 한 열 이기 때문에 MCV가 없기 때문에 (예를 들어 , 다른 값보다 더 일반적인 값이 없기 때문에) 예제는 올바르게 진행되었습니다 . 고유하지 않은 열의 경우 일반적으로 히스토그램과 MCV 목록이 모두 있으며 히스토그램에는 MCV로 &lt;em&gt;표시되는 열 모집단 부분이 포함되지 않습니다&lt;/em&gt; . 우리는 좀 더 정확한 추정을 할 수 있기 때문에 이런 식으로 일을합니다. 이 상황에서 &lt;code&gt;scalarltsel&lt;/code&gt; MCV 목록의 각 값에 조건 (예 : &quot;&amp;lt;1000&quot;)을 직접 적용하고 조건이 참인 MCV의 주파수를 더합니다. 이는 MCV 인 테이블 부분 내에서 선택성의 정확한 추정치를 제공합니다. 그런 다음 히스토그램을 MCV가 아닌 테이블 부분의 선택도를 추정하기 위해 위와 같은 방식으로 사용하고 두 숫자를 결합하여 전체 선택도를 추정합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bb34259f0365c548655973db55e1cb8224129b77" translate="yes" xml:space="preserve">
          <source>The primary and standby server work together to provide this capability, though the servers are only loosely coupled. The primary server operates in continuous archiving mode, while each standby server operates in continuous recovery mode, reading the WAL files from the primary. No changes to the database tables are required to enable this capability, so it offers low administration overhead compared to some other replication solutions. This configuration also has relatively low performance impact on the primary server.</source>
          <target state="translated">기본 서버와 대기 서버는이 기능을 제공하기 위해 함께 작동하지만 서버는 느슨하게 연결되어 있습니다. 기본 서버는 연속 보관 모드로 작동하고 각 대기 서버는 연속 복구 모드로 작동하여 기본에서 WAL 파일을 읽습니다. 이 기능을 활성화하기 위해 데이터베이스 테이블을 변경할 필요가 없으므로 다른 복제 솔루션에 비해 관리 오버 헤드가 적습니다. 이 구성은 기본 서버에 대한 성능 영향도 상대적으로 낮습니다.</target>
        </trans-unit>
        <trans-unit id="0da66f61871c96b75f9ab923507bcc1a24b7f889" translate="yes" xml:space="preserve">
          <source>The primary and standby servers are in many ways loosely connected. Actions on the primary will have an effect on the standby. As a result, there is potential for negative interactions or conflicts between them. The easiest conflict to understand is performance: if a huge data load is taking place on the primary then this will generate a similar stream of WAL records on the standby, so standby queries may contend for system resources, such as I/O.</source>
          <target state="translated">기본 및 대기 서버는 여러 방법으로 느슨하게 연결되어 있습니다. 기본에 대한 조치는 대기에 영향을 미칩니다. 결과적으로 부정적인 상호 작용 또는 그들 사이의 충돌 가능성이 있습니다. 이해하기 가장 쉬운 충돌은 성능입니다. 기본에서 대량의 데이터로드가 발생하면 대기에서 유사한 WAL 레코드 스트림이 생성되므로 대기 쿼리는 I / O와 같은 시스템 리소스에 대해 경쟁 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="798c0c5f43fda644a454b46372f29e554497fa2e" translate="yes" xml:space="preserve">
          <source>The primary error message and associated SQLSTATE code for the most recent failed query in the current psql session, or an empty string and &lt;code&gt;00000&lt;/code&gt; if no error has occurred in the current session.</source>
          <target state="translated">현재 psql 세션에서 가장 최근에 실패한 쿼리에 대한 기본 오류 메시지 및 연관된 SQLSTATE 코드 또는 현재 세션에서 오류가 발생하지 않은 경우 빈 문자열 및 &lt;code&gt;00000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ab145e1a33deb5fe3582f237dbec8cdd7e1d8ca" translate="yes" xml:space="preserve">
          <source>The primary goal of developing GIN indexes was to create support for highly scalable full-text search in PostgreSQL, and there are often situations when a full-text search returns a very large set of results. Moreover, this often happens when the query contains very frequent words, so that the large result set is not even useful. Since reading many tuples from the disk and sorting them could take a lot of time, this is unacceptable for production. (Note that the index search itself is very fast.)</source>
          <target state="translated">GIN 인덱스 개발의 주요 목표는 PostgreSQL에서 확장 성이 뛰어난 전체 텍스트 검색을 지원하는 것이 었으며 전체 텍스트 검색이 매우 큰 결과 집합을 반환하는 경우가 종종 있습니다. 또한 쿼리에 단어가 매우 자주 포함되어 큰 결과 집합이 유용하지 않은 경우가 종종 발생합니다. 디스크에서 많은 튜플을 읽고 정렬하는 데 많은 시간이 걸릴 수 있으므로 프로덕션에는 적용 할 수 없습니다. 인덱스 검색 자체는 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="6c7d00d06905a4bbc00c744c0f27a07f33dd5060" translate="yes" xml:space="preserve">
          <source>The primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table. (Otherwise, the unique constraint is redundant and will be discarded.)</source>
          <target state="translated">기본 키 제약 조건은 동일한 테이블에 대해 정의 된 고유 제약 조건으로 명명 된 열 집합과 다른 열 집합의 이름을 지정해야합니다. (그렇지 않으면 고유 제한 조건이 중복되어 버려집니다.)</target>
        </trans-unit>
        <trans-unit id="095c1f180ee69bf2f8a1425ef17c7371474cd375" translate="yes" xml:space="preserve">
          <source>The primary query and the &lt;code&gt;WITH&lt;/code&gt; queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; cannot be seen from other parts of the query, other than by reading its &lt;code&gt;RETURNING&lt;/code&gt; output. If two such data-modifying statements attempt to modify the same row, the results are unspecified.</source>
          <target state="translated">기본 쿼리와 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 모두 (정상적으로) 동시에 실행됩니다. 이는 &lt;code&gt;WITH&lt;/code&gt; 의 데이터 수정 명령문 이 &lt;code&gt;RETURNING&lt;/code&gt; 출력 을 읽는 것 외에는 쿼리의 다른 부분에서 볼 수 없음을 나타 냅니다. 이러한 두 개의 데이터 수정 명령문이 동일한 행을 수정하려고하면 결과가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9af619375db4792c2c6568b4b82266a2578d8e4a" translate="yes" xml:space="preserve">
          <source>The primary use of unlogged tables is for storing transient work data that must be shared across processes.</source>
          <target state="translated">The primary use of unlogged tables is for storing transient work data that must be shared across processes.</target>
        </trans-unit>
        <trans-unit id="8ea3da5c410e9ce91a550f33e83dec4f1762b9fe" translate="yes" xml:space="preserve">
          <source>The privileges necessary to execute this command are left implementation-defined by the standard.</source>
          <target state="translated">이 명령을 실행하는 데 필요한 권한은 표준에 의해 구현 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d054afefddca1f4fd0c80061650d8bf2f8607fd" translate="yes" xml:space="preserve">
          <source>The privileges required by other commands are listed on the reference page of the respective command.</source>
          <target state="translated">다른 명령에 필요한 권한은 해당 명령의 참조 페이지에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="304d4014e67dda82fac817f06e9aef50bfd659e4" translate="yes" xml:space="preserve">
          <source>The privileges required to create a conversion might be changed in a future release.</source>
          <target state="translated">변환을 작성하는 데 필요한 권한은 다음 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb7e4f8bb27785f30b9b8a7055a803cd67b6df6" translate="yes" xml:space="preserve">
          <source>The privileges that have been granted for a particular object are displayed as a list of &lt;code&gt;aclitem&lt;/code&gt; entries, where each &lt;code&gt;aclitem&lt;/code&gt; describes the permissions of one grantee that have been granted by a particular grantor. For example, &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; specifies that the role &lt;code&gt;calvin&lt;/code&gt; has the privilege &lt;code&gt;SELECT&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;) with grant option (&lt;code&gt;*&lt;/code&gt;) as well as the non-grantable privilege &lt;code&gt;UPDATE&lt;/code&gt; (&lt;code&gt;w&lt;/code&gt;), both granted by the role &lt;code&gt;hobbes&lt;/code&gt;. If &lt;code&gt;calvin&lt;/code&gt; also has some privileges on the same object granted by a different grantor, those would appear as a separate &lt;code&gt;aclitem&lt;/code&gt; entry. An empty grantee field in an &lt;code&gt;aclitem&lt;/code&gt; stands for &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">특정 개체에 대해 부여 된 권한은 &lt;code&gt;aclitem&lt;/code&gt; 항목 의 목록으로 표시되며 각 &lt;code&gt;aclitem&lt;/code&gt; 은 특정 부여자가 부여한 한 수 여자의 권한을 설명합니다. 예를 들어, &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; 역할 &lt;code&gt;calvin&lt;/code&gt; 은 역할 &lt;code&gt;hobbes&lt;/code&gt; 에 의해 부여 된 부여 할 수없는 권한 &lt;code&gt;UPDATE&lt;/code&gt; ( &lt;code&gt;w&lt;/code&gt; ) 와 권한 부여 옵션 ( &lt;code&gt;*&lt;/code&gt; ) 이있는 &lt;code&gt;SELECT&lt;/code&gt; 특권 ( &lt;code&gt;r&lt;/code&gt; )을 갖도록 지정 합니다. 만약 &lt;code&gt;calvin&lt;/code&gt; 이 다른 부여자가 부여한 동일한 객체에 대한 특권을 가지고 있다면 , 그것들은 별도의 &lt;code&gt;aclitem&lt;/code&gt; 으로 보일 것입니다기입. &lt;code&gt;aclitem&lt;/code&gt; 의 빈 수 여자 필드는 &lt;code&gt;PUBLIC&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="146fa2f880a1a0967ddf597dd80c4df17c9e7c69" translate="yes" xml:space="preserve">
          <source>The procedural language code to be executed. This must be specified as a string literal, just as in &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Use of a dollar-quoted literal is recommended.</source>
          <target state="translated">실행할 절차 언어 코드입니다. &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 에서와 같이 문자열 리터럴로 지정해야합니다 . 달러 인용 리터럴을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6f86ee50294a4a7a3fef4b5b2297c9c5402611ba" translate="yes" xml:space="preserve">
          <source>The procedural language to be used must already have been installed into the current database by means of &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. &lt;code&gt;plpgsql&lt;/code&gt; is installed by default, but other languages are not.</source>
          <target state="translated">사용할 프로 시저 언어는 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 을 통해 현재 데이터베이스에 이미 설치되어 있어야합니다 . &lt;code&gt;plpgsql&lt;/code&gt; 은 기본적으로 설치되지만 다른 언어는 설치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eeffbbfe4a95a1cfc7af97774b63ebc4c95bcc67" translate="yes" xml:space="preserve">
          <source>The procedure for making a base backup using the low level APIs contains a few more steps than the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; method, but is relatively simple. It is very important that these steps are executed in sequence, and that the success of a step is verified before proceeding to the next step.</source>
          <target state="translated">저수준 API를 사용하여 기본 백업을 만드는 절차에는 &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; 방법 보다 몇 가지 단계가 더 있지만 비교적 간단합니다. 이 단계를 순서대로 실행하고 다음 단계로 진행하기 전에 단계의 성공 여부를 확인하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0cb38c62a0e05e7bd2148e42b61d27ee2ab30693" translate="yes" xml:space="preserve">
          <source>The procedure will now execute with whatever search path is used by its caller.</source>
          <target state="translated">프로시 저는 이제 호출자가 사용하는 검색 경로로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4b5bcbc092d024a0a7543e925fc016ccd66517c6" translate="yes" xml:space="preserve">
          <source>The process ID of the backend currently connected to.</source>
          <target state="translated">현재 연결된 백엔드의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="34795750bd1d44ec3bd68f7c69b56e729608c717" translate="yes" xml:space="preserve">
          <source>The process ID of the session using this slot if the slot is currently actively being used. &lt;code&gt;NULL&lt;/code&gt; if inactive.</source>
          <target state="translated">슬롯이 현재 사용중인 경우이 슬롯을 사용하는 세션의 프로세스 ID입니다. 비활성 인 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32a4bb7cc46bcf50934800d5f3c98570d230e94a" translate="yes" xml:space="preserve">
          <source>The process for an exclusive backup is mostly the same as for a non-exclusive one, but it differs in a few key steps. This type of backup can only be taken on a primary and does not allow concurrent backups. Moreover, because it creates a backup label file, as described below, it can block automatic restart of the master server after a crash. On the other hand, the erroneous removal of this file from a backup or standby is a common mistake, which can result in serious data corruption. If it is necessary to use this method, the following steps may be used.</source>
          <target state="translated">단독 백업 프로세스는 대부분 비 독점 백업 프로세스와 동일하지만 몇 가지 주요 단계가 다릅니다. 이 유형의 백업은 기본 백업에서만 수행 할 수 있으며 동시 백업은 허용하지 않습니다. 또한 아래와 같이 백업 레이블 파일을 작성하므로 충돌 후 마스터 서버의 자동 재시작을 차단할 수 있습니다. 반면에 백업 또는 대기에서이 파일을 잘못 제거하는 것은 일반적인 실수이며 심각한 데이터 손상을 초래할 수 있습니다. 이 방법을 사용해야하는 경우 다음 단계를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ac18966156d31cda12f7c9ac2957f1b7e5f24a9" translate="yes" xml:space="preserve">
          <source>The process of collecting statistics from data in &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; and other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; to help the &lt;a href=&quot;glossary#GLOSSARY-PLANNER&quot;&gt;query planner&lt;/a&gt; to make decisions about how to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;.</source>
          <target state="translated">The process of collecting statistics from data in &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; and other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; to help the &lt;a href=&quot;glossary#GLOSSARY-PLANNER&quot;&gt;query planner&lt;/a&gt; to make decisions about how to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="164dce5302a4d4d5322e298ad9a4e62c23cc3474" translate="yes" xml:space="preserve">
          <source>The process of removing outdated &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple versions&lt;/a&gt; from tables or materialized views, and other closely related processing required by PostgreSQL's implementation of &lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;MVCC&lt;/a&gt;. This can be initiated through the use of the &lt;code&gt;VACUUM&lt;/code&gt; command, but can also be handled automatically via &lt;a href=&quot;glossary#GLOSSARY-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; processes.</source>
          <target state="translated">The process of removing outdated &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple versions&lt;/a&gt; from tables or materialized views, and other closely related processing required by PostgreSQL's implementation of &lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;MVCC&lt;/a&gt;. This can be initiated through the use of the &lt;code&gt;VACUUM&lt;/code&gt; command, but can also be handled automatically via &lt;a href=&quot;glossary#GLOSSARY-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; processes.</target>
        </trans-unit>
        <trans-unit id="6e312719075282712af63a4478358c161b9ce7c1" translate="yes" xml:space="preserve">
          <source>The process of retrieving or the command to retrieve data from a database is called a &lt;em&gt;query&lt;/em&gt;. In SQL the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command is used to specify queries. The general syntax of the &lt;code&gt;SELECT&lt;/code&gt; command is</source>
          <target state="translated">검색 프로세스 또는 데이터베이스에서 데이터를 검색하는 명령을 &lt;em&gt;쿼리&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . SQL에서 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 명령은 쿼리를 지정하는 데 사용됩니다. &lt;code&gt;SELECT&lt;/code&gt; 명령 의 일반적인 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0bd352dde02b38bfa623807b29516cb539dd331" translate="yes" xml:space="preserve">
          <source>The program &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; is a wrapper program around this command, provided for convenience.</source>
          <target state="translated">프로그램 &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; 는 편의를 위해 제공된이 명령 주위의 랩퍼 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="3eff284be443ff432de37efc6563b33dc2f6e837" translate="yes" xml:space="preserve">
          <source>The prompts psql issues can be customized to your preference. The three variables &lt;code&gt;PROMPT1&lt;/code&gt;, &lt;code&gt;PROMPT2&lt;/code&gt;, and &lt;code&gt;PROMPT3&lt;/code&gt; contain strings and special escape sequences that describe the appearance of the prompt. Prompt 1 is the normal prompt that is issued when psql requests a new command. Prompt 2 is issued when more input is expected during command entry, for example because the command was not terminated with a semicolon or a quote was not closed. Prompt 3 is issued when you are running an SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; command and you need to type in a row value on the terminal.</source>
          <target state="translated">psql 문제 프롬프트는 원하는대로 사용자 정의 할 수 있습니다. 세 개의 변수 &lt;code&gt;PROMPT1&lt;/code&gt; , &lt;code&gt;PROMPT2&lt;/code&gt; 및 &lt;code&gt;PROMPT3&lt;/code&gt; 에는 프롬프트의 모양을 설명하는 문자열 및 특수 이스케이프 시퀀스가 ​​포함됩니다. 프롬프트 1은 psql이 새 명령을 요청할 때 발행되는 일반 프롬프트입니다. 명령이 세미콜론으로 종료되지 않았거나 따옴표가 닫히지 않아서 명령 입력 중에 더 많은 입력이 예상되면 프롬프트 2가 발행됩니다. 프롬프트 3은 SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; 명령을 실행할 때 발행 되며 터미널에서 행 값을 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="beda63023776d34df94471c0f164755d13f940bc" translate="yes" xml:space="preserve">
          <source>The property of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; that either all its operations complete as a single unit or none do. In addition, if a system failure occurs during the execution of a transaction, no partial results are visible after recovery. This is one of the ACID properties.</source>
          <target state="translated">The property of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; that either all its operations complete as a single unit or none do. In addition, if a system failure occurs during the execution of a transaction, no partial results are visible after recovery. This is one of the ACID properties.</target>
        </trans-unit>
        <trans-unit id="60437688afa311c4869b8b3f6a8991364e3687d3" translate="yes" xml:space="preserve">
          <source>The property of certain &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; that the changes to them are not reflected in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. This disables replication and crash recovery for these relations.</source>
          <target state="translated">The property of certain &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; that the changes to them are not reflected in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. This disables replication and crash recovery for these relations.</target>
        </trans-unit>
        <trans-unit id="fb5f3d4498a374f31c0813bda303e196477c5021" translate="yes" xml:space="preserve">
          <source>The property that some information has been pre-computed and stored for later use, rather than computing it on-the-fly.</source>
          <target state="translated">The property that some information has been pre-computed and stored for later use, rather than computing it on-the-fly.</target>
        </trans-unit>
        <trans-unit id="83b4c095224b564ce4e74b023e585d03df96a6dc" translate="yes" xml:space="preserve">
          <source>The property that the data in the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; is always in compliance with &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;integrity constraints&lt;/a&gt;. Transactions may be allowed to violate some of the constraints transiently before it commits, but if such violations are not resolved by the time it commits, such a transaction is automatically &lt;a href=&quot;glossary#GLOSSARY-ROLLBACK&quot;&gt;rolled back&lt;/a&gt;. This is one of the ACID properties.</source>
          <target state="translated">The property that the data in the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; is always in compliance with &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;integrity constraints&lt;/a&gt;. Transactions may be allowed to violate some of the constraints transiently before it commits, but if such violations are not resolved by the time it commits, such a transaction is automatically &lt;a href=&quot;glossary#GLOSSARY-ROLLBACK&quot;&gt;rolled back&lt;/a&gt;. This is one of the ACID properties.</target>
        </trans-unit>
        <trans-unit id="a6435c94ce6f1ff88843d11bc1738457d2390918" translate="yes" xml:space="preserve">
          <source>The property that the effects of a transaction are not visible to &lt;a href=&quot;glossary#GLOSSARY-CONCURRENCY&quot;&gt;concurrent transactions&lt;/a&gt; before it commits. This is one of the ACID properties.</source>
          <target state="translated">The property that the effects of a transaction are not visible to &lt;a href=&quot;glossary#GLOSSARY-CONCURRENCY&quot;&gt;concurrent transactions&lt;/a&gt; before it commits. This is one of the ACID properties.</target>
        </trans-unit>
        <trans-unit id="0b52632ebba8d8fdc7d9a5f3df0121e320094037" translate="yes" xml:space="preserve">
          <source>The provided functions are shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;Table F.5&lt;/a&gt;.</source>
          <target state="translated">제공된 기능은 &lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;표 F.5&lt;/a&gt; 에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="5afa1f9b64bd52e3a56222e3e5d393c2eefea25a" translate="yes" xml:space="preserve">
          <source>The purpose is to limit the impact of pg_basebackup on the running server.</source>
          <target state="translated">목적은 pg_basebackup이 실행중인 서버에 미치는 영향을 제한하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5073941a47e032b26bcb9d69507584568abea85b" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="translated">&lt;code&gt;WINDOW&lt;/code&gt; 절의 목적은 쿼리의 &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; &lt;/a&gt; 목록 또는 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/a&gt; 절에 나타나는 &lt;em&gt;창 함수&lt;/em&gt; 의 동작을 지정하는 것 입니다. 이 함수는 &lt;code&gt;OVER&lt;/code&gt; 절 에서 &lt;code&gt;WINDOW&lt;/code&gt; 절 항목을 이름으로 참조 할 수 있습니다 . 그러나 &lt;code&gt;WINDOW&lt;/code&gt; 절 항목은 어디에서나 참조 할 필요는 없습니다. 쿼리에서 사용되지 않으면 단순히 무시됩니다. 창 함수 호출은 &lt;code&gt;OVER&lt;/code&gt; 절 에서 직접 창 정의를 지정할 수 있으므로 &lt;code&gt;WINDOW&lt;/code&gt; 절 없이 창 함수를 사용할 수 있습니다 . 그러나 &lt;code&gt;WINDOW&lt;/code&gt; 절은 둘 이상의 창 함수에 동일한 창 정의가 필요할 때 입력을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b96262653baf1cfb436f7851543f2559b2750e87" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; list&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/a&gt; clause. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="translated">The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; list&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/a&gt; clause. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</target>
        </trans-unit>
        <trans-unit id="7a79e1e6c48912d3a19f2334c5cde8a4adb3de10" translate="yes" xml:space="preserve">
          <source>The purpose of an index, of course, is to support scans for tuples matching an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, often called a &lt;em&gt;qualifier&lt;/em&gt; or &lt;em&gt;scan key&lt;/em&gt;. The semantics of index scanning are described more fully in &lt;a href=&quot;index-scanning&quot;&gt;Section 61.3&lt;/a&gt;, below. An index access method can support &amp;ldquo;plain&amp;rdquo; index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, or both. The scan-related functions that an index access method must or may provide are:</source>
          <target state="translated">물론 인덱스의 목적은 종종 &lt;em&gt;한정자&lt;/em&gt; 또는 &lt;em&gt;스캔 키&lt;/em&gt; 라고 하는 인덱스 가능한 &lt;code&gt;WHERE&lt;/code&gt; 조건과 일치하는 튜플에 대한 스캔을 지원하는 것 입니다. 인덱스 스캔의 시맨틱은 아래의 &lt;a href=&quot;index-scanning&quot;&gt;섹션 61.3에&lt;/a&gt; 더 자세히 설명되어 있습니다. 인덱스 액세스 방법은 &quot;일반&quot;인덱스 스캔, &quot;비트 맵&quot;인덱스 스캔 또는 둘 다를 지원할 수 있습니다. 인덱스 액세스 방법이 제공하거나 제공 할 수있는 스캔 관련 기능은 다음과 같습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71dfcd4f15fca395ab847bf8654ecc1126908484" translate="yes" xml:space="preserve">
          <source>The quantifiers &lt;code&gt;{1,1}&lt;/code&gt; and &lt;code&gt;{1,1}?&lt;/code&gt; can be used to force greediness or non-greediness, respectively, on a subexpression or a whole RE. This is useful when you need the whole RE to have a greediness attribute different from what's deduced from its elements. As an example, suppose that we are trying to separate a string containing some digits into the digits and the parts before and after them. We might try to do that like this:</source>
          <target state="translated">수량 자 &lt;code&gt;{1,1}&lt;/code&gt; 및 &lt;code&gt;{1,1}?&lt;/code&gt; 하위 표현식 또는 전체 RE에 대해 각각 탐욕이나 욕심을 강요하는 데 사용될 수 있습니다. 이는 요소에서 추론 된 것과 다른 탐욕 속성을 갖기 위해 전체 RE가 필요할 때 유용합니다. 예를 들어, 일부 숫자가 포함 된 문자열을 숫자와 그 앞뒤에있는 부분으로 분리하려고한다고 가정합니다. 우리는 다음과 같이하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="343b9e25e0029b4f349abf2c9eb3c709d6c9db46" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1 - 4) that the date is in</source>
          <target state="translated">날짜가있는 연도의 분기 (1-4)</target>
        </trans-unit>
        <trans-unit id="4b7ab2f4293b424598bc3b854175b38f8e2117d5" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1&amp;ndash;4) that the date is in</source>
          <target state="translated">The quarter of the year (1&amp;ndash;4) that the date is in</target>
        </trans-unit>
        <trans-unit id="5c024cf5d71d6d58e1719ea5b88c2edd0af4738d" translate="yes" xml:space="preserve">
          <source>The queried JSON data contain nested arrays. In this case, only the outermost array is unwrapped, while all the inner arrays remain unchanged. Thus, implicit unwrapping can only go one level down within each path evaluation step.</source>
          <target state="translated">쿼리 된 JSON 데이터에는 중첩 배열이 포함됩니다. 이 경우 가장 바깥 쪽 배열 만 래핑되지 않고 모든 안쪽 배열은 변경되지 않습니다. 따라서 암시 적 언 래핑은 각 경로 평가 단계 내에서 한 수준 아래로만 내려갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ec83a60a4572c2a39f277feef2e26e14c05d5aa" translate="yes" xml:space="preserve">
          <source>The query above specifies that the &lt;code&gt;english&lt;/code&gt; configuration is to be used to parse and normalize the strings. Alternatively we could omit the configuration parameters:</source>
          <target state="translated">위의 쿼리는 &lt;code&gt;english&lt;/code&gt; 구성이 문자열을 구문 분석하고 정규화하는 데 사용되도록 지정합니다 . 또는 구성 매개 변수를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="755893eaea71f45690b0b8daa7c44ccecde3f16e" translate="yes" xml:space="preserve">
          <source>The query is running inside of another query that is already parallel. For example, if a function called by a parallel query issues an SQL query itself, that query will never use a parallel plan. This is a limitation of the current implementation, but it may not be desirable to remove this limitation, since it could result in a single query using a very large number of processes.</source>
          <target state="translated">쿼리가 이미 병렬 인 다른 쿼리 내에서 실행 중입니다. 예를 들어, 병렬 쿼리에 의해 호출 된 함수가 SQL 쿼리 자체를 발행하면 해당 쿼리는 병렬 계획을 사용하지 않습니다. 이것은 현재 구현의 제한 사항이지만이 제한을 제거하는 것은 바람직하지 않습니다. 많은 수의 프로세스를 사용하는 단일 쿼리가 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5a0a949650f6ba760f80fb27f318b51f13c26bd4" translate="yes" xml:space="preserve">
          <source>The query might be suspended during execution. In any situation in which the system thinks that partial or incremental execution might occur, no parallel plan is generated. For example, a cursor created using &lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt; will never use a parallel plan. Similarly, a PL/pgSQL loop of the form &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; will never use a parallel plan, because the parallel query system is unable to verify that the code in the loop is safe to execute while parallel query is active.</source>
          <target state="translated">실행 중에 쿼리가 일시 중단 될 수 있습니다. 시스템이 부분 또는 증분 실행이 발생할 수 있다고 생각하는 상황에서는 병렬 계획이 생성되지 않습니다. 예를 들어, &lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt; 를 사용하여 작성된 커서 는 병렬 계획을 사용하지 않습니다. 이와 유사하게 &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; 형식의 PL / pgSQL 루프 는 병렬 쿼리 시스템이 병렬 쿼리가 활성화되어있는 동안 루프의 코드가 안전하게 실행되는지 확인할 수 없기 때문에 병렬 계획을 사용하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="bdfa8875f3090d46606e95d96800e6f18174861f" translate="yes" xml:space="preserve">
          <source>The query must reference only columns stored in the index. For example, given an index on columns &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of a table that also has a column &lt;code&gt;z&lt;/code&gt;, these queries could use index-only scans:</source>
          <target state="translated">쿼리는 인덱스에 저장된 열만 참조해야합니다. 예를 들어, &lt;code&gt;z&lt;/code&gt; 열이있는 테이블의 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 열에 대한 인덱스가 주어지면 이러한 쿼리는 인덱스 전용 스캔을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c50468726e4134a52ce71c84ac34c354a3e1b957" translate="yes" xml:space="preserve">
          <source>The query optimizer takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">쿼리 옵티마이 저는 쿼리 계획을 생성 할 때 &lt;code&gt;LIMIT&lt;/code&gt; 를 고려하므로 &lt;code&gt;LIMIT&lt;/code&gt; 및 &lt;code&gt;OFFSET&lt;/code&gt; 에 제공 한 내용에 따라 다른 행 순서를 갖는 다른 계획을 얻을 가능성이 높습니다 . 따라서 다른 &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; 값을 사용하여 쿼리 결과의 다른 서브 세트를 선택 하면 &lt;code&gt;ORDER BY&lt;/code&gt; 로 예측 가능한 결과 순서를 적용하지 않으면 &lt;em&gt;일치&lt;/em&gt; 하지 않는 결과 &lt;em&gt;가 제공됩니다&lt;/em&gt; . 이것은 버그가 아닙니다. &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용하여 순서를 제한 하지 않는 한 SQL이 특정 순서로 쿼리 결과를 제공하지 않을 것이라는 사실의 본질적인 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="9591ec91d27bd94fc1ed0042a9c68fc7e7f8799e" translate="yes" xml:space="preserve">
          <source>The query planner takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">쿼리 계획자는 쿼리 계획을 생성 할 때 &lt;code&gt;LIMIT&lt;/code&gt; 를 고려하므로 &lt;code&gt;LIMIT&lt;/code&gt; 및 &lt;code&gt;OFFSET&lt;/code&gt; 에 사용하는 것에 따라 다른 계획 (행 순서가 다름)을 얻을 가능성이 큽니다 . 따라서 다른 &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; 값을 사용하여 쿼리 결과의 다른 서브 세트를 선택 하면 &lt;code&gt;ORDER BY&lt;/code&gt; 로 예측 가능한 결과 순서를 적용하지 않으면 &lt;em&gt;일치&lt;/em&gt; 하지 않는 결과 &lt;em&gt;가 제공됩니다&lt;/em&gt; . 이것은 버그가 아닙니다. &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용하여 순서를 제한 하지 않는 한 SQL이 특정 순서로 쿼리 결과를 제공하지 않을 것이라는 사실의 본질적인 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="4af81e08bfabc175af6208808228c3292ec1d219" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="translated">쿼리 재 작성기는 &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;40 장에&lt;/a&gt; 자세하게 설명되어 있으므로 여기서 다루지 않아도됩니다. 우리는 리 라이터의 입력과 출력이 모두 쿼리 트리이며, 트리의 시맨틱 디테일의 표현이나 레벨에는 변화가 없다는 것을 지적 할 것이다. 재 작성은 매크로 확장의 한 형태로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294de92ad34c3155980be69ecc50bda8db23e6c8" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="translated">The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</target>
        </trans-unit>
        <trans-unit id="84cbe05d8623ccd8c2adba905f772e1af6572a6b" translate="yes" xml:space="preserve">
          <source>The query string submitted by the client to create this prepared statement. For prepared statements created via SQL, this is the &lt;code&gt;PREPARE&lt;/code&gt; statement submitted by the client. For prepared statements created via the frontend/backend protocol, this is the text of the prepared statement itself.</source>
          <target state="translated">이 준비된 명령문을 작성하기 위해 클라이언트가 제출 한 쿼리 문자열입니다. SQL을 통해 작성된 준비된 명령문의 경우 이는 클라이언트가 제출 한 &lt;code&gt;PREPARE&lt;/code&gt; 문입니다. 프론트 엔드 / 백엔드 프로토콜을 통해 작성된 준비된 명령문의 경우 이는 준비된 명령문 자체의 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="b1d53885b655d33f7ad2a2d0f4ca8ce4c9afa697" translate="yes" xml:space="preserve">
          <source>The query that is actually sent to the remote server for execution can be examined using &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt;.</source>
          <target state="translated">실행을 위해 실제로 원격 서버로 전송 된 쿼리는 &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt; 를 사용하여 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb7170c364ffc0983c042ed7b707bee01230d841" translate="yes" xml:space="preserve">
          <source>The query tree created by the transformation process is structurally similar to the raw parse tree in most places, but it has many differences in detail. For example, a &lt;code&gt;FuncCall&lt;/code&gt; node in the parse tree represents something that looks syntactically like a function call. This might be transformed to either a &lt;code&gt;FuncExpr&lt;/code&gt; or &lt;code&gt;Aggref&lt;/code&gt; node depending on whether the referenced name turns out to be an ordinary function or an aggregate function. Also, information about the actual data types of columns and expression results is added to the query tree.</source>
          <target state="translated">변환 프로세스에 의해 생성 된 쿼리 트리는 대부분의 경우 원시 구문 분석 트리와 구조적으로 유사하지만 세부적으로 많은 차이점이 있습니다. 예를 들어 구문 분석 트리 의 &lt;code&gt;FuncCall&lt;/code&gt; 노드는 구문 적으로 함수 호출처럼 보이는 것을 나타냅니다. 이것은 참조 된 이름이 일반 함수인지 집계 함수인지에 따라 &lt;code&gt;FuncExpr&lt;/code&gt; 또는 &lt;code&gt;Aggref&lt;/code&gt; 노드 로 변환 될 수 있습니다 . 또한 실제 데이터 유형 열 및 표현식 결과에 대한 정보가 쿼리 트리에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="85e8ce3a8f2eab045a32523ebad51fd65a628dc9" translate="yes" xml:space="preserve">
          <source>The query uses any function marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt;. Most system-defined functions are &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, but user-defined functions are marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; by default. See the discussion of &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt;.</source>
          <target state="translated">쿼리는 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 로 표시된 함수를 사용합니다 . 대부분의 시스템 정의 함수는 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; 이지만 사용자 정의 함수는 기본적 으로 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 로 표시 됩니다. &lt;a href=&quot;parallel-safety&quot;&gt;섹션 15.4&lt;/a&gt; 의 논의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae584697a944b3092f1bdba0372976965b96c14e" translate="yes" xml:space="preserve">
          <source>The query writes any data or locks any database rows. If a query contains a data-modifying operation either at the top level or within a CTE, no parallel plans for that query will be generated. As an exception, the commands &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt;, and &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; which create a new table and populate it can use a parallel plan.</source>
          <target state="translated">쿼리는 데이터를 쓰거나 데이터베이스 행을 잠급니다. 쿼리에 최상위 수준이나 CTE 내에서 데이터 수정 작업이 포함되어 있으면 해당 쿼리에 대한 병렬 계획이 생성되지 않습니다. 예외적으로 &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt; , &lt;code&gt;SELECT INTO&lt;/code&gt; 및 &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; 명령 은 새 테이블을 작성하고 채우는 병렬 계획을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="646431d95f05f7752d11dec325de9bca5192ab21" translate="yes" xml:space="preserve">
          <source>The radius of the Earth is obtained from the &lt;code&gt;earth()&lt;/code&gt; function. It is given in meters. But by changing this one function you can change the module to use some other units, or to use a different value of the radius that you feel is more appropriate.</source>
          <target state="translated">지구의 반지름은 &lt;code&gt;earth()&lt;/code&gt; 함수 에서 얻습니다 . 미터 단위로 제공됩니다. 그러나이 하나의 기능을 변경하면 다른 단위를 사용하거나 더 적절한 다른 반경 값을 사용하도록 모듈을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33dd011e0a27c9e4a8da0750e328420ec5636341" translate="yes" xml:space="preserve">
          <source>The range type's &lt;code&gt;subtype&lt;/code&gt; can be any type with an associated b-tree operator class (to determine the ordering of values for the range type). Normally the subtype's default b-tree operator class is used to determine ordering; to use a non-default operator class, specify its name with &lt;code&gt;subtype_opclass&lt;/code&gt;. If the subtype is collatable, and you want to use a non-default collation in the range's ordering, specify the desired collation with the &lt;code&gt;collation&lt;/code&gt; option.</source>
          <target state="translated">범위 유형의 &lt;code&gt;subtype&lt;/code&gt; 은 연관된 b- 트리 연산자 클래스가있는 모든 유형일 수 있습니다 (범위 유형의 값 순서를 결정하기 위해). 일반적으로 하위 유형의 기본 b- 트리 연산자 클래스는 순서를 결정하는 데 사용됩니다. 기본이 아닌 연산자 클래스를 사용하려면 &lt;code&gt;subtype_opclass&lt;/code&gt; 로 이름을 지정 하십시오 . 하위 유형을 정리할 수 있고 범위 순서에 기본이 아닌 데이터 정렬을 사용하려면 &lt;code&gt;collation&lt;/code&gt; 옵션을 사용하여 원하는 데이터 정렬을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="45e371c3b97fa5eccf6d1070963f8eb35bb332f4" translate="yes" xml:space="preserve">
          <source>The rate is targeted by starting transactions along a Poisson-distributed schedule time line. The expected start time schedule moves forward based on when the client first started, not when the previous transaction ended. That approach means that when transactions go past their original scheduled end time, it is possible for later ones to catch up again.</source>
          <target state="translated">요금은 포아송 분포 일정표에 따라 거래를 시작하여 목표로합니다. 예상 시작 시간 일정은 이전 트랜잭션이 종료 된 시점이 아니라 클라이언트가 처음 시작된 시점을 기준으로 진행됩니다. 이러한 접근 방식은 트랜잭션이 원래의 예정된 종료 시간을 지나면 이후 트랜잭션이 다시 따라 잡을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f993d6ebc7309b2d31242d61b21f2b56ac8f6a72" translate="yes" xml:space="preserve">
          <source>The reason for separating raw parsing from semantic analysis is that system catalog lookups can only be done within a transaction, and we do not wish to start a transaction immediately upon receiving a query string. The raw parsing stage is sufficient to identify the transaction control commands (&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;ROLLBACK&lt;/code&gt;, etc), and these can then be correctly executed without any further analysis. Once we know that we are dealing with an actual query (such as &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;), it is okay to start a transaction if we're not already in one. Only then can the transformation process be invoked.</source>
          <target state="translated">시맨틱 분석에서 원시 구문 분석을 분리하는 이유는 시스템 카탈로그 검색을 트랜잭션 내에서만 수행 할 수 있고 쿼리 문자열을 수신하는 즉시 트랜잭션을 시작하지 않기 때문입니다. 원시 구문 분석 단계는 트랜잭션 제어 명령 ( &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;ROLLBACK&lt;/code&gt; 등) 을 식별하기에 충분하며 추가 분석없이 올바르게 실행할 수 있습니다. 실제 쿼리 (예 : &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; )를 처리하고 있다는 것을 알면 아직 트랜잭션이없는 경우 트랜잭션을 시작해도됩니다. 그런 다음에 만 변환 프로세스를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2555cbea73ebf259be548a413cb3f00d947e85ce" translate="yes" xml:space="preserve">
          <source>The reason that periodic vacuuming solves the problem is that &lt;code&gt;VACUUM&lt;/code&gt; will mark rows as &lt;em&gt;frozen&lt;/em&gt;, indicating that they were inserted by a transaction that committed sufficiently far in the past that the effects of the inserting transaction are certain to be visible to all current and future transactions. Normal XIDs are compared using modulo-2&lt;sup&gt;32&lt;/sup&gt; arithmetic. This means that for every normal XID, there are two billion XIDs that are &amp;ldquo;older&amp;rdquo; and two billion that are &amp;ldquo;newer&amp;rdquo;; another way to say it is that the normal XID space is circular with no endpoint. Therefore, once a row version has been created with a particular normal XID, the row version will appear to be &amp;ldquo;in the past&amp;rdquo; for the next two billion transactions, no matter which normal XID we are talking about. If the row version still exists after more than two billion transactions, it will suddenly appear to be in the future. To prevent this, PostgreSQL reserves a special XID, &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which does not follow the normal XID comparison rules and is always considered older than every normal XID. Frozen row versions are treated as if the inserting XID were &lt;code&gt;FrozenTransactionId&lt;/code&gt;, so that they will appear to be &amp;ldquo;in the past&amp;rdquo; to all normal transactions regardless of wraparound issues, and so such row versions will be valid until deleted, no matter how long that is.</source>
          <target state="translated">주기적 진공 청소기로 문제를 해결하는 이유는 &lt;code&gt;VACUUM&lt;/code&gt; 이 행을 &lt;em&gt;고정 된&lt;/em&gt; 것으로 표시하여 삽입 트랜잭션의 효과가 현재 및 미래의 모든 트랜잭션에서 볼 수있을 정도로 과거에 충분히 커밋 된 트랜잭션에 의해 삽입되었음을 나타냅니다. . 일반 XID는 모듈로 -2 &lt;sup&gt;32를&lt;/sup&gt; 사용하여 비교됩니다.&lt;sup&gt;&lt;/sup&gt;산수. 이는 모든 일반 XID에 대해 &quot;더 오래된&quot;20 억 개의 XID와 &quot;더 새로운&quot;20 억 개의 XID가 있음을 의미합니다. 또 다른 방법은 정상적인 XID 공간이 끝 점이없는 원형이라는 것입니다. 따라서 특정 일반 XID를 사용하여 행 버전을 만든 후에는 향후 20 억 건의 트랜잭션에 대해 행 버전이&amp;ldquo;현재 과거&amp;rdquo;인 것처럼 보일 것입니다. 행 버전이 여전히 20 억 건 이상의 트랜잭션 후에도 존재하면 갑자기 미래에 나타날 것으로 보입니다. 이를 방지하기 위해 PostgreSQL은 일반 XID 비교 규칙을 따르지 않고 항상 모든 일반 XID보다 오래된 것으로 간주 되는 특수 XID &lt;code&gt;FrozenTransactionId&lt;/code&gt; 를 예약합니다 . 고정 된 행 버전은 삽입 XID가 &lt;code&gt;FrozenTransactionId&lt;/code&gt; 인 것처럼 처리됩니다.따라서 랩 어라운드 문제와 상관없이 모든 일반 트랜잭션에 대해 &quot;과거에&quot;있는 것처럼 보이므로 이러한 행 버전은 기간에 관계없이 삭제 될 때까지 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3e52350494447bb6f36961ad4e797bd18a9eb61e" translate="yes" xml:space="preserve">
          <source>The reason that single quotes must be doubled, as shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt;, is that this is true for any string literal in a SQL command. The generic string-literal parser consumes the outermost single quotes and reduces any pair of single quotes to one data character. What the &lt;code&gt;bytea&lt;/code&gt; input function sees is just one single quote, which it treats as a plain data character. However, the &lt;code&gt;bytea&lt;/code&gt; input function treats backslashes as special, and the other behaviors shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; are implemented by that function.</source>
          <target state="translated">&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;표 8.7&lt;/a&gt; 과 같이 작은 따옴표를 두 배로 늘려야하는 이유 는 이것이 SQL 명령의 모든 문자열 리터럴에 해당하기 때문입니다. 일반 문자열 리터럴 파서는 가장 작은 따옴표를 사용하고 작은 따옴표 쌍을 하나의 데이터 문자로 줄입니다. 무엇 &lt;code&gt;bytea&lt;/code&gt; 와의 입력 기능이 보는 것은 일반 데이터 문자로 처리 한 작은 따옴표입니다. 그러나 &lt;code&gt;bytea&lt;/code&gt; 입력 기능은 백 슬래시를 특수한 것으로 취급하며 &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;표 8.7에&lt;/a&gt; 표시된 다른 동작 은 해당 기능으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="035f0c664448dfa923a884566e84523654a5a8a5" translate="yes" xml:space="preserve">
          <source>The recommended method for configuring shared memory in macOS is to create a file named &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, containing variable assignments such as:</source>
          <target state="translated">macOS에서 공유 메모리를 구성하기 위해 권장되는 방법은 다음과 같은 변수 지정을 포함하는 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 파일을 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6faaba60ea4ceaac002ffa0497dd503d8d8e004" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the index and try again to perform &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;. (Another possibility is to rebuild the index with &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">이러한 경우 권장되는 복구 방법은 인덱스를 삭제하고 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 수행을 다시 시도하는 것 입니다. (또 다른 가능성은 &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt; 로 인덱스를 다시 작성하는 것입니다 ).</target>
        </trans-unit>
        <trans-unit id="65854068ac8d3288768569a456ffe6db4148ee2b" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the invalid index and try again to perform &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;. The concurrent index created during the processing has a name ending in the suffix &lt;code&gt;ccnew&lt;/code&gt;, or &lt;code&gt;ccold&lt;/code&gt; if it is an old index definition which we failed to drop. Invalid indexes can be dropped using &lt;code&gt;DROP INDEX&lt;/code&gt;, including invalid toast indexes.</source>
          <target state="translated">이러한 경우 권장되는 복구 방법은 유효하지 않은 인덱스를 삭제하고 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 를 다시 수행하는 것 입니다. 처리 중에 작성된 동시 색인의 이름은 접미사 &lt;code&gt;ccnew&lt;/code&gt; 로 끝나 거나 삭제하지 못한 이전 색인 정의 인 경우 &lt;code&gt;ccold&lt;/code&gt; 입니다. 유효 하지 않은 토스트 인덱스를 포함 하여 &lt;code&gt;DROP INDEX&lt;/code&gt; 를 사용하여 유효하지 않은 인덱스를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfc0dfd0875395d5ad4e9971dc3ba071b3c62b6b" translate="yes" xml:space="preserve">
          <source>The recommended syntax for referencing an ordered-set aggregate is to write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications, in the same style as in &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;. However, it will also work to omit &lt;code&gt;ORDER BY&lt;/code&gt; and just run the direct and aggregated argument specifications into a single list. In this abbreviated form, if &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; was used in both the direct and aggregated argument lists, write &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; only once.</source>
          <target state="translated">순서 집합 집계를 참조하기 위해 권장되는 구문 은 &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; 와 동일한 스타일로 직접 및 집계 인수 스펙 사이에 &lt;code&gt;ORDER BY&lt;/code&gt; 를 작성 하는 것 입니다. 그러나 &lt;code&gt;ORDER BY&lt;/code&gt; 를 생략 하고 직접 집계 된 인수 사양을 단일 목록으로 실행하기도합니다. 이 축약 된 형태에서, 경우 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 모두 직접 및 집계 인수 목록을 사용, 쓰기 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 한 번만.</target>
        </trans-unit>
        <trans-unit id="2c54b57bbcf06dd2c13692d0332c35778b6cad50" translate="yes" xml:space="preserve">
          <source>The recursive query evaluation algorithm produces its output in breadth-first search order. You can display the results in depth-first search order by making the outer query &lt;code&gt;ORDER BY&lt;/code&gt; a &amp;ldquo;path&amp;rdquo; column constructed in this way.</source>
          <target state="translated">재귀 쿼리 평가 알고리즘은 너비 우선 검색 순서로 출력을 생성합니다. 외부 쿼리 &lt;code&gt;ORDER BY&lt;/code&gt; 를 이런 방식으로 구성된 &quot;경로&quot;열로 만들어 결과를 깊이 우선 검색 순서로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10c71ff4aa80650437aaee9d5a8e7f1f079dae18" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned as the target of a dependent policy object.</source>
          <target state="translated">참조 된 오브젝트 (역할이어야 함)는 종속 정책 오브젝트의 대상으로 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="c023a7885506a46d5cd80a1b95eea9a1b30194d8" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned in the ACL (access control list, i.e., privileges list) of the dependent object. (A &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; entry is not made for the owner of the object, since the owner will have a &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; entry anyway.)</source>
          <target state="translated">참조 된 객체 (역할이어야 함)는 종속 객체의 ACL (액세스 제어 목록, 즉 권한 목록)에 언급되어 있습니다. ( 어쨌든 소유자는 &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; 항목 을 가지므로 &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; 항목은 오브젝트 소유자에 대해 작성되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="b0815ccf510952893128b6ac3763e885ed6f0544" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is the owner of the dependent object.</source>
          <target state="translated">참조 된 객체 (역할이어야 함)는 종속 객체의 소유자입니다.</target>
        </trans-unit>
        <trans-unit id="a3a42d2bcdc41726ac7929beb724897943cebede" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="translated">XQuery에 의해 정의 된 정규식 플래그 문자는 POSIX의 옵션 문자와 관련이 있지만 동일하지는 않습니다 ( &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23&lt;/a&gt; ). &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;q&lt;/code&gt; 옵션은 동일하게 작동 하지만 다른 옵션은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae81b35c4a3c7dab3568d7bb9b480ebd9e7e6d71" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="translated">The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</target>
        </trans-unit>
        <trans-unit id="ba9e7d00d7dfab39d193126f7366a926fa396e54" translate="yes" xml:space="preserve">
          <source>The relevant files have to be installed into &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; and a summary of them into &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt;, where &lt;code&gt;$pkglibdir&lt;/code&gt; is the directory returned by &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; and &lt;code&gt;$extension&lt;/code&gt; is the base name of the extension's shared library.</source>
          <target state="translated">관련 파일은 &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; 설치하고 $ pkglibdir / bitcode / $ extension.index.bc 에 요약해야 &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt; . 여기서 &lt;code&gt;$pkglibdir&lt;/code&gt; 은 &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; 에 의해 반환되는 디렉토리 이며 &lt;code&gt;$extension&lt;/code&gt; 은 확장 공유 라이브러리의 기본 이름</target>
        </trans-unit>
        <trans-unit id="6ba726b7abb409f8a48dfda787ffd9ea8e7624bd" translate="yes" xml:space="preserve">
          <source>The relevant settings can be changed in &lt;code&gt;/etc/system&lt;/code&gt;, for example:</source>
          <target state="translated">관련 설정은 &lt;code&gt;/etc/system&lt;/code&gt; 에서 다음과 같이 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fd56dd803d0f7d0e1d83485ba93a1ea518a48b4" translate="yes" xml:space="preserve">
          <source>The remaining defaults are quite generously sized, and usually do not require changes.</source>
          <target state="translated">나머지 기본값은 상당히 넉넉하며 일반적으로 변경하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="e214a53b19603c5bd3de31f71ebb545b28127eb2" translate="yes" xml:space="preserve">
          <source>The remaining five input formats are not part of any standard.</source>
          <target state="translated">나머지 5 개의 입력 형식은 표준의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a23206cc28b1e52f80477ca74330c7ee7d48a063" translate="yes" xml:space="preserve">
          <source>The remaining forms change the session default for a run-time configuration variable for a PostgreSQL database. Whenever a new session is subsequently started in that database, the specified value becomes the session default value. The database-specific default overrides whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. Only the database owner or a superuser can change the session defaults for a database. Certain variables cannot be set this way, or can only be set by a superuser.</source>
          <target state="translated">나머지 양식은 PostgreSQL 데이터베이스의 런타임 구성 변수에 대한 세션 기본값을 변경합니다. 해당 데이터베이스에서 새 세션이 이후에 시작될 때마다 지정된 값이 세션 기본값이됩니다. 데이터베이스 별 기본값은 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 있거나 &lt;code&gt;postgres&lt;/code&gt; 명령 줄 에서받은 설정을 무시 합니다. 데이터베이스 소유자 또는 수퍼 유저 만 데이터베이스의 세션 기본값을 변경할 수 있습니다. 특정 변수는 이런 식으로 설정할 수 없거나 수퍼 유저 만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="657f4dc87f97eb4fa07203598556b9c37fdd908d" translate="yes" xml:space="preserve">
          <source>The remaining locale categories can be changed later when the server is started. You can also use &lt;code&gt;--locale&lt;/code&gt; to set the default for all locale categories, including collation order and character set classes. All server locale values (&lt;code&gt;lc_*&lt;/code&gt;) can be displayed via &lt;code&gt;SHOW ALL&lt;/code&gt;. More details can be found in &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;.</source>
          <target state="translated">나머지 로케일 범주는 나중에 서버가 시작될 때 변경 될 수 있습니다. &lt;code&gt;--locale&lt;/code&gt; 을 사용 하여 데이터 정렬 순서 및 문자 집합 클래스를 포함한 모든 로캘 범주의 기본값을 설정할 수도 있습니다. 모든 서버 로캘 값 ( &lt;code&gt;lc_*&lt;/code&gt; )은 &lt;code&gt;SHOW ALL&lt;/code&gt; 을 통해 표시 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;locale&quot;&gt;섹션 23.1을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39583e46f87084afedd4c54635cee3575eddc6c6" translate="yes" xml:space="preserve">
          <source>The remaining variants change a role's session default for a configuration variable, either for all databases or, when the &lt;code&gt;IN DATABASE&lt;/code&gt; clause is specified, only for sessions in the named database. If &lt;code&gt;ALL&lt;/code&gt; is specified instead of a role name, this changes the setting for all roles. Using &lt;code&gt;ALL&lt;/code&gt; with &lt;code&gt;IN DATABASE&lt;/code&gt; is effectively the same as using the command &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt;.</source>
          <target state="translated">나머지 변형은 모든 데이터베이스 또는 &lt;code&gt;IN DATABASE&lt;/code&gt; 절이 지정된 경우 명명 된 데이터베이스의 세션에 대해서만 구성 변수의 역할 세션 기본값을 변경 합니다. 역할 이름 대신 &lt;code&gt;ALL&lt;/code&gt; 을 지정 하면 모든 역할의 설정이 변경됩니다. 사용 &lt;code&gt;ALL&lt;/code&gt; 을 함께 &lt;code&gt;IN DATABASE&lt;/code&gt; 효과적으로 명령을 사용하는 것과 같습니다 &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5290f23dd3a823420c1c9cce7d4e8058bd8eb3fa" translate="yes" xml:space="preserve">
          <source>The remaining variants change the owner and the name of the publication.</source>
          <target state="translated">나머지 변형은 소유자와 발행물의 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="fd818ebf2b83e4b29f88c818dcaf7941b628e1ea" translate="yes" xml:space="preserve">
          <source>The remote schema to import from. The specific meaning of a remote schema depends on the foreign data wrapper in use.</source>
          <target state="translated">가져올 원격 스키마. 원격 스키마의 구체적인 의미는 사용중인 외부 데이터 래퍼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c2f6cfebe2ad1dd2cbdde5a3b92b04d140d615ff" translate="yes" xml:space="preserve">
          <source>The remote transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level when the local transaction has &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level; otherwise it uses &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level. This choice ensures that if a query performs multiple table scans on the remote server, it will get snapshot-consistent results for all the scans. A consequence is that successive queries within a single transaction will see the same data from the remote server, even if concurrent updates are occurring on the remote server due to other activities. That behavior would be expected anyway if the local transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level, but it might be surprising for a &lt;code&gt;READ COMMITTED&lt;/code&gt; local transaction. A future PostgreSQL release might modify these rules.</source>
          <target state="translated">로컬 트랜잭션에 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 격리 레벨 이 있으면 원격 트랜잭션은 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 격리 레벨을 사용 합니다. 그렇지 않으면 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 격리 수준을 사용 합니다. 이 선택은 쿼리가 원격 서버에서 여러 테이블 스캔을 수행하는 경우 모든 스캔에 대해 스냅 샷 일관성있는 결과를 얻도록합니다. 그 결과 다른 활동으로 인해 원격 서버에서 동시 업데이트가 발생하더라도 단일 트랜잭션 내에서 연속 된 쿼리는 원격 서버에서 동일한 데이터를 보게됩니다. 로컬 트랜잭션이 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 또는 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 격리 수준을 사용하는 경우 어쨌든 이러한 동작이 예상 되지만 &lt;code&gt;READ COMMITTED&lt;/code&gt; 에 대해서는 놀랍습니다.현지 거래. 향후 PostgreSQL 릴리스에서 이러한 규칙을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b784ef85aba666ab41976b71fec7b8c205701bef" translate="yes" xml:space="preserve">
          <source>The reported &lt;code&gt;index_size&lt;/code&gt; will normally correspond to one more page than is accounted for by &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt;, because it also includes the index's metapage.</source>
          <target state="translated">보고 된 &lt;code&gt;index_size&lt;/code&gt; 는 일반적으로 &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt; 가 설명하는 것보다 하나 이상의 페이지에 해당합니다 . 인덱스의 메타 페이지도 포함하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="55f0c215e7b27076f4a6dfbf779db270819931cc" translate="yes" xml:space="preserve">
          <source>The reported lag times are not predictions of how long it will take for the standby to catch up with the sending server assuming the current rate of replay. Such a system would show similar times while new WAL is being generated, but would differ when the sender becomes idle. In particular, when the standby has caught up completely, &lt;code&gt;pg_stat_replication&lt;/code&gt; shows the time taken to write, flush and replay the most recent reported WAL location rather than zero as some users might expect. This is consistent with the goal of measuring synchronous commit and transaction visibility delays for recent write transactions. To reduce confusion for users expecting a different model of lag, the lag columns revert to NULL after a short time on a fully replayed idle system. Monitoring systems should choose whether to represent this as missing data, zero or continue to display the last known value.</source>
          <target state="translated">보고 된 지연 시간은 현재 재생 속도를 가정하여 대기가 송신 서버를 따라 잡는 데 걸리는 시간을 예측하지 않습니다. 이러한 시스템은 새 WAL이 생성되는 동안 비슷한 시간을 표시하지만 발신자가 유휴 상태가되면 다릅니다. 특히 대기가 완전히 종료되면 &lt;code&gt;pg_stat_replication&lt;/code&gt; 일부 사용자가 예상 할 수있는 가장 최근에보고 된 WAL 위치를 0이 아닌 쓰기, 플러시 및 재생하는 데 걸린 시간을 보여줍니다. 이는 최근 쓰기 트랜잭션에 대한 동기 커밋 및 트랜잭션 가시성 지연을 측정한다는 목표와 일치합니다. 다른 지연 모델을 기대하는 사용자의 혼동을 줄이려면 지연 시간이 완전히 재생 된 유휴 시스템에서 잠시 후 NULL로 되돌아갑니다. 모니터링 시스템은이 데이터를 결측 데이터로 표시할지, 0으로 설정하거나 마지막으로 알려진 값을 계속 표시할지 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="a645551df2ec2063cbaae776527e78ce19d49632" translate="yes" xml:space="preserve">
          <source>The representative query texts are kept in an external disk file, and do not consume shared memory. Therefore, even very lengthy query texts can be stored successfully. However, if many long query texts are accumulated, the external file might grow unmanageably large. As a recovery method if that happens, &lt;code&gt;pg_stat_statements&lt;/code&gt; may choose to discard the query texts, whereupon all existing entries in the &lt;code&gt;pg_stat_statements&lt;/code&gt; view will show null &lt;code&gt;query&lt;/code&gt; fields, though the statistics associated with each &lt;code&gt;queryid&lt;/code&gt; are preserved. If this happens, consider reducing &lt;code&gt;pg_stat_statements.max&lt;/code&gt; to prevent recurrences.</source>
          <target state="translated">대표 쿼리 텍스트는 외부 디스크 파일에 보관되며 공유 메모리를 사용하지 않습니다. 따라서 매우 긴 쿼리 텍스트도 성공적으로 저장할 수 있습니다. 그러나 많은 긴 쿼리 텍스트가 누적되면 외부 파일이 관리하기 어렵게 커질 수 있습니다. 이 경우 복구 방법으로 &lt;code&gt;pg_stat_statements&lt;/code&gt; 는 쿼리 텍스트를 버리도록 선택할 수 있으며, &lt;code&gt;pg_stat_statements&lt;/code&gt; 뷰 의 모든 기존 항목은 null &lt;code&gt;query&lt;/code&gt; 필드 를 표시 하지만 각 &lt;code&gt;queryid&lt;/code&gt; 와 관련된 통계 는 유지됩니다. 이 경우 재발을 방지하기 위해 &lt;code&gt;pg_stat_statements.max&lt;/code&gt; 를 줄이십시오 .</target>
        </trans-unit>
        <trans-unit id="af46176f2702f864ba766599fbfd240339b13483" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the column(s) that will be produced in the output table. See the syntax summary above for the format. A name is required for each column, as is a data type (unless &lt;code&gt;FOR ORDINALITY&lt;/code&gt; is specified, in which case type &lt;code&gt;integer&lt;/code&gt; is implicit). The path, default and nullability clauses are optional.</source>
          <target state="translated">The required &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the column(s) that will be produced in the output table. See the syntax summary above for the format. A name is required for each column, as is a data type (unless &lt;code&gt;FOR ORDINALITY&lt;/code&gt; is specified, in which case type &lt;code&gt;integer&lt;/code&gt; is implicit). The path, default and nullability clauses are optional.</target>
        </trans-unit>
        <trans-unit id="7e8d7c0fc3cb406e8f13266456fbfe6097e7dd7f" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression (given as &lt;code&gt;text&lt;/code&gt;) that is evaluated, passing the XML value &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="translated">The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression (given as &lt;code&gt;text&lt;/code&gt; ) that is evaluated, passing the XML value &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</target>
        </trans-unit>
        <trans-unit id="0ec95cfaa7fde5c159e36da65695933b4d1251cc" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression that is evaluated, passing the &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="translated">필수 &lt;code&gt;row_expression&lt;/code&gt; 인수는 &lt;code&gt;document_expression&lt;/code&gt; 을 컨텍스트 항목으로 전달하여 XML 노드 세트를 가져 오는 평가되는 XPath 1.0 표현식입니다 . 이러한 노드는 &lt;code&gt;xmltable&lt;/code&gt; 이 출력 행으로 변환 하는 것 입니다. &lt;code&gt;document_expression&lt;/code&gt; 이 null이거나 &lt;code&gt;row_expression&lt;/code&gt; 이 빈 노드 집합 또는 노드 집합 이외의 다른 값을 생성하는 경우 행이 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b11399ca691e0ca5b399e8672e2715124cece495" translate="yes" xml:space="preserve">
          <source>The requirement to escape &lt;em&gt;non-printable&lt;/em&gt; octets varies depending on locale settings. In some instances you can get away with leaving them unescaped.</source>
          <target state="translated">&lt;em&gt;인쇄&lt;/em&gt; 할 수 &lt;em&gt;없는&lt;/em&gt; 8 진수 를 이스케이프 처리해야하는 요구 사항 은 로캘 설정에 따라 다릅니다. 경우에 따라 이스케이프 처리하지 않은 채로 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1fdcf794bda35b8905b9d7b4d4c5b307eaf0f21" translate="yes" xml:space="preserve">
          <source>The resolution can be done either by changing data on the subscriber so that it does not conflict with the incoming change or by skipping the transaction that conflicts with the existing data. The transaction can be skipped by calling the &lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt;&lt;code&gt;pg_replication_origin_advance()&lt;/code&gt;&lt;/a&gt; function with a &lt;em&gt;&lt;code&gt;node_name&lt;/code&gt;&lt;/em&gt; corresponding to the subscription name, and a position. The current position of origins can be seen in the &lt;a href=&quot;view-pg-replication-origin-status&quot;&gt;&lt;code&gt;pg_replication_origin_status&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">수신 변경과 충돌하지 않도록 구독자에서 데이터를 변경하거나 기존 데이터와 충돌하는 트랜잭션을 건너 뛰어 해결을 수행 할 수 있습니다. 구독 이름에 해당 하는 &lt;em&gt; &lt;code&gt;node_name&lt;/code&gt; &lt;/em&gt; 및 위치 와 함께 &lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt; &lt;code&gt;pg_replication_origin_advance()&lt;/code&gt; &lt;/a&gt; 함수를 호출하여 트랜잭션을 건너 뛸 수 있습니다 . 원점의 현재 위치는 &lt;a href=&quot;view-pg-replication-origin-status&quot;&gt; &lt;code&gt;pg_replication_origin_status&lt;/code&gt; &lt;/a&gt; 시스템 뷰 에서 볼 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="723a98a8202cef2494a119e8677686ce411c0bb4" translate="yes" xml:space="preserve">
          <source>The response indicates that the large object received object ID 152801, which can be used to access the newly-created large object in the future. For the sake of readability, it is recommended to always associate a human-readable comment with every object. Both OIDs and comments can be viewed with the &lt;code&gt;\lo_list&lt;/code&gt; command.</source>
          <target state="translated">응답은 대형 오브젝트가 오브젝트 ID 152801을 수신했으며 이는 나중에 새로 작성된 대형 오브젝트에 액세스하는 데 사용될 수 있음을 나타냅니다. 가독성을 위해 항상 사람이 읽을 수있는 주석을 모든 객체와 연결하는 것이 좋습니다. Olo와 주석은 모두 &lt;code&gt;\lo_list&lt;/code&gt; 명령 으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2934d0e903001f7986e041f38eab1c8c1f288032" translate="yes" xml:space="preserve">
          <source>The restriction for the join is &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt;. The operator is just our familiar &lt;code&gt;=&lt;/code&gt;, however the selectivity function is obtained from the &lt;code&gt;oprjoin&lt;/code&gt; column of &lt;code&gt;pg_operator&lt;/code&gt;, and is &lt;code&gt;eqjoinsel&lt;/code&gt;. &lt;code&gt;eqjoinsel&lt;/code&gt; looks up the statistical information for both &lt;code&gt;tenk2&lt;/code&gt; and &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">결합 제한은 &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt; 입니다. 작업자는 단지 우리 익숙한 &lt;code&gt;=&lt;/code&gt; 그러나 선택성 함수로부터 얻어진다 &lt;code&gt;oprjoin&lt;/code&gt; 의 열에 &lt;code&gt;pg_operator&lt;/code&gt; 되고 &lt;code&gt;eqjoinsel&lt;/code&gt; . &lt;code&gt;eqjoinsel&lt;/code&gt; 은 &lt;code&gt;tenk2&lt;/code&gt; 및 &lt;code&gt;tenk1&lt;/code&gt; 에 대한 통계 정보를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="42ea840e6963b1db2f144f830a72190a8a92d8a7" translate="yes" xml:space="preserve">
          <source>The restriction on &lt;code&gt;tenk1&lt;/code&gt;, &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt;, is evaluated before the nested-loop join. This is handled analogously to the previous range example. This time the value 50 falls into the first bucket of the &lt;code&gt;unique1&lt;/code&gt; histogram:</source>
          <target state="translated">중첩 루프 조인 전에 &lt;code&gt;tenk1&lt;/code&gt; , &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt; 제한 이 평가됩니다. 이것은 이전 범위 예제와 유사하게 처리됩니다. 이번에는 값 50이 &lt;code&gt;unique1&lt;/code&gt; 히스토그램 의 첫 번째 버킷에 속합니다 .</target>
        </trans-unit>
        <trans-unit id="80154a0c17a7ca3699a207d67e1600353cb2e59b" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator.</source>
          <target state="translated">이 연산자에 대한 제한 선택성 추정 기능.</target>
        </trans-unit>
        <trans-unit id="c1e9d6876e675991a0158e89b5c587ee7ffe971a" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">이 연산자에 대한 제한 선택성 추정 기능; 기존 선택성 추정기를 제거하려면 NONE을 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="bff27a668430c02df3bea2ab6b32530d85a3310d" translate="yes" xml:space="preserve">
          <source>The result has the same type as the first argument &amp;mdash; but there is a subtlety. What is actually returned is the first argument of the implied &lt;code&gt;=&lt;/code&gt; operator, and in some cases that will have been promoted to match the second argument's type. For example, &lt;code&gt;NULLIF(1, 2.2)&lt;/code&gt; yields &lt;code&gt;numeric&lt;/code&gt;, because there is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator, only &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="translated">The result has the same type as the first argument &amp;mdash; but there is a subtlety. What is actually returned is the first argument of the implied &lt;code&gt;=&lt;/code&gt; operator, and in some cases that will have been promoted to match the second argument's type. For example, &lt;code&gt;NULLIF(1, 2.2)&lt;/code&gt; yields &lt;code&gt;numeric&lt;/code&gt; , because there is no &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; operator, only &lt;code&gt;numeric&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e176f734fe6408fc6b88696f88ea896277748c08" translate="yes" xml:space="preserve">
          <source>The result is equivalent to replacing the target data directory with the source one. Only changed blocks from relation files are copied; all other files are copied in full, including configuration files. The advantage of pg_rewind over taking a new base backup, or tools like rsync, is that pg_rewind does not require reading through unchanged blocks in the cluster. This makes it a lot faster when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="translated">결과는 대상 데이터 디렉토리를 소스 디렉토리로 바꾸는 것과 같습니다. 관계 파일에서 변경된 블록 만 복사됩니다. 구성 파일을 포함하여 다른 모든 파일이 완전히 복사됩니다. 새로운 기본 백업 또는 rsync와 같은 도구를 사용하는 것보다 pg_rewind의 장점은 pg_rewind가 클러스터에서 변경되지 않은 블록을 읽을 필요가 없다는 것입니다. 따라서 데이터베이스가 크거나 클러스터간에 블록의 일부분 만 다른 경우 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="71c257a34cf97f05e33ccd5803182c14ff7c7772" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="465e9b5b70493d1bded19fc1f9a4a0487651fc46" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear max(&lt;code&gt;m&lt;/code&gt;-&lt;code&gt;n&lt;/code&gt;,0) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; 옵션을 지정 하지 않으면 &lt;code&gt;EXCEPT&lt;/code&gt; 의 결과에 중복 행이 포함되지 않습니다 . &lt;code&gt;ALL&lt;/code&gt; 을 사용하면 왼쪽 테이블에 &lt;code&gt;m&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 복제본이 있고 오른쪽 테이블에 n 개의 복제본 이있는 행 은 결과 집합에 최대 ( &lt;code&gt;m&lt;/code&gt; - &lt;code&gt;n&lt;/code&gt; , 0) 번 나타납니다 . 중복 행을 제거하는 기본 동작을 명시 적으로 지정하기 위해 &lt;code&gt;DISTINCT&lt;/code&gt; 를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e065829e339ca2263a957857644dcd1c568a754" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;INTERSECT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear min(&lt;code&gt;m&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; 옵션을 지정 하지 않으면 &lt;code&gt;INTERSECT&lt;/code&gt; 의 결과에 중복 행이 포함되지 않습니다 . &lt;code&gt;ALL&lt;/code&gt; 을 사용하면 왼쪽 테이블에 &lt;code&gt;m&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 복제본이 있고 오른쪽 테이블에 n 개의 복제본 이있는 행 은 결과 집합에 min ( &lt;code&gt;m&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; ) 번 나타납니다 . 중복 행을 제거하는 기본 동작을 명시 적으로 지정하기 위해 &lt;code&gt;DISTINCT&lt;/code&gt; 를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ef35ef4ee4e7ace61e6bdb22721c0932c911c40" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;UNION&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. &lt;code&gt;ALL&lt;/code&gt; prevents elimination of duplicates. (Therefore, &lt;code&gt;UNION ALL&lt;/code&gt; is usually significantly quicker than &lt;code&gt;UNION&lt;/code&gt;; use &lt;code&gt;ALL&lt;/code&gt; when you can.) &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; 옵션을 지정 하지 않으면 &lt;code&gt;UNION&lt;/code&gt; 의 결과에 중복 행이 포함되지 않습니다 . &lt;code&gt;ALL&lt;/code&gt; 은 중복 제거를 방지합니다. 따라서 &lt;code&gt;UNION ALL&lt;/code&gt; 은 일반적으로 &lt;code&gt;UNION&lt;/code&gt; 보다 훨씬 빠릅니다 . 가능하면 &lt;code&gt;ALL&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;DISTINCT&lt;/code&gt; 를 작성하여 중복 행을 제거하는 기본 동작을 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72402b7b0b331fd1b54d5308fde49885c6b05ef8" translate="yes" xml:space="preserve">
          <source>The result of a database content mapping looks like this:</source>
          <target state="translated">데이터베이스 컨텐츠 맵핑의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5bf0f22088cf3019c1a1b1dbed662be7a69e9148" translate="yes" xml:space="preserve">
          <source>The result of a schema content mapping looks like this:</source>
          <target state="translated">스키마 컨텐츠 맵핑의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31f7fafc96662c4abec5838f93938c08f12e39f5" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get an array size:</source>
          <target state="translated">각 경로 평가 단계의 결과는 &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;섹션 9.15.2.3에&lt;/a&gt; 나열된 하나 이상의 &lt;code&gt;jsonpath&lt;/code&gt; 연산자 및 방법 으로 처리 할 수 ​​있습니다 . 각 메소드 이름 앞에는 점이 있어야합니다. 예를 들어 배열 크기를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec7ce6cfc1de15ad9d69c5a41b7880b123d8687e" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get the size of an array:</source>
          <target state="translated">The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get the size of an array:</target>
        </trans-unit>
        <trans-unit id="2c39389298dad4176af2cd2f4f928038308a6b18" translate="yes" xml:space="preserve">
          <source>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</source>
          <target state="translated">트랜잭션 그룹을 성공적으로 커밋 한 결과는 해당 트랜잭션을 한 번에 하나씩 실행하는 모든 가능한 순서와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f90d6b2c73e8ea4c0551da0df475a8d425331eb2" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;union&lt;/code&gt; function must be a value of the index's storage type, whatever that is (it might or might not be different from the indexed column's type). The &lt;code&gt;union&lt;/code&gt; function should return a pointer to newly &lt;code&gt;palloc()&lt;/code&gt;ed memory. You can't just return the input value as-is, even if there is no type change.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 함수 의 결과는 인덱스 스토리지 유형의 값 (인덱싱 된 열의 유형과 다를 수도 있고 다를 수도 있음)에 관계없이 값이어야합니다. &lt;code&gt;union&lt;/code&gt; 기능을 새롭게에 대한 포인터를 반환해야합니다 &lt;code&gt;palloc()&lt;/code&gt; 에드 메모리. 유형 변경이 없더라도 입력 값을 그대로 반환 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b294fef53c3a5221592cc68d2bcc8aa48d712cd" translate="yes" xml:space="preserve">
          <source>The result of the function is a single record. The &lt;em&gt;&lt;code&gt;lsn&lt;/code&gt;&lt;/em&gt; column holds the backup's ending write-ahead log location (which again can be ignored). The second and third columns are &lt;code&gt;NULL&lt;/code&gt; when ending an exclusive backup; after a non-exclusive backup they hold the desired contents of the label and tablespace map files.</source>
          <target state="translated">The result of the function is a single record. The &lt;em&gt; &lt;code&gt;lsn&lt;/code&gt; &lt;/em&gt; column holds the backup's ending write-ahead log location (which again can be ignored). The second and third columns are &lt;code&gt;NULL&lt;/code&gt; when ending an exclusive backup; after a non-exclusive backup they hold the desired contents of the label and tablespace map files.</target>
        </trans-unit>
        <trans-unit id="b4a9c39c953a9312145a45ccbb983953c2e08ee1" translate="yes" xml:space="preserve">
          <source>The result of the previous two inserts looks like this:</source>
          <target state="translated">이전 두 인서트의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b464f588a5c51e3217548207540b5bba236a02d5" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;setval&lt;/code&gt; is just the value of its second argument.</source>
          <target state="translated">&lt;code&gt;setval&lt;/code&gt; 이 리턴 한 결과 는 두 번째 인수의 값일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="94a3bc7cb16b6aa14b4272070826c46eaa5db71f" translate="yes" xml:space="preserve">
          <source>The result type of the &lt;code&gt;datetime()&lt;/code&gt; and &lt;code&gt;datetime(template)&lt;/code&gt; methods can be &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;timetz&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamptz&lt;/code&gt;, or &lt;code&gt;timestamp&lt;/code&gt;. Both methods determine their result type dynamically.</source>
          <target state="translated">The result type of the &lt;code&gt;datetime()&lt;/code&gt; and &lt;code&gt;datetime(template)&lt;/code&gt; methods can be &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;timetz&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamptz&lt;/code&gt; , or &lt;code&gt;timestamp&lt;/code&gt; . Both methods determine their result type dynamically.</target>
        </trans-unit>
        <trans-unit id="5675fc85ce2eab9d13414767f82a9b7b9d9a68bc" translate="yes" xml:space="preserve">
          <source>The resulting dump can be restored with psql:</source>
          <target state="translated">결과 덤프는 psql로 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd98dcbc013dfe386ef25cd013047250a70319f2" translate="yes" xml:space="preserve">
          <source>The results of the &lt;code&gt;in_range&lt;/code&gt; function must be consistent with the sort ordering imposed by the operator family. To be precise, given any fixed values of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;sub&lt;/code&gt;, then:</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 함수 의 결과 는 연산자 제품군이 부과 한 정렬 순서와 일치해야합니다. 고정 된 &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;sub&lt;/code&gt; 값이 있으면 다음 과 같이 정확합니다 .</target>
        </trans-unit>
        <trans-unit id="09c3bbabf641766b5c1086657a825502c1601a40" translate="yes" xml:space="preserve">
          <source>The results of two queries can be combined using the set operations union, intersection, and difference. The syntax is</source>
          <target state="translated">두 가지 쿼리의 결과는 집합 연산 조합, 교차 및 차이를 사용하여 결합 할 수 있습니다. 문법은</target>
        </trans-unit>
        <trans-unit id="6af5cccdc36b9ba47ebe00f94b9f0ae450f2173e" translate="yes" xml:space="preserve">
          <source>The return data type (optionally schema-qualified). The return type can be a base, composite, or domain type, or can reference the type of a table column. Depending on the implementation language it might also be allowed to specify &amp;ldquo;pseudo-types&amp;rdquo; such as &lt;code&gt;cstring&lt;/code&gt;. If the function is not supposed to return a value, specify &lt;code&gt;void&lt;/code&gt; as the return type.</source>
          <target state="translated">리턴 데이터 유형 (선택적으로 스키마 규정). 리턴 유형은 기본, 복합 또는 도메인 유형이거나 테이블 열의 유형을 참조 할 수 있습니다. 구현 언어에 따라 &lt;code&gt;cstring&lt;/code&gt; 과 같은 &quot;의사 유형&quot;을 지정할 수도 있습니다 . 함수가 값을 리턴하지 않으면 &lt;code&gt;void&lt;/code&gt; 를 리턴 유형으로 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="68f515e9225e3a8bd926fdcf278047adb080a143" translate="yes" xml:space="preserve">
          <source>The return type of a cast function must be identical to or binary-coercible to the cast's target type.</source>
          <target state="translated">캐스트 함수의 리턴 유형은 캐스트의 대상 유형과 동일하거나 2 진 변환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="e79b9ffc9a06ade0f94c181bff76d0c5e0055f02" translate="yes" xml:space="preserve">
          <source>The return type of each function is &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">각 함수의 반환 유형은 &lt;code&gt;xml&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ccb6d89ec3d8d5f1a14886d00086edc74d4f798" translate="yes" xml:space="preserve">
          <source>The return value is static information about an operator class and collation. Returning &lt;code&gt;true&lt;/code&gt; indicates that the &lt;code&gt;order&lt;/code&gt; function for the operator class is guaranteed to only return &lt;code&gt;0&lt;/code&gt; (&amp;ldquo;arguments are equal&amp;rdquo;) when its &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arguments are also interchangeable without any loss of semantic information. Not registering an &lt;code&gt;equalimage&lt;/code&gt; function or returning &lt;code&gt;false&lt;/code&gt; indicates that this condition cannot be assumed to hold.</source>
          <target state="translated">The return value is static information about an operator class and collation. Returning &lt;code&gt;true&lt;/code&gt; indicates that the &lt;code&gt;order&lt;/code&gt; function for the operator class is guaranteed to only return &lt;code&gt;0&lt;/code&gt; (&amp;ldquo;arguments are equal&amp;rdquo;) when its &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arguments are also interchangeable without any loss of semantic information. Not registering an &lt;code&gt;equalimage&lt;/code&gt; function or returning &lt;code&gt;false&lt;/code&gt; indicates that this condition cannot be assumed to hold.</target>
        </trans-unit>
        <trans-unit id="ae53d800dbf466337096571156e983ea2cef4a1a" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;BrinMemTuple&lt;/code&gt; and &lt;code&gt;BrinValues&lt;/code&gt; structs. See &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; for details.</source>
          <target state="translated">반환 된 열은 &lt;code&gt;BrinMemTuple&lt;/code&gt; 및 &lt;code&gt;BrinValues&lt;/code&gt; 구조체 의 필드에 해당 합니다. 자세한 내용은 &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cbe5a0ea635cc6baf516f6e2eb370c36b529a917" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;PageHeaderData&lt;/code&gt; struct. See &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; for details.</source>
          <target state="translated">반환 된 열은 &lt;code&gt;PageHeaderData&lt;/code&gt; 구조체 의 필드에 해당합니다 . 자세한 내용은 &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ce8dcca026fdd1326a0feb6d5dcbe4fd79aa2a7" translate="yes" xml:space="preserve">
          <source>The rewriting forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; are not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred. See &lt;a href=&quot;mvcc-caveats&quot;&gt;Section 13.5&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; 의 다시 쓰기 양식은 MVCC 안전하지 않습니다. 테이블을 다시 쓴 후에는 테이블이 다시 쓰기 전에 스냅 샷을 사용하는 경우 동시 트랜잭션에 대해 비어있는 것으로 나타납니다. 자세한 내용 &lt;a href=&quot;mvcc-caveats&quot;&gt;은 13.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9dd9c3f397a07f60ffdbedaa5659c2ca90ab6d90" translate="yes" xml:space="preserve">
          <source>The right to drop an object, or to alter its definition in any way, is not treated as a grantable privilege; it is inherent in the owner, and cannot be granted or revoked. (However, a similar effect can be obtained by granting or revoking membership in the role that owns the object; see below.) The owner implicitly has all grant options for the object, too.</source>
          <target state="translated">어떤 방식 으로든 객체를 떨어 뜨리거나 정의를 변경할 수있는 권리는 허용 가능한 특권으로 취급되지 않습니다. 소유자에 내재되어 있으며 부여하거나 취소 할 수 없습니다. 그러나 개체를 소유 한 역할의 멤버 자격을 부여하거나 취소하면 비슷한 효과를 얻을 수 있습니다 (아래 참조). 소유자는 개체에 대한 모든 부여 옵션도 암시 적으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1485f3d0af50f7ad2c38bab6ab4b82f7cade74e8" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is always the privilege of the owner only.</source>
          <target state="translated">객체를 수정하거나 파기 할 권리는 항상 소유자의 특권입니다.</target>
        </trans-unit>
        <trans-unit id="081b4bb5f9bb63c56a6d0ef4a59ec5296ea9be8b" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is inherent in being the object's owner, and cannot be granted or revoked in itself. (However, like all privileges, that right can be inherited by members of the owning role; see &lt;a href=&quot;role-membership&quot;&gt;Section 21.3&lt;/a&gt;.)</source>
          <target state="translated">The right to modify or destroy an object is inherent in being the object's owner, and cannot be granted or revoked in itself. (However, like all privileges, that right can be inherited by members of the owning role; see &lt;a href=&quot;role-membership&quot;&gt;Section 21.3&lt;/a&gt;.)</target>
        </trans-unit>
        <trans-unit id="a4b02a1fae471a2cfa0b9f0f9afcb866f7eeb267" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all comparisons yield true (including the case where the array has zero elements). The result is &amp;ldquo;false&amp;rdquo; if any false result is found.</source>
          <target state="translated">오른쪽은 괄호로 묶은 표현식으로, 배열 값을 가져와야합니다. 주어진 &lt;code&gt;operator&lt;/code&gt; 사용하여 왼쪽 표현식을 평가하고 배열의 각 요소와 비교 하여 부울 결과를 생성해야합니다. 모든 비교 결과 가 true 인 경우 (배열에 요소가없는 경우 포함) &lt;code&gt;ALL&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 잘못된 결과가 발견되면 결과는 &quot;거짓&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0854056fb124d8ec388aaba4b2f113f43a992144" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the array has zero elements).</source>
          <target state="translated">오른쪽은 괄호로 묶은 표현식으로, 배열 값을 가져와야합니다. 주어진 &lt;code&gt;operator&lt;/code&gt; 사용하여 왼쪽 표현식을 평가하고 배열의 각 요소와 비교 하여 부울 결과를 생성해야합니다. 진정한 결과를 얻으면 &lt;code&gt;ANY&lt;/code&gt; 의 결과 는&amp;ldquo;참&amp;rdquo;입니다. 실제 결과가없는 경우 결과는 &quot;false&quot;입니다 (배열에 요소가없는 경우 포함).</target>
        </trans-unit>
        <trans-unit id="4cadd4592ac992256e9ca190e2ede2776b0f06bb" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is equal to any of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">오른쪽은 괄호로 묶은 스칼라 식 목록입니다. 왼쪽 표현식의 결과가 오른쪽 표현식 중 하나와 같으면 결과는 &quot;true&quot;입니다. 이것은 속기 표기법입니다</target>
        </trans-unit>
        <trans-unit id="9a6bece97382db0f9b6ad5060523f2f32e422503" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is unequal to all of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">오른쪽은 괄호로 묶은 스칼라 식 목록입니다. 왼쪽 표현식의 결과가 모든 오른쪽 표현식과 다르면 결과는 &quot;참&quot;입니다. 이것은 속기 표기법입니다</target>
        </trans-unit>
        <trans-unit id="4623e53b09512588ad13e7eaadc6e34f6d36d750" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all rows yield true (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any false result is found. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">오른쪽은 괄호로 묶인 하위 쿼리이며 정확히 하나의 열을 반환해야합니다. 왼쪽 &lt;code&gt;operator&lt;/code&gt; 는 주어진 연산자를 사용하여 하위 쿼리 결과의 각 행과 비교하여 평가되며 부울 결과를 생성해야합니다. 하위 쿼리가 행을 반환하지 않는 경우를 포함하여 모든 행이 true를 생성하면 &lt;code&gt;ALL&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 잘못된 결과가 발견되면 결과는 &quot;거짓&quot;입니다. 서브 쿼리 행과의 비교가 false를 리턴하지 않으면 결과는 NULL이며, 하나 이상의 비교가 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="89b47774fd6157f8ca176076b1ed18f995c2daef" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the subquery returns no rows).</source>
          <target state="translated">오른쪽은 괄호로 묶인 하위 쿼리이며 정확히 하나의 열을 반환해야합니다. 왼쪽 &lt;code&gt;operator&lt;/code&gt; 는 주어진 연산자를 사용하여 하위 쿼리 결과의 각 행과 비교하여 평가되며 부울 결과를 생성해야합니다. 진정한 결과를 얻으면 &lt;code&gt;ANY&lt;/code&gt; 의 결과 는&amp;ldquo;참&amp;rdquo;입니다. 하위 결과가 행을 반환하지 않는 경우를 포함하여 실제 결과가 없으면 결과는 &quot;거짓&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a7873b5839bfc7065dc6edeb7940049a4cb53216" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">오른쪽은 괄호로 묶인 하위 쿼리이며 정확히 하나의 열을 반환해야합니다. 왼쪽 표현식이 평가되어 서브 쿼리 결과의 각 행과 비교됩니다. 동일한 하위 쿼리 행이 있으면 &lt;code&gt;IN&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 동일한 행이 없으면 하위 쿼리가 행을 반환하지 않는 경우를 포함하여 결과는 &quot;false&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0ca2d475edb7fe77a4b6be61177af0a4c222988e" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">오른쪽은 괄호로 묶인 하위 쿼리이며 정확히 하나의 열을 반환해야합니다. 왼쪽 표현식이 평가되어 서브 쿼리 결과의 각 행과 비교됩니다. 부질의가있는 서브 쿼리 행만 발견되면 (서브 쿼리가 행을 리턴하지 않는 경우 포함) &lt;code&gt;NOT IN&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 동일한 행이 있으면 결과는 &quot;false&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="60ffe49fd73a1dfeb0ff0a3cd27bc012700f7f66" translate="yes" xml:space="preserve">
          <source>The risk that is taken by using asynchronous commit is of data loss, not data corruption. If the database should crash, it will recover by replaying WAL up to the last record that was flushed. The database will therefore be restored to a self-consistent state, but any transactions that were not yet flushed to disk will not be reflected in that state. The net effect is therefore loss of the last few transactions. Because the transactions are replayed in commit order, no inconsistency can be introduced &amp;mdash; for example, if transaction B made changes relying on the effects of a previous transaction A, it is not possible for A's effects to be lost while B's effects are preserved.</source>
          <target state="translated">비동기 커밋을 사용하면 데이터가 손상되지 않고 데이터가 손실 될 수 있습니다. 데이터베이스가 중단되면 마지막으로 플러시 된 레코드까지 WAL을 재생하여 복구합니다. 따라서 데이터베이스는 일관된 상태로 복원되지만 아직 디스크로 플러시되지 않은 트랜잭션은 해당 상태에 반영되지 않습니다. 결과적으로 마지막 몇 트랜잭션의 손실이 발생합니다. 트랜잭션이 커밋 순서로 재생되기 때문에 불일치가 발생할 수 없습니다. 예를 들어, 트랜잭션 B가 이전 트랜잭션 A의 효과에 따라 변경 한 경우 B의 효과는 유지되지만 A의 효과는 손실 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="458aee8243a88af8890a3686268fbeeebdc768b4" translate="yes" xml:space="preserve">
          <source>The role attributes &lt;code&gt;LOGIN&lt;/code&gt;, &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;CREATEDB&lt;/code&gt;, and &lt;code&gt;CREATEROLE&lt;/code&gt; can be thought of as special privileges, but they are never inherited as ordinary privileges on database objects are. You must actually &lt;code&gt;SET ROLE&lt;/code&gt; to a specific role having one of these attributes in order to make use of the attribute. Continuing the above example, we might choose to grant &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; to the &lt;code&gt;admin&lt;/code&gt; role. Then a session connecting as role &lt;code&gt;joe&lt;/code&gt; would not have these privileges immediately, only after doing &lt;code&gt;SET ROLE admin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LOGIN&lt;/code&gt; , &lt;code&gt;SUPERUSER&lt;/code&gt; , &lt;code&gt;CREATEDB&lt;/code&gt; 및 &lt;code&gt;CREATEROLE&lt;/code&gt; 역할 속성 은 특수 권한으로 생각할 수 있지만 데이터베이스 오브젝트에 대한 일반 권한으로 상속되지는 않습니다. 속성을 사용 하려면 실제로 이러한 속성 중 하나를 갖는 특정 역할로 &lt;code&gt;SET ROLE&lt;/code&gt; 을 설정 해야 합니다. 위의 예제를 계속하여 &lt;code&gt;CREATEDB&lt;/code&gt; 및 &lt;code&gt;CREATEROLE&lt;/code&gt; 을 &lt;code&gt;admin&lt;/code&gt; 역할 에 부여하도록 선택할 수 있습니다 . 그러면 &lt;code&gt;joe&lt;/code&gt; 역할로 연결되는 세션 은 &lt;code&gt;SET ROLE admin&lt;/code&gt; 을 수행 한 후에 만 ​​이러한 권한을 갖지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="cc4f14a678d35107865a506875d403f1fabcef04" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default (namely, the user executing the command). To create a database owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">새 데이터베이스를 소유 할 사용자의 역할 이름 또는 &lt;code&gt;DEFAULT&lt;/code&gt; 을 사용하는 DEFAULT (즉, 명령을 실행하는 사용자) 다른 역할이 소유 한 데이터베이스를 만들려면 해당 역할의 직접 또는 간접 구성원이거나 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e0cd094fcb28a6d1c971a4fe5ea4b6668f0b2297" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new schema. If omitted, defaults to the user executing the command. To create a schema owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">새 스키마를 소유 할 사용자의 역할 이름입니다. 생략하면 기본적으로 명령을 실행하는 사용자가됩니다. 다른 역할이 소유 한 스키마를 만들려면 해당 역할의 직접 또는 간접 구성원이거나 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="288659e152f65b17d46027cdd207a204fb13225f" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="translated">복제 연결에 사용되는 역할에는 &lt;code&gt;REPLICATION&lt;/code&gt; 속성이 있거나 수퍼 유저 여야합니다. 역할에 대한 액세스는 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 구성 되어야하며 &lt;code&gt;LOGIN&lt;/code&gt; 속성 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ae4f6c3527bb773eca24ae98fe7bc2235694a76b" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). If the role lacks &lt;code&gt;SUPERUSER&lt;/code&gt; and &lt;code&gt;BYPASSRLS&lt;/code&gt;, publisher row security policies can execute. If the role does not trust all table owners, include &lt;code&gt;options=-crow_security=off&lt;/code&gt; in the connection string; if a table owner then adds a row security policy, that setting will cause replication to halt rather than execute the policy. Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="translated">The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). If the role lacks &lt;code&gt;SUPERUSER&lt;/code&gt; and &lt;code&gt;BYPASSRLS&lt;/code&gt; , publisher row security policies can execute. If the role does not trust all table owners, include &lt;code&gt;options=-crow_security=off&lt;/code&gt; in the connection string; if a table owner then adds a row security policy, that setting will cause replication to halt rather than execute the policy. Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</target>
        </trans-unit>
        <trans-unit id="7270c8298ccd5ab28e0386f721a4bd64642b81f5" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy applies. Multiple roles can be specified at one time. To apply the policy to all roles, use &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">정책이 적용되는 역할. 한 번에 여러 역할을 지정할 수 있습니다. 정책을 모든 역할에 적용하려면 &lt;code&gt;PUBLIC&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="672dc56056e4468fca330096a6f7988e99426d64" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy is to be applied. The default is &lt;code&gt;PUBLIC&lt;/code&gt;, which will apply the policy to all roles.</source>
          <target state="translated">정책을 적용 할 역할. 기본값은 &lt;code&gt;PUBLIC&lt;/code&gt; 이며 모든 역할에 정책을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="da08283627fb6b277f73d5b0ddf0372ed6cb0f5d" translate="yes" xml:space="preserve">
          <source>The roles to which the policy is applied</source>
          <target state="translated">정책이 적용되는 역할</target>
        </trans-unit>
        <trans-unit id="0b502eae099c8f10d1ed4ef0c354669f63bce361" translate="yes" xml:space="preserve">
          <source>The roles to which this policy applies</source>
          <target state="translated">이 정책이 적용되는 역할</target>
        </trans-unit>
        <trans-unit id="acd6a9c4a0e56d2f8f09c7b30b75a454cb6c1d08" translate="yes" xml:space="preserve">
          <source>The rows considered by a window function are those of the &amp;ldquo;virtual table&amp;rdquo; produced by the query's &lt;code&gt;FROM&lt;/code&gt; clause as filtered by its &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses if any. For example, a row removed because it does not meet the &lt;code&gt;WHERE&lt;/code&gt; condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways using different &lt;code&gt;OVER&lt;/code&gt; clauses, but they all act on the same collection of rows defined by this virtual table.</source>
          <target state="translated">창 함수에 의해 고려되는 행 은 &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절이 필터링 된 경우 쿼리의 &lt;code&gt;FROM&lt;/code&gt; 절에 의해 생성 된 &quot;가상 테이블&quot;의 행 입니다. 예를 들어, &lt;code&gt;WHERE&lt;/code&gt; 조건을 충족하지 않아서 행이 제거되면 창 기능이 보이지 않습니다. 쿼리에는 다른 &lt;code&gt;OVER&lt;/code&gt; 절을 사용하여 다른 방식으로 데이터를 분리하는 여러 개의 창 함수가 포함될 수 있지만이 가상 테이블에 의해 정의 된 동일한 행 컬렉션에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ac9a42afd27bb82c7fefe7d8456c8e56005d3e20" translate="yes" xml:space="preserve">
          <source>The rows skipped by an &lt;code&gt;OFFSET&lt;/code&gt; clause still have to be computed inside the server; therefore a large &lt;code&gt;OFFSET&lt;/code&gt; might be inefficient.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; 절에서 건너 뛴 행은 여전히 서버 내부에서 계산되어야합니다. 따라서 큰 &lt;code&gt;OFFSET&lt;/code&gt; 이 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c6595d74dd986e8e704f616ce70f02f89a3b6e5" translate="yes" xml:space="preserve">
          <source>The rule firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;, analogous to triggers as described above.</source>
          <target state="translated">규칙 발생 메커니즘은 위에서 설명한 트리거와 유사한 구성 변수 &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role의&lt;/a&gt; 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="77cbd29a44e08d42c19c09374140fe6b3a2c7eb5" translate="yes" xml:space="preserve">
          <source>The rules file has the following format:</source>
          <target state="translated">규칙 파일의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20f26d0e3be07fc8411c53cf4fec028b4fb7ddc1" translate="yes" xml:space="preserve">
          <source>The rules given in the preceding sections will result in assignment of non-&lt;code&gt;unknown&lt;/code&gt; data types to all expressions in a SQL query, except for unspecified-type literals that appear as simple output columns of a &lt;code&gt;SELECT&lt;/code&gt; command. For example, in</source>
          <target state="translated">이전 섹션에 제공된 규칙 은 &lt;code&gt;SELECT&lt;/code&gt; 명령 의 단순 출력 열로 표시되는 지정되지 않은 유형 리터럴을 제외하고 SQL 쿼리의 모든 표현식에 &lt;code&gt;unknown&lt;/code&gt; 데이터 유형을 할당 합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a710b4d0128d22b5baa147d345de94a14b25c08a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;1...2&lt;/code&gt;, or &lt;code&gt;1 .. 2&lt;/code&gt;, or &lt;code&gt;1..2&lt;/code&gt; (spaces around the range operator are ignored)</source>
          <target state="translated">동일하게 &lt;code&gt;1...2&lt;/code&gt; , 또는 &lt;code&gt;1 .. 2&lt;/code&gt; , 또는 &lt;code&gt;1..2&lt;/code&gt; (범위 운전자 주위 공간이 무시된다)</target>
        </trans-unit>
        <trans-unit id="e6e201d82f084cc5d95195c10944ee93631d8df0" translate="yes" xml:space="preserve">
          <source>The same, and also reset any associated sequence generators:</source>
          <target state="translated">동일하며 관련 시퀀스 생성기를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="241b8d226e8b5f79ed0ec6888a0ce004af81b21c" translate="yes" xml:space="preserve">
          <source>The same, but counting only word occurrences with weight &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">동일하지만 가중치가 &lt;code&gt;A&lt;/code&gt; 또는 &lt;code&gt;B&lt;/code&gt; 인 단어 발생 횟수 만 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d2d2e57444e30e19980ec9c24adfc53e9305e592" translate="yes" xml:space="preserve">
          <source>The same, but only execute the function if column &lt;code&gt;balance&lt;/code&gt; is specified as a target in the &lt;code&gt;UPDATE&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; 명령 에서 컬럼 &lt;code&gt;balance&lt;/code&gt; 가 대상으로 지정된 경우에만 동일하지만 함수를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="002437cb1427716a633526fb7913d4100317c440" translate="yes" xml:space="preserve">
          <source>The same, specified as a table constraint:</source>
          <target state="translated">동일하며 테이블 제약 조건으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="788d460ac0c5a82665dae9bd0fa72bfb74260b32" translate="yes" xml:space="preserve">
          <source>The same, using regular expression notation to consolidate the switches:</source>
          <target state="translated">정규식 표기법을 사용하여 스위치를 통합하는 것도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="bfae0e75e1b6288495d53b506d9a241bf9d03b6d" translate="yes" xml:space="preserve">
          <source>The same, when the column has a default expression that won't automatically cast to the new data type:</source>
          <target state="translated">열에 새 데이터 유형으로 자동 캐스트되지 않는 기본 표현식이있는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="d799562b98253554741c727e0742611d0f2a5b8b" translate="yes" xml:space="preserve">
          <source>The sample results shown on this page assume that the server parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;&lt;code&gt;bytea_output&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;escape&lt;/code&gt; (the traditional PostgreSQL format).</source>
          <target state="translated">이 페이지에 표시된 샘플 결과 는 &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt; &lt;code&gt;bytea_output&lt;/code&gt; &lt;/a&gt; 서버 매개 변수 가 &lt;code&gt;escape&lt;/code&gt; (일반 PostgreSQL 형식)로 설정되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="63cecb1fda6e05d04ffb99e00faba23729910dbf" translate="yes" xml:space="preserve">
          <source>The savepoint to roll back to.</source>
          <target state="translated">롤백 할 저장 점입니다.</target>
        </trans-unit>
        <trans-unit id="237920c06713568a0627b8a6cf3c35b4a6fcf5f1" translate="yes" xml:space="preserve">
          <source>The scalar ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) do not make a lot of sense for any practical purpose but sorting. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column.</source>
          <target state="translated">스칼라 순서 연산자 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 등)는 실제 목적이 아니라 정렬에있어 의미가 없습니다. 이 연산자는 먼저 첫 번째 좌표를 비교하고 두 좌표가 같은 경우 두 번째 좌표 등을 비교합니다. 주로 &lt;code&gt;cube&lt;/code&gt; 에 대한 b-tree 인덱스 연산자 클래스를 지원하기 위해 존재 합니다. 예를 들어 UNIQUE 제약 조건을 원할 경우 유용합니다. &lt;code&gt;cube&lt;/code&gt; 열입니다.</target>
        </trans-unit>
        <trans-unit id="c8365d330a7b8ee61b52ae905279178001855d43" translate="yes" xml:space="preserve">
          <source>The schema containing the &lt;code&gt;citext&lt;/code&gt; operators must be in the current &lt;code&gt;search_path&lt;/code&gt; (typically &lt;code&gt;public&lt;/code&gt;); if it is not, the normal case-sensitive &lt;code&gt;text&lt;/code&gt; operators will be invoked instead.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 연산자를 포함하는 스키마 는 현재 &lt;code&gt;search_path&lt;/code&gt; 에 있어야합니다 (일반적으로 &lt;code&gt;public&lt;/code&gt; ). 그렇지 않으면 대소 문자를 구분하는 일반 &lt;code&gt;text&lt;/code&gt; 연산자가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a1b72adef26aba98ed5b9a11c3f8d9f992851abe" translate="yes" xml:space="preserve">
          <source>The schema definitions are not replicated, and the published tables must exist on the subscriber. Only regular tables may be the target of replication. For example, you can't replicate to a view.</source>
          <target state="translated">스키마 정의는 복제되지 않으며 게시 된 테이블이 구독자에 존재해야합니다. 일반 테이블 만 복제 대상이 될 수 있습니다. 예를 들어보기로 복제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="459a237a85ce3b91cf8ef1e52361b976ab47c1f2" translate="yes" xml:space="preserve">
          <source>The schema in which the imported foreign tables will be created.</source>
          <target state="translated">가져온 외부 테이블이 작성되는 스키마입니다.</target>
        </trans-unit>
        <trans-unit id="01865c073aef636c813a71a650ffa6b695ee5717" translate="yes" xml:space="preserve">
          <source>The schemes shown here assume that the values of a row's key column(s) never change, or at least do not change enough to require it to move to another partition. An &lt;code&gt;UPDATE&lt;/code&gt; that attempts to do that will fail because of the &lt;code&gt;CHECK&lt;/code&gt; constraints. If you need to handle such cases, you can put suitable update triggers on the child tables, but it makes management of the structure much more complicated.</source>
          <target state="translated">여기에 표시된 구성표는 행의 키 열 값이 절대로 변경되지 않거나 다른 파티션으로 이동하기에 충분하도록 변경되지 않았다고 가정합니다. 이를 수행하는 &lt;code&gt;UPDATE&lt;/code&gt; 는 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건으로 인해 실패 합니다. 이러한 경우를 처리해야하는 경우 하위 테이블에 적합한 업데이트 트리거를 배치 할 수 있지만 구조 관리가 훨씬 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="ec9b55e40d83c1563492fc665bcf7be0f37fb815" translate="yes" xml:space="preserve">
          <source>The scripts can be run in any order and can be deleted once they have been run.</source>
          <target state="translated">스크립트는 임의의 순서로 실행될 수 있으며 일단 실행되면 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5351b57ec30c67488f197082c674a1ac3697572e" translate="yes" xml:space="preserve">
          <source>The search filter to use when doing search+bind authentication. Occurrences of &lt;code&gt;$username&lt;/code&gt; will be replaced with the user name. This allows for more flexible search filters than &lt;code&gt;ldapsearchattribute&lt;/code&gt;.</source>
          <target state="translated">검색 + 바인드 인증을 수행 할 때 사용할 검색 필터입니다. &lt;code&gt;$username&lt;/code&gt; 이 발생 하면 사용자 이름으로 바뀝니다. 이것은 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 보다 유연한 검색 필터를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="cc9e6cb9abd2e41c04bc258bc4b8a29867d6da64" translate="yes" xml:space="preserve">
          <source>The search path can be altered at run time. The command is:</source>
          <target state="translated">검색 경로는 런타임시 변경 될 수 있습니다. 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="478354e0ca1e05b1455044d0dbe23d731c182378" translate="yes" xml:space="preserve">
          <source>The search path works in the same way for data type names, function names, and operator names as it does for table names. Data type and function names can be qualified in exactly the same way as table names. If you need to write a qualified operator name in an expression, there is a special provision: you must write</source>
          <target state="translated">검색 경로는 데이터 유형 이름, 함수 이름 및 연산자 이름에 대해 테이블 ​​이름과 동일한 방식으로 작동합니다. 데이터 유형 및 함수 이름은 테이블 이름과 정확히 같은 방식으로 규정 될 수 있습니다. 표현식에 규정 된 연산자 이름을 작성해야하는 경우 특별한 규정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="90f585a0c61cda16f1f2f37af64c77ecb164389f" translate="yes" xml:space="preserve">
          <source>The second approach combines any authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries with the verification of client certificates by setting the &lt;code&gt;clientcert&lt;/code&gt; authentication option to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. The former option only enforces that the certificate is valid, while the latter also ensures that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the user name or an applicable mapping.</source>
          <target state="translated">두 번째 방법은 &lt;code&gt;clientcert&lt;/code&gt; 인증 옵션을 &lt;code&gt;verify-ca&lt;/code&gt; 또는 &lt;code&gt;verify-full&lt;/code&gt; 로 설정하여 &lt;code&gt;hostssl&lt;/code&gt; 항목에 대한 모든 인증 방법을 클라이언트 인증서 확인과 결합합니다 . 전자의 옵션은 인증서가 유효하도록하는 반면 인증서의 &lt;code&gt;cn&lt;/code&gt; (공통 이름)이 사용자 이름 또는 적용 가능한 매핑과 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4e7e9d77036e0c9575b0fa838e7bb55bd546fa0a" translate="yes" xml:space="preserve">
          <source>The second argument must be a well formed XML document. In particular, it must have a single root node element.</source>
          <target state="translated">두 번째 인수는 올바른 형식의 XML 문서 여야합니다. 특히 단일 루트 노드 요소가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="971af670862eab67d21e45dbeea285001e2a069e" translate="yes" xml:space="preserve">
          <source>The second example will store cities and their associated geographical location:</source>
          <target state="translated">두 번째 예는 도시와 관련 지리적 위치를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="a8fdfc2d4d4050aa9351fe7e549967c0e1502821" translate="yes" xml:space="preserve">
          <source>The second form changes the name of the database. Only the database owner or a superuser can rename a database; non-superuser owners must also have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. The current database cannot be renamed. (Connect to a different database if you need to do that.)</source>
          <target state="translated">두 번째 양식은 데이터베이스 이름을 변경합니다. 데이터베이스 소유자 또는 수퍼 유저 만 데이터베이스 이름을 바꿀 수 있습니다. 수퍼 유저가 아닌 소유자에게는 &lt;code&gt;CREATEDB&lt;/code&gt; 권한 이 있어야합니다 . 현재 데이터베이스의 이름을 바꿀 수 없습니다. 필요한 경우 다른 데이터베이스에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="5f97cd14403d43a28906f958a63aa9be74a831f3" translate="yes" xml:space="preserve">
          <source>The second form is a PostgreSQL extension. It fills the columns from the left with as many values as are given, and the rest will be defaulted.</source>
          <target state="translated">두 번째 형태는 PostgreSQL 확장입니다. 주어진 열 수만큼 왼쪽에서 열을 채우고 나머지는 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="001f55ae6b12f7691ee493402996a3cedd18d43d" translate="yes" xml:space="preserve">
          <source>The second form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates an enumerated (enum) type, as described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;. Enum types take a list of quoted labels, each of which must be less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long (64 bytes in a standard PostgreSQL build). (It is possible to create an enumerated type with zero labels, but such a type cannot be used to hold values before at least one label is added using &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; 의 두 번째 형식은 &lt;a href=&quot;datatype-enum&quot;&gt;8.7 섹션에&lt;/a&gt; 설명 된대로 열거 형 (enum) 유형을 작성합니다 . 열거 형은 따옴표로 묶인 레이블 목록을 취하며 각 레이블은 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 바이트 보다 작아야 합니다 (표준 PostgreSQL 빌드에서 64 바이트). 레이블이 0 인 열거 유형을 작성할 수 있지만 &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE을&lt;/a&gt; 사용하여 하나 이상의 레이블을 추가하기 전에 이러한 유형을 사용하여 값을 보유 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9646c72014e3dc0cdbc889805cc625cb2e00d4a4" translate="yes" xml:space="preserve">
          <source>The second implementation of the rule system is a technique called &lt;em&gt;query rewriting&lt;/em&gt;. The &lt;em&gt;rewrite system&lt;/em&gt; is a module that exists between the &lt;em&gt;parser stage&lt;/em&gt; and the &lt;em&gt;planner/optimizer&lt;/em&gt;. This technique is still implemented.</source>
          <target state="translated">규칙 시스템의 두 번째 구현은 &lt;em&gt;쿼리 다시 작성&lt;/em&gt; 이라는 기술 입니다. &lt;em&gt;재기록 시스템&lt;/em&gt; 사이에 존재하는 모듈 &lt;em&gt;파서 단계&lt;/em&gt; 및 &lt;em&gt;계획 / 최적화&lt;/em&gt; . 이 기술은 여전히 ​​구현되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b82fe6094f17ae862d5ae179aa9cdfdad11af121" translate="yes" xml:space="preserve">
          <source>The second line is the command that would be invoked in restart mode.</source>
          <target state="translated">두 번째 줄은 재시작 모드에서 호출되는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="5e54d9500bd7199e013e0c26f4d1118e580aabf7" translate="yes" xml:space="preserve">
          <source>The second part of the module relies on representing Earth locations as values of type &lt;code&gt;point&lt;/code&gt;, in which the first component is taken to represent longitude in degrees, and the second component is taken to represent latitude in degrees. Points are taken as (longitude, latitude) and not vice versa because longitude is closer to the intuitive idea of x-axis and latitude to y-axis.</source>
          <target state="translated">모듈의 두 번째 부분은 지구 위치를 &lt;code&gt;point&lt;/code&gt; 유형의 값으로 나타내는 데 의존 합니다. 첫 번째 구성 요소는 경도를도 단위로 나타내고 두 번째 구성 요소는 위도를도 단위로 나타냅니다. 경도는 x 축 및 위도 y 축에 대한 직관적 인 아이디어에 더 가깝기 때문에 포인트는 (경도, 위도)로 간주되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="07476921b1bd87798420cb9dffdda71ef3f07ce3" translate="yes" xml:space="preserve">
          <source>The second variant changes the name of the role. Database superusers can rename any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can rename non-superuser roles. The current session user cannot be renamed. (Connect as a different user if you need to do that.) Because &lt;code&gt;MD5&lt;/code&gt;-encrypted passwords use the role name as cryptographic salt, renaming a role clears its password if the password is &lt;code&gt;MD5&lt;/code&gt;-encrypted.</source>
          <target state="translated">두 번째 변형은 역할의 이름을 변경합니다. 데이터베이스 수퍼 유저는 모든 역할의 이름을 바꿀 수 있습니다. &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이있는 역할은 수퍼 유저가 아닌 역할의 이름을 바꿀 수 있습니다. 현재 세션 사용자의 이름을 바꿀 수 없습니다. (연결은 당신이를. 할 필요가있는 경우 다른 사용자로) 때문에 &lt;code&gt;MD5&lt;/code&gt; 는 암호가있는 경우 암호를 암호화 소금 같은 역할 이름을 사용으로 암호화, 역할의 이름을 변경하는 것은 해당 암호를 지 웁니다 &lt;code&gt;MD5&lt;/code&gt; 는 으로 암호화.</target>
        </trans-unit>
        <trans-unit id="ee438b765dcc18ec34d603a483697e804f9db58b" translate="yes" xml:space="preserve">
          <source>The seconds field, including any fractional seconds</source>
          <target state="translated">The seconds field, including any fractional seconds</target>
        </trans-unit>
        <trans-unit id="cfe4da30b9c6bff8e95fbde2fcc03500be370613" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts (0 - 59&lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;)</source>
          <target state="translated">소수 부분을 포함한 초 필드 (0-59 &lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="663b58f51194288bd80b435fbc5e648d8e6f6580" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1 000 000; note that this includes full seconds</source>
          <target state="translated">분수 부분을 포함하여 초 필드에 1,000,000을 곱한 값; 여기에는 전체 초가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2d44e15dba826649cac46abaee1bc5cb23f259a3" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1000. Note that this includes full seconds.</source>
          <target state="translated">소수 부분을 포함하여 초 필드에 1000을 곱한 값입니다. 여기에는 전체 초가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7bfc04444cf0b5a28dd815138a4bbbe840cd72f0" translate="yes" xml:space="preserve">
          <source>The security label applied to this object.</source>
          <target state="translated">이 개체에 적용된 보안 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="b47689b397bbce6da7cf131cc329c56ad0b8b0d2" translate="yes" xml:space="preserve">
          <source>The security model of SELinux describes all the access control rules as relationships between a subject entity (typically, a client of the database) and an object entity (such as a database object), each of which is identified by a security label. If access to an unlabeled object is attempted, the object is treated as if it were assigned the label &lt;code&gt;unlabeled_t&lt;/code&gt;.</source>
          <target state="translated">SELinux의 보안 모델은 모든 액세스 제어 규칙을 주제 엔티티 (일반적으로 데이터베이스의 클라이언트)와 오브젝트 엔티티 (예 : 데이터베이스 오브젝트) 사이의 관계로 설명합니다. 각각은 보안 레이블로 식별됩니다. 레이블이없는 오브젝트에 대한 액세스가 시도되면 오브젝트는 레이블 &lt;code&gt;unlabeled_t&lt;/code&gt; 로 지정된 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="230231accae0954bfa7e47d9f5e404dcd469b2c5" translate="yes" xml:space="preserve">
          <source>The security policy of SELinux also has rules to control whether or not particular accesses are logged. By default, access violations are logged, but allowed accesses are not.</source>
          <target state="translated">SELinux의 보안 정책에는 특정 액세스의 기록 여부를 제어하는 ​​규칙도 있습니다. 기본적으로 액세스 위반은 기록되지만 허용 된 액세스는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbcd4d113ca55d30a1adafc062bb48c13c7f8e98" translate="yes" xml:space="preserve">
          <source>The seed can also be set by invoking the function &lt;code&gt;setseed&lt;/code&gt;:</source>
          <target state="translated">시드는 &lt;code&gt;setseed&lt;/code&gt; 함수를 호출하여 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c3344ee525a48fbaf283fc79a5b884444be3dcb" translate="yes" xml:space="preserve">
          <source>The segment [a, b] contains the segment [c, d], that is, a &amp;lt;= c and b &amp;gt;= d.</source>
          <target state="translated">세그먼트 [a, b]는 세그먼트 [c, d], 즉 a &amp;lt;= c 및 b&amp;gt; = d를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0167ae8a0ef2744b5f058f32dbb8df42b67bb33e" translate="yes" xml:space="preserve">
          <source>The segment [a, b] is contained in [c, d], that is, a &amp;gt;= c and b &amp;lt;= d.</source>
          <target state="translated">세그먼트 [a, b]는 [c, d], 즉 a&amp;gt; = c 및 b &amp;lt;= d에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9dfe875337796db870c4bb2a262e2bbef3945b" translate="yes" xml:space="preserve">
          <source>The segments [a, b] and [c, d] overlap.</source>
          <target state="translated">세그먼트 [a, b] 및 [c, d]가 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="b10711fce98e1c5fe5a4897a9961ed9ae2f37aef" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a most natural way of working with JSON data, SQL/JSON path syntax uses some of the JavaScript conventions:</source>
          <target state="translated">SQL / JSON 경로 술어 및 연산자의 의미는 일반적으로 SQL을 따릅니다. 동시에, JSON 데이터를 사용하는 가장 자연스러운 방법을 제공하기 위해 SQL / JSON 경로 구문은 다음과 같은 JavaScript 규칙 중 일부를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fd623d8bcf9db9273d58642da7f1fb001cf303e9" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a natural way of working with JSON data, SQL/JSON path syntax uses some JavaScript conventions:</source>
          <target state="translated">The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a natural way of working with JSON data, SQL/JSON path syntax uses some JavaScript conventions:</target>
        </trans-unit>
        <trans-unit id="ca2f632c9b81511535163336539f86f918d83e9e" translate="yes" xml:space="preserve">
          <source>The semicolon (&lt;code&gt;;&lt;/code&gt;) terminates an SQL command. It cannot appear anywhere within a command, except within a string constant or quoted identifier.</source>
          <target state="translated">세미콜론 ( &lt;code&gt;;&lt;/code&gt; )은 SQL 명령을 종료합니다. 문자열 상수 또는 따옴표 붙은 식별자를 제외하고 명령 내의 어느 곳에도 나타날 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c68a3eca090a3377bf1a78fea499d56ec605109" translate="yes" xml:space="preserve">
          <source>The sequence created for a &lt;code&gt;serial&lt;/code&gt; column is automatically dropped when the owning column is dropped. You can drop the sequence without dropping the column, but this will force removal of the column default expression.</source>
          <target state="translated">소유 열이 삭제되면 &lt;code&gt;serial&lt;/code&gt; 열에 대해 생성 된 시퀀스 가 자동으로 삭제됩니다. 열을 삭제하지 않고 시퀀스를 삭제할 수 있지만 열 기본 표현식을 강제로 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b5a5d93057bd5edff8daf4648c4c935388f9e10e" translate="yes" xml:space="preserve">
          <source>The sequence name can be schema-qualified if necessary:</source>
          <target state="translated">필요한 경우 시퀀스 이름을 스키마로 규정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6a359aa04dbc4531fddf8d09e8fef46d55e14f6" translate="yes" xml:space="preserve">
          <source>The sequence to be operated on by a sequence function is specified by a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the sequence in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the sequence name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the sequence name. Thus:</source>
          <target state="translated">시퀀스 함수에 의해 조작되는 시퀀스 는 &lt;code&gt;pg_class&lt;/code&gt; 시스템 카탈로그 에있는 시퀀스의 OID 인 &lt;code&gt;regclass&lt;/code&gt; 인수로 지정됩니다 . 그러나 &lt;code&gt;regclass&lt;/code&gt; 데이터 유형의 입력 변환기가 자동으로 작업 하므로 OID를 직접 찾아 볼 필요는 없습니다 . 리터럴 상수처럼 보이도록 작은 따옴표로 묶은 시퀀스 이름을 작성하십시오. 일반 SQL 이름 처리와의 호환성을 위해 시퀀스 이름 주위에 큰 따옴표가 포함되어 있지 않으면 문자열이 소문자로 변환됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="ea7d18fda0e93393ee728bac05185520e2d92f5c" translate="yes" xml:space="preserve">
          <source>The server log might contain more information about an authentication failure than is reported to the client. If you are confused about the reason for a failure, check the server log.</source>
          <target state="translated">서버 로그에는 클라이언트에보고 된 것보다 인증 실패에 대한 자세한 정보가 포함될 수 있습니다. 실패 이유에 대해 혼란 스러우면 서버 로그를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4ca1254319f0477050eedb4dcb243dbc28231770" translate="yes" xml:space="preserve">
          <source>The server name must be unique within the database.</source>
          <target state="translated">서버 이름은 데이터베이스 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c59301168d9556837d6ae02c071fa4e2e245b97" translate="yes" xml:space="preserve">
          <source>The server process is idle. This event type indicates a process waiting for activity in its main processing loop. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt;.</source>
          <target state="translated">The server process is idle. This event type indicates a process waiting for activity in its main processing loop. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="31a48413f524a2e22ba2b89cc5a923ac95e25337" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a heavyweight lock. Heavyweight locks, also known as lock manager locks or simply locks, primarily protect SQL-visible objects such as tables. However, they are also used to ensure mutual exclusion for certain internal operations such as relation extension. &lt;code&gt;wait_event&lt;/code&gt; will identify the type of lock awaited; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.</source>
          <target state="translated">The server process is waiting for a heavyweight lock. Heavyweight locks, also known as lock manager locks or simply locks, primarily protect SQL-visible objects such as tables. However, they are also used to ensure mutual exclusion for certain internal operations such as relation extension. &lt;code&gt;wait_event&lt;/code&gt; will identify the type of lock awaited; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1f51ae65c30da3ee23ba46209eb3c2d669b578e3" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a lightweight lock. Most such locks protect a particular data structure in shared memory. &lt;code&gt;wait_event&lt;/code&gt; will contain a name identifying the purpose of the lightweight lock. (Some locks have specific names; others are part of a group of locks each with a similar purpose.) See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LWLOCK-TABLE&quot;&gt;Table 27.12&lt;/a&gt;.</source>
          <target state="translated">The server process is waiting for a lightweight lock. Most such locks protect a particular data structure in shared memory. &lt;code&gt;wait_event&lt;/code&gt; will contain a name identifying the purpose of the lightweight lock. (Some locks have specific names; others are part of a group of locks each with a similar purpose.) See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LWLOCK-TABLE&quot;&gt;Table 27.12&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1282755dbc7fcbac3f92fb89910bc9353d2096ee" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a timeout to expire. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="translated">The server process is waiting for a timeout to expire. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8e0987499e5a13bf6c786db17c89cc8ef22d6f54" translate="yes" xml:space="preserve">
          <source>The server process is waiting for activity on a socket connected to a user application. Thus, the server expects something to happen that is independent of its internal processes. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-CLIENT-TABLE&quot;&gt;Table 27.7&lt;/a&gt;.</source>
          <target state="translated">The server process is waiting for activity on a socket connected to a user application. Thus, the server expects something to happen that is independent of its internal processes. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-CLIENT-TABLE&quot;&gt;Table 27.7&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9b31b52ace66848125879633c9823a38b3287ac3" translate="yes" xml:space="preserve">
          <source>The server process is waiting for an I/O operation to complete. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IO-TABLE&quot;&gt;Table 27.9&lt;/a&gt;.</source>
          <target state="translated">The server process is waiting for an I/O operation to complete. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IO-TABLE&quot;&gt;Table 27.9&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e8bb014aedce015b73f39d1e5ca61f9c69eeed52" translate="yes" xml:space="preserve">
          <source>The server process is waiting for exclusive access to a data buffer. Buffer pin waits can be protracted if another process holds an open cursor that last read data from the buffer in question. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-BUFFERPIN-TABLE&quot;&gt;Table 27.6&lt;/a&gt;.</source>
          <target state="translated">The server process is waiting for exclusive access to a data buffer. Buffer pin waits can be protracted if another process holds an open cursor that last read data from the buffer in question. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-BUFFERPIN-TABLE&quot;&gt;Table 27.6&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d9849ed38bcc2dc42a7bd3ba776b5832e6dd4516" translate="yes" xml:space="preserve">
          <source>The server process is waiting for some condition defined by an extension module. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-EXTENSION-TABLE&quot;&gt;Table 27.8&lt;/a&gt;.</source>
          <target state="translated">The server process is waiting for some condition defined by an extension module. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-EXTENSION-TABLE&quot;&gt;Table 27.8&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7fff16781ff90b488a09e62468878f27f389a70f" translate="yes" xml:space="preserve">
          <source>The server process is waiting for some interaction with another server process. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IPC-TABLE&quot;&gt;Table 27.10&lt;/a&gt;.</source>
          <target state="translated">The server process is waiting for some interaction with another server process. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IPC-TABLE&quot;&gt;Table 27.10&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ac56c0453261e732a23fed94e0a24c8f95cc0488" translate="yes" xml:space="preserve">
          <source>The server reads these files at server start and whenever the server configuration is reloaded. On Windows systems, they are also re-read whenever a new backend process is spawned for a new client connection.</source>
          <target state="translated">서버는 서버 시작시 및 서버 구성을 다시로드 할 때마다 이러한 파일을 읽습니다. Windows 시스템에서는 새 클라이언트 연결을 위해 새 백엔드 프로세스가 생성 될 때마다 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="d0d31219164213fd90b64aadc8577b6089ce02b9" translate="yes" xml:space="preserve">
          <source>The server sends an AuthenticationSASL message. It includes a list of SASL authentication mechanisms that the server can accept. This will be &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; and &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; if the server is built with SSL support, or else just the latter.</source>
          <target state="translated">서버는 AuthenticationSASL 메시지를 보냅니다. 서버가 승인 할 수있는 SASL 인증 메커니즘 목록이 포함되어 있습니다. 이 될 것 &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; 와 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 서버가 SSL 지원, 그렇지 않으면 바로 후자에 내장되어있는 경우.</target>
        </trans-unit>
        <trans-unit id="b019b1a1b7d85dded861255aa6e59d8f9921d05a" translate="yes" xml:space="preserve">
          <source>The server will occasionally request the client to perform a flush and report the flush position to the server. This setting is in addition to that, to perform flushes more frequently.</source>
          <target state="translated">서버는 때때로 클라이언트에게 플러시를 수행하고 플러시 위치를 서버에보고하도록 요청합니다. 이 설정은 더 자주 플러시를 수행하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b8da77a2b390601e3adff073821408d13cdbea6" translate="yes" xml:space="preserve">
          <source>The server's checkpointer process automatically performs a checkpoint every so often. A checkpoint is begun every &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; seconds, or if &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; is about to be exceeded, whichever comes first. The default settings are 5 minutes and 1 GB, respectively. If no WAL has been written since the previous checkpoint, new checkpoints will be skipped even if &lt;code&gt;checkpoint_timeout&lt;/code&gt; has passed. (If WAL archiving is being used and you want to put a lower limit on how often files are archived in order to bound potential data loss, you should adjust the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; parameter rather than the checkpoint parameters.) It is also possible to force a checkpoint by using the SQL command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">서버의 검사 점 프로세스는 항상 검사 점을 자동으로 수행합니다. 체크 포인트는 &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; 초 마다 시작 되거나 &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; 를 초과하려고 할 때 중 빠른 시간에 시작됩니다 . 기본 설정은 각각 5 분과 1GB입니다. 이전 체크 포인트 이후 WAL이 작성되지 않은 경우 &lt;code&gt;checkpoint_timeout&lt;/code&gt; 이 지나도 새 체크 포인트를 건너 뜁니다 . (WAL 보관을 사용하고 있고 잠재적 인 데이터 손실을 막기 위해 파일을 보관하는 빈도를 더 낮게 설정 하려면 검사 점 매개 변수 대신 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; 매개 변수를 조정해야합니다 .) &lt;code&gt;CHECKPOINT&lt;/code&gt; SQL 명령을 사용하여 .</target>
        </trans-unit>
        <trans-unit id="c205218c3546e4b301b493a03547b46277844636" translate="yes" xml:space="preserve">
          <source>The server's version number as a string, for example &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt; or &lt;code&gt;11beta1&lt;/code&gt;, and in numeric form, for example &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;. These are set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">서버의 버전 번호는 문자열 (예 : &lt;code&gt;9.6.2&lt;/code&gt; , &lt;code&gt;10.1&lt;/code&gt; 또는 &lt;code&gt;11beta1&lt;/code&gt; ) 및 숫자 형식 (예 : &lt;code&gt;90602&lt;/code&gt; 또는 &lt;code&gt;100001&lt;/code&gt; ) 입니다. 데이터베이스 (프로그램 시작 포함)에 연결할 때마다 설정되지만 변경하거나 설정을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a84cc79fdbb16a887f43ceaad26726c6755ffe1" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="translated">구성 매개 변수 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt; , &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt; 을 설정하여 세션 기본 트랜잭션 모드를 설정할 수도 있습니다 . (사실 &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; 단지 이러한 변수를 설정하기위한 용장 상당 &lt;code&gt;SET&lt;/code&gt; 를 .) 디폴트 구성 파일에 설정 될 수있는이 방법을 통해 &lt;code&gt;ALTER DATABASE&lt;/code&gt; 등 참조 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 이상의 정보.</target>
        </trans-unit>
        <trans-unit id="2aaa3b9320a8aa3d463da80f8c085ef96d144a67" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="translated">The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt; .) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt; , etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="6723e0bdad2077d09fd447f64653c3402fb21a9f" translate="yes" xml:space="preserve">
          <source>The session user identifier can be changed only if the initial session user (the &lt;em&gt;authenticated user&lt;/em&gt;) had the superuser privilege. Otherwise, the command is accepted only if it specifies the authenticated user name.</source>
          <target state="translated">세션 사용자 식별자는 초기 세션 사용자 ( &lt;em&gt;인증 된 사용자&lt;/em&gt; )가 수퍼 유저 권한을 가진 경우에만 변경할 수 있습니다 . 그렇지 않으면 인증 된 사용자 이름을 지정하는 경우에만 명령이 승인됩니다.</target>
        </trans-unit>
        <trans-unit id="715d310203fd1767744b0e3abc3cbaadfd49947d" translate="yes" xml:space="preserve">
          <source>The session user identifier is initially set to be the (possibly authenticated) user name provided by the client. The current user identifier is normally equal to the session user identifier, but might change temporarily in the context of &lt;code&gt;SECURITY DEFINER&lt;/code&gt; functions and similar mechanisms; it can also be changed by &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. The current user identifier is relevant for permission checking.</source>
          <target state="translated">세션 사용자 식별자는 처음에 클라이언트가 제공 한 인증 된 사용자 이름으로 설정됩니다. 현재 사용자 식별자는 일반적으로 세션 사용자 식별자와 동일하지만 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 기능 및 유사한 메커니즘과 관련하여 일시적으로 변경 될 수 있습니다 . &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 로도 변경할 수 있습니다 . 현재 사용자 식별자는 권한 검사와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="94dcf85932be3ca953bb5dbee89cd4f7713067fb" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 에서 설명한대로 클라이언트 인증 설정에 따라 지정된 클라이언트 연결에 연결할 수있는 데이터베이스 역할 세트가 있습니다 . (따라서, 개인의 로그인 이름이 실제 이름과 일치 할 필요가없는 것처럼 클라이언트는 운영 체제 사용자와 일치하는 역할로 연결하도록 제한되지 않습니다.) 역할 ID는 연결된 클라이언트가 사용할 수있는 권한 세트를 결정하므로, 다중 사용자 환경을 설정할 때 권한을 신중하게 구성하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="116c57f39b5a10aa3016899fd490e3422c042da6" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="translated">The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</target>
        </trans-unit>
        <trans-unit id="d9e7e3efb30616b981cfefa41268aa6951e3d5f2" translate="yes" xml:space="preserve">
          <source>The setting &lt;code&gt;RemoveIPC&lt;/code&gt; in &lt;code&gt;logind.conf&lt;/code&gt; controls whether IPC objects are removed when a user fully logs out. System users are exempt. This setting defaults to on in stock systemd, but some operating system distributions default it to off.</source>
          <target state="translated">&lt;code&gt;RemoveIPC&lt;/code&gt; 의 &lt;code&gt;logind.conf&lt;/code&gt; 설정 은 사용자가 완전히 로그 아웃 할 때 IPC 객체 제거 여부를 제어합니다. 시스템 사용자는 면제됩니다. 이 설정은 기본 시스템에서 기본으로 설정되어 있지만 일부 운영 체제 배포에서는 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="64eba0ac674f39ed469aa292d2c2a8445eebc9f9" translate="yes" xml:space="preserve">
          <source>The setting of some parameters on the standby will need reconfiguration if they have been changed on the primary. For these parameters, the value on the standby must be equal to or greater than the value on the primary. Therefore, if you want to increase these values, you should do so on all standby servers first, before applying the changes to the primary server. Conversely, if you want to decrease these values, you should do so on the primary server first, before applying the changes to all standby servers. If these parameters are not set high enough then the standby will refuse to start. Higher values can then be supplied and the server restarted to begin recovery again. These parameters are:</source>
          <target state="translated">기본 매개 변수가 변경된 경우 대기에서 일부 매개 변수 설정을 다시 구성해야합니다. 이러한 매개 변수의 경우 대기의 값은 기본의 값보다 크거나 같아야합니다. 따라서이 값을 늘리려면 기본 서버에 변경 사항을 적용하기 전에 모든 대기 서버에서 먼저 증가시켜야합니다. 반대로,이 값을 줄이려면 모든 대기 서버에 변경 사항을 적용하기 전에 기본 서버에서 먼저 변경해야합니다. 이 매개 변수가 충분히 높게 설정되지 않으면 대기가 시작되지 않습니다. 그런 다음 더 높은 값을 제공하고 서버를 다시 시작하여 복구를 다시 시작합니다. 이러한 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f66060d984a3d43717aaa1c8e7136685e2e6d1f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g. query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="translated">공유 잠금 테이블은 &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; ) 오브젝트 (예 : 테이블)의 잠금을 추적합니다 . 따라서이 많은 개별 객체를 한 번에 잠글 수 있습니다. 이 매개 변수는 각 트랜잭션에 할당 된 평균 오브젝트 잠금 수를 제어합니다. 모든 트랜잭션의 잠금이 잠금 테이블에 맞는 한 개별 트랜잭션은 더 많은 오브젝트를 잠글 수 있습니다. 이것은 &lt;em&gt;아닙니다&lt;/em&gt;잠글 수있는 행 수; 그 가치는 무제한입니다. 기본값 인 64는 역사적으로 충분한 것으로 입증되었지만 단일 트랜잭션에서 여러 테이블에 닿는 쿼리 (예 : 자식이 많은 부모 테이블의 쿼리)가있는 경우이 값을 높여야합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3a2293e6351084a16aac1acbf3842262fd1322f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g., query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="translated">The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g., query of a parent table with many children. This parameter can only be set at server start.</target>
        </trans-unit>
        <trans-unit id="ed8d27015cd393d0e4d2ed8b1d7004db3e56b61f" translate="yes" xml:space="preserve">
          <source>The shared memory size settings can be changed via the &lt;code&gt;sysctl&lt;/code&gt; interface. For example, to allow 16 GB:</source>
          <target state="translated">공유 메모리 크기 설정은 &lt;code&gt;sysctl&lt;/code&gt; 인터페이스 를 통해 변경할 수 있습니다 . 예를 들어 16GB를 허용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="068843c57f60fb86ac3cb60c430b5300612b2f9d" translate="yes" xml:space="preserve">
          <source>The shared predicate lock table tracks locks on &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has generally been sufficient in testing, but you might need to raise this value if you have clients that touch many different tables in a single serializable transaction. This parameter can only be set at server start.</source>
          <target state="translated">공유 술어 잠금 테이블은 &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; * ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; ) 오브젝트 (예 : 테이블)의 잠금을 추적합니다 . 따라서이 많은 개별 객체를 한 번에 잠글 수 있습니다. 이 매개 변수는 각 트랜잭션에 할당 된 평균 오브젝트 잠금 수를 제어합니다. 모든 트랜잭션의 잠금이 잠금 테이블에 맞는 한 개별 트랜잭션은 더 많은 오브젝트를 잠글 수 있습니다. 이것은 잠글 수있는 행의 수가 &lt;em&gt;아닙니다&lt;/em&gt; . 그 가치는 무제한입니다. 기본값 인 64는 일반적으로 테스트에 충분했지만 직렬화 가능한 단일 트랜잭션에서 여러 테이블을 터치하는 클라이언트가있는 경우이 값을 높여야 할 수 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca5a87d53a78cc8149d60b5d1c35e814aa59a259" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS server. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="translated">RADIUS 서버와 안전하게 통신 할 때 사용되는 공유 비밀. PostgreSQL 및 RADIUS 서버에서 정확히 동일한 값을 가져야합니다. 이 문자열은 16 자 이상인 것이 좋습니다. 이 매개 변수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="1aeeff6b5f410ecdf1f1d99d13f99d22c13ce407" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS servers. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="translated">The shared secrets used when talking securely to the RADIUS servers. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</target>
        </trans-unit>
        <trans-unit id="58e38019afd1ad1853e1d01481b88d4b91b8d05a" translate="yes" xml:space="preserve">
          <source>The sharp (&lt;code&gt;#&lt;/code&gt;) sign is a comment delimiter. It may appear at any position in a line. The rest of the line will be skipped.</source>
          <target state="translated">날카로운 ( &lt;code&gt;#&lt;/code&gt; ) 기호는 주석 구분 기호입니다. 줄의 어느 위치 에나 나타날 수 있습니다. 나머지 줄은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="67cfcf8acce2ecc45db3a0f17045ee10928b08a1" translate="yes" xml:space="preserve">
          <source>The short procedure for configuring a standby server using this alternative method is as follows. For full details of each step, refer to previous sections as noted.</source>
          <target state="translated">이 대체 방법을 사용하여 대기 서버를 구성하는 간단한 절차는 다음과 같습니다. 각 단계에 대한 자세한 내용은 앞에서 설명한대로 이전 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="968f59638db3803d09dafd7e362f7206431f6346" translate="yes" xml:space="preserve">
          <source>The simple comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; compare the lower bounds first, and only if those are equal, compare the upper bounds. These comparisons are not usually very useful for ranges, but are provided to allow B-tree indexes to be constructed on ranges.</source>
          <target state="translated">간단한 비교 연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 는 하한을 먼저 비교하고, 상한이 같으면 상한을 비교합니다. 이러한 비교는 일반적으로 범위에 유용하지 않지만 B- 트리 인덱스를 범위에 구성 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8ea620de73d7bb2e034a3dc8ebd2dd0118f06f72" translate="yes" xml:space="preserve">
          <source>The simplest kind of extended statistics tracks &lt;em&gt;functional dependencies&lt;/em&gt;, a concept used in definitions of database normal forms. We say that column &lt;code&gt;b&lt;/code&gt; is functionally dependent on column &lt;code&gt;a&lt;/code&gt; if knowledge of the value of &lt;code&gt;a&lt;/code&gt; is sufficient to determine the value of &lt;code&gt;b&lt;/code&gt;, that is there are no two rows having the same value of &lt;code&gt;a&lt;/code&gt; but different values of &lt;code&gt;b&lt;/code&gt;. In a fully normalized database, functional dependencies should exist only on primary keys and superkeys. However, in practice many data sets are not fully normalized for various reasons; intentional denormalization for performance reasons is a common example. Even in a fully normalized database, there may be partial correlation between some columns, which can be expressed as partial functional dependency.</source>
          <target state="translated">가장 간단한 종류의 확장 된 통계 는 데이터베이스 정규 형식의 정의에 사용되는 개념 인 &lt;em&gt;기능적 종속성을&lt;/em&gt; 추적 합니다. 우리는 열 말 &lt;code&gt;b&lt;/code&gt; 컬럼에 기능적으로 의존 의 값을 기술하는 경우 &lt;code&gt;a&lt;/code&gt; 의 값을 결정하기에 충분하다 &lt;code&gt;b&lt;/code&gt; 동일한 값을 갖는 두 개의 행이 없는지, 의 그러나 다른 값 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; . 완전히 정규화 된 데이터베이스에서 기능적 종속성은 기본 키와 수 퍼키에만 존재해야합니다. 그러나 실제로 많은 데이터 세트가 여러 가지 이유로 완전히 정규화되지는 않습니다. 성능상의 이유로 의도적 인 비정규 화가 일반적인 예입니다. 완전히 정규화 된 데이터베이스에서도 일부 열간에 부분적인 상관 관계가있을 수 있으며 이는 부분적인 기능 종속성으로 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="218e0e862d91c332c13bb63fca705baa68ee5396" translate="yes" xml:space="preserve">
          <source>The simplest kind of select list is &lt;code&gt;*&lt;/code&gt; which emits all columns that the table expression produces. Otherwise, a select list is a comma-separated list of value expressions (as defined in &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;). For instance, it could be a list of column names:</source>
          <target state="translated">가장 간단한 종류의 선택 목록은 &lt;code&gt;*&lt;/code&gt; 이며 테이블 표현식이 생성하는 모든 열을 방출합니다. 그렇지 않으면 선택 목록은 쉼표로 구분 된 값 표현식 목록입니다 ( &lt;a href=&quot;sql-expressions&quot;&gt;4.2 절에&lt;/a&gt; 정의 된대로 ). 예를 들어 열 이름 목록이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ff410c0d68dcd6b5d1a3a14a5e05f946ef4e40" translate="yes" xml:space="preserve">
          <source>The simplest option for removing old data is to drop the partition that is no longer necessary:</source>
          <target state="translated">오래된 데이터를 제거하는 가장 간단한 옵션은 더 이상 필요하지 않은 파티션을 삭제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d938ffa1d7d07edb850b5b705fb8034d9885325" translate="yes" xml:space="preserve">
          <source>The size of the block range is determined at index creation time by the &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter. The number of index entries will be equal to the size of the relation in pages divided by the selected value for &lt;code&gt;pages_per_range&lt;/code&gt;. Therefore, the smaller the number, the larger the index becomes (because of the need to store more index entries), but at the same time the summary data stored can be more precise and more data blocks can be skipped during an index scan.</source>
          <target state="translated">블록 범위의 크기는 인덱스 생성시 &lt;code&gt;pages_per_range&lt;/code&gt; 스토리지 매개 변수에 의해 결정됩니다 . 색인 항목 수는 페이지의 관계 크기를 &lt;code&gt;pages_per_range&lt;/code&gt; 에 대해 선택된 값으로 나눈 값과 같습니다 . 따라서 숫자가 작을수록 (더 많은 색인 항목을 저장해야하기 때문에) 색인이 커지지 만, 동시에 저장된 요약 데이터가 더 정확하고 색인 스캔 중에 더 많은 데이터 블록을 건너 뛸 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
