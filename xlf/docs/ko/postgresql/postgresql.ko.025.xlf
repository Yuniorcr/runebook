<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="1daf3db24fd8109b791952bf2bea84cc95a73e77" translate="yes" xml:space="preserve">
          <source>Two parameterized GiST index operator classes are provided: &lt;code&gt;gist__int_ops&lt;/code&gt; (used by default) is suitable for small- to medium-size data sets, while &lt;code&gt;gist__intbig_ops&lt;/code&gt; uses a larger signature and is more suitable for indexing large data sets (i.e., columns containing a large number of distinct array values). The implementation uses an RD-tree data structure with built-in lossy compression.</source>
          <target state="translated">두 파라미터 요지 지수 연산자 클래스가 제공된다 : &lt;code&gt;gist__int_ops&lt;/code&gt; 동안 (기본적으로 사용), 중간 크기 데이터 세트에 소형 적합 &lt;code&gt;gist__intbig_ops&lt;/code&gt; 이 큰 특성을 사용하여 (a 다수 함유하는, 즉, 열을 대용량 데이터 세트를 인덱싱 더 적합 고유 한 배열 값). 이 구현은 손실 압축이 내장 된 RD- 트리 데이터 구조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="662248ac968d8ab661b9569a6e6849ae788e24f8" translate="yes" xml:space="preserve">
          <source>Two significant incompatibilities exist between AREs and the ERE syntax recognized by pre-7.4 releases of PostgreSQL:</source>
          <target state="translated">PostgreSQL의 7.4 이전 릴리스에서 인식 된 ARE와 ERE 구문 사이에는 두 가지 중요한 비 호환성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a32f2ed2800b3a048eac6f3c98ed4d6f0004a87" translate="yes" xml:space="preserve">
          <source>Two string constants that are only separated by whitespace &lt;em&gt;with at least one newline&lt;/em&gt; are concatenated and effectively treated as if the string had been written as one constant. For example:</source>
          <target state="translated">&lt;em&gt;최소한 하나의 줄 바꿈&lt;/em&gt; 으로 공백 &lt;em&gt;으로&lt;/em&gt; 구분 된 두 개의 문자열 상수 는 문자열이 하나의 상수로 작성된 것처럼 연결되고 효과적으로 처리됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90b63e2a4e205cf20d0c53869ecd885349050bdf" translate="yes" xml:space="preserve">
          <source>Two tablespaces are automatically created when the database cluster is initialized. The &lt;code&gt;pg_global&lt;/code&gt; tablespace is used for shared system catalogs. The &lt;code&gt;pg_default&lt;/code&gt; tablespace is the default tablespace of the &lt;code&gt;template1&lt;/code&gt; and &lt;code&gt;template0&lt;/code&gt; databases (and, therefore, will be the default tablespace for other databases as well, unless overridden by a &lt;code&gt;TABLESPACE&lt;/code&gt; clause in &lt;code&gt;CREATE DATABASE&lt;/code&gt;).</source>
          <target state="translated">데이터베이스 클러스터가 초기화 될 때 두 개의 테이블 스페이스가 자동으로 작성됩니다. &lt;code&gt;pg_global&lt;/code&gt; 테이블 공유 시스템 카탈로그에 사용됩니다. &lt;code&gt;pg_default&lt;/code&gt; 의 테이블 스페이스의 기본 테이블 스페이스 &lt;code&gt;template1&lt;/code&gt; 를 하고 &lt;code&gt;template0&lt;/code&gt; (A 재정의하지 않는 한 따라서,뿐만 아니라 다른 데이터베이스의 기본 테이블 스페이스 될 것이며, 데이터베이스 &lt;code&gt;TABLESPACE&lt;/code&gt; 에 절 &lt;code&gt;CREATE DATABASE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c5b854b5685b242cd142ae86c5c04afbc5fc30b6" translate="yes" xml:space="preserve">
          <source>Two types can be &lt;em&gt;binary coercible&lt;/em&gt;, which means that the conversion can be performed &amp;ldquo;for free&amp;rdquo; without invoking any function. This requires that corresponding values use the same internal representation. For instance, the types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary coercible both ways. Binary coercibility is not necessarily a symmetric relationship. For example, the cast from &lt;code&gt;xml&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt; can be performed for free in the present implementation, but the reverse direction requires a function that performs at least a syntax check. (Two types that are binary coercible both ways are also referred to as binary compatible.)</source>
          <target state="translated">&lt;em&gt;이진 강제&lt;/em&gt; 변환은 두 가지 유형이 될 수 있습니다. 즉, 함수를 호출하지 않고 &quot;무료로&quot;변환을 수행 할 수 있습니다. 이를 위해서는 해당 값이 동일한 내부 표현을 사용해야합니다. 예를 들어, &lt;code&gt;text&lt;/code&gt; 및 &lt;code&gt;varchar&lt;/code&gt; 유형 은 두 가지 방식으로 이진 강제입니다. 이진 보자 성이 반드시 대칭 관계는 아닙니다. 예를 들어, &lt;code&gt;xml&lt;/code&gt; 에서 &lt;code&gt;text&lt;/code&gt; 의 캐스트 는 본 구현에서 무료로 수행 될 수 있지만, 역방향에는 적어도 구문 검사를 수행하는 기능이 필요하다. (이진 강제 변환이 가능한 두 가지 유형은 이진 호환이라고도합니다.)</target>
        </trans-unit>
        <trans-unit id="51632bd25b09e4b06271cc8939c29fce73a7a60c" translate="yes" xml:space="preserve">
          <source>Two useful flags exist in &lt;code&gt;pg_database&lt;/code&gt; for each database: the columns &lt;code&gt;datistemplate&lt;/code&gt; and &lt;code&gt;datallowconn&lt;/code&gt;. &lt;code&gt;datistemplate&lt;/code&gt; can be set to indicate that a database is intended as a template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. If this flag is set, the database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if it is not set, only superusers and the owner of the database can clone it. If &lt;code&gt;datallowconn&lt;/code&gt; is false, then no new connections to that database will be allowed (but existing sessions are not terminated simply by setting the flag false). The &lt;code&gt;template0&lt;/code&gt; database is normally marked &lt;code&gt;datallowconn = false&lt;/code&gt; to prevent its modification. Both &lt;code&gt;template0&lt;/code&gt; and &lt;code&gt;template1&lt;/code&gt; should always be marked with &lt;code&gt;datistemplate = true&lt;/code&gt;.</source>
          <target state="translated">각 데이터베이스에 대해 두 개의 유용한 플래그 인 &lt;code&gt;pg_database&lt;/code&gt; 에 열 &lt;code&gt;datistemplate&lt;/code&gt; 및 &lt;code&gt;datallowconn&lt;/code&gt; 이 있습니다. 데이터베이스가 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 의 템플리트로 &lt;code&gt;datistemplate&lt;/code&gt; 을 나타내도록 datistemplate 을 설정할 수 있습니다 . 이 플래그를 설정하면 &lt;code&gt;CREATEDB&lt;/code&gt; 권한을 가진 모든 사용자가 데이터베이스를 복제 할 수 있습니다 . 설정되어 있지 않으면 수퍼 유저와 데이터베이스 소유자 만 복제 할 수 있습니다. 경우 &lt;code&gt;datallowconn&lt;/code&gt; 은 거짓, 그 데이터베이스에 대한 새로운 연결은 허용되지 않습니다 (그러나 기존 세션이 플래그는 false를 설정하여 간단하게 종료되지 않음). &lt;code&gt;template0&lt;/code&gt; 의 데이터베이스가 정상적으로 표시됩니다 &lt;code&gt;datallowconn = false&lt;/code&gt; 수정을 방지합니다. &lt;code&gt;template0&lt;/code&gt; 과 &lt;code&gt;template1&lt;/code&gt; 모두 항상 &lt;code&gt;datistemplate = true&lt;/code&gt; 로 표시되어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="2ba8214ba00d79461864d0001c2912a5c18b7b9a" translate="yes" xml:space="preserve">
          <source>Two-phase commit commands - &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, &lt;code&gt;COMMIT PREPARED&lt;/code&gt;, &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; because even read-only transactions need to write WAL in the prepare phase (the first phase of two phase commit).</source>
          <target state="translated">2 단계 커밋 명령 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; , &lt;code&gt;COMMIT PREPARED&lt;/code&gt; , &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 는 읽기 전용 트랜잭션조차도 준비 단계 (2 단계 커밋의 첫 번째 단계)에서 WAL을 작성해야하므로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2e2bfc913787b0e6ea8551f81e2791cd42f7a318" translate="yes" xml:space="preserve">
          <source>Two-phase commit commands: &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, &lt;code&gt;COMMIT PREPARED&lt;/code&gt;, &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; because even read-only transactions need to write WAL in the prepare phase (the first phase of two phase commit).</source>
          <target state="translated">2 단계 커밋 명령 : &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; , &lt;code&gt;COMMIT PREPARED&lt;/code&gt; , &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; . 읽기 전용 트랜잭션도 준비 단계 (2 단계 커밋의 첫 번째 단계)에서 WAL을 작성해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="caa2352205156323130852be37f36d8839e386c6" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;ltree&lt;/code&gt; has the usual comparison operators &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;. Comparison sorts in the order of a tree traversal, with the children of a node sorted by label text. In addition, the specialized operators shown in &lt;a href=&quot;ltree#LTREE-OP-TABLE&quot;&gt;Table F.13&lt;/a&gt; are available.</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 유형 에는 일반적인 비교 연산자 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 이 있습니다. 비교는 트리 순회 순서로 정렬되며, 노드의 자식은 레이블 텍스트로 정렬됩니다. 또한 &lt;a href=&quot;ltree#LTREE-OP-TABLE&quot;&gt;표 F.13에&lt;/a&gt; 나와있는 특수 연산자 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">타입 변환</target>
        </trans-unit>
        <trans-unit id="0f621c80a40b4c3bb2242b9a8d5ab32c97b28181" translate="yes" xml:space="preserve">
          <source>Type modifier input function, or 0 if type does not support modifiers</source>
          <target state="translated">유형 수정 자 입력 기능 또는 유형이 수정자를 지원하지 않는 경우 0</target>
        </trans-unit>
        <trans-unit id="49427798b611e70520545325588242b32904d7b8" translate="yes" xml:space="preserve">
          <source>Type modifier output function, or 0 to use the standard format</source>
          <target state="translated">수정 자 출력 함수를 입력하거나 표준 형식을 사용하려면 0</target>
        </trans-unit>
        <trans-unit id="13f4f7c42905c25fa5436f830df968dd5cfd652c" translate="yes" xml:space="preserve">
          <source>Type of connection</source>
          <target state="translated">연결 유형</target>
        </trans-unit>
        <trans-unit id="4a864d40476979903a17a15ee7653201ddd8043f" translate="yes" xml:space="preserve">
          <source>Type of current backend. Possible types are &lt;code&gt;autovacuum launcher&lt;/code&gt;, &lt;code&gt;autovacuum worker&lt;/code&gt;, &lt;code&gt;logical replication launcher&lt;/code&gt;, &lt;code&gt;logical replication worker&lt;/code&gt;, &lt;code&gt;parallel worker&lt;/code&gt;, &lt;code&gt;background writer&lt;/code&gt;, &lt;code&gt;client backend&lt;/code&gt;, &lt;code&gt;checkpointer&lt;/code&gt;, &lt;code&gt;startup&lt;/code&gt;, &lt;code&gt;walreceiver&lt;/code&gt;, &lt;code&gt;walsender&lt;/code&gt; and &lt;code&gt;walwriter&lt;/code&gt;. In addition, background workers registered by extensions may have additional types.</source>
          <target state="translated">현재 백엔드 유형 가능한 유형은 &lt;code&gt;autovacuum launcher&lt;/code&gt; , &lt;code&gt;autovacuum worker&lt;/code&gt; , &lt;code&gt;logical replication launcher&lt;/code&gt; , &lt;code&gt;logical replication worker&lt;/code&gt; , &lt;code&gt;parallel worker&lt;/code&gt; , &lt;code&gt;background writer&lt;/code&gt; , &lt;code&gt;client backend&lt;/code&gt; , &lt;code&gt;checkpointer&lt;/code&gt; , &lt;code&gt;startup&lt;/code&gt; , &lt;code&gt;walreceiver&lt;/code&gt; , &lt;code&gt;walsender&lt;/code&gt; 및 &lt;code&gt;walwriter&lt;/code&gt; 입니다. 또한 확장 프로그램에 의해 등록 된 백그라운드 워커에는 추가 유형이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82ff0d03f044b1bc03e6d585b2bc9ad0f83dd9c" translate="yes" xml:space="preserve">
          <source>Type of data stored in index, or zero if same as &lt;code&gt;opcintype&lt;/code&gt;</source>
          <target state="translated">인덱스에 저장된 데이터 유형 또는 &lt;code&gt;opcintype&lt;/code&gt; 과 동일한 경우 0</target>
        </trans-unit>
        <trans-unit id="4055eb85cfd66c39ef30f33fb4b4a5d50d592112" translate="yes" xml:space="preserve">
          <source>Type of object this entry is for: &lt;code&gt;r&lt;/code&gt; = relation (table, view), &lt;code&gt;S&lt;/code&gt; = sequence, &lt;code&gt;f&lt;/code&gt; = function, &lt;code&gt;T&lt;/code&gt; = type, &lt;code&gt;n&lt;/code&gt; = schema</source>
          <target state="translated">이 항목의 대상 유형 : &lt;code&gt;r&lt;/code&gt; = 관계 (테이블,보기), &lt;code&gt;S&lt;/code&gt; = 시퀀스, &lt;code&gt;f&lt;/code&gt; = 함수, &lt;code&gt;T&lt;/code&gt; = 유형, &lt;code&gt;n&lt;/code&gt; = 스키마</target>
        </trans-unit>
        <trans-unit id="3399c96b222ffc038be1234147fc38489a358880" translate="yes" xml:space="preserve">
          <source>Type of the JSON item (see &lt;code&gt;json_typeof&lt;/code&gt;)</source>
          <target state="translated">JSON 항목의 유형 ( &lt;code&gt;json_typeof&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="c6f5ec2f1c5458817693d6d76b369073909c045e" translate="yes" xml:space="preserve">
          <source>Type of the SQL/JSON item</source>
          <target state="translated">SQL / JSON 항목의 유형</target>
        </trans-unit>
        <trans-unit id="00a9fa45d41b5ea65aa7f18aa2626b820f2f9cef" translate="yes" xml:space="preserve">
          <source>Type of the left operand</source>
          <target state="translated">왼쪽 피연산자의 유형</target>
        </trans-unit>
        <trans-unit id="21ac751dedd0b562597b93f21b2acf37d95f8772" translate="yes" xml:space="preserve">
          <source>Type of the lockable object: &lt;code&gt;relation&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;frozenid&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;transactionid&lt;/code&gt;, &lt;code&gt;virtualxid&lt;/code&gt;, &lt;code&gt;spectoken&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;userlock&lt;/code&gt;, or &lt;code&gt;advisory&lt;/code&gt;. (See also &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.)</source>
          <target state="translated">잠글 수있는 객체의 유형 : &lt;code&gt;relation&lt;/code&gt; , &lt;code&gt;extend&lt;/code&gt; , &lt;code&gt;frozenid&lt;/code&gt; , &lt;code&gt;page&lt;/code&gt; , &lt;code&gt;tuple&lt;/code&gt; , &lt;code&gt;transactionid&lt;/code&gt; , &lt;code&gt;virtualxid&lt;/code&gt; , &lt;code&gt;spectoken&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;userlock&lt;/code&gt; , &lt;code&gt;advisory&lt;/code&gt; . ( &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;표 27.11&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="767fb9969a4cc64a16553ca389e0f0b5a4e5c458" translate="yes" xml:space="preserve">
          <source>Type of the lockable object: &lt;code&gt;relation&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;transactionid&lt;/code&gt;, &lt;code&gt;virtualxid&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;userlock&lt;/code&gt;, or &lt;code&gt;advisory&lt;/code&gt;</source>
          <target state="translated">잠금 가능한 객체의 유형 : &lt;code&gt;relation&lt;/code&gt; , &lt;code&gt;extend&lt;/code&gt; , &lt;code&gt;page&lt;/code&gt; , &lt;code&gt;tuple&lt;/code&gt; , &lt;code&gt;transactionid&lt;/code&gt; , &lt;code&gt;virtualxid&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;userlock&lt;/code&gt; 또는 &lt;code&gt;advisory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="727af93962dbd00f156d10d2619e6fe4d2766070" translate="yes" xml:space="preserve">
          <source>Type of the result</source>
          <target state="translated">결과의 유형</target>
        </trans-unit>
        <trans-unit id="4b171dbb72682b90735ae1019128b1fa8fc68223" translate="yes" xml:space="preserve">
          <source>Type of the right operand</source>
          <target state="translated">올바른 피연산자의 유형</target>
        </trans-unit>
        <trans-unit id="886a7edda3ba752fafb210f2d1fc042903763b8a" translate="yes" xml:space="preserve">
          <source>Type of the server (optional)</source>
          <target state="translated">서버 유형 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="b84c44ea065844d42eb4ff46ceca0a63ebb5fb0f" translate="yes" xml:space="preserve">
          <source>Typed Tables</source>
          <target state="translated">유형이 지정된 테이블</target>
        </trans-unit>
        <trans-unit id="0e36cf7838eed64c7c287419b5db638ff701a9f7" translate="yes" xml:space="preserve">
          <source>Typed tables implement a subset of the SQL standard. According to the standard, a typed table has columns corresponding to the underlying composite type as well as one other column that is the &amp;ldquo;self-referencing column&amp;rdquo;. PostgreSQL does not support self-referencing columns explicitly.</source>
          <target state="translated">유형이 지정된 테이블은 SQL 표준의 서브 세트를 구현합니다. 표준에 따르면, 유형이 지정된 테이블에는 기본 복합 유형에 해당하는 열과 &quot;자기 참조 열&quot;인 다른 열이 있습니다. PostgreSQL은 자체 참조 열을 명시 적으로 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5754e4191a491637e871b6ade422b1bcee16cbbf" translate="yes" xml:space="preserve">
          <source>Types of extended statistics enabled for this record</source>
          <target state="translated">이 레코드에 사용 가능한 확장 통계 유형</target>
        </trans-unit>
        <trans-unit id="30b55d03eac01f6040e3abe9feb9e154100f2081" translate="yes" xml:space="preserve">
          <source>Typical examples of an IPv4 address range specified this way are &lt;code&gt;172.20.143.89/32&lt;/code&gt; for a single host, or &lt;code&gt;172.20.143.0/24&lt;/code&gt; for a small network, or &lt;code&gt;10.6.0.0/16&lt;/code&gt; for a larger one. An IPv6 address range might look like &lt;code&gt;::1/128&lt;/code&gt; for a single host (in this case the IPv6 loopback address) or &lt;code&gt;fe80::7a31:c1ff:0000:0000/96&lt;/code&gt; for a small network. &lt;code&gt;0.0.0.0/0&lt;/code&gt; represents all IPv4 addresses, and &lt;code&gt;::0/0&lt;/code&gt; represents all IPv6 addresses. To specify a single host, use a mask length of 32 for IPv4 or 128 for IPv6. In a network address, do not omit trailing zeroes.</source>
          <target state="translated">IPv4 주소 범위의 전형적인 예는,이 방법은 지정된 &lt;code&gt;172.20.143.89/32&lt;/code&gt; 단일 호스트 또는 &lt;code&gt;172.20.143.0/24&lt;/code&gt; 작은 네트워크 또는 &lt;code&gt;10.6.0.0/16&lt;/code&gt; 한 큰 대. IPv6 주소 범위 는 단일 호스트 (이 경우 IPv6 루프백 주소)의 경우 &lt;code&gt;::1/128&lt;/code&gt; 또는 소규모 네트워크의 경우 &lt;code&gt;fe80::7a31:c1ff:0000:0000/96&lt;/code&gt; 과 같습니다 . &lt;code&gt;0.0.0.0/0&lt;/code&gt; 은 모든 IPv4 주소를 나타내고 &lt;code&gt;::0/0&lt;/code&gt; 은 모든 IPv6 주소를 나타냅니다. 단일 호스트를 지정하려면 IPv4의 경우 마스크 길이 32를, IPv6의 경우 128을 사용하십시오. 네트워크 주소에서 후행 0을 생략하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3ba7280f9a6416aff842d582d030dc0d547a8079" translate="yes" xml:space="preserve">
          <source>Typical examples would be:</source>
          <target state="translated">일반적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3ae6c139f98be74a60c4eaf214c1269190843b0" translate="yes" xml:space="preserve">
          <source>Typical output from pgbench looks like:</source>
          <target state="translated">pgbench의 일반적인 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f215729680a38802cfd4b9559a7e299252d552b" translate="yes" xml:space="preserve">
          <source>Typical output from this plugin, used over the SQL logical decoding interface, might be:</source>
          <target state="translated">SQL 논리 디코딩 인터페이스를 통해 사용되는이 플러그인의 일반적인 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d9380cc46b3004a735b71b1ddc5769ac9cc9d80" translate="yes" xml:space="preserve">
          <source>Typically a role being used as a group would not have the &lt;code&gt;LOGIN&lt;/code&gt; attribute, though you can set it if you wish.</source>
          <target state="translated">일반적으로 그룹으로 사용되는 역할에는 &lt;code&gt;LOGIN&lt;/code&gt; 속성이 없지만 원하는 경우 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c79e0bb5747a47177b68165db0b8e29d1e90432" translate="yes" xml:space="preserve">
          <source>Typically an &lt;code&gt;UPDATE&lt;/code&gt; command also needs to read data from columns in the relation being updated (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause, or in an expression on the right hand side of the &lt;code&gt;SET&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation being updated, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;UPDATE&lt;/code&gt; policies. Thus the user must have access to the row(s) being updated through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to update the row(s) via an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">일반적으로 &lt;code&gt;UPDATE&lt;/code&gt; 명령은 업데이트중인 관계의 열 (예 : &lt;code&gt;WHERE&lt;/code&gt; 절 또는 &lt;code&gt;RETURNING&lt;/code&gt; 절 또는 &lt;code&gt;SET&lt;/code&gt; 절의 오른쪽에있는 표현식)에서 데이터를 읽어야합니다 . 이 경우 업데이트되는 관계에 대해 &lt;code&gt;SELECT&lt;/code&gt; 권한이 필요 하며 &lt;code&gt;UPDATE&lt;/code&gt; 정책 외에 적절한 &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;ALL&lt;/code&gt; 정책이 적용됩니다 . 따라서 사용자는 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;ALL&lt;/code&gt; 정책을 통해 행을 업데이트 할 수있는 권한이 부여 될뿐만 아니라 &lt;code&gt;SELECT&lt;/code&gt; 또는 ALL 정책을 통해 업데이트되는 행에 액세스 할 수 있어야합니다. &lt;code&gt;ALL&lt;/code&gt; 정책.</target>
        </trans-unit>
        <trans-unit id="4a5dff53d37ef582f6443160c6077ab3c024f6ad" translate="yes" xml:space="preserve">
          <source>Typically libraries like libpq only add new functionality, again unless mentioned in the release notes.</source>
          <target state="translated">릴리스 노트에 언급되지 않은 경우 일반적으로 libpq와 같은 라이브러리는 새로운 기능 만 다시 추가합니다.</target>
        </trans-unit>
        <trans-unit id="74be98305cce33f0717978700ff85879bd035ba2" translate="yes" xml:space="preserve">
          <source>Typically that would be written in an extension's creation script, and users would do this to install the extension:</source>
          <target state="translated">일반적으로 확장의 생성 스크립트에 작성되며 사용자는 확장을 설치하기 위해 이렇게합니다.</target>
        </trans-unit>
        <trans-unit id="d506067679b9e62e7a37578f7129dcc3d999cc58" translate="yes" xml:space="preserve">
          <source>Typically this includes new SQL command capabilities and not changes in behavior, unless specifically mentioned in the release notes.</source>
          <target state="translated">일반적으로 릴리스 노트에서 특별히 언급하지 않는 한 새로운 SQL 명령 기능이 포함되며 동작 변경은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3822092fc5f3e669e643e30f8ce5e23c88a10d9c" translate="yes" xml:space="preserve">
          <source>Typically weights are used to mark words from special areas of the document, like the title or an initial abstract, so they can be treated with more or less importance than words in the document body.</source>
          <target state="translated">일반적으로 가중치는 제목이나 초기 초록과 같이 문서의 특정 영역에서 단어를 표시하는 데 사용되므로 문서 본문의 단어보다 중요도가 더 높거나 덜 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ec6d184c198c058b18b104c2264bc1718aff70" translate="yes" xml:space="preserve">
          <source>UNION, CASE, and Related Constructs</source>
          <target state="translated">UNION, CASE 및 관련 구문</target>
        </trans-unit>
        <trans-unit id="e85ec09bfd030dc1a5734a458795c226244fc313" translate="yes" xml:space="preserve">
          <source>UNLISTEN</source>
          <target state="translated">UNLISTEN</target>
        </trans-unit>
        <trans-unit id="4e75e16efe1381bdf958afc52921070dcac9674c" translate="yes" xml:space="preserve">
          <source>UNLISTEN &amp;mdash; stop listening for a notification</source>
          <target state="translated">UNLISTEN &amp;mdash; 알림 수신 중지</target>
        </trans-unit>
        <trans-unit id="e42fbf3248836a2bda1822a0f26f66440fa0c899" translate="yes" xml:space="preserve">
          <source>UPC &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">UPC &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="8ea457eae40d594e81201972c4abd897fed37408" translate="yes" xml:space="preserve">
          <source>UPC numbers are a subset of the EAN13 numbers (they are basically EAN13 without the first &lt;code&gt;0&lt;/code&gt; digit).</source>
          <target state="translated">UPC 번호는 EAN13 번호의 하위 집합입니다 (기본적으로 처음 &lt;code&gt;0&lt;/code&gt; 자리가 없는 EAN13입니다 ).</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="391f048e928d94ac0bc9a0124d925ff0ab247d37" translate="yes" xml:space="preserve">
          <source>UPDATE &amp;mdash; update rows of a table</source>
          <target state="translated">UPDATE &amp;mdash; 테이블의 행을 업데이트</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="5bc5065b4243467de49ffd6feb4dc052247ba467" translate="yes" xml:space="preserve">
          <source>URL locations can be canonicalized to make equivalent URLs match:</source>
          <target state="translated">동등한 URL을 일치시키기 위해 URL 위치를 표준화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1156d91b64895766702da1dac1a03bdacc18d8" translate="yes" xml:space="preserve">
          <source>URL path</source>
          <target state="translated">URL 경로</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="618f65101275eae124d9a7c9c7a5431c588e88d8" translate="yes" xml:space="preserve">
          <source>UTF</source>
          <target state="translated">UTF</target>
        </trans-unit>
        <trans-unit id="006a48ffb6b1c6d449c6f984e56102797a110071" translate="yes" xml:space="preserve">
          <source>UTF-8 (8-bit UCS/Unicode Transformation Format) is defined here.</source>
          <target state="translated">UTF-8 (8 비트 UCS / 유니 코드 변환 형식)이 여기에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fa9ad7f9065e92883a9407e908d043b05c218a2" translate="yes" xml:space="preserve">
          <source>UTF8</source>
          <target state="translated">UTF8</target>
        </trans-unit>
        <trans-unit id="21bf75a5255af008f6315cb6aca4bb3bdccee521" translate="yes" xml:space="preserve">
          <source>UUID</source>
          <target state="translated">UUID</target>
        </trans-unit>
        <trans-unit id="cd5f8485e99e1466105fe2ccda1a6e32ac64f458" translate="yes" xml:space="preserve">
          <source>UUID Functions</source>
          <target state="translated">UUID 함수</target>
        </trans-unit>
        <trans-unit id="0b3aa0aafa91ea5c6d6154167ed0f9530a1ec26c" translate="yes" xml:space="preserve">
          <source>UUID Type</source>
          <target state="translated">UUID 유형</target>
        </trans-unit>
        <trans-unit id="0a7e35cb9fd13ab0f8bc30cc95fe3965c0075fa2" translate="yes" xml:space="preserve">
          <source>Unary plus (no operation)</source>
          <target state="translated">단항 더하기 (작동 없음)</target>
        </trans-unit>
        <trans-unit id="c93712543c02319baab11b2b81799e7e791b6f5f" translate="yes" xml:space="preserve">
          <source>Unary plus (no operation); unlike addition, this can iterate over multiple values</source>
          <target state="translated">단항 플러스 (작동 없음); 덧셈과 달리 여러 값을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbfa247ab63ebe054b1f625efaac8d7d2ed2786f" translate="yes" xml:space="preserve">
          <source>Unconditionally trace locks on this table (OID).</source>
          <target state="translated">이 테이블에 대한 무조건 추적 잠금 (OID).</target>
        </trans-unit>
        <trans-unit id="1a26494bd46f598c2d3b286cc32f8f8da4c3c529" translate="yes" xml:space="preserve">
          <source>Undo that, restoring whatever setting was effective in &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 에서 효과적인 설정을 복원하여 실행 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="d82f20269a7ba351c65d96d467573f44ed2241db" translate="yes" xml:space="preserve">
          <source>Undo the above, so that subsequently-created tables won't have any more permissions than normal:</source>
          <target state="translated">이후에 생성 된 테이블에 일반보다 더 많은 권한이 없도록 위의 명령을 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="69537adb0c6a954242641822e574baa70cf65b67" translate="yes" xml:space="preserve">
          <source>Unexpected results might be obtained if a &lt;code&gt;cache&lt;/code&gt; setting greater than one is used for a sequence object that will be used concurrently by multiple sessions. Each session will allocate and cache successive sequence values during one access to the sequence object and increase the sequence object's &lt;code&gt;last_value&lt;/code&gt; accordingly. Then, the next &lt;code&gt;cache&lt;/code&gt;-1 uses of &lt;code&gt;nextval&lt;/code&gt; within that session simply return the preallocated values without touching the sequence object. So, any numbers allocated but not used within a session will be lost when that session ends, resulting in &amp;ldquo;holes&amp;rdquo; in the sequence.</source>
          <target state="translated">여러 세션에서 동시에 사용되는 시퀀스 객체에 &lt;code&gt;cache&lt;/code&gt; 설정이 1보다 큰 경우 예기치 않은 결과가 발생할 수 있습니다 . 각 세션은 시퀀스 객체에 한 번 액세스하는 동안 연속적인 시퀀스 값을 할당 및 캐시하고 &lt;code&gt;last_value&lt;/code&gt; 따라 시퀀스 객체의 last_value를 증가시킵니다 . 그런 다음 해당 세션 내 에서 &lt;code&gt;nextval&lt;/code&gt; 의 다음 &lt;code&gt;cache&lt;/code&gt; -1 사용은 시퀀스 객체를 건드리지 않고 미리 할당 된 값을 반환합니다. 따라서 세션 내에서 할당되었지만 사용되지 않은 숫자는 해당 세션이 종료 될 때 손실되어 시퀀스에 &quot;구멍&quot;이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="bac601add3bc88ae7a8e23e81f98747db513fcef" translate="yes" xml:space="preserve">
          <source>Unfortunately, there is no well-defined method for determining ideal values for the cost variables. They are best treated as averages over the entire mix of queries that a particular installation will receive. This means that changing them on the basis of just a few experiments is very risky.</source>
          <target state="translated">불행히도, 비용 변수에 대한 이상적인 값을 결정하기위한 잘 정의 된 방법은 없습니다. 특정 설치에서 수신 할 전체 쿼리 조합에 대한 평균으로 가장 잘 처리됩니다. 이것은 단지 몇 번의 실험에 기초하여 그것들을 바꾸는 것이 매우 위험하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5477f70b1eea785630b35cd84e386522cded5715" translate="yes" xml:space="preserve">
          <source>Unicode Transformation Format</source>
          <target state="translated">유니 코드 변환 형식</target>
        </trans-unit>
        <trans-unit id="8de2de87fc64e84d8c1aa641cad76e717bc7b29c" translate="yes" xml:space="preserve">
          <source>Unicode, 8-bit</source>
          <target state="translated">유니 코드, 8 비트</target>
        </trans-unit>
        <trans-unit id="93a858d6fa1dc81e7eaad3250789d05cb036b8fa" translate="yes" xml:space="preserve">
          <source>Unified Hangul Code</source>
          <target state="translated">통합 한글 코드</target>
        </trans-unit>
        <trans-unit id="67ef7a3b2dde1ee8d6d2f80347f89266789839b9" translate="yes" xml:space="preserve">
          <source>Uniform Resource Locator</source>
          <target state="translated">유니폼 리소스 로케이터</target>
        </trans-unit>
        <trans-unit id="86a932dd65a48b174d2aada36f1bfffd412deac8" translate="yes" xml:space="preserve">
          <source>Unique Indexes</source>
          <target state="translated">고유 인덱스</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="translated">독특한 제약</target>
        </trans-unit>
        <trans-unit id="94adb10ebc944ac8b8156528bb8fd8dc3337202a" translate="yes" xml:space="preserve">
          <source>Unique constraints (and hence primary keys) on partitioned tables must include all the partition key columns. This limitation exists because PostgreSQL can only enforce uniqueness in each partition individually.</source>
          <target state="translated">파티션을 나눈 테이블의 고유 한 제약 조건 (및 기본 키)에는 모든 파티션 키 열이 포함되어야합니다. 이 제한은 PostgreSQL이 각 파티션에서 개별적으로 만 고유성을 적용 할 수 있기 때문에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="b4e5e39c7a8efbcd5a2b7282c47950080c8841cd" translate="yes" xml:space="preserve">
          <source>Unique constraints and primary keys are not inherited in the current implementation. This makes the combination of inheritance and unique constraints rather dysfunctional.</source>
          <target state="translated">현재 구현에서는 고유 제한 조건 및 기본 키가 상속되지 않습니다. 이로 인해 상속과 고유 제한 조건의 조합이 다소 기능 장애가됩니다.</target>
        </trans-unit>
        <trans-unit id="a46827700fc4ef4d046ba4ec7203d49efc58d66f" translate="yes" xml:space="preserve">
          <source>Unique constraints ensure that the data contained in a column, or a group of columns, is unique among all the rows in the table. The syntax is:</source>
          <target state="translated">고유 제한 조건은 열 또는 열 그룹에 포함 된 데이터가 테이블의 모든 행에서 고유한지 확인합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9aef8c8c0041d90e74399130137479516c8ba5f" translate="yes" xml:space="preserve">
          <source>Unique constraints on partitioned tables must include all the partition key columns. This limitation exists because PostgreSQL can only enforce uniqueness in each partition individually.</source>
          <target state="translated">파티션 된 테이블의 고유 제한 조건에는 모든 파티션 키 열이 포함되어야합니다. PostgreSQL은 각 파티션에서 개별적으로 만 고유성을 시행 할 수 있기 때문에 이러한 제한이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="9ef954009038fb621257b004ec6cd8cd826ed58e" translate="yes" xml:space="preserve">
          <source>Unique prefixes of these strings are also accepted, for example &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt;. Leading or trailing whitespace is ignored, and case does not matter.</source>
          <target state="translated">이러한 문자열의 고유 접두어도 허용됩니다 (예 : &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;n&lt;/code&gt; ) . 선행 또는 후행 공백은 무시되며 대소 ​​문자는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f49788f44915bd3a94e16e6f26e2424dc403e286" translate="yes" xml:space="preserve">
          <source>Universal Product Codes</source>
          <target state="translated">범용 제품 코드</target>
        </trans-unit>
        <trans-unit id="b3357a0d067580c052d7ebc854b226e0d5262199" translate="yes" xml:space="preserve">
          <source>Universally Unique Identifier</source>
          <target state="translated">보편적으로 고유 한 식별자</target>
        </trans-unit>
        <trans-unit id="49e71ce661ccc6dfcd03e849d0ea4cd3cac1c011" translate="yes" xml:space="preserve">
          <source>Unix System V</source>
          <target state="translated">유닉스 시스템 V</target>
        </trans-unit>
        <trans-unit id="356c3f979b3eb09e01dc5a248ce81de4df5a2076" translate="yes" xml:space="preserve">
          <source>Unix-like operating systems enforce various kinds of resource limits that might interfere with the operation of your PostgreSQL server. Of particular importance are limits on the number of processes per user, the number of open files per process, and the amount of memory available to each process. Each of these have a &amp;ldquo;hard&amp;rdquo; and a &amp;ldquo;soft&amp;rdquo; limit. The soft limit is what actually counts but it can be changed by the user up to the hard limit. The hard limit can only be changed by the root user. The system call &lt;code&gt;setrlimit&lt;/code&gt; is responsible for setting these parameters. The shell's built-in command &lt;code&gt;ulimit&lt;/code&gt; (Bourne shells) or &lt;code&gt;limit&lt;/code&gt; (csh) is used to control the resource limits from the command line. On BSD-derived systems the file &lt;code&gt;/etc/login.conf&lt;/code&gt; controls the various resource limits set during login. See the operating system documentation for details. The relevant parameters are &lt;code&gt;maxproc&lt;/code&gt;, &lt;code&gt;openfiles&lt;/code&gt;, and &lt;code&gt;datasize&lt;/code&gt;. For example:</source>
          <target state="translated">유닉스 계열 운영 체제는 PostgreSQL 서버의 작동을 방해 할 수있는 다양한 종류의 리소스 제한을 시행합니다. 사용자 당 프로세스 수, 프로세스 당 열린 파일 수 및 각 프로세스에 사용 가능한 메모리 양에 대한 제한이 특히 중요합니다. 이들 각각에는 &quot;하드&quot;및 &quot;소프트&quot;한계가 있습니다. 소프트 한계는 실제로 계산되지만 사용자가 하드 한계까지 변경할 수 있습니다. 하드 한계는 루트 사용자 만 변경할 수 있습니다. 시스템 호출 &lt;code&gt;setrlimit&lt;/code&gt; 는 이러한 매개 변수 설정을 담당합니다. 쉘의 내장 명령 &lt;code&gt;ulimit&lt;/code&gt; (Bourne 쉘) 또는 &lt;code&gt;limit&lt;/code&gt; (csh)는 명령 행에서 자원 한계를 제어하는 ​​데 사용됩니다. BSD 파생 시스템에서 &lt;code&gt;/etc/login.conf&lt;/code&gt; 파일로그인 중에 설정된 다양한 자원 제한을 제어합니다. 자세한 내용은 운영 체제 설명서를 참조하십시오. 관련 매개 변수는 &lt;code&gt;maxproc&lt;/code&gt; , &lt;code&gt;openfiles&lt;/code&gt; 및 &lt;code&gt;datasize&lt;/code&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a738963ffda0371927d9ea96b648a8947fa84b5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;WITH HOLD&lt;/code&gt; is specified, the cursor created by this command can only be used within the current transaction. Thus, &lt;code&gt;DECLARE&lt;/code&gt; without &lt;code&gt;WITH HOLD&lt;/code&gt; is useless outside a transaction block: the cursor would survive only to the completion of the statement. Therefore PostgreSQL reports an error if such a command is used outside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; (or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;) to define a transaction block.</source>
          <target state="translated">&lt;code&gt;WITH HOLD&lt;/code&gt; 를 지정 하지 않으면 이 명령으로 작성된 커서는 현재 트랜잭션 내에서만 사용할 수 있습니다. 따라서, &lt;code&gt;DECLARE&lt;/code&gt; 없이 &lt;code&gt;WITH HOLD&lt;/code&gt; 쓸모 외부 트랜잭션 블록입니다 : 커서는 명령문의 완료에 살아남을 것입니다. 따라서 PostgreSQL은 이러한 명령이 트랜잭션 블록 외부에서 사용되는 경우 오류를보고합니다. 사용은 &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; 및 &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; (또는 &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; 트랜잭션 블록을 정의하기 위해).</target>
        </trans-unit>
        <trans-unit id="f36df6a348af57e59d7545a3e535407a26fb9186" translate="yes" xml:space="preserve">
          <source>Unless it is passed an &lt;code&gt;-X&lt;/code&gt; option, psql attempts to read and execute commands from the system-wide startup file (&lt;code&gt;psqlrc&lt;/code&gt;) and then the user's personal startup file (&lt;code&gt;~/.psqlrc&lt;/code&gt;), after connecting to the database but before accepting normal commands. These files can be used to set up the client and/or the server to taste, typically with &lt;code&gt;\set&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;-X&lt;/code&gt; 옵션 이 전달되지 않으면 psql 은 데이터베이스에 연결 한 후 일반 명령을 수락하기 전에 시스템 전체 시작 파일 ( &lt;code&gt;psqlrc&lt;/code&gt; )과 사용자 개인 시작 파일 ( &lt;code&gt;~/.psqlrc&lt;/code&gt; .psqlrc ) 에서 명령을 읽고 실행하려고 시도 합니다. . 이 파일은 일반적으로 &lt;code&gt;\set&lt;/code&gt; 및 &lt;code&gt;SET&lt;/code&gt; 명령을 사용하여 클라이언트 및 / 또는 서버를 설정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ebac9c6005801410e118c32c680d55ed8b8c195" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;, there is no large performance advantage to loading a library at session start rather than when it is first used. There is some advantage, however, when connection pooling is used.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; 와 달리 라이브러리를 처음 사용할 때가 아니라 세션을 시작할 때 라이브러리를로드 할 때 큰 성능 이점이 없습니다. 그러나 연결 풀링을 사용하면 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f97215c9ceadf639797c9ff18cfda7e2adaae5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INHERITS&lt;/code&gt;, the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table.</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; 와 달리 새 테이블과 원본 테이블은 생성이 완료된 후 완전히 분리됩니다. 원본 테이블에 대한 변경 사항은 새 테이블에 적용되지 않으며 원본 테이블 스캔에 새 테이블의 데이터를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="155a510971d12c46f75bfa7a5024bf809f98a32b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;statement_timeout&lt;/code&gt;, this timeout can only occur while waiting for locks. Note that if &lt;code&gt;statement_timeout&lt;/code&gt; is nonzero, it is rather pointless to set &lt;code&gt;lock_timeout&lt;/code&gt; to the same or larger value, since the statement timeout would always trigger first. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will be logged.</source>
          <target state="translated">&lt;code&gt;statement_timeout&lt;/code&gt; 과 달리이 시간 초과는 잠금을 기다리는 동안에 만 발생할 수 있습니다. &lt;code&gt;statement_timeout&lt;/code&gt; 이 0이 아닌 경우 명령문 시간 종료가 항상 먼저 트리거되므로 &lt;code&gt;lock_timeout&lt;/code&gt; 을 같거나 더 큰 값 으로 설정하는 것은 의미가 없습니다 . &lt;code&gt;log_min_error_statement&lt;/code&gt; 가 &lt;code&gt;ERROR&lt;/code&gt; 이하 로 설정 되면 시간 종료 된 명령문이 로그됩니다.</target>
        </trans-unit>
        <trans-unit id="01f67f25338b64081817dcfc5c06974c9678164c" translate="yes" xml:space="preserve">
          <source>Unlike an XQuery/XPath sequence, which can contain any desired items in any desired order, an XPath 1.0 node-set has no guaranteed order and, like any set, does not allow multiple appearances of the same item.</source>
          <target state="translated">원하는 순서로 원하는 항목을 포함 할 수있는 XQuery / XPath 시퀀스와 달리 XPath 1.0 노드 세트는 보장 된 순서가 없으며 다른 세트와 마찬가지로 동일한 항목의 여러 모양을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bd39bd8bedec3e142d1db4767a229ec44898026" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\!&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">대부분의 다른 메타 명령과 달리 나머지 줄 전체는 항상 &lt;code&gt;\!&lt;/code&gt; 의 인수로 간주됩니다 ! 인수에서 변수 보간이나 역 따옴표 확장이 수행되지 않습니다. 나머지 줄은 문자 그대로 쉘로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f03bc80a9071747274c116c1e2637b147c1236d6" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\ef&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">대부분의 다른 메타 명령과 달리 나머지 행 전체는 항상 &lt;code&gt;\ef&lt;/code&gt; 의 인수로 간주되며 인수에서 변수 보간이나 역 따옴표 확장이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ad59f5d51ac2d51e40eadad80e70c35b9563ffa" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\ev&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">대부분의 다른 메타 명령과 달리 나머지 행 전체는 항상 &lt;code&gt;\ev&lt;/code&gt; 의 인수로 간주되며 인수에서 변수 보간이나 백 따옴표 확장이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="969a2dc5b4f67a3964fc411e75789aab5f823e51" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\help&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">대부분의 다른 메타 명령과 달리 줄의 나머지 부분은 항상 &lt;code&gt;\help&lt;/code&gt; 의 인수로 간주되며 인수에서 변수 보간이나 역 따옴표 확장이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bcb7b9bd68e7cf599cb0566f121f159d3638a90" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\sf&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">대부분의 다른 메타 명령과 달리 나머지 행 전체는 항상 &lt;code&gt;\sf&lt;/code&gt; 의 인수로 간주되며 인수에서 변수 보간이나 역 따옴표 확장이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3d8189c59a9d485c225bb21085a7dacfbf70328" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\sv&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">대부분의 다른 메타 명령과 달리 나머지 행 전체는 항상 &lt;code&gt;\sv&lt;/code&gt; 의 인수로 간주되며 인수에서 변수 보간이나 역 따옴표 확장이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af5b4f9ec65cdc48545903249d2323c25ceebafa" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_database&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_database&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_database&lt;/code&gt; 는 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_database&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4e709aa40757d88375a6ee47a77d6e0698e4303" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_db_role_setting&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_db_role_setting&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_db_role_setting&lt;/code&gt; 은 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_db_role_setting&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dbf1c1060e2c0aacae52353ec7fcd45b3ccceac" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_pltemplate&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_pltemplate&lt;/code&gt; per cluster, not one per database. This allows the information to be accessible in each database as it is needed.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_pltemplate&lt;/code&gt; 는 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_pltemplate&lt;/code&gt; 사본 만 있습니다. 이를 통해 필요에 따라 각 데이터베이스에서 정보에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90ff2576b542214d688a9eed4987d1a4510c063b" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_replication_origin&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_replication_origin&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_replication_origin&lt;/code&gt; 은 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_replication_origin&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="091dfd81e1c158b99b74cd5401b694679d3d2a31" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shdepend&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shdepend&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_shdepend&lt;/code&gt; 는 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_shdepend&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1cd5b470b7693ec3b4e72d1482e8ab6f1102fe7" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shdescription&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shdescription&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_shdescription&lt;/code&gt; 은 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_shdescription&lt;/code&gt; 복사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="45f9981f7d01238e6386247ed7e8c9b367559cb4" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shseclabel&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shseclabel&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_shseclabel&lt;/code&gt; 은 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_shseclabel&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="eec8ee0cfbfbe1f6f908ff68c376680c64650f41" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_subscription&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_subscription&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_subscription&lt;/code&gt; 은 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_subscription&lt;/code&gt; 복사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b07b56a669f78b6086b457c5748686a76e734e9" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_tablespace&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_tablespace&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">대부분의 시스템 카탈로그와 달리 &lt;code&gt;pg_tablespace&lt;/code&gt; 는 클러스터의 모든 데이터베이스에서 공유 됩니다. 데이터베이스 당 하나가 아니라 클러스터 당 하나의 &lt;code&gt;pg_tablespace&lt;/code&gt; 사본 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="92c63faeedbf5e16bc5b93cceba5f7d683c79fc1" translate="yes" xml:space="preserve">
          <source>Unlike the WAL receiver of a PostgreSQL standby server, pg_receivewal by default flushes WAL data only when a WAL file is closed. The option &lt;code&gt;--synchronous&lt;/code&gt; must be specified to flush WAL data in real time. Since pg_receivewal does not apply WAL, you should not allow it to become a synchronous standby when &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; equals &lt;code&gt;remote_apply&lt;/code&gt;. If it does, it will appear to be a standby that never catches up, and will cause transaction commits to block. To avoid this, you should either configure an appropriate value for &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt;, or specify &lt;code&gt;application_name&lt;/code&gt; for pg_receivewal that does not match it, or change the value of &lt;code&gt;synchronous_commit&lt;/code&gt; to something other than &lt;code&gt;remote_apply&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 대기 서버의 WAL 수신기와 달리 pg_receivewal은 기본적으로 WAL 파일이 닫힐 때만 WAL 데이터를 플러시합니다. WAL 데이터를 실시간으로 플러시하려면 &lt;code&gt;--synchronous&lt;/code&gt; 옵션을 지정해야합니다. pg_receivewal은 WAL을 적용하지 않으므로 &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; 이 &lt;code&gt;remote_apply&lt;/code&gt; 와 같을 때 WAL이 동기 대기가되도록 허용해서는 안됩니다 . 그렇지 않으면 대기하지 않는 것으로 보이며 트랜잭션 커밋이 차단됩니다. 이를 피하려면 &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names에&lt;/a&gt; 적절한 값을 구성 하거나 일치하지 않는 pg_receivewal에 &lt;code&gt;application_name&lt;/code&gt; 을 지정 하거나 &lt;code&gt;synchronous_commit&lt;/code&gt; 값을 다른 값으로 변경해야합니다 &lt;code&gt;remote_apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="209b27f026f1a4e49e27f779263f8527ec3c4bc5" translate="yes" xml:space="preserve">
          <source>Unlike the case when adding a constraint to a regular table, nothing is done to verify the constraint is correct; rather, this action simply declares that some new condition should be assumed to hold for all rows in the foreign table. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.) If the constraint is marked &lt;code&gt;NOT VALID&lt;/code&gt;, then it isn't assumed to hold, but is only recorded for possible future use.</source>
          <target state="translated">일반 테이블에 제약 조건을 추가 할 때와 달리 제약 조건이 올바른지 확인하는 작업은 없습니다. 오히려이 조치는 외부 테이블의 모든 행에 대해 일부 새로운 조건이 유지되어야한다고 선언합니다. ( &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 의 설명을 참조하십시오 .) 제한 조건이 &lt;code&gt;NOT VALID&lt;/code&gt; 로 표시되는 경우 제한 조건으로 간주되지 않고 나중에 사용할 수 있도록 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8b364554eb1587843dacba831a236e3430803901" translate="yes" xml:space="preserve">
          <source>Unlike the case with privileges, membership in a role cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt;.</source>
          <target state="translated">권한이있는 경우와 달리 역할의 멤버십은 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 할 수 없습니다 . 또한이 형식의 명령은 &lt;code&gt;role_specification&lt;/code&gt; 에서 의미없는 단어 &lt;code&gt;GROUP&lt;/code&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4e0b1d236f8fe0f3fb7bccf02c7559e609f29c15" translate="yes" xml:space="preserve">
          <source>Unlike the case with privileges, membership in a role cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">권한이있는 경우와 달리 역할 멤버 자격은 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 될 수 없습니다 . 또한이 형식의 명령은 노이즈 단어 &lt;code&gt;GROUP&lt;/code&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d61210b660dd2a2ba353539f0d486b1b1e1ca0f9" translate="yes" xml:space="preserve">
          <source>Unlike the standard C function &lt;code&gt;sprintf&lt;/code&gt;, PostgreSQL's &lt;code&gt;format&lt;/code&gt; function allows format specifiers with and without &lt;code&gt;position&lt;/code&gt; fields to be mixed in the same format string. A format specifier without a &lt;code&gt;position&lt;/code&gt; field always uses the next argument after the last argument consumed. In addition, the &lt;code&gt;format&lt;/code&gt; function does not require all function arguments to be used in the format string. For example:</source>
          <target state="translated">표준 C 함수 &lt;code&gt;sprintf&lt;/code&gt; 와 달리 PostgreSQL의 &lt;code&gt;format&lt;/code&gt; 함수를 사용하면 &lt;code&gt;position&lt;/code&gt; 필드가 있거나 없는 형식 지정자를 동일한 형식 문자열로 혼합 할 수 있습니다. &lt;code&gt;position&lt;/code&gt; 필드가 없는 형식 지정자는 항상 마지막으로 사용한 인수 다음에 다음 인수를 사용합니다. 또한 &lt;code&gt;format&lt;/code&gt; 함수는 모든 함수 인수를 형식 문자열에 사용할 필요는 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42d22ba12e56f3a8c0a56dce7ddb132f01963118" translate="yes" xml:space="preserve">
          <source>Unlike the standard C function &lt;code&gt;sprintf&lt;/code&gt;, PostgreSQL's &lt;code&gt;format&lt;/code&gt; function allows format specifiers with and without &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; fields to be mixed in the same format string. A format specifier without a &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; field always uses the next argument after the last argument consumed. In addition, the &lt;code&gt;format&lt;/code&gt; function does not require all function arguments to be used in the format string. For example:</source>
          <target state="translated">표준 C 함수 &lt;code&gt;sprintf&lt;/code&gt; 와 달리 PostgreSQL의 &lt;code&gt;format&lt;/code&gt; 함수는 &lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt; 필드가 있거나 없는 형식 지정자를 동일한 형식 문자열에서 혼합 할 수 있습니다. &lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt; 필드가 없는 형식 지정자는 항상 사용 된 마지막 인수 다음의 다음 인수를 사용합니다. 또한 &lt;code&gt;format&lt;/code&gt; 함수는 형식 문자열에서 사용되는 모든 함수 인수를 요구하지 않습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="56340fd933fcc44d2d615474f7eee7f478fca5bb" translate="yes" xml:space="preserve">
          <source>Unlogged</source>
          <target state="translated">Unlogged</target>
        </trans-unit>
        <trans-unit id="b45f16ac00bccd2d97ad31eb4586a8a733d1ed1a" translate="yes" xml:space="preserve">
          <source>Unsets (deletes) the psql variable &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">psql 변수 &lt;code&gt;name&lt;/code&gt; 을 설정 해제 (삭제)합니다 .</target>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">부호없는 정수</target>
        </trans-unit>
        <trans-unit id="50b79815e623c9d659af2f6f4f16ea14ba889265" translate="yes" xml:space="preserve">
          <source>Unused column contain zeroes. For example, &lt;code&gt;oprleft&lt;/code&gt; is zero for a prefix operator.</source>
          <target state="translated">사용하지 않는 열에는 0이 포함됩니다. 예를 들어 접두사 연산자의 경우 &lt;code&gt;oprleft&lt;/code&gt; 는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2038bdec9210202d0d9d74839e3925ff0cd91ba1" translate="yes" xml:space="preserve">
          <source>Up</source>
          <target state="translated">Up</target>
        </trans-unit>
        <trans-unit id="d7530c6545fdfa9b651c7e47222acdb144b78573" translate="yes" xml:space="preserve">
          <source>Updatable Views</source>
          <target state="translated">업데이트 가능한 뷰</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="6f08e7604a29958aee71de0f6521d5ea65d07570" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;autoprewarm.blocks&lt;/code&gt; immediately. This may be useful if the autoprewarm worker is not running but you anticipate running it after the next restart. The return value is the number of records written to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;autoprewarm.blocks&lt;/code&gt; 를 즉시 업데이트 하십시오. 이는 자동 예열 작업자가 실행되고 있지 않지만 다음에 다시 시작한 후에 실행할 것으로 예상되는 경우에 유용 할 수 있습니다. 리턴 값은 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; 에 기록 된 레코드 수입니다 .</target>
        </trans-unit>
        <trans-unit id="dd357ab63dd67dab2769f9aad042acbec503d583" translate="yes" xml:space="preserve">
          <source>Update a pre-9.1 installation of &lt;code&gt;hstore&lt;/code&gt; into extension style:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 9.1 이전 설치 를 확장 스타일로 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="155fdafe50a3b57765513f60c5758d6496a123b2" translate="yes" xml:space="preserve">
          <source>Update contact names in an accounts table to match the currently assigned salesmen:</source>
          <target state="translated">현재 할당 된 영업 사원과 일치하도록 계정 테이블에서 연락처 이름을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="a54b58d6201c8e67be3e5d043168cab0aaf4bd7b" translate="yes" xml:space="preserve">
          <source>Update statistics in a summary table to match the current data:</source>
          <target state="translated">현재 데이터와 일치하도록 요약 테이블에서 통계를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="a72e347972a409d75e922a98a8cb86184a8c091e" translate="yes" xml:space="preserve">
          <source>Update the collation's version. See &lt;a href=&quot;sql-altercollation#SQL-ALTERCOLLATION-NOTES&quot;&gt;Notes&lt;/a&gt; below.</source>
          <target state="translated">데이터 정렬 버전을 업데이트하십시오. 아래 참고 &lt;a href=&quot;sql-altercollation#SQL-ALTERCOLLATION-NOTES&quot;&gt;사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="886aa2619ee6c1b5dcabc291df392328e61fad29" translate="yes" xml:space="preserve">
          <source>Update the sequence value after a &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; 후에 시퀀스 값을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="40cf1fe41c48155dea09e4ac1106c72553cfd43c" translate="yes" xml:space="preserve">
          <source>Updates statistics used by the planner to determine the most efficient way to execute a query.</source>
          <target state="translated">쿼리를 실행하는 가장 효율적인 방법을 결정하기 위해 플래너가 사용하는 통계를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="dd8ce06e479993fd7940ea48abaafb1c49415931" translate="yes" xml:space="preserve">
          <source>Updating Data</source>
          <target state="translated">데이터 업데이트</target>
        </trans-unit>
        <trans-unit id="bbfacc342802549d59dc86ad3b2d308cd32c8b65" translate="yes" xml:space="preserve">
          <source>Updating a GIN index tends to be slow because of the intrinsic nature of inverted indexes: inserting or updating one heap row can cause many inserts into the index (one for each key extracted from the indexed item). As of PostgreSQL 8.4, GIN is capable of postponing much of this work by inserting new tuples into a temporary, unsorted list of pending entries. When the table is vacuumed or autoanalyzed, or when &lt;code&gt;gin_clean_pending_list&lt;/code&gt; function is called, or if the pending list becomes larger than &lt;a href=&quot;runtime-config-client#GUC-GIN-PENDING-LIST-LIMIT&quot;&gt;gin_pending_list_limit&lt;/a&gt;, the entries are moved to the main GIN data structure using the same bulk insert techniques used during initial index creation. This greatly improves GIN index update speed, even counting the additional vacuum overhead. Moreover the overhead work can be done by a background process instead of in foreground query processing.</source>
          <target state="translated">거꾸로 된 인덱스의 본질적인 특성으로 인해 GIN 인덱스 업데이트가 느려지는 경향이 있습니다. 하나의 힙 행을 삽입하거나 업데이트하면 인덱스에 많은 삽입이 발생할 수 있습니다 (인덱싱 된 항목에서 추출 된 각 키마다 하나씩). PostgreSQL 8.4부터 GIN은 새로운 튜플을 임시 정렬되지 않은 보류중인 항목 목록에 삽입하여이 작업의 대부분을 연기 할 수 있습니다. 테이블이 진공 또는 자동 분석되거나 &lt;code&gt;gin_clean_pending_list&lt;/code&gt; 함수가 호출 될 때 또는 보류 목록이 &lt;a href=&quot;runtime-config-client#GUC-GIN-PENDING-LIST-LIMIT&quot;&gt;gin_pending_list_limit&lt;/a&gt; 보다 커지는 경우, 항목은 초기 색인 작성 중에 사용 된 것과 동일한 대량 삽입 기술을 사용하여 기본 GIN 데이터 구조로 이동됩니다. 이를 통해 GIN 인덱스 업데이트 속도가 크게 향상되고 추가 진공 오버 헤드도 계산됩니다. 또한 오버 헤드 작업은 포 그라운드 쿼리 처리 대신 백그라운드 프로세스로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a2d3257a7cb0893d951688c3d6595c16276249" translate="yes" xml:space="preserve">
          <source>Updating the partition key of a row might cause it to be moved into a different partition where this row satisfies the partition bounds.</source>
          <target state="translated">행의 파티션 키를 업데이트하면이 행이 파티션 경계를 만족하는 다른 파티션으로 이동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5d0b369531663af264541c44e93e18c3ec6ca5" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster</source>
          <target state="translated">PostgreSQL 클러스터 업그레이드</target>
        </trans-unit>
        <trans-unit id="953812b4543e49a3e367bde451848478a686a885" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via Replication</source>
          <target state="translated">PostgreSQL 클러스터 업그레이드 : 복제를 통한 데이터 업그레이드</target>
        </trans-unit>
        <trans-unit id="2a87484838982cc6d197b8aae2ccdf6a9936eca6" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via pg_dumpall</source>
          <target state="translated">PostgreSQL 클러스터 업그레이드 : pg_dumpall을 통한 데이터 업그레이드</target>
        </trans-unit>
        <trans-unit id="725bfd4bce7d201deda730473db6dfc713d4524b" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via pg_upgrade</source>
          <target state="translated">PostgreSQL 클러스터 업그레이드 : pg_upgrade를 통한 데이터 업그레이드</target>
        </trans-unit>
        <trans-unit id="4b80cb33cf9b567178f3f5855946aac8c80e285f" translate="yes" xml:space="preserve">
          <source>Upon creation, a constraint is given one of three characteristics: &lt;code&gt;DEFERRABLE INITIALLY DEFERRED&lt;/code&gt;, &lt;code&gt;DEFERRABLE INITIALLY IMMEDIATE&lt;/code&gt;, or &lt;code&gt;NOT DEFERRABLE&lt;/code&gt;. The third class is always &lt;code&gt;IMMEDIATE&lt;/code&gt; and is not affected by the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. The first two classes start every transaction in the indicated mode, but their behavior can be changed within a transaction by &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">작성시 제한 조건에는 &lt;code&gt;DEFERRABLE INITIALLY DEFERRED&lt;/code&gt; , &lt;code&gt;DEFERRABLE INITIALLY IMMEDIATE&lt;/code&gt; 또는 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; 의 세 특성 중 하나가 제공 됩니다. 세 번째 클래스는 항상 &lt;code&gt;IMMEDIATE&lt;/code&gt; 이며 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 명령의 영향을받지 않습니다 . 처음 두 클래스는 표시된 모드에서 모든 트랜잭션을 시작하지만 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 에 의해 트랜잭션 내에서 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d7a654640c2b50b3e7df60aeeabb5b08422ed24" translate="yes" xml:space="preserve">
          <source>Upper Limit</source>
          <target state="translated">상한</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="b4f04a10cb842d23a6e0c14dfb525ccfc19a7eeb" translate="yes" xml:space="preserve">
          <source>Usage notes for date/time formatting:</source>
          <target state="translated">날짜 / 시간 형식에 대한 사용법 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="c18762bb9fd2f772e7a3cc1038dad6521a3cdc73" translate="yes" xml:space="preserve">
          <source>Usage notes for numeric formatting:</source>
          <target state="translated">숫자 형식에 대한 사용법 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="c17fd067f164433138f454d194adc8307cae8bca" translate="yes" xml:space="preserve">
          <source>Usage of &lt;em&gt;edge recombination crossover&lt;/em&gt; which is especially suited to keep edge losses low for the solution of the TSP by means of a GA;</source>
          <target state="translated">GA에 의해 TSP의 솔루션에 대해 에지 손실을 낮게 유지하는데 특히 적합한 &lt;em&gt;에지 재조합 크로스 오버의&lt;/em&gt; 사용 ;</target>
        </trans-unit>
        <trans-unit id="8cb6064dc167ff3a0e3b42195a78e15770baa73c" translate="yes" xml:space="preserve">
          <source>Usage of a &lt;em&gt;steady state&lt;/em&gt; GA (replacement of the least fit individuals in a population, not whole-generational replacement) allows fast convergence towards improved query plans. This is essential for query handling with reasonable time;</source>
          <target state="translated">&lt;em&gt;정상 상태&lt;/em&gt; GA를 사용하면 (전체 세대 교체가 아닌 인구 중 가장 적합하지 않은 개인을 대체) 개선 된 쿼리 계획으로 빠른 수렴이 가능합니다. 이는 합리적인 시간의 쿼리 처리에 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="fc32adaef16ee6908ebadfca82b7126506f9473f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;'s &lt;code&gt;\ddp&lt;/code&gt; command to obtain information about existing assignments of default privileges. The meaning of the privilege display is the same as explained for &lt;code&gt;\dp&lt;/code&gt; in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;a href=&quot;app-psql&quot;&gt;psql의&lt;/a&gt; 의 &lt;code&gt;\ddp&lt;/code&gt; 기본 권한의 기존 할당에 대한 정보를 얻기 위해 명령을 사용합니다. 권한 표시의 의미는 &lt;a href=&quot;ddl-priv&quot;&gt;5.7 절&lt;/a&gt; 에서 &lt;code&gt;\dp&lt;/code&gt; 에 대해 설명한 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6ba1f539905474c7406568a7a7f9b3f0d11b5735" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; to change the attributes of a role, and &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; to remove a role. All the attributes specified by &lt;code&gt;CREATE ROLE&lt;/code&gt; can be modified by later &lt;code&gt;ALTER ROLE&lt;/code&gt; commands.</source>
          <target state="translated">&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; 을 사용 하여 역할 속성을 변경하고 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; 을 사용하여 역할을 제거하십시오. &lt;code&gt;CREATE ROLE&lt;/code&gt; 로 지정된 모든 속성 은 나중에 &lt;code&gt;ALTER ROLE&lt;/code&gt; 명령 으로 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7488ebe056d7926158f410bc5c4336c809c61a3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-call&quot;&gt;CALL&lt;/a&gt; to execute a procedure.</source>
          <target state="translated">&lt;a href=&quot;sql-call&quot;&gt;CALL&lt;/a&gt; 을 사용 하여 프로 시저를 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="63fbf455d11c44c5877b87a971f27977e59c85ca" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; to terminate a transaction block.</source>
          <target state="translated">트랜잭션 블록을 종료 하려면 &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; 또는 &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa95bc5e0df28b02065365fe45c3e1b0d1eafbd6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; to successfully terminate a transaction.</source>
          <target state="translated">&lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; 를 사용 하여 트랜잭션을 성공적으로 종료 하십시오 .</target>
        </trans-unit>
        <trans-unit id="66e6213ccf4796834fff65a2132381a6fc00d716" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; to load all the rows in one command, instead of using a series of &lt;code&gt;INSERT&lt;/code&gt; commands. The &lt;code&gt;COPY&lt;/code&gt; command is optimized for loading large numbers of rows; it is less flexible than &lt;code&gt;INSERT&lt;/code&gt;, but incurs significantly less overhead for large data loads. Since &lt;code&gt;COPY&lt;/code&gt; is a single command, there is no need to disable autocommit if you use this method to populate a table.</source>
          <target state="translated">일련의 &lt;code&gt;INSERT&lt;/code&gt; 명령 을 사용하는 대신 &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; 를 사용 하여 하나의 명령으로 모든 행을로드 하십시오 . &lt;code&gt;COPY&lt;/code&gt; 명령은 행 많은 수의로드에 최적화되어 있습니다; &lt;code&gt;INSERT&lt;/code&gt; 보다 유연성이 떨어지지 만 큰 데이터로드에 대한 오버 헤드가 상당히 줄어 듭니다. 이후 &lt;code&gt;COPY&lt;/code&gt; 가 하나의 명령은 테이블을 채우는 데이 방법을 사용하는 경우, 사용하지 않도록 자동 커밋 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="09047c3a617e15ed6b5d857521bdd8e734e0300e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; to add new roles, and &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; to remove a role.</source>
          <target state="translated">&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 을 사용 하여 새 역할을 추가하고 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; 을 사용하여 역할을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9b4d3d6618c9949a9ad76ab0ddb5874169d923d3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropcast&quot;&gt;DROP CAST&lt;/a&gt; to remove user-defined casts.</source>
          <target state="translated">&lt;a href=&quot;sql-dropcast&quot;&gt;DROP CAST&lt;/a&gt; 를 사용 하여 사용자 정의 캐스트를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="f593b5e915433730446b465706be5f4af789f7c8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; to remove a database.</source>
          <target state="translated">&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; 를 사용 하여 데이터베이스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="f6d31dd4270e5743088ace63fb2eb93db009e693" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropindex&quot;&gt;DROP INDEX&lt;/a&gt; to remove an index.</source>
          <target state="translated">&lt;a href=&quot;sql-dropindex&quot;&gt;DROP INDEX&lt;/a&gt; 를 사용 하여 색인 을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c243eaa6db16e01a7e2d96464804f5badfa4a886" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droplanguage&quot;&gt;DROP LANGUAGE&lt;/a&gt; to drop procedural languages.</source>
          <target state="translated">프로 시저 언어를 삭제 하려면 &lt;a href=&quot;sql-droplanguage&quot;&gt;DROP LANGUAGE&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="611b170ec13c2b52270c3dae6f1ab02cf82d138c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropoperator&quot;&gt;DROP OPERATOR&lt;/a&gt; to delete user-defined operators from a database. Use &lt;a href=&quot;sql-alteroperator&quot;&gt;ALTER OPERATOR&lt;/a&gt; to modify operators in a database.</source>
          <target state="translated">&lt;a href=&quot;sql-dropoperator&quot;&gt;DROP OPERATOR&lt;/a&gt; 를 사용 하여 데이터베이스에서 사용자 정의 연산자를 삭제 하십시오 . &lt;a href=&quot;sql-alteroperator&quot;&gt;ALTER OPERATOR&lt;/a&gt; 를 사용 하여 데이터베이스에서 연산자 를 수정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="58497b86e7746a484024506bf39de0e9955831f3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droptransform&quot;&gt;DROP TRANSFORM&lt;/a&gt; to remove transforms.</source>
          <target state="translated">&lt;a href=&quot;sql-droptransform&quot;&gt;DROP TRANSFORM&lt;/a&gt; 을 사용 하여 변환 을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b075359ef1491da7c72c666849ad06ca28042837" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; to remove a trigger.</source>
          <target state="translated">&lt;a href=&quot;sql-droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; 를 사용 하여 트리거 를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="e27e35b2729f99b5a4d57cb1356ed22041def512" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; to destroy a savepoint without discarding the effects of commands executed after it was established.</source>
          <target state="translated">&lt;a href=&quot;sql-release-savepoint&quot;&gt;RAVEASE SAVEPOINT&lt;/a&gt; 를 사용 하여 설정 후 실행 된 명령의 영향을 버리지 않고 저장 점을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="54340c6db432893de03388140d111cf79cc5bd33" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; to abort a transaction.</source>
          <target state="translated">&lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; 을 사용 하여 트랜잭션을 중단 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b54ec80fcdd9c1cc0a780b0c3e10b24a114e978c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-rollback-to&quot;&gt;ROLLBACK TO SAVEPOINT&lt;/a&gt; to rollback to a savepoint. Use &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; to destroy a savepoint, keeping the effects of commands executed after it was established.</source>
          <target state="translated">&lt;a href=&quot;sql-rollback-to&quot;&gt;SAVEPOINT&lt;/a&gt; 로 롤백을 사용하여 저장 점으로 롤백 하십시오 . &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; 를 사용 하여 저장 점을 제거하고 명령이 설정된 후에 실행 된 명령의 효과를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f8f348396f663d6710748aac99721ad4f0c1192d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP COLLATION&lt;/code&gt; to remove user-defined collations.</source>
          <target state="translated">&lt;code&gt;DROP COLLATION&lt;/code&gt; 을 사용 하여 사용자 정의 데이터 정렬을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="f84b3986ffc86a297e493d0aa18ef741b0d79725" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP CONVERSION&lt;/code&gt; to remove user-defined conversions.</source>
          <target state="translated">&lt;code&gt;DROP CONVERSION&lt;/code&gt; 을 사용 하여 사용자 정의 변환을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="ff15db4e13f780cb214c1fb5755bb245ba8cdda8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP SEQUENCE&lt;/code&gt; to remove a sequence.</source>
          <target state="translated">&lt;code&gt;DROP SEQUENCE&lt;/code&gt; 를 사용 하여 시퀀스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="15726e7944bcacfcfd9200215f0e42b66131bfdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;OUT&lt;/code&gt; parameters to define the return type implicitly. The same example could also be done this way:</source>
          <target state="translated">사용 &lt;code&gt;OUT&lt;/code&gt; 암시 적으로 반환 형식을 정의하는 매개 변수를. 이 방법으로도 같은 예를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67538321bf9a606c6338bda53e8523a0fee89c08" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;\lo_list&lt;/code&gt; to find out the large object's OID.</source>
          <target state="translated">&lt;code&gt;\lo_list&lt;/code&gt; 를 사용 하여 큰 개체의 OID를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="2965f87f5b2b233b83696be719d6f81a6a38ddaa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;restore_command&lt;/code&gt; defined in the target cluster configuration to retrieve WAL files from the WAL archive if these files are no longer available in the &lt;code&gt;pg_wal&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; 디렉토리 에서 더 이상 사용할 수없는 경우 WAL 아카이브에서 WAL 파일을 검색하려면 대상 클러스터 구성에 정의 된 &lt;code&gt;restore_command&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="5c1ddd9e45a36cc1cb06c4712dd45f333163ae53" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;separator&lt;/code&gt; as the field separator for unaligned output. This is equivalent to &lt;code&gt;\pset fieldsep&lt;/code&gt; or &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="translated">정렬되지 않은 출력의 경우 필드 &lt;code&gt;separator&lt;/code&gt; 로 구분 기호 를 사용하십시오 . 이것은 &lt;code&gt;\pset fieldsep&lt;/code&gt; 또는 &lt;code&gt;\f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f33f5b37daa8a924b75643b07be4642a71a3839" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;separator&lt;/code&gt; as the record separator for unaligned output. This is equivalent to &lt;code&gt;\pset recordsep&lt;/code&gt;.</source>
          <target state="translated">정렬되지 않은 출력을 위해 분리자를 레코드 &lt;code&gt;separator&lt;/code&gt; 자로 사용하십시오 . 이것은 &lt;code&gt;\pset recordsep&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d5d5c3e044f569ed4a54b5c8b2aeebf1c2b6cc75" translate="yes" xml:space="preserve">
          <source>Use GSSAPI to authenticate the user. This is only available for TCP/IP connections. See &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details. It can be used in conjunction with GSSAPI encryption.</source>
          <target state="translated">GSSAPI를 사용하여 사용자를 인증하십시오. TCP / IP 연결에만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;gssapi-auth&quot;&gt;은 20.6 절&lt;/a&gt; 을 참조하십시오. GSSAPI 암호화와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeb12709af5299bd1b78d1fc87510677adf5e4d9" translate="yes" xml:space="preserve">
          <source>Use SSPI to authenticate the user. This is only available on Windows. See &lt;a href=&quot;sspi-auth&quot;&gt;Section 20.7&lt;/a&gt; for details.</source>
          <target state="translated">SSPI를 사용하여 사용자를 인증하십시오. 이것은 Windows에서만 사용 가능합니다. 자세한 내용 &lt;a href=&quot;sspi-auth&quot;&gt;은 20.7 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="09a0b632c4471d6df190780101d005ba97319161" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;serializable&lt;/code&gt; transaction for the dump, to ensure that the snapshot used is consistent with later database states; but do this by waiting for a point in the transaction stream at which no anomalies can be present, so that there isn't a risk of the dump failing or causing other transactions to roll back with a &lt;code&gt;serialization_failure&lt;/code&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">사용 된 스냅 샷이 이후 데이터베이스 상태와 일치하도록 덤프에 &lt;code&gt;serializable&lt;/code&gt; 트랜잭션을 사용하십시오 . 그러나 트랜잭션 스트림에서 예외가 존재하지 않는 지점을 기다리면 덤프가 실패하거나 다른 트랜잭션이 &lt;code&gt;serialization_failure&lt;/code&gt; 로 롤백 될 위험이 없습니다 . 트랜잭션 격리 및 동시성 제어에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ca5d4bab09764f17142fbf20ac5e71fb208ada4" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;serializable&lt;/code&gt; transaction for the dump, to ensure that the snapshot used is consistent with later database states; but do this by waiting for a point in the transaction stream at which no anomalies can be present, so that there isn't a risk of the dump failing or causing other transactions to roll back with a &lt;code&gt;serialization_failure&lt;/code&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">덤프에 &lt;code&gt;serializable&lt;/code&gt; 트랜잭션을 사용하여 사용 된 스냅 샷이 이후 데이터베이스 상태와 일치하는지 확인하십시오. 그러나 트랜잭션 스트림에서 예외가있을 수없는 지점을 기다리면 덤프가 실패하거나 다른 트랜잭션이 &lt;code&gt;serialization_failure&lt;/code&gt; 로 롤백 될 위험이 없습니다 . 트랜잭션 격리 및 동시성 제어에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;13 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c1cd79ab101e360e9a13e652ea38bf6edc2d76e" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt; to enforce the rule that a cage at a zoo can contain only one kind of animal:</source>
          <target state="translated">동물원의 케이지가 한 종류의 동물 만 포함 할 수 있다는 규칙을 시행하려면 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;제외 제약 조건&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3ff396f1aa38be47c72d90438e9b5c8fc599d4d" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt;&lt;code&gt;pg_stat_database&lt;/code&gt;&lt;/a&gt; view.</source>
          <target state="translated">데이터 페이지에서 체크섬을 사용하면 I / O 시스템에 의한 손상을 감지하는 데 도움이됩니다. 체크섬을 활성화하면 눈에 띄는 성능 저하가 발생할 수 있습니다. 설정된 경우 모든 데이터베이스의 모든 개체에 대해 체크섬이 계산됩니다. 모든 체크섬 실패는 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt; &lt;code&gt;pg_stat_database&lt;/code&gt; &lt;/a&gt; 뷰에 보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed495ec2e832a44d27151818dc3a53eb05f6485b" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="translated">데이터 페이지에서 체크섬을 사용하면 I / O 시스템에 의한 자동 손상을 감지 할 수 있습니다. 체크섬을 활성화하면 눈에 띄는 성능 저하가 발생할 수 있습니다. 설정된 경우 모든 데이터베이스의 모든 개체에 대해 체크섬이 계산됩니다. 모든 체크섬 실패는 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; 보기에 보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce023d8439552305d2edc6e2bf4149ad204ec26c" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">조건부 명령 (예 : &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 )을 사용하여 데이터베이스 개체를 삭제하십시오. &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d755e67717cdd34225a86cde8e3134de7095e52a" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">조건부 명령을 사용하여 (예 : &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 ) 데이터베이스 및 기타 개체를 삭제하십시오. &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="723b15fd565cd7b73cc4c9f69508e6bb65d787d0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">데이터베이스 개체를 정리할 때 조건부 명령을 사용하십시오 (예 : &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 ). &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e393204f90a01988137d09cb6497fb713cc35dc8" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">조건부 명령 (즉, &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 )을 사용하여 데이터베이스 개체를 삭제합니다. 이 옵션은 &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="03fb63958860db5f3f91183fba351eaf47350bb0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">조건부 명령 (즉, &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 )을 사용하여 데이터베이스 및 기타 개체를 삭제합니다. 이 옵션은 &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7dab14262df7a0d62d0ac14dd30b69bdadab90b1" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">데이터베이스 개체를 정리할 때 조건부 명령 (즉, &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 )을 사용합니다. 이 옵션은 &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f8dc23b011f6f1a62e695d4c31ea4636fb489dcc" translate="yes" xml:space="preserve">
          <source>Use efficient file cloning (also known as &amp;ldquo;reflinks&amp;rdquo; on some systems) instead of copying files to the new cluster. This can result in near-instantaneous copying of the data files, giving the speed advantages of &lt;code&gt;-k&lt;/code&gt;/&lt;code&gt;--link&lt;/code&gt; while leaving the old cluster untouched.</source>
          <target state="translated">파일을 새 클러스터로 복사하는 대신 효율적인 파일 복제 (일부 시스템에서는 &quot;참조&quot;라고도 함)를 사용하십시오. 이로 인해 데이터 파일을 거의 즉시 복사 할 수 있으며, 이전 클러스터는 그대로두고 &lt;code&gt;-k&lt;/code&gt; / &lt;code&gt;--link&lt;/code&gt; 의 속도 이점을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="717457386c7410d1c0caadadb8bcf5cee9b94ef2" translate="yes" xml:space="preserve">
          <source>Use genetic query optimization to plan queries with at least this many &lt;code&gt;FROM&lt;/code&gt; items involved. (Note that a &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; construct counts as only one &lt;code&gt;FROM&lt;/code&gt; item.) The default is 12. For simpler queries it is usually best to use the regular, exhaustive-search planner, but for queries with many tables the exhaustive search takes too long, often longer than the penalty of executing a suboptimal plan. Thus, a threshold on the size of the query is a convenient way to manage use of GEQO.</source>
          <target state="translated">유전자 쿼리 최적화를 사용하여 최소한이 &lt;code&gt;FROM&lt;/code&gt; 항목이 포함 된 쿼리를 계획하십시오 . (주 &amp;bull; 그래도 &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; 은 하나 같이 구조의 수를 &lt;code&gt;FROM&lt;/code&gt; 기본이 정규, 철저한 검색 플래너를 사용하는 것이 가장 좋습니다 간단한 쿼리의 12입니다. 항목), 그러나 많은 테이블 쿼리에 대한 철저한 검색이 너무 오래 걸리 차선책을 실행하는 데 따르는 형벌보다 더 긴 경우가 많습니다. 따라서 쿼리 크기의 임계 값은 GEQO 사용을 관리하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a0976de4de13332a56e83de88d1173b0054dd784" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;INHERITS&lt;/code&gt; creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; 를 사용 하면 새 하위 테이블과 해당 상위 테이블간에 지속적인 관계가 생성됩니다. 부모에 대한 스키마 수정은 일반적으로 자식에도 전파되며 기본적으로 자식 테이블의 데이터는 부모 스캔에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4eb26aa371684361e3e419e078890b371282ac" translate="yes" xml:space="preserve">
          <source>Use of most of these functions requires PostgreSQL to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">이러한 대부분의 기능을 사용하려면 PostgreSQL이 &lt;code&gt;configure --with-libxml&lt;/code&gt; 로 빌드되어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="c68e27d415e6287dfc4c6988546eee3d268cda34" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g. &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">&lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; 을 열 정의 에 첨부하여 특정 카탈로그 열에서 기호 참조를 사용할 수 있습니다 . 여기서 &lt;code&gt;lookuprule&lt;/code&gt; 은 참조 된 카탈로그의 이름입니다 (예 : &lt;code&gt;pg_proc&lt;/code&gt; ) . &lt;code&gt;BKI_LOOKUP&lt;/code&gt; 은 &lt;code&gt;Oid&lt;/code&gt; , &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;oidvector&lt;/code&gt; 또는 &lt;code&gt;Oid[]&lt;/code&gt; 유형의 열에 첨부 될 수 있습니다 . 후자의 두 경우에는 배열의 각 요소에 대한 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3fb4ce36062b56e26da7090e374ab7610c6e2ceb" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g., &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">&lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; 을 열 정의 에 첨부하여 특정 카탈로그 열에서 기호 참조를 사용할 수 있습니다 . 여기서 &lt;code&gt;lookuprule&lt;/code&gt; 은 참조 된 카탈로그의 이름입니다 (예 : &lt;code&gt;pg_proc&lt;/code&gt; ) . &lt;code&gt;BKI_LOOKUP&lt;/code&gt; 은 &lt;code&gt;Oid&lt;/code&gt; , &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;oidvector&lt;/code&gt; 또는 &lt;code&gt;Oid[]&lt;/code&gt; 유형의 열에 첨부 될 수 있습니다 . 후자의 두 경우에는 배열의 각 요소에 대한 조회 수행을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7de245d3c3aa0bf5e90f594f4cb93e3038943a92" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;RETURNING&lt;/code&gt; clause requires &lt;code&gt;SELECT&lt;/code&gt; privilege on all columns mentioned in &lt;code&gt;RETURNING&lt;/code&gt;. If you use the &lt;code&gt;query&lt;/code&gt; clause to insert rows from a query, you of course need to have &lt;code&gt;SELECT&lt;/code&gt; privilege on any table or column used in the query.</source>
          <target state="translated">의 사용 &lt;code&gt;RETURNING&lt;/code&gt; 절은 필요 &lt;code&gt;SELECT&lt;/code&gt; 에 언급 된 모든 컬럼에 대한 권한을 &lt;code&gt;RETURNING&lt;/code&gt; . &lt;code&gt;query&lt;/code&gt; 절을 사용하여 쿼리 에서 행을 삽입하는 경우 물론 쿼리에 사용 된 테이블 또는 열에 대해 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2aa84cc2dc2791298c5a401376b7bb182eec75e7" translate="yes" xml:space="preserve">
          <source>Use real data for experimentation. Using test data for setting up indexes will tell you what indexes you need for the test data, but that is all.</source>
          <target state="translated">실험에 실제 데이터를 사용하십시오. 인덱스 설정에 테스트 데이터를 사용하면 테스트 데이터에 필요한 인덱스가 무엇인지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="740a1a424b9afbaad4fd5f97eac328593356e696" translate="yes" xml:space="preserve">
          <source>Use semicolon followed by two newlines, rather than just newline, as the command entry terminator.</source>
          <target state="translated">세미콜론 다음에 명령 줄 종결 자로 줄 바꿈 대신 두 줄 바꿈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="493672dde3eb1e21802c93c463663707684dc28f" translate="yes" xml:space="preserve">
          <source>Use separate session key. Public-key encryption always uses a separate session key; this option is for symmetric-key encryption, which by default uses the S2K key directly.</source>
          <target state="translated">별도의 세션 키를 사용하십시오. 공개 키 암호화는 항상 별도의 세션 키를 사용합니다. 이 옵션은 대칭 키 암호화를위한 것으로 기본적으로 S2K 키를 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93c526253accc03345c125a338a69425d93d7a5c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; statement to drop views.</source>
          <target state="translated">&lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; 문을 사용하여 보기 를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="0d8fcf6d0e2c0c387fa9db23f6382b953340061f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션을 사용하십시오 . 자세한 내용은 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b4b457d273cfa55849542aa4f8ee8d5c092684f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;, where all the caveats of this option are explained in detail.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션을 사용하십시오 . 이 옵션의 모든주의 사항이 자세히 설명 된 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49e85f329c30105292985206289324c8f90af224" translate="yes" xml:space="preserve">
          <source>Use the alternative column-list syntax to do the same update:</source>
          <target state="translated">대체 열 목록 구문을 사용하여 동일한 업데이트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c367993bbb1f90b5675f542abe2a7cf24ff8d497" translate="yes" xml:space="preserve">
          <source>Use the manifest file at the specified path, rather than one located in the root of the backup directory.</source>
          <target state="translated">백업 디렉터리의 루트에있는 파일이 아닌 지정된 경로에있는 매니페스트 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9ae2307b8f401e6a987e3d05544bf2939cd859f9" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_COLLATE&lt;/code&gt; locale category.</source>
          <target state="translated">&lt;code&gt;LC_COLLATE&lt;/code&gt; 로캘 범주에 지정된 운영 체제 로캘을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="55a394e7b9e61f2a206b4b6967eab6c67d2c7b7c" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale category.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 로캘 범주에 지정된 운영 체제 로캘을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2aa6b91b4c4ba84fa390b2a6da37aa75a60894a" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.87&lt;/a&gt; for more details).</source>
          <target state="translated">데이터베이스 덤프시 지정된 동기화 된 스냅 샷을 사용하십시오 ( 자세한 내용 은 &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;표 9.87&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="f01c307a5f93cc4ea8d811925d49d9a9c26369ed" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; for more details).</source>
          <target state="translated">데이터베이스 덤프를 만들 때 지정된 동기화 된 스냅 샷을 사용합니다 ( 자세한 내용 은 &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;표 9.88&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="ee78ab2ce0e01deb66fa480713a33b2c2b35d2ab" translate="yes" xml:space="preserve">
          <source>Use the specified value of &lt;code&gt;extra_float_digits&lt;/code&gt; when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">부동 소수점 데이터를 덤프 할 때 사용 가능한 최대 정밀도 대신 &lt;code&gt;extra_float_digits&lt;/code&gt; 의 지정된 값을 사용하십시오 . 백업 목적으로 작성된 루틴 덤프는이 옵션을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="af4516f566a55d94c31709c01f556432e3bd7291" translate="yes" xml:space="preserve">
          <source>Use the specified value of extra_float_digits when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">부동 소수점 데이터를 덤프 할 때 사용 가능한 최대 정밀도 대신 extra_float_digits의 지정된 값을 사용하십시오. 백업 목적으로 작성된 루틴 덤프는이 옵션을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6f31da9aa85cb07454372ac17645a52a84247324" translate="yes" xml:space="preserve">
          <source>Use this sequence in an &lt;code&gt;INSERT&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 명령 에서이 순서를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="29370364d5a3aa7edfb47c0679c084d535a999d7" translate="yes" xml:space="preserve">
          <source>Used to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on any column appearing within &lt;code&gt;index_predicate&lt;/code&gt; is required.</source>
          <target state="translated">부분 고유 인덱스를 유추하는 데 사용됩니다. 술어를 만족시키는 인덱스 (실제로 인덱스 일 필요는 없음)가 유추 될 수 있습니다. &lt;code&gt;CREATE INDEX&lt;/code&gt; 형식을 따릅니다 . &lt;code&gt;index_predicate&lt;/code&gt; 내에 나타나는 모든 열에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="60a26aae579e4125ce2ef1b4188cb642a6c52362" translate="yes" xml:space="preserve">
          <source>Used to compute the maximum amount of memory that hash-based operations can use. The final limit is determined by multiplying &lt;code&gt;work_mem&lt;/code&gt; by &lt;code&gt;hash_mem_multiplier&lt;/code&gt;. The default value is 1.0, which makes hash-based operations subject to the same simple &lt;code&gt;work_mem&lt;/code&gt; maximum as sort-based operations.</source>
          <target state="translated">해시 기반 작업에서 사용할 수있는 최대 메모리 양을 계산하는 데 사용됩니다. 최종 제한은 &lt;code&gt;work_mem&lt;/code&gt; 에 &lt;code&gt;hash_mem_multiplier&lt;/code&gt; 를 곱하여 결정됩니다 . 기본값은 1.0이며, 해시 기반 작업 은 정렬 기반 작업과 동일한 단순 &lt;code&gt;work_mem&lt;/code&gt; 최대 값을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="1bfbb286795d184b793a60a1094e6c47b8ed4218" translate="yes" xml:space="preserve">
          <source>Useful values for production work probably range from a small number of hours to a few days. Small values (such as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1min&lt;/code&gt;) are only allowed because they may sometimes be useful for testing. While a setting as high as &lt;code&gt;60d&lt;/code&gt; is allowed, please note that in many workloads extreme bloat or transaction ID wraparound may occur in much shorter time frames.</source>
          <target state="translated">생산 작업에 유용한 값은 몇 시간에서 며칠까지입니다. 작은 값 (예 : &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1min&lt;/code&gt; )은 때때로 테스트에 유용 할 수 있기 때문에 허용됩니다. &lt;code&gt;60d&lt;/code&gt; 의 높은 설정 이 허용되는 동안 많은 워크로드에서 극단적 인 팽창 또는 트랜잭션 ID 랩 어라운드가 훨씬 짧은 시간 프레임에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="0aa9c997122e493dfcfb31ff0542b184a558e6ef" translate="yes" xml:space="preserve">
          <source>User Name Maps</source>
          <target state="translated">사용자 이름 맵</target>
        </trans-unit>
        <trans-unit id="657c8b98d31db02ca6e2f49846863d392059fe65" translate="yes" xml:space="preserve">
          <source>User bypasses every row level security policy, see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt; for more information.</source>
          <target state="translated">사용자는 모든 행 수준 보안 정책을 무시합니다 . 자세한 내용 은 &lt;a href=&quot;ddl-rowsecurity&quot;&gt;섹션 5.8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="17a367250b51dc731bdf8cbd166e2c6618238172" translate="yes" xml:space="preserve">
          <source>User can create databases</source>
          <target state="translated">사용자는 데이터베이스를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0cd638046cbfe5c1f3e3cd84a3d83b310d114f21" translate="yes" xml:space="preserve">
          <source>User can initiate streaming replication and put the system in and out of backup mode.</source>
          <target state="translated">사용자는 스트리밍 복제를 시작하고 시스템을 백업 모드로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62ff3be7aa18f82b61ae56cce7156698ab778283" translate="yes" xml:space="preserve">
          <source>User is a superuser</source>
          <target state="translated">사용자가 수퍼 유저</target>
        </trans-unit>
        <trans-unit id="4aef5e6fb407d9fa24def89a2aaec4ed9412ef6a" translate="yes" xml:space="preserve">
          <source>User mapping</source>
          <target state="translated">사용자 매핑</target>
        </trans-unit>
        <trans-unit id="0381065a82fe9d6c10d8cd3e9089f5c14f9312b8" translate="yes" xml:space="preserve">
          <source>User mapping specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 사용자 매핑 특정 옵션</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">사용자 이름</target>
        </trans-unit>
        <trans-unit id="0966c5e99e856745941e09bf863b1894eaa04766" translate="yes" xml:space="preserve">
          <source>User name for the user to run the service as. For domain users, use the format &lt;code&gt;DOMAIN\username&lt;/code&gt;.</source>
          <target state="translated">서비스를 실행할 사용자의 사용자 이름입니다. 도메인 사용자의 경우 &lt;code&gt;DOMAIN\username&lt;/code&gt; 형식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae03b2f53e94d67697836cc9ddba3d24303f1bd3" translate="yes" xml:space="preserve">
          <source>User name maps are defined in the ident map file, which by default is named &lt;code&gt;pg_ident.conf&lt;/code&gt; and is stored in the cluster's data directory. (It is possible to place the map file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; configuration parameter.) The ident map file contains lines of the general form:</source>
          <target state="translated">사용자 이름 맵은 기본적으로 &lt;code&gt;pg_ident.conf&lt;/code&gt; 라는 이름의 ident map 파일에 정의되며 클러스터의 데이터 디렉토리에 저장됩니다. 그러나 맵 파일을 다른 곳에 배치 할 수 있습니다 . &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; 구성 매개 변수를 참조하십시오 . ident 맵 파일에는 다음과 같은 일반적인 형식의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="26c83bd5ba1faee58ca4dfcad77ca8603bcdb897" translate="yes" xml:space="preserve">
          <source>User name of the mapping. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. &lt;code&gt;PUBLIC&lt;/code&gt; is used to match all present and future user names in the system.</source>
          <target state="translated">매핑의 사용자 이름 &lt;code&gt;CURRENT_USER&lt;/code&gt; 및 &lt;code&gt;USER&lt;/code&gt; 는 현재 사용자의 이름과 일치합니다. &lt;code&gt;PUBLIC&lt;/code&gt; 은 시스템에서 현재와 미래의 모든 사용자 이름을 일치시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f782be03fcdc443b383e428fe084103c7519032" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to create).</source>
          <target state="translated">연결할 사용자 이름 (생성 할 사용자 이름이 아님).</target>
        </trans-unit>
        <trans-unit id="58a48e5ec3f1ddd8734180ce7a8bcf7ce3e61813" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to drop).</source>
          <target state="translated">연결할 사용자 이름입니다 (삭제할 사용자 이름이 아님).</target>
        </trans-unit>
        <trans-unit id="6c7c5d855fc83ff64eb10669f8523b7d11212f01" translate="yes" xml:space="preserve">
          <source>User name to connect as.</source>
          <target state="translated">연결할 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="104f2eb40da0056ec5533c282848e3fce154c0c2" translate="yes" xml:space="preserve">
          <source>User name to connect as. Defaults to current operating system user name.</source>
          <target state="translated">연결할 사용자 이름입니다. 현재 운영 체제 사용자 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d47cce93b040f97f45693a064d2ec0fe0d47cbfa" translate="yes" xml:space="preserve">
          <source>User-defined constraint triggers (created with &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt;) also give rise to an entry in this table.</source>
          <target state="translated">&lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt; 로 작성된 사용자 정의 제한 조건 트리거 도이 테이블의 항목을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">사용자 정의 유형</target>
        </trans-unit>
        <trans-unit id="08a19bf7678e0c925ef7e00adabbc0a5965212bf" translate="yes" xml:space="preserve">
          <source>Users (roles) that are to be added to or removed from the group. The users must already exist; &lt;code&gt;ALTER GROUP&lt;/code&gt; does not create or drop users.</source>
          <target state="translated">그룹에 추가되거나 그룹에서 제거 될 사용자 (역할). 사용자는 이미 존재해야합니다. &lt;code&gt;ALTER GROUP&lt;/code&gt; 은 사용자를 만들거나 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c368e154de403e348ebf85b5c480f63c95e940b6" translate="yes" xml:space="preserve">
          <source>Users accustomed to working with other SQL database management systems might be disappointed by the performance of the &lt;code&gt;count&lt;/code&gt; aggregate when it is applied to the entire table. A query like:</source>
          <target state="translated">다른 SQL 데이터베이스 관리 시스템 작업에 익숙한 사용자는 성능에 실망 될 수 &lt;code&gt;count&lt;/code&gt; 가 전체 테이블에 적용 할 때 집계. 다음과 같은 쿼리 :</target>
        </trans-unit>
        <trans-unit id="ec14cfda8b568c538e7a2b35ec4764216fe766a6" translate="yes" xml:space="preserve">
          <source>Users can define their own range types. The most common reason to do this is to use ranges over subtypes not provided among the built-in range types. For example, to define a new range type of subtype &lt;code&gt;float8&lt;/code&gt;:</source>
          <target state="translated">사용자는 자신의 범위 유형을 정의 할 수 있습니다. 가장 일반적인 이유는 내장 된 범위 유형 중에서 제공되지 않은 하위 유형에 대한 범위를 사용하기 때문입니다. 예를 들어, 새로운 범위의 하위 유형 &lt;code&gt;float8&lt;/code&gt; 을 정의하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9efc48c7a0e88a7803961454d90d55b5ba0528" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of role names means that there cannot be different roles named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">클러스터의 사용자는 반드시 클러스터의 모든 데이터베이스에 액세스 할 수있는 권한이있는 것은 아닙니다. 역할 이름을 공유한다는 것은 동일한 클러스터의 두 데이터베이스에 &lt;code&gt;joe&lt;/code&gt; 와 같이 이름이 다른 역할이있을 수 없음을 의미 합니다. 그러나 &lt;code&gt;joe&lt;/code&gt; 가 일부 데이터베이스에만 액세스 할 수 있도록 시스템을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4944fa9df06f02dea3273ddeb97bb2eab5830741" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of user names means that there cannot be different users named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">클러스터 사용자는 반드시 클러스터의 모든 데이터베이스에 액세스 할 수있는 권한이 없습니다. 사용자 이름을 공유한다는 것은 동일한 클러스터의 두 데이터베이스에 &lt;code&gt;joe&lt;/code&gt; 라는 다른 사용자가있을 수 없음을 의미 합니다. 그러나 &lt;code&gt;joe&lt;/code&gt; 가 일부 데이터베이스에만 액세스 할 수 있도록 시스템을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="655defefcbd5cf77a94fb403c6b891d5f809540a" translate="yes" xml:space="preserve">
          <source>Users should be clear that tables that are regularly and heavily updated on the primary server will quickly cause cancellation of longer running queries on the standby. In such cases the setting of a finite value for &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; can be considered similar to setting &lt;code&gt;statement_timeout&lt;/code&gt;.</source>
          <target state="translated">사용자는 기본 서버에서 정기적으로 많이 업데이트 된 테이블이 대기에서 더 오래 실행되는 쿼리를 신속하게 취소 할 수 있음을 분명히해야합니다. 이러한 경우 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 또는 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 에 대한 유한 값 설정은 &lt;code&gt;statement_timeout&lt;/code&gt; 설정과 유사한 것으로 간주 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc34515c6a1d7984b3e11718da650ce1ef5ed348" translate="yes" xml:space="preserve">
          <source>Users sometimes try to declare operators applying just to a domain type. This is possible but is not nearly as useful as it might seem, because the operator resolution rules are designed to select operators applying to the domain's base type. As an example consider</source>
          <target state="translated">사용자는 때때로 도메인 유형에만 적용되는 연산자를 선언하려고합니다. 운영자 확인 규칙은 도메인의 기본 유형에 적용되는 운영자를 선택하도록 설계 되었기 때문에 이것이 가능하지만 거의 유용하지는 않습니다. 예를 들어 고려</target>
        </trans-unit>
        <trans-unit id="1772f82727e2e70cce145a14908f76eba9dee789" translate="yes" xml:space="preserve">
          <source>Users sometimes wonder why host names are handled in this seemingly complicated way, with two name resolutions including a reverse lookup of the client's IP address. This complicates use of the feature in case the client's reverse DNS entry is not set up or yields some undesirable host name. It is done primarily for efficiency: this way, a connection attempt requires at most two resolver lookups, one reverse and one forward. If there is a resolver problem with some address, it becomes only that client's problem. A hypothetical alternative implementation that only did forward lookups would have to resolve every host name mentioned in &lt;code&gt;pg_hba.conf&lt;/code&gt; during every connection attempt. That could be quite slow if many names are listed. And if there is a resolver problem with one of the host names, it becomes everyone's problem.</source>
          <target state="translated">사용자는 때때로 호스트 이름이 클라이언트처럼 보이는 IP 주소의 역방향 조회를 포함하여 두 가지 이름 확인을 통해 이처럼 복잡한 방식으로 처리되는 이유를 궁금해합니다. 이는 클라이언트의 역방향 DNS 항목이 설정되지 않았거나 바람직하지 않은 호스트 이름을 생성 할 경우이 기능의 사용을 복잡하게합니다. 이는 주로 효율성을 위해 수행됩니다. 이러한 방식으로 연결을 시도하려면 최대 2 개의 리졸버 조회가 필요합니다 (하나는 역방향 및 하나는 정방향). 일부 주소에 대한 리졸버 문제가있는 경우 해당 클라이언트의 문제 만됩니다. 정방향 조회 만 수행 한 가상의 대체 구현은 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 언급 된 모든 호스트 이름을 확인해야합니다.모든 연결 시도 중에. 많은 이름이 나열되면 상당히 느려질 수 있습니다. 호스트 이름 중 하나에 해결 자 문제가 있으면 모두의 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="4adcca052990f33f0c6c8200c5c596110e4cd88f" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">사용자는 &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; 를 실행하여 세션이 읽기 전용인지 여부를 알 수 있습니다 . 또한 일련의 기능 ( &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;표 9.85&lt;/a&gt; )을 통해 사용자는 대기 서버에 대한 정보에 액세스 할 수 있습니다. 이를 통해 데이터베이스의 현재 상태를 인식하는 프로그램을 작성할 수 있습니다. 이를 통해 복구 진행률을 모니터링하거나 데이터베이스를 특정 상태로 복원하는 복잡한 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c06bb19535af77b0a89cf5ee576459c7758e4d" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">사용자는 &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; 를 발행하여 세션이 읽기 전용인지 여부를 알 수 있습니다 . 또한 기능 세트 ( &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;표 9.86&lt;/a&gt; )를 통해 사용자는 대기 서버에 대한 정보에 액세스 할 수 있습니다. 이를 통해 데이터베이스의 현재 상태를 인식하는 프로그램을 작성할 수 있습니다. 복구 진행 상황을 모니터링하거나 데이터베이스를 특정 상태로 복원하는 복잡한 프로그램을 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28e2bf0df748000aab563d6b102d035c272f7dd2" translate="yes" xml:space="preserve">
          <source>Users will stop waiting if a fast shutdown is requested. However, as when using asynchronous replication, the server will not fully shutdown until all outstanding WAL records are transferred to the currently connected standby servers.</source>
          <target state="translated">빠른 종료가 요청되면 사용자는 대기를 중단합니다. 그러나 비동기 복제를 사용할 때와 같이 모든 미해결 WAL 레코드가 현재 연결된 대기 서버로 전송 될 때까지 서버가 완전히 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00379b69f39e7e2d3d7c05f05b12ede542302d0d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; on an object additionally requires &lt;code&gt;relabelfrom&lt;/code&gt; permission for the object in conjunction with its old security label and &lt;code&gt;relabelto&lt;/code&gt; permission for the object in conjunction with its new security label. (In cases where multiple label providers are installed and the user tries to set a security label, but it is not managed by SELinux, only &lt;code&gt;setattr&lt;/code&gt; should be checked here. This is currently not done due to implementation restrictions.)</source>
          <target state="translated">사용하여 &lt;a href=&quot;sql-security-label&quot;&gt;보안 레이블을&lt;/a&gt; 개체에 대한 것은 추가로 필요 &lt;code&gt;relabelfrom&lt;/code&gt; 의 옛 보안 레이블과와 함께 개체에 대한 권한을 &lt;code&gt;relabelto&lt;/code&gt; 새로운 보안 레이블과 함께 개체에 대한 권한을. (여러 레이블 제공자가 설치되어 있고 사용자가 보안 레이블을 설정하려고하지만 SELinux에서 관리하지 않는 경우 여기서 &lt;code&gt;setattr&lt;/code&gt; 만 점검해야합니다. 현재 구현 제한으로 인해 수행되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="7ba7d6f6db215ecebd0a0dd010a3ef4d72762c57" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; on this view, specifically updating the &lt;code&gt;setting&lt;/code&gt; column, is the equivalent of issuing &lt;code&gt;SET&lt;/code&gt; commands. For example, the equivalent of</source>
          <target state="translated">사용 &lt;a href=&quot;sql-update&quot;&gt;UPDATE를&lt;/a&gt; 구체적 갱신이보기 &lt;code&gt;setting&lt;/code&gt; 항목을 실행하는 것과 동일 &lt;code&gt;SET&lt;/code&gt; 의 명령. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9f4a279994eeee7b66ef6f4b6c4072e3efe337a2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ALL&lt;/code&gt; for a policy means that it will apply to all commands, regardless of the type of command. If an &lt;code&gt;ALL&lt;/code&gt; policy exists and more specific policies exist, then both the &lt;code&gt;ALL&lt;/code&gt; policy and the more specific policy (or policies) will be applied. Additionally, &lt;code&gt;ALL&lt;/code&gt; policies will be applied to both the selection side of a query and the modification side, using the &lt;code&gt;USING&lt;/code&gt; expression for both cases if only a &lt;code&gt;USING&lt;/code&gt; expression has been defined.</source>
          <target state="translated">정책에 &lt;code&gt;ALL&lt;/code&gt; 을 사용하면 명령 유형에 관계없이 모든 명령에 적용됩니다. 는 IF &lt;code&gt;ALL&lt;/code&gt; 의 다음 정책이 존재하고보다 구체적인 정책이 존재하는 양쪽 &lt;code&gt;ALL&lt;/code&gt; 정책과보다 구체적인 정책 (또는 정책) 적용됩니다. 또한 &lt;code&gt;ALL&lt;/code&gt; 정책은 사용하는 쿼리의 선택 측과 변형 양면에 적용되는 &lt;code&gt;USING&lt;/code&gt; 단지 두 경우 모두에 대한 식을 &lt;code&gt;USING&lt;/code&gt; 발현이 정의되었다.</target>
        </trans-unit>
        <trans-unit id="b1caa6904d1b2e3c70cf23410fccedf2e858e4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;DELETE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;DELETE&lt;/code&gt; commands. Only rows that pass this policy will be seen by a &lt;code&gt;DELETE&lt;/code&gt; command. There can be rows that are visible through a &lt;code&gt;SELECT&lt;/code&gt; that are not available for deletion, if they do not pass the &lt;code&gt;USING&lt;/code&gt; expression for the &lt;code&gt;DELETE&lt;/code&gt; policy.</source>
          <target state="translated">사용 &lt;code&gt;DELETE&lt;/code&gt; 가 적용하는 정책 수단에 대한 &lt;code&gt;DELETE&lt;/code&gt; 명령을. 이 정책을 통과 한 행만 &lt;code&gt;DELETE&lt;/code&gt; 명령 으로 표시됩니다 . &lt;code&gt;DELETE&lt;/code&gt; 정책에 대한 &lt;code&gt;USING&lt;/code&gt; 표현식을 전달하지 않으면 삭제할 수없는 &lt;code&gt;SELECT&lt;/code&gt; 를 통해 볼 수있는 행이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ba736c87dfcbb2c8e16a4a5fbcf41dc4d34ae6e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;INSERT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;INSERT&lt;/code&gt; commands. Rows being inserted that do not pass this policy will result in a policy violation error, and the entire &lt;code&gt;INSERT&lt;/code&gt; command will be aborted. An &lt;code&gt;INSERT&lt;/code&gt; policy cannot have a &lt;code&gt;USING&lt;/code&gt; expression, as it only applies in cases where records are being added to the relation.</source>
          <target state="translated">사용하여 &lt;code&gt;INSERT&lt;/code&gt; 를 이 적용됩니다있는 정책 수단에 대한 &lt;code&gt;INSERT&lt;/code&gt; 의 명령. 이 정책을 통과하지 않은 행을 삽입하면 정책 위반 오류가 발생하고 전체 &lt;code&gt;INSERT&lt;/code&gt; 명령이 중단됩니다. &lt;code&gt;INSERT&lt;/code&gt; 의 정책은 가질 수 없습니다 &lt;code&gt;USING&lt;/code&gt; 이 레코드 만의 관계에 추가되는 경우에 적용되는 표현입니다.</target>
        </trans-unit>
        <trans-unit id="4584b8b01123eb82dc7847c4d9677c40b0e5bba4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ONLY&lt;/code&gt; to add or drop a constraint on only the partitioned table is supported as long as there are no partitions. Once partitions exist, using &lt;code&gt;ONLY&lt;/code&gt; will result in an error as adding or dropping constraints on only the partitioned table, when partitions exist, is not supported. Instead, constraints on the partitions themselves can be added and (if they are not present in the parent table) dropped.</source>
          <target state="translated">파티션이없는 한 파티션 테이블에만 제한 조건을 추가하거나 삭제하기 위해 &lt;code&gt;ONLY&lt;/code&gt; 를 사용 하는 것이 지원됩니다. 파티션이 존재하면 &lt;code&gt;ONLY&lt;/code&gt; 를 사용하면 파티션이 존재 하는 경우 파티션 된 테이블에 대한 제한 조건 추가 또는 삭제가 지원되지 않으므로 오류가 발생합니다. 대신 파티션 자체에 대한 제약 조건을 추가하고 부모 테이블에없는 경우에는 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9191967f0b2195c21483c93a60dfe19fe3e18ef8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;. If the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; is defined in the client's environment, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">&lt;code&gt;PGCLIENTENCODING&lt;/code&gt; 사용 . 환경 변수 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; 이 클라이언트 환경에 정의되어 있으면 서버에 연결할 때 해당 클라이언트 인코딩이 자동으로 선택됩니다. (이는 위에서 언급 한 다른 방법을 사용하여 무시할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="de75f251dab5b0ad3801e8b63609c603b9f339f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SELECT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;SELECT&lt;/code&gt; queries and whenever &lt;code&gt;SELECT&lt;/code&gt; permissions are required on the relation the policy is defined for. The result is that only those records from the relation that pass the &lt;code&gt;SELECT&lt;/code&gt; policy will be returned during a &lt;code&gt;SELECT&lt;/code&gt; query, and that queries that require &lt;code&gt;SELECT&lt;/code&gt; permissions, such as &lt;code&gt;UPDATE&lt;/code&gt;, will also only see those records that are allowed by the &lt;code&gt;SELECT&lt;/code&gt; policy. A &lt;code&gt;SELECT&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being retrieved from the relation.</source>
          <target state="translated">사용하여 &lt;code&gt;SELECT&lt;/code&gt; 를 가 적용하는 정책 수단에 대한 &lt;code&gt;SELECT&lt;/code&gt; 쿼리를 때마다 &lt;code&gt;SELECT&lt;/code&gt; 권한이 관계에 필요한 정책이 정의됩니다. 결과적으로 &lt;code&gt;SELECT&lt;/code&gt; 정책 을 통과 한 관계의 레코드 만 &lt;code&gt;SELECT&lt;/code&gt; 쿼리 중에 반환 되고 &lt;code&gt;UPDATE&lt;/code&gt; 와 같은 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 필요한 쿼리 도 &lt;code&gt;SELECT&lt;/code&gt; 정책에 의해 허용 된 레코드 만 볼 수 있습니다. &lt;code&gt;SELECT&lt;/code&gt; 정책은있을 수 없습니다 &lt;code&gt;WITH CHECK&lt;/code&gt; 에만 기록이 관계로부터 검색되는 경우에 적용되는 표현.</target>
        </trans-unit>
        <trans-unit id="8ea11f118aea185625aef767542a580e19f76285" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SET client_encoding TO&lt;/code&gt;. Setting the client encoding can be done with this SQL command:</source>
          <target state="translated">사용 &lt;code&gt;SET client_encoding TO&lt;/code&gt; . 클라이언트 인코딩 설정은 다음 SQL 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e9a2e659e09abe2efa2c5be22d40b62c3aee16" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Type=notify&lt;/code&gt; requires that the server binary was built with &lt;code&gt;configure --with-systemd&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;Type=notify&lt;/code&gt; 서버 바이너리로 지어진 것을 요구 &lt;code&gt;configure --with-systemd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f17447546dfac5a3cba43658b86d3ae11e9f49a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;UPDATE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands, as well as auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clauses of &lt;code&gt;INSERT&lt;/code&gt; commands. Since &lt;code&gt;UPDATE&lt;/code&gt; involves pulling an existing record and replacing it with a new modified record, &lt;code&gt;UPDATE&lt;/code&gt; policies accept both a &lt;code&gt;USING&lt;/code&gt; expression and a &lt;code&gt;WITH CHECK&lt;/code&gt; expression. The &lt;code&gt;USING&lt;/code&gt; expression determines which records the &lt;code&gt;UPDATE&lt;/code&gt; command will see to operate against, while the &lt;code&gt;WITH CHECK&lt;/code&gt; expression defines which modified rows are allowed to be stored back into the relation.</source>
          <target state="translated">정책에 &lt;code&gt;UPDATE&lt;/code&gt; 를 사용하면 &lt;code&gt;INSERT&lt;/code&gt; 명령 의 보조 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절 뿐만 아니라 &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 명령에도 적용됩니다 . 이후 &lt;code&gt;UPDATE&lt;/code&gt; 기존 기록을 당겨 새로운 수정 된 레코드로 교체 포함, &lt;code&gt;UPDATE&lt;/code&gt; 의 정책은 모두 받아 &lt;code&gt;USING&lt;/code&gt; 표현하고 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현. &lt;code&gt;USING&lt;/code&gt; 레코드를 결정 식 &lt;code&gt;UPDATE&lt;/code&gt; 명령은 동작에 대해 표시되는 동안 &lt;code&gt;WITH CHECK&lt;/code&gt; expression은 수정 된 행을 관계에 다시 저장할 수 있도록 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4872b905960b3b0bb609a1d1f16d8a8085172d7f" translate="yes" xml:space="preserve">
          <source>Using WAL results in a significantly reduced number of disk writes, because only the log file needs to be flushed to disk to guarantee that a transaction is committed, rather than every data file changed by the transaction. The log file is written sequentially, and so the cost of syncing the log is much less than the cost of flushing the data pages. This is especially true for servers handling many small transactions touching different parts of the data store. Furthermore, when the server is processing many small concurrent transactions, one &lt;code&gt;fsync&lt;/code&gt; of the log file may suffice to commit many transactions.</source>
          <target state="translated">WAL을 사용하면 트랜잭션에 의해 변경된 모든 데이터 파일이 아니라 트랜잭션이 커밋되도록 로그 파일 만 디스크로 플러시되어야하기 때문에 디스크 쓰기 수가 크게 줄어 듭니다. 로그 파일은 순차적으로 작성되므로 로그 동기화 비용은 데이터 페이지 플러시 비용보다 훨씬 적습니다. 이는 데이터 저장소의 다른 부분에 닿는 많은 소규모 트랜잭션을 처리하는 서버에서 특히 그렇습니다. 또한 서버가 여러 개의 작은 동시 트랜잭션을 처리 할 때 많은 트랜잭션을 커밋하기 위해 로그 파일의 한 &lt;code&gt;fsync&lt;/code&gt; 로 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4792021563cf0153c3bbaaa6301ad807dbacef8" translate="yes" xml:space="preserve">
          <source>Using a SHA hash function provides a cryptographically secure digest of each file for users who wish to verify that the backup has not been tampered with, while the CRC32C algorithm provides a checksum that is much faster to calculate; it is good at catching errors due to accidental changes but is not resistant to malicious modifications. Note that, to be useful against an adversary who has access to the backup, the backup manifest would need to be stored securely elsewhere or otherwise verified not to have been modified since the backup was taken.</source>
          <target state="translated">SHA 해시 기능을 사용하면 백업이 변조되지 않았 음을 확인하려는 사용자에게 각 파일의 암호화 된 보안 다이제스트를 제공하는 반면 CRC32C 알고리즘은 계산 속도가 훨씬 더 빠른 체크섬을 제공합니다. 우발적 인 변경으로 인한 오류를 포착하는 데 능숙하지만 악의적 인 수정에는 저항하지 않습니다. 백업에 액세스 할 수있는 공격자에게 유용하려면 백업 매니페스트를 다른 곳에 안전하게 저장하거나 백업을 수행 한 이후 수정되지 않았는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e62e4e51350449dc0eec4f1e12ec4aa76a1f3f9" translate="yes" xml:space="preserve">
          <source>Using a separate script file is advisable any time you want to use more than a single command in the archiving process. This allows all complexity to be managed within the script, which can be written in a popular scripting language such as bash or perl.</source>
          <target state="translated">아카이브 프로세스에서 둘 이상의 명령을 사용하려는 경우에는 별도의 스크립트 파일을 사용하는 것이 좋습니다. 이를 통해 스크립트 내에서 모든 복잡성을 관리 할 수 ​​있으며 bash 또는 perl과 같은 널리 사용되는 스크립팅 언어로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b28cc95da9f9c8ec1f9441e5caff1c654ea239b4" translate="yes" xml:space="preserve">
          <source>Using a simple integer &lt;code&gt;offset&lt;/code&gt; is preferred when defining an abbreviation whose offset from UTC has never changed, as such abbreviations are much cheaper to process than those that require consulting a time zone definition.</source>
          <target state="translated">UTC에서 오프셋이 변경되지 않은 약어를 정의 할 때는 시간대 정의를 참조해야하는 약어보다 처리가 훨씬 저렴 하므로 간단한 정수 &lt;code&gt;offset&lt;/code&gt; 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d159535298801ecd67e86d11daf24d3f29bae4e5" translate="yes" xml:space="preserve">
          <source>Using a table:</source>
          <target state="translated">테이블 사용하기 :</target>
        </trans-unit>
        <trans-unit id="97a7d609ae1fc837ff854c4a8fe8b3cbd1349e8b" translate="yes" xml:space="preserve">
          <source>Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial.</source>
          <target state="translated">pgAdmin과 같은 기존 그래픽 프론트 엔드 도구 또는 ODBC 또는 JDBC 지원 기능이있는 오피스 스위트를 사용하여 데이터베이스를 작성하고 조작합니다. 이러한 가능성은이 튜토리얼에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b0ce3043e87fd971bf85082c10b3ea412051c05" translate="yes" xml:space="preserve">
          <source>Using filter expressions at different nesting levels is also allowed. The following example first filters all segments by location, and then returns high heart rate values for these segments, if available:</source>
          <target state="translated">서로 다른 중첩 수준에서 필터 식을 사용할 수도 있습니다. 다음 예제는 먼저 위치별로 모든 세그먼트를 필터링 한 다음 가능한 경우 해당 세그먼트에 대한 높은 심박수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f87542d489a5d09a003c3d32c1fdd090240fb1a" translate="yes" xml:space="preserve">
          <source>Using huge pages reduces overhead when using large contiguous chunks of memory, as PostgreSQL does, particularly when using large values of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;. To use this feature in PostgreSQL you need a kernel with &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; and &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt;. You will also have to adjust the kernel setting &lt;code&gt;vm.nr_hugepages&lt;/code&gt;. To estimate the number of huge pages needed, start PostgreSQL without huge pages enabled and check the postmaster's anonymous shared memory segment size, as well as the system's huge page size, using the &lt;code&gt;/proc&lt;/code&gt; file system. This might look like:</source>
          <target state="translated">큰 페이지를 사용하면 PostgreSQL과 같이 특히 큰 값의 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers를&lt;/a&gt; 사용할 때 큰 연속 메모리 청크를 사용할 때 오버 헤드가 줄어 듭니다 . PostgreSQL에서이 기능을 사용하려면 &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; 및 &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt; 인 커널이 필요합니다 . 커널 설정 &lt;code&gt;vm.nr_hugepages&lt;/code&gt; 도 조정해야합니다 . 필요한 대용량 페이지 수를 추정하려면 대용량 페이지를 사용하지 않고 PostgreSQL을 시작하고 &lt;code&gt;/proc&lt;/code&gt; 파일 시스템을 사용하여 포스트 마스터의 익명 공유 메모리 세그먼트 크기와 시스템의 대용량 페이지 크기를 확인하십시오 . 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0f4579fb33ddb8969cb60774c58272e5c781549" translate="yes" xml:space="preserve">
          <source>Using just common sense, it appears more convenient to store such data as intervals, rather than pairs of numbers. In practice, it even turns out more efficient in most applications.</source>
          <target state="translated">상식을 사용하면 숫자 쌍이 아닌 간격으로 데이터를 저장하는 것이 더 편리합니다. 실제로 대부분의 응용 프로그램에서 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a8fc95773ce3956bab8c2e8bf2027d9e849d1b1f" translate="yes" xml:space="preserve">
          <source>Using psql on a recently vacuumed or analyzed database, you can issue queries to see the disk usage of any table:</source>
          <target state="translated">최근에 정리되었거나 분석 된 데이터베이스에서 psql을 사용하면 쿼리를 실행하여 테이블의 디스크 사용량을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65181e02239e5820a5b7c0dec699536af98e9eef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command recurse to objects owned by other users.</source>
          <target state="translated">&lt;code&gt;CASCADE&lt;/code&gt; 옵션을 사용하면 다른 사용자가 소유 한 객체로 명령이 재귀 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3919689ac7e30c1a7b51bdbeb0b298903ed7b06" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command remove objects in other schemas besides the one(s) named.</source>
          <target state="translated">은 Using &lt;code&gt;CASCADE&lt;/code&gt; 의 옵션은 이름의 한 (들) 이외의 다른 스키마에서 명령 제거 개체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d956f8965b7e70f75d823768214bbad6a425210" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;\encoding&lt;/code&gt; command in psql. &lt;code&gt;\encoding&lt;/code&gt; allows you to change client encoding on the fly. For example, to change the encoding to &lt;code&gt;SJIS&lt;/code&gt;, type:</source>
          <target state="translated">psql에서 &lt;code&gt;\encoding&lt;/code&gt; 명령 사용 &lt;code&gt;\encoding&lt;/code&gt; 사용하면 클라이언트 인코딩을 즉시 변경할 수 있습니다. 예를 들어, 인코딩을 &lt;code&gt;SJIS&lt;/code&gt; 로 변경하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="ce95ab1950e8fbb1a63e8b189b58b6a856d611e2" translate="yes" xml:space="preserve">
          <source>Using the configuration variable &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;. If the &lt;code&gt;client_encoding&lt;/code&gt; variable is set, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">구성 변수 &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding 사용&lt;/a&gt; . 경우] &lt;code&gt;client_encoding&lt;/code&gt; 변수가 설정되어 서버에 연결되면, 해당 클라이언트 인코딩이 자동으로 선택된다. (이는 위에서 언급 한 다른 방법을 사용하여 무시할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="7b44d852d97da519564a9d99f8e49c858203cdb6" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;&lt;code&gt;UNION&lt;/code&gt; Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;&lt;code&gt;INTERSECT&lt;/code&gt; Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;&lt;code&gt;EXCEPT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">연산자 &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; 및 &lt;code&gt;EXCEPT&lt;/code&gt; 를 사용하면 둘 이상의 &lt;code&gt;SELECT&lt;/code&gt; 문의 출력을 결합하여 단일 결과 집합을 구성 할 수 있습니다. &lt;code&gt;UNION&lt;/code&gt; 오퍼레이터는 결과 세트 중 하나 또는 모두에 모든 행을 반환한다. &lt;code&gt;INTERSECT&lt;/code&gt; 의 연산자는 두 결과 집합에 엄격 모든 행을 반환합니다. &lt;code&gt;EXCEPT&lt;/code&gt; 연산자는 최초 결과 집합 아니라 초에 행을 반환한다. 하지 않는 한 세 가지 경우 모두, 중복 행은 제거되고 &lt;code&gt;ALL&lt;/code&gt; 을 지정 됩니다. 중복 단어 제거를 명시 적으로 지정하기 위해 노이즈 단어 &lt;code&gt;DISTINCT&lt;/code&gt; 를 추가 할 수 있습니다. 그주의 &lt;code&gt;DISTINCT&lt;/code&gt; 를여기서는 &lt;code&gt;ALL&lt;/code&gt; 이 &lt;code&gt;SELECT&lt;/code&gt; 자체 의 기본값 이지만 기본 동작 입니다. (아래의 &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt; &lt;code&gt;UNION&lt;/code&gt; 절&lt;/a&gt;&lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt; &lt;code&gt;EXCEPT&lt;/code&gt; &lt;/a&gt; 절을 참조하십시오.), &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt; &lt;code&gt;INTERSECT&lt;/code&gt; 조항&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="60ff87ccea487ea3e7de59df62d12a0091443a0c" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;UNION Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;INTERSECT Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;EXCEPT Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; 및 &lt;code&gt;EXCEPT&lt;/code&gt; 연산자를 사용하면 둘 이상의 &lt;code&gt;SELECT&lt;/code&gt; 문의 출력을 결합하여 단일 결과 집합을 형성 할 수 있습니다. &lt;code&gt;UNION&lt;/code&gt; 오퍼레이터는 결과 세트 중 하나 또는 모두에 모든 행을 반환한다. &lt;code&gt;INTERSECT&lt;/code&gt; 의 연산자는 두 결과 집합에 엄격 모든 행을 반환합니다. &lt;code&gt;EXCEPT&lt;/code&gt; 연산자는 최초 결과 집합 아니라 초에 행을 반환한다. 세 가지 경우 &lt;code&gt;ALL&lt;/code&gt; 을 지정 하지 않으면 중복 행이 제거 됩니다. 의미없는 단어 &lt;code&gt;DISTINCT&lt;/code&gt; 를 추가하여 중복 행 제거를 명시 적으로 지정할 수 있습니다. 그주의 &lt;code&gt;DISTINCT&lt;/code&gt; 를 &lt;code&gt;ALL&lt;/code&gt; 이 &lt;code&gt;SELECT&lt;/code&gt; 자체 의 기본값 이지만 여기서는 기본 동작 입니다. (아래 &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;UNION 절&lt;/a&gt; , &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;INTERSECT 절&lt;/a&gt; 및 &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;EXCEPT 절&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="345d4ccffce95dcf05491c18eea8197735fd71fd" translate="yes" xml:space="preserve">
          <source>Using this command, it is possible to either add privileges or restrict one's privileges. If the session user role has the &lt;code&gt;INHERIT&lt;/code&gt; attribute, then it automatically has all the privileges of every role that it could &lt;code&gt;SET ROLE&lt;/code&gt; to; in this case &lt;code&gt;SET ROLE&lt;/code&gt; effectively drops all the privileges assigned directly to the session user and to the other roles it is a member of, leaving only the privileges available to the named role. On the other hand, if the session user role has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, &lt;code&gt;SET ROLE&lt;/code&gt; drops the privileges assigned directly to the session user and instead acquires the privileges available to the named role.</source>
          <target state="translated">이 명령을 사용하여 권한을 추가하거나 권한을 제한 할 수 있습니다. 세션 사용자 역할에 &lt;code&gt;INHERIT&lt;/code&gt; 속성이 있으면 &lt;code&gt;SET ROLE&lt;/code&gt; 이 할 수있는 모든 역할의 모든 권한이 자동으로 부여 됩니다. 이 경우 &lt;code&gt;SET ROLE&lt;/code&gt; 은 세션 사용자 및 해당 구성원이 속한 다른 역할에 직접 할당 된 모든 권한을 효과적으로 삭제하고 명명 된 역할에 사용 가능한 권한 만 남겨 둡니다. 반면 세션 사용자 역할에 &lt;code&gt;NOINHERIT&lt;/code&gt; 속성 이 있으면 &lt;code&gt;SET ROLE&lt;/code&gt; 은 세션 사용자에게 직접 지정된 권한을 삭제하고 대신 지정된 역할에 사용 가능한 권한을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="bf3833196f5808681a4549e6dae3e11c17ff7d14" translate="yes" xml:space="preserve">
          <source>Using this option is subtly different from writing &lt;code&gt;psql &amp;lt; filename&lt;/code&gt;. In general, both will do what you expect, but using &lt;code&gt;-f&lt;/code&gt; enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand.</source>
          <target state="translated">이 옵션을 사용하는 것은 &lt;code&gt;psql &amp;lt; filename&lt;/code&gt; 작성과 미묘하게 다릅니다 . 일반적으로 두 가지 모두 예상대로 작동하지만 &lt;code&gt;-f&lt;/code&gt; 를 사용하면 줄 번호가있는 오류 메시지와 같은 멋진 기능이 활성화됩니다. 이 옵션을 사용하면 시작 오버 헤드가 줄어들 가능성이 약간 있습니다. 반면에 쉘의 입력 경로 재 지정을 사용하는 변형은 이론적으로는 모든 것을 직접 입력했을 때와 동일한 출력을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="bb94658d71fedbd45e9091422be0f40e3960ad97" translate="yes" xml:space="preserve">
          <source>Usually, a row reflecting an incorrect entry will have values for only the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; fields.</source>
          <target state="translated">일반적으로 잘못된 항목을 반영하는 행에는 &lt;code&gt;line_number&lt;/code&gt; 및 &lt;code&gt;error&lt;/code&gt; 필드 의 값만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="615ff5ce2e5448f0eae82299f9e03df2b83f7a7d" translate="yes" xml:space="preserve">
          <source>VACUUM &amp;mdash; garbage-collect and optionally analyze a database</source>
          <target state="translated">VACUUM &amp;mdash; 가비지 수집 및 선택적으로 데이터베이스 분석</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="7e2bb4ebd8bb3d86c6acc1d3b34b4607a8278459" translate="yes" xml:space="preserve">
          <source>VALUES &amp;mdash; compute a set of rows</source>
          <target state="translated">값 &amp;mdash; 행 집합 계산</target>
        </trans-unit>
        <trans-unit id="df605145d9028810fbbd6bb82ba2cbbdf49fe2f6" translate="yes" xml:space="preserve">
          <source>VALUES Lists</source>
          <target state="translated">값 목록</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="49310dbe4a27690da5f29db4c406ef0b0e02e27a" translate="yes" xml:space="preserve">
          <source>Vacuum all databases.</source>
          <target state="translated">모든 데이터베이스를 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="d78bc05489ae0681fdd181a90fe2d3af72c88331" translate="yes" xml:space="preserve">
          <source>Vacuum all four standard tables before running the test. With neither &lt;code&gt;-n&lt;/code&gt; nor &lt;code&gt;-v&lt;/code&gt;, pgbench will vacuum the &lt;code&gt;pgbench_tellers&lt;/code&gt; and &lt;code&gt;pgbench_branches&lt;/code&gt; tables, and will truncate &lt;code&gt;pgbench_history&lt;/code&gt;.</source>
          <target state="translated">테스트를 실행하기 전에 4 개의 표준 테이블을 모두 진공 청소기로 청소하십시오. 도 함께 &lt;code&gt;-n&lt;/code&gt; 도 &lt;code&gt;-v&lt;/code&gt; , pgbench는 진공 청소기로 청소한다 &lt;code&gt;pgbench_tellers&lt;/code&gt; 및 &lt;code&gt;pgbench_branches&lt;/code&gt; 것이다 잘라 내기 테이블을, 그리고 &lt;code&gt;pgbench_history&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="558c7ef6cec7040888bc23237bf5bc10ac6c115d" translate="yes" xml:space="preserve">
          <source>Vacuum also allows removal of old files from the &lt;code&gt;pg_xact&lt;/code&gt; subdirectory, which is why the default is a relatively low 200 million transactions. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="translated">Vacuum은 또한 &lt;code&gt;pg_xact&lt;/code&gt; 서브 디렉토리 에서 오래된 파일을 제거 할 수있게 하므로 기본값은 2 억 건의 트랜잭션입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있지만 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 줄일 수 있습니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4af123f2e65a46f53e9a9ee64ca03a1079be929" translate="yes" xml:space="preserve">
          <source>Vacuum maintains a &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; for each table to keep track of which pages contain only tuples that are known to be visible to all active transactions (and all future transactions, until the page is again modified). This has two purposes. First, vacuum itself can skip such pages on the next run, since there is nothing to clean up.</source>
          <target state="translated">Vacuum 은 각 테이블에 대한 &lt;a href=&quot;storage-vm&quot;&gt;가시성 맵&lt;/a&gt; 을 유지하여 모든 활성 트랜잭션 (및 페이지가 다시 수정 될 때까지 모든 미래 트랜잭션에 표시되는 것으로 알려진 튜플 만 포함)을 추적하는 페이지를 추적합니다. 이것은 두 가지 목적이 있습니다. 첫째, 진공 청소 자체는 정리할 것이 없기 때문에 다음 실행에서 이러한 페이지를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fb0ba1bca8b404cfdbdb7679f9f4d296fc6f1fa" translate="yes" xml:space="preserve">
          <source>Vacuuming multixacts also allows removal of old files from the &lt;code&gt;pg_multixact/members&lt;/code&gt; and &lt;code&gt;pg_multixact/offsets&lt;/code&gt; subdirectories, which is why the default is a relatively low 400 million multixacts. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="translated">multixact를 진공 청소기로 청소하면 &lt;code&gt;pg_multixact/members&lt;/code&gt; 및 &lt;code&gt;pg_multixact/offsets&lt;/code&gt; 서브 디렉토리 에서 오래된 파일을 제거 할 수 있습니다. 이것이 기본값이 4 억 개의 multixact입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있지만 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 줄일 수 있습니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;24.1.5.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac19d033655fd012b97b53639462b257da978e6a" translate="yes" xml:space="preserve">
          <source>Valid Types</source>
          <target state="translated">유효한 유형</target>
        </trans-unit>
        <trans-unit id="c7e5f1bbc3dc93b5ff6072a3bc81757a3ed075d7" translate="yes" xml:space="preserve">
          <source>Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional &lt;code&gt;AD&lt;/code&gt; or &lt;code&gt;BC&lt;/code&gt;. (Alternatively, &lt;code&gt;AD&lt;/code&gt;/&lt;code&gt;BC&lt;/code&gt; can appear before the time zone, but this is not the preferred ordering.) Thus:</source>
          <target state="translated">타임 스탬프 유형에 유효한 입력은 날짜와 시간을 연결 한 다음 선택적 시간대와 선택적 &lt;code&gt;AD&lt;/code&gt; 또는 &lt;code&gt;BC&lt;/code&gt; 로 구성 됩니다. (대체 &lt;code&gt;AD&lt;/code&gt; / &lt;code&gt;BC&lt;/code&gt; 시간대 앞에 가 나타날 수 있지만이 순서는 선호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3fd0054c277594413eaed1c75df986510128d67" translate="yes" xml:space="preserve">
          <source>Valid input for these types consists of a time of day followed by an optional time zone. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;Table 8.11&lt;/a&gt; and &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;Table 8.12&lt;/a&gt;.) If a time zone is specified in the input for &lt;code&gt;time without time zone&lt;/code&gt;, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as &lt;code&gt;America/New_York&lt;/code&gt;. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the &lt;code&gt;time with time zone&lt;/code&gt; value.</source>
          <target state="translated">이 유형에 유효한 입력은 시간대와 선택적 시간대로 구성됩니다. ( &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;표 8.11&lt;/a&gt; 및 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;표 8.12&lt;/a&gt; 참조 ) 시간대가 &lt;code&gt;time without time zone&lt;/code&gt; 에 대한 입력에 시간대가 지정된 경우 자동 무시됩니다. 날짜를 지정할 수도 있지만 &lt;code&gt;America/New_York&lt;/code&gt; 와 같은 일광 절약 규칙이 포함 된 시간대 이름을 사용하는 경우를 제외하고는 날짜가 무시됩니다 . 이 경우 표준 또는 일광 절약 시간이 적용되는지 확인하려면 날짜를 지정해야합니다. 적절한 시간대 오프셋은 &lt;code&gt;time with time zone&lt;/code&gt; 값이 있는 시간에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="844edfde8ce5da216439f5cc862b141254fb9d4a" translate="yes" xml:space="preserve">
          <source>Valid memory units are &lt;code&gt;B&lt;/code&gt; (bytes), &lt;code&gt;kB&lt;/code&gt; (kilobytes), &lt;code&gt;MB&lt;/code&gt; (megabytes), &lt;code&gt;GB&lt;/code&gt; (gigabytes), and &lt;code&gt;TB&lt;/code&gt; (terabytes). The multiplier for memory units is 1024, not 1000.</source>
          <target state="translated">유효한 메모리 단위는 &lt;code&gt;B&lt;/code&gt; (바이트), &lt;code&gt;kB&lt;/code&gt; (킬로바이트), &lt;code&gt;MB&lt;/code&gt; (메가 바이트), &lt;code&gt;GB&lt;/code&gt; (기가 바이트) 및 &lt;code&gt;TB&lt;/code&gt; (테라 바이트)입니다. 메모리 단위의 승수는 1000이 아니라 1024입니다.</target>
        </trans-unit>
        <trans-unit id="239bf25206857881980ea876d3982e5ae2994831" translate="yes" xml:space="preserve">
          <source>Valid starting points for standby queries are generated at each checkpoint on the master. If the standby is shut down while the master is in a shutdown state, it might not be possible to re-enter Hot Standby until the primary is started up, so that it generates further starting points in the WAL logs. This situation isn't a problem in the most common situations where it might happen. Generally, if the primary is shut down and not available anymore, that's likely due to a serious failure that requires the standby being converted to operate as the new primary anyway. And in situations where the primary is being intentionally taken down, coordinating to make sure the standby becomes the new primary smoothly is also standard procedure.</source>
          <target state="translated">대기 조회에 대한 유효한 시작점이 마스터의 각 체크 포인트에서 생성됩니다. 마스터가 종료 상태에있는 동안 대기가 종료되면 기본이 시작될 때까지 핫 스탠바이를 다시 입력하지 못할 수 있으므로 WAL 로그에 추가 시작점이 생성됩니다. 이 상황은 발생할 수있는 가장 일반적인 상황에서는 문제가되지 않습니다. 일반적으로 1 차가 종료되어 더 이상 사용할 수없는 경우 대기가 새 1 차로 작동하도록 변환해야하는 심각한 장애가 원인 일 수 있습니다. 1 차가 의도적으로 중단되는 상황에서 대기가 새 1 차가 순조롭게되도록 조정하는 것도 표준 절차입니다.</target>
        </trans-unit>
        <trans-unit id="36d562c59f538b4cf6287a1bc49b7023b220600a" translate="yes" xml:space="preserve">
          <source>Valid time units are &lt;code&gt;us&lt;/code&gt; (microseconds), &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), &lt;code&gt;min&lt;/code&gt; (minutes), &lt;code&gt;h&lt;/code&gt; (hours), and &lt;code&gt;d&lt;/code&gt; (days).</source>
          <target state="translated">유효한 시간 단위는 &lt;code&gt;us&lt;/code&gt; (마이크로 초), &lt;code&gt;ms&lt;/code&gt; (밀리 초), &lt;code&gt;s&lt;/code&gt; (초), &lt;code&gt;min&lt;/code&gt; (분), &lt;code&gt;h&lt;/code&gt; (시간) 및 &lt;code&gt;d&lt;/code&gt; (일)입니다.</target>
        </trans-unit>
        <trans-unit id="dfda311a4ab9af803299c88d82467b20a4636196" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;field&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 의 유효한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10d7649316ac64615f5264b37dbb56375dda92e2" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">유효한 변수 이름에는 문자, 숫자 및 밑줄이 포함될 수 있습니다. 자세한 내용은 아래 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수를&lt;/a&gt; 참조하십시오. 변수 이름은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="4e71de8159ccd805dfaf84c4abe0cc37c7fd0bef" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">유효한 변수 이름은 문자, 숫자 및 밑줄을 포함 할 수 있습니다. 자세한 내용은 아래 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수&lt;/a&gt; 섹션 을 참조하십시오. 변수 이름은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="6495bdc388499bc5f8ab2cec7e4d413da357e199" translate="yes" xml:space="preserve">
          <source>Validate the catalog entries for the specified operator class, so far as the access method can reasonably do that. For example, this might include testing that all required support functions are provided. The &lt;code&gt;amvalidate&lt;/code&gt; function must return false if the opclass is invalid. Problems should be reported with &lt;code&gt;ereport&lt;/code&gt; messages.</source>
          <target state="translated">액세스 메소드가 합리적으로 수행 할 수있는 한, 지정된 연산자 클래스의 카탈로그 항목을 유효성 검증하십시오. 예를 들어 여기에는 필요한 모든 지원 기능이 제공되는지 테스트하는 것이 포함될 수 있습니다. &lt;code&gt;amvalidate&lt;/code&gt; 의 opclass가 무효 인 경우 함수는 false를 반환해야합니다. &lt;code&gt;ereport&lt;/code&gt; 메시지 와 함께 문제를보고해야 합니다.</target>
        </trans-unit>
        <trans-unit id="89711f6e0ac15ee4534c22e657dbb299816df29f" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag)</source>
          <target state="translated">유효하지 않은 숫자를 확인합니다 (유효하지 않은 플래그를 지 웁니다).</target>
        </trans-unit>
        <trans-unit id="589311b6a2805b6a0281872c806ce0f19f6dd7a2" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag).</source>
          <target state="translated">잘못된 번호를 확인합니다 (잘못된 플래그를 지움).</target>
        </trans-unit>
        <trans-unit id="a914a2300c495dde9a239ee72a952fef70648b1b" translate="yes" xml:space="preserve">
          <source>Value Example</source>
          <target state="translated">가치 예</target>
        </trans-unit>
        <trans-unit id="892634b1322b72a29145754cdb909390816e79df" translate="yes" xml:space="preserve">
          <source>Value Expressions</source>
          <target state="translated">가치 표현</target>
        </trans-unit>
        <trans-unit id="b69a17e345014c4860d42b3ea12bfd1d74a98205" translate="yes" xml:space="preserve">
          <source>Value Expressions: Aggregate Expressions</source>
          <target state="translated">값 표현 : 집계 표현</target>
        </trans-unit>
        <trans-unit id="62258d667ea100846bebdafcf33e6ba0d80bc0cf" translate="yes" xml:space="preserve">
          <source>Value Expressions: Array Constructors</source>
          <target state="translated">값 표현 : 배열 생성자</target>
        </trans-unit>
        <trans-unit id="538d0773b42800a1dced9ebd66981d039270223a" translate="yes" xml:space="preserve">
          <source>Value Expressions: Collation Expressions</source>
          <target state="translated">값 식 : 데이터 정렬 식</target>
        </trans-unit>
        <trans-unit id="09b3d5a6d9bce4eae0f96433329fd2780b515b1d" translate="yes" xml:space="preserve">
          <source>Value Expressions: Column References</source>
          <target state="translated">값 표현식 : 열 참조</target>
        </trans-unit>
        <trans-unit id="0f5899e3893a9e71da04384ff81d2b0668b66cce" translate="yes" xml:space="preserve">
          <source>Value Expressions: Expression Evaluation Rules</source>
          <target state="translated">값 표현 : 표현 평가 규칙</target>
        </trans-unit>
        <trans-unit id="7a33243a5a764268dbc19c7b5d5ffb815f2b2494" translate="yes" xml:space="preserve">
          <source>Value Expressions: Field Selection</source>
          <target state="translated">값 표현 : 필드 선택</target>
        </trans-unit>
        <trans-unit id="fc2734409ea30f439f8007a816c89fd5d4964498" translate="yes" xml:space="preserve">
          <source>Value Expressions: Function Calls</source>
          <target state="translated">값 표현 : 함수 호출</target>
        </trans-unit>
        <trans-unit id="06ab5a8d541c803b5a6f5f5baa72444250b7d0c9" translate="yes" xml:space="preserve">
          <source>Value Expressions: Operator Invocations</source>
          <target state="translated">값 표현 : 연산자 호출</target>
        </trans-unit>
        <trans-unit id="e5f7f7098e87803a977afb22b3e716623af90f8e" translate="yes" xml:space="preserve">
          <source>Value Expressions: Positional Parameters</source>
          <target state="translated">값 표현 : 위치 매개 변수</target>
        </trans-unit>
        <trans-unit id="c58f459ac2b52cf9d74d05fef53f0cf74dcac929" translate="yes" xml:space="preserve">
          <source>Value Expressions: Row Constructors</source>
          <target state="translated">값 표현 : 행 생성자</target>
        </trans-unit>
        <trans-unit id="2c538998fa55638c7ded3a8a283b8e9feb0bd885" translate="yes" xml:space="preserve">
          <source>Value Expressions: Scalar Subqueries</source>
          <target state="translated">값 표현 : 스칼라 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="1da69c14dd40700afb2c0a8abd86f7b740450e6f" translate="yes" xml:space="preserve">
          <source>Value Expressions: Subscripts</source>
          <target state="translated">값 표현 : 첨자</target>
        </trans-unit>
        <trans-unit id="cccb4f69d3a8cb038ef6a413bb2c663923cd9fc0" translate="yes" xml:space="preserve">
          <source>Value Expressions: Type Casts</source>
          <target state="translated">값 표현 : 타입 캐스트</target>
        </trans-unit>
        <trans-unit id="3715da19fdcfeeba7fe50bb93e020a8b25f6a530" translate="yes" xml:space="preserve">
          <source>Value Expressions: Window Function Calls</source>
          <target state="translated">값 표현식 : 창 함수 호출</target>
        </trans-unit>
        <trans-unit id="bf4f8a0decbb4b4fd4371821f1c74ba9a1594ce9" translate="yes" xml:space="preserve">
          <source>Value Storage</source>
          <target state="translated">가치 저장</target>
        </trans-unit>
        <trans-unit id="2977eb7ab7cb1230619c6002ed4cbbc6cc756fa6" translate="yes" xml:space="preserve">
          <source>Value expressions are used in a variety of contexts, such as in the target list of the &lt;code&gt;SELECT&lt;/code&gt; command, as new column values in &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or in search conditions in a number of commands. The result of a value expression is sometimes called a &lt;em&gt;scalar&lt;/em&gt;, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called &lt;em&gt;scalar expressions&lt;/em&gt; (or even simply &lt;em&gt;expressions&lt;/em&gt;). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations.</source>
          <target state="translated">값 표현식은 &lt;code&gt;SELECT&lt;/code&gt; 명령 의 대상 목록 , &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 의 새 열 값 또는 여러 명령의 검색 조건 과 같은 다양한 컨텍스트에서 사용됩니다. 테이블 표현식 (테이블)의 결과와 구별하기 위해 값 표현식의 결과를 &lt;em&gt;스칼라&lt;/em&gt; 라고도합니다 . 따라서 값 표현식은 &lt;em&gt;스칼라 표현식&lt;/em&gt; (또는 단순히 &lt;em&gt;표현식&lt;/em&gt; ) 이라고도 합니다. 표현식 구문을 사용하면 산술, 논리, 집합 및 기타 연산을 사용하여 기본 부분의 값을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="114f96aeed1ddb1f81a693ccadc122b00691f706" translate="yes" xml:space="preserve">
          <source>Value that &lt;code&gt;RESET&lt;/code&gt; would reset the parameter to in the current session</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 이 현재 세션에서 매개 변수를 재설정하는 값</target>
        </trans-unit>
        <trans-unit id="28c18b9457473dab8964985ffc208f4a1973292c" translate="yes" xml:space="preserve">
          <source>Value to be assigned to the parameter</source>
          <target state="translated">파라미터에 할당 할 값</target>
        </trans-unit>
        <trans-unit id="f84541e98210f793e8890e82c64afbe27a9c9a73" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;false&lt;/code&gt; literal</source>
          <target state="translated">JSON &lt;code&gt;false&lt;/code&gt; 리터럴 과 비교하는 데 사용되는 값</target>
        </trans-unit>
        <trans-unit id="f129faa853bacb07b12134ac4fd986301a263b11" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;null&lt;/code&gt; value</source>
          <target state="translated">JSON &lt;code&gt;null&lt;/code&gt; 값 과 비교하는 데 사용되는 값</target>
        </trans-unit>
        <trans-unit id="8a792873148b2fe92c538941fe93212a85f960e9" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;true&lt;/code&gt; literal</source>
          <target state="translated">JSON &lt;code&gt;true&lt;/code&gt; 리터럴 과 비교하는 데 사용되는 값</target>
        </trans-unit>
        <trans-unit id="e8086792911df062e24caa3131a5135743c9b16c" translate="yes" xml:space="preserve">
          <source>Value/Predicate</source>
          <target state="translated">Value/Predicate</target>
        </trans-unit>
        <trans-unit id="1f1cb2e6759dab2334119644e8cf129ac32ce11d" translate="yes" xml:space="preserve">
          <source>Values are stored internally as 64-bit floating point numbers. This means that numbers with more than about 16 significant digits will be truncated.</source>
          <target state="translated">값은 내부적으로 64 비트 부동 소수점 숫자로 저장됩니다. 즉, 유효 숫자가 약 16보다 큰 숫자는 잘립니다.</target>
        </trans-unit>
        <trans-unit id="6d7efb522647e3ca74917dae6abd528277b3ab9e" translate="yes" xml:space="preserve">
          <source>Values needed to run one PostgreSQL instance</source>
          <target state="translated">하나의 PostgreSQL 인스턴스를 실행하는 데 필요한 값</target>
        </trans-unit>
        <trans-unit id="8d380e11f26f75eaba033d74818adbe55ddca1de" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; data types can be cast to &lt;code&gt;money&lt;/code&gt;. Conversion from the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; data types can be done by casting to &lt;code&gt;numeric&lt;/code&gt; first, for example:</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; 및 &lt;code&gt;bigint&lt;/code&gt; 데이터 유형의 값은 &lt;code&gt;money&lt;/code&gt; 으로 캐스트 될 수 있습니다 . 로부터 변환 &lt;code&gt;real&lt;/code&gt; 및 &lt;code&gt;double precision&lt;/code&gt; 데이터 형식에 캐스팅하여 수행 할 수 있습니다 &lt;code&gt;numeric&lt;/code&gt; , 예를 들면, 첫째 :</target>
        </trans-unit>
        <trans-unit id="6a94b34531e2a116d1ab90afc1f71919f7dc0067" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; can be obtained only from the &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list&lt;/code&gt; 의 값은 &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; 열 에서만 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="850035024c129e8a798d30d9fc0a41ee9af84afc" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; type can be obtained only from the &lt;code&gt;pg_statistic_ext_data&lt;/code&gt;.&lt;code&gt;stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list&lt;/code&gt; 유형의 값은 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 에서만 얻을 수 있습니다 . &lt;code&gt;stxdmcv&lt;/code&gt; 열.</target>
        </trans-unit>
        <trans-unit id="3b87bdbb02446940728e896c08b8825bde2b21b0" translate="yes" xml:space="preserve">
          <source>Values of this domain are allowed to be null. This is the default.</source>
          <target state="translated">이 도메인의 값은 null이 될 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d29119abb7de6b63218065ed67e351db8dc51728" translate="yes" xml:space="preserve">
          <source>Values of this domain are prevented from being null (but see notes below).</source>
          <target state="translated">이 도메인의 값은 널이 될 수 없습니다 (하지만 아래 참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="0d30cecbfdbc76e7857e49ac92bd25f13ef34d9b" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;character&lt;/code&gt; are physically padded with spaces to the specified width &lt;code&gt;n&lt;/code&gt;, and are stored and displayed that way. However, trailing spaces are treated as semantically insignificant and disregarded when comparing two values of type &lt;code&gt;character&lt;/code&gt;. In collations where whitespace is significant, this behavior can produce unexpected results; for example &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; returns true, even though &lt;code&gt;C&lt;/code&gt; locale would consider a space to be greater than a newline. Trailing spaces are removed when converting a &lt;code&gt;character&lt;/code&gt; value to one of the other string types. Note that trailing spaces &lt;em&gt;are&lt;/em&gt; semantically significant in &lt;code&gt;character varying&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; values, and when using pattern matching, that is &lt;code&gt;LIKE&lt;/code&gt; and regular expressions.</source>
          <target state="translated">&lt;code&gt;character&lt;/code&gt; 유형의 값은 지정된 너비 &lt;code&gt;n&lt;/code&gt; 까지의 공백으로 물리적으로 채워 지며, 그런 식으로 저장 및 표시됩니다. 그러나 &lt;code&gt;character&lt;/code&gt; 유형의 두 값을 비교할 때 후행 공백은 의미 상 중요하지 않은 것으로 간주되고 무시됩니다 . 공백이 중요한 데이터 정렬에서이 동작은 예기치 않은 결과를 생성 할 수 있습니다. 예를 들어, &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; 는 &lt;code&gt;C&lt;/code&gt; 로케일이 공백을 줄 바꾸기보다 큰 것으로 간주 하더라도 true를 리턴합니다 . &lt;code&gt;character&lt;/code&gt; 값을 다른 문자열 유형 중 하나로 변환 할 때 후행 공백이 제거됩니다 . 후행 공백 &lt;em&gt;은&lt;/em&gt; 의미 상 의미가 있습니다. &lt;code&gt;character varying&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 값, 패턴 일치 사용시 &lt;code&gt;LIKE&lt;/code&gt; 및 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="0d0e8ddc497a1b9c951f5949c5d9e1b70b9a22cd" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;path&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d80b51f9c7fc6e7a8b7e3fe299274555e9a2ae02" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;polygon&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">&lt;code&gt;polygon&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a16467bfe399e24f49eb7fdb667ccec5d8723e" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER DATABASE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt; are applied only when starting a fresh database session. They override values obtained from the configuration files or server command line, and constitute defaults for the rest of the session. Note that some settings cannot be changed after server start, and so cannot be set with these commands (or the ones listed below).</source>
          <target state="translated">&lt;code&gt;ALTER DATABASE&lt;/code&gt; 및 &lt;code&gt;ALTER ROLE&lt;/code&gt; 로 설정된 값 은 새로운 데이터베이스 세션을 시작할 때만 적용됩니다. 구성 파일 또는 서버 명령 행에서 얻은 값을 대체하고 나머지 세션의 기본값을 구성합니다. 서버를 시작한 후에는 일부 설정을 변경할 수 없으므로 이러한 명령 (또는 아래 나열된 항목)을 사용하여 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="818a4a9f523da08f985a8d7bb8387b916781ef1a" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will be effective after the next server configuration reload, or after the next server restart in the case of parameters that can only be changed at server start. A server configuration reload can be commanded by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, running &lt;code&gt;pg_ctl reload&lt;/code&gt;, or sending a SIGHUP signal to the main server process.</source>
          <target state="translated">&lt;code&gt;ALTER SYSTEM&lt;/code&gt; 으로 설정된 값 은 다음 서버 구성을 다시로드 한 후 또는 서버 시작시에만 변경할 수있는 매개 변수의 경우 다음 서버를 다시 시작한 후에 적용됩니다. SQL 함수 &lt;code&gt;pg_reload_conf()&lt;/code&gt; 를 호출 하거나 &lt;code&gt;pg_ctl reload&lt;/code&gt; 를 실행 하거나 SIGHUP 신호를 주 서버 프로세스로 보내서 서버 구성 재로드를 명령 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e2a94acd55e77d304a8881179a17d08010c723b" translate="yes" xml:space="preserve">
          <source>Values to be inserted into a table are converted to the destination column's data type according to the following steps.</source>
          <target state="translated">테이블에 삽입 할 값은 다음 단계에 따라 대상 열의 데이터 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="543a387448ddbbf661178992c3adaa7b069168fb" translate="yes" xml:space="preserve">
          <source>Values: 0 - Without salt. Dangerous! 1 - With salt but with fixed iteration count. 3 - Variable iteration count. Default: 3 Applies to: pgp_sym_encrypt</source>
          <target state="translated">값 : 0-소금이 없습니다. 위험한! 1-소금은 있지만 반복 횟수는 고정되어 있습니다. 3-가변 반복 횟수. 기본값 : 3 적용 대상 : pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e85fa17c91ce0d6924e2ed0119f352ea3f8fb549" translate="yes" xml:space="preserve">
          <source>Values: 0 - no compression 1 - ZIP compression 2 - ZLIB compression (= ZIP plus meta-data and block CRCs) Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">값 : 0-압축 안함 1-ZIP 압축 2-ZLIB 압축 (= ZIP + 메타 데이터 및 블록 CRC) 기본값 : 0 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="52218ba89357173a5dfb8618986a1e8fdfb757a3" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt</source>
          <target state="translated">값 : 0, 1 기본값 : 0 적용 대상 : pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="922303e052dbc79ebb5e801b79cffb9186efe35c" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">값 : 0, 1 기본값 : 0 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="bbe411494b7a8541ba3eda983d9fa94b6f7dde40" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</source>
          <target state="translated">값 : 0, 1 기본값 : 0 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</target>
        </trans-unit>
        <trans-unit id="87f52252bc49eca143f466418a46bf231d397765" translate="yes" xml:space="preserve">
          <source>Values: 0, 1-9 Default: 6 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">값 : 0, 1-9 기본값 : 6 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="631bb9d3f376659e6d97cddb0d8676370c2c08b3" translate="yes" xml:space="preserve">
          <source>Values: bf, aes, aes128, aes192, aes256 Default: use cipher-algo Applies to: pgp_sym_encrypt</source>
          <target state="translated">값 : bf, aes, aes128, aes192, aes256 기본값 : cipher-algo 사용 적용 대상 : pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e9d1d35bfb5be3f756eb7a018b33d9e394f847ba" translate="yes" xml:space="preserve">
          <source>Values: bf, aes128, aes192, aes256 (OpenSSL-only: &lt;code&gt;3des&lt;/code&gt;, &lt;code&gt;cast5&lt;/code&gt;) Default: aes128 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">값 : bf, aes128, aes192, aes256 (OpenSSL 전용 : &lt;code&gt;3des&lt;/code&gt; , &lt;code&gt;cast5&lt;/code&gt; ) 기본값 : aes128 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="777af837f1de8927748898b65d1060bc773bad7b" translate="yes" xml:space="preserve">
          <source>Values: md5, sha1 Default: sha1 Applies to: pgp_sym_encrypt</source>
          <target state="translated">값 : md5, sha1 기본값 : sha1 적용 대상 : pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a0b72534c52ce05719721c1bfff6524b4aef3cf8" translate="yes" xml:space="preserve">
          <source>Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as &lt;code&gt;':foo'&lt;/code&gt; doesn't work to produce a quoted literal from a variable's value (and it would be unsafe if it did work, since it wouldn't correctly handle quotes embedded in the value).</source>
          <target state="translated">인용 된 SQL 리터럴 및 식별자 내에서는 변수 보간이 수행되지 않습니다. 따라서 &lt;code&gt;':foo'&lt;/code&gt; 와 같은 구성 은 변수 값에서 따옴표 붙은 리터럴을 생성하는 데 작동하지 않습니다 (그리고 값에 포함 된 따옴표를 올바르게 처리하지 않으므로 작동하면 안전하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f20578601408732c8ea02e8d928be3d22ba16637" translate="yes" xml:space="preserve">
          <source>Variables that control psql's behavior generally cannot be unset or set to invalid values. An &lt;code&gt;\unset&lt;/code&gt; command is allowed but is interpreted as setting the variable to its default value. A &lt;code&gt;\set&lt;/code&gt; command without a second argument is interpreted as setting the variable to &lt;code&gt;on&lt;/code&gt;, for control variables that accept that value, and is rejected for others. Also, control variables that accept the values &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; will also accept other common spellings of Boolean values, such as &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">psql의 동작을 제어하는 ​​변수는 일반적으로 설정을 해제하거나 유효하지 않은 값으로 설정할 수 없습니다. &lt;code&gt;\unset&lt;/code&gt; 명령은 허용되지만 기본 값으로 변수를 설정하는 것으로 해석된다. &lt;code&gt;\set&lt;/code&gt; 두 번째 인수없이 명령에 변수를 설정으로 해석됩니다 &lt;code&gt;on&lt;/code&gt; 그 값을 수락 제어 변수, 그리고 다른 사람에 대한 거부됩니다. 또한, 값 동의를 제어 변수 &lt;code&gt;on&lt;/code&gt; 와 &lt;code&gt;off&lt;/code&gt; 또한 다음과 같은 부울 값의 다른 일반적인 철자, 받아 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71d1d14c3d8bef73e900f87a2c49118ec1795b0b" translate="yes" xml:space="preserve">
          <source>Various other settings related to &amp;ldquo;semaphore undo&amp;rdquo;, such as &lt;code&gt;SEMMNU&lt;/code&gt; and &lt;code&gt;SEMUME&lt;/code&gt;, do not affect PostgreSQL.</source>
          <target state="translated">&lt;code&gt;SEMMNU&lt;/code&gt; 및 &lt;code&gt;SEMUME&lt;/code&gt; 와 같은 &quot;세마포어 실행 취소&quot;와 관련된 다양한 기타 설정 은 PostgreSQL에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd6240cba4fe3aa73d43764309d30fb6d3d037a4" translate="yes" xml:space="preserve">
          <source>Various parameters have been mentioned above in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt; and &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;Section 26.5.3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;섹션 26.5.2&lt;/a&gt; 및 &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;섹션 26.5.3&lt;/a&gt; 에서 다양한 매개 변수가 위에서 언급되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d5b3325956fac55ce90bb38fba311678783c4a5a" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">검증은 인덱스 스캔 자체에서 사용하는 것과 동일한 절차를 사용하여 수행되며, 이는 사용자 정의 연산자 클래스 코드 일 수 있습니다. 예를 들어, B-Tree 인덱스 검증은 하나 이상의 B-Tree 지원 기능 1 루틴을 사용한 비교에 의존합니다. 연산자 클래스 지원 함수에 대한 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;은 37.16.3 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61976158db30bfdbe77805af6f5914f1244b7a45" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">사용자 정의 연산자 클래스 코드 일 수있는 인덱스 스캔 자체에서 사용하는 것과 동일한 절차를 사용하여 확인이 수행됩니다. 예를 들어, B- 트리 인덱스 확인은 하나 이상의 B- 트리 지원 기능 1 루틴으로 이루어진 비교에 의존합니다. 연산자 클래스 지원 기능에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;섹션 37.16.3&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="875530bb85a9bc9a572c1b81ee549fe16ccb6d4b" translate="yes" xml:space="preserve">
          <source>Version and Platform Compatibility</source>
          <target state="translated">버전 및 플랫폼 호환성</target>
        </trans-unit>
        <trans-unit id="1d9929f1f28bbd8834745a088bfee2450b12d5d8" translate="yes" xml:space="preserve">
          <source>Version name</source>
          <target state="translated">버전 이름</target>
        </trans-unit>
        <trans-unit id="2597e3332e662024a1086db859f74acc32e53a21" translate="yes" xml:space="preserve">
          <source>Version name for the extension</source>
          <target state="translated">확장의 버전 이름</target>
        </trans-unit>
        <trans-unit id="29156f5ef29fca0492cf46682a435025e1953ccd" translate="yes" xml:space="preserve">
          <source>Version number</source>
          <target state="translated">버전 번호</target>
        </trans-unit>
        <trans-unit id="637ea0ea7f40808c77700c1c4f68ba0087e0490c" translate="yes" xml:space="preserve">
          <source>Version of SSL in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">사용중인 SSL 버전 또는이 연결에서 SSL을 사용하지 않는 경우 NULL</target>
        </trans-unit>
        <trans-unit id="20a77b4ce23e6a598792ebba9c5fa53b934c43a3" translate="yes" xml:space="preserve">
          <source>Version of the server (optional)</source>
          <target state="translated">서버 버전 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="2002aefc5b11f637b7466ee1a13c20a9e6171391" translate="yes" xml:space="preserve">
          <source>Vertical tab (ASCII 11)</source>
          <target state="translated">세로 탭 (ASCII 11)</target>
        </trans-unit>
        <trans-unit id="9fe85f9993f6a26e677373400348d89af1072a3c" translate="yes" xml:space="preserve">
          <source>Very long-lived write transactions</source>
          <target state="translated">매우 장기적인 쓰기 트랜잭션</target>
        </trans-unit>
        <trans-unit id="30f98f07baa783307d6eeb3e956be798331b0ca1" translate="yes" xml:space="preserve">
          <source>Victor Wagner &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Cryptocom LTD</source>
          <target state="translated">빅터 바그너 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Cryptocom LTD</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="bf0400b0f3aafc0bb49249e45dc8694f8cdb7fdb" translate="yes" xml:space="preserve">
          <source>View Name</source>
          <target state="translated">뷰 이름</target>
        </trans-unit>
        <trans-unit id="33ef89bbb476e8982fc98b280a43e4c9b99ae10c" translate="yes" xml:space="preserve">
          <source>View all the locks currently outstanding, all the locks on relations in a particular database, all the locks on a particular relation, or all the locks held by a particular PostgreSQL session.</source>
          <target state="translated">현재 미해결 된 모든 잠금, 특정 데이터베이스의 관계에 대한 모든 잠금, 특정 관계에 대한 모든 잠금 또는 특정 PostgreSQL 세션이 보유한 모든 잠금을 봅니다.</target>
        </trans-unit>
        <trans-unit id="cbe38ed5293f170b37453ef21637367ceda0f0b8" translate="yes" xml:space="preserve">
          <source>View definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">뷰 정의 (재구성 된 &lt;code&gt;SELECT&lt;/code&gt; 쿼리)</target>
        </trans-unit>
        <trans-unit id="94f66a08ed3a699a66860df21a573d573a238197" translate="yes" xml:space="preserve">
          <source>Viewing Locks</source>
          <target state="translated">잠금 장치보기</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c43c0cfc302cb10077693176e5e074e56b5aa3e7" translate="yes" xml:space="preserve">
          <source>Views can be used in almost any place a real table can be used. Building views upon other views is not uncommon.</source>
          <target state="translated">실제 테이블을 사용할 수있는 거의 모든 장소에서 뷰를 사용할 수 있습니다. 다른 뷰에 뷰를 구축하는 것은 드문 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8e39d0decda3838416b25ba5106b0efbe06c4023" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction targeted by the lock, or null if the target is not a virtual transaction ID</source>
          <target state="translated">잠금이 대상으로하는 트랜잭션의 가상 ID. 대상이 가상 트랜잭션 ID가 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="811a0b30888086bd25c748477319220487f25d50" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction that is holding or awaiting this lock</source>
          <target state="translated">이 잠금을 보류 중이거나 대기중인 트랜잭션의 가상 ID</target>
        </trans-unit>
        <trans-unit id="4e4ba211a7e69b2432d26b396c51c526655c765b" translate="yes" xml:space="preserve">
          <source>Virtual transaction ID (backendID/localXID)</source>
          <target state="translated">가상 트랜잭션 ID (backendID / localXID)</target>
        </trans-unit>
        <trans-unit id="588b3f896da2cfeabe798008bfd5617b36ad005b" translate="yes" xml:space="preserve">
          <source>Visibility map (fork)</source>
          <target state="translated">가시성 맵 (포크)</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="588c142955d93338aefe3c6dd59baf541f7f60c7" translate="yes" xml:space="preserve">
          <source>WAL</source>
          <target state="translated">WAL</target>
        </trans-unit>
        <trans-unit id="1d1c95a48c1cec72e7cde457f1faf1b2311bbdfd" translate="yes" xml:space="preserve">
          <source>WAL Configuration</source>
          <target state="translated">WAL 구성</target>
        </trans-unit>
        <trans-unit id="dc7b27e2b628547b61cdbe01ad5b4d44572d2c25" translate="yes" xml:space="preserve">
          <source>WAL Internals</source>
          <target state="translated">WAL 내부</target>
        </trans-unit>
        <trans-unit id="cd824454d5f714596ff079dcd401902ac18dd100" translate="yes" xml:space="preserve">
          <source>WAL also makes it possible to support on-line backup and point-in-time recovery, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. By archiving the WAL data we can support reverting to any time instant covered by the available WAL data: we simply install a prior physical backup of the database, and replay the WAL log just as far as the desired time. What's more, the physical backup doesn't have to be an instantaneous snapshot of the database state &amp;mdash; if it is made over some period of time, then replaying the WAL log for that period will fix any internal inconsistencies.</source>
          <target state="translated">또한 WAL을 사용하면 &lt;a href=&quot;continuous-archiving&quot;&gt;섹션 25.3에&lt;/a&gt; 설명 된대로 온라인 백업 및 특정 시점 복구를 지원할 수 있습니다 . WAL 데이터를 보관하면 사용 가능한 WAL 데이터가 적용되는 즉시 복구 할 수 있습니다. 데이터베이스의 사전 물리적 백업을 설치하고 원하는 시간까지 WAL 로그를 재생하면됩니다. 또한 실제 백업은 데이터베이스 상태의 즉각적인 스냅 샷일 필요는 없습니다. 일정 기간 동안 만들어진 경우 해당 기간 동안 WAL 로그를 재생하면 내부 불일치가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="56d9842b4dd6ff8912c8130e9ac002eac147ee40" translate="yes" xml:space="preserve">
          <source>WAL archiver (process)</source>
          <target state="translated">WAL 아카이버 (프로세스)</target>
        </trans-unit>
        <trans-unit id="52a8587a456d98f221f4f9bce63c226fcda62f9a" translate="yes" xml:space="preserve">
          <source>WAL file</source>
          <target state="translated">WAL 파일</target>
        </trans-unit>
        <trans-unit id="e4adb460b94535160dc5514c2f3243fad9448dc8" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g. &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">복구 중에 WAL 파일 제어 명령이 작동하지 않습니다 (예 : &lt;code&gt;pg_start_backup&lt;/code&gt; , &lt;code&gt;pg_switch_wal&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="0dc06e1a1b8ef3a3c8739d9743e015585588e2e0" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g., &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">WAL 파일 제어 명령은 복구 중에 작동하지 않습니다 (예 : &lt;code&gt;pg_start_backup&lt;/code&gt; , &lt;code&gt;pg_switch_wal&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="9b2801865ae804dc7013c1520108c058b7f6c30a" translate="yes" xml:space="preserve">
          <source>WAL is automatically enabled; no action is required from the administrator except ensuring that the disk-space requirements for the WAL logs are met, and that any necessary tuning is done (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;).</source>
          <target state="translated">WAL이 자동으로 활성화됩니다. WAL 로그의 디스크 공간 요구 사항이 충족되고 필요한 조정이 완료되었는지 확인하는 것 외에는 관리자의 조치가 필요하지 않습니다 ( &lt;a href=&quot;wal-configuration&quot;&gt;29.4 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c356b4888573bfd6af6c126f717a43c96a7d21b4" translate="yes" xml:space="preserve">
          <source>WAL location at which to start reading. The default is to start reading the first valid log record found in the earliest file found.</source>
          <target state="translated">읽기 시작 WAL 위치. 기본값은 가장 오래된 파일에서 찾은 첫 번째 유효한 로그 레코드를 읽기 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4873b80cfe4fe4ff618ed5cd62f9b47043675a98" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000000&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">WAL 로그는 일반적으로 크기가 각각 16MB 인 세그먼트 파일 세트로 데이터 디렉토리 아래의 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리에 저장 되지만 크기는 &lt;code&gt;--wal-segsize&lt;/code&gt; initdb 옵션 을 변경하여 변경할 수 있습니다 . 각 세그먼트는 일반적으로 각 페이지 당 8kB로 분할됩니다 (이 크기는 &lt;code&gt;--with-wal-blocksize&lt;/code&gt; 구성 옵션을 통해 변경할 수 있음 ). 로그 레코드 헤더는 &lt;code&gt;access/xlogrecord.h&lt;/code&gt; 에 설명되어 있습니다 . 레코드 내용은 기록중인 이벤트 유형에 따라 다릅니다. 세그먼트 파일에는 &lt;code&gt;000000010000000000000000&lt;/code&gt; 에서 시작하여 점점 더 많은 숫자가 이름으로 제공됩니다 . 숫자는 줄 바꿈되지 않지만 사용 가능한 숫자를 소진하는 데 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="fce41bc59a921956886daa163cc3371dfbffcdb7" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000001&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">WAL 로그는 데이터 디렉토리 아래의 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리에 일반적으로 각각 16MB 크기의 세그먼트 파일 세트로 저장됩니다 (하지만 &lt;code&gt;--wal-segsize&lt;/code&gt; initdb 옵션 을 변경하여 크기를 변경할 수 있음 ). 각 세그먼트는 일반적으로 각각 8kB의 페이지로 나뉩니다 (이 크기는 &lt;code&gt;--with-wal-blocksize&lt;/code&gt; 구성 옵션을 통해 변경할 수 있음 ). 로그 레코드 헤더는 &lt;code&gt;access/xlogrecord.h&lt;/code&gt; 에 설명되어 있습니다 . 기록 내용은 기록되는 이벤트 유형에 따라 다릅니다. 세그먼트 파일에는 &lt;code&gt;000000010000000000000001&lt;/code&gt; 에서 시작하는 이름으로 계속 증가하는 숫자가 지정 됩니다. 숫자는 줄 바꿈되지 않지만 사용 가능한 숫자 재고를 모두 소진하는 데는 매우 오랜 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="f9cabc60b441504c082bc1d5bf727636abc5fa64" translate="yes" xml:space="preserve">
          <source>WAL record</source>
          <target state="translated">WAL 기록</target>
        </trans-unit>
        <trans-unit id="5fa55cdd1f960e02b270cbf81d5d051cfdadab50" translate="yes" xml:space="preserve">
          <source>WAL record construction can be canceled between any of the above steps by calling &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt;. This will discard all changes to the page image copies.</source>
          <target state="translated">&lt;code&gt;GenericXLogAbort(state)&lt;/code&gt; 호출하여 위의 단계 중 하나에서 WAL 레코드 구성을 취소 할 수 있습니다 . 페이지 이미지 사본에 대한 모든 변경 사항이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0756aa72f12460643a103d61be69d319455e3e" translate="yes" xml:space="preserve">
          <source>WAL records are appended to the WAL logs as each new record is written. The insert position is described by a Log Sequence Number (LSN) that is a byte offset into the logs, increasing monotonically with each new record. LSN values are returned as the datatype &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;. Values can be compared to calculate the volume of WAL data that separates them, so they are used to measure the progress of replication and recovery.</source>
          <target state="translated">각각의 새 레코드가 작성 될 때 WAL 레코드가 WAL 로그에 추가됩니다. 삽입 위치는 로그에 바이트 오프셋 인 LSN (Log Sequence Number)으로 설명되며, 각 새 레코드마다 단조 증가합니다. LSN 값은 데이터 유형 &lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; 으로&lt;/a&gt; 반환됩니다 . 값을 비교하여 WAL 데이터를 분리하는 볼륨을 계산할 수 있으므로 복제 및 복구 진행률을 측정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d60f7a41c7594f9d60365bb80cc500438858f049" translate="yes" xml:space="preserve">
          <source>WAL segment</source>
          <target state="translated">WAL 구간</target>
        </trans-unit>
        <trans-unit id="85207d0ebcdb97d98e8f6e4d0d99438888bd2967" translate="yes" xml:space="preserve">
          <source>WAL segments that cannot be found in the archive will be sought in &lt;code&gt;pg_wal/&lt;/code&gt;; this allows use of recent un-archived segments. However, segments that are available from the archive will be used in preference to files in &lt;code&gt;pg_wal/&lt;/code&gt;.</source>
          <target state="translated">아카이브에서 찾을 수없는 WAL 세그먼트는 &lt;code&gt;pg_wal/&lt;/code&gt; 에서 찾을 수 있습니다 . 이를 통해 최근의 보관되지 않은 세그먼트를 사용할 수 있습니다. 그러나 아카이브에서 사용 가능한 세그먼트는 &lt;code&gt;pg_wal/&lt;/code&gt; 파일보다 우선적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a848a0c06549fd9cb5d11422d342ef502df6d940" translate="yes" xml:space="preserve">
          <source>WAL writer (process)</source>
          <target state="translated">WAL 작가 (프로세스)</target>
        </trans-unit>
        <trans-unit id="670936924f36e223ed7101a5577c1a95fc54d46f" translate="yes" xml:space="preserve">
          <source>WIDE Project</source>
          <target state="translated">와이드 프로젝트</target>
        </trans-unit>
        <trans-unit id="0c238a027f49a7325c81b6fcad74df656598a8d1" translate="yes" xml:space="preserve">
          <source>WITH Queries</source>
          <target state="translated">쿼리</target>
        </trans-unit>
        <trans-unit id="62c72223105cadaf945f1907d7cca51ac5e11a9a" translate="yes" xml:space="preserve">
          <source>WITH Queries: Data-Modifying Statements in WITH</source>
          <target state="translated">WITH 쿼리 : WITH의 데이터 수정 명령문</target>
        </trans-unit>
        <trans-unit id="81a33ebe9b068dc28117b34d20aebb31ffcc15d4" translate="yes" xml:space="preserve">
          <source>WITH Queries: SELECT in WITH</source>
          <target state="translated">WITH 쿼리 : WITH에서 선택</target>
        </trans-unit>
        <trans-unit id="b3c1b6ed1901fdc76c7650d703ade5c43c418ba9" translate="yes" xml:space="preserve">
          <source>Wait Event Name</source>
          <target state="translated">대기 이벤트 이름</target>
        </trans-unit>
        <trans-unit id="cfecc9a9e7dbc0650b752c6d733646645d5d3acd" translate="yes" xml:space="preserve">
          <source>Wait Event Type</source>
          <target state="translated">대기 이벤트 유형</target>
        </trans-unit>
        <trans-unit id="b1541ea954698c8eaec6697e4064951737b7ac58" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt; through &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="translated">백엔드가 현재 대기 중이면 이벤트 이름을 대기하고, 그렇지 않으면 NULL입니다. &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;표 27.5&lt;/a&gt; ~ &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;표 27.13을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d1dd06a2c6e4048cfa872860c567be1efcd7c2b" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">백엔드가 현재 대기중인 경우 이벤트 이름을 대기하고 그렇지 않으면 NULL입니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;표 27.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0d176395064480d6a06595b0b0b2f5082eb7376" translate="yes" xml:space="preserve">
          <source>Wait event type name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">백엔드가 현재 대기중인 경우 대기 이벤트 유형 이름이고, 그렇지 않으면 NULL입니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;표 27.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d814f74425edb745c0f36dde73fdb494bc74e548" translate="yes" xml:space="preserve">
          <source>Wait for the operation to complete. This is supported for the modes &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;restart&lt;/code&gt;, &lt;code&gt;promote&lt;/code&gt;, and &lt;code&gt;register&lt;/code&gt;, and is the default for those modes.</source>
          <target state="translated">작업이 완료 될 때까지 기다리십시오. 이는 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;restart&lt;/code&gt; , &lt;code&gt;promote&lt;/code&gt; 및 &lt;code&gt;register&lt;/code&gt; 모드에서 지원되며 해당 모드 의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="dd618adedec17e6469d06a5651fc5072c2cb8b33" translate="yes" xml:space="preserve">
          <source>Waiting a new WAL segment created by copying an existing one to reach stable storage.</source>
          <target state="translated">안정적인 스토리지에 도달하기 위해 기존 세그먼트를 복사하여 생성 된 새 WAL 세그먼트를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="d1f87abf987753c903a49d1bd2c679d42224c9ed" translate="yes" xml:space="preserve">
          <source>Waiting due to a call to &lt;code&gt;pg_sleep&lt;/code&gt; or a sibling function.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; 또는 형제 함수 호출로 인해 대기 중 입니다.</target>
        </trans-unit>
        <trans-unit id="7b263c588c8a9b03696257b8f7a21247383c1982" translate="yes" xml:space="preserve">
          <source>Waiting during base backup when throttling activity.</source>
          <target state="translated">활동을 제한 할 때 기본 백업 중 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="af48f8ee80431258cbd39e7f8a24022d589cd2d4" translate="yes" xml:space="preserve">
          <source>Waiting during recovery when WAL data is not available from any source (&lt;code&gt;pg_wal&lt;/code&gt;, archive or stream).</source>
          <target state="translated">WAL 데이터를 어떤 소스 ( &lt;code&gt;pg_wal&lt;/code&gt; , 아카이브 또는 스트림) 에서 사용할 수 없을 때 복구 중 대기 중 입니다.</target>
        </trans-unit>
        <trans-unit id="d62ddea7d6b1ce8c2e8479d95982f02c6ba59204" translate="yes" xml:space="preserve">
          <source>Waiting for I/O a subtransaction buffer.</source>
          <target state="translated">서브 트랜잭션 버퍼 입출력 대기 중.</target>
        </trans-unit>
        <trans-unit id="b41198be2ca46788de05f6339f5abc58ad97837a" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a &lt;code&gt;NOTIFY&lt;/code&gt; message SLRU buffer.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 메시지 SLRU 버퍼 에서 I / O를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="10b267052de8e5af8879f9629c8e82adc667c91f" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a clog (transaction status) buffer.</source>
          <target state="translated">막힘 (트랜잭션 상태) 버퍼에서 I / O 대기 중</target>
        </trans-unit>
        <trans-unit id="e58154eef4dbe4cc36348aa199353c80f25bfc90" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a commit timestamp SLRU buffer.</source>
          <target state="translated">커밋 타임 스탬프 SLRU 버퍼에서 I / O를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bbc9325a896b8fd7a70abd45c23e5faa43a813b" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a data page.</source>
          <target state="translated">데이터 페이지에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="b97519258b555ff83c2d8f7537b4d0c3849dc3b0" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact member SLRU buffer.</source>
          <target state="translated">multixact 멤버 SLRU 버퍼에서 I / O를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5520e2be332ddadef5e822360efad62eedfb3753" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset SLRU buffer.</source>
          <target state="translated">multixact 오프셋 SLRU 버퍼에서 I / O를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8a704e423e485baf39382a4b61985268bdbe9816" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset buffer.</source>
          <target state="translated">멀티 액션 오프셋 버퍼에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="567d45c24a3c7adfee8a01424ebb678b04e38b31" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact_member buffer.</source>
          <target state="translated">multixact_member 버퍼에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="f5580fedd445b2fc16dfac5701d5e862d784f551" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a replication slot.</source>
          <target state="translated">복제 슬롯에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="e6bc836d70082711faa785a87bbd568bb40a26f2" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a serializable transaction conflict SLRU buffer.</source>
          <target state="translated">직렬화 가능한 트랜잭션 충돌 SLRU 버퍼에서 I / O를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="3cf608c43f24f0741708f464c3bfab6ed45555c1" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a sub-transaction SLRU buffer.</source>
          <target state="translated">하위 트랜잭션 SLRU 버퍼에서 I / O를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e164de805b3886359f5010f6a7deb581bdf00ae0" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a transaction status SLRU buffer.</source>
          <target state="translated">트랜잭션 상태 SLRU 버퍼에서 I / O를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eda0ee8cd8803033853db58b70b41cefa970a11" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an async (notify) buffer.</source>
          <target state="translated">비동기 (알림) 버퍼에서 I / O 대기 중</target>
        </trans-unit>
        <trans-unit id="abba94e34c19d07b07ce80f08b906e7d03736163" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an oldserxid buffer.</source>
          <target state="translated">oldserxid 버퍼에서 입출력 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="89be09a6258d69b36b9e65eae64f0556be147bdd" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on commit timestamp buffer.</source>
          <target state="translated">커밋 타임 스탬프 버퍼에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="785bfc0b8ad80cb03e1bb84a54b286b13aa0651d" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach durable storage during a checkpoint or database shutdown.</source>
          <target state="translated">체크 포인트 또는 데이터베이스 종료 중에 SLRU 데이터가 내구성있는 스토리지에 도달 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="003d2dd01b2593677f27df1a51eb75521d66a25d" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach durable storage following a page write.</source>
          <target state="translated">페이지 쓰기 후 SLRU 데이터가 내구성있는 스토리지에 도달 할 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="da4c5fd8e7b43af2a409040c541ebf56ba090a42" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage during a checkpoint or database shutdown.</source>
          <target state="translated">체크 포인트 또는 데이터베이스 종료 중에 SLRU 데이터가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="a795b2d3551897df90d4dc06b1de18f13711e4ef" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage following a page write.</source>
          <target state="translated">페이지 쓰기 후 SLRU 데이터가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="3f43eca07331b8b4d48d83deb11f1187e3222c57" translate="yes" xml:space="preserve">
          <source>Waiting for SSL while attempting connection.</source>
          <target state="translated">연결을 시도하는 동안 SSL을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="cea499b505dfbcd4c53729e4e78e2f60a5e0dfa9" translate="yes" xml:space="preserve">
          <source>Waiting for TBM shared iterator lock.</source>
          <target state="translated">TBM 공유 반복자 잠금 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="28f5fe1f96a90cf6f89027f31d1f8fff440aadd4" translate="yes" xml:space="preserve">
          <source>Waiting for WAL buffers to be written to disk.</source>
          <target state="translated">WAL 버퍼가 디스크에 기록되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="984062f9c9b976e8df42046bfd109717db60ade5" translate="yes" xml:space="preserve">
          <source>Waiting for WAL files required for a backup to be successfully archived.</source>
          <target state="translated">백업이 성공적으로 아카이브되는 데 필요한 WAL 파일을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e5f443781f65a70ffb9eadd8d00b62bec73ed570" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from a stream at recovery.</source>
          <target state="translated">복구시 스트림에서 WAL을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ce0b3cbfc2a21133aecfeb0025076a64608b1920" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from any kind of source (local, archive or stream) at recovery.</source>
          <target state="translated">복구시 모든 종류의 소스 (로컬, 아카이브 또는 스트림)에서 WAL을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="c3d04b47f170d0a017b5a8840ab7fd732b861077" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to be flushed in WAL sender process.</source>
          <target state="translated">WAL 발신자 프로세스에서 WAL이 플러시되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="f4a5e554d691351f284f09d8db7f55190422b270" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach durable storage during bootstrapping.</source>
          <target state="translated">부트 스트랩 중 WAL이 내구성있는 저장소에 도달 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="35934124d45c41b66cac20041da4f7acc6c09234" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach stable storage during bootstrapping.</source>
          <target state="translated">부트 스트랩 중 WAL이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b82237d07a68b8fa940123851d375627fb31efe7" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach durable storage.</source>
          <target state="translated">WAL 파일이 내구성있는 저장소에 도달 할 때까지 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2347bde945d2a1ac488cc00b97f03eb25edf886c" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach stable storage.</source>
          <target state="translated">WAL 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="52ca09d978f55744184f7d9cdb893379dab55dfe" translate="yes" xml:space="preserve">
          <source>Waiting for a barrier event to be processed by all backends.</source>
          <target state="translated">모든 백엔드에서 장벽 이벤트가 처리되기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64554949a794fe8845162525251d4f832f615ae" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to complete.</source>
          <target state="translated">검사 점이 완료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fbe85ec49696086b315ad919340a19fe4137e208" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to start.</source>
          <target state="translated">검사 점이 시작되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="318c8efea6418e0ce484fc89483b1eb1ff78690d" translate="yes" xml:space="preserve">
          <source>Waiting for a logical replication remote server to change state.</source>
          <target state="translated">논리적 복제 원격 서버가 상태를 변경하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9be1a8f95aa3da64fa571808ebb5f548539f1390" translate="yes" xml:space="preserve">
          <source>Waiting for a logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">논리적 복제 원격 서버가 초기 테이블 동기화를 위해 데이터를 보내기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d59d3373d5959bbfb7f16fd5cf3905eaaca00840" translate="yes" xml:space="preserve">
          <source>Waiting for a new WAL segment created by copying an existing one to reach durable storage.</source>
          <target state="translated">영구 저장소에 도달하기 위해 기존 세그먼트를 복사하여 생성 된 새 WAL 세그먼트를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="bdee33be52627bad37addf1e4cb4de672175760f" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach durable storage.</source>
          <target state="translated">새로 생성 된 타임 라인 기록 파일이 내구성있는 저장소에 도달 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="a86020a20952ecd2adfecfb302ee0a5d59b93de9" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach stable storage.</source>
          <target state="translated">새로 작성된 타임 라인 히스토리 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b0cdef84441eaddf22ea692b65eccf4c082d170e" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach durable storage.</source>
          <target state="translated">새로 초기화 된 WAL 파일이 내구성있는 저장소에 도달 할 때까지 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe40708f510b2425a56df962113c332035d1ebb" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach stable storage.</source>
          <target state="translated">새로 초기화 된 WAL 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="a99635b6aefa182932d6d8ac35e0fadee6f58362" translate="yes" xml:space="preserve">
          <source>Waiting for a read during a file copy operation.</source>
          <target state="translated">파일 복사 작업 중에 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1b1c7ee0bc940e8ff954a9dc21e088de25e160e7" translate="yes" xml:space="preserve">
          <source>Waiting for a read during recheck of the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일을 다시 확인하는 동안 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="9ae33919f01ffd845bcfe367fc1ce42274883982" translate="yes" xml:space="preserve">
          <source>Waiting for a read during reorder buffer management.</source>
          <target state="translated">재정렬 버퍼 관리 중 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="21b0b22bdd6995f4c8facc815a7958bc78a4df11" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a WAL file.</source>
          <target state="translated">WAL 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7c0a57a09d41e3dd4b6c43069589a550983cdfbc" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a buffered file.</source>
          <target state="translated">버퍼링 된 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="9d7f43727962110ab0f659fc3569b92c09e1e4c3" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a relation data file.</source>
          <target state="translated">관계 데이터 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b5434d2dc36bc6e479cf33762dac4cdbbad013ab" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a replication slot control file.</source>
          <target state="translated">복제 슬롯 제어 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="d17e29530adb24a2c7484307af3bcddda11a2aae" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during a walsender timeline command.</source>
          <target state="translated">walsender 타임 라인 명령 중에 타임 라인 히스토리 파일에서 읽기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8e0677108348e6cb25c6439df96979d79370b4" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during walsender timeline command.</source>
          <target state="translated">walsender 타임 라인 명령 중에 타임 라인 히스토리 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b83f25adf4d23330ec82b288f382bbfe80bca47f" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; 파일 에서 읽기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb87f9075b737550478460fe92ea81d5a8e44f1b" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the control file.</source>
          <target state="translated">제어 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b13a29b976f4d9243fad247169f0d2821ffe4aa3" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a logical mapping during reorder buffer management.</source>
          <target state="translated">재정렬 버퍼 관리 중 논리 맵핑 읽기를 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="94303f5f840422428a360dcb8cf874ed8d7188d8" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a serialized historical catalog snapshot.</source>
          <target state="translated">직렬화 된 히스토리 카탈로그 스냅 샷 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2ab04c92d0fda0e18fe65ce97ed4f4a6278c8bda" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a timeline history file.</source>
          <target state="translated">타임 라인 히스토리 파일 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="c0e334fe7275467445ed31f445bb0d89fc42ea11" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a two phase state file.</source>
          <target state="translated">2 단계 상태 파일 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="24f5541db52af4f2f83a5aff926cb570ad37ea9a" translate="yes" xml:space="preserve">
          <source>Waiting for a read of an SLRU page.</source>
          <target state="translated">SLRU 페이지 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ab3bd50798c846431f5c99cd295ac155af5c3628" translate="yes" xml:space="preserve">
          <source>Waiting for a read of the relation map file.</source>
          <target state="translated">관계 맵 파일 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="653fed415a1560b6108907354641e1d02603af7f" translate="yes" xml:space="preserve">
          <source>Waiting for a read when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">기존 WAL 세그먼트를 복사하여 새 WAL 세그먼트를 작성할 때 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8b50fdc4779713a2250434752ac096729a9b9e3d" translate="yes" xml:space="preserve">
          <source>Waiting for a read while adding a line to the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일에 행을 추가하는 동안 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="764d5f916fab0f4117b0be0cbd2e731f54a839fb" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be extended.</source>
          <target state="translated">관계 데이터 파일이 확장되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2d4550cc931e0694f7888372505856f6d3c09005" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be truncated.</source>
          <target state="translated">관계 데이터 파일이 잘릴 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="56656077995a3c3ccd9b20b71affc54ffa5f3b73" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach durable storage.</source>
          <target state="translated">관계 데이터 파일이 영구 저장소에 도달 할 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="196784ad8df1886187ea3f9758445468708682d5" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach stable storage.</source>
          <target state="translated">관계 데이터 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e193dd315e3b35e9bfde686ab2df07cc942ef67f" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive so it can be dropped.</source>
          <target state="translated">복제 오리진이 비활성화 될 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="2c6dd21f72774436bf4201a14e0bef224865f318" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive to be dropped.</source>
          <target state="translated">복제 오리진이 비활성화되기를 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="a2c385c9c429e881d994641cd053fdd40d599ca4" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach durable storage while restoring it to memory.</source>
          <target state="translated">복제 슬롯 제어 파일이 메모리에 복원하는 동안 내구성있는 저장소에 도달 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="933e401eade88c4d239f909f0d7a24552c57d2a6" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach durable storage.</source>
          <target state="translated">복제 슬롯 제어 파일이 내구성있는 저장소에 도달 할 때까지 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="51efea4b8a37a030875e22581e67a71b2c0b921b" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage while restoring it to memory.</source>
          <target state="translated">복제 슬롯 제어 파일이 메모리에 복원되는 동안 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="3360d7e3a23f4e402f25182926d976cf44db39f3" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage.</source>
          <target state="translated">복제 슬롯 제어 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="494ade39222b8fb62d122bed2c1029dcb97e4b7f" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive so it can be dropped.</source>
          <target state="translated">복제 슬롯이 비활성화 될 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="199501dcba57d5c5271ac74b95e191bf236cb733" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive to be dropped.</source>
          <target state="translated">복제 슬롯이 비활성화되기를 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="6e324c985d50a900618f8748e92b810be7e79671" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach durable storage.</source>
          <target state="translated">직렬화 된 히스토리 카탈로그 스냅 샷이 내구성있는 스토리지에 도달 할 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="863f50afd3c1563b85fb65b1a42b5b1ae705dfb7" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach stable storage.</source>
          <target state="translated">직렬화 된 히스토리 카탈로그 스냅 샷이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b66c979e7938ef913ce663fc865d33095c21de87" translate="yes" xml:space="preserve">
          <source>Waiting for a snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">&lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; 트랜잭션 의 스냅 샷 대기 중입니다 .</target>
        </trans-unit>
        <trans-unit id="111cfd0a418a3a5087e98e0082a0895f0e94e2f0" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach durable storage.</source>
          <target state="translated">스트리밍 복제를 통해 수신 된 타임 라인 기록 파일이 내구성있는 스토리지에 도달 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="e483dd61b2e17583a1594dcda6e591f3ac3e513f" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach stable storage.</source>
          <target state="translated">스트리밍 복제를 통해 수신 된 타임 라인 히스토리 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2853dc0fde120da340c58317ae296218c97a1c94" translate="yes" xml:space="preserve">
          <source>Waiting for a transaction to finish.</source>
          <target state="translated">거래가 완료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e24c900a389bc0f02e97f81a8ce41fbab7e291af" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach durable storage.</source>
          <target state="translated">2 단계 상태 파일이 내구성있는 스토리지에 도달 할 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="157ed476e7697e7a1cadb6976248a98472434e0a" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach stable storage.</source>
          <target state="translated">2 단계 상태 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="85a6ffd0d68eb37b547774e0919378d07b939300" translate="yes" xml:space="preserve">
          <source>Waiting for a write during a file copy operation.</source>
          <target state="translated">파일 복사 작업 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="32492adb76e65f3fe0a6e72f8951521baef55fec" translate="yes" xml:space="preserve">
          <source>Waiting for a write during reorder buffer management.</source>
          <target state="translated">재정렬 버퍼 관리 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ba450cd205c3dd8e5640b537d57ff27410f1253d" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a WAL page during bootstrapping.</source>
          <target state="translated">부트 스트랩 중 WAL 페이지 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8705f070fa23d795eb616cd9e31b50566ca67cc3" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a newly created timeline history file.</source>
          <target state="translated">새로 작성된 타임 라인 히스토리 파일의 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8d1760404310ebeadc931ff2c4124968d47b107a" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a serialized historical catalog snapshot.</source>
          <target state="translated">직렬화 된 히스토리 카탈로그 스냅 샷의 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b37297f957be6d38118691421e743bea3d403b7c" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a timeline history file received via streaming replication.</source>
          <target state="translated">스트리밍 복제를 통해 수신 된 타임 라인 기록 파일 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="be49d8c0c1b4685519fdd85850348ecd44be9749" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a two phase state file.</source>
          <target state="translated">2 단계 상태 파일의 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="53aeb8cdb283bc1d47f777ad7b24ec161b846ee7" translate="yes" xml:space="preserve">
          <source>Waiting for a write of an SLRU page.</source>
          <target state="translated">SLRU 페이지 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1465353979b7faf0b115892be0b212bb41254cd5" translate="yes" xml:space="preserve">
          <source>Waiting for a write of logical rewrite mappings.</source>
          <target state="translated">논리적 다시 쓰기 매핑의 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="262bd0eebb54ede821d500429e0af687cc713958" translate="yes" xml:space="preserve">
          <source>Waiting for a write of mapping data during a logical rewrite.</source>
          <target state="translated">논리적 다시 쓰기 중 매핑 데이터 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="3b9bd51d9cae106255dd99b45134793e8fe5ca42" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a WAL file.</source>
          <target state="translated">WAL 파일 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="251086a074c439cbe743d7c3bb152d463c21bb7b" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a buffered file.</source>
          <target state="translated">버퍼링 된 파일에 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8b47e588513cf133674bba56df9090d2883dd101" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a relation data file.</source>
          <target state="translated">관계 데이터 파일에 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="299b50c23e70d2d279fbb4a9694963e890bfee88" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a replication slot control file.</source>
          <target state="translated">복제 슬롯 제어 파일에 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="c78572013cf870b1d5b2f14bfe069a7a53092ec4" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; 파일에 쓰기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f26411046b5f9c53b1644f439224f22b40020be7" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the control file.</source>
          <target state="translated">제어 파일에 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="f75228f5ef22ab61abd11733484809e768dbf43c" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the relation map file.</source>
          <target state="translated">관계 맵 파일에 대한 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="49fdc5304647deaf1df0e95e8d9b82ecf63a8d41" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; 파일 을 업데이트하기 위해 쓰기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4dc5be0a61a88b12bee2628ecf09d1b773c4c35" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the control file.</source>
          <target state="translated">쓰기가 제어 파일을 업데이트하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="610d140534d98776f4ceaac82401a792839d1b45" translate="yes" xml:space="preserve">
          <source>Waiting for a write when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">기존 WAL 세그먼트를 복사하여 새 WAL 세그먼트를 작성할 때 쓰기 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="e8e6f804ba2f5656426f9c3ccd5ba5ebd95a87d4" translate="yes" xml:space="preserve">
          <source>Waiting for a write while adding a line to the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일에 행을 추가하는 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="0696197c3d3d4067137d8fe428f74da050d0c268" translate="yes" xml:space="preserve">
          <source>Waiting for a write while creating the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일을 작성하는 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2fa5fc8fd5be1292b1cb40d3c83b93e702c367e3" translate="yes" xml:space="preserve">
          <source>Waiting for a write while initializing a new WAL file.</source>
          <target state="translated">새 WAL 파일을 초기화하는 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="734b565bcfa5ca2fc97c773bf856a02689576213" translate="yes" xml:space="preserve">
          <source>Waiting for action on logical replication worker to finish.</source>
          <target state="translated">논리적 복제 작업자의 작업이 완료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="d26e6e2627cb32e8a27e81f318db98a11e54cd12" translate="yes" xml:space="preserve">
          <source>Waiting for activity from a child process while executing a &lt;code&gt;Gather&lt;/code&gt; plan node.</source>
          <target state="translated">&lt;code&gt;Gather&lt;/code&gt; 계획 노드 를 실행하는 동안 자식 프로세스의 활동을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1613179ffe75070217dd36a5f12906b74afc2ab" translate="yes" xml:space="preserve">
          <source>Waiting for activity from child process when executing &lt;code&gt;Gather&lt;/code&gt; node.</source>
          <target state="translated">&lt;code&gt;Gather&lt;/code&gt; 노드를 실행할 때 하위 프로세스의 활동을 기다리는 중입니다 .</target>
        </trans-unit>
        <trans-unit id="6126b8aaccca6a7a91b7220ca50f325ae2373721" translate="yes" xml:space="preserve">
          <source>Waiting for an asynchronous prefetch from a relation data file.</source>
          <target state="translated">관계 데이터 파일에서 비동기 프리 페치를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7ceade57b19a1c5eb1845d4c821b850186cc2839" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">선출 된 Parallel Hash 참가자가 해시 테이블을 할당하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7ae35732e2bfced9301c45c422a5bb06a774ed38" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate more batches.</source>
          <target state="translated">선출 된 Parallel Hash 참가자가 더 많은 배치를 할당하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fb366154c77101be0d76ea7c08df266aa7b65be9" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">선출 된 병렬 해시 참가자가 초기 해시 테이블을 할당하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7cf1c258cd35461c3f1727fa0a9eacebdd04769c" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">선출 된 Parallel Hash 참가자가 향후 배치 성장을 결정할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="07635fd669dda3c946a486e6f1b23b449441353e" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</source>
          <target state="translated">선출 된 Parallel Hash 참가자가 더 많은 버킷 할당을 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5801375733f68124f62514d2e4570d9207fd757f" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to durable storage.</source>
          <target state="translated">관계 데이터 파일이 영구 저장소에 즉시 동기화되기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e246fb175c5f149773d0331209040875fd42182" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to stable storage.</source>
          <target state="translated">안정적인 스토리지에 관계 데이터 파일의 즉각적인 동기화를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7259a212cd02dc7285b0b4c7fac8d9b3dccce991" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the &lt;code&gt;pg_control&lt;/code&gt; file to reach durable storage.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; 파일 에 대한 업데이트가 내구성있는 저장소에 도달 하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d64a2fc217b281e035d77c750609359d54019d" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the control file to reach stable storage.</source>
          <target state="translated">제어 파일의 업데이트가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="77a6d736fc930334f93ec4961120d3fbb33658a7" translate="yes" xml:space="preserve">
          <source>Waiting for another process to be attached to a shared message queue.</source>
          <target state="translated">다른 프로세스가 공유 메시지 큐에 연결되기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcf18468a43ecee10b4dea21dad9d1ae0888b697" translate="yes" xml:space="preserve">
          <source>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</source>
          <target state="translated">WAL 발신자 프로세스에서 WAL 수신자의 응답을 처리 할 때 활동을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="27bad1ed6561f03baa1813e29bc1d6a9f97d039b" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to shut down.</source>
          <target state="translated">백그라운드 작업자가 종료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="17b78b2404a9c8efe7417660102cb11bcbc99fa4" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to start up.</source>
          <target state="translated">백그라운드 작업자가 시작하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1092cdc7eb9ee3391d3a4d79e4f2cbbadb7d2536" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach durable storage.</source>
          <target state="translated">관계 데이터 파일의 변경 사항이 영구 스토리지에 도달하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="121ce51ab6e249cf929aa9e0635dd5196c724d55" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach stable storage.</source>
          <target state="translated">안정적인 스토리지에 도달하기 위해 관계 데이터 파일의 변경을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="06baf37c4d00743bd8f1d4776619f21e41c7e849" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from a remote server during synchronous replication.</source>
          <target state="translated">동기 복제 중 원격 서버에서 확인을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aedff25c55dbcd34ea828efe5df0cac10c04231" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from remote server during synchronous replication.</source>
          <target state="translated">동기 복제 중 원격 서버에서 확인을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="06dd73106355257e55c5973700b35599b6ab2aa8" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while adding a line to the data directory lock file.</source>
          <target state="translated">데이터 디렉터리 잠금 파일에 줄을 추가하는 동안 데이터가 내구성있는 저장소에 도달 할 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="bf1a2cd56f85be8ddf428ad8cd1741cd6c232ca4" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while assigning a new WAL sync method.</source>
          <target state="translated">새 WAL 동기화 방법을 할당하는 동안 데이터가 내구성있는 저장소에 도달 할 때까지 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7393e0800215c6dc732cf1bd3e9c0f59b66e27cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while creating the data directory lock file.</source>
          <target state="translated">데이터 디렉터리 잠금 파일을 만드는 동안 데이터가 영구 저장소에 도달 할 때까지 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e096887a303519506fcd67516869ace11ad3e59e" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while adding a line to the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일에 행을 추가하는 동안 데이터가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fe0ab1a16e2329bfa52c27e76aa50ab788d415cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while assigning WAL sync method.</source>
          <target state="translated">WAL 동기화 방법을 할당하는 동안 데이터가 안정적인 저장소에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="0a67fcfeb93618a5687879b86795e36261b23961" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while creating the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일을 작성하는 동안 데이터가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1f817023f7f1aeed83afe73b277506f04bbf5f51" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to clear transaction id at transaction end.</source>
          <target state="translated">그룹 리더가 트랜잭션 종료시 트랜잭션 ID를 지울 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9ad12c44c511affe8e5b28dfe797e5442cb69ba2" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to update transaction status at transaction end.</source>
          <target state="translated">그룹 리더가 트랜잭션 종료시 트랜잭션 상태를 업데이트하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="6303bec3edc9303d1de1e17ffbef9d10deeb2ec7" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to change state.</source>
          <target state="translated">논리적 복제 원격 서버가 상태를 변경하기를 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="a171ef7b847c02147b5330baa42032a3b728b099" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">논리적 복제 원격 서버가 초기 테이블 동기화를 위해 데이터를 전송하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="f7b87a554b163e3c4b56d071e13d3bb40ae9dcd8" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach durable storage during a checkpoint.</source>
          <target state="translated">체크 포인트 중에 논리적 다시 쓰기 매핑이 내구성있는 스토리지에 도달 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d0128fffe323c5eab36d0b583264686f6fdc14a9" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach durable storage.</source>
          <target state="translated">논리적 다시 쓰기 매핑이 내구성있는 스토리지에 도달하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1252663514ce3e310a8ccaa53abc308558932c1" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage during a checkpoint.</source>
          <target state="translated">검사 점 동안 논리적 다시 쓰기 매핑이 안정적인 저장소에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="754897ce0cd2e99fe42e75806589d9d45f48b612" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage.</source>
          <target state="translated">논리적 재 작성 매핑이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1012667842a00603eeb152c4741dc06b3a218b04" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach durable storage during a logical rewrite.</source>
          <target state="translated">논리적 다시 쓰기 중에 매핑 데이터가 내구성있는 저장소에 도달 할 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="ddcc4581e90866cae66b033e94adc36e9d35b43d" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach stable storage during a logical rewrite.</source>
          <target state="translated">논리적 재 작성 중 데이터 맵핑이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b8552e94ff493c563b97bc367629ad56d62866bf" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish hashing the inner relation.</source>
          <target state="translated">다른 Parallel Hash 참가자가 내부 관계 해시를 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e11479178e59844fd7fe15f1ce4eb490d0773d60" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</source>
          <target state="translated">다른 Parallel Hash 참가자가 새 버킷에 튜플 삽입을 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7c11b60c1a40d4f8d29e90353a8affe9075ec7f0" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish loading a hash table.</source>
          <target state="translated">다른 Parallel Hash 참가자가 해시 테이블로드를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5413b25ebacbf60f6298ddfd13544237708b4afd" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</source>
          <target state="translated">다른 Parallel Hash 참가자가 외부 관계 분할을 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5d8612704b7ac31605b00f1b5ae0376a34a38614" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish repartitioning.</source>
          <target state="translated">다른 병렬 해시 참가자가 재 파티션을 완료하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ddf8230dce1afc618c7942a19d13a4e06fbab65" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finishing repartitioning.</source>
          <target state="translated">다른 Parallel Hash 참가자가 재 파티션을 마치기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="7ddcd3a1c9792343c59de081cc3c348d37cc1494" translate="yes" xml:space="preserve">
          <source>Waiting for other process to be attached in shared message queue.</source>
          <target state="translated">다른 프로세스가 공유 메시지 큐에 첨부되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ea1e4d605c6dfe012718f5d6b6342a2c1167a5ba" translate="yes" xml:space="preserve">
          <source>Waiting for parallel &lt;code&gt;CREATE INDEX&lt;/code&gt; workers to finish heap scan.</source>
          <target state="translated">병렬 &lt;code&gt;CREATE INDEX&lt;/code&gt; 작업자가 힙 스캔을 완료하기를 기다리는 중입니다 .</target>
        </trans-unit>
        <trans-unit id="2c0e5b890525a78c621a8bd9247fc1bb58a1d9d0" translate="yes" xml:space="preserve">
          <source>Waiting for parallel bitmap scan to become initialized.</source>
          <target state="translated">병렬 비트 맵 스캔이 초기화되기를 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="54d8ebcdd8df7afcbc1ca990a46b504e44b8711d" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation lock.</source>
          <target state="translated">병렬 쿼리 동적 공유 메모리 할당 잠금을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1fc906f71278562c97c85008b2e438b9bb00035c" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation.</source>
          <target state="translated">병렬 쿼리 동적 공유 메모리 할당을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="6b2ad8cbb3533dbd2f7a9b18414fee3c1da25764" translate="yes" xml:space="preserve">
          <source>Waiting for parallel workers to finish computing.</source>
          <target state="translated">병렬 작업자가 컴퓨팅을 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="be528b921033388197b955d3bbbb7b2e892893ec" translate="yes" xml:space="preserve">
          <source>Waiting for recovery conflict resolution for a vacuum cleanup.</source>
          <target state="translated">진공 정리를위한 복구 충돌 해결을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="98c345abde177b384e76034b5919030c1a291113" translate="yes" xml:space="preserve">
          <source>Waiting for recovery conflict resolution for dropping a tablespace.</source>
          <target state="translated">테이블 스페이스 삭제를위한 복구 충돌 해결을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7d3620b94d83d3288e29f36d6b41b0a233781347" translate="yes" xml:space="preserve">
          <source>Waiting for recovery to be resumed.</source>
          <target state="translated">복구가 재개되기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d884014cf602749f289dbc7c7fc61acad84fa09d" translate="yes" xml:space="preserve">
          <source>Waiting for standby promotion.</source>
          <target state="translated">대기 프로모션 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="8cb227e761e8b1bc97dcd2f57c98b273168fa6eb" translate="yes" xml:space="preserve">
          <source>Waiting for startup process to send initial data for streaming replication.</source>
          <target state="translated">스트리밍 복제를 위해 시작 프로세스가 초기 데이터를 전송하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="575b51c84a8a278b78f70ac32550deee0ade954c" translate="yes" xml:space="preserve">
          <source>Waiting for the &lt;code&gt;pg_control&lt;/code&gt; file to reach durable storage.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; 파일이 영구 저장소에 도달 할 때까지 기다 립니다.</target>
        </trans-unit>
        <trans-unit id="4de10813baf47bfe4c27cf4c7969243299b919ed" translate="yes" xml:space="preserve">
          <source>Waiting for the control file to reach stable storage.</source>
          <target state="translated">제어 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7dd0de4ea463c3d55bd0ecf6a2a3ba4fdd4c90a5" translate="yes" xml:space="preserve">
          <source>Waiting for the group leader to clear the transaction ID at end of a parallel operation.</source>
          <target state="translated">그룹 리더가 병렬 작업이 끝날 때 트랜잭션 ID를 지울 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="1d874537780129e3ca666a787de17aa9ba412019" translate="yes" xml:space="preserve">
          <source>Waiting for the group leader to update transaction status at end of a parallel operation.</source>
          <target state="translated">병렬 작업이 끝날 때 그룹 리더가 트랜잭션 상태를 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="681bd23f805b6da445bd3d82fc4a46addc600e13" translate="yes" xml:space="preserve">
          <source>Waiting for the page number needed to continue a parallel B-tree scan to become available.</source>
          <target state="translated">병렬 B- 트리 스캔을 계속 사용하는 데 필요한 페이지 번호를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="19a27081e7292e225f5308f76e3b7bb1b53bae9d" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach durable storage.</source>
          <target state="translated">관계 맵 파일이 영구 저장소에 도달 할 때까지 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c939d0ba9c27dac2f7d8824016725fedd49ef586" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach stable storage.</source>
          <target state="translated">관계 맵 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="9e983510c142fcea08d4f84210ccfa6323d4b28e" translate="yes" xml:space="preserve">
          <source>Waiting for truncate of mapping data during a logical rewrite.</source>
          <target state="translated">논리적 다시 쓰기 중 매핑 데이터 자르기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7be20b27094dae3303ee1fadc67011cd3751be8" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to establish connection to remote server.</source>
          <target state="translated">원격 서버에 연결하기 위해 WAL 수신자 대기 중.</target>
        </trans-unit>
        <trans-unit id="8b6df6362589c923614f910bed59cf34ff945324" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to receive data from remote server.</source>
          <target state="translated">원격 서버에서 데이터를 수신하기 위해 WAL 수신자 대기 중.</target>
        </trans-unit>
        <trans-unit id="cb632d8f0ca89d0c5cd00cc7485e8835401d24f7" translate="yes" xml:space="preserve">
          <source>Waiting in a cost-based vacuum delay point.</source>
          <target state="translated">비용 기반 진공 지연 지점에서 대기합니다.</target>
        </trans-unit>
        <trans-unit id="bb83e82efa5858b6db8ad5949e98eced2a90463a" translate="yes" xml:space="preserve">
          <source>Waiting in an extension.</source>
          <target state="translated">내선에서 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="feb270e93605e72d07d6bcedd0737f5a39e22df0" translate="yes" xml:space="preserve">
          <source>Waiting in background writer process, hibernating.</source>
          <target state="translated">백그라운드 라이터 프로세스에서 대기중인 동면.</target>
        </trans-unit>
        <trans-unit id="88eefbfbae399c6feea1548c69357a5e9736f5ab" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL receiver process.</source>
          <target state="translated">WAL 수신기 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="375265f881add8dd9c33130678344167b52a9588" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL sender process.</source>
          <target state="translated">WAL 발신자 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="f5e173311caac73154fc23d76aed32502c099d08" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL writer process.</source>
          <target state="translated">WAL 라이터 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="3a633670f0870c8e9a937ee6b4ff3e55e43509be" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of archiver process.</source>
          <target state="translated">아카이버 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="7acb76585737d883d007ddb658d4cfd89597eb50" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of autovacuum launcher process.</source>
          <target state="translated">autovacuum 런처 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="7e6e41b3df7e89238ff4283ef4198a69ebe76109" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process background worker.</source>
          <target state="translated">배경 작가 프로세스 배경 작업자의 메인 루프에서 기다리고.</target>
        </trans-unit>
        <trans-unit id="4468be3c04a316f7404c95b5e3ff6208ba74e229" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process.</source>
          <target state="translated">백그라운드 작성기 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="d193be75953171ebbce3b3db2cde50e60c132491" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of checkpointer process.</source>
          <target state="translated">검사 점 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="db02418c7eb01a5eb05765091cb30a31f71aa88d" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical apply process.</source>
          <target state="translated">논리적 적용 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="82a745dd84bf90f7ae367a6c7dc035147ac68293" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical launcher process.</source>
          <target state="translated">논리 실행기 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="56edcd7dc5636046884520046ede7d834d729f36" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical replication apply process.</source>
          <target state="translated">논리적 복제 적용 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9560c436af4a42ef660a92403ce9cdd3a8693974" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical replication launcher process.</source>
          <target state="translated">논리적 복제 실행기 프로세스의 기본 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="1679d413ddb6f0377771d12a5f1423b023c45511" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of startup process for WAL to arrive, during streaming recovery.</source>
          <target state="translated">스트리밍 복구 중에 WAL이 도착할 때까지 시작 프로세스의 기본 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="fd3c72bbecc0f184f22e57ca78f3e93236b96e1a" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of statistics collector process.</source>
          <target state="translated">통계 수집기 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="1e0772397293bff630517da7bd7ffb1ab81b17f5" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of syslogger process.</source>
          <target state="translated">syslogger 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="54f59b1a36db7407d20232e85176d4c1a23692f4" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the archiver process.</source>
          <target state="translated">아카이버 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="212f0884ddfbc91689a2a97c09aafbcd3f389116" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the statistics collector process.</source>
          <target state="translated">통계 콜렉터 프로세스의 기본 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="3b4ceca9ff1b34dd3a21d5a1be2bf8a9aa711a70" translate="yes" xml:space="preserve">
          <source>Waiting in process that called &lt;code&gt;pg_sleep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; 이라는 프로세스를 기다리는 중입니다 .</target>
        </trans-unit>
        <trans-unit id="8d789f564ccad610d19b36929dbb0ef518eb37c8" translate="yes" xml:space="preserve">
          <source>Waiting to access a data page in memory.</source>
          <target state="translated">메모리의 데이터 페이지에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4ae79783ab5a39da6e76c4478527282bcedbc6a" translate="yes" xml:space="preserve">
          <source>Waiting to access a parallel query's information about composite types.</source>
          <target state="translated">복합 유형에 대한 병렬 쿼리의 정보에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d1b409aa03dee9b02a04e2a2e3f64452f3400a" translate="yes" xml:space="preserve">
          <source>Waiting to access a parallel query's information about type modifiers that identify anonymous record types.</source>
          <target state="translated">익명 레코드 유형을 식별하는 유형 수정 자에 대한 병렬 쿼리의 정보에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1030c503e3237c1219d1eea28582a6ddcbee56c" translate="yes" xml:space="preserve">
          <source>Waiting to access a shared TID bitmap during a parallel bitmap index scan.</source>
          <target state="translated">병렬 비트 맵 인덱스 스캔 중에 공유 TID 비트 맵에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eba3915c1db0580d2b281d905946603d4982aff" translate="yes" xml:space="preserve">
          <source>Waiting to access a shared tuple store during parallel query.</source>
          <target state="translated">병렬 쿼리 중에 공유 튜플 저장소에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="129d2539d77dbbde3d4d4e8ea2141ca238f7d876" translate="yes" xml:space="preserve">
          <source>Waiting to access predicate lock information used by serializable transactions.</source>
          <target state="translated">직렬화 가능한 트랜잭션에서 사용하는 술어 잠금 정보에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7319b09761891c0f9227dbd3732f4b9eaeb8739" translate="yes" xml:space="preserve">
          <source>Waiting to access the &lt;code&gt;NOTIFY&lt;/code&gt; message SLRU cache.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 메시지 SLRU 캐시 에 액세스하기를 기다리고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af1ca2e2935e52e66c06e90f2e54befc88f72df7" translate="yes" xml:space="preserve">
          <source>Waiting to access the commit timestamp SLRU cache.</source>
          <target state="translated">커밋 타임 스탬프 SLRU 캐시에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0184a02009f44f4d2a88cbd98d9dfe8231fceb5e" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of finished serializable transactions.</source>
          <target state="translated">완료된 직렬화 가능 트랜잭션 목록에 액세스하려고 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="55fba80517e3090a2255d706ee1972631c869d74" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of predicate locks held by serializable transactions.</source>
          <target state="translated">직렬화 가능한 트랜잭션이 보유한 술어 잠금 목록에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f47f83daf5272307314e793a722029f6849c834f" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of predicate locks held by the current serializable transaction during a parallel query.</source>
          <target state="translated">병렬 쿼리 중에 현재 직렬화 가능한 트랜잭션이 보유한 술어 잠금 목록에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d72c61a42652b27a772dd6eed5858254b3939df" translate="yes" xml:space="preserve">
          <source>Waiting to access the multixact member SLRU cache.</source>
          <target state="translated">multixact 멤버 SLRU 캐시에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c797a16c61c341fd52d3f66bf04186016fb3de" translate="yes" xml:space="preserve">
          <source>Waiting to access the multixact offset SLRU cache.</source>
          <target state="translated">multixact 오프셋 SLRU 캐시에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="860e2d04d5faad33e65a1c939bd5f4775f44e584" translate="yes" xml:space="preserve">
          <source>Waiting to access the serializable transaction conflict SLRU cache.</source>
          <target state="translated">직렬화 가능한 트랜잭션 충돌 SLRU 캐시에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c61dc32e3583de9339bc9f5339255eccb847d4" translate="yes" xml:space="preserve">
          <source>Waiting to access the shared per-process data structures (typically, to get a snapshot or report a session's transaction ID).</source>
          <target state="translated">공유 된 프로세스 별 데이터 구조에 대한 액세스 대기 (일반적으로 스냅 샷을 가져 오거나 세션의 트랜잭션 ID를보고하기 위해)</target>
        </trans-unit>
        <trans-unit id="6be8feecbd6665e987b15bc5fe4b1aa15dcee557" translate="yes" xml:space="preserve">
          <source>Waiting to access the sub-transaction SLRU cache.</source>
          <target state="translated">하위 트랜잭션 SLRU 캐시에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9c50c150b703d0eb8293a5862178e36f3db67f" translate="yes" xml:space="preserve">
          <source>Waiting to access the transaction status SLRU cache.</source>
          <target state="translated">트랜잭션 상태 SLRU 캐시에 액세스하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="453521c4c18069faa9fd0afad3d83ca7731d1096" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a non-relation database object.</source>
          <target state="translated">비 관계형 데이터베이스 오브젝트에 대한 잠금 획득을 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="373b1f9b0bfcc9c3b92c4d65ca011a20f7f7ee7b" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a page of a relation.</source>
          <target state="translated">관계 페이지에 대한 잠금을 획득하려고 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="e1e200aae0e4f2353a2c19cd08c7d6ee7ce7f912" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a relation.</source>
          <target state="translated">관계에 대한 잠금을 획득하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="caf9078aaa0a5a46ce631268ce4c46ea2cb0e198" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a tuple.</source>
          <target state="translated">튜플에서 잠금을 획득하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="20d61e9ac29e8e57ca0786825f9ae212af87d782" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on page of a relation.</source>
          <target state="translated">관계의 페이지에서 잠금을 획득하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="60529117b6f828f517a439e0152cfca12a03780e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a pin on a buffer.</source>
          <target state="translated">버퍼에서 핀을 얻기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9dff15d412549524e8b05e08b4e658a978321307" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a speculative insertion lock.</source>
          <target state="translated">투기 삽입 잠금을 얻기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="6f1d92a10ff6e0f42c232bac9cd39b9515b5e1f1" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a user lock.</source>
          <target state="translated">사용자 잠금 획득을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b864edb73d7fdb51b089c159fd2e24aac209fa44" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual transaction ID lock.</source>
          <target state="translated">가상 트랜잭션 ID 잠금을 얻기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="feee645b171eddc5255ea3172e0b6eaae2f3531e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual xid lock.</source>
          <target state="translated">가상 xid 잠금 획득을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="0cff112c15e1e7f938ee8722e01003e541c3a9b9" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an advisory user lock.</source>
          <target state="translated">권고 사용자 잠금 획득을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fb4afc5fd680e2c4a5249b716bc3eb3612204493" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an exclusive pin on a buffer.</source>
          <target state="translated">버퍼에서 독점 핀을 얻기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="f4b782a596b50a85963931c1ce8ff87a36ab9e82" translate="yes" xml:space="preserve">
          <source>Waiting to add a message in shared invalidation queue.</source>
          <target state="translated">공유 무효화 큐에 메시지 추가 대기 중.</target>
        </trans-unit>
        <trans-unit id="e0bc3fce7ad76f7cd0de9cfb2f8867086e1cad27" translate="yes" xml:space="preserve">
          <source>Waiting to add a message to the shared catalog invalidation queue.</source>
          <target state="translated">공유 카탈로그 무효화 큐에 메시지를 추가하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30c5b64b9088c9bea1b788c2d9cad490d0feadc" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine locks for backends, or waiting to join or exit a locking group (used by parallel query).</source>
          <target state="translated">백엔드에 대한 잠금을 추가 또는 검사하기 위해 대기 중이거나 잠금 그룹에 참여 또는 종료하기 위해 대기 중 (병렬 쿼리에서 사용)</target>
        </trans-unit>
        <trans-unit id="4234f3768471935481a7a5ac70e216c3b3196d0a" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine predicate lock information.</source>
          <target state="translated">술어 잠금 정보 추가 또는 검사 대기 중</target>
        </trans-unit>
        <trans-unit id="cd6ab73b17fc50224d6ba20de7b66c56a5168edd" translate="yes" xml:space="preserve">
          <source>Waiting to allocate a new OID.</source>
          <target state="translated">새 OID 할당을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6110497bf2fb4e7dd3e567f14149228534e81be" translate="yes" xml:space="preserve">
          <source>Waiting to allocate a new transaction ID.</source>
          <target state="translated">새 트랜잭션 ID 할당을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="922ece807fb5d0e3eca745374502101b8e2f9883" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign a transaction id.</source>
          <target state="translated">트랜잭션 ID 할당 또는 할당을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="4df1187e247ec9e3885764b731ccac5a81693366" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign an OID.</source>
          <target state="translated">OID 할당 또는 할당을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="36e78f99b93b8582ddda9533616d35bad0cb3435" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or exchange a chunk of memory or update counters during Parallel Hash plan execution.</source>
          <target state="translated">Parallel Hash 계획 실행 중 메모리 청크 또는 업데이트 카운터 할당 또는 교환을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="aea0084a8686cdd126b6dc0b70e3bb510372f940" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or free a replication slot.</source>
          <target state="translated">복제 슬롯 할당 또는 해제 대기 중</target>
        </trans-unit>
        <trans-unit id="392b0fcbf6923b50ad00d9bcdf711922567f010a" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL at recovery because it is delayed.</source>
          <target state="translated">WAL이 지연되어 복구시 WAL 적용 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="6a88aa7353a070ee85e5931747ec79047e6808c8" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL during recovery because of a delay setting.</source>
          <target state="translated">지연 설정으로 인해 복구 중 WAL 적용 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="417e2e4d470ba2ea215e899c1f2f47a808b6cd1d" translate="yes" xml:space="preserve">
          <source>Waiting to associate a data block with a buffer in the buffer pool.</source>
          <target state="translated">버퍼 풀의 버퍼와 데이터 블록 연결을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="441c3081779de229e60de2154d2224a6b45068d6" translate="yes" xml:space="preserve">
          <source>Waiting to begin a checkpoint.</source>
          <target state="translated">체크 포인트 시작을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b5eba1b1476e67df8c9026fe8a8423164cbbbaf" translate="yes" xml:space="preserve">
          <source>Waiting to choose the next subplan during Parallel Append plan execution.</source>
          <target state="translated">병렬 추가 계획 실행 중 다음 하위 계획을 선택하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="ef3a63e38286ce146119c1f18cfc00a196004cf5" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop a tablespace.</source>
          <target state="translated">테이블 스페이스 생성 또는 삭제를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="11402cb956b4c4ad7b4f3ee48f5957e1d0e2837b" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop the tablespace.</source>
          <target state="translated">테이블 스페이스 작성 또는 삭제 대기 중</target>
        </trans-unit>
        <trans-unit id="33c72accbdd4730b372dab88dd65b76db73de627" translate="yes" xml:space="preserve">
          <source>Waiting to create, drop or use a replication origin.</source>
          <target state="translated">복제 오리진 생성, 삭제 또는 사용을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="65bc84d857a25120993bfa2901196e8db0fe8c4c" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">해시 테이블을 할당 할 병렬 해시 참가자를 선택하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4f746425fc465e7164c9c695db3b4635155f935" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate more batches.</source>
          <target state="translated">더 많은 배치를 할당하기 위해 병렬 해시 참가자를 선출하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="639eee9765487a635a37650a7d0fb63770b1ca2a" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate more buckets.</source>
          <target state="translated">더 많은 버킷을 할당하기 위해 병렬 해시 참가자를 선택하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5677145792ffce4d3d31df1e9a789e136de6ea8" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">초기 해시 테이블을 할당 할 병렬 해시 참가자를 선택하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="065be077f679b5dad73d4b8a473bd2b28958e69a" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">향후 배치 증가를 결정하기 위해 병렬 해시 참가자를 선출하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f5db2c59767bd472dd0b1faf70ac07aafa7a96" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that a table selected for autovacuum still needs vacuuming.</source>
          <target state="translated">autovacuum 용으로 선택한 테이블에 여전히 vacuum이 필요한지 확인하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="ef13562f4466bb31b5bf871e5d3f767784c48032" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that the table it has selected for a vacuum still needs vacuuming.</source>
          <target state="translated">진공을 위해 선택한 테이블이 여전히 진공 상태를 유지하도록 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="d69f496f29eae75635234b22654119ee74ecb1dc" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;pg_xact_status&lt;/code&gt; or update the oldest transaction ID available to it.</source>
          <target state="translated">&lt;code&gt;pg_xact_status&lt;/code&gt; 를 실행 하거나 사용 가능한 가장 오래된 트랜잭션 ID를 업데이트 하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d2e90490a1d7b7d270317787f40bff2e1d72ee9" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;txid_status&lt;/code&gt; or update the oldest transaction id available to it.</source>
          <target state="translated">&lt;code&gt;txid_status&lt;/code&gt; 를 실행 하거나 사용 가능한 가장 오래된 트랜잭션 ID를 기다리는 중 입니다.</target>
        </trans-unit>
        <trans-unit id="905b59818613073e2e260c6b0fb7d68bf3c39843" translate="yes" xml:space="preserve">
          <source>Waiting to extend a relation.</source>
          <target state="translated">관계 확장을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="d1ff05f0321453c7e170463f2183122fba046afb" translate="yes" xml:space="preserve">
          <source>Waiting to fill a dynamic shared memory backing file with zeroes.</source>
          <target state="translated">동적 공유 메모리 백업 파일을 0으로 채우기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8b7f54188ceea3dc5def955dc47ae1f28373839" translate="yes" xml:space="preserve">
          <source>Waiting to find or allocate space in shared memory.</source>
          <target state="translated">공유 메모리에서 공간을 찾거나 할당하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="fb53c073cc374cfb75fd8b826e6b4d7eb6cc9003" translate="yes" xml:space="preserve">
          <source>Waiting to get a snapshot or clearing a transaction id at transaction end.</source>
          <target state="translated">트랜잭션 종료시 스냅 샷을 확보하거나 트랜잭션 ID를 지우는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e384d346b49ba85024e06c032fcf3ccf1737b636" translate="yes" xml:space="preserve">
          <source>Waiting to get the start location of a scan on a table for synchronized scans.</source>
          <target state="translated">동기화 된 스캔을 위해 테이블에서 스캔 시작 위치를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="77a61ca13921177e3120d7941bf5fe7710333ad3" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL data into a memory buffer.</source>
          <target state="translated">WAL 데이터를 메모리 버퍼에 삽입하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a6beee315605623099d06c2371ae56da6b46cc7" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL into a memory buffer.</source>
          <target state="translated">메모리 버퍼에 WAL 삽입을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="cadbcac0880c9c035e541586388a47501c362c88" translate="yes" xml:space="preserve">
          <source>Waiting to manage an extension's space allocation in shared memory.</source>
          <target state="translated">공유 메모리에서 확장의 공간 할당 관리를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe4ce59b2db271f1abfb91f4099370c7dcadc0ae" translate="yes" xml:space="preserve">
          <source>Waiting to manage fsync requests.</source>
          <target state="translated">fsync 요청 관리를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e3141c5d05c342451c8644a34df11be83dd434ad" translate="yes" xml:space="preserve">
          <source>Waiting to manage space allocation in shared memory.</source>
          <target state="translated">공유 메모리에서 공간 할당 관리를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fac57a518044fa2f05c64ea1dd8ce9527a59af1f" translate="yes" xml:space="preserve">
          <source>Waiting to obtain a valid snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">&lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; 트랜잭션에 대한 유효한 스냅 샷을 얻기 위해 대기 중 입니다.</target>
        </trans-unit>
        <trans-unit id="b97c8584b996285f48aeab64ef02658839acbba9" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a list of locks held by serializable transactions.</source>
          <target state="translated">직렬화 가능 트랜잭션이 보유한 잠금 목록에서 조작을 수행하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="d8589a1b8c66d6f8e4debafdd099f1a4b71a5b13" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a serializable transaction in a parallel query.</source>
          <target state="translated">병렬 쿼리에서 직렬화 가능 트랜잭션에 대한 작업을 수행하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="d2ade432e382335fbb1d6fb86bda4500ee8c2cbb" translate="yes" xml:space="preserve">
          <source>Waiting to perform checkpoint.</source>
          <target state="translated">검사 점 수행을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="3e379fd689c1e6c70aa9f8b650b7c7fb7692028c" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client while establishing a GSSAPI session.</source>
          <target state="translated">GSSAPI 세션을 설정하는 동안 클라이언트에서 데이터 읽기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1908bfbabea7a0ab1bbde739ebc0330fc7517b79" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client.</source>
          <target state="translated">클라이언트에서 데이터 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="05dd640e8c1d54ebf01054c0befd12ca4f14b63e" translate="yes" xml:space="preserve">
          <source>Waiting to read or record conflicting serializable transactions.</source>
          <target state="translated">충돌하는 직렬화 가능 트랜잭션을 읽거나 기록하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="0afe38ebe7d995583b3d1a5cd94b6fbc8cf1b845" translate="yes" xml:space="preserve">
          <source>Waiting to read or truncate multixact information.</source>
          <target state="translated">multixact 정보를 읽거나 자르기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="89e6d605086c4806a8e8361ed20ce472bcc5d0c1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update &lt;code&gt;NOTIFY&lt;/code&gt; messages.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 메시지 를 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa2ee7fba8bdd1b9ba46fd013db4148ed8d4f325" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a &lt;code&gt;pg_filenode.map&lt;/code&gt; file (used to track the filenode assignments of certain system catalogs).</source>
          <target state="translated">&lt;code&gt;pg_filenode.map&lt;/code&gt; 파일 을 읽거나 업데이트하기를 기다리고 있습니다 (특정 시스템 카탈로그의 파일 노드 할당을 추적하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="f06b28a219ba82487eff75cb07672ef51a1fba36" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a &lt;code&gt;pg_internal.init&lt;/code&gt; relation cache initialization file.</source>
          <target state="translated">&lt;code&gt;pg_internal.init&lt;/code&gt; 관계 캐시 초기화 파일 을 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="29aea2dafdc907848a947f9ada3488409914bca8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a process' fast-path lock information.</source>
          <target state="translated">프로세스의 빠른 경로 잠금 정보를 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a018a1a15593b5af23414939d50aec3fcb48c5cb" translate="yes" xml:space="preserve">
          <source>Waiting to read or update background worker state.</source>
          <target state="translated">백그라운드 작업자 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="98f949b18dca9797ce85a82873e92ff14c18778a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory allocation information.</source>
          <target state="translated">동적 공유 메모리 할당 정보를 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea27617060567594092b7422c38330bfc2e5ee2" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory state.</source>
          <target state="translated">동적 공유 메모리 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9ba9dcf3b19a57aaa5ade4bb0b3f5c3178217365" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about &amp;ldquo;heavyweight&amp;rdquo; locks.</source>
          <target state="translated">&quot;heavyweight&quot;잠금에 대한 정보를 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aef06dd768e3617fde4dd6b5fb7f38e7fb0ef3c" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about serializable transactions.</source>
          <target state="translated">직렬화 가능한 트랜잭션에 대한 정보를 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b94e34a6c9a38b9de8ddbf38266ea41569caa0e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about synchronous replicas.</source>
          <target state="translated">동기 복제본에 대한 정보를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="8db953a370c198b1e5b5a6d588d15d8ed6771d32" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about the state of synchronous replication.</source>
          <target state="translated">동기 복제 상태에 대한 정보를 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7be479f3c24eeb847b5e44a9bf4f341c29d1834b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact member mappings.</source>
          <target state="translated">multixact 멤버 맵핑을 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="548a78a89a3c004e9ad475a70fb6f1bb50c1151e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact offset mappings.</source>
          <target state="translated">multixact 오프셋 맵핑을 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="ed18ac469b6f870e80be0efbf5c76a4d5c79b754" translate="yes" xml:space="preserve">
          <source>Waiting to read or update notification messages.</source>
          <target state="translated">알림 메시지를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="76d4dfb568ccc6112df58f601dc5c426ad5d62a8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update old snapshot control information.</source>
          <target state="translated">오래된 스냅 샷 제어 정보를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="6ce0cc66a076e07f94b764161b2bddd57ada2509" translate="yes" xml:space="preserve">
          <source>Waiting to read or update replication slot state.</source>
          <target state="translated">복제 슬롯 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="fff67315163276ff44c96c0a78a1830dd666732b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared multixact state.</source>
          <target state="translated">공유 멀티 플렉스 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="b79ef3c6f580409e99c1e495bc8e24c202fbe7ed" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared notification state.</source>
          <target state="translated">공유 알림 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="af64ba8ecf87cac9594cd6dc3c61c2e7ddf060d1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update sub-transaction information.</source>
          <target state="translated">서브 트랜잭션 정보를 읽거나 갱신하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="c25e2fc156128ae3093a921e12431593e8862638" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the &lt;code&gt;pg_control&lt;/code&gt; file or create a new WAL file.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; 파일 을 읽거나 업데이트 하거나 새 WAL 파일을 생성하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdb0edf32466a645cdde40c21227abb2a0bb1f30" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the control file or creation of a new WAL file.</source>
          <target state="translated">제어 파일을 읽거나 업데이트하기 위해 대기 중이거나 새 WAL 파일을 작성 중입니다.</target>
        </trans-unit>
        <trans-unit id="017527ae52f7de277c3c95bf02bbacf34474f0f5" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the current state of autovacuum workers.</source>
          <target state="translated">autovacuum 작업자의 현재 상태를 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="221da797b029fb896c5fbaed99fd507a4ef2a941" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the fast-path lock information.</source>
          <target state="translated">빠른 경로 잠금 정보를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="744cbcf49721354a8aff1c310f4ca421dbb8db3a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for a transaction commit timestamp.</source>
          <target state="translated">트랜잭션 커밋 타임 스탬프에 대해 설정된 마지막 값을 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9baf36ef5d66bb0ea1e99230d14314cf70bc406" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for the transaction timestamp.</source>
          <target state="translated">트랜잭션 타임 스탬프에 설정된 마지막 값을 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="e381bb78e4f640c21175ed08f51ed2c3a71544c7" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the progress of one replication origin.</source>
          <target state="translated">한 복제 오리진의 진행 상황을 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f6ffef563dec9ba786a7f233d5003f5ed45d14" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the replication progress.</source>
          <target state="translated">복제 진행률을 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9ed2e28217e033a2eda63210c67632651e72f60a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of logical replication workers.</source>
          <target state="translated">논리적 복제 작업자의 상태를 읽거나 업데이트하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="defd9a9d465fec9edd19efb8c557ca9acbf7364b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of prepared transactions.</source>
          <target state="translated">준비된 트랜잭션의 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="3dc7e6836006d3d5cbb7a9151c1a348063bbcc88" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction commit timestamps.</source>
          <target state="translated">트랜잭션 커밋 타임 스탬프를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="22fb7890af933754ae7b2b3d81b6bd6e23c2cc52" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction status.</source>
          <target state="translated">트랜잭션 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="1691bd5ffa74ce0764d59f613b874fce42907700" translate="yes" xml:space="preserve">
          <source>Waiting to read or update vacuum-related information for a B-tree index.</source>
          <target state="translated">B- 트리 인덱스에 대한 진공 관련 정보를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="7909f678b84800f1b2a16328d0f20ff93a738a0c" translate="yes" xml:space="preserve">
          <source>Waiting to read or write a data page in memory.</source>
          <target state="translated">메모리에서 데이터 페이지를 읽거나 쓰기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="ba3f3c6d87b25a2add5f41dc054490a6748416d8" translate="yes" xml:space="preserve">
          <source>Waiting to read or write relation cache initialization file.</source>
          <target state="translated">관계 캐시 초기화 파일 읽기 또는 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="56e29e2fa37b4e49226f461d31f27cc492afa177" translate="yes" xml:space="preserve">
          <source>Waiting to read while creating the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일을 작성하는 중 읽기 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="22b6a17e9f6b4570d83c86bfc0b1331afbfa69c0" translate="yes" xml:space="preserve">
          <source>Waiting to receive bytes from a shared message queue.</source>
          <target state="translated">공유 메시지 큐에서 바이트를 받기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9ce53a35add68653a7082475749be3845de4e91c" translate="yes" xml:space="preserve">
          <source>Waiting to replace a page in WAL buffers.</source>
          <target state="translated">WAL 버퍼에서 페이지 교체를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="c84c4a6cb5ccf93e74ddb23312f4a777174ed071" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve messages from the shared catalog invalidation queue.</source>
          <target state="translated">공유 카탈로그 무효화 큐에서 메시지 검색을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3b17dffde0ea5035f1032f34d22df0ea10ab951" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or remove messages from shared invalidation queue.</source>
          <target state="translated">공유 무효화 큐에서 메시지를 검색하거나 제거하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="4f507f65bfda2fa748e9dfb44f6b949cbab52bf9" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or store information about serializable transactions.</source>
          <target state="translated">직렬화 가능 트랜잭션에 대한 정보를 검색하거나 저장하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="eda502d0abfb7f1427a080a8bf7103d25fc2176f" translate="yes" xml:space="preserve">
          <source>Waiting to select the starting location of a synchronized table scan.</source>
          <target state="translated">동기화 된 테이블 스캔의 시작 위치를 선택하기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9928fb30a8b9bafde30f4c1a7932ab2be3ad802" translate="yes" xml:space="preserve">
          <source>Waiting to send bytes to a shared message queue.</source>
          <target state="translated">공유 메시지 큐에 바이트를 보내기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="352defc191b1b37d8d934ce574b79689999451d7" translate="yes" xml:space="preserve">
          <source>Waiting to setup, drop or use replication origin.</source>
          <target state="translated">복제 원본을 설정, 삭제 또는 사용하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="25cb6ca2b8d634f565c4d46066dc5f3462003ea1" translate="yes" xml:space="preserve">
          <source>Waiting to synchronize workers during Parallel Hash Join plan execution.</source>
          <target state="translated">병렬 해시 조인 계획 실행 중 작업자 동기화를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9266129c75950e38bd53efc5efcc13655677392e" translate="yes" xml:space="preserve">
          <source>Waiting to update &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datfrozenxid&lt;/code&gt; and &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datminmxid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_database&lt;/code&gt; 업데이트를 기다리고 있습니다. &lt;code&gt;datfrozenxid&lt;/code&gt; 및 &lt;code&gt;pg_database&lt;/code&gt; . &lt;code&gt;datminmxid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb44735a3aba3220d386c9b3faf0ba38310b7b2b" translate="yes" xml:space="preserve">
          <source>Waiting to update limit on &lt;code&gt;NOTIFY&lt;/code&gt; message storage.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 메시지 저장소 에 대한 업데이트 제한을 기다리는 중 입니다.</target>
        </trans-unit>
        <trans-unit id="bedfd2279a25f8b35eba1268870241ba6990c56e" translate="yes" xml:space="preserve">
          <source>Waiting to update limits on transaction id and multixact consumption.</source>
          <target state="translated">트랜잭션 ID 및 multixact 소비에 대한 제한 업데이트를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="99b1822a05f8be538a4edd0d27d811178799d3aa" translate="yes" xml:space="preserve">
          <source>Waiting to update the &lt;code&gt;postgresql.auto.conf&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;postgresql.auto.conf&lt;/code&gt; 파일 업데이트를 기다리는 중 입니다.</target>
        </trans-unit>
        <trans-unit id="7f7ad4b1674906a82b48581d682f5005d47dd119" translate="yes" xml:space="preserve">
          <source>Waiting to update the relation map file used to store catalog to filenode mapping.</source>
          <target state="translated">카탈로그 대 파일 노드 맵핑을 저장하는 데 사용되는 관계 맵 파일 업데이트를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8dc204f5803f3077a290dca7bb374395f034529e" translate="yes" xml:space="preserve">
          <source>Waiting to write a protocol message to a shared message queue.</source>
          <target state="translated">공유 메시지 큐에 프로토콜 메시지 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2d0728d153f9f18004a22e4fb271924454b6a556" translate="yes" xml:space="preserve">
          <source>Waiting to write data to the client.</source>
          <target state="translated">클라이언트에 데이터 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="65a1974782cb646a2959736cb6599731cefd99f2" translate="yes" xml:space="preserve">
          <source>Waiting to write zero bytes to a dynamic shared memory backing file.</source>
          <target state="translated">동적 공유 메모리 백업 파일에 0 바이트 쓰기를 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="0929df55dd9f72fd6c1d910f07bdae3bd6e941bb" translate="yes" xml:space="preserve">
          <source>Warm and hot standby servers can be kept current by reading a stream of write-ahead log (WAL) records. If the main server fails, the standby contains almost all of the data of the main server, and can be quickly made the new master database server. This can be synchronous or asynchronous and can only be done for the entire database server.</source>
          <target state="translated">WAL (Write-Ahead Log) 레코드 스트림을 읽으면 웜 및 핫 대기 서버를 최신 상태로 유지할 수 있습니다. 주 서버에 장애가 발생하면 대기에는 주 서버의 거의 모든 데이터가 포함되며 새 마스터 데이터베이스 서버를 신속하게 만들 수 있습니다. 이는 동기식 또는 비동기식 일 수 있으며 전체 데이터베이스 서버에 대해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="a016c375864acf9c142cbb1359e053c54d4d9438" translate="yes" xml:space="preserve">
          <source>We already saw that &lt;code&gt;ORDER BY&lt;/code&gt; can be omitted if the ordering of rows is not important. It is also possible to omit &lt;code&gt;PARTITION BY&lt;/code&gt;, in which case there is a single partition containing all rows.</source>
          <target state="translated">행 순서가 중요하지 않은 경우 &lt;code&gt;ORDER BY&lt;/code&gt; 를 생략 할 수 있음 을 이미 확인했습니다. &lt;code&gt;PARTITION BY&lt;/code&gt; 를 생략 할 수도 있습니다 .이 경우 모든 행을 포함하는 단일 파티션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="836ee2eeb6e7ae6444006848acb871065ea3b213" translate="yes" xml:space="preserve">
          <source>We already saw the MCV information for &lt;code&gt;stringu1&lt;/code&gt;, and here is its histogram:</source>
          <target state="translated">우리는 이미 &lt;code&gt;stringu1&lt;/code&gt; 에 대한 MCV 정보를 보았으며 다음 은 히스토그램입니다.</target>
        </trans-unit>
        <trans-unit id="4916a888ae7040005cd716f2c3e28e1930fe1e1c" translate="yes" xml:space="preserve">
          <source>We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has indeed been permanently recorded and won't be lost even if a crash ensues shortly thereafter. For example, if we are recording a cash withdrawal by Bob, we do not want any chance that the debit to his account will disappear in a crash just after he walks out the bank door. A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.</source>
          <target state="translated">또한 데이터베이스 시스템에서 트랜잭션을 완료하고 승인 한 후에는 실제로 영구적으로 기록되어 그 이후에 충돌이 발생하더라도 손실되지 않는다는 보장을 원합니다. 예를 들어, Bob이 현금 인출을 기록하는 경우 은행 계좌 밖으로 나간 직후에 계좌에서 차변이 사라질 가능성을 원하지 않습니다. 트랜잭션 데이터베이스는 트랜잭션이 완료된 것으로보고되기 전에 트랜잭션에 의해 이루어진 모든 업데이트가 영구 저장소 (즉, 디스크)에 기록되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6743dd465747bd2e107f6841f4c88e12a10fdc63" translate="yes" xml:space="preserve">
          <source>We can also access arbitrary rectangular slices of an array, or subarrays. An array slice is denoted by writing &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; for one or more array dimensions. For example, this query retrieves the first item on Bill's schedule for the first two days of the week:</source>
          <target state="translated">배열의 임의의 직사각형 슬라이스 또는 하위 배열에 액세스 할 수도 있습니다. 배열 슬라이스는 하나 이상의 배열 차원에 대해 &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; 을 쓰면 표시됩니다 . 예를 들어,이 쿼리는 Bill의 일정에서 주 중 처음 2 일 동안 첫 번째 항목을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="26d5e00c2932aa021f71e1c7987bbc84382d9b85" translate="yes" xml:space="preserve">
          <source>We can also choose to return &lt;code&gt;NULL&lt;/code&gt;, instead of the lower-cased word, if it is not found in the stop words file. This behavior is selected by setting the dictionary's &lt;code&gt;Accept&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt;. Continuing the example:</source>
          <target state="translated">중지 단어 파일에서 찾을 수없는 경우 소문자 단어 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환하도록 선택할 수도 있습니다 . 이 동작은 사전의 &lt;code&gt;Accept&lt;/code&gt; 매개 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하면 선택됩니다 . 예제 계속하기 :</target>
        </trans-unit>
        <trans-unit id="dfd312f5fc4d67101d851237062bdba159c0ec59" translate="yes" xml:space="preserve">
          <source>We can also join a table against itself. This is called a &lt;em&gt;self join&lt;/em&gt;. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of each &lt;code&gt;weather&lt;/code&gt; row to the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of all other &lt;code&gt;weather&lt;/code&gt; rows. We can do this with the following query:</source>
          <target state="translated">테이블 자체를 조인 할 수도 있습니다. 이를 &lt;em&gt;자체 조인&lt;/em&gt; 이라고합니다 . 예를 들어, 다른 날씨 기록의 온도 범위에있는 모든 날씨 기록을 찾으려고 가정합니다. 따라서 각 &lt;code&gt;weather&lt;/code&gt; 행의 &lt;code&gt;temp_lo&lt;/code&gt; 및 &lt;code&gt;temp_hi&lt;/code&gt; 열을 다른 모든 &lt;code&gt;weather&lt;/code&gt; 행 의 &lt;code&gt;temp_lo&lt;/code&gt; 및 &lt;code&gt;temp_hi&lt;/code&gt; 열과 비교해야합니다 . 다음과 같은 쿼리로이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc6beb3b0e1bef62d183184143ea3d3ef810b4c" translate="yes" xml:space="preserve">
          <source>We can change the rewriting rules just by updating the table:</source>
          <target state="translated">테이블을 업데이트하여 다시 쓰기 규칙을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee2618785314089b8d336377e9a207db9405d3b4" translate="yes" xml:space="preserve">
          <source>We can create a GIN index (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;) to speed up text searches:</source>
          <target state="translated">텍스트 검색 속도를 높이기 위해 GIN 색인 ( &lt;a href=&quot;textsearch-indexes&quot;&gt;섹션 12.9&lt;/a&gt; )을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7821bbb704a2ac952eb9690616bfdd424400d47" translate="yes" xml:space="preserve">
          <source>We can do inheritance:</source>
          <target state="translated">우리는 상속을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d91685339d290a8a5e3f0243e992defd515e095f" translate="yes" xml:space="preserve">
          <source>We can then see that an administrator connecting over a network will not see any records, due to the restrictive policy:</source>
          <target state="translated">그런 다음 제한적인 정책으로 인해 네트워크를 통해 연결하는 관리자가 레코드를 볼 수 없음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e7ee16addc76bca0dc0a634456700165327da1e" translate="yes" xml:space="preserve">
          <source>We can update an individual subfield of a composite column:</source>
          <target state="translated">복합 열의 개별 하위 필드를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbaecdebc4248cd30d99181acc6ee4648ce55281" translate="yes" xml:space="preserve">
          <source>We choose not to index or search some token types that the built-in configuration does handle:</source>
          <target state="translated">내장 구성이 처리하는 일부 토큰 유형을 색인화하거나 검색하지 않기로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f68910847b8b293ecced82107bbdb7c9e86be5f0" translate="yes" xml:space="preserve">
          <source>We could also have written:</source>
          <target state="translated">우리는 또한 다음과 같이 쓸 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="1af074a97ee1433a54eef949ce0f504465ee61b0" translate="yes" xml:space="preserve">
          <source>We could simplify this by creating a SQL function that inserts a label at a specified position in a path:</source>
          <target state="translated">경로의 지정된 위치에 레이블을 삽입하는 SQL 함수를 작성하여이를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ed1bedde4f0b0f00a9838d665bf3bd179f0836" translate="yes" xml:space="preserve">
          <source>We define the synonym dictionary like this:</source>
          <target state="translated">동의어 사전은 다음과 같이 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d488cdbcb41070244eeea7399c07a12ab608b66e" translate="yes" xml:space="preserve">
          <source>We do not need a perfectly consistent file system backup as the starting point. Any internal inconsistency in the backup will be corrected by log replay (this is not significantly different from what happens during crash recovery). So we do not need a file system snapshot capability, just tar or a similar archiving tool.</source>
          <target state="translated">시작 지점으로 완벽하게 일관된 파일 시스템 백업이 필요하지 않습니다. 백업의 내부 불일치는 로그 재생을 통해 수정됩니다 (충돌 복구 중 발생하는 것과 크게 다르지 않음). 따라서 파일 시스템 스냅 샷 기능이 필요하지 않으며 tar 또는 유사한 아카이브 도구 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7d9a8fa7a3f06527b3bcf2908ca8717c376647ee" translate="yes" xml:space="preserve">
          <source>We have already discussed constants in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The following sections discuss the remaining options.</source>
          <target state="translated">&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;4.1.2 절&lt;/a&gt; 에서 상수에 대해 이미 논의했습니다 . 다음 섹션에서는 나머지 옵션에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a1ef9ac43045748116a115e49374f363a8ba372f" translate="yes" xml:space="preserve">
          <source>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data. In this situation we can use partitioning to help us meet all of our different requirements for the measurements table.</source>
          <target state="translated">이 표의 주요 용도는 관리를 위해 온라인 보고서를 준비하는 것이기 때문에 대부분의 쿼리는 지난 주, 월 또는 분기 데이터에만 액세스한다는 것을 알고 있습니다. 저장해야 할 오래된 데이터의 양을 줄이려면 최근 3 년 분량의 데이터 만 유지하기로합니다. 매월 초에 가장 오래된 월의 데이터를 제거합니다. 이 상황에서 파티셔닝을 사용하여 측정 테이블에 대한 다양한 요구 사항을 모두 충족 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a993aca05617d8df040114000bd6876b7a6bbb8" translate="yes" xml:space="preserve">
          <source>We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:</source>
          <target state="translated">외래 키로 인해 제품과 관련이없는 주문을 만들 수 없습니다. 그러나 제품을 참조하는 주문이 작성된 후 제품을 제거하면 어떻게됩니까? SQL을 사용하면이를 처리 할 수 ​​있습니다. 직관적으로 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afd1ca25954ba7db5e426cd93dec87fb2f18cad3" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">우리는 데이터가 어떻게 든 &lt;code&gt;capitals&lt;/code&gt; 테이블 로 라우팅되기를 원할 수도 있지만 이런 일은 일어나지 않습니다. &lt;code&gt;INSERT&lt;/code&gt; 는 항상 지정된 테이블에 정확하게 삽입됩니다. 경우에 따라 규칙을 사용하여 삽입을 리디렉션 할 수 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;40 장&lt;/a&gt; 참조 ). 그러나 &lt;code&gt;cities&lt;/code&gt; 테이블에 열 &lt;code&gt;state&lt;/code&gt; 가 포함되어 있지 않으므로 위의 경우에는 도움이되지 않으므로 규칙을 적용하기 전에 명령이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="b41ce96b205209d5c52d43184eb3122bcf4d7162" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">데이터가 어떻게 든 &lt;code&gt;capitals&lt;/code&gt; 테이블 로 라우팅되기를 바랄 수 있지만, 이것은 발생하지 않습니다. &lt;code&gt;INSERT&lt;/code&gt; 는 항상 지정된 테이블에 정확히 삽입합니다. 어떤 경우에는 규칙을 사용하여 삽입을 리디렉션 할 수 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;40 장&lt;/a&gt; 참조 ). 그러나 이는 &lt;code&gt;cities&lt;/code&gt; 테이블에 &lt;code&gt;state&lt;/code&gt; 열이 포함되어 있지 않으므로 위의 경우에는 도움이되지 않으므로 규칙을 적용하기 전에 명령이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="668bafcded25fc8a525c39fc8ba11f8e8e98aa03" translate="yes" xml:space="preserve">
          <source>We might want to insert data and have the server automatically locate the child table into which the row should be added. We could do this with a more complex trigger function, for example:</source>
          <target state="translated">데이터를 삽입하고 서버가 행을 추가 할 하위 테이블을 자동으로 찾도록 할 수 있습니다. 보다 복잡한 트리거 기능으로이를 수행 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1aa4d9dcdf43d5b53cef629cb08b1cf507249faa" translate="yes" xml:space="preserve">
          <source>We must redefine the trigger function each month so that it always points to the current child table. The trigger definition does not need to be updated, however.</source>
          <target state="translated">항상 현재 자식 테이블을 가리 키도록 트리거 함수를 매달 재정의해야합니다. 그러나 트리거 정의를 업데이트 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1597c32eb07ab6cca066ebab3e65392f57896307" translate="yes" xml:space="preserve">
          <source>We recommend that active production databases be vacuumed frequently (at least nightly), in order to remove dead rows. After adding or deleting a large number of rows, it might be a good idea to issue a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; command for the affected table. This will update the system catalogs with the results of all recent changes, and allow the PostgreSQL query planner to make better choices in planning queries.</source>
          <target state="translated">죽은 행을 제거하기 위해 활성 프로덕션 데이터베이스를 자주 (적어도 밤마다) 청소하는 것이 좋습니다. 많은 수의 행을 추가하거나 삭제 한 후 영향을받는 테이블에 대해 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 명령을 실행 하는 것이 좋습니다 . 그러면 모든 최근 변경 결과로 시스템 카탈로그가 업데이트되고 PostgreSQL 쿼리 플래너가 쿼리 계획에서 더 나은 선택을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e67abf5ade818ba6d22ea4bc6d74fa648515393" translate="yes" xml:space="preserve">
          <source>We reject the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command across the board, because any module loaded could easily circumvent security policy enforcement.</source>
          <target state="translated">로드 된 모든 모듈이 보안 정책 시행을 쉽게 우회 할 수 있으므로 보드 전체 에서 &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; 명령을 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="977603731abefa85626583cf9841c1f7f86bb5c7" translate="yes" xml:space="preserve">
          <source>We require the index access method to apply these tests itself, which means that it must reach into the heap to check the commit status of any row that is shown to have a duplicate key according to the index contents. This is without a doubt ugly and non-modular, but it saves redundant work: if we did a separate probe then the index lookup for a conflicting row would be essentially repeated while finding the place to insert the new row's index entry. What's more, there is no obvious way to avoid race conditions unless the conflict check is an integral part of insertion of the new index entry.</source>
          <target state="translated">이러한 테스트 자체를 적용하려면 인덱스 액세스 방법이 필요합니다. 즉, 인덱스 내용에 따라 중복 키가있는 것으로 표시된 행의 커밋 상태를 확인하려면 힙에 도달해야합니다. 이것은 추악하고 모듈화되지 않은 의심의 여지가 없지만 중복 작업을 절약합니다. 별도의 프로브를 사용하면 충돌하는 행에 대한 인덱스 조회가 본질적으로 반복되어 새 행의 인덱스 항목을 삽입 할 위치를 찾습니다. 또한 충돌 검사가 새 인덱스 항목을 삽입하는 데 필수적인 부분이 아닌 한 경쟁 조건을 피할 수있는 확실한 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="61809ffaa1e9bec3b74e00f63e536c6b27a9b1ac" translate="yes" xml:space="preserve">
          <source>We say that in this situation the orders table is the &lt;em&gt;referencing&lt;/em&gt; table and the products table is the &lt;em&gt;referenced&lt;/em&gt; table. Similarly, there are referencing and referenced columns.</source>
          <target state="translated">이 상황에서 orders 테이블은 &lt;em&gt;참조&lt;/em&gt; 테이블이고 products 테이블은 &lt;em&gt;참조&lt;/em&gt; 테이블이라고합니다. 마찬가지로 참조 및 참조 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="926fa8d618ecd63d98d203881339877369fb9e8a" translate="yes" xml:space="preserve">
          <source>We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:</source>
          <target state="translated">처음 두 제약 조건은 열 제약 조건 인 반면 세 번째 제약 조건은 하나의 열 정의와 별도로 작성되므로 테이블 제약 조건이라고합니다. 열 제약 조건은 테이블 제약 조건으로 작성할 수도 있지만 열 제약 조건은 연결된 열만 참조해야하기 때문에 그 반대의 경우가 반드시 필요한 것은 아닙니다. PostgreSQL은이 규칙을 적용하지 않지만 테이블 정의가 다른 데이터베이스 시스템과 작동하도록하려면 규칙을 따라야합니다. 위의 예제는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ad12c01cac6b9fd7b6ff658816ff5bf8b904a2" translate="yes" xml:space="preserve">
          <source>We store these documents in a table named &lt;code&gt;api&lt;/code&gt;, in a &lt;code&gt;jsonb&lt;/code&gt; column named &lt;code&gt;jdoc&lt;/code&gt;. If a GIN index is created on this column, queries like the following can make use of the index:</source>
          <target state="translated">이러한 문서는 &lt;code&gt;api&lt;/code&gt; 라는 테이블 , &lt;code&gt;jsonb&lt;/code&gt; 이라는 &lt;code&gt;jdoc&lt;/code&gt; 열에 저장 합니다. 이 열에 GIN 색인이 작성되면 다음과 같은 조회가 색인을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00287a4e7374c9957df5b25550d2f8b5bf2d466" translate="yes" xml:space="preserve">
          <source>We use the following terms below: The &lt;em&gt;precision&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The &lt;em&gt;scale&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.</source>
          <target state="translated">아래의 용어를 사용합니다 . &lt;code&gt;numeric&lt;/code&gt; 의 &lt;em&gt;정밀도&lt;/em&gt; 는 정수의 유효 자릿수 총계, 즉 소수점 양쪽의 자릿수입니다. &lt;code&gt;numeric&lt;/code&gt; 의 &lt;em&gt;스케일&lt;/em&gt; 은 소수점 오른쪽에있는 소수 부분의 소수 자릿수입니다. 따라서 숫자 23.5141의 정밀도는 6이고 스케일은 4입니다. 정수는 스케일이 0 인 것으로 간주 될 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c61d0c97e5f7c008c140e2ad3c2ca5a1fbcdb590" translate="yes" xml:space="preserve">
          <source>We use the non-partitioned &lt;code&gt;measurement&lt;/code&gt; table above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">위의 분할되지 않은 &lt;code&gt;measurement&lt;/code&gt; 테이블을 사용합니다 . 상속을 사용하여 분할을 구현하려면 다음 단계를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a22e103a166cab5bebeb6c6bf8216ec0f41d1ce6" translate="yes" xml:space="preserve">
          <source>We use the same &lt;code&gt;measurement&lt;/code&gt; table we used above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">위에서 사용한 것과 동일한 &lt;code&gt;measurement&lt;/code&gt; 표를 사용합니다. 상속을 사용하여 파티셔닝을 구현하려면 다음 단계를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="87bb5356e299e65f3820ac3133d7b4e088f6bde2" translate="yes" xml:space="preserve">
          <source>We use the word &lt;em&gt;item&lt;/em&gt; to refer to a composite value that is to be indexed, and the word &lt;em&gt;key&lt;/em&gt; to refer to an element value. GIN always stores and searches for keys, not item values per se.</source>
          <target state="translated">인덱싱 할 복합 값을 나타내는 단어 &lt;em&gt;항목&lt;/em&gt; 을 사용하고 요소 값을 나타내는 단어 &lt;em&gt;키&lt;/em&gt; 를 사용합니다. GIN은 항상 항목 값이 아닌 키를 저장하고 검색합니다.</target>
        </trans-unit>
        <trans-unit id="aaac10448fb5e7278bf16580755bd9621bfb54f1" translate="yes" xml:space="preserve">
          <source>We want our application to be able to say &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; and have the data be redirected into the appropriate child table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest child, we can use a very simple trigger function:</source>
          <target state="translated">우리는 어플리케이션이 &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; 을 말할 수 있기를 원 하고 데이터를 적절한 자식 테이블로 리디렉션합니다. 우리는 적절한 트리거 함수를 마스터 테이블에 첨부하여이를 정렬 할 수 있습니다. 데이터가 최신 자식에만 추가되는 경우 매우 간단한 트리거 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc05935dfdf1c41e4dbff177f8b502be331c045" translate="yes" xml:space="preserve">
          <source>We will use a PostgreSQL-specific synonym list and store it in &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt;. The file contents look like:</source>
          <target state="translated">PostgreSQL 관련 동의어 목록을 사용하여 &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt; 에 저장합니다 . 파일 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="963adbfe40be253cf091e436ca27447ef3a470bc" translate="yes" xml:space="preserve">
          <source>Wed, Weds</source>
          <target state="translated">수, 수</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="fdeddc33f6adb1db2fc6d6142f8a57019f70774f" translate="yes" xml:space="preserve">
          <source>Weights are typically used to reflect document structure, for example by marking title words differently from body words. Text search ranking functions can assign different priorities to the different weight markers.</source>
          <target state="translated">가중치는 일반적으로 제목 단어를 본문 단어와 다르게 표시하여 문서 구조를 반영하는 데 사용됩니다. 텍스트 검색 순위 기능은 다른 가중치 마커에 다른 우선 순위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="683c9370be61bfcd03e58355d7c86c6e1369d2d9" translate="yes" xml:space="preserve">
          <source>Western European</source>
          <target state="translated">서유럽</target>
        </trans-unit>
        <trans-unit id="e82bc7cf6e54b2e4257e788dff104c1e42da4e0b" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?</source>
          <target state="translated">JIT 컴파일이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9d446878c466219c122696ab7b32c54ff789d87e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Inlining</source>
          <target state="translated">JIT 컴파일이란? : 인라이닝</target>
        </trans-unit>
        <trans-unit id="ca44cc7300ef1dcac2b672637a01e3b0a0da90f7" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: JIT Accelerated Operations</source>
          <target state="translated">JIT 컴파일이란? : JIT 가속화 작업</target>
        </trans-unit>
        <trans-unit id="760d95b57cc4647ff2722b6cf5ee7f34082cc25e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Optimization</source>
          <target state="translated">JIT 컴파일이란? : 최적화</target>
        </trans-unit>
        <trans-unit id="6026d88e883e805146a8bbfee4583738ccfd77d8" translate="yes" xml:space="preserve">
          <source>What Is the &amp;ldquo;Transaction&amp;rdquo; Actually Performed in pgbench?</source>
          <target state="translated">pgbench에서 실제로 수행되는 &quot;트랜잭션&quot;은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6c8a97eccbb7e55f60d7659738855ee30c65e97d" translate="yes" xml:space="preserve">
          <source>What has really happened here is that the two unknown literals are resolved to &lt;code&gt;text&lt;/code&gt; by default, allowing the &lt;code&gt;||&lt;/code&gt; operator to be resolved as &lt;code&gt;text&lt;/code&gt; concatenation. Then the &lt;code&gt;text&lt;/code&gt; result of the operator is converted to &lt;code&gt;bpchar&lt;/code&gt; (&amp;ldquo;blank-padded char&amp;rdquo;, the internal name of the &lt;code&gt;character&lt;/code&gt; data type) to match the target column type. (Since the conversion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;bpchar&lt;/code&gt; is binary-coercible, this conversion does not insert any real function call.) Finally, the sizing function &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; is found in the system catalog and applied to the operator's result and the stored column length. This type-specific function performs the required length check and addition of padding spaces.</source>
          <target state="translated">여기서 실제로 일어난 일은 두 개의 알 수없는 리터럴이 기본적 으로 &lt;code&gt;text&lt;/code&gt; 로 해석되어 &lt;code&gt;||&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 연결 로 해석되는 연산자입니다. 그런 다음 연산자 의 &lt;code&gt;text&lt;/code&gt; 결과 는 대상 열 유형과 일치 하도록 &lt;code&gt;bpchar&lt;/code&gt; ( &lt;code&gt;character&lt;/code&gt; 데이터 유형 의 내부 이름 인 &quot;공백으로 채워진 문자&quot; )로 변환됩니다. ( &lt;code&gt;text&lt;/code&gt; 에서 &lt;code&gt;bpchar&lt;/code&gt; 로의 변환 은 이진 강제 변환 이므로이 변환은 실제 함수 호출을 삽입하지 않습니다.) 마지막으로 사이징 함수 &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; 시스템 카탈로그에 있으며 운영자 결과 및 저장된 열 길이에 적용됩니다. 이 유형별 기능은 필요한 길이 확인 및 패딩 공간 추가를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dfcede4e6134968fca6be5ab22337a4021df7d2f" translate="yes" xml:space="preserve">
          <source>What is a &amp;ldquo;system user&amp;rdquo; is determined at systemd compile time from the &lt;code&gt;SYS_UID_MAX&lt;/code&gt; setting in &lt;code&gt;/etc/login.defs&lt;/code&gt;.</source>
          <target state="translated">&quot;시스템 사용자&quot;는 시스템 컴파일 시간 에 &lt;code&gt;/etc/login.defs&lt;/code&gt; 의 &lt;code&gt;SYS_UID_MAX&lt;/code&gt; 설정에서 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3b062bdc5b358d8bc1d0ea5b87500675ecf488c" translate="yes" xml:space="preserve">
          <source>What is essentially happening here is a join between &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;producers&lt;/code&gt;, with all successfully joined &lt;code&gt;films&lt;/code&gt; rows being marked for deletion. This syntax is not standard. A more standard way to do it is:</source>
          <target state="translated">본질적으로 여기서 일어나는 것은 &lt;code&gt;films&lt;/code&gt; 와 &lt;code&gt;producers&lt;/code&gt; 사이의 조인 이며 , 성공적으로 조인 된 모든 &lt;code&gt;films&lt;/code&gt; 행은 삭제 표시됩니다. 이 구문은 표준이 아닙니다. 더 표준적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6eec3dfd99f17e2a6e53d2f854ed352bd2c2826" translate="yes" xml:space="preserve">
          <source>What locales are available on your system under what names depends on what was provided by the operating system vendor and what was installed. On most Unix systems, the command &lt;code&gt;locale -a&lt;/code&gt; will provide a list of available locales. Windows uses more verbose locale names, such as &lt;code&gt;German_Germany&lt;/code&gt; or &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt;, but the principles are the same.</source>
          <target state="translated">어떤 이름으로 시스템에서 사용 가능한 로케일은 운영 체제 공급 업체에서 제공 한 내용과 설치된 내용에 따라 다릅니다. 대부분의 Unix 시스템에서 &lt;code&gt;locale -a&lt;/code&gt; 명령 은 사용 가능한 로케일 목록을 제공합니다. Windows는 &lt;code&gt;German_Germany&lt;/code&gt; 또는 &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt; 와 같이 더 자세한 로케일 이름을 사용 하지만 원칙은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="40680439c20fb6866bd543023ba55a7dbd37c92b" translate="yes" xml:space="preserve">
          <source>What this does is to record the links created by pg_upgrade's link mode that connect files in the old and new clusters on the primary server. It then finds matching files in the standby's old cluster and creates links for them in the standby's new cluster. Files that were not linked on the primary are copied from the primary to the standby. (They are usually small.) This provides rapid standby upgrades. Unfortunately, rsync needlessly copies files associated with temporary and unlogged tables because these files don't normally exist on standby servers.</source>
          <target state="translated">이 작업은 주 서버의 기존 클러스터와 새 클러스터의 파일을 연결하는 pg_upgrade의 링크 모드로 생성 된 링크를 기록하는 것입니다. 그런 다음 대기의 이전 클러스터에서 일치하는 파일을 찾고 대기의 새 클러스터에서 해당 파일에 대한 링크를 작성합니다. 기본에서 링크되지 않은 파일은 기본에서 대기로 복사됩니다. (일반적으로 작습니다.) 빠른 대기 업그레이드를 제공합니다. 불행하게도 rsync는 불필요하게 임시 테이블과 기록되지 않은 테이블과 관련된 파일을 불필요하게 복사합니다. 이러한 파일은 일반적으로 대기 서버에 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a446c8d9e480b9f0f6cbcd76fef7e2bcda6c700b" translate="yes" xml:space="preserve">
          <source>What's more, when you load data into a table with existing foreign key constraints, each new row requires an entry in the server's list of pending trigger events (since it is the firing of a trigger that checks the row's foreign key constraint). Loading many millions of rows can cause the trigger event queue to overflow available memory, leading to intolerable swapping or even outright failure of the command. Therefore it may be &lt;em&gt;necessary&lt;/em&gt;, not just desirable, to drop and re-apply foreign keys when loading large amounts of data. If temporarily removing the constraint isn't acceptable, the only other recourse may be to split up the load operation into smaller transactions.</source>
          <target state="translated">또한 기존 외래 키 제약 조건이있는 테이블에 데이터를로드 할 때 각 새 행에는 서버의 보류중인 트리거 이벤트 목록에 항목이 필요합니다 (행의 외래 키 제약 조건을 확인하는 트리거가 실행되므로). 수백만 행을로드하면 트리거 이벤트 큐가 사용 가능한 메모리를 오버플로하여 참을 수없는 스와핑 또는 명령이 완전히 실패 할 수 있습니다. 따라서 많은 양의 데이터를로드 할 때 외래 키를 삭제하고 다시 적용하는 것이 바람직 할뿐만 아니라 &lt;em&gt;필요할&lt;/em&gt; 수도 있습니다 . 제약 조건을 일시적으로 제거 할 수없는 경우 다른 유일한 방법은로드 작업을 더 작은 트랜잭션으로 분할하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0604f8d2119324fb427a16a8668c529701bc1a2" translate="yes" xml:space="preserve">
          <source>Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding &lt;code&gt;CASCADE&lt;/code&gt;:</source>
          <target state="translated">열에 있던 데이터가 사라집니다. 열과 관련된 테이블 제약 조건도 삭제됩니다. 그러나 열이 다른 테이블의 외래 키 제약 조건에 의해 참조되는 경우 PostgreSQL은 해당 제약 조건을 자동으로 삭제하지 않습니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 추가하여 열에 종속 된 모든 항목을 삭제하도록 승인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="a60fe559ad2643627bd47ea3eceb6f63037101eb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt; is set, this parameter also determines the amount of time to wait before a log message is issued about the lock wait. If you are trying to investigate locking delays you might want to set a shorter than normal &lt;code&gt;deadlock_timeout&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits가&lt;/a&gt; 설정 로그 메시지가 잠금 대기에 대해 발행되기 전에,이 매개 변수는 또한 대기 시간을 결정한다. 잠금 지연을 조사하려는 경우 일반 &lt;code&gt;deadlock_timeout&lt;/code&gt; 보다 짧게 설정하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48421d6240bf9ea87a63b5a2373cb0ad9cf5cd58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--include-foreign-data&lt;/code&gt; is specified, pg_dump does not check that the foreign table is writable. Therefore, there is no guarantee that the results of a foreign table dump can be successfully restored.</source>
          <target state="translated">때 &lt;code&gt;--include-foreign-data&lt;/code&gt; 지정, pg_dump를 외국 테이블이 쓰기 가능한지 확인하지 않습니다. 따라서 외부 테이블 덤프의 결과가 성공적으로 복원 될 수 있다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="57e37b6a94a28e9acbd6287be1d60c38f8541fd8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;--source-server&lt;/code&gt; 옵션이 사용된다 pg_rewind libpq로 지원되는 환경 변수를 사용한다 (참조 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;섹션을 33.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2797c2b01f0d49dcbbe6a48419d9e0d238c086dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;--source-server&lt;/code&gt; 옵션이 사용된다 pg_rewind libpq로 지원되는 환경 변수를 사용한다 (참조 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;섹션을 33.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1854281aa73e4f5b1f721e95b9f05123b0ade134" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-n&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected schema(s) might depend upon. Therefore, there is no guarantee that the results of a specific-schema dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">때 &lt;code&gt;-n&lt;/code&gt; 가 지정되면 pg_dump를 선택한 스키마 (들)에 의존 수도 다른 데이터베이스 개체를 덤프하는 것이 아니다. 따라서 특정 스키마 덤프의 결과가 자체적으로 깨끗한 데이터베이스로 성공적으로 복원 될 수 있다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5fef81c501efe3e088f4b73c9a697af2561cb6dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that the results of a specific-table dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">때 &lt;code&gt;-t&lt;/code&gt; 가 지정되면 pg_dump를 선택한 테이블 (들)에 의존 수도 다른 데이터베이스 개체를 덤프하는 것이 아니다. 따라서 특정 테이블 덤프 결과를 자체적으로 깨끗한 데이터베이스로 성공적으로 복원 할 수 있다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c86589858bd9989813c8435013ddbc1a41c69f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_restore makes no attempt to restore any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that a specific-table restore into a clean database will succeed.</source>
          <target state="translated">때 &lt;code&gt;-t&lt;/code&gt; 가 지정되어, pg_restore에 선택한 테이블 (들)에 의존 수도 다른 데이터베이스 오브젝트를 복원하는 것이 아니다. 따라서 클린 데이터베이스로의 특정 테이블 복원이 성공할 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6dd3feb588f68391e70d37037327ad64b7721fd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALTER&lt;/code&gt; command is executed, &lt;code&gt;setattr&lt;/code&gt; will be checked on the object being modified for each object types, except for subsidiary objects such as the indexes or triggers of a table, where permissions are instead checked on the parent object. In some cases, additional permissions are required:</source>
          <target state="translated">경우 &lt;code&gt;ALTER&lt;/code&gt; 의 명령이 실행되고, &lt;code&gt;setattr&lt;/code&gt; 객체가 각 객체 종류에 대해 수정되는에 체크한다 자회사 제외하면 인덱스 또는 권한이 아니라 부모 오브젝트에 체크 테이블의 트리거와 같은 개체. 경우에 따라 추가 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="95ea06756271ccb08739b45bacb4e5cf14e003e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE INDEX&lt;/code&gt; is invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If the &lt;code&gt;ONLY&lt;/code&gt; option is specified, no recursion is done, and the index is marked invalid. (&lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; marks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future using &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; will automatically have a matching index, regardless of whether &lt;code&gt;ONLY&lt;/code&gt; is specified.</source>
          <target state="translated">파티션 된 테이블에서 &lt;code&gt;CREATE INDEX&lt;/code&gt; 가 호출 될 때 기본 동작은 모든 파티션으로 재귀하여 모든 인덱스가 일치하는지 확인하는 것입니다. 각 파티션은 먼저 동등한 색인이 이미 존재하는지 판별하기 위해 점검되며, 존재하는 경우 해당 색인은 작성중인 색인에 파티션 색인으로 첨부되어 상위 색인이됩니다. 일치하는 색인이 없으면 새 색인이 작성되어 자동으로 첨부됩니다. 각 파티션의 새 인덱스 이름은 명령에 인덱스 이름이 지정되지 않은 것처럼 결정됩니다. 는 IF &lt;code&gt;ONLY&lt;/code&gt; 옵션을 지정, 더 재귀이 완료되지 않고, 인덱스가 유효하지 않은 것으로 표시됩니다. ( &lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; 모든 파티션이 일치하는 인덱스를 획득하면 인덱스가 유효한 것으로 표시됩니다.) 그러나 &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; 사용하여 나중에 생성되는 파티션은 &lt;code&gt;ONLY&lt;/code&gt; 의 지정 여부에 관계없이 자동으로 일치하는 인덱스를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0c15e2e86d36f47a57239a8f802301f2d222dbb6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; is used to replace an existing function, the ownership and permissions of the function do not change. All other function properties are assigned the values specified or implied in the command. You must own the function to replace it (this includes being a member of the owning role).</source>
          <target state="translated">때 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 는 기존의 기능을 대체하는 데 사용됩니다, 함수의 소유권과 권한은 변경되지 않습니다. 다른 모든 기능 속성에는 명령에 지정되거나 암시 된 값이 할당됩니다. 이를 대체 할 기능을 소유해야합니다 (소유 역할의 구성원이 포함됨).</target>
        </trans-unit>
        <trans-unit id="db55d63efcb8b5298291fde068a29837b503dfcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; is used to replace an existing procedure, the ownership and permissions of the procedure do not change. All other procedure properties are assigned the values specified or implied in the command. You must own the procedure to replace it (this includes being a member of the owning role).</source>
          <target state="translated">때 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 기존 절차를 대체하기 위해 사용되는 절차의 소유권과 권한은 변경되지 않습니다. 다른 모든 프로 시저 속성에는 명령에 지정되거나 암시 된 값이 할당됩니다. 교체 절차를 소유해야합니다 (소유 역할의 구성원이 포함됨).</target>
        </trans-unit>
        <trans-unit id="11b7e02139c0fd56fa0d0c0d7e02cacf1863b7dd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; is used on an existing view, only the view's defining SELECT rule is changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).</source>
          <target state="translated">때 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 가 기존 뷰에서 사용되는,보기 만의 정의 SELECT 규칙이 변경됩니다. 소유권, 권한 및 비 SELECT 규칙을 포함한 다른보기 속성은 변경되지 않습니다. 뷰를 바꾸려면 뷰를 소유해야합니다 (소유 역할의 구성원이 포함됨).</target>
        </trans-unit>
        <trans-unit id="b2b68d33a4076adb362da4bb710ac3317fb09cf8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DROP&lt;/code&gt; command is executed, &lt;code&gt;drop&lt;/code&gt; will be checked on the object being removed. Permissions will be also checked for objects dropped indirectly via &lt;code&gt;CASCADE&lt;/code&gt;. Deletion of objects contained within a particular schema (tables, views, sequences and procedures) additionally requires &lt;code&gt;remove_name&lt;/code&gt; on the schema.</source>
          <target state="translated">경우 &lt;code&gt;DROP&lt;/code&gt; 의 명령이 실행되고, &lt;code&gt;drop&lt;/code&gt; 객체가 제거되기에 체크한다. &lt;code&gt;CASCADE&lt;/code&gt; 를 통해 간접적으로 삭제 된 개체에 대한 권한도 확인됩니다 . 특정 스키마 (테이블, 뷰, 시퀀스 및 프로 시저)에 포함 된 객체를 삭제하려면 스키마에서 &lt;code&gt;remove_name&lt;/code&gt; 이 추가로 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f47c9d6dc4a8942d1dd522d4978fe59346f8ad48" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GROUP BY&lt;/code&gt; is present, or any aggregate functions are present, it is not valid for the &lt;code&gt;SELECT&lt;/code&gt; list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.</source>
          <target state="translated">때 &lt;code&gt;GROUP BY&lt;/code&gt; 가 존재, 또는 집계 함수가 존재하는, 그것은 유효하지 않습니다 &lt;code&gt;SELECT&lt;/code&gt; 그렇지 않으면 더있을 것이기 때문에 그룹이 해제 된 열이 그룹화 컬럼에 기능적으로 의존하는 경우 목록 표현이 집계 함수에서 제외 그룹화되지 않은 열을 참조하거나 그룹화되지 않은 열에 대해 하나 이상의 가능한 값을 반환합니다. 그룹화 된 열 (또는 그 서브 세트)이 그룹화되지 않은 열을 포함하는 테이블의 기본 키인 경우 기능 종속성이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a61a8feeb668ae119fbcd691b6fc8464f954d0c9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NOTIFY&lt;/code&gt; is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the &lt;code&gt;NOTIFY&lt;/code&gt; in a statement trigger that is triggered by table updates. In this way, notification happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it.</source>
          <target state="translated">때 &lt;code&gt;NOTIFY&lt;/code&gt; 특정 테이블에 대한 변경 사항의 발생을 신호하는 데 사용되는 유용한 프로그래밍 기법은 넣어하는 것입니다 &lt;code&gt;NOTIFY&lt;/code&gt; 테이블 업데이트로 트리거 명령문 트리거. 이러한 방식으로, 테이블이 변경되면 알림이 자동으로 발생하며 응용 프로그램 프로그래머는 실수로이를 잊을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="693b980fbbb477839ff0fa0e6f6f64c259b4b463" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">때 &lt;code&gt;RESTART IDENTITY&lt;/code&gt; 이 지정되면, 묵시적 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 의 작업은 트랜잭션 완료; 즉, 주변 트랜잭션이 커밋되지 않으면 롤백됩니다. 트랜잭션이 롤백되기 전에 다시 시작된 시퀀스에서 추가 시퀀스 작업이 수행되면 시퀀스에 대한 이러한 작업의 효과는 롤백되지만 &lt;code&gt;currval()&lt;/code&gt; 영향을주지 않습니다 . 즉, 트랜잭션 후 &lt;code&gt;currval()&lt;/code&gt; 은 시퀀스 자체가 더 이상 일치하지 않더라도 실패한 트랜잭션 내에서 얻은 마지막 시퀀스 값을 계속 반영합니다. 이는 트랜잭션 실패 후 &lt;code&gt;currval()&lt;/code&gt; 의 일반적인 동작과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="96d946d891d853517e02080ffe41ee5e79e55c40" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. This is unlike the normal behavior of &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt;. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">때 &lt;code&gt;RESTART IDENTITY&lt;/code&gt; 이 지정되면, 묵시적 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 의 작업은 트랜잭션 완료; 즉, 주변 트랜잭션이 커밋되지 않으면 롤백됩니다. 이것은 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 의 정상적인 동작과 다릅니다 . 트랜잭션이 롤백되기 전에 다시 시작된 시퀀스에서 추가 시퀀스 작업이 수행되면 시퀀스에 대한 이러한 작업의 영향은 롤백되지만 &lt;code&gt;currval()&lt;/code&gt; 에 대한 영향은 아닙니다 . 즉, 트랜잭션 &lt;code&gt;currval()&lt;/code&gt; 이후시퀀스 자체가 더 이상 일치하지 않더라도 실패한 트랜잭션 내에서 얻은 마지막 시퀀스 값을 계속 반영합니다. 이는 트랜잭션 실패 후 &lt;code&gt;currval()&lt;/code&gt; 의 일반적인 동작과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="1dd38b054f6c38892cf4b53376368a92afaa9614" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; changes the mode of a constraint from &lt;code&gt;DEFERRED&lt;/code&gt; to &lt;code&gt;IMMEDIATE&lt;/code&gt;, the new mode takes effect retroactively: any outstanding data modifications that would have been checked at the end of the transaction are instead checked during the execution of the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. If any such constraint is violated, the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; fails (and does not change the constraint mode). Thus, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; can be used to force checking of constraints to occur at a specific point in a transaction.</source>
          <target state="translated">때 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 에서 제약 조건의 모드를 변경 &lt;code&gt;DEFERRED&lt;/code&gt; 로 &lt;code&gt;IMMEDIATE&lt;/code&gt; , 새로운 모드는 소급 적용됩니다 : 트랜잭션의 끝에서 확인 된 것이다 미결제 데이터 수정이 대신 실행하는 동안 체크 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 명령. 이러한 제한 조건을 위반하면 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 가 실패하고 제한 조건 모드를 변경하지 않습니다. 따라서 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 를 사용하여 트랜잭션의 특정 지점에서 제한 조건 확인을 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b169cb5b7cb17bff71441e629815508752132d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VALUES&lt;/code&gt; is used in &lt;code&gt;INSERT&lt;/code&gt;, the values are all automatically coerced to the data type of the corresponding destination column. When it's used in other contexts, it might be necessary to specify the correct data type. If the entries are all quoted literal constants, coercing the first is sufficient to determine the assumed type for all:</source>
          <target state="translated">때는 &lt;code&gt;VALUES&lt;/code&gt; 사용된다 &lt;code&gt;INSERT&lt;/code&gt; , 값이 모두 자동으로 해당 대상 칼럼의 데이터 형식으로 강제된다. 다른 컨텍스트에서 사용될 경우 올바른 데이터 유형을 지정해야 할 수도 있습니다. 항목이 모두 인용 리터럴 상수 인 경우 첫 번째 항목을 강제 변환하면 모든 가정 유형을 결정하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="45ae9ff8fa95f77c4ea16390adcefafbd4f890d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;ANALYZE&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">경우 &lt;code&gt;VERBOSE&lt;/code&gt; 가 지정되면 &lt;code&gt;ANALYZE&lt;/code&gt; 을 방출 현재 처리되고있는 테이블을 표시하기 위해 메시지를 진행. 테이블에 대한 다양한 통계도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="14f1458fcf796362f90bd6b53ff757eaee1e2939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;VACUUM&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">경우 &lt;code&gt;VERBOSE&lt;/code&gt; 가 지정되어, &lt;code&gt;VACUUM&lt;/code&gt; 을 방출들은 현재 처리되고있는 테이블을 표시하기 위해 메시지를 진행. 테이블에 대한 다양한 통계도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f54823d23e5df73c9472414a7a83e6ba082b1ce2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, or &lt;code&gt;\ev&lt;/code&gt; is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user's editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples:</source>
          <target state="translated">때 &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\ef&lt;/code&gt; , 또는 &lt;code&gt;\ev&lt;/code&gt; 행 번호의 인수와 함께 사용되며,이 변수의 지정은 사용 된 명령 줄 인수는 사용자의 편집기로 시작하는 행 번호를 전달합니다. Emacs 또는 vi와 같은 편집기의 경우 이는 더하기 부호입니다. 옵션 이름과 행 번호 사이에 공백이 필요한 경우 변수 값에 후행 공백을 포함하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="880bf87755564e46a3f310f5734ab8ac6764465b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;archive_mode&lt;/code&gt; is enabled, completed WAL segments are sent to archive storage by setting &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. In addition to &lt;code&gt;off&lt;/code&gt;, to disable, there are two modes: &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;always&lt;/code&gt;. During normal operation, there is no difference between the two modes, but when set to &lt;code&gt;always&lt;/code&gt; the WAL archiver is enabled also during archive recovery or standby mode. In &lt;code&gt;always&lt;/code&gt; mode, all files restored from the archive or streamed with streaming replication will be archived (again). See &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;Section 26.2.9&lt;/a&gt; for details.</source>
          <target state="translated">때 &lt;code&gt;archive_mode&lt;/code&gt; 가 활성화되어, 완성 된 WAL 세그먼트 설정하여 아카이브 스토리지로 전송됩니다 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command를&lt;/a&gt; . &lt;code&gt;off&lt;/code&gt; 외에도 비활성화하기 위해 &lt;code&gt;on&lt;/code&gt; 과 &lt;code&gt;always&lt;/code&gt; 의 두 가지 모드가 있습니다 . 정상 작동 중에는 두 모드간에 차이가 없지만 &lt;code&gt;always&lt;/code&gt; 설정 하면 WAL 아카이버가 아카이브 복구 또는 대기 모드 중에도 활성화됩니다. &lt;code&gt;always&lt;/code&gt; 모드 에서는 아카이브에서 복원되거나 스트리밍 복제로 스트리밍 된 모든 파일이 (다시) 아카이브됩니다. 자세한 내용 &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;은 26.2.9 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46cdaf5a9c68bb7dda3e95a7d23c6fce30bcf59a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;commit_delay&lt;/code&gt; is set to zero (the default), it is still possible for a form of group commit to occur, but each group will consist only of sessions that reach the point where they need to flush their commit records during the window in which the previous flush operation (if any) is occurring. At higher client counts a &amp;ldquo;gangway effect&amp;rdquo; tends to occur, so that the effects of group commit become significant even when &lt;code&gt;commit_delay&lt;/code&gt; is zero, and thus explicitly setting &lt;code&gt;commit_delay&lt;/code&gt; tends to help less. Setting &lt;code&gt;commit_delay&lt;/code&gt; can only help when (1) there are some concurrently committing transactions, and (2) throughput is limited to some degree by commit rate; but with high rotational latency this setting can be effective in increasing transaction throughput with as few as two clients (that is, a single committing client with one sibling transaction).</source>
          <target state="translated">&lt;code&gt;commit_delay&lt;/code&gt; 가 0 (기본값)으로 설정되어 있으면 그룹 커밋 형식이 여전히 발생할 수 있지만 각 그룹은 해당 창에서 커밋 레코드를 플러시해야하는 시점에 도달하는 세션으로 만 구성됩니다. 이전 플러시 작업 (있는 경우)이 발생합니다. 클라이언트 수가 많을수록 &quot;갱 웨이 효과&quot;가 발생하는 경향이 있으므로 &lt;code&gt;commit_delay&lt;/code&gt; 가 0 인 경우에도 그룹 커밋의 효과가 현저 해 지므로 &lt;code&gt;commit_delay&lt;/code&gt; 를 명시 적으로 설정 하면 덜 도움이됩니다. &lt;code&gt;commit_delay&lt;/code&gt; 설정(1) 일부 동시 커밋 트랜잭션이 있고 (2) 처리량이 커밋 비율에 따라 어느 정도 제한되는 경우에만 도움이됩니다. 그러나 높은 회전 대기 시간으로이 설정은 클라이언트 수가 2 개 (즉, 하나의 형제 트랜잭션이있는 단일 커밋 클라이언트)로 트랜잭션 처리량을 증가시키는 데 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="639e6544c619e9aa79e7a25d85adc789836438b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;default_tablespace&lt;/code&gt; is set to anything but an empty string, it supplies an implicit &lt;code&gt;TABLESPACE&lt;/code&gt; clause for &lt;code&gt;CREATE TABLE&lt;/code&gt; and &lt;code&gt;CREATE INDEX&lt;/code&gt; commands that do not have an explicit one.</source>
          <target state="translated">&lt;code&gt;default_tablespace&lt;/code&gt; 가 빈 문자열 이외의 값으로 설정 되면 명시 적 명령이없는 &lt;code&gt;CREATE TABLE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령에 대한 암시 적 &lt;code&gt;TABLESPACE&lt;/code&gt; 절을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="26b9fcc2ea9102afd846d23d5a3d7acf06ea6fcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extractQuery&lt;/code&gt; returns a null key in &lt;code&gt;queryKeys[]&lt;/code&gt;, the corresponding &lt;code&gt;check[]&lt;/code&gt; element is true if the indexed item contains a null key; that is, the semantics of &lt;code&gt;check[]&lt;/code&gt; are like &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt;. The &lt;code&gt;consistent&lt;/code&gt; function can examine the corresponding &lt;code&gt;nullFlags[]&lt;/code&gt; element if it needs to tell the difference between a regular value match and a null match.</source>
          <target state="translated">경우 &lt;code&gt;extractQuery&lt;/code&gt; 이 있는 널 키 반환 &lt;code&gt;queryKeys[]&lt;/code&gt; , 해당 &lt;code&gt;check[]&lt;/code&gt; 인덱싱 항목 널 키 요소를 포함하는 경우 사실이다; 즉, &lt;code&gt;check[]&lt;/code&gt; 의 의미는 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 과 같습니다 . &lt;code&gt;consistent&lt;/code&gt; 함수는 대응하는 검사 할 &lt;code&gt;nullFlags[]&lt;/code&gt; 는 일정한 값이 일치하고 널 매치를 구별 할 필요가있는 경우 소자.</target>
        </trans-unit>
        <trans-unit id="e521d3acb4576333ab5bee010106dc1a1c2bc018" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">&lt;code&gt;geqo_threshold&lt;/code&gt; 가 초과 되면 &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;59 장에&lt;/a&gt; 설명 된대로 휴리스틱에 의해 고려되는 결합 시퀀스가 ​​결정됩니다 . 그렇지 않으면 프로세스는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5dc55d7e2d48050cd0f6633337d76448e1d4e69c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">&lt;code&gt;geqo_threshold&lt;/code&gt; 를 초과 하면 고려되는 결합 시퀀스는 &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;59 장에&lt;/a&gt; 설명 된대로 휴리스틱 스에 의해 결정됩니다 . 그렇지 않으면 프로세스는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d28ef38bf9e5530ece862031c842201d36ddd349" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the directory in which log files will be created. It can be specified as an absolute path, or relative to the cluster data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;log&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수는 로그 파일이 생성 될 디렉토리를 결정합니다. 절대 경로로 지정하거나 클러스터 데이터 디렉토리를 기준으로 지정할 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;log&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3acb8f6d64e7dee8bb588e16430447375cec4a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum amount of time to use an individual log file, after which a new log file will be created. If this value is specified without units, it is taken as minutes. The default is 24 hours. Set to zero to disable time-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">경우 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 파라미터는 새로운 로그 파일이 생성 될 후에 개별 로그 파일을 사용할 수있는 최대 시간을 결정한다. 이 값을 단위없이 지정하면 분으로 간주됩니다. 기본값은 24 시간입니다. 새 로그 파일의 시간 기반 작성을 사용하지 않으려면 0으로 설정하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ba6806c5a61bd0e7df256b20d72936b6dfff344" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum size of an individual log file. After this amount of data has been emitted into a log file, a new log file will be created. If this value is specified without units, it is taken as kilobytes. The default is 10 megabytes. Set to zero to disable size-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">경우 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수는 개별 로그 파일의 최대 사이즈를 결정한다. 이 양의 데이터가 로그 파일로 방출 된 후 새 로그 파일이 작성됩니다. 이 값을 단위없이 지정하면 킬로바이트로 간주됩니다. 기본값은 10MB입니다. 새 로그 파일의 크기 기반 작성을 사용하지 않으려면 0으로 설정하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33d04df6ccc65336486b417a686759bd20169c58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수는 생성 된 로그 파일의 파일 이름을 설정합니다. 값은 &lt;code&gt;strftime&lt;/code&gt; 패턴 으로 처리 되므로 &lt;code&gt;%&lt;/code&gt; -escapes를 사용하여 시변 파일 이름을 지정할 수 있습니다. 표준 시간대에 따른 &lt;code&gt;%&lt;/code&gt; 이스케이프가있는 경우 계산은 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone에&lt;/a&gt; 지정된 영역에서 수행됩니다 . 지원되는 &lt;code&gt;%&lt;/code&gt; 이스케이프는 Open Group의 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; 사양에 나열된 것과 유사합니다 . 시스템의 &lt;code&gt;strftime&lt;/code&gt; 은 직접 사용되지 않으므로 플랫폼 별 (비표준) 확장은 작동하지 않습니다. 기본값은 &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de9428c551b8b57c64cfa71598ced7921a3ab10e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수는 생성 된 로그 파일의 파일 이름을 설정합니다. 값은 &lt;code&gt;strftime&lt;/code&gt; 패턴 으로 처리 되므로 &lt;code&gt;%&lt;/code&gt; -escapes를 사용하여 시간에 따라 달라지는 파일 이름을 지정할 수 있습니다. (모든 시간대에 의존이있는 경우주의 &lt;code&gt;%&lt;/code&gt; 의 -escapes를 계산에 의해 지정된 영역에서 이루어집니다 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; .) 지원 &lt;code&gt;%&lt;/code&gt; 의 -escapes 열기 그룹의 나열과 유사 &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;은 strftime의&lt;/a&gt; 사양입니다. 시스템의 &lt;code&gt;strftime&lt;/code&gt; 은 직접 사용되지 않으므로 플랫폼 별 (비표준) 확장이 작동하지 않습니다. 기본값은 &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="912a8bc2db1f94954749b8b7569bc346c69e11ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter will cause PostgreSQL to truncate (overwrite), rather than append to, any existing log file of the same name. However, truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation. When off, pre-existing files will be appended to in all cases. For example, using this setting in combination with a &lt;code&gt;log_filename&lt;/code&gt; like &lt;code&gt;postgresql-%H.log&lt;/code&gt; would result in generating twenty-four hourly log files and then cyclically overwriting them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">때 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수 잘라 내기 (덮어 쓰기)에 PostgreSQL의 원인이됩니다보다는에 추가, 같은 이름의 기존 로그 파일. 그러나 서버 시작 또는 크기 기반 회전이 아닌 시간 기반 회전으로 인해 새 파일을 열 때만 잘림이 발생합니다. 해제하면 기존 파일이 모든 경우에 추가됩니다. 예를 들어, &lt;code&gt;postgresql-%H.log&lt;/code&gt; 와 같은 &lt;code&gt;log_filename&lt;/code&gt; 과 함께이 설정을 사용하면 24 시간마다 로그 파일을 생성 한 다음 주기적으로 덮어 씁니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac2a30741ea2b8dcb498e785772cf2a514f01258" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;on&lt;/code&gt; (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL command. When &lt;code&gt;off&lt;/code&gt; or unset, SQL commands are not committed until you explicitly issue &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;. The autocommit-off mode works by issuing an implicit &lt;code&gt;BEGIN&lt;/code&gt; for you, just before any command that is not already in a transaction block and is not itself a &lt;code&gt;BEGIN&lt;/code&gt; or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as &lt;code&gt;VACUUM&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;on&lt;/code&gt; (기본값), 각 SQL 명령은 자동으로 성공적으로 완료되면 최선을 다하고 있습니다. 이 모드에서 커미트를 연기하려면 &lt;code&gt;BEGIN&lt;/code&gt; 또는 &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL 명령을 입력해야합니다 . &lt;code&gt;off&lt;/code&gt; 하거나 설정 해제 하면 &lt;code&gt;COMMIT&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 를 명시 적으로 발행 할 때까지 SQL 명령이 커미트되지 않습니다 . 자동 커미트 오프 모드는 아직 트랜잭션 블록에없고 &lt;code&gt;BEGIN&lt;/code&gt; 또는 다른 트랜잭션 제어 명령이 아닌 명령이나 트랜잭션 블록 내에서 실행할 수없는 명령 직전에 암시 적 &lt;code&gt;BEGIN&lt;/code&gt; 을 발행하여 작동 합니다. (예 : &lt;code&gt;VACUUM&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c85a8f652ce31ff087a3b7cc628918aedc0afe36" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pg_stat_statements&lt;/code&gt; is loaded, it tracks statistics across all databases of the server. To access and manipulate these statistics, the module provides a view, &lt;code&gt;pg_stat_statements&lt;/code&gt;, and the utility functions &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; and &lt;code&gt;pg_stat_statements&lt;/code&gt;. These are not available globally but can be enabled for a specific database with &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;pg_stat_statements&lt;/code&gt; 가 로드, 서버의 모든 데이터베이스에서 통계를 추적합니다. 이 통계에 액세스하고 조작하기 위해 모듈은 &lt;code&gt;pg_stat_statements&lt;/code&gt; 뷰 와 &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; 및 &lt;code&gt;pg_stat_statements&lt;/code&gt; 유틸리티 기능을 제공합니다 . 전역 적으로 사용할 수는 없지만 &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt; 를 사용하여 특정 데이터베이스에 대해 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c48693eca5bd4dca7f7f71afdfbb3d41be3ea38" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;postgres_fdw&lt;/code&gt; encounters a join between foreign tables on the same foreign server, it sends the entire join to the foreign server, unless for some reason it believes that it will be more efficient to fetch rows from each table individually, or unless the table references involved are subject to different user mappings. While sending the &lt;code&gt;JOIN&lt;/code&gt; clauses, it takes the same precautions as mentioned above for the &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">때 &lt;code&gt;postgres_fdw&lt;/code&gt; 만남은 같은 외국 서버에서 외부 테이블 간의 조인 몇 가지 이유는 테이블 참조가 관여하지 않는 한 개별적으로 각 테이블에서 행을 인출하는 것이 더 효율적, 또는 것이라고 생각하지 않는 한, 그것은 전체가 외국 서버에 가입 전송 다른 사용자 매핑이 적용됩니다. &lt;code&gt;JOIN&lt;/code&gt; 절을 전송하는 동안 &lt;code&gt;WHERE&lt;/code&gt; 절에 대해 위에서 언급 한 것과 동일한 예방 조치가 취해집니다 .</target>
        </trans-unit>
        <trans-unit id="8c8497bbbc5c881081d121fdf01a588723979b05" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;program&lt;/code&gt; is specified, &lt;code&gt;command&lt;/code&gt; is executed by psql and the data passed from or to &lt;code&gt;command&lt;/code&gt; is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">때 &lt;code&gt;program&lt;/code&gt; 지정, &lt;code&gt;command&lt;/code&gt; psql의에 의해 실행되고, 또는에 전달 된 데이터 &lt;code&gt;command&lt;/code&gt; 서버와 클라이언트 사이에 라우팅됩니다. 다시 실행 권한은 서버가 아닌 로컬 사용자의 권한이며 SQL 슈퍼 유저 권한은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6840df87dd751c0fab0c6f46649358f6b34c5849" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;slot_name&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, there will be no replication slot associated with the subscription. This can be used if the replication slot will be created later manually. Such subscriptions must also have both &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;create_slot&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;slot_name&lt;/code&gt; 이 &lt;code&gt;NONE&lt;/code&gt; 으로 설정 되면 구독과 연관된 복제 슬롯이 없습니다. 나중에 복제 슬롯을 수동으로 생성 할 경우에 사용할 수 있습니다. 이러한 구독은 &lt;code&gt;enabled&lt;/code&gt; 및 &lt;code&gt;create_slot&lt;/code&gt; 을 모두 &lt;code&gt;false&lt;/code&gt; 로 설정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d3788a4cfcb030ae27460c4ddd94f0d92885c664" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;temp_tablespaces&lt;/code&gt; is set interactively, specifying a nonexistent tablespace is an error, as is specifying a tablespace for which the user does not have &lt;code&gt;CREATE&lt;/code&gt; privilege. However, when using a previously set value, nonexistent tablespaces are ignored, as are tablespaces for which the user lacks &lt;code&gt;CREATE&lt;/code&gt; privilege. In particular, this rule applies when using a value set in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;temp_tablespaces&lt;/code&gt; 가 대화 형으로 설정되어, 존재하지 않는 테이블 스페이스를 지정하면 같은 사용자가 없습니다있는 테이블 스페이스 지정되고, 오류가 &lt;code&gt;CREATE&lt;/code&gt; 권한을. 그러나 이전에 설정 한 값을 사용하는 경우 사용자에게 &lt;code&gt;CREATE&lt;/code&gt; 권한 이없는 테이블 스페이스와 같이 존재하지 않는 테이블 스페이스는 무시 됩니다. 특히이 규칙은 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정된 값을 사용할 때 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c068d98cbad8e288e90e4c1dd972e7c59abbaa3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;tgconstraint&lt;/code&gt; is nonzero, &lt;code&gt;tgconstrrelid&lt;/code&gt;, &lt;code&gt;tgconstrindid&lt;/code&gt;, &lt;code&gt;tgdeferrable&lt;/code&gt;, and &lt;code&gt;tginitdeferred&lt;/code&gt; are largely redundant with the referenced &lt;code&gt;pg_constraint&lt;/code&gt; entry. However, it is possible for a non-deferrable trigger to be associated with a deferrable constraint: foreign key constraints can have some deferrable and some non-deferrable triggers.</source>
          <target state="translated">때 &lt;code&gt;tgconstraint&lt;/code&gt; 이 제로이며, &lt;code&gt;tgconstrrelid&lt;/code&gt; , &lt;code&gt;tgconstrindid&lt;/code&gt; , &lt;code&gt;tgdeferrable&lt;/code&gt; 및 &lt;code&gt;tginitdeferred&lt;/code&gt; 크게 참조와 중복되는 &lt;code&gt;pg_constraint&lt;/code&gt; 의 항목. 그러나 지연 불가능한 트리거가 지연 가능한 제한 조건과 연관 될 수 있습니다. 외래 키 제한 조건은 지연 가능하고 지연 불가능한 트리거를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19d575b88117ece85c7a87c6ea7ead5a6532b19a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trust&lt;/code&gt; authentication is specified, PostgreSQL assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the &lt;code&gt;database&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</source>
          <target state="translated">때 &lt;code&gt;trust&lt;/code&gt; 인증이 지정되어, PostgreSQL는 서버에 연결할 수 누군가가 (심지어 수퍼 유저 이름)를 지정 어떤 데이터베이스 사용자 이름으로 데이터베이스에 액세스 할 수있는 권한을 가정합니다. 물론 &lt;code&gt;database&lt;/code&gt; 및 &lt;code&gt;user&lt;/code&gt; 열의 제한 사항이 여전히 적용됩니다. 이 방법은 서버 연결에 적절한 운영 체제 수준의 보호가있는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="966280f7c40171987c3cbc983291b38e3a71017e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_remote_estimate&lt;/code&gt; is true, &lt;code&gt;postgres_fdw&lt;/code&gt; obtains row count and cost estimates from the remote server and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. When &lt;code&gt;use_remote_estimate&lt;/code&gt; is false, &lt;code&gt;postgres_fdw&lt;/code&gt; performs local row count and cost estimation and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. This local estimation is unlikely to be very accurate unless local copies of the remote table's statistics are available. Running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the foreign table is the way to update the local statistics; this will perform a scan of the remote table and then calculate and store statistics just as though the table were local. Keeping local statistics can be a useful way to reduce per-query planning overhead for a remote table &amp;mdash; but if the remote table is frequently updated, the local statistics will soon be obsolete.</source>
          <target state="translated">경우 &lt;code&gt;use_remote_estimate&lt;/code&gt; 는 사실이다 &lt;code&gt;postgres_fdw&lt;/code&gt; 다음 얻 행수 및 원격 서버로부터 예상 비용 및 추가 &lt;code&gt;fdw_startup_cost&lt;/code&gt; 및 &lt;code&gt;fdw_tuple_cost&lt;/code&gt; 을 비용 추정치. 경우 &lt;code&gt;use_remote_estimate&lt;/code&gt; 이 거짓, &lt;code&gt;postgres_fdw&lt;/code&gt; 된 후 수행 로컬 로우 카운트 및 비용 추정 및 추가 &lt;code&gt;fdw_startup_cost&lt;/code&gt; 및 &lt;code&gt;fdw_tuple_cost&lt;/code&gt; 비용 추정치. 리모트 테이블 통계의 로컬 사본이 사용 가능하지 않으면이 로컬 추정이 매우 정확하지 않을 수 있습니다. &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 실행외부 테이블에는 로컬 통계를 업데이트하는 방법이 있습니다. 이것은 원격 테이블의 스캔을 수행 한 다음 테이블이 로컬 인 것처럼 통계를 계산하고 저장합니다. 로컬 통계를 유지하면 원격 테이블에 대한 쿼리 별 계획 오버 헤드를 줄일 수있는 유용한 방법이 될 수 있습니다. 그러나 원격 테이블이 자주 업데이트되는 경우 로컬 통계는 곧 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="fb7e09297d71df57df7c85aea76275071123b814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and a transaction commits after creating or rewriting a permanent relation, this setting determines how to persist the new data. If the data is smaller than this setting, write it to the WAL log; otherwise, use an fsync of affected files. Depending on the properties of your storage, raising or lowering this value might help if such commits are slowing concurrent transactions. If this value is specified without units, it is taken as kilobytes. The default is two megabytes (&lt;code&gt;2MB&lt;/code&gt;).</source>
          <target state="translated">때 &lt;code&gt;wal_level&lt;/code&gt; 가 있다 &lt;code&gt;minimal&lt;/code&gt; 하고 만들거나 영구적 인 관계를 재 작성 후 트랜잭션 커밋이 설정은 새로운 데이터를 유지하는 방법을 결정합니다. 데이터가이 설정보다 작 으면 WAL 로그에 기록하십시오. 그렇지 않으면 영향을받는 파일의 fsync를 사용하십시오. 스토리지 속성에 따라 이러한 커밋으로 인해 동시 트랜잭션이 느려지는 경우이 값을 높이거나 낮추면 도움이 될 수 있습니다. 이 값이 단위없이 지정되면 킬로바이트로 간주됩니다. 기본값은 &lt;code&gt;2MB&lt;/code&gt; ( 2MB )입니다.</target>
        </trans-unit>
        <trans-unit id="f04447293cfe5a43fce5bd6f976cc350e753a232" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; some SQL commands are optimized to avoid WAL logging, as described in &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;. If archiving or streaming replication were turned on during execution of one of these statements, WAL would not contain enough information for archive recovery. (Crash recovery is unaffected.) For this reason, &lt;code&gt;wal_level&lt;/code&gt; can only be changed at server start. However, &lt;code&gt;archive_command&lt;/code&gt; can be changed with a configuration file reload. If you wish to temporarily stop archiving, one way to do it is to set &lt;code&gt;archive_command&lt;/code&gt; to the empty string (&lt;code&gt;''&lt;/code&gt;). This will cause WAL files to accumulate in &lt;code&gt;pg_wal/&lt;/code&gt; until a working &lt;code&gt;archive_command&lt;/code&gt; is re-established.</source>
          <target state="translated">경우 &lt;code&gt;wal_level&lt;/code&gt; 가 인 &lt;code&gt;minimal&lt;/code&gt; 에 설명 된 어떤 SQL 명령, WAL 로깅을 방지하기 위해 최적화 &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;섹션 14.4.7&lt;/a&gt; . 이러한 명령문 중 하나를 실행하는 동안 아카이브 또는 스트리밍 복제가 설정된 경우 WAL에 아카이브 복구에 필요한 정보가 충분하지 않습니다. (충돌 복구는 영향을받지 않습니다.) 이런 이유로 &lt;code&gt;wal_level&lt;/code&gt; 은 서버 시작시에만 변경할 수 있습니다. 그러나 구성 파일을 다시로드하여 &lt;code&gt;archive_command&lt;/code&gt; 를 변경할 수 있습니다. 보관을 일시적으로 중지하려는 경우, 한 가지 방법은 &lt;code&gt;archive_command&lt;/code&gt; 를 빈 문자열 ( &lt;code&gt;''&lt;/code&gt; )로 설정하는 것입니다. 이렇게하면 WAL 파일 이 작업 할 때까지 &lt;code&gt;pg_wal/&lt;/code&gt; 에 누적됩니다 &lt;code&gt;archive_command&lt;/code&gt; 가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc54463c4a91042c587b320f65f275bd091c2193" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed, there is generally a greatly increased chance of detecting single-bit errors, since strict binary equality is tested, and the indexed attributes within the heap are tested.</source>
          <target state="translated">때 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 검증이 수행되어, 엄격한 진 평등을 테스트하기 때문에, 일반적으로 단일 비트 오류를 검출하는 크게 증가 기회이며, 힙 내에서 인덱스 속성을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="668fe437dfa47692f950b23dc7849bfb4637dcda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; is greater than one, the returned numbers should be averages expected for any one scan of the index.</source>
          <target state="translated">때 &lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; 이&lt;/em&gt; 보다 큰 하나이며, 반환 된 숫자는 지수의 1 스캔 예상 평균해야한다.</target>
        </trans-unit>
        <trans-unit id="36ef5495d24b79877e9b0ce1d70303e79e6501c2" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned for &lt;code&gt;NULL&lt;/code&gt; inputs. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">때 &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 긍정적 인 경우, 제로 행이 반환되는 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 보다 큰 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; . 반대로, &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 가 음수이면 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 가 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; 보다 작은 경우 0 개의 행이 반환됩니다 . &lt;code&gt;NULL&lt;/code&gt; 입력에 대해서는 제로 행도 리턴 됩니다 . &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 가 0 이되는 것은 오류입니다 . 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80eeda2a3957217fb0ef90a74740dda9cf0f27e8" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned if any input is &lt;code&gt;NULL&lt;/code&gt;. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">때 &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 긍정적 인 경우, 제로 행이 반환되는 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 보다 큰 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; . 반대로 &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 이 음수이면 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 가 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; 보다 작 으면 0 행이 반환됩니다 . 입력이 &lt;code&gt;NULL&lt;/code&gt; 인 경우 0 행도 반환 됩니다 . &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 가 0 이면 오류입니다 . 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="4d1d230678ad6398ea1b726af7844a229cc8f13e" translate="yes" xml:space="preserve">
          <source>When Can Parallel Query Be Used?</source>
          <target state="translated">병렬 쿼리는 언제 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1ace675b775ff95ec59fcdc66447d15d12e35d34" translate="yes" xml:space="preserve">
          <source>When Color is Used</source>
          <target state="translated">색상이 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="8c5a55e381f3b4b99fc5f9dc03b78c3fc758ed84" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">GSSAPI는 Kerberos를 사용하는 경우 &lt;code&gt;servicename/hostname@realm&lt;/code&gt; 형식의 표준 사용자를 사용합니다 . PostgreSQL 서버는 서버가 사용하는 키탭에 포함 된 프린시 펄을 승인하지만 &lt;code&gt;krbsrvname&lt;/code&gt; 연결 매개 변수를 사용하여 클라이언트에서 연결할 때 올바른 프린시 펄 세부 사항을 지정하도록주의를 기울여야합니다 . ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;33.1.2 절&lt;/a&gt; 참조 ) 설치 기본값은 빌드시 &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; 를 사용하여 기본 &lt;code&gt;postgres&lt;/code&gt; 에서 변경할 수 있습니다.. 대부분의 환경에서이 매개 변수는 변경할 필요가 없습니다. 일부 Kerberos 구현에는 서비스 이름이 대문자 여야하는 Microsoft Active Directory와 같은 다른 서비스 이름이 필요할 수 있습니다 ( &lt;code&gt;POSTGRES&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0d3dbcdfb1b49d79ff3ed10298c962dc04c9d92" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">GSSAPI가 Kerberos를 사용하는 경우 &lt;code&gt;servicename/hostname@realm&lt;/code&gt; 형식의 표준 주체를 사용합니다 . PostgreSQL 서버는 서버에서 사용하는 키탭에 포함 된 모든 주체를 허용하지만 &lt;code&gt;krbsrvname&lt;/code&gt; 연결 매개 변수를 사용하여 클라이언트에서 연결할 때 올바른 주체 세부 정보를 지정하도록주의해야합니다 . ( &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;섹션 33.1.2&lt;/a&gt; 참조 ) &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; 을 사용하여 빌드시 기본 &lt;code&gt;postgres&lt;/code&gt; 에서 설치 기본값을 변경할 수 있습니다.. 대부분의 환경에서이 매개 변수는 변경할 필요가 없습니다. 일부 Kerberos 구현에는 서비스 이름이 대문자 여야하는 Microsoft Active Directory ( &lt;code&gt;POSTGRES&lt;/code&gt; ) 와 같은 다른 서비스 이름이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb176371849755f8e3fddd6c5c7996731ba8719c" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_archive_delay&lt;/code&gt; applies when WAL data is being read from WAL archive (and is therefore not current). If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">핫 스탠바이가 활성화되면이 매개 변수는 &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;26.5.2 절에&lt;/a&gt; 설명 된대로 적용 할 WAL 항목과 충돌하는 스탠바이 쿼리를 취소하기 전에 스탠바이 서버가 대기해야하는 시간을 결정합니다 . &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 는 WAL 데이터를 WAL 아카이브에서 읽을 때 적용되므로 현재가 아닙니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 30 초입니다. 값이 -1이면 대기 쿼리가 충돌하는 쿼리가 완료 될 때까지 영원히 대기 할 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ec8116773102304d6d7b1390f1e98f30e3bb2ff" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; applies when WAL data is being received via streaming replication. If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">핫 스탠바이가 활성화되면이 매개 변수는 &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;26.5.2 절에&lt;/a&gt; 설명 된대로 적용 할 WAL 항목과 충돌하는 스탠바이 쿼리를 취소하기 전에 스탠바이 서버가 대기해야하는 시간을 결정합니다 . &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 는 WAL 데이터가 스트리밍 복제를 통해 수신 될 때 적용됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 30 초입니다. 값이 -1이면 대기 쿼리가 충돌하는 쿼리가 완료 될 때까지 영원히 대기 할 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f0d78fac0ffb73c1a9e09c7cc14d11764cc7556" translate="yes" xml:space="preserve">
          <source>When PostgreSQL maps SQL data values to XML (as in &lt;code&gt;xmlelement&lt;/code&gt;), or XML to SQL (as in the output columns of &lt;code&gt;xmltable&lt;/code&gt;), except for a few cases treated specially, PostgreSQL simply assumes that the XML data type's XPath 1.0 string form will be valid as the text-input form of the SQL datatype, and conversely. This rule has the virtue of simplicity while producing, for many data types, results similar to the mappings specified in the standard.</source>
          <target state="translated">PostgreSQL이 특별히 처리 된 몇 가지 경우를 제외하고 SQL 데이터 값을 &lt;code&gt;xmlelement&lt;/code&gt; 의 XML 또는 XML &lt;code&gt;xmltable&lt;/code&gt; 의 출력 열에 매핑 할 때 PostgreSQL은 단순히 XML 데이터 유형의 XPath 1.0 문자열 형식이 다음 과 같다고 가정합니다. SQL 데이터 유형의 텍스트 입력 형식으로 유효합니다. 이 규칙은 많은 데이터 유형에 대해 표준에 지정된 매핑과 유사한 결과를 생성하는 동안 단순성이라는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4181958cdfd24c8fd1ab7073c5b2ff83fa0a559f" translate="yes" xml:space="preserve">
          <source>When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name that the client sends in the &lt;code&gt;client-first-message&lt;/code&gt;. The user name that was already sent in the startup message is used instead. PostgreSQL supports multiple character encodings, while SCRAM dictates UTF-8 to be used for the user name, so it might be impossible to represent the PostgreSQL user name in UTF-8.</source>
          <target state="translated">PostgreSQL에서 SCRAM-SHA-256을 사용하는 경우 서버는 클라이언트가 &lt;code&gt;client-first-message&lt;/code&gt; 에서 보내는 사용자 이름을 무시합니다 . 시작 메시지에 이미 전송 된 사용자 이름이 대신 사용됩니다. PostgreSQL은 다중 문자 인코딩을 지원하지만 SCRAM은 UTF-8이 사용자 이름으로 사용되도록 지시하므로 PostgreSQL 사용자 이름을 UTF-8로 표현하는 것이 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b543779d02e501d6f789fd6a94efbe4d169a8312" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_item&lt;/code&gt; list, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절이 있을 때 본질적으로 발생하는 것은 대상 테이블이 &lt;code&gt;from_item&lt;/code&gt; 목록에 언급 된 테이블 에 조인되고 조인의 각 출력 행이 대상 테이블에 대한 업데이트 작업을 나타내는 것입니다. &lt;code&gt;FROM&lt;/code&gt; 을 사용할 때 조인이 수정할 각 행에 대해 최대 하나의 출력 행을 생성하는지 확인해야합니다. 즉, 대상 행은 다른 테이블의 두 개 이상의 행에 조인되어서는 안됩니다. 그렇다면 조인 행 중 하나만 대상 행을 업데이트하는 데 사용되지만 사용할 행은 쉽게 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4cd20efcfa95fdaaa37532258734ec47bc3eda12" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_list&lt;/code&gt;, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">때 &lt;code&gt;FROM&lt;/code&gt; 절이, 본질적으로 어떤 일이 목표 테이블은 언급 된 테이블에 결합된다는 것이다 &lt;code&gt;from_list&lt;/code&gt; 및 조인의 각 출력 행 목표 테이블에 대한 갱신 동작을 나타낸다. &lt;code&gt;FROM&lt;/code&gt; 을 사용할 때 결합은 각 행이 수정 될 때마다 최대 하나의 출력 행을 생성해야합니다. 즉, 대상 행이 다른 테이블에서 둘 이상의 행에 조인되어서는 안됩니다. 그렇다면 조인 행 중 하나만 대상 행을 업데이트하는 데 사용되지만 어느 행을 사용할지는 쉽게 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a80d67f6221f67e848e31748e5e7aded5d6746e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; item contains &lt;code&gt;LATERAL&lt;/code&gt; cross-references, evaluation proceeds as follows: for each row of the &lt;code&gt;FROM&lt;/code&gt; item providing the cross-referenced column(s), or set of rows of multiple &lt;code&gt;FROM&lt;/code&gt; items providing the columns, the &lt;code&gt;LATERAL&lt;/code&gt; item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).</source>
          <target state="translated">때 &lt;code&gt;FROM&lt;/code&gt; 항목이 포함 된 &lt;code&gt;LATERAL&lt;/code&gt; 은 다음과 같이 상호 참조 평가를 진행하여 다음의 각 행 &lt;code&gt;FROM&lt;/code&gt; 항목 복수의 행들의 상호 참조 컬럼 (들), 또는 세트 제공 &lt;code&gt;FROM&lt;/code&gt; 열을 제공하는 상품의 &lt;code&gt;LATERAL&lt;/code&gt; 항목으로 평가되고 해당 행 또는 행 집합의 열 값 결과 행은 평소처럼 계산 된 행과 결합됩니다. 이는 열 소스 테이블에서 각 행 또는 행 세트에 대해 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="9131be6a2fce2c0e060d15eb98b8c743d3328da0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint is not deferrable, PostgreSQL checks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint as &lt;code&gt;DEFERRABLE&lt;/code&gt; but not deferred (i.e., &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;). Be aware that this can be significantly slower than immediate uniqueness checking.</source>
          <target state="translated">때 &lt;code&gt;UNIQUE&lt;/code&gt; 또는 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 의 제약 연기 아니다 고유성 PostgreSQL의 검사 행 삽입 또는 수정 될 때마다 즉시. SQL 표준에 따르면 명령문의 끝에서만 고유성이 적용되어야합니다. 예를 들어 단일 명령이 여러 키 값을 업데이트 할 때 차이가 있습니다. 표준 호환 동작을 얻으려면 제약 조건을 &lt;code&gt;DEFERRABLE&lt;/code&gt; 로 선언 하지만 지연되지는 않습니다 (즉, &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; ). 이는 즉시 고유성 검사보다 속도가 상당히 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7633f6759da586e80f43626088973d06a48ea56" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;pg_cast&lt;/code&gt; entry has different source and target types and a function that takes more than one argument, it represents converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">때 &lt;code&gt;pg_cast&lt;/code&gt; 의 항목이 상이한 소스 및 타겟 유형 및 하나 개 이상의 인자를하는 기능을 갖고, 그 한 유형에서 다른 유형으로 변환하여 단일 단계로 길이 강제 적용 나타낸다. 이러한 항목을 사용할 수없는 경우 유형 수정자를 사용하는 유형으로 강제 변환하려면 두 가지 단계가 필요합니다. 하나는 데이터 유형간에 변환하고 다른 하나는 수정자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="88f0e69da747f3bb16cb53c469a234fbf587434e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;timestamp with time zone&lt;/code&gt; value is output, it is always converted from UTC to the current &lt;code&gt;timezone&lt;/code&gt; zone, and displayed as local time in that zone. To see the time in another time zone, either change &lt;code&gt;timezone&lt;/code&gt; or use the &lt;code&gt;AT TIME ZONE&lt;/code&gt; construct (see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;Section 9.9.3&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;timestamp with time zone&lt;/code&gt; 값이 있는 타임 스탬프 가 출력되면 항상 UTC에서 현재 &lt;code&gt;timezone&lt;/code&gt; 로 변환 되어 해당 시간대의 현지 시간으로 표시됩니다. 다른 시간대의 시간을 보려면 &lt;code&gt;timezone&lt;/code&gt; 를 변경 하거나 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 구문을 사용 하십시오 ( &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;섹션 9.9.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="27629e4b11182354bc4cc1d2c2660d2bd8a7f20c" translate="yes" xml:space="preserve">
          <source>When a cast has different source and target types and a function that takes more than one argument, it supports converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two cast steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">캐스트에 다른 소스 및 대상 유형과 둘 이상의 인수를 사용하는 함수가 있으면 한 유형에서 다른 유형으로 변환하고 단일 단계에서 길이 강제 적용을 지원합니다. 이러한 항목을 사용할 수없는 경우 유형 수정자를 사용하는 유형으로 강제 변환하려면 두 가지 캐스트 단계가 필요합니다. 하나는 데이터 유형간에 변환하고 다른 하나는 수정자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="49788d41c6b6cbdafb9c157dde66cc21e7ad5c8d" translate="yes" xml:space="preserve">
          <source>When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type).</source>
          <target state="translated">알려진 유형의 값 표현식에 캐스트가 적용되면 런타임 유형 변환을 나타냅니다. 캐스트는 적합한 유형 변환 조작이 정의 된 경우에만 성공합니다. 이것은 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;4.1.2.7 절&lt;/a&gt; 에서 보여 지듯이 상수를 가진 캐스트를 사용하는 것과는 미묘한 차이가 있음을 주목 하라 . 비공식 문자열 리터럴에 적용된 캐스트는 리터럴 상수 값에 대한 유형의 초기 할당을 나타내므로 모든 유형에 대해 성공합니다 (문자열 리터럴의 내용이 데이터 유형에 허용되는 입력 구문 인 경우).</target>
        </trans-unit>
        <trans-unit id="cf5e183edf65b04ea968b8cbec71c03d82d34814" translate="yes" xml:space="preserve">
          <source>When a character string value is cast to or from type &lt;code&gt;xml&lt;/code&gt; without going through &lt;code&gt;XMLPARSE&lt;/code&gt; or &lt;code&gt;XMLSERIALIZE&lt;/code&gt;, respectively, the choice of &lt;code&gt;DOCUMENT&lt;/code&gt; versus &lt;code&gt;CONTENT&lt;/code&gt; is determined by the &amp;ldquo;XML option&amp;rdquo;  session configuration parameter, which can be set using the standard command:</source>
          <target state="translated">문자열 값이 각각 &lt;code&gt;XMLPARSE&lt;/code&gt; 또는 &lt;code&gt;XMLSERIALIZE&lt;/code&gt; 를 거치지 않고 &lt;code&gt;xml&lt;/code&gt; 유형으로 캐스트되거나 xml 유형에서 캐스트 될 때 &lt;code&gt;DOCUMENT&lt;/code&gt; 대 &lt;code&gt;CONTENT&lt;/code&gt; 의 선택은 &quot;XML 옵션&quot;세션 구성 매개 변수에 의해 결정되며 표준 명령을 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42fc13aa34e4743bab6d0037fe542f1b13a66649" translate="yes" xml:space="preserve">
          <source>When a column is added with &lt;code&gt;ADD COLUMN&lt;/code&gt; and a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If no &lt;code&gt;DEFAULT&lt;/code&gt; is specified, NULL is used. In neither case is a rewrite of the table required.</source>
          <target state="translated">&lt;code&gt;ADD COLUMN&lt;/code&gt; 을 사용하여 열을 추가 하고 비 휘발성 &lt;code&gt;DEFAULT&lt;/code&gt; 를 지정하면 명령문의 시점과 기본값이 테이블의 메타 데이터에 저장 될 때 기본값이 평가됩니다. 이 값은 모든 기존 행의 열에 사용됩니다. &lt;code&gt;DEFAULT&lt;/code&gt; 를 지정 하지 않으면 NULL이 사용됩니다. 두 경우 모두 테이블을 다시 쓰지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="4617ca746c05eccbac9e1250d759f5bd44319fcd" translate="yes" xml:space="preserve">
          <source>When a conflicting query is short, it's typically desirable to allow it to complete by delaying WAL application for a little bit; but a long delay in WAL application is usually not desirable. So the cancel mechanism has parameters, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;, that define the maximum allowed delay in WAL application. Conflicting queries will be canceled once it has taken longer than the relevant delay setting to apply any newly-received WAL data. There are two parameters so that different delay values can be specified for the case of reading WAL data from an archive (i.e., initial recovery from a base backup or &amp;ldquo;catching up&amp;rdquo; a standby server that has fallen far behind) versus reading WAL data via streaming replication.</source>
          <target state="translated">충돌하는 쿼리가 짧은 경우 일반적으로 WAL 응용 프로그램을 약간 지연 시켜서 완료하는 것이 바람직합니다. 그러나 WAL 응용 프로그램의 긴 지연은 일반적으로 바람직하지 않습니다. 따라서 취소 메커니즘에는 WAL 애플리케이션에서 허용되는 최대 지연을 정의하는 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; 매개 변수가 있습니다. 새로 수신 된 WAL 데이터를 적용하기 위해 관련 지연 설정보다 오래 걸리면 충돌 쿼리가 취소됩니다. 아카이브에서 WAL 데이터를 읽는 경우 (즉, 기본 백업에서 초기 복구 또는 멀리 떨어진 대기 서버를 &quot;캐치&quot;) 다른 방법을 통해 WAL 데이터를 읽는 경우 다른 지연 값을 지정할 수 있도록 두 개의 매개 변수가 있습니다 스트리밍 복제.</target>
        </trans-unit>
        <trans-unit id="fe9942af75508e96643f23b2bb2b19c3cb29a5d8" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind anonymously (since &lt;code&gt;ldapbinddn&lt;/code&gt; was not specified) to the LDAP server, perform a search for &lt;code&gt;(uid=someuser)&lt;/code&gt; under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</source>
          <target state="translated">데이터베이스 사용자 &lt;code&gt;someuser&lt;/code&gt; 로 데이터베이스 서버에 대한 연결 이 요청되면 PostgreSQL은 ( &lt;code&gt;ldapbinddn&lt;/code&gt; 이 지정되지 않았으므로) LDAP 서버에 익명으로 바인딩하려고 시도 하고 지정된 기본 DN에서 &lt;code&gt;(uid=someuser)&lt;/code&gt; 를 검색합니다 . 항목이 발견되면 클라이언트가 제공 한 찾은 정보와 비밀번호를 사용하여 바인드를 시도합니다. 두 번째 연결에 성공하면 데이터베이스 액세스 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="48781ec5a4acd4a7481b8c8839149e95712b5009" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind to the LDAP server using the DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; and the password provided by the client. If that connection succeeds, the database access is granted.</source>
          <target state="translated">데이터베이스 사용자 &lt;code&gt;someuser&lt;/code&gt; 로 데이터베이스 서버에 대한 연결 이 요청되면 PostgreSQL은 DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; 및 클라이언트가 제공 한 비밀번호를 사용하여 LDAP 서버에 바인딩하려고 시도합니다 . 해당 연결에 성공하면 데이터베이스 액세스 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="c225436eedb2c4fcd16a275b1ddffc50962ab028" translate="yes" xml:space="preserve">
          <source>When a constant's value has been ignored for purposes of matching the query to other queries, the constant is replaced by a parameter symbol, such as &lt;code&gt;$1&lt;/code&gt;, in the &lt;code&gt;pg_stat_statements&lt;/code&gt; display. The rest of the query text is that of the first query that had the particular &lt;code&gt;queryid&lt;/code&gt; hash value associated with the &lt;code&gt;pg_stat_statements&lt;/code&gt; entry.</source>
          <target state="translated">조회를 다른 조회와 일치시키기 위해 상수 값이 무시 된 경우, &lt;code&gt;pg_stat_statements&lt;/code&gt; 표시 에서 상수는 &lt;code&gt;$1&lt;/code&gt; 과 같은 매개 변수 기호로 대체 됩니다. 나머지 쿼리 텍스트는 &lt;code&gt;pg_stat_statements&lt;/code&gt; 항목 과 관련된 특정 &lt;code&gt;queryid&lt;/code&gt; 해시 값 을 가진 첫 번째 쿼리의 텍스트입니다 .</target>
        </trans-unit>
        <trans-unit id="ecb409e448668771f827d8fbf0e7974aed415eec" translate="yes" xml:space="preserve">
          <source>When a data-only dump is chosen and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_dump emits commands to disable triggers on user tables before inserting the data, and then commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">데이터 전용 덤프가 선택되고 &lt;code&gt;--disable-triggers&lt;/code&gt; 옵션 이 사용되면 pg_dump는 데이터를 삽입하기 전에 사용자 테이블에서 트리거를 비활성화하는 명령을 내 보낸 다음 데이터가 삽입 된 후 다시 활성화하는 명령을 내 보냅니다. 중간에 복원이 중지되면 시스템 카탈로그가 잘못된 상태로 남아있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bb4292f30931b17f0bc254f84df53dc22a84368" translate="yes" xml:space="preserve">
          <source>When a direct database connection is specified using the &lt;code&gt;-d&lt;/code&gt; option, pg_restore internally executes SQL statements. If you have problems running pg_restore, make sure you are able to select information from the database using, for example, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 옵션을 사용하여 직접 데이터베이스 연결을 지정하면 pg_restore는 내부적으로 SQL 문을 실행합니다. pg_restore를 실행하는 데 문제가있는 경우 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 등을 사용하여 데이터베이스에서 정보를 선택할 수 있는지 확인하십시오 . 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="70b0a551bd1d82e60af1e6e20328604ac27e04a2" translate="yes" xml:space="preserve">
          <source>When a domain has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested in alphabetical order by name. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">도메인에 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 이 여러 개 있으면 이름순으로 사전 순으로 테스트됩니다. 9.5 이전의 PostgreSQL 버전은 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건에 대한 특정 실행 순서를 따르지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="d2882ec668c4758898724ea8c42f8d7a46c5af40" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the function's output column(s), which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">의 함수 경우 &lt;code&gt;FROM&lt;/code&gt; 절에서 접미사 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 하는 &lt;code&gt;bigint&lt;/code&gt; 열이 기능의 출력의 각 행 (1)에 의해 1 단위에서 시작 기능의 출력 컬럼 (들)에 추가된다. 이것은 &lt;code&gt;unnest()&lt;/code&gt; 와 같은 함수를 반환하는 집합의 경우에 가장 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="82ae6b8670e18414fb24938a0f2cc8a6d1070788" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the output which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절의 함수에 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 가 접미 부로 지정 되면 &lt;code&gt;bigint&lt;/code&gt; 열이 출력에 추가되어 1에서 시작하여 함수 출력의 각 행에 대해 1 씩 증가합니다. 이것은 &lt;code&gt;unnest()&lt;/code&gt; 와 같은 반환 함수를 설정하는 경우에 가장 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="cc5d8fb3f4d70c3c0f1dea589130a29e4dae23e6" translate="yes" xml:space="preserve">
          <source>When a heap entry is to be deleted (by &lt;code&gt;VACUUM&lt;/code&gt;), all its index entries must be removed first.</source>
          <target state="translated">힙 항목을 삭제하려면 ( &lt;code&gt;VACUUM&lt;/code&gt; ) 모든 색인 항목을 먼저 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="00af93fe8454ff02af34b94554824196fc81e8fc" translate="yes" xml:space="preserve">
          <source>When a locking clause appears at the top level of a &lt;code&gt;SELECT&lt;/code&gt; query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a &lt;code&gt;LIMIT&lt;/code&gt; is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by &lt;code&gt;OFFSET&lt;/code&gt; will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 절의 최상위 레벨에 잠금 절이 표시되면 잠긴 행은 쿼리에 의해 리턴 된 행과 정확히 일치합니다. 조인 쿼리의 경우 잠긴 행은 반환 된 조인 행에 기여하는 행입니다. 또한, 스냅 샷 이후에 갱신되어 쿼리 조건을 만족시키지 않으면 리턴되지 않지만 쿼리 스냅 샷 시점의 쿼리 조건을 만족하는 행은 잠 깁니다. &lt;code&gt;LIMIT&lt;/code&gt; 가 사용되는 경우, 한계 를 만족시키기에 충분한 행이 리턴되면 잠금이 중지됩니다 (그러나 &lt;code&gt;OFFSET&lt;/code&gt; 에 의해 건너 뛴 행 은 잠금 됨에 유의하십시오 ). 마찬가지로, 커서 쿼리에서 잠금 절을 사용하면 실제로 커서로 가져 오거나 한 단계 씩 지난 행만 잠 깁니다.</target>
        </trans-unit>
        <trans-unit id="ef95b8a60ebd804a0c28a2e00cab45258a43a0d6" translate="yes" xml:space="preserve">
          <source>When a locking clause appears in a sub-&lt;code&gt;SELECT&lt;/code&gt;, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,</source>
          <target state="translated">하위 &lt;code&gt;SELECT&lt;/code&gt; 에 잠금 절이 표시되면 잠긴 행은 하위 쿼리에 의해 외부 쿼리로 반환되는 행입니다. 외부 쿼리의 조건을 사용하여 하위 쿼리의 실행을 최적화 할 수 있으므로 하위 쿼리 만 검사하는 것보다 적은 수의 행이 필요할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bfc7a3d97debfcf5d558fe06d1809283c70c4abd" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;GRANT&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options. The &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">객체의 소유자가 아닌 사람 이 객체에 대한 권한 을 &lt;code&gt;GRANT&lt;/code&gt; 하려고 하면 사용자에게 객체에 대한 권한이없는 경우 명령이 실패합니다. 사용 가능한 권한이 있으면 명령이 진행되지만 사용자에게 권한 부여 옵션이있는 권한 만 부여됩니다. &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; 에는 그랜트 옵션을 보유하지 않으면 특별히 명령에 명명 된 권한의 교부금 옵션이 유지되지 않을 경우 다른 형태의 경고를 발행 반면 양식은 경고 메시지를 발행합니다. (이러한 진술은 원칙적으로 개체 소유자에게도 적용되지만 소유자는 항상 모든 보조금 옵션을 보유한 것으로 간주되므로 해당 사례가 발생할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="89d5be09265c0f260930da66e4dbc18e249c5a52" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;REVOKE&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options. The &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">개체의 비 소유자가 개체 에 대한 권한 을 &lt;code&gt;REVOKE&lt;/code&gt; 하려고 하면 사용자에게 개체에 대한 권한이없는 경우 명령이 실패합니다. 사용 가능한 권한이 있으면 명령이 진행되지만 사용자에게 권한 부여 옵션이있는 권한 만 취소됩니다. &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; 에는 그랜트 옵션을 보유하지 않으면 특별히 명령에 명명 된 권한의 교부금 옵션이 유지되지 않을 경우 다른 형태의 경고를 발행 반면 양식은 경고 메시지를 발행합니다. (이러한 진술은 원칙적으로 개체 소유자에게도 적용되지만 소유자는 항상 모든 보조금 옵션을 보유한 것으로 간주되므로 해당 사례가 발생할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="0029c76ef03f694dc7bb9ed004592d4eb27d7674" translate="yes" xml:space="preserve">
          <source>When a partitioned table is added to a publication, all of its existing and future partitions are implicitly considered to be part of the publication. So, even operations that are performed directly on a partition are also published via publications that its ancestors are part of.</source>
          <target state="translated">분할 된 테이블이 게시에 추가되면 모든 기존 및 미래 파티션이 암시 적으로 게시의 일부로 간주됩니다. 따라서 파티션에서 직접 수행되는 작업도 조상이 속한 게시를 통해 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="81fc5d42be5663314dba2e99345c9e9036540107" translate="yes" xml:space="preserve">
          <source>When a password is specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, this parameter determines the algorithm to use to encrypt the password. The default value is &lt;code&gt;md5&lt;/code&gt;, which stores the password as an MD5 hash (&lt;code&gt;on&lt;/code&gt; is also accepted, as alias for &lt;code&gt;md5&lt;/code&gt;). Setting this parameter to &lt;code&gt;scram-sha-256&lt;/code&gt; will encrypt the password with SCRAM-SHA-256.</source>
          <target state="translated">&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 또는 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; 에 비밀번호가 지정된 경우이 매개 변수는 비밀번호를 암호화하는 데 사용할 알고리즘을 결정합니다. 기본값은 &lt;code&gt;md5&lt;/code&gt; 이며, 비밀번호를 MD5 해시로 저장합니다 ( &lt;code&gt;on&lt;/code&gt; 은 &lt;code&gt;md5&lt;/code&gt; 의 별명으로도 허용됨 ). 이 매개 변수를 &lt;code&gt;scram-sha-256&lt;/code&gt; 으로 설정하면 SCRAM-SHA-256을 사용하여 비밀번호를 암호화합니다.</target>
        </trans-unit>
        <trans-unit id="a045ad36bdf763a5564eafc812cd1f70e538ac02" translate="yes" xml:space="preserve">
          <source>When a query involves multiple window functions, it is possible to write out each one with a separate &lt;code&gt;OVER&lt;/code&gt; clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a &lt;code&gt;WINDOW&lt;/code&gt; clause and then referenced in &lt;code&gt;OVER&lt;/code&gt;. For example:</source>
          <target state="translated">쿼리에 여러 개의 창 함수가 포함 된 경우 별도의 &lt;code&gt;OVER&lt;/code&gt; 절을 사용하여 각 창을 작성할 수 있지만 여러 함수에 대해 동일한 창 동작이 필요한 경우 중복되고 오류가 발생하기 쉽습니다. 대신, 각 윈도우 동작은 &lt;code&gt;WINDOW&lt;/code&gt; 절 에서 이름을 지정한 다음 &lt;code&gt;OVER&lt;/code&gt; 에서 참조 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b051ff28261e8c6e18971fa6cb50736f0add4f7" translate="yes" xml:space="preserve">
          <source>When a query only involves two or three tables, there aren't many join orders to worry about. But the number of possible join orders grows exponentially as the number of tables expands. Beyond ten or so input tables it's no longer practical to do an exhaustive search of all the possibilities, and even for six or seven tables planning might take an annoyingly long time. When there are too many input tables, the PostgreSQL planner will switch from exhaustive search to a &lt;em&gt;genetic&lt;/em&gt; probabilistic search through a limited number of possibilities. (The switch-over threshold is set by the &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; run-time parameter.) The genetic search takes less time, but it won't necessarily find the best possible plan.</source>
          <target state="translated">쿼리에 두 개 또는 세 개의 테이블 만 포함되는 경우 걱정할 조인 순서가 많지 않습니다. 그러나 가능한 조인 순서의 수는 테이블 수가 늘어남에 따라 기하 급수적으로 증가합니다. 입력 테이블이 10 개 이상이면 모든 가능성을 철저히 검색하는 것이 더 이상 실용적이지 않으며 6 개 또는 7 개의 테이블 계획에도 성가신 시간이 오래 걸릴 수 있습니다. 입력 테이블이 너무 많으면 PostgreSQL 플래너는 제한된 수의 가능성을 통해 철저한 검색에서 &lt;em&gt;유전자&lt;/em&gt; 확률 &lt;em&gt;적&lt;/em&gt; 검색으로 전환 합니다. 전환 임계 값은 &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; 런타임 매개 변수 로 설정됩니다 . 유전자 검색에는 시간이 덜 걸리지 만 반드시 최상의 계획을 찾을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="52a265f5fc62979fde73128f8ace62054feb152e" translate="yes" xml:space="preserve">
          <source>When a schema-qualified operator name is used in the &lt;code&gt;OPERATOR&lt;/code&gt; syntax, as for example in:</source>
          <target state="translated">스키마 규정 연산자 이름이 &lt;code&gt;OPERATOR&lt;/code&gt; 구문에서 사용되는 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="07d688620d10b715a262026cbd31ef1489999e7d" translate="yes" xml:space="preserve">
          <source>When a sequential scan and sort is used, a temporary sort file is also created, so that the peak temporary space requirement is as much as double the table size, plus the index sizes. This method is often faster than the index scan method, but if the disk space requirement is intolerable, you can disable this choice by temporarily setting &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">순차 스캔 및 정렬을 사용하는 경우 임시 정렬 파일도 작성되므로 최대 임시 공간 요구 사항은 테이블 크기와 인덱스 크기의 두 배에 해당합니다. 이 방법은 종종 색인 스캔 방법보다 빠르지 만 디스크 공간 요구 사항을 견딜 수없는 경우 &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; 를 일시적 으로 &lt;code&gt;off&lt;/code&gt; 로 설정하여이 선택을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0770f15e6049d266a12140bc7f33a5609b9c35a" translate="yes" xml:space="preserve">
          <source>When a single element is pushed onto either the beginning or end of a one-dimensional array, the result is an array with the same lower bound subscript as the array operand. For example:</source>
          <target state="translated">단일 요소를 1 차원 배열의 시작 또는 끝으로 밀면 결과는 배열 피연산자와 동일한 하한 첨자를 가진 배열입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f80cd58c4f6747cdabdfc227aecb194029c6f93d" translate="yes" xml:space="preserve">
          <source>When a standby first attaches to the primary, it will not yet be properly synchronized. This is described as &lt;code&gt;catchup&lt;/code&gt; mode. Once the lag between standby and primary reaches zero for the first time we move to real-time &lt;code&gt;streaming&lt;/code&gt; state. The catch-up duration may be long immediately after the standby has been created. If the standby is shut down, then the catch-up period will increase according to the length of time the standby has been down. The standby is only able to become a synchronous standby once it has reached &lt;code&gt;streaming&lt;/code&gt; state. This state can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">대기가 기본 서버에 처음 연결되면 아직 제대로 동기화되지 않습니다. 이것을 &lt;code&gt;catchup&lt;/code&gt; 모드라고합니다. 대기 및 기본 간의 지연이 처음으로 0에 도달하면 실시간 &lt;code&gt;streaming&lt;/code&gt; 상태 로 이동합니다 . 대기 시간이 생성 된 직후 캐치 업 시간이 길어질 수 있습니다. 대기가 종료되면 대기가 종료 된 시간에 따라 캐치 업 기간이 증가합니다. 대기는 &lt;code&gt;streaming&lt;/code&gt; 상태에 도달 한 후에 만 ​​동기 대기가 될 수 있습니다. 이 상태는 &lt;code&gt;pg_stat_replication&lt;/code&gt; 보기를 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad5c61ffccbfb5effcfe0a2c8686ec7385263d29" translate="yes" xml:space="preserve">
          <source>When a subscription is dropped and recreated, the synchronization information is lost. This means that the data has to be resynchronized afterwards.</source>
          <target state="translated">구독을 삭제하고 다시 만들면 동기화 정보가 손실됩니다. 즉, 나중에 데이터를 다시 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b46a9ad23681ef38bc14d25148f1365c37846a4e" translate="yes" xml:space="preserve">
          <source>When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate &lt;code&gt;CHECK&lt;/code&gt; constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.</source>
          <target state="translated">테이블에 기본 파티션이있는 경우 새 파티션을 정의하면 기본 파티션의 파티션 제약 조건이 변경됩니다. 기본 파티션은 새 파티션으로 이동해야하는 행을 포함 할 수 없으며, 존재하지 않는지 확인하기 위해 스캔됩니다. 적절한 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건이 있으면 새 파티션의 스캔과 같이이 스캔을 피할 수 있습니다 . 새 파티션의 스캔과 마찬가지로 기본 파티션이 외부 테이블 인 경우 항상 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="152306185769e157a52b3f97557867eb083f11a7" translate="yes" xml:space="preserve">
          <source>When a table has an existing &lt;code&gt;DEFAULT&lt;/code&gt; partition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.</source>
          <target state="translated">테이블에 기존 &lt;code&gt;DEFAULT&lt;/code&gt; 파티션이 있고 새 파티션이 추가되면 새 파티션에 올바르게 속하는 행이 포함되어 있지 않은지 확인하기 위해 기본 파티션을 스캔해야합니다. 기본 파티션에 많은 수의 행이 있으면 속도가 느려질 수 있습니다. 기본 파티션이 외부 테이블이거나 새 파티션에 배치해야하는 행을 포함 할 수 없다는 제한 조건이있는 경우 스캔을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="43b2ea07826933a7c581c975e04300af317cf31d" translate="yes" xml:space="preserve">
          <source>When a table has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested for each row in alphabetical order by name, after checking &lt;code&gt;NOT NULL&lt;/code&gt; constraints. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">테이블에 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 이 여러 개 있으면 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건 을 확인한 후 이름별로 알파벳 순서로 각 행에 대해 테스트 됩니다 . 9.5 이전의 PostgreSQL 버전은 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건에 대한 특정 실행 순서를 따르지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="082c9f9ffee26ce9be34e1d589e0da24d6b1e31a" translate="yes" xml:space="preserve">
          <source>When a table is being clustered, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock is acquired on it. This prevents any other database operations (both reads and writes) from operating on the table until the &lt;code&gt;CLUSTER&lt;/code&gt; is finished.</source>
          <target state="translated">테이블이 클러스터 될 때 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금이 획득됩니다. 이렇게하면 &lt;code&gt;CLUSTER&lt;/code&gt; 가 완료 될 때까지 다른 데이터베이스 작업 (읽기 및 쓰기)이 테이블에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7d4eb9118baea2c47a40ccbe4939e2face5ca64c" translate="yes" xml:space="preserve">
          <source>When a table is clustered, PostgreSQL remembers which index it was clustered by. The form &lt;code&gt;CLUSTER table_name&lt;/code&gt; reclusters the table using the same index as before. You can also use the &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; forms of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to set the index to be used for future cluster operations, or to clear any previous setting.</source>
          <target state="translated">테이블이 클러스터링되면 PostgreSQL은 클러스터 된 인덱스를 기억합니다. &lt;code&gt;CLUSTER table_name&lt;/code&gt; 양식 은 이전과 동일한 색인을 사용하여 테이블을 다시 클러스터링합니다. 또한 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 의 &lt;code&gt;CLUSTER&lt;/code&gt; 또는 &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; 양식을 사용하여 향후 클러스터 조작에 사용될 인덱스를 설정하거나 이전 설정을 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb320e131f3533a19b92cb04f708af68aba5d79" translate="yes" xml:space="preserve">
          <source>When a table is clustered, it is physically reordered based on the index information. Clustering is a one-time operation: when the table is subsequently updated, the changes are not clustered. That is, no attempt is made to store new or updated rows according to their index order. (If one wishes, one can periodically recluster by issuing the command again. Also, setting the table's &lt;code&gt;fillfactor&lt;/code&gt; storage parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are kept on the same page if enough space is available there.)</source>
          <target state="translated">테이블이 클러스터되면 인덱스 정보에 따라 물리적으로 재정렬됩니다. 클러스터링은 일회성 작업입니다. 이후에 테이블을 업데이트하면 변경 내용이 클러스터되지 않습니다. 즉, 인덱스 순서에 따라 새 행이나 업데이트 된 행을 저장하려고 시도하지 않습니다. (원하는 경우 명령을 다시 실행하여 주기적으로 재 클러스터 할 수 있습니다. 또한 테이블의 &lt;code&gt;fillfactor&lt;/code&gt; 스토리지 매개 변수를 100 % 미만으로 설정하면 업데이트 중에 행이 충분한 경우 공간이 동일한 경우 업데이트 된 행이 동일한 페이지에 유지되므로 업데이트 중에 클러스터 순서를 유지하는 데 도움이 될 수 있습니다 거기에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="49a3d5e22ae2844ff5c06f47ba492689eb79f5ba" translate="yes" xml:space="preserve">
          <source>When a table is created, it contains no data. The first thing to do before a database can be of much use is to insert data. Data is conceptually inserted one row at a time. Of course you can also insert more than one row, but there is no way to insert less than one row. Even if you know only some column values, a complete row must be created.</source>
          <target state="translated">테이블이 작성되면 데이터가 포함되지 않습니다. 데이터베이스를 많이 사용하기 전에 가장 먼저해야 할 일은 데이터를 삽입하는 것입니다. 데이터는 개념적으로 한 번에 한 행씩 삽입됩니다. 물론 둘 이상의 행을 삽입 할 수도 있지만 둘 이상의 행을 삽입 할 방법은 없습니다. 일부 열 값만 알고 있더라도 완전한 행을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="85bad0d57dfc672246f13e6ad8d8a435cc923083" translate="yes" xml:space="preserve">
          <source>When a table or index exceeds 1 GB, it is divided into gigabyte-sized &lt;em&gt;segments&lt;/em&gt;. The first segment's file name is the same as the filenode; subsequent segments are named filenode.1, filenode.2, etc. This arrangement avoids problems on platforms that have file size limitations. (Actually, 1 GB is just the default segment size. The segment size can be adjusted using the configuration option &lt;code&gt;--with-segsize&lt;/code&gt; when building PostgreSQL.) In principle, free space map and visibility map forks could require multiple segments as well, though this is unlikely to happen in practice.</source>
          <target state="translated">테이블 또는 인덱스가 1GB를 초과하면 기가 바이트 크기의 &lt;em&gt;세그먼트&lt;/em&gt; 로 나뉩니다 . 첫 번째 세그먼트의 파일 이름은 파일 노드와 동일합니다. 후속 세그먼트의 이름은 filenode.1, filenode.2 등입니다.이 배열은 파일 크기 제한이있는 플랫폼에서 문제를 방지합니다. (실제로 1GB는 기본 세그먼트 크기 &lt;code&gt;--with-segsize&lt;/code&gt; 입니다. PostgreSQL을 빌드 할 때 --with-segsize 구성 옵션을 사용하여 세그먼트 크기를 조정할 수 있습니다 .) 원칙적으로 여유 공간 맵과 가시성 맵 포크에는 여러 세그먼트가 필요할 수 있습니다. 이것은 실제로 일어날 가능성이 적습니다.</target>
        </trans-unit>
        <trans-unit id="10a45cc60012ed72f0453155b208d80983750321" translate="yes" xml:space="preserve">
          <source>When a table reference names a table that is the parent of a table inheritance hierarchy, the table reference produces rows of not only that table but all of its descendant tables, unless the key word &lt;code&gt;ONLY&lt;/code&gt; precedes the table name. However, the reference produces only the columns that appear in the named table &amp;mdash; any columns added in subtables are ignored.</source>
          <target state="translated">테이블 참조 이름 테이블 상속 계층의 부모 테이블은 테이블 참조가 해당 테이블 그러나 그 자손 테이블의 모든 단지의 행을 생성 할 때 핵심 단어는하지 않는 &lt;code&gt;ONLY&lt;/code&gt; 테이블 이름 앞에. 그러나 참조는 명명 된 테이블에 나타나는 열만 생성합니다. 서브 테이블에 추가 된 모든 열은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="238107619ce9861ed394df0ebec618f90c2d4272" translate="yes" xml:space="preserve">
          <source>When a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by the &lt;code&gt;CREATE TABLE&lt;/code&gt; command. But the &lt;code&gt;CREATE TABLE&lt;/code&gt; command can add defaults and constraints to the table and can specify storage parameters.</source>
          <target state="translated">유형이 지정된 테이블이 작성 될 때 열의 데이터 유형은 기본 복합 유형에 의해 결정되며 &lt;code&gt;CREATE TABLE&lt;/code&gt; 명령으로 지정되지 않습니다 . 그러나 &lt;code&gt;CREATE TABLE&lt;/code&gt; 명령은 테이블에 기본값 및 제한 조건을 추가하고 스토리지 매개 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40ca1a4315d7efd053d1772d2a1868caf568479c" translate="yes" xml:space="preserve">
          <source>When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way:</source>
          <target state="translated">값이 SQL 리터럴 또는 식별자로 사용되는 경우 인용되도록 정렬하는 것이 가장 안전합니다. 변수의 값을 SQL 리터럴로 인용하려면 콜론과 변수 이름을 작은 따옴표로 묶으십시오. 값을 SQL 식별자로 인용하려면 콜론 뒤에 변수 이름을 큰 따옴표로 묶으십시오. 이러한 구문은 변수 값에 포함 된 따옴표 및 기타 특수 문자를 올바르게 처리합니다. 이전 예제는 다음과 같이보다 안전하게 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="55eaed5a13493b2841925c6347f0f009f1c69d52" translate="yes" xml:space="preserve">
          <source>When a view is locked, all relations appearing in the view definition query are also locked recursively with the same lock mode.</source>
          <target state="translated">뷰가 잠기면 뷰 정의 쿼리에 나타나는 모든 관계도 동일한 잠금 모드로 재귀 적으로 잠 깁니다.</target>
        </trans-unit>
        <trans-unit id="0731d9c33a2135d592b4234920022cbe73ac4232" translate="yes" xml:space="preserve">
          <source>When acquiring locks automatically for commands that reference tables, PostgreSQL always uses the least restrictive lock mode possible. &lt;code&gt;LOCK TABLE&lt;/code&gt; provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the &lt;code&gt;READ COMMITTED&lt;/code&gt; isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain &lt;code&gt;SHARE&lt;/code&gt; lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because &lt;code&gt;SHARE&lt;/code&gt; lock mode conflicts with the &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; lock acquired by writers, and your &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; statement will wait until any concurrent holders of &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode locks commit or roll back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock.</source>
          <target state="translated">테이블을 참조하는 명령에 대해 자동으로 잠금을 획득하면 PostgreSQL은 항상 가능한 가장 제한적인 잠금 모드를 사용합니다. &lt;code&gt;LOCK TABLE&lt;/code&gt; 은보다 제한적인 잠금이 필요할 수있는 경우를 제공합니다. 예를 들어, 응용 프로그램이 &lt;code&gt;READ COMMITTED&lt;/code&gt; 분리 레벨 에서 트랜잭션을 실행하고 트랜잭션 기간 동안 테이블의 데이터가 안정적으로 유지되도록해야 한다고 가정 하십시오. 이를 위해 쿼리하기 전에 테이블에서 &lt;code&gt;SHARE&lt;/code&gt; 잠금 모드를 얻을 수 있습니다 . &lt;code&gt;SHARE&lt;/code&gt; 잠금 모드 가 기록기에서 획득 한 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 잠금 과 충돌 하므로 &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; 문은 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 모드 잠금 의 동시 보유자가 커밋하거나 롤백 할 때까지 기다립니다 . 따라서 일단 잠금을 확보하면 커밋되지 않은 쓰기 미해결이 없습니다. 또한 잠금을 해제 할 때까지 아무것도 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b867fce21cdcff5c6925a3d0a1d7eb430184e42c" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days, keeping the time of day the same. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;America/Denver&lt;/code&gt;:</source>
          <target state="translated">가산하면 &lt;code&gt;interval&lt;/code&gt; 에 값 (또는 감산 &lt;code&gt;interval&lt;/code&gt; 값에서)는 &lt;code&gt;timestamp with time zone&lt;/code&gt; 일 값 성분 진보 또는 날짜 감소 &lt;code&gt;timestamp with time zone&lt;/code&gt; 매일 같은 시간을 유지하는 일 표시된 번호로한다. 일광 절약 시간이 변경되는 동안 (세션 시간대가 DST를 인식하는 시간대로 설정된 경우) 이는 &lt;code&gt;interval '1 day'&lt;/code&gt; 이 반드시 &lt;code&gt;interval '24 hours'&lt;/code&gt; 과 같지는 않음을 의미 합니다 . 예를 들어 세션 시간대가 &lt;code&gt;America/Denver&lt;/code&gt; 로 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="71a870f6af21f8dafd4cc733a991bd99fd9d13ef" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;CST7CDT&lt;/code&gt;, &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; will produce &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt;, while adding &lt;code&gt;interval '24 hours'&lt;/code&gt; to the same initial &lt;code&gt;timestamp with time zone&lt;/code&gt; produces &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt;, as there is a change in daylight saving time at &lt;code&gt;2005-04-03 02:00&lt;/code&gt; in time zone &lt;code&gt;CST7CDT&lt;/code&gt;.</source>
          <target state="translated">가산하면 &lt;code&gt;interval&lt;/code&gt; 에 값 (또는 감산 &lt;code&gt;interval&lt;/code&gt; 값에서)는 &lt;code&gt;timestamp with time zone&lt;/code&gt; 일 값을, 발전 요소 또는 일 감소 &lt;code&gt;timestamp with time zone&lt;/code&gt; 일 수에 의하여 지시한다. 일광 절약 시간제 변경 (세션 시간대가 DST를 인식하는 시간대로 설정된 경우)에서 &lt;code&gt;interval '1 day'&lt;/code&gt; 은 반드시 &lt;code&gt;interval '24 hours'&lt;/code&gt; 과 같지 않습니다 . 예를 들어, 세션 시간대로 설정된 &lt;code&gt;CST7CDT&lt;/code&gt; , &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; 생산할 예정 &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt; ,추가하는 동안 &lt;code&gt;interval '24 hours'&lt;/code&gt; &lt;code&gt;timestamp with time zone&lt;/code&gt; 가 있는 동일한 초기 타임 스탬프 에 대한 '24 시간 '간격 &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt; 인 타임 스탬프를 생성합니다 . &lt;code&gt;2005-04-03 02:00&lt;/code&gt; 의 일광 절약 시간 제가 변경되었습니다 . 시간대 &lt;code&gt;CST7CDT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1434d3ccf06b603b0c31a66fe4b553e885790f9" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;Append&lt;/code&gt; node is used in a parallel plan, each process will execute the child plans in the order in which they appear, so that all participating processes cooperate to execute the first child plan until it is complete and then move to the second plan at around the same time. When a &lt;code&gt;Parallel Append&lt;/code&gt; is used instead, the executor will instead spread out the participating processes as evenly as possible across its child plans, so that multiple child plans are executed simultaneously. This avoids contention, and also avoids paying the startup cost of a child plan in those processes that never execute it.</source>
          <target state="translated">때 &lt;code&gt;Append&lt;/code&gt; 노드가 병렬 계획에 사용되는 각 프로세스가 완료 될 때까지 모든 참여 프로세스가 첫 번째 자식 계획을 실행하기 위해 협력 그래서, 그들이 나타나는 순서대로 하위 계획을 실행하고 그 다음에 두 번째 계획으로 이동합니다 같은 시간에. 때 &lt;code&gt;Parallel Append&lt;/code&gt; 대신 사용됩니다, 집행자 대신 여러 하위 계획이 동시에 실행되도록 균등 하위 계획에서 가능한 한 참여 과정을 확산됩니다. 이렇게하면 경합을 피할 수 있으며이를 실행하지 않는 프로세스에서 하위 계획의 시작 비용을 지불하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="5e4864e701f86b03083b18f6c388ffa7cee629fe" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;INSERT&lt;/code&gt; command has an auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause, if the &lt;code&gt;UPDATE&lt;/code&gt; path is taken, the row to be updated is first checked against the &lt;code&gt;USING&lt;/code&gt; expressions of any &lt;code&gt;UPDATE&lt;/code&gt; policies, and then the new updated row is checked against the &lt;code&gt;WITH CHECK&lt;/code&gt; expressions. Note, however, that unlike a standalone &lt;code&gt;UPDATE&lt;/code&gt; command, if the existing row does not pass the &lt;code&gt;USING&lt;/code&gt; expressions, an error will be thrown (the &lt;code&gt;UPDATE&lt;/code&gt; path will &lt;em&gt;never&lt;/em&gt; be silently avoided).</source>
          <target state="translated">때 &lt;code&gt;INSERT&lt;/code&gt; 의 명령이 보조가 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절을 경우, &lt;code&gt;UPDATE&lt;/code&gt; 의 경로가 촬영되는 행이 먼저 확인됩니다 업데이트 할 &lt;code&gt;USING&lt;/code&gt; 어떤 표현 &lt;code&gt;UPDATE&lt;/code&gt; 정책 및 다음 새 업데이트 된 행이에 대해 확인 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현 . 그러나 독립형 &lt;code&gt;UPDATE&lt;/code&gt; 명령 과 달리 기존 행이 &lt;code&gt;USING&lt;/code&gt; 표현식을 전달하지 않으면 오류가 발생합니다 ( &lt;code&gt;UPDATE&lt;/code&gt; 경로는 자동으로 피할 수 &lt;em&gt;없습니다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="f5ddde61a4b6e8647a9abfe81db27fb6ec9b4388" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;N&lt;/code&gt;-dimensional array is pushed onto the beginning or end of an &lt;code&gt;N+1&lt;/code&gt;-dimensional array, the result is analogous to the element-array case above. Each &lt;code&gt;N&lt;/code&gt;-dimensional sub-array is essentially an element of the &lt;code&gt;N+1&lt;/code&gt;-dimensional array's outer dimension. For example:</source>
          <target state="translated">때 &lt;code&gt;N&lt;/code&gt; 차원 배열이 시작 또는 끝으로 푸시 &lt;code&gt;N+1&lt;/code&gt; 차원 배열의 결과는 상기 소자 배열의 경우와 유사하다. 각각의 &lt;code&gt;N&lt;/code&gt; 차원 서브 어레이는 본질적으로 &lt;code&gt;N+1&lt;/code&gt; 차원 어레이의 외부 차원의 요소이다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31260cf4fd42afa924c8ee13fbb974bf90d187b0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; command affects an inheritance hierarchy, the output might look like this:</source>
          <target state="translated">때 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 명령은 상속 계층 구조에 영향을 미치는, 출력은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="5c47d72e8415ae2214a0b4c8ffca096b8ee4f7c5" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">하위 쿼리에 집계식이 나타나는 경우 ( &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;4.2.11 &lt;/a&gt;&lt;a href=&quot;functions-subquery&quot;&gt;단원&lt;/a&gt; 및 9.22 섹션 참조 ) 집계는 일반적으로 하위 쿼리의 행에 대해 평가됩니다. 그러나 집계의 인수 (있는 경우 &lt;code&gt;filter_clause&lt;/code&gt; )에 외부 레벨 변수 만 포함 된 경우 예외가 발생합니다. 그런 다음 집계는 가장 가까운 외부 레벨에 속하며 해당 쿼리의 행에 대해 평가됩니다. 전체 집계 표현식은 하위 쿼리에 대한 외부 참조이며 해당 하위 쿼리에 대한 하나의 평가에 대해 상수 역할을합니다. 결과 목록 또는 &lt;code&gt;HAVING&lt;/code&gt; 절 에만 표시되는 것에 대한 제한 사항은 집계가 속한 쿼리 레벨과 관련하여 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3611155577957d7d62aaa216921a5999dd2f0cc2" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">집계 표현식이 하위 쿼리에 나타날 때 ( &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;섹션 4.2.11&lt;/a&gt; 및 &lt;a href=&quot;functions-subquery&quot;&gt;섹션 9.23 참조&lt;/a&gt; ) 집계는 일반적으로 하위 쿼리의 행에 대해 평가됩니다. 그러나 집계의 인수 (및있는 경우 &lt;code&gt;filter_clause&lt;/code&gt; )에 외부 수준 변수 만 포함 된 경우 예외가 발생 합니다. 그러면 집계는 가장 가까운 외부 수준에 속하고 해당 쿼리의 행에 대해 평가됩니다. 전체적으로 집계 식은 표시되는 하위 쿼리에 대한 외부 참조가되며 해당 하위 쿼리에 대한 하나의 평가에 대해 상수 역할을합니다. 결과 목록 또는 &lt;code&gt;HAVING&lt;/code&gt; 절 에만 표시되는 것에 대한 제한은 집계가 속한 쿼리 수준과 관련하여 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="34d2b87c80e1af3054e4c9d4d3c71d80a5607eb6" translate="yes" xml:space="preserve">
          <source>When an aggregate function is used as a window function, it aggregates over the rows within the current row's window frame. An aggregate used with &lt;code&gt;ORDER BY&lt;/code&gt; and the default window frame definition produces a &amp;ldquo;running sum&amp;rdquo; type of behavior, which may or may not be what's wanted. To obtain aggregation over the whole partition, omit &lt;code&gt;ORDER BY&lt;/code&gt; or use &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt;. Other frame specifications can be used to obtain other effects.</source>
          <target state="translated">집계 함수가 창 함수로 사용되면 현재 행의 창 프레임 내 행에 대해 집계됩니다. &lt;code&gt;ORDER BY&lt;/code&gt; 및 기본 창 프레임 정의와 함께 사용되는 집계 는 &quot;실행 합계&quot;유형의 동작을 생성하며, 원하는 유형일 수도 있고 아닐 수도 있습니다. 전체 파티션에 대한 집계를 얻으려면 &lt;code&gt;ORDER BY&lt;/code&gt; 를 생략 하거나 &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt; 사용하십시오 . 다른 프레임 사양을 사용하여 다른 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64b60eb6cf1570c88f1c1631b3c6e4c5824a2f8b" translate="yes" xml:space="preserve">
          <source>When an alias is applied to the output of a &lt;code&gt;JOIN&lt;/code&gt; clause, the alias hides the original name(s) within the &lt;code&gt;JOIN&lt;/code&gt;. For example:</source>
          <target state="translated">별명이 출력에 적용될 때 &lt;code&gt;JOIN&lt;/code&gt; (가)에서 절 별명 수피 원래 이름 (들) &lt;code&gt;JOIN&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0151521ad4c1bed3dd275586a7870760908f04a0" translate="yes" xml:space="preserve">
          <source>When an application receives this error message, it should abort the current transaction and retry the whole transaction from the beginning. The second time through, the transaction will see the previously-committed change as part of its initial view of the database, so there is no logical conflict in using the new version of the row as the starting point for the new transaction's update.</source>
          <target state="translated">응용 프로그램이이 오류 메시지를 받으면 현재 트랜잭션을 중단하고 전체 트랜잭션을 처음부터 다시 시도해야합니다. 두 번째로, 트랜잭션은 데이터베이스의 초기보기의 일부로 이전에 커밋 된 변경 사항을 볼 수 있으므로 새 버전의 행을 새 트랜잭션 업데이트의 시작점으로 사용하는 데 논리적 충돌이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ee9b3bf4967c5d2fb0d054d753f418145337cf0" translate="yes" xml:space="preserve">
          <source>When an enum type is created, its members are assigned sort-order positions 1..&lt;code&gt;n&lt;/code&gt;. But members added later might be given negative or fractional values of &lt;code&gt;enumsortorder&lt;/code&gt;. The only requirement on these values is that they be correctly ordered and unique within each enum type.</source>
          <target state="translated">열거 형이 작성되면 해당 멤버에는 정렬 순서 위치 1.가 지정됩니다. &lt;code&gt;n&lt;/code&gt; . 그러나 나중에 추가 된 멤버에는 &lt;code&gt;enumsortorder&lt;/code&gt; 의 음수 또는 분수 값이 제공 될 수 있습니다 . 이러한 값에 대한 유일한 요구 사항은 각 열거 형 유형 내에서 올바르게 정렬되고 고유해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0950043f7233c157a718d379ee2b34585d4ee731" translate="yes" xml:space="preserve">
          <source>When an index is declared unique, multiple table rows with equal indexed values are not allowed. Null values are not considered equal. A multicolumn unique index will only reject cases where all indexed columns are equal in multiple rows.</source>
          <target state="translated">인덱스가 고유 한 것으로 선언되면 인덱스 값이 동일한 여러 테이블 행이 허용되지 않습니다. 널값은 동일하지 않은 것으로 간주됩니다. 다중 열 고유 인덱스는 모든 인덱스 열이 여러 행에서 동일한 경우 만 거부합니다.</target>
        </trans-unit>
        <trans-unit id="4aa9424b6df0026312433f3f9260dd9161451961" translate="yes" xml:space="preserve">
          <source>When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page.</source>
          <target state="translated">인덱스 페이지 분할이 필요한 경우이 기능은 페이지의 어떤 항목이 이전 페이지에 남아 있고 어떤 항목이 새 페이지로 이동 할지를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d0d21498c252827ceaa7947111042a06bc38a5a5" translate="yes" xml:space="preserve">
          <source>When an index scan is used, a temporary copy of the table is created that contains the table data in the index order. Temporary copies of each index on the table are created as well. Therefore, you need free space on disk at least equal to the sum of the table size and the index sizes.</source>
          <target state="translated">인덱스 스캔이 사용되면 인덱스 순서로 테이블 데이터가 포함 된 테이블의 임시 사본이 작성됩니다. 테이블에서 각 인덱스의 임시 사본도 작성됩니다. 따라서 최소한 테이블 크기와 인덱스 크기의 합과 같은 디스크 여유 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dad624a33f1e64269d27c153de83dc5212addec4" translate="yes" xml:space="preserve">
          <source>When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, &lt;em&gt;privileges&lt;/em&gt; must be granted.</source>
          <target state="translated">객체가 생성되면 소유자에게 할당됩니다. 소유자는 일반적으로 작성 문을 실행 한 역할입니다. 대부분의 종류의 객체에서 초기 상태는 소유자 (또는 수퍼 유저)만이 객체로 무엇이든 할 수 있다는 것입니다. 다른 역할이이를 사용하려면 &lt;em&gt;권한&lt;/em&gt; 이 부여되어야합니다.</target>
        </trans-unit>
        <trans-unit id="016db50c093e11f2c3975978fc13dbb74ccca023" translate="yes" xml:space="preserve">
          <source>When an operator or function of the underlying type is applied to a domain value, the domain is automatically down-cast to the underlying type. Thus, for example, the result of &lt;code&gt;mytable.id - 1&lt;/code&gt; is considered to be of type &lt;code&gt;integer&lt;/code&gt; not &lt;code&gt;posint&lt;/code&gt;. We could write &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; to cast the result back to &lt;code&gt;posint&lt;/code&gt;, causing the domain's constraints to be rechecked. In this case, that would result in an error if the expression had been applied to an &lt;code&gt;id&lt;/code&gt; value of 1. Assigning a value of the underlying type to a field or variable of the domain type is allowed without writing an explicit cast, but the domain's constraints will be checked.</source>
          <target state="translated">기본 유형의 연산자 또는 기능이 도메인 값에 적용되면 도메인은 기본 유형으로 자동 다운 캐스트됩니다. 따라서, 예를 들어, 결과 &lt;code&gt;mytable.id - 1&lt;/code&gt; 타입의 것으로 간주된다 &lt;code&gt;integer&lt;/code&gt; 하지 &lt;code&gt;posint&lt;/code&gt; . 우리는 쓸 수 &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; 에 캐스팅 결과 다시 &lt;code&gt;posint&lt;/code&gt; 도메인의 제약 조건을 다시 검사하는 원인. 이 경우 표현식이 &lt;code&gt;id&lt;/code&gt; 값 1 에 적용된 경우 오류가 발생합니다. 기본 유형의 값을 도메인 유형의 필드 또는 변수에 지정하는 것은 명시 적 캐스트를 작성하지 않고 허용되지만 도메인의 구속 조건이 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="9d220c80b589197cba0d859444da322b0880222c" translate="yes" xml:space="preserve">
          <source>When archiving WAL data, we need to capture the contents of each segment file once it is filled, and save that data somewhere before the segment file is recycled for reuse. Depending on the application and the available hardware, there could be many different ways of &amp;ldquo;saving the data somewhere&amp;rdquo;: we could copy the segment files to an NFS-mounted directory on another machine, write them onto a tape drive (ensuring that you have a way of identifying the original name of each file), or batch them together and burn them onto CDs, or something else entirely. To provide the database administrator with flexibility, PostgreSQL tries not to make any assumptions about how the archiving will be done. Instead, PostgreSQL lets the administrator specify a shell command to be executed to copy a completed segment file to wherever it needs to go. The command could be as simple as a &lt;code&gt;cp&lt;/code&gt;, or it could invoke a complex shell script &amp;mdash; it's all up to you.</source>
          <target state="translated">WAL 데이터를 보관할 때는 각 세그먼트 파일의 내용이 채워지면 캡처하고 재사용을 위해 세그먼트 파일을 재활용하기 전에 해당 데이터를 어딘가에 저장해야합니다. 응용 프로그램 및 사용 가능한 하드웨어에 따라&amp;ldquo;어딘가에 데이터를 저장하는&amp;rdquo;방법에는 여러 가지가있을 수 있습니다. 세그먼트 파일을 다른 시스템의 NFS 마운트 디렉토리에 복사하여 테이프 드라이브에 기록 할 수 있습니다 ( 각 파일의 원래 이름을 식별하는 방법) 또는 함께 배치하여 CD 또는 다른 것으로 완전히 굽습니다. 데이터베이스 관리자에게 유연성을 제공하기 위해 PostgreSQL은 아카이브 수행 방법에 대한 어떠한 가정도하지 않습니다. 대신, 관리자는 PostgreSQL을 사용하여 완료된 세그먼트 파일을 필요한 곳으로 복사하기 위해 실행할 쉘 명령을 지정할 수 있습니다.명령은 다음과 같이 간단 할 수 있습니다. &lt;code&gt;cp&lt;/code&gt; 또는 복잡한 쉘 스크립트를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3d93c6ecb33c6eb94db27d2fba2d265ff994790" translate="yes" xml:space="preserve">
          <source>When autosummarization is enabled, each time a page range is filled a request is sent to autovacuum for it to execute a targeted summarization for that range, to be fulfilled at the end of the next worker run on the same database. If the request queue is full, the request is not recorded and a message is sent to the server log:</source>
          <target state="translated">자동 요약이 활성화되면 페이지 범위가 채워질 때마다 동일한 데이터베이스에서 다음 작업자 실행이 끝날 때 해당 범위에 대한 대상 요약이 실행되도록 요청이 autovacuum으로 전송됩니다. 요청 큐가 가득 찬 경우 요청이 기록되지 않고 서버 로그로 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f660851bc52c800a20554ffeb6a7df92726f03b4" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-b&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are given, the behavior is to output large objects, when data is being dumped, see the &lt;code&gt;-b&lt;/code&gt; documentation.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; 와 &lt;code&gt;-B&lt;/code&gt; 가 둘 다 주어지면, 데이터를 덤프 할 때 큰 오브젝트를 출력하는 것이 작동 합니다. &lt;code&gt;-b&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad45f5349fac03bd7966e305b187db06383f5ed7" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given for the same schema name, the &lt;code&gt;-N&lt;/code&gt; switch wins and the schema is excluded.</source>
          <target state="translated">두 경우 &lt;code&gt;-n&lt;/code&gt; 와 &lt;code&gt;-N&lt;/code&gt; 이 같은 스키마 이름 주어진다는 &lt;code&gt;-N&lt;/code&gt; 스위치 승 스키마는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="ede3b8af7caafd954943fe5f04f3a1cc429ba018" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given, the behavior is to dump just the schemas that match at least one &lt;code&gt;-n&lt;/code&gt; switch but no &lt;code&gt;-N&lt;/code&gt; switches. If &lt;code&gt;-N&lt;/code&gt; appears without &lt;code&gt;-n&lt;/code&gt;, then schemas matching &lt;code&gt;-N&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">두 경우 &lt;code&gt;-n&lt;/code&gt; 와 &lt;code&gt;-N&lt;/code&gt; 이 제공되며, 동작이 일치하는 적어도 하나 개의 단지 스키마를 덤프하는 것입니다 &lt;code&gt;-n&lt;/code&gt; 스위치하지만 &lt;code&gt;-N&lt;/code&gt; 스위치. 경우 &lt;code&gt;-N&lt;/code&gt; 나타납니다없이 &lt;code&gt;-n&lt;/code&gt; , 다음 스키마 일치 &lt;code&gt;-N&lt;/code&gt; 는 달리 일반 덤프 무엇에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="031547c5dfb59556734ca49134f210c68e4c5520" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-T&lt;/code&gt; are given, the behavior is to dump just the tables that match at least one &lt;code&gt;-t&lt;/code&gt; switch but no &lt;code&gt;-T&lt;/code&gt; switches. If &lt;code&gt;-T&lt;/code&gt; appears without &lt;code&gt;-t&lt;/code&gt;, then tables matching &lt;code&gt;-T&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">두 경우 &lt;code&gt;-t&lt;/code&gt; 및 &lt;code&gt;-T&lt;/code&gt; 가 주어진 동작이 일치하는 적어도 하나 개의 단지 테이블을 덤프하는 것입니다 &lt;code&gt;-t&lt;/code&gt; 스위치하지만 &lt;code&gt;-T&lt;/code&gt; 스위치. 경우 &lt;code&gt;-T&lt;/code&gt; 가 없이 나타납니다 &lt;code&gt;-t&lt;/code&gt; , 일치하는 다음 테이블 &lt;code&gt;-T&lt;/code&gt; 는 달리 일반 덤프 무엇에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="6e63ae1dfc17974e0be483ba0ff638bbea32a3b3" translate="yes" xml:space="preserve">
          <source>When casting from &lt;code&gt;EAN13&lt;/code&gt; to another type, there is a run-time check that the value is within the domain of the other type, and an error is thrown if not. The other casts are simply relabelings that will always succeed.</source>
          <target state="translated">&lt;code&gt;EAN13&lt;/code&gt; 에서 다른 유형으로 캐스트 할 때 값이 다른 유형의 도메인 내에 있는지 런타임 검사가 있으며 그렇지 않은 경우 오류가 발생합니다. 다른 캐스트는 단순히 성공할 레이블을 다시 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b112e4a8b6a5ae3071dcef7339526c0bc3d3e45" translate="yes" xml:space="preserve">
          <source>When changing this value, consider also adjusting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;.</source>
          <target state="translated">이 값을 변경할 때 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; 조정도 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="db437265a89a8152322953823332b5732e1c0d00" translate="yes" xml:space="preserve">
          <source>When choosing OIDs for a patch that is not expected to be committed immediately, best practice is to use a group of more-or-less consecutive OIDs starting with some random choice in the range 8000&amp;mdash;9999. This minimizes the risk of OID collisions with other patches being developed concurrently. To keep the 8000&amp;mdash;9999 range free for development purposes, after a patch has been committed to the master git repository its OIDs should be renumbered into available space below that range. Typically, this will be done near the end of each development cycle, moving all OIDs consumed by patches committed in that cycle at the same time. The script &lt;code&gt;renumber_oids.pl&lt;/code&gt; can be used for this purpose. If an uncommitted patch is found to have OID conflicts with some recently-committed patch, &lt;code&gt;renumber_oids.pl&lt;/code&gt; may also be useful for recovering from that situation.</source>
          <target state="translated">즉시 커밋되지 않을 패치에 대해 OID를 선택할 때 가장 좋은 방법은 8000-9999 범위에서 임의의 선택으로 시작하여 다소 연속적인 OID 그룹을 사용하는 것입니다. 이렇게하면 다른 패치와 동시에 개발되는 OID 충돌의 위험이 최소화됩니다. 개발 목적으로 8000-9999 범위를 자유롭게 유지하려면 패치가 마스터 git 저장소에 커밋 된 후 OID의 번호가 해당 범위 아래의 사용 가능한 공간으로 다시 지정되어야합니다. 일반적으로 이는 각 개발주기가 끝날 무렵에 수행되어 해당주기에서 커밋 된 패치가 소비하는 모든 OID를 동시에 이동합니다. &lt;code&gt;renumber_oids.pl&lt;/code&gt; 스크립트 를이 목적으로 사용할 수 있습니다. 커밋되지 않은 패치가 최근에 커밋 된 패치와 OID 충돌이있는 것으로 확인되면 &lt;code&gt;renumber_oids.pl&lt;/code&gt; 해당 상황에서 복구하는 데 유용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9881b7b2a51c119b916b26c12b2f50a595bc868b" translate="yes" xml:space="preserve">
          <source>When compiled with OpenSSL, there will be more algorithms available. Also public-key encryption functions will be faster as OpenSSL has more optimized BIGNUM functions.</source>
          <target state="translated">OpenSSL로 컴파일하면 더 많은 알고리즘을 사용할 수 있습니다. 또한 OpenSSL에 최적화 된 BIGNUM 기능이 있으므로 공개 키 암호화 기능이 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="5f2a4f35ae5e876b04f4e8702b5ef942899c0855" translate="yes" xml:space="preserve">
          <source>When compiled with zlib, PGP encryption functions are able to compress data before encrypting.</source>
          <target state="translated">zlib로 컴파일하면 PGP 암호화 기능은 암호화 전에 데이터를 압축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4526356cc9d2b5524d1c0613a2cac8e5545975fc" translate="yes" xml:space="preserve">
          <source>When compiling the preprocessed C code files, the compiler needs to be able to find the ECPG header files in the PostgreSQL include directory. Therefore, you might have to use the &lt;code&gt;-I&lt;/code&gt; option when invoking the compiler (e.g., &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt;).</source>
          <target state="translated">사전 처리 된 C 코드 파일을 컴파일 할 때 컴파일러는 PostgreSQL 포함 디렉토리에서 ECPG 헤더 파일을 찾을 수 있어야합니다. 따라서 컴파일러를 호출 할 때 &lt;code&gt;-I&lt;/code&gt; 옵션 을 사용해야 할 수도 있습니다 (예 : &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6cfdda77ce1539f64bc346b96c3160b7466725a" translate="yes" xml:space="preserve">
          <source>When computing the selectivity for a query involving functionally dependent columns, the planner adjusts the per-condition selectivity estimates using the dependency coefficients so as not to produce an underestimate.</source>
          <target state="translated">기능적으로 종속 된 열이 포함 된 쿼리에 대한 선택성을 계산할 때 플래너는 과소 평가를 생성하지 않도록 종속성 계수를 사용하여 조건 별 선택성 추정치를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="29ea042e28fa2362fa9c26ca7e49e9bd0ec5e906" translate="yes" xml:space="preserve">
          <source>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name &lt;code&gt;fred&lt;/code&gt;, principal &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; would be able to connect. To also allow principal &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt;, use a user name map, as described in &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;.</source>
          <target state="translated">데이터베이스에 연결할 때 요청 된 데이터베이스 사용자 이름과 일치하는 프린시 펄에 대한 티켓이 있는지 확인하십시오. 예를 들어, 데이터베이스 사용자 이름 &lt;code&gt;fred&lt;/code&gt; 의 경우 프린시 &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; 을 연결할 수 있습니다. 프린시 &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt; 을 허용하려면 &lt;a href=&quot;auth-username-maps&quot;&gt;섹션 20.2에&lt;/a&gt; 설명 된대로 사용자 이름 맵을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fb2d529ca9e4c06995d0fca116b867907b7f0d6" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify in its connection request the name of the database it wants to connect to. It is not possible to access more than one database per connection. However, an application is not restricted in the number of connections it opens to the same or other databases. Databases are physically separated and access control is managed at the connection level. If one PostgreSQL server instance is to house projects or users that should be separate and for the most part unaware of each other, it is therefore recommended to put them into separate databases. If the projects or users are interrelated and should be able to use each other's resources, they should be put in the same database but possibly into separate schemas. Schemas are a purely logical structure and who can access what is managed by the privilege system. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 서버에 연결할 때 클라이언트는 연결 요청에서 연결할 데이터베이스 이름을 지정해야합니다. 연결 당 둘 이상의 데이터베이스에 액세스 할 수 없습니다. 그러나 응용 프로그램은 동일하거나 다른 데이터베이스에 열려있는 연결 수에 제한이 없습니다. 데이터베이스는 물리적으로 분리되어 있으며 액세스 제어는 연결 수준에서 관리됩니다. 하나의 PostgreSQL 서버 인스턴스가 분리되어야하고 대부분 서로를 알지 못하는 프로젝트 나 사용자를 수용하는 경우 별도의 데이터베이스에 배치하는 것이 좋습니다. 프로젝트 또는 사용자가 서로 관련되어 있고 서로의 리소스를 사용할 수 있어야하는 경우 동일한 데이터베이스에 배치되지만 별도의 스키마에 있어야합니다.스키마는 순전히 논리적 인 구조이며 권한 시스템이 관리하는 것에 액세스 할 수있는 사람입니다. 스키마 관리에 대한 자세한 정보는&lt;a href=&quot;ddl-schemas&quot;&gt;섹션 5.9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b02ea043cf0c79a30fc9e7d7d2f7eb7a91ce38" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify the database name in its connection request. It is not possible to access more than one database per connection. However, clients can open multiple connections to the same database, or different databases. Database-level security has two components: access control (see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;), managed at the connection level, and authorization control (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;), managed via the grant system. Foreign data wrappers (see &lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt;) allow for objects within one database to act as proxies for objects in other database or clusters. The older dblink module (see &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt;) provides a similar capability. By default, all users can connect to all databases using all connection methods.</source>
          <target state="translated">데이터베이스 서버에 연결할 때 클라이언트는 연결 요청에 데이터베이스 이름을 지정해야합니다. 연결 당 둘 이상의 데이터베이스에 액세스 할 수 없습니다. 그러나 클라이언트는 동일한 데이터베이스 또는 다른 데이터베이스에 대한 여러 연결을 열 수 있습니다. 데이터베이스 수준 보안에는 연결 수준에서 관리되는 액세스 제어 ( &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;섹션 20.1&lt;/a&gt; 참조 )와 권한 부여 시스템을 통해 관리되는 권한 제어 ( &lt;a href=&quot;ddl-priv&quot;&gt;섹션 5.7&lt;/a&gt; 참조)의 두 가지 구성 요소가 있습니다. 외부 데이터 래퍼 ( &lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt; 참조 )를 사용하면 한 데이터베이스 내의 개체가 다른 데이터베이스 또는 클러스터의 개체에 대한 프록시 역할을 할 수 있습니다. 이전 dblink 모듈 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; 참조 )은 유사한 기능을 제공합니다. 기본적으로 모든 사용자는 모든 연결 방법을 사용하여 모든 데이터베이스에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12d0d4ecddcc515b05d012f2d76c53d27fb85b80" translate="yes" xml:space="preserve">
          <source>When continuous WAL archiving is used in a standby, there are two different scenarios: the WAL archive can be shared between the primary and the standby, or the standby can have its own WAL archive. When the standby has its own WAL archive, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt;, and the standby will call the archive command for every WAL segment it receives, whether it's by restoring from the archive or by streaming replication. The shared archive can be handled similarly, but the &lt;code&gt;archive_command&lt;/code&gt; must test if the file being archived exists already, and if the existing file has identical contents. This requires more care in the &lt;code&gt;archive_command&lt;/code&gt;, as it must be careful to not overwrite an existing file with different contents, but return success if the exactly same file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive the same file at the same time.</source>
          <target state="translated">대기에서 연속 WAL 보관을 사용하는 경우 두 가지 시나리오가 있습니다. WAL 보관은 기본 및 대기간에 공유되거나 대기에는 자체 WAL 보관이있을 수 있습니다. 대기에 자체 WAL 아카이브가있는 경우 &lt;code&gt;archive_mode&lt;/code&gt; 를 &lt;code&gt;always&lt;/code&gt; 로 설정 하면 대기는 아카이브에서 복원하거나 스트리밍 복제를 통해 수신하는 모든 WAL 세그먼트에 대해 archive 명령을 호출합니다. 공유 아카이브는 비슷하게 처리 할 수 ​​있지만 &lt;code&gt;archive_command&lt;/code&gt; 는 아카이브중인 파일이 이미 존재하는지와 기존 파일의 내용이 동일한 지 테스트해야합니다. &lt;code&gt;archive_command&lt;/code&gt; 에서 더주의해야합니다.내용이 다른 기존 파일을 덮어 쓰지 않도록주의해야하지만 정확히 동일한 파일이 두 번 아카이브되면 성공을 리턴합니다. 두 서버가 동일한 파일을 동시에 아카이브하려고 시도하는 경우 경쟁 조건이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="206b825e98c6a586acace075380fd147e6696a55" translate="yes" xml:space="preserve">
          <source>When converting textual JSON input into &lt;code&gt;jsonb&lt;/code&gt;, the primitive types described by RFC 7159 are effectively mapped onto native PostgreSQL types, as shown in &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;Table 8.23&lt;/a&gt;. Therefore, there are some minor additional constraints on what constitutes valid &lt;code&gt;jsonb&lt;/code&gt; data that do not apply to the &lt;code&gt;json&lt;/code&gt; type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, &lt;code&gt;jsonb&lt;/code&gt; will reject numbers that are outside the range of the PostgreSQL &lt;code&gt;numeric&lt;/code&gt; data type, while &lt;code&gt;json&lt;/code&gt; will not. Such implementation-defined restrictions are permitted by RFC 7159. However, in practice such problems are far more likely to occur in other implementations, as it is common to represent JSON's &lt;code&gt;number&lt;/code&gt; primitive type as IEEE 754 double precision floating point (which RFC 7159 explicitly anticipates and allows for). When using JSON as an interchange format with such systems, the danger of losing numeric precision compared to data originally stored by PostgreSQL should be considered.</source>
          <target state="translated">텍스트 JSON 입력을 &lt;code&gt;jsonb&lt;/code&gt; 로 변환 할 때 RFC 7159에 설명 된 기본 유형은 &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;표 8.23에&lt;/a&gt; 표시된대로 기본 PostgreSQL 유형에 효과적으로 맵핑 됩니다. 따라서 &lt;code&gt;json&lt;/code&gt; 유형에 적용되지 않는 유효한 &lt;code&gt;jsonb&lt;/code&gt; 데이터를 구성하는 요소와 추상 데이터의 JSON에는 기본 데이터 유형으로 표시 할 수있는 항목의 한계에 해당하는 약간의 추가 제한 사항 이 있습니다. 특히 &lt;code&gt;jsonb&lt;/code&gt; 는 PostgreSQL &lt;code&gt;numeric&lt;/code&gt; 데이터 유형 의 범위를 벗어난 숫자를 거부 하지만 &lt;code&gt;json&lt;/code&gt; 은하지 않을 것이다. 이러한 구현 정의 된 제한은 RFC 7159에 의해 허용됩니다. 그러나 실제로 이러한 문제는 다른 구현에서 발생할 가능성이 훨씬 높습니다 .JSON의 &lt;code&gt;number&lt;/code&gt; 기본 유형을 IEEE 754 배정 밀도 부동 소수점 (RFC 7159가 명시 적으로 예상 함)으로 나타내는 것이 일반적이기 때문입니다. 허용). 이러한 시스템에서 JSON을 교환 형식으로 사용하는 경우 원래 PostgreSQL에 저장된 데이터와 비교할 때 숫자 정밀도가 손실 될 위험이 고려되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e063ec55d6b5085c54d075810d580142922489d3" translate="yes" xml:space="preserve">
          <source>When creating a comment on a constraint, a trigger, a rule or a policy these parameters specify the name of the table or domain on which that object is defined.</source>
          <target state="translated">제한 조건, 트리거, 규칙 또는 정책에 대한 주석을 작성할 때이 매개 변수는 해당 오브젝트가 정의 된 테이블 또는 도메인의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="696e17ed5a7d60938c1cece83fb1d6b1c0903390" translate="yes" xml:space="preserve">
          <source>When creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.</source>
          <target state="translated">해시 파티션을 만들 때 모듈러스와 나머지를 지정해야합니다. 모듈러스는 양의 정수 여야하고 나머지는 모듈러스보다 작은 음이 아닌 정수 여야합니다. 일반적으로 해시 파티션 된 테이블을 처음 설정할 때 파티션 수와 동일한 모듈러스를 선택하고 모든 테이블에 동일한 모듈러스와 다른 나머지를 지정해야합니다 (아래 예 참조). 그러나 모든 파티션이 동일한 계수를 가질 필요는 없으며, 해시 파티션 된 테이블의 파티션 중 발생하는 모든 계수는 다음으로 큰 계수의 요소 일뿐입니다. 따라서 모든 데이터를 한 번에 이동할 필요없이 파티션 수를 증 분식으로 늘릴 수 있습니다. 예를 들어, 8 개의 파티션을 가진 해시 파티션 된 테이블이 있고 각 파티션에는 모듈러스가 8이라고 가정합니다.모듈 수 8 파티션 중 하나를 분리하고 키 공간의 동일한 부분을 차지하는 두 개의 새로운 모듈 수 16 파티션을 생성 할 수 있습니다 (하나는 나머지는 나머지와 동일 함). 분리 된 파티션, 나머지는 그 값에 8을 더한 값을 더한 8)로 나누고 데이터로 다시 채 웁니다. 그런 다음 아무 것도 남지 않을 때까지 각 계수 -8 파티션에 대해이 작업을 나중에 다시 반복 할 수 있습니다. 여기에는 각 단계에서 여전히 많은 양의 데이터 이동이 포함될 수 있지만 완전히 새로운 테이블을 작성하고 모든 데이터를 한 번에 이동하는 것보다 낫습니다.나머지는 그 값에 8을 더한 나머지 8), 데이터로 다시 채 웁니다. 그런 다음 아무 것도 남지 않을 때까지 각 계수 -8 파티션에 대해이 작업을 나중에 다시 반복 할 수 있습니다. 여기에는 각 단계에서 여전히 많은 양의 데이터 이동이 포함될 수 있지만 완전히 새로운 테이블을 작성하고 모든 데이터를 한 번에 이동하는 것보다 낫습니다.나머지는 그 값에 8을 더한 나머지 8), 데이터로 다시 채 웁니다. 그런 다음 아무 것도 남지 않을 때까지 각 계수 -8 파티션에 대해이 작업을 나중에 다시 반복 할 수 있습니다. 여기에는 각 단계에서 여전히 많은 양의 데이터 이동이 포함될 수 있지만 완전히 새로운 테이블을 작성하고 모든 데이터를 한 번에 이동하는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="dc592c55de3b2852cc094ece1e21e03a790645cd" translate="yes" xml:space="preserve">
          <source>When creating a list partition, &lt;code&gt;NULL&lt;/code&gt; can be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table. &lt;code&gt;NULL&lt;/code&gt; cannot be specified for range partitions.</source>
          <target state="translated">목록 파티션을 작성할 때 파티션 키 파티션이 &lt;code&gt;NULL&lt;/code&gt; 이 될 수 있음을 나타 내기 위해 NULL을 지정할 수 있습니다. 그러나 주어진 상위 테이블에 대해 그러한 목록 파티션을 두 개 이상 가질 수는 없습니다. 범위 파티션에 &lt;code&gt;NULL&lt;/code&gt; 을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="959c4be92ae7a89cd93733c9fb53bfb204d0cf54" translate="yes" xml:space="preserve">
          <source>When creating a range partition involving more than one column, it can also make sense to use &lt;code&gt;MAXVALUE&lt;/code&gt; as part of the lower bound, and &lt;code&gt;MINVALUE&lt;/code&gt; as part of the upper bound. For example, a partition defined using &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined using &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; allows any rows where the first partition key column starts with &quot;a&quot;.</source>
          <target state="translated">둘 이상의 열을 포함하는 범위 파티션을 작성할 때 &lt;code&gt;MAXVALUE&lt;/code&gt; 를 하한의 일부로 사용 하고 &lt;code&gt;MINVALUE&lt;/code&gt; 를 상한의 일부로 사용하는 것이 좋습니다. 예를 들어, &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; 사용하여 정의 된 파티션 은 첫 번째 파티션 키 열이 0보다 크고 10보다 작거나 같은 모든 행을 허용합니다. 마찬가지로, &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; 는 첫 번째 파티션 키 열이 &quot;a&quot;로 시작하는 모든 행을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="57bc08d42f10eaae11d2af1199ad3605b863277f" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">범위 파티션을 작성할 때 &lt;code&gt;FROM&lt;/code&gt; 으로 지정된 하한 은 포함 범위이고 &lt;code&gt;TO&lt;/code&gt; 로 지정된 상한 은 배타적입니다. 즉, &lt;code&gt;FROM&lt;/code&gt; 목록에 지정된 값은이 파티션에 해당하는 파티션 키 열의 유효한 값이지만 &lt;code&gt;TO&lt;/code&gt; 목록의 값은 유효 하지 않습니다. 이 문장은 행 단위 비교 규칙 ( &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;9.23.5 절&lt;/a&gt; ) 에 따라 이해되어야합니다 . 예를 들어 &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; 가 주어지면 파티션 바운드 &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; 는 &lt;code&gt;x=1&lt;/code&gt; 은 &lt;code&gt;y&amp;gt;=2&lt;/code&gt; 이고 &lt;code&gt;x=2&lt;/code&gt; 는 null이 아닌 &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;x=3&lt;/code&gt; 임의와 &lt;code&gt;y&amp;lt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7765f2e543f0af71f77765315c7b66c2db81da2" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">범위 파티션을 만들 때 &lt;code&gt;FROM&lt;/code&gt; 으로 지정된 하한 은 포함 범위이고 &lt;code&gt;TO&lt;/code&gt; 로 지정된 상한 은 배타적 범위입니다. 즉, &lt;code&gt;FROM&lt;/code&gt; 목록에 지정된 값은이 파티션에 대한 해당 파티션 키 열의 유효한 값이지만 &lt;code&gt;TO&lt;/code&gt; 목록에있는 값은 그렇지 않습니다. 이 설명은 &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;행별&lt;/a&gt; 비교 규칙 ( 섹션 9.24.5 ) 에 따라 이해되어야합니다 . 예를 들어, 소정의 &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; , 결합 분할 &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; 허용 &lt;code&gt;x=1&lt;/code&gt; 하나와 &lt;code&gt;y&amp;gt;=2&lt;/code&gt; , &lt;code&gt;x=2&lt;/code&gt; 비 - 널과 &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;x=3&lt;/code&gt; 임의와 &lt;code&gt;y&amp;lt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="812122c3d99be13340fb205c1949bf12eabae44b" translate="yes" xml:space="preserve">
          <source>When creating a replication slot (the default behavior), &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">복제 슬롯을 만들 때 (기본 동작) 트랜잭션 블록 안에서 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="de7cd6bf9e49c5d84cc8863ddd6e1c17c3e9e579" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">슬롯을 만들 때 지정된 논리적 디코딩 출력 플러그인을 사용하십시오. &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장을&lt;/a&gt; 참조하십시오 . 슬롯이 이미 존재하는 경우이 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1423e49aad04fb2810f02511e3e72b04f513e2b2" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">슬롯을 생성 할 때 지정된 논리적 디코딩 출력 플러그인을 사용하십시오. &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;48 장을&lt;/a&gt; 참조하십시오 . 이 옵션은 슬롯이 이미 존재하는 경우 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="005a2c498e4cc6e0542ca9414edc2d0ef17812bb" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the remote host is not reachable or in an unclear state. In that case, the subscription can be created using the &lt;code&gt;connect = false&lt;/code&gt; option. The remote host will then not be contacted at all. This is what pg_dump uses. The remote replication slot will then have to be created manually before the subscription can be activated.</source>
          <target state="translated">구독을 만들 때 원격 호스트에 연결할 수 없거나 불분명 한 상태가 아닙니다. 이 경우, &lt;code&gt;connect = false&lt;/code&gt; 옵션을 사용하여 구독을 작성할 수 있습니다 . 그러면 원격 호스트에 전혀 연결되지 않습니다. 이것이 pg_dump가 사용하는 것입니다. 그러면 구독을 활성화하기 전에 원격 복제 슬롯을 수동으로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="34ca2fb6b711dd16e241f960cfce7ef591df396f" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the replication slot already exists. In that case, the subscription can be created using the &lt;code&gt;create_slot = false&lt;/code&gt; option to associate with the existing slot.</source>
          <target state="translated">가입을 생성 할 때 복제 슬롯이 이미 존재합니다. 이 경우 기존 슬롯과 연관시키기 위해 &lt;code&gt;create_slot = false&lt;/code&gt; 옵션을 사용하여 구독을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16abed6745cbdfc58355b822cc58590cd4574664" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the number of partitions on which the index has been completed.</source>
          <target state="translated">파티션 된 테이블에서 인덱스를 작성할 때이 열은 인덱스가 완료된 파티션 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0cf84112606c62d754e9e14623f4cabe94d1c440" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the total number of partitions on which the index is to be created.</source>
          <target state="translated">파티션 된 테이블에서 인덱스를 작성할 때이 컬럼은 인덱스를 작성할 총 파티션 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0f225feca5ba0ff2fa1c5fa9fb76ca1ce05ad30d" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, a &lt;code&gt;choose&lt;/code&gt; result of &lt;code&gt;spgMatchNode&lt;/code&gt; is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied &lt;code&gt;nodeN&lt;/code&gt; value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since that would make the nodes not all equivalent; the &lt;code&gt;spgSplitTuple&lt;/code&gt; action must be used if the value to be inserted doesn't match the existing nodes.</source>
          <target state="translated">를 다룰 때 &lt;code&gt;allTheSame&lt;/code&gt; 의 튜플, a는 &lt;code&gt;choose&lt;/code&gt; 의 결과 &lt;code&gt;spgMatchNode&lt;/code&gt; 가 새로운 값이 해당 노드 중 하나에 할당 할 수 있음을 의미하는 것으로 해석된다; 코어 코드는 제공된 &lt;code&gt;nodeN&lt;/code&gt; 값을 무시하고 임의로 노드 중 하나로 내려갑니다 (트리 균형을 유지하기 위해). &lt;code&gt;spgAddNode&lt;/code&gt; 를 리턴 &lt;code&gt;choose&lt;/code&gt; 하면 오류가 발생 하는데 , 이는 노드가 모두 동일하지는 않기 때문입니다. &lt;code&gt;spgSplitTuple&lt;/code&gt; 의 값이 기존 노드와 일치하지 않는 삽입 할 경우 작업을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc81dfaf2529806492d6926ee92f707f3d6c4c1b" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, the &lt;code&gt;inner_consistent&lt;/code&gt; function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the &lt;code&gt;inner_consistent&lt;/code&gt; function normally assumes about the meaning of the nodes.</source>
          <target state="translated">&lt;code&gt;allTheSame&lt;/code&gt; 튜플을 처리 할 때 &lt;code&gt;inner_consistent&lt;/code&gt; 함수는 노드가 모두 동일하므로 인덱스 검색을 계속하기위한 대상으로 노드를 모두 또는 전혀 반환하지 않아야합니다. &lt;code&gt;inner_consistent&lt;/code&gt; 함수가 일반적으로 노드의 의미에 대해 얼마나 많이 가정 하는지에 따라 특수 코드가 필요할 수도 있고 필요하지 않을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b32b90019e8bbf81fee22cbcc2778aa7cfddfd6c" translate="yes" xml:space="preserve">
          <source>When dealing with multiple-argument aggregate functions, note that the &lt;code&gt;ORDER BY&lt;/code&gt; clause goes after all the aggregate arguments. For example, write this:</source>
          <target state="translated">다중 인수 집계 함수를 처리 할 때 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 모든 집계 인수 뒤에옵니다. 예를 들어 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ec8f5c244f8f3ee5e69ba2a3cc1d82f9a3714553" translate="yes" xml:space="preserve">
          <source>When dealing with outer joins, you might see join plan nodes with both &amp;ldquo;Join Filter&amp;rdquo; and plain &amp;ldquo;Filter&amp;rdquo; conditions attached. Join Filter conditions come from the outer join's &lt;code&gt;ON&lt;/code&gt; clause, so a row that fails the Join Filter condition could still get emitted as a null-extended row. But a plain Filter condition is applied after the outer-join rules and so acts to remove rows unconditionally. In an inner join there is no semantic difference between these types of filters.</source>
          <target state="translated">외부 조인을 처리 할 때&amp;ldquo;조인 필터&amp;rdquo;와 일반&amp;ldquo;필터&amp;rdquo;조건이 모두 연결된 조인 계획 노드가 표시 될 수 있습니다. 조인 필터 조건은 외부 조인의 &lt;code&gt;ON&lt;/code&gt; 절에서 가져 오므로 조인 필터 조건에 실패한 행은 여전히 ​​널 확장 행으로 생성 될 수 있습니다. 그러나 일반 조인 조건은 외부 조인 규칙 뒤에 적용되므로 무조건 행을 제거하는 역할을합니다. 내부 조인에서는 이러한 유형의 필터간에 의미 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a4bff252219a510e2ce0b73debb16a2f8ba45f1" translate="yes" xml:space="preserve">
          <source>When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: &lt;code&gt;bb*&lt;/code&gt; matches the three middle characters of &lt;code&gt;abbbc&lt;/code&gt;; &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; matches all ten characters of &lt;code&gt;weeknights&lt;/code&gt;; when &lt;code&gt;(.*).*&lt;/code&gt; is matched against &lt;code&gt;abc&lt;/code&gt; the parenthesized subexpression matches all three characters; and when &lt;code&gt;(a*)*&lt;/code&gt; is matched against &lt;code&gt;bc&lt;/code&gt; both the whole RE and the parenthesized subexpression match an empty string.</source>
          <target state="translated">더 길거나 더 짧은 일치 항목을 결정할 때 일치 길이는 요소를 대조하지 않고 문자로 측정됩니다. 빈 문자열은 전혀 일치하지 않는 것으로 간주됩니다. 예를 들어, &lt;code&gt;bb*&lt;/code&gt; 는 &lt;code&gt;abbbc&lt;/code&gt; 의 세 중간 문자와 일치합니다 . &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; 모두 10 자와 일치 &lt;code&gt;weeknights&lt;/code&gt; ; 시 &lt;code&gt;(.*).*&lt;/code&gt; 에 대해 일치 &lt;code&gt;abc&lt;/code&gt; 괄호 표현식은 세 개의 문자와 일치; 때 &lt;code&gt;(a*)*&lt;/code&gt; 에 대해 일치 &lt;code&gt;bc&lt;/code&gt; 전체 RE와 괄호 표현식 모두 빈 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="158e24683a0dfaf92eb2d2d99535563f16d12035" translate="yes" xml:space="preserve">
          <source>When defining a path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similarly to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">경로를 정의 할 때 SQL 의 &lt;code&gt;WHERE&lt;/code&gt; 절 과 유사하게 작동 하는 하나 이상의 &lt;em&gt;필터 표현식&lt;/em&gt; 을 사용할 수도 있습니다 . 필터 표현식은 물음표로 시작하고 괄호 안에 조건을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f51f30bba3581f1e69eb69eac04311486d90890a" translate="yes" xml:space="preserve">
          <source>When defining the path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similar to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">경로를 정의 할 때 SQL 의 &lt;code&gt;WHERE&lt;/code&gt; 절 과 유사한 하나 이상의 &lt;em&gt;필터 표현식&lt;/em&gt; 을 사용할 수도 있습니다 . 필터 표현식은 물음표로 시작하고 괄호 안에 조건을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="359ea83f4fdb1b7fa655731f901be35273bbf743" translate="yes" xml:space="preserve">
          <source>When dropping a subscription that is associated with a replication slot on the remote host (the normal state), &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will connect to the remote host and try to drop the replication slot as part of its operation. This is necessary so that the resources allocated for the subscription on the remote host are released. If this fails, either because the remote host is not reachable or because the remote replication slot cannot be dropped or does not exist or never existed, the &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; command will fail. To proceed in this situation, disassociate the subscription from the replication slot by executing &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt;. After that, &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will no longer attempt any actions on a remote host. Note that if the remote replication slot still exists, it should then be dropped manually; otherwise it will continue to reserve WAL and might eventually cause the disk to fill up. See also &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;Section 30.2.1&lt;/a&gt;.</source>
          <target state="translated">원격 호스트의 복제 슬롯 (정상 상태)과 관련된 구독을 삭제하면 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 이 원격 호스트에 연결하고 작업의 일부로 복제 슬롯을 삭제하려고 시도합니다. 이는 원격 호스트에서 구독에 할당 된 자원이 해제되도록하는 데 필요합니다. 원격 호스트에 도달 할 수 없거나 원격 복제 슬롯을 삭제할 수 없거나 존재하지 않거나 존재하지 않기 때문에이 작업 이 실패 하면 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 명령이 실패합니다. 이 상황을 진행하려면 &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt; 을 실행하여 구독을 복제 슬롯에서 연결 해제하십시오 . 그 후 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 더 이상 원격 호스트에서 조치를 시도하지 않습니다. 원격 복제 슬롯이 여전히 존재하면 수동으로 삭제해야합니다. 그렇지 않으면 WAL이 계속 예약되어 결국 디스크가 가득 찰 수 있습니다. &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;섹션 30.2.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="16b8b09fc04797b1f4bd77cb938d65220f3c98d4" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the remote host is not reachable. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription. If the remote database instance no longer exists, no further action is then necessary. If, however, the remote database instance is just unreachable, the replication slot should then be dropped manually; otherwise it would continue to reserve WAL and might eventually cause the disk to fill up. Such cases should be carefully investigated.</source>
          <target state="translated">구독을 삭제하면 원격 호스트에 연결할 수 없습니다. 이 경우 구독 을 삭제하기 전에 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; 을 사용하여 구독에서 슬롯을 분리하십시오 . 원격 데이터베이스 인스턴스가 더 이상 존재하지 않으면 추가 조치가 필요하지 않습니다. 그러나 원격 데이터베이스 인스턴스에 도달 할 수없는 경우 복제 슬롯을 수동으로 삭제해야합니다. 그렇지 않으면 WAL이 계속 예약되어 결국 디스크가 가득 찰 수 있습니다. 이러한 경우를 면밀히 조사해야합니다.</target>
        </trans-unit>
        <trans-unit id="aef261ef51923658a5c92b355545488277ab638d" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the replication slot should be kept. This could be useful when the subscriber database is being moved to a different host and will be activated from there. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription.</source>
          <target state="translated">구독을 삭제할 때 복제 슬롯을 유지해야합니다. 이는 구독자 데이터베이스가 다른 호스트로 이동되고 거기서 활성화 될 때 유용 할 수 있습니다. 이 경우 구독 을 삭제하기 전에 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; 을 사용하여 구독에서 슬롯을 분리하십시오 .</target>
        </trans-unit>
        <trans-unit id="7012bb7adb09426a92f880209bcb563fe9379138" translate="yes" xml:space="preserve">
          <source>When dumping data for a table partition, make the &lt;code&gt;COPY&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt; statements target the root of the partitioning hierarchy that contains it, rather than the partition itself. This causes the appropriate partition to be re-determined for each row when the data is loaded. This may be useful when reloading data on a server where rows do not always fall into the same partitions as they did on the original server. That could happen, for example, if the partitioning column is of type text and the two systems have different definitions of the collation used to sort the partitioning column.</source>
          <target state="translated">테이블 파티션에 대한 데이터를 덤프 할 때 &lt;code&gt;COPY&lt;/code&gt; 또는 &lt;code&gt;INSERT&lt;/code&gt; 문이 파티션 자체가 아니라이를 포함하는 파티션 계층의 루트를 대상으로하십시오. 이로 인해 데이터가로드 될 때 각 행에 대해 적절한 파티션이 다시 결정됩니다. 이것은 행이 항상 원래 서버에서와 동일한 파티션에 속하지 않는 서버에서 데이터를 다시로드 할 때 유용 할 수 있습니다. 예를 들어, 파티션 컬럼이 텍스트 유형이고 두 시스템이 파티션 컬럼을 정렬하는 데 사용되는 조합의 정의가 다른 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c4665e18254fa2583d0b9a6ca4200ef73e4faf" translate="yes" xml:space="preserve">
          <source>When dumping logical replication subscriptions, pg_dump will generate &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; commands that use the &lt;code&gt;connect = false&lt;/code&gt; option, so that restoring the subscription does not make remote connections for creating a replication slot or for initial table copy. That way, the dump can be restored without requiring network access to the remote servers. It is then up to the user to reactivate the subscriptions in a suitable way. If the involved hosts have changed, the connection information might have to be changed. It might also be appropriate to truncate the target tables before initiating a new full table copy.</source>
          <target state="translated">논리적 복제 구독을 덤프 할 때 pg_dump는 &lt;code&gt;connect = false&lt;/code&gt; 옵션 을 사용하는 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 명령을 생성 하므로 구독을 복원해도 복제 슬롯을 만들거나 초기 테이블 복사를 위해 원격으로 연결되지 않습니다. 이렇게하면 원격 서버에 대한 네트워크 액세스없이 덤프를 복원 할 수 있습니다. 그러면 적절한 방식으로 구독을 재 활성화하는 것은 사용자의 몫입니다. 관련 호스트가 변경된 경우 연결 정보를 변경해야합니다. 새 전체 테이블 복사를 시작하기 전에 대상 테이블을 자르는 것이 적절할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="edeac7aa265daa84ac15a79b57465693d865b8ff" translate="yes" xml:space="preserve">
          <source>When either stderr or csvlog are included, the file &lt;code&gt;current_logfiles&lt;/code&gt; is created to record the location of the log file(s) currently in use by the logging collector and the associated logging destination. This provides a convenient way to find the logs currently in use by the instance. Here is an example of this file's content:</source>
          <target state="translated">stderr 또는 csvlog가 포함되면 &lt;code&gt;current_logfiles&lt;/code&gt; 파일 이 작성되어 로깅 수집기 및 관련 로깅 대상에서 현재 사용중인 로그 파일의 위치를 ​​기록합니다. 이를 통해 인스턴스에서 현재 사용중인 로그를 편리하게 찾을 수 있습니다. 이 파일 내용의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bf7e84c79ef7d8674ff36f5bd69afa904df5b94" translate="yes" xml:space="preserve">
          <source>When encrypting with a public key:</source>
          <target state="translated">공개 키로 암호화하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d8c4c4accb682e67b5f8b1813c77704fe93cbcb0" translate="yes" xml:space="preserve">
          <source>When encrypting with a symmetric key (i.e., a password):</source>
          <target state="translated">대칭 키 (예 : 비밀번호)로 암호화하는 경우 :</target>
        </trans-unit>
        <trans-unit id="db0cd6f3816a8188a89deee57f710a1baaa98cf3" translate="yes" xml:space="preserve">
          <source>When entering &lt;code&gt;bytea&lt;/code&gt; values in escape format, octets of certain values &lt;em&gt;must&lt;/em&gt; be escaped, while all octet values &lt;em&gt;can&lt;/em&gt; be escaped. In general, to escape an octet, convert it into its three-digit octal value and precede it by a backslash. Backslash itself (octet decimal value 92) can alternatively be represented by double backslashes. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; shows the characters that must be escaped, and gives the alternative escape sequences where applicable.</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 값을 이스케이프 형식으로 입력 할 때 특정 값의 옥텟을 이스케이프 &lt;em&gt;해야&lt;/em&gt; 하며 모든 옥텟 값 &lt;em&gt;을&lt;/em&gt; 이스케이프 &lt;em&gt;할 수&lt;/em&gt; 있습니다. 일반적으로 8 진수를 이스케이프하려면 3 자리 8 진수 값으로 변환 한 다음 백 슬래시를 선행시킵니다. 백 슬래시 자체 (10 진수 10 진수 값 92)는 이중 백 슬래시로 표시 될 수도 있습니다. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;표 8.7&lt;/a&gt; 은 이스케이프해야하는 문자를 보여 주며 해당되는 경우 대체 이스케이프 시퀀스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b723af7e86ecb6fa9f1f4fcf436b5692ddd09fd" translate="yes" xml:space="preserve">
          <source>When establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.</source>
          <target state="translated">다중 레벨 파티션 계층 구조에 대한 고유 제한 조건을 설정할 때 대상 파티션 된 테이블의 파티션 키에있는 모든 열과 모든 하위 파티션 된 테이블의 열이 제한 조건 정의에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5828ba22818bd784c0d1de682badc9fdcf5283f1" translate="yes" xml:space="preserve">
          <source>When estimating the selectivity, the planner applies all the conditions on items in the MCV list, and then sums the frequencies of the matching ones. See &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; in &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; for details.</source>
          <target state="translated">선택도를 추정 할 때 플래너는 MCV 목록의 항목에 대한 모든 조건을 적용한 다음 일치하는 항목의 빈도를 합합니다. 참조 &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; 의 &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="716da7567a674fa423040a77262890c91b3b1491" translate="yes" xml:space="preserve">
          <source>When estimating with functional dependencies, the planner assumes that conditions on the involved columns are compatible and hence redundant. If they are incompatible, the correct estimate would be zero rows, but that possibility is not considered. For example, given a query like</source>
          <target state="translated">기능적 종속성으로 추정 할 때 플래너는 관련 열의 조건이 호환 가능하므로 중복되는 것으로 가정합니다. 호환되지 않는 경우 올바른 추정값은 0 행이지만 해당 가능성은 고려되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="064d226f0b61cda9a60ca08881b4d97cee01ca7a" translate="yes" xml:space="preserve">
          <source>When executed on a primary, the function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. The return value is the backup's ending write-ahead log location (which again can be ignored). After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">기본에서 실행되면이 기능은 미리 쓰기 로그 아카이브 영역에 백업 히스토리 파일을 작성합니다. 히스토리 파일에는 &lt;code&gt;pg_start_backup&lt;/code&gt; 에 지정된 레이블 , 백업 시작 및 종료 미리 쓰기 로그 위치, 백업 시작 및 종료 시간이 포함됩니다. 리턴 값은 백업의 종료 미리 쓰기 로그 위치입니다 (다시 무시할 수 있음). 종료 위치를 기록한 후 현재 미리 쓰기 로그 삽입 지점이 다음 미리 쓰기 로그 파일로 자동으로 진행되므로 백업을 완료하기 위해 즉시 미리 쓰기 로그 파일을 보관할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f889c44a7c84c84f84b08b78362ee8d2fe32a7ef" translate="yes" xml:space="preserve">
          <source>When executed on a primary, this function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">이 기능은 기본에서 실행될 때 미리 쓰기 로그 아카이브 영역에 백업 이력 파일도 생성합니다. 히스토리 파일에는 &lt;code&gt;pg_start_backup&lt;/code&gt; 에 지정된 레이블 , 백업의 시작 및 종료 미리 쓰기 로그 위치, 백업 시작 및 종료 시간이 포함됩니다. 끝 위치를 기록한 후 현재 미리 쓰기 로그 삽입 지점이 자동으로 다음 미리 쓰기 로그 파일로 이동하므로 종료 미리 쓰기 로그 파일을 즉시 보관하여 백업을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b575c812fb039c331ed73bad6b9599e79ed09b9b" translate="yes" xml:space="preserve">
          <source>When executed, the example D script gives output such as:</source>
          <target state="translated">실행될 때 예제 D 스크립트는 다음과 같은 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9b9cbbd3bd8e290879a575143872c711e1071acb" translate="yes" xml:space="preserve">
          <source>When executing a parallel plan, you can use &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; to display per-worker statistics for each plan node. This may be useful in determining whether the work is being evenly distributed between all plan nodes and more generally in understanding the performance characteristics of the plan.</source>
          <target state="translated">병렬 계획을 실행할 때 &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; 을 사용하여 각 계획 노드에 대한 작업자 별 통계를 표시 할 수 있습니다 . 이는 작업이 모든 계획 노드간에 균등하게 분배되는지 여부를 결정하고보다 일반적으로 계획의 성능 특성을 이해하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5c9db9afb12cc927dcae6f85bc0fefc8f88ecba" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion so as its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">최근 승격 된 소스로 온라인 클러스터를 사용하여 pg_rewind를 실행하는 경우 제어 파일이 최신 타임 라인 정보를 반영하도록 제어 파일이 대상 클러스터가 사용할 수 있는지 확인하기 위해 제어 파일이 최신 타임 라인 정보를 반영하도록 승격 후 &lt;code&gt;CHECKPOINT&lt;/code&gt; 를 실행 해야합니다. 지정된 소스 클러스터를 사용하여 다시 감습니다.</target>
        </trans-unit>
        <trans-unit id="bc2e3d886cd659c186dac8f9dc7a3737bab777bf" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion such that its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">최근 승격 된 소스로 온라인 클러스터를 사용하여 pg_rewind를 실행할 때, 승격 후 &lt;code&gt;CHECKPOINT&lt;/code&gt; 를 실행하여 해당 제어 파일이 최신 타임 라인 정보를 반영하도록해야하며, 이는 pg_rewind에서 대상 클러스터가 가능한지 확인하는 데 사용됩니다. 지정된 소스 클러스터를 사용하여 되감습니다.</target>
        </trans-unit>
        <trans-unit id="45578e8de56cf79c1bab7717b9b7f3794e4ce080" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source, a role having sufficient permissions to execute the functions used by pg_rewind on the source cluster can be used instead of a superuser. Here is how to create such a role, named &lt;code&gt;rewind_user&lt;/code&gt; here:</source>
          <target state="translated">온라인 클러스터를 소스로 사용하여 pg_rewind를 실행하는 경우 수퍼 유저 대신 소스 클러스터에서 pg_rewind가 사용하는 기능을 실행할 수있는 권한이있는 역할을 사용할 수 있습니다. &lt;code&gt;rewind_user&lt;/code&gt; 라는 역할을 만드는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9d8da664aa55aa1d9ba572665740c9977324d898" translate="yes" xml:space="preserve">
          <source>When false, the command will not try to refresh table information. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; should then be executed separately. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">false 인 경우 명령은 테이블 정보를 새로 고치려고 시도하지 않습니다. 그런 다음 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 을 별도로 실행해야합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d12b7ebd6720c102addd509acf7a1b3a9bca1905" translate="yes" xml:space="preserve">
          <source>When host names are specified in &lt;code&gt;pg_hba.conf&lt;/code&gt;, you should make sure that name resolution is reasonably fast. It can be of advantage to set up a local name resolution cache such as &lt;code&gt;nscd&lt;/code&gt;. Also, you may wish to enable the configuration parameter &lt;code&gt;log_hostname&lt;/code&gt; to see the client's host name instead of the IP address in the log.</source>
          <target state="translated">호스트 이름이 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 지정되면 이름 확인 속도가 상당히 빨라야합니다. &lt;code&gt;nscd&lt;/code&gt; 와 같은 로컬 이름 확인 캐시를 설정하는 것이 유리할 수 있습니다 . 또한 구성 매개 변수 &lt;code&gt;log_hostname&lt;/code&gt; 을 사용하여 로그의 IP 주소 대신 클라이언트의 호스트 이름을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b7c985f760c5c9e2832f32ef829164b2539557" translate="yes" xml:space="preserve">
          <source>When ident is specified for a local (non-TCP/IP) connection, peer authentication (see &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt;) will be used instead.</source>
          <target state="translated">로컬 (비 TCP / IP) 연결에 ident가 지정되면 피어 인증 ( &lt;a href=&quot;auth-peer&quot;&gt;20.9&lt;/a&gt; 참조 )이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="81c1aa17a38d25550246efe2b31fe8f5cb3b0dba" translate="yes" xml:space="preserve">
          <source>When indexes are not used, it can be useful for testing to force their use. There are run-time parameters that can turn off various plan types (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;). For instance, turning off sequential scans (&lt;code&gt;enable_seqscan&lt;/code&gt;) and nested-loop joins (&lt;code&gt;enable_nestloop&lt;/code&gt;), which are the most basic plans, will force the system to use a different plan. If the system still chooses a sequential scan or nested-loop join then there is probably a more fundamental reason why the index is not being used; for example, the query condition does not match the index. (What kind of query can use what kind of index is explained in the previous sections.)</source>
          <target state="translated">인덱스를 사용하지 않으면 강제로 사용하도록 테스트하는 데 유용 할 수 있습니다. 다양한 계획 유형을 끌 수있는 런타임 매개 변수가 있습니다 ( &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;19.7.1 절 참조&lt;/a&gt; ). 예를 들어, 가장 기본적인 계획 인 순차 스캔 ( &lt;code&gt;enable_seqscan&lt;/code&gt; ) 및 중첩 루프 조인 ( &lt;code&gt;enable_nestloop&lt;/code&gt; )을 끄면 시스템에서 다른 계획을 사용하게됩니다. 시스템이 여전히 순차적 스캔 또는 중첩 루프 조인을 선택하는 경우 인덱스를 사용하지 않는 더 근본적인 이유가있을 수 있습니다. 예를 들어 쿼리 조건이 인덱스와 일치하지 않습니다. (이전 섹션에서 설명 된 인덱스 종류를 사용할 수있는 쿼리 종류는 무엇입니까?)</target>
        </trans-unit>
        <trans-unit id="9e50d0004d8680329345366b2774f5ebb4ad654f" translate="yes" xml:space="preserve">
          <source>When inserting a lot of data at the same time, consider using the &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. It is not as flexible as the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command, but is more efficient. Refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt; for more information on improving bulk loading performance.</source>
          <target state="translated">많은 양의 데이터를 동시에 삽입 할 때는 &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; 명령 사용을 고려하십시오 . &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; 명령 만큼 유연 하지는 않지만보다 효율적입니다. 벌크 로딩 성능 개선에 대한 자세한 내용 &lt;a href=&quot;populate&quot;&gt;은 14.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfb95bd9b76a1aa6b1bb1f21c135d8d5ba87cb03" translate="yes" xml:space="preserve">
          <source>When issuing queries in a database where some users mistrust other users, observe security precautions from &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt; when writing function calls.</source>
          <target state="translated">일부 사용자가 다른 사용자를 불신하는 데이터베이스에서 쿼리를 발행 할 때는 함수 호출을 작성할 때 &lt;a href=&quot;typeconv-func&quot;&gt;섹션 10.3의&lt;/a&gt; 보안 예방 조치를 준수하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ed9176dec0c08e99a6d40ec733c0b7bac5bbcf2" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.17&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">평가 순서를 강제 &lt;a href=&quot;functions-conditional&quot;&gt;해야하는&lt;/a&gt; 경우 &lt;code&gt;CASE&lt;/code&gt; 구문 ( 섹션 9.17 참조 )을 사용할 수 있습니다. 예를 들어, &lt;code&gt;WHERE&lt;/code&gt; 절 에서 0으로 나누지 않으려는 신뢰할 수없는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="f8882a94a7fafb56987fef2a0a2e2d4eb96df827" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.18&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">평가 순서를 강제하는 것이 필수적인 경우 &lt;code&gt;CASE&lt;/code&gt; 구성 ( &lt;a href=&quot;functions-conditional&quot;&gt;섹션 9.18&lt;/a&gt; 참조 )을 사용할 수 있습니다. 예를 들어, 이것은 &lt;code&gt;WHERE&lt;/code&gt; 절 에서 0으로 나누는 것을 피하려는 신뢰할 수없는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="d43ae9852bbd4e7fca0407119c0359f8ae17da03" translate="yes" xml:space="preserve">
          <source>When loading large amounts of data into an installation that uses WAL archiving or streaming replication, it might be faster to take a new base backup after the load has completed than to process a large amount of incremental WAL data. To prevent incremental WAL logging while loading, disable archiving and streaming replication, by setting &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; to &lt;code&gt;minimal&lt;/code&gt;, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;, and &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; to zero. But note that changing these settings requires a server restart.</source>
          <target state="translated">WAL 보관 또는 스트리밍 복제를 사용하는 설비에 대량의 데이터를로드 할 경우로드가 완료된 후 대량의 증분 WAL 데이터를 처리하는 것보다 새로운 기본 백업을 수행하는 것이 더 빠를 수 있습니다. 로드하는 동안 증분 WAL 로깅을 방지하려면 &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; 을 &lt;code&gt;minimal&lt;/code&gt; 로 , &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; 를 &lt;code&gt;off&lt;/code&gt; 로 , &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; 를 0 으로 설정하여 보관 및 스트리밍 복제를 비활성화하십시오 . 그러나이 설정을 변경하면 서버를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="a320947bd6f8b1714ed336d766e812f876be824d" translate="yes" xml:space="preserve">
          <source>When logging to event log is enabled, this parameter determines the program name used to identify PostgreSQL messages in the log. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이벤트 로그에 로깅이 활성화되면이 매개 변수는 로그에서 PostgreSQL 메시지를 식별하는 데 사용되는 프로그램 이름을 결정합니다. 기본값은 &lt;code&gt;PostgreSQL&lt;/code&gt; 입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="688b202e83ca61ee5187e2a33b6d2092af8c2739" translate="yes" xml:space="preserve">
          <source>When logging to syslog and this is on (the default), then each message will be prefixed by an increasing sequence number (such as &lt;code&gt;[2]&lt;/code&gt;). This circumvents the &amp;ldquo;--- last message repeated N times ---&amp;rdquo; suppression that many syslog implementations perform by default. In more modern syslog implementations, repeated message suppression can be configured (for example, &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; in rsyslog), so this might not be necessary. Also, you could turn this off if you actually want to suppress repeated messages.</source>
          <target state="translated">syslog에 로깅 할 때이 값이 켜져 있으면 (기본값) 각 메시지 앞에 일련 번호가 증가합니다 (예 : &lt;code&gt;[2]&lt;/code&gt; ). 이로 인해 많은 syslog 구현이 기본적으로 수행하는 &quot;--- 마지막 메시지 N 번 반복 ---&quot;억제를 피할 수 있습니다. 보다 현대적인 syslog 구현에서는 반복되는 메시지 억제를 구성 할 수 있으므로 (예 : rsyslog의 &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; ) 필요하지 않을 수 있습니다. 또한 실제로 반복되는 메시지를 표시하지 않으려면이 기능을 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba8a396481d44a42fb2aa24b4ad06150638300e9" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines how messages are delivered to syslog. When on (the default), messages are split by lines, and long lines are split so that they will fit into 1024 bytes, which is a typical size limit for traditional syslog implementations. When off, PostgreSQL server log messages are delivered to the syslog service as is, and it is up to the syslog service to cope with the potentially bulky messages.</source>
          <target state="translated">syslog에 로깅이 사용 가능한 경우이 매개 변수는 메시지가 syslog에 전달되는 방법을 결정합니다. 설정하면 (기본값) 메시지가 한 줄씩 분할되고 긴 줄은 1024 바이트에 맞도록 분할됩니다. 이는 전통적인 syslog 구현의 일반적인 크기 제한입니다. 해제하면 PostgreSQL 서버 로그 메시지가 그대로 syslog 서비스로 전달되며 잠재적으로 부피가 큰 메시지에 대처하는 것은 syslog 서비스의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="80ff0840aef3199452ea4eb2990b10a8d1c55939" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the program name used to identify PostgreSQL messages in syslog logs. The default is &lt;code&gt;postgres&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">syslog에 로깅이 사용 가능한 경우이 매개 변수는 syslog 로그에서 PostgreSQL 메시지를 식별하는 데 사용되는 프로그램 이름을 결정합니다. 기본값은 &lt;code&gt;postgres&lt;/code&gt; 입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="985b03993881f4457d8f0c3b34d9b7b01342f4d8" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the syslog &amp;ldquo;facility&amp;rdquo; to be used. You can choose from &lt;code&gt;LOCAL0&lt;/code&gt;, &lt;code&gt;LOCAL1&lt;/code&gt;, &lt;code&gt;LOCAL2&lt;/code&gt;, &lt;code&gt;LOCAL3&lt;/code&gt;, &lt;code&gt;LOCAL4&lt;/code&gt;, &lt;code&gt;LOCAL5&lt;/code&gt;, &lt;code&gt;LOCAL6&lt;/code&gt;, &lt;code&gt;LOCAL7&lt;/code&gt;; the default is &lt;code&gt;LOCAL0&lt;/code&gt;. See also the documentation of your system's syslog daemon. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">syslog에 로깅이 사용 가능한 경우이 매개 변수는 사용할 syslog &quot;기능&quot;을 결정합니다. &lt;code&gt;LOCAL0&lt;/code&gt; , &lt;code&gt;LOCAL1&lt;/code&gt; , &lt;code&gt;LOCAL2&lt;/code&gt; , &lt;code&gt;LOCAL3&lt;/code&gt; , &lt;code&gt;LOCAL4&lt;/code&gt; , &lt;code&gt;LOCAL5&lt;/code&gt; , &lt;code&gt;LOCAL6&lt;/code&gt; , &lt;code&gt;LOCAL7&lt;/code&gt; 중에서 선택할 수 있습니다 . 기본값은 &lt;code&gt;LOCAL0&lt;/code&gt; 입니다. 시스템의 syslog 데몬 설명서도 참조하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d9a3edba4451cb3d18020f74c5a06ee8a7a52bd" translate="yes" xml:space="preserve">
          <source>When managing the server directly, you can control the type of shutdown by sending different signals to the &lt;code&gt;postgres&lt;/code&gt; process:</source>
          <target state="translated">서버를 직접 관리 할 때 &lt;code&gt;postgres&lt;/code&gt; 프로세스에 다른 신호를 전송하여 종료 유형을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b30985843aab3e94f2bd3bce331e8a5523cabcbb" translate="yes" xml:space="preserve">
          <source>When more than one expression is specified, the later values are used to sort rows that are equal according to the earlier values. Each expression can be followed by an optional &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; keyword to set the sort direction to ascending or descending. &lt;code&gt;ASC&lt;/code&gt; order is the default. Ascending order puts smaller values first, where &amp;ldquo;smaller&amp;rdquo; is defined in terms of the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. Similarly, descending order is determined with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">둘 이상의 표현식이 지정되면 나중 값은 이전 값과 동일한 행을 정렬하는 데 사용됩니다. 각 표현식 뒤에 선택적인 &lt;code&gt;ASC&lt;/code&gt; 또는 &lt;code&gt;DESC&lt;/code&gt; 키워드 가 오면 정렬 방향을 오름차순 또는 내림차순으로 설정할 수 있습니다 . &lt;code&gt;ASC&lt;/code&gt; 순서가 기본값입니다. 오름차순은 더 작은 값을 먼저 설정하며, 여기서 &quot;작은&quot;은 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자로 정의됩니다 . 마찬가지로 내림차순은 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자로 결정됩니다 . &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11912d8e839cffb71f2e5fc45344859e046a9cbc" translate="yes" xml:space="preserve">
          <source>When more than one row is specified, all the rows must have the same number of elements. The data types of the resulting table's columns are determined by combining the explicit or inferred types of the expressions appearing in that column, using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="translated">둘 이상의 행이 지정되면 모든 행에 동일한 수의 요소가 있어야합니다. 결과 테이블 열의 데이터 유형은 &lt;code&gt;UNION&lt;/code&gt; 과 동일한 규칙을 사용하여 해당 열에 나타나는 명시 적 또는 유추 된 표현식 유형을 결합하여 결정됩니다 ( &lt;a href=&quot;typeconv-union-case&quot;&gt;10.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="dcff81a7a0194a63301c74dc5ce189cffc265222" translate="yes" xml:space="preserve">
          <source>When multiple policies apply to a given query, they are combined using either &lt;code&gt;OR&lt;/code&gt; (for permissive policies, which are the default) or using &lt;code&gt;AND&lt;/code&gt; (for restrictive policies). This is similar to the rule that a given role has the privileges of all roles that they are a member of. Permissive vs. restrictive policies are discussed further below.</source>
          <target state="translated">지정된 쿼리에 여러 정책이 적용되면 &lt;code&gt;OR&lt;/code&gt; (기본값 인 허용 정책의 경우) 또는 &lt;code&gt;AND&lt;/code&gt; (제한 정책의 경우)를 사용하여 결합 됩니다. 이는 주어진 역할이 자신이 속한 모든 역할의 권한을 갖는다는 규칙과 유사합니다. 허용 정책과 제한 정책은 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="269b9ef4adee76f3240604e5767201bc6ee01e71" translate="yes" xml:space="preserve">
          <source>When multiple policies of different command types apply to the same command (for example, &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; policies applied to an &lt;code&gt;UPDATE&lt;/code&gt; command), then the user must have both types of permissions (for example, permission to select rows from the relation as well as permission to update them). Thus the expressions for one type of policy are combined with the expressions for the other type of policy using the &lt;code&gt;AND&lt;/code&gt; operator.</source>
          <target state="translated">다른 명령 유형의 여러 정책이 동일한 명령에 적용되는 경우 (예 : &lt;code&gt;UPDATE&lt;/code&gt; 명령에 적용된 &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 정책 ) 사용자는 두 가지 유형의 권한 (예 : 관계에서 행을 선택할 수있는 권한 및 업데이트 권한). 따라서 한 유형의 정책에 대한 표현식은 &lt;code&gt;AND&lt;/code&gt; 연산자를 사용하여 다른 유형의 정책에 대한 표현식과 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="556057cb09a8742cb36bd19c1657e03ac61a815b" translate="yes" xml:space="preserve">
          <source>When multiple policies of the same command type apply to the same command, then there must be at least one &lt;code&gt;PERMISSIVE&lt;/code&gt; policy granting access to the relation, and all of the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policies must pass. Thus all the &lt;code&gt;PERMISSIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;OR&lt;/code&gt;, all the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;AND&lt;/code&gt;, and the results are combined using &lt;code&gt;AND&lt;/code&gt;. If there are no &lt;code&gt;PERMISSIVE&lt;/code&gt; policies, then access is denied.</source>
          <target state="translated">동일한 명령 유형의 여러 정책이 동일한 명령에 적용 되면 관계에 대한 액세스 권한을 부여하는 &lt;code&gt;PERMISSIVE&lt;/code&gt; 정책이 하나 이상 있어야 하며 모든 &lt;code&gt;RESTRICTIVE&lt;/code&gt; 정책이 통과해야합니다. 따라서 모든 &lt;code&gt;PERMISSIVE&lt;/code&gt; 정책 표현식은 &lt;code&gt;OR&lt;/code&gt; 을 사용하여 결합 되고 모든 &lt;code&gt;RESTRICTIVE&lt;/code&gt; 정책 표현식은 &lt;code&gt;AND&lt;/code&gt; 를 사용하여 결합 되며 결과는 &lt;code&gt;AND&lt;/code&gt; 를 사용하여 결합됩니다 . &lt;code&gt;PERMISSIVE&lt;/code&gt; 정책 이 없으면 액세스가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="5d6d15be5ddf45a51b853b506d5d1a1d2068106c" translate="yes" xml:space="preserve">
          <source>When multiple window functions are used, all the window functions having syntactically equivalent &lt;code&gt;PARTITION BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; clauses in their window definitions are guaranteed to be evaluated in a single pass over the data. Therefore they will see the same sort ordering, even if the &lt;code&gt;ORDER BY&lt;/code&gt; does not uniquely determine an ordering. However, no guarantees are made about the evaluation of functions having different &lt;code&gt;PARTITION BY&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; specifications. (In such cases a sort step is typically required between the passes of window function evaluations, and the sort is not guaranteed to preserve ordering of rows that its &lt;code&gt;ORDER BY&lt;/code&gt; sees as equivalent.)</source>
          <target state="translated">여러 개의 창 함수를 사용 하는 경우 창 정의에서 구문 상 동등한 &lt;code&gt;PARTITION BY&lt;/code&gt; 및 &lt;code&gt;ORDER BY&lt;/code&gt; 절을 갖는 모든 창 함수 는 데이터에 대한 단일 패스로 평가됩니다. 따라서 &lt;code&gt;ORDER BY&lt;/code&gt; 가 순서를 고유하게 결정하지 않더라도 동일한 정렬 순서를 보게됩니다 . 그러나 &lt;code&gt;PARTITION BY&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 스펙 이 다른 기능의 평가에 대해서는 보증하지 않습니다 . (이러한 경우 일반적으로 창 함수 평가 단계 사이에 정렬 단계가 필요하며 &lt;code&gt;ORDER BY&lt;/code&gt; 가 동등한 행 순서를 유지한다고 정렬이 보장되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="34f31d5224ac605a926f4e92907e12ec5add9474" translate="yes" xml:space="preserve">
          <source>When multiple workers are running, the autovacuum cost delay parameters (see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt;) are &amp;ldquo;balanced&amp;rdquo; among all the running workers, so that the total I/O impact on the system is the same regardless of the number of workers actually running. However, any workers processing tables whose per-table &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; or &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; storage parameters have been set are not considered in the balancing algorithm.</source>
          <target state="translated">여러 작업자가 실행중인 경우, 모든 &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;진공&lt;/a&gt; 작업자간에 autovacuum 비용 지연 매개 변수 ( 섹션 19.4.4 참조 )가 &quot;균형 조정&quot;되므로 시스템에 대한 총 I / O 영향은 실제로 실행중인 작업자 수에 관계없이 동일합니다 . 그러나 테이블 당 &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; 또는 &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; 스토리지 매개 변수가 설정된 테이블을 처리하는 작업자 는 밸런싱 알고리즘에서 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84f11ff5e7225ec364ea450b05da5b31bd525923" translate="yes" xml:space="preserve">
          <source>When no final &lt;code&gt;ELSE&lt;/code&gt; clause is provided to a &lt;code&gt;CASE&lt;/code&gt;, the default value is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 에 최종 &lt;code&gt;ELSE&lt;/code&gt; 절이 제공 되지 않으면 기본값은 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb2d002b299026c6a8e3abc29ae594e572a6b112" translate="yes" xml:space="preserve">
          <source>When non-serializable writes are possible, to ensure the current validity of a row and protect it against concurrent updates one must use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or an appropriate &lt;code&gt;LOCK TABLE&lt;/code&gt; statement. (&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; lock just the returned rows against concurrent updates, while &lt;code&gt;LOCK TABLE&lt;/code&gt; locks the whole table.) This should be taken into account when porting applications to PostgreSQL from other environments.</source>
          <target state="translated">직렬화 할 수없는 쓰기가 가능한 경우, 행의 현재 유효성을 보장하고 동시 갱신으로부터이를 보호하려면 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 또는 적절한 &lt;code&gt;LOCK TABLE&lt;/code&gt; 문을 사용해야 합니다. ( &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 는 동시 업데이트에 대해 반환 된 행만 잠그는 반면 &lt;code&gt;LOCK TABLE&lt;/code&gt; 은 전체 테이블을 잠급니다.) 다른 환경에서 응용 프로그램을 PostgreSQL로 이식 할 때는이 점을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d5d4ed5a8f5b52f15315d7a651b9128c1d498f8" translate="yes" xml:space="preserve">
          <source>When not all owned objects are to be transferred to the same successor owner, it's best to handle the exceptions manually and then perform the above steps to mop up.</source>
          <target state="translated">소유 한 모든 객체를 동일한 후속 소유자에게 전송하지 않을 경우 예외를 수동으로 처리 한 다음 위의 단계를 수행하여 정리하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ed8afcb65f27d90b88c36a924e96931352e55b61" translate="yes" xml:space="preserve">
          <source>When not using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, the &lt;code&gt;column_definition&lt;/code&gt; list replaces the column alias list that could otherwise be attached to the &lt;code&gt;FROM&lt;/code&gt; item; the names in the column definitions serve as column aliases. When using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, a &lt;code&gt;column_definition&lt;/code&gt; list can be attached to each member function separately; or if there is only one member function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause, a &lt;code&gt;column_definition&lt;/code&gt; list can be written in place of a column alias list following &lt;code&gt;ROWS FROM()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ROWS FROM()&lt;/code&gt; 구문을 사용하지 않는 경우 &lt;code&gt;column_definition&lt;/code&gt; 목록은 &lt;code&gt;FROM&lt;/code&gt; 항목에 첨부 될 수있는 열 별명 목록을 대체합니다 . 열 정의의 이름은 열 별칭으로 사용됩니다. 사용시 &lt;code&gt;ROWS FROM()&lt;/code&gt; 구문하는 &lt;code&gt;column_definition&lt;/code&gt; 의 리스트는 별도로 각 기능 부재에 부착 될 수있다; 또는 멤버 함수가 하나만 있고 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 절이 없는 경우 &lt;code&gt;ROWS FROM()&lt;/code&gt; 다음에 열 별명 목록 대신 &lt;code&gt;column_definition&lt;/code&gt; 목록을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89c266fb8eeefdc22c382f51ddfa36d2cdf3fd08" translate="yes" xml:space="preserve">
          <source>When objects are created without specifying a particular target schema, they will be placed in the first valid schema named in &lt;code&gt;search_path&lt;/code&gt;. An error is reported if the search path is empty.</source>
          <target state="translated">특정 대상 스키마를 지정하지 않고 객체를 &lt;code&gt;search_path&lt;/code&gt; 이름이 지정된 첫 번째 유효한 스키마에 배치됩니다 . 검색 경로가 비어 있으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="99ff2ff0bf302907b157207503609b9e0138a5a9" translate="yes" xml:space="preserve">
          <source>When on, a warning is issued if a backslash (&lt;code&gt;\&lt;/code&gt;) appears in an ordinary string literal (&lt;code&gt;'...'&lt;/code&gt; syntax) and &lt;code&gt;standard_conforming_strings&lt;/code&gt; is off. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">설정하면 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )가 일반 문자열 리터럴 ( &lt;code&gt;'...'&lt;/code&gt; 구문)에 나타나고 &lt;code&gt;standard_conforming_strings&lt;/code&gt; 가 해제 된 경우 경고가 발행됩니다 . 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a39a26ef7d5c306f15cfec242fa1908a71ae3775" translate="yes" xml:space="preserve">
          <source>When on, expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; (or &lt;code&gt;NULL = expr&lt;/code&gt;) are treated as &lt;code&gt;expr IS NULL&lt;/code&gt;, that is, they return true if &lt;code&gt;expr&lt;/code&gt; evaluates to the null value, and false otherwise. The correct SQL-spec-compliant behavior of &lt;code&gt;expr = NULL&lt;/code&gt; is to always return null (unknown). Therefore this parameter defaults to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">설정하면 &lt;code&gt;expr = NULL&lt;/code&gt; (또는 &lt;code&gt;NULL = expr&lt;/code&gt; ) 형식의 표현식은 &lt;code&gt;expr IS NULL&lt;/code&gt; 로 처리됩니다. 즉 &lt;code&gt;expr&lt;/code&gt; 이 널값으로 평가 되면 true를 리턴 하고 그렇지 않으면 false를 리턴합니다. &lt;code&gt;expr = NULL&lt;/code&gt; 의 올바른 SQL 스펙 호환 동작은 항상 널 (알 수 없음)을 리턴하는 것입니다. 따라서이 매개 변수의 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd83814e734e8771d44c1de9842876866f19a1c6" translate="yes" xml:space="preserve">
          <source>When on, the parser will emit a warning for any construct that might have changed meanings since PostgreSQL 9.4 as a result of changes in operator precedence. This is useful for auditing applications to see if precedence changes have broken anything; but it is not meant to be kept turned on in production, since it will warn about some perfectly valid, standard-compliant SQL code. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">설정하면 파서에서 PostgreSQL 9.4 이후 연산자 우선 순위가 변경되어 의미가 변경되었을 수있는 모든 구문에 대해 경고를 표시합니다. 이 기능은 응용 프로그램을 감사하여 우선 순위 변경으로 인해 문제가 발생했는지 확인하는 데 유용합니다. 그러나 완벽하게 유효한 표준 호환 SQL 코드에 대해 경고하므로 프로덕션 환경에서 계속 켜져 있지는 않습니다. 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f61f3e69afe30c64a291d60390d7c29326445c47" translate="yes" xml:space="preserve">
          <source>When operators and support functions are added to a family with &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;, they are not part of any specific operator class within the family, but are just &amp;ldquo;loose&amp;rdquo; within the family. This indicates that these operators and functions are compatible with the family's semantics, but are not required for correct functioning of any specific index. (Operators and functions that are so required should be declared as part of an operator class, instead; see &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS&lt;/a&gt;.) PostgreSQL will allow loose members of a family to be dropped from the family at any time, but members of an operator class cannot be dropped without dropping the whole class and any indexes that depend on it. Typically, single-data-type operators and functions are part of operator classes because they are needed to support an index on that specific data type, while cross-data-type operators and functions are made loose members of the family.</source>
          <target state="translated">운영자 및 지원 기능이 &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 가있는 패밀리에 추가되면 해당 패밀리 내의 특정 운영자 클래스의 일부가 아니라 패밀리 내에서 &quot;느슨한&quot;것입니다. 이는 이러한 연산자 및 기능이 제품군의 의미와 호환되지만 특정 색인의 올바른 기능에 필요하지는 않음을 나타냅니다. (필요한 연산자와 함수는 대신 연산자 클래스의 일부로 선언해야합니다. &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS를&lt;/a&gt; 참조하십시오..) PostgreSQL을 사용하면 언제든지 패밀리의 느슨한 멤버를 패밀리에서 삭제할 수 있지만 전체 클래스와 그에 종속 된 인덱스를 삭제하지 않고 운영자 클래스의 멤버를 삭제할 수 없습니다. 일반적으로 단일 데이터 유형 연산자 및 함수는 해당 특정 데이터 유형에 대한 색인을 지원하는 데 필요하기 때문에 연산자 데이터의 일부이며, 교차 데이터 유형 연산자 및 함수는 계열의 느슨한 구성원이됩니다.</target>
        </trans-unit>
        <trans-unit id="0f2ad4b5a54137b2f0c70ae82420f67c0b1b6ea3" translate="yes" xml:space="preserve">
          <source>When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table.</source>
          <target state="translated">쿼리 또는 업데이트가 단일 파티션의 많은 비율에 액세스 할 때 전체 테이블에 분산 된 인덱스 및 임의 액세스 읽기를 사용하는 대신 해당 파티션의 순차적 스캔을 활용하여 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2540d43e50d1abeb1a847d9db340690266815c23" translate="yes" xml:space="preserve">
          <source>When relying on Serializable transactions to prevent anomalies, it is important that any data read from a permanent user table not be considered valid until the transaction which read it has successfully committed. This is true even for read-only transactions, except that data read within a &lt;em&gt;deferrable&lt;/em&gt; read-only transaction is known to be valid as soon as it is read, because such a transaction waits until it can acquire a snapshot guaranteed to be free from such problems before starting to read any data. In all other cases applications must not depend on results read during a transaction that later aborted; instead, they should retry the transaction until it succeeds.</source>
          <target state="translated">예외를 방지하기 위해 직렬화 가능 트랜잭션에 의존하는 경우 영구 사용자 테이블에서 읽은 데이터는 트랜잭션을 성공적으로 커밋 할 때까지 유효하지 않은 것으로 간주해야합니다. 이는 &lt;em&gt;지연 가능한&lt;/em&gt; 읽기 전용 트랜잭션 내에서 읽은 데이터가 읽히는 즉시 유효한 것으로 알려져 있다는 점을 제외하고는 읽기 전용 트랜잭션의 경우에도 해당됩니다. 이러한 트랜잭션은 해당 트랜잭션이없는 스냅 샷을 확보 할 수있을 때까지 대기하기 때문입니다. 데이터를 읽기 전에 문제가 발생합니다. 다른 모든 경우에 응용 프로그램은 나중에 중단 된 트랜잭션 동안 읽은 결과에 의존해서는 안됩니다. 대신 성공할 때까지 트랜잭션을 재 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f545c1f8d440a6a74e5e5cae7b49a8321ce778e" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE FUNCTION&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">반복 된 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 호출이 동일한 오브젝트 파일을 참조하면 파일은 세션 당 한 번만로드됩니다. 파일을 언로드하고 다시로드하려면 (아마 개발 중에) 새 세션을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="63cb3d013e86db6ef5ef57500326cdf863814f3a" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">&lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 호출이 동일한 오브젝트 파일을 반복 하면 파일은 세션 당 한 번만로드됩니다. 파일을 언로드하고 다시로드하려면 (아마 개발 중에) 새 세션을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b358e9fc6a1b297fd0b37a45eac263be99236636" translate="yes" xml:space="preserve">
          <source>When replacing an existing definition, the argument types, result type, and number of direct arguments may not be changed. Also, the new definition must be of the same kind (ordinary aggregate, ordered-set aggregate, or hypothetical-set aggregate) as the old one.</source>
          <target state="translated">기존 정의를 대체 할 때 인수 유형, 결과 유형 및 직접 인수 수는 변경되지 않을 수 있습니다. 또한 새 정의는 이전 정의와 동일한 종류 (일반 집계, 순서 집합 집계 또는 가정 집합 집합) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="bf16a952f545e26cfee0e603603bfd07e12cf881" translate="yes" xml:space="preserve">
          <source>When replacing an existing function with &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;, there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function's result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced.</source>
          <target state="translated">기존 함수를 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 으로 바꾸는 경우 매개 변수 이름 변경에 제한이 있습니다. 입력 매개 변수에 이미 지정된 이름은 변경할 수 없습니다 (이전에없는 매개 변수에는 이름을 추가 할 수 있음). 출력 매개 변수가 두 개 이상인 경우 출력 매개 변수의 이름을 변경할 수 없습니다. 그 결과 함수의 결과를 설명하는 익명 복합 유형의 열 이름이 변경되기 때문입니다. 이러한 제한 사항은 함수의 기존 호출이 교체 될 때 작동을 중지하지 않도록하기 위해 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="c4f24499d5667a6f6b8b67600774aa56a3d4c33d" translate="yes" xml:space="preserve">
          <source>When replicating between partitioned tables, the actual replication originates, by default, from the leaf partitions on the publisher, so partitions on the publisher must also exist on the subscriber as valid target tables. (They could either be leaf partitions themselves, or they could be further subpartitioned, or they could even be independent tables.) Publications can also specify that changes are to be replicated using the identity and schema of the partitioned root table instead of that of the individual leaf partitions in which the changes actually originate (see &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;).</source>
          <target state="translated">파티션 된 테이블간에 복제 할 때 실제 복제는 기본적으로 게시자의 리프 파티션에서 시작되므로 게시자의 파티션도 구독자에 유효한 대상 테이블로 존재해야합니다. (리프 파티션 자체 일 수도 있고 추가 하위 파티션이 될 수도 있고 독립적 인 테이블 일 수도 있습니다.) 게시는 또한 파티션 된 루트 테이블의 ID와 스키마를 사용하여 변경 사항이 복제되도록 지정할 수 있습니다. 변경 사항이 실제로 발생하는 개별 리프 파티션 ( &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="80773f67cc3b08f5dcb6c36638c7da08b5a16582" translate="yes" xml:space="preserve">
          <source>When requesting synchronous replication, each commit of a write transaction will wait until confirmation is received that the commit has been written to the write-ahead log on disk of both the primary and standby server. The only possibility that data can be lost is if both the primary and the standby suffer crashes at the same time. This can provide a much higher level of durability, though only if the sysadmin is cautious about the placement and management of the two servers. Waiting for confirmation increases the user's confidence that the changes will not be lost in the event of server crashes but it also necessarily increases the response time for the requesting transaction. The minimum wait time is the round-trip time between primary to standby.</source>
          <target state="translated">동기식 복제를 요청할 때 쓰기 트랜잭션의 각 커밋은 커밋이 기본 및 대기 서버의 디스크의 미리 쓰기 로그에 기록되었다는 확인이 수신 될 때까지 기다립니다. 기본 및 대기가 동시에 충돌하는 경우 데이터가 유실 될 수있는 유일한 가능성입니다. 이것은 sysadmin이 두 서버의 배치 및 관리에 대해 신중한 경우에만 훨씬 높은 수준의 내구성을 제공 할 수 있습니다. 확인 대기는 서버 충돌시 변경 사항이 손실되지 않는다는 사용자의 확신을 높이지만 요청 트랜잭션에 대한 응답 시간을 늘릴 수도 있습니다. 최소 대기 시간은 기본에서 대기 사이의 왕복 시간입니다.</target>
        </trans-unit>
        <trans-unit id="7cbfd2d18fb6178afa3088b0725b2bc3fcdf04fe" translate="yes" xml:space="preserve">
          <source>When restoring data to a pre-existing table and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_restore emits commands to disable triggers on user tables before inserting the data, then emits commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">기존 테이블로 데이터를 복원하고 &lt;code&gt;--disable-triggers&lt;/code&gt; 옵션을 사용하는 경우 pg_restore는 데이터를 삽입하기 전에 사용자 테이블에서 트리거를 비활성화하는 명령을 생성 한 다음 데이터가 삽입 된 후 다시 활성화하는 명령을 생성합니다. 중간에 복원이 중지되면 시스템 카탈로그가 잘못된 상태로 남아있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ade7c8c975218ba23dcef154671330d11fa5728d" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">역할 멤버 자격을 취소 할 때 &lt;code&gt;GRANT OPTION&lt;/code&gt; 을 &lt;code&gt;ADMIN OPTION&lt;/code&gt; 이라고 하지만 동작은 비슷합니다. 이 명령 형식에서는 노이즈 단어 &lt;code&gt;GROUP&lt;/code&gt; 이 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2378e777cb7029b72a32e416964ca17fb134eb03" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. This form of the command also allows a &lt;code&gt;GRANTED BY&lt;/code&gt; option, but that option is currently ignored (except for checking the existence of the named role). Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt;.</source>
          <target state="translated">역할의 멤버십을 취소 할 때 &lt;code&gt;GRANT OPTION&lt;/code&gt; 은 대신 &lt;code&gt;ADMIN OPTION&lt;/code&gt; 이라고 하지만 동작은 비슷합니다. 이 명령 형식은 &lt;code&gt;GRANTED BY&lt;/code&gt; 옵션 도 허용 하지만 해당 옵션은 현재 무시됩니다 (명명 된 역할의 존재 여부 확인 제외). 또한이 형식의 명령은 &lt;code&gt;role_specification&lt;/code&gt; 에서 의미없는 단어 &lt;code&gt;GROUP&lt;/code&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f68adac31376cf57c26d631be30fdfc9650022d2" translate="yes" xml:space="preserve">
          <source>When revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect.</source>
          <target state="translated">테이블에 대한 권한을 취소하면 해당 열 권한 (있는 경우)도 테이블의 각 열에 대해 자동으로 취소됩니다. 반면, 역할에 테이블에 대한 권한이 부여 된 경우 개별 열에서 동일한 권한을 취소해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="300dad807edac8d993f28c0997a914c75b99f4bc" translate="yes" xml:space="preserve">
          <source>When rounding values, the &lt;code&gt;numeric&lt;/code&gt; type rounds ties away from zero, while (on most machines) the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; types round ties to the nearest even number. For example:</source>
          <target state="translated">값을 반올림 할 때 &lt;code&gt;numeric&lt;/code&gt; 유형은 0에서 멀어 지도록 반올림하지만 &lt;code&gt;real&lt;/code&gt; 및 &lt;code&gt;double precision&lt;/code&gt; 유형은 가장 가까운 짝수로 반올림합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f76f7c7b77ca49ded558a0639a8d27cc09a3811" translate="yes" xml:space="preserve">
          <source>When row security is enabled on a table (with &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt;), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as &lt;code&gt;TRUNCATE&lt;/code&gt; and &lt;code&gt;REFERENCES&lt;/code&gt;, are not subject to row security.</source>
          <target state="translated">테이블에서 행 보안이 사용 가능한 경우 ( &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY 사용&lt;/a&gt; ) 행 보안 정책에 의해 행 선택 또는 행 수정을 위해 테이블에 대한 모든 일반 액세스가 허용되어야합니다. 그러나 테이블 소유자는 일반적으로 행 보안 정책의 적용을받지 않습니다. 테이블에 대한 정책이 없으면 기본 거부 정책이 사용되므로 행이 표시되지 않거나 수정할 수 없습니다. &lt;code&gt;TRUNCATE&lt;/code&gt; 및 &lt;code&gt;REFERENCES&lt;/code&gt; 와 같이 전체 테이블에 적용되는 조작 에는 행 보안이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="226f5e12ea7fb1c629a76bb1b3cc1943cd4502fc" translate="yes" xml:space="preserve">
          <source>When running a long test on hardware that can handle a lot of transactions, the log files can become very large. The &lt;code&gt;--sampling-rate&lt;/code&gt; option can be used to log only a random sample of transactions.</source>
          <target state="translated">많은 트랜잭션을 처리 할 수있는 하드웨어에서 장기간 테스트를 실행하면 로그 파일이 매우 커질 수 있습니다. &lt;code&gt;--sampling-rate&lt;/code&gt; 옵션 거래의 무작위 표본을 기록하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4051fc47591e058546d74bee2aa79ca3ea360af8" translate="yes" xml:space="preserve">
          <source>When running a standby server, you must set this parameter to the same or higher value than on the master server. Otherwise, queries will not be allowed in the standby server.</source>
          <target state="translated">대기 서버를 실행할 때이 매개 변수를 마스터 서버와 같거나 더 높은 값으로 설정해야합니다. 그렇지 않으면 대기 서버에서 조회가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0becdbc99cfe7674fb7d475f00ec87ca3a5a28cc" translate="yes" xml:space="preserve">
          <source>When running at the &lt;code&gt;serializable&lt;/code&gt; isolation level, a deferrable read-only SQL transaction may be delayed before it is allowed to proceed. However, once it begins executing it does not incur any of the overhead required to ensure serializability; so serialization code will have no reason to force it to abort because of concurrent updates, making this option suitable for long-running read-only transactions.</source>
          <target state="translated">&lt;code&gt;serializable&lt;/code&gt; 격리 레벨 에서 실행될 때 지연 가능한 읽기 전용 SQL 트랜잭션이 진행되기 전에 지연 될 수 있습니다. 그러나 일단 실행이 시작되면 직렬화 가능성을 보장하는 데 필요한 오버 헤드가 발생하지 않습니다. 따라서 직렬화 코드는 동시 업데이트로 인해 강제로 중단 될 이유가 없으므로이 옵션은 장기 실행 읽기 전용 트랜잭션에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d1a67057ea54f0f16f47cefbf38d78344e7ecca6" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;on&lt;/code&gt;, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to &lt;code&gt;interactive&lt;/code&gt;, such errors are only ignored in interactive sessions, and not when reading script files. When set to &lt;code&gt;off&lt;/code&gt; (the default), a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit &lt;code&gt;SAVEPOINT&lt;/code&gt; for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 으로 설정되면 트랜잭션 블록의 명령문이 오류를 생성하면 오류가 무시되고 트랜잭션이 계속됩니다. &lt;code&gt;interactive&lt;/code&gt; 로 설정하면 이러한 오류는 스크립트 파일을 읽을 때가 아니라 대화식 세션에서만 무시됩니다. &lt;code&gt;off&lt;/code&gt; (기본값)로 설정 하면 오류를 생성하는 트랜잭션 블록의 명령문이 전체 트랜잭션을 중단합니다. 오류 롤백 모드 는 트랜잭션 블록에있는 각 명령 바로 전에 암시 적 &lt;code&gt;SAVEPOINT&lt;/code&gt; 를 발행 한 다음 명령이 실패하면 저장 점으로 롤백하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="549604915bc0a6d5cfb5cf7a10c720e97be80363" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;remote_apply&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s), and also written to durable storage on the standbys. This will cause much larger commit delays than previous settings since it waits for WAL replay. When set to &lt;code&gt;on&lt;/code&gt;, commits wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to durable storage. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_write&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it to their file systems. This setting ensures data preservation if a standby instance of PostgreSQL crashes, but not if the standby suffers an operating-system-level crash because the data has not necessarily reached durable storage on the standby. The setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is usually not desirable when synchronous replication is in use, but is provided for completeness.</source>
          <target state="translated">&lt;code&gt;remote_apply&lt;/code&gt; 로 설정되면 커밋은 현재 동기 대기 (들)의 응답이 트랜잭션의 커밋 레코드를 수신하고 적용했음을 나타낼 때까지 대기하여 대기의 쿼리에 표시되고 기록됩니다. 대기의 내구성있는 스토리지에. 이것은 WAL 재생을 기다리기 때문에 이전 설정보다 훨씬 더 큰 커밋 지연을 유발합니다. &lt;code&gt;on&lt;/code&gt; 으로 설정하면 커밋은 현재 동기 대기의 응답이 트랜잭션의 커밋 레코드를 수신하고이를 영구 저장소로 플러시했음을 나타낼 때까지 대기합니다. 이렇게하면 기본 및 모든 동기 대기 모두가 데이터베이스 스토리지가 손상되지 않는 한 트랜잭션이 손실되지 않습니다. &lt;code&gt;remote_write&lt;/code&gt; 로 설정된 경우, 커밋은 현재 동기 대기 (들)의 응답이 트랜잭션의 커밋 레코드를 수신하여 파일 시스템에 기록했음을 나타낼 때까지 대기합니다. 이 설정은 PostgreSQL의 대기 인스턴스가 충돌하는 경우 데이터 보존을 보장하지만 데이터가 대기의 내구성 스토리지에 반드시 도달하지 않았기 때문에 대기가 운영 체제 수준 충돌을 겪는 경우에는 그렇지 않습니다. &lt;code&gt;local&lt;/code&gt; 로 설정 하면 커밋이 디스크로의 로컬 플러시를 기다리지 만 복제는 기다리지 않습니다. 이는 일반적으로 동기식 복제를 사용할 때는 바람직하지 않지만 완전성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="43e9cba78fc8dadeb25eba89d19fc5d8c6ee61b8" translate="yes" xml:space="preserve">
          <source>When set to off, which is the default, PostgreSQL will raise a PANIC-level error on failure to flush modified data files to the file system. This causes the database server to crash. This parameter can only be set at server start.</source>
          <target state="translated">기본값 인 off로 설정하면 PostgreSQL은 수정 된 데이터 파일을 파일 시스템으로 플러시하지 못할 때 PANIC 수준 오류를 발생시킵니다. 이로 인해 데이터베이스 서버가 중단됩니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbaca794cc78ed3c2b124781f712501c0ff4934" translate="yes" xml:space="preserve">
          <source>When set to on, which is the default, PostgreSQL will automatically reinitialize after a backend crash. Leaving this value set to on is normally the best way to maximize the availability of the database. However, in some circumstances, such as when PostgreSQL is being invoked by clusterware, it may be useful to disable the restart so that the clusterware can gain control and take any actions it deems appropriate.</source>
          <target state="translated">기본값 인 on으로 설정하면 PostgreSQL은 백엔드 충돌 후 자동으로 다시 초기화됩니다. 이 값을 설정 한 상태로 두는 것이 일반적으로 데이터베이스의 가용성을 최대화하는 가장 좋은 방법입니다. 그러나 PostgreSQL이 클러스터웨어에 의해 호출되는 경우와 같은 일부 상황에서는 클러스터웨어가 제어를 얻고 적절한 것으로 간주되는 조치를 취할 수 있도록 재시작을 비활성화하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b55871d6d7b3f171d441751dee834b0868dec6" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;debug_pretty_print&lt;/code&gt; indents the messages produced by &lt;code&gt;debug_print_parse&lt;/code&gt;, &lt;code&gt;debug_print_rewritten&lt;/code&gt;, or &lt;code&gt;debug_print_plan&lt;/code&gt;. This results in more readable but much longer output than the &amp;ldquo;compact&amp;rdquo; format used when it is off. It is on by default.</source>
          <target state="translated">설정되면 &lt;code&gt;debug_pretty_print&lt;/code&gt; 는 &lt;code&gt;debug_print_parse&lt;/code&gt; , &lt;code&gt;debug_print_rewritten&lt;/code&gt; 또는 &lt;code&gt;debug_print_plan&lt;/code&gt; 에 의해 생성 된 메시지를 들여 씁니다 . 따라서 꺼져있을 때 사용되는 &quot;컴팩트&quot;형식보다 더 읽기 쉽고 출력이 훨씬 길어집니다. 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9655c6cce4ab0fb89202aa42165255e7c2310c07" translate="yes" xml:space="preserve">
          <source>When setting any of these parameters, a relative path will be interpreted with respect to the directory in which &lt;code&gt;postgres&lt;/code&gt; is started.</source>
          <target state="translated">이러한 매개 변수를 설정하면 &lt;code&gt;postgres&lt;/code&gt; 가 시작된 디렉토리와 관련하여 상대 경로가 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5cba5ccebd44827dbe97e5c58205ecd19cd5549" translate="yes" xml:space="preserve">
          <source>When several data types share near-identical sorting semantics, their operator classes can be grouped into an operator family. Doing so is advantageous because it allows the planner to make deductions about cross-type comparisons. Each operator class within the family should contain the single-type operators (and associated support functions) for its input data type, while cross-type comparison operators and support functions are &amp;ldquo;loose&amp;rdquo; in the family. It is recommendable that a complete set of cross-type operators be included in the family, thus ensuring that the planner can represent any comparison conditions that it deduces from transitivity.</source>
          <target state="translated">여러 데이터 유형이 거의 동일한 정렬 의미를 공유하는 경우 해당 연산자 클래스를 연산자 제품군으로 그룹화 할 수 있습니다. 그렇게하면 플래너가 교차 유형 비교에 대해 추론 할 수 있기 때문에 유리합니다. 제품군 내의 각 연산자 클래스에는 입력 데이터 유형에 대한 단일 유형 연산자 (및 관련 지원 기능)가 포함되어야하며, 교차 유형 비교 연산자 및 지원 기능은 제품군에서 &quot;느슨합니다&quot;. 전체 교차 유형 연산자 세트를 제품군에 포함시키는 것이 좋습니다. 따라서 플래너는 전이성에서 추론하는 비교 조건을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb221d1e490779006a131832600e7b4ca11a22c2" translate="yes" xml:space="preserve">
          <source>When showing progress (option &lt;code&gt;-P&lt;/code&gt;), use a timestamp (Unix epoch) instead of the number of seconds since the beginning of the run. The unit is in seconds, with millisecond precision after the dot. This helps compare logs generated by various tools.</source>
          <target state="translated">진행률을 표시 할 때 (옵션 &lt;code&gt;-P&lt;/code&gt; ), 실행 시작 이후 시간 (초) 대신 시간 소인 (Unix epoch)을 사용하십시오. 단위는 초 단위이며 도트 뒤에 밀리 초 단위로 표시됩니다. 이를 통해 다양한 도구로 생성 된 로그를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc026cecf0c9d705d368f497265f6e7182739df8" translate="yes" xml:space="preserve">
          <source>When sorting &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; data types, IPv4 addresses will always sort before IPv6 addresses, including IPv4 addresses encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::ffff:10.4.3.2.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 또는 &lt;code&gt;cidr&lt;/code&gt; 데이터 유형을 정렬 할 때 IPv4 주소는 :: 10.2.3.4 또는 :: ffff : 10.4.3.2와 같이 IPv6 주소에 캡슐화되거나 매핑 된 IPv4 주소를 포함하여 IPv6 주소보다 항상 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="00112c1a0dfb2756ee57aac0f953ab1b28e8aa6b" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">지정된 경우, 대응하는 위임 &lt;code&gt;index_column_name&lt;/code&gt; 또는 &lt;code&gt;index_expression&lt;/code&gt; 을 위해 특정 정렬을 사용 추론 중에 일치한다. 데이터 정렬은 일반적으로 제약 조건 위반이 발생하는지 여부에 영향을 미치지 않으므로 일반적으로 생략됩니다. &lt;code&gt;CREATE INDEX&lt;/code&gt; 형식을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="49ab9aed56a17743958b35c4487c001e52ad9448" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use particular operator class in order to be matched during inference. Typically this is omitted, as the &lt;em&gt;equality&lt;/em&gt; semantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">지정된 경우, 대응하는 위임 &lt;code&gt;index_column_name&lt;/code&gt; 또는 &lt;code&gt;index_expression&lt;/code&gt; 을 위해 특별한 연산자 클래스를 사용하여 추론 중에 일치한다. 일반적으로 &lt;em&gt;항등&lt;/em&gt; 시맨틱은 유형의 연산자 클래스에서 동일하거나 정의 된 고유 색인에 적절한 항등 정의가 있다고 신뢰하기에 충분하므로 일반적으로 생략됩니다 . &lt;code&gt;CREATE INDEX&lt;/code&gt; 형식을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="cb6cddffb6a42656d1b6071c587cfd75339041b2" translate="yes" xml:space="preserve">
          <source>When specifying a function by name rather than by OID, the allowed input is the same as for the &lt;code&gt;regprocedure&lt;/code&gt; data type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;). An example is:</source>
          <target state="translated">OID가 아닌 이름으로 함수를 지정할 때 허용되는 입력은 &lt;code&gt;regprocedure&lt;/code&gt; 데이터 유형 과 동일 합니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 예 :</target>
        </trans-unit>
        <trans-unit id="f47b14844e6f65e1969fe664f76645a83ada8978" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;program&lt;/code&gt; option, keep in mind that the option string is executed by the shell. If you need to pass any arguments to the command that come from an untrusted source, you must be careful to strip or escape any characters that might have special meaning to the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">&lt;code&gt;program&lt;/code&gt; 옵션을 지정할 때 옵션 문자열은 쉘에 의해 실행됩니다. 신뢰할 수없는 소스에서 온 명령에 인수를 전달해야하는 경우 쉘에 특별한 의미가있는 문자를 제거하거나 이스케이프해야합니다. 보안상의 이유로 고정 명령 문자열을 사용하거나 사용자 입력을 전달하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a86f4916e3e42d9bf0f446f6ed8f6c9365f0b9b8" translate="yes" xml:space="preserve">
          <source>When starting a client session via libpq, parameter settings can be specified using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable. Settings established in this way constitute defaults for the life of the session, but do not affect other sessions. For historical reasons, the format of &lt;code&gt;PGOPTIONS&lt;/code&gt; is similar to that used when launching the &lt;code&gt;postgres&lt;/code&gt; command; specifically, the &lt;code&gt;-c&lt;/code&gt; flag must be specified. For example,</source>
          <target state="translated">libpq를 통해 클라이언트 세션을 시작할 때 &lt;code&gt;PGOPTIONS&lt;/code&gt; 환경 변수를 사용하여 매개 변수 설정을 지정할 수 있습니다 . 이러한 방식으로 설정된 설정은 세션 수명 동안 기본값을 구성하지만 다른 세션에는 영향을 미치지 않습니다. 역사적 이유로 &lt;code&gt;PGOPTIONS&lt;/code&gt; 의 형식은 &lt;code&gt;postgres&lt;/code&gt; 명령을 시작할 때 사용 된 형식 과 유사합니다 . 특히, &lt;code&gt;-c&lt;/code&gt; 플래그를 지정해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8b3e57832327b1f4cd35e9869284543eb2583802" translate="yes" xml:space="preserve">
          <source>When starting the target, PostgreSQL replays all the required WAL, resulting in a data directory in a consistent state.</source>
          <target state="translated">대상을 시작할 때 PostgreSQL은 필요한 모든 WAL을 재생하여 데이터 디렉터리를 일관된 상태로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="80810b3a36d5394cd36078211fe98f572205f903" translate="yes" xml:space="preserve">
          <source>When suitable, query results can be shown in a crosstab representation with the &lt;code&gt;\crosstabview&lt;/code&gt; command:</source>
          <target state="translated">적절한 경우 쿼리 결과는 &lt;code&gt;\crosstabview&lt;/code&gt; 명령을 사용하여 크로스 탭 표현으로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4333b702c3660525cc0e63ef6d85c05931c74735" translate="yes" xml:space="preserve">
          <source>When tar format is used, it is the user's responsibility to unpack each tar file before starting a PostgreSQL server that uses the data. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar 형식을 사용하는 경우 데이터를 사용하는 PostgreSQL 서버를 시작하기 전에 각 tar 파일의 압축을 푸는 것은 사용자의 책임입니다. 추가 테이블 스페이스가있는 경우 해당 테이블 스페이스에 대한 tar 파일을 올바른 위치에 압축 해제해야합니다. 이 경우 해당 테이블 스페이스에 대한 심볼릭 링크 는 &lt;code&gt;base.tar&lt;/code&gt; 파일에 포함 된 &lt;code&gt;tablespace_map&lt;/code&gt; 파일 의 내용에 따라 서버에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4ddbde0da0e9c11c9f3ba6aaa05f9fc0b15fe03" translate="yes" xml:space="preserve">
          <source>When tar format is used, the write-ahead log files will be included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar 형식을 사용하면 미리 쓰기 로그 파일이 &lt;code&gt;base.tar&lt;/code&gt; 파일에 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="7e8dcb5224676a60278f816ad09b8db2eb2d49b5" translate="yes" xml:space="preserve">
          <source>When tar format is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">tar 형식을 사용하면 미리 쓰기 로그 파일이 &lt;code&gt;pg_wal.tar&lt;/code&gt; 라는 별도의 파일에 기록됩니다 (서버 버전이 10 이전 인 경우 파일 이름은 &lt;code&gt;pg_xlog.tar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a46f34ffb8c110010cfd3fe050b49b5689c1e534" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, it is the user's responsibility to unpack each tar file before starting the PostgreSQL server. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar 형식 모드를 사용하는 경우 PostgreSQL 서버를 시작하기 전에 각 tar 파일의 압축을 풀어야합니다. 추가 테이블 스페이스가있는 경우 해당 테이블 스페이스의 tar 파일을 올바른 위치에 압축 해제해야합니다. 이 경우, 해당 테이블 공간에 대한 기호 링크 는 &lt;code&gt;base.tar&lt;/code&gt; 파일에 포함 된 &lt;code&gt;tablespace_map&lt;/code&gt; 파일 의 내용에 따라 서버에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="34c7d99e4e21933c48e46c135fcf1d89d1aca09e" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">tar 형식 모드를 사용하는 경우 미리 쓰기 로그 파일은 &lt;code&gt;pg_wal.tar&lt;/code&gt; 라는 별도의 파일에 기록됩니다 (서버가 10보다 이전 버전 인 경우 파일 이름은 &lt;code&gt;pg_xlog.tar&lt;/code&gt; ).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
