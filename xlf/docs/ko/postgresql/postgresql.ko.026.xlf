<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="13bf3c4060b6a548c1c5420c5acc0dd3edcdfdfa" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar 형식 모드를 사용하면 미리 쓰기 로그 파일이 &lt;code&gt;base.tar&lt;/code&gt; 파일에 기록 됩니다.</target>
        </trans-unit>
        <trans-unit id="f11ae7cfc9d8e7c9709340ffb2024d1b68d62efb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; parameter is set to true on a standby server, it will begin accepting connections once the recovery has brought the system to a consistent state. All such connections are strictly read-only; not even temporary tables may be written.</source>
          <target state="translated">대기 서버 에서 &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; 매개 변수가 true로 설정되면 복구가 시스템을 일관된 상태로 만들면 연결을 수락하기 시작합니다. 이러한 연결은 모두 읽기 전용입니다. 임시 테이블조차 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7959e96ecaba15e9d39e3fc41cafc94b8dcfae7f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CONSTRAINT&lt;/code&gt; option is specified, this command creates a &lt;em&gt;constraint trigger&lt;/em&gt;. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;. Constraint triggers must be &lt;code&gt;AFTER ROW&lt;/code&gt; triggers on plain tables (not foreign tables). They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be &lt;em&gt;deferred&lt;/em&gt;. A pending deferred-trigger firing can also be forced to happen immediately by using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</source>
          <target state="translated">때 &lt;code&gt;CONSTRAINT&lt;/code&gt; 옵션을 지정,이 명령은 생성 &lt;em&gt;제약 조건 트리거를&lt;/em&gt; . 이는 &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS를&lt;/a&gt; 사용하여 트리거 발생 타이밍을 조정할 수 있다는 점을 제외하면 일반 트리거와 동일합니다 . 제한 조건 트리거는 외부 테이블이 아닌 일반 테이블에서 &lt;code&gt;AFTER ROW&lt;/code&gt; 트리거 여야합니다 . 트리거 이벤트를 발생시키는 명령문의 끝 또는 포함 트랜잭션의 끝에서 실행될 수 있습니다. 후자의 경우에는 &lt;em&gt;연기&lt;/em&gt; 된다고한다 . &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 를 사용하여 보류중인 지연 트리거 발생을 즉시 강제 할 수도 있습니다 . 구속 조건 트리거는 구현 한 구속 조건을 위반할 때 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="df5c7d4a7ad0b452626a13ac455de82c0906adea" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;SELECT&lt;/code&gt; is one arm of a &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) construct, or when it appears within &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, this rule is not applied since rules given in preceding sections take precedence. The type of an unspecified-type literal can be taken from the other &lt;code&gt;UNION&lt;/code&gt; arm in the first case, or from the destination column in the second case.</source>
          <target state="translated">경우 &lt;code&gt;SELECT&lt;/code&gt; 는 하나 개의 암이다 &lt;code&gt;UNION&lt;/code&gt; (또는 &lt;code&gt;INTERSECT&lt;/code&gt; 또는 &lt;code&gt;EXCEPT&lt;/code&gt; ) 구조, 또는 그 안에 나타날 때 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; ,이 규칙은 섹션 우선 이전에 주어진 규칙 때문에 적용되지 않는다. 지정되지 않은 유형 리터럴의 유형 은 첫 번째 경우 의 다른 &lt;code&gt;UNION&lt;/code&gt; 암 또는 두 번째 경우의 대상 열에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f2ffb48d56de0e4aaa18bb9efa3e04da4e9e279" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;WHERE&lt;/code&gt; clause is present, a &lt;em&gt;partial index&lt;/em&gt; is created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to use &lt;code&gt;WHERE&lt;/code&gt; with &lt;code&gt;UNIQUE&lt;/code&gt; to enforce uniqueness over a subset of a table. See &lt;a href=&quot;indexes-partial&quot;&gt;Section 11.8&lt;/a&gt; for more discussion.</source>
          <target state="translated">때 &lt;code&gt;WHERE&lt;/code&gt; 의 조항이 존재하는 &lt;em&gt;부분의 인덱스가&lt;/em&gt; 생성된다. 부분 인덱스는 테이블의 일부에 대한 항목, 일반적으로 나머지 테이블보다 인덱싱에 더 유용한 항목을 포함하는 인덱스입니다. 예를 들어, 청구되지 않은 주문이 총 테이블의 작은 부분을 차지하지만 자주 사용되는 섹션 인 청구 및 미 청구 주문이 모두 포함 된 테이블이있는 경우 해당 부분에 대해서만 색인을 작성하여 성능을 향상시킬 수 있습니다. 또 다른 가능한 응용 프로그램은 &lt;code&gt;WHERE&lt;/code&gt; 를 &lt;code&gt;UNIQUE&lt;/code&gt; 와 함께 사용 하여 테이블의 하위 집합에 고유성을 적용하는 것입니다. 자세한 내용 &lt;a href=&quot;indexes-partial&quot;&gt;은 11.8 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4116b168926d645beb5cdf62d04cc02528b0adbd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;\aset&lt;/code&gt; command is used, all combined SQL queries (separated by &lt;code&gt;\;&lt;/code&gt;) have their columns stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided. If a query returns no row, no assignment is made and the variable can be tested for existence to detect this. If a query returns more than one row, the last value is kept.</source>
          <target state="translated">때 &lt;code&gt;\aset&lt;/code&gt; 명령이 사용되며, 결합 된 모든 SQL 쿼리 (의해 분리는 &lt;code&gt;\;&lt;/code&gt; ) 그 열은 열 이름을 따서 변수에 저장하고, 앞에 둔으로 한 &lt;code&gt;prefix&lt;/code&gt; 제공된 경우. 쿼리가 행을 반환하지 않으면 할당이 이루어지지 않으며 변수가 존재하는지 테스트하여이를 감지 할 수 있습니다. 쿼리가 둘 이상의 행을 반환하는 경우 마지막 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="438baff021646797a12e7710aeb9b4212d4a00b5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;\gset&lt;/code&gt; command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="translated">때 &lt;code&gt;\gset&lt;/code&gt; 명령을 사용하는 경우, 위의 SQL 쿼리가 하나 개의 행을 반환 할 것으로 예상된다,의 열은 열 이름의 이름을 따서 명명 변수에 저장하고, 앞에 둔과 함께하는 &lt;code&gt;prefix&lt;/code&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8c185ac9497904ca6d14d82c8dc0a0e1690d4901" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ampredlocks&lt;/code&gt; flag is not set, any scan using that index access method within a serializable transaction will acquire a nonblocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations.</source>
          <target state="translated">때 &lt;code&gt;ampredlocks&lt;/code&gt; 의 플래그는 전체 인덱스에 블로킹 술어 잠금을 획득하는 직렬화 가능 트랜잭션 내에서 해당 인덱스 액세스 방법을 사용하여 임의의 스캔 설정되어 있지 않습니다. 이렇게하면 동시 직렬화 가능 트랜잭션에 의해 해당 인덱스에 튜플을 삽입 할 때 읽기 / 쓰기 충돌이 발생합니다. 일련의 동시 직렬화 가능 트랜잭션 세트에서 특정 패턴의 읽기 / 쓰기 충돌이 감지되면 해당 트랜잭션 중 하나가 취소되어 데이터 무결성을 보호 할 수 있습니다. 플래그가 설정되면 이는 인덱스 액세스 방법이보다 세분화 된 술어 잠금을 구현하므로 이러한 트랜잭션 취소 빈도를 줄이는 경향이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32c110466857121d054324f74c8a38f9bb5212e4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;border&lt;/code&gt; setting is greater than zero, the &lt;code&gt;linestyle&lt;/code&gt; option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them.</source>
          <target state="translated">때 &lt;code&gt;border&lt;/code&gt; 설정이 0보다 크면 &lt;code&gt;linestyle&lt;/code&gt; 옵션은 경계선이 그려있는 문자를 결정합니다. 일반 ASCII 문자는 모든 곳에서 작동하지만 유니 코드 문자는이를 인식하는 디스플레이에서 더보기 좋습니다.</target>
        </trans-unit>
        <trans-unit id="00d6a0dfb20c2e25ada6bca76d0486b409be8ef1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;off&lt;/code&gt;, the pager program is not used. When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;on&lt;/code&gt;, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The &lt;code&gt;pager&lt;/code&gt; option can also be set to &lt;code&gt;always&lt;/code&gt;, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. &lt;code&gt;\pset pager&lt;/code&gt; without a &lt;code&gt;value&lt;/code&gt; toggles pager use on and off.</source>
          <target state="translated">때 &lt;code&gt;pager&lt;/code&gt; 옵션은 &lt;code&gt;off&lt;/code&gt; , 페이저 프로그램은 사용되지 않습니다. &lt;code&gt;pager&lt;/code&gt; 옵션이 &lt;code&gt;on&lt;/code&gt; 있으면 호출기가 적절한 경우, 즉 출력이 터미널에 있고 화면에 맞지 않을 때 사용됩니다. &lt;code&gt;pager&lt;/code&gt; 옵션은 설정할 수 있습니다 &lt;code&gt;always&lt;/code&gt; 관계없이 화면에 맞는지의 모든 터미널 출력에 사용되는 호출기가 발생한다. &lt;code&gt;value&lt;/code&gt; 없는 &lt;code&gt;\pset pager&lt;/code&gt; 는 호출기 사용을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="81a140433737ca4c23a575624ce695fcc511dede" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_buffercache&lt;/code&gt; view is accessed, internal buffer manager locks are taken for long enough to copy all the buffer state data that the view will display. This ensures that the view produces a consistent set of results, while not blocking normal buffer activity longer than necessary. Nonetheless there could be some impact on database performance if this view is read often.</source>
          <target state="translated">때 &lt;code&gt;pg_buffercache&lt;/code&gt; 된 뷰를 액세스하고, 내부 버퍼 관리자 잠금 뷰가 표시하는 모든 버퍼 상태 데이터를 복사하기 위해 충분히 오래 소요된다. 이렇게하면 뷰가 일관된 결과 세트를 생성하는 동시에 정상 버퍼 활동을 필요 이상으로 차단하지 않습니다. 그럼에도 불구하고이 뷰를 자주 읽으면 데이터베이스 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd60a2856753e705f8fe475e92d422e142a5a733" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_prepared_xacts&lt;/code&gt; view is accessed, the internal transaction manager data structures are momentarily locked, and a copy is made for the view to display. This ensures that the view produces a consistent set of results, while not blocking normal operations longer than necessary. Nonetheless there could be some impact on database performance if this view is frequently accessed.</source>
          <target state="translated">때 &lt;code&gt;pg_prepared_xacts&lt;/code&gt; 의 뷰를 액세스 내부 트랜잭션 관리 데이터 구조를 잠깐 고정되며, 복사본 디스플레이 뷰에 대해 이루어진다. 이렇게하면 뷰가 일관된 결과 집합을 생성하는 동시에 정상 작업을 필요 이상으로 차단하지 않습니다. 그럼에도 불구하고이 뷰에 자주 액세스하면 데이터베이스 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ee8be71b9dbdb6fe9839b8abd30a5d0ca45b722" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;text&lt;/code&gt; format is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null. &lt;code&gt;COPY FROM&lt;/code&gt; will raise an error if any line of the input file contains more or fewer columns than are expected.</source>
          <target state="translated">때 &lt;code&gt;text&lt;/code&gt; 형식을 사용하는 데이터를 읽거나 테이블 행 당 하나의 선으로 텍스트 파일입니다 작성. 행의 열은 구분 문자로 구분됩니다. 열 값 자체는 각 속성 데이터 유형의 출력 함수에 의해 생성되거나 입력 함수에 허용되는 문자열입니다. 널이 아닌 열 대신 지정된 널 문자열이 사용됩니다. 입력 파일의 행에 예상보다 많은 열이 포함되어 있으면 &lt;code&gt;COPY FROM&lt;/code&gt; 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1c4c47cbbcff114da7b14a508ba7d65a0b19eac7" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; argument to verification functions is &lt;code&gt;true&lt;/code&gt;, an additional phase of verification is performed against the table associated with the target index relation. This consists of a &amp;ldquo;dummy&amp;rdquo;&lt;code&gt;CREATE INDEX&lt;/code&gt; operation, which checks for the presence of all hypothetical new index tuples against a temporary, in-memory summarizing structure (this is built when needed during the basic first phase of verification). The summarizing structure &amp;ldquo;fingerprints&amp;rdquo; every tuple found within the target index. The high level principle behind &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is that a new index that is equivalent to the existing, target index must only have entries that can be found in the existing structure.</source>
          <target state="translated">검증 함수에 대한 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우 대상 인덱스 관계와 연관된 테이블에 대해 추가 검증 단계가 수행됩니다. 이것은 &quot;더미&quot; &lt;code&gt;CREATE INDEX&lt;/code&gt; 연산으로 구성되며 , 임시 인 메모리 요약 구조 (기본 검증 단계에서 필요할 때 작성 됨)에 대해 모든 가상의 새 인덱스 튜플이 있는지 확인합니다. 요약 구조는 대상 인덱스에서 찾은 모든 튜플을 &quot;지문&quot;합니다. &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 인덱스 &lt;em&gt;화&lt;/em&gt; 검증의 기본 원리 는 기존의 대상 인덱스와 동일한 새 인덱스가 기존 구조에서 찾을 수있는 항목 만 가져야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40b2d91686c90899997e62b0858a7f4eb03cb150" translate="yes" xml:space="preserve">
          <source>When the backup is in tar format, the target directory may be specified as &lt;code&gt;-&lt;/code&gt; (dash), causing the tar file to be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">백업이 tar 형식이면 대상 디렉토리가 &lt;code&gt;-&lt;/code&gt; (대시) 로 지정되어 tar 파일이 &lt;code&gt;stdout&lt;/code&gt; 에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4898e6eb712c6c928410a4432225d77730464bb" translate="yes" xml:space="preserve">
          <source>When the backup is in tar mode, and the directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar file will be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">백업이 tar 모드이고 디렉토리가 &lt;code&gt;-&lt;/code&gt; (대시) 로 지정 되면 tar 파일이 &lt;code&gt;stdout&lt;/code&gt; 에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bf62b247e8d0c8ddb36cb4a11374b1155c5b650" translate="yes" xml:space="preserve">
          <source>When the client application uses the &amp;ldquo;extended query&amp;rdquo; protocol to issue a &lt;code&gt;FETCH&lt;/code&gt; command, the Bind protocol message specifies whether data is to be retrieved in text or binary format. This choice overrides the way that the cursor is defined. The concept of a binary cursor as such is thus obsolete when using extended query protocol &amp;mdash; any cursor can be treated as either text or binary.</source>
          <target state="translated">클라이언트 응용 프로그램이 &quot;확장 조회&quot;프로토콜을 사용하여 &lt;code&gt;FETCH&lt;/code&gt; 명령 을 발행 할 때 바인드 프로토콜 메시지는 데이터를 텍스트 또는 2 진 형식으로 검색할지 여부를 지정합니다. 이 선택은 커서가 정의 된 방식을 대체합니다. 따라서 이진 커서 개념은 확장 쿼리 프로토콜을 사용할 때는 더 이상 사용되지 않습니다. 모든 커서는 텍스트 또는 이진으로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef2bc6393c8c4a9107edf2302ecf0f071877452" translate="yes" xml:space="preserve">
          <source>When the connection to the server is lost, do not retry in a loop, just exit.</source>
          <target state="translated">서버와의 연결이 끊어지면 루프에서 다시 시도하지 말고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="c8229aa8ad36a0b0c5e6146511e976844f24d945" translate="yes" xml:space="preserve">
          <source>When the database generates SQL, force all identifiers to be quoted, even if they are not (currently) keywords. This will affect the output of &lt;code&gt;EXPLAIN&lt;/code&gt; as well as the results of functions like &lt;code&gt;pg_get_viewdef&lt;/code&gt;. See also the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option of &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; and &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;.</source>
          <target state="translated">데이터베이스가 SQL을 생성 할 때 (현재) 키워드가 아니더라도 모든 식별자를 인용하도록합니다. 이것은 &lt;code&gt;pg_get_viewdef&lt;/code&gt; 와 같은 함수의 결과뿐만 아니라 &lt;code&gt;EXPLAIN&lt;/code&gt; 의 출력에도 영향을 미칩니다 . &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; 및 &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt; 의 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea2bc8f44657321dd80c423b48806c42005dbc7a" translate="yes" xml:space="preserve">
          <source>When the database system has to perform an ordering or a character classification, it uses the collation of the input expression. This happens, for example, with &lt;code&gt;ORDER BY&lt;/code&gt; clauses and function or operator calls such as &lt;code&gt;&amp;lt;&lt;/code&gt;. The collation to apply for an &lt;code&gt;ORDER BY&lt;/code&gt; clause is simply the collation of the sort key. The collation to apply for a function or operator call is derived from the arguments, as described below. In addition to comparison operators, collations are taken into account by functions that convert between lower and upper case letters, such as &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt;; by pattern matching operators; and by &lt;code&gt;to_char&lt;/code&gt; and related functions.</source>
          <target state="translated">데이터베이스 시스템은 순서화 또는 문자 분류를 수행해야하는 경우 입력 표현식의 데이터 정렬을 사용합니다. 예를 들어 &lt;code&gt;ORDER BY&lt;/code&gt; 절과 함수 또는 연산자 호출 ( &lt;code&gt;&amp;lt;&lt;/code&gt; 등)을 사용하면 이러한 상황이 발생합니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 절 에 적용 할 데이터 정렬 은 단순히 정렬 키의 데이터 정렬입니다. 함수 또는 연산자 호출에 적용 할 데이터 정렬은 아래 설명 된대로 인수에서 파생됩니다. 비교 연산자 외에도 &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; 및 &lt;code&gt;initcap&lt;/code&gt; 과 같이 소문자와 대문자를 변환하는 함수에 의해 데이터 정렬이 고려됩니다 . 패턴 매칭 연산자에 의해; &lt;code&gt;to_char&lt;/code&gt; 및 관련 함수에 의해 .</target>
        </trans-unit>
        <trans-unit id="cf20c03f9a438d0f6675629396820f040d752814" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">기본값이 정확하지 않은 경우 환경 변수 &lt;code&gt;PGDATABASE&lt;/code&gt; , &lt;code&gt;PGHOST&lt;/code&gt; , &lt;code&gt;PGPORT&lt;/code&gt; 및 / 또는 &lt;code&gt;PGUSER&lt;/code&gt; 를 적절한 값 으로 설정하여 입력을 절약 할 수 있습니다 . (추가 환경 변수에 대해서는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;33.14 절을&lt;/a&gt; 참조하십시오 .) 정기적으로 암호를 입력하지 않도록 &lt;code&gt;~/.pgpass&lt;/code&gt; 파일을 사용 하는 것이 편리 합니다. 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;33.15 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f26c72fbc997c040dd4a76409d282497125e57c" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">기본값이 정확하지 않은 경우 환경 변수 &lt;code&gt;PGDATABASE&lt;/code&gt; , &lt;code&gt;PGHOST&lt;/code&gt; , &lt;code&gt;PGPORT&lt;/code&gt; 및 / 또는 &lt;code&gt;PGUSER&lt;/code&gt; 를 적절한 값 으로 설정하여 입력을 절약 할 수 있습니다 . (추가 환경 변수에 대해서는 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;섹션 33.14를&lt;/a&gt; 참조하십시오 .) &lt;code&gt;~/.pgpass&lt;/code&gt; 파일을 사용하여 정기적으로 암호를 입력하지 않아도되는 것도 편리 합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-pgpass.html&quot;&gt;섹션 33.15&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58644d348761a861122023ab84e086a5de61b1bd" translate="yes" xml:space="preserve">
          <source>When the input value is +/-Infinity, &lt;code&gt;extract&lt;/code&gt; returns +/-Infinity for monotonically-increasing fields (&lt;code&gt;epoch&lt;/code&gt;, &lt;code&gt;julian&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;isoyear&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, and &lt;code&gt;millennium&lt;/code&gt;). For other fields, NULL is returned. PostgreSQL versions before 9.6 returned zero for all cases of infinite input.</source>
          <target state="translated">입력 값이 +/- Infinity 인 경우 &lt;code&gt;extract&lt;/code&gt; 는 단조 증가하는 필드 ( &lt;code&gt;epoch&lt;/code&gt; , &lt;code&gt;julian&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;isoyear&lt;/code&gt; , &lt;code&gt;decade&lt;/code&gt; , &lt;code&gt;century&lt;/code&gt; 및 &lt;code&gt;millennium&lt;/code&gt; )에 대해 +/- Infinity를 반환합니다 . 다른 필드의 경우 NULL이 반환됩니다. 9.6 이전의 PostgreSQL 버전은 모든 무한 입력의 경우 0을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="ca7b95a2bfd76e66a3b9a3c283932ae7ceb9d1f3" translate="yes" xml:space="preserve">
          <source>When the input value is of type &lt;code&gt;timestamp with time zone&lt;/code&gt;, the truncation is performed with respect to a particular time zone; for example, truncation to &lt;code&gt;day&lt;/code&gt; produces a value that is midnight in that zone. By default, truncation is done with respect to the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, but the optional &lt;code&gt;time_zone&lt;/code&gt; argument can be provided to specify a different time zone. The time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">입력 값이 &lt;code&gt;timestamp with time zone&lt;/code&gt; 가있는 타임 스탬프 유형 인 경우 절단은 특정 시간대에 대해 수행됩니다. 예를 들어, &lt;code&gt;day&lt;/code&gt; 자르기 는 해당 영역의 자정 값을 생성합니다. 기본적으로 현재 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;시간대&lt;/a&gt; 설정 과 관련하여 잘림이 수행 되지만 다른 시간대를 지정하기 위해 선택적 &lt;code&gt;time_zone&lt;/code&gt; 인수를 제공 할 수 있습니다. 표준 시간대 이름은 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3 절에&lt;/a&gt; 설명 된 방법 중 하나로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9861851aff8e3d639ce4f8c2222c534c2772377" translate="yes" xml:space="preserve">
          <source>When the last argument begins with &lt;code&gt;|&lt;/code&gt;, the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">마지막 인수가 &lt;code&gt;|&lt;/code&gt; , 행의 나머지 전체 가 실행 &lt;code&gt;command&lt;/code&gt; 되며 변수 보간이나 역 따옴표 확장이 수행되지 않습니다. 나머지 줄은 문자 그대로 셸로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fb992423a64d9af4e9c24a6d03361c5985029c38" translate="yes" xml:space="preserve">
          <source>When the node at the top of the parallel portion of the plan is &lt;code&gt;Gather Merge&lt;/code&gt; rather than &lt;code&gt;Gather&lt;/code&gt;, it indicates that each process executing the parallel portion of the plan is producing tuples in sorted order, and that the leader is performing an order-preserving merge. In contrast, &lt;code&gt;Gather&lt;/code&gt; reads tuples from the workers in whatever order is convenient, destroying any sort order that may have existed.</source>
          <target state="translated">평면의 평행 부 상단의 노드 인 경우에는 &lt;code&gt;Gather Merge&lt;/code&gt; 보다는 &lt;code&gt;Gather&lt;/code&gt; , 상기 평면의 평행 부분의 실행 각 프로세스 정렬 된 순서 튜플 제조되어, 상기 선두 명령 보존 병합을 수행하고 있음을 나타낸다 . 반대로, &lt;code&gt;Gather&lt;/code&gt; 는 편리한 순서대로 작업자로부터 튜플을 읽으며 존재하는 정렬 순서를 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="3c8d54f7450d49b82cd5a8da77194f4c25e5cdb1" translate="yes" xml:space="preserve">
          <source>When the operating system sends a write request to the storage hardware, there is little it can do to make sure the data has arrived at a truly non-volatile storage area. Rather, it is the administrator's responsibility to make certain that all storage components ensure integrity for both data and file-system metadata. Avoid disk controllers that have non-battery-backed write caches. At the drive level, disable write-back caching if the drive cannot guarantee the data will be written before shutdown. If you use SSDs, be aware that many of these do not honor cache flush commands by default. You can test for reliable I/O subsystem behavior using &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt;&lt;code&gt;diskchecker.pl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">운영 체제가 스토리지 하드웨어에 쓰기 요청을 보낼 때 데이터가 실제로 비 휘발성 스토리지 영역에 도착했는지 확인하는 방법은 거의 없습니다. 오히려 모든 스토리지 구성 요소가 데이터 및 파일 시스템 메타 데이터에 대한 무결성을 보장하도록하는 것은 관리자의 책임입니다. 배터리가 지원되지 않는 쓰기 캐시가있는 디스크 컨트롤러를 피하십시오. 드라이브 수준에서 드라이브가 종료 전에 데이터 쓰기를 보장 할 수없는 경우 후기 입 캐싱을 비활성화하십시오. SSD를 사용하는 경우,이 중 다수는 기본적으로 캐시 플러시 명령을 따르지 않습니다. &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt; &lt;code&gt;diskchecker.pl&lt;/code&gt; 을&lt;/a&gt; 사용하여 안정적인 I / O 하위 시스템 동작을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d33bb04f73c12f42af37757660638f7bf07dd0c" translate="yes" xml:space="preserve">
          <source>When the optimizer determines that parallel query is the fastest execution strategy for a particular query, it will create a query plan which includes a &lt;em&gt;Gather&lt;/em&gt; or &lt;em&gt;Gather Merge&lt;/em&gt; node. Here is a simple example:</source>
          <target state="translated">옵티마이 저가 병렬 쿼리가 특정 쿼리에 대한 가장 빠른 실행 전략이라고 판단하면 &lt;em&gt;수집&lt;/em&gt; 또는 &lt;em&gt;병합 병합&lt;/em&gt; 노드 를 포함하는 쿼리 계획을 생성 합니다. 다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="01b643d7a7954ad91561b8c24a008664f59d15dd" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. The parenthesized syntax was added in PostgreSQL 11; the unparenthesized syntax is deprecated.</source>
          <target state="translated">옵션 목록을 괄호로 묶으면 옵션을 임의의 순서로 작성할 수 있습니다. 괄호로 묶은 구문이 PostgreSQL 11에 추가되었습니다. 괄호로 묶지 않은 구문은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abee5df8a890efa75529bd092cf02d64e5f74e41" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. Without parentheses, options must be specified in exactly the order shown above. The parenthesized syntax was added in PostgreSQL 9.0; the unparenthesized syntax is deprecated.</source>
          <target state="translated">옵션 목록을 괄호로 묶으면 옵션을 임의의 순서로 작성할 수 있습니다. 괄호없이 옵션은 위에 표시된 순서대로 정확하게 지정해야합니다. 괄호로 묶은 구문은 PostgreSQL 9.0에서 추가되었습니다. 괄호로 묶지 않은 구문은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e9dc738f4097cde58c9e8bf1cce2f13a3e0faff" translate="yes" xml:space="preserve">
          <source>When the query executor is running a statement using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, individual operations are timed as well as showing a summary. The overhead of your system can be checked by counting rows with the psql program:</source>
          <target state="translated">쿼리 실행자가 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 를 사용하여 명령문을 실행하는 경우 개별 조작의 시간이 지정되고 요약이 표시됩니다. psql 프로그램으로 행을 계산하여 시스템의 오버 헤드를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4efc71382094156bb1e14ebb8922c4bbfee26e8" translate="yes" xml:space="preserve">
          <source>When the query involves more than two relations, the final result must be built up by a tree of join steps, each with two inputs. The planner examines different possible join sequences to find the cheapest one.</source>
          <target state="translated">쿼리에 두 개 이상의 관계가 포함 된 경우 최종 결과는 각각 두 개의 입력이있는 조인 단계 트리로 구성해야합니다. 플래너는 가능한 다른 조인 시퀀스를 검사하여 가장 저렴한 조인 시퀀스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f91c3e21cf6bd9480dad3eeeece86758f55a90e3" translate="yes" xml:space="preserve">
          <source>When the query involves outer joins, the planner has less freedom than it does for plain (inner) joins. For example, consider:</source>
          <target state="translated">쿼리에 외부 조인이 포함되면 플래너는 일반 (내부) 조인보다 자유도가 떨어집니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="53d57a11c26095ca3bee53a6ad82668d9cd1b948" translate="yes" xml:space="preserve">
          <source>When the replication client of pg_receivewal is configured on the server as a synchronous standby, then using a replication slot will report the flush position to the server, but only when a WAL file is closed. Therefore, that configuration will cause transactions on the primary to wait for a long time and effectively not work satisfactorily. The option &lt;code&gt;--synchronous&lt;/code&gt; (see below) must be specified in addition to make this work correctly.</source>
          <target state="translated">pg_receivewal의 복제 클라이언트가 서버에서 동기 대기로 구성된 경우 복제 슬롯을 사용하면 서버에 플러시 위치가보고되지만 WAL 파일이 닫힐 때만 해당됩니다. 따라서 해당 구성으로 인해 기본의 트랜잭션이 오랫동안 대기하고 효과적으로 작동하지 않습니다. 이 작업을 올바르게 수행하려면 &lt;code&gt;--synchronous&lt;/code&gt; (아래 참조) 옵션을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e97e877617ee50758f9c1ed0038c82401b37ff4" translate="yes" xml:space="preserve">
          <source>When the server finds an entry in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog for the given language name, it will use the catalog data even if the command includes language parameters. This behavior simplifies loading of old dump files, which are likely to contain out-of-date information about language support functions.</source>
          <target state="translated">서버는 주어진 언어 이름 에 대한 &lt;code&gt;pg_pltemplate&lt;/code&gt; 카탈로그 에서 항목을 찾으면 명령에 언어 매개 변수가 포함되어 있어도 카탈로그 데이터를 사용합니다. 이 동작은 언어 지원 기능에 대한 오래된 정보를 포함 할 수있는 이전 덤프 파일의로드를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="826ce26725107a5df987e11185041fdbac70af26" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a &lt;code&gt;walreceiver&lt;/code&gt; in the standby, and a corresponding &lt;code&gt;walsender&lt;/code&gt; process in the primary.</source>
          <target state="translated">대기가 시작되고 &lt;code&gt;primary_conninfo&lt;/code&gt; 가 올바르게 설정되면 대기는 아카이브에서 사용 가능한 모든 WAL 파일을 재생 한 후 기본에 연결됩니다. 연결이 성공적으로 설정 되면 대기에 &lt;code&gt;walreceiver&lt;/code&gt; 가 표시 되고 기본에 해당 &lt;code&gt;walsender&lt;/code&gt; 프로세스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5acf91c2009ea693cf720914c5dcc7ec25263a3f" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a walreceiver process in the standby, and a corresponding walsender process in the primary.</source>
          <target state="translated">대기가 시작되고 &lt;code&gt;primary_conninfo&lt;/code&gt; 가 올바르게 설정되면 아카이브에서 사용 가능한 모든 WAL 파일을 재생 한 후 대기가 기본에 연결됩니다. 연결이 성공적으로 완료되면 대기에서 Walreceiver 프로세스가 표시되고 기본에서 해당 Walsender 프로세스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eedf68c3267fbf09aabeff8e3149a2fc6e02e4a5" translate="yes" xml:space="preserve">
          <source>When the system is forced to combine multiple page-level predicate locks into a single relation-level predicate lock because the predicate lock table is short of memory, an increase in the rate of serialization failures may occur. You can avoid this by increasing &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;, &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;, and/or &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt;.</source>
          <target state="translated">술어 잠금 테이블에 메모리가 부족하여 시스템이 여러 페이지 레벨 술어 잠금을 단일 관계 레벨 술어 잠금으로 결합하면 직렬화 실패 비율이 증가 할 수 있습니다. &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt; , &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt; 및 / 또는 &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt; 를 늘려 이를 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e5d69b735badff5a43514c3f20c29f9fa27a5a4" translate="yes" xml:space="preserve">
          <source>When the target server is started for the first time after running pg_rewind, it will go into recovery mode and replay all WAL generated in the source server after the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and configuring suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">pg_rewind를 실행 한 후 대상 서버를 처음 시작하면 복구 모드로 전환되어 분기 지점 이후에 소스 서버에서 생성 된 모든 WAL을 재생합니다. pg_rewind가 실행될 때 소스 서버에서 일부 WAL을 더 이상 사용할 수 없어서 pg_rewind 세션으로 복사 할 수없는 경우 대상 서버가 시작될 때 사용할 수 있어야합니다. 대상 데이터 디렉토리에 &lt;code&gt;recovery.signal&lt;/code&gt; 파일 을 작성하고 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 적절한 &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 를 구성하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="46d8ca3256e28b3a76b80a636c768a65a62af8f1" translate="yes" xml:space="preserve">
          <source>When the token is a number or number field:</source>
          <target state="translated">토큰이 숫자 또는 숫자 필드 인 경우 :</target>
        </trans-unit>
        <trans-unit id="13de437cb552624377cc1efe8012608874203a3b" translate="yes" xml:space="preserve">
          <source>When there are &lt;code&gt;OUT&lt;/code&gt; or &lt;code&gt;INOUT&lt;/code&gt; parameters, the &lt;code&gt;RETURNS&lt;/code&gt; clause can be omitted. If present, it must agree with the result type implied by the output parameters: &lt;code&gt;RECORD&lt;/code&gt; if there are multiple output parameters, or the same type as the single output parameter.</source>
          <target state="translated">있을 때 &lt;code&gt;OUT&lt;/code&gt; 또는 &lt;code&gt;INOUT&lt;/code&gt; 파라미터의 &lt;code&gt;RETURNS&lt;/code&gt; 의 항은 생략 될 수있다. 존재하는 경우 출력 매개 변수가 암시하는 결과 유형과 일치해야합니다. 여러 출력 매개 변수가있는 경우 &lt;code&gt;RECORD&lt;/code&gt; 또는 단일 출력 매개 변수와 동일한 유형.</target>
        </trans-unit>
        <trans-unit id="3cbc021b4d99bd0fb8948c27e6c55ec68fedb0d0" translate="yes" xml:space="preserve">
          <source>When there are multiple queries in the &lt;code&gt;WITH&lt;/code&gt; clause, &lt;code&gt;RECURSIVE&lt;/code&gt; should be written only once, immediately after &lt;code&gt;WITH&lt;/code&gt;. It applies to all queries in the &lt;code&gt;WITH&lt;/code&gt; clause, though it has no effect on queries that do not use recursion or forward references.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 절 에 여러 쿼리가있는 경우 &lt;code&gt;RECURSIVE&lt;/code&gt; 는 &lt;code&gt;WITH&lt;/code&gt; 바로 뒤에 한 번만 작성해야합니다 . 재귀 또는 정방향 참조를 사용하지 않는 쿼리에는 영향을주지 않지만 &lt;code&gt;WITH&lt;/code&gt; 절의 모든 쿼리에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="086da7e4c8252cf99eea2a26d212bfca20a89638" translate="yes" xml:space="preserve">
          <source>When there are no &lt;code&gt;GIN_MAYBE&lt;/code&gt; values in the &lt;code&gt;check&lt;/code&gt; vector, a &lt;code&gt;GIN_MAYBE&lt;/code&gt; return value is the equivalent of setting the &lt;code&gt;recheck&lt;/code&gt; flag in the Boolean &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; 벡터 에 &lt;code&gt;GIN_MAYBE&lt;/code&gt; 값 이없는 경우 &lt;code&gt;GIN_MAYBE&lt;/code&gt; 반환 값은 부울 &lt;code&gt;consistent&lt;/code&gt; 함수 에서 &lt;code&gt;recheck&lt;/code&gt; 플래그 를 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6d0ae32f2046467b15848b335dcbaffbcaf195f8" translate="yes" xml:space="preserve">
          <source>When this command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="translated">이 명령이 사용되면, 위의 SQL 쿼리의 열은 열 이름을 따서 변수에 저장하고, 접두어 번 행을 리턴 할 것으로 예상된다 &lt;code&gt;prefix&lt;/code&gt; 제공된 경우.</target>
        </trans-unit>
        <trans-unit id="d01a63b618f24f934c421a450096ebe3b2d3fb7a" translate="yes" xml:space="preserve">
          <source>When this feature is enabled, freed space at the end of a relation cannot be released to the operating system, since that could remove information needed to detect the &amp;ldquo;snapshot too old&amp;rdquo; condition. All space allocated to a relation remains associated with that relation for reuse only within that relation unless explicitly freed (for example, with &lt;code&gt;VACUUM FULL&lt;/code&gt;).</source>
          <target state="translated">이 기능을 사용하면 관계의 끝에서 사용 가능한 공간을 운영 체제로 해제 할 수 없습니다. 이렇게하면 &quot;스냅 샷이 너무 오래된&quot;상태를 감지하는 데 필요한 정보가 제거 될 수 있습니다. 관계에 할당 된 모든 공간은 명시 적으로 해제되지 않은 경우 (예 : &lt;code&gt;VACUUM FULL&lt;/code&gt; ) 해당 관계 내에서만 재사용하기 위해 해당 관계와 연관된 상태로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="edeb5910da7722ed71fd344bba96eef32a3f6641" translate="yes" xml:space="preserve">
          <source>When this happens, the range will be summarized normally during the next regular vacuum of the table.</source>
          <target state="translated">이 경우, 테이블의 다음 정기 진공 청소 중에 범위가 정상적으로 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="e4570af0f67cc29537d90c659afba5db93e8b7f0" translate="yes" xml:space="preserve">
          <source>When this is enabled, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent.</source>
          <target state="translated">이 기능이 활성화되면 전체 데이터베이스의 크기를 열거하여 백업을 시작한 다음 돌아가서 실제 내용을 보냅니다. 이로 인해 백업 시간이 약간 길어질 수 있으며 특히 첫 번째 데이터가 전송되기까지 시간이 더 걸립니다.</target>
        </trans-unit>
        <trans-unit id="ba484c59ded97840ba63ed48a33d5adcad782f3b" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt; below.</source>
          <target state="translated">이 옵션을 사용하면 PostgreSQL은 테이블에 대한 동시 삽입, 업데이트 또는 삭제를 방지하는 잠금을 사용하지 않고 인덱스를 빌드합니다. 표준 인덱스 빌드는 완료 될 때까지 테이블에 대한 쓰기 (읽기 아님)를 잠급니다. 이 옵션을 사용할 때주의해야 할 몇 가지주의 사항이 있습니다 . 아래의 &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;동시 색인 작성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28c1776ab93887297f059584c258d507675ecdfe" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 PostgreSQL은 테이블에서 동시 삽입, 업데이트 또는 삭제를 방지하는 잠금을 수행하지 않고 인덱스를 빌드합니다. 반면 표준 인덱스 빌드는 완료 될 때까지 테이블에 대한 쓰기 (읽지 않지만 읽기)를 잠급니다. 이 옵션을 사용할 때주의해야 할 몇 가지주의 사항이 있습니다 . &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;동시에 색인 작성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cfbc756ec0e3884dc8a6bdc957bf776447f05d6" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt; below.</source>
          <target state="translated">이 옵션을 사용하면 PostgreSQL은 테이블에 대한 동시 삽입, 업데이트 또는 삭제를 방지하는 잠금을 사용하지 않고 인덱스를 다시 작성합니다. 표준 인덱스 재 구축은 완료 될 때까지 테이블에 대한 쓰기 (읽기 아님)를 잠급니다. 이 옵션을 사용할 때주의해야 할 몇 가지주의 사항이 있습니다 . 아래의 &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;인덱스 동시 작성을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="469c5b3c25ebc28298d0a68f767fa4e6b9232f83" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 PostgreSQL은 테이블에서 동시 삽입, 업데이트 또는 삭제를 방지하는 잠금을 수행하지 않고 인덱스를 다시 작성합니다. 반면 표준 인덱스 재 구축은 테이블이 완료 될 때까지 테이블에 대한 쓰기를 잠급니다. 이 옵션을 사용할 때주의해야 할 몇 가지주의 사항이 있습니다 ( &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;동시에 인덱스 다시 작성&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="8c3757e4ca86742c07911d6404be9ee33ce2c815" translate="yes" xml:space="preserve">
          <source>When this option is used, psql will connect to the database &lt;code&gt;postgres&lt;/code&gt;, unless a different database is named on the command line (option &lt;code&gt;-d&lt;/code&gt; or non-option argument, possibly via a service entry, but not via an environment variable).</source>
          <target state="translated">이 옵션을 사용 하면 다른 데이터베이스가 명령 행에 지정되지 않는 한 ( p 옵션은 옵션 &lt;code&gt;-d&lt;/code&gt; 또는 비 옵션 인수, 가능하면 환경 변수가 아닌 서비스 항목을 통해 ) psql은 데이터베이스 &lt;code&gt;postgres&lt;/code&gt; 에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="2bc222201723d0a9f83d166df5e42c7cf99836b6" translate="yes" xml:space="preserve">
          <source>When this option is used, the database named with &lt;code&gt;-d&lt;/code&gt; is used only to issue the initial &lt;code&gt;DROP DATABASE&lt;/code&gt; and &lt;code&gt;CREATE DATABASE&lt;/code&gt; commands. All data is restored into the database name that appears in the archive.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;-d&lt;/code&gt; 로 이름 지정된 데이터베이스 는 초기 &lt;code&gt;DROP DATABASE&lt;/code&gt; 및 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 명령 을 발행하는 데만 사용됩니다 . 모든 데이터는 아카이브에 나타나는 데이터베이스 이름으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="3390cee1b88ac1d254da2a22a816a53421d2e870" translate="yes" xml:space="preserve">
          <source>When this parameter allows it for a particular table, the planner compares query conditions with the table's &lt;code&gt;CHECK&lt;/code&gt; constraints, and omits scanning tables for which the conditions contradict the constraints. For example:</source>
          <target state="translated">이 매개 변수가 특정 테이블에 대해이를 허용하면 플래너는 쿼리 조건을 테이블의 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건과 비교 하고 조건이 제약 조건과 상충되는 스캔 테이블을 생략합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70be33b4f92d88452bcc535d531cf8223b72afbc" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server compresses a full page image written to WAL when &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is on or during a base backup. A compressed page image will be decompressed during WAL replay. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">이 매개 변수가 &lt;code&gt;on&lt;/code&gt; 있으면 PostgreSQL 서버 는 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 가 켜져 있거나 기본 백업 중에 WAL에 기록 된 전체 페이지 이미지를 압축합니다 . 압축 된 페이지 이미지는 WAL 재생 중에 압축 해제됩니다. 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="095a2e6ccc43e3049250993f0343788b4a6a861a" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint, even for non-critical modifications of so-called hint bits.</source>
          <target state="translated">이 매개 변수가 &lt;code&gt;on&lt;/code&gt; 있으면 PostgreSQL 서버는 체크 포인트 후 해당 페이지를 처음 수정하는 동안 (소위 힌트 비트의 중요하지 않은 수정의 경우에도) 각 디스크 페이지의 전체 내용을 WAL에 씁니다.</target>
        </trans-unit>
        <trans-unit id="ff47b09b0654ad59cedec7d15e17e9fba55f3e2b" translate="yes" xml:space="preserve">
          <source>When this parameter is on, &lt;code&gt;sepgsql&lt;/code&gt; functions in permissive mode, even if SELinux in general is working in enforcing mode. This parameter is primarily useful for testing purposes.</source>
          <target state="translated">이 매개 변수가 설정되면 &lt;code&gt;sepgsql&lt;/code&gt; 은 일반적으로 SELinux가 강제 모드에서 작동하더라도 허용 모드에서 작동합니다. 이 매개 변수는 주로 테스트 목적으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b664e492ac1b6b5bd7bf06b57282c7f341a60102" translate="yes" xml:space="preserve">
          <source>When this parameter is on, per-plan-node timing occurs for all statements executed, whether or not they run long enough to actually get logged. This can have an extremely negative impact on performance. Turning off &lt;code&gt;auto_explain.log_timing&lt;/code&gt; ameliorates the performance cost, at the price of obtaining less information.</source>
          <target state="translated">이 매개 변수가 설정되면 실제로 기록 될 정도로 오래 실행되는지 여부에 관계없이 실행 된 모든 명령문에 대해 계획 노드 당 타이밍이 발생합니다. 이는 성능에 매우 부정적인 영향을 줄 수 있습니다. &lt;code&gt;auto_explain.log_timing&lt;/code&gt; 을 끄면 적은 정보를 얻는 대가로 성능 비용이 개선됩니다.</target>
        </trans-unit>
        <trans-unit id="d4e134d46721d701b088fe76d2d53da371f96514" translate="yes" xml:space="preserve">
          <source>When this parameter is on, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint. This is needed because a page write that is in process during an operating system crash might be only partially completed, leading to an on-disk page that contains a mix of old and new data. The row-level change data normally stored in WAL will not be enough to completely restore such a page during post-crash recovery. Storing the full page image guarantees that the page can be correctly restored, but at the price of increasing the amount of data that must be written to WAL. (Because WAL replay always starts from a checkpoint, it is sufficient to do this during the first change of each page after a checkpoint. Therefore, one way to reduce the cost of full-page writes is to increase the checkpoint interval parameters.)</source>
          <target state="translated">이 매개 변수가 설정되어 있으면 PostgreSQL 서버는 검사 점 이후 해당 페이지를 처음 수정하는 동안 각 디스크 페이지의 전체 내용을 WAL에 씁니다. 이것은 운영 체제 충돌 중에 처리중인 페이지 쓰기가 부분적으로 만 완료되어 오래된 데이터와 새 데이터가 혼합 된 디스크 페이지로 이어질 수 있기 때문에 필요합니다. WAL에 일반적으로 저장된 행 레벨 변경 데이터로는 충돌 후 복구 중에 이러한 페이지를 완전히 복원하기에 충분하지 않습니다. 전체 페이지 이미지를 저장하면 페이지를 올바르게 복원 할 수 있지만 WAL에 기록해야하는 데이터 양이 증가합니다. WAL 재생은 항상 검사 점에서 시작하므로 검사 점 다음에 각 페이지를 처음 변경하는 동안이를 수행하면 충분합니다.전체 페이지 쓰기 비용을 줄이는 한 가지 방법은 검사 점 간격 매개 변수를 늘리는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="5a1902b314fccc53fa419bb9d1c5d0a54674b4cd" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;on&lt;/code&gt; and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch &lt;code&gt;-E&lt;/code&gt;.) If you set this variable to the value &lt;code&gt;noexec&lt;/code&gt;, the queries are just shown but are not actually sent to the server and executed. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">이 변수가 &lt;code&gt;on&lt;/code&gt; 으로 설정되고 백 슬래시 명령이 데이터베이스를 쿼리하면 쿼리가 먼저 표시됩니다. 이 기능을 사용하면 PostgreSQL 내부를 연구하고 자신의 프로그램에서 유사한 기능을 제공 할 수 있습니다. (프로그램 시작시이 동작을 선택하려면 스위치 &lt;code&gt;-E&lt;/code&gt; 를 사용하십시오 .)이 변수를 &lt;code&gt;noexec&lt;/code&gt; 값으로 설정 하면 쿼리가 방금 표시되지만 실제로 서버로 전송되어 실행되지는 않습니다. 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a31ece5bfbb183043ca04edf566185c4d24f24d" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="translated">제한이 활성화되면 실행이 끝날 때보고 된 트랜잭션 대기 시간이 예약 된 시작 시간에서 계산되므로 각 트랜잭션이 이전 트랜잭션이 완료되기를 기다려야하는 시간이 포함됩니다. 대기 시간을 스케줄 지연 시간이라고하며 평균 및 최대 값도 별도로보고됩니다. 실제 트랜잭션 시작 시간, 즉 데이터베이스에서 트랜잭션을 실행하는 데 소요 된 시간에 대한 트랜잭션 대기 시간은보고 된 대기 시간에서 일정 지연 시간을 빼서 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf9d744865a36adaaaa98eb0ce0a8d0e8d495ea9" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e., the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="translated">조절이 활성화되면 실행이 끝날 때보고되는 트랜잭션 대기 시간이 예약 된 시작 시간에서 계산되므로 각 트랜잭션이 이전 트랜잭션이 완료 될 때까지 기다려야하는 시간이 포함됩니다. 대기 시간을 일정 지연 시간이라고하며 평균 및 최대 값도 별도로보고됩니다. 실제 트랜잭션 시작 시간에 대한 트랜잭션 지연 시간, 즉 데이터베이스에서 트랜잭션을 실행하는 데 소요 된 시간은보고 된 지연 시간에서 일정 지연 시간을 빼서 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a5ce62fea33e48d7ca4dcdb6fc1d49b58833f9" translate="yes" xml:space="preserve">
          <source>When throttling is used (&lt;code&gt;--rate=...&lt;/code&gt;), transactions that lag behind schedule by more than &lt;code&gt;limit&lt;/code&gt; ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as &lt;em&gt;skipped&lt;/em&gt;.</source>
          <target state="translated">제한이 사용되는 경우 ( &lt;code&gt;--rate=...&lt;/code&gt; ), &lt;code&gt;limit&lt;/code&gt; ms 이상으로 일정보다 뒤쳐져 지연 시간 제한을 충족 할 수없는 트랜잭션 은 전혀 서버로 전송되지 않습니다. 그것들은 별도로 &lt;em&gt;건너 뛴&lt;/em&gt; 것으로 계산되고보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0431d629c5fa2195a09522dc9eddb52b7d7ef5d" translate="yes" xml:space="preserve">
          <source>When to JIT?</source>
          <target state="translated">언제 JIT해야합니까?</target>
        </trans-unit>
        <trans-unit id="c212a8c30b6a166bd84fdfc048fb956853e7ba65" translate="yes" xml:space="preserve">
          <source>When two arrays with an equal number of dimensions are concatenated, the result retains the lower bound subscript of the left-hand operand's outer dimension. The result is an array comprising every element of the left-hand operand followed by every element of the right-hand operand. For example:</source>
          <target state="translated">동일한 수의 차원을 가진 두 개의 배열이 연결되면 결과는 왼쪽 피연산자의 외부 차원의 하한 첨자를 유지합니다. 결과는 왼쪽 피연산자의 모든 요소와 오른쪽 피연산자의 모든 요소로 구성된 배열입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75c057cb6b39ec5ed6fcfc1f9fbef6e3ffe333d8" translate="yes" xml:space="preserve">
          <source>When two or more &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;databases&lt;/a&gt; are linked via &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;replication&lt;/a&gt;, the &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; that is considered the authoritative source of information is called the &lt;em&gt;primary&lt;/em&gt;, also known as a &lt;em&gt;master&lt;/em&gt;.</source>
          <target state="translated">두 개 이상의 경우 &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;데이터베이스를&lt;/a&gt; 통해 연결되어 &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;복제&lt;/a&gt; 의 &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;서버&lt;/a&gt; 정보의 권위있는 소스로 간주됩니다라고 &lt;em&gt;주&lt;/em&gt; , 또한으로 알려진 &lt;em&gt;마스터&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a09c4eb9b4b598594720766db600d02893739065" translate="yes" xml:space="preserve">
          <source>When used as a standalone program all WAL files logically preceding the &lt;code&gt;oldestkeptwalfile&lt;/code&gt; will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. In this mode, if you specify a &lt;code&gt;.partial&lt;/code&gt; or &lt;code&gt;.backup&lt;/code&gt; file name, then only the file prefix will be used as the &lt;code&gt;oldestkeptwalfile&lt;/code&gt;. This treatment of &lt;code&gt;.backup&lt;/code&gt; file name allows you to remove all WAL files archived prior to a specific base backup without error. For example, the following example will remove all files older than WAL file name &lt;code&gt;000000010000003700000010&lt;/code&gt;:</source>
          <target state="translated">독립 실행 형 프로그램으로 사용하면 가장 &lt;code&gt;oldestkeptwalfile&lt;/code&gt; 파일 앞에 논리적으로있는 모든 WAL 파일 이 &lt;code&gt;archivelocation&lt;/code&gt; 에서 제거됩니다 . 이 모드에서 &lt;code&gt;.partial&lt;/code&gt; 또는 &lt;code&gt;.backup&lt;/code&gt; 파일 이름 을 지정 하면 파일 접두사 만 &lt;code&gt;oldestkeptwalfile&lt;/code&gt; 로 사용됩니다 . &lt;code&gt;.backup&lt;/code&gt; 파일 이름을 처리 하면 특정 기본 백업 전에 아카이브 된 모든 WAL 파일을 오류없이 제거 할 수 있습니다. 예를 들어 다음 예제는 WAL 파일 이름 &lt;code&gt;000000010000003700000010&lt;/code&gt; 이전의 모든 파일을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="54ce62d903f7c6555c73f41594c6b595d712ec4b" translate="yes" xml:space="preserve">
          <source>When used in exclusive mode, this function writes a backup label file (&lt;code&gt;backup_label&lt;/code&gt;) and, if there are any links in the &lt;code&gt;pg_tblspc/&lt;/code&gt; directory, a tablespace map file (&lt;code&gt;tablespace_map&lt;/code&gt;) into the database cluster's data directory, then performs a checkpoint, and then returns the backup's starting write-ahead log location. (The user can ignore this result value, but it is provided in case it is useful.) When used in non-exclusive mode, the contents of these files are instead returned by the &lt;code&gt;pg_stop_backup&lt;/code&gt; function, and should be copied to the backup area by the user.</source>
          <target state="translated">단독 모드로 사용하는 경우이 함수는 백업 레이블 파일 ( &lt;code&gt;backup_label&lt;/code&gt; )과 &lt;code&gt;pg_tblspc/&lt;/code&gt; 디렉토리에 링크가있는 경우 테이블 스페이스 맵 파일 ( &lt;code&gt;tablespace_map&lt;/code&gt; )을 데이터베이스 클러스터의 데이터 디렉토리에 기록한 다음 체크 포인트를 수행 한 다음 백업의 시작 미리 쓰기 로그 위치를 반환합니다. (사용자는이 결과 값을 무시할 수 있지만 유용 할 경우 제공됩니다.) 비 독점 모드에서 사용하는 경우 이러한 파일의 내용은 &lt;code&gt;pg_stop_backup&lt;/code&gt; 함수에 의해 대신 반환되며 다음 을 통해 백업 영역에 복사해야합니다. 사용자.</target>
        </trans-unit>
        <trans-unit id="b4f92bbabc1b26d77780494bcd623901f19d77be" translate="yes" xml:space="preserve">
          <source>When used with one of the archive file formats and combined with pg_restore, pg_dump provides a flexible archival and transfer mechanism. pg_dump can be used to backup an entire database, then pg_restore can be used to examine the archive and/or select which parts of the database are to be restored. The most flexible output file formats are the &amp;ldquo;custom&amp;rdquo; format (&lt;code&gt;-Fc&lt;/code&gt;) and the &amp;ldquo;directory&amp;rdquo; format (&lt;code&gt;-Fd&lt;/code&gt;). They allow for selection and reordering of all archived items, support parallel restoration, and are compressed by default. The &amp;ldquo;directory&amp;rdquo; format is the only format that supports parallel dumps.</source>
          <target state="translated">아카이브 파일 형식 중 하나와 함께 사용하고 pg_restore와 함께 사용되는 경우 pg_dump는 유연한 보관 및 전송 메커니즘을 제공합니다. pg_dump를 사용하여 전체 데이터베이스를 백업 한 다음 pg_restore를 사용하여 아카이브를 검사하거나 복원 할 데이터베이스 부분을 선택할 수 있습니다. 가장 유연한 출력 파일 형식은 &quot;custom&quot;형식 ( &lt;code&gt;-Fc&lt;/code&gt; ) 및 &quot;directory&quot;형식 ( &lt;code&gt;-Fd&lt;/code&gt; )입니다. 모든 아카이브 된 항목을 선택하고 재정렬 할 수 있으며 병렬 복원을 지원하며 기본적으로 압축됩니다. &quot;디렉토리&quot;형식은 병렬 덤프를 지원하는 유일한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7fe14a6b317961785cf4d152bc27d49064bcda5a" translate="yes" xml:space="preserve">
          <source>When used within &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;, all WAL files logically preceding the value of the &lt;code&gt;%r&lt;/code&gt; argument will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. This minimizes the number of files that need to be retained, while preserving crash-restart capability. Use of this parameter is appropriate if the &lt;code&gt;archivelocation&lt;/code&gt; is a transient staging area for this particular standby server, but &lt;em&gt;not&lt;/em&gt; when the &lt;code&gt;archivelocation&lt;/code&gt; is intended as a long-term WAL archive area, or when multiple standby servers are recovering from the same archive location.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; 내에서 사용될 경우, &lt;code&gt;%r&lt;/code&gt; 인수 의 값보다 논리적으로 선행하는 모든 WAL 파일 이 &lt;code&gt;archivelocation&lt;/code&gt; 에서 제거됩니다 . 이는 충돌 재시작 기능을 유지하면서 보유해야하는 파일 수를 최소화합니다. 경우이 매개 변수의 사용은 적절한 &lt;code&gt;archivelocation&lt;/code&gt; 는 이 특정 대기 서버에 대한 과도 준비 영역이지만, &lt;em&gt;하지&lt;/em&gt; 때 &lt;code&gt;archivelocation&lt;/code&gt; 가 여러 대기 서버가 동일한 아카이브 위치에서 회복 될 때 장기 WAL 아카이브 영역으로 구성되어, 또는.</target>
        </trans-unit>
        <trans-unit id="7051b09dcb61945ea4e0d3beb1e52e65c9014732" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;COPY FROM&lt;/code&gt;, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used with &lt;code&gt;COPY TO&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; 을 사용 하는 경우이 문자열과 일치하는 모든 데이터 항목이 널값으로 저장되므로 &lt;code&gt;COPY TO&lt;/code&gt; 와 함께 사용한 것과 동일한 문자열을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8b5d7a27b46e73dc32c1b851c7dfef0ad7fe8a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is a good idea to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows &amp;mdash; you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;LIMIT&lt;/code&gt; 를 , 그것은 사용하는 좋은 아이디어이다 &lt;code&gt;ORDER BY&lt;/code&gt; 고유 순서로 결과 행을 제한 절. 그렇지 않으면 쿼리 행의 예측할 수없는 부분 집합을 얻게됩니다. 10 번째에서 20 번째 행을 요구할 수 있지만 10 번째에서 20 번째 순서는 무엇입니까? &lt;code&gt;ORDER BY&lt;/code&gt; 를 지정하지 않으면 어떤 순서를 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="481c23a58e8db851baee87afbfd06f8aa525bda9" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is important to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;LIMIT&lt;/code&gt; 를 , 사용하는 것이 중요하다 &lt;code&gt;ORDER BY&lt;/code&gt; 고유 순서로 결과 행을 제한 조항. 그렇지 않으면 예측할 수없는 쿼리 행의 하위 집합이 표시됩니다. 열 번째 열두 번째 열을 요구할 수도 있지만 열 두 번째 열을 어떤 순서로 요구할 수 있습니까? &lt;code&gt;ORDER BY&lt;/code&gt; 를 지정하지 않으면 순서를 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f85dc3be9cb7f009d076c5eedd8386addcb8b584" translate="yes" xml:space="preserve">
          <source>When using Kerberos authentication, SSPI works the same way GSSAPI does; see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details.</source>
          <target state="translated">Kerberos 인증을 사용할 때 SSPI는 GSSAPI와 동일한 방식으로 작동합니다. 자세한 내용 &lt;a href=&quot;gssapi-auth&quot;&gt;은 20.6 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc80b0e9ed4294e8911057b0a0a50261a196de62" translate="yes" xml:space="preserve">
          <source>When using POSIX semaphores, the number of semaphores needed is the same as for System V, that is one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;). On the platforms where this option is preferred, there is no specific kernel limit on the number of POSIX semaphores.</source>
          <target state="translated">POSIX 세마포어를 사용할 때 필요한 세마포어 수는 System V의 경우와 동일합니다. 즉 허용 된 연결 당 하나의 세마포어 ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; ), 허용 된 자동 진공 작업자 프로세스 ( &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; ) 및 허용 된 백그라운드 프로세스 ( &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; )입니다. 이 옵션이 선호되는 플랫폼에서는 POSIX 세마포 수에 대한 특정 커널 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8579cb5fcd4b92d72b4fadb397cff9f7dbbdad05" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this request with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="translated">RADIUS 인증을 사용하는 경우 구성된 RADIUS 서버로 액세스 요청 메시지가 전송됩니다. 이 요청은 &lt;code&gt;Authenticate Only&lt;/code&gt; 유형 이며 &lt;code&gt;user name&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; (암호화 됨) 및 &lt;code&gt;NAS Identifier&lt;/code&gt; 대한 매개 변수를 포함 합니다 . 요청은 서버와 공유되는 비밀을 사용하여 암호화됩니다. RADIUS 서버는 &lt;code&gt;Access Accept&lt;/code&gt; 또는 &lt;code&gt;Access Reject&lt;/code&gt; 로이 요청에 응답합니다 . RADIUS 계정은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d87a93d2de1be22dab32dcbbc5446297da3c6d5" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="translated">RADIUS 인증을 사용하면 액세스 요청 메시지가 구성된 RADIUS 서버로 전송됩니다. 이 요청은 &lt;code&gt;Authenticate Only&lt;/code&gt; 유형 이며 &lt;code&gt;user name&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; (암호화) 및 &lt;code&gt;NAS Identifier&lt;/code&gt; 대한 매개 변수를 포함 합니다 . 요청은 서버와 공유 된 비밀을 사용하여 암호화됩니다. RADIUS 서버는이 서버에 &lt;code&gt;Access Accept&lt;/code&gt; 또는 &lt;code&gt;Access Reject&lt;/code&gt; 중 하나로 응답합니다 . RADIUS 계정은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df1ce6f4ba5a71b98d3f24da1f9c50898361216d" translate="yes" xml:space="preserve">
          <source>When using System V semaphores, PostgreSQL uses one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;), in sets of 16. Each such set will also contain a 17th semaphore which contains a &amp;ldquo;magic number&amp;rdquo;, to detect collision with semaphore sets used by other applications. The maximum number of semaphores in the system is set by &lt;code&gt;SEMMNS&lt;/code&gt;, which consequently must be at least as high as &lt;code&gt;max_connections&lt;/code&gt; plus &lt;code&gt;autovacuum_max_workers&lt;/code&gt; plus &lt;code&gt;max_wal_senders&lt;/code&gt;, plus &lt;code&gt;max_worker_processes&lt;/code&gt;, plus one extra for each 16 allowed connections plus workers (see the formula in &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;Table 18.1&lt;/a&gt;). The parameter &lt;code&gt;SEMMNI&lt;/code&gt; determines the limit on the number of semaphore sets that can exist on the system at one time. Hence this parameter must be at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt;. Lowering the number of allowed connections is a temporary workaround for failures, which are usually confusingly worded &amp;ldquo;No space left on device&amp;rdquo;, from the function &lt;code&gt;semget&lt;/code&gt;.</source>
          <target state="translated">System V 세마포어를 사용하는 경우 PostgreSQL은 허용되는 연결 ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; ), 허용 된 autovacuum 작업자 프로세스 ( &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; ) 및 허용 된 백그라운드 프로세스 ( &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; ) 당 하나의 세마포어 를 16 세트로 사용합니다. 이러한 각 세트에는 &quot; 다른 응용 프로그램에서 사용하는 세마포어 세트와의 충돌을 감지합니다. 시스템의 최대 세마포어 수는 &lt;code&gt;SEMMNS&lt;/code&gt; 에 의해 설정되며 , 결과적으로 최소한 &lt;code&gt;max_connections&lt;/code&gt; + &lt;code&gt;autovacuum_max_workers&lt;/code&gt; + &lt;code&gt;max_wal_senders&lt;/code&gt; 및 &lt;code&gt;max_worker_processes&lt;/code&gt; 만큼 높아야합니다 ., 16 개의 허용 된 연결 및 작업자에 대해 1 개의 추가 추가 ( &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;표 18.1&lt;/a&gt; 의 공식 참조 ). &lt;code&gt;SEMMNI&lt;/code&gt; 매개 변수 는 한 번에 시스템에 존재할 수있는 세마포어 세트 수의 한계를 판별합니다. 따라서이 매개 변수는 최소한 &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; 이어야합니다 . 허용되는 연결 수를 낮추는 것은 실패에 대한 임시 해결 방법이며, 일반적으로 함수 &lt;code&gt;semget&lt;/code&gt; 에서 &quot;장치에 남은 공간 없음&quot;으로 혼동 됩니다.</target>
        </trans-unit>
        <trans-unit id="c8382eef968bcd1841af0a45f03df20722ebed18" translate="yes" xml:space="preserve">
          <source>When using a replication setup with tools which perform direct copies of relation file blocks (for example &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;), enabling or disabling checksums can lead to page corruptions in the shape of incorrect checksums if the operation is not done consistently across all nodes. When enabling or disabling checksums in a replication setup, it is thus recommended to stop all the clusters before switching them all consistently. Destroying all standbys, performing the operation on the primary and finally recreating the standbys from scratch is also safe.</source>
          <target state="translated">관계 파일 블록의 직접 복사를 수행하는 도구 (예 : &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; ) 와 함께 복제 설정을 사용하는 경우, 모든 노드에서 작업이 일관되게 수행되지 않으면 체크섬을 활성화 또는 비활성화하면 잘못된 체크섬 모양으로 페이지가 손상 될 수 있습니다. 복제 설정에서 체크섬을 활성화 또는 비활성화 할 때 모든 클러스터를 일관되게 전환하기 전에 모든 클러스터를 중지하는 것이 좋습니다. 모든 대기를 제거하고 기본에서 작업을 수행 한 후 마지막으로 대기를 처음부터 다시 작성하는 것도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="eac93956f94fd1f4ae45bb87df2631e194bcbe28" translate="yes" xml:space="preserve">
          <source>When using a separate column to store the &lt;code&gt;tsvector&lt;/code&gt; representation of your documents, it is necessary to create a trigger to update the &lt;code&gt;tsvector&lt;/code&gt; column when the document content columns change. Two built-in trigger functions are available for this, or you can write your own.</source>
          <target state="translated">별도의 열을 사용 하여 문서 의 &lt;code&gt;tsvector&lt;/code&gt; 표현 을 저장하는 경우 문서 컨텐츠 열이 변경 될 때 &lt;code&gt;tsvector&lt;/code&gt; 열 을 업데이트하는 트리거를 작성해야합니다 . 이를 위해 2 개의 내장 트리거 기능을 사용하거나 직접 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9150f1a85447666f80a11e9912230df80685449c" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;archive_command&lt;/code&gt; script, it's desirable to enable &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;. Any messages written to stderr from the script will then appear in the database server log, allowing complex configurations to be diagnosed easily if they fail.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;archive_command&lt;/code&gt; 의 스크립트를, 그것을 가능하게하는 것이 바람직의 &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector을&lt;/a&gt; . 스크립트에서 stderr에 기록 된 모든 메시지는 데이터베이스 서버 로그에 표시되어 복잡한 구성이 실패한 경우 쉽게 진단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="953b500ebbfdd4983d6d154f36b232db63c79506" translate="yes" xml:space="preserve">
          <source>When using an external authentication system such as Ident or GSSAPI, the name of the operating system user that initiated the connection might not be the same as the database user (role) that is to be used. In this case, a user name map can be applied to map the operating system user name to a database user. To use user name mapping, specify &lt;code&gt;map&lt;/code&gt;=&lt;code&gt;map-name&lt;/code&gt; in the options field in &lt;code&gt;pg_hba.conf&lt;/code&gt;. This option is supported for all authentication methods that receive external user names. Since different mappings might be needed for different connections, the name of the map to be used is specified in the &lt;code&gt;map-name&lt;/code&gt; parameter in &lt;code&gt;pg_hba.conf&lt;/code&gt; to indicate which map to use for each individual connection.</source>
          <target state="translated">Ident 또는 GSSAPI와 같은 외부 인증 시스템을 사용하는 경우 연결을 시작한 운영 체제 사용자 이름이 사용할 데이터베이스 사용자 (역할)와 같지 않을 수 있습니다. 이 경우, 운영 체제 사용자 이름을 데이터베이스 사용자에 맵핑하기 위해 사용자 이름 맵을 적용 할 수 있습니다. 사용자 이름 매핑을 사용하려면 &lt;code&gt;pg_hba.conf&lt;/code&gt; 의 옵션 필드에 &lt;code&gt;map&lt;/code&gt; = &lt;code&gt;map-name&lt;/code&gt; 을 지정 하십시오 . 이 옵션은 외부 사용자 이름을받는 모든 인증 방법에 지원됩니다. 다른 연결에 대해 다른 매핑이 필요할 수 있으므로 사용할 &lt;code&gt;map-name&lt;/code&gt; 은 &lt;code&gt;pg_hba.conf&lt;/code&gt; 의 map-name 매개 변수에 지정되어 각 개별 연결에 사용할 맵을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="492838d017254285805f7e847c1bb4763dffb265" translate="yes" xml:space="preserve">
          <source>When using binary mode to pass query parameters to the server and query results back to the client, no encoding conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that PostgreSQL does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.</source>
          <target state="translated">이진 모드를 사용하여 쿼리 매개 변수를 서버로 전달하고 쿼리 결과를 클라이언트로 다시 쿼리하면 인코딩 변환이 수행되지 않으므로 상황이 다릅니다. 이 경우 XML 데이터의 인코딩 선언이 관찰되며,없는 경우 데이터는 UTF-8로 간주됩니다 (XML 표준에 따라 PostgreSQL은 UTF-16을 지원하지 않습니다) . 출력시, 클라이언트 인코딩이 UTF-8이 아닌 한, 데이터는 클라이언트 인코딩을 지정하는 인코딩 선언을 갖습니다.이 경우 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="5c43830d30560b418ee227f739bdeb1afbb63531" translate="yes" xml:space="preserve">
          <source>When using collations provided by &lt;code&gt;libc&lt;/code&gt; and PostgreSQL was built with the GNU C library, the C library's version is used as a collation version. Since collation definitions typically change only with GNU C library releases, this provides some defense against corruption, but it is not completely reliable.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 에서 제공하는 데이터 정렬을 사용 하고 PostgreSQL이 GNU C 라이브러리로 빌드 된 경우 C 라이브러리의 버전이 데이터 정렬 버전으로 사용됩니다. 데이터 정렬 정의는 일반적으로 GNU C 라이브러리 릴리스에서만 변경되므로 손상에 대한 방어를 제공하지만 완전히 신뢰할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="56607247aff04e4e074b7797ef04095046172c94" translate="yes" xml:space="preserve">
          <source>When using collations provided by the ICU library, the ICU-specific version of the collator is recorded in the system catalog when the collation object is created. When the collation is used, the current version is checked against the recorded version, and a warning is issued when there is a mismatch, for example:</source>
          <target state="translated">ICU 라이브러리에서 제공 한 데이터 정렬을 사용하는 경우 데이터 정렬 개체가 생성 될 때 ICU 특정 버전의 데이터 생성기가 시스템 카탈로그에 기록됩니다. 데이터 정렬을 사용하면 현재 버전이 기록 된 버전과 비교하여 확인되고 일치하지 않는 경우 경고가 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de5896493e8d94d607ede6725d8b75b29f2f0f82" translate="yes" xml:space="preserve">
          <source>When using cost-based vacuuming, appropriate values for &lt;code&gt;vacuum_cost_delay&lt;/code&gt; are usually quite small, perhaps less than 1 millisecond. While &lt;code&gt;vacuum_cost_delay&lt;/code&gt; can be set to fractional-millisecond values, such delays may not be measured accurately on older platforms. On such platforms, increasing &lt;code&gt;VACUUM&lt;/code&gt;'s throttled resource consumption above what you get at 1ms will require changing the other vacuum cost parameters. You should, nonetheless, keep &lt;code&gt;vacuum_cost_delay&lt;/code&gt; as small as your platform will consistently measure; large delays are not helpful.</source>
          <target state="translated">비용 기반 진공 청소기를 사용할 때 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 의 적절한 값 은 일반적으로 1 밀리 초 미만으로 매우 작습니다. &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 를 분수 밀리 초 값으로 설정할 수 있지만 이러한 지연은 이전 플랫폼에서 정확하게 측정되지 않을 수 있습니다. 이러한 플랫폼에서 &lt;code&gt;VACUUM&lt;/code&gt; 의 조절 된 리소스 소비를 1ms 이상으로 늘리 려면 다른 진공 비용 매개 변수를 변경해야합니다. 그럼에도 불구하고 플랫폼이 지속적으로 측정 할 수있는 한 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 를 작게 유지해야합니다 . 큰 지연은 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75aee5f97d42018467b21311d706aa5a647707a9" translate="yes" xml:space="preserve">
          <source>When using exclusive backup mode, it is absolutely imperative to ensure that &lt;code&gt;pg_stop_backup&lt;/code&gt; completes successfully at the end of the backup. Even if the backup itself fails, for example due to lack of disk space, failure to call &lt;code&gt;pg_stop_backup&lt;/code&gt; will leave the server in backup mode indefinitely, causing future backups to fail and increasing the risk of a restart failure during the time that &lt;code&gt;backup_label&lt;/code&gt; exists.</source>
          <target state="translated">단독 백업 모드를 사용하는 경우 백업 종료시 &lt;code&gt;pg_stop_backup&lt;/code&gt; 이 성공적으로 완료 되도록해야합니다 . 디스크 공간 부족으로 인해 백업 자체가 실패하더라도 &lt;code&gt;pg_stop_backup&lt;/code&gt; 을 호출 하지 않으면 서버가 무기한 백업 모드로 유지되어 향후 백업이 실패하고 &lt;code&gt;backup_label&lt;/code&gt; 이 존재 하는 동안 재시작 실패의 위험이 증가 합니다.</target>
        </trans-unit>
        <trans-unit id="ec73be80732f41a040847bc00566e73f63c25a96" translate="yes" xml:space="preserve">
          <source>When using link mode, standby servers can be quickly upgraded using rsync. To accomplish this, from a directory on the primary server that is above the old and new database cluster directories, run this on the &lt;em&gt;primary&lt;/em&gt; for each standby server:</source>
          <target state="translated">링크 모드를 사용하면 rsync를 사용하여 대기 서버를 빠르게 업그레이드 할 수 있습니다. 이를 수행하려면 이전 및 새 데이터베이스 클러스터 디렉토리 위에있는 1 차 서버의 디렉토리에서 각 대기 서버 의 &lt;em&gt;1 차&lt;/em&gt; 서버 에서이를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d1e98ef020032cfb9faf29c2d74acac7b1c192c" translate="yes" xml:space="preserve">
          <source>When using multiple &lt;code&gt;INSERT&lt;/code&gt;s, turn off autocommit and just do one commit at the end. (In plain SQL, this means issuing &lt;code&gt;BEGIN&lt;/code&gt; at the start and &lt;code&gt;COMMIT&lt;/code&gt; at the end. Some client libraries might do this behind your back, in which case you need to make sure the library does it when you want it done.) If you allow each insertion to be committed separately, PostgreSQL is doing a lot of work for each row that is added. An additional benefit of doing all insertions in one transaction is that if the insertion of one row were to fail then the insertion of all rows inserted up to that point would be rolled back, so you won't be stuck with partially loaded data.</source>
          <target state="translated">여러 개의 &lt;code&gt;INSERT&lt;/code&gt; 를 사용하는 경우 자동 커밋을 끄고 마지막에 한 번의 커밋을 수행하십시오. (일반 SQL에서 이것은 시작시 &lt;code&gt;BEGIN&lt;/code&gt; 을 발행 하고 끝에서 &lt;code&gt;COMMIT&lt;/code&gt; 을 발행 함을 의미 합니다. 일부 클라이언트 라이브러리는이 작업을 수행 할 수 있습니다.이 경우 원하는 경우 라이브러리가이를 수행하도록해야합니다.) 각 삽입은 별도로 커밋되므로 PostgreSQL은 추가 된 각 행에 대해 많은 작업을 수행합니다. 한 트랜잭션에서 모든 삽입을 수행 할 경우의 또 다른 이점은 하나의 행 삽입이 실패하면 해당 지점까지 삽입 된 모든 행의 삽입이 롤백되므로 부분적으로로드 된 데이터가 고착되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8692847b55239c8542d72c31d947ca1f69e8f98c" translate="yes" xml:space="preserve">
          <source>When using pg_receivewal instead of &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; as the main WAL backup method, it is strongly recommended to use replication slots. Otherwise, the server is free to recycle or remove write-ahead log files before they are backed up, because it does not have any information, either from &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; or the replication slots, about how far the WAL stream has been archived. Note, however, that a replication slot will fill up the server's disk space if the receiver does not keep up with fetching the WAL data.</source>
          <target state="translated">기본 WAL 백업 방법 으로 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; 대신 pg_receivewal 을 사용하는 경우 복제 슬롯을 사용하는 것이 좋습니다. 그렇지 않으면 서버는 WAL 스트림이 아카이브 된 거리에 대한 정보가 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; 또는 복제 슬롯에 없기 때문에 백업하기 전에 미리 쓰기 로그 파일을 재활용하거나 제거 할 수 있습니다 . 그러나 리시버가 WAL 데이터를 페치하지 않으면 복제 슬롯이 서버의 디스크 공간을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="7805e078bb69ca14f943ca44e9ff4b57cc0c775e" translate="yes" xml:space="preserve">
          <source>When using search+bind mode, the search can be performed using a single attribute specified with &lt;code&gt;ldapsearchattribute&lt;/code&gt;, or using a custom search filter specified with &lt;code&gt;ldapsearchfilter&lt;/code&gt;. Specifying &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; is equivalent to specifying &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt;. If neither option is specified the default is &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt;.</source>
          <target state="translated">검색 + 결합 모드를 사용하는 경우, 탐색은 지정된 단일 속성을 사용하여 수행 될 수 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 을 , 또는 지정된 사용자 검색 필터 사용 &lt;code&gt;ldapsearchfilter&lt;/code&gt; 를 . 지정 &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; 는 것은 지정하는 것과 같습니다 &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt; . 옵션이 지정되지 않은 경우 기본값은 &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="135e97cd9c471619bb69517b95ef6da4e4340a4c" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this time frame. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="translated">정적 로그 파일 이름을 사용하는 경우 최대 열린 파일 제한에 도달하거나 파일 테이블 오버플로가 발생하면 서버가 로그 파일을 다시 열지 못할 수 있습니다. 이 경우 로그 메시지는 로그 회전이 성공할 때까지 이전 로그 파일로 전송됩니다. logrotate가 로그 파일을 압축하고 삭제하도록 구성된 경우 서버는이 시간 프레임에 기록 된 메시지를 잃을 수 있습니다. 이 문제를 방지하려면 로그 파일 이름을 동적으로 할당하도록 로깅 수집기를 구성하고 사전 &lt;code&gt;prerotate&lt;/code&gt; 스크립트를 사용하여 열린 로그 파일을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccf2c531c08aa10ba699a8b190067e047b3e70bf" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this timeframe. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="translated">정적 로그 파일 이름을 사용할 때 최대 파일 열기 한계에 도달하거나 파일 테이블 오버 플로우가 발생하면 서버가 로그 파일을 다시 열지 못할 수 있습니다. 이 경우 로그 메시지는 성공적인 로그 회전까지 이전 로그 파일로 전송됩니다. logrotate가 로그 파일을 압축하고 삭제하도록 구성된 경우 서버는이 시간대에 기록 된 메시지를 잃을 수 있습니다. 이 문제를 피하기 위해 로그 파일 이름을 동적으로 할당하고 사전 &lt;code&gt;prerotate&lt;/code&gt; 스크립트를 사용하여 열린 로그 파일을 무시 하도록 로깅 수집기를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddcdbf5154b4eb280778c5288af6f89414cb4462" translate="yes" xml:space="preserve">
          <source>When using systemd, you can use the following service unit file (e.g., at &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt;):</source>
          <target state="translated">systemd를 사용할 때 다음 서비스 유닛 파일을 사용할 수 있습니다 (예 : &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa4f4b5954d77c90199a922670870bbe00993316" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; 모듈을 사용할 때 외부 서버 이름을 &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; 함수 의 인수로 사용 하여 연결 매개 변수를 표시 할 수 있습니다 . 이런 방식으로 사용하려면 외부 서버에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="2a1340434fcccdcd8d13b6480e2a087b4c7cd975" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; 모듈을 사용할 때 외부 서버의 이름을 &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; 함수 의 인수로 사용 하여 연결 매개 변수를 나타낼 수 있습니다. 이러한 방식으로 사용하려면 외부 서버에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bd246a1d45857b9944b119a71ad8342fdd069e69" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. A column definition list can be placed after the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; construct only if there's just a single function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause.</source>
          <target state="translated">사용시 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 구문 기능 중 하나는 열 정의리스트를 요구하는 경우, 내부에 함수를 호출 한 후 열 정의 목록을 넣어 바람직한 것 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; . &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 절이 없고 단일 함수 만있는 경우에만 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 구문 뒤에 열 정의 목록을 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98b68f1005505d22ba3f1b802a0a0796977dd397" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;extensions&lt;/code&gt; option, &lt;em&gt;it is the user's responsibility&lt;/em&gt; that the listed extensions exist and behave identically on both the local and remote servers. Otherwise, remote queries may fail or behave unexpectedly.</source>
          <target state="translated">&lt;code&gt;extensions&lt;/code&gt; 옵션을 사용 하는 경우 나열된 확장이 존재하고 로컬 및 원격 서버에서 동일하게 작동 &lt;em&gt;하는&lt;/em&gt; 것은 &lt;em&gt;사용자의 책임&lt;/em&gt; 입니다. 그렇지 않으면 원격 쿼리가 실패하거나 예기치 않게 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e797775100fdafb459cefc34e37395f8e226c9b6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;libc&lt;/code&gt; collation provider, the locale must be applicable to the current database encoding. See &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; for the precise rules.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 데이터 정렬 제공자를 사용하는 경우 로케일이 현재 데이터베이스 인코딩에 적용 가능해야합니다. 정확한 규칙 은 &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33347a458dabb91eee87e22ef8743db48a2953ba" translate="yes" xml:space="preserve">
          <source>When using the statistics to monitor collected data, it is important to realize that the information does not update instantaneously. Each individual server process transmits new statistical counts to the collector just before going idle; so a query or transaction still in progress does not affect the displayed totals. Also, the collector itself emits a new report at most once per &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; milliseconds (500 ms unless altered while building the server). So the displayed information lags behind actual activity. However, current-query information collected by &lt;code&gt;track_activities&lt;/code&gt; is always up-to-date.</source>
          <target state="translated">통계를 사용하여 수집 된 데이터를 모니터링 할 때 정보가 즉시 업데이트되지 않는다는 것을 인식해야합니다. 각 개별 서버 프로세스는 유휴 상태가되기 직전에 새로운 통계 계수를 수집기로 전송합니다. 따라서 진행중인 쿼리 또는 트랜잭션은 표시된 총계에 영향을 미치지 않습니다. 또한 콜렉터 자체는 &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; 밀리 초당 최대 한 번 (새 서버를 빌드하는 동안 변경하지 않는 한 500ms) 새 보고서를 발행 합니다. 따라서 표시된 정보는 실제 활동보다 뒤떨어집니다. 그러나 &lt;code&gt;track_activities&lt;/code&gt; 에 의해 수집 된 현재 쿼리 정보 는 항상 최신 정보입니다.</target>
        </trans-unit>
        <trans-unit id="869040936f3cd63714aedfeb674cbbcb51ecde9f" translate="yes" xml:space="preserve">
          <source>When using this option together with &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, the text of statements that are logged because of &lt;code&gt;log_statement&lt;/code&gt; will not be repeated in the duration log message. If you are not using syslog, it is recommended that you log the PID or session ID using &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; so that you can link the statement message to the later duration message using the process ID or session ID.</source>
          <target state="translated">와 함께이 옵션을 사용할 때 &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt; , 때문에 로그인 문장의 텍스트 &lt;code&gt;log_statement&lt;/code&gt; 는 기간의 로그 메시지에서 반복되지 않습니다. syslog를 사용하지 않는 경우 프로세스 ID 또는 세션 ID를 사용하여 명령문 메시지를 이후 지속 기간 메시지에 링크 할 수 있도록 &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix를&lt;/a&gt; 사용하여 PID 또는 세션 ID를 로그하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f56584dae166e0f5d41c03bae8959fb67da882b7" translate="yes" xml:space="preserve">
          <source>When using this technique, it will avoid creating an unnecessary burden for application programmers if the application software goes through a framework which automatically retries transactions which are rolled back with a serialization failure. It may be a good idea to set &lt;code&gt;default_transaction_isolation&lt;/code&gt; to &lt;code&gt;serializable&lt;/code&gt;. It would also be wise to take some action to ensure that no other transaction isolation level is used, either inadvertently or to subvert integrity checks, through checks of the transaction isolation level in triggers.</source>
          <target state="translated">이 기술을 사용할 때 응용 프로그램 소프트웨어가 직렬화 실패로 롤백 된 트랜잭션을 자동으로 재 시도하는 프레임 워크를 통과하는 경우 응용 프로그램 프로그래머에게 불필요한 부담을주지 않습니다. &lt;code&gt;default_transaction_isolation&lt;/code&gt; 을 &lt;code&gt;serializable&lt;/code&gt; 로 설정하는 것이 좋습니다 . 트리거에서 트랜잭션 격리 수준을 검사하여 실수로 무결성 검사를 파괴하거나 다른 트랜잭션 격리 수준을 사용하지 않도록 조치를 취하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a2c852145ce2448ef43e1a7c8c990a843033f4d6" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten in-place. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="translated">체크섬을 확인할 때 클러스터의 모든 파일이 스캔됩니다. 체크섬을 활성화하면 클러스터의 모든 파일이 제자리에 다시 작성됩니다. 체크섬을 비활성화하면 &lt;code&gt;pg_control&lt;/code&gt; 파일 만 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e33ed6ffb66e09afb90b2aa31b40f235c917227" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="translated">체크섬을 확인할 때 클러스터의 모든 파일이 검사됩니다. 체크섬을 활성화하면 클러스터의 모든 파일이 다시 작성됩니다. 체크섬을 비활성화하면 &lt;code&gt;pg_control&lt;/code&gt; 파일 만 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="fda53778d06f68bfde32b3023f6347b2be67790d" translate="yes" xml:space="preserve">
          <source>When waiting, &lt;code&gt;pg_ctl&lt;/code&gt; repeatedly checks the server's PID file, sleeping for a short amount of time between checks. Startup is considered complete when the PID file indicates that the server is ready to accept connections. Shutdown is considered complete when the server removes the PID file. &lt;code&gt;pg_ctl&lt;/code&gt; returns an exit code based on the success of the startup or shutdown.</source>
          <target state="translated">대기 할 때 &lt;code&gt;pg_ctl&lt;/code&gt; 은 반복적으로 서버의 PID 파일을 점검하고 점검 사이에 짧은 시간 동안 휴면 상태를 유지합니다. PID 파일이 서버가 연결을 수락 할 준비가되었음을 표시하면 시작이 완료된 것으로 간주됩니다. 서버가 PID 파일을 제거하면 종료가 완료된 것으로 간주됩니다. &lt;code&gt;pg_ctl&lt;/code&gt; 은 시작 또는 종료 성공에 따라 종료 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="319a6ac32ba7d37c93ad8b3aed41a7b25d9cd283" translate="yes" xml:space="preserve">
          <source>When we speak of inheriting the locale from the execution environment, this means the following on most operating systems: For a given locale category, say the collation, the following environment variables are consulted in this order until one is found to be set: &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; (or the variable corresponding to the respective category), &lt;code&gt;LANG&lt;/code&gt;. If none of these environment variables are set then the locale defaults to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">실행 환경에서 로케일을 상속한다고 할 때, 이는 대부분의 운영 체제에서 다음을 의미합니다. 주어진 로케일 범주의 경우 데이터 정렬을 말하면 다음 환경 변수가 설정 될 때까지 순서대로 참조됩니다. &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; (또는 각각의 카테고리에 대응하는 변수) &lt;code&gt;LANG&lt;/code&gt; . 이러한 환경 변수가 설정되지 않은 경우 로케일의 기본값은 &lt;code&gt;C&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09870d0ba2815a6a474afa8adde88701322779a5" translate="yes" xml:space="preserve">
          <source>When we write</source>
          <target state="translated">우리가 쓸 때</target>
        </trans-unit>
        <trans-unit id="5f55fad869d686971a61de9989dadab77ae5eb95" translate="yes" xml:space="preserve">
          <source>When working with an inner tuple having unlabeled nodes, it is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since the set of nodes is supposed to be fixed in such cases.</source>
          <target state="translated">레이블이 지정되지 않은 노드가있는 내부 튜플을 사용하는 경우 노드 세트가 수정되어야하므로 &lt;code&gt;spgAddNode&lt;/code&gt; 를 반환 &lt;code&gt;choose&lt;/code&gt; 하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="513c84ce8934fc59619703510a7a572aaca0c319" translate="yes" xml:space="preserve">
          <source>When working with multiple tables, it can also be useful to ask for all the columns of a particular table:</source>
          <target state="translated">여러 테이블로 작업 할 때 특정 테이블의 모든 열을 요청하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f387116d6a98de65f13445ebf4c25f94df15576" translate="yes" xml:space="preserve">
          <source>When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a left unary operator named &lt;code&gt;@&lt;/code&gt;, you cannot write &lt;code&gt;X*@Y&lt;/code&gt;; you must write &lt;code&gt;X* @Y&lt;/code&gt; to ensure that PostgreSQL reads it as two operator names not one.</source>
          <target state="translated">비 SQL 표준 연산자 이름으로 작업 할 때는 일반적으로 모호성을 피하기 위해 인접한 연산자를 공백으로 구분해야합니다. 예를 들어, &lt;code&gt;@&lt;/code&gt; 이라는 왼쪽 단항 연산자를 정의한 경우 &lt;code&gt;X*@Y&lt;/code&gt; 쓸 수 없습니다 . PostgreSQL &lt;code&gt;X* @Y&lt;/code&gt; 를 하나의 연산자가 아닌 두 개의 연산자 이름으로 읽도록 X * @Y 를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ec3a2849e7e7665d1ef0586b393970fa38e06c50" translate="yes" xml:space="preserve">
          <source>When working with recursive queries it is important to be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. Sometimes, using &lt;code&gt;UNION&lt;/code&gt; instead of &lt;code&gt;UNION ALL&lt;/code&gt; can accomplish this by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are completely duplicate: it may be necessary to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the already-visited values. For example, consider the following query that searches a table &lt;code&gt;graph&lt;/code&gt; using a &lt;code&gt;link&lt;/code&gt; field:</source>
          <target state="translated">재귀 쿼리로 작업 할 때 쿼리의 재귀 부분이 결국 튜플을 반환하지 않거나 쿼리가 무기한 반복되도록해야합니다. 때로는 &lt;code&gt;UNION ALL&lt;/code&gt; 대신 &lt;code&gt;UNION&lt;/code&gt; 을 사용하면 이전 출력 행을 복제하는 행을 삭제하여이 작업을 수행 할 수 있습니다. 그러나주기에 완전히 중복되는 출력 행이 포함되지 않는 경우가 있습니다. 동일한 포인트에 도달했는지 확인하기 위해 하나 또는 몇 개의 필드 만 확인해야 할 수도 있습니다. 이러한 상황을 처리하는 표준 방법은 이미 방문한 값의 배열을 계산하는 것입니다. 예를 들어, &lt;code&gt;link&lt;/code&gt; 필드를 사용하여 테이블 &lt;code&gt;graph&lt;/code&gt; 를 검색하는 다음 쿼리를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5718cfeb2fe2d91286009aaf2e77c006f835bbe" translate="yes" xml:space="preserve">
          <source>When writing an interval constant with a &lt;code&gt;fields&lt;/code&gt; specification, or when assigning a string to an interval column that was defined with a &lt;code&gt;fields&lt;/code&gt; specification, the interpretation of unmarked quantities depends on the &lt;code&gt;fields&lt;/code&gt;. For example &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; is read as 1 year, whereas &lt;code&gt;INTERVAL '1'&lt;/code&gt; means 1 second. Also, field values &amp;ldquo;to the right&amp;rdquo; of the least significant field allowed by the &lt;code&gt;fields&lt;/code&gt; specification are silently discarded. For example, writing &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; results in dropping the seconds field, but not the day field.</source>
          <target state="translated">으로 일정한 간격을 작성할 때 &lt;code&gt;fields&lt;/code&gt; 데이터 유형으로 정의 된 간격 열 문자열을 할당 할 때 명세서 또는 &lt;code&gt;fields&lt;/code&gt; 사양, 수량의 도장이 해석은에 따라 &lt;code&gt;fields&lt;/code&gt; . 예를 들어 &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; 는 1 년으로 읽히지 만 &lt;code&gt;INTERVAL '1'&lt;/code&gt; 은 1 초를 나타냅니다. 또한 &lt;code&gt;fields&lt;/code&gt; 스펙에 의해 허용되는 최하위 필드의 &quot;오른쪽에있는&quot;필드 값 은 자동으로 삭제됩니다. 예를 들어, &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; 초 필드는 삭제되지만 일 필드는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="988ef8be5d9c8af4c97d0fc59910f990922134e4" translate="yes" xml:space="preserve">
          <source>When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.</source>
          <target state="translated">테이블을 만들 때 실수를했거나 응용 프로그램의 요구 사항이 변경되었다는 것을 알게되면 테이블을 삭제하고 다시 만들 수 있습니다. 그러나 테이블이 이미 데이터로 채워져 있거나 다른 데이터베이스 개체 (예 : 외래 키 제약 조건)에서 테이블을 참조하는 경우 편리한 옵션이 아닙니다. 따라서 PostgreSQL은 기존 테이블을 수정하기위한 명령 군을 제공합니다. 이것은 개념적으로 테이블에 포함 된 데이터를 변경하는 것과 구별됩니다. 여기서는 테이블의 정의 또는 구조를 변경하는 데 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a09c13346cb20d8d1dd7186def1b2a2f01cbc1" translate="yes" xml:space="preserve">
          <source>When you create complex database structures involving many tables with foreign key constraints, views, triggers, functions, etc. you implicitly create a net of dependencies between the objects. For instance, a table with a foreign key constraint depends on the table it references.</source>
          <target state="translated">외래 키 제약 조건, 뷰, 트리거, 함수 등을 사용하여 많은 테이블이 포함 된 복잡한 데이터베이스 구조를 만들면 개체간에 종속성이 생길 수 있습니다. 예를 들어 외래 키 제약 조건이있는 테이블은 참조하는 테이블에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b9a5344aa581794cb8d710e210bdb65e511f2134" translate="yes" xml:space="preserve">
          <source>When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other.</source>
          <target state="translated">서로 관련된 많은 테이블을 만들 때는 테이블과 열에 대해 일관된 이름 지정 패턴을 선택하는 것이 좋습니다. 예를 들어, 테이블 이름에 단수 또는 복수 명사를 사용할 수 있습니다. 둘 다 일부 이론가 또는 다른 사람들이 선호합니다.</target>
        </trans-unit>
        <trans-unit id="593e96c33f6f0aab676c4ca184c4ca854f13bc97" translate="yes" xml:space="preserve">
          <source>When you insert invalid numbers in a table using the weak mode, the number will be inserted with the corrected check digit, but it will be displayed with an exclamation mark (&lt;code&gt;!&lt;/code&gt;) at the end, for example &lt;code&gt;0-11-000322-5!&lt;/code&gt;. This invalid marker can be checked with the &lt;code&gt;is_valid&lt;/code&gt; function and cleared with the &lt;code&gt;make_valid&lt;/code&gt; function.</source>
          <target state="translated">약한 모드를 사용하여 테이블에 유효하지 않은 숫자를 삽입하면 수정 된 체크 숫자와 함께 숫자가 삽입되지만 끝에 느낌표 ( &lt;code&gt;!&lt;/code&gt; ) 가 표시됩니다 ( 예 : &lt;code&gt;0-11-000322-5!&lt;/code&gt; . 이 유효하지 않은 마커는 &lt;code&gt;is_valid&lt;/code&gt; 함수 로 확인 하고 &lt;code&gt;make_valid&lt;/code&gt; 함수로 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bf59c49779a368d436367de404fed33cad74dcd" translate="yes" xml:space="preserve">
          <source>When you query JSON data, the path expression may not match the actual JSON data structure. An attempt to access a non-existent member of an object or element of an array results in a structural error. SQL/JSON path expressions have two modes of handling structural errors:</source>
          <target state="translated">JSON 데이터를 쿼리 할 때 경로 표현식이 실제 JSON 데이터 구조와 일치하지 않을 수 있습니다. 객체 또는 배열 요소의 존재하지 않는 멤버에 액세스하려고하면 구조적 오류가 발생합니다. SQL / JSON 경로 표현식에는 구조적 오류를 처리하는 두 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3780caf73c39bd4ac2d31b375fc0dd6e1923bd0" translate="yes" xml:space="preserve">
          <source>When you write the argument of a sequence function as an unadorned literal string, it becomes a constant of type &lt;code&gt;regclass&lt;/code&gt;. Since this is really just an OID, it will track the originally identified sequence despite later renaming, schema reassignment, etc. This &amp;ldquo;early binding&amp;rdquo; behavior is usually desirable for sequence references in column defaults and views. But sometimes you might want &amp;ldquo;late binding&amp;rdquo; where the sequence reference is resolved at run time. To get late-binding behavior, force the constant to be stored as a &lt;code&gt;text&lt;/code&gt; constant instead of &lt;code&gt;regclass&lt;/code&gt;:</source>
          <target state="translated">시퀀스 함수의 인수를 비 인수 리터럴 문자열로 쓰면 &lt;code&gt;regclass&lt;/code&gt; 유형의 상수가됩니다 . 이것은 실제로 OID 일 뿐이므로 나중에 이름 변경, 스키마 재 할당 등에도 불구하고 원래 식별 된 시퀀스를 추적합니다.이 &quot;초기 바인딩&quot;동작은 일반적으로 열 기본값 및 뷰의 시퀀스 참조에 바람직합니다. 그러나 때때로 시퀀스 참조가 런타임에 해결되는 &quot;late binding&quot;을 원할 수도 있습니다. 늦은 바인딩 동작을 얻으려면 상수를 &lt;code&gt;regclass&lt;/code&gt; 대신 &lt;code&gt;text&lt;/code&gt; 상수 로 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="0deb417e3efe2ecd61376860b861e35f77f81d08" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;ANALYZE&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_analyze&lt;/code&gt; view will contain a row for each backend that is currently running that command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 가 실행될 때마다 &lt;code&gt;pg_stat_progress_analyze&lt;/code&gt; 보기에는 현재 해당 명령을 실행중인 각 백엔드에 대한 행이 포함됩니다. 아래 표는보고 될 정보를 설명하고이를 해석하는 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2507ec70331a5deab93cd40d826b1bdba44ecbc3" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; view will contain a row for each backend that is currently running either command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; 또는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 이 실행될 때마다 &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; 보기에는 현재 두 명령 중 하나를 실행중인 각 백엔드에 대한 행이 포함됩니다. 아래 표는보고 될 정보를 설명하고 해석 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="51b73a7d0ff3b39db66ff19d5f58e0f20613bb45" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; view will contain one row for each backend that is currently creating indexes. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; 또는 &lt;code&gt;REINDEX&lt;/code&gt; 가 실행될 때마다 &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; 보기는 현재 색인을 작성중인 각 백엔드마다 하나의 행을 포함합니다. 아래 표는보고 될 정보를 설명하고 해석 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0da2e4c266065ef5b47dc244d1142646be363723" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 실행될 때마다 &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; 보기는 현재 진공 상태 인 각 백엔드 (자동 진공 작업자 프로세스 포함)에 대해 하나의 행을 포함합니다. 아래 표는보고 될 정보를 설명하고 해석 방법에 대한 정보를 제공합니다. 진행을 위해 &lt;code&gt;VACUUM FULL&lt;/code&gt; 명령을 통해보고 &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; 모두 있기 때문에 &lt;code&gt;VACUUM FULL&lt;/code&gt; 와 &lt;code&gt;CLUSTER&lt;/code&gt; 가 테이블을 재 작성 규칙적인 반면, &lt;code&gt;VACUUM&lt;/code&gt; 유일한 장소에서 그것을 수정합니다. &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;섹션 27.4.3&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="3fb8592a09f7a3ed7d4104db7d0d68ac3ee490fb" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 실행될 때마다 &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; 보기에는 현재 vacuum 중인 각 백엔드 (autovacuum 작업자 프로세스 포함)에 대해 하나의 행이 포함됩니다. 아래 표는보고 될 정보를 설명하고이를 해석하는 방법에 대한 정보를 제공합니다. &lt;code&gt;VACUUM FULL&lt;/code&gt; 명령에 대한 진행률은 &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; 를 통해보고됩니다. &lt;code&gt;VACUUM FULL&lt;/code&gt; 및 &lt;code&gt;CLUSTER&lt;/code&gt; 는 모두 테이블을 재 작성하는 반면 일반 &lt;code&gt;VACUUM&lt;/code&gt; 은 제자리에서 수정 만하 기 때문 입니다. &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;27.4.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48d664025546cdeafdfe0701b9fa38130d919c75" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; scans any part of a table, it will replace any multixact ID it encounters which is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;, an aggressive vacuum is forced. As discussed in the previous section, an aggressive vacuum means that only those pages which are known to be all-frozen will be skipped. &lt;code&gt;mxid_age()&lt;/code&gt; can be used on &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; to find its age.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 테이블의 일부를 스캔 할 때마다 &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; 보다 오래된 멀티 플렉스 ID를 다른 값으로 대체 합니다 (0 값, 단일 트랜잭션 ID 또는 최신 멀티 플렉스 ID). 각 테이블의 경우, &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relminmxid&lt;/code&gt; 는 해당 테이블의 튜플에 여전히 나타나는 가장 오래된 가능한 멀티 플렉스 ID를 저장합니다. 이 값이 &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt; 보다 오래된 경우 공격적인 진공이 발생합니다. 이전 섹션에서 설명한 바와 같이 공격적인 진공 상태는 완전히 고정 된 것으로 알려진 페이지 만 건너 뜁니다. &lt;code&gt;pg_class&lt;/code&gt; 에서 &lt;code&gt;mxid_age()&lt;/code&gt; 사용할 수 있습니다 . &lt;code&gt;relminmxid&lt;/code&gt; 나이를 찾기 위해.</target>
        </trans-unit>
        <trans-unit id="5f844cc225201cbe85cbdde3d905d07e347e61a8" translate="yes" xml:space="preserve">
          <source>Whenever PostgreSQL needs to combine rows from multiple sources into a single result set, it uses an &lt;code&gt;Append&lt;/code&gt; or &lt;code&gt;MergeAppend&lt;/code&gt; plan node. This commonly happens when implementing &lt;code&gt;UNION ALL&lt;/code&gt; or when scanning a partitioned table. Such nodes can be used in parallel plans just as they can in any other plan. However, in a parallel plan, the planner may instead use a &lt;code&gt;Parallel Append&lt;/code&gt; node.</source>
          <target state="translated">PostgreSQL은 여러 소스의 행을 단일 결과 집합으로 결합해야 할 때마다 &lt;code&gt;Append&lt;/code&gt; 또는 &lt;code&gt;MergeAppend&lt;/code&gt; 계획 노드를 사용합니다. 이는 일반적으로 &lt;code&gt;UNION ALL&lt;/code&gt; 을 구현 하거나 파티션 된 테이블을 스캔 할 때 발생 합니다. 이러한 노드는 다른 계획에서와 마찬가지로 병렬 계획에서 사용될 수 있습니다. 그러나 병렬 계획에서 플래너는 대신 &lt;code&gt;Parallel Append&lt;/code&gt; 노드 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85e82d59ea38cfaea7777dbbbcc2b327247984a8" translate="yes" xml:space="preserve">
          <source>Whenever a command is executed, psql also polls for asynchronous notification events generated by &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;.</source>
          <target state="translated">명령이 실행될 때마다 psql은 &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; 및 &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY에&lt;/a&gt; 의해 생성 된 비동기 알림 이벤트를 폴링합니다 .</target>
        </trans-unit>
        <trans-unit id="fe283c15f98e1d6878cfeeadd5bbfd6c5078c552" translate="yes" xml:space="preserve">
          <source>Whenever a user-defined type is created, PostgreSQL automatically creates an associated array type, whose name consists of the element type's name prepended with an underscore, and truncated if necessary to keep it less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long. (If the name so generated collides with an existing type name, the process is repeated until a non-colliding name is found.) This implicitly-created array type is variable length and uses the built-in input and output functions &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. The array type tracks any changes in its element type's owner or schema, and is dropped if the element type is.</source>
          <target state="translated">사용자 정의 형식이 생성 될 때마다 PostgreSQL은 연관된 배열 형식을 자동으로 생성합니다.이 형식의 이름은 밑줄이 앞에 붙은 요소 형식의 이름으로 구성되며 필요한 경우 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 바이트 보다 작게 유지해야합니다 . 생성 된 이름이 기존 유형 이름과 충돌하는 경우 충돌하지 않는 이름을 찾을 때까지 프로세스가 반복됩니다. 암시 적으로 생성 된이 배열 유형은 가변 길이이며 내장 입력 및 출력 함수 &lt;code&gt;array_in&lt;/code&gt; 및 &lt;code&gt;array_out&lt;/code&gt; 을 사용 합니다. 배열 유형은 요소 유형 소유자 또는 스키마의 모든 변경 사항을 추적하고 요소 유형 인 경우 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="7c3ae7e94c74ecafe04f858b486a7a8022aa32dd" translate="yes" xml:space="preserve">
          <source>Whenever an application like pg_basebackup is taking a base backup, the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will contain a row for each WAL sender process that is currently running the &lt;code&gt;BASE_BACKUP&lt;/code&gt; replication command and streaming the backup. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">pg_basebackup과 같은 애플리케이션이 기본 백업을 수행 할 때마다 &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; 뷰에는 현재 &lt;code&gt;BASE_BACKUP&lt;/code&gt; 복제 명령을 실행 하고 백업을 스트리밍하는 각 WAL 발신자 프로세스에 대한 행이 포함됩니다 . 아래 표는보고 될 정보를 설명하고이를 해석하는 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c317e2f18ac74c5065186374d831c55658598512" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by a single backend, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;0&lt;/code&gt;, i.e., no forced writeback. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the maximum value scales proportionally to it.)</source>
          <target state="translated">단일 백엔드가이 양보다 많은 양의 데이터를 기록 할 때마다 OS가 기본 스토리지에 이러한 쓰기를 실행하도록합니다. 이렇게하면 커널의 페이지 캐시에있는 더티 데이터의 양이 제한되어 검사 점이 끝날 때 &lt;code&gt;fsync&lt;/code&gt; 가 발행되거나 OS가 백그라운드에서 더 큰 배치로 데이터를 다시 쓸 때 중단 될 가능성이 줄어 듭니다 . 종종 트랜잭션 대기 시간이 크게 줄어드는 경우가 있지만 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 보다 크지 만 성능이 저하 될 수있는 OS의 페이지 캐시보다 작은 워크로드의 경우도 있습니다. 이 설정은 일부 플랫폼에 영향을 미치지 않을 수 있습니다. 이 값을 단위없이 지정하면 블록으로 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트, 일반적으로 8kB 유효한 범위는 &lt;code&gt;0&lt;/code&gt; 이며 강제 쓰기 저장을 사용하지 않으며 &lt;code&gt;2MB&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다 . 즉 강제 쓰기 저장이 없습니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8kB가 아닌 경우 최대 값은 비례 적으로 비례합니다.)</target>
        </trans-unit>
        <trans-unit id="de89b6016c756123d6b9441e22d55848a32a9ab3" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;512kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">백그라운드 작성기가 이보다 많은 양의 데이터를 쓸 때마다 OS가 기본 쓰기 저장소에 이러한 쓰기를 실행하도록합니다. 이렇게하면 커널의 페이지 캐시에있는 더티 데이터의 양이 제한되어 검사 점이 끝날 때 &lt;code&gt;fsync&lt;/code&gt; 가 발행되거나 OS가 백그라운드에서 더 큰 배치로 데이터를 다시 쓸 때 중단 될 가능성이 줄어 듭니다 . 종종 트랜잭션 대기 시간이 크게 줄어드는 경우가 있지만 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 보다 크지 만 성능이 저하 될 수있는 OS의 페이지 캐시보다 작은 워크로드의 경우도 있습니다. 이 설정은 일부 플랫폼에 영향을 미치지 않을 수 있습니다. 이 값을 단위없이 지정하면 블록으로 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트, 일반적으로 8kB 유효한 범위는 &lt;code&gt;0&lt;/code&gt; 이며 강제 쓰기 저장을 사용하지 않으며 &lt;code&gt;2MB&lt;/code&gt; 입니다. 기본값은 Linux에서 &lt;code&gt;512kB&lt;/code&gt; 이고 다른 곳 에서는 &lt;code&gt;0&lt;/code&gt; 입니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8kB가 아닌 경우 기본값과 최대 값이 비례 적으로 조정됩니다.)이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 행 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41035af23763d236bc43d7713084261d3a812120" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written while performing a checkpoint, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of the checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;256kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">검사 점을 수행하는 동안 이보다 많은 양의 데이터가 기록 될 때마다 OS가 기본 쓰기 저장소에 이러한 쓰기를 실행하도록합니다. 이렇게하면 커널의 페이지 캐시에서 더티 데이터의 양이 제한되어 검사 점 끝에서 &lt;code&gt;fsync&lt;/code&gt; 가 발행되거나 OS가 백그라운드에서 더 큰 배치로 데이터를 다시 쓸 때 중단 될 가능성이 줄어 듭니다 . 종종 트랜잭션 대기 시간이 크게 줄어드는 경우가 있지만 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 보다 크지 만 성능이 저하 될 수있는 OS의 페이지 캐시보다 작은 워크로드의 경우도 있습니다. 이 설정은 일부 플랫폼에 영향을 미치지 않을 수 있습니다. 이 값을 단위없이 지정하면 블록으로 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트, 일반적으로 8kB 유효한 범위는 &lt;code&gt;0&lt;/code&gt; 이며 강제 쓰기 저장을 사용하지 않으며 &lt;code&gt;2MB&lt;/code&gt; 입니다. 기본값은 Linux에서 &lt;code&gt;256kB&lt;/code&gt; 이고 다른 곳 에서는 &lt;code&gt;0&lt;/code&gt; 입니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8kB가 아닌 경우 기본값과 최대 값이 비례 적으로 조정됩니다.)이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 행 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="103203b2b9af3babb0455dacf44200f8d0e1dba1" translate="yes" xml:space="preserve">
          <source>Whenever pg_basebackup is taking a base backup, the server's &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will report the progress of the backup. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt; for details.</source>
          <target state="translated">pg_basebackup이 기본 백업을 수행 할 때마다 서버의 &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; 보기는 백업 진행 상황을보고합니다. 자세한 내용은 &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;섹션 27.4.5&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cafdfe0e40c272ef5695922c2a975f51df9e1cea" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;pattern&lt;/code&gt; parameter is omitted completely, the &lt;code&gt;\d&lt;/code&gt; commands display all objects that are visible in the current schema search path &amp;mdash; this is equivalent to using &lt;code&gt;*&lt;/code&gt; as the pattern. (An object is said to be &lt;em&gt;visible&lt;/em&gt; if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use &lt;code&gt;*.*&lt;/code&gt; as the pattern.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 매개 변수가 완전히 생략 될 때마다 &lt;code&gt;\d&lt;/code&gt; 명령은 현재 스키마 검색 경로에 보이는 모든 오브젝트를 표시합니다 . 이는 &lt;code&gt;*&lt;/code&gt; 를 패턴 으로 사용하는 것과 같습니다 . (객체가 될 수라고 &lt;em&gt;볼 수&lt;/em&gt; 는 포함 스키마가 검색 경로에 동일한 종류와 이름의 객체가 검색 경로에서 이전에 나타납니다없는 경우.이 객체가 명시 적 스키마없이 이름으로 참조 할 수있는 문에 해당 가시성에 관계없이 데이터베이스의 모든 오브젝트를 보려면 패턴으로 &lt;code&gt;*.*&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2dffd7d6d50f37b1f139649fc2afe46f33411c06" translate="yes" xml:space="preserve">
          <source>Whenever the command &lt;code&gt;NOTIFY channel&lt;/code&gt; is invoked, either by this session or another one connected to the same database, all the sessions currently listening on that notification channel are notified, and each will in turn notify its connected client application.</source>
          <target state="translated">이 세션 또는 동일한 데이터베이스에 연결된 다른 세션에서 &lt;code&gt;NOTIFY channel&lt;/code&gt; 명령을 호출 할 때마다 해당 알림 채널에서 현재 수신 대기중인 모든 세션에 알림이 표시되고 각 세션은 연결된 클라이언트 응용 프로그램에 알립니다.</target>
        </trans-unit>
        <trans-unit id="464c9a84b9274c416e8217076cf62d6ce77919b2" translate="yes" xml:space="preserve">
          <source>Whenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. This only happens at login time; executing &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; or &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; does not cause new configuration values to be set. Settings set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.</source>
          <target state="translated">이후에 역할이 새 세션을 시작할 때마다 지정된 값이 세션 기본값이되어 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 있거나 &lt;code&gt;postgres&lt;/code&gt; 명령 줄 에서받은 설정을 무시 합니다. 이것은 로그인시에만 발생합니다. &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 또는 &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION을&lt;/a&gt; 실행 해도 새로운 구성 값이 설정되지 않습니다. 모든 데이터베이스에 대해 설정된 설정은 역할에 연결된 데이터베이스 별 설정으로 대체됩니다. 특정 데이터베이스 또는 특정 역할에 대한 설정이 모든 역할에 대한 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1cb07a399aec26555c15e193c16effe1e79f48af" translate="yes" xml:space="preserve">
          <source>Whenever you create a table, a composite type is also automatically created, with the same name as the table, to represent the table's row type. For example, had we said:</source>
          <target state="translated">테이블을 작성할 때마다 테이블의 행 유형을 나타 내기 위해 테이블과 동일한 이름으로 복합 유형도 자동으로 작성됩니다. 예를 들어 다음과 같이 말한 적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72417af150626f41547b564cc2af3102889d282f" translate="yes" xml:space="preserve">
          <source>Whenever you have significantly altered the distribution of data within a table, running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; is strongly recommended. This includes bulk loading large amounts of data into the table. Running &lt;code&gt;ANALYZE&lt;/code&gt; (or &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;) ensures that the planner has up-to-date statistics about the table. With no statistics or obsolete statistics, the planner might make poor decisions during query planning, leading to poor performance on any tables with inaccurate or nonexistent statistics. Note that if the autovacuum daemon is enabled, it might run &lt;code&gt;ANALYZE&lt;/code&gt; automatically; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">테이블 내에서 데이터 분포를 크게 변경 한 경우에는 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE를&lt;/a&gt; 실행 하는 것이 좋습니다. 여기에는 대량의 데이터를 테이블에 대량로드하는 것이 포함됩니다. &lt;code&gt;ANALYZE&lt;/code&gt; (또는 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; )를 실행 하면 플래너가 테이블에 대한 최신 통계를 갖습니다. 통계가 없거나 사용되지 않는 통계가 없으면 플래너는 쿼리 계획 중에 의사 결정을 잘못하여 통계가 부정확하거나 존재하지 않는 테이블에서 성능이 저하 될 수 있습니다. autovacuum 데몬이 활성화되면 &lt;code&gt;ANALYZE&lt;/code&gt; 가 자동으로 실행될 수 있습니다 . 참조 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;섹션 24.1.3&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6을&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="70267c330cb08a0ff5a2a298e316262a59a144c4" translate="yes" xml:space="preserve">
          <source>Where interoperability with other systems is a concern, for some data types, it may be necessary to use data type formatting functions (such as those in &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) explicitly to produce the standard mappings.</source>
          <target state="translated">다른 시스템과의 상호 운용성이 중요한 경우, 일부 데이터 유형의 경우 표준 맵핑을 생성하기 위해 명시 적으로 데이터 유형 형식화 기능 (예 : &lt;a href=&quot;functions-formatting&quot;&gt;섹션 9.8&lt;/a&gt; ) 을 사용해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de87765a2f74958f3598da9f1ae5cd4df124304a" translate="yes" xml:space="preserve">
          <source>Where the command omits database name, user, host, or port, the new connection can reuse values from the previous connection. By default, values from the previous connection are reused except when processing a &lt;code&gt;conninfo&lt;/code&gt; string. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. When the command neither specifies nor reuses a particular parameter, the libpq default is used. Specifying any of &lt;code&gt;dbname&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter. If &lt;code&gt;hostaddr&lt;/code&gt; was specified in the original connection's &lt;code&gt;conninfo&lt;/code&gt;, that address is reused for the new connection (disregarding any other host specification).</source>
          <target state="translated">명령이 데이터베이스 이름, 사용자, 호스트 또는 포트를 생략하면 새 연결은 이전 연결의 값을 재사용 할 수 있습니다. 기본적으로 &lt;code&gt;conninfo&lt;/code&gt; 문자열을 처리 할 때를 제외하고 이전 연결의 값이 재사용됩니다 . &lt;code&gt;-reuse-previous=on&lt;/code&gt; 또는 &lt;code&gt;-reuse-previous=off&lt;/code&gt; 의 첫 번째 인수를 전달하면 해당 기본값이 무시됩니다. 명령이 특정 매개 변수를 지정하거나 재사용하지 않으면 libpq 기본값이 사용됩니다. &lt;code&gt;dbname&lt;/code&gt; , &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;host&lt;/code&gt; 또는 &lt;code&gt;port&lt;/code&gt; 를 &lt;code&gt;-&lt;/code&gt; 로 지정하는 것은 해당 매개 변수를 생략하는 것과 같습니다. 원래 연결의 &lt;code&gt;conninfo&lt;/code&gt; 에 &lt;code&gt;hostaddr&lt;/code&gt; 이 지정된 경우이 주소는 다른 호스트 사양을 무시하고 새 연결에 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b1968453a400f5fd07425f7b52ed24d9c6b52b" translate="yes" xml:space="preserve">
          <source>Where the current standard provides a family of XML data types to hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo; in untyped or XML Schema-typed variants, and a type &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; to hold arbitrary pieces of XML content, PostgreSQL provides the single &lt;code&gt;xml&lt;/code&gt; type, which can hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo;. There is no equivalent of the standard's &amp;ldquo;sequence&amp;rdquo; type.</source>
          <target state="translated">현재 표준이 유형이 지정되지 않은 XML 스키마 유형 변형에서 &quot;문서&quot;또는 &quot;콘텐츠&quot;를 보유하는 XML 데이터 유형 군을 제공하고 임의의 XML 컨텐츠를 보유하는 &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; 유형을 제공하는 경우 PostgreSQL은 단일 &lt;code&gt;xml&lt;/code&gt; 유형을 제공합니다. '문서'또는 '콘텐츠'를 보유 할 수 있습니다. 표준의 &quot;시퀀스&quot;유형과 동등한 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9be0ce89e49423198dedc7c03fd710b9a77c7468" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;pgstattuple&lt;/code&gt; always performs a full-table scan and returns an exact count of live and dead tuples (and their sizes) and free space, &lt;code&gt;pgstattuple_approx&lt;/code&gt; tries to avoid the full-table scan and returns exact dead tuple statistics along with an approximation of the number and size of live tuples and free space.</source>
          <target state="translated">반면 &lt;code&gt;pgstattuple&lt;/code&gt; 은 항상 전체 테이블을 스캔 및 반품 라이브와 죽은 튜플 (및 크기)의 정확한 수와 여유 공간을 수행 &lt;code&gt;pgstattuple_approx&lt;/code&gt; 의 시도는 스캔 전체 테이블을 피하기 위해 반환 숫자의 근사치와 함께 죽은 튜플 통계를 정확한 라이브 튜플과 여유 공간의 크기.</target>
        </trans-unit>
        <trans-unit id="9ec341d8bc6b0b4825eb80f0ff91c4f3ae8eee3b" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;aggfinalfn&lt;/code&gt; modifies the transition state value: &lt;code&gt;r&lt;/code&gt; if it is read-only, &lt;code&gt;s&lt;/code&gt; if the &lt;code&gt;aggtransfn&lt;/code&gt; cannot be applied after the &lt;code&gt;aggfinalfn&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; if it writes on the value</source>
          <target state="translated">&lt;code&gt;aggfinalfn&lt;/code&gt; 이 전이 상태 값을 수정 하는지 여부 : &lt;code&gt;r&lt;/code&gt; 읽기 전용 인 경우 &lt;code&gt;s&lt;/code&gt; &lt;code&gt;aggtransfn&lt;/code&gt; 이후에 &lt;code&gt;aggfinalfn&lt;/code&gt; 적용 할 수없는 경우 s 또는 값을 쓰는 경우 &lt;code&gt;w&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b63ddfd6a1548ba35d00a888f441158a5e09419b" translate="yes" xml:space="preserve">
          <source>Whether an RE is greedy or not is determined by the following rules:</source>
          <target state="translated">RE가 욕심인지 아닌지는 다음 규칙에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="a052d21cc109877e0a34f6fceb8177147b8e054e" translate="yes" xml:space="preserve">
          <source>Whether the sequence cycles</source>
          <target state="translated">시퀀스 사이클 여부</target>
        </trans-unit>
        <trans-unit id="099ca603e257bb42c8d0080a36e8a200732df4c1" translate="yes" xml:space="preserve">
          <source>Whether to convert &lt;code&gt;\n&lt;/code&gt; into &lt;code&gt;\r\n&lt;/code&gt; when encrypting and &lt;code&gt;\r\n&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; when decrypting. RFC 4880 specifies that text data should be stored using &lt;code&gt;\r\n&lt;/code&gt; line-feeds. Use this to get fully RFC-compliant behavior.</source>
          <target state="translated">암호화 할 때 &lt;code&gt;\n&lt;/code&gt; 을 &lt;code&gt;\r\n&lt;/code&gt; \ n 으로 변환 하고 해독 할 때 &lt;code&gt;\r\n&lt;/code&gt; 을 &lt;code&gt;\n&lt;/code&gt; 으로 변환할지 여부 . RFC 4880은 &lt;code&gt;\r\n&lt;/code&gt; 줄 바꿈을 사용하여 텍스트 데이터를 저장하도록 지정합니다 . 이를 사용하여 RFC를 완벽하게 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="6a913bec72a9d1cd9190d3ca3274a90d4c381b09" translate="yes" xml:space="preserve">
          <source>Whether to convert textual data from database internal encoding to UTF-8 and back. If your database already is UTF-8, no conversion will be done, but the message will be tagged as UTF-8. Without this option it will not be.</source>
          <target state="translated">데이터베이스 내부 인코딩에서 UTF-8로 텍스트 데이터를 변환할지 여부. 데이터베이스가 이미 UTF-8 인 경우 변환이 수행되지 않지만 메시지는 UTF-8로 태그 지정됩니다. 이 옵션이 없으면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d0908bbd26e431175b3928caa067e2b55410af7" translate="yes" xml:space="preserve">
          <source>Which S2K algorithm to use.</source>
          <target state="translated">사용할 S2K 알고리즘</target>
        </trans-unit>
        <trans-unit id="1b435ac17c99f4ed78933b5d05d5b47d3dfdd820" translate="yes" xml:space="preserve">
          <source>Which cipher algorithm to use.</source>
          <target state="translated">사용할 암호 알고리즘</target>
        </trans-unit>
        <trans-unit id="4215d6c5a786cf08cc1b93732554ac25c2ba7716" translate="yes" xml:space="preserve">
          <source>Which cipher to use for encrypting separate session key.</source>
          <target state="translated">별도의 세션 키를 암호화하는 데 사용할 암호</target>
        </trans-unit>
        <trans-unit id="8c9643312802b96a36d211d4bd8a2d4fbec5df7d" translate="yes" xml:space="preserve">
          <source>Which compression algorithm to use. Only available if PostgreSQL was built with zlib.</source>
          <target state="translated">사용할 압축 알고리즘. PostgreSQL이 zlib로 빌드 된 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36178694d36e0d8b9b4d6953d14f4cb84f698946" translate="yes" xml:space="preserve">
          <source>Which digest algorithm to use in S2K calculation.</source>
          <target state="translated">S2K 계산에 사용할 다이제스트 알고리즘</target>
        </trans-unit>
        <trans-unit id="5b9d8c9d7eb5636216a755086b48fa5a8cd067ff" translate="yes" xml:space="preserve">
          <source>Which one of these you use is mainly a matter of style. The &lt;code&gt;JOIN&lt;/code&gt; syntax in the &lt;code&gt;FROM&lt;/code&gt; clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the &lt;code&gt;FROM&lt;/code&gt; clause. The &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause of an outer join is &lt;em&gt;not&lt;/em&gt; equivalent to a &lt;code&gt;WHERE&lt;/code&gt; condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result.</source>
          <target state="translated">이 중 어느 것을 사용 하느냐는 주로 스타일의 문제입니다. (가) &lt;code&gt;JOIN&lt;/code&gt; 에서 구문을 &lt;code&gt;FROM&lt;/code&gt; 절하면이 SQL 표준에 경우에도 아마 다른 SQL 데이터베이스 관리 시스템으로 이식 할 수 없습니다. 외부 조인의 경우 선택의 여지가 없습니다 . &lt;code&gt;FROM&lt;/code&gt; 절 에서 수행해야합니다 . 외부 조인 의 &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;USING&lt;/code&gt; 절은 &lt;code&gt;WHERE&lt;/code&gt; 조건 과 동일 &lt;em&gt;하지 않습니다.&lt;/em&gt; 결과 가 &lt;em&gt;일치하지&lt;/em&gt; 않는 입력 행의 경우 행이 추가되고 최종 결과에서 행이 제거되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f207dff92fd241726ec3f780d5ff085d75648337" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="translated">존재하는 특정 연산자와 단항인지 이진인지는 시스템이나 사용자가 정의한 연산자에 따라 다릅니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장&lt;/a&gt; 에서는 내장 연산자에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6b60d8de1898a75db9c84423bdbee981b013228e" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="translated">어떤 특정 연산자가 존재하고 이들이 단항인지 이진인지 여부는 시스템이나 사용자가 정의한 연산자에 따라 다릅니다. &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;9 장&lt;/a&gt; 에서는 기본 제공 연산자에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8189028b5d12d59cd50147d702e5a513253a68c3" translate="yes" xml:space="preserve">
          <source>Which row(s) to update</source>
          <target state="translated">업데이트 할 행</target>
        </trans-unit>
        <trans-unit id="a8a5e55dc1620d200691892efc7a7c676cbd8264" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CREATE INDEX&lt;/code&gt; with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션이 있는 &lt;code&gt;CREATE INDEX&lt;/code&gt; 는 특별한 제한없이 병렬 빌드를 지원 하지만 실제로 첫 번째 테이블 스캔 만 병렬로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="714b73638a1ef948dee8dfe7820683df70955357" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;UNIQUE&lt;/code&gt; is a natural constraint for scalar values, it is usually unsuitable for range types. Instead, an exclusion constraint is often more appropriate (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt;). Exclusion constraints allow the specification of constraints such as &amp;ldquo;non-overlapping&amp;rdquo; on a range type. For example:</source>
          <target state="translated">반면 &lt;code&gt;UNIQUE&lt;/code&gt; 은 스칼라 값의 자연 제약, 그것은 다양한 유형 통상 부적합하다. 대신, 제외 제약 조건이 종종 더 적합합니다 ( &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE 참조&lt;/a&gt; ). 제외 제약 조건을 사용하면 범위 유형에 &quot;비 중복&quot;과 같은 제약 조건을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a9577e86cf0dfccc12f0ecf60188a3b6040e454" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;pg_resetwal&lt;/code&gt; will set the WAL starting address beyond the latest existing WAL segment file, some segment size changes can cause previous WAL file names to be reused. It is recommended to use &lt;code&gt;-l&lt;/code&gt; together with this option to manually set the WAL starting address if WAL file name overlap will cause problems with your archiving strategy.</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; 은 기존의 최신 WAL 세그먼트 파일을 넘어 WAL 시작 주소를 설정 하지만 일부 세그먼트 크기 변경으로 인해 이전 WAL 파일 이름이 재사용 될 수 있습니다. WAL 파일 이름이 겹치면 아카이브 전략에 문제가 발생할 경우이 옵션과 함께 &lt;code&gt;-l&lt;/code&gt; 을 사용 하여 WAL 시작 주소를 수동으로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="01708a73847573f321d3d2da0f455cb9f949df75" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;to_date&lt;/code&gt; will reject a mixture of Gregorian and ISO week-numbering date fields, &lt;code&gt;to_char&lt;/code&gt; will not, since output format specifications like &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; can be useful. But avoid writing something like &lt;code&gt;IYYY-MM-DD&lt;/code&gt;; that would yield surprising results near the start of the year. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt; for more information.)</source>
          <target state="translated">&lt;code&gt;to_date&lt;/code&gt; 는 Gregorian과 ISO 주 번호 매기기 날짜 필드의 혼합을 거부 하지만 &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; 와 같은 출력 형식 사양 이 유용 할 수 있으므로 &lt;code&gt;to_char&lt;/code&gt; 는 그렇지 않습니다 . 그러나 &lt;code&gt;IYYY-MM-DD&lt;/code&gt; 와 같은 것을 쓰지 마십시오 . 그것은 연초에 놀라운 결과를 낳을 것입니다. (자세한 내용 &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;은 9.9.1 절&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e362e9f328b5aa2d887a4c59191ea1b7f9721dc4" translate="yes" xml:space="preserve">
          <source>While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql.</source>
          <target state="translated">C 스타일 블록 주석은 처리 및 제거를 위해 서버로 전달되지만 SQL 표준 주석은 psql에 의해 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5d725442e0975d9459afb2abfae7302730928d6f" translate="yes" xml:space="preserve">
          <source>While PostgreSQL's Serializable transaction isolation level only allows concurrent transactions to commit if it can prove there is a serial order of execution that would produce the same effect, it doesn't always prevent errors from being raised that would not occur in true serial execution. In particular, it is possible to see unique constraint violations caused by conflicts with overlapping Serializable transactions even after explicitly checking that the key isn't present before attempting to insert it. This can be avoided by making sure that &lt;em&gt;all&lt;/em&gt; Serializable transactions that insert potentially conflicting keys explicitly check if they can do so first. For example, imagine an application that asks the user for a new key and then checks that it doesn't exist already by trying to select it first, or generates a new key by selecting the maximum existing key and adding one. If some Serializable transactions insert new keys directly without following this protocol, unique constraints violations might be reported even in cases where they could not occur in a serial execution of the concurrent transactions.</source>
          <target state="translated">PostgreSQL의 Serializable 트랜잭션 격리 수준은 동일한 효과를 생성하는 일련의 실행 순서가 있음을 증명할 수있는 경우 동시 트랜잭션 만 커밋 할 수 있지만 실제 직렬 실행에서는 발생하지 않는 오류가 발생하는 것을 항상 막지는 않습니다. 특히, 키를 삽입하기 전에 키가 존재하지 않는지 명시 적으로 확인한 후에도 겹치는 직렬화 가능 트랜잭션과의 충돌로 인한 고유 제한 조건 위반을 볼 수 있습니다. 이것은 &lt;em&gt;모든&lt;/em&gt; 것을 확인함으로써 피할 수 있습니다&lt;em&gt;&lt;/em&gt;충돌 가능성이있는 키를 삽입하는 직렬화 가능 트랜잭션은 먼저 수행 할 수 있는지 명시 적으로 확인합니다. 예를 들어, 사용자에게 새 키를 요청한 다음 먼저 키를 선택하여 존재하지 않는지 확인하거나 기존의 최대 키를 선택하고 추가하여 새 키를 생성하는 응용 프로그램을 상상해보십시오. 일부 직렬화 가능 트랜잭션이이 프로토콜을 따르지 않고 직접 새 키를 삽입하는 경우 동시 트랜잭션의 직렬 실행에서 발생할 수없는 경우에도 고유 제한 조건 위반이보고 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594dab457c5441b59c42227020751df6f6f62a48" translate="yes" xml:space="preserve">
          <source>While XQuery/XPath provides all of the types defined in XML Schema and many operators and functions over those types, XPath 1.0 has only node-sets and the three atomic types &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">XQuery / XPath는 XML 스키마에 정의 된 모든 유형과 해당 유형에 대한 많은 연산자 및 함수를 제공하지만 XPath 1.0에는 노드 세트와 3 개의 원자 유형 &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a627fd0ca096f765ec57a0f53e97d18839b3a4e" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;LIKE&lt;/code&gt; clause exists in the SQL standard, many of the options that PostgreSQL accepts for it are not in the standard, and some of the standard's options are not implemented by PostgreSQL.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 절이 SQL 표준에 존재 하지만 PostgreSQL이이를 수락하는 많은 옵션은 표준이 아니며 일부 표준 옵션은 PostgreSQL에 의해 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcdd2fd3f430f1ca01d2b3670c0f594bdee786bb" translate="yes" xml:space="preserve">
          <source>While a Repeatable Read transaction has a stable view of the data throughout its execution, there is a subtle issue with using MVCC snapshots for data consistency checks, involving something known as &lt;em&gt;read/write conflicts&lt;/em&gt;. If one transaction writes data and a concurrent transaction attempts to read the same data (whether before or after the write), it cannot see the work of the other transaction. The reader then appears to have executed first regardless of which started first or which committed first. If that is as far as it goes, there is no problem, but if the reader also writes data which is read by a concurrent transaction there is now a transaction which appears to have run before either of the previously mentioned transactions. If the transaction which appears to have executed last actually commits first, it is very easy for a cycle to appear in a graph of the order of execution of the transactions. When such a cycle appears, integrity checks will not work correctly without some help.</source>
          <target state="translated">반복 가능한 읽기 트랜잭션은 실행 전체에서 데이터를 안정적으로 볼 수 있지만 &lt;em&gt;읽기 / 쓰기 충돌&lt;/em&gt; 로 알려진 데이터 일관성 검사를 위해 MVCC 스냅 샷을 사용하는 데 미묘한 문제가 &lt;em&gt;있습니다.&lt;/em&gt;. 한 트랜잭션이 데이터를 쓰고 동시 트랜잭션이 같은 데이터를 쓰려고 시도하는 경우 (쓰기 전 또는 후에) 다른 트랜잭션의 작업을 볼 수 없습니다. 그런 다음 독자가 어느 것이 먼저 시작했는지 또는 어느 것이 먼저 커밋되었는지에 관계없이 먼저 실행 한 것으로 보입니다. 그것이 가능한 한 문제는 없지만 독자가 동시 트랜잭션에서 읽은 데이터를 쓰면 이전에 언급 된 트랜잭션 중 하나보다 먼저 실행 된 트랜잭션이있는 것입니다. 마지막으로 실행 된 것으로 보이는 트랜잭션이 실제로 먼저 커밋되면 트랜잭션 실행 순서의 그래프에주기가 나타나는 것이 매우 쉽습니다. 이러한주기가 나타나면 도움이 없으면 무결성 검사가 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a87fa7f9afe44920c1e825c81201c0429df3a1c" translate="yes" xml:space="preserve">
          <source>While a self-signed certificate can be used for testing, a certificate signed by a certificate authority (CA) (usually an enterprise-wide root CA) should be used in production.</source>
          <target state="translated">자체 서명 된 인증서를 사용하여 테스트 할 수 있지만 인증 기관 (CA) (일반적으로 전사적 루트 CA)이 서명 한 인증서를 프로덕션에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cdc31b216171332e350cb9df34dfb0418ab3630e" translate="yes" xml:space="preserve">
          <source>While designing your archiving setup, consider what will happen if the archive command fails repeatedly because some aspect requires operator intervention or the archive runs out of space. For example, this could occur if you write to tape without an autochanger; when the tape fills, nothing further can be archived until the tape is swapped. You should ensure that any error condition or request to a human operator is reported appropriately so that the situation can be resolved reasonably quickly. The &lt;code&gt;pg_wal/&lt;/code&gt; directory will continue to fill with WAL segment files until the situation is resolved. (If the file system containing &lt;code&gt;pg_wal/&lt;/code&gt; fills up, PostgreSQL will do a PANIC shutdown. No committed transactions will be lost, but the database will remain offline until you free some space.)</source>
          <target state="translated">보관 설정을 설계하는 동안 운영자의 개입이 필요하거나 보관 공간이 부족하여 보관 명령이 반복적으로 실패하면 어떻게되는지 고려하십시오. 예를 들어, Autochanger없이 테이프에 쓰면이 문제가 발생할 수 있습니다. 테이프가 가득 차면 테이프를 교체 할 때까지 더 이상 아카이브 할 수 없습니다. 상황이 합리적으로 신속하게 해결 될 수 있도록 오류 조건이나 작업자에게 요청한 내용이 적절하게보고되도록해야합니다. &lt;code&gt;pg_wal/&lt;/code&gt; 디렉토리는 상황이 해결 될 때까지 WAL 세그먼트 파일을 채울 것입니다. ( &lt;code&gt;pg_wal/&lt;/code&gt; 포함하는 파일 시스템이 가득 차면 PostgreSQL은 PANIC 종료를 수행합니다. 커밋 된 트랜잭션은 손실되지 않지만 공간을 확보 할 때까지 데이터베이스는 오프라인 상태를 유지합니다.)</target>
        </trans-unit>
        <trans-unit id="ed48d255fcc854a30e92ea66bfc2714ea9b2abf4" translate="yes" xml:space="preserve">
          <source>While forcing data to the disk platters periodically might seem like a simple operation, it is not. Because disk drives are dramatically slower than main memory and CPUs, several layers of caching exist between the computer's main memory and the disk platters. First, there is the operating system's buffer cache, which caches frequently requested disk blocks and combines disk writes. Fortunately, all operating systems give applications a way to force writes from the buffer cache to disk, and PostgreSQL uses those features. (See the &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; parameter to adjust how this is done.)</source>
          <target state="translated">디스크 플래터에 데이터를 주기적으로 강제하는 것은 간단한 작업처럼 보이지만 그렇지 않습니다. 디스크 드라이브는 주 메모리 및 CPU보다 속도가 매우 느리기 때문에 컴퓨터의 주 메모리와 디스크 플래터 사이에 여러 계층의 캐싱이 있습니다. 첫째, 자주 요청되는 디스크 블록을 캐시하고 디스크 쓰기를 결합하는 운영 체제의 버퍼 캐시가 있습니다. 다행히 모든 운영 체제는 응용 프로그램에 버퍼 캐시에서 디스크로의 쓰기를 강제 할 수있는 방법을 제공하며 PostgreSQL은 이러한 기능을 사용합니다. 이 방법을 조정 하려면 &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; 매개 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae2f9725af5b866105aef02d826c3c21674b82a5" translate="yes" xml:space="preserve">
          <source>While it is possible to obtain information about which processes block which other processes by joining &lt;code&gt;pg_locks&lt;/code&gt; against itself, this is very difficult to get right in detail. Such a query would have to encode knowledge about which lock modes conflict with which others. Worse, the &lt;code&gt;pg_locks&lt;/code&gt; view does not expose information about which processes are ahead of which others in lock wait queues, nor information about which processes are parallel workers running on behalf of which other client sessions. It is better to use the &lt;code&gt;pg_blocking_pids()&lt;/code&gt; function (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;Table 9.63&lt;/a&gt;) to identify which process(es) a waiting process is blocked behind.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; 를 자신과 결합하여 어떤 프로세스가 어떤 프로세스를 차단하는지에 대한 정보를 얻을 수는 있지만 ,이를 자세히 이해하기는 매우 어렵습니다. 이러한 쿼리는 어떤 잠금 모드가 다른 잠금 모드와 충돌하는지에 대한 지식을 인코딩해야합니다. 더 나쁜 것은 &lt;code&gt;pg_locks&lt;/code&gt; 뷰는 어떤 프로세스가 잠금 대기 큐에서 다른 프로세스보다 앞선 정보인지, 어떤 프로세스가 다른 클라이언트 세션을 대신하여 실행중인 병렬 작업자인지에 대한 정보를 노출시키지 않습니다. 그것은 사용하는 것이 좋습니다 &lt;code&gt;pg_blocking_pids()&lt;/code&gt; 함수 (참조 &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;표 9.63을&lt;/a&gt; 대기 프로세스가 뒤에 차단되는 과정 (들)을 식별하기 위해).</target>
        </trans-unit>
        <trans-unit id="17d114999ab92dc3c41f0deae7314e26f77d91d6" translate="yes" xml:space="preserve">
          <source>While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout.</source>
          <target state="translated">대부분의 정규 표현식 검색을 매우 빠르게 실행할 수 있지만 처리하는 데 임의의 시간과 메모리가 필요한 정규 표현식을 고려할 수 있습니다. 적대적인 소스로부터 정규식 검색 패턴을 받아들이는 것에주의하십시오. 그렇게해야하는 경우, 명령문 시간 종료를 적용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4544bbaee7531ef45a0e42c59e09a0908293364f" translate="yes" xml:space="preserve">
          <source>While most timezone abbreviations represent fixed offsets from UTC, there are some that have historically varied in value (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt; for more information). In such cases this view presents their current meaning.</source>
          <target state="translated">대부분의 시간대 약어는 UTC와의 고정 오프셋을 나타내지 만 역사적으로 값이 다른 것이 있습니다 ( 자세한 내용 은 &lt;a href=&quot;datetime-config-files&quot;&gt;섹션 B.4&lt;/a&gt; 참조 ). 이러한 경우이보기는 현재 의미를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eb000322f7d40100b6e53cb7562cee4c2935cc07" translate="yes" xml:space="preserve">
          <source>While multiple databases can be created within a single cluster, it is advised to consider carefully whether the benefits outweigh the risks and limitations. In particular, the impact that having a shared WAL (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;) has on backup and recovery options. While individual databases in the cluster are isolated when considered from the user's perspective, they are closely bound from the database administrator's point-of-view.</source>
          <target state="translated">단일 클러스터 내에서 여러 데이터베이스를 만들 수 있지만 이점이 위험과 한계를 능가하는지 신중하게 고려하는 것이 좋습니다. 특히 공유 WAL ( &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;29 장&lt;/a&gt; 참조 )이 백업 및 복구 옵션에 미치는 영향 . 클러스터의 개별 데이터베이스는 사용자 관점에서 고려할 때 격리되지만 데이터베이스 관리자의 관점과 밀접하게 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e20acb9a4d1b2d1994838c4133180e7c30312a" translate="yes" xml:space="preserve">
          <source>While not required, it is recommended that you continue to follow this old convention of naming cast implementation functions after the target data type. Many users are used to being able to cast data types using a function-style notation, that is &lt;code&gt;typename&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;). This notation is in fact nothing more nor less than a call of the cast implementation function; it is not specially treated as a cast. If your conversion functions are not named to support this convention then you will have surprised users. Since PostgreSQL allows overloading of the same function name with different argument types, there is no difficulty in having multiple conversion functions from different types that all use the target type's name.</source>
          <target state="translated">필수는 아니지만 대상 데이터 유형 뒤에이 캐스트 구현 기능의 기존 규칙을 계속 따르는 것이 좋습니다. 많은 사용자가 함수 스타일 표기법, 즉 &lt;code&gt;typename&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )을 사용하여 데이터 유형을 캐스트 할 수있었습니다 . 이 표기법은 실제로 캐스트 구현 함수의 호출에 지나지 않습니다. 특별히 캐스트로 취급되지 않습니다. 이 컨벤션을 지원하도록 변환 기능의 이름이 지정되지 않은 경우 사용자를 놀라게 할 것입니다. PostgreSQL은 인수 유형이 다른 동일한 함수 이름을 오버로드 할 수 있으므로 대상 유형의 이름을 모두 사용하는 다른 유형의 여러 변환 함수를 사용하는 데 어려움이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e3fedf4b54ce85919b4142394d398f5b611a696" translate="yes" xml:space="preserve">
          <source>While policies will be applied for explicit queries against tables in the database, they are not applied when the system is performing internal referential integrity checks or validating constraints. This means there are indirect ways to determine that a given value exists. An example of this is attempting to insert a duplicate value into a column that is a primary key or has a unique constraint. If the insert fails then the user can infer that the value already exists. (This example assumes that the user is permitted by policy to insert records which they are not allowed to see.) Another example is where a user is allowed to insert into a table which references another, otherwise hidden table. Existence can be determined by the user inserting values into the referencing table, where success would indicate that the value exists in the referenced table. These issues can be addressed by carefully crafting policies to prevent users from being able to insert, delete, or update records at all which might possibly indicate a value they are not otherwise able to see, or by using generated values (e.g., surrogate keys) instead of keys with external meanings.</source>
          <target state="translated">데이터베이스의 테이블에 대한 명시 적 쿼리에는 정책이 적용되지만 시스템이 내부 참조 무결성 검사 또는 유효성 검사 제약 조건을 수행 할 때는 적용되지 않습니다. 이는 주어진 값이 존재하는지 확인하는 간접적 인 방법이 있음을 의미합니다. 이에 대한 예로는 기본 키이거나 고유 제한 조건이있는 열에 중복 값을 삽입하려고합니다. 삽입에 실패하면 사용자는 값이 이미 존재한다고 유추 할 수 있습니다. (이 예에서는 사용자가 볼 수없는 레코드를 삽입 할 수 있도록 정책에 의해 사용자가 허용된다고 가정합니다.) 다른 예는 사용자가 다른 숨겨진 테이블을 참조하는 테이블에 사용자를 삽입 할 수있는 위치입니다. 존재 여부는 사용자가 참조 테이블에 값을 삽입하여 결정할 수 있습니다.성공은 참조 된 테이블에 값이 존재 함을 나타냅니다. 이러한 문제는 사용자가 다른 방법으로는 볼 수없는 값을 나타내거나 생성 된 값 (예 : 대리 키)을 사용하여 레코드를 삽입, 삭제 또는 업데이트 할 수 없도록 정책을 신중하게 작성하여 해결할 수 있습니다. 외부 의미를 가진 키 대신.</target>
        </trans-unit>
        <trans-unit id="5fbe4c0896d37fe14f081d1ac25be59617f075b0" translate="yes" xml:space="preserve">
          <source>While recovery is paused no further database changes are applied. If in hot standby, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="translated">복구가 일시 정지 된 동안에는 추가 데이터베이스 변경 사항이 적용되지 않습니다. 상시 대기 상태 인 경우 모든 새 쿼리는 데이터베이스의 동일한 일관된 스냅 샷을보고 복구가 다시 시작될 때까지 더 이상 쿼리 충돌이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67bee53c255823e86d8c23b4190b410627254abc" translate="yes" xml:space="preserve">
          <source>While rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">행을 로컬 파티션에서 외부 테이블 파티션으로 이동할 수 있지만 (외부 데이터 랩퍼가 튜플 라우팅을 지원하는 경우) 외부 테이블 파티션에서 다른 파티션으로 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7158e641e335f398bdfc35c274f36a1760cfa0bc" translate="yes" xml:space="preserve">
          <source>While running pg_dump, one should examine the output for any warnings (printed on standard error), especially in light of the limitations listed below.</source>
          <target state="translated">pg_dump를 실행하는 동안, 특히 아래 나열된 제한 사항에 비추어 경고 (표준 오류로 인쇄)에 대한 출력을 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="891b0584891eb2794e238a1971ed31f1c215e841" translate="yes" xml:space="preserve">
          <source>While that doesn't look all that bad by itself, it's still oversimplified. A far more complicated sub-select would be needed to select the right OID if there are multiple tables named &lt;code&gt;mytable&lt;/code&gt; in different schemas. The &lt;code&gt;regclass&lt;/code&gt; input converter handles the table lookup according to the schema path setting, and so it does the &amp;ldquo;right thing&amp;rdquo; automatically. Similarly, casting a table's OID to &lt;code&gt;regclass&lt;/code&gt; is handy for symbolic display of a numeric OID.</source>
          <target state="translated">그 자체가 그렇게 나쁘게 보이지는 않지만 여전히 지나치게 단순화되어 있습니다. 다른 스키마에 &lt;code&gt;mytable&lt;/code&gt; 이라는 여러 테이블이있는 경우 올바른 OID를 선택하려면 훨씬 더 복잡한 하위 선택이 필요 합니다. &lt;code&gt;regclass&lt;/code&gt; 형의 입력 컨버터는 스키마 경로 설정에 따라 테이블 조회를 처리하고 자동으로 &quot;옳은 일&quot;않도록. 마찬가지로 테이블의 OID를 &lt;code&gt;regclass&lt;/code&gt; 로 캐스트하는 것은 숫자 OID의 기호 표시에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="d982cd814f64616912cda4d88166e9a69d28b85b" translate="yes" xml:space="preserve">
          <source>While that particular example might seem silly, related cases that don't obviously involve constants can occur in queries executed within functions, since the values of function arguments and local variables can be inserted into queries as constants for planning purposes. Within PL/pgSQL functions, for example, using an &lt;code&gt;IF&lt;/code&gt;-&lt;code&gt;THEN&lt;/code&gt;-&lt;code&gt;ELSE&lt;/code&gt; statement to protect a risky computation is much safer than just nesting it in a &lt;code&gt;CASE&lt;/code&gt; expression.</source>
          <target state="translated">이 특정 예제는 어리석은 것처럼 보일 수 있지만 함수 인수와 로컬 변수의 값은 계획 목적을 위해 상수로 쿼리에 삽입 될 수 있으므로 함수 내에서 실행되는 쿼리에서 분명히 상수를 포함하지 않는 관련 사례가 발생할 수 있습니다. 예를 들어 PL / pgSQL 함수 내에서 &lt;code&gt;IF&lt;/code&gt; - &lt;code&gt;THEN&lt;/code&gt; - &lt;code&gt;ELSE&lt;/code&gt; 문을 사용하여 위험한 계산을 보호하는 것은 &lt;code&gt;CASE&lt;/code&gt; 표현식 에 중첩시키는 것보다 훨씬 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="cfcd6cf6959e988635a363ac7fbe48c4622cc9ea" translate="yes" xml:space="preserve">
          <source>While the built-in declarative partitioning is suitable for most common use cases, there are some circumstances where a more flexible approach may be useful. Partitioning can be implemented using table inheritance, which allows for several features not supported by declarative partitioning, such as:</source>
          <target state="translated">내장 된 선언적 파티셔닝이 가장 일반적인 사용 사례에 적합하지만보다 유연한 접근 방식이 유용한 상황이 있습니다. 테이블 상속을 사용하여 파티셔닝을 구현할 수 있으며, 다음과 같은 선언적 파티셔닝에서 지원되지 않는 몇 가지 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f761cf19de1d987297c4bdb87e576a9e8ef5e265" translate="yes" xml:space="preserve">
          <source>While the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations is retained, &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; does not order the generated rows based on this property. If you want the data to be ordered upon generation, you must use an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the backing query.</source>
          <target state="translated">향후 &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 조작에 대한 기본 색인 은 유지되지만 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; 는이 특성을 기반으로 생성 된 행을 정렬하지 않습니다. 생성시 데이터를 정렬 하려면 백업 조회에서 &lt;code&gt;ORDER BY&lt;/code&gt; 절을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="89bb80c5dc369e5a7b8dcef839df901e5b397bf5" translate="yes" xml:space="preserve">
          <source>While the details of the new type's internal representation are only known to the I/O functions and other functions you create to work with the type, there are several properties of the internal representation that must be declared to PostgreSQL. Foremost of these is &lt;code&gt;internallength&lt;/code&gt;. Base data types can be fixed-length, in which case &lt;code&gt;internallength&lt;/code&gt; is a positive integer, or variable-length, indicated by setting &lt;code&gt;internallength&lt;/code&gt; to &lt;code&gt;VARIABLE&lt;/code&gt;. (Internally, this is represented by setting &lt;code&gt;typlen&lt;/code&gt; to -1.) The internal representation of all variable-length types must start with a 4-byte integer giving the total length of this value of the type. (Note that the length field is often encoded, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;; it's unwise to access it directly.)</source>
          <target state="translated">새 유형의 내부 표현에 대한 세부 사항은 I / O 함수 및 유형에 대해 작업하기 위해 생성하는 다른 함수에만 알려져 있지만 PostgreSQL에 선언해야하는 내부 표현의 여러 속성이 있습니다. 이들 중 가장 중요한 것은 &lt;code&gt;internallength&lt;/code&gt; 입니다. 기본 데이터 유형은 고정 길이 일 수 있으며,이 경우 &lt;code&gt;internallength&lt;/code&gt; 는 양의 정수이거나 variablelength는 &lt;code&gt;internallength&lt;/code&gt; 를 &lt;code&gt;VARIABLE&lt;/code&gt; 로 설정 하여 표시됩니다 . 내부적으로는 &lt;code&gt;typlen&lt;/code&gt; 을 -1 로 설정 하여 표시됩니다 . 모든 가변 길이 유형의 내부 표현은이 유형 값의 총 길이를 제공하는 4 바이트 정수로 시작해야합니다. (길이 필드는 종종&lt;a href=&quot;storage-toast&quot;&gt;섹션 68.2&lt;/a&gt; ; 직접 액세스하는 것은 현명하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e2a6eda1b3f1244604b394ad1d7fc00d1fb05fef" translate="yes" xml:space="preserve">
          <source>While the example below uses a constant JSON value, typical use would be to reference a &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; column laterally from another table in the query's &lt;code&gt;FROM&lt;/code&gt; clause. Writing &lt;code&gt;json_populate_record&lt;/code&gt; in the &lt;code&gt;FROM&lt;/code&gt; clause is good practice, since all of the extracted columns are available for use without duplicate function calls.</source>
          <target state="translated">아래 예제에서는 상수 JSON 값을 사용하지만 일반적인 용도는 쿼리의 &lt;code&gt;FROM&lt;/code&gt; 절 에있는 다른 테이블에서 측면으로 &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt; 열 을 참조하는 것 입니다. 추출 된 모든 열을 중복 함수 호출없이 사용할 수 있으므로 &lt;code&gt;FROM&lt;/code&gt; 절에 &lt;code&gt;json_populate_record&lt;/code&gt; 를 작성 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="915068b5c9a0a4207ecd95ee0a72471b7e35a59c" translate="yes" xml:space="preserve">
          <source>While the examples for these functions use constants, the typical use would be to reference a table in the &lt;code&gt;FROM&lt;/code&gt; clause and use one of its &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; columns as an argument to the function. Extracted key values can then be referenced in other parts of the query, like &lt;code&gt;WHERE&lt;/code&gt; clauses and target lists. Extracting multiple values in this way can improve performance over extracting them separately with per-key operators.</source>
          <target state="translated">이러한 함수의 예는 상수를 사용하지만 일반적으로 &lt;code&gt;FROM&lt;/code&gt; 절 에서 테이블을 참조하고 해당 &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt; 열 중 하나를 함수의 인수로 사용합니다. 그런 다음 추출 된 키 값은 &lt;code&gt;WHERE&lt;/code&gt; 절 및 대상 목록과 같은 쿼리의 다른 부분에서 참조 될 수 있습니다 . 이러한 방식으로 여러 값을 추출하면 키별 연산자로 개별적으로 추출하는 것보다 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c45fc673d90d93e24f91fea428d0f8a94bae39e" translate="yes" xml:space="preserve">
          <source>While the input strings &lt;code&gt;now&lt;/code&gt;, &lt;code&gt;today&lt;/code&gt;, &lt;code&gt;tomorrow&lt;/code&gt;, and &lt;code&gt;yesterday&lt;/code&gt; are fine to use in interactive SQL commands, they can have surprising behavior when the command is saved to be executed later, for example in prepared statements, views, and function definitions. The string can be converted to a specific time value that continues to be used long after it becomes stale. Use one of the SQL functions instead in such contexts. For example, &lt;code&gt;CURRENT_DATE + 1&lt;/code&gt; is safer than &lt;code&gt;'tomorrow'::date&lt;/code&gt;.</source>
          <target state="translated">입력 문자열 &lt;code&gt;now&lt;/code&gt; , &lt;code&gt;today&lt;/code&gt; , &lt;code&gt;tomorrow&lt;/code&gt; 및 &lt;code&gt;yesterday&lt;/code&gt; 는 대화식 SQL 명령에서 사용하는 것이 좋지만 명령이 나중에 실행되도록 저장 될 때 (예 : 준비된 명령문,보기 및 함수 정의) 놀라운 동작을 할 수 있습니다. 문자열은 오래 된 후에도 오랫동안 계속 사용되는 특정 시간 값으로 변환 될 수 있습니다. 이러한 컨텍스트에서 대신 SQL 함수 중 하나를 사용하십시오. 예를 들어 &lt;code&gt;CURRENT_DATE + 1&lt;/code&gt; 은 &lt;code&gt;'tomorrow'::date&lt;/code&gt; 보다 안전 합니다 .</target>
        </trans-unit>
        <trans-unit id="0c09c1945f14d262f5a989a6b1b7f78a8869fb1b" translate="yes" xml:space="preserve">
          <source>While the server is running, it is not possible for a malicious user to take the place of the normal database server. However, when the server is down, it is possible for a local user to spoof the normal server by starting their own server. The spoof server could read passwords and queries sent by clients, but could not return any data because the &lt;code&gt;PGDATA&lt;/code&gt; directory would still be secure because of directory permissions. Spoofing is possible because any user can start a database server; a client cannot identify an invalid server unless it is specially configured.</source>
          <target state="translated">서버가 실행되는 동안 악의적 인 사용자가 일반 데이터베이스 서버를 대신 할 수 없습니다. 그러나 서버가 다운되면 로컬 사용자가 자신의 서버를 시작하여 일반 서버를 스푸핑 할 수 있습니다. 스푸핑 서버는 클라이언트가 보낸 비밀번호와 쿼리를 읽을 수 있지만 디렉토리 권한으로 인해 &lt;code&gt;PGDATA&lt;/code&gt; 디렉토리는 여전히 안전하므로 데이터를 반환 할 수 없습니다 . 스푸핑은 모든 사용자가 데이터베이스 서버를 시작할 수 있기 때문에 가능합니다. 클라이언트가 특별히 구성되어 있지 않으면 유효하지 않은 서버를 식별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8b90c7536148bdec5e290019a51b2379ecb8d63" translate="yes" xml:space="preserve">
          <source>While the server is running, its PID is stored in the file &lt;code&gt;postmaster.pid&lt;/code&gt; in the data directory. This is used to prevent multiple server instances from running in the same data directory and can also be used for shutting down the server.</source>
          <target state="translated">서버가 실행되는 동안 PID는 데이터 디렉토리의 &lt;code&gt;postmaster.pid&lt;/code&gt; 파일에 저장됩니다 . 이는 여러 서버 인스턴스가 동일한 데이터 디렉토리에서 실행되는 것을 방지하고 서버를 종료하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03c807444bf3594110c4d388ec7b0a59f62a431" translate="yes" xml:space="preserve">
          <source>While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes or backslashes, since each of those must be doubled. To allow more readable queries in such situations, PostgreSQL provides another way, called &amp;ldquo;dollar quoting&amp;rdquo;, to write string constants. A dollar-quoted string constant consists of a dollar sign (&lt;code&gt;$&lt;/code&gt;), an optional &amp;ldquo;tag&amp;rdquo; of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string &amp;ldquo;Dianne's horse&amp;rdquo; using dollar quoting:</source>
          <target state="translated">문자열 상수를 지정하는 표준 구문은 일반적으로 편리하지만 각 문자열을 두 배로 늘려야하므로 원하는 문자열에 작은 따옴표 나 백 슬래시가 많은 경우 이해하기 어려울 수 있습니다. 이러한 상황에서 더 읽기 쉬운 쿼리를 허용하기 위해 PostgreSQL은 &quot;달러 인용&quot;이라는 다른 방법을 사용하여 문자열 상수를 작성합니다. 달러 인용 문자열 상수는 달러 기호 ( &lt;code&gt;$&lt;/code&gt; ), 0 개 이상의 문자로 구성된 선택적 &quot;태그&quot;, 다른 달러 기호, 문자열 내용을 구성하는 임의의 문자 시퀀스, 달러 기호, 동일한 태그로 구성됩니다. 이 달러 따옴표와 달러 기호를 시작했습니다. 예를 들어, 달러 인용을 사용하여 문자열 &quot;Dianne 's horse&quot;를 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="97a03d15b6274d3b06d93b14cfe041b66ef2af72" translate="yes" xml:space="preserve">
          <source>While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed.</source>
          <target state="translated">이 기능은 한 달의 경우보다 복잡하지만 필요에 따라 분기를 추가 할 수 있으므로 자주 업데이트 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb917c6d1ba7f34837342b8b023d8fdc99add536" translate="yes" xml:space="preserve">
          <source>While this is the only way to convert character strings into XML values according to the SQL standard, the PostgreSQL-specific syntaxes:</source>
          <target state="translated">이것이 SQL 표준에 따라 문자열을 XML 값으로 변환하는 유일한 방법이지만 PostgreSQL 관련 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13b118c29b5eac33252cf8f05a41900068035eae" translate="yes" xml:space="preserve">
          <source>While transition table names for &lt;code&gt;AFTER&lt;/code&gt; triggers are specified using the &lt;code&gt;REFERENCING&lt;/code&gt; clause in the standard way, the row variables used in &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers may not be specified in a &lt;code&gt;REFERENCING&lt;/code&gt; clause. They are available in a manner that is dependent on the language in which the trigger function is written, but is fixed for any one language. Some languages effectively behave as though there is a &lt;code&gt;REFERENCING&lt;/code&gt; clause containing &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AFTER&lt;/code&gt; 트리거의 전이 테이블 이름 은 표준 방식으로 &lt;code&gt;REFERENCING&lt;/code&gt; 절을 사용하여 지정 되지만 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 트리거에 사용 된 행 변수 는 &lt;code&gt;REFERENCING&lt;/code&gt; 절에 지정되지 않을 수 있습니다 . 트리거 기능이 작성되는 언어에 따라 달라 지지만 한 언어로 고정되어 있습니다. 일부 언어는 &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt; 를 포함 하는 &lt;code&gt;REFERENCING&lt;/code&gt; 절이 있는 것처럼 효과적으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0775e3a82644839414e547fda3c53cda5989eee1" translate="yes" xml:space="preserve">
          <source>While turning off &lt;code&gt;fsync&lt;/code&gt; is often a performance benefit, this can result in unrecoverable data corruption in the event of a power failure or system crash. Thus it is only advisable to turn off &lt;code&gt;fsync&lt;/code&gt; if you can easily recreate your entire database from external data.</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; 를 끄는 것이 성능상의 이점 인 경우가 많지만 정전 또는 시스템 충돌시 데이터를 복구 할 수 없습니다. 따라서 외부 데이터에서 전체 데이터베이스를 쉽게 다시 만들 수있는 경우 에만 &lt;code&gt;fsync&lt;/code&gt; 를 끄는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5d9f7345f5e4a9cecb1d3a73e9e82a30d0080279" translate="yes" xml:space="preserve">
          <source>White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (&amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo;) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above).</source>
          <target state="translated">공백 (예 : 공백, 탭 및 개행)은 SQL 명령에서 자유롭게 사용할 수 있습니다. 즉, 명령을 위와 다르게 정렬하거나 한 줄에 모두 입력 할 수 있습니다. 두 개의 대시 (&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo;)는 주석을 소개합니다. 뒤 따르는 것은 줄 끝까지 무시됩니다. SQL은 대소 문자를 구분하기 위해 식별자가 큰 따옴표로 묶인 경우를 제외하고 키워드와 식별자에 대해 대소 문자를 구분하지 않습니다 (위에서 수행하지 않음).</target>
        </trans-unit>
        <trans-unit id="58bd91fff64a844973a8238af97e34efc8a5c324" translate="yes" xml:space="preserve">
          <source>White space is ignored on input, so &lt;code&gt;[(x),(y)]&lt;/code&gt; is the same as &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt;.</source>
          <target state="translated">공백이므로, 입력을 무시 &lt;code&gt;[(x),(y)]&lt;/code&gt; 동일하다 &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac41fe428645044123abfe95a020b4d162465d70" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed before and after the range value, but any whitespace between the parentheses or brackets is taken as part of the lower or upper bound value. (Depending on the element type, it might or might not be significant.)</source>
          <target state="translated">범위 값 전후에 공백이 허용되지만 괄호 또는 대괄호 사이의 공백은 하한 또는 상한 값의 일부로 사용됩니다. 요소 유형에 따라 중요하거나 중요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d976901748b052cce834685b15a7dd1749e3bc" translate="yes" xml:space="preserve">
          <source>Whitespace of the same width as the most recent output of &lt;code&gt;PROMPT1&lt;/code&gt;. This can be used as a &lt;code&gt;PROMPT2&lt;/code&gt; setting, so that multi-line statements are aligned with the first line, but there is no visible secondary prompt.</source>
          <target state="translated">&lt;code&gt;PROMPT1&lt;/code&gt; 의 가장 최근 출력과 동일한 너비의 공백 . &lt;code&gt;PROMPT2&lt;/code&gt; 설정 으로 사용할 수 있으므로 여러 줄 문이 첫 번째 줄과 정렬되지만 표시되는 보조 프롬프트는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cc40c3d855977fc828d35a4c20284c43f252dc0" translate="yes" xml:space="preserve">
          <source>Why would you want to use the weak mode? Well, it could be that you have a huge collection of ISBN numbers, and that there are so many of them that for weird reasons some have the wrong check digit (perhaps the numbers were scanned from a printed list and the OCR got the numbers wrong, perhaps the numbers were manually captured... who knows). Anyway, the point is you might want to clean the mess up, but you still want to be able to have all the numbers in your database and maybe use an external tool to locate the invalid numbers in the database so you can verify the information and validate it more easily; so for example you'd want to select all the invalid numbers in the table.</source>
          <target state="translated">왜 약한 모드를 사용하고 싶습니까? 글쎄, 당신은 ISBN 번호가 엄청나게 많을 수도 있고, 너무 많은 숫자가있어 이상한 이유로 일부 체크 숫자가 잘못되었을 수도 있습니다 (아마도 인쇄 된 목록에서 숫자가 스캔되고 OCR에서 숫자가 잘못되었을 수 있습니다) , 아마도 숫자는 수동으로 잡혔을 것입니다. 어쨌든 요점은 엉망을 정리하고 싶지만 데이터베이스에 모든 숫자를 가질 수 있고 외부 도구를 사용하여 데이터베이스에서 유효하지 않은 숫자를 찾아 정보를 확인할 수 있기를 원한다는 것입니다. 더 쉽게 확인하십시오. 예를 들어 테이블에서 유효하지 않은 모든 숫자를 선택하려고합니다.</target>
        </trans-unit>
        <trans-unit id="70a7ce99eb76502ad0a6210d94039f0b40c3419d" translate="yes" xml:space="preserve">
          <source>Wildcard array element accessor that returns all array elements.</source>
          <target state="translated">모든 배열 요소를 반환하는 와일드 카드 배열 요소 접근 자</target>
        </trans-unit>
        <trans-unit id="cd2106ae04d09a5386f20710a015aa4219dc3f6c" translate="yes" xml:space="preserve">
          <source>Wildcard member accessor that returns the values of all members located at the top level of the current object.</source>
          <target state="translated">현재 개체의 최상위 수준에있는 모든 멤버의 값을 반환하는 와일드 카드 멤버 접근 자</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="927627d12746803cbdee2462dc2d4d29bab17c5e" translate="yes" xml:space="preserve">
          <source>Window function (routine)</source>
          <target state="translated">창 기능 (루틴)</target>
        </trans-unit>
        <trans-unit id="01267df331f99498a90196b34760cb7aa229a46d" translate="yes" xml:space="preserve">
          <source>Window function calls are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query.</source>
          <target state="translated">창 함수 호출은 조회 의 &lt;code&gt;SELECT&lt;/code&gt; 목록 및 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c367a920e4a4ea3efbe3a1a798085a3a023e6741" translate="yes" xml:space="preserve">
          <source>Window functions are described in detail in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">윈도우 기능은 &lt;a href=&quot;tutorial-window&quot;&gt;3.5&lt;/a&gt; , &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;4.2.8&lt;/a&gt; 및 &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;7.2.5 &lt;/a&gt;섹션 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f451b621911f3a41da7c18da4aff7cdb55589c1" translate="yes" xml:space="preserve">
          <source>Window functions are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query. They are forbidden elsewhere, such as in &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.</source>
          <target state="translated">창 함수는 조회 의 &lt;code&gt;SELECT&lt;/code&gt; 목록 및 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서만 허용됩니다 . &lt;code&gt;GROUP BY&lt;/code&gt; , &lt;code&gt;HAVING&lt;/code&gt; 및 &lt;code&gt;WHERE&lt;/code&gt; 절 과 같은 다른 곳에서는 금지되어 있습니다 . 이는 해당 절을 처리 한 후에 논리적으로 실행되기 때문입니다. 또한 창 함수는 비창 합 집계 함수 후에 실행됩니다. 이것은 윈도우 함수의 인수에 집계 함수 호출을 포함하는 것이 유효하지만 그 반대의 경우는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="79e789d251d694ff69667eed3b6a1eef1b73bc73" translate="yes" xml:space="preserve">
          <source>Window: cume_dist</source>
          <target state="translated">창 : cume_dist</target>
        </trans-unit>
        <trans-unit id="1e7f6a60bbd5fd2e82c3412bbb88bea212c4bdb7" translate="yes" xml:space="preserve">
          <source>Window: dense_rank</source>
          <target state="translated">창 : dense_rank</target>
        </trans-unit>
        <trans-unit id="08d36b418003a8b9c0e9b2dd2a6f2bff70e5a8ac" translate="yes" xml:space="preserve">
          <source>Window: first_value</source>
          <target state="translated">창 : first_value</target>
        </trans-unit>
        <trans-unit id="b5f178a106cd7cba1da80bdc71ec514eea37f26d" translate="yes" xml:space="preserve">
          <source>Window: lag</source>
          <target state="translated">창 : 시차</target>
        </trans-unit>
        <trans-unit id="fabaa17e6490da4ec5451b3b47ee388b70cf91b0" translate="yes" xml:space="preserve">
          <source>Window: last_value</source>
          <target state="translated">창 : last_value</target>
        </trans-unit>
        <trans-unit id="994efd60b559fadbd405573c301089b7cf18f884" translate="yes" xml:space="preserve">
          <source>Window: lead</source>
          <target state="translated">창 : 납</target>
        </trans-unit>
        <trans-unit id="757db4a854089f2de8d98fd39c8889ef5116458d" translate="yes" xml:space="preserve">
          <source>Window: nth_value</source>
          <target state="translated">창 : nth_value</target>
        </trans-unit>
        <trans-unit id="e7f90d6e0544bf0f16ab443f5e02ee4cd6fe42bc" translate="yes" xml:space="preserve">
          <source>Window: ntile</source>
          <target state="translated">창 : 니블</target>
        </trans-unit>
        <trans-unit id="bb901cf4a6350aa408d137094086445ef7a0cf50" translate="yes" xml:space="preserve">
          <source>Window: percent_rank</source>
          <target state="translated">창 : percent_rank</target>
        </trans-unit>
        <trans-unit id="c0ecbc78e1223c489bcdc839303f81579d301dbd" translate="yes" xml:space="preserve">
          <source>Window: rank</source>
          <target state="translated">창 : 계급</target>
        </trans-unit>
        <trans-unit id="31c13454a2137d228d57d97a95bb16f2559129e2" translate="yes" xml:space="preserve">
          <source>Window: row_number</source>
          <target state="translated">창 : row_number</target>
        </trans-unit>
        <trans-unit id="afb3a4bfc7eab0371f71e7828e71cca0cb17b3c3" translate="yes" xml:space="preserve">
          <source>Windows CP1250</source>
          <target state="translated">Windows CP1250</target>
        </trans-unit>
        <trans-unit id="9a2c00b8e44a047e41a03f1caab3a7b4b6689695" translate="yes" xml:space="preserve">
          <source>Windows CP1251</source>
          <target state="translated">Windows CP1251</target>
        </trans-unit>
        <trans-unit id="ee9d69428625d1ff5f15b6e3dcde936a0fd1f094" translate="yes" xml:space="preserve">
          <source>Windows CP1252</source>
          <target state="translated">Windows CP1252</target>
        </trans-unit>
        <trans-unit id="cc78a0c32f91f66c55ae633ccbcefebb486eb07a" translate="yes" xml:space="preserve">
          <source>Windows CP1253</source>
          <target state="translated">Windows CP1253</target>
        </trans-unit>
        <trans-unit id="5f231ed423cb65bf660816b30028087f1a8e8ce5" translate="yes" xml:space="preserve">
          <source>Windows CP1254</source>
          <target state="translated">Windows CP1254</target>
        </trans-unit>
        <trans-unit id="a23b534f177679e438c10751dd8cd9af7ceda942" translate="yes" xml:space="preserve">
          <source>Windows CP1255</source>
          <target state="translated">Windows CP1255</target>
        </trans-unit>
        <trans-unit id="6790dc03b7d5b6e6f32fcb36c60e23323fb868ac" translate="yes" xml:space="preserve">
          <source>Windows CP1256</source>
          <target state="translated">Windows CP1256</target>
        </trans-unit>
        <trans-unit id="2de6d342a6a1f91fe73d1aed1c38e985a216e16e" translate="yes" xml:space="preserve">
          <source>Windows CP1257</source>
          <target state="translated">Windows CP1257</target>
        </trans-unit>
        <trans-unit id="640bb2a94fe66a43ea03427875c71fa7af756764" translate="yes" xml:space="preserve">
          <source>Windows CP1258</source>
          <target state="translated">Windows CP1258</target>
        </trans-unit>
        <trans-unit id="e95532249be79aa59a141ea1dc6d988132a7c104" translate="yes" xml:space="preserve">
          <source>Windows CP866</source>
          <target state="translated">Windows CP866</target>
        </trans-unit>
        <trans-unit id="69925dc2d1afa064badeb7131e0815ad04126da3" translate="yes" xml:space="preserve">
          <source>Windows CP874</source>
          <target state="translated">Windows CP874</target>
        </trans-unit>
        <trans-unit id="c6d589f8c6c9e727468855e6a54c0d6dfb5cce47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, pg_restore also restores the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also restored, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--create&lt;/code&gt; 를 사용하면 pg_restore는 데이터베이스의 주석 및이 데이터베이스에 특정한 구성 변수 설정, 즉 &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 및 &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; 도 복원합니다 . 이 데이터베이스를 언급하는 SET ... 명령 &lt;code&gt;--no-acl&lt;/code&gt; 을 지정 하지 않으면 데이터베이스 자체에 대한 액세스 권한도 복원 됩니다.</target>
        </trans-unit>
        <trans-unit id="8fdece12f1fb080c2dbfd8709cabeca4afb1d172" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, the output also includes the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also dumped, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--create&lt;/code&gt; 를 사용 하면 데이터베이스의 주석 및이 데이터베이스에 특정한 구성 변수 설정 (즉, &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 및 &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; 이 데이터베이스를 언급하는 SET ... 명령. &lt;code&gt;--no-acl&lt;/code&gt; 을 지정 하지 않으면 데이터베이스 자체에 대한 액세스 권한도 덤프 됩니다.</target>
        </trans-unit>
        <trans-unit id="f1abf8b357cf8a269c4c68a487360b4810c28399" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;G&lt;/code&gt; (server-side data generation), only small queries are sent from the &lt;code&gt;pgbench&lt;/code&gt; client and then data is actually generated in the server. No significant bandwidth is required for this variant, but the server will do more work. Using &lt;code&gt;G&lt;/code&gt; causes logging not to print any progress message while generating data.</source>
          <target state="translated">와 &lt;code&gt;G&lt;/code&gt; (서버 측 데이터 생성) 만 작은 쿼리로부터 전송되는 &lt;code&gt;pgbench&lt;/code&gt; 의 클라이언트 다음 데이터가 실제로 서버에 생성된다. 이 변형에는 상당한 대역폭이 필요하지 않지만 서버가 더 많은 작업을 수행합니다. &lt;code&gt;G&lt;/code&gt; 를 사용 하면 데이터를 생성하는 동안 로깅이 진행 메시지를 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc8bd1c0f7d38dd3394b226a28acc604884d1615" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;g&lt;/code&gt; (client-side data generation), data is generated in &lt;code&gt;pgbench&lt;/code&gt; client and then sent to the server. This uses the client/server bandwidth extensively through a &lt;code&gt;COPY&lt;/code&gt;. Using &lt;code&gt;g&lt;/code&gt; causes logging to print one message every 100,000 rows while generating data for the &lt;code&gt;pgbench_accounts&lt;/code&gt; table.</source>
          <target state="translated">와 &lt;code&gt;g&lt;/code&gt; (클라이언트 측 데이터 생성), 데이터가 생성된다 &lt;code&gt;pgbench&lt;/code&gt; 의 클라이언트와 그 서버에 송신. 이것은 &lt;code&gt;COPY&lt;/code&gt; 를 통해 클라이언트 / 서버 대역폭을 광범위하게 사용합니다 . &lt;code&gt;g&lt;/code&gt; 를 사용 하면 &lt;code&gt;pgbench_accounts&lt;/code&gt; 테이블에 대한 데이터를 생성하는 동안 로깅이 100,000 행마다 하나의 메시지를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="f453a9fafc8b310f8a3de3fda65ed4c38e9ca283" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1, this forces the planner to join A to B before joining them to other tables, but doesn't constrain its choices otherwise. In this example, the number of possible join orders is reduced by a factor of 5.</source>
          <target state="translated">&lt;code&gt;join_collapse_limit&lt;/code&gt; = 1을 사용 하면 플래너가 다른 테이블에 조인하기 전에 A를 B에 조인해야하지만 그렇지 않은 경우에는 선택을 제한하지 않습니다. 이 예에서는 가능한 조인 순서 수가 5 배 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="fe49ef2ae18f846d2f24144892dcb7436b22edbb" translate="yes" xml:space="preserve">
          <source>With ICU, it is not sensible to enumerate all possible locale names. ICU uses a particular naming system for locales, but there are many more ways to name a locale than there are actually distinct locales. &lt;code&gt;initdb&lt;/code&gt; uses the ICU APIs to extract a set of distinct locales to populate the initial set of collations. Collations provided by ICU are created in the SQL environment with names in BCP 47 language tag format, with a &amp;ldquo;private use&amp;rdquo; extension &lt;code&gt;-x-icu&lt;/code&gt; appended, to distinguish them from libc locales.</source>
          <target state="translated">ICU를 사용하면 가능한 모든 로캘 이름을 열거하는 것이 합리적이지 않습니다. ICU는 로케일에 특정 이름 지정 시스템을 사용하지만 실제로 구별되는 로케일보다 로케일의 이름을 지정하는 방법이 더 많습니다. &lt;code&gt;initdb&lt;/code&gt; 는 ICU API를 사용하여 고유 한 로케일 세트를 추출하여 초기 데이터 정렬 세트를 채 웁니다. ICU에서 제공하는 데이터 정렬 은 libc 로켈과 구별하기 위해 &quot;private use&quot;확장명 &lt;code&gt;-x-icu&lt;/code&gt; 가 추가 된 BCP 47 언어 태그 형식의 이름을 가진 SQL 환경에서 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0ce6e945d75c0e017cd4582a6ce07fb85c72b6" translate="yes" xml:space="preserve">
          <source>With OpenSSL</source>
          <target state="translated">OpenSSL로</target>
        </trans-unit>
        <trans-unit id="2a51bd6ec05106a3703acb2d25cff0f482de5c76" translate="yes" xml:space="preserve">
          <source>With SQL-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="translated">SQL 기반 복제 미들웨어를 사용하는 프로그램은 모든 SQL 쿼리를 가로 채서 하나 또는 모든 서버로 보냅니다. 각 서버는 독립적으로 작동합니다. 읽기-쓰기 쿼리는 모든 서버로 보내야 모든 서버가 변경 사항을받을 수 있습니다. 그러나 읽기 전용 쿼리는 하나의 서버로만 전송 될 수 있으므로 읽기 워크로드가 서버간에 분산 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fa1343fb87dfb28347c1e7e66e33ba69c59c2ca" translate="yes" xml:space="preserve">
          <source>With SSL support compiled in, the PostgreSQL server can be started with SSL enabled by setting the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The server will listen for both normal and SSL connections on the same TCP port, and will negotiate with any connecting client on whether to use SSL. By default, this is at the client's option; see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about how to set up the server to require use of SSL for some or all connections.</source>
          <target state="translated">SSL 지원이 컴파일 된 상태 에서 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; 매개 변수 를 &lt;code&gt;on&lt;/code&gt; 으로 설정하여 SSL을 사용하여 PostgreSQL 서버를 시작할 수 있습니다 . 서버는 동일한 TCP 포트에서 일반 연결과 SSL 연결을 모두 수신하고 SSL 사용 여부에 대한 연결 클라이언트와 협상합니다. 기본적으로 이것은 클라이언트의 옵션입니다. 일부 또는 모든 연결에 SSL을 사용하도록 서버를 설정하는 방법에 대해서는 &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;20.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d13ab27fd57668592221b667df2e40b0bb1e2e4" translate="yes" xml:space="preserve">
          <source>With a cluster distributed across multiple geographic locations, using different values per location brings more flexibility in the cluster management. A smaller value is useful for faster failure detection with a standby having a low-latency network connection, and a larger value helps in judging better the health of a standby if located on a remote location, with a high-latency network connection.</source>
          <target state="translated">여러 지리적 위치에 분산 된 클러스터의 경우 위치마다 다른 값을 사용하면 클러스터 관리에 유연성이 향상됩니다. 값이 작을수록 지연 시간이 짧은 네트워크 연결을 가진 대기 상태에서 오류를 빠르게 감지하는 데 유용하며 값이 클수록 대기 시간이 긴 네트워크 연결로 원격 위치에있는 경우 대기 상태를보다 잘 판단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2817eb5fe50b4283e89c69a97c63500ae24da2d7" translate="yes" xml:space="preserve">
          <source>With a parameter, turns displaying of how long each SQL statement takes on or off. Without a parameter, toggles the display between on and off. The display is in milliseconds; intervals longer than 1 second are also shown in minutes:seconds format, with hours and days fields added if needed.</source>
          <target state="translated">매개 변수를 사용하면 각 SQL 문이 얼마나 오래 걸리는지 표시합니다. 매개 변수가 없으면 디스플레이를 켜거나 끕니다. 디스플레이는 밀리 초 단위입니다. 1 초보다 긴 간격도 분 : 초 형식으로 표시되며 필요한 경우 시간 및 일 필드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="862b8683e39578b4e7d997552333b9aad19243ce" translate="yes" xml:space="preserve">
          <source>With constraint exclusion enabled, this &lt;code&gt;SELECT&lt;/code&gt; will not scan &lt;code&gt;child1000&lt;/code&gt; at all, improving performance.</source>
          <target state="translated">제약 조건 제외가 활성화되면이 &lt;code&gt;SELECT&lt;/code&gt; 는 &lt;code&gt;child1000&lt;/code&gt; 을 전혀 검색하지 않으므로 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="281288184f75c730f93254833c37347e0fc29fe4" translate="yes" xml:space="preserve">
          <source>With data warehouse type workloads, it can make sense to use a larger number of partitions than with an OLTP type workload. Generally, in data warehouses, query planning time is less of a concern as the majority of processing time is spent during query execution. With either of these two types of workload, it is important to make the right decisions early, as re-partitioning large quantities of data can be painfully slow. Simulations of the intended workload are often beneficial for optimizing the partitioning strategy. Never assume that more partitions are better than fewer partitions and vice-versa.</source>
          <target state="translated">데이터웨어 하우스 유형의 워크로드를 사용하면 OLTP 유형의 워크로드보다 많은 수의 파티션을 사용하는 것이 좋습니다. 일반적으로 데이터웨어 하우스에서 대부분의 처리 시간이 쿼리 실행 중에 소비되므로 쿼리 계획 시간은 그다지 중요하지 않습니다. 이 두 가지 유형의 워크로드 중 하나를 사용하면 대량의 데이터를 다시 파티션하는 데 어려움이있을 수 있으므로 올바른 결정을 일찍 내리는 것이 중요합니다. 의도 한 워크로드의 시뮬레이션은 파티셔닝 전략을 최적화하는 데 종종 도움이됩니다. 더 많은 파티션이 더 적은 파티션보다 낫다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3766650cc974cf1ed93fe99df3e842788c554914" translate="yes" xml:space="preserve">
          <source>With no advance preparation, the system would have to scan the entire &lt;code&gt;test1&lt;/code&gt; table, row by row, to find all matching entries. If there are many rows in &lt;code&gt;test1&lt;/code&gt; and only a few rows (perhaps zero or one) that would be returned by such a query, this is clearly an inefficient method. But if the system has been instructed to maintain an index on the &lt;code&gt;id&lt;/code&gt; column, it can use a more efficient method for locating matching rows. For instance, it might only have to walk a few levels deep into a search tree.</source>
          <target state="translated">사전 준비가 없으면 시스템은 전체 &lt;code&gt;test1&lt;/code&gt; 테이블을 한 행씩 스캔하여 일치하는 모든 항목을 찾아야합니다. &lt;code&gt;test1&lt;/code&gt; 에 많은 행 이 있고 그러한 쿼리에 의해 반환되는 몇 개의 행 (아마도 0 또는 1 개) 만있는 경우 이는 분명히 비효율적 인 방법입니다. 그러나 시스템이 &lt;code&gt;id&lt;/code&gt; 열에서 색인을 유지하도록 지시받은 경우 일치하는 행을 찾는 데 더 효율적인 방법을 사용할 수 있습니다. 예를 들어, 검색 트리에 몇 단계 깊숙히 들어가야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d718f6eccff45185b0a45095de6fde081eea1bba" translate="yes" xml:space="preserve">
          <source>With no argument, escapes to a sub-shell; psql resumes when the sub-shell exits. With an argument, executes the shell command &lt;code&gt;command&lt;/code&gt;.</source>
          <target state="translated">논증없이, 서브 쉘로 탈출합니다. 서브 쉘이 종료되면 psql이 재개됩니다. 인수로 쉘 명령 &lt;code&gt;command&lt;/code&gt; 를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="9514950fe011b56b473f75097880ade2b163bceb" translate="yes" xml:space="preserve">
          <source>With statement-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="translated">명령문 기반 복제 미들웨어를 사용하면 프로그램이 모든 SQL 쿼리를 가로 채서 하나 또는 모든 서버로 보냅니다. 각 서버는 독립적으로 작동합니다. 모든 서버가 변경 사항을 수신 할 수 있도록 읽기 / 쓰기 쿼리를 모든 서버로 보내야합니다. 그러나 읽기 전용 쿼리는 단 하나의 서버로 전송 될 수 있으므로 읽기 작업 부하가 서버간에 분산 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4094d09ba0d0f0a9849aa3ea46bb7d77a767e980" translate="yes" xml:space="preserve">
          <source>With synchronous replication options specified at the application level (on the primary) we can offer synchronous replication for the most important changes, without slowing down the bulk of the total workload. Application level options are an important and practical tool for allowing the benefits of synchronous replication for high performance applications.</source>
          <target state="translated">애플리케이션 수준 (기본)에 지정된 동기식 복제 옵션을 사용하면 전체 워크로드를 크게 줄이지 않고도 가장 중요한 변경 사항에 대한 동기식 복제를 제공 할 수 있습니다. 응용 프로그램 수준 옵션은 고성능 응용 프로그램에 대한 동기 복제의 이점을 허용하는 중요하고 실용적인 도구입니다.</target>
        </trans-unit>
        <trans-unit id="e625f82083935e0517f3c7cf1a804070d41f41f5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--aggregate-interval&lt;/code&gt; option, a different format is used for the log files:</source>
          <target state="translated">으로 &lt;code&gt;--aggregate-interval&lt;/code&gt; 옵션, 다른 형식 로그 파일에 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="21c13395c6ff50aca429bd803e2b410319037881" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-l&lt;/code&gt; option (but without the &lt;code&gt;--aggregate-interval&lt;/code&gt; option), pgbench writes information about each transaction to a log file. The log file will be named &lt;code&gt;prefix.nnn&lt;/code&gt;, where &lt;code&gt;prefix&lt;/code&gt; defaults to &lt;code&gt;pgbench_log&lt;/code&gt;, and &lt;code&gt;nnn&lt;/code&gt; is the PID of the pgbench process. The prefix can be changed by using the &lt;code&gt;--log-prefix&lt;/code&gt; option. If the &lt;code&gt;-j&lt;/code&gt; option is 2 or higher, so that there are multiple worker threads, each will have its own log file. The first worker will use the same name for its log file as in the standard single worker case. The additional log files for the other workers will be named &lt;code&gt;prefix.nnn.mmm&lt;/code&gt;, where &lt;code&gt;mmm&lt;/code&gt; is a sequential number for each worker starting with 1.</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; 옵션을 사용하면 ( &lt;code&gt;--aggregate-interval&lt;/code&gt; 옵션 제외) pgbench는 각 트랜잭션에 대한 정보를 로그 파일에 기록합니다. 로그 파일의 이름은 &lt;code&gt;prefix.nnn&lt;/code&gt; 이며 &lt;code&gt;prefix&lt;/code&gt; 기본값은 &lt;code&gt;pgbench_log&lt;/code&gt; 이며 &lt;code&gt;nnn&lt;/code&gt; 은 pgbench 프로세스의 PID입니다. &lt;code&gt;--log-prefix&lt;/code&gt; 옵션 을 사용하여 접두사를 변경할 수 있습니다 . 경우 &lt;code&gt;-j&lt;/code&gt; 옵션은 2 이상이고, 여러 작업자 스레드가 그래서, 각각 자신의 로그 파일이있을 것이다. 첫 번째 작업자는 표준 단일 작업자 사례와 동일한 이름의 로그 파일을 사용합니다. 다른 작업자의 추가 로그 파일 이름은 &lt;code&gt;prefix.nnn.mmm&lt;/code&gt; 이며 여기서 &lt;code&gt;mmm&lt;/code&gt; 은 1부터 시작하는 각 작업자의 순차적 번호입니다.</target>
        </trans-unit>
        <trans-unit id="dea12aa8ce2a4f9481a6f03ad5ce52c7d1882b2a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-r&lt;/code&gt; option, pgbench collects the elapsed transaction time of each statement executed by every client. It then reports an average of those values, referred to as the latency for each statement, after the benchmark has finished.</source>
          <target state="translated">&lt;code&gt;-r&lt;/code&gt; 옵션을 사용하면 pgbench는 모든 클라이언트가 실행 한 각 명령문의 경과 된 트랜잭션 시간을 수집합니다. 그런 다음 벤치 마크가 완료된 후 각 명령문의 대기 시간이라고하는 해당 값의 평균을보고합니다.</target>
        </trans-unit>
        <trans-unit id="b0d0adcb9fc8fc9dddac0cfadc06d179ba840172" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;, it is only useful to place a &lt;code&gt;simple&lt;/code&gt; dictionary at the end of a list of dictionaries, since it will never pass on any token to a following dictionary. Conversely, &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; is only useful when there is at least one following dictionary.</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; 의 기본 설정 을 사용하면 다음 사전에 토큰을 전달하지 않으므로 사전 목록의 끝에 &lt;code&gt;simple&lt;/code&gt; 사전 을 배치하는 것만 유용합니다 . 반대로 &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 는 다음 사전이 하나 이상있을 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1679a02524be37201556be412a6d701fa1ad4ae3" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="translated">지금까지 설명한 도구를 사용하면 완전한 기능의 테이블을 만들 수 있습니다. 이 장의 나머지 부분에서는 데이터 무결성, 보안 또는 편의를 보장하기 위해 테이블 ​​정의에 기능을 추가하는 방법에 대해 설명합니다. 이제 데이터로 테이블을 채우고 싶다면 &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;6 장으로&lt;/a&gt; 건너 뛰고이 장의 나머지 부분을 나중에 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="65bded40379a6ac67a03a08a9d131c48acd1a16a" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="translated">지금까지 설명한 도구를 사용하여 완전한 기능의 테이블을 만들 수 있습니다. 이 장의 나머지 부분에서는 데이터 무결성, 보안 또는 편의성을 보장하기 위해 테이블 ​​정의에 기능을 추가하는 것과 관련됩니다. 지금 데이터로 테이블을 채우고 싶다면 &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;6 장으로&lt;/a&gt; 건너 뛰고이 장의 나머지 부분을 나중에 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37674f638cca87d9f8a3c6dc8d132c3743ff6b7c" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g. &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="translated">이 매개 변수를 사용하면 여전히 일반 글로벌 사용자를 작성할 수 있습니다. 클라이언트에서 사용자 이름을 지정할 때 간단히 &lt;code&gt;@&lt;/code&gt; 를 추가하십시오 ( 예 : &lt;code&gt;joe@&lt;/code&gt; . &lt;code&gt;@&lt;/code&gt; 는 사용자 이름이 서버에 의해보고되기 전에 벗겨됩니다.</target>
        </trans-unit>
        <trans-unit id="5c255d5e2ff800e00e81014aac8b22d43990196d" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g., &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="translated">이 매개 변수를 활성화해도 일반 글로벌 사용자를 생성 할 수 있습니다. 클라이언트에서 사용자 이름을 지정할 때 &lt;code&gt;@&lt;/code&gt; 를 추가하기 만하면 됩니다 (예 : &lt;code&gt;joe@&lt;/code&gt; . &lt;code&gt;@&lt;/code&gt; 는 사용자 이름이 서버에 의해보고되기 전에 벗겨됩니다.</target>
        </trans-unit>
        <trans-unit id="de39e9b44ca28bac2cf5d078925f7311c5e84abb" translate="yes" xml:space="preserve">
          <source>With this preparation, a backup can be taken using a script like the following:</source>
          <target state="translated">이 준비를 통해 다음과 같은 스크립트를 사용하여 백업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d93925105d3192c92e0036610fccacd28a3de6" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;, the special table names &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt; can be used to refer to values in the referenced table. &lt;code&gt;NEW&lt;/code&gt; is valid in &lt;code&gt;ON INSERT&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; rules to refer to the new row being inserted or updated. &lt;code&gt;OLD&lt;/code&gt; is valid in &lt;code&gt;ON UPDATE&lt;/code&gt; and &lt;code&gt;ON DELETE&lt;/code&gt; rules to refer to the existing row being updated or deleted.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 및 &lt;code&gt;command&lt;/code&gt; 내 에서 특수 테이블 이름 &lt;code&gt;NEW&lt;/code&gt; 및 &lt;code&gt;OLD&lt;/code&gt; 를 사용하여 참조 된 테이블의 값을 참조 할 수 있습니다. &lt;code&gt;NEW&lt;/code&gt; 는 삽입 또는 업데이트되는 새 행을 참조하기 위해 &lt;code&gt;ON INSERT&lt;/code&gt; 및 &lt;code&gt;ON UPDATE&lt;/code&gt; 규칙 에서 유효합니다 . &lt;code&gt;OLD&lt;/code&gt; 는 업데이트 또는 삭제중인 기존 행을 참조하기 위해 &lt;code&gt;ON UPDATE&lt;/code&gt; 및 &lt;code&gt;ON DELETE&lt;/code&gt; 규칙 에서 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="b7c7983937789ea59f666ccaa3b6dc10f18e4489" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;tsquery&lt;/code&gt;, the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) operator specifies that both its arguments must appear in the document to have a match. Similarly, the &lt;code&gt;|&lt;/code&gt; (OR) operator specifies that at least one of its arguments must appear, while the &lt;code&gt;!&lt;/code&gt; (NOT) operator specifies that its argument must &lt;em&gt;not&lt;/em&gt; appear in order to have a match. For example, the query &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; matches documents that contain &lt;code&gt;fat&lt;/code&gt; but not &lt;code&gt;rat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 내 에서 &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) 연산자는 두 인수가 모두 일치하도록 문서에 나타나도록 지정합니다. 마찬가지로 &lt;code&gt;|&lt;/code&gt; (OR) 연산자는 적어도 하나의 인수가 나타나도록 지정하고 &lt;code&gt;!&lt;/code&gt; (NOT) 인수가 있어야 운영자를 지정 &lt;em&gt;하지&lt;/em&gt; 일치를 위해 표시를. 예를 들어, 쿼리 &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; 는 &lt;code&gt;fat&lt;/code&gt; 은 포함 하지만 &lt;code&gt;rat&lt;/code&gt; 는 포함 하지 않은 문서와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="f2368cc4cb5a919d014b1e03cda4cf0d9819b781" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a &lt;code&gt;ch&lt;/code&gt; collating element, then the RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; matches the first five characters of &lt;code&gt;chchcc&lt;/code&gt;.</source>
          <target state="translated">대괄호 표현식 내에서 조합 요소 (문자, 단일 문자 인 것처럼 조합하는 다중 문자 시퀀스 또는 둘 중 하나의 조합 순서 이름)는 &lt;code&gt;[.&lt;/code&gt; 와 &lt;code&gt;.]&lt;/code&gt; 그 조합 요소의 문자 순서를 의미합니다. 시퀀스는 대괄호 표현식 목록의 단일 요소로 취급됩니다. 이렇게하면 여러 문자 조합 요소를 포함하는 대괄호 표현식이 둘 이상의 문자와 일치 할 수 있습니다. 예를 들어 조합 순서에 &lt;code&gt;ch&lt;/code&gt; 조합 요소가 포함 된 경우 RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; 는 &lt;code&gt;chchcc&lt;/code&gt; 의 처음 다섯 문자와 일치합니다. .</target>
        </trans-unit>
        <trans-unit id="5e1fe750b2061555e551fa7ddfd0d60d1ac81517" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element enclosed in &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; is an &lt;em&gt;equivalence class&lt;/em&gt;, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt;.) For example, if &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt; are the members of an equivalence class, then &lt;code&gt;[[=o=]]&lt;/code&gt;, &lt;code&gt;[[=^=]]&lt;/code&gt;, and &lt;code&gt;[o^]&lt;/code&gt; are all synonymous. An equivalence class cannot be an endpoint of a range.</source>
          <target state="translated">대괄호 표현식 내에서 &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; 로 묶인 조합 요소 는 &lt;em&gt;등가 클래스&lt;/em&gt; 이며, 그 자체를 포함하여 해당 조합 요소와 동등한 모든 조합 요소의 문자 시퀀스를 나타냅니다. (등가 배열 요소가없는 경우 처리는 둘러싸는 분리 문자가 &lt;code&gt;[.&lt;/code&gt; 및 &lt;code&gt;.]&lt;/code&gt; 인 것처럼 처리됩니다 .) 예를 들어 &lt;code&gt;o&lt;/code&gt; 와 &lt;code&gt;^&lt;/code&gt; 가 동등성 클래스의 구성원 인 경우 &lt;code&gt;[[=o=]]&lt;/code&gt; , &lt;code&gt;[[=^=]]&lt;/code&gt; 및 &lt;code&gt;[o^]&lt;/code&gt; 는 모두 동의어입니다. 동등성 클래스는 범위의 끝 점이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="abb82d076f25a7be9aee0f56365d178b74a1a2ff" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, the name of a character class enclosed in &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; stands for the list of all characters belonging to that class. A character class cannot be used as an endpoint of a range. The POSIX standard defines these character class names: &lt;code&gt;alnum&lt;/code&gt; (letters and numeric digits), &lt;code&gt;alpha&lt;/code&gt; (letters), &lt;code&gt;blank&lt;/code&gt; (space and tab), &lt;code&gt;cntrl&lt;/code&gt; (control characters), &lt;code&gt;digit&lt;/code&gt; (numeric digits), &lt;code&gt;graph&lt;/code&gt; (printable characters except space), &lt;code&gt;lower&lt;/code&gt; (lower-case letters), &lt;code&gt;print&lt;/code&gt; (printable characters including space), &lt;code&gt;punct&lt;/code&gt; (punctuation), &lt;code&gt;space&lt;/code&gt; (any white space), &lt;code&gt;upper&lt;/code&gt; (upper-case letters), and &lt;code&gt;xdigit&lt;/code&gt; (hexadecimal digits). The behavior of these standard character classes is generally consistent across platforms for characters in the 7-bit ASCII set. Whether a given non-ASCII character is considered to belong to one of these classes depends on the &lt;em&gt;collation&lt;/em&gt; that is used for the regular-expression function or operator (see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;), or by default on the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting (see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;). The classification of non-ASCII characters can vary across platforms even in similarly-named locales. (But the &lt;code&gt;C&lt;/code&gt; locale never considers any non-ASCII characters to belong to any of these classes.) In addition to these standard character classes, PostgreSQL defines the &lt;code&gt;ascii&lt;/code&gt; character class, which contains exactly the 7-bit ASCII set.</source>
          <target state="translated">대괄호 표현식 내에서 &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; 로 묶인 문자 클래스의 이름은 해당 클래스에 속하는 모든 문자 목록을 나타냅니다. 문자 클래스는 범위의 끝점으로 사용할 수 없습니다. POSIX 표준은 다음과 같은 문자 클래스 이름을 정의합니다. &lt;code&gt;alnum&lt;/code&gt; (문자 및 숫자), &lt;code&gt;alpha&lt;/code&gt; (문자), &lt;code&gt;blank&lt;/code&gt; (공백 및 탭), &lt;code&gt;cntrl&lt;/code&gt; (제어 문자), &lt;code&gt;digit&lt;/code&gt; (숫자), &lt;code&gt;graph&lt;/code&gt; (공백을 제외한 문자), &lt;code&gt;lower&lt;/code&gt; (소문자), &lt;code&gt;print&lt;/code&gt; (공백을 포함하여 인쇄 가능한 문자), &lt;code&gt;punct&lt;/code&gt; (문장), &lt;code&gt;space&lt;/code&gt; (공백), &lt;code&gt;upper&lt;/code&gt; (대문자) 및 &lt;code&gt;xdigit&lt;/code&gt; (16 진수). 이러한 표준 문자 클래스의 동작은 일반적으로 7 비트 ASCII 세트의 문자에 대해 플랫폼간에 일관됩니다. 주어진 비 ASCII 문자가 이러한 클래스 중 하나에 속하는 것으로 간주되는지 여부는 정규식 함수 또는 연산자에 사용되는 &lt;em&gt;데이터 정렬&lt;/em&gt; ( &lt;a href=&quot;collation&quot;&gt;섹션 23.2&lt;/a&gt; 참조 ) 또는 기본적으로 데이터베이스의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로캘 설정 ( &lt;a href=&quot;locale&quot;&gt;섹션 23.1&lt;/a&gt; 참조 ) 에 따라 다릅니다. ). 비 ASCII 문자의 분류는 비슷한 이름의 로케일에서도 플랫폼마다 다를 수 있습니다. (그러나 &lt;code&gt;C&lt;/code&gt; locale은 ASCII가 아닌 문자가 이러한 클래스에 속하는 것으로 간주하지 않습니다.) 이러한 표준 문자 클래스 외에도 PostgreSQL은 정확히 7 비트 ASCII 세트를 포함 하는 &lt;code&gt;ascii&lt;/code&gt; 문자 클래스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d35bef27a0203dd6547cf96a8cb6d957c5595d5c" translate="yes" xml:space="preserve">
          <source>Within a pattern, &lt;code&gt;*&lt;/code&gt; matches any sequence of characters (including no characters) and &lt;code&gt;?&lt;/code&gt; matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, &lt;code&gt;\dt int*&lt;/code&gt; displays tables whose names begin with &lt;code&gt;int&lt;/code&gt;. But within double quotes, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; lose these special meanings and are just matched literally.</source>
          <target state="translated">패턴 내에서 &lt;code&gt;*&lt;/code&gt; 는 모든 문자 시퀀스 (문자 제외)와 일치하고 &lt;code&gt;?&lt;/code&gt; 단일 문자와 일치합니다. (이 표기법은 Unix 쉘 파일 이름 패턴과 비슷합니다.) 예를 들어, &lt;code&gt;\dt int*&lt;/code&gt; 는 이름이 &lt;code&gt;int&lt;/code&gt; 로 시작하는 테이블을 표시합니다 . 그러나 큰 따옴표 안에 &lt;code&gt;*&lt;/code&gt; 와 &lt;code&gt;?&lt;/code&gt; 이 특별한 의미를 잃어 버리고 문자 그대로 일치합니다</target>
        </trans-unit>
        <trans-unit id="323b9b12ce6cec030c2782c77172b386cffa6487" translate="yes" xml:space="preserve">
          <source>Within an argument, text that is enclosed in backquotes (&lt;code&gt;`&lt;/code&gt;) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. Within the text enclosed in backquotes, no special quoting or other processing occurs, except that appearances of &lt;code&gt;:variable_name&lt;/code&gt; where &lt;code&gt;variable_name&lt;/code&gt; is a psql variable name are replaced by the variable's value. Also, appearances of &lt;code&gt;:'variable_name'&lt;/code&gt; are replaced by the variable's value suitably quoted to become a single shell command argument. (The latter form is almost always preferable, unless you are very sure of what is in the variable.) Because carriage return and line feed characters cannot be safely quoted on all platforms, the &lt;code&gt;:'variable_name'&lt;/code&gt; form prints an error message and does not substitute the variable value when such characters appear in the value.</source>
          <target state="translated">인수 내에서 큰 따옴표 ( &lt;code&gt;`&lt;/code&gt; )로 묶인 텍스트 는 셸에 전달되는 명령 줄로 사용됩니다. 명령의 출력 (후행 줄 바꿈이 제거 된)은 인용 된 텍스트를 대체합니다. 백 따옴표로 묶인 텍스트 내에서 &lt;code&gt;:variable_name&lt;/code&gt; 의 모양 ( 여기서 &lt;code&gt;variable_name&lt;/code&gt; 은 psql 변수 이름 임) 이 변수 값으로 대체 된다는 점을 제외하고는 특별한 인용 또는 기타 처리가 발생하지 않습니다 . 또한 &lt;code&gt;:'variable_name'&lt;/code&gt; 의 모양단일 쉘 명령 인수가되도록 적절하게 인용 된 변수 값으로 대체됩니다. (변수에 무엇이 있는지 확실하지 않으면 후자의 형식이 거의 항상 선호됩니다.) 캐리지 리턴 및 줄 바꿈 문자를 모든 플랫폼에서 안전하게 인용 할 수 없으므로 &lt;code&gt;:'variable_name'&lt;/code&gt; 형식은 오류 메시지를 인쇄하지만 그렇지 않습니다. 이러한 문자가 값에 나타나면 변수 값을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="02446a7929ab10f300f87f18642a172ae6a7fbfe" translate="yes" xml:space="preserve">
          <source>Within any particular database, only collations that use that database's encoding are of interest. Other entries in &lt;code&gt;pg_collation&lt;/code&gt; are ignored. Thus, a stripped collation name such as &lt;code&gt;de_DE&lt;/code&gt; can be considered unique within a given database even though it would not be unique globally. Use of the stripped collation names is recommended, since it will make one less thing you need to change if you decide to change to another database encoding. Note however that the &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; collations can be used regardless of the database encoding.</source>
          <target state="translated">특정 데이터베이스 내에서 해당 데이터베이스의 인코딩을 사용하는 데이터 정렬 만 관심 대상입니다. &lt;code&gt;pg_collation&lt;/code&gt; 의 다른 항목 은 무시됩니다. 따라서 &lt;code&gt;de_DE&lt;/code&gt; 와 같은 제거 된 조합 이름 은 전체적으로 고유하지 않더라도 주어진 데이터베이스 내에서 고유 한 것으로 간주 될 수 있습니다. 제거 된 데이터 정렬 이름을 사용하는 것이 좋습니다. 다른 데이터베이스 인코딩으로 변경하기로 결정한 경우 변경해야 할 사항이 더 적기 때문입니다. 그러나 데이터베이스 인코딩에 관계없이 &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;POSIX&lt;/code&gt; 데이터 정렬을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a80b578691f1b5a7af0065fe86a5cb4aa2ce86a" translate="yes" xml:space="preserve">
          <source>Within bracket expressions, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; lose their outer brackets, and &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt; are illegal. (So, for example, &lt;code&gt;[a-c\d]&lt;/code&gt; is equivalent to &lt;code&gt;[a-c[:digit:]]&lt;/code&gt;. Also, &lt;code&gt;[a-c\D]&lt;/code&gt;, which is equivalent to &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt;, is illegal.)</source>
          <target state="translated">대괄호 표현식 내에서 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 는 외부 대괄호를 잃어 버리고 &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; 및 &lt;code&gt;\W&lt;/code&gt; 는 불법입니다. (예를 들어 &lt;code&gt;[a-c\d]&lt;/code&gt; 는 &lt;code&gt;[a-c[:digit:]]&lt;/code&gt; 와 동일합니다 . 또한 &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt; 와 동일한 &lt;code&gt;[a-c\D]&lt;/code&gt; 는 불법입니다.)</target>
        </trans-unit>
        <trans-unit id="2542957abf2f09b64545fb48b800de1036c8c62f" translate="yes" xml:space="preserve">
          <source>Within each FSM page is a binary tree, stored in an array with one byte per node. Each leaf node represents a heap page, or a lower level FSM page. In each non-leaf node, the higher of its children's values is stored. The maximum value in the leaf nodes is therefore stored at the root.</source>
          <target state="translated">각 FSM 페이지에는 이진 트리가 있으며 노드 당 1 바이트로 배열에 저장됩니다. 각 리프 노드는 힙 페이지 또는 하위 레벨 FSM 페이지를 나타냅니다. 각 비 리프 노드에는 하위 값 중 높은 값이 저장됩니다. 따라서 리프 노드의 최대 값은 루트에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="eb8d6e1ae92682e55948b9d998dc41d07bd4d9ee" translate="yes" xml:space="preserve">
          <source>Within each catalog row, write comma-separated &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The allowed &lt;code&gt;key&lt;/code&gt;s are the names of the catalog's columns, plus the metadata keys &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt;. (The use of &lt;code&gt;oid&lt;/code&gt; and &lt;code&gt;oid_symbol&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;Section 69.2.2&lt;/a&gt; below, while &lt;code&gt;array_type_oid&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;Section 69.2.4&lt;/a&gt;. &lt;code&gt;descr&lt;/code&gt; supplies a description string for the object, which will be inserted into &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_shdescription&lt;/code&gt; as appropriate.) While the metadata keys are optional, the catalog's defined columns must all be provided, except when the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for the column. (In the example above, the &lt;code&gt;datdba&lt;/code&gt; field has been omitted because &lt;code&gt;pg_database.h&lt;/code&gt; supplies a suitable default value for it.)</source>
          <target state="translated">각 카탈로그 행 내에 쉼표로 구분 된 &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 쌍을 작성하십시오. 허용되는 &lt;code&gt;key&lt;/code&gt; 는 카탈로그 열의 이름과 메타 데이터 키 &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;oid_symbol&lt;/code&gt; , &lt;code&gt;array_type_oid&lt;/code&gt; 및 &lt;code&gt;descr&lt;/code&gt; 입니다. ( &lt;code&gt;oid&lt;/code&gt; 와 &lt;code&gt;oid_symbol&lt;/code&gt; 의 사용법 은 아래 &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;69.2.2 절에&lt;/a&gt; 설명되어 있으며, &lt;code&gt;array_type_oid&lt;/code&gt; 는 &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;69.2.4 절에&lt;/a&gt; 설명되어 있습니다. &lt;code&gt;descr&lt;/code&gt; 은 &lt;code&gt;pg_description&lt;/code&gt; 또는 &lt;code&gt;pg_shdescription&lt;/code&gt; 에 삽입 될 객체에 대한 설명 문자열을 제공합니다 .메타 데이터 키는 선택 사항이지만 카탈로그의 &lt;code&gt;.h&lt;/code&gt; 파일이 열의 기본값을 지정하는 경우를 제외하고 카탈로그의 정의 된 열을 모두 제공해야합니다 . (위의 예에서 &lt;code&gt;datdba&lt;/code&gt; 가 적절한 기본값을 제공 하기 때문에 &lt;code&gt;pg_database.h&lt;/code&gt; 필드는 생략되었습니다 .)</target>
        </trans-unit>
        <trans-unit id="3b70f85093aa93c4bd37783889d55ab04e575f61" translate="yes" xml:space="preserve">
          <source>Within each pair of curly braces, the metadata fields &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt; (if present) come first, in that order, then the catalog's own fields appear in their defined order.</source>
          <target state="translated">각 중괄호 쌍 내에서 메타 데이터 필드 &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;oid_symbol&lt;/code&gt; , &lt;code&gt;array_type_oid&lt;/code&gt; 및 &lt;code&gt;descr&lt;/code&gt; (있는 경우) 이이 순서대로 먼저 나온 다음 카탈로그의 자체 필드가 ​​정의 된 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7877c1484b515b178eb13d5365bc7aee43c3498f" translate="yes" xml:space="preserve">
          <source>Within larger commands, &lt;code&gt;VALUES&lt;/code&gt; is syntactically allowed anywhere that &lt;code&gt;SELECT&lt;/code&gt; is. Because it is treated like a &lt;code&gt;SELECT&lt;/code&gt; by the grammar, it is possible to use the &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt; (or equivalently &lt;code&gt;FETCH FIRST&lt;/code&gt;), and &lt;code&gt;OFFSET&lt;/code&gt; clauses with a &lt;code&gt;VALUES&lt;/code&gt; command.</source>
          <target state="translated">더 큰 명령 내에서 &lt;code&gt;VALUES&lt;/code&gt; 는 &lt;code&gt;SELECT&lt;/code&gt; 가있는 모든 위치에서 구문 적으로 허용 됩니다. 문법 으로 &lt;code&gt;SELECT&lt;/code&gt; 처럼 취급되므로 &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; (또는 &lt;code&gt;FETCH FIRST&lt;/code&gt; ) 및 &lt;code&gt;OFFSET&lt;/code&gt; 절을 &lt;code&gt;VALUES&lt;/code&gt; 명령 과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b2c20b975865db54e88c092240735063656bf9" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;ANALYZE&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to analyze. With a list, &lt;code&gt;ANALYZE&lt;/code&gt; processes only those table(s). It is further possible to give a list of column names for a table, in which case only the statistics for those columns are collected.</source>
          <target state="translated">&lt;code&gt;table_and_columns&lt;/code&gt; 목록이 없으면 &lt;code&gt;ANALYZE&lt;/code&gt; 는 현재 사용자가 분석 할 권한이있는 현재 데이터베이스의 모든 테이블 및 구체화 된보기를 처리합니다. &lt;code&gt;ANALYZE&lt;/code&gt; 는 목록을 사용하여 해당 테이블 만 처리합니다. 테이블에 대한 열 이름 목록을 제공 할 수도 있으며,이 경우 해당 열에 대한 통계 만 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd2342b55fa6fe36f0fd7dea1e8abcfbe35286d" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;VACUUM&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to vacuum. With a list, &lt;code&gt;VACUUM&lt;/code&gt; processes only those table(s).</source>
          <target state="translated">&lt;code&gt;table_and_columns&lt;/code&gt; 목록이 없으면 &lt;code&gt;VACUUM&lt;/code&gt; 은 현재 사용자가 진공 권한을 가지고있는 현재 데이터베이스의 모든 테이블 및 구체화 된보기를 처리합니다. &lt;code&gt;VACUUM&lt;/code&gt; 은 목록을 사용하여 해당 테이블 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2564642da39c57e6f0da0af32cec7b221b00e6cf" translate="yes" xml:space="preserve">
          <source>Without a qualification, &lt;code&gt;DELETE&lt;/code&gt; will remove &lt;em&gt;all&lt;/em&gt; rows from the given table, leaving it empty. The system will not request confirmation before doing this!</source>
          <target state="translated">규정이 없으면 &lt;code&gt;DELETE&lt;/code&gt; 는 주어진 테이블에서 &lt;em&gt;모든&lt;/em&gt; 행을 제거 하고 비워 둡니다. 시스템은이를 수행하기 전에 확인을 요청하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="63fcdcc5d8356bd3ccce31a7a0f56d4a3af85303" translate="yes" xml:space="preserve">
          <source>Without functional-dependency statistics, the planner would assume that the two &lt;code&gt;WHERE&lt;/code&gt; conditions are independent, and would multiply their selectivities together to arrive at a much-too-small row count estimate. With such statistics, the planner recognizes that the &lt;code&gt;WHERE&lt;/code&gt; conditions are redundant and does not underestimate the row count.</source>
          <target state="translated">기능적 의존성 통계가 없으면, 계획자는 두 &lt;code&gt;WHERE&lt;/code&gt; 조건이 독립적 이라고 가정 하고 선택성을 곱하여 너무 작은 행 수 추정치에 도달합니다. 이러한 통계를 통해 플래너는 &lt;code&gt;WHERE&lt;/code&gt; 조건이 중복되고 행 수를 과소 평가하지 않음을 인식합니다 .</target>
        </trans-unit>
        <trans-unit id="dc783547ace7f2e9e22e7b50a67f3d97784d6474" translate="yes" xml:space="preserve">
          <source>Without partition pruning, the above query would scan each of the partitions of the &lt;code&gt;measurement&lt;/code&gt; table. With partition pruning enabled, the planner will examine the definition of each partition and prove that the partition need not be scanned because it could not contain any rows meeting the query's &lt;code&gt;WHERE&lt;/code&gt; clause. When the planner can prove this, it excludes (&lt;em&gt;prunes&lt;/em&gt;) the partition from the query plan.</source>
          <target state="translated">파티션 프 루닝이 없으면 위의 쿼리는 &lt;code&gt;measurement&lt;/code&gt; 테이블 의 각 파티션을 스캔 합니다. 파티션 정리를 사용하면 플래너는 각 파티션의 정의를 검사하고 쿼리의 &lt;code&gt;WHERE&lt;/code&gt; 절을 충족하는 행을 포함 할 수 없으므로 파티션을 스캔 할 필요가 없음을 증명합니다 . 플래너는 이것을 증명할 수있는 때 (제외 &lt;em&gt;자두&lt;/em&gt; ) 쿼리 계획에서 파티션을.</target>
        </trans-unit>
        <trans-unit id="23034486b72d6e700160ee9f0facdf636985eee4" translate="yes" xml:space="preserve">
          <source>Without quotes, &lt;code&gt;to_tsquery&lt;/code&gt; will generate a syntax error for tokens that are not separated by an AND, OR, or FOLLOWED BY operator.</source>
          <target state="translated">따옴표가 없으면 &lt;code&gt;to_tsquery&lt;/code&gt; 는 AND, OR 또는 FOLLOWED BY 연산자로 구분되지 않은 토큰에 대해 구문 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8d1c012acaa571247fa7393ff98695c754cfacba" translate="yes" xml:space="preserve">
          <source>Without the extra parentheses, this will generate a syntax error.</source>
          <target state="translated">추가 괄호가 없으면 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3003268a98f289ec381313920f30367739bc175f" translate="yes" xml:space="preserve">
          <source>Without the third rule, it is possible for an index reader to see an index entry just before it is removed by &lt;code&gt;VACUUM&lt;/code&gt;, and then to arrive at the corresponding heap entry after that was removed by &lt;code&gt;VACUUM&lt;/code&gt;. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by &lt;code&gt;heap_fetch()&lt;/code&gt;. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as &lt;code&gt;SnapshotAny&lt;/code&gt;), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be &amp;ldquo;in flight&amp;rdquo; from the index entry to the matching heap entry. Making &lt;code&gt;ambulkdelete&lt;/code&gt; block on such a pin ensures that &lt;code&gt;VACUUM&lt;/code&gt; cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict.</source>
          <target state="translated">인덱스 리더가 제거되기 직전에 인덱스 항목을 참조하는 제 규칙 없이는 가능 &lt;code&gt;VACUUM&lt;/code&gt; 그 의해 제거한 후 해당 힙 입구에 도착 후, 그리고 &lt;code&gt;VACUUM&lt;/code&gt; . 빈 항목 슬롯은 &lt;code&gt;heap_fetch()&lt;/code&gt; 의해 무시되므로, 항목 번호가 판독기에 도달 할 때 해당 항목 번호를 여전히 사용하지 않으면 심각한 문제가 발생하지 않습니다 . 그러나 세 번째 백엔드에서 이미 아이템 슬롯을 다른 용도로 재사용 한 경우 어떻게해야합니까? MVCC 호환 스냅 샷을 사용하는 경우, 슬롯의 새 점유자가 스냅 샷 테스트를 통과하기에는 너무 새롭기 때문에 문제가 없습니다. 그러나 비 MVCC 호환 스냅 샷 (예 : &lt;code&gt;SnapshotAny&lt;/code&gt; )), 실제로 스캔 키와 일치하지 않는 행을 승인하고 리턴 할 수 있습니다. 모든 경우에 힙 키에 대해 스캔 키를 다시 확인하도록함으로써이 시나리오를 막을 수는 있지만 너무 비쌉니다. 대신, 색인 페이지의 핀을 프록시로 사용하여 독자가 색인 항목에서 일치하는 힙 항목으로 &quot;비행 중&quot;임을 나타낼 수 있습니다. 이러한 핀에 &lt;code&gt;ambulkdelete&lt;/code&gt; 블록을 만들면 판독기가 완료되기 전에 &lt;code&gt;VACUUM&lt;/code&gt; 이 힙 항목을 삭제할 수 없습니다. 이 솔루션은 런타임 비용이 거의 들지 않으며 실제로 충돌이 발생하는 드문 경우에만 블로킹 오버 헤드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fdba0729d7141c4dc983525f28420a370b378b16" translate="yes" xml:space="preserve">
          <source>Without this clause, it is an error to specify an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) for an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;. This clause overrides that restriction.</source>
          <target state="translated">이 절이 없으면 &lt;code&gt;GENERATED ALWAYS&lt;/code&gt; 로 정의 된 식별 컬럼에 명시 적 값 ( &lt;code&gt;DEFAULT&lt;/code&gt; 이외 ) 을 지정하는 것은 오류 입니다. 이 절은 해당 제한을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="77f4e928561a920783857c04bc4af1f2750cf7f5" translate="yes" xml:space="preserve">
          <source>Without this option, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent. This option is useful to avoid such estimation time if it's too long.</source>
          <target state="translated">이 옵션이 없으면 전체 데이터베이스의 크기를 열거하여 백업을 시작한 다음 돌아가서 실제 내용을 보냅니다. 이로 인해 백업이 약간 더 오래 걸릴 수 있으며, 특히 첫 번째 데이터가 전송되기까지 더 오래 걸립니다. 이 옵션은 너무 긴 경우 이러한 추정 시간을 피하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5de5c631615b4050dbf3abcb11bda852949d1d49" translate="yes" xml:space="preserve">
          <source>Word, all ASCII letters</source>
          <target state="translated">단어, 모든 ASCII 문자</target>
        </trans-unit>
        <trans-unit id="cd638519c2bb50f94881c41d59edcf0f4b988187" translate="yes" xml:space="preserve">
          <source>Word, all letters</source>
          <target state="translated">단어, 모든 글자</target>
        </trans-unit>
        <trans-unit id="d929261f89fb5edc0a55361dccd5a42cfafc1e28" translate="yes" xml:space="preserve">
          <source>Word, letters and digits</source>
          <target state="translated">단어, 문자 및 숫자</target>
        </trans-unit>
        <trans-unit id="1c821c5f35490070199526bcafeccdc95331fb80" translate="yes" xml:space="preserve">
          <source>Work is still needed to improve the genetic algorithm parameter settings. In file &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt;, routines &lt;code&gt;gimme_pool_size&lt;/code&gt; and &lt;code&gt;gimme_number_generations&lt;/code&gt;, we have to find a compromise for the parameter settings to satisfy two competing demands:</source>
          <target state="translated">유전자 알고리즘 매개 변수 설정을 개선하기위한 작업이 여전히 필요합니다. 파일에서 &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt; , 루틴 &lt;code&gt;gimme_pool_size&lt;/code&gt; 및 &lt;code&gt;gimme_number_generations&lt;/code&gt; 는 , 우리는이 개 경쟁하는 요구를 충족 할 수있는 매개 변수 설정에 대한 타협을 찾을 수있다 :</target>
        </trans-unit>
        <trans-unit id="3ae6871c604e1194dadbdf1baf868fa3278d7cc4" translate="yes" xml:space="preserve">
          <source>Write Ahead Log</source>
          <target state="translated">미리 기록</target>
        </trans-unit>
        <trans-unit id="3f9793b6786fb282a995505c49ca5c8dab4849b1" translate="yes" xml:space="preserve">
          <source>Write a message to the server log if checkpoints caused by the filling of WAL segment files happen closer together than this amount of time (which suggests that &lt;code&gt;max_wal_size&lt;/code&gt; ought to be raised). If this value is specified without units, it is taken as seconds. The default is 30 seconds (&lt;code&gt;30s&lt;/code&gt;). Zero disables the warning. No warnings will be generated if &lt;code&gt;checkpoint_timeout&lt;/code&gt; is less than &lt;code&gt;checkpoint_warning&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WAL 세그먼트 파일 채우기로 인한 체크 포인트가이 시간보다 더 긴 시간에 근접하면 서버 로그에 메시지를 작성하십시오 ( &lt;code&gt;max_wal_size&lt;/code&gt; 가 높아져야 함을 나타냄 ). 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 기본값은 30 초입니다 ( &lt;code&gt;30s&lt;/code&gt; ). 0은 경고를 비활성화합니다. &lt;code&gt;checkpoint_timeout&lt;/code&gt; 이 &lt;code&gt;checkpoint_warning&lt;/code&gt; 보다 작은 경우 경고가 생성되지 않습니다 . 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79f29b256742ae32a7ee610c6c80dec55fe4bb44" translate="yes" xml:space="preserve">
          <source>Write all query output into file &lt;code&gt;filename&lt;/code&gt;, in addition to the normal output destination.</source>
          <target state="translated">일반 출력 대상 외에 모든 쿼리 출력을 파일 &lt;code&gt;filename&lt;/code&gt; 에 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="ced9f94f9040a73c60549d122b831459c11a3fbf" translate="yes" xml:space="preserve">
          <source>Write information about each transaction to a log file. See below for details.</source>
          <target state="translated">각 트랜잭션에 대한 정보를 로그 파일에 기록하십시오. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e33b6c1a70b5c50c6203011bb22d6394a5061934" translate="yes" xml:space="preserve">
          <source>Write received and decoded transaction data into this file. Use &lt;code&gt;-&lt;/code&gt; for stdout.</source>
          <target state="translated">수신 및 디코딩 된 트랜잭션 데이터를이 파일에 씁니다. stdout에 &lt;code&gt;-&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="660438e8219803d5c64d3c38fd0601dbee576ac1" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the current data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the server.</source>
          <target state="translated">현재 데이터 디렉토리 및 테이블 스페이스와 동일한 레이아웃으로 출력을 일반 파일로 작성하십시오. 클러스터에 추가 테이블 스페이스가 없으면 전체 데이터베이스가 대상 디렉토리에 배치됩니다. 클러스터에 추가 테이블 스페이스가 포함 된 경우 기본 데이터 디렉토리는 대상 디렉토리에 배치되지만 다른 모든 테이블 스페이스는 서버에서와 동일한 절대 경로에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="6b1ff15d67ddd19c1531e3e1b72239d7b15119da" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the source server's data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the source server.</source>
          <target state="translated">소스 서버의 데이터 디렉토리 및 테이블 스페이스와 동일한 레이아웃을 사용하여 출력을 일반 파일로 작성합니다. 클러스터에 추가 테이블 스페이스가 없으면 전체 데이터베이스가 대상 디렉토리에 배치됩니다. 클러스터에 추가 테이블 스페이스가 포함 된 경우 기본 데이터 디렉토리는 대상 디렉토리에 배치되지만 다른 모든 테이블 스페이스는 소스 서버와 동일한 절대 경로에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc92c3f4b6de8494f22f127e95dec8313f91169" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and all other tablespaces will be named after the tablespace OID.</source>
          <target state="translated">출력을 대상 디렉토리에 tar 파일로 작성하십시오. 기본 데이터 디렉토리는 &lt;code&gt;base.tar&lt;/code&gt; 라는 파일에 작성되며 다른 모든 테이블 스페이스는 테이블 스페이스 OID의 이름을 따서 명명됩니다.</target>
        </trans-unit>
        <trans-unit id="a1016f820515616448d3af03f5c6cb584f20f3bd" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory's contents will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and each other tablespace will be written to a separate tar file named after that tablespace's OID.</source>
          <target state="translated">출력을 대상 디렉토리에 tar 파일로 작성합니다. 기본 데이터 디렉토리의 내용은 &lt;code&gt;base.tar&lt;/code&gt; 라는 파일에 기록 되고 서로 다른 테이블 스페이스는 해당 테이블 스페이스의 OID 이름을 따서 명명 된 별도의 tar 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="12aba288e98df3f05ebad1cf7143b1a4df822af8" translate="yes" xml:space="preserve">
          <source>Write, or append to, a text file</source>
          <target state="translated">텍스트 파일 쓰기 또는 추가</target>
        </trans-unit>
        <trans-unit id="73694598d4f6dd9ae50f65c44a8d5357103fbda0" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log</source>
          <target state="translated">미리 쓰기 로그</target>
        </trans-unit>
        <trans-unit id="32219ea741aab08cd4b2cc75491ff92cd882b3c1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Shipping</source>
          <target state="translated">미리 쓰기 로그 배송</target>
        </trans-unit>
        <trans-unit id="bd375d03897609b092749de9e582ed65e566d377" translate="yes" xml:space="preserve">
          <source>Write-ahead log</source>
          <target state="translated">미리 쓰기 로그</target>
        </trans-unit>
        <trans-unit id="aab8077ca2cb9e3834b524a783525c97b082b885" translate="yes" xml:space="preserve">
          <source>Write-heavy workloads that don't benefit from deduplication due to having few or no duplicate values in indexes will incur a small, fixed performance penalty (unless deduplication is explicitly disabled). The &lt;code&gt;deduplicate_items&lt;/code&gt; storage parameter can be used to disable deduplication within individual indexes. There is never any performance penalty with read-only workloads, since reading posting list tuples is at least as efficient as reading the standard tuple representation. Disabling deduplication isn't usually helpful.</source>
          <target state="translated">인덱스에 중복 값이 ​​거의 없거나 전혀 없기 때문에 중복 제거의 이점을 얻지 못하는 쓰기 작업이 많은 워크로드는 작고 고정 된 성능 패널티를 발생시킵니다 (중복 제거가 명시 적으로 비활성화되지 않는 한). &lt;code&gt;deduplicate_items&lt;/code&gt; 의 저장 매개 변수는 개별 인덱스를 비활성화 할 중복 제거에 사용할 수 있습니다. 게시 목록 튜플을 읽는 것이 최소한 표준 튜플 표현을 읽는 것만 큼 효율적이기 때문에 읽기 전용 워크로드에 대한 성능 저하는 없습니다. 중복 제거를 비활성화하는 것은 일반적으로 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="674bcf8c81a59458958b21d0660da76f6ba332b5" translate="yes" xml:space="preserve">
          <source>Writes the current query buffer to the file &lt;code&gt;filename&lt;/code&gt; or pipes it to the shell command &lt;code&gt;command&lt;/code&gt;. If the current query buffer is empty, the most recently executed query is written instead.</source>
          <target state="translated">현재 쿼리 버퍼를 파일 파일 &lt;code&gt;filename&lt;/code&gt; 쓰거나 쉘 명령 &lt;code&gt;command&lt;/code&gt; 파이프합니다 . 현재 쿼리 버퍼가 비어 있으면 가장 최근에 실행 된 쿼리가 대신 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b84228914215a42dbe6fe7e926dad3ab9b4cf367" translate="yes" xml:space="preserve">
          <source>Writes the generated LLVM IR out to the file system, inside &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;. This is only useful for working on the internals of the JIT implementation. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be changed by a superuser.</source>
          <target state="translated">생성 된 LLVM IR을 &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt; 내의 파일 시스템에 기록 합니다. 이것은 JIT 구현의 내부 작업에만 유용합니다. 기본 설정은 &lt;code&gt;off&lt;/code&gt; 입니다. 이 매개 변수는 수퍼 유저 만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="682768582621701d8f61b9c4bbc3b649ebde2e19" translate="yes" xml:space="preserve">
          <source>Writes, or appends to, a text file.</source>
          <target state="translated">Writes, or appends to, a text file.</target>
        </trans-unit>
        <trans-unit id="d5af6404c7f764d57f9d5c62315cdf9f310e1309" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;*&lt;/code&gt; is not necessary, since this behavior is always the default. However, this syntax is still supported for compatibility with older releases where the default could be changed.</source>
          <target state="translated">작성 &lt;code&gt;*&lt;/code&gt; 것은 이 동작은 항상 기본이기 때문에, 필요하지 않습니다. 그러나이 구문은 기본값을 변경할 수있는 이전 릴리스와의 호환성을 위해 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6151e701c60f047c7b832b2686813d1310a12fca" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;ALL&lt;/code&gt; in place of a specific privilege grants all privileges that are relevant for the object type.</source>
          <target state="translated">특정 권한 대신 &lt;code&gt;ALL&lt;/code&gt; 을 쓰면 개체 유형과 관련된 모든 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="f43277b6f1b770dadde2ceed80f27334202f924f" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;SECURITY DEFINER&lt;/code&gt; Functions Safely</source>
          <target state="translated">&lt;code&gt;SECURITY DEFINER&lt;/code&gt; 함수를 안전하게 작성</target>
        </trans-unit>
        <trans-unit id="ffbf328be37b139670f7ef37c6af175473c5c705" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 여러 언어 바인딩 중 하나를 사용하여 사용자 지정 응용 프로그램 작성 이러한 가능성에 대해서는 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;4 부&lt;/a&gt; 에서 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="d2f9ec6d7e0edde20b9de31e1198d1816d564790" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="translated">Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="de5165fc57d1f9a5e5c5994fec1932df3a128a9e" translate="yes" xml:space="preserve">
          <source>Writing the actual numeric value of any OID in C code is considered very bad form; always use a macro, instead. Direct references to &lt;code&gt;pg_proc&lt;/code&gt; OIDs are common enough that there's a special mechanism to create the necessary macros automatically; see &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt;. Similarly &amp;mdash; but, for historical reasons, not done the same way &amp;mdash; there's an automatic method for creating macros for &lt;code&gt;pg_type&lt;/code&gt; OIDs. &lt;code&gt;oid_symbol&lt;/code&gt; entries are therefore not necessary in those two catalogs. Likewise, macros for the &lt;code&gt;pg_class&lt;/code&gt; OIDs of system catalogs and indexes are set up automatically. For all other system catalogs, you have to manually specify any macros you need via &lt;code&gt;oid_symbol&lt;/code&gt; entries.</source>
          <target state="translated">C 코드에서 OID의 실제 숫자 값을 쓰는 것은 매우 나쁜 형태로 간주됩니다. 대신 항상 매크로를 사용하십시오. &lt;code&gt;pg_proc&lt;/code&gt; OID에 대한 직접적인 참조 는 필요한 매크로를 자동으로 생성하는 특별한 메커니즘이있을 정도로 일반적입니다. &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt; 을 참조하십시오 . 마찬가지로 역사적으로 같은 방식으로 수행되지는 않았지만 &lt;code&gt;pg_type&lt;/code&gt; OID에 대한 매크로를 자동으로 생성하는 방법이 있습니다. 따라서 &lt;code&gt;oid_symbol&lt;/code&gt; 항목은이 두 카탈로그에서 필요하지 않습니다. 마찬가지로 시스템 카탈로그 및 인덱스 의 &lt;code&gt;pg_class&lt;/code&gt; OID에 대한 매크로가 자동으로 설정됩니다. 다른 모든 시스템 카탈로그의 경우 &lt;code&gt;oid_symbol&lt;/code&gt; 항목을 통해 필요한 매크로를 수동으로 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="d5409f1461aa5b5298ee6d5c93002f7a27e50654" translate="yes" xml:space="preserve">
          <source>XID</source>
          <target state="translated">XID</target>
        </trans-unit>
        <trans-unit id="70fc167721857c5174dbbe545fe597100e840cd6" translate="yes" xml:space="preserve">
          <source>XID for VACUUM operation moving a row version</source>
          <target state="translated">행 버전을 이동하는 VACUUM 조 작용 XID</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="6dbc2e3a95bd424284a60fab71bfd99ecc6aa480" translate="yes" xml:space="preserve">
          <source>XML Functions</source>
          <target state="translated">XML 함수</target>
        </trans-unit>
        <trans-unit id="677fbcd727fb96243fff280b768de17534da204d" translate="yes" xml:space="preserve">
          <source>XML Limits and Conformance to SQL/XML</source>
          <target state="translated">SQL / XML에 대한 XML 제한 및 적합성</target>
        </trans-unit>
        <trans-unit id="be1200e7280e074bb09cc29b489d7736fa9c3b13" translate="yes" xml:space="preserve">
          <source>XML Type</source>
          <target state="translated">XML 타입</target>
        </trans-unit>
        <trans-unit id="72f6e6e18c4cf2cdf2736a3171665401b5f531b0" translate="yes" xml:space="preserve">
          <source>XML data</source>
          <target state="translated">XML 데이터</target>
        </trans-unit>
        <trans-unit id="9bc2b7976718250ab1463410139c7c00b0f2e7ce" translate="yes" xml:space="preserve">
          <source>XML declarations, if present, are combined as follows. If all argument values have the same XML version declaration, that version is used in the result, else no version is used. If all argument values have the standalone declaration value &amp;ldquo;yes&amp;rdquo;, then that value is used in the result. If all argument values have a standalone declaration value and at least one is &amp;ldquo;no&amp;rdquo;, then that is used in the result. Else the result will have no standalone declaration. If the result is determined to require a standalone declaration but no version declaration, a version declaration with version 1.0 will be used because XML requires an XML declaration to contain a version declaration. Encoding declarations are ignored and removed in all cases.</source>
          <target state="translated">XML 선언이있는 경우 다음과 같이 결합됩니다. 모든 인수 값이 동일한 XML 버전 선언을 갖는 경우 해당 버전이 결과에 사용되며, 그렇지 않으면 버전이 사용되지 않습니다. 모든 인수 값에 독립형 선언 값 &quot;yes&quot;가 있으면 해당 값이 결과에 사용됩니다. 모든 인수 값에 독립형 선언 값이 있고 하나 이상이 &quot;아니오&quot;이면 결과에 사용됩니다. 그렇지 않으면 결과에 독립형 선언이 없습니다. 결과에 독립형 선언이 필요하지만 버전 선언은 필요하지 않은 것으로 판명되면 XML에 버전 선언을 포함하는 XML 선언이 필요하므로 버전 1.0의 버전 선언이 사용됩니다. 인코딩 선언은 모든 경우에 무시되고 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="93db77a518a3a65df06b8910ae3df05493323aa8" translate="yes" xml:space="preserve">
          <source>XML entity</source>
          <target state="translated">XML 엔터티</target>
        </trans-unit>
        <trans-unit id="41d948a6e01de6c3d4845c4fb6a9cd77bb4a345f" translate="yes" xml:space="preserve">
          <source>XML format is left as an exercise for the reader.</source>
          <target state="translated">XML 형식은 독자의 연습으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="c648229e46576f92e57966e5bb6a169947ab07af" translate="yes" xml:space="preserve">
          <source>XML tag</source>
          <target state="translated">XML 태그</target>
        </trans-unit>
        <trans-unit id="b7b6740d5d3d1f4067adb9c002cd0cc814ec4855" translate="yes" xml:space="preserve">
          <source>XML: IS DOCUMENT</source>
          <target state="translated">XML : 문서</target>
        </trans-unit>
        <trans-unit id="863fe78f50c66a6f7d93b18bf787a5d0aa670b5c" translate="yes" xml:space="preserve">
          <source>XML: IS NOT DOCUMENT</source>
          <target state="translated">XML : 문서가 아님</target>
        </trans-unit>
        <trans-unit id="708b35917f64aea4aecf43902f9f6861b388f0a3" translate="yes" xml:space="preserve">
          <source>XML: XMLEXISTS</source>
          <target state="translated">XML : XMLEXISTS</target>
        </trans-unit>
        <trans-unit id="7aea648b2b4e07c316d48e040a2dfe07aea119ed" translate="yes" xml:space="preserve">
          <source>XML: xml_is_well_formed</source>
          <target state="translated">XML : xml_is_well_formed</target>
        </trans-unit>
        <trans-unit id="3eca7373df1b8e0c5ed4c506c73dcc360d0c1000" translate="yes" xml:space="preserve">
          <source>XML: xmlagg</source>
          <target state="translated">XML : xmlagg</target>
        </trans-unit>
        <trans-unit id="31986b6f48c236780bb28b6f7a97cd2e7fe2fbbc" translate="yes" xml:space="preserve">
          <source>XML: xmlcomment</source>
          <target state="translated">XML : xmlcomment</target>
        </trans-unit>
        <trans-unit id="3336319324aa48adbaa76e0cbbf9934042dd41f7" translate="yes" xml:space="preserve">
          <source>XML: xmlconcat</source>
          <target state="translated">XML : xmlconcat</target>
        </trans-unit>
        <trans-unit id="c269b1860c6e177984dcd77f1f2f9180f500a7b1" translate="yes" xml:space="preserve">
          <source>XML: xmlelement</source>
          <target state="translated">XML : xmlelement</target>
        </trans-unit>
        <trans-unit id="f6f6cd60dad73c2efa2b22421846170fa537daf4" translate="yes" xml:space="preserve">
          <source>XML: xmlforest</source>
          <target state="translated">XML : xmlforest</target>
        </trans-unit>
        <trans-unit id="b4c3ab3b44e0a9d5e8cf4d618e5fb213a70446ae" translate="yes" xml:space="preserve">
          <source>XML: xmlpi</source>
          <target state="translated">XML : xmlpi</target>
        </trans-unit>
        <trans-unit id="2cb9abaad07f3be72c6b803b64719f6ad9373b8b" translate="yes" xml:space="preserve">
          <source>XML: xmlroot</source>
          <target state="translated">XML : xmlroot</target>
        </trans-unit>
        <trans-unit id="fe1c1afeea56eb4d61a6d5854b178d21b29bd194" translate="yes" xml:space="preserve">
          <source>XML: xmltable</source>
          <target state="translated">XML : xmltable</target>
        </trans-unit>
        <trans-unit id="943bcc21921946abacf747784b147601338c43bb" translate="yes" xml:space="preserve">
          <source>XML: xpath</source>
          <target state="translated">XML : xpath</target>
        </trans-unit>
        <trans-unit id="112eb0200c63c2f0de87632cdeab3a1c8a706831" translate="yes" xml:space="preserve">
          <source>XML: xpath_exists</source>
          <target state="translated">XML : xpath_exists</target>
        </trans-unit>
        <trans-unit id="a417f6430ccc4b644617c160b0d4f1b2c80cd5e2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 blurs the distinction between &lt;em&gt;value comparisons&lt;/em&gt; and &lt;em&gt;general comparisons&lt;/em&gt; as XQuery/XPath define them. Both &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; and &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; are existentially quantified comparisons, true if there is any &lt;code&gt;sale&lt;/code&gt; with the given value for the attribute, but &lt;code&gt;sale/@taxable = false()&lt;/code&gt; is a value comparison to the &lt;em&gt;effective boolean value&lt;/em&gt; of a whole node-set. It is true only if no &lt;code&gt;sale&lt;/code&gt; has a &lt;code&gt;taxable&lt;/code&gt; attribute at all.</source>
          <target state="translated">XPath 1.0 은 XQuery / XPath에서 정의한 &lt;em&gt;값 비교&lt;/em&gt; 와 &lt;em&gt;일반 비교&lt;/em&gt; 의 차이점을 흐리게 합니다. &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; 및 &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; 는 모두 실질적으로 정량화 된 비교 입니다. 속성에 대해 주어진 값을 가진 &lt;code&gt;sale&lt;/code&gt; 있는 경우 true 이지만 &lt;code&gt;sale/@taxable = false()&lt;/code&gt; 는 전체 노드 세트의 &lt;em&gt;유효 부울 값 &lt;/em&gt; &lt;code&gt;taxable&lt;/code&gt; 속성 이 없는 &lt;code&gt;sale&lt;/code&gt; 없는 경우에만 해당됩니다 .</target>
        </trans-unit>
        <trans-unit id="f37617c0d5dc43deba6ebd523a1e7daa408818b2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 does not specify an order for nodes in a node-set, so code that relies on a particular order of the results will be implementation-dependent. Details can be found in &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;Section D.3.1.2&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0은 노드 세트의 노드 순서를 지정하지 않으므로 결과의 특정 순서에 의존하는 코드는 구현에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;섹션 D.3.1.2&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccec9b819d48fea6e95ee65b1f2c2363e5212016" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no conditional operator. An XQuery/XPath expression such as &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; has no XPath 1.0 equivalent.</source>
          <target state="translated">XPath 1.0에는 조건부 연산자가 없습니다. &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; 과 같은 XQuery / XPath 표현식 에는 XPath 1.0에 해당하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="575a5727a0aaf2dc929963572ab31f3a07d3b31b" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no ordering comparison operator for strings. Both &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; and &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; are false, because each is a numeric comparison of two &lt;code&gt;NaN&lt;/code&gt;s. In contrast, &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; do compare the strings as strings.</source>
          <target state="translated">XPath 1.0에는 문자열에 대한 순서 비교 연산자가 없습니다. 모두 &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; 각각 두 개의 숫자 비교이기 때문에, 거짓 &lt;code&gt;NaN&lt;/code&gt; 이 들. 반대로 &lt;code&gt;=&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; 는 문자열을 문자열로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="8c4149ee47a54aa2c037b2786d8549ef1627ad8e" translate="yes" xml:space="preserve">
          <source>XQuery allows declaration and use of local functions.</source>
          <target state="translated">XQuery는 로컬 함수의 선언 및 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="818970bcffceb4be8cc185fddd03719babd24f42" translate="yes" xml:space="preserve">
          <source>XQuery character class elements using &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; or the inverse &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; are not supported.</source>
          <target state="translated">&lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; 또는 역 &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; 사용하는 XQuery 문자 클래스 요소 는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f9675f91b1bee552c1436f5af897518b9d66036" translate="yes" xml:space="preserve">
          <source>XQuery character class shorthands &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\i&lt;/code&gt;, and &lt;code&gt;\I&lt;/code&gt; are not supported.</source>
          <target state="translated">XQuery 문자 클래스 속기 &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\C&lt;/code&gt; , &lt;code&gt;\i&lt;/code&gt; 및 &lt;code&gt;\I&lt;/code&gt; 는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e05d40877e991191e09256daf83989a5f47e5557" translate="yes" xml:space="preserve">
          <source>XQuery character class subtraction is not supported. An example of this feature is using the following to match only English consonants: &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt;.</source>
          <target state="translated">XQuery 문자 클래스 빼기는 지원되지 않습니다. 이 기능의 예는 다음을 사용하여 영어 자음 만 일치시킵니다. &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ba7fb2ffaaf928a3568f9854442e7071379dc9" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">XQuery에는 lookahead 또는 lookbehind 제약 조건이 없으며 &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;표 9.21에&lt;/a&gt; 설명 된 제약 조건 이스케이프가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb9c8b3c7792b9cf1dc2ef58684f3e70a06da1d2" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</source>
          <target state="translated">XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="41577214ab7c5c54db475c958675a49fbb00b4a6" translate="yes" xml:space="preserve">
          <source>XQuery does not support the &lt;code&gt;[:name:]&lt;/code&gt; syntax for character classes within bracket expressions.</source>
          <target state="translated">XQuery는 대괄호 표현식 내의 문자 클래스에 대해 &lt;code&gt;[:name:]&lt;/code&gt; 구문을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e0c3c6ff5da1ba3d8311b799d1cf51c7385d7c2" translate="yes" xml:space="preserve">
          <source>XQuery expressions can construct and return new XML nodes, in addition to all possible XPath values. XPath can create and return values of the atomic types (numbers, strings, and so on) but can only return XML nodes that were already present in documents supplied as input to the expression.</source>
          <target state="translated">XQuery 표현식은 가능한 모든 XPath 값 외에도 새로운 XML 노드를 구성하고 리턴 할 수 있습니다. XPath는 원자 유형 (숫자, 문자열 등)의 값을 작성하고 리턴 할 수 있지만 표현식의 입력으로 제공된 문서에 이미 존재하는 XML 노드 만 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d07dea26dd7592af4147bb1ae9d21c709ece2a7" translate="yes" xml:space="preserve">
          <source>XQuery has control constructs for iteration, sorting, and grouping.</source>
          <target state="translated">XQuery에는 반복, 정렬 및 그룹화를위한 제어 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9add350a4eb532be8a2c9c9d393be8bd03cceb66" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;s&lt;/code&gt; (allow dot to match newline) and &lt;code&gt;m&lt;/code&gt; (allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines) flags provide access to the same behaviors as POSIX's &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; flags, but they do &lt;em&gt;not&lt;/em&gt; match the behavior of POSIX's &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; flags. Note in particular that dot-matches-newline is the default behavior in POSIX but not XQuery.</source>
          <target state="translated">XQuery의 &lt;code&gt;s&lt;/code&gt; (개행과 일치하는 도트 허용) 및 &lt;code&gt;m&lt;/code&gt; ( 개행과 일치 하는 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 허용 ) 플래그는 POSIX의 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;w&lt;/code&gt; 플래그 와 동일한 동작에 액세스 할 수 있지만 POSIX의 &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;m&lt;/code&gt; 플래그 의 동작과 일치 하지 &lt;em&gt;않습니다.&lt;/em&gt; . 특히 dot-matches-newline은 POSIX의 기본 동작이지만 XQuery는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0fbdf61430816231b42e0b59499fabbec39b5ae3" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;x&lt;/code&gt; (ignore whitespace in pattern) flag is noticeably different from POSIX's expanded-mode flag. POSIX's &lt;code&gt;x&lt;/code&gt; flag also allows &lt;code&gt;#&lt;/code&gt; to begin a comment in the pattern, and POSIX will not ignore a whitespace character after a backslash.</source>
          <target state="translated">XQuery의 &lt;code&gt;x&lt;/code&gt; (패턴에서 공백 무시) 플래그는 POSIX의 확장 모드 플래그와 현저히 다릅니다. POSIX의 &lt;code&gt;x&lt;/code&gt; 플래그는 또한 &lt;code&gt;#&lt;/code&gt; 이 패턴에서 주석을 시작할 수있게 하며 POSIX는 백 슬래시 후 공백 문자를 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="cb29757e458776404c0d0c4f5c75b0740d559b1c" translate="yes" xml:space="preserve">
          <source>Year and day of year: for example &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; also returns &lt;code&gt;2006-10-19&lt;/code&gt;.</source>
          <target state="translated">연도 및 연도 : 예를 들어 &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; 는 &lt;code&gt;2006-10-19&lt;/code&gt; 도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fc5a18c267810c3dc6c5d4fdd0b02c9e146fd0f1" translate="yes" xml:space="preserve">
          <source>Year, week number, and weekday: for example &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; returns the date &lt;code&gt;2006-10-19&lt;/code&gt;. If you omit the weekday it is assumed to be 1 (Monday).</source>
          <target state="translated">연도, 주 번호 및 요일 : 예를 들어 &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; 는 &lt;code&gt;2006-10-19&lt;/code&gt; 날짜를 반환합니다 . 평일을 생략하면 1 (월요일)로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7abdb2567a06fc713cd1d6b57e90f634441b367e" translate="yes" xml:space="preserve">
          <source>Year-Month Interval</source>
          <target state="translated">년-월 간격</target>
        </trans-unit>
        <trans-unit id="96f997bcecb36502ed4b296a795f72aff9d6bfe7" translate="yes" xml:space="preserve">
          <source>Years</source>
          <target state="translated">Years</target>
        </trans-unit>
        <trans-unit id="3cfd5c7e576642a9c9f3bbe4db929041cea0177f" translate="yes" xml:space="preserve">
          <source>Years in the 1900s are in the second millennium. The third millennium started January 1, 2001.</source>
          <target state="translated">1900 년대는 2 천년입니다. 세 번째 밀레니엄은 2001 년 1 월 1 일에 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="6dd15150afde3fb668c9c37b5570c9f350a42483" translate="yes" xml:space="preserve">
          <source>You can (and, for most purposes, probably should) increase the number of rows by using the &lt;code&gt;-s&lt;/code&gt; (scale factor) option. The &lt;code&gt;-F&lt;/code&gt; (fillfactor) option might also be used at this point.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; (scale factor) 옵션 을 사용하여 행 수를 늘릴 수 있습니다 (대부분의 경우 아마도 ). &lt;code&gt;-F&lt;/code&gt; (FILLFACTOR) 옵션은이 시점에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="145c00d5953681c62f21c82b058caafeee2a8310" translate="yes" xml:space="preserve">
          <source>You can adapt this module to your needs by changing the source code. For example, you can use &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; to check passwords &amp;mdash; this only requires uncommenting two lines in the &lt;code&gt;Makefile&lt;/code&gt; and rebuilding the module. (We cannot include CrackLib by default for license reasons.) Without CrackLib, the module enforces a few simple rules for password strength, which you can modify or extend as you see fit.</source>
          <target state="translated">소스 코드를 변경하여이 모듈을 필요에 맞게 조정할 수 있습니다. 예를 들어 &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; 을 사용 하여 비밀번호를 확인할 수 있습니다 . &lt;code&gt;Makefile&lt;/code&gt; 에서 두 줄의 주석 처리를 제거 하고 모듈을 다시 작성하면됩니다. 라이센스 이유로 인해 기본적으로 CrackLib을 포함 할 수 없습니다. CrackLib이 없으면 모듈은 비밀번호 강도에 대한 몇 가지 간단한 규칙을 적용하며, 사용자가 원하는대로 수정하거나 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28dae3ce662983a3720ca411f5e625f764893bf1" translate="yes" xml:space="preserve">
          <source>You can add whitespace before a left brace or after a right brace. You can also add whitespace before or after any individual item string. In all of these cases the whitespace will be ignored. However, whitespace within double-quoted elements, or surrounded on both sides by non-whitespace characters of an element, is not ignored.</source>
          <target state="translated">왼쪽 괄호 앞이나 오른쪽 괄호 뒤에 공백을 추가 할 수 있습니다. 개별 항목 문자열 앞뒤에 공백을 추가 할 수도 있습니다. 이 모든 경우에 공백은 무시됩니다. 그러나 큰 따옴표로 묶은 요소 내의 공백이나 요소의 공백이 아닌 문자로 양쪽에 둘러싸인 공백은 무시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="569893ff6c39724a565a145b8a3ad3a0b9606463" translate="yes" xml:space="preserve">
          <source>You can adjust the ordering of a B-tree index by including the options &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; when creating the index; for example:</source>
          <target state="translated">인덱스를 만들 때 &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; , &lt;code&gt;NULLS FIRST&lt;/code&gt; 및 / 또는 &lt;code&gt;NULLS LAST&lt;/code&gt; 옵션을 포함시켜 B- 트리 인덱스의 순서를 조정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b7d9d02889a217be36bf8f71750c721f9d62b3a" translate="yes" xml:space="preserve">
          <source>You can also control the order in which rows are processed by window functions using &lt;code&gt;ORDER BY&lt;/code&gt; within &lt;code&gt;OVER&lt;/code&gt;. (The window &lt;code&gt;ORDER BY&lt;/code&gt; does not even have to match the order in which the rows are output.) Here is an example:</source>
          <target state="translated">&lt;code&gt;OVER&lt;/code&gt; 내에서 &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용하여 창 함수에 의해 행이 처리되는 순서를 제어 할 수도 있습니다 . ( &lt;code&gt;ORDER BY&lt;/code&gt; 창 은 행이 출력되는 순서와 일치하지 않아도됩니다.) 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8031e0a82c5477e58a31c17656bff548035b193" translate="yes" xml:space="preserve">
          <source>You can also create databases with other names. PostgreSQL allows you to create any number of databases at a given site. Database names must have an alphabetic first character and are limited to 63 bytes in length. A convenient choice is to create a database with the same name as your current user name. Many tools assume that database name as the default, so it can save you some typing. To create that database, simply type:</source>
          <target state="translated">다른 이름으로 데이터베이스를 만들 수도 있습니다. PostgreSQL을 사용하면 특정 사이트에서 여러 데이터베이스를 만들 수 있습니다. 데이터베이스 이름은 알파벳 첫 문자를 가져야하며 길이는 63 바이트로 제한됩니다. 편리한 선택은 현재 사용자 이름과 동일한 이름으로 데이터베이스를 작성하는 것입니다. 많은 도구가 데이터베이스 이름을 기본값으로 가정하므로 일부 입력을 저장할 수 있습니다. 해당 데이터베이스를 작성하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="2855332ddeec7909c633615734e0f09916910215" translate="yes" xml:space="preserve">
          <source>You can also define constraints on the column at the same time, using the usual syntax:</source>
          <target state="translated">일반적인 구문을 사용하여 열에 대한 제약 조건을 동시에 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1e40e96d3d99c788ff89c86039beb4c7ae5ad3" translate="yes" xml:space="preserve">
          <source>You can also force the insertion of invalid numbers even when not in the weak mode, by appending the &lt;code&gt;!&lt;/code&gt; character at the end of the number.</source>
          <target state="translated">약한 모드가 아닌 경우에도 &lt;code&gt;!&lt;/code&gt; 를 추가하여 유효하지 않은 숫자를 강제로 삽입 할 수도 있습니다 . 숫자 끝에있는 문자.</target>
        </trans-unit>
        <trans-unit id="e92dd9f79aa93357545022991d035db8fa3c697a" translate="yes" xml:space="preserve">
          <source>You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:</source>
          <target state="translated">구속 조건에 별도의 이름을 지정할 수도 있습니다. 오류 메시지를 명확하게하고 변경해야 할 때 제약 조건을 참조 할 수 있습니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c0e733bb8f77339cb0554d27f0faf1999d777b7" translate="yes" xml:space="preserve">
          <source>You can also nest filter expressions within each other:</source>
          <target state="translated">필터 표현식을 서로 중첩시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="540c7cc55f43958519f25aa973c9e5a2c6dcb66b" translate="yes" xml:space="preserve">
          <source>You can also search an array using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, which checks whether the left operand overlaps with the right operand. For instance:</source>
          <target state="translated">왼쪽 피연산자가 오른쪽 피연산자와 겹치는 지 확인 하는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자를 사용하여 배열을 검색 할 수도 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="7317ad78770ade20f7fc205d1692cc3871b32860" translate="yes" xml:space="preserve">
          <source>You can also search for specific values in an array using the &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt; functions. The former returns the subscript of the first occurrence of a value in an array; the latter returns an array with the subscripts of all occurrences of the value in the array. For example:</source>
          <target state="translated">&lt;code&gt;array_position&lt;/code&gt; 및 &lt;code&gt;array_positions&lt;/code&gt; 함수를 사용하여 배열에서 특정 값을 검색 할 수도 있습니다. 전자는 배열에서 처음 나타나는 값의 첨자를 반환합니다. 후자는 배열에서 모든 값의 첨자 배열을 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72011efb5669336e4615ad697b69c64d57f8e812" translate="yes" xml:space="preserve">
          <source>You can also shorten the above command to:</source>
          <target state="translated">위 명령을 단축하여 다음을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="362c18912cf35df18fb18daa4743d6a04f75f78b" translate="yes" xml:space="preserve">
          <source>You can also write &lt;code&gt;all&lt;/code&gt; to match any IP address, &lt;code&gt;samehost&lt;/code&gt; to match any of the server's own IP addresses, or &lt;code&gt;samenet&lt;/code&gt; to match any address in any subnet that the server is directly connected to.</source>
          <target state="translated">당신은 또한 쓸 수있는 &lt;code&gt;all&lt;/code&gt; 모든 IP 주소와 일치하는 &lt;code&gt;samehost&lt;/code&gt; 서버의 자신의 IP 주소와 일치하거나 &lt;code&gt;samenet&lt;/code&gt; 을 서버가 직접 연결되어 있는지 어떤 서브넷의 모든 주소와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="81719f677a0ec0af21aab7f90315c40b111bfbd1" translate="yes" xml:space="preserve">
          <source>You can also write the table name with a trailing &lt;code&gt;*&lt;/code&gt; to explicitly specify that descendant tables are included:</source>
          <target state="translated">또한 후행 &lt;code&gt;*&lt;/code&gt; 가 포함 된 테이블 이름을 작성하여 하위 테이블이 포함되도록 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5703517ac040c492127e1fb49e5ced3da0debc99" translate="yes" xml:space="preserve">
          <source>You can ask for all fields of a composite value by writing &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 를 쓰면 복합 값의 모든 필드를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc07d5e0044a9e8829c097c35614fb4ad2ee919" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a foreign key constraint, in the usual way.</source>
          <target state="translated">일반적인 방식으로 외래 키 제약 조건에 고유 한 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78537f8a74bec7b625797355864a6e8b33eb27d6" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a unique constraint, in the usual way:</source>
          <target state="translated">일반적인 방식으로 고유 제한 조건에 고유 한 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4029bdb8227766d867d39118fde7beadbd5eab" translate="yes" xml:space="preserve">
          <source>You can avoid always having to write out a &lt;code&gt;FROM&lt;/code&gt; clause to define the output columns, by setting up a custom crosstab function that has the desired output row type wired into its definition. This is described in the next section. Another possibility is to embed the required &lt;code&gt;FROM&lt;/code&gt; clause in a view definition.</source>
          <target state="translated">원하는 출력 행 유형이 정의에 연결되어있는 사용자 정의 크로스 탭 함수를 설정하여 출력 열을 정의 하기 위해 항상 &lt;code&gt;FROM&lt;/code&gt; 절 을 작성하지 않아도됩니다 . 이에 대해서는 다음 섹션에서 설명합니다. 또 다른 가능성은 뷰 정의에 필수 &lt;code&gt;FROM&lt;/code&gt; 절 을 포함시키는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="91ab32b5c2f6769faecc52b84a69c2005aae2685" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas.</source>
          <target state="translated">You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas.</target>
        </trans-unit>
        <trans-unit id="564b000e3befed57b182cb04e1dbb1e1574bf5b5" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas. Default privileges that are specified per-schema are added to whatever the global default privileges are for the particular object type.</source>
          <target state="translated">본인 또는 회원이 수행 한 역할에 의해 생성되는 개체에 대해서만 기본 권한을 변경할 수 있습니다. 특권은 전체적으로 (즉, 현재 데이터베이스에서 작성된 모든 오브젝트에 대해) 또는 지정된 스키마에서 작성된 오브젝트에 대해서만 설정할 수 있습니다. 스키마별로 지정된 기본 권한은 특정 개체 유형에 대한 전역 기본 권한에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce7b82cbd1c40e5d5b3f5f38a6fd3d98a532714" translate="yes" xml:space="preserve">
          <source>You can combine these approaches by setting up logrotate to collect log files produced by PostgreSQL built-in logging collector. In this case, the logging collector defines the names and location of the log files, while logrotate periodically archives these files. When initiating log rotation, logrotate must ensure that the application sends further output to the new file. This is commonly done with a &lt;code&gt;postrotate&lt;/code&gt; script that sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the application, which then reopens the log file. In PostgreSQL, you can run &lt;code&gt;pg_ctl&lt;/code&gt; with the &lt;code&gt;logrotate&lt;/code&gt; option instead. When the server receives this command, the server either switches to a new log file or reopens the existing file, depending on the logging configuration (see &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL 내장 로깅 수집기에서 생성 된 로그 파일을 수집하도록 logrotate를 설정하여 이러한 접근 방식을 결합 할 수 있습니다. 이 경우 로깅 수집기는 로그 파일의 이름과 위치를 정의하고 logrotate는 이러한 파일을 정기적으로 보관합니다. 로그 회전을 시작할 때 logrotate는 애플리케이션이 새 파일로 추가 출력을 보내도록해야합니다. 이는 일반적으로 &lt;code&gt;SIGHUP&lt;/code&gt; 신호를 응용 프로그램으로 전송 한 후 로그 파일을 다시 여는 &lt;code&gt;postrotate&lt;/code&gt; 스크립트로 수행 됩니다. PostgreSQL에서는 대신 &lt;code&gt;logrotate&lt;/code&gt; 옵션을 사용 하여 &lt;code&gt;pg_ctl&lt;/code&gt; 을 실행할 수 있습니다 . 서버가이 명령을 수신하면 서버는 로깅 구성에 따라 새 로그 파일로 전환하거나 기존 파일을 다시 엽니 다 (참조&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;섹션 19.8.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5b0f94e4408c19791436a634fd6c150fbb5fd164" translate="yes" xml:space="preserve">
          <source>You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example:</source>
          <target state="translated">빈 배열을 만들 수는 있지만 형식이없는 배열을 사용할 수 없으므로 빈 배열을 원하는 형식으로 명시 적으로 캐스팅해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="769ef112866ecb5c170f43630a2adb624d294a3a" translate="yes" xml:space="preserve">
          <source>You can convert an epoch value back to a time stamp with &lt;code&gt;to_timestamp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; 를 사용하여 에포크 값을 타임 스탬프로 다시 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ea1e38b69360026f2565a2133b9cc41f674fbe6" translate="yes" xml:space="preserve">
          <source>You can create a new table by specifying the table name, along with all column names and their types:</source>
          <target state="translated">모든 열 이름 및 유형과 함께 테이블 이름을 지정하여 새 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2293b489a80bd69ba669dbf459fa76acfff7a213" translate="yes" xml:space="preserve">
          <source>You can create a replication slot like this:</source>
          <target state="translated">다음과 같이 복제 슬롯을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3025b62033e69c38fff841b12fa1dec6f73605a" translate="yes" xml:space="preserve">
          <source>You can create predefined functions to avoid having to write out the result column names and types in each query. See the examples in the previous section. The underlying C function for this form of &lt;code&gt;crosstab&lt;/code&gt; is named &lt;code&gt;crosstab_hash&lt;/code&gt;.</source>
          <target state="translated">각 쿼리에서 결과 열 이름과 유형을 작성하지 않아도되도록 사전 정의 된 함수를 작성할 수 있습니다. 이전 섹션의 예를 참조하십시오. 이 형태의 &lt;code&gt;crosstab&lt;/code&gt; 대한 기본 C 함수의 이름은 &lt;code&gt;crosstab_hash&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05fb579365a5f238d0a6df67c0b79ce59d0a29c6" translate="yes" xml:space="preserve">
          <source>You can create the illusion of an updatable view by defining &lt;code&gt;ON INSERT&lt;/code&gt;, &lt;code&gt;ON UPDATE&lt;/code&gt;, and &lt;code&gt;ON DELETE&lt;/code&gt; rules (or any subset of those that's sufficient for your purposes) to replace update actions on the view with appropriate updates on other tables. If you want to support &lt;code&gt;INSERT RETURNING&lt;/code&gt; and so on, then be sure to put a suitable &lt;code&gt;RETURNING&lt;/code&gt; clause into each of these rules.</source>
          <target state="translated">&lt;code&gt;ON INSERT&lt;/code&gt; , &lt;code&gt;ON UPDATE&lt;/code&gt; 및 &lt;code&gt;ON DELETE&lt;/code&gt; 규칙 (또는 목적에 충분한 규칙 중 일부)을 정의하여 뷰의 업데이트 동작을 다른 테이블의 적절한 업데이트로 대체 하여 업데이트 가능한 뷰의 환상을 만들 수 있습니다 . &lt;code&gt;INSERT RETURNING&lt;/code&gt; 등 을 지원 하려면 각 규칙에 적절한 &lt;code&gt;RETURNING&lt;/code&gt; 절 을 넣어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0fd26f2da3bc0e528eb70dd91043a00be53f7e3" translate="yes" xml:space="preserve">
          <source>You can define a cast as an &lt;em&gt;I/O conversion cast&lt;/em&gt; by using the &lt;code&gt;WITH INOUT&lt;/code&gt; syntax. An I/O conversion cast is performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type. In many common cases, this feature avoids the need to write a separate cast function for conversion. An I/O conversion cast acts the same as a regular function-based cast; only the implementation is different.</source>
          <target state="translated">&lt;code&gt;WITH INOUT&lt;/code&gt; 구문 을 사용하여 &lt;em&gt;캐스트&lt;/em&gt; 를 &lt;em&gt;I / O 변환&lt;/em&gt; 캐스트로 정의 할 수 있습니다 . I / O 변환 캐스트는 소스 데이터 유형의 출력 함수를 호출하고 결과 문자열을 대상 데이터 유형의 입력 함수에 전달하여 수행됩니다. 많은 경우,이 기능은 변환을 위해 별도의 캐스트 함수를 작성할 필요가 없습니다. I / O 변환 캐스트는 일반 함수 기반 캐스트와 동일하게 작동합니다. 구현 만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="986b5339acb3c76e9d88ad629ad134c8af474edf" translate="yes" xml:space="preserve">
          <source>You can display tables in different ways by using the &lt;code&gt;\pset&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; 명령 을 사용하여 다른 방법으로 테이블을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16683852e12279f72c19abb8cc240108de7e38a2" translate="yes" xml:space="preserve">
          <source>You can do the same thing more verbosely with an explicitly named composite type:</source>
          <target state="translated">명시 적으로 명명 된 복합 유형을 사용하여 동일한 작업을 더 자세하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="647bf3e05906b80225fe1b4782288902652983a3" translate="yes" xml:space="preserve">
          <source>You can easily display index sizes, too:</source>
          <target state="translated">색인 크기도 쉽게 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a376faf67a062024c4f071a8c440875731b4314a" translate="yes" xml:space="preserve">
          <source>You can enter this into &lt;code&gt;psql&lt;/code&gt; with the line breaks. &lt;code&gt;psql&lt;/code&gt; will recognize that the command is not terminated until the semicolon.</source>
          <target state="translated">줄 바꿈 으로 &lt;code&gt;psql&lt;/code&gt; 에 이것을 입력 할 수 있습니다 . &lt;code&gt;psql&lt;/code&gt; 은 세미콜론까지 명령이 종료되지 않음을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="b7e2b6740f842ed6fc3ff802c0860722cdf6db76" translate="yes" xml:space="preserve">
          <source>You can even omit the schema name, in which case the schema name will be the same as the user name. See &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;Section 5.9.6&lt;/a&gt; for how this can be useful.</source>
          <target state="translated">스키마 이름을 생략 할 수도 있습니다.이 경우 스키마 이름은 사용자 이름과 동일합니다. 이것이 유용한 방법 &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;은 5.9.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc36ec902ca8c0ca398f503d160c7bcb9cae5a08" translate="yes" xml:space="preserve">
          <source>You can grant membership to other group roles, too (since there isn't really any distinction between group roles and non-group roles). The database will not let you set up circular membership loops. Also, it is not permitted to grant membership in a role to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">그룹 역할과 비 그룹 역할이 실제로 다르지 않기 때문에 다른 그룹 역할에도 멤버십을 부여 할 수 있습니다. 데이터베이스에서는 순환 멤버쉽 루프를 설정할 수 없습니다. 또한 &lt;code&gt;PUBLIC&lt;/code&gt; 에 역할의 멤버십을 부여 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1855de10627c59aa70817e07d54ec85b68d5f2a6" translate="yes" xml:space="preserve">
          <source>You can have any number of standby servers, but if you use streaming replication, make sure you set &lt;code&gt;max_wal_senders&lt;/code&gt; high enough in the primary to allow them to be connected simultaneously.</source>
          <target state="translated">대기 서버는 여러 개있을 수 있지만 스트리밍 복제를 사용하는 경우 &lt;code&gt;max_wal_senders&lt;/code&gt; 를 기본 서버에서 동시에 연결될 수 있도록 충분히 높게 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fd1cb07de1f7e656292c8ca30e0d8e6b56ad41dd" translate="yes" xml:space="preserve">
          <source>You can insert multiple rows in a single command:</source>
          <target state="translated">단일 명령으로 여러 행을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42ba202e5611e6787a856f8be8ec1439c95a1b90" translate="yes" xml:space="preserve">
          <source>You can list the columns in a different order if you wish or even omit some columns, e.g., if the precipitation is unknown:</source>
          <target state="translated">예를 들어 강수량이 알려지지 않은 경우 일부 열을 원하거나 생략하면 열을 다른 순서로 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d6ecf73216b6b457189a453d966978eb4171c2e" translate="yes" xml:space="preserve">
          <source>You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/12/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;표 9.89에&lt;/a&gt; 나열된 SQL 함수 사용, &lt;a href=&quot;https://www.postgresql.org/docs/12/oid2name.html&quot;&gt;oid2name&lt;/a&gt; 모듈 사용 또는 시스템 카탈로그의 수동 검사를 사용하여 디스크 공간을 모니터 할 수 있습니다 . SQL 기능이 가장 사용하기 쉽고 일반적으로 권장됩니다. 이 섹션의 나머지 부분에서는 시스템 카탈로그를 검사하여 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fc43586ff2149aed2e36a6059af6a439ca36056f" translate="yes" xml:space="preserve">
          <source>You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/13/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</source>
          <target state="translated">You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/13/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</target>
        </trans-unit>
        <trans-unit id="d41216c0546ef7a2b57fe5526f609434095e7579" translate="yes" xml:space="preserve">
          <source>You can reduce the width of the output by explicitly specifying which columns you want to see:</source>
          <target state="translated">보고자하는 열을 명시 적으로 지정하여 출력 너비를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8331a990fbd5bf29d20b7859a75677eec31adfb9" translate="yes" xml:space="preserve">
          <source>You can request that duplicate rows be removed from the result of a query:</source>
          <target state="translated">쿼리 결과에서 중복 행을 제거하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fcea913f233f38e0ca5df494ac39fe2b0977a56" translate="yes" xml:space="preserve">
          <source>You can request that the results of a query be returned in sorted order:</source>
          <target state="translated">쿼리 결과를 정렬 된 순서로 반환하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb5aec5733f23b6d31556d97f7864bf4f3ef3fd" translate="yes" xml:space="preserve">
          <source>You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</source>
          <target state="translated">You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt; &lt;code&gt;pg_stat_replication&lt;/code&gt; &lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</target>
        </trans-unit>
        <trans-unit id="fa31e230282587f91ce67696a7ae247357fc3c92" translate="yes" xml:space="preserve">
          <source>You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</source>
          <target state="translated">&lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; 보기 를 통해 WAL 발신자 프로세스 목록을 검색 할 수 있습니다 . &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; 과 뷰의 &lt;code&gt;sent_lsn&lt;/code&gt; 필드 사이의 큰 차이 는 마스터 서버의로드가 과도하다는 것을 나타내는 반면 대기의 &lt;code&gt;sent_lsn&lt;/code&gt; 과 &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; 의 차이 는 네트워크 지연을 나타내거나 대기의 로드가 너무 높음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8d913910be5bfeaa10ff530630e730b9ef488370" translate="yes" xml:space="preserve">
          <source>You can see all available cursors by querying the &lt;a href=&quot;view-pg-cursors&quot;&gt;&lt;code&gt;pg_cursors&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">&lt;a href=&quot;view-pg-cursors&quot;&gt; &lt;code&gt;pg_cursors&lt;/code&gt; &lt;/a&gt; 시스템 뷰를 쿼리하여 사용 가능한 모든 커서를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d1e44f9701af9c1191f1ae4aa31b23f502dc3b9" translate="yes" xml:space="preserve">
          <source>You can see all prepared statements available in the session by querying the &lt;a href=&quot;view-pg-prepared-statements&quot;&gt;&lt;code&gt;pg_prepared_statements&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">&lt;a href=&quot;view-pg-prepared-statements&quot;&gt; &lt;code&gt;pg_prepared_statements&lt;/code&gt; &lt;/a&gt; 시스템 뷰를 쿼리하여 세션에서 사용 가능한 모든 준비된 명령문을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1851e47d03f25069a58e8ba84744ebf9f76c67c" translate="yes" xml:space="preserve">
          <source>You can specify a non-default encoding at database creation time, provided that the encoding is compatible with the selected locale:</source>
          <target state="translated">인코딩이 선택한 로케일과 호환되는 경우 데이터베이스 작성시 기본이 아닌 인코딩을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="429c21ef7f32890bc18b9fd73f1ebb90743874ca" translate="yes" xml:space="preserve">
          <source>You can unlisten something you were not listening for; no warning or error will appear.</source>
          <target state="translated">당신이 듣지 않은 것을 들으실 수 있습니다. 경고 나 오류가 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f0825c19fa74c86ea4fde39915a5f442a1301c8" translate="yes" xml:space="preserve">
          <source>You can update existing rows using the &lt;code&gt;UPDATE&lt;/code&gt; command. Suppose you discover the temperature readings are all off by 2 degrees after November 28. You can correct the data as follows:</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; 명령을 사용하여 기존 행을 업데이트 할 수 있습니다 . 11 월 28 일 이후 온도 측정 값이 모두 2 도씩 벗어났다는 것을 발견했다고 가정합니다. 다음과 같이 데이터를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d9d610480d842b7b4dae95f084d8c480dea21a" translate="yes" xml:space="preserve">
          <source>You can update more than one column in an &lt;code&gt;UPDATE&lt;/code&gt; command by listing more than one assignment in the &lt;code&gt;SET&lt;/code&gt; clause. For example:</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 절 에 둘 이상의 할당을 나열 하여 &lt;code&gt;UPDATE&lt;/code&gt; 명령 에서 둘 이상의 열을 업데이트 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afbd81cf7abf6e1ee5aed73e857469d9b19d9be7" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_restore -j&lt;/code&gt; to restore a dump in parallel. This will work for any archive of either the &quot;custom&quot; or the &quot;directory&quot; archive mode, whether or not it has been created with &lt;code&gt;pg_dump -j&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_restore -j&lt;/code&gt; 를 사용 하여 덤프를 병렬로 복원 할 수 있습니다 . 이것은 &lt;code&gt;pg_dump -j&lt;/code&gt; 로 작성되었는지 여부에 관계없이 &quot;custom&quot;또는 &quot;directory&quot;아카이브 모드의 모든 아카이브에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e548ce622037cda7095c1bcbf3f92886d139cb4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from a &lt;code&gt;pg_lsn&lt;/code&gt; value. For example:</source>
          <target state="translated">You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from a &lt;code&gt;pg_lsn&lt;/code&gt; value. For example:</target>
        </trans-unit>
        <trans-unit id="7b820c01225164f2d5b985f5de0dcbc0100e250a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from the results of any of the above functions. For example:</source>
          <target state="translated">&lt;code&gt;pg_walfile_name_offset&lt;/code&gt; 을 사용 하여 위의 함수 결과에서 해당 미리 쓰기 로그 파일 이름과 바이트 오프셋을 추출 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c69d101f435a1744fb1dd6c3be27758cb46e4777" translate="yes" xml:space="preserve">
          <source>You can use data-modifying statements (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;) in &lt;code&gt;WITH&lt;/code&gt;. This allows you to perform several different operations in the same query. An example is:</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 에서 데이터 수정 명령문 ( &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; )을 사용할 수 있습니다 . 이를 통해 동일한 쿼리에서 여러 가지 다른 작업을 수행 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ab93f9848617cd1c9b0e1e4c6fbe5e015dc7f2a" translate="yes" xml:space="preserve">
          <source>You can use several filter expressions in sequence, if required. For example, the following expression selects start times of all segments that contain locations with relevant coordinates and high heart rate values:</source>
          <target state="translated">You can use several filter expressions in sequence, if required. For example, the following expression selects start times of all segments that contain locations with relevant coordinates and high heart rate values:</target>
        </trans-unit>
        <trans-unit id="4aecc1927f70a57ed9583d45287b1db5300bd7af" translate="yes" xml:space="preserve">
          <source>You can use several filter expressions on the same nesting level, if required. For example, the following expression selects all segments that contain locations with relevant coordinates and high heart rate values:</source>
          <target state="translated">필요한 경우 동일한 중첩 수준에서 여러 필터 표현식을 사용할 수 있습니다. 예를 들어 다음 식은 관련 좌표와 높은 심박수 값을 가진 위치가 포함 된 모든 세그먼트를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="cfeaa68d3d1e02bb6f35ba750e012709276d477e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;btree-gist&quot;&gt;&lt;code&gt;btree_gist&lt;/code&gt;&lt;/a&gt; extension to define exclusion constraints on plain scalar data types, which can then be combined with range exclusions for maximum flexibility. For example, after &lt;code&gt;btree_gist&lt;/code&gt; is installed, the following constraint will reject overlapping ranges only if the meeting room numbers are equal:</source>
          <target state="translated">&lt;a href=&quot;btree-gist&quot;&gt; &lt;code&gt;btree_gist&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 일반 스칼라 데이터 유형에 대한 제외 제약 조건을 정의한 다음 최대한의 유연성을 위해 범위 제외와 결합 할 수 있습니다. 예를 들어, &lt;code&gt;btree_gist&lt;/code&gt; 가 설치된 후 다음 제한 조건은 미팅 룸 번호가 동일한 경우에만 겹치는 범위를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="002e817c446bf19265c623a41f235f06765b50f1" translate="yes" xml:space="preserve">
          <source>You can verify what the command will do using rsync's &lt;code&gt;--dry-run&lt;/code&gt; option. While rsync must be run on the primary for at least one standby, it is possible to run rsync on an upgraded standby to upgrade other standbys, as long as the upgraded standby has not been started.</source>
          <target state="translated">rsync의 &lt;code&gt;--dry-run&lt;/code&gt; 옵션을 사용하여 명령이 수행 할 작업을 확인할 수 있습니다 . 하나 이상의 대기에 대해 기본에서 rsync를 실행해야하지만 업그레이드 된 대기가 시작되지 않은 경우 업그레이드 된 대기에서 rsync를 실행하여 다른 대기를 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d48e271b4c23101cd376b3231b8d00d43b6839" translate="yes" xml:space="preserve">
          <source>You can write expressions, not just simple column references, in the select list. For example, you can do:</source>
          <target state="translated">선택 목록에서 단순한 열 참조뿐만 아니라 표현식을 작성할 수 있습니다. 예를 들어 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b204489972744de11c0eeded07bbc813914aafd" translate="yes" xml:space="preserve">
          <source>You can:</source>
          <target state="translated">당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="de82188f9fe7e2d788196205280b0985f84081cc" translate="yes" xml:space="preserve">
          <source>You cannot drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint on a partition's column if the constraint is present in the parent table.</source>
          <target state="translated">제약 조건이 부모 테이블에 있으면 파티션의 열에 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건을 삭제할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="093c2a9d5eef8843d884253372bdbca71ca3f136" translate="yes" xml:space="preserve">
          <source>You cannot execute the &lt;code&gt;DROP DATABASE&lt;/code&gt; command while connected to the victim database. You can, however, be connected to any other database, including the &lt;code&gt;template1&lt;/code&gt; database. &lt;code&gt;template1&lt;/code&gt; would be the only option for dropping the last user database of a given cluster.</source>
          <target state="translated">대상 데이터베이스에 연결되어있는 동안 &lt;code&gt;DROP DATABASE&lt;/code&gt; 명령을 실행할 수 없습니다 . 그러나 &lt;code&gt;template1&lt;/code&gt; 데이터베이스를 포함한 다른 데이터베이스에 연결할 수 있습니다 . &lt;code&gt;template1&lt;/code&gt; 은 주어진 클러스터의 마지막 사용자 데이터베이스를 삭제하는 유일한 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="7a936475d5b2fe8219655a01b86bcd035950ef3f" translate="yes" xml:space="preserve">
          <source>You could also have set up port forwarding as</source>
          <target state="translated">You could also have set up port forwarding as</target>
        </trans-unit>
        <trans-unit id="b8854264af301815bd4c143e497bc4039dd4ee05" translate="yes" xml:space="preserve">
          <source>You could also have set up the port forwarding as</source>
          <target state="translated">포트 포워딩을 다음과 같이 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="00192154b86c5479e232f9339dfec14280fa9591" translate="yes" xml:space="preserve">
          <source>You could also have used &lt;code&gt;COPY&lt;/code&gt; to load large amounts of data from flat-text files. This is usually faster because the &lt;code&gt;COPY&lt;/code&gt; command is optimized for this application while allowing less flexibility than &lt;code&gt;INSERT&lt;/code&gt;. An example would be:</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 를 사용 하여 플랫 텍스트 파일에서 많은 양의 데이터를로드 할 수도 있습니다 . &lt;code&gt;COPY&lt;/code&gt; 명령이 &lt;code&gt;INSERT&lt;/code&gt; 보다 유연성이 떨어지지 만이 응용 프로그램에 최적화되어 있기 때문에 일반적으로 더 빠릅니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db5bb918efb1956e14366be6e4e8492955095b0f" translate="yes" xml:space="preserve">
          <source>You do not need to constrain the join order completely in order to cut search time, because it's OK to use &lt;code&gt;JOIN&lt;/code&gt; operators within items of a plain &lt;code&gt;FROM&lt;/code&gt; list. For example, consider:</source>
          <target state="translated">일반 &lt;code&gt;FROM&lt;/code&gt; 목록의 항목 내에서 &lt;code&gt;JOIN&lt;/code&gt; 연산자 를 사용해도되므로 검색 시간을 줄이기 위해 조인 순서를 완전히 제한 할 필요는 없습니다 . 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cb9759ceb3a93faeeed42501a60a856539a7fb24" translate="yes" xml:space="preserve">
          <source>You do not want to use the third form when specifying a &lt;code&gt;DEFAULT&lt;/code&gt; clause while creating a table. The system will convert &lt;code&gt;now&lt;/code&gt; to a &lt;code&gt;timestamp&lt;/code&gt; as soon as the constant is parsed, so that when the default value is needed, the time of the table creation would be used! The first two forms will not be evaluated until the default value is used, because they are function calls. Thus they will give the desired behavior of defaulting to the time of row insertion.</source>
          <target state="translated">테이블을 작성하는 동안 &lt;code&gt;DEFAULT&lt;/code&gt; 절을 지정할 때 세 번째 양식을 사용하지 않으려 고합니다. 이 시스템은 변환됩니다 &lt;code&gt;now&lt;/code&gt; A를 &lt;code&gt;timestamp&lt;/code&gt; 즉시 상수가 구문 분석으로, 그래서 디폴트 값이 필요할 때, 테이블 작성시 사용되는 것! 처음 두 양식은 함수 호출이므로 기본값을 사용할 때까지 평가되지 않습니다. 따라서 원하는 행 삽입 시간으로 기본 설정 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="82ae0883f7a2deb13919a7b51525df4e84881170" translate="yes" xml:space="preserve">
          <source>You have altered a storage parameter (such as fillfactor) for an index, and wish to ensure that the change has taken full effect.</source>
          <target state="translated">색인에 대한 스토리지 매개 변수 (예 : fillfactor)를 변경했으며 변경 사항이 완전히 적용되도록하려고합니다.</target>
        </trans-unit>
        <trans-unit id="9105126c4b98c9abf43cead14144e7c73642eea6" translate="yes" xml:space="preserve">
          <source>You have to adapt &lt;code&gt;compressed_data_type&lt;/code&gt; to the specific type you're converting to in order to compress your leaf nodes, of course.</source>
          <target state="translated">리프 노드를 압축하려면 압축 된 특정 유형에 &lt;code&gt;compressed_data_type&lt;/code&gt; _ 데이터 _ 유형 을 적용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c6ec9a715c152149c664d288cf7e25e03ec9494f" translate="yes" xml:space="preserve">
          <source>You may decide to use multiple columns in the partition key for range partitioning, if desired. Of course, this will often result in a larger number of partitions, each of which is individually smaller. On the other hand, using fewer columns may lead to a coarser-grained partitioning criteria with smaller number of partitions. A query accessing the partitioned table will have to scan fewer partitions if the conditions involve some or all of these columns. For example, consider a table range partitioned using columns &lt;code&gt;lastname&lt;/code&gt; and &lt;code&gt;firstname&lt;/code&gt; (in that order) as the partition key.</source>
          <target state="translated">원하는 경우 범위 파티셔닝을 위해 파티션 키에 여러 열을 사용하기로 결정할 수 있습니다. 물론, 이것은 종종 더 많은 수의 파티션을 만들며, 각 파티션은 개별적으로 더 작습니다. 반면, 더 적은 수의 열을 사용하면 더 적은 수의 파티션으로 더 세분화 된 파티셔닝 기준으로 이어질 수 있습니다. 조건이 이러한 열 중 일부 또는 전부를 포함하는 경우 파티션 된 테이블에 액세스하는 쿼리는 더 적은 파티션을 스캔해야합니다. 예를 들어, &lt;code&gt;lastname&lt;/code&gt; 및 &lt;code&gt;firstname&lt;/code&gt; 열을 파티션 키로 사용하여 파티션 된 테이블 범위를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf47ba3690a812065d027e7932a77588e377659a" translate="yes" xml:space="preserve">
          <source>You might also want to configure your kernel to lock System V shared memory into RAM and prevent it from being paged out to swap. This can be accomplished using the &lt;code&gt;sysctl&lt;/code&gt; setting &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt;.</source>
          <target state="translated">System V 공유 메모리를 RAM에 잠그고 스왑을 위해 페이지 아웃되지 않도록 커널을 구성 할 수도 있습니다. 이것은 &lt;code&gt;sysctl&lt;/code&gt; 설정 &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt; 를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a62a7a5cf401923b709acdb0497028fe1fd4d2f" translate="yes" xml:space="preserve">
          <source>You might be tempted to create a large set of non-overlapping partial indexes, for example</source>
          <target state="translated">You might be tempted to create a large set of non-overlapping partial indexes, for example</target>
        </trans-unit>
        <trans-unit id="118dd6812b30292a1fcd4d319831dc8ec3a9335e" translate="yes" xml:space="preserve">
          <source>You might instead use this approach to naming the files descriptively:</source>
          <target state="translated">대신이 접근 방식을 사용하여 파일 이름을 설명 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="149e9ef120e49f8ae119951c604cd065ab893c33" translate="yes" xml:space="preserve">
          <source>You might prefer to remove the &lt;code&gt;sepgsql-regtest&lt;/code&gt; policy entirely:</source>
          <target state="translated">&lt;code&gt;sepgsql-regtest&lt;/code&gt; 정책을 완전히 제거하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a34411202b4ded0e9449c6d67415d0bad4541f5b" translate="yes" xml:space="preserve">
          <source>You might reasonably ask why there is an &lt;code&gt;ELEMENT&lt;/code&gt; option, if the system makes the correct array type automatically. The only case where it's useful to use &lt;code&gt;ELEMENT&lt;/code&gt; is when you are making a fixed-length type that happens to be internally an array of a number of identical things, and you want to allow these things to be accessed directly by subscripting, in addition to whatever operations you plan to provide for the type as a whole. For example, type &lt;code&gt;point&lt;/code&gt; is represented as just two floating-point numbers, which can be accessed using &lt;code&gt;point[0]&lt;/code&gt; and &lt;code&gt;point[1]&lt;/code&gt;. Note that this facility only works for fixed-length types whose internal form is exactly a sequence of identical fixed-length fields. A subscriptable variable-length type must have the generalized internal representation used by &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. For historical reasons (i.e., this is clearly wrong but it's far too late to change it), subscripting of fixed-length array types starts from zero, rather than from one as for variable-length arrays.</source>
          <target state="translated">시스템이 올바른 배열 유형을 자동으로 만드는 경우 &lt;code&gt;ELEMENT&lt;/code&gt; 옵션 이있는 이유를 합리적으로 묻습니다 . &lt;code&gt;ELEMENT&lt;/code&gt; 를 사용하는 것이 유용한 유일한 경우 는 내부에 여러 가지 동일한 것들로 구성된 고정 길이 유형을 만들고 첨자에 의해 이러한 것들에 직접 액세스하도록 허용하는 경우입니다. 유형 전체에 제공하려는 모든 작업 예를 들어, 유형 &lt;code&gt;point&lt;/code&gt; 는 두 개의 부동 소수점 숫자로 표시되며 다음을 사용하여 액세스 할 수 있습니다. &lt;code&gt;point[0]&lt;/code&gt; 및 &lt;code&gt;point[1]&lt;/code&gt; . 이 기능은 내부 형식이 정확히 동일한 고정 길이 필드의 시퀀스 인 고정 길이 유형에만 작동합니다. 아래 첨자 가변 길이 유형에는 &lt;code&gt;array_in&lt;/code&gt; 및 &lt;code&gt;array_out&lt;/code&gt; 에서 사용하는 일반화 된 내부 표현이 있어야합니다 . 역사적 이유로 (즉, 이것은 분명히 잘못되었지만 변경하기에는 너무 늦습니다) 고정 길이 배열 유형의 첨자는 가변 길이 배열의 경우가 아니라 0부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e76fa113e33e26d7d8bdc7061b1bdc78af7c35cf" translate="yes" xml:space="preserve">
          <source>You might want to reset &lt;code&gt;parallel_workers&lt;/code&gt; after setting it as part of tuning an index build. This avoids inadvertent changes to query plans, since &lt;code&gt;parallel_workers&lt;/code&gt; affects &lt;em&gt;all&lt;/em&gt; parallel table scans.</source>
          <target state="translated">인덱스 빌드 튜닝의 일부로 &lt;code&gt;parallel_workers&lt;/code&gt; 를 설정 한 후 재설정 할 수 있습니다 . 이는 &lt;code&gt;parallel_workers&lt;/code&gt; 가&lt;em&gt;모든&lt;/em&gt; 병렬 테이블 스캔에 영향을주기 때문에 쿼리 계획에 대한 실수로 인한 변경을 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="16c3ec0adfcebb8df4d8276a101b477163d7255e" translate="yes" xml:space="preserve">
          <source>You might wonder why bother providing all four options, when two options together with the possibility of backward scan would cover all the variants of &lt;code&gt;ORDER BY&lt;/code&gt;. In single-column indexes the options are indeed redundant, but in multicolumn indexes they can be useful. Consider a two-column index on &lt;code&gt;(x, y)&lt;/code&gt;: this can satisfy &lt;code&gt;ORDER BY x, y&lt;/code&gt; if we scan forward, or &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; if we scan backward. But it might be that the application frequently needs to use &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;. There is no way to get that ordering from a plain index, but it is possible if the index is defined as &lt;code&gt;(x ASC, y DESC)&lt;/code&gt; or &lt;code&gt;(x DESC, y ASC)&lt;/code&gt;.</source>
          <target state="translated">역방향 스캔 가능성과 함께 두 가지 옵션이 &lt;code&gt;ORDER BY&lt;/code&gt; 의 모든 변형을 포함 할 때 왜 네 가지 옵션을 모두 제공해야하는지 궁금 할 것 입니다. 단일 열 인덱스에서는 옵션이 실제로 중복되지만 다중 열 인덱스에서는 유용 할 수 있습니다. &lt;code&gt;(x, y)&lt;/code&gt; 에 대한 2 열 색인을 고려하십시오. 스캔 할 경우 &lt;code&gt;ORDER BY x, y&lt;/code&gt; , 또는 스캔 할 경우 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; 만족시킬 수 있습니다 . 그러나 응용 프로그램에서 &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; 를 자주 사용해야 할 수도 있습니다 . 일반 인덱스에서 순서를 얻는 방법은 없지만 인덱스가 &lt;code&gt;(x ASC, y DESC)&lt;/code&gt; 또는 &lt;code&gt;(x DESC, y ASC)&lt;/code&gt; 로 정의 된 경우 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="a96b7a75456662c5aa3c61f0b2bf6c8181936405" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="translated">&lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 를 사용하려면 수퍼 유저 여야합니다 . (이 제한은 잘못된 운영자 패밀리 정의가 서버를 혼란 시키거나 충돌시킬 수 있기 때문에 작성됩니다.)</target>
        </trans-unit>
        <trans-unit id="f2c54ba09d5b62548914418dced24b83c29f8192" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; 를 사용하려면 수퍼 유저 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b1c6e4d091898d0c808adc78af3decbefdf7c390" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; 를 사용하려면 수퍼 유저 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="4112b2d8f8d95b2e2b447d1ab817d0a272e11d27" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt;. (This restriction is made because an erroneous text search parser definition could confuse or even crash the server.)</source>
          <target state="translated">&lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; 를 사용하려면 수퍼 유저 여야합니다 . (이 제한은 잘못된 텍스트 검색 파서 정의가 서버를 혼란 시키거나 충돌시킬 수 있기 때문에 만들어졌습니다.)</target>
        </trans-unit>
        <trans-unit id="6ab7f85ecb54195b79adfabb967e5f95ee6fb3b3" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt;. This restriction is made because an erroneous text search template definition could confuse or even crash the server. The reason for separating templates from dictionaries is that a template encapsulates the &amp;ldquo;unsafe&amp;rdquo; aspects of defining a dictionary. The parameters that can be set when defining a dictionary are safe for unprivileged users to set, and so creating a dictionary need not be a privileged operation.</source>
          <target state="translated">&lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; 를 사용하려면 수퍼 유저 여야합니다 . 잘못된 텍스트 검색 템플릿 정의로 인해 서버가 혼동되거나 충돌 할 수 있기 때문에 이러한 제한 사항이 적용됩니다. 템플릿을 사전과 분리하는 이유는 템플릿이 사전 정의의 &quot;안전하지 않은&quot;측면을 캡슐화하기 때문입니다. 사전을 정의 할 때 설정할 수있는 매개 변수는 권한이없는 사용자가 설정하기에 안전하므로 사전을 작성하는 것이 특권 조작 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d6ba0fbc9ee76ec30e6a734cc139602ed5f74a38" translate="yes" xml:space="preserve">
          <source>You must be superuser to alter an event trigger.</source>
          <target state="translated">이벤트 트리거를 변경하려면 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d2778f188a2bae6cf3e02c68a508357eae34c9bc" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create a statistics object reading it. Once created, however, the ownership of the statistics object is independent of the underlying table(s).</source>
          <target state="translated">테이블을 읽는 통계 오브젝트를 작성하려면 테이블의 소유자 여야합니다. 그러나 일단 작성된 통계 오브젝트의 소유권은 기본 테이블과 무관합니다.</target>
        </trans-unit>
        <trans-unit id="b18eb66aae7b37aaff80a2a943d09edee67a5cd6" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create or change policies for it.</source>
          <target state="translated">정책을 작성하거나 변경하려면 테이블의 소유자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="dd98593a661bbd8265aa519e6846bcf6a1a65a93" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create or change rules for it.</source>
          <target state="translated">규칙을 작성하거나 변경하려면 테이블의 소유자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="fb2285ad531d2e07d6d7c86c0203500d7139806c" translate="yes" xml:space="preserve">
          <source>You must be the owner of the configuration to use &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; 을 사용하려면 구성 소유자 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="90b9a22d759305d6fe1fa47e1f5ffd11756e94a9" translate="yes" xml:space="preserve">
          <source>You must be the owner of the dictionary to use &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; 를 사용하려면 사전의 소유자 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="1e259c4dd1968568dc3fb80e1b6efb5689d6bdb9" translate="yes" xml:space="preserve">
          <source>You must have &lt;code&gt;INSERT&lt;/code&gt; privilege on a table in order to insert into it. If &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is present, &lt;code&gt;UPDATE&lt;/code&gt; privilege on the table is also required.</source>
          <target state="translated">테이블에 삽입하려면 테이블에 대한 &lt;code&gt;INSERT&lt;/code&gt; 특권 이 있어야 합니다. 경우 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 가 존재, &lt;code&gt;UPDATE&lt;/code&gt; 의 테이블에 권한도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bb31803ee937f757ae783b41d67981c9d86f3e9e" translate="yes" xml:space="preserve">
          <source>You must have &lt;code&gt;SELECT&lt;/code&gt; privilege on each column used in a &lt;code&gt;SELECT&lt;/code&gt; command. The use of &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; or &lt;code&gt;FOR KEY SHARE&lt;/code&gt; requires &lt;code&gt;UPDATE&lt;/code&gt; privilege as well (for at least one column of each table so selected).</source>
          <target state="translated">당신은 있어야합니다 &lt;code&gt;SELECT&lt;/code&gt; 의 (A)에 사용되는 각 컬럼에 권한을 &lt;code&gt;SELECT&lt;/code&gt; 명령에 . 사용 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;FOR UPDATE&lt;/code&gt; , &lt;code&gt;FOR SHARE&lt;/code&gt; 또는 &lt;code&gt;FOR KEY SHARE&lt;/code&gt; 필요 &lt;code&gt;UPDATE&lt;/code&gt; (각 표 중 적어도 하나 개의 칼럼에 대해 매우 선택)과 특권.</target>
        </trans-unit>
        <trans-unit id="d02911fbcb07608d5d71771e387bdf240b881b98" translate="yes" xml:space="preserve">
          <source>You must have select privilege on the table whose values are read by &lt;code&gt;COPY TO&lt;/code&gt;, and insert privilege on the table into which values are inserted by &lt;code&gt;COPY FROM&lt;/code&gt;. It is sufficient to have column privileges on the column(s) listed in the command.</source>
          <target state="translated">&lt;code&gt;COPY TO&lt;/code&gt; 로 값을 읽는 테이블에 대한 선택 특권이 있어야 하며 &lt;code&gt;COPY FROM&lt;/code&gt; 에 의해 값이 삽입되는 테이블에 대한 특권을 삽입해야합니다 . 명령에 나열된 열에 대한 열 권한이 있으면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="f7e79121fed35518353fce9ebea22091560488e8" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;DELETE&lt;/code&gt; privilege on the table to delete from it, as well as the &lt;code&gt;SELECT&lt;/code&gt; privilege for any table in the &lt;code&gt;USING&lt;/code&gt; clause or whose values are read in the &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">당신은 있어야합니다 &lt;code&gt;DELETE&lt;/code&gt; &lt;code&gt;USING&lt;/code&gt; 절 에있는 테이블에 대한 &lt;code&gt;SELECT&lt;/code&gt; 특권 뿐만 아니라 &lt;code&gt;condition&lt;/code&gt; 에서 값을 읽는 테이블에 대해 삭제하려면 테이블에 DELETE 특권 .</target>
        </trans-unit>
        <trans-unit id="4a1c02ef145014df727c0bbfa9c3ff89cf785dd1" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;TRUNCATE&lt;/code&gt; privilege on a table to truncate it.</source>
          <target state="translated">테이블을 자르려면 테이블에 대한 &lt;code&gt;TRUNCATE&lt;/code&gt; 권한 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="77a7a29185db04a6a9d2e4452098a88fd3c7b7ea" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;UPDATE&lt;/code&gt; privilege on the table, or at least on the column(s) that are listed to be updated. You must also have the &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;expressions&lt;/code&gt; or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; 가 있어야합니다테이블 또는 최소한 갱신 대상으로 나열된 컬럼에 특권 . 또한 &lt;code&gt;expressions&lt;/code&gt; 이나 &lt;code&gt;condition&lt;/code&gt; 에서 값을 읽는 모든 열에 대해 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d6be4ee2e09272568e1f74da88776799e39f34a3" translate="yes" xml:space="preserve">
          <source>You must own the aggregate function to use &lt;code&gt;ALTER AGGREGATE&lt;/code&gt;. To change the schema of an aggregate function, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the aggregate function's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the aggregate function. However, a superuser can alter ownership of any aggregate function anyway.)</source>
          <target state="translated">사용할 집계 함수를 소유해야합니다. &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; . 집계 함수의 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 집계 함수의 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한 사항은 집계 함수를 삭제하고 다시 생성하여 소유자를 변경해도 수행 할 수없는 작업은 수행하지 않지만 수퍼 유저는 어쨌든 집계 함수의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a5408e4e6a9f4b7999bf20809f4af3f8dff4cea5" translate="yes" xml:space="preserve">
          <source>You must own the collation to use &lt;code&gt;ALTER COLLATION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the collation's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the collation. However, a superuser can alter ownership of any collation anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER COLLATION&lt;/code&gt; 을 사용하려면 데이터 정렬을 소유해야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 데이터 정렬 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . 이러한 제한으로 인해 소유자를 변경하면 데이터 정렬을 삭제하고 다시 생성하여 수행 할 수없는 작업이 수행되지 않습니다. 그러나 수퍼 유저는 데이터 정렬의 소유권을 어쨌든 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3b0175f69dcf313a89dcb0b18357a030f315c24" translate="yes" xml:space="preserve">
          <source>You must own the conversion to use &lt;code&gt;ALTER CONVERSION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the conversion's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the conversion. However, a superuser can alter ownership of any conversion anyway.)</source>
          <target state="translated">사용하려면 전환을 소유해야합니다 &lt;code&gt;ALTER CONVERSION&lt;/code&gt; . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 변환 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 소유자를 변경해도 전환을 삭제하고 다시 만들어서 할 수 없었던 작업을 수행 할 수는 없지만 수퍼 유저는 전환의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b3c900b3d4c912ff5e4ebc53ea79d5d20107d085" translate="yes" xml:space="preserve">
          <source>You must own the domain to use &lt;code&gt;ALTER DOMAIN&lt;/code&gt;. To change the schema of a domain, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the domain's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the domain. However, a superuser can alter ownership of any domain anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER DOMAIN&lt;/code&gt; 을 사용하려면 도메인을 소유해야합니다 . 도메인의 스키마를 변경하려면 &lt;code&gt;CREATE&lt;/code&gt; 도 있어야합니다. 새 스키마에 대한 권한 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에 도메인 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한은 소유자를 변경해도 도메인을 삭제하고 다시 생성하여 수행 할 수없는 작업을 수행하지 않도록합니다. 그러나 수퍼 유저는 도메인의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="cb1bc5a4738dcb26a0f29902f3cbbe388057acc0" translate="yes" xml:space="preserve">
          <source>You must own the extension to use &lt;code&gt;ALTER EXTENSION&lt;/code&gt;. The &lt;code&gt;ADD&lt;/code&gt;/&lt;code&gt;DROP&lt;/code&gt; forms require ownership of the added/dropped object as well.</source>
          <target state="translated">&lt;code&gt;ALTER EXTENSION&lt;/code&gt; 을 사용하려면 확장을 소유해야합니다 . &lt;code&gt;ADD&lt;/code&gt; / &lt;code&gt;DROP&lt;/code&gt; 의 양식은 추가 / 감소 개체의 소유권뿐만 아니라 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a6dffb3cd3b426a1dfeb4f3d4a34d04b92502381" translate="yes" xml:space="preserve">
          <source>You must own the extension to use &lt;code&gt;DROP EXTENSION&lt;/code&gt;.</source>
          <target state="translated">사용하려면 확장 프로그램을 소유해야합니다 &lt;code&gt;DROP EXTENSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9424f801bf04776e94b23d25a246b419d9f806fc" translate="yes" xml:space="preserve">
          <source>You must own the function to use &lt;code&gt;ALTER FUNCTION&lt;/code&gt;. To change a function's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the function's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the function. However, a superuser can alter ownership of any function anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER FUNCTION&lt;/code&gt; 을 사용하려면 함수를 소유해야합니다 . 함수 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할이 있어야합니다. &lt;code&gt;CREATE&lt;/code&gt; 에는 함수 스키마에 대한 CREATE 권한이 . (이러한 제한으로 인해 소유자를 변경해도 함수를 삭제하고 다시 생성하여 수행 할 수없는 작업이 수행되지 않습니다. 그러나 수퍼 유저는 어쨌든 모든 기능의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2c5eaf93b84b8e16b7b4075e87568743bd5c26dc" translate="yes" xml:space="preserve">
          <source>You must own the large object to use &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. (However, a superuser can alter any large object anyway.) Currently, the only functionality is to assign a new owner, so both restrictions always apply.</source>
          <target state="translated">&lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; 를 사용하려면 큰 객체를 소유해야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야합니다. (그러나 수퍼 유저는 어쨌든 큰 개체를 변경할 수 있습니다.) 현재 유일한 기능은 새 소유자를 할당하는 것이므로 두 제한이 항상 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c749af14eff465f32f3ae73b6015d4eb8f90f209" translate="yes" xml:space="preserve">
          <source>You must own the materialized view to use &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt;. To change a materialized view's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the materialized view's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the materialized view. However, a superuser can alter ownership of any view anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; 를 사용하려면 구체화 된 뷰를 소유해야합니다 . 구체화 된 뷰의 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 구체화 된보기의 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 구체화 된 뷰를 삭제하고 다시 생성하여 소유자를 변경해도 수행 할 수없는 작업이 수행되지 않지만 수퍼 유저는 뷰의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="c551fec90f0914ad71d1aabc9e18e3244b6d6bf8" translate="yes" xml:space="preserve">
          <source>You must own the operator class to use &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the operator class's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the operator class. However, a superuser can alter ownership of any operator class anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; 를 사용하려면 연산자 클래스를 소유해야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 운영자 클래스의 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 소유자를 변경하면 운영자 클래스를 삭제하고 다시 생성하여 수행 할 수없는 작업이 수행되지 않지만 수퍼 유저는 운영자 클래스의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="289cb9ff5358010db129ab37edd147b9711820ba" translate="yes" xml:space="preserve">
          <source>You must own the operator to use &lt;code&gt;ALTER OPERATOR&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the operator's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the operator. However, a superuser can alter ownership of any operator anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER OPERATOR&lt;/code&gt; 를 사용하려면 운영자를 소유해야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 운영자 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한 사항은 운영자를 삭제하고 다시 생성하여 소유자를 변경해도 수행 할 수없는 작업은 수행하지 않지만 수퍼 유저는 운영자의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="aa32bd3d71baaa7969581d0d0f33bf13710aaa54" translate="yes" xml:space="preserve">
          <source>You must own the procedure to use &lt;code&gt;ALTER PROCEDURE&lt;/code&gt;. To change a procedure's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the procedure's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the procedure. However, a superuser can alter ownership of any procedure anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 를 사용하려면 절차를 소유해야합니다 . 프로 시저 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 프로 시저 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 소유자를 변경해도 절차를 삭제하고 다시 생성하여 수행 할 수 없었던 작업을 수행 할 수 없지만 수퍼 유저는 절차의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8c5dd2c9f09fa4613a78c896a4d8ff93764043b0" translate="yes" xml:space="preserve">
          <source>You must own the publication to use &lt;code&gt;ALTER PUBLICATION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. The new owner must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the database. Also, the new owner of a &lt;code&gt;FOR ALL TABLES&lt;/code&gt; publication must be a superuser. However, a superuser can change the ownership of a publication while circumventing these restrictions.</source>
          <target state="translated">&lt;code&gt;ALTER PUBLICATION&lt;/code&gt; 을 사용하려면 발행물을 소유해야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야합니다. 새 소유자에게는 데이터베이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다. 또한 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 발행물 의 새 소유자 는 수퍼 유저 여야합니다. 그러나 수퍼 유저는 이러한 제한을 피하면서 게시의 소유권을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ebd09d1ba00b2c43b82e29c8fd88f155f0cc3ea" translate="yes" xml:space="preserve">
          <source>You must own the schema to use &lt;code&gt;ALTER SCHEMA&lt;/code&gt;. To rename a schema you must also have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the database. To alter the owner, you must also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the database. (Note that superusers have all these privileges automatically.)</source>
          <target state="translated">&lt;code&gt;ALTER SCHEMA&lt;/code&gt; 를 사용하려면 스키마를 소유해야합니다 . 스키마의 이름을 바꾸려면 데이터베이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야 합니다. 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야 하며 데이터베이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다. (수퍼 유저에게는 이러한 모든 권한이 자동으로 부여됩니다.)</target>
        </trans-unit>
        <trans-unit id="06321f48b26cbb2ac459fd0a6dc711be8eab0c9e" translate="yes" xml:space="preserve">
          <source>You must own the sequence to use &lt;code&gt;ALTER SEQUENCE&lt;/code&gt;. To change a sequence's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the sequence's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the sequence. However, a superuser can alter ownership of any sequence anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER SEQUENCE&lt;/code&gt; 를 사용하려면 시퀀스를 소유해야합니다 . 시퀀스 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 시퀀스 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 소유자를 변경해도 시퀀스를 삭제하고 다시 생성하여 수행 할 수 없었던 작업을 수행 할 수 없지만 수퍼 유저는 시퀀스의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="43effe8f1154a0915e8a351241bc95aed6ecd629" translate="yes" xml:space="preserve">
          <source>You must own the statistics object to use &lt;code&gt;ALTER STATISTICS&lt;/code&gt;. To change a statistics object's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the statistics object's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the statistics object. However, a superuser can alter ownership of any statistics object anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER STATISTICS&lt;/code&gt; 를 사용하려면 통계 오브젝트를 소유해야합니다 . 통계 개체의 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에 통계 개체의 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 소유자를 변경해도 통계 개체를 삭제하고 다시 생성하여 수행 할 수없는 작업이 수행되지 않지만 수퍼 유저는 통계 개체의 소유권을 어쨌든 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="407b57125ead1fe2313dbe8d95fd59c9276cf527" translate="yes" xml:space="preserve">
          <source>You must own the subscription to use &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. The new owner has to be a superuser. (Currently, all subscription owners must be superusers, so the owner checks will be bypassed in practice. But this might change in the future.)</source>
          <target state="translated">&lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; 을 사용하려면 구독을 소유해야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야합니다. 새로운 소유자는 수퍼 유저 여야합니다. (현재 모든 구독 소유자는 수퍼 유저 여야합니다. 따라서 실제로는 소유자 확인을 우회하지만 앞으로 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="fcf405f07e7e1cd6574b23914c55360281a218b4" translate="yes" xml:space="preserve">
          <source>You must own the table on which the trigger acts to be allowed to change its properties.</source>
          <target state="translated">트리거가 특성 변경을 허용하는 테이블을 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3ea6ee180cd5e6ed5b2a16c0c2bbd450f2133e6" translate="yes" xml:space="preserve">
          <source>You must own the table to use &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt;. To change the schema of a foreign table, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">&lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; 을 사용하려면 테이블을 소유해야합니다 . 외부 테이블의 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에 테이블 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 소유자를 변경해도 테이블을 삭제하고 다시 생성하여 수행 할 수없는 작업을 수행 할 수 없습니다. 그러나 수퍼 유저는 테이블의 소유권을 어쨌든 변경할 수 있습니다.) 열을 추가하거나 열 유형을 변경하려면 데이터 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ec11d641723946e6db98f0517abce2857c0ddb6" translate="yes" xml:space="preserve">
          <source>You must own the table to use &lt;code&gt;ALTER TABLE&lt;/code&gt;. To change the schema or tablespace of a table, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema or tablespace. To add the table as a new child of a parent table, you must own the parent table as well. Also, to attach a table as a new partition of the table, you must own the table being attached. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type or use the &lt;code&gt;OF&lt;/code&gt; clause, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; 을 사용하려면 테이블을 소유해야합니다 . 테이블의 스키마 또는 테이블 스페이스를 변경하려면 새 스키마 또는 테이블 스페이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 부모 테이블의 새 자식으로 테이블을 추가하려면 부모 테이블도 소유해야합니다. 또한 테이블을 새 테이블 파티션으로 연결하려면 첨부 할 테이블을 소유해야합니다. 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에 테이블 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 소유자를 변경해도 테이블을 삭제하고 다시 생성하여 수행 할 수없는 작업을 수행 할 수 없습니다. 그러나 수퍼 유저는 테이블의 소유권을 어쨌든 변경할 수 있습니다.) 열을 추가하거나 열 유형을 변경하거나 &lt;code&gt;OF&lt;/code&gt; 절 에서 데이터 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 특권 도 가지고 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b208c35edf5cc5dc00f7bfea3242b7d2ef5016a5" translate="yes" xml:space="preserve">
          <source>You must own the tablespace to change the definition of a tablespace. To alter the owner, you must also be a direct or indirect member of the new owning role. (Note that superusers have these privileges automatically.)</source>
          <target state="translated">테이블 스페이스의 정의를 변경하려면 테이블 스페이스를 소유해야합니다. 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야합니다. (수퍼 유저에게는 이러한 권한이 자동으로 부여됩니다.)</target>
        </trans-unit>
        <trans-unit id="bb0b957526a357fbf1b5dba72d0747095b82b01d" translate="yes" xml:space="preserve">
          <source>You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt;. To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the attribute's data type.</source>
          <target state="translated">You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt; . To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the attribute's data type.</target>
        </trans-unit>
        <trans-unit id="43a595550cf8e4892a3f9ade890ea91fd323c045" translate="yes" xml:space="preserve">
          <source>You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt;. To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">&lt;code&gt;ALTER TYPE&lt;/code&gt; 을 사용하려면 유형을 소유해야합니다 . 유형의 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에 유형 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한으로 인해 소유자를 변경하면 유형을 삭제하고 다시 생성하여 수행 할 수없는 작업이 수행되지 않습니다. 그러나 수퍼 유저는 모든 유형의 소유권을 변경할 수 있습니다.) 속성을 추가하거나 속성 유형을 변경하려면 데이터 유형에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcbfaecbde4a2455af73d870203e3398469ff416" translate="yes" xml:space="preserve">
          <source>You must own the view to use &lt;code&gt;ALTER VIEW&lt;/code&gt;. To change a view's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the view's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the view. However, a superuser can alter ownership of any view anyway.)</source>
          <target state="translated">&lt;code&gt;ALTER VIEW&lt;/code&gt; 를 사용하려면 뷰를 소유해야합니다 . 뷰의 스키마를 변경하려면 새 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 도 있어야합니다 . 소유자를 변경하려면 새 소유 역할의 직접 또는 간접 구성원이어야하며 해당 역할 에는 뷰 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . (이러한 제한 사항은 뷰를 삭제하고 다시 생성하여 소유자를 변경해도 수행 할 수없는 작업은 수행하지 않지만 수퍼 유저는 모든 뷰의 소유권을 변경할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="4911aa708898e67357c9d052b13bb6ead7673cb0" translate="yes" xml:space="preserve">
          <source>You need to reboot for the changes to take effect. See also &lt;a href=&quot;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&quot;&gt;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&lt;/a&gt; for information on shared memory under older versions of Solaris.</source>
          <target state="translated">변경 사항을 적용하려면 재부팅해야합니다. 이전 버전의 Solaris에서 공유 메모리에 대한 정보 는 &lt;a href=&quot;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&quot;&gt;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fab91ed3926641d5859d776177b64f5776bb444d" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;dearmor()&lt;/code&gt; on these keys before giving them to the PGP functions. Or if you can handle binary data, you can drop &lt;code&gt;-a&lt;/code&gt; from the command.</source>
          <target state="translated">PGP 함수에 키를 제공하기 전에이 키에 &lt;code&gt;dearmor()&lt;/code&gt; 를 사용해야 합니다. 또는 이진 데이터를 처리 할 수 ​​있으면 명령에서 &lt;code&gt;-a&lt;/code&gt; 를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="329e6d57552f34bb2c8cbc84c71a4150ac977a8a" translate="yes" xml:space="preserve">
          <source>You probably want to start up &lt;code&gt;psql&lt;/code&gt; to try the examples in this tutorial. It can be activated for the &lt;code&gt;mydb&lt;/code&gt; database by typing the command:</source>
          <target state="translated">이 튜토리얼의 예제를 시도하기 위해 &lt;code&gt;psql&lt;/code&gt; 을 시작하고 싶을 것입니다 . 다음 명령을 입력하여 &lt;code&gt;mydb&lt;/code&gt; 데이터베이스에 대해 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e22ef5923c1fd5594bbdb16bda1e16d0fcc7df3" translate="yes" xml:space="preserve">
          <source>You should also consider setting &lt;code&gt;hot_standby_feedback&lt;/code&gt; on standby server(s) as an alternative to using this parameter.</source>
          <target state="translated">이 매개 변수를 사용하는 대신 대기 서버에서 &lt;code&gt;hot_standby_feedback&lt;/code&gt; 을 설정하는 것도 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="abf0f469a9c924ec822fbdcdda37276bcd973b00" translate="yes" xml:space="preserve">
          <source>You should at this point be wondering how the input and output functions can be declared to have results or arguments of the new type, when they have to be created before the new type can be created. The answer is that the type should first be defined as a &lt;em&gt;shell type&lt;/em&gt;, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the C I/O functions can be defined referencing the shell type. Finally, &lt;code&gt;CREATE TYPE&lt;/code&gt; with a full definition replaces the shell entry with a complete, valid type definition, after which the new type can be used normally.</source>
          <target state="translated">이 시점에서 입력 및 출력 함수가 새 유형을 작성하기 전에 작성해야 할 때 새 유형의 결과 또는 인수를 갖도록 선언 할 수있는 방법이 궁금합니다. 대답은 유형이 먼저 &lt;em&gt;쉘 유형&lt;/em&gt; 으로 정의되어야한다는 것입니다.이 유형은 이름과 소유자 이외의 속성이없는 자리 표시 자 유형입니다. 추가 매개 변수없이 &lt;code&gt;CREATE TYPE name&lt;/code&gt; 명령을 실행하여 수행됩니다 . 그런 다음 쉘 유형을 참조하여 CI / O 기능을 정의 할 수 있습니다. 마지막으로, 전체 정의가있는 &lt;code&gt;CREATE TYPE&lt;/code&gt; 은 쉘 항목을 완전한 유효한 유형 정의로 대체 한 후 새 유형을 정상적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62998832a31a93f392b8c5c32a45b2a0ab95bec2" translate="yes" xml:space="preserve">
          <source>You should consider that the network bandwidth must be higher than the rate of generation of WAL data.</source>
          <target state="translated">네트워크 대역폭은 WAL 데이터 생성 속도보다 높아야합니다.</target>
        </trans-unit>
        <trans-unit id="43179d16a3a417045be109f728f3b3a1fb7c1178" translate="yes" xml:space="preserve">
          <source>You should remember that DTrace scripts need to be carefully written and debugged, otherwise the trace information collected might be meaningless. In most cases where problems are found it is the instrumentation that is at fault, not the underlying system. When discussing information found using dynamic tracing, be sure to enclose the script used to allow that too to be checked and discussed.</source>
          <target state="translated">DTrace 스크립트는주의해서 작성하고 디버깅해야합니다. 그렇지 않으면 수집 된 추적 정보가 의미가 없을 수 있습니다. 문제가 발견되는 대부분의 경우 기본 시스템이 아닌 결함이있는 계측입니다. 동적 추적을 사용하여 찾은 정보를 논의 할 때는이를 확인하고 논의 할 수 있도록 스크립트를 동봉해야합니다.</target>
        </trans-unit>
        <trans-unit id="3bf69a6d0ffb8bac8b279e39a485a02a700714e9" translate="yes" xml:space="preserve">
          <source>You should take care that the data types specified for a probe's parameters match the data types of the variables used in the macro. Otherwise, you will get compilation errors.</source>
          <target state="translated">프로브 매개 변수에 지정된 데이터 유형이 매크로에 사용 된 변수의 데이터 유형과 일치하는지주의해야합니다. 그렇지 않으면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d04a892bbd8087c24b67b0ef9b1ba084ecd5f255" translate="yes" xml:space="preserve">
          <source>You should, however, omit from the backup the files within the cluster's &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory. This slight adjustment is worthwhile because it reduces the risk of mistakes when restoring. This is easy to arrange if &lt;code&gt;pg_wal/&lt;/code&gt; is a symbolic link pointing to someplace outside the cluster directory, which is a common setup anyway for performance reasons. You might also want to exclude &lt;code&gt;postmaster.pid&lt;/code&gt; and &lt;code&gt;postmaster.opts&lt;/code&gt;, which record information about the running postmaster, not about the postmaster which will eventually use this backup. (These files can confuse pg_ctl.)</source>
          <target state="translated">그러나 백업에서 클러스터의 &lt;code&gt;pg_wal/&lt;/code&gt; 하위 디렉토리에 있는 파일을 생략해야합니다 . 이 약간의 조정은 복원 할 때 실수의 위험을 줄이기 때문에 가치가 있습니다. &lt;code&gt;pg_wal/&lt;/code&gt; 이 클러스터 디렉토리 외부의 어딘가를 가리키는 심볼릭 링크 인 경우 쉽게 정렬 할 수 있습니다. 이는 성능상의 이유로 일반적인 설정입니다. 결국이 백업을 사용할 포스트 마스터가 아니라 실행중인 포스트 마스터에 대한 정보를 기록하는 &lt;code&gt;postmaster.pid&lt;/code&gt; 및 &lt;code&gt;postmaster.opts&lt;/code&gt; 를 제외 할 수도 있습니다 . (이 파일들은 pg_ctl을 혼동 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="f688c2bcf87c6522b972dcd5d1a0d98122829c3b" translate="yes" xml:space="preserve">
          <source>You use the &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; command to remove rows; the syntax is very similar to the &lt;code&gt;UPDATE&lt;/code&gt; command. For instance, to remove all rows from the products table that have a price of 10, use:</source>
          <target state="translated">&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; 명령을 사용하여 행을 제거합니다. 구문은 &lt;code&gt;UPDATE&lt;/code&gt; 명령 과 매우 유사합니다 . 예를 들어, 제품 테이블에서 가격이 10 인 모든 행을 제거하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c8d44004f1a1375d285a996132364e5a09cd0aa9" translate="yes" xml:space="preserve">
          <source>You usually only need to set this parameter in complex re-recovery situations, where you need to return to a state that itself was reached after a point-in-time recovery. See &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">특정 시점 복구 후 자체 도달 한 상태로 돌아 가야하는 복잡한 재 복구 상황에서만이 매개 변수를 설정하면됩니다. 자세한 내용 &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;은 25.3.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c0b4770f607d09fa317c5dc06f4c40416fa8fa6" translate="yes" xml:space="preserve">
          <source>You will encounter this style of abbreviating quite frequently.</source>
          <target state="translated">이 스타일의 약어는 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f2689ccc464a2d160017022cb703ee291e2f949e" translate="yes" xml:space="preserve">
          <source>You will sometimes need to add parentheses when using combinations of binary and unary operators. For instance:</source>
          <target state="translated">이진 연산자와 단항 연산자의 조합을 사용할 때 괄호를 추가해야하는 경우가 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="4f96b903666683fcb600721163b7537153b2acf3" translate="yes" xml:space="preserve">
          <source>You will then need to use gunzip during recovery:</source>
          <target state="translated">그런 다음 복구 중에 gunzip을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="76a9773cd5b34137343c2a3db898da05e9e5088f" translate="yes" xml:space="preserve">
          <source>You will usually want to increase &lt;code&gt;kern.ipc.semmni&lt;/code&gt; and &lt;code&gt;kern.ipc.semmns&lt;/code&gt;, as NetBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">NetBSD의 기본 설정은 불편 하기 때문에 &lt;code&gt;kern.ipc.semmni&lt;/code&gt; 및 &lt;code&gt;kern.ipc.semmns&lt;/code&gt; 를 늘려야 합니다.</target>
        </trans-unit>
        <trans-unit id="4d7dd316d288d7dc8cab74686babd6da0f71907c" translate="yes" xml:space="preserve">
          <source>You will usually want to increase &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; and &lt;code&gt;kern.seminfo.semmns&lt;/code&gt;, as OpenBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">OpenBSD의 기본 설정은 불편 하기 때문에 &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; 및 &lt;code&gt;kern.seminfo.semmns&lt;/code&gt; 를 늘려야 합니다.</target>
        </trans-unit>
        <trans-unit id="2609a6d5763d68ee7a0a0d2d4b45f307e6ae5ffd" translate="yes" xml:space="preserve">
          <source>Zero-Column Tables</source>
          <target state="translated">제로 열 테이블</target>
        </trans-unit>
        <trans-unit id="30c11554a2b9e71795733af27503dd2000ac35f9" translate="yes" xml:space="preserve">
          <source>Zipfian-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; Zipfian 분포 난수 , 아래 참조</target>
        </trans-unit>
        <trans-unit id="329669d49d5a7c00789e68977fd4b07da1d077c8" translate="yes" xml:space="preserve">
          <source>[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; '&lt;code&gt;password&lt;/code&gt;'&lt;code&gt;PASSWORD NULL&lt;/code&gt;</source>
          <target state="translated">[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; ' &lt;code&gt;password&lt;/code&gt; ' &lt;code&gt;PASSWORD NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689b11d9bddde6c1d7ee8e5eb112418a0978460f" translate="yes" xml:space="preserve">
          <source>[(x1,y1),...]</source>
          <target state="translated">[(x1,y1),...]</target>
        </trans-unit>
        <trans-unit id="56bed60529c445af77ea7362851c52890ef3de9a" translate="yes" xml:space="preserve">
          <source>[a, b] is entirely to the left of [c, d]. That is, [a, b] &amp;lt;&amp;lt; [c, d] is true if b &amp;lt; c and false otherwise.</source>
          <target state="translated">[a, b]는 [c, d]의 왼쪽에 있습니다. 즉, b &amp;lt;c이면 [a, b] &amp;lt;&amp;lt; [c, d]는 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="46347467de76083a1f3b3ab7c5a273c56dcfd8f4" translate="yes" xml:space="preserve">
          <source>[a, b] is entirely to the right of [c, d]. That is, [a, b] &amp;gt;&amp;gt; [c, d] is true if a &amp;gt; d and false otherwise.</source>
          <target state="translated">[a, b]는 전적으로 [c, d]의 오른쪽에 있습니다. 즉, a&amp;gt; d이면 [a, b] &amp;gt;&amp;gt; [c, d]는 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="038cf8dbb178850257e9230060d8fcef7ddfb5a0" translate="yes" xml:space="preserve">
          <source>[elma04]</source>
          <target state="translated">[elma04]</target>
        </trans-unit>
        <trans-unit id="2b5f5b947ce4c4c7f099a0a2d735357e09310b58" translate="yes" xml:space="preserve">
          <source>[fong]</source>
          <target state="translated">[fong]</target>
        </trans-unit>
        <trans-unit id="5c07a6ad2db9480747f4d609fb47951588166180" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;bracket expression&lt;/em&gt;, matching any one of the &lt;code&gt;chars&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-BRACKET-EXPRESSIONS&quot;&gt;Section 9.7.3.2&lt;/a&gt; for more detail)</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 중 하나와 일치 하는 &lt;em&gt;대괄호 표현식&lt;/em&gt; (자세한 내용 &lt;a href=&quot;functions-matching#POSIX-BRACKET-EXPRESSIONS&quot;&gt;은 9.7.3.2 절&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="5c2a04f8a25082f47f2b1b62420d51d9e2586092" translate="yes" xml:space="preserve">
          <source>a closed path?</source>
          <target state="translated">닫힌 길?</target>
        </trans-unit>
        <trans-unit id="4f837508b52bb0f6f0c188e3d8239bb66f7f30b3" translate="yes" xml:space="preserve">
          <source>a label beginning with the case-insensitive prefix &lt;code&gt;sport&lt;/code&gt;</source>
          <target state="translated">대소 문자를 구분하지 않는 접두사 &lt;code&gt;sport&lt;/code&gt; 시작하는 레이블</target>
        </trans-unit>
        <trans-unit id="8b52f02d3dbf1419017e235881c6561ac7603288" translate="yes" xml:space="preserve">
          <source>a sequence of 0 or 1 matches of the atom</source>
          <target state="translated">원자와 일치하는 0 또는 1의 시퀀스</target>
        </trans-unit>
        <trans-unit id="c789ac60ffb3a4856f62a0cc113a4a9eb99a3e78" translate="yes" xml:space="preserve">
          <source>a sequence of 0 or more matches of the atom</source>
          <target state="translated">원자와 0 개 이상의 일치 시퀀스</target>
        </trans-unit>
        <trans-unit id="37235ff249a4a2dc93bed2d89eba1468f3102441" translate="yes" xml:space="preserve">
          <source>a sequence of 1 or more matches of the atom</source>
          <target state="translated">원자의 1 개 이상의 일치 시퀀스</target>
        </trans-unit>
        <trans-unit id="f4d6892681b0f2c2f68672a4ea2ebea56a26fb7c" translate="yes" xml:space="preserve">
          <source>a sequence of &lt;code&gt;m&lt;/code&gt; or more matches of the atom</source>
          <target state="translated">원자 의 &lt;code&gt;m&lt;/code&gt; 이상의 일치 시퀀스</target>
        </trans-unit>
        <trans-unit id="d6eb7a7a662e02de4e455a3d9cb22b1e5cbc9fd0" translate="yes" xml:space="preserve">
          <source>a sequence of &lt;code&gt;m&lt;/code&gt; through &lt;code&gt;n&lt;/code&gt; (inclusive) matches of the atom; &lt;code&gt;m&lt;/code&gt; cannot exceed &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">원자 의 &lt;code&gt;m&lt;/code&gt; 내지 &lt;code&gt;n&lt;/code&gt; (포함) 일치의 서열 ; &lt;code&gt;m&lt;/code&gt; 은 &lt;code&gt;n&lt;/code&gt; 을 초과 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="8a1befdcf13a2caa739dbb24cca880bbc955a58b" translate="yes" xml:space="preserve">
          <source>a sequence of exactly &lt;code&gt;m&lt;/code&gt; matches of the atom</source>
          <target state="translated">원자와 정확히 일치 하는 &lt;code&gt;m&lt;/code&gt; 의 시퀀스</target>
        </trans-unit>
        <trans-unit id="42e244f289cb2901a2850fc0e292f5c6110aec21" translate="yes" xml:space="preserve">
          <source>a single lexeme with the &lt;code&gt;TSL_FILTER&lt;/code&gt; flag set, to replace the original token with a new token to be passed to subsequent dictionaries (a dictionary that does this is called a &lt;em&gt;filtering dictionary&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;TSL_FILTER&lt;/code&gt; 플래그가 설정된 단일 exeme , 원래 토큰을 새 사전 토큰으로 대체하여 후속 사전 (이 사전을 &lt;em&gt;필터링 사전&lt;/em&gt; 이라고 함 )에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="39c985af6407cb40e9f21b877cb2f14f1ab7445e" translate="yes" xml:space="preserve">
          <source>a white-space character or &lt;code&gt;#&lt;/code&gt; preceded by &lt;code&gt;\&lt;/code&gt; is retained</source>
          <target state="translated">공백 문자 또는 &lt;code&gt;#&lt;/code&gt; 앞에 &lt;code&gt;\&lt;/code&gt; 가 붙는 경우</target>
        </trans-unit>
        <trans-unit id="c79c0a316e1b5d5dfe7325f52987831549fe62de" translate="yes" xml:space="preserve">
          <source>abbreviated capitalized day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">축약 된 대문자 이름 (영어 3 자, 현지화 된 길이는 다름)</target>
        </trans-unit>
        <trans-unit id="264cda486a8f189eb4b75e086f6d14582addebc5" translate="yes" xml:space="preserve">
          <source>abbreviated capitalized month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">약식 대문자 이름 (영문 3 자, 현지화 된 길이는 다름)</target>
        </trans-unit>
        <trans-unit id="ece4f8ac5a0911464c77304a7d93e8b052502ee1" translate="yes" xml:space="preserve">
          <source>abbreviated display format as text</source>
          <target state="translated">텍스트로 약식 표시 형식</target>
        </trans-unit>
        <trans-unit id="88b965dacddbd5c3be3568170a1a398601e53a48" translate="yes" xml:space="preserve">
          <source>abbreviated lower case day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">약식 소문자 이름 (영어 3 자, 현지화 된 길이는 다름)</target>
        </trans-unit>
        <trans-unit id="9186b18dd65f270c46192797d4cb755071c05c1e" translate="yes" xml:space="preserve">
          <source>abbreviated lower case month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">약식 소문자 월 이름 (영문 3 자, 현지화 된 길이는 다름)</target>
        </trans-unit>
        <trans-unit id="a3f61c541f5db806cb405bf2892b6722718fec31" translate="yes" xml:space="preserve">
          <source>abbreviated upper case day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">약식 대문자 이름 (영문 3 자, 현지화 된 길이는 다름)</target>
        </trans-unit>
        <trans-unit id="7577f3a97383fa6c0292570407f15fbf40857e56" translate="yes" xml:space="preserve">
          <source>abbreviated upper case month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">약식 대문자 월 이름 (영문 3 자, 현지화 된 길이는 다름)</target>
        </trans-unit>
        <trans-unit id="33f31413199ddb62fc17b8f2bed78e9d010e94da" translate="yes" xml:space="preserve">
          <source>absolute value</source>
          <target state="translated">절대 값</target>
        </trans-unit>
        <trans-unit id="de8436d989e265b7b258d6602654167f651db67b" translate="yes" xml:space="preserve">
          <source>access method operator classes</source>
          <target state="translated">액세스 메소드 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="639212fb06d8ccc51f13d82301ca6b66a2deb947" translate="yes" xml:space="preserve">
          <source>access method operator families</source>
          <target state="translated">액세스 방법 운영자 제품군</target>
        </trans-unit>
        <trans-unit id="a5886a24a9cd7f64cdec22dc5f1b0dad9949c443" translate="yes" xml:space="preserve">
          <source>access method operators</source>
          <target state="translated">액세스 방법 연산자</target>
        </trans-unit>
        <trans-unit id="cce1015f8d299b67b710b93d76b497f49fa98565" translate="yes" xml:space="preserve">
          <source>access method support functions</source>
          <target state="translated">액세스 방법 지원 기능</target>
        </trans-unit>
        <trans-unit id="b9cfb8c8675bb466671371ec06207e1c430329f4" translate="yes" xml:space="preserve">
          <source>adding affix</source>
          <target state="translated">접미사 추가</target>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="translated">addition</target>
        </trans-unit>
        <trans-unit id="9118866496dfbc2e597505390a41e74349ab5152" translate="yes" xml:space="preserve">
          <source>addition, subtraction</source>
          <target state="translated">더하기, 빼기</target>
        </trans-unit>
        <trans-unit id="aaf09a4b156ac6da8c98f72704c7cee1497e7d6f" translate="yes" xml:space="preserve">
          <source>additional foreign table information</source>
          <target state="translated">추가 외래 테이블 정보</target>
        </trans-unit>
        <trans-unit id="1a32619c4b1c2c834145f692705708f779bed83a" translate="yes" xml:space="preserve">
          <source>additional index information</source>
          <target state="translated">추가 색인 정보</target>
        </trans-unit>
        <trans-unit id="de48f56b01bcd91fd19904d21fc567f7aeb73b16" translate="yes" xml:space="preserve">
          <source>address of the local connection</source>
          <target state="translated">로컬 연결 주소</target>
        </trans-unit>
        <trans-unit id="95dd78f31f2d2267d2022e6763c1fb744bbf23ea" translate="yes" xml:space="preserve">
          <source>address of the remote connection</source>
          <target state="translated">원격 연결 주소</target>
        </trans-unit>
        <trans-unit id="0e18d863cc787a1080e11d6aad8c84c3d163b704" translate="yes" xml:space="preserve">
          <source>adminpack</source>
          <target state="translated">adminpack</target>
        </trans-unit>
        <trans-unit id="bccf7370fc6bc7e65ebb00bcd447b407dc6e3ec1" translate="yes" xml:space="preserve">
          <source>aggregate functions</source>
          <target state="translated">집계 함수</target>
        </trans-unit>
        <trans-unit id="5707e56794034492e28fb802f0929edc22148ae3" translate="yes" xml:space="preserve">
          <source>aggregates name/value pairs as a JSON object; values can be null, but not names</source>
          <target state="translated">이름 / 값 쌍을 JSON 객체로 집계합니다. 값은 null 일 수 있지만 이름은 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="100b0a2fce8f87a6bf417e59568b60def0dd95ed" translate="yes" xml:space="preserve">
          <source>aggregates values, including nulls, as a JSON array</source>
          <target state="translated">null을 포함하여 값을 JSON 배열로 집계</target>
        </trans-unit>
        <trans-unit id="27428a051111f05b13f941652832e7ba4a594fed" translate="yes" xml:space="preserve">
          <source>alert (bell) character, as in C</source>
          <target state="translated">C에서와 같이 경고 (종) 문자</target>
        </trans-unit>
        <trans-unit id="8a97bf0012dbebc5bcefd88a6e6ca0df50de1524" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;hash_murmur2()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash_murmur2()&lt;/code&gt; 별명</target>
        </trans-unit>
        <trans-unit id="e3acb7916bd347d132eed28f72c60ded2aae1942" translate="yes" xml:space="preserve">
          <source>all other native and user-defined operators</source>
          <target state="translated">다른 모든 기본 및 사용자 정의 연산자</target>
        </trans-unit>
        <trans-unit id="15100289fd2a2926dbfc0362c8c82f216aafdb18" translate="yes" xml:space="preserve">
          <source>amcheck</source>
          <target state="translated">amcheck</target>
        </trans-unit>
        <trans-unit id="663bae22b8d6ed1b0c5424f47e75478c4fc96f3e" translate="yes" xml:space="preserve">
          <source>an array of lexemes if the input token is known to the dictionary (notice that one token can produce more than one lexeme)</source>
          <target state="translated">입력 토큰이 사전에 알려진 경우 렉서스 배열 (하나의 토큰이 둘 이상의 exeme을 생성 할 수 있음에 유의)</target>
        </trans-unit>
        <trans-unit id="232a7414ddb1870267de0ac5d074d426c7090d4d" translate="yes" xml:space="preserve">
          <source>an empty array if the dictionary knows the token, but it is a stop word</source>
          <target state="translated">사전이 토큰을 알고있는 경우 빈 배열이지만 중지 단어입니다.</target>
        </trans-unit>
        <trans-unit id="4a50c2a4d787c9ec20847e24d511e5f7edd971bf" translate="yes" xml:space="preserve">
          <source>an integer between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;10&lt;/code&gt; 사이의 정수</target>
        </trans-unit>
        <trans-unit id="0b6686e81b37171a7ea6080018ce0ae5e675c63c" translate="yes" xml:space="preserve">
          <source>an open path?</source>
          <target state="translated">열린 길?</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="195ca7bc7f18fd5ef1b0e2c3a54dd46b02d4927d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;frame_exclusion&lt;/code&gt; can be one of</source>
          <target state="translated">및 &lt;code&gt;frame_exclusion&lt;/code&gt; 이 중 하나가 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b061bc6b05f4e30ad67fd83ca835fa19bda9bb24" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;mode&lt;/code&gt; is one of:</source>
          <target state="translated">및 &lt;code&gt;mode&lt;/code&gt; 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="dfcc9edf53bd479c53a758f8cd20ae723fac9500" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;padding&lt;/code&gt; is one of:</source>
          <target state="translated">및 &lt;code&gt;padding&lt;/code&gt; 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="1f043826d65c29cd9d06435f4c3f4c44886caf1f" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;psql&lt;/code&gt; will quit and return you to your command shell. (For more internal commands, type &lt;code&gt;\?&lt;/code&gt; at the &lt;code&gt;psql&lt;/code&gt; prompt.) The full capabilities of &lt;code&gt;psql&lt;/code&gt; are documented in &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. In this tutorial we will not use these features explicitly, but you can use them yourself when it is helpful.</source>
          <target state="translated">와 &lt;code&gt;psql&lt;/code&gt; 프로그램은 종료하고 당신은 당신의 명령 쉘로 돌아갑니다. (자세한 내부 명령 유형에 대해 &lt;code&gt;\?&lt;/code&gt; 상기 &lt;code&gt;psql&lt;/code&gt; 의 프롬프트.)의 전체 기능 &lt;code&gt;psql&lt;/code&gt; 의은 에 설명되어 있습니다 &lt;a href=&quot;app-psql&quot;&gt;psql의&lt;/a&gt; . 이 자습서에서는 이러한 기능을 명시 적으로 사용하지 않지만 도움이 될 때 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3badfcd96666510617917bc44cf260ce650da948" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;t2&lt;/code&gt;:</source>
          <target state="translated">및 &lt;code&gt;t2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="64f54598fc8b10700b447590aedbe9802f2cf914" translate="yes" xml:space="preserve">
          <source>and Collations</source>
          <target state="translated">및 콜 레이션</target>
        </trans-unit>
        <trans-unit id="097ca12344ffcd3926b70cf91232fc017a3d35e9" translate="yes" xml:space="preserve">
          <source>and ORDER BY</source>
          <target state="translated">주문</target>
        </trans-unit>
        <trans-unit id="a41a99f30db5c8c73bb765ef058446c9ffe876c5" translate="yes" xml:space="preserve">
          <source>and all the dependent objects will be removed, as will any objects that depend on them, recursively. In this case, it doesn't remove the orders table, it only removes the foreign key constraint. It stops there because nothing depends on the foreign key constraint. (If you want to check what &lt;code&gt;DROP ... CASCADE&lt;/code&gt; will do, run &lt;code&gt;DROP&lt;/code&gt; without &lt;code&gt;CASCADE&lt;/code&gt; and read the &lt;code&gt;DETAIL&lt;/code&gt; output.)</source>
          <target state="translated">그리고 종속 된 모든 개체는 재귀 적으로 제거됩니다. 이 경우 orders 테이블을 제거하지 않고 외래 키 제약 조건 만 제거합니다. 외래 키 제약 조건에 의존하지 않으므로 중지됩니다. (당신이 무엇인지 확인하려면 &lt;code&gt;DROP ... CASCADE&lt;/code&gt; 실행 할 것 &lt;code&gt;DROP&lt;/code&gt; 을 하지 않고 &lt;code&gt;CASCADE&lt;/code&gt; 및 읽기 &lt;code&gt;DETAIL&lt;/code&gt; 의 출력을.)</target>
        </trans-unit>
        <trans-unit id="91ded08e1c2fb163ac112ff991a147382d928feb" translate="yes" xml:space="preserve">
          <source>and can appear anywhere a &lt;code&gt;SELECT&lt;/code&gt; can. For example, you can use it as part of a &lt;code&gt;UNION&lt;/code&gt;, or attach a &lt;code&gt;sort_specification&lt;/code&gt; (&lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, and/or &lt;code&gt;OFFSET&lt;/code&gt;) to it. &lt;code&gt;VALUES&lt;/code&gt; is most commonly used as the data source in an &lt;code&gt;INSERT&lt;/code&gt; command, and next most commonly as a subquery.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 가 할 수 있는 곳이면 어디든지 나타날 수 있습니다. 예를 들어, &lt;code&gt;UNION&lt;/code&gt; 의 일부로 사용 하거나 &lt;code&gt;sort_specification&lt;/code&gt; ( &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; 및 / 또는 &lt;code&gt;OFFSET&lt;/code&gt; )을 첨부 할 수 있습니다. &lt;code&gt;VALUES&lt;/code&gt; 는 &lt;code&gt;INSERT&lt;/code&gt; 명령 에서 데이터 소스로 가장 일반적으로 사용되며 다음으로 가장 일반적으로 하위 쿼리로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="463a6cd589d2223d499014d12a55159d1281075e" translate="yes" xml:space="preserve">
          <source>and her transaction is in &lt;code&gt;READ COMMITTED&lt;/code&gt; mode, it is possible for her to see &amp;ldquo;secret from mallory&amp;rdquo;. That happens if her transaction reaches the &lt;code&gt;information&lt;/code&gt; row just after &lt;code&gt;alice&lt;/code&gt;'s does. It blocks waiting for &lt;code&gt;alice&lt;/code&gt;'s transaction to commit, then fetches the updated row contents thanks to the &lt;code&gt;FOR UPDATE&lt;/code&gt; clause. However, it does &lt;em&gt;not&lt;/em&gt; fetch an updated row for the implicit &lt;code&gt;SELECT&lt;/code&gt; from &lt;code&gt;users&lt;/code&gt;, because that sub-&lt;code&gt;SELECT&lt;/code&gt; did not have &lt;code&gt;FOR UPDATE&lt;/code&gt;; instead the &lt;code&gt;users&lt;/code&gt; row is read with the snapshot taken at the start of the query. Therefore, the policy expression tests the old value of &lt;code&gt;mallory&lt;/code&gt;'s privilege level and allows her to see the updated row.</source>
          <target state="translated">그녀의 거래는 &lt;code&gt;READ COMMITTED&lt;/code&gt; 모드에 있으며, 그녀는 &quot;mallory의 비밀&quot;을 볼 수 있습니다. &lt;code&gt;alice&lt;/code&gt; 의 거래 직후 에 그녀의 거래가 &lt;code&gt;information&lt;/code&gt; 행에 도달하면 발생합니다 . &lt;code&gt;alice&lt;/code&gt; 의 트랜잭션이 커밋 되기를 기다리는 것을 차단 한 다음 &lt;code&gt;FOR UPDATE&lt;/code&gt; 절 덕분에 업데이트 된 행 내용을 가져옵니다 . 그러나 않습니다 &lt;em&gt;하지&lt;/em&gt; 암시에 대한 업데이트 된 행 가져 오기 &lt;code&gt;SELECT&lt;/code&gt; 에서 &lt;code&gt;users&lt;/code&gt; 그 하위 때문에, &lt;code&gt;SELECT&lt;/code&gt; 가 없었 &lt;code&gt;FOR UPDATE&lt;/code&gt; ; 대신 &lt;code&gt;users&lt;/code&gt; &lt;em&gt;&lt;/em&gt;쿼리 시작시 스냅 샷을 작성하여 행을 읽습니다. 따라서 정책 표현은 &lt;code&gt;mallory&lt;/code&gt; 권한 수준 의 이전 값을 테스트 하고 업데이트 된 행을 볼 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="2ddf7473848fa4907e6ee0ff26623f75dfed1f01" translate="yes" xml:space="preserve">
          <source>and next has zero to two labels before</source>
          <target state="translated">다음은 0에서 2까지의 레이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d723326824a3836a81d727940bbbaebfea441ace" translate="yes" xml:space="preserve">
          <source>and obtains the result 300, which it inserts in a new row with &lt;code&gt;class&lt;/code&gt;&lt;code&gt;= 1&lt;/code&gt;. Then both transactions try to commit. If either transaction were running at the Repeatable Read isolation level, both would be allowed to commit; but since there is no serial order of execution consistent with the result, using Serializable transactions will allow one transaction to commit and will roll the other back with this message:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; &lt;code&gt;= 1&lt;/code&gt; 새 행에 삽입하는 결과 300을 얻습니다 . 그런 다음 두 트랜잭션 모두 커밋을 시도합니다. 트랜잭션이 반복 가능한 읽기 격리 수준에서 실행 중이면 둘 다 커밋 할 수 있습니다. 그러나 결과와 일치하는 일련의 실행 순서가 없으므로 Serializable 트랜잭션을 사용하면 한 트랜잭션이 커밋되고 다른 트랜잭션이 다음 메시지와 함께 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="abd292e64f5762adf92489151f65db3a2d25c4cf" translate="yes" xml:space="preserve">
          <source>and overriding the collation of a function or operator call that has locale-sensitive results, for example:</source>
          <target state="translated">로케일 구분 결과가있는 함수 또는 연산자 호출의 데이터 정렬을 대체합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="4472b3d78f22b89c61f97b762041a5148f6b86b3" translate="yes" xml:space="preserve">
          <source>and the application issues many queries of the form:</source>
          <target state="translated">응용 프로그램은 다음과 같은 형식의 많은 쿼리를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="519bfeab6436137fc4443c937b4e2a57a5222950" translate="yes" xml:space="preserve">
          <source>and then ends with a label beginning with &lt;code&gt;Russ&lt;/code&gt; or exactly matching &lt;code&gt;Spain&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;Russ&lt;/code&gt; 로 시작 하거나 정확히 일치하는 &lt;code&gt;Spain&lt;/code&gt; 레이블로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="da0d7e15413e88d505f96b30393006166f82a571" translate="yes" xml:space="preserve">
          <source>and then insert the &lt;code&gt;NOT&lt;/code&gt; key word where desired.</source>
          <target state="translated">그런 다음 원하는 곳에 &lt;code&gt;NOT&lt;/code&gt; 키워드 를 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="f550ff82765c7c77442e312860d5c5a6aa4ec136" translate="yes" xml:space="preserve">
          <source>and then inserts the result (30) as the &lt;code&gt;value&lt;/code&gt; in a new row with &lt;code&gt;class&lt;/code&gt;&lt;code&gt;= 2&lt;/code&gt;. Concurrently, serializable transaction B computes:</source>
          <target state="translated">그런 다음 &lt;code&gt;class&lt;/code&gt; &lt;code&gt;= 2&lt;/code&gt; 새 행에 결과 (30)을 &lt;code&gt;value&lt;/code&gt; 으로 삽입합니다 . 동시에, 직렬화 가능 트랜잭션 B는 다음을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d17266916c8a994f2881eb849993c9875639d0c1" translate="yes" xml:space="preserve">
          <source>and then run pg_upgrade with quoted directories, e.g.:</source>
          <target state="translated">그리고 따옴표 붙은 디렉토리로 pg_upgrade를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="146d654592d3bdf49836fb607a26abdff8dc565f" translate="yes" xml:space="preserve">
          <source>and these representations for the &amp;ldquo;false&amp;rdquo; state:</source>
          <target state="translated">&quot;false&quot;상태에 대한 다음 표현 :</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="f0d8476cddfcece7be214ceeeb87fed56a99c5be" translate="yes" xml:space="preserve">
          <source>any OID column</source>
          <target state="translated">모든 OID 열</target>
        </trans-unit>
        <trans-unit id="776b72d37856a0495e69540bbde0cf0ff74423cc" translate="yes" xml:space="preserve">
          <source>any array type</source>
          <target state="translated">모든 배열 유형</target>
        </trans-unit>
        <trans-unit id="c8fdfd5cb246da542aaeb9979987b47c98e64395" translate="yes" xml:space="preserve">
          <source>any non-array type</source>
          <target state="translated">비 배열 유형</target>
        </trans-unit>
        <trans-unit id="72433658efe8a2e649ce354eaceeb1954b3d6706" translate="yes" xml:space="preserve">
          <source>any numeric, string, date/time, network, or enum type, or arrays of these types</source>
          <target state="translated">숫자, 문자열, 날짜 / 시간, 네트워크 또는 열거 형 또는 이러한 유형의 배열</target>
        </trans-unit>
        <trans-unit id="1d1ab32371b3accbfb7ecab87204e63142da53d2" translate="yes" xml:space="preserve">
          <source>any range type</source>
          <target state="translated">모든 범위 유형</target>
        </trans-unit>
        <trans-unit id="17b1f448b91caed36d022289e6bc4c20cb8cb1bf" translate="yes" xml:space="preserve">
          <source>any sortable type</source>
          <target state="translated">정렬 가능한 모든 유형</target>
        </trans-unit>
        <trans-unit id="fc497c9667b2d21c95e0422a7a79489a554110d8" translate="yes" xml:space="preserve">
          <source>append an element to the beginning of an array</source>
          <target state="translated">배열의 시작 부분에 요소를 추가</target>
        </trans-unit>
        <trans-unit id="8510099a899e6e19ffcdc41786dd5bee38c2a170" translate="yes" xml:space="preserve">
          <source>append an element to the end of an array</source>
          <target state="translated">배열의 끝에 요소를 추가</target>
        </trans-unit>
        <trans-unit id="9a48ebf2c2867a717af59a3d046f96e76db2e70a" translate="yes" xml:space="preserve">
          <source>are also of interest, an additional index could be created that supports the &lt;code&gt;&quot;y&quot;&lt;/code&gt; collation, like this:</source>
          <target state="translated">다음 과 같이 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 데이터 정렬 을 지원하는 추가 인덱스를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa4b0695d2fd6cd9abbff5f407b06b97863d61bd" translate="yes" xml:space="preserve">
          <source>are the addresses from the same family?</source>
          <target state="translated">같은 가족의 주소입니까?</target>
        </trans-unit>
        <trans-unit id="0ae7b878964a32c5aa151b7336192d99e50b6fa5" translate="yes" xml:space="preserve">
          <source>are valid values, which follow the ISO 8601 standard. In addition, the common format:</source>
          <target state="translated">유효한 값이며 ISO 8601 표준을 따릅니다. 또한 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="699e8ae92ca31d0753b1eacb9fbc3f555d78fbd6" translate="yes" xml:space="preserve">
          <source>area</source>
          <target state="translated">area</target>
        </trans-unit>
        <trans-unit id="b572d4fbffd87db31a54fcc4b02fd6c33f9b05c2" translate="yes" xml:space="preserve">
          <source>array concatenation (right array added to the end of left one)</source>
          <target state="translated">배열 연결 (오른쪽 배열이 왼쪽 끝에 추가됨)</target>
        </trans-unit>
        <trans-unit id="1f16a17f620eb69917c63399a0983d0af0fc74f5" translate="yes" xml:space="preserve">
          <source>array element selection</source>
          <target state="translated">배열 요소 선택</target>
        </trans-unit>
        <trans-unit id="195b3de97f0176b7d1d976b97a073f956d949127" translate="yes" xml:space="preserve">
          <source>array of sort expression's type</source>
          <target state="translated">정렬 식의 배열</target>
        </trans-unit>
        <trans-unit id="a9cce9638686dc89b3132c8f4d5d6e72457ed9a4" translate="yes" xml:space="preserve">
          <source>array of the argument type</source>
          <target state="translated">인수 타입의 배열</target>
        </trans-unit>
        <trans-unit id="c368852a549cff62f53f0d0deed89bc97c0d743b" translate="yes" xml:space="preserve">
          <source>array-to-array concatenation</source>
          <target state="translated">배열-배열 연결</target>
        </trans-unit>
        <trans-unit id="f88f7ee63beb76da63ba7e7001aa8cd4317f04f4" translate="yes" xml:space="preserve">
          <source>array-to-element concatenation</source>
          <target state="translated">배열-요소 연결</target>
        </trans-unit>
        <trans-unit id="2c4cd6638cd2c3a0b7a8372b993390a30fda1d5e" translate="yes" xml:space="preserve">
          <source>as a more complicated example. Of course, you could wrap all of this in a view for convenience.</source>
          <target state="translated">더 복잡한 예입니다. 물론, 편의를 위해이 모든 것을 포장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3946fc8e2b3dea5bb756fef7515425b6a069b26" translate="yes" xml:space="preserve">
          <source>as above, but the match is not noted for reporting (a &amp;ldquo;non-capturing&amp;rdquo; set of parentheses) (AREs only)</source>
          <target state="translated">위와 같이 일치하지만보고 ( &quot;캡처하지 않는&quot;괄호 집합)에 대해서는 언급되지 않습니다 (만 해당)</target>
        </trans-unit>
        <trans-unit id="44737fbeead1f9bddc0c69fc725d8ac03c45707a" translate="yes" xml:space="preserve">
          <source>as an index-only scan; and this is very attractive if &lt;code&gt;f()&lt;/code&gt; is an expensive-to-compute function. However, PostgreSQL's planner is currently not very smart about such cases. It considers a query to be potentially executable by index-only scan only when all &lt;em&gt;columns&lt;/em&gt; needed by the query are available from the index. In this example, &lt;code&gt;x&lt;/code&gt; is not needed except in the context &lt;code&gt;f(x)&lt;/code&gt;, but the planner does not notice that and concludes that an index-only scan is not possible. If an index-only scan seems sufficiently worthwhile, this can be worked around by adding &lt;code&gt;x&lt;/code&gt; as an included column, for example</source>
          <target state="translated">인덱스 전용 스캔으로; 그리고 &lt;code&gt;f()&lt;/code&gt; 가 계산하기에 비싼 기능 이라면 매우 매력적 입니다. 그러나 PostgreSQL의 플래너는 현재 그러한 경우에 대해 현명하지 않습니다. 쿼리에 필요한 모든 &lt;em&gt;열을&lt;/em&gt; 인덱스에서 사용할 수있는 경우에만 인덱스 전용 검색으로 쿼리를 실행할 수있는 것으로 간주합니다 . 이 예제 에서 컨텍스트 &lt;code&gt;f(x)&lt;/code&gt; 제외하고 &lt;code&gt;x&lt;/code&gt; 는 필요 하지 않지만 플래너는이를 인식하지 못하고 인덱스 전용 스캔이 불가능하다는 결론을 내립니다. 인덱스 전용 스캔이 충분히 가치가있는 것처럼 보이면 &lt;code&gt;x&lt;/code&gt; 를 포함 된 열로 추가하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fcfdc695e360dde8446f7425d95888b6550157a" translate="yes" xml:space="preserve">
          <source>as if the query were</source>
          <target state="translated">마치 쿼리가</target>
        </trans-unit>
        <trans-unit id="a7261a75560cee1649f6ecc0f31279f94dba2bcf" translate="yes" xml:space="preserve">
          <source>assign &lt;code&gt;weight&lt;/code&gt; to each element of &lt;code&gt;vector&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vector&lt;/code&gt; 각 요소에 &lt;code&gt;weight&lt;/code&gt; 를 할당</target>
        </trans-unit>
        <trans-unit id="5f3de199d97e97e8e060913f33b95d03a4f06c7e" translate="yes" xml:space="preserve">
          <source>assign &lt;code&gt;weight&lt;/code&gt; to elements of &lt;code&gt;vector&lt;/code&gt; that are listed in &lt;code&gt;lexemes&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lexemes&lt;/code&gt; 에 나열된 &lt;code&gt;vector&lt;/code&gt; 요소에 &lt;code&gt;weight&lt;/code&gt; 를 할당</target>
        </trans-unit>
        <trans-unit id="43ede3444dff3e595fe1c6f01b6c9f4950cb71df" translate="yes" xml:space="preserve">
          <source>at least 1000 (The default is often 32767; do not change unless necessary)</source>
          <target state="translated">1000 이상 (기본값은 32767이며, 필요하지 않으면 변경하지 마십시오)</target>
        </trans-unit>
        <trans-unit id="5439e16ae06517bfbf55405bc08c2e92863bf5ea" translate="yes" xml:space="preserve">
          <source>at least 17</source>
          <target state="translated">적어도 17</target>
        </trans-unit>
        <trans-unit id="443e099bc3b684e0db01a5fa2add4d3ea2882a4a" translate="yes" xml:space="preserve">
          <source>at least 1kB, but the default is usually much higher</source>
          <target state="translated">1kB 이상이지만 기본값은 일반적으로 훨씬 높습니다</target>
        </trans-unit>
        <trans-unit id="b54a445594f650278b14b942cc8d8778f01c797e" translate="yes" xml:space="preserve">
          <source>at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; plus room for other applications</source>
          <target state="translated">적어도 &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; 및 다른 응용 프로그램을위한 공간</target>
        </trans-unit>
        <trans-unit id="72b7c9e2eb3bd23a8fd3c8e377b81389e5a528cf" translate="yes" xml:space="preserve">
          <source>auth_delay</source>
          <target state="translated">auth_delay</target>
        </trans-unit>
        <trans-unit id="ad397fd87c3e39210986b3c99c01e01ebcf26995" translate="yes" xml:space="preserve">
          <source>authorization identifier membership relationships</source>
          <target state="translated">인증 식별자 멤버십 관계</target>
        </trans-unit>
        <trans-unit id="d2896d216ff2416211d2a0e36e3d0a7b13db82ff" translate="yes" xml:space="preserve">
          <source>authorization identifiers (roles)</source>
          <target state="translated">인증 식별자 (역할)</target>
        </trans-unit>
        <trans-unit id="b483ffa7f9b4926c39834e971e056d9afed0e3b7" translate="yes" xml:space="preserve">
          <source>auto_explain</source>
          <target state="translated">auto_explain</target>
        </trans-unit>
        <trans-unit id="3286d9c6ac632aa037945fb31c0e37f0dd633546" translate="yes" xml:space="preserve">
          <source>autoincrementing eight-byte integer</source>
          <target state="translated">8 바이트 정수 자동 증가</target>
        </trans-unit>
        <trans-unit id="1e4abd38ff5fb04fd9cc6e1989de0864a83533bd" translate="yes" xml:space="preserve">
          <source>autoincrementing four-byte integer</source>
          <target state="translated">4 바이트 정수 자동 증가</target>
        </trans-unit>
        <trans-unit id="2162f05f39e1f496096d2494f2a79d5030c2b804" translate="yes" xml:space="preserve">
          <source>autoincrementing integer</source>
          <target state="translated">자동 증가 정수</target>
        </trans-unit>
        <trans-unit id="954cc0f6e210f639b3c9f9351202ace47d52913a" translate="yes" xml:space="preserve">
          <source>autoincrementing two-byte integer</source>
          <target state="translated">2 바이트 정수 자동 증가</target>
        </trans-unit>
        <trans-unit id="8d3a645cd2a324f0617182d92fe36ab22475ce17" translate="yes" xml:space="preserve">
          <source>available extensions</source>
          <target state="translated">사용 가능한 확장</target>
        </trans-unit>
        <trans-unit id="0cc0f41b2e69a6e8bf4387c1a1ce9ef5e7d390b0" translate="yes" xml:space="preserve">
          <source>available versions of extensions</source>
          <target state="translated">사용 가능한 확장 버전</target>
        </trans-unit>
        <trans-unit id="9a6de5e0d48d7fb642bda1b378500dd99c53f1dd" translate="yes" xml:space="preserve">
          <source>average of the dependent variable (&lt;code&gt;sum(Y)/N&lt;/code&gt;)</source>
          <target state="translated">종속 변수의 평균 ( &lt;code&gt;sum(Y)/N&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f20b015e8a66fb8ce9b0949ef84f41895f7b022b" translate="yes" xml:space="preserve">
          <source>average of the independent variable (&lt;code&gt;sum(X)/N&lt;/code&gt;)</source>
          <target state="translated">독립 변수의 평균 ( &lt;code&gt;sum(X)/N&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3853072116a861ff4c871d3e96a9cac7da78b7d2" translate="yes" xml:space="preserve">
          <source>backslash</source>
          <target state="translated">backslash</target>
        </trans-unit>
        <trans-unit id="4930eb3f60df3a6a61e8d44178feb2b8f820a153" translate="yes" xml:space="preserve">
          <source>backspace</source>
          <target state="translated">backspace</target>
        </trans-unit>
        <trans-unit id="66cdf1600430f705cc4d8f5e11204829f8383256" translate="yes" xml:space="preserve">
          <source>backspace, as in C</source>
          <target state="translated">C에서와 같이 백 스페이스</target>
        </trans-unit>
        <trans-unit id="7f0d7679eb22f81f891057708c71dfb599a38184" translate="yes" xml:space="preserve">
          <source>base 10 logarithm</source>
          <target state="translated">밑이 10 인 로그</target>
        </trans-unit>
        <trans-unit id="b749c20d2998dde8c54f69e19a74da9a0e84fc42" translate="yes" xml:space="preserve">
          <source>base frequency of this MCV item</source>
          <target state="translated">이 MCV 항목의 기본 주파수</target>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="9965fcf7de748d3c770146162736f22b09a2ffad" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;postgres&lt;/code&gt; gets stemmed to &lt;code&gt;postgr&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 가 &lt;code&gt;postgr&lt;/code&gt; 로 줄기 때문에 :</target>
        </trans-unit>
        <trans-unit id="af23afc243510d2615878774b81457104ad38f78" translate="yes" xml:space="preserve">
          <source>because a repeatable read transaction cannot modify or lock rows changed by other transactions after the repeatable read transaction began.</source>
          <target state="translated">반복 가능한 읽기 트랜잭션이 시작된 후에는 반복 가능한 읽기 트랜잭션이 다른 트랜잭션에 의해 변경된 행을 수정하거나 잠글 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cbcbd26ed5be476f354422d6b658763c38b229f1" translate="yes" xml:space="preserve">
          <source>because in absence of a column list the primary key of the referenced table is used as the referenced column(s).</source>
          <target state="translated">열 목록이 없으면 참조 된 테이블의 기본 키가 참조 된 열로 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2d96d3c2be8f36cf4d125d8a4ee9c4468f5d1613" translate="yes" xml:space="preserve">
          <source>because it attempts to apply a collation to the result of the &lt;code&gt;&amp;gt;&lt;/code&gt; operator, which is of the non-collatable data type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">비교할 수없는 데이터 유형이 &lt;code&gt;boolean&lt;/code&gt; 인 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자 의 결과에 데이터 정렬을 적용하려고 시도하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="5d39b947f257995ccfde497491739ecd566455f0" translate="yes" xml:space="preserve">
          <source>because the parser has no idea &amp;mdash; until it is too late &amp;mdash; that &lt;code&gt;!&lt;/code&gt; is defined as a postfix operator, not an infix one. To get the desired behavior in this case, you must write:</source>
          <target state="translated">파서는 너무 늦을 때까지는 전혀 모릅니다 &lt;code&gt;!&lt;/code&gt; 는 접미사가 아닌 접미사 연산자로 정의됩니다. 이 경우 원하는 동작을 얻으려면 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc3a884c6b37262fcaf12532a1f9c235ecbf4b6d" translate="yes" xml:space="preserve">
          <source>because the server will reject the file if its permissions are more liberal than this. For more details on how to create your server private key and certificate, refer to the OpenSSL documentation.</source>
          <target state="translated">권한이 이것보다 더 자유롭다면 서버는 파일을 거부하기 때문입니다. 서버 개인 키 및 인증서를 만드는 방법에 대한 자세한 내용은 OpenSSL 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd03a44af506549f106aba97d42f455d1fa7455f" translate="yes" xml:space="preserve">
          <source>begins with the label &lt;code&gt;Top&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Top&lt;/code&gt; 레이블로 시작</target>
        </trans-unit>
        <trans-unit id="709634051471385aada32356842983beeff4b065" translate="yes" xml:space="preserve">
          <source>between</source>
          <target state="translated">between</target>
        </trans-unit>
        <trans-unit id="2ec6bc31b898e16ec539ddbd405a5a171a3df210" translate="yes" xml:space="preserve">
          <source>between, after sorting the comparison values</source>
          <target state="translated">비교 값을 정렬 한 후</target>
        </trans-unit>
        <trans-unit id="5f9c9d32d71f1ef8b8014c350a5f8aec50c577ec" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="translated">bigint</target>
        </trans-unit>
        <trans-unit id="77277e00630649e46e2738e754d21819c7bc1bf5" translate="yes" xml:space="preserve">
          <source>bigserial</source>
          <target state="translated">bigserial</target>
        </trans-unit>
        <trans-unit id="e52bf437dfb9f0dadee4cb21fac3d9c8ada93bb1" translate="yes" xml:space="preserve">
          <source>binary JSON data, decomposed</source>
          <target state="translated">이진 JSON 데이터, 분해</target>
        </trans-unit>
        <trans-unit id="02ab455c076e6f4b354b1446757e9a4b0a79445f" translate="yes" xml:space="preserve">
          <source>binary data (&amp;ldquo;byte array&amp;rdquo;)</source>
          <target state="translated">이진 데이터 ( &quot;바이트 배열&quot;)</target>
        </trans-unit>
        <trans-unit id="892a67172f0a564c168e95647e62558366e70470" translate="yes" xml:space="preserve">
          <source>bit varying</source>
          <target state="translated">조금 변화</target>
        </trans-unit>
        <trans-unit id="4ba5b46e332d373dfdfa248036598eb70f831d32" translate="yes" xml:space="preserve">
          <source>bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="898900a45561d4f119a2ed52510f1ace0fda7e60" translate="yes" xml:space="preserve">
          <source>bitwise NOT</source>
          <target state="translated">비트 NOT</target>
        </trans-unit>
        <trans-unit id="7d5bb4d1e43ddd2b7554d5d7d0b44fa8e15c9b68" translate="yes" xml:space="preserve">
          <source>bitwise OR</source>
          <target state="translated">비트 OR</target>
        </trans-unit>
        <trans-unit id="8f0757e0ba4c22c9e209a79597f6b1dc188081e0" translate="yes" xml:space="preserve">
          <source>bitwise XOR</source>
          <target state="translated">비트 XOR</target>
        </trans-unit>
        <trans-unit id="e8be396aab93c1fef2fc7e54326638d41fd49ba3" translate="yes" xml:space="preserve">
          <source>bitwise shift left</source>
          <target state="translated">비트 시프트 왼쪽</target>
        </trans-unit>
        <trans-unit id="ee3a57994d0683b1945f1e65426a85e401e290c1" translate="yes" xml:space="preserve">
          <source>bitwise shift right</source>
          <target state="translated">비트 시프트 오른쪽</target>
        </trans-unit>
        <trans-unit id="5812e2b7356193b66b6555bd2fa41ed3da124f67" translate="yes" xml:space="preserve">
          <source>bloom</source>
          <target state="translated">bloom</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="65fc5cc5f306627f2ee258292e0df90691c67af1" translate="yes" xml:space="preserve">
          <source>both date and time (no time zone)</source>
          <target state="translated">날짜와 시간 모두 (시간대 없음)</target>
        </trans-unit>
        <trans-unit id="a27279f9f262e5ba8cd291de1630ce7357a275c8" translate="yes" xml:space="preserve">
          <source>both date and time, with time zone</source>
          <target state="translated">시간대와 날짜 및 시간 모두</target>
        </trans-unit>
        <trans-unit id="33ca9adbe02fe4b2c1b14995a225396cc073c647" translate="yes" xml:space="preserve">
          <source>both of which sort by the first output column. Note that an output column name has to stand alone, that is, it cannot be used in an expression &amp;mdash; for example, this is &lt;em&gt;not&lt;/em&gt; correct:</source>
          <target state="translated">둘 다 첫 번째 출력 열을 기준으로 정렬합니다. 출력 열 이름은 독립형이어야합니다. 즉, 표현식에 사용할 수 없습니다 (예 : 올바르지 &lt;em&gt;않음)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8cde009a0af187221e6f6dd025a6cf362c599c99" translate="yes" xml:space="preserve">
          <source>box diagonal to line segment</source>
          <target state="translated">상자 대각선에서 선분으로</target>
        </trans-unit>
        <trans-unit id="6f5d0d15c57b74089e23ebb9522965d12a29230c" translate="yes" xml:space="preserve">
          <source>box to 4-point polygon</source>
          <target state="translated">4 점 다각형 상자</target>
        </trans-unit>
        <trans-unit id="96b6dbd46e1f666fe3c50b034ebe2000e41de085" translate="yes" xml:space="preserve">
          <source>box to circle</source>
          <target state="translated">원형 상자</target>
        </trans-unit>
        <trans-unit id="1ca211a26e16f8cade4a85971d5852f1c33fff52" translate="yes" xml:space="preserve">
          <source>boxes to bounding box</source>
          <target state="translated">경계 상자에 상자</target>
        </trans-unit>
        <trans-unit id="7e65a745a42ef9c805310b0bccb5bfa33fa4d8e9" translate="yes" xml:space="preserve">
          <source>broadcast address for network</source>
          <target state="translated">네트워크의 브로드 캐스트 주소</target>
        </trans-unit>
        <trans-unit id="7e429fb710b1bd41375b836cf8242f042f2393a6" translate="yes" xml:space="preserve">
          <source>btree_gin</source>
          <target state="translated">btree_gin</target>
        </trans-unit>
        <trans-unit id="d4fc5c2b17c1dc2564aad5782a24ec87dbb33485" translate="yes" xml:space="preserve">
          <source>btree_gist</source>
          <target state="translated">btree_gist</target>
        </trans-unit>
        <trans-unit id="59d8e37e115d9900867db7d20d223db479f6ea75" translate="yes" xml:space="preserve">
          <source>build an &lt;code&gt;aclitem&lt;/code&gt; from input</source>
          <target state="translated">입력 에서 &lt;code&gt;aclitem&lt;/code&gt; 을 짓다</target>
        </trans-unit>
        <trans-unit id="0c70d21c53edbb94215b7aa66f5ea7d3aa0b789c" translate="yes" xml:space="preserve">
          <source>built-in logical repl., pglogical</source>
          <target state="translated">built-in logical repl., pglogical</target>
        </trans-unit>
        <trans-unit id="6310070850ba6f8f16435b6767ef6e3d84d1b51c" translate="yes" xml:space="preserve">
          <source>built-in logical replication, pglogical</source>
          <target state="translated">내장 논리 복제, pglogical</target>
        </trans-unit>
        <trans-unit id="0a4f60411d00d9bc19c78893536c661c6bb4cbb3" translate="yes" xml:space="preserve">
          <source>built-in streaming repl.</source>
          <target state="translated">built-in streaming repl.</target>
        </trans-unit>
        <trans-unit id="0b8c9efbbdae1b8096b4be992666e1f2306047c9" translate="yes" xml:space="preserve">
          <source>built-in streaming replication</source>
          <target state="translated">내장 스트리밍 복제</target>
        </trans-unit>
        <trans-unit id="d9b843a298d5353ed2a7fe506917dc36463cf904" translate="yes" xml:space="preserve">
          <source>but not all type names can be used in this way; see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt; for details.</source>
          <target state="translated">그러나 모든 유형 이름을 이런 식으로 사용할 수있는 것은 아닙니다. 자세한 내용 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;은 4.2.9 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f09f88b6f29fee99798bea8929b062956fb7df58" translate="yes" xml:space="preserve">
          <source>but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">그러나 실제 사용에는 &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장에&lt;/a&gt; 설명 된대로 텍스트 검색 구성에 포함하는 것이 포함됩니다 . 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="931bb3d7295a22ba60e407c439a2751b6a2e54c6" translate="yes" xml:space="preserve">
          <source>but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</target>
        </trans-unit>
        <trans-unit id="47b8dd0ef1d9374c938682dcc12763e6b91b0511" translate="yes" xml:space="preserve">
          <source>but that approach is less flexible, and often less efficient as well.</source>
          <target state="translated">그러나이 방법은 유연성이 떨어지고 종종 효율성도 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="777c2dee3f742dec7bfd8f0986b9928f96755335" translate="yes" xml:space="preserve">
          <source>but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; bind address, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt;. This is usually not what you want.</source>
          <target state="translated">but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; bind address, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt; . This is usually not what you want.</target>
        </trans-unit>
        <trans-unit id="ee2c835e71e434c69308497a09a58270d6b3eddb" translate="yes" xml:space="preserve">
          <source>but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; interface, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt;. This is usually not what you want.</source>
          <target state="translated">그러나 데이터베이스 서버는 기본 설정 &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt; 의해 열리지 않은 &lt;code&gt;foo.com&lt;/code&gt; 인터페이스 에서 연결이 들어오는 것으로 간주 합니다. 이것은 일반적으로 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="254eff7ff12131042b7e5d6791570b4b68f6d612" translate="yes" xml:space="preserve">
          <source>but these queries could not:</source>
          <target state="translated">그러나이 쿼리는 할 수 없었습니다 :</target>
        </trans-unit>
        <trans-unit id="f051e659481b1bdec5c2a7ae3f0ba578a9c5a900" translate="yes" xml:space="preserve">
          <source>but this does:</source>
          <target state="translated">그러나 이것은 :</target>
        </trans-unit>
        <trans-unit id="0b6affe425ac3cac0ecdcc4b798bd2ce34e6c9ad" translate="yes" xml:space="preserve">
          <source>but this will not work since the aggregate &lt;code&gt;max&lt;/code&gt; cannot be used in the &lt;code&gt;WHERE&lt;/code&gt; clause. (This restriction exists because the &lt;code&gt;WHERE&lt;/code&gt; clause determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before aggregate functions are computed.) However, as is often the case the query can be restated to accomplish the desired result, here by using a &lt;em&gt;subquery&lt;/em&gt;:</source>
          <target state="translated">그러나 집계 &lt;code&gt;max&lt;/code&gt; 을 &lt;code&gt;WHERE&lt;/code&gt; 절 에서 사용할 수 없으므로 작동 하지 않습니다 . ( &lt;code&gt;WHERE&lt;/code&gt; 절이 집계 계산에 포함될 행을 결정 하기 때문에이 제한이 존재하므로 집계 함수를 계산하기 전에 분명히 평가해야합니다.) 그러나 종종 원하는 결과를 얻기 위해 쿼리를 다시 작성할 수 있습니다. &lt;em&gt;하위 쿼리&lt;/em&gt; 를 사용하여 여기에 :</target>
        </trans-unit>
        <trans-unit id="b94da3599274cc93c9ee4f4d4dce4fea875b2503" translate="yes" xml:space="preserve">
          <source>but:</source>
          <target state="translated">but:</target>
        </trans-unit>
        <trans-unit id="ca4a2057bd9e261b071397023cf198c3db0688ef" translate="yes" xml:space="preserve">
          <source>calendar date (year, month, day)</source>
          <target state="translated">달력 날짜 (년, 월, 일)</target>
        </trans-unit>
        <trans-unit id="3f5ae5c8becacd92f5b89cba285014d49fe90e2c" translate="yes" xml:space="preserve">
          <source>can also be used.</source>
          <target state="translated">사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a9f2d676dd4658059a5f07359111b9cc42edcba" translate="yes" xml:space="preserve">
          <source>can be increased by recompiling PostgreSQL</source>
          <target state="translated">PostgreSQL을 다시 컴파일하여 증가시킬 수 있습니다</target>
        </trans-unit>
        <trans-unit id="07b307ab5d0c778628385e3d5dbb950c4bbe7a5d" translate="yes" xml:space="preserve">
          <source>can be used too, but at present this is just for &lt;em&gt;pro forma&lt;/em&gt; compliance with the SQL standard. If you write a database name, it must be the same as the database you are connected to.</source>
          <target state="translated">도 사용하지만, 현재 이것은 단지입니다 수 있습니다 &lt;em&gt;외형&lt;/em&gt; SQL 표준을 준수. 데이터베이스 이름을 쓰면 연결된 데이터베이스 이름과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="45514644f4621795d582e24c02cb7cf058d26351" translate="yes" xml:space="preserve">
          <source>can equivalently be written as:</source>
          <target state="translated">다음과 같이 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6e9f192b79a14968d26f70ab1aa8e21b65e3df64" translate="yes" xml:space="preserve">
          <source>carriage return</source>
          <target state="translated">캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="def334c5877ea4f63b5575fa4cc2f60305278d07" translate="yes" xml:space="preserve">
          <source>carriage return, as in C</source>
          <target state="translated">C에서와 같이 캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="f99b34b4fa1fea2ca07ad8897d13ba6b1206cc37" translate="yes" xml:space="preserve">
          <source>case-insensitive matching (see &lt;a href=&quot;functions-matching#POSIX-MATCHING-RULES&quot;&gt;Section 9.7.3.5&lt;/a&gt;) (overrides operator type)</source>
          <target state="translated">대소 문자를 구분하지 않는 일치 ( &lt;a href=&quot;functions-matching#POSIX-MATCHING-RULES&quot;&gt;9.7.3.5 절&lt;/a&gt; 참조 ) (연산자 유형 재정의)</target>
        </trans-unit>
        <trans-unit id="3e82d968dc00f833dad374e757a334e4a040c90c" translate="yes" xml:space="preserve">
          <source>case-sensitive matching (overrides operator type)</source>
          <target state="translated">대소 문자 구분 일치 (연산자 유형을 대체 함)</target>
        </trans-unit>
        <trans-unit id="5bf41021d1e013cdbe5336b032060b46fb810232" translate="yes" xml:space="preserve">
          <source>cast &lt;code&gt;ltree&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 를 &lt;code&gt;text&lt;/code&gt; 캐스트</target>
        </trans-unit>
        <trans-unit id="ed1123013c2bd604bb0d461547480f74dc473e37" translate="yes" xml:space="preserve">
          <source>cast &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 를 &lt;code&gt;ltree&lt;/code&gt; 로 캐스트</target>
        </trans-unit>
        <trans-unit id="a283f70188863d91855937695daa6c350cfcf558" translate="yes" xml:space="preserve">
          <source>cast to double</source>
          <target state="translated">두 배로 캐스팅</target>
        </trans-unit>
        <trans-unit id="34472e7f0cad05f2b2dd139e2a7581cfa2e2f29a" translate="yes" xml:space="preserve">
          <source>cast to int</source>
          <target state="translated">int로 캐스팅</target>
        </trans-unit>
        <trans-unit id="542ab67ef49ce56f684a8718e87598af02f5d74b" translate="yes" xml:space="preserve">
          <source>casts (data type conversions)</source>
          <target state="translated">캐스트 (데이터 유형 변환)</target>
        </trans-unit>
        <trans-unit id="305047e96ec089021660ee5965f893ac80268731" translate="yes" xml:space="preserve">
          <source>center</source>
          <target state="translated">center</target>
        </trans-unit>
        <trans-unit id="1c324c54487e53c22fd01ca907a0c848c8a583d9" translate="yes" xml:space="preserve">
          <source>center and radius to circle</source>
          <target state="translated">중심과 반지름</target>
        </trans-unit>
        <trans-unit id="81a86dca1152d33417863c0f5f4e6cf2b16480a6" translate="yes" xml:space="preserve">
          <source>center of box</source>
          <target state="translated">상자 중심</target>
        </trans-unit>
        <trans-unit id="2ec0ff924735c49e81d70e8e2c7d6dfe9d7d60bc" translate="yes" xml:space="preserve">
          <source>center of circle</source>
          <target state="translated">원의 중심</target>
        </trans-unit>
        <trans-unit id="525b6f618cb47140c2374dbe02a53765c3c85c24" translate="yes" xml:space="preserve">
          <source>center of line segment</source>
          <target state="translated">선분 중심</target>
        </trans-unit>
        <trans-unit id="33d628e71b8e6a1a2c384ae970e47570fc0b9a61" translate="yes" xml:space="preserve">
          <source>center of polygon</source>
          <target state="translated">다각형의 중심</target>
        </trans-unit>
        <trans-unit id="21957663c4fb58419a0c98a3724294cbfdbf1a7f" translate="yes" xml:space="preserve">
          <source>century (2 digits) (the twenty-first century starts on 2001-01-01)</source>
          <target state="translated">세기 (2 자리) (21 세기는 2001-01-01에 시작)</target>
        </trans-unit>
        <trans-unit id="370ecf2ad70a13142bf3174e9abe256169452bd0" translate="yes" xml:space="preserve">
          <source>certificates revoked by certificate authorities</source>
          <target state="translated">인증 기관에서 해지 한 인증서</target>
        </trans-unit>
        <trans-unit id="932784433f85ba8abc6f12c517aaf96068258f16" translate="yes" xml:space="preserve">
          <source>channel names that the session is currently listening on</source>
          <target state="translated">세션이 현재 청취중인 채널 이름</target>
        </trans-unit>
        <trans-unit id="f0db3fa401aea04b711d6f1f3630552eaaee8e59" translate="yes" xml:space="preserve">
          <source>character</source>
          <target state="translated">character</target>
        </trans-unit>
        <trans-unit id="d0eb7b3b4e386ffe76f12fc6f7502ffde2a5b1ca" translate="yes" xml:space="preserve">
          <source>character varying</source>
          <target state="translated">다양한 캐릭터</target>
        </trans-unit>
        <trans-unit id="eea64a15c7c41d6cf7da5318bba35b0dfa86b13f" translate="yes" xml:space="preserve">
          <source>check clusters only, don't change any data</source>
          <target state="translated">클러스터 만 확인하고 데이터를 변경하지 마십시오</target>
        </trans-unit>
        <trans-unit id="a29a96de4ab639d87155b423113f741d6b399fca" translate="yes" xml:space="preserve">
          <source>check constraints, unique constraints, primary key constraints, foreign key constraints</source>
          <target state="translated">제약 조건 확인, 고유 제약 조건, 기본 키 제약 조건, 외래 키 제약 조건</target>
        </trans-unit>
        <trans-unit id="4b91f9d8b975eee622772ea62a86896ef4ef61ce" translate="yes" xml:space="preserve">
          <source>checks that client certificate is signed by a trusted certificate authority</source>
          <target state="translated">클라이언트 인증서가 신뢰할 수있는 인증 기관에 의해 서명되었는지 확인</target>
        </trans-unit>
        <trans-unit id="00b7b8118efde44c546b69243ec15b21cd64c9d9" translate="yes" xml:space="preserve">
          <source>circle</source>
          <target state="translated">circle</target>
        </trans-unit>
        <trans-unit id="bfac9bc25b5fb8f2fa83ccb26e83e30c35a3a06c" translate="yes" xml:space="preserve">
          <source>circle on a plane</source>
          <target state="translated">비행기에 동그라미</target>
        </trans-unit>
        <trans-unit id="fe2bd0ef7b1249d0169c74005f37ca2fd5a93734" translate="yes" xml:space="preserve">
          <source>circle to 12-point polygon</source>
          <target state="translated">12 점 다각형의 원</target>
        </trans-unit>
        <trans-unit id="ddf50c7158a693b8ba86924c5d88bec2f50e83aa" translate="yes" xml:space="preserve">
          <source>circle to &lt;code&gt;npts&lt;/code&gt;-point polygon</source>
          <target state="translated">원에서 &lt;code&gt;npts&lt;/code&gt; 포인트 다각형</target>
        </trans-unit>
        <trans-unit id="ad3b153d9429c109e68ce6ced77c4260d4c34577" translate="yes" xml:space="preserve">
          <source>circle to box</source>
          <target state="translated">상자에 동그라미</target>
        </trans-unit>
        <trans-unit id="e241ce9d9ce43d18211ad61727ab59139118a131" translate="yes" xml:space="preserve">
          <source>citext</source>
          <target state="translated">citext</target>
        </trans-unit>
        <trans-unit id="751266a7fa555fd650fe60f7bd15324008f60eaf" translate="yes" xml:space="preserve">
          <source>client certificate must not be on this list</source>
          <target state="translated">클라이언트 인증서는이 목록에 없어야합니다</target>
        </trans-unit>
        <trans-unit id="12c22af93332ba93d2c7d1b12c8c3a6239448f8b" translate="yes" xml:space="preserve">
          <source>client character set representation</source>
          <target state="translated">클라이언트 문자 세트 표현</target>
        </trans-unit>
        <trans-unit id="fe3b3f96eb8a29aa95ee6742e5391daa5a853668" translate="yes" xml:space="preserve">
          <source>closed geometric path on a plane</source>
          <target state="translated">평면에 닫힌 형상 경로</target>
        </trans-unit>
        <trans-unit id="9d2a05384389e39e55a9fb33419864a52dc20579" translate="yes" xml:space="preserve">
          <source>cluster's install user name; environment variable &lt;code&gt;PGUSER&lt;/code&gt;</source>
          <target state="translated">클러스터의 설치 사용자 이름; 환경 변수 &lt;code&gt;PGUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39f2375a466659e991122be876571fa32e1c3224" translate="yes" xml:space="preserve">
          <source>clusterdb</source>
          <target state="translated">clusterdb</target>
        </trans-unit>
        <trans-unit id="823fd4756652ecc890aa45a56776dffb0e59f612" translate="yes" xml:space="preserve">
          <source>clusterdb &amp;mdash; cluster a PostgreSQL database</source>
          <target state="translated">clusterdb &amp;mdash; PostgreSQL 데이터베이스 클러스터</target>
        </trans-unit>
        <trans-unit id="d5bb141c39226c781b730bc7a91ab0f06285e4f0" translate="yes" xml:space="preserve">
          <source>clusterdb accepts the following command-line arguments:</source>
          <target state="translated">clusterdb는 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cf3ac3c5cfb26bd0e1f0c4ae38487d9d7c314d08" translate="yes" xml:space="preserve">
          <source>clusterdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">clusterdb는 또한 연결 매개 변수에 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e2fe317f2e4ea451e21fc774dc0d79619e64edfd" translate="yes" xml:space="preserve">
          <source>clusterdb is a utility for reclustering tables in a PostgreSQL database. It finds tables that have previously been clustered, and clusters them again on the same index that was last used. Tables that have never been clustered are not affected.</source>
          <target state="translated">clusterdb는 PostgreSQL 데이터베이스에서 테이블을 다시 클러스터링하는 유틸리티입니다. 이전에 클러스터 된 테이블을 찾아 마지막으로 사용한 동일한 인덱스에서 다시 클러스터합니다. 클러스터되지 않은 테이블은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd2735ad5e6a19ac7e1140a224c1c24a97fc9e17" translate="yes" xml:space="preserve">
          <source>clusterdb is a wrapper around the SQL command &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;. There is no effective difference between clustering databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">clusterdb는 SQL 명령 &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER를&lt;/a&gt; 감싸는 래퍼 입니다. 이 유틸리티와 서버에 액세스하기위한 다른 방법을 통한 데이터베이스 클러스터링에는 효과적인 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f1784fa738e6d5473ab5f43d736a5f44fb259b0" translate="yes" xml:space="preserve">
          <source>collation name</source>
          <target state="translated">collation name</target>
        </trans-unit>
        <trans-unit id="bea494244f54b23f44820cb069f810bb4eca7c7b" translate="yes" xml:space="preserve">
          <source>collations (locale information)</source>
          <target state="translated">데이터 정렬 (로캘 정보)</target>
        </trans-unit>
        <trans-unit id="f6e81a8e1f0b533eb70f9ceeb98b3f99d57e7764" translate="yes" xml:space="preserve">
          <source>column default values</source>
          <target state="translated">열 기본값</target>
        </trans-unit>
        <trans-unit id="fe7f2cdd0d102e4f8a30abbef55f21da4b2ba7d9" translate="yes" xml:space="preserve">
          <source>columns per index</source>
          <target state="translated">인덱스 당 열</target>
        </trans-unit>
        <trans-unit id="ff07f44a4127edb55f44386b09eae02d54daca39" translate="yes" xml:space="preserve">
          <source>columns per table</source>
          <target state="translated">테이블 당 열</target>
        </trans-unit>
        <trans-unit id="f34c9877f2bf68c0333fc87b9e95a52bc11e5b67" translate="yes" xml:space="preserve">
          <source>comments on shared objects</source>
          <target state="translated">공유 객체에 대한 의견</target>
        </trans-unit>
        <trans-unit id="7b66eba0b67c3b9e73cc97b3d1b94a251d742d90" translate="yes" xml:space="preserve">
          <source>comparison operators</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="8154454006381d49284649c66b2403f81afb118d" translate="yes" xml:space="preserve">
          <source>compile-time configuration parameters</source>
          <target state="translated">컴파일 타임 구성 매개 변수</target>
        </trans-unit>
        <trans-unit id="55a34178d77f1c51b211c756f759f8cf161a23d4" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;hstore&lt;/code&gt;s</source>
          <target state="translated">CONCATENATE &lt;code&gt;hstore&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="8e1ad14ad4374d48d20d7479ab315932269fbff4" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;ltree&lt;/code&gt; paths</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 경로 연결</target>
        </trans-unit>
        <trans-unit id="29b58ef42868498f9fead6297c0c68588c926edf" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;tsvector&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; s를 연결</target>
        </trans-unit>
        <trans-unit id="2c4447d1d44ee3c074941b8c08ca342d23d066f6" translate="yes" xml:space="preserve">
          <source>concatenate two arrays</source>
          <target state="translated">두 배열을 연결</target>
        </trans-unit>
        <trans-unit id="22d0551615cf0d8546cc1c9c81d271b5e72e2fda" translate="yes" xml:space="preserve">
          <source>concatenates array elements using supplied delimiter and optional null string</source>
          <target state="translated">제공된 구분 기호 및 선택적 null 문자열을 사용하여 배열 요소를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="5c93b563298b75fc6d2f4fcfedc5ca6dd370b747" translate="yes" xml:space="preserve">
          <source>concatenation</source>
          <target state="translated">concatenation</target>
        </trans-unit>
        <trans-unit id="5fff9a64a91f5155fd20f1f5322675919eba1779" translate="yes" xml:space="preserve">
          <source>concatenation of non-null XML values (see also &lt;a href=&quot;functions-xml#FUNCTIONS-XML-XMLAGG&quot;&gt;Section 9.14.1.7&lt;/a&gt;)</source>
          <target state="translated">널이 아닌 XML 값의 연결 ( &lt;a href=&quot;functions-xml#FUNCTIONS-XML-XMLAGG&quot;&gt;섹션 9.14.1.7&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="cab21417f26804f2821e9cba7ec02b3d22bb0dcb" translate="yes" xml:space="preserve">
          <source>condition that has a format similar to the format of regular expressions.</source>
          <target state="translated">정규 표현식 형식과 유사한 형식을 갖는 조건.</target>
        </trans-unit>
        <trans-unit id="bdd9e092f915a4d94a6a2f20a48a3e86b741db40" translate="yes" xml:space="preserve">
          <source>configuration load time</source>
          <target state="translated">구성로드 시간</target>
        </trans-unit>
        <trans-unit id="d1fa507954b44038b5d98dbdafb2b36374cc6386" translate="yes" xml:space="preserve">
          <source>constrained by maximum relations per database</source>
          <target state="translated">데이터베이스 당 최대 관계에 의해 제한됨</target>
        </trans-unit>
        <trans-unit id="242491a8bd7940610b5e65d571dcdb5c72e647a2" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from a record or row</source>
          <target state="translated">레코드 또는 행에서 &lt;code&gt;hstore&lt;/code&gt; 를 구성</target>
        </trans-unit>
        <trans-unit id="c929167cb94b880f0746653e53959fc18c0bf793" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from an array, which may be either a key/value array, or a two-dimensional array</source>
          <target state="translated">키 / 값 배열 또는 2 차원 배열 일 수있는 배열에서 &lt;code&gt;hstore&lt;/code&gt; 를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="bbd40f04098912d0ba742a8bc5af223e27c7adda" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from separate key and value arrays</source>
          <target state="translated">별도의 키 및 값 배열에서 &lt;code&gt;hstore&lt;/code&gt; 를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="3cc74499a516b13f15e51d5c826818942c36a609" translate="yes" xml:space="preserve">
          <source>construct host mask for network</source>
          <target state="translated">네트워크를위한 호스트 마스크 구성</target>
        </trans-unit>
        <trans-unit id="b01b9cfc44c043d7e34a6cc2f5c24aa8c879193c" translate="yes" xml:space="preserve">
          <source>construct netmask for network</source>
          <target state="translated">네트워크를위한 넷 마스크 구성</target>
        </trans-unit>
        <trans-unit id="14dd4fbbe8eed4db88e77a3d9dee637dfc2d10c4" translate="yes" xml:space="preserve">
          <source>construct point</source>
          <target state="translated">구성 점</target>
        </trans-unit>
        <trans-unit id="b75f26d172a89e83c2261d72cb9d9e1b5ef7769c" translate="yes" xml:space="preserve">
          <source>contained &amp;mdash; &lt;code&gt;true&lt;/code&gt; if left array is contained in right array</source>
          <target state="translated">contains &amp;mdash; 왼쪽 배열이 오른쪽 배열에 포함되어 있으면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caeb909ae4ff4ee25a0ff0d476946ed256f2aee1" translate="yes" xml:space="preserve">
          <source>contains</source>
          <target state="translated">contains</target>
        </trans-unit>
        <trans-unit id="0957a97cac9a10ebe40f435c740cc3345b2efc3f" translate="yes" xml:space="preserve">
          <source>contains &amp;mdash; &lt;code&gt;true&lt;/code&gt; if left array contains right array</source>
          <target state="translated">contains &amp;mdash; 왼쪽 배열에 오른쪽 배열이 있으면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="007f7efed9b7619cf2555d2be05833ff839d3962" translate="yes" xml:space="preserve">
          <source>contains element</source>
          <target state="translated">요소를 포함</target>
        </trans-unit>
        <trans-unit id="e74dd6ca81a7e2eecc18f2ec9e65ec0ea5be7ef4" translate="yes" xml:space="preserve">
          <source>contains or equals</source>
          <target state="translated">포함하거나 같음</target>
        </trans-unit>
        <trans-unit id="ce904d2429dea4c4cd6a0c965103aaf0e346da09" translate="yes" xml:space="preserve">
          <source>contains or is contained by</source>
          <target state="translated">포함하거나 포함</target>
        </trans-unit>
        <trans-unit id="e75b7119f1d5d414ff82917ba2603bf9e5b45df6" translate="yes" xml:space="preserve">
          <source>contains range</source>
          <target state="translated">범위를 포함</target>
        </trans-unit>
        <trans-unit id="19f826ba869b2fee68bf1f114b8e677ae0c0d856" translate="yes" xml:space="preserve">
          <source>continuous percentile: returns a value corresponding to the specified fraction in the ordering, interpolating between adjacent input items if needed</source>
          <target state="translated">연속 백분위 수 : 순서대로 지정된 분수에 해당하는 값을 반환하고 필요한 경우 인접한 입력 항목 사이를 보간합니다.</target>
        </trans-unit>
        <trans-unit id="36c18c788db3f3304d051679f1b40f05f59e4471" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;hstore&lt;/code&gt; to array of alternating keys and values</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 를 대체 키와 값의 배열 로 변환</target>
        </trans-unit>
        <trans-unit id="a10418c81af1657f4831a46624d04836bc50be5c" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;hstore&lt;/code&gt; to two-dimensional key/value array</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 를 2 차원 키 / 값 배열 로 변환</target>
        </trans-unit>
        <trans-unit id="602cf0e08612bf183b6a1d481640a135b45b733b" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;tsvector&lt;/code&gt; to array of lexemes</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 를 lexemes의 배열 로 변환</target>
        </trans-unit>
        <trans-unit id="6d582c6dfa728d8842a0e41ff985c05950fcac9e" translate="yes" xml:space="preserve">
          <source>convert array of lexemes to &lt;code&gt;tsvector&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 배열을 tsvector 로 변환</target>
        </trans-unit>
        <trans-unit id="042e1227ee9efe77eb7cf25e971dd091316797bb" translate="yes" xml:space="preserve">
          <source>convert integer to string</source>
          <target state="translated">정수를 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="8883e03ee79e5b7ca0bcc6c68d4b71517843c875" translate="yes" xml:space="preserve">
          <source>convert interval to string</source>
          <target state="translated">간격을 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="2c348d29e84f0505a741faf5cd29979ee0784eb6" translate="yes" xml:space="preserve">
          <source>convert numeric to string</source>
          <target state="translated">숫자를 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="e58b5696e1ecb535182f8da0e55ea16d3ba9714b" translate="yes" xml:space="preserve">
          <source>convert path to closed</source>
          <target state="translated">경로를 닫힌 것으로 변환</target>
        </trans-unit>
        <trans-unit id="e8c6b63ef451acece45e4a2472ed3246d96680fa" translate="yes" xml:space="preserve">
          <source>convert path to open</source>
          <target state="translated">경로를 열로 변환</target>
        </trans-unit>
        <trans-unit id="b4e06a2b81ef98774ce30290d2c91fbe2ee0a163" translate="yes" xml:space="preserve">
          <source>convert real/double precision to string</source>
          <target state="translated">실수 / 배정도를 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="16630f62d1ae61b7816445e29898565307e22a6f" translate="yes" xml:space="preserve">
          <source>convert string to date</source>
          <target state="translated">문자열을 날짜로 변환</target>
        </trans-unit>
        <trans-unit id="77457ad94d28223c821b4d450456f45b1fe1f3c5" translate="yes" xml:space="preserve">
          <source>convert string to numeric</source>
          <target state="translated">문자열을 숫자로 변환</target>
        </trans-unit>
        <trans-unit id="d592ee6202ef0abdfa519a7ee4c6978379812ba5" translate="yes" xml:space="preserve">
          <source>convert string to time stamp</source>
          <target state="translated">문자열을 타임 스탬프로 변환</target>
        </trans-unit>
        <trans-unit id="7554307f0c7cf7f9b6e803a9465e3e2cd2090bfa" translate="yes" xml:space="preserve">
          <source>convert text to &lt;code&gt;ltree&lt;/code&gt; and concatenate</source>
          <target state="translated">텍스트를 &lt;code&gt;ltree&lt;/code&gt; 로 변환 하고 연결</target>
        </trans-unit>
        <trans-unit id="176526ef5504731e3313035b22ba3c0b5c8f498b" translate="yes" xml:space="preserve">
          <source>convert time stamp to string</source>
          <target state="translated">타임 스탬프를 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="a3d85881749badcc411aff88ce02fb6973926ade" translate="yes" xml:space="preserve">
          <source>converts the integer constant 42 to type &lt;code&gt;float8&lt;/code&gt; by invoking a previously specified function, in this case &lt;code&gt;float8(int4)&lt;/code&gt;. (If no suitable cast has been defined, the conversion fails.)</source>
          <target state="translated">이전에 지정된 함수 &lt;code&gt;float8(int4)&lt;/code&gt; 이 경우 float8 (int4)) 를 호출 하여 정수 상수 42를 &lt;code&gt;float8&lt;/code&gt; 유형으로 변환합니다 . (적당한 캐스트가 정의되지 않은 경우 변환이 실패합니다.)</target>
        </trans-unit>
        <trans-unit id="9156629cfbed20d63d58fec30d0c098f0e19d25d" translate="yes" xml:space="preserve">
          <source>copy files to the &lt;code&gt;$SHAREDIR/tsearch_data&lt;/code&gt; directory</source>
          <target state="translated">&lt;code&gt;$SHAREDIR/tsearch_data&lt;/code&gt; 디렉토리로 파일 복사</target>
        </trans-unit>
        <trans-unit id="6f5d0356cf2bf7c83124fef63669f30215a05eee" translate="yes" xml:space="preserve">
          <source>correlation coefficient</source>
          <target state="translated">상관 계수</target>
        </trans-unit>
        <trans-unit id="76b5d4c037174657db2ef3d6849098ed26c598c7" translate="yes" xml:space="preserve">
          <source>cosine</source>
          <target state="translated">cosine</target>
        </trans-unit>
        <trans-unit id="92c39d6b13445a5705c2f7b251a21f0fb971660d" translate="yes" xml:space="preserve">
          <source>cotangent</source>
          <target state="translated">cotangent</target>
        </trans-unit>
        <trans-unit id="e3b7cc2c1242a390854b610b0efc253303b2b6fd" translate="yes" xml:space="preserve">
          <source>could be used as input to pg_restore and would only restore items 10 and 6, in that order:</source>
          <target state="translated">pg_restore에 대한 입력으로 사용될 수 있으며 순서대로 항목 10과 6 만 복원합니다.</target>
        </trans-unit>
        <trans-unit id="fa3275b435c87e20aa8f38ceb77beb1839950e18" translate="yes" xml:space="preserve">
          <source>could handle these queries as index-only scans, because &lt;code&gt;y&lt;/code&gt; can be obtained from the index without visiting the heap.</source>
          <target state="translated">는 힙을 방문하지 않고 인덱스에서 &lt;code&gt;y&lt;/code&gt; 를 얻을 수 있기 때문에 이러한 쿼리를 인덱스 전용 스캔으로 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d4415f60a15671f449844424b8af6b0eb46e52d" translate="yes" xml:space="preserve">
          <source>could use the index, because the comparison will by default use the collation of the column. However, this index cannot accelerate queries that involve some other collation. So if queries of the form, say,</source>
          <target state="translated">비교는 기본적으로 열의 데이터 정렬을 사용하기 때문에 인덱스를 사용할 수 있습니다. 그러나이 인덱스는 다른 데이터 정렬과 관련된 쿼리를 가속화 할 수 없습니다. 따라서 다음과 같은 형식의 쿼리가</target>
        </trans-unit>
        <trans-unit id="0bac556c5d3bb14c1fede879eb302b107d254487" translate="yes" xml:space="preserve">
          <source>createdb</source>
          <target state="translated">createdb</target>
        </trans-unit>
        <trans-unit id="6b407470937a987ede5e1a0f6201cc8aa6dfebd1" translate="yes" xml:space="preserve">
          <source>createdb &amp;mdash; create a new PostgreSQL database</source>
          <target state="translated">createdb &amp;mdash; 새로운 PostgreSQL 데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="ddafc0b5a0df99cf7efa3a37dabf9dc9fc318b1d" translate="yes" xml:space="preserve">
          <source>createdb accepts the following command-line arguments:</source>
          <target state="translated">createdb는 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="bbf7672a9395c4080a0583f706be79ec1c196ff7" translate="yes" xml:space="preserve">
          <source>createdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">createdb는 또한 연결 매개 변수에 대해 다음 명령 행 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9470bae91f4b1b94fa4d30d94087484824b0dc48" translate="yes" xml:space="preserve">
          <source>createdb creates a new PostgreSQL database.</source>
          <target state="translated">createdb는 새로운 PostgreSQL 데이터베이스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="048a808c9479ad0cf4813cdc85239ab9acdb44e2" translate="yes" xml:space="preserve">
          <source>createdb is a wrapper around the SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;. There is no effective difference between creating databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">createdb는 SQL 명령 &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE를&lt;/a&gt; 감싸는 래퍼 입니다. 이 유틸리티를 통한 데이터베이스 작성과 다른 서버 액세스 방법을 사용하여 데이터베이스를 작성하는 것 사이에는 효과적인 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df58b9eb4912cb4f51a557c31f280002a97c1cba" translate="yes" xml:space="preserve">
          <source>createuser</source>
          <target state="translated">createuser</target>
        </trans-unit>
        <trans-unit id="b3fcd1b75b88d9bb09cc16243ed746793c22b9e2" translate="yes" xml:space="preserve">
          <source>createuser &amp;mdash; define a new PostgreSQL user account</source>
          <target state="translated">createuser &amp;mdash; 새로운 PostgreSQL 사용자 계정을 정의합니다</target>
        </trans-unit>
        <trans-unit id="d10ac2835716c1122f4b67809fce50fe94a29e90" translate="yes" xml:space="preserve">
          <source>createuser accepts the following command-line arguments:</source>
          <target state="translated">createuser는 다음 명령 행 인수를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="6a28423b7c898a6be61a407aeecb01d59a5820bb" translate="yes" xml:space="preserve">
          <source>createuser also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">createuser는 연결 매개 변수에 대해 다음 명령 행 인수도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d2a84b3f8857986e6dd89f160acf7f9e638227ea" translate="yes" xml:space="preserve">
          <source>createuser creates a new PostgreSQL user (or more precisely, a role). Only superusers and users with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can create new users, so createuser must be invoked by someone who can connect as a superuser or a user with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege.</source>
          <target state="translated">createuser는 새로운 PostgreSQL 사용자 (또는 더 정확하게는 역할)를 만듭니다. &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이있는 수퍼 유저 및 사용자 만 새 사용자를 작성할 수 있으므로 수퍼 유저 또는 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이 있는 사용자가 연결할 수있는 사람이 createuser를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e447ff571994f9f3e3ba25c8d7ecf9fb22fbb73" translate="yes" xml:space="preserve">
          <source>createuser is a wrapper around the SQL command &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. There is no effective difference between creating users via this utility and via other methods for accessing the server.</source>
          <target state="translated">createuser는 SQL 명령 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 주위의 랩퍼 입니다. 이 유틸리티를 통한 사용자 작성과 다른 서버 액세스 방법을 사용하는 것 사이에는 효과적인 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="55f7d1f71091501a0205fba94258266031264150" translate="yes" xml:space="preserve">
          <source>cube</source>
          <target state="translated">cube</target>
        </trans-unit>
        <trans-unit id="a7b0a72c320ec18ab3059928fd9784a02afb8268" translate="yes" xml:space="preserve">
          <source>cube root</source>
          <target state="translated">큐브 루트</target>
        </trans-unit>
        <trans-unit id="12f7353964de624d3d4543c138e1761bcfdc57f8" translate="yes" xml:space="preserve">
          <source>cumulative distribution: (number of partition rows preceding or peer with current row) / total partition rows</source>
          <target state="translated">누적 분포 : (현재 행과 선행 또는 피어의 파티션 행 수) / 총 파티션 행</target>
        </trans-unit>
        <trans-unit id="64607b5d8e4412896465575375d94f0725abe039" translate="yes" xml:space="preserve">
          <source>currency amount</source>
          <target state="translated">통화 금액</target>
        </trans-unit>
        <trans-unit id="b81619f92b172ce2f6fa0a84df042cb5fd37a50f" translate="yes" xml:space="preserve">
          <source>currency symbol (uses locale)</source>
          <target state="translated">통화 기호 (로케일 사용)</target>
        </trans-unit>
        <trans-unit id="4f4406b4ea462b2d1ce31fff99c629ac6a9ecade" translate="yes" xml:space="preserve">
          <source>current TID of this or newer row version</source>
          <target state="translated">이 또는 최신 행 버전의 현재 TID</target>
        </trans-unit>
        <trans-unit id="ccae96815d506bcc8eb6b9e7ef48a9c48d733f5f" translate="yes" xml:space="preserve">
          <source>current nesting level of PostgreSQL triggers (0 if not called, directly or indirectly, from inside a trigger)</source>
          <target state="translated">PostgreSQL 트리거의 현재 중첩 수준 (트리거 내부에서 직접 또는 간접적으로 호출되지 않은 경우 0)</target>
        </trans-unit>
        <trans-unit id="779b51a546eca5f4d60da79d0ec7ada57a18e13f" translate="yes" xml:space="preserve">
          <source>current scale factor</source>
          <target state="translated">현재 스케일 팩터</target>
        </trans-unit>
        <trans-unit id="056ca10ef8889b41faa742d26656a471608732e4" translate="yes" xml:space="preserve">
          <source>current transaction's start time</source>
          <target state="translated">현재 거래의 시작 시간</target>
        </trans-unit>
        <trans-unit id="3ccfd1fb04d76ca6fa36faf318d4bbbe6e019e62" translate="yes" xml:space="preserve">
          <source>current user is a superuser</source>
          <target state="translated">현재 사용자는 수퍼 유저입니다</target>
        </trans-unit>
        <trans-unit id="e76746f9f64ea77f86d57b4affc2e26c70e97db1" translate="yes" xml:space="preserve">
          <source>current user is the server owner and mapping is for &lt;code&gt;PUBLIC&lt;/code&gt;</source>
          <target state="translated">현재 사용자는 서버 소유자이며 매핑은 &lt;code&gt;PUBLIC&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="56acd550331e29f863c4189d4f0d3e7d6050a758" translate="yes" xml:space="preserve">
          <source>current user is the user being mapped, and owns the server or holds &lt;code&gt;USAGE&lt;/code&gt; privilege on it</source>
          <target state="translated">현재 사용자는 매핑되는 사용자이며 서버를 소유하거나 서버 에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한을 보유 합니다</target>
        </trans-unit>
        <trans-unit id="251e17f62ca5a0bad33a4794560b84bff241ddd2" translate="yes" xml:space="preserve">
          <source>dartmouth.edu/~sting/sw/imath</source>
          <target state="translated">dartmouth.edu/~sting/sw/imath</target>
        </trans-unit>
        <trans-unit id="248361612d1d3c64585c3817d26796e95c11dece" translate="yes" xml:space="preserve">
          <source>data pages for large objects</source>
          <target state="translated">큰 객체의 데이터 페이지</target>
        </trans-unit>
        <trans-unit id="c429160164cb02d0618b1e822bdab4bf43fbb586" translate="yes" xml:space="preserve">
          <source>data type name</source>
          <target state="translated">데이터 타입 이름</target>
        </trans-unit>
        <trans-unit id="1bd41877f2856c4d7b5bc551b1c51509f9f61a5b" translate="yes" xml:space="preserve">
          <source>data types</source>
          <target state="translated">데이터 타입</target>
        </trans-unit>
        <trans-unit id="9dbbcafe5430392decd61d26126df6cde3ef6b46" translate="yes" xml:space="preserve">
          <source>database creation</source>
          <target state="translated">데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="564babd5efa4c177e7fbceca3d3d19ecd02f9665" translate="yes" xml:space="preserve">
          <source>database roles</source>
          <target state="translated">데이터베이스 역할</target>
        </trans-unit>
        <trans-unit id="4167ac168b132ec514ae402ff3cd6a698a1a72b2" translate="yes" xml:space="preserve">
          <source>database size</source>
          <target state="translated">데이터베이스 크기</target>
        </trans-unit>
        <trans-unit id="9ac69b495c64616d7b51aad907a1b0a02e1e82e1" translate="yes" xml:space="preserve">
          <source>database users</source>
          <target state="translated">데이터베이스 사용자</target>
        </trans-unit>
        <trans-unit id="cb7adbeff69aceed0bcbedf307c65b93eee9ad75" translate="yes" xml:space="preserve">
          <source>databases within this database cluster</source>
          <target state="translated">이 데이터베이스 클러스터 내의 데이터베이스</target>
        </trans-unit>
        <trans-unit id="d202efb306923275367bde19b04202628d0810f8" translate="yes" xml:space="preserve">
          <source>date (no time of day)</source>
          <target state="translated">날짜 (시간 없음)</target>
        </trans-unit>
        <trans-unit id="1b3873d4c20bb95e93889a9abb13b9714bb3aebb" translate="yes" xml:space="preserve">
          <source>date and time (no time zone)</source>
          <target state="translated">날짜 및 시간 (시간대 없음)</target>
        </trans-unit>
        <trans-unit id="eec85f3a0d545b904948082d0843118f704b1d8d" translate="yes" xml:space="preserve">
          <source>date and time, including time zone</source>
          <target state="translated">시간대를 포함한 날짜 및 시간</target>
        </trans-unit>
        <trans-unit id="a8317cc31a263bf0df643e148f49a9ce920f53ce" translate="yes" xml:space="preserve">
          <source>day of ISO 8601 week-numbering year (001&amp;ndash;371; day 1 of the year is Monday of the first ISO week)</source>
          <target state="translated">day of ISO 8601 week-numbering year (001&amp;ndash;371; day 1 of the year is Monday of the first ISO week)</target>
        </trans-unit>
        <trans-unit id="d2d8e3721b3534cc276e29fdaeef31b7178dcae1" translate="yes" xml:space="preserve">
          <source>day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)</source>
          <target state="translated">ISO 8601 주 번호 매기기 연도 (001-371, 연도 1 일은 첫 번째 ISO 주 월요일)</target>
        </trans-unit>
        <trans-unit id="090f8b3f331eb935f525922409bffea8e09b7d95" translate="yes" xml:space="preserve">
          <source>day of month (01&amp;ndash;31)</source>
          <target state="translated">day of month (01&amp;ndash;31)</target>
        </trans-unit>
        <trans-unit id="0ad17a3576b304f060bc744adbfaf1cfd97c0b9f" translate="yes" xml:space="preserve">
          <source>day of month (01-31)</source>
          <target state="translated">달의 날짜 (01-31)</target>
        </trans-unit>
        <trans-unit id="469af68e3866ca6a9deafcaeae3928c434d4b3e1" translate="yes" xml:space="preserve">
          <source>day of the week, Sunday (&lt;code&gt;1&lt;/code&gt;) to Saturday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">요일, 일요일 ( &lt;code&gt;1&lt;/code&gt; ) ~ 토요일 ( &lt;code&gt;7&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0edf11eeeb832dd1b17b8e28879ed7531aa362ac" translate="yes" xml:space="preserve">
          <source>day of year (001&amp;ndash;366)</source>
          <target state="translated">day of year (001&amp;ndash;366)</target>
        </trans-unit>
        <trans-unit id="8a71c2096de47fbc8680000b32ef705fe832913e" translate="yes" xml:space="preserve">
          <source>day of year (001-366)</source>
          <target state="translated">년의 일 (001-366)</target>
        </trans-unit>
        <trans-unit id="700a54df2e790245f9dcd527f33cd998af18e65f" translate="yes" xml:space="preserve">
          <source>dblink_build_sql_update</source>
          <target state="translated">dblink_build_sql_update</target>
        </trans-unit>
        <trans-unit id="a03c4c4da450b6b78f166172cdfad6685ad457cd" translate="yes" xml:space="preserve">
          <source>de-summarize the page range covering the given block, if summarized</source>
          <target state="translated">주어진 블록을 포함하는 페이지 범위를 요약합니다 (요약 된 경우).</target>
        </trans-unit>
        <trans-unit id="cbb374265aa2a00ae1a935c1b66a5a8765c5a8db" translate="yes" xml:space="preserve">
          <source>decimal point</source>
          <target state="translated">소수점</target>
        </trans-unit>
        <trans-unit id="f0dcabf47a6adda5ccdca5499ec11830a3bb794d" translate="yes" xml:space="preserve">
          <source>decimal point (uses locale)</source>
          <target state="translated">소수점 (로케일 사용)</target>
        </trans-unit>
        <trans-unit id="d9f9f3ca28421c771e69ddc796196abbfc38261a" translate="yes" xml:space="preserve">
          <source>decompile internal form of an expression, assuming that any Vars in it refer to the relation indicated by the second parameter</source>
          <target state="translated">변수의 Var이 두 번째 매개 변수로 표시된 관계를 참조한다고 가정하여 표현식의 내부 양식을 디 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="5d0f59b9287cc99be12e3adc0a5ed8bb3aa30762" translate="yes" xml:space="preserve">
          <source>default privileges for object types</source>
          <target state="translated">객체 유형에 대한 기본 권한</target>
        </trans-unit>
        <trans-unit id="7ab389d535d69add8b20d71d3316df0764149116" translate="yes" xml:space="preserve">
          <source>degrees to radians</source>
          <target state="translated">도에서 라디안으로</target>
        </trans-unit>
        <trans-unit id="76a1d7b09f9d708126885250c26d9a7c5662a26e" translate="yes" xml:space="preserve">
          <source>delete XID stamp</source>
          <target state="translated">XID 스탬프 삭제</target>
        </trans-unit>
        <trans-unit id="4e7d874e194c57e56c6808bda722d6e762a82d75" translate="yes" xml:space="preserve">
          <source>delete key from left operand</source>
          <target state="translated">왼쪽 피연산자에서 키 삭제</target>
        </trans-unit>
        <trans-unit id="5994ddb3d5afc39677fe0d3e53b41199d5e46887" translate="yes" xml:space="preserve">
          <source>delete keys from left operand</source>
          <target state="translated">왼쪽 피연산자에서 키 삭제</target>
        </trans-unit>
        <trans-unit id="e872e58a377017a736cf1e1ab4ff236790275777" translate="yes" xml:space="preserve">
          <source>delete matching pairs from left operand</source>
          <target state="translated">왼쪽 피연산자에서 일치하는 쌍을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="eae96a435f5bdb0c81e63fb0c70854998629b631" translate="yes" xml:space="preserve">
          <source>delete pair with matching key</source>
          <target state="translated">일치하는 키로 페어 삭제</target>
        </trans-unit>
        <trans-unit id="b1c7a2750dfb5f36480871a2e5c6e4567af9e887" translate="yes" xml:space="preserve">
          <source>delete pairs matching those in the second argument</source>
          <target state="translated">두 번째 인수와 일치하는 쌍을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="3efddac41d9ff2c5cb13d8732824f2be0263e5fa" translate="yes" xml:space="preserve">
          <source>delete pairs with matching keys</source>
          <target state="translated">일치하는 키가있는 쌍을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="1039b55fb5734d3d36060d3f7c0dffed078f3f5d" translate="yes" xml:space="preserve">
          <source>dependencies between database objects</source>
          <target state="translated">데이터베이스 객체 간의 종속성</target>
        </trans-unit>
        <trans-unit id="bcf260757062336d168e0b854a6bfec054320982" translate="yes" xml:space="preserve">
          <source>dependencies on shared objects</source>
          <target state="translated">공유 객체에 대한 의존성</target>
        </trans-unit>
        <trans-unit id="643b64fb4c981ee959710c294a989bd23751dfb6" translate="yes" xml:space="preserve">
          <source>depending on your system. If you are certain that no conflicting server is running, you can remove the lock file mentioned in the message and try again.</source>
          <target state="translated">시스템에 따라 다릅니다. 충돌하는 서버가 실행되고 있지 않다고 확신하면 메시지에 언급 된 잠금 파일을 제거하고 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="74b0f36995620769c56ddd2cbff3cada94967a2b" translate="yes" xml:space="preserve">
          <source>deprecated synonym for &lt;code&gt;@@&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@@&lt;/code&gt; 에 사용되지 않는 동의어</target>
        </trans-unit>
        <trans-unit id="bfeb202c643a0ab0c62a61acbeda3c7ce92fcd15" translate="yes" xml:space="preserve">
          <source>descriptions or comments on database objects</source>
          <target state="translated">데이터베이스 오브젝트에 대한 설명 또는 주석</target>
        </trans-unit>
        <trans-unit id="13c1d29555b21e921b0a3aedc5e4ff745b633b81" translate="yes" xml:space="preserve">
          <source>diameter of circle</source>
          <target state="translated">원의 지름</target>
        </trans-unit>
        <trans-unit id="ff9ccbf023e1d5c01856ab64c92fc6a9f9161e07" translate="yes" xml:space="preserve">
          <source>dict_int</source>
          <target state="translated">dict_int</target>
        </trans-unit>
        <trans-unit id="08bafab9b334b62e4fc9fb37bf107442495772df" translate="yes" xml:space="preserve">
          <source>dict_xsyn</source>
          <target state="translated">dict_xsyn</target>
        </trans-unit>
        <trans-unit id="48d53c6e22192bbaaff43be3456d5f6f5d82da6f" translate="yes" xml:space="preserve">
          <source>difference</source>
          <target state="translated">difference</target>
        </trans-unit>
        <trans-unit id="85ee40d69e337d51248f4aebee5d12dd412aef01" translate="yes" xml:space="preserve">
          <source>digit position (can be dropped if insignificant)</source>
          <target state="translated">자릿수 위치 (중요하지 않은 경우 제거 가능)</target>
        </trans-unit>
        <trans-unit id="a724a4d536d891e4bd851b3b127513c5cac870e7" translate="yes" xml:space="preserve">
          <source>digit position (will not be dropped, even if insignificant)</source>
          <target state="translated">자릿수 위치 (소용이 없더라도 삭제되지 않음)</target>
        </trans-unit>
        <trans-unit id="58e4fb37fdcbe481209c5e401fac9ed4117d48b5" translate="yes" xml:space="preserve">
          <source>directory to use for postmaster sockets during upgrade; default is current working directory; environment variable &lt;code&gt;PGSOCKETDIR&lt;/code&gt;</source>
          <target state="translated">업그레이드 중 포스트 마스터 소켓에 사용할 디렉토리; 기본값은 현재 작업 디렉토리입니다. 환경 변수 &lt;code&gt;PGSOCKETDIR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="302710649278eb0883ce3392069d7e99b6dfb8f9" translate="yes" xml:space="preserve">
          <source>dirty read</source>
          <target state="translated">더티 읽기</target>
        </trans-unit>
        <trans-unit id="24d5fc5c766af09ab08d7bfd916da7e70bb52c5e" translate="yes" xml:space="preserve">
          <source>discrete percentile: returns the first input value whose position in the ordering equals or exceeds the specified fraction</source>
          <target state="translated">이산 백분위 수 : 순서의 위치가 지정된 분수와 같거나 초과하는 첫 번째 입력 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2090e17cbce163da2ce919466e3fd2175625ec32" translate="yes" xml:space="preserve">
          <source>disk blocks</source>
          <target state="translated">디스크 블록</target>
        </trans-unit>
        <trans-unit id="c96264e7d87a9178b70f95d33581e0839e385c5a" translate="yes" xml:space="preserve">
          <source>display a query match</source>
          <target state="translated">검색어 일치 표시</target>
        </trans-unit>
        <trans-unit id="7a1ad48b2e1eb83707513d8a4c172844610b0eac" translate="yes" xml:space="preserve">
          <source>display version information, then exit</source>
          <target state="translated">버전 정보를 표시 한 다음 종료</target>
        </trans-unit>
        <trans-unit id="314b330f1a69b0d1e908c495db3cf5b21621f484" translate="yes" xml:space="preserve">
          <source>division (integer division truncates the result)</source>
          <target state="translated">나누기 (정수 나누기 결과가 잘림)</target>
        </trans-unit>
        <trans-unit id="030d8c79e8db0778a98b5c136a1d9a70816df62e" translate="yes" xml:space="preserve">
          <source>division (integer truncates the results)</source>
          <target state="translated">나누기 (정수는 결과를 자릅니다)</target>
        </trans-unit>
        <trans-unit id="4cb6cafbb6abf82018a9534f90701e2e42fca638" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain all specified keys?</source>
          <target state="translated">않습니다 &lt;code&gt;hstore&lt;/code&gt; 지정된 모든 키를 포함?</target>
        </trans-unit>
        <trans-unit id="bafd763d733c6d384cfadd48039c1c94b64a5057" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain any of the specified keys?</source>
          <target state="translated">않습니다 &lt;code&gt;hstore&lt;/code&gt; 가 지정된 키를 포함 할?</target>
        </trans-unit>
        <trans-unit id="16f67fbb1f9b0ce89c412fa9f9c91ed03c52ef42" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain key?</source>
          <target state="translated">않습니다 &lt;code&gt;hstore&lt;/code&gt; 가 키를 포함?</target>
        </trans-unit>
        <trans-unit id="6d66dc3d673440da44d129cf30dafe0627587c75" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain non-&lt;code&gt;NULL&lt;/code&gt; value for key?</source>
          <target state="translated">않습니다 &lt;code&gt;hstore&lt;/code&gt; 는 비 포함 &lt;code&gt;NULL&lt;/code&gt; 의 키에 대한 값을?</target>
        </trans-unit>
        <trans-unit id="c33f0d5d452e89fd44dcdef1104e34e2460df71f" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; array contain any path matching any &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">않는 &lt;code&gt;ltree&lt;/code&gt; 배열이 일치하는 모든 경로를 포함 &lt;code&gt;lquery&lt;/code&gt; 를 ?</target>
        </trans-unit>
        <trans-unit id="1c53b57b8ca3d240b9dc88085af96b6dbab6fa68" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 는 &lt;code&gt;lquery&lt;/code&gt; 와 일치 합니까 ?</target>
        </trans-unit>
        <trans-unit id="3648ad67b9d0438df764a00aa33a91ea0f51da62" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 는 &lt;code&gt;ltxtquery&lt;/code&gt; 와 일치 합니까 ?</target>
        </trans-unit>
        <trans-unit id="bee15116149fbb94972f0f1f0a198543b5d86fe4" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match any &lt;code&gt;lquery&lt;/code&gt; in array?</source>
          <target state="translated">않습니다 &lt;code&gt;ltree&lt;/code&gt; 은 어떤 일치 &lt;code&gt;lquery&lt;/code&gt; 배열을?</target>
        </trans-unit>
        <trans-unit id="6daa1a6ed3cacf7a57ce4c941eea23a2076c5480" translate="yes" xml:space="preserve">
          <source>does &lt;em&gt;not&lt;/em&gt; mean you've run out of disk space. It means your kernel's limit on the number of System V semaphores is smaller than the number PostgreSQL wants to create. As above, you might be able to work around the problem by starting the server with a reduced number of allowed connections (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), but you'll eventually want to increase the kernel limit.</source>
          <target state="translated">디스크 공간이 부족하다는 의미 는 &lt;em&gt;아닙니다&lt;/em&gt; . 이는 System V 세마포어 수에 대한 커널의 제한이 PostgreSQL이 생성하려는 수보다 작음을 의미합니다. 위와 같이, 허용 된 연결 수가 줄어든 서버를 시작하여 ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; ) 문제점을 해결할 수 있지만 결국 커널 한계를 늘리고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="64868bbf0f6334a11707f036779fce59caac51fe" translate="yes" xml:space="preserve">
          <source>does array contain a descendant of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">배열에 &lt;code&gt;ltree&lt;/code&gt; 의 자손이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="a301dc21d55ea9fa1daaf587093b7b700878a61f" translate="yes" xml:space="preserve">
          <source>does array contain an ancestor of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">배열에 &lt;code&gt;ltree&lt;/code&gt; 의 조상이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="567bff233f20cf454c16349c2b002f100e4644d2" translate="yes" xml:space="preserve">
          <source>does array contain any path matching &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">배열에 &lt;code&gt;lquery&lt;/code&gt; 와 일치하는 경로가 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="7d7b1ca647e0b44d6a318e89c4b79d80dec00662" translate="yes" xml:space="preserve">
          <source>does array contain any path matching &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">배열에 &lt;code&gt;ltxtquery&lt;/code&gt; 와 일치하는 경로가 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="d0e93f199be58627d5290fb7e295a3883e34de0e" translate="yes" xml:space="preserve">
          <source>does current user have privilege for any column of table</source>
          <target state="translated">현재 사용자에게 테이블의 모든 열에 대한 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="923f34e72b54c44d587b74dfe716fb9e7a0b69f3" translate="yes" xml:space="preserve">
          <source>does current user have privilege for column</source>
          <target state="translated">현재 사용자에게 열에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="8eebefcd3db5e0fd1f67f23a742c8cbdb52ca488" translate="yes" xml:space="preserve">
          <source>does current user have privilege for database</source>
          <target state="translated">현재 사용자에게 데이터베이스에 대한 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="d5d20390d72f10839e55e755a41622b4e83aaad2" translate="yes" xml:space="preserve">
          <source>does current user have privilege for foreign server</source>
          <target state="translated">현재 사용자에게는 외부 서버에 대한 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="76e06765244ec4f69ad0edf35314e91668644688" translate="yes" xml:space="preserve">
          <source>does current user have privilege for foreign-data wrapper</source>
          <target state="translated">현재 사용자에게 외부 데이터 래퍼에 대한 권한이 있습니까?</target>
        </trans-unit>
        <trans-unit id="14cf9981a77c04be078c13991b9209c61e42b19f" translate="yes" xml:space="preserve">
          <source>does current user have privilege for function</source>
          <target state="translated">현재 사용자에게 기능에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="e53afcf7f590b1f341c771ee932c34274218fee2" translate="yes" xml:space="preserve">
          <source>does current user have privilege for language</source>
          <target state="translated">현재 사용자에게 언어에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="d392178c73923ceb61788ee59e66cfc98b85b093" translate="yes" xml:space="preserve">
          <source>does current user have privilege for role</source>
          <target state="translated">현재 사용자에게 역할에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="3ce043cb41e01186d5429925060d21732a8a9b01" translate="yes" xml:space="preserve">
          <source>does current user have privilege for schema</source>
          <target state="translated">현재 사용자에게 스키마에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="44e2c7a7969b5280a9ac5e18312a1a719915e5c8" translate="yes" xml:space="preserve">
          <source>does current user have privilege for sequence</source>
          <target state="translated">현재 사용자에게 시퀀스 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="a8553aada6aa07a63b9fb14a123e6eb5d6132d87" translate="yes" xml:space="preserve">
          <source>does current user have privilege for table</source>
          <target state="translated">현재 사용자에게 테이블에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="aa74612a59a28280141be932e93980e9b80f16c8" translate="yes" xml:space="preserve">
          <source>does current user have privilege for tablespace</source>
          <target state="translated">현재 사용자에게 테이블 스페이스에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="dd7e9d6b9c5d3197cefad7a4260eb463901b4b09" translate="yes" xml:space="preserve">
          <source>does current user have privilege for type</source>
          <target state="translated">현재 사용자에게 유형에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="65119e338c802227733d23f560577b1f92332234" translate="yes" xml:space="preserve">
          <source>does current user have row level security active for table</source>
          <target state="translated">현재 사용자에게 테이블에 대해 행 레벨 보안이 활성화되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="b12d604405828eb6355ba772e8353d7dff5c090e" translate="yes" xml:space="preserve">
          <source>does left operand contain right?</source>
          <target state="translated">왼쪽 피연산자에 오른쪽이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="756c9771ba43bfeb3fc0b27733143e509011767d" translate="yes" xml:space="preserve">
          <source>does not contradict common sense, neither does the intersection</source>
          <target state="translated">상식과 모순되지 않으며, 교차점도</target>
        </trans-unit>
        <trans-unit id="b36715a10925245466a61b1c713e5e53614f7d3c" translate="yes" xml:space="preserve">
          <source>does not extend to the left of</source>
          <target state="translated">왼쪽으로 확장되지 않습니다</target>
        </trans-unit>
        <trans-unit id="7d4052eb9215bde986d065d712fe5d1ea63cb4dd" translate="yes" xml:space="preserve">
          <source>does not extend to the right of</source>
          <target state="translated">의 오른쪽으로 확장되지 않습니다</target>
        </trans-unit>
        <trans-unit id="f7f46d46a353213d12fe0e106cd32be9a96a313c" translate="yes" xml:space="preserve">
          <source>does not result in an error, because the &lt;code&gt;||&lt;/code&gt; operator does not care about collations: its result is the same regardless of the collation.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; 이므로 오류가 발생하지 않습니다. 연산자는 데이터 정렬에 신경 쓰지 않습니다. 결과는 데이터 정렬에 관계없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="75e4c1b191e5aba3fca713359bb284f3bba53197" translate="yes" xml:space="preserve">
          <source>does user have privilege for any column of table</source>
          <target state="translated">사용자에게 테이블의 모든 열에 대한 권한이 있습니까?</target>
        </trans-unit>
        <trans-unit id="3e3a02344dffd3279b448eb7d8ae2788f7b6be07" translate="yes" xml:space="preserve">
          <source>does user have privilege for column</source>
          <target state="translated">사용자에게 열에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="e98b58c4f0fc14060c4884df933960d9628f8716" translate="yes" xml:space="preserve">
          <source>does user have privilege for database</source>
          <target state="translated">사용자에게 데이터베이스에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="765c96c7f8619408b3a2ef1d6a65be4c1cacb9c9" translate="yes" xml:space="preserve">
          <source>does user have privilege for foreign server</source>
          <target state="translated">사용자에게 외부 서버에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="a1aad5c71dcb9de7b0ebfe1791764c821ee31f90" translate="yes" xml:space="preserve">
          <source>does user have privilege for foreign-data wrapper</source>
          <target state="translated">사용자에게 외부 데이터 래퍼에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="c225f178288924737bfa6e4b6a297dd843498dd4" translate="yes" xml:space="preserve">
          <source>does user have privilege for function</source>
          <target state="translated">사용자에게 기능에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="d470907c424695bcabb45adae12569de1bad3b0d" translate="yes" xml:space="preserve">
          <source>does user have privilege for language</source>
          <target state="translated">사용자에게 언어에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="a0ba62c173d0bc0e7a46899574360820b2bc2f9f" translate="yes" xml:space="preserve">
          <source>does user have privilege for role</source>
          <target state="translated">사용자에게 역할에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="bed67dbbf088b4b1ffec5c7180d7d0ec267b5df8" translate="yes" xml:space="preserve">
          <source>does user have privilege for schema</source>
          <target state="translated">사용자에게 스키마에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="fda3d32d403e4d198f5f4e5703028831a30fe866" translate="yes" xml:space="preserve">
          <source>does user have privilege for sequence</source>
          <target state="translated">사용자에게 시퀀스 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="0b3c10883f54a4a3a8e9b7a17c728cb3f9c09b6a" translate="yes" xml:space="preserve">
          <source>does user have privilege for table</source>
          <target state="translated">사용자에게 테이블에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="d616ba1bcc2173d55dc3b40b681e7e2c83c7625d" translate="yes" xml:space="preserve">
          <source>does user have privilege for tablespace</source>
          <target state="translated">사용자에게 테이블 스페이스에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="f37310ea7053667a4967493d91089148515177e4" translate="yes" xml:space="preserve">
          <source>does user have privilege for type</source>
          <target state="translated">사용자에게 유형에 대한 권한이 있습니까</target>
        </trans-unit>
        <trans-unit id="bdb36bb22deb169275b3094ba9005a29eeddd195" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="translated">double</target>
        </trans-unit>
        <trans-unit id="f70c61055e7cd930e448a61146df9dcec538dae5" translate="yes" xml:space="preserve">
          <source>double if any &lt;code&gt;a&lt;/code&gt; is double, else integer</source>
          <target state="translated">어떤 경우 두 배 &lt;code&gt;a&lt;/code&gt; 두 번, 다른 정수</target>
        </trans-unit>
        <trans-unit id="a9d7d2a5b010ce1408927d410711b2b9b2dcf630" translate="yes" xml:space="preserve">
          <source>double precision</source>
          <target state="translated">배정도</target>
        </trans-unit>
        <trans-unit id="7bd1b3d84f60bc411ebad0e502e786bfb5dff6b4" translate="yes" xml:space="preserve">
          <source>double precision floating-point number (8 bytes)</source>
          <target state="translated">배정 밀도 부동 소수점 수 (8 바이트)</target>
        </trans-unit>
        <trans-unit id="2b0e335cd50db4422abd071d794ce8250a0af460" translate="yes" xml:space="preserve">
          <source>download dictionary configuration files. OpenOffice extension files have the &lt;code&gt;.oxt&lt;/code&gt; extension. It is necessary to extract &lt;code&gt;.aff&lt;/code&gt; and &lt;code&gt;.dic&lt;/code&gt; files, change extensions to &lt;code&gt;.affix&lt;/code&gt; and &lt;code&gt;.dict&lt;/code&gt;. For some dictionary files it is also needed to convert characters to the UTF-8 encoding with commands (for example, for a Norwegian language dictionary):</source>
          <target state="translated">사전 구성 파일을 다운로드하십시오. OpenOffice 확장 파일의 확장자는 &lt;code&gt;.oxt&lt;/code&gt; 입니다. 추출하는 것이 필요하다 &lt;code&gt;.aff&lt;/code&gt; 및 &lt;code&gt;.dic&lt;/code&gt; 를 파일로 변경 확장 &lt;code&gt;.affix&lt;/code&gt; 및 &lt;code&gt;.dict&lt;/code&gt; 을 . 일부 사전 파일의 경우 명령을 사용하여 문자를 UTF-8 인코딩으로 변환해야합니다 (예 : 노르웨이어 사전의 경우).</target>
        </trans-unit>
        <trans-unit id="6cbe8eee2be1493251c74aba3d14ce090704c314" translate="yes" xml:space="preserve">
          <source>dropdb</source>
          <target state="translated">dropdb</target>
        </trans-unit>
        <trans-unit id="da2f55f30903093b88b2abe2ff1d8c8878785d4d" translate="yes" xml:space="preserve">
          <source>dropdb &amp;mdash; remove a PostgreSQL database</source>
          <target state="translated">dropdb &amp;mdash; PostgreSQL 데이터베이스 제거</target>
        </trans-unit>
        <trans-unit id="cee0a709ed144356dd15d656bc6b22fb78c87ab6" translate="yes" xml:space="preserve">
          <source>dropdb accepts the following command-line arguments:</source>
          <target state="translated">dropdb는 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6f5dc55cde4d56805bce8487bd823396755fbd8f" translate="yes" xml:space="preserve">
          <source>dropdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">dropdb는 또한 연결 매개 변수에 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b2c63240befa5a55623102754bbe3f06e330117d" translate="yes" xml:space="preserve">
          <source>dropdb destroys an existing PostgreSQL database. The user who executes this command must be a database superuser or the owner of the database.</source>
          <target state="translated">dropdb는 기존 PostgreSQL 데이터베이스를 삭제합니다. 이 명령을 실행하는 사용자는 데이터베이스 수퍼 유저 또는 데이터베이스 소유자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="5fdb4e6dd14831ab684970c9656f06e02410c343" translate="yes" xml:space="preserve">
          <source>dropdb is a wrapper around the SQL command &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;. There is no effective difference between dropping databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">dropdb는 SQL 명령 &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE를&lt;/a&gt; 감싸는 래퍼 입니다. 이 유틸리티와 서버에 액세스하기위한 다른 방법을 통해 데이터베이스를 삭제하는 것 사이에는 효과적인 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="61f8d2eb809b42145cb0c2cc59455f90ae6b39d4" translate="yes" xml:space="preserve">
          <source>dropuser</source>
          <target state="translated">dropuser</target>
        </trans-unit>
        <trans-unit id="3d4f5569f58e7a7d09eb7133d2210c8728567a77" translate="yes" xml:space="preserve">
          <source>dropuser &amp;mdash; remove a PostgreSQL user account</source>
          <target state="translated">dropuser &amp;mdash; PostgreSQL 사용자 계정을 제거합니다</target>
        </trans-unit>
        <trans-unit id="1077aba6c2b30bf419021fbb806b212443ec339c" translate="yes" xml:space="preserve">
          <source>dropuser accepts the following command-line arguments:</source>
          <target state="translated">dropuser는 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2671207f049e22f4b10b3fd2b9765935cf20ee06" translate="yes" xml:space="preserve">
          <source>dropuser also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">dropuser는 또한 연결 매개 변수에 대해 다음 명령 행 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c9d1416783a863b7c532e14663d3712fc1f90804" translate="yes" xml:space="preserve">
          <source>dropuser is a wrapper around the SQL command &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. There is no effective difference between dropping users via this utility and via other methods for accessing the server.</source>
          <target state="translated">dropuser는 SQL 명령 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE을&lt;/a&gt; 감싸는 래퍼 입니다. 이 유틸리티와 서버에 액세스하는 다른 방법을 통해 사용자를 삭제하는 것 사이에는 효과적인 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c08c2e0100e4eb26441eea8482accbff764a871" translate="yes" xml:space="preserve">
          <source>dropuser removes an existing PostgreSQL user. Only superusers and users with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can remove PostgreSQL users. (To remove a superuser, you must yourself be a superuser.)</source>
          <target state="translated">dropuser는 기존 PostgreSQL 사용자를 제거합니다. &lt;code&gt;CREATEROLE&lt;/code&gt; 권한을 가진 수퍼 유저와 사용자 만 PostgreSQL 사용자를 제거 할 수 있습니다. (수퍼 유저를 제거하려면 자신이 수퍼 유저 여야합니다.)</target>
        </trans-unit>
        <trans-unit id="2d1c3f7cb60beb3d49e3f4e046f5ea896f8b0a5d" translate="yes" xml:space="preserve">
          <source>earlier than all other time stamps</source>
          <target state="translated">다른 모든 타임 스탬프보다 빠름</target>
        </trans-unit>
        <trans-unit id="d00152028f9066049bf52b54717487fea14124ea" translate="yes" xml:space="preserve">
          <source>earthdistance</source>
          <target state="translated">earthdistance</target>
        </trans-unit>
        <trans-unit id="d13f9c0d833baac358fedb3d5d5130ba389408d4" translate="yes" xml:space="preserve">
          <source>ecpg</source>
          <target state="translated">ecpg</target>
        </trans-unit>
        <trans-unit id="ee8426e3ae205f6a4fbf14400afc72dbe65a18e6" translate="yes" xml:space="preserve">
          <source>ecpg &amp;mdash; embedded SQL C preprocessor</source>
          <target state="translated">ecpg &amp;mdash; 임베디드 SQL C 프리 프로세서</target>
        </trans-unit>
        <trans-unit id="431fd257c42ba97d31ee98637d51749f58818b72" translate="yes" xml:space="preserve">
          <source>element is contained by</source>
          <target state="translated">요소는</target>
        </trans-unit>
        <trans-unit id="7fd8de61bf0672691fbb98aab87cd593aeaf89f4" translate="yes" xml:space="preserve">
          <source>element-to-array concatenation</source>
          <target state="translated">요소-배열 연결</target>
        </trans-unit>
        <trans-unit id="ab2afe87d80f8f35bf989060afa3c6ac12a43886" translate="yes" xml:space="preserve">
          <source>enable verbose internal logging</source>
          <target state="translated">자세한 내부 로깅 사용</target>
        </trans-unit>
        <trans-unit id="7cbe751985c35402c31394cb0929695fc5649328" translate="yes" xml:space="preserve">
          <source>encoding conversion information</source>
          <target state="translated">변환 정보 인코딩</target>
        </trans-unit>
        <trans-unit id="1671ca77906f61454bce6768a91e2e8e821e8948" translate="yes" xml:space="preserve">
          <source>enum label and value definitions</source>
          <target state="translated">열거 형 레이블 및 값 정의</target>
        </trans-unit>
        <trans-unit id="f57b2d312d9efe8fe993c8eb1f3e19d41ad04030" translate="yes" xml:space="preserve">
          <source>equal</source>
          <target state="translated">equal</target>
        </trans-unit>
        <trans-unit id="44040a02784585bdd6249b4edd2dd94238188e6f" translate="yes" xml:space="preserve">
          <source>equal, treating null like an ordinary value</source>
          <target state="translated">평범한 값처럼 null을 처리</target>
        </trans-unit>
        <trans-unit id="80b2f559a14748525776894e12e1216b49b5b558" translate="yes" xml:space="preserve">
          <source>equals</source>
          <target state="translated">equals</target>
        </trans-unit>
        <trans-unit id="f18bd7a51999b2b1d95efa4274723b39e0ac6b39" translate="yes" xml:space="preserve">
          <source>equivalent to &lt;code&gt;bool_and&lt;/code&gt;</source>
          <target state="translated">에 해당하는 &lt;code&gt;bool_and&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4232efd7b52fa7af1f07ed9b444c78b5cec9a81" translate="yes" xml:space="preserve">
          <source>equivalent to &lt;code&gt;current_user&lt;/code&gt;</source>
          <target state="translated">에 해당 &lt;code&gt;current_user&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65b09de7c4f948564eb4e9f8a8c8ad7481598866" translate="yes" xml:space="preserve">
          <source>era indicator (with periods)</source>
          <target state="translated">시대 표시기 (마침표 포함)</target>
        </trans-unit>
        <trans-unit id="24e96aa5ab5679037b391de37b4ce482d43684f1" translate="yes" xml:space="preserve">
          <source>era indicator (without periods)</source>
          <target state="translated">시대 표시기 (기간 없음)</target>
        </trans-unit>
        <trans-unit id="cdecabe1520a398e4e46deff9d55b19bed6d6457" translate="yes" xml:space="preserve">
          <source>escape</source>
          <target state="translated">escape</target>
        </trans-unit>
        <trans-unit id="be464074e84929b3edb1afc53993489c2a50213d" translate="yes" xml:space="preserve">
          <source>even though there will really be zero rows satisfying this query. Functional dependency statistics do not provide enough information to conclude that, however.</source>
          <target state="translated">이 쿼리를 만족시키는 행이 실제로 없을지라도. 그러나 기능적 의존성 통계는 그 결론을 내리기에 충분한 정보를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2fe05583b44066ff5424d20e6314b48bc6e0ea7" translate="yes" xml:space="preserve">
          <source>even though they had no intention of ever using &lt;code&gt;y&lt;/code&gt; as part of a &lt;code&gt;WHERE&lt;/code&gt; clause. This works fine as long as the extra columns are trailing columns; making them be leading columns is unwise for the reasons explained in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;. However, this method doesn't support the case where you want the index to enforce uniqueness on the key column(s).</source>
          <target state="translated">비록 그들이 &lt;code&gt;WHERE&lt;/code&gt; 절의 일부로 &lt;code&gt;y&lt;/code&gt; 를 사용하려는 의도는 없었지만 . 여분의 열이 후행 열이면 제대로 작동합니다. &lt;a href=&quot;indexes-multicolumn&quot;&gt;11.3 절에&lt;/a&gt; 설명 된 이유로 열을 선행 열로 만드는 것은 현명하지 않습니다 . 그러나이 방법은 인덱스가 키 열에 고유성을 적용하려는 경우를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7833e7d391c504aee68e45dea9634b1c53821bff" translate="yes" xml:space="preserve">
          <source>event triggers</source>
          <target state="translated">이벤트 트리거</target>
        </trans-unit>
        <trans-unit id="f5caa8594147ec7c253638db4988e8f1141145c5" translate="yes" xml:space="preserve">
          <source>eventlog</source>
          <target state="translated">eventlog</target>
        </trans-unit>
        <trans-unit id="a1369004de61926651324b802d6bf7dde40d8308" translate="yes" xml:space="preserve">
          <source>exact numeric of selectable precision</source>
          <target state="translated">선택 가능한 정밀도의 정확한 숫자</target>
        </trans-unit>
        <trans-unit id="910088c467ddca75f7465dd40037d50a4b1024d5" translate="yes" xml:space="preserve">
          <source>exactly one of &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;A&lt;/code&gt; is true (&lt;em&gt;trichotomy law&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 중 정확히 하나 가 참 ( &lt;em&gt;삼분법&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="98585ed8f50402fa8abbe3b11d352d8c7b352517" translate="yes" xml:space="preserve">
          <source>expand a &lt;code&gt;tsvector&lt;/code&gt; to a set of rows</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 를 행 세트로 확장</target>
        </trans-unit>
        <trans-unit id="f1b33fd39221d674e864b833837123f8c9c566a5" translate="yes" xml:space="preserve">
          <source>expand an array to a set of rows</source>
          <target state="translated">배열을 행 세트로 확장</target>
        </trans-unit>
        <trans-unit id="b4177b3fdd9f1dcef4246133756c7d4295ee3473" translate="yes" xml:space="preserve">
          <source>expand multiple arrays (possibly of different types) to a set of rows. This is only allowed in the FROM clause; see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;Section 7.2.1.4&lt;/a&gt;</source>
          <target state="translated">여러 배열 (다른 유형일 수도 있음)을 행 세트로 확장합니다. 이것은 FROM 절에서만 허용됩니다. &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;섹션 7.2.1.4&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="4500e56b5a24d60ce7b2499c19162fb567e578b4" translate="yes" xml:space="preserve">
          <source>expanded syntax (see below)</source>
          <target state="translated">확장 된 구문 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="51a433a570f5960fccaccfbfa93909e78f841178" translate="yes" xml:space="preserve">
          <source>exponent for scientific notation</source>
          <target state="translated">과학적 표기법에 대한 지수</target>
        </trans-unit>
        <trans-unit id="dc606218848a18d5c34862a175d29c1fe03c13d9" translate="yes" xml:space="preserve">
          <source>exponential</source>
          <target state="translated">exponential</target>
        </trans-unit>
        <trans-unit id="1e78ce1a1f32081b3133e35ca2ce8f4369be90ee" translate="yes" xml:space="preserve">
          <source>exponentially-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; 지수 분포 난수 , 아래 참조</target>
        </trans-unit>
        <trans-unit id="1d422390c5a3d1333fb7f5d97621fa0f6e7f0d6c" translate="yes" xml:space="preserve">
          <source>exponentiation</source>
          <target state="translated">exponentiation</target>
        </trans-unit>
        <trans-unit id="0db5a9a232a6935699542e335a56a8df9f43d2e9" translate="yes" xml:space="preserve">
          <source>exponentiation (associates left to right)</source>
          <target state="translated">지수화 (왼쪽에서 오른쪽으로 연결)</target>
        </trans-unit>
        <trans-unit id="5d7f1bff34ea278c6c5a2fc91295c8a87607dc57" translate="yes" xml:space="preserve">
          <source>extended planner statistics</source>
          <target state="translated">확장 된 플래너 통계</target>
        </trans-unit>
        <trans-unit id="cc65f5c101ab8b09f58273801d736b9e9677d0e8" translate="yes" xml:space="preserve">
          <source>extended planner statistics (built statistics)</source>
          <target state="translated">확장 플래너 통계 (빌드 통계)</target>
        </trans-unit>
        <trans-unit id="6d557d048a3b2c532f56398c201f9c70fcd3184e" translate="yes" xml:space="preserve">
          <source>extended planner statistics (definition)</source>
          <target state="translated">확장 된 플래너 통계 (정의)</target>
        </trans-unit>
        <trans-unit id="b56ba1d1de71303ba9e7ac7e6d37ccee335d2140" translate="yes" xml:space="preserve">
          <source>external node identifier</source>
          <target state="translated">외부 노드 식별자</target>
        </trans-unit>
        <trans-unit id="8cea632a3c2f5380e27bf9754368859382f731f4" translate="yes" xml:space="preserve">
          <source>extract IP address and netmask length as text</source>
          <target state="translated">텍스트로 IP 주소 및 넷 마스크 길이 추출</target>
        </trans-unit>
        <trans-unit id="1adf6634d9f5912d39aae24816f962b74dbd1d3d" translate="yes" xml:space="preserve">
          <source>extract IP address as text</source>
          <target state="translated">텍스트로 IP 주소 추출</target>
        </trans-unit>
        <trans-unit id="52224bb43ff5437ccb717a45646600f74c89bca0" translate="yes" xml:space="preserve">
          <source>extract a subset of an &lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 서브 세트 추출</target>
        </trans-unit>
        <trans-unit id="6a0f78ab60fe16f14c77cc85e268514510fb939e" translate="yes" xml:space="preserve">
          <source>extract family of address; &lt;code&gt;4&lt;/code&gt; for IPv4, &lt;code&gt;6&lt;/code&gt; for IPv6</source>
          <target state="translated">주소 패밀리를 추출하십시오. IPv4의 경우 &lt;code&gt;4&lt;/code&gt; , IPv6의 경우 &lt;code&gt;6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63b60e17da1c01c315490ec61d92c6ae1b9cfac1" translate="yes" xml:space="preserve">
          <source>extract netmask length</source>
          <target state="translated">넷 마스크 길이 추출</target>
        </trans-unit>
        <trans-unit id="8eb7d749717b314ca4b624308f167fb8f0536c57" translate="yes" xml:space="preserve">
          <source>extract network part of address</source>
          <target state="translated">주소의 네트워크 부분을 추출</target>
        </trans-unit>
        <trans-unit id="cf2f15ec5a30d6402b8a8b59c0f122369583dbf1" translate="yes" xml:space="preserve">
          <source>f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) / (2.0 * PHI(parameter) - 1)</source>
          <target state="translated">f (x) = PHI (2.0 * 매개 변수 * (x-mu) / (max-min + 1)) / (2.0 * PHI (parameter)-1)</target>
        </trans-unit>
        <trans-unit id="d8ecaf8c657a2b137edff4403d3015c673733131" translate="yes" xml:space="preserve">
          <source>f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))</source>
          <target state="translated">f (x) = exp (-parameter * (x-min) / (max-min + 1)) / (1-exp (-parameter))</target>
        </trans-unit>
        <trans-unit id="2bd70faaff2dc3145c4f93d20179cef8d5fd1bdd" translate="yes" xml:space="preserve">
          <source>factorial</source>
          <target state="translated">factorial</target>
        </trans-unit>
        <trans-unit id="30d4e08f4264897498d5f939d1ac8e6b0526d163" translate="yes" xml:space="preserve">
          <source>factorial (prefix operator)</source>
          <target state="translated">계승 (접두사 연산자)</target>
        </trans-unit>
        <trans-unit id="519c2566cb819aa98f00c389f875acd6c2f82fd8" translate="yes" xml:space="preserve">
          <source>field size</source>
          <target state="translated">필드 크기</target>
        </trans-unit>
        <trans-unit id="3a88b38ae3a3604d3f1af4ad93ba5fe6fb9f87bc" translate="yes" xml:space="preserve">
          <source>file_fdw</source>
          <target state="translated">file_fdw</target>
        </trans-unit>
        <trans-unit id="983401d0e918dc765c97b567a565058e6af554ed" translate="yes" xml:space="preserve">
          <source>fill mode (suppress leading zeroes and padding blanks)</source>
          <target state="translated">채우기 모드 (리딩 제로 및 패딩 공백 억제)</target>
        </trans-unit>
        <trans-unit id="a5e4a7072f8551b572a1cee1a88417461488e2a7" translate="yes" xml:space="preserve">
          <source>fill mode (suppress trailing zeroes and padding blanks)</source>
          <target state="translated">채우기 모드 (후행 0 및 패딩 공백 억제)</target>
        </trans-unit>
        <trans-unit id="32003507876dacdf67e2131262acee891800afea" translate="yes" xml:space="preserve">
          <source>first array entry that is a descendant of &lt;code&gt;ltree&lt;/code&gt;; NULL if none</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 의 자손 인 첫 번째 배열 항목 ; 없으면 NULL</target>
        </trans-unit>
        <trans-unit id="515013b791f433a9eae1982ebea0e32381eccb14" translate="yes" xml:space="preserve">
          <source>first array entry that is an ancestor of &lt;code&gt;ltree&lt;/code&gt;; NULL if none</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 의 조상 인 첫 번째 배열 항목 ; 없으면 NULL</target>
        </trans-unit>
        <trans-unit id="5a3fdedfab8428272c62bd9bbab1aa027083b860" translate="yes" xml:space="preserve">
          <source>first array entry that matches &lt;code&gt;lquery&lt;/code&gt;; NULL if none</source>
          <target state="translated">&lt;code&gt;lquery&lt;/code&gt; 와 일치하는 첫 번째 배열 항목 ; 없으면 NULL</target>
        </trans-unit>
        <trans-unit id="086d1f932d7df2500f28084d6285586dd205f44c" translate="yes" xml:space="preserve">
          <source>first array entry that matches &lt;code&gt;ltxtquery&lt;/code&gt;; NULL if none</source>
          <target state="translated">&lt;code&gt;ltxtquery&lt;/code&gt; 와 일치하는 첫 번째 배열 항목 ; 없으면 NULL</target>
        </trans-unit>
        <trans-unit id="25970e09bd0194f53db323fdee569ecc5ee9d06a" translate="yes" xml:space="preserve">
          <source>fixed format global option (see usage notes)</source>
          <target state="translated">고정 형식 글로벌 옵션 (사용 정보 참조)</target>
        </trans-unit>
        <trans-unit id="f6a11edd2a4d248a530de4d7e132bac84862a375" translate="yes" xml:space="preserve">
          <source>fixed-length bit string</source>
          <target state="translated">고정 길이 비트 문자열</target>
        </trans-unit>
        <trans-unit id="dcb97d9db2463758f31c0de9d3bce9df50408dfb" translate="yes" xml:space="preserve">
          <source>fixed-length character string</source>
          <target state="translated">고정 길이 문자열</target>
        </trans-unit>
        <trans-unit id="223f2208f7d4b1043c7e491f40e2e2d8ed03ae8b" translate="yes" xml:space="preserve">
          <source>fixed-length, blank padded</source>
          <target state="translated">고정 길이, 빈 패딩</target>
        </trans-unit>
        <trans-unit id="42f81371a9d58223349ec7034da245db8ada9ccd" translate="yes" xml:space="preserve">
          <source>flag (name of the affix class)</source>
          <target state="translated">플래그 (첨부 클래스 이름)</target>
        </trans-unit>
        <trans-unit id="b0163776e81d6187e8b5cfa662418933736608b6" translate="yes" xml:space="preserve">
          <source>flags identifying &lt;code&gt;NULL&lt;/code&gt; values</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 값을 식별하는 플래그</target>
        </trans-unit>
        <trans-unit id="93d9feb10aec6e36f31762cbd4d5259b39c8aceb" translate="yes" xml:space="preserve">
          <source>foreign server definitions</source>
          <target state="translated">외부 서버 정의</target>
        </trans-unit>
        <trans-unit id="0d25df728aebb140e50bd8e011aaf8a6c6258f90" translate="yes" xml:space="preserve">
          <source>foreign-data wrapper definitions</source>
          <target state="translated">외부 데이터 랩퍼 정의</target>
        </trans-unit>
        <trans-unit id="cacfbd40505fff5a97d7effce15468bbc881b94d" translate="yes" xml:space="preserve">
          <source>form feed</source>
          <target state="translated">사료 공급</target>
        </trans-unit>
        <trans-unit id="e03c80c93af95df14136862d42780c28c008d0cd" translate="yes" xml:space="preserve">
          <source>form feed, as in C</source>
          <target state="translated">C에서와 같이 양식 피드</target>
        </trans-unit>
        <trans-unit id="170f5a3f34787c6aab8fa71dfbca18211e9264aa" translate="yes" xml:space="preserve">
          <source>fraction of the asynchronous notification queue currently occupied (0-1)</source>
          <target state="translated">현재 점유 된 비동기 알림 큐의 비율 (0-1)</target>
        </trans-unit>
        <trans-unit id="b5b60b504526b12a5eff5f8bd8a0e84a7249041e" translate="yes" xml:space="preserve">
          <source>frequency of this MCV item</source>
          <target state="translated">이 MCV 항목의 빈도</target>
        </trans-unit>
        <trans-unit id="0fd4434dbd8cb20c8f7359b16e3d296dc62d764e" translate="yes" xml:space="preserve">
          <source>from the SQL environment, or:</source>
          <target state="translated">SQL 환경에서 또는</target>
        </trans-unit>
        <trans-unit id="ba98c5a979f1d430811c4a4f29ea3a0721cf65fc" translate="yes" xml:space="preserve">
          <source>from the shell.</source>
          <target state="translated">껍질에서.</target>
        </trans-unit>
        <trans-unit id="280f7dd2055e25f7e89bbec785c710da22de8e5a" translate="yes" xml:space="preserve">
          <source>from the shell. Only the superuser is allowed to create a database for someone else (that is, for a role you are not a member of).</source>
          <target state="translated">껍질에서. 수퍼 유저 만 다른 사람 (즉, 구성원이 아닌 역할의 데이터베이스)을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15af0e8bf417a69fca0c301e28c0685d91c4b491" translate="yes" xml:space="preserve">
          <source>full capitalized day name (blank-padded to 9 chars)</source>
          <target state="translated">전체 대문자 이름 (9 자로 공백으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="c4a997d97658b2cf2b8d26ebdf86435fc5ee3692" translate="yes" xml:space="preserve">
          <source>full capitalized month name (blank-padded to 9 chars)</source>
          <target state="translated">전체 대문자로 된 월 이름 (9 자로 공백으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="5a16a10dfdd5e4a2703b7455bf1f1425a37e5980" translate="yes" xml:space="preserve">
          <source>full lower case day name (blank-padded to 9 chars)</source>
          <target state="translated">전체 소문자 날 이름 (9 자까지 공백으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="f00512a393e028490b88f3aa5ebbe3549d7e487f" translate="yes" xml:space="preserve">
          <source>full lower case month name (blank-padded to 9 chars)</source>
          <target state="translated">소문자 월 이름 (9 자로 공백으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="42477234123d86e358924810115cf7e4102d895a" translate="yes" xml:space="preserve">
          <source>full upper case day name (blank-padded to 9 chars)</source>
          <target state="translated">대문자 전체 요일 이름 (공백 9 자)</target>
        </trans-unit>
        <trans-unit id="6d1edcedc94dd056218887a634de10777f3b1f06" translate="yes" xml:space="preserve">
          <source>full upper case month name (blank-padded to 9 chars)</source>
          <target state="translated">전체 대문자 월 이름 (9 자로 공백으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="1105c0cc10eb74d7fc4c164ddb5ce386bb49d61b" translate="yes" xml:space="preserve">
          <source>function name</source>
          <target state="translated">기능 이름</target>
        </trans-unit>
        <trans-unit id="79337461ae50346a3c64aedc6576d26f07d2da99" translate="yes" xml:space="preserve">
          <source>function to merge two elements</source>
          <target state="translated">두 요소를 병합하는 기능</target>
        </trans-unit>
        <trans-unit id="381ba103b087ce725ad29d6fb3167623521eab03" translate="yes" xml:space="preserve">
          <source>function with argument types</source>
          <target state="translated">인수 유형을 가진 함수</target>
        </trans-unit>
        <trans-unit id="d68671ea551cf0ba52601309c38f48f032157b66" translate="yes" xml:space="preserve">
          <source>functions and operators for processing and creating JSON data</source>
          <target state="translated">JSON 데이터 처리 및 작성을위한 함수 및 연산자</target>
        </trans-unit>
        <trans-unit id="2b9a1162c90a10eaa1c1d22357b7148a2281502d" translate="yes" xml:space="preserve">
          <source>functions and procedures</source>
          <target state="translated">기능과 절차</target>
        </trans-unit>
        <trans-unit id="eb3a477dc4afde1f163053db118d49c3a03b5564" translate="yes" xml:space="preserve">
          <source>further limited by tuple size fitting on a single page; see note below</source>
          <target state="translated">한 페이지에 튜플 크기를 맞추면 제한됩니다. 아래 참고 참조</target>
        </trans-unit>
        <trans-unit id="a52bca9149e86a7c11c1c387784ebae5aaedd68c" translate="yes" xml:space="preserve">
          <source>fuzzystrmatch</source>
          <target state="translated">fuzzystrmatch</target>
        </trans-unit>
        <trans-unit id="8c0aaf10dcd6bcacc121f7b404cf2264a1048fdc" translate="yes" xml:space="preserve">
          <source>generation of ancestors at a time t</source>
          <target state="translated">한 번에 조상 생성 t</target>
        </trans-unit>
        <trans-unit id="e9092fbeebad65d675ea2563bb6ea87d206977be" translate="yes" xml:space="preserve">
          <source>generation of descendants at a time t</source>
          <target state="translated">한 번에 자손 생성 t</target>
        </trans-unit>
        <trans-unit id="8f26ec92a3e06fc1bd67c0ec5e3b881f007ba31d" translate="yes" xml:space="preserve">
          <source>geometric path on a plane</source>
          <target state="translated">평면의 기하학적 경로</target>
        </trans-unit>
        <trans-unit id="5ae39128635d531b866a9705ccff8372c2803a08" translate="yes" xml:space="preserve">
          <source>geometric point on a plane</source>
          <target state="translated">평면상의 기하학적 점</target>
        </trans-unit>
        <trans-unit id="3c5902d9d1907e1e688e601d8dea2602b582cd8e" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE INDEX&lt;/code&gt; command for index</source>
          <target state="translated">인덱스에 대한 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령 가져 오기</target>
        </trans-unit>
        <trans-unit id="a3ec23c0e08fffde0bbe5f680221fb2baaef5bd5" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE INDEX&lt;/code&gt; command for index, or definition of just one index column when &lt;em&gt;&lt;code&gt;column_no&lt;/code&gt;&lt;/em&gt; is not zero</source>
          <target state="translated">인덱스에 대한 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령 또는 &lt;em&gt; &lt;code&gt;column_no&lt;/code&gt; &lt;/em&gt; 가 0이 아닌 경우 하나의 인덱스 열에 대한 정의 가져 오기</target>
        </trans-unit>
        <trans-unit id="196b69b47830d30e71241d4bd8b0fab2ca945d23" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE RULE&lt;/code&gt; command for rule</source>
          <target state="translated">&lt;code&gt;CREATE RULE&lt;/code&gt; 대한 CREATE RULE 명령 가져 오기</target>
        </trans-unit>
        <trans-unit id="2bd218c54320163748989ae51ee788d92b994ad7" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command for extended statistics object</source>
          <target state="translated">확장 통계 오브젝트에 대한 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 명령 가져 오기</target>
        </trans-unit>
        <trans-unit id="2dce21084875e338db2211be806cce40af161367" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE [ CONSTRAINT ] TRIGGER&lt;/code&gt; command for trigger</source>
          <target state="translated">트리거에 대한 &lt;code&gt;CREATE [ CONSTRAINT ] TRIGGER&lt;/code&gt; 명령 가져 오기</target>
        </trans-unit>
        <trans-unit id="af0a1a4c510167b0be953ce464e30ebb21bbb406" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;RETURNS&lt;/code&gt; clause for function (returns null for a procedure)</source>
          <target state="translated">함수에 대한 &lt;code&gt;RETURNS&lt;/code&gt; 절을 가져옵니다 (프로 시저에 대해서는 널을 리턴 함)</target>
        </trans-unit>
        <trans-unit id="22f30c887b27700ca538951254039e1464d1cdd5" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;aclitem&lt;/code&gt; array as tuples</source>
          <target state="translated">&lt;code&gt;aclitem&lt;/code&gt; 배열을 튜플로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="937dcfc31310a1d87c64ad58c35d643c3dbb2cef" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;json&lt;/code&gt; value, but attempt to distinguish numerical and Boolean values so they are unquoted in the JSON</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 를 &lt;code&gt;json&lt;/code&gt; 값 으로 가져 오지만 숫자 및 부울 값을 구별하여 JSON에서 인용되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="fe0b67a6cd7df0e277a3dcb3562abb8976f3d94c" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;json&lt;/code&gt; value, converting all non-null values to JSON strings</source>
          <target state="translated">null이 아닌 모든 값을 JSON 문자열로 변환 하여 &lt;code&gt;hstore&lt;/code&gt; 를 &lt;code&gt;json&lt;/code&gt; 값 으로 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="6ae7444ae534490ab8b85dfd69c23426f2b097e0" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;jsonb&lt;/code&gt; value, but attempt to distinguish numerical and Boolean values so they are unquoted in the JSON</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 를 &lt;code&gt;jsonb&lt;/code&gt; 값 으로 가져 오지만 숫자 및 부울 값을 구별하여 JSON에서 인용되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="e18937d566312b9c933716239bd0a1b2cab0e0bf" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;jsonb&lt;/code&gt; value, converting all non-null values to JSON strings</source>
          <target state="translated">null이 아닌 모든 값을 JSON 문자열로 변환 하여 &lt;code&gt;jsonb&lt;/code&gt; 값 으로 가져 &lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d860c2d98eb0770214f44f458048681c29c6293" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a set</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 키와 값을 세트로 가져 옵니다</target>
        </trans-unit>
        <trans-unit id="8b81abcbdffa1d36be6f3db92afd0c712b05149f" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a two-dimensional array</source>
          <target state="translated">GET &lt;code&gt;hstore&lt;/code&gt; 은 '2 차원 배열 등의 키와 값 S는</target>
        </trans-unit>
        <trans-unit id="7732475b39d72d6d44dd2efd78c07a49212ac801" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as an array of alternating keys and values</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 키와 값을 대체 키와 값의 배열로 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="3f21a27616331d2636099cf4cc88b18f8e29a805" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys as a set</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 키를 세트로 가져 옵니다</target>
        </trans-unit>
        <trans-unit id="dc9a8f1f8f4ef349c79e43b0211eead30fe502f3" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys as an array</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 키를 배열로 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="536f1dece096291af39df61eb1a0b2a7eaf9983d" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s values as a set</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 값을 세트로 가져 옵니다</target>
        </trans-unit>
        <trans-unit id="5251a2aba056bba63a67d56fc4203ed79712e3e4" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s values as an array</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 값을 배열로 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="ad8730c72dc5b463ea8cac770153712d6576278e" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;xmax&lt;/code&gt; of snapshot</source>
          <target state="translated">스냅 샷의 &lt;code&gt;xmax&lt;/code&gt; 를 얻습니다</target>
        </trans-unit>
        <trans-unit id="3ed704a6f174339573cf0c434a1db7a555f66cec" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;xmin&lt;/code&gt; of snapshot</source>
          <target state="translated">스냅 샷의 &lt;code&gt;xmin&lt;/code&gt; 을 얻습니다</target>
        </trans-unit>
        <trans-unit id="337b585e11d46bb402f4a4cec72193fc16d86d74" translate="yes" xml:space="preserve">
          <source>get SQL name of a data type</source>
          <target state="translated">데이터 타입의 SQL 이름을 얻는다</target>
        </trans-unit>
        <trans-unit id="c2ee42154b8befeb7b402a3997c784dac4cdd3a2" translate="yes" xml:space="preserve">
          <source>get address of a database object from its external representation</source>
          <target state="translated">외부 표현으로부터 데이터베이스 객체의 주소를 얻는다</target>
        </trans-unit>
        <trans-unit id="05dd67a0eb2fea988f4c7bff60b25d5bcfd72760" translate="yes" xml:space="preserve">
          <source>get argument list of function's or procedure's definition (with default values)</source>
          <target state="translated">함수 또는 프로 시저 정의의 인수 목록 가져 오기 (기본값)</target>
        </trans-unit>
        <trans-unit id="c519a3e8267da358402769c054226a03635c67ee" translate="yes" xml:space="preserve">
          <source>get argument list to identify a function or procedure (without default values)</source>
          <target state="translated">함수 또는 프로 시저를 식별하기위한 인수 목록 가져 오기 (기본값 없음)</target>
        </trans-unit>
        <trans-unit id="6b32a6038832e813790af0776307cf7b231fbb8e" translate="yes" xml:space="preserve">
          <source>get comment for a database object</source>
          <target state="translated">데이터베이스 객체에 대한 의견을 얻다</target>
        </trans-unit>
        <trans-unit id="362276384bf1063fb473a3d69cd61ec994e9c173" translate="yes" xml:space="preserve">
          <source>get comment for a database object (&lt;em&gt;deprecated&lt;/em&gt;)</source>
          <target state="translated">데이터베이스 객체에 대한 주석을 얻습니다 ( &lt;em&gt;더 이상 사용되지 않음&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb86807e0f1bd4d25c9ec5a1d13bea140bc18075" translate="yes" xml:space="preserve">
          <source>get comment for a shared database object</source>
          <target state="translated">공유 데이터베이스 객체에 대한 주석을받습니다.</target>
        </trans-unit>
        <trans-unit id="ff9969c90af75d2566e6867dd12ee5fce7632f50" translate="yes" xml:space="preserve">
          <source>get comment for a table column</source>
          <target state="translated">표 열에 대한 의견을 얻다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
