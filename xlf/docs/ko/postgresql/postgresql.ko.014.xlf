<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="debbd30b66af886f3ad4a4846dc7b2ee2e468eb1" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, emit the data needed to allow perf to profile functions generated by JIT. This writes out files to &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt;; the user is responsible for performing cleanup when desired. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">LLVM에 필요한 기능이있는 경우 perf가 JIT에서 생성 한 기능을 프로파일 링하는 데 필요한 데이터를 생성하십시오. &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt; 파일을 씁니다 . 사용자는 원할 때 정리를 수행 할 책임이 있습니다. 기본 설정은 &lt;code&gt;off&lt;/code&gt; 입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef3c317e4d741dc71490a33136e9ff9dc5428c13" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, register generated functions with GDB. This makes debugging easier. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">LLVM에 필요한 기능이 있으면 생성 된 기능을 GDB에 등록하십시오. 이것은 디버깅을 더 쉽게 만듭니다. 기본 설정은 &lt;code&gt;off&lt;/code&gt; 입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efe3f3026039f58c4fe8aa03beba8ad31146f904" translate="yes" xml:space="preserve">
          <source>If OIDs are included in the file, the OID field immediately follows the field-count word. It is a normal field except that it's not included in the field-count. Note that oid system columns are not supported in current versions of PostgreSQL.</source>
          <target state="translated">파일에 OID가 포함 된 경우 OID 필드는 필드 수 단어 바로 뒤에옵니다. 필드 수에 포함되지 않은 것을 제외하고는 일반 필드입니다. 현재 버전의 PostgreSQL에서는 OID 시스템 열이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e65f986646d4bd64aa08e3d223eb8fd14aab146" translate="yes" xml:space="preserve">
          <source>If PAM is set up to read &lt;code&gt;/etc/shadow&lt;/code&gt;, authentication will fail because the PostgreSQL server is started by a non-root user. However, this is not an issue when PAM is configured to use LDAP or other authentication methods.</source>
          <target state="translated">PAM이 &lt;code&gt;/etc/shadow&lt;/code&gt; 를 읽도록 설정되면 루트가 아닌 사용자가 PostgreSQL 서버를 시작하므로 인증이 실패합니다. 그러나 PAM이 LDAP 또는 다른 인증 방법을 사용하도록 구성된 경우에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="415ce588e29ad070811b2db4490099f305d07266" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">PostgreSQL 자체가 시스템 메모리 부족의 원인 인 경우 구성을 변경하여 문제를 피할 수 있습니다. 경우에 따라 메모리 관련 구성 매개 변수, 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/a&gt; 을 낮추는 데 도움이 될 수 있습니다 . 다른 경우에는 데이터베이스 서버 자체에 너무 많은 연결을 허용하여 문제점이 발생할 수 있습니다. 대부분의 경우 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt; 를 줄이고 대신 외부 연결 풀링 소프트웨어를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6e051bc67e0a6c331eb48a8b787733592331e28c" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-HASH-MEM-MULTIPLIER&quot;&gt;&lt;code&gt;hash_mem_multiplier&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">PostgreSQL 자체가 시스템 메모리 부족의 원인 인 경우 구성을 변경하여 문제를 피할 수 있습니다. 경우에 따라 메모리 관련 구성 매개 변수, 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;runtime-config-resource#GUC-HASH-MEM-MULTIPLIER&quot;&gt; &lt;code&gt;hash_mem_multiplier&lt;/code&gt; &lt;/a&gt; 를 낮추는 데 도움이 될 수 있습니다 . 다른 경우에는 데이터베이스 서버 자체에 너무 많은 연결을 허용하여 문제가 발생할 수 있습니다. 대부분의 경우 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt; 를 줄이고 대신 외부 연결 풀링 소프트웨어를 사용하는 것이 더 나을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce5c2e1e6b44cb1c8622c0c5ffed0c31ab912017" translate="yes" xml:space="preserve">
          <source>If PostgreSQL was compiled with OpenLDAP as the LDAP client library, the &lt;code&gt;ldapserver&lt;/code&gt; setting may be omitted. In that case, a list of host names and ports is looked up via RFC 2782 DNS SRV records. The name &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; is looked up, where &lt;code&gt;DOMAIN&lt;/code&gt; is extracted from &lt;code&gt;ldapbasedn&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL을 LDAP 클라이언트 라이브러리로 OpenLDAP와 함께 컴파일 한 경우 &lt;code&gt;ldapserver&lt;/code&gt; 설정을 생략 할 수 있습니다. 이 경우 호스트 이름 및 포트 목록은 RFC 2782 DNS SRV 레코드를 통해 조회됩니다. &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; 이름 이 조회되며 여기서 &lt;code&gt;DOMAIN&lt;/code&gt; 은 &lt;code&gt;ldapbasedn&lt;/code&gt; 에서 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f92e62044fa208f984d06131f910dfb1c21e1338" translate="yes" xml:space="preserve">
          <source>If SELinux is disabled or not installed, you must set that product up first before installing this module.</source>
          <target state="translated">SELinux가 사용 불가능하거나 설치되지 않은 경우이 모듈을 설치하기 전에 해당 제품을 먼저 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9341d807a078bf8721a956d7df4d8eca09e01a0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command is executed while a base backup is being taken, and then the template database that the &lt;code&gt;CREATE DATABASE&lt;/code&gt; copied is modified while the base backup is still in progress, it is possible that recovery will cause those modifications to be propagated into the created database as well. This is of course undesirable. To avoid this risk, it is best not to modify any template databases while taking a base backup.</source>
          <target state="translated">경우 &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE의&lt;/a&gt; 명령이 실행되는 기본 백업이 수행되고, 다음이있는 템플릿 데이터베이스 동안 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 기본 백업이 진행되는 동안 수정 복사, 회복이 그 수정이에 전파하게됩니다 가능성이 있습니다 데이터베이스도 만들었습니다. 이것은 물론 바람직하지 않습니다. 이 위험을 피하려면 기본 백업을 수행하는 동안 템플릿 데이터베이스를 수정하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fa1de3a6861be1ec1b6ec90aa7e6b3e06531f1df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DROP&lt;/code&gt; command lists multiple objects, &lt;code&gt;CASCADE&lt;/code&gt; is only required when there are dependencies outside the specified group. For example, when saying &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; the existence of a foreign key referencing &lt;code&gt;tab1&lt;/code&gt; from &lt;code&gt;tab2&lt;/code&gt; would not mean that &lt;code&gt;CASCADE&lt;/code&gt; is needed to succeed.</source>
          <target state="translated">경우 &lt;code&gt;DROP&lt;/code&gt; 의 명령 목록을 여러 개체, &lt;code&gt;CASCADE&lt;/code&gt; 는 오직 지정된 그룹 외부 의존성이있을 때 필요합니다. 말을 할 때 예를 들어, &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; 참조하는 외래 키의 존재 &lt;code&gt;tab1&lt;/code&gt; 에서 &lt;code&gt;tab2&lt;/code&gt; 것을 의미하지 않을 &lt;code&gt;CASCADE&lt;/code&gt; 가 성공하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="92e1a30bd1d3658160c72094059d0371a401f9cd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a function, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the function for the same variable are restricted to the function: the configuration parameter's prior value is still restored at function exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after function exit, unless the current transaction is rolled back.</source>
          <target state="translated">경우 &lt;code&gt;SET&lt;/code&gt; 의 절을 함수에 연결되어, 다음의 효과 &lt;code&gt;SET LOCAL&lt;/code&gt; 의 같은 변수에 대한 함수 내에서 실행 된 명령은 기능 제한됩니다 : 구성 매개 변수의 이전 값이 여전히 기능 출구에서 복원됩니다. 그러나 &lt;code&gt;LOCAL&lt;/code&gt; 이 없는 일반 &lt;code&gt;SET&lt;/code&gt; 명령 은 이전 &lt;code&gt;SET LOCAL&lt;/code&gt; 명령 에서와 마찬가지로 &lt;code&gt;SET&lt;/code&gt; 절을 재정의합니다 . 이러한 명령의 효과는 현재 트랜잭션이 롤백되지 않는 한 함수 종료 후에도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9c0a79a4075f581261c7fcce27f70643bea75e21" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then that procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">경우 &lt;code&gt;SET&lt;/code&gt; 의 절이 절차에 연결되어, 그 절차는 (예를 들어, 트랜잭션 제어 문을 실행할 수 없습니다 &lt;code&gt;COMMIT&lt;/code&gt; 및 &lt;code&gt;ROLLBACK&lt;/code&gt; 언어에 따라).</target>
        </trans-unit>
        <trans-unit id="f0bddcb97ee43256f36e19dc04e898959e413d86" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the procedure for the same variable are restricted to the procedure: the configuration parameter's prior value is still restored at procedure exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after procedure exit, unless the current transaction is rolled back.</source>
          <target state="translated">경우 &lt;code&gt;SET&lt;/code&gt; 의 절이 절차에 연결되어, 다음의 효과 &lt;code&gt;SET LOCAL&lt;/code&gt; 의 같은 변수에 대한 절차 내에서 실행 된 명령은 절차에 제한 : 구성 매개 변수의 이전 값이 여전히 절차 종료에 복원됩니다. 그러나 &lt;code&gt;LOCAL&lt;/code&gt; 이 없는 일반 &lt;code&gt;SET&lt;/code&gt; 명령 은 이전 &lt;code&gt;SET LOCAL&lt;/code&gt; 명령 과 마찬가지로 &lt;code&gt;SET&lt;/code&gt; 절을 재정의합니다 . 이러한 명령의 효과는 현재 트랜잭션이 롤백되지 않는 한 프로 시저 종료 후에도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="902cabcc62fcf46f7c4713fa1c043b73884c956f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;&lt;code&gt;command&lt;/code&gt; argument is given, the query's output is written to the named file or piped to the given shell command, instead of displaying it as usual. The file or command is written to only if the query successfully returns zero or more tuples, not if the query fails or is a non-data-returning SQL command.</source>
          <target state="translated">하면 &lt;code&gt;filename&lt;/code&gt; 또는 &lt;code&gt;|&lt;/code&gt; &lt;code&gt;command&lt;/code&gt; 인수가 주어지면 쿼리의 출력은 이름이 지정된 파일에 기록되거나 주어진 쉘 명령에 파이프됩니다. 파일 또는 명령은 쿼리가 실패하거나 데이터를 반환하지 않는 SQL 명령 인 경우가 아니라 쿼리가 0 개 이상의 튜플을 성공적으로 반환하는 경우에만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2402d507bf01ad0609465ee16a38cc42b24afe" translate="yes" xml:space="preserve">
          <source>If a check constraint, an internal representation of the expression. (It's recommended to use &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; to extract the definition of a check constraint.)</source>
          <target state="translated">점검 제한 조건 인 경우 표현식의 내부 표현입니다. 검사 제한 조건의 정의를 추출 하려면 &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f25b711856ae449f9c3d73dd4473185e384f4706" translate="yes" xml:space="preserve">
          <source>If a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.</source>
          <target state="translated">부모 테이블의 열이 ID 열이면 해당 속성이 상속되지 않습니다. 원하는 경우 자식 테이블의 열을 ID 열로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d9a8592c9a8387fcf3bd4a77c9762fb9a47cc1" translate="yes" xml:space="preserve">
          <source>If a column list is specified, &lt;code&gt;COPY TO&lt;/code&gt; copies only the data in the specified columns to the file. For &lt;code&gt;COPY FROM&lt;/code&gt;, each field in the file is inserted, in order, into the specified column. Table columns not specified in the &lt;code&gt;COPY FROM&lt;/code&gt; column list will receive their default values.</source>
          <target state="translated">열 목록이 지정된 경우 &lt;code&gt;COPY TO&lt;/code&gt; 는 지정된 열의 데이터 만 파일 에 복사합니다. 들어 &lt;code&gt;COPY FROM&lt;/code&gt; , 파일의 각 필드에 지정된 컬럼에 순서대로 삽입된다. &lt;code&gt;COPY FROM&lt;/code&gt; 열 목록에 지정되지 않은 테이블 열 은 기본값을받습니다.</target>
        </trans-unit>
        <trans-unit id="c8c03e9dff51a371ecb3dbf0f3542cbc1ae0bd39" translate="yes" xml:space="preserve">
          <source>If a column list is specified, you only need &lt;code&gt;INSERT&lt;/code&gt; privilege on the listed columns. Similarly, when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is specified, you only need &lt;code&gt;UPDATE&lt;/code&gt; privilege on the column(s) that are listed to be updated. However, &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; also requires &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; expressions or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">열 목록이 지정되면 나열된 열에 대한 &lt;code&gt;INSERT&lt;/code&gt; 권한 만 필요합니다 . 마찬가지로 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 가 지정되면 업데이트 된 것으로 나열된 열에 대한 &lt;code&gt;UPDATE&lt;/code&gt; 권한 만 필요합니다 . 그러나 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 에는 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 표현식 또는 &lt;code&gt;condition&lt;/code&gt; 에서 값을 읽는 모든 열에 대한 &lt;code&gt;SELECT&lt;/code&gt; 특권 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="6ae12c756d83d3fa84f0842896261c6e6de98fbd" translate="yes" xml:space="preserve">
          <source>If a column result is NULL, the corresponding variable is unset rather than being set.</source>
          <target state="translated">열 결과가 NULL이면 해당 변수가 설정되지 않고 설정되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd07d38bba484cac13838ebc8d7dd08509069d67" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">열의 XPath 표현식이 XML 이외의 값 (XPath 1.0에서 string, boolean 또는 double로 제한됨)을 리턴하고 열에 &lt;code&gt;xml&lt;/code&gt; 이외의 PostgreSQL 유형 이있는 경우, 값의 문자열 표시를 다음과 같이 지정하여 열이 설정됩니다. PostgreSQL 유형. (값이 부울 인 경우 출력 열의 유형 범주가 숫자 &lt;code&gt;true&lt;/code&gt; 문자열 표현이 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 으로 , 그렇지 않으면 true 또는 &lt;code&gt;false&lt;/code&gt; 로 설정 됩니다.)</target>
        </trans-unit>
        <trans-unit id="3d86c8d327357d64a90febd0e7b2a64229fc6de1" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (which is limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">열의 XPath 표현식이 비 XML 값 (XPath 1.0에서 string, boolean 또는 double로 제한됨)을 반환하고 열에 &lt;code&gt;xml&lt;/code&gt; 이외의 PostgreSQL 유형 이있는 경우 값의 문자열 표현을 할당하는 것처럼 열이 설정됩니다. PostgreSQL 유형에. (값이 부울 이면 출력 열의 유형 범주가 숫자 &lt;code&gt;true&lt;/code&gt; 문자열 표현이 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 이되고 그렇지 않으면 true 또는 &lt;code&gt;false&lt;/code&gt; 가 됩니다.)</target>
        </trans-unit>
        <trans-unit id="dd49d82e6f7364358b7e1308125e6548ff45efeb" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">열의 XPath 표현식이 비어 있지 않은 XML 노드 세트를 리턴하고 열의 PostgreSQL 유형이 &lt;code&gt;xml&lt;/code&gt; 인 경우, 열이 문서 또는 컨텐츠 양식 인 경우 표현식 결과가 정확하게 지정됩니다. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f606ba5da3ce72a5b48e1fa0637f31121b0521b" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.21.7.5.15.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.21.7.5.15.2&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">열의 XPath식이 비어 있지 않은 XML 노드 집합을 반환하고 열의 PostgreSQL 유형이 &lt;code&gt;xml&lt;/code&gt; 이면 열에 문서 또는 콘텐츠 형식 인 경우 식 결과가 정확하게 할당됩니다. &lt;a href=&quot;#ftn.id-1.5.8.21.7.5.15.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.21.7.5.15.2&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2001ae15ca417e0e9b4706925c6ddabecd8102f7" translate="yes" xml:space="preserve">
          <source>If a conflicting row has been inserted by an as-yet-uncommitted transaction, the would-be inserter must wait to see if that transaction commits. If it rolls back then there is no conflict. If it commits without deleting the conflicting row again, there is a uniqueness violation. (In practice we just wait for the other transaction to end and then redo the visibility check in toto.)</source>
          <target state="translated">커밋되지 않은 트랜잭션에 의해 충돌하는 행이 삽입 된 경우 해당 삽입 기는 해당 트랜잭션이 커밋되는지 확인해야합니다. 롤백되면 충돌이 없습니다. 충돌하는 행을 다시 삭제하지 않고 커밋하면 고유성 위반이 있습니다. (실제로 다른 트랜잭션이 종료 될 때까지 기다린 다음 가시성 체크인을 다시 실행하십시오.)</target>
        </trans-unit>
        <trans-unit id="25c5a233f983a5a11d2f0ce26b28af3fbae3c56b" translate="yes" xml:space="preserve">
          <source>If a conflicting valid row has been deleted by the current transaction, it's okay. (In particular, since an UPDATE always deletes the old row version before inserting the new version, this will allow an UPDATE on a row without changing the key.)</source>
          <target state="translated">충돌하는 유효한 행이 현재 트랜잭션에 의해 삭제 되었다면 괜찮습니다. 특히, UPDATE는 새 버전을 삽입하기 전에 항상 이전 행 버전을 삭제하므로 키를 변경하지 않고 행에서 UPDATE를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2370b745676126171b063e2e2d72095b349175fc" translate="yes" xml:space="preserve">
          <source>If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;, it is checked after each statement. This is the default. If the constraint is &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt;, it is checked only at the end of the transaction. The constraint check time can be altered with the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command.</source>
          <target state="translated">제한 조건을 연기 할 수있는 경우이 절은 제한 조건을 점검하는 기본 시간을 지정합니다. 제한 조건이 &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; 인 경우 각 명령문 다음에 점검됩니다. 이것이 기본값입니다. 제한 조건이 &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt; 인 경우 트랜잭션이 끝날 때만 점검됩니다. 제약 조건 확인 시간은 &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; 명령 으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45ddd1496c9c8970f749841790d5cc33a1ed958c" translate="yes" xml:space="preserve">
          <source>If a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index.</source>
          <target state="translated">제한 조건 이름이 제공되면 제한 조건 이름과 일치하도록 색인 이름이 변경됩니다. 그렇지 않으면 제약 조건의 이름이 색인과 동일하게 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="516a948273fe630c2fd2d3bb4954b014ec3a728f" translate="yes" xml:space="preserve">
          <source>If a cursor is closed after a savepoint which is later rolled back, the &lt;code&gt;CLOSE&lt;/code&gt; is not rolled back; that is, the cursor remains closed.</source>
          <target state="translated">저장 점이 나중에 롤백 된 후 커서가 닫히면 &lt;code&gt;CLOSE&lt;/code&gt; 는 롤백되지 않습니다. 즉, 커서는 닫힌 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6755c4a78a3da118c77dadc78bfef40de55f4e2d" translate="yes" xml:space="preserve">
          <source>If a daylight-savings abbreviation is given but the transition &lt;code&gt;rule&lt;/code&gt; field is omitted, the fallback behavior is to use the rule &lt;code&gt;M3.2.0,M11.1.0&lt;/code&gt;, which corresponds to USA practice as of 2020 (that is, spring forward on the second Sunday of March, fall back on the first Sunday of November, both transitions occurring at 2AM prevailing time). Note that this rule does not give correct USA transition dates for years before 2007.</source>
          <target state="translated">일광 절약 약어가 제공되었지만 전환 &lt;code&gt;rule&lt;/code&gt; 필드가 생략 된 경우 대체 동작은 2020 년 현재 미국 관행에 해당하는 규칙 &lt;code&gt;M3.2.0,M11.1.0&lt;/code&gt; 을 사용하는 것입니다 (즉, 두 번째 일요일에 봄) 3 월 중, 11 월 첫 번째 일요일에 폴백, 두 전환 모두 오전 2시에 발생). 이 규칙은 2007 년 이전 몇 년 동안 정확한 미국 전환 날짜를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b8ad01bd9eefe5ae6504ee533b29e5940a9bbcc" translate="yes" xml:space="preserve">
          <source>If a different escape character than backslash is desired, it can be specified using the &lt;code&gt;UESCAPE&lt;/code&gt; clause after the string, for example:</source>
          <target state="translated">백 슬래시와 다른 이스케이프 문자가 필요한 경우 문자열 뒤에 &lt;code&gt;UESCAPE&lt;/code&gt; 절을 사용하여 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c0e309df60d6b04409ae8154560e144f149154e" translate="yes" xml:space="preserve">
          <source>If a dynamically loadable module needs to be opened and the file name specified in the &lt;code&gt;CREATE FUNCTION&lt;/code&gt; or &lt;code&gt;LOAD&lt;/code&gt; command does not have a directory component (i.e., the name does not contain a slash), the system will search this path for the required file.</source>
          <target state="translated">동적으로로드 가능한 모듈을 열어야하고 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 또는 &lt;code&gt;LOAD&lt;/code&gt; 명령에 지정된 파일 이름 에 디렉토리 구성 요소가없는 경우 (즉, 이름에 슬래시가 포함되지 않은 경우) 시스템은이 경로에서 필요한 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="eead72d18dc8bb550762010fb49abdc92926fc22" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for FK = FK comparisons</source>
          <target state="translated">외래 키인 경우 FK = FK 비교에 대한 항등 연산자 목록</target>
        </trans-unit>
        <trans-unit id="f2557ac45b6d34f20af024d349a08e662002e006" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = FK comparisons</source>
          <target state="translated">외래 키인 경우 PK = FK 비교에 대한 항등 연산자 목록</target>
        </trans-unit>
        <trans-unit id="65b7a7238de39c08afb78813e4651af5cc557847" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = PK comparisons</source>
          <target state="translated">외래 키인 경우 PK = PK 비교에 대한 항등 연산자 목록</target>
        </trans-unit>
        <trans-unit id="84b58f81bb95714e62ab14756a76120d62320f41" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the referenced columns</source>
          <target state="translated">외래 키인 경우 참조 된 열 목록</target>
        </trans-unit>
        <trans-unit id="7870e560cb55fb3708abcfcfa26fc2aa507576ee" translate="yes" xml:space="preserve">
          <source>If a foreign key, the referenced table; else 0</source>
          <target state="translated">외래 키인 경우 참조 테이블 그렇지 않으면 0</target>
        </trans-unit>
        <trans-unit id="575611ec6feb49c10dfac57d786d3e40ac55a75b" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any unit conversion.</source>
          <target state="translated">분수 값이 단위와 함께 지정되면 다음으로 작은 단위가 있으면 그 다음으로 작은 단위의 배수로 반올림됩니다. 예를 들어, &lt;code&gt;30.1 GB&lt;/code&gt; 는 변환됩니다 &lt;code&gt;30822 MB&lt;/code&gt; 하지 &lt;code&gt;32319628902 B&lt;/code&gt; . 매개 변수가 정수 유형이면 단위 변환 후 정수로 최종 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="302fc67ef061c10f65906072775cc6ba157a3bf8" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any units conversion.</source>
          <target state="translated">소수 값이 단위로 지정되면 다음 작은 단위가 여러 개인 경우 반올림됩니다. 예를 들어, &lt;code&gt;30.1 GB&lt;/code&gt; 는 변환됩니다 &lt;code&gt;30822 MB&lt;/code&gt; 하지 &lt;code&gt;32319628902 B&lt;/code&gt; . 매개 변수가 정수 유형 인 경우, 단위 변환 후 정수로의 마지막 반올림이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16517351d5f6d1324d494a56b7cbc1349aadbd26" translate="yes" xml:space="preserve">
          <source>If a function executed within a parallel worker acquires locks which are not held by the leader, for example by querying a table not referenced in the query, those locks will be released at worker exit, not end of transaction. If you write a function which does this, and this behavior difference is important to you, mark such functions as &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; to ensure that they execute only in the leader.</source>
          <target state="translated">병렬 작업자 내에서 실행 된 함수가 리더에서 보유하지 않은 잠금 (예 : 쿼리에서 참조되지 않은 테이블을 쿼리)을 획득하면 해당 잠금은 트랜잭션 종료가 아닌 작업자 종료시 해제됩니다. 이를 수행하는 함수를 작성하고이 동작 차이가 중요한 경우 해당 함수를 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 로 표시 하여 리더에서만 실행되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="c08af80c4ec0b88bc818f2eba0deaa5cfe1fa698" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;STRICT&lt;/code&gt; with a &lt;code&gt;VARIADIC&lt;/code&gt; argument, the strictness check tests that the variadic array &lt;em&gt;as a whole&lt;/em&gt; is non-null. The function will still be called if the array has null elements.</source>
          <target state="translated">함수가 &lt;code&gt;VARIADIC&lt;/code&gt; 인수 와 함께 &lt;code&gt;STRICT&lt;/code&gt; 로 선언 되면 엄격 검사는 가변 배열 &lt;em&gt;이 전체적으로&lt;/em&gt; 널이 아닌지 테스트합니다 . 배열에 null 요소가 있으면 함수가 계속 호출됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d9a8948caa2988125e4b727f3b2df8159e037f5" translate="yes" xml:space="preserve">
          <source>If a function is declared with a &lt;code&gt;VARIADIC&lt;/code&gt; array parameter, and the call does not use the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, then the function is treated as if the array parameter were replaced by one or more occurrences of its element type, as needed to match the call. After such expansion the function might have effective argument types identical to some non-variadic function. In that case the function appearing earlier in the search path is used, or if the two functions are in the same schema, the non-variadic one is preferred.</source>
          <target state="translated">&lt;code&gt;VARIADIC&lt;/code&gt; 배열 매개 변수를 사용하여 함수를 선언 하고 호출에서 &lt;code&gt;VARIADIC&lt;/code&gt; 키워드를 사용하지 않는 경우 함수는 배열 매개 변수가 호출과 일치하는 데 필요한 요소 유형의 하나 이상으로 대체 된 것처럼 처리됩니다. 이러한 확장 후 함수는 가변적이지 않은 함수와 동일한 효과적인 인수 유형을 가질 수 있습니다. 이 경우 검색 경로에서 이전에 나타나는 함수가 사용되거나 두 함수가 동일한 스키마에 있으면 비 변형적인 것이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="29873e6b07ca3d965e9bf60280fc04e4b50e061e" translate="yes" xml:space="preserve">
          <source>If a generic plan is in use, it will contain parameter symbols &lt;code&gt;$n&lt;/code&gt;, while a custom plan will have the supplied parameter values substituted into it.</source>
          <target state="translated">일반 계획을 사용중인 경우 매개 변수 기호 &lt;code&gt;$n&lt;/code&gt; 이 포함 되고 사용자 정의 계획에는 제공된 매개 변수 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="b9eddb833bc9b9e1959393e089ee3b45e63b93cb" translate="yes" xml:space="preserve">
          <source>If a host name is specified (anything that is not an IP address range or a special key word is treated as a host name), that name is compared with the result of a reverse name resolution of the client's IP address (e.g., reverse DNS lookup, if DNS is used). Host name comparisons are case insensitive. If there is a match, then a forward name resolution (e.g., forward DNS lookup) is performed on the host name to check whether any of the addresses it resolves to are equal to the client's IP address. If both directions match, then the entry is considered to match. (The host name that is used in &lt;code&gt;pg_hba.conf&lt;/code&gt; should be the one that address-to-name resolution of the client's IP address returns, otherwise the line won't be matched. Some host name databases allow associating an IP address with multiple host names, but the operating system will only return one host name when asked to resolve an IP address.)</source>
          <target state="translated">호스트 이름이 지정되면 (IP 주소 범위가 아니거나 특수 키워드가 호스트 이름으로 취급되는 경우) 해당 이름은 클라이언트 IP 주소의 역 이름 확인 결과 (예 : 역 DNS)와 비교됩니다 DNS를 사용하는 경우 조회). 호스트 이름 비교는 대소 문자를 구분하지 않습니다. 일치하는 경우 호스트 이름에 대해 정방향 이름 확인 (예 : 정방향 DNS 조회)을 수행하여 확인 된 주소 중 하나가 클라이언트의 IP 주소와 같은지 확인합니다. 두 방향이 일치하면 항목이 일치하는 것으로 간주됩니다. ( &lt;code&gt;pg_hba.conf&lt;/code&gt; 에서 사용되는 호스트 이름클라이언트의 IP 주소의 주소 대 이름 확인이 반환되는 이름이어야합니다. 그렇지 않으면 행이 일치하지 않습니다. 일부 호스트 이름 데이터베이스에서는 IP 주소를 여러 호스트 이름과 연결할 수 있지만 운영 체제는 IP 주소를 확인하라는 메시지가 표시 될 때 하나의 호스트 이름 만 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="29821b670fa593b8c5ed4db6b848a4180ea0c1c3" translate="yes" xml:space="preserve">
          <source>If a limit count is given, no more than that many rows will be returned (but possibly fewer, if the query itself yields fewer rows). &lt;code&gt;LIMIT ALL&lt;/code&gt; is the same as omitting the &lt;code&gt;LIMIT&lt;/code&gt; clause, as is &lt;code&gt;LIMIT&lt;/code&gt; with a NULL argument.</source>
          <target state="translated">제한 개수를 지정하면 그보다 많은 행이 반환되지 않습니다 (단, 쿼리 자체가 더 적은 행을 생성하는 경우 더 적음). &lt;code&gt;LIMIT ALL&lt;/code&gt; 은 &lt;code&gt;LIMIT&lt;/code&gt; 절 을 생략하는 것과 동일 하며 NULL 인수를 갖는 &lt;code&gt;LIMIT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e0f012a9c847bea5735587a0a262fd8fc04fc30" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the file or query buffer. Note that if a single all-digits argument is given, psql assumes it is a line number, not a file name.</source>
          <target state="translated">행 번호가 지정되면 psql은 커서를 파일 또는 조회 버퍼의 지정된 행에 위치시킵니다. 하나의 모든 자릿수 인수가 제공되면 psql은 파일 이름이 아니라 행 번호라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="989ad942cdac74f48ff0f663910b668e0bfcd851" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the function body. (Note that the function body typically does not begin on the first line of the file.)</source>
          <target state="translated">행 번호가 지정되면, psql은 함수 본문의 지정된 행에 커서를 위치시킵니다. 함수 본문은 일반적으로 파일의 첫 번째 줄에서 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f28240e112ab05b43febc5915be398cc2c0ace7d" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the view definition.</source>
          <target state="translated">라인 번호가 지정되면 psql은 뷰 정의의 지정된 라인에 커서를 놓습니다.</target>
        </trans-unit>
        <trans-unit id="e1603d0c375b802bfd8ff93da28473ffff6f9ce0" translate="yes" xml:space="preserve">
          <source>If a list of columns is specified, &lt;code&gt;COPY&lt;/code&gt; will only copy the data in the specified columns to or from the file. If there are any columns in the table that are not in the column list, &lt;code&gt;COPY FROM&lt;/code&gt; will insert the default values for those columns.</source>
          <target state="translated">열 목록이 지정된 경우 &lt;code&gt;COPY&lt;/code&gt; 는 지정된 열의 데이터 만 파일에서 또는 파일로 복사합니다. 테이블에 열 목록에없는 열이 있으면 &lt;code&gt;COPY FROM&lt;/code&gt; 에서 해당 열의 기본값을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="5d76d1bc7bed56c879e14e369962729e0bb7fe98" translate="yes" xml:space="preserve">
          <source>If a new child node must be added, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgAddNode&lt;/code&gt;. Set &lt;code&gt;nodeLabel&lt;/code&gt; to the label to be used for the new node, and set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) at which to insert the node in the node array. After the node has been added, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the modified inner tuple; that call should result in an &lt;code&gt;spgMatchNode&lt;/code&gt; result.</source>
          <target state="translated">새 자식 노드를 추가해야하는 경우 &lt;code&gt;resultType&lt;/code&gt; 을 &lt;code&gt;spgAddNode&lt;/code&gt; 로 설정 하십시오 . 집합 &lt;code&gt;nodeLabel&lt;/code&gt; 라벨에 새로운 노드를 사용하고, 설정되는 &lt;code&gt;nodeN&lt;/code&gt; 를 노드 어레이에서의 노드를 삽입하는 (제로)에서 인덱스로. 노드가 추가되면 수정 된 내부 튜플과 함께 &lt;code&gt;choose&lt;/code&gt; 함수가 다시 호출됩니다. 이 호출은 &lt;code&gt;spgMatchNode&lt;/code&gt; 결과를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="342f14a4cf8cecaaec4f439a2239828717657aec" translate="yes" xml:space="preserve">
          <source>If a parent column is a generated column, a child column must also be a generated column using the same expression. In the definition of the child column, leave off the &lt;code&gt;GENERATED&lt;/code&gt; clause, as it will be copied from the parent.</source>
          <target state="translated">상위 열이 생성 된 열인 경우 하위 열도 동일한 표현식을 사용하여 생성 된 열이어야합니다. 하위 열의 정의에서 &lt;code&gt;GENERATED&lt;/code&gt; 절은 상위에서 복사되므로 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="bc7892c6f8a458e96e3334e518119041320e0ca8" translate="yes" xml:space="preserve">
          <source>If a parent column is not a generated column, a child column may be defined to be a generated column or not.</source>
          <target state="translated">상위 열이 생성 된 열이 아닌 경우 하위 열은 생성 된 열인지 여부로 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6c9e178ba05d52398d348d0978c9f0904579a20" translate="yes" xml:space="preserve">
          <source>If a part of the plan guarantees an ordering on a prefix of the required sort keys, then the planner may instead decide to use an &lt;code&gt;incremental sort&lt;/code&gt; step:</source>
          <target state="translated">계획의 일부가 필수 정렬 키의 접두사에 대한 순서를 보장하는 경우 플래너는 대신 &lt;code&gt;incremental sort&lt;/code&gt; 단계 를 사용하기로 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01753c01a634660c1afc91855a2bf3e6c0a24915" translate="yes" xml:space="preserve">
          <source>If a problem arises while rebuilding the indexes, such as a uniqueness violation in a unique index, the &lt;code&gt;REINDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; new index in addition to the pre-existing one. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">고유 인덱스의 고유성 위반과 같은 인덱스를 재 구축하는 동안 문제가 발생하면 &lt;code&gt;REINDEX&lt;/code&gt; 명령이 실패하지만 기존 인덱스 외에 &quot;잘못된&quot;새 인덱스가 남습니다. 이 인덱스는 불완전 할 수 있으므로 쿼리 목적으로 무시됩니다. 그러나 여전히 업데이트 오버 헤드를 소비합니다. psql &lt;code&gt;\d&lt;/code&gt; 명령은 &lt;code&gt;INVALID&lt;/code&gt; 와 같은 색인을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="fc2fcf347772c27798939c43c378ac44b8d079f9" translate="yes" xml:space="preserve">
          <source>If a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">교착 상태 또는 고유 인덱스의 고유성 위반과 같은 테이블을 스캔하는 동안 문제가 발생하면 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령이 실패하지만 &quot;유효하지 않은&quot;인덱스는 남겨 둡니다. 이 인덱스는 불완전 할 수 있으므로 쿼리 목적으로 무시됩니다. 그러나 여전히 업데이트 오버 헤드를 소비합니다. psql &lt;code&gt;\d&lt;/code&gt; 명령은 &lt;code&gt;INVALID&lt;/code&gt; 와 같은 색인을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="60b7f8c376b0c316858e3c03acae729e9e8e0bbd" translate="yes" xml:space="preserve">
          <source>If a problem like this arises, it may not affect each individual index that is ordered using an affected collation, simply because &lt;em&gt;indexed&lt;/em&gt; values might happen to have the same absolute ordering regardless of the behavioral inconsistency. See &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; and &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for further details about how PostgreSQL uses operating system locales and collations.</source>
          <target state="translated">이와 같은 문제가 발생하면 영향을받는 데이터 정렬을 사용하여 정렬 된 각 개별 인덱스에 영향을 미치지 않을 수 있습니다. 단순히 &lt;em&gt;인덱스 된&lt;/em&gt; 값이 동작 불일치에 관계없이 동일한 절대 순서를 가질 수 있기 때문 입니다. PostgreSQL이 운영 체제 로캘 및 데이터 정렬을 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;locale&quot;&gt;23.1 절&lt;/a&gt; 및 &lt;a href=&quot;collation&quot;&gt;23.2 &lt;/a&gt;절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14159bc71155b473a106589680a4763fc75cdf28" translate="yes" xml:space="preserve">
          <source>If a query contains aggregate function calls, but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, grouping still occurs: the result is a single group row (or perhaps no rows at all, if the single row is then eliminated by &lt;code&gt;HAVING&lt;/code&gt;). The same is true if it contains a &lt;code&gt;HAVING&lt;/code&gt; clause, even without any aggregate function calls or &lt;code&gt;GROUP BY&lt;/code&gt; clause.</source>
          <target state="translated">쿼리에 집계 함수 호출이 포함되어 있지만 &lt;code&gt;GROUP BY&lt;/code&gt; 절이없는 경우 그룹화는 여전히 발생합니다. 결과는 단일 그룹 행이거나 단일 행이 &lt;code&gt;HAVING&lt;/code&gt; 에 의해 제거되는 경우 행이 전혀 없습니다 . 집계 함수 호출이나 &lt;code&gt;GROUP BY&lt;/code&gt; 절이 없어도 &lt;code&gt;HAVING&lt;/code&gt; 절이 포함 된 경우 에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="7e2704031f22c0864166ff4a01e062f291652c11" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g. after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">그렇게 할 것으로 예상되는 쿼리가 병렬 계획을 생성하지 않으면 &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost를&lt;/a&gt; 줄일 수 있습니다 . 물론,이 계획은 플래너가 선호하는 일련 계획보다 느릴 수 있지만 항상 그런 것은 아닙니다. 이러한 설정 값이 매우 작은 경우에도 병렬 계획을 얻지 못한 경우 (예 : 둘 다 0으로 설정 한 후) 쿼리 플래너가 쿼리에 대한 병렬 계획을 생성 할 수없는 이유가있을 수 있습니다. 왜 그런지에 대한 정보는 &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;15.2 절&lt;/a&gt; 과 &lt;a href=&quot;parallel-safety&quot;&gt;15.4 &lt;/a&gt;절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e703ec1af7c6fe8daa3820fdcecb57bac64cdaff" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g., after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">그렇게 할 것으로 예상되는 쿼리가 병렬 계획을 생성하지 않는 경우 &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost를&lt;/a&gt; 줄일 수 있습니다 . 물론이 계획은 계획자가 선호하는 직렬 계획보다 느릴 수 있지만 항상 그런 것은 아닙니다. 이러한 설정의 값이 매우 작은 경우에도 (예 : 둘 다 0으로 설정 한 후) 병렬 계획을 얻지 못하는 경우 쿼리 플래너가 쿼리에 대한 병렬 계획을 생성 할 수없는 이유가있을 수 있습니다. 이것이 왜 그런지에 대한 정보는 &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;섹션 15.2&lt;/a&gt; 및 &lt;a href=&quot;parallel-safety&quot;&gt;섹션 15.4&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d78bc381604777d833daa7f8a441adef31412d42" translate="yes" xml:space="preserve">
          <source>If a query's results do not fit on the screen, they are piped through this command. Typical values are &lt;code&gt;more&lt;/code&gt; or &lt;code&gt;less&lt;/code&gt;. Use of the pager can be disabled by setting &lt;code&gt;PSQL_PAGER&lt;/code&gt; or &lt;code&gt;PAGER&lt;/code&gt; to an empty string, or by adjusting the pager-related options of the &lt;code&gt;\pset&lt;/code&gt; command. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use &lt;code&gt;more&lt;/code&gt; on most platforms, but &lt;code&gt;less&lt;/code&gt; on Cygwin.</source>
          <target state="translated">쿼리 결과가 화면에 맞지 않으면이 명령을 통해 파이프됩니다. 일반적인 값은 &lt;code&gt;more&lt;/code&gt; 또는 &lt;code&gt;less&lt;/code&gt; . &lt;code&gt;PSQL_PAGER&lt;/code&gt; 또는 &lt;code&gt;PAGER&lt;/code&gt; 를 빈 문자열 로 설정 하거나 &lt;code&gt;\pset&lt;/code&gt; 명령 의 호출기 관련 옵션을 조정하여 호출기를 사용하지 않도록 설정할 수 있습니다 . 이러한 변수는 나열된 순서대로 검사됩니다. 설정된 첫 번째가 사용됩니다. 설정되지 않은 경우 기본값은 대부분의 플랫폼에서 &lt;code&gt;more&lt;/code&gt; 사용 하지만 Cygwin 에서는 &lt;code&gt;less&lt;/code&gt; 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a16d1e24e65d591a8270e12d2132334cb1a5266" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt;) then the aggregate function is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 제공되면 (예 : &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt; ) 집계 함수가 지정된 스키마에 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9221069e2f8158080f0dab328adf9a4fc4ac50a4" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt;) then the domain is created in the specified schema. Otherwise it is created in the current schema. The domain name must be unique among the types and domains existing in its schema.</source>
          <target state="translated">스키마 이름이 지정되면 (예 : &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt; ) 지정된 도메인에 도메인이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 도메인 이름은 스키마에 존재하는 유형과 도메인 중에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b01ea3ef0736036d56ce2802cb7af1e7ac1551f" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. The name of the foreign table must be distinct from the name of any other foreign table, table, sequence, index, view, or materialized view in the same schema.</source>
          <target state="translated">스키마 이름이 지정되면 (예 : &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt; ) 지정된 테이블에 테이블이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 외부 테이블의 이름은 동일한 스키마에서 다른 외부 테이블, 테이블, 시퀀스, 인덱스, 뷰 또는 구체화 된 뷰의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="0017dfefecb7c7d878ccd99cec2c2243eb08f548" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt;) then the statistics object is created in the specified schema. Otherwise it is created in the current schema. The name of the statistics object must be distinct from the name of any other statistics object in the same schema.</source>
          <target state="translated">스키마 이름이 제공되면 (예 : &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt; ) 통계 오브젝트가 지정된 스키마에 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 통계 오브젝트의 이름은 동일한 스키마에있는 다른 통계 오브젝트의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="d358a0109b0b0aa95ca587460e4392925dac3d64" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other table, sequence, index, view, or foreign table in the same schema.</source>
          <target state="translated">스키마 이름이 지정된 경우 (예 : &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt; ) 지정된 스키마에 테이블이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 임시 테이블은 특수 스키마에 존재하므로 임시 테이블을 작성할 때 스키마 이름을 지정할 수 없습니다. 테이블 이름은 동일한 스키마에서 다른 테이블, 시퀀스, 인덱스, 뷰 또는 외부 테이블의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="93459b6de8914138c246c45451309801fa4eb75b" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt;) then the view is created in the specified schema. Otherwise it is created in the current schema. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view. The name of the view must be distinct from the name of any other view, table, sequence, index or foreign table in the same schema.</source>
          <target state="translated">스키마 이름이 지정된 경우 (예 : &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt; )보기가 지정된 스키마에 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 임시 뷰는 특수 스키마에 존재하므로 임시 뷰를 생성 할 때 스키마 이름을 지정할 수 없습니다. 뷰 이름은 동일한 스키마에서 다른 뷰, 테이블, 시퀀스, 인덱스 또는 외부 테이블의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="f45727194d879f2673b515b0704bca00c0cdc2be" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator class is created in the specified schema. Otherwise it is created in the current schema. Two operator classes in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">스키마 이름이 제공되면 지정된 스키마에서 연산자 클래스가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 동일한 스키마에있는 두 개의 연산자 클래스는 다른 색인 메소드에 대해서만 동일한 이름을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="924ee280ad5b0efe3a03d3f74bd950473afe0d2b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator family is created in the specified schema. Otherwise it is created in the current schema. Two operator families in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">스키마 이름이 제공되면 지정된 스키마에 운영자 패밀리가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 동일한 스키마에있는 두 개의 연산자 제품군은 서로 다른 색인 메소드에 대해서만 동일한 이름을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d43b98c46599ec5632b8b68a4c4aec5bc7c49e45" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the sequence is created in the specified schema. Otherwise it is created in the current schema. Temporary sequences exist in a special schema, so a schema name cannot be given when creating a temporary sequence. The sequence name must be distinct from the name of any other sequence, table, index, view, or foreign table in the same schema.</source>
          <target state="translated">스키마 이름이 지정되면 지정된 스키마에서 시퀀스가 ​​작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 임시 시퀀스는 특수 스키마에 존재하므로 임시 시퀀스를 만들 때 스키마 이름을 지정할 수 없습니다. 시퀀스 이름은 동일한 스키마에서 다른 시퀀스, 테이블, 인덱스, 뷰 또는 외부 테이블의 이름과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="d3a817f61150e098cf1b32f5797358f478896c39" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search configuration is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 지정되면 지정된 스키마에 텍스트 검색 구성이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6aa5bd7767ed3e5d5d615c990a382ab4eccb349b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search dictionary is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 지정되면 지정된 스키마에 텍스트 검색 사전이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f275ed3d77d7d07fbadd2aeff95331926c88b60" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search parser is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 제공되면 지정된 스키마에 텍스트 검색 구문 분석기가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c90f2803121a2139271a7f1f2ab6d88702071162" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search template is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">스키마 이름이 지정되면 지정된 스키마에 텍스트 검색 템플리트가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1b270e2011c6de6a6609606ad6c64491399611" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the type is created in the specified schema. Otherwise it is created in the current schema. The type name must be distinct from the name of any existing type or domain in the same schema. (Because tables have associated data types, the type name must also be distinct from the name of any existing table in the same schema.)</source>
          <target state="translated">스키마 이름이 제공되면 지정된 스키마에서 유형이 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 유형 이름은 동일한 스키마의 기존 유형 또는 도메인 이름과 달라야합니다. (테이블에 연관된 데이터 유형이 있으므로 유형 이름도 동일한 스키마에있는 기존 테이블의 이름과 달라야합니다.)</target>
        </trans-unit>
        <trans-unit id="3270e8102f1d16bb2969879cc26ff629f7438593" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the function is created in the specified schema. Otherwise it is created in the current schema. The name of the new function must not match any existing function or procedure with the same input argument types in the same schema. However, functions and procedures of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">스키마 이름이 포함 된 경우 지정된 스키마에 함수가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 새 함수의 이름은 동일한 스키마에서 동일한 입력 인수 유형을 가진 기존 함수 또는 프로 시저와 일치하지 않아야합니다. 그러나 다른 인수 유형의 함수 및 프로시 저는 이름을 공유 할 수 있습니다 (이를 &lt;em&gt;오버로딩&lt;/em&gt; 이라고 함 ).</target>
        </trans-unit>
        <trans-unit id="fa9f9c34f552135ee16bf0e254ac4f8936e929d0" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the procedure is created in the specified schema. Otherwise it is created in the current schema. The name of the new procedure must not match any existing procedure or function with the same input argument types in the same schema. However, procedures and functions of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">스키마 이름이 포함 된 경우 지정된 스키마에서 프로 시저가 작성됩니다. 그렇지 않으면 현재 스키마에서 작성됩니다. 새 프로 시저의 이름은 동일한 스키마에서 동일한 입력 인수 유형을 가진 기존 프로 시저 또는 함수와 일치하지 않아야합니다. 그러나 다른 인수 유형의 프로 시저 및 함수는 이름을 공유 할 수 있습니다 (이를 &lt;em&gt;오버로딩&lt;/em&gt; 이라고 함 ).</target>
        </trans-unit>
        <trans-unit id="dacc047d6b80f30af4e1b3c075ae268658bf910d" translate="yes" xml:space="preserve">
          <source>If a separate session key is requested, a new random key will be generated. Otherwise the S2K key will be used directly as the session key.</source>
          <target state="translated">별도의 세션 키가 요청되면 새로운 임의의 키가 생성됩니다. 그렇지 않으면 S2K 키가 세션 키로 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5829673b8ac4bdf9ef5ccbb615c82963b07e7a46" translate="yes" xml:space="preserve">
          <source>If a sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using special parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command; see its command reference page for more information.</source>
          <target state="translated">기본 매개 변수를 사용하여 시퀀스 오브젝트를 작성한 경우, 연속적인 &lt;code&gt;nextval&lt;/code&gt; 호출은 1로 시작하는 연속적인 값을 리턴합니다. &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; 명령 에서 특수 매개 변수를 사용하여 다른 동작을 얻을 수 있습니다 . 자세한 내용은 해당 명령 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f45a6ad1ab211a977ca7a8e8006108f711740038" translate="yes" xml:space="preserve">
          <source>If a subscription is associated with a replication slot, then &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">구독이 복제 슬롯과 연결된 경우 트랜잭션 블록 내에서 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fefee0e29f8ef757e65c2ca97914e54656fff0f" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. In particular, privileges granted via such a command will appear to have been granted by the object owner. (For role membership, the membership appears to have been granted by the containing role itself.)</source>
          <target state="translated">수퍼 유저가 &lt;code&gt;GRANT&lt;/code&gt; 또는 &lt;code&gt;REVOKE&lt;/code&gt; 명령을 실행 하도록 선택한 경우 영향을받는 개체의 소유자가 명령을 실행 한 것처럼 명령이 수행됩니다. 특히, 이러한 명령을 통해 부여 된 권한은 개체 소유자가 부여한 것으로 나타납니다. (역할 멤버쉽의 경우 포함 역할 자체에서 멤버쉽을 부여한 것으로 보입니다.)</target>
        </trans-unit>
        <trans-unit id="bdba0ac2d184c2c84f2cf4f8d54b0cd35c6bae22" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. Since all privileges ultimately come from the object owner (possibly indirectly via chains of grant options), it is possible for a superuser to revoke all privileges, but this might require use of &lt;code&gt;CASCADE&lt;/code&gt; as stated above.</source>
          <target state="translated">수퍼 유저가 &lt;code&gt;GRANT&lt;/code&gt; 또는 &lt;code&gt;REVOKE&lt;/code&gt; 명령을 실행 하도록 선택한 경우 영향을받는 개체의 소유자가 명령을 실행 한 것처럼 명령이 수행됩니다. 모든 권한은 궁극적으로 개체 소유자 (권한 부여 옵션 체인을 통해 간접적으로)에서 가져 오기 때문에 수퍼 유저는 모든 권한을 취소 할 수 있지만 위에서 설명한대로 &lt;code&gt;CASCADE&lt;/code&gt; 를 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3105c963db998b17d895e80efc90a4f3ec29f6b5" translate="yes" xml:space="preserve">
          <source>If a table constraint (including foreign keys, but not constraint triggers), list of the constrained columns</source>
          <target state="translated">테이블 제약 조건 (외래 키는 포함하지만 제약 조건 트리거는 포함되지 않음) 인 경우 제약 된 열 목록</target>
        </trans-unit>
        <trans-unit id="d9d8db43e6826c95f740877ac4ab55e53bc6727a" translate="yes" xml:space="preserve">
          <source>If a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, a &lt;code&gt;CHECK&lt;/code&gt; constraint cannot be renamed in the parent without also renaming it in all descendants, so that &lt;code&gt;CHECK&lt;/code&gt; constraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases, &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; will be rejected.</source>
          <target state="translated">테이블에 하위 테이블이있는 경우 하위 테이블과 동일하게 수행하지 않고 상위 테이블의 열 유형을 추가, 이름 변경 또는 변경할 수 없습니다. 따라서 하위 항목에는 항상 상위 항목과 일치하는 열이 있습니다. 마찬가지로 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 모든 하위 항목에서 이름을 바꾸지 않고 부모에서 이름을 바꿀 수 없으므로 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건도 부모와 그 하위 항목 사이에서 일치합니다. (그러한 제한은 인덱스 기반 제한 조건에는 적용되지 않습니다.) 또한 상위 항목에서 선택하면 해당 하위 항목도 선택되므로 해당 하위 항목에도 유효한 것으로 표시되지 않으면 상위 제한 조건이 유효로 표시 될 수 없습니다. 이 경우 &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; 만 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="f72f4b4a7dd1cbe9511c2732830698755442a3ed" translate="yes" xml:space="preserve">
          <source>If a table has been grouped using &lt;code&gt;GROUP BY&lt;/code&gt;, but only certain groups are of interest, the &lt;code&gt;HAVING&lt;/code&gt; clause can be used, much like a &lt;code&gt;WHERE&lt;/code&gt; clause, to eliminate groups from the result. The syntax is:</source>
          <target state="translated">테이블이 &lt;code&gt;GROUP BY&lt;/code&gt; 를 사용하여 그룹화 되었지만 특정 그룹 만 관심이 있는 경우 &lt;code&gt;WHERE&lt;/code&gt; 절 과 유사하게 &lt;code&gt;HAVING&lt;/code&gt; 절을 사용 하여 결과에서 그룹을 제거 할 수 있습니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd8b65709a6edce92f223fae042df5baecd19362" translate="yes" xml:space="preserve">
          <source>If a tablespace is relocated in this way, the symbolic links inside the main data directory are updated to point to the new location. So the new data directory is ready to be used for a new server instance with all tablespaces in the updated locations.</source>
          <target state="translated">이러한 방식으로 테이블 스페이스를 재배치하면 기본 데이터 디렉토리 내의 기호 링크가 새 위치를 가리 키도록 업데이트됩니다. 따라서 새 데이터 디렉토리는 업데이트 된 위치에 모든 테이블 스페이스가있는 새 서버 인스턴스에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58895429ed60b7ffce3462e3dfc985d5ce11688f" translate="yes" xml:space="preserve">
          <source>If a transaction of this sort is going to change the data in the table, then it should use &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock mode instead of &lt;code&gt;SHARE&lt;/code&gt; mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire &lt;code&gt;SHARE&lt;/code&gt; mode, and then be unable to also acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode to actually perform their updates. (Note that a transaction's own locks never conflict, so a transaction can acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode when it holds &lt;code&gt;SHARE&lt;/code&gt; mode &amp;mdash; but not if anyone else holds &lt;code&gt;SHARE&lt;/code&gt; mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first.</source>
          <target state="translated">이런 종류의 트랜잭션이 테이블의 데이터를 변경하려고 할 경우, 다음 사용해야 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 의 잠금 모드 대신에 &lt;code&gt;SHARE&lt;/code&gt; 의 모드. 이를 통해이 유형의 트랜잭션은 한 번에 하나만 실행됩니다. 이를 사용하지 않으면 교착 상태가 발생할 수 있습니다. 두 트랜잭션 모두 &lt;code&gt;SHARE&lt;/code&gt; 모드를 획득 한 다음 실제로 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 모드를 획득 하여 실제로 업데이트를 수행 할 수 없습니다 . 트랜잭션이 획득 할 수 있도록 (주 트랜잭션의 자신의 잠금 장치는 결코 충돌 것을 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 의 이 보유 할 때 모드를 &lt;code&gt;SHARE&lt;/code&gt; 의 모드 -하지만 다른 사람이 보유하지 않을 경우 &lt;code&gt;SHARE&lt;/code&gt; 를교착 상태를 피하려면 모든 트랜잭션이 동일한 오브젝트에서 동일한 순서로 잠금을 획득하고 단일 오브젝트에 대해 여러 잠금 모드가 관련된 경우 트랜잭션은 항상 가장 제한적인 모드를 먼저 획득해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d7eb85ea844d2ba5b981dae6af94a75b4526c2e" translate="yes" xml:space="preserve">
          <source>If a user does not have the required privilege on the table or columns, then in many cases the query will ultimately receive a permission-denied error, in which case this mechanism is invisible in practice. But if the user is reading from a security-barrier view, then the planner might wish to check the statistics of an underlying table that is otherwise inaccessible to the user. In that case, the operator should be leak-proof or the statistics will not be used. There is no direct feedback about that, except that the plan might be suboptimal. If one suspects that this is the case, one could try running the query as a more privileged user, to see if a different plan results.</source>
          <target state="translated">사용자에게 테이블이나 열에 대한 필요한 권한이없는 경우 대부분의 경우 쿼리에 권한 거부 오류가 발생하며이 경우이 메커니즘은 실제로 보이지 않습니다. 그러나 사용자가 보안 장벽보기에서 읽는 경우 플래너는 사용자가 액세스 할 수없는 기본 테이블의 통계를 확인할 수 있습니다. 이 경우, 작업자는 누출 방지 기능을 갖추어야합니다. 그렇지 않으면 통계가 사용되지 않습니다. 계획이 차선책 일 수 있다는 점을 제외하고는 이에 대한 직접적인 피드백은 없습니다. 이 경우에 해당되는 것으로 의심되면보다 권한있는 사용자로 쿼리를 실행하여 다른 계획의 결과를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dba31a67ed7f0ca43338760f7f94d591211dfb7" translate="yes" xml:space="preserve">
          <source>If a user holds a privilege with grant option and has granted it to other users then the privileges held by those other users are called dependent privileges. If the privilege or the grant option held by the first user is being revoked and dependent privileges exist, those dependent privileges are also revoked if &lt;code&gt;CASCADE&lt;/code&gt; is specified; if it is not, the revoke action will fail. This recursive revocation only affects privileges that were granted through a chain of users that is traceable to the user that is the subject of this &lt;code&gt;REVOKE&lt;/code&gt; command. Thus, the affected users might effectively keep the privilege if it was also granted through other users.</source>
          <target state="translated">사용자가 권한 부여 옵션으로 권한을 보유하고 다른 사용자에게 권한을 부여한 경우 다른 사용자가 보유한 권한을 종속 권한이라고합니다. 첫 번째 사용자가 보유한 특권 또는 권한 부여 옵션이 취소되고 종속 특권이 존재하는 경우 &lt;code&gt;CASCADE&lt;/code&gt; 가 지정된 경우 해당 종속 특권도 취소됩니다 . 그렇지 않으면 취소 작업이 실패합니다. 이 재귀 취소는이 &lt;code&gt;REVOKE&lt;/code&gt; 명령 의 대상인 사용자에게 추적 가능한 사용자 체인을 통해 부여 된 권한에만 영향을줍니다 . 따라서 영향을받는 사용자는 다른 사용자를 통해서도 권한을 부여받은 경우 효과적으로 권한을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5f3c1cab021783ead43914fa444508c73ceec6" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not a generated column. Otherwise, &lt;code&gt;s&lt;/code&gt; = stored. (Other values might be added in the future.)</source>
          <target state="translated">0 바이트 ( &lt;code&gt;''&lt;/code&gt; )이면 생성 된 열이 아닙니다. 그렇지 않으면 &lt;code&gt;s&lt;/code&gt; = 저장됩니다. (나중에 다른 값이 추가 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a7c2f91a2488ff29789b7c51189ebdab420b3b17" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not an identity column. Otherwise, &lt;code&gt;a&lt;/code&gt; = generated always, &lt;code&gt;d&lt;/code&gt; = generated by default.</source>
          <target state="translated">0 바이트 ( &lt;code&gt;''&lt;/code&gt; )이면 식별 열이 아닙니다. 그렇지 않으면 &lt;code&gt;a&lt;/code&gt; = 항상 생성되고 &lt;code&gt;d&lt;/code&gt; = 기본적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ff9b8990736e5c895e3ff32d995dc7be0250f86a" translate="yes" xml:space="preserve">
          <source>If activated, the process writes information about database events into the current &lt;a href=&quot;glossary#GLOSSARY-LOG-FILE&quot;&gt;log file&lt;/a&gt;. When reaching certain time- or volume-dependent criteria, a new log file is created. Also called &lt;em&gt;syslogger&lt;/em&gt;.</source>
          <target state="translated">활성화되면 프로세스는 데이터베이스 이벤트에 대한 정보를 현재 &lt;a href=&quot;glossary#GLOSSARY-LOG-FILE&quot;&gt;로그 파일에 기록합니다&lt;/a&gt; . 특정 시간 또는 볼륨 종속 기준에 도달하면 새 로그 파일이 생성됩니다. 또한라는 &lt;em&gt;syslogger&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5de4b09ad9373970f4d3245c8e5f5878c7360739" translate="yes" xml:space="preserve">
          <source>If all inputs are of the same type, and it is not &lt;code&gt;unknown&lt;/code&gt;, resolve as that type.</source>
          <target state="translated">모든 입력이 동일한 유형이고 &lt;code&gt;unknown&lt;/code&gt; 경우 해당 유형으로 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="2f0d22550a877dd1e7a10ea59bd4e64873db9458" translate="yes" xml:space="preserve">
          <source>If all inputs are of type &lt;code&gt;unknown&lt;/code&gt;, resolve as type &lt;code&gt;text&lt;/code&gt; (the preferred type of the string category). Otherwise, &lt;code&gt;unknown&lt;/code&gt; inputs are ignored for the purposes of the remaining rules.</source>
          <target state="translated">모든 입력이 &lt;code&gt;unknown&lt;/code&gt; 유형 인 경우 유형 &lt;code&gt;text&lt;/code&gt; (문자열 범주의 기본 유형)로 확인하십시오. 그렇지 않으면 나머지 규칙의 목적으로 &lt;code&gt;unknown&lt;/code&gt; 입력이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa6c40971fdf72080d58a6233c79f7c8dce2a255" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ORDER BY&lt;/code&gt; expression is a simple name that matches both an output column name and an input column name, &lt;code&gt;ORDER BY&lt;/code&gt; will interpret it as the output column name. This is the opposite of the choice that &lt;code&gt;GROUP BY&lt;/code&gt; will make in the same situation. This inconsistency is made to be compatible with the SQL standard.</source>
          <target state="translated">는 IF &lt;code&gt;ORDER BY&lt;/code&gt; 식이 출력 열 이름 입력 컬럼 이름이 모두 일치하는 간단한 이름은, &lt;code&gt;ORDER BY&lt;/code&gt; 는 출력 열 이름으로 해석된다. 이것은 같은 상황에서 &lt;code&gt;GROUP BY&lt;/code&gt; 가하는 선택과 반대입니다 . 이 불일치는 SQL 표준과 호환되도록 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="0ad7084c5cdd9f3be36397e8c9220c13ae237d6c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;existing_window_name&lt;/code&gt; is specified it must refer to an earlier entry in the &lt;code&gt;WINDOW&lt;/code&gt; list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own &lt;code&gt;PARTITION BY&lt;/code&gt; clause, and it can specify &lt;code&gt;ORDER BY&lt;/code&gt; only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.</source>
          <target state="translated">는 IF &lt;code&gt;existing_window_name&lt;/code&gt; 이 지정 그것은에서 이전 항목을 참조해야 &lt;code&gt;WINDOW&lt;/code&gt; 목록; 새 창은 해당 항목의 파티션 절과 순서 절 (있는 경우)을 복사합니다. 이 경우 새 창은 자체 &lt;code&gt;PARTITION BY&lt;/code&gt; 절을 지정할 수 없으며 , 복사 된 창에 &lt;code&gt;ORDER BY&lt;/code&gt; 가 없는 경우에만 ORDER BY를 지정할 수 있습니다 . 새 창은 항상 자체 프레임 절을 사용합니다. 복사 된 창은 프레임 절을 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d9f4f0d891ac5ca27debdc2266324be50c274311" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;options&lt;/code&gt; string is specified it must consist of a comma-separated list of one or more &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The available options are:</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 문자열 지정은 하나 이상의 쉼표로 구분 된 목록으로 구성되어야합니다 &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 쌍. 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cd30de9bbf3f8180a703c4e2d6c583071ea1a34" translate="yes" xml:space="preserve">
          <source>If an OID that does not represent an existing object is passed as argument to one of the above functions, NULL is returned.</source>
          <target state="translated">기존 객체를 나타내지 않는 OID가 위 함수 중 하나에 인수로 전달되면 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc31d26a07681f5637a04d968a3f5e70276453d" translate="yes" xml:space="preserve">
          <source>If an aggregate supports moving-aggregate mode, it will improve calculation efficiency when the aggregate is used as a window function for a window with moving frame start (that is, a frame start mode other than &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;). Conceptually, the forward transition function adds input values to the aggregate's state when they enter the window frame from the bottom, and the inverse transition function removes them again when they leave the frame at the top. So, when values are removed, they are always removed in the same order they were added. Whenever the inverse transition function is invoked, it will thus receive the earliest added but not yet removed argument value(s). The inverse transition function can assume that at least one row will remain in the current state after it removes the oldest row. (When this would not be the case, the window function mechanism simply starts a fresh aggregation, rather than using the inverse transition function.)</source>
          <target state="translated">집계가 이동 집계 모드를 지원하는 경우 이동 프레임 시작이있는 창 (즉, &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 이외의 프레임 시작 모드)에 대한 창 함수로 집계를 사용하면 계산 효율성이 향상됩니다.). 개념적으로, 순방향 전환 기능은 입력 값을 아래쪽에서 창 프레임으로 들어갈 때 집계 상태에 추가하고 역 이동 기능은 프레임을 맨 위에 놓을 때 다시 값을 제거합니다. 따라서 값을 제거하면 추가 된 순서대로 항상 제거됩니다. 역 전이 함수가 호출 될 때마다 가장 먼저 추가되었지만 아직 제거되지 않은 인수 값이 수신됩니다. 역 전이 함수는 가장 오래된 행을 제거한 후에도 하나 이상의 행이 현재 상태를 유지한다고 가정 할 수 있습니다. (그렇지 않으면 창 함수 메커니즘은 역 전이 함수를 사용하지 않고 단순히 새로운 집계를 시작합니다.)</target>
        </trans-unit>
        <trans-unit id="3eaeb85716c71ac82a1780ada62bc3bcdfffa64e" translate="yes" xml:space="preserve">
          <source>If an arbitrary value expression is used in the select list, it conceptually adds a new virtual column to the returned table. The value expression is evaluated once for each result row, with the row's values substituted for any column references. But the expressions in the select list do not have to reference any columns in the table expression of the &lt;code&gt;FROM&lt;/code&gt; clause; they can be constant arithmetic expressions, for instance.</source>
          <target state="translated">선택 목록에서 임의의 값 표현식이 사용되면 개념적으로 리턴 된 테이블에 새 가상 컬럼을 추가합니다. 값 표현식은 각 결과 행에 대해 한 번 평가되며 행 값은 열 참조로 대체됩니다. 그러나 선택 목록의 표현식은 &lt;code&gt;FROM&lt;/code&gt; 절의 테이블 표현식에서 열을 참조 할 필요가 없습니다 . 예를 들어 상수 산술 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80b1d5b3ba2fcc79e9cc1eabebb22c4a831065de" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view contains a &lt;code&gt;WHERE&lt;/code&gt; condition, the condition restricts which rows of the base relation are available to be modified by &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements on the view. However, an &lt;code&gt;UPDATE&lt;/code&gt; is allowed to change a row so that it no longer satisfies the &lt;code&gt;WHERE&lt;/code&gt; condition, and thus is no longer visible through the view. Similarly, an &lt;code&gt;INSERT&lt;/code&gt; command can potentially insert base-relation rows that do not satisfy the &lt;code&gt;WHERE&lt;/code&gt; condition and thus are not visible through the view (&lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; may similarly affect an existing row not visible through the view). The &lt;code&gt;CHECK OPTION&lt;/code&gt; may be used to prevent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands from creating such rows that are not visible through the view.</source>
          <target state="translated">자동으로 업데이트 가능한 뷰에 &lt;code&gt;WHERE&lt;/code&gt; 조건이 포함 된 경우 조건 은 뷰의 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 문으로 수정할 수있는 기본 관계의 행을 제한 합니다. 그러나 &lt;code&gt;UPDATE&lt;/code&gt; 는 행을 변경하여 더 이상 &lt;code&gt;WHERE&lt;/code&gt; 조건을 충족 시키지 않으므로 뷰를 통해 더 이상 표시되지 않습니다. 마찬가지로 &lt;code&gt;INSERT&lt;/code&gt; 명령은 &lt;code&gt;WHERE&lt;/code&gt; 조건을 충족하지 않아 뷰를 통해 볼 수 없는 기본 관계 행을 삽입 할 수 있습니다 ( &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; 는 뷰를 통해 볼 수없는 기존 행에 유사하게 영향을 줄 수 있음). &lt;code&gt;CHECK OPTION&lt;/code&gt; 을 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 명령이 뷰를 통해 볼 수없는 행을 작성 하지 못하게하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2404db1fa7170a324c806fd815c2c382fbb3ff70" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">자동으로 업데이트 가능한보기가 &lt;code&gt;security_barrier&lt;/code&gt; 특성으로 표시되는 경우 모든보기의 &lt;code&gt;WHERE&lt;/code&gt; 조건 (및 &lt;code&gt;LEAKPROOF&lt;/code&gt; 로 표시된 연산자를 사용하는 모든 조건 )은 항상보기 사용자가 추가 한 조건보다 먼저 평가됩니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 를 참조 하십시오. 이로 인해 최종적으로 리턴되지 않는 행 (사용자의 &lt;code&gt;WHERE&lt;/code&gt; 조건을 전달하지 않기 때문에 )이 여전히 잠금 상태가 될 수 있습니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 을 사용하여 관계 레벨에 적용되는 조건 (따라서 행을 잠그지 않음)과 그렇지 않은 조건을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="079f47cbc1cbed10c9582aabec32812c70758e86" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">자동으로 업데이트 가능한 뷰가 &lt;code&gt;security_barrier&lt;/code&gt; 속성으로 표시 되면 뷰의 모든 &lt;code&gt;WHERE&lt;/code&gt; 조건 (및 &lt;code&gt;LEAKPROOF&lt;/code&gt; 로 표시된 연산자를 사용하는 모든 조건 )은 항상 뷰 사용자가 추가 한 조건보다 먼저 평가됩니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 를 참조 하십시오. 이로 인해 최종적으로 반환되지 않는 행 (사용자의 &lt;code&gt;WHERE&lt;/code&gt; 조건을 전달하지 않기 때문에 )은 여전히 ​​잠기 게 될 수 있습니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 을 사용하여 관계 수준에서 적용되는 조건 (따라서 행을 잠그지 않음)과 그렇지 않은 조건을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c5594932b933065e06b18f724dcf95bf8608f76" translate="yes" xml:space="preserve">
          <source>If an error in these files is detected at server start, the server will refuse to start. But if an error is detected during a configuration reload, the files are ignored and the old SSL configuration continues to be used. On Windows systems, if an error in these files is detected at backend start, that backend will be unable to establish an SSL connection. In all these cases, the error condition is reported in the server log.</source>
          <target state="translated">서버 시작시 이러한 파일에서 오류가 발견되면 서버 시작을 거부합니다. 그러나 구성을 다시로드하는 동안 오류가 감지되면 파일이 무시되고 이전 SSL 구성이 계속 사용됩니다. Windows 시스템에서이 파일의 오류가 백엔드 시작시 감지되면 해당 백엔드는 SSL 연결을 설정할 수 없습니다. 이 모든 경우에 오류 조건이 서버 로그에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="97b646bc602dad48858332961c1cd79032617933" translate="yes" xml:space="preserve">
          <source>If an error occurs while reading the time zone abbreviation set, no new value is applied and the old set is kept. If the error occurs while starting the database, startup fails.</source>
          <target state="translated">표준 시간대 약어 세트를 읽는 중에 오류가 발생하면 새 값이 적용되지 않고 이전 세트가 유지됩니다. 데이터베이스를 시작하는 동안 오류가 발생하면 시작이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1de87c93627deeafcb3370199aca0fb5ecf8ffbd" translate="yes" xml:space="preserve">
          <source>If an error occurs while restoring the database schema, &lt;code&gt;pg_upgrade&lt;/code&gt; will exit and you will have to revert to the old cluster as outlined in &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;Step 16&lt;/a&gt; below. To try &lt;code&gt;pg_upgrade&lt;/code&gt; again, you will need to modify the old cluster so the pg_upgrade schema restore succeeds. If the problem is a &lt;code&gt;contrib&lt;/code&gt; module, you might need to uninstall the &lt;code&gt;contrib&lt;/code&gt; module from the old cluster and install it in the new cluster after the upgrade, assuming the module is not being used to store user data.</source>
          <target state="translated">데이터베이스 스키마를 복원하는 동안 오류가 발생하면 &lt;code&gt;pg_upgrade&lt;/code&gt; 가 종료되고 아래 &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;16 단계에&lt;/a&gt; 설명 된대로 이전 클러스터로 되돌려 야 합니다. &lt;code&gt;pg_upgrade&lt;/code&gt; 를 다시 시도하려면 pg_upgrade 스키마 복원이 성공하도록 이전 클러스터를 수정해야합니다. 문제가 &lt;code&gt;contrib&lt;/code&gt; 모듈 인 경우, 모듈을 사용하여 사용자 데이터를 저장하지 않는다고 가정하면 업그레이드 후 기존 클러스터에서 &lt;code&gt;contrib&lt;/code&gt; 모듈 을 설치 제거 하고 새 클러스터에 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f87c733146ee0c8066dc39794ef31c58e51824d2" translate="yes" xml:space="preserve">
          <source>If an exclusion constraint, list of the per-column exclusion operators</source>
          <target state="translated">제외 제약 조건 인 경우 열별 제외 연산자 목록</target>
        </trans-unit>
        <trans-unit id="5e3f8c180f35468731cc99d8e63857d68ba52649" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of a composite type (row type), then a specific field of the row can be extracted by writing</source>
          <target state="translated">표현식이 복합 유형 (행 유형)의 값을 생성하는 경우, 작성하여 행의 특정 필드를 추출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4ecdcd8e3d88016c98e66e3a3a5e3c60d566e607" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of an array type, then a specific element of the array value can be extracted by writing</source>
          <target state="translated">식이 배열 유형의 값을 생성하면 다음을 작성하여 배열 값의 특정 요소를 추출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6de9a52dce84b15b69f729bccf651727ae858f41" translate="yes" xml:space="preserve">
          <source>If an index build fails with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option, this index is left as &amp;ldquo;invalid&amp;rdquo;. Such indexes are useless but it can be convenient to use &lt;code&gt;REINDEX&lt;/code&gt; to rebuild them. Note that only &lt;code&gt;REINDEX INDEX&lt;/code&gt; is able to perform a concurrent build on an invalid index.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션으로 인덱스 빌드에 실패하면 이 인덱스는 &quot;유효하지 않은&quot;상태로 남습니다. 이러한 인덱스는 쓸모가 없지만 &lt;code&gt;REINDEX&lt;/code&gt; 를 사용 하여 다시 작성하는 것이 편리 할 수 ​​있습니다 . &lt;code&gt;REINDEX INDEX&lt;/code&gt; 만 유효하지 않은 인덱스에서 동시 빌드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3fe0fb957d2052bc5b183b29d4175b03f7dd244" translate="yes" xml:space="preserve">
          <source>If an input file name is just &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;ecpg&lt;/code&gt; reads the program from standard input (and writes to standard output, unless that is overridden with &lt;code&gt;-o&lt;/code&gt;).</source>
          <target state="translated">입력 파일 이름이있는 경우 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;ecpg&lt;/code&gt; (즉,이로 대체되지 않는 한, 표준 출력에 기록 표준 입력에서 프로그램을 읽어 &lt;code&gt;-o&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ce1cc9d13f2dd4c882f2d9159dd6b972278963b" translate="yes" xml:space="preserve">
          <source>If an option is specified that is valid, but not relevant to the selected operating mode, pg_ctl ignores it.</source>
          <target state="translated">유효하지만 선택된 작동 모드와 관련이없는 옵션이 지정되면 pg_ctl은 해당 옵션을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="848fca9ee8526b8eb2fb6fd4b08b921862d216f2" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt; below. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">인용되지 않은 경우 콜론 ( &lt;code&gt;:&lt;/code&gt; )을 psql의 변수 이름 다음 인수 내에서 나타나는 바와 같이,이 변수의 값에 의해 대체된다 &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL 보간&lt;/a&gt; 이하. 여기에 설명 된 &lt;code&gt;:'variable_name'&lt;/code&gt; 및 &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; 형식 도 작동합니다. &lt;code&gt;:{?variable_name}&lt;/code&gt; 구문은 변수가 정의되어 있는지 여부를 테스트 허용한다. TRUE 또는 FALSE로 대체됩니다. 백 슬래시로 콜론을 이스케이프하면 대체로부터 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="af23873c246a8a5e4a8cad331942f631fec99b40" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt;. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">(가 인용되지 않은 경우 대장 &lt;code&gt;:&lt;/code&gt; )는 psql의 변수 이름 다음 인수 내에서 나타나는 바와 같이,이 변수의 값에 의해 대체된다 &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL 보간&lt;/a&gt; . 폼 &lt;code&gt;:'variable_name'&lt;/code&gt; 와 &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; 뿐만 아니라이 작품을 설명했다. &lt;code&gt;:{?variable_name}&lt;/code&gt; 구문은 변수가 정의되어 있는지 여부를 테스트 허용한다. TRUE 또는 FALSE로 대체됩니다. 백 슬래시로 콜론을 이스케이프하면 대체되지 않도록 보호합니다.</target>
        </trans-unit>
        <trans-unit id="e21ea67d0d720310272c7536aaef9fbd409c780b" translate="yes" xml:space="preserve">
          <source>If an upstream standby server is promoted to become new master, downstream servers will continue to stream from the new master if &lt;code&gt;recovery_target_timeline&lt;/code&gt; is set to &lt;code&gt;'latest'&lt;/code&gt; (the default).</source>
          <target state="translated">업스트림 대기 서버가 새 마스터로 승격 된 경우 &lt;code&gt;recovery_target_timeline&lt;/code&gt; 이 &lt;code&gt;'latest'&lt;/code&gt; (기본값)로 설정된 경우 다운 스트림 서버는 새 마스터에서 계속 스트리밍됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bd7c108b9d4e211b151f51193b945c5454b1371" translate="yes" xml:space="preserve">
          <source>If any dimension is written as a slice, i.e., contains a colon, then all dimensions are treated as slices. Any dimension that has only a single number (no colon) is treated as being from 1 to the number specified. For example, &lt;code&gt;[2]&lt;/code&gt; is treated as &lt;code&gt;[1:2]&lt;/code&gt;, as in this example:</source>
          <target state="translated">차원이 슬라이스로 기록 된 경우, 즉 콜론을 포함하면 모든 차원이 슬라이스로 처리됩니다. 단일 숫자 (콜론 없음) 만있는 차원은 1에서 지정된 숫자까지 처리됩니다. 예를 들어,이 예에서와 같이 &lt;code&gt;[2]&lt;/code&gt; 는 &lt;code&gt;[1:2]&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="644d831a9e7d5bb7b9cf967c049a8eb98186cce0" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-function resolution.</source>
          <target state="translated">입력 인수가 도메인 유형 인 경우 모든 후속 단계에서 도메인의 기본 유형으로 간주하십시오. 이렇게하면 모호한 기능 해결을 위해 도메인이 기본 유형처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aa9d9b8570b39bd99c0391cf769b6b9a97f8cfdc" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-operator resolution.</source>
          <target state="translated">입력 인수가 도메인 유형 인 경우 모든 후속 단계에서 도메인의 기본 유형으로 간주하십시오. 이를 통해 도메인은 모호한 운영자 해결을 위해 기본 유형처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f08ac7bfcc7896ec3ccba829e9cc32f16385e939" translate="yes" xml:space="preserve">
          <source>If any input arguments are &lt;code&gt;unknown&lt;/code&gt;, check the type categories accepted at those argument positions by the remaining candidates. At each position, select the &lt;code&gt;string&lt;/code&gt; category if any candidate accepts that category. (This bias towards string is appropriate since an unknown-type literal looks like a string.) Otherwise, if all the remaining candidates accept the same type category, select that category; otherwise fail because the correct choice cannot be deduced without more clues. Now discard candidates that do not accept the selected type category. Furthermore, if any candidate accepts a preferred type in that category, discard candidates that accept non-preferred types for that argument. Keep all candidates if none survive these tests. If only one candidate remains, use it; else continue to the next step.</source>
          <target state="translated">입력 인수를 &lt;code&gt;unknown&lt;/code&gt; 경우 나머지 후보가 해당 인수 위치에서 허용되는 유형 카테고리를 확인하십시오. 각 위치에서 &lt;code&gt;string&lt;/code&gt; 선택하십시오후보자가 해당 범주를 승인하면 범주. (알 수없는 유형의 리터럴이 문자열처럼 보이기 때문에 문자열에 대한이 편향이 적절합니다.) 그렇지 않은 경우 나머지 후보가 모두 동일한 유형 범주를 허용하면 해당 범주를 선택하십시오. 그렇지 않으면 더 많은 단서없이 올바른 선택을 추론 할 수 없으므로 실패합니다. 이제 선택한 유형 카테고리를 허용하지 않는 후보를 삭제하십시오. 또한, 후보가 해당 범주에서 선호되는 유형을 허용하는 경우 해당 인수에 대해 선호되지 않는 유형을 허용하는 후보를 삭제하십시오. 이 시험에서 생존하지 못하면 모든 응시자를 유지하십시오. 후보자가 하나만 남아 있으면 사용하십시오. 그렇지 않으면 다음 단계로 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="88a4eb3b7b2c17b935f14a3d49969dbb3c987944" translate="yes" xml:space="preserve">
          <source>If any input expression has an explicit collation derivation, then all explicitly derived collations among the input expressions must be the same, otherwise an error is raised. If any explicitly derived collation is present, that is the result of the collation combination.</source>
          <target state="translated">입력 표현식에 명시 적 데이터 정렬 파생이있는 경우 입력 표현식에서 명시 적으로 파생 된 모든 데이터 정렬이 동일해야합니다. 그렇지 않으면 오류가 발생합니다. 명시 적으로 파생 된 데이터 정렬이 있으면 데이터 정렬 조합의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="848b268c3aef8e0ec228a9fd161ed5d209cdafec" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">입력이 도메인 유형 인 경우 모든 후속 단계에서 해당 입력을 도메인의 기본 유형으로 취급합니다. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5b589b0a29736a2c76abe777e082206c27d9542" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">입력이 도메인 유형 인 경우 모든 후속 단계에서 입력을 도메인의 기본 유형으로 취급하십시오. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062ef5413f1971acdecb4ea39fded859da884ac5" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;GROUPING SETS&lt;/code&gt;, &lt;code&gt;ROLLUP&lt;/code&gt; or &lt;code&gt;CUBE&lt;/code&gt; are present as grouping elements, then the &lt;code&gt;GROUP BY&lt;/code&gt; clause as a whole defines some number of independent &lt;code&gt;grouping sets&lt;/code&gt;. The effect of this is equivalent to constructing a &lt;code&gt;UNION ALL&lt;/code&gt; between subqueries with the individual grouping sets as their &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For further details on the handling of grouping sets see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;.</source>
          <target state="translated">의 경우 &lt;code&gt;GROUPING SETS&lt;/code&gt; , &lt;code&gt;ROLLUP&lt;/code&gt; 이나 &lt;code&gt;CUBE&lt;/code&gt; 는 요소, 다음 그룹화로 존재 &lt;code&gt;GROUP BY&lt;/code&gt; 전체를 정의로 절 독립적 인 몇 개의 &lt;code&gt;grouping sets&lt;/code&gt; . 이 결과는 개별 그룹화 세트를 &lt;code&gt;GROUP BY&lt;/code&gt; 절로 사용하여 서브 쿼리간에 &lt;code&gt;UNION ALL&lt;/code&gt; 을 구성하는 것과 같습니다 . 그룹화 세트 처리에 대한 자세한 내용은 다음을 참조하십시오.&lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt; 섹션 7.2.4를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee7daf9476f8c0077c19fa91e9fc5b6d1dd5a0b5" translate="yes" xml:space="preserve">
          <source>If any of the child tables are foreign tables whose foreign data wrappers do not support &lt;code&gt;ANALYZE&lt;/code&gt;, those child tables are ignored while gathering inheritance statistics.</source>
          <target state="translated">하위 테이블 중 하나가 외부 데이터 랩퍼가 지원하지 않는 외부 테이블 인 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 를 상속 통계를 수집하는 동안 해당 하위 테이블이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5559a39fd47d326a14a46d78afa053af9afa62f6" translate="yes" xml:space="preserve">
          <source>If any of the columns of a table are TOAST-able, the table will have an associated TOAST table, whose OID is stored in the table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; entry. On-disk TOASTed values are kept in the TOAST table, as described in more detail below.</source>
          <target state="translated">테이블의 컬럼 중 하나가 TOAST 가능하면 테이블에 연관된 TOAST 테이블이 있으며 해당 테이블의 OID는 테이블의 &lt;code&gt;pg_class&lt;/code&gt; 에 저장됩니다 . &lt;code&gt;reltoastrelid&lt;/code&gt; 항목. 온 디스크 TOAST 값은 아래에 자세히 설명 된대로 TOAST 테이블에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="cf49cd2bc67ee3c3481f1ffe2933861356e2738f" translate="yes" xml:space="preserve">
          <source>If any of the tables referenced by the view are temporary, the view is created as a temporary view (whether &lt;code&gt;TEMPORARY&lt;/code&gt; is specified or not).</source>
          <target state="translated">뷰가 참조하는 테이블 중 하나라도 임시 테이블 인 경우 뷰는 임시 뷰로 작성됩니다 ( &lt;code&gt;TEMPORARY&lt;/code&gt; 의 지정 여부 ).</target>
        </trans-unit>
        <trans-unit id="e74c2195dcb53833cfc91730aac90c474163ed9c" translate="yes" xml:space="preserve">
          <source>If any post-upgrade processing is required, pg_upgrade will issue warnings as it completes. It will also generate script files that must be run by the administrator. The script files will connect to each database that needs post-upgrade processing. Each script should be run using:</source>
          <target state="translated">업그레이드 후 처리가 필요한 경우 pg_upgrade는 완료 될 때 경고를 발행합니다. 또한 관리자가 실행해야하는 스크립트 파일을 생성합니다. 스크립트 파일은 업그레이드 후 처리가 필요한 각 데이터베이스에 연결됩니다. 각 스크립트는 다음을 사용하여 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="800a2d135577a55dc7316ea712cf7f6d1165ae24" translate="yes" xml:space="preserve">
          <source>If archive storage size is a concern, you can use gzip to compress the archive files:</source>
          <target state="translated">아카이브 스토리지 크기가 중요한 경우 gzip을 사용하여 아카이브 파일을 압축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e48896c1f0ace93b93a8656d8514a4835072596" translate="yes" xml:space="preserve">
          <source>If at all possible, &lt;em&gt;do not&lt;/em&gt; use &lt;code&gt;SIGKILL&lt;/code&gt; to kill the main &lt;code&gt;postgres&lt;/code&gt; server. Doing so will prevent &lt;code&gt;postgres&lt;/code&gt; from freeing the system resources (e.g., shared memory and semaphores) that it holds before terminating. This might cause problems for starting a fresh &lt;code&gt;postgres&lt;/code&gt; run.</source>
          <target state="translated">가능 하면 &lt;code&gt;SIGKILL&lt;/code&gt; 을 사용 하여 기본 &lt;code&gt;postgres&lt;/code&gt; 서버를 종료 &lt;em&gt;하지 마십시오&lt;/em&gt; . 그렇게하면 &lt;code&gt;postgres&lt;/code&gt; 가 종료하기 전에 보유하고있는 시스템 리소스 (예 : 공유 메모리 및 세마포어)를 해제 하지 못하게 됩니다. 이것은 새로운 &lt;code&gt;postgres&lt;/code&gt; 시작에 문제를 일으킬 수 있습니다 실행 .</target>
        </trans-unit>
        <trans-unit id="ed12d9d5c43a1c95cedd4f159ed6ce3a1940c1ed" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; appear, then &lt;code&gt;OFFSET&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;LIMIT&lt;/code&gt; rows that are returned.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; 및 &lt;code&gt;LIMIT&lt;/code&gt; 가 모두 나타나면 반환 된 &lt;code&gt;LIMIT&lt;/code&gt; 행 수를 계산하기 전에 &lt;code&gt;OFFSET&lt;/code&gt; 행을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="d1beaf85265bd8e8de4c00a803a4295f898d6a9d" translate="yes" xml:space="preserve">
          <source>If both standard input and standard output are a terminal, then psql sets the client encoding to &amp;ldquo;auto&amp;rdquo;, which will detect the appropriate client encoding from the locale settings (&lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable on Unix systems). If this doesn't work out as expected, the client encoding can be overridden using the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;.</source>
          <target state="translated">표준 입력과 표준 출력이 모두 터미널 인 경우 psql은 클라이언트 인코딩을 &quot;auto&quot;로 설정하여 로케일 설정 ( 유닉스 시스템의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 환경 변수) 에서 적절한 클라이언트 인코딩을 감지합니다 . 예상대로 작동하지 않으면 환경 변수 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; 을 사용하여 클라이언트 인코딩을 재정의 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="124d332dfa6ef76e2334514ac990a431fc574564" translate="yes" xml:space="preserve">
          <source>If cascaded replication is in use the feedback is passed upstream until it eventually reaches the primary. Standbys make no other use of feedback they receive other than to pass upstream.</source>
          <target state="translated">계단식 복제를 사용중인 경우 피드백이 결국 기본에 도달 할 때까지 업스트림으로 전달됩니다. 대기는 업스트림을 통과하는 것 이외의 다른 피드백을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21ad797b1873a315d3fc0d5c790db4d1476ce970" translate="yes" xml:space="preserve">
          <source>If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, e.g., &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt;. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, e.g., &lt;code&gt;[x]&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt; and &lt;code&gt;[^x]&lt;/code&gt; becomes &lt;code&gt;[^xX]&lt;/code&gt;.</source>
          <target state="translated">대 / 소문자를 구분하지 않는 일치를 지정하면 모든 대 / 소문자 구분이 알파벳에서 사라진 것처럼 효과가 나타납니다. 여러 경우에 존재하는 알파벳이 대괄호 표현식 외부의 일반 문자로 표시되면 두 경우를 모두 포함하는 대괄호 표현식으로 효과적으로 변환됩니다. 예를 들어 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;[xX]&lt;/code&gt; 가 됩니다. 대괄호 표현식 안에 나타나면 모든 대소 문자가 대괄호 표현식에 추가됩니다. 예를 들어 &lt;code&gt;[x]&lt;/code&gt; 는 &lt;code&gt;[xX]&lt;/code&gt; 가 되고 &lt;code&gt;[^x]&lt;/code&gt; 는 &lt;code&gt;[^xX]&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf258208ab5152d2c12b1e28ed793831fd7c461c" translate="yes" xml:space="preserve">
          <source>If column aliases are not supplied, then for a function returning a base data type, the column name is also the same as the function name. For a function returning a composite type, the result columns get the names of the individual attributes of the type.</source>
          <target state="translated">열 별명이 제공되지 않으면 기본 데이터 유형을 리턴하는 함수의 경우 열 이름도 함수 이름과 동일합니다. 복합 유형을 리턴하는 함수의 경우 결과 열은 유형의 개별 속성 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6deaaf1ae6fdc8847b55dec525d8c4461d71750b" translate="yes" xml:space="preserve">
          <source>If consistent response time is more important than update speed, use of pending entries can be disabled by turning off the &lt;code&gt;fastupdate&lt;/code&gt; storage parameter for a GIN index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details.</source>
          <target state="translated">일관된 응답 시간이 업데이트 속도보다 중요한 경우 GIN 인덱스에 대한 &lt;code&gt;fastupdate&lt;/code&gt; 스토리지 매개 변수를 해제하여 보류중인 항목 사용을 비활성화 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="41ef4d0c1740eb702f05dcbd27c8d877f11fcd3a" translate="yes" xml:space="preserve">
          <source>If csvlog is included in &lt;code&gt;log_destination&lt;/code&gt;, log entries are output in &amp;ldquo;comma separated value&amp;rdquo; (CSV) format, which is convenient for loading logs into programs. See &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;Section 19.8.4&lt;/a&gt; for details. &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; must be enabled to generate CSV-format log output.</source>
          <target state="translated">csvlog가 &lt;code&gt;log_destination&lt;/code&gt; 에 포함 된 경우 로그 항목은&amp;ldquo;쉼표로 구분 된 값&amp;rdquo;(CSV) 형식으로 출력되므로 프로그램에 로그를로드하는 데 편리합니다. 자세한 내용 &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;은 19.8.4 절&lt;/a&gt; 을 참조하십시오. CSV 형식의 로그 출력을 생성하려면 &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; 를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed1042acfa5d378be31e2b80e8d7ffc7bef64f8e" translate="yes" xml:space="preserve">
          <source>If data checksums are enabled, hint bit updates are always WAL-logged and this setting is ignored. You can use this setting to test how much extra WAL-logging would occur if your database had data checksums enabled.</source>
          <target state="translated">데이터 체크섬이 활성화 된 경우 힌트 비트 업데이트는 항상 WAL로 기록되며이 설정은 무시됩니다. 데이터베이스에 데이터 체크섬이 활성화 된 경우이 설정을 사용하여 추가 WAL 로깅이 얼마나 발생하는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9574b9b4b7b428cee25c96a3966fa8df72a24cd9" translate="yes" xml:space="preserve">
          <source>If different date/time types need to be compared, an implicit cast is applied. A &lt;code&gt;date&lt;/code&gt; value can be cast to &lt;code&gt;timestamp&lt;/code&gt; or &lt;code&gt;timestamptz&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt; can be cast to &lt;code&gt;timestamptz&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt; to &lt;code&gt;timetz&lt;/code&gt;. However, all but the first of these conversions depend on the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, and thus can only be performed within timezone-aware &lt;code&gt;jsonpath&lt;/code&gt; functions.</source>
          <target state="translated">다른 날짜 / 시간 유형을 비교해야하는 경우 암시 적 캐스트가 적용됩니다. &lt;code&gt;date&lt;/code&gt; 값으로 캐스팅 할 수 있습니다 &lt;code&gt;timestamp&lt;/code&gt; 또는 &lt;code&gt;timestamptz&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt; 에 캐스트 할 수 &lt;code&gt;timestamptz&lt;/code&gt; 및 &lt;code&gt;time&lt;/code&gt; 에 &lt;code&gt;timetz&lt;/code&gt; . 그러나 이러한 변환 중 첫 번째를 제외한 모든 변환은 현재 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 설정 에 따라 달라 지므로 시간대 인식 &lt;code&gt;jsonpath&lt;/code&gt; 함수 내에서만 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf0a4beca9338b9c149bc626eda6f48fc9e5c025" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;toptag&lt;/code&gt; or &lt;code&gt;itemtag&lt;/code&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">어느 경우 &lt;code&gt;toptag&lt;/code&gt; 또는 &lt;code&gt;itemtag&lt;/code&gt; 가 빈 문자열, 관련 태그를 생략한다.</target>
        </trans-unit>
        <trans-unit id="03df124a73c895463360e1ed34f1a74da7815fc6" translate="yes" xml:space="preserve">
          <source>If either &lt;em&gt;&lt;code&gt;toptag&lt;/code&gt;&lt;/em&gt; or &lt;em&gt;&lt;code&gt;itemtag&lt;/code&gt;&lt;/em&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">어느 경우 &lt;em&gt; &lt;code&gt;toptag&lt;/code&gt; &lt;/em&gt; 또는 &lt;em&gt; &lt;code&gt;itemtag&lt;/code&gt; 가&lt;/em&gt; 빈 문자열, 관련 태그를 생략한다.</target>
        </trans-unit>
        <trans-unit id="b92d15119505820507c6255b9360f73a82ee471e" translate="yes" xml:space="preserve">
          <source>If executed during recovery, the &lt;code&gt;CHECKPOINT&lt;/code&gt; command will force a restartpoint (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;) rather than writing a new checkpoint.</source>
          <target state="translated">복구 중에 실행되면 &lt;code&gt;CHECKPOINT&lt;/code&gt; 명령은 새 검사 점을 작성하지 않고 다시 시작점 ( &lt;a href=&quot;wal-configuration&quot;&gt;29.4&lt;/a&gt; 참조)을 강제 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="61ea49c86b3b55d886450b38a9cc42e4e9c69fce" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database.</source>
          <target state="translated">False이면 아무도이 데이터베이스에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="67f61dc72a1244f231103433b1246606e94298b4" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. The default is true, allowing connections (except as restricted by other mechanisms, such as &lt;code&gt;GRANT&lt;/code&gt;/&lt;code&gt;REVOKE CONNECT&lt;/code&gt;).</source>
          <target state="translated">False이면 아무도이 데이터베이스에 연결할 수 없습니다. 기본값은 true이며 연결을 허용합니다 ( &lt;code&gt;GRANT&lt;/code&gt; / &lt;code&gt;REVOKE CONNECT&lt;/code&gt; 와 같은 다른 메커니즘에 의해 제한되는 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="068609549b5f3904794ff7927c8befaac0ac4357" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. This is used to protect the &lt;code&gt;template0&lt;/code&gt; database from being altered.</source>
          <target state="translated">False이면 아무도이 데이터베이스에 연결할 수 없습니다. &lt;code&gt;template0&lt;/code&gt; 데이터베이스가 변경되지 않도록 보호하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5279e693a4509d44588c8398060bdbb7e4662f3c" translate="yes" xml:space="preserve">
          <source>If false, the index is in process of being dropped, and should be ignored for all purposes (including HOT-safety decisions)</source>
          <target state="translated">False 인 경우 인덱스가 삭제되는 중이므로 모든 용도 (HOT 안전 결정 포함)에서 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="024b18cb2d326ba0157f9b09e5a42b7967d00fb4" translate="yes" xml:space="preserve">
          <source>If fewer column aliases are specified than the actual table has columns, the remaining columns are not renamed. This syntax is especially useful for self-joins or subqueries.</source>
          <target state="translated">실제 테이블에 컬럼이있는 것보다 적은 컬럼 별명이 지정되면 나머지 컬럼의 이름이 변경되지 않습니다. 이 구문은 자체 조인 또는 하위 쿼리에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7788a3fcadf6ada52028229d6f513ec9b5a33011" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach eleven million transactions from the wraparound point:</source>
          <target state="translated">어떤 이유로 autovacuum이 테이블에서 이전 XID를 지우지 못하면 데이터베이스의 가장 오래된 XID가 랩 어라운드 지점에서 1,100 만 트랜잭션에 도달하면 시스템은 다음과 같은 경고 메시지를 표시하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="8ab96b15ba19344208a4881ae65df7268a6bcc7d" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach ten million transactions from the wraparound point:</source>
          <target state="translated">어떤 이유로 autovacuum이 테이블에서 오래된 XID를 지우지 못하는 경우 데이터베이스의 가장 오래된 XID가 랩 어라운드 지점에서 천만 건의 트랜잭션에 도달하면 시스템은 다음과 같은 경고 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="80fa6f646b83284df410a911e1de501df6e5b069" translate="yes" xml:space="preserve">
          <source>If forcing index usage does use the index, then there are two possibilities: Either the system is right and using the index is indeed not appropriate, or the cost estimates of the query plans are not reflecting reality. So you should time your query with and without indexes. The &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; command can be useful here.</source>
          <target state="translated">강제 색인 사용이 색인을 사용하는 경우 두 가지 가능성이 있습니다. 시스템이 올 바르고 색인을 사용하는 것이 실제로 적절하지 않거나 쿼리 계획의 비용 추정이 현실을 반영하지 않습니다. 따라서 인덱스를 사용하거나 사용하지 않고 쿼리 시간을 정해야합니다. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 명령은 여기에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="360561360313d63c949a4bb8b50e6444752b1851" translate="yes" xml:space="preserve">
          <source>If four or six digits and a year has already been read, then interpret as a time (&lt;code&gt;HHMM&lt;/code&gt; or &lt;code&gt;HHMMSS&lt;/code&gt;).</source>
          <target state="translated">4 자리 또는 6 자리와 1 년을 이미 읽은 경우 시간 ( &lt;code&gt;HHMM&lt;/code&gt; 또는 &lt;code&gt;HHMMSS&lt;/code&gt; )으로 해석하십시오 .</target>
        </trans-unit>
        <trans-unit id="42c28f0a9935826074d643ae6e75e6be762517ad" translate="yes" xml:space="preserve">
          <source>If given, createuser will issue a prompt for the password of the new user. This is not necessary if you do not plan on using password authentication.</source>
          <target state="translated">주어진 경우, createuser는 새 사용자의 비밀번호를 묻는 프롬프트를 발행합니다. 비밀번호 인증을 사용하지 않으려는 경우에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea4e98adccd9512cd68509c9e2207bdcbb1a1273" translate="yes" xml:space="preserve">
          <source>If greater than zero, each bind parameter value logged with a non-error statement-logging message is trimmed to this many bytes. Zero disables logging of bind parameters for non-error statement logs. &lt;code&gt;-1&lt;/code&gt; (the default) allows bind parameters to be logged in full. If this value is specified without units, it is taken as bytes. Only superusers can change this setting.</source>
          <target state="translated">0보다 크면 오류가 아닌 명령문 로깅 메시지와 함께 로깅 된 각 바인드 매개 변수 값이이 바이트 수로 잘립니다. 0은 오류가 아닌 문 로그에 대한 바인드 매개 변수 로깅을 비활성화합니다. &lt;code&gt;-1&lt;/code&gt; (기본값)을 사용하면 바인드 매개 변수를 전체로 기록 할 수 있습니다. 이 값이 단위없이 지정되면 바이트로 간주됩니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b5cd71938c46f540f5b875d785655ef9301be2" translate="yes" xml:space="preserve">
          <source>If greater than zero, each bind parameter value reported in error messages is trimmed to this many bytes. Zero (the default) disables including bind parameters in error messages. &lt;code&gt;-1&lt;/code&gt; allows bind parameters to be printed in full. If this value is specified without units, it is taken as bytes.</source>
          <target state="translated">0보다 크면 오류 메시지에보고 된 각 바인드 매개 변수 값이이 바이트 수로 잘립니다. 0 (기본값)은 오류 메시지에 바인드 매개 변수를 포함하지 않습니다. &lt;code&gt;-1&lt;/code&gt; 을 사용하면 바인드 매개 변수를 전체적으로 인쇄 할 수 있습니다. 이 값이 단위없이 지정되면 바이트로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="95adc82bd644fa7ad31393ac2f57ca7d35f902fd" translate="yes" xml:space="preserve">
          <source>If greater than zero, the estimated number of distinct values in the column. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique column in which the number of distinct values is the same as the number of rows.</source>
          <target state="translated">0보다 크면 열의 예상 고유 값 수입니다. 0보다 작은 경우 고유 값 수의 음수를 행 수로 나눈 값입니다. (거짓된 형식은 &lt;code&gt;ANALYZE&lt;/code&gt; 에서 테이블이 커짐에 따라 고유 한 값의 수가 증가 할 것으로 판단 할 때 사용되며, 양의 형식은 열에 고정 된 수의 가능한 값이있는 경우 사용됩니다.) 예를 들어, -1은 고유 값의 수가 행 수와 동일한 고유 열.</target>
        </trans-unit>
        <trans-unit id="b21def7d275563964950f72033030facdc8caa8d" translate="yes" xml:space="preserve">
          <source>If indexing numbers, we can remove some fractional digits to reduce the range of possible numbers, so for example &lt;em&gt;3.14&lt;/em&gt;159265359, &lt;em&gt;3.14&lt;/em&gt;15926, &lt;em&gt;3.14&lt;/em&gt; will be the same after normalization if only two digits are kept after the decimal point.</source>
          <target state="translated">숫자를 인덱싱하는 경우 가능한 소수 범위를 줄이기 위해 일부 소수 자릿수를 제거 할 수 있으므로 소수점 이하 두 자리 만 유지하면 정규화 후에 &lt;em&gt;3.14&lt;/em&gt; 159265359, &lt;em&gt;3.14&lt;/em&gt; 15926, &lt;em&gt;3.14&lt;/em&gt; 가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="76133018bd86f9f10167401dc275f9ef001f11b2" translate="yes" xml:space="preserve">
          <source>If inverse partial newline-sensitive matching is specified, this affects &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; as with newline-sensitive matching, but not &lt;code&gt;.&lt;/code&gt; and bracket expressions. This isn't very useful but is provided for symmetry.</source>
          <target state="translated">역 부분 줄 바꿈 구분 일치가 지정되면 이는 줄 바꿈 구분 일치와 같이 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 에 영향을 미치지 만 그렇지 않습니다 &lt;code&gt;.&lt;/code&gt; 및 괄호 표현식. 이것은 매우 유용하지는 않지만 대칭을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="dcbd0be8463498dfec58ee2ded857848642b3788" translate="yes" xml:space="preserve">
          <source>If it is necessary to have a comma or whitespace in a RADIUS parameter value, that can be done by putting double quotes around the value, but it is tedious because two layers of double-quoting are now required. An example of putting whitespace into RADIUS secret strings is:</source>
          <target state="translated">RADIUS 매개 변수 값에 쉼표 또는 공백이 필요한 경우 값을 큰 따옴표로 묶어 수행 할 수 있지만 이제는 두 개의 큰 따옴표 레이어가 필요하기 때문에 지루합니다. RADIUS 비밀 문자열에 공백을 넣는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c82c509d031e15398bd7fe00861081d6405c8be4" translate="yes" xml:space="preserve">
          <source>If it turns out that the cost estimates are wrong, there are, again, two possibilities. The total cost is computed from the per-row costs of each plan node times the selectivity estimate of the plan node. The costs estimated for the plan nodes can be adjusted via run-time parameters (described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). An inaccurate selectivity estimate is due to insufficient statistics. It might be possible to improve this by tuning the statistics-gathering parameters (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">비용 추정치가 잘못되었다는 것이 밝혀지면 다시 두 가지 가능성이 있습니다. 총 비용은 각 계획 노드의 행당 비용과 계획 노드의 선택성 추정값을 곱한 값으로 계산됩니다. 계획 노드에 대해 추정 된 비용은 런타임 매개 변수를 통해 조정할 수 있습니다 ( &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;섹션 19.7.2 참조&lt;/a&gt; ). 부정확 한 선택성 추정은 불충분 한 통계로 인해 발생합니다. 통계 수집 매개 변수를 조정하여이를 개선 할 수 있습니다 ( &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="18729ccb1c4146c8bab4ae3596759dabf5573ab7" translate="yes" xml:space="preserve">
          <source>If locale support doesn't work according to the explanation above, check that the locale support in your operating system is correctly configured. To check what locales are installed on your system, you can use the command &lt;code&gt;locale -a&lt;/code&gt; if your operating system provides it.</source>
          <target state="translated">위의 설명에 따라 로케일 지원이 작동하지 않으면 운영 체제의 로케일 지원이 올바르게 구성되어 있는지 확인하십시오. 시스템에 설치된 로케일을 확인하려면 운영 체제가 제공하는 경우 &lt;code&gt;locale -a&lt;/code&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="742c773e01d7235a3ab536311ea18ceb446289e6" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">백업하는 경우 데이터베이스가 업데이트되고 있지 않은지 확인하십시오. 백업의 무결성에는 영향을 미치지 않지만 변경된 데이터는 포함되지 않습니다. 필요한 경우, &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; 파일 (또는 동등한 파일)에서 권한을 편집하여 귀하를 제외한 모든 사람이 액세스 할 수 없도록하십시오. 액세스 제어에 대한 추가 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7635b5eb0e6be90090ac67c5260cad61569c3e50" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">백업하는 경우 데이터베이스가 업데이트되고 있지 않은지 확인하십시오. 이것은 백업의 무결성에 영향을주지 않지만 변경된 데이터는 물론 포함되지 않습니다. 필요한 경우 &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (또는 이와 동등한 파일) 파일의 권한을 편집하여 사용자를 제외한 모든 사람의 액세스를 허용하지 않습니다. 액세스 제어에 대한 추가 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;20 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0a6e1d7bfcacfaf25b4fbb67794def2eb6d19f0" translate="yes" xml:space="preserve">
          <source>If more flexibility in copying the backup files is needed, a lower level process can be used for standalone hot backups as well. To prepare for low level standalone hot backups, make sure &lt;code&gt;wal_level&lt;/code&gt; is set to &lt;code&gt;replica&lt;/code&gt; or higher, &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, and set up an &lt;code&gt;archive_command&lt;/code&gt; that performs archiving only when a &lt;em&gt;switch file&lt;/em&gt; exists. For example:</source>
          <target state="translated">백업 파일을보다 유연하게 복사해야하는 경우 독립형 핫 백업에도 낮은 수준의 프로세스를 사용할 수 있습니다. 저수준 독립형 핫 백업을 준비하려면 &lt;code&gt;wal_level&lt;/code&gt; 을 &lt;code&gt;replica&lt;/code&gt; 이상으로 설정하고 &lt;code&gt;archive_mode&lt;/code&gt; 를 &lt;code&gt;on&lt;/code&gt; 으로 설정 하고 &lt;em&gt;스위치 파일&lt;/em&gt; 이 존재 하는 경우에만 아카이브를 수행 하는 &lt;code&gt;archive_command&lt;/code&gt; 를 설정 &lt;em&gt;하십시오&lt;/em&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b849cfa2234fdad4226b42e149aff052e2ec6ceb" translate="yes" xml:space="preserve">
          <source>If more than one flag bit is specified, the transformations are applied in the order listed.</source>
          <target state="translated">하나 이상의 플래그 비트가 지정되면 변환이 나열된 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8368877f8014c70dc2f0a265b592212cfc0ddc8" translate="yes" xml:space="preserve">
          <source>If more than one leaf tuple is supplied, it is expected that the &lt;code&gt;picksplit&lt;/code&gt; function will classify them into more than one node; otherwise it is not possible to split the leaf tuples across multiple pages, which is the ultimate purpose of this operation. Therefore, if the &lt;code&gt;picksplit&lt;/code&gt; function ends up placing all the leaf tuples in the same node, the core SP-GiST code will override that decision and generate an inner tuple in which the leaf tuples are assigned at random to several identically-labeled nodes. Such a tuple is marked &lt;code&gt;allTheSame&lt;/code&gt; to signify that this has happened. The &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions must take suitable care with such inner tuples. See &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt; for more information.</source>
          <target state="translated">둘 이상의 리프 튜플이 제공되는 경우 &lt;code&gt;picksplit&lt;/code&gt; 함수가이를 두 개 이상의 노드로 분류 할 것으로 예상 됩니다. 그렇지 않으면 리프 튜플을 여러 페이지에 분할 할 수 없으며이 작업의 최종 목적입니다. 따라서 &lt;code&gt;picksplit&lt;/code&gt; 함수가 모든 리프 튜플을 동일한 노드에 배치하면 코어 SP-GiST 코드는 해당 결정을 무시하고 리프 튜플이 동일한 레이블이 지정된 여러 노드에 무작위로 할당되는 내부 튜플을 생성합니다. 이러한 튜플은 &lt;code&gt;allTheSame&lt;/code&gt; 이 표시 되었음을 나타냅니다. 은 &lt;code&gt;choose&lt;/code&gt; 과 &lt;code&gt;inner_consistent&lt;/code&gt; 함수는 내부 튜플에 적절한주의를 기울여야합니다. 자세한 내용 &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;섹션 65.4.3&lt;/a&gt;은 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1854b837fa3254f90682ac28255cbd702178269" translate="yes" xml:space="preserve">
          <source>If more than one option is given, the information is printed in that order, one item per line. If no options are given, all available information is printed, with labels.</source>
          <target state="translated">둘 이상의 옵션이 제공되면 정보는 한 줄에 한 항목 씩 순서대로 인쇄됩니다. 옵션이 제공되지 않으면 사용 가능한 모든 정보가 레이블과 함께 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f1a02345ba89ad66d10fbdabf34539cb6dd7d98c" translate="yes" xml:space="preserve">
          <source>If more than one table has a column of the same name, the table name must also be given, as in:</source>
          <target state="translated">둘 이상의 테이블에 동일한 이름의 열이있는 경우 다음과 같이 테이블 이름도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd5e9dbc9005fdf88d98048279bb5e957015fc29" translate="yes" xml:space="preserve">
          <source>If multiple CPUs are available in the database server, consider using pg_restore's &lt;code&gt;--jobs&lt;/code&gt; option. This allows concurrent data loading and index creation.</source>
          <target state="translated">데이터베이스 서버에서 여러 CPU를 사용할 수있는 경우 pg_restore의 &lt;code&gt;--jobs&lt;/code&gt; 옵션 사용을 고려하십시오 . 이를 통해 동시 데이터로드 및 인덱스 생성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="87fac9519c05562bef87a4e35aa2a859278b1c40" translate="yes" xml:space="preserve">
          <source>If multiple grouping items are specified in a single &lt;code&gt;GROUP BY&lt;/code&gt; clause, then the final list of grouping sets is the cross product of the individual items. For example:</source>
          <target state="translated">단일 &lt;code&gt;GROUP BY&lt;/code&gt; 절 에 여러 그룹화 항목이 지정된 경우 그룹화 세트의 최종 목록은 개별 항목의 교차 곱입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b80b5e3c45aa43e720ac77a6f9a3ef8d195c588d" translate="yes" xml:space="preserve">
          <source>If multiple savepoints have the same name, only the one that was most recently defined is released.</source>
          <target state="translated">여러 저장 점이 동일한 이름을 갖는 경우 가장 최근에 정의 된 저장 점이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb7ddb9b949ac875aa47f26b30ade97f88eab22" translate="yes" xml:space="preserve">
          <source>If multiple script files are specified, the averages are reported separately for each script file.</source>
          <target state="translated">여러 스크립트 파일이 지정된 경우 평균은 각 스크립트 파일에 대해 별도로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="e33be9af0afb6da142699266371977c598700dcd" translate="yes" xml:space="preserve">
          <source>If multiple triggers of the same kind are defined for the same event, they will be fired in alphabetical order by name.</source>
          <target state="translated">동일한 이벤트에 대해 동일한 종류의 트리거가 여러 개 정의되면 이름순으로 알파벳 순서대로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="65a4d92a17b0442c58eb3e977048325cf5830355" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;ALSO&lt;/code&gt; nor &lt;code&gt;INSTEAD&lt;/code&gt; is specified, &lt;code&gt;ALSO&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; 또는 &lt;code&gt;INSTEAD&lt;/code&gt; 가 지정 되지 않은 경우 &lt;code&gt;ALSO&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7e603a3b3a3e88af33582419d67e19ea60ef676f" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR SEARCH&lt;/code&gt; nor &lt;code&gt;FOR ORDER BY&lt;/code&gt; is specified, &lt;code&gt;FOR SEARCH&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;FOR SEARCH&lt;/code&gt; 또는 &lt;code&gt;FOR ORDER BY&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;FOR SEARCH&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5e9aa69e6e2804ffb3ebc122107e995dd5c9a00a" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR TABLE&lt;/code&gt; nor &lt;code&gt;FOR ALL TABLES&lt;/code&gt; is specified, then the publication starts out with an empty set of tables. That is useful if tables are to be added later.</source>
          <target state="translated">&lt;code&gt;FOR TABLE&lt;/code&gt; 또는 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 를 지정 하지 않으면 빈 테이블 집합으로 게시가 시작됩니다. 나중에 테이블을 추가 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89d1b1553626d39b44b8a8db61a149cf8fdc3227" translate="yes" xml:space="preserve">
          <source>If newline-sensitive matching is specified, &lt;code&gt;.&lt;/code&gt; and bracket expressions using &lt;code&gt;^&lt;/code&gt; will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. But the ARE escapes &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; continue to match beginning or end of string &lt;em&gt;only&lt;/em&gt;.</source>
          <target state="translated">개행 구분 일치가 지정되면 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; 를 사용하는 대괄호 표현식 은 개행 문자와 절대 일치하지 않으므로 (RE가 명시 적으로 정렬하지 않으면 일치는 개행을 절대로 교차하지 않습니다) &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 는 개행 전후 각각의 빈 문자열과 일치합니다. 문자열. 그러나 ARE 이스케이프 &lt;code&gt;\A&lt;/code&gt; 및 &lt;code&gt;\Z&lt;/code&gt; 는 문자열의 시작 또는 끝과 &lt;em&gt;만&lt;/em&gt; 계속 일치 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eec0fa542613e1975aae2a48b92903dde3eacbb8" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;table_alias&lt;/code&gt; is specified, the function name is used as the table name; in the case of a &lt;code&gt;ROWS FROM()&lt;/code&gt; construct, the first function's name is used.</source>
          <target state="translated">&lt;code&gt;table_alias&lt;/code&gt; 를 지정 하지 않으면 함수 이름이 테이블 이름으로 사용됩니다. (A)의 경우에는 &lt;code&gt;ROWS FROM()&lt;/code&gt; 구조체, 제 함수의 이름이 이용된다.</target>
        </trans-unit>
        <trans-unit id="5c82c2225e73852e8c357908e66b1d12e66520ab" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;weights&lt;/code&gt; are provided, then these defaults are used:</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 가 제공 되지 않으면 다음 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0368275c8128ea23b2ee02837095ef288617003c" translate="yes" xml:space="preserve">
          <source>If no collation is explicitly specified, the database system either derives a collation from the columns involved in the expression, or it defaults to the default collation of the database if no column is involved in the expression.</source>
          <target state="translated">데이터 정렬을 명시 적으로 지정하지 않으면 데이터베이스 시스템은 식에 포함 된 열에서 데이터 정렬을 파생 시키거나 식에 열이 포함되지 않은 경우 데이터베이스의 기본 데이터 정렬을 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="21307971878d081789f53c6ec3a32e0fa2a71500" translate="yes" xml:space="preserve">
          <source>If no default value is declared explicitly, the default value is the null value. This usually makes sense because a null value can be considered to represent unknown data.</source>
          <target state="translated">기본값이 명시 적으로 선언되지 않은 경우 기본값은 널값입니다. 널값이 알 수없는 데이터를 나타내는 것으로 간주 될 수 있기 때문에 이는 일반적으로 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6bbf77c4f367e9f49f3db1ca226b2a952882830" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">정확히 일치하는 항목이 없으면 함수 호출이 특수 유형 변환 요청으로 나타나는지 확인합니다. 이것은 함수 호출에 인수가 하나만 있고 함수 이름이 일부 데이터 유형의 (내부) 이름과 동일한 경우 발생합니다. 또한 함수 인수는 알 수없는 유형의 리터럴이거나 명명 된 데이터 유형에 대해 이진 강제 변환 가능한 유형이거나 해당 유형의 I / O 함수를 적용하여 명명 된 데이터 유형으로 변환 할 수있는 유형이어야합니다. 즉, 변환은 표준 문자열 유형 중 하나에서 이루어집니다). 이러한 조건이 충족되면 함수 호출이 &lt;code&gt;CAST&lt;/code&gt; 사양의 한 형태로 처리됩니다 . &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35149dcf4bfae750a59efc48da69e479e9799355" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">정확히 일치하는 것이 없으면 함수 호출이 특수한 유형 변환 요청으로 나타나는지 확인하십시오. 함수 호출에 인수가 하나만 있고 함수 이름이 일부 데이터 유형의 (내부) 이름과 동일한 경우에 발생합니다. 또한 함수 인수는 알 수없는 형식 리터럴이거나 명명 된 데이터 형식에 이진 강제 형식이거나 해당 형식의 I / O 함수를 적용하여 명명 된 데이터 형식으로 변환 할 수있는 형식이어야합니다. 즉, 변환은 표준 문자열 유형 중 하나에서 또는 표준 문자열 유형으로 변환됩니다). 이러한 조건이 충족되면 함수 호출은 &lt;code&gt;CAST&lt;/code&gt; 스펙 의 형태로 처리됩니다 . &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93b5e5aff6e0171effd161da742f968f9068eee6" translate="yes" xml:space="preserve">
          <source>If no explicit provision is made for a sign in &lt;code&gt;to_char()&lt;/code&gt;'s pattern, one column will be reserved for the sign, and it will be anchored to (appear just left of) the number. If &lt;code&gt;S&lt;/code&gt; appears just left of some &lt;code&gt;9&lt;/code&gt;'s, it will likewise be anchored to the number.</source>
          <target state="translated">&lt;code&gt;to_char()&lt;/code&gt; 패턴에 사인을 명시 적으로 제공하지 않으면 사인을 위해 하나의 열이 예약되고 숫자에 고정됩니다 (왼쪽에 나타남). 경우 &lt;code&gt;S&lt;/code&gt; 는 그냥 왼쪽에 나타납니다 &lt;code&gt;9&lt;/code&gt; 의, 그것은 마찬가지로 숫자에 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="6e409b417f72efc6d96ed16a0afc9bdc881a346a" translate="yes" xml:space="preserve">
          <source>If no function is specified, a blank &lt;code&gt;CREATE FUNCTION&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">함수를 지정하지 않으면 편집을 위해 빈 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 템플릿이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bfdbba53034a54f85542008e5a3f670d8b001aa1" translate="yes" xml:space="preserve">
          <source>If no lock mode is specified, then &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt;, the most restrictive mode, is used.</source>
          <target state="translated">잠금 모드를 지정하지 않으면 가장 제한적인 모드 인 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e62fb9f6836054022a0013bdbc9afb997f69a82f" translate="yes" xml:space="preserve">
          <source>If no moving-aggregate implementation is supplied, the aggregate can still be used with moving frames, but PostgreSQL will recompute the whole aggregation whenever the start of the frame moves. Note that whether or not the aggregate supports moving-aggregate mode, PostgreSQL can handle a moving frame end without recalculation; this is done by continuing to add new values to the aggregate's state. This is why use of an aggregate as a window function requires that the final function be read-only: it must not damage the aggregate's state value, so that the aggregation can be continued even after an aggregate result value has been obtained for one set of frame boundaries.</source>
          <target state="translated">이동 집계 구현이 제공되지 않으면 집계를 이동 프레임과 함께 계속 사용할 수 있지만 PostgreSQL은 프레임 시작이 이동할 때마다 전체 집계를 다시 계산합니다. 집계가 이동 집계 모드를 지원하는지 여부에 관계없이 PostgreSQL은 재 계산없이 이동 프레임 끝을 처리 할 수 ​​있습니다. 이는 집계 상태에 새 값을 계속 추가하여 수행됩니다. 이것이 창 함수로 집계를 사용하려면 최종 함수가 읽기 전용이어야합니다. 집계의 상태 값을 손상시키지 않아야하므로 한 세트의 집계 결과 값을 얻은 후에도 집계를 계속할 수 있습니다. 프레임 경계.</target>
        </trans-unit>
        <trans-unit id="f9d74d492594986bfbf1fc1386e105965c9b3fc3" translate="yes" xml:space="preserve">
          <source>If no output column name is specified using &lt;code&gt;AS&lt;/code&gt;, the system assigns a default column name. For simple column references, this is the name of the referenced column. For function calls, this is the name of the function. For complex expressions, the system will generate a generic name.</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 를 사용하여 출력 열 이름을 지정하지 않으면 시스템은 기본 열 이름을 지정합니다. 간단한 열 참조의 경우이 이름은 참조 된 열의 이름입니다. 함수 호출의 경우 함수 이름입니다. 복잡한 표현식의 경우 시스템은 일반 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="46eb45e8cda4a2fa8f3f15869002e910f361619b" translate="yes" xml:space="preserve">
          <source>If no role is specified, or the special user name &lt;code&gt;PUBLIC&lt;/code&gt; is used, then the policy applies to all users on the system. To allow all users to access only their own row in a &lt;code&gt;users&lt;/code&gt; table, a simple policy can be used:</source>
          <target state="translated">역할을 지정하지 않거나 특수 사용자 이름 &lt;code&gt;PUBLIC&lt;/code&gt; 을 사용하면 정책이 시스템의 모든 사용자에게 적용됩니다. 모든 사용자가 &lt;code&gt;users&lt;/code&gt; 테이블 에서 자신의 행에만 액세스 할 수 있도록 간단한 정책을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d6b57e5927a5bed9026e109eaaf60a10bd5032f" translate="yes" xml:space="preserve">
          <source>If no synchronous standby names are specified here, then synchronous replication is not enabled and transaction commits will not wait for replication. This is the default configuration. Even when synchronous replication is enabled, individual transactions can be configured not to wait for replication by setting the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; parameter to &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">여기에 동기 대기 이름을 지정하지 않으면 동기 복제를 사용할 수 없으며 트랜잭션 커밋이 복제를 기다리지 않습니다. 이것이 기본 구성입니다. 동기식 복제가 사용 가능하더라도 &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; 매개 변수를 &lt;code&gt;local&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 로 설정하여 복제를 기다리지 않도록 개별 트랜잭션을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b499f250be4863620a8af2772b67aa546566a3ec" translate="yes" xml:space="preserve">
          <source>If no table name is available, that is, when mapping a query or a cursor, the string &lt;code&gt;table&lt;/code&gt; is used in the first format, &lt;code&gt;row&lt;/code&gt; in the second format.</source>
          <target state="translated">사용 가능한 테이블 이름이 없으면, 즉 쿼리 또는 커서를 매핑 할 때 문자열 &lt;code&gt;table&lt;/code&gt; 이 첫 번째 형식으로 사용되며 두 번째 형식으로 &lt;code&gt;row&lt;/code&gt; 이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="31cbf099df48b49708d8e3fe1c5398bc9eb2b4ff" translate="yes" xml:space="preserve">
          <source>If no tuples were deleted from the heap, B-tree indexes are still scanned at the &lt;code&gt;VACUUM&lt;/code&gt; cleanup stage when at least one of the following conditions is met: the index statistics are stale, or the index contains deleted pages that can be recycled during cleanup. Index statistics are considered to be stale if the number of newly inserted tuples exceeds the &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; fraction of the total number of heap tuples detected by the previous statistics collection. The total number of heap tuples is stored in the index meta-page. Note that the meta-page does not include this data until &lt;code&gt;VACUUM&lt;/code&gt; finds no dead tuples, so B-tree index scan at the cleanup stage can only be skipped if the second and subsequent &lt;code&gt;VACUUM&lt;/code&gt; cycles detect no dead tuples.</source>
          <target state="translated">힙에서 삭제 된 튜플이없는 경우 다음 조건 중 하나 이상이 충족 될 때 &lt;code&gt;VACUUM&lt;/code&gt; 정리 단계 에서 B- 트리 인덱스가 계속 스캔됩니다 . 인덱스 통계가 오래되었거나 인덱스에 정리 중에 재활용 할 수있는 삭제 된 페이지가 포함되어 있습니다. . 새로 삽입 된 튜플의 수가 이전 통계 콜렉션에서 감지 한 총 힙 튜플 수의 &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; 비율을 초과하면 인덱스 통계는 오래된 것으로 간주됩니다 . 총 힙 튜플 수는 인덱스 메타 페이지에 저장됩니다. &lt;code&gt;VACUUM&lt;/code&gt; 이 죽은 튜플을 찾을 때까지 메타 페이지에는이 데이터가 포함되지 않으므로 정리 단계에서 B- 트리 인덱스 스캔은 두 번째 및 후속 &lt;code&gt;VACUUM&lt;/code&gt; 인 경우에만 건너 뛸 수 있습니다. 사이클은 죽은 튜플을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a50a96a1efd9e9515cc7402b6a1585dcf6707637" translate="yes" xml:space="preserve">
          <source>If no view is specified, a blank &lt;code&gt;CREATE VIEW&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">뷰를 지정하지 않으면 빈 &lt;code&gt;CREATE VIEW&lt;/code&gt; 템플릿이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b168c695895a81115afb54900077dcd6394dd9a3" translate="yes" xml:space="preserve">
          <source>If not found, search an internal table to match the token as either a special string (e.g., &lt;code&gt;today&lt;/code&gt;), day (e.g., &lt;code&gt;Thursday&lt;/code&gt;), month (e.g., &lt;code&gt;January&lt;/code&gt;), or noise word (e.g., &lt;code&gt;at&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;).</source>
          <target state="translated">찾을 수없는 경우, 특별한 문자열 (예를 들어, 하나 같이 토큰을 일치하는 내부 테이블을 검색 &lt;code&gt;today&lt;/code&gt; ), 일 (예를 들어, &lt;code&gt;Thursday&lt;/code&gt; (예), 월 &lt;code&gt;January&lt;/code&gt; (예) 또는 노이즈 단어 &lt;code&gt;at&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc5b189453f6a7ea6efcd19711a7a024dd08877c" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this entry could not be applied</source>
          <target state="translated">널이 아닌 경우이 항목을 적용 할 수없는 이유를 나타내는 오류 메시지</target>
        </trans-unit>
        <trans-unit id="8da51845e78e415599c49039ce6e56d900436b63" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this line could not be processed</source>
          <target state="translated">널이 아닌 경우,이 행을 처리 할 수없는 이유를 나타내는 오류 메시지</target>
        </trans-unit>
        <trans-unit id="96520540e7decec105d922c1561ef9f2b1d6ac9b" translate="yes" xml:space="preserve">
          <source>If on, any error will terminate the current session. By default, this is set to off, so that only FATAL errors will terminate the session.</source>
          <target state="translated">설정하면 오류가 발생하여 현재 세션이 종료됩니다. 기본적으로 이것은 FATAL 오류만으로 세션을 종료하도록 off로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="22cc3fdc7c909051830d32f3a9f4757f2bc2a2b3" translate="yes" xml:space="preserve">
          <source>If on, emit WAL-related debugging output. This parameter is only available if the &lt;code&gt;WAL_DEBUG&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">켜져 있으면 WAL 관련 디버깅 출력을 내 보냅니다. 이 매개 변수는 PostgreSQL이 컴파일 될 때 &lt;code&gt;WAL_DEBUG&lt;/code&gt; 매크로가 정의 된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea0ac9e4d18cd146b0646e9f1eaaad11f3441b88" translate="yes" xml:space="preserve">
          <source>If on, emit information about lightweight lock usage. Lightweight locks are intended primarily to provide mutual exclusion of access to shared-memory data structures.</source>
          <target state="translated">켜져 있으면 경량 잠금 사용법에 대한 정보를 내 보냅니다. 경량 잠금 장치는 주로 공유 메모리 데이터 구조에 대한 액세스를 상호 배제하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="108192b0a0e55fbd6c757081d9b7601d8b8f83e2" translate="yes" xml:space="preserve">
          <source>If on, emit information about lock usage. Information dumped includes the type of lock operation, the type of lock and the unique identifier of the object being locked or unlocked. Also included are bit masks for the lock types already granted on this object as well as for the lock types awaited on this object. For each lock type a count of the number of granted locks and waiting locks is also dumped as well as the totals. An example of the log file output is shown here:</source>
          <target state="translated">켜져 있으면 잠금 사용법에 대한 정보를 내 보냅니다. 덤프 된 정보에는 잠금 조작 유형, 잠금 유형 및 잠금 또는 잠금 해제중인 오브젝트의 고유 ID가 포함됩니다. 이 객체에 이미 부여 된 잠금 유형과이 객체에서 대기 한 잠금 유형에 대한 비트 마스크도 포함되어 있습니다. 각 잠금 유형에 대해 부여 된 잠금 및 대기 잠금의 수와 총계도 덤프됩니다. 로그 파일 출력의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb4d7f85e50d03eb97a6b576612fc80288cfa67e" translate="yes" xml:space="preserve">
          <source>If on, emit information about resource usage during sort operations. This parameter is only available if the &lt;code&gt;TRACE_SORT&lt;/code&gt; macro was defined when PostgreSQL was compiled. (However, &lt;code&gt;TRACE_SORT&lt;/code&gt; is currently defined by default.)</source>
          <target state="translated">설정되어 있으면 정렬 작업 중에 리소스 사용량에 대한 정보를 내 보냅니다. 이 매개 변수는 PostgreSQL이 컴파일 될 때 &lt;code&gt;TRACE_SORT&lt;/code&gt; 매크로가 정의 된 경우에만 사용 가능합니다 . 그러나 &lt;code&gt;TRACE_SORT&lt;/code&gt; 는 현재 기본적으로 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d6e32677420949906412ec403c3421f5aa432cd" translate="yes" xml:space="preserve">
          <source>If on, emit information about user lock usage. Output is the same as for &lt;code&gt;trace_locks&lt;/code&gt;, only for advisory locks.</source>
          <target state="translated">설정하면 사용자 잠금 사용법에 대한 정보를 내 보냅니다. 출력은 권고 잠금의 경우에만 &lt;code&gt;trace_locks&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4f521f40c917171fc7c2808f83dd0cac811f61dc" translate="yes" xml:space="preserve">
          <source>If one PostgreSQL server cluster is planned to contain unrelated projects or users that should be, for the most part, unaware of each other, it is recommended to put them into separate databases and adjust authorizations and access controls accordingly. If the projects or users are interrelated, and thus should be able to use each other's resources, they should be put in the same database but probably into separate schemas; this provides a modular structure with namespace isolation and authorization control. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">하나의 PostgreSQL 서버 클러스터가 대부분 서로를 인식하지 못하는 관련없는 프로젝트 또는 사용자를 포함하도록 계획된 경우이를 별도의 데이터베이스에 배치하고 그에 따라 권한 부여 및 액세스 제어를 조정하는 것이 좋습니다. 프로젝트 또는 사용자가 서로 관련되어 있으므로 서로의 리소스를 사용할 수 있어야하는 경우 동일한 데이터베이스에 배치해야하지만 별도의 스키마에 배치해야합니다. 이는 네임 스페이스 격리 및 권한 부여 제어가 포함 된 모듈 식 구조를 제공합니다. 스키마 관리에 대한 자세한 내용은 &lt;a href=&quot;ddl-schemas&quot;&gt;섹션 5.9에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa31b9c1a7b9373a56b5ac2143c494c8a9df5d88" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type and the other is of a domain type, next check to see if there is an operator accepting exactly the domain's base type on both sides; if so, use it.</source>
          <target state="translated">이진 연산자 호출의 한 인수가 &lt;code&gt;unknown&lt;/code&gt; 유형이고 다른 인수가 도메인 유형 인 경우, 다음으로 도메인의 기본 유형을 정확하게 수락하는 연산자가 양쪽에 있는지 확인하십시오. 그렇다면 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f194f32ef831d4b3157a47fd2652de25dffaf886" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type, then assume it is the same type as the other argument for this check. Invocations involving two &lt;code&gt;unknown&lt;/code&gt; inputs, or a unary operator with an &lt;code&gt;unknown&lt;/code&gt; input, will never find a match at this step.</source>
          <target state="translated">2 진 연산자 호출의 한 인수가 &lt;code&gt;unknown&lt;/code&gt; 유형 인 경우이 점검에 대한 다른 인수와 동일한 유형이라고 가정하십시오. 두 포함하는 호출이 &lt;code&gt;unknown&lt;/code&gt; 입력, 또는와 단항 연산자 &lt;code&gt;unknown&lt;/code&gt; 입력은이 단계에서 일치하는 항목을 찾을 수 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3677d43219ced3f6fdb380478ec70536347404f" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a bit-string value to &lt;code&gt;bit(n)&lt;/code&gt;, it will be truncated or zero-padded on the right to be exactly &lt;code&gt;n&lt;/code&gt; bits, without raising an error. Similarly, if one explicitly casts a bit-string value to &lt;code&gt;bit varying(n)&lt;/code&gt;, it will be truncated on the right if it is more than &lt;code&gt;n&lt;/code&gt; bits.</source>
          <target state="translated">비트 문자열 값을 &lt;code&gt;bit(n)&lt;/code&gt; 명시 적으로 캐스팅 하면 오른쪽에서 정확히 &lt;code&gt;n&lt;/code&gt; 비트가되도록 오류가 발생하지 않고 잘 리거나 0으로 채워집니다 . 마찬가지로 비트 문자열 값을 &lt;code&gt;bit varying(n)&lt;/code&gt; 으로 명시 적으로 캐스팅하는 경우 &lt;code&gt;n&lt;/code&gt; 비트 보다 크면 오른쪽에서 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="7d503789d22d34918cc5945f90261d6c003a05f3" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a value to &lt;code&gt;character varying(n)&lt;/code&gt; or &lt;code&gt;character(n)&lt;/code&gt;, then an over-length value will be truncated to &lt;code&gt;n&lt;/code&gt; characters without raising an error. (This too is required by the SQL standard.)</source>
          <target state="translated">값을 &lt;code&gt;character varying(n)&lt;/code&gt; 또는 &lt;code&gt;character(n)&lt;/code&gt; 명시 적으로 캐스팅하면 길이를 초과하는 값은 오류없이 &lt;code&gt;n&lt;/code&gt; 문자 로 잘립니다 . (이 역시 SQL 표준에 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="1de7610e41ebab1a246a8c49a8f76058b712b92e" translate="yes" xml:space="preserve">
          <source>If one of the list items is the special name &lt;code&gt;$user&lt;/code&gt;, then the schema having the name returned by &lt;code&gt;CURRENT_USER&lt;/code&gt; is substituted, if there is such a schema and the user has &lt;code&gt;USAGE&lt;/code&gt; permission for it. (If not, &lt;code&gt;$user&lt;/code&gt; is ignored.)</source>
          <target state="translated">목록 항목 중 하나가 특수 이름 &lt;code&gt;$user&lt;/code&gt; 인 경우, 해당 스키마가 있고 사용자에게 &lt;code&gt;USAGE&lt;/code&gt; 권한 이 있으면 &lt;code&gt;CURRENT_USER&lt;/code&gt; 에 의해 리턴 된 이름을 가진 스키마 가 대체 됩니다. 그렇지 않으면 &lt;code&gt;$user&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="19441d8efa255c5a903fe7f3e4cb160f4e49f55a" translate="yes" xml:space="preserve">
          <source>If only the parser is specified, then the new text search configuration initially has no mappings from token types to dictionaries, and therefore will ignore all words. Subsequent &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; commands must be used to create mappings to make the configuration useful. Alternatively, an existing text search configuration can be copied.</source>
          <target state="translated">구문 분석기 만 지정된 경우 새 텍스트 검색 구성에는 처음에 토큰 유형에서 사전으로의 맵핑이 없으므로 모든 단어를 무시합니다. 후속 &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; 명령을 사용하여 구성을 유용하게하려면 맵핑을 작성해야합니다. 또는 기존 텍스트 검색 구성을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8ecaaa3f305e080c140c9a79731fd19853d9256" translate="yes" xml:space="preserve">
          <source>If parentheses appear after &lt;code&gt;\g&lt;/code&gt;, they surround a space-separated list of &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; formatting-option clauses, which are interpreted in the same way as &lt;code&gt;\pset&lt;/code&gt;&lt;code&gt;option&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; commands, but take effect only for the duration of this query. In this list, spaces are not allowed around &lt;code&gt;=&lt;/code&gt; signs, but are required between option clauses. If &lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; is omitted, the named &lt;code&gt;option&lt;/code&gt; is changed in the same way as for &lt;code&gt;\pset&lt;/code&gt;&lt;code&gt;option&lt;/code&gt; with no explicit &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\g&lt;/code&gt; 뒤에 괄호가 나타나면 공백으로 구분 된 &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; format-option 절 목록을 묶습니다.이 목록은 &lt;code&gt;\pset&lt;/code&gt; &lt;code&gt;option&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 명령 과 동일한 방식으로 해석 되지만이 쿼리 기간 동안에 만 적용됩니다. 이 목록에서 &lt;code&gt;=&lt;/code&gt; 기호 주위에는 공백이 허용되지 않지만 옵션 절 사이에 필요합니다. 경우 &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 생략 명명 된 &lt;code&gt;option&lt;/code&gt; 과 동일한 방법으로 변경 &lt;code&gt;\pset&lt;/code&gt; &lt;code&gt;option&lt;/code&gt; 없이 명시 적으로 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1317b8ae94e1b0f60e57dbb20e11b92a9f8c5a7" translate="yes" xml:space="preserve">
          <source>If partial newline-sensitive matching is specified, this affects &lt;code&gt;.&lt;/code&gt; and bracket expressions as with newline-sensitive matching, but not &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">부분 개행 구분 일치가 지정되면이 영향을 &lt;code&gt;.&lt;/code&gt; 줄 바꿈과 일치하지만 대괄호 표현식은 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5535f2a09b6cea90f6f2421f76ccf57b35834ee5" translate="yes" xml:space="preserve">
          <source>If pg_checksums is aborted or killed while enabling or disabling checksums, the cluster's data checksum configuration remains unchanged, and pg_checksums can be re-run to perform the same operation.</source>
          <target state="translated">체크섬을 활성화 또는 비활성화하는 동안 pg_checksums가 중단되거나 종료되면 클러스터의 데이터 체크섬 구성은 변경되지 않고 pg_checksums를 다시 실행하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="329ffa5a3154cd15ee165233a8d448dbe8dc1875" translate="yes" xml:space="preserve">
          <source>If pg_rewind fails while processing, then the data folder of the target is likely not in a state that can be recovered. In such a case, taking a new fresh backup is recommended.</source>
          <target state="translated">처리하는 동안 pg_rewind가 실패하면 대상의 데이터 폴더가 복구 가능한 상태가 아닐 수 있습니다. 이 경우 새로운 백업을 새로 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="928868bbd3ab201faf3713aebe691a864c3216eb" translate="yes" xml:space="preserve">
          <source>If present, the operator class will become the default operator class for its data type. At most one operator class can be the default for a specific data type and index method.</source>
          <target state="translated">존재하는 경우 연산자 클래스는 해당 데이터 유형의 기본 연산자 클래스가됩니다. 특정 데이터 유형 및 색인 메소드에 대해 최대 하나의 연산자 클래스가 기본값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce8d13840c91deea2eabbef36d881ff8d4820b8" translate="yes" xml:space="preserve">
          <source>If primary restarts while commits are waiting for acknowledgment, those waiting transactions will be marked fully committed once the primary database recovers. There is no way to be certain that all standbys have received all outstanding WAL data at time of the crash of the primary. Some transactions may not show as committed on the standby, even though they show as committed on the primary. The guarantee we offer is that the application will not receive explicit acknowledgment of the successful commit of a transaction until the WAL data is known to be safely received by all the synchronous standbys.</source>
          <target state="translated">커밋이 승인을 기다리는 동안 기본이 다시 시작되면 대기중인 트랜잭션은 기본 데이터베이스가 복구되면 완전히 커밋 된 것으로 표시됩니다. 기본 서버가 충돌 할 때 모든 대기가 모든 미해결 WAL 데이터를 수신했는지 확인할 방법이 없습니다. 일부 트랜잭션은 기본 트랜잭션에서 커밋 된 것으로 표시 되더라도 대기에서 커밋 된 것으로 표시되지 않을 수 있습니다. 우리가 제공하는 보증은 WAL 데이터가 모든 동기 대기에 의해 안전하게 수신 될 때까지 응용 프로그램이 트랜잭션의 성공적인 커밋에 대한 명시적인 승인을받지 못한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cabf4b566b843e529d70b87d853fee3f06c7f4bf" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e. data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">쿼리가 수정되지 않고 브로드 캐스트 된 경우 &lt;code&gt;random()&lt;/code&gt; 과 같은 기능 , &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 시퀀스는 서버마다 값이 다를 수 있습니다. 이는 각 서버가 독립적으로 작동하고 SQL 쿼리가 브로드 캐스트 (실제로 수정 된 행이 아님)이기 때문입니다. 이것이 허용되지 않는 경우, 미들웨어 또는 애플리케이션은 단일 서버에서 이러한 값을 조회 한 후 해당 값을 쓰기 조회에 사용해야합니다. 또 다른 옵션은이 복제 옵션을 기존 마스터 대기 설정과 함께 사용하는 것입니다. 즉, 데이터 수정 쿼리는 마스터로만 전송되고 복제 미들웨어가 아닌 마스터 대기 복제를 통해 대기 서버로 전파됩니다. 또한 2 단계 커밋 ( &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; 및 &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED)을&lt;/a&gt; 사용하여 모든 트랜잭션이 모든 서버에서 커밋 또는 중단되도록주의해야합니다.). Pgpool-II 및 Continuous 텅스텐은 이러한 유형의 복제의 예입니다.</target>
        </trans-unit>
        <trans-unit id="493b00be39141f1a1aeb09adbc6c889957fa4153" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e., data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">쿼리가 수정되지 않은 상태로 브로드 캐스트되는 경우 &lt;code&gt;random()&lt;/code&gt; , &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 같은 기능, 시퀀스는 서버마다 다른 값을 가질 수 있습니다. 이는 각 서버가 독립적으로 작동하고 SQL 쿼리가 브로드 캐스트 (실제로 수정 된 행이 아님)되기 때문입니다. 이것이 허용되지 않는 경우 미들웨어 또는 애플리케이션은 단일 서버에서 이러한 값을 쿼리 한 다음 쓰기 쿼리에서 해당 값을 사용해야합니다. 또 다른 옵션은 기존의 마스터-대기 설정에서이 복제 옵션을 사용하는 것입니다. 즉, 데이터 수정 쿼리가 마스터로만 전송되고 복제 미들웨어가 아닌 마스터-대기 복제를 통해 대기 서버로 전파됩니다. 또한 모든 트랜잭션이 2 단계 커밋 ( &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; 및 &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED)을&lt;/a&gt; 사용하여 모든 서버에서 커밋 또는 중단되도록주의해야합니다.). Pgpool-II 및 Continuent Tungsten은 이러한 복제 유형의 예입니다.</target>
        </trans-unit>
        <trans-unit id="f63cea3b2db7baf929d271a8512ae9d2283784c6" translate="yes" xml:space="preserve">
          <source>If recovery finds corrupted WAL data, recovery will halt at that point and the server will not start. In such a case the recovery process could be re-run from the beginning, specifying a &amp;ldquo;recovery target&amp;rdquo; before the point of corruption so that recovery can complete normally. If recovery fails for an external reason, such as a system crash or if the WAL archive has become inaccessible, then the recovery can simply be restarted and it will restart almost from where it failed. Recovery restart works much like checkpointing in normal operation: the server periodically forces all its state to disk, and then updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again.</source>
          <target state="translated">복구에서 손상된 WAL 데이터를 찾으면 해당 시점에서 복구가 중지되고 서버가 시작되지 않습니다. 이러한 경우 복구 프로세스가 처음부터 다시 실행되어 손상 시점 이전에 &quot;복구 대상&quot;을 지정하여 복구가 정상적으로 완료 될 수 있습니다. 시스템 충돌과 같은 외부 이유로 인해 복구에 실패하거나 WAL 아카이브에 액세스 할 수없는 경우 복구를 다시 시작하면 거의 실패한 시점부터 다시 시작됩니다. 복구 다시 시작은 정상 작업의 검사 점과 매우 유사합니다. 서버는 주기적으로 모든 상태를 디스크로 강제 한 다음 &lt;code&gt;pg_control&lt;/code&gt; 파일을 업데이트 하여 이미 처리 된 WAL 데이터를 다시 검색 할 필요가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="28dab788b6122ef3bd1cdbda4da4f94cd1b6e630" translate="yes" xml:space="preserve">
          <source>If restoring from backup, rename or delete the old installation directory if it is not version-specific. It is a good idea to rename the directory, rather than delete it, in case you have trouble and need to revert to it. Keep in mind the directory might consume significant disk space. To rename the directory, use a command like this:</source>
          <target state="translated">백업에서 복원하는 경우 버전 별이 아닌 경우 이전 설치 디렉토리의 이름을 바꾸거나 삭제하십시오. 문제가 발생하여 되돌려 야하는 경우 디렉토리를 삭제하지 않고 이름을 바꾸는 것이 좋습니다. 디렉토리는 상당한 디스크 공간을 소비 할 수 있습니다. 디렉토리 이름을 바꾸려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e309c571c391be62f34e7db7a0c0dec41e3362c4" translate="yes" xml:space="preserve">
          <source>If role can log in, this specifies how many concurrent connections the role can make. -1 (the default) means no limit. Note that only normal connections are counted towards this limit. Neither prepared transactions nor background worker connections are counted towards this limit.</source>
          <target state="translated">역할이 로그인 할 수있는 경우 역할이 만들 수있는 동시 연결 수를 지정합니다. -1 (기본값)은 제한이 없음을 의미합니다. 이 연결에는 일반 연결 만 계산됩니다. 준비된 트랜잭션이나 백그라운드 작업자 연결은이 제한에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62496fbde4961b27e361cbfa11a352d993b40959" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for a table, but no applicable policies exist, a &amp;ldquo;default deny&amp;rdquo; policy is assumed, so that no rows will be visible or updatable.</source>
          <target state="translated">테이블에 대해 행 레벨 보안이 사용 가능하지만 적용 가능한 정책이없는 경우, &quot;기본 거부&quot;정책이 가정되므로 행이 표시되거나 갱신 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe157e3ff3573012872e8150157f95ab8031e531" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for the table, the relevant &lt;code&gt;SELECT&lt;/code&gt; policies will apply to &lt;code&gt;COPY table TO&lt;/code&gt; statements. Currently, &lt;code&gt;COPY FROM&lt;/code&gt; is not supported for tables with row-level security. Use equivalent &lt;code&gt;INSERT&lt;/code&gt; statements instead.</source>
          <target state="translated">테이블에 행 레벨 보안이 사용 가능한 경우 관련 &lt;code&gt;SELECT&lt;/code&gt; 정책이 &lt;code&gt;COPY table TO&lt;/code&gt; 문 에 적용됩니다 . 현재 &lt;code&gt;COPY FROM&lt;/code&gt; 은 행 레벨 보안이있는 테이블에 대해 지원되지 않습니다. 대신 동등한 &lt;code&gt;INSERT&lt;/code&gt; 문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6aa638ed0fa1c0e796268aac030545b317ec979" translate="yes" xml:space="preserve">
          <source>If running in FreeBSD jails by enabling sysctl's &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt;, postmasters running in different jails should be run by different operating system users. This improves security because it prevents non-root users from interfering with shared memory or semaphores in different jails, and it allows the PostgreSQL IPC cleanup code to function properly. (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect processes in other jails, preventing the running of postmasters on the same port in different jails.)</source>
          <target state="translated">sysctl의 &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt; 를 활성화하여 FreeBSD jails에서 실행하는 경우 , 다른 jail에서 실행되는 포스트 마스터는 다른 운영 체제 사용자가 실행해야합니다. 이는 루트가 아닌 사용자가 다른 감옥에서 공유 메모리 또는 세마포어를 방해하지 못하고 PostgreSQL IPC 정리 코드가 올바르게 작동 할 수있게하므로 보안을 향상시킵니다. (FreeBSD 6.0 이상에서 IPC 정리 코드는 다른 감옥에서 프로세스를 제대로 감지하지 않아서 다른 감옥의 동일한 포트에서 포스트 마스터가 실행되는 것을 방지합니다.)</target>
        </trans-unit>
        <trans-unit id="3d60f2762027b6b57c372852caf475ebc7475d90" translate="yes" xml:space="preserve">
          <source>If running in a FreeBSD jail, you should set its &lt;code&gt;sysvshm&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt;, so that it has its own separate System V shared memory namespace. (Before FreeBSD 11.0, it was necessary to enable shared access to the host's IPC namespace from jails, and take measures to avoid collisions.)</source>
          <target state="translated">FreeBSD jail에서 실행하는 경우 &lt;code&gt;sysvshm&lt;/code&gt; 매개 변수를 &lt;code&gt;new&lt;/code&gt; 로 설정하여 별도의 System V 공유 메모리 네임 스페이스를 갖도록해야합니다. (FreeBSD 11.0 이전에는 감옥에서 호스트의 IPC 네임 스페이스에 대한 공유 액세스를 활성화하고 충돌을 방지하기위한 조치를 취해야했습니다.)</target>
        </trans-unit>
        <trans-unit id="abdee92b42312c6177118cbed677697bf85b5620" translate="yes" xml:space="preserve">
          <source>If set to 0, the realm name from the authenticated user principal is stripped off before being passed through the user name mapping (&lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;). This is discouraged and is primarily available for backwards compatibility, as it is not secure in multi-realm environments unless &lt;code&gt;krb_realm&lt;/code&gt; is also used. It is recommended to leave &lt;code&gt;include_realm&lt;/code&gt; set to the default (1) and to provide an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt; to convert principal names to PostgreSQL user names.</source>
          <target state="translated">0으로 설정하면 인증 된 사용자 프린시 펄의 영역 이름이 제거되어 사용자 이름 맵핑을 통과합니다 ( &lt;a href=&quot;auth-username-maps&quot;&gt;섹션 20.2&lt;/a&gt; ). &lt;code&gt;krb_realm&lt;/code&gt; 을 사용 하지 않으면 다중 영역 환경에서는 안전하지 않으므로 권장하지 않으며 주로 하위 호환성을 위해 사용 가능합니다. &lt;code&gt;include_realm&lt;/code&gt; 을 기본값 (1)으로 설정하고 주체 이름을 PostgreSQL 사용자 이름으로 변환하기 위해 &lt;code&gt;pg_ident.conf&lt;/code&gt; 에 명시 적 매핑을 제공하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="752bcd0b9281c38894ddeb4c193f0b06ac531341" translate="yes" xml:space="preserve">
          <source>If set to 1 or less, sending an EOF character (usually &lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;D&lt;/strong&gt;) to an interactive session of psql will terminate the application. If set to a larger numeric value, that many consecutive EOF characters must be typed to make an interactive session terminate. If the variable is set to a non-numeric value, it is interpreted as 10. The default is 0.</source>
          <target state="translated">1 이하로 설정하면 psql의 대화식 세션 으로 EOF 문자 (보통 &lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;D&lt;/strong&gt; )를 보내면 응용 프로그램이 종료됩니다. 더 큰 숫자 값으로 설정하면 대화식 세션이 종료되도록 연속 된 많은 EOF 문자를 입력해야합니다. 변수가 숫자가 아닌 값으로 설정되면 10으로 해석됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f150c6b9d3460dc605d8aac9efe72846ba7bd56d" translate="yes" xml:space="preserve">
          <source>If set to 1, the domain's SAM-compatible name (also known as the NetBIOS name) is used for the &lt;code&gt;include_realm&lt;/code&gt; option. This is the default. If set to 0, the true realm name from the Kerberos user principal name is used.</source>
          <target state="translated">1로 설정하면 도메인의 SAM 호환 이름 (NetBIOS 이름이라고도 함)이 &lt;code&gt;include_realm&lt;/code&gt; 옵션에 사용됩니다. 이것이 기본값입니다. 0으로 설정하면 Kerberos 사용자 프린시 펄 이름의 실제 영역 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82302c2f8409896da1eb7439e9dc154b96d3a8b4" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;all&lt;/code&gt;, all nonempty input lines are printed to standard output as they are read. (This does not apply to lines read interactively.) To select this behavior on program start-up, use the switch &lt;code&gt;-a&lt;/code&gt;. If set to &lt;code&gt;queries&lt;/code&gt;, psql prints each query to standard output as it is sent to the server. The switch to select this behavior is &lt;code&gt;-e&lt;/code&gt;. If set to &lt;code&gt;errors&lt;/code&gt;, then only failed queries are displayed on standard error output. The switch for this behavior is &lt;code&gt;-b&lt;/code&gt;. If set to &lt;code&gt;none&lt;/code&gt; (the default), then no queries are displayed.</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; 로 설정하면 비어 있지 않은 모든 입력 행을 읽을 때 표준 출력으로 인쇄됩니다. (대화식으로 읽은 행에는 적용되지 않습니다.) 프로그램 시작시이 동작을 선택하려면 스위치 &lt;code&gt;-a&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;queries&lt;/code&gt; 설정된 경우 psql은 서버로 전송 될 때 각 쿼리를 표준 출력으로 인쇄합니다. 이 동작을 선택하는 스위치는 &lt;code&gt;-e&lt;/code&gt; 입니다. &lt;code&gt;errors&lt;/code&gt; 로 설정되면 표준 오류 출력에 실패한 쿼리 만 표시됩니다. 이 동작의 스위치는 &lt;code&gt;-b&lt;/code&gt; 입니다. &lt;code&gt;none&lt;/code&gt; (기본값)으로 설정하면 쿼리가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e8e09a59b4bf762d85ca1f3a58b8a4dd3ab9bc9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;off&lt;/code&gt; (the default), detection of WAL records having references to invalid pages during recovery causes PostgreSQL to raise a PANIC-level error, aborting the recovery. Setting &lt;code&gt;ignore_invalid_pages&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt; causes the system to ignore invalid page references in WAL records (but still report a warning), and continue the recovery. This behavior may &lt;em&gt;cause crashes, data loss, propagate or hide corruption, or other serious problems&lt;/em&gt;. However, it may allow you to get past the PANIC-level error, to finish the recovery, and to cause the server to start up. The parameter can only be set at server start. It only has effect during recovery or in standby mode.</source>
          <target state="translated">&lt;code&gt;off&lt;/code&gt; (기본값)로 설정하면 복구 중에 유효하지 않은 페이지에 대한 참조가있는 WAL 레코드가 감지되면 PostgreSQL에서 PANIC 수준 오류가 발생하여 복구가 중단됩니다. &lt;code&gt;ignore_invalid_pages&lt;/code&gt; 를 &lt;code&gt;on&lt;/code&gt; 으로 설정 하면 시스템이 WAL 레코드에서 유효하지 않은 페이지 참조를 무시하고 (하지만 여전히 경고를보고 함) 복구를 계속합니다. 이 동작은 &lt;em&gt;충돌, 데이터 손실, 손상 전파 또는 숨기기 또는 기타 심각한 문제를 일으킬 수 있습니다&lt;/em&gt; . 그러나 PANIC 수준 오류를지나 복구를 완료하고 서버가 시작되도록 할 수 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 복구 중 또는 대기 모드에서만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9981243abcd6bfa6b05982c27d6e7ff810b5e4a9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes WAL files to be recycled by renaming them, avoiding the need to create new ones. On COW file systems, it may be faster to create new ones, so the option is given to disable this behavior.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; (기본값)으로 설정된 경우이 옵션을 사용하면 WAL 파일의 이름을 바꾸어 새 파일을 만들 필요없이 WAL 파일을 재활용 할 수 있습니다. COW 파일 시스템에서는 새 파일 시스템을 만드는 것이 더 빠를 수 있으므로이 동작을 비활성화하는 옵션이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="813f1fb7e134b84c20368173806332413bb9e2ea" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes new WAL files to be filled with zeroes. On some file systems, this ensures that space is allocated before we need to write WAL records. However, &lt;em&gt;Copy-On-Write&lt;/em&gt; (COW) file systems may not benefit from this technique, so the option is given to skip the unnecessary work. If set to &lt;code&gt;off&lt;/code&gt;, only the final byte is written when the file is created so that it has the expected size.</source>
          <target state="translated">로 설정하면 &lt;code&gt;on&lt;/code&gt; (기본값)으로 경우이 옵션을 사용하면 새 WAL 파일이 0으로 채워집니다. 일부 파일 시스템에서는 WAL 레코드를 작성하기 전에 공간이 할당됩니다. 그러나 COW ( &lt;em&gt;Copy-On-Write&lt;/em&gt; ) 파일 시스템은이 기술의 이점을 얻지 못할 수 있으므로 불필요한 작업을 건너 뛰도록 옵션이 제공됩니다. &lt;code&gt;off&lt;/code&gt; 로 설정 되면 파일이 예상 크기를 갖도록 작성 될 때 최종 바이트 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0fba393e4d7deed9cb85ba465e5b27c9e3ab7dd3" translate="yes" xml:space="preserve">
          <source>If set to a non-existent library, JIT will not be available, but no error will be raised. This allows JIT support to be installed separately from the main PostgreSQL package.</source>
          <target state="translated">존재하지 않는 라이브러리로 설정하면 JIT를 사용할 수 없지만 오류는 발생하지 않습니다. 이를 통해 JIT 지원을 기본 PostgreSQL 패키지와 별도로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3b3af4f011e1d63d9b8223219828980a0583602" translate="yes" xml:space="preserve">
          <source>If set to on, PostgreSQL will instead report an error but continue to run so that the data flushing operation can be retried in a later checkpoint. Only set it to on after investigating the operating system's treatment of buffered data in case of write-back failure.</source>
          <target state="translated">on으로 설정하면 PostgreSQL이 대신 오류를보고하지만 나중에 검사 점에서 데이터 플러시 작업을 다시 시도 할 수 있도록 계속 실행됩니다. 후기 입 실패의 경우 운영 체제의 버퍼링 된 데이터 처리를 조사한 후에 만 ​​설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bbcf79a2d604d4a130bf67d3aa6808540ca830ba" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID (used to avoid output on system tables).</source>
          <target state="translated">설정된 경우이 OID 아래의 테이블에 대한 잠금을 추적하지 마십시오 (시스템 테이블의 출력을 방지하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="7b7ecf1b7610990cb56a543c68a5259c46df2a63" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID. (use to avoid output on system tables)</source>
          <target state="translated">설정된 경우이 OID 아래의 테이블에 대한 잠금을 추적하지 마십시오. (시스템 테이블에서 출력을 피하기 위해 사용)</target>
        </trans-unit>
        <trans-unit id="41deca852e6fe629c05086ec201225e618efe1c2" translate="yes" xml:space="preserve">
          <source>If set, dumps information about all current locks when a deadlock timeout occurs.</source>
          <target state="translated">설정되면 교착 상태 시간 종료가 발생할 때 모든 현재 잠금에 대한 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="18ea3580271535268c36ef5f8d3f6aa2461f7a29" translate="yes" xml:space="preserve">
          <source>If set, logs system resource usage statistics (memory and CPU) on various B-tree operations.</source>
          <target state="translated">설정된 경우 다양한 B- 트리 작업에서 시스템 리소스 사용 통계 (메모리 및 CPU)를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="8cd44fecb272ef12a9372f7353f761fae8a5a0b8" translate="yes" xml:space="preserve">
          <source>If set, the name of the database to create, unless overridden on the command line.</source>
          <target state="translated">설정된 경우 명령 줄에서 재정의하지 않는 한 만들 데이터베이스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="451271dfdfad4c754e04924937d10fe2728cec15" translate="yes" xml:space="preserve">
          <source>If several large tables all become eligible for vacuuming in a short amount of time, all autovacuum workers might become occupied with vacuuming those tables for a long period. This would result in other tables and databases not being vacuumed until a worker becomes available. There is no limit on how many workers might be in a single database, but workers do try to avoid repeating work that has already been done by other workers. Note that the number of running workers does not count towards &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; or &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; limits.</source>
          <target state="translated">여러 개의 큰 테이블이 모두 짧은 시간 안에 진공 청소기로 청소할 수있게되면 모든 자동 진공 작업자가 해당 테이블을 오랫동안 진공 청소기로 청소할 수 있습니다. 이로 인해 작업자가 사용 가능해질 때까지 다른 테이블과 데이터베이스가 정리되지 않습니다. 단일 데이터베이스에있을 수있는 작업자 수에는 제한이 없지만 작업자는 다른 작업자가 이미 수행 한 반복 작업을 피하려고합니다. 실행중인 작업자 수는 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; 제한에 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0c0765d00a52dbd937ed1bff59efeb02a5ce2381" translate="yes" xml:space="preserve">
          <source>If simultaneous snapshots are not possible, one option is to shut down the database server long enough to establish all the frozen snapshots. Another option is to perform a continuous archiving base backup (&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;) because such backups are immune to file system changes during the backup. This requires enabling continuous archiving just during the backup process; restore is done using continuous archive recovery (&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">동시 스냅 샷이 불가능한 경우 고정 된 모든 스냅 샷을 설정하기에 충분한 시간 동안 데이터베이스 서버를 종료하는 옵션이 있습니다. 또 다른 옵션은 백업 중 파일 시스템 변경에 영향을받지 않기 때문에 지속적인 아카이브 기반 백업 ( &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;25.3.2 절&lt;/a&gt; ) 을 수행하는 것 입니다. 이를 위해서는 백업 프로세스 중 지속적인 아카이브가 가능해야합니다. 지속적인 아카이브 복구 ( &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;25.3.4 절&lt;/a&gt; )를 사용하여 복구가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b56d1af18915d5bc67acc7e5f67cf1743ccd0db" translate="yes" xml:space="preserve">
          <source>If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the &lt;code&gt;SELECT&lt;/code&gt; are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to &lt;code&gt;WITH&lt;/code&gt; queries referenced by the primary query. If you want row locking to occur within a &lt;code&gt;WITH&lt;/code&gt; query, specify a locking clause within the &lt;code&gt;WITH&lt;/code&gt; query.</source>
          <target state="translated">특정 테이블의 이름이 잠금 절에 지정된 경우 해당 테이블에서 오는 행만 잠 깁니다. &lt;code&gt;SELECT&lt;/code&gt; 에 사용 된 다른 테이블 은 평상시처럼 읽습니다. 테이블 목록이없는 잠금 절은 명령문에 사용 된 모든 테이블에 영향을줍니다. 잠금 절이 뷰 또는 하위 쿼리에 적용되면 뷰 또는 하위 쿼리에 사용 된 모든 테이블에 영향을줍니다. 그러나 이러한 절은 기본 쿼리에서 참조하는 &lt;code&gt;WITH&lt;/code&gt; 쿼리 에는 적용되지 않습니다 . &lt;code&gt;WITH&lt;/code&gt; 쿼리 내에서 행 잠금이 발생 하도록하려면 &lt;code&gt;WITH&lt;/code&gt; 쿼리 내에 잠금 절을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="beba3aa15b0f31c93cbfaa613e20da31b4d61852" translate="yes" xml:space="preserve">
          <source>If specified, the sequence object is created only for this session, and is automatically dropped on session exit. Existing permanent sequences with the same name are not visible (in this session) while the temporary sequence exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">지정된 경우 시퀀스 오브젝트는이 세션에 대해서만 작성되며 세션 종료시 자동으로 삭제됩니다. 스키마 규정 이름으로 참조되지 않는 한 임시 시퀀스가 ​​존재하는 동안 동일한 이름의 기존 영구 시퀀스는이 세션에서 보이지 않습니다 (이 세션에서).</target>
        </trans-unit>
        <trans-unit id="96e1f90a66af2b7d727620148bca6f42e74b9d62" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">지정하면 테이블이 임시 테이블로 작성됩니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a93d62c01130cfe765292bae429e3354023ac5a8" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see &lt;code&gt;ON COMMIT&lt;/code&gt; below). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.</source>
          <target state="translated">지정하면 테이블이 임시 테이블로 작성됩니다. 임시 테이블은 세션이 끝날 때 또는 선택적으로 현재 트랜잭션이 끝날 때 자동으로 삭제됩니다 (아래의 &lt;code&gt;ON COMMIT&lt;/code&gt; 참조). 동일한 이름을 가진 기존 영구 테이블은 스키마 규정 이름으로 참조되지 않는 한 임시 테이블이 존재하는 동안 현재 세션에 표시되지 않습니다. 임시 테이블에서 생성 된 인덱스도 자동으로 임시입니다.</target>
        </trans-unit>
        <trans-unit id="e56b4bad12a19e93500049e2da8fe4abf56f18b0" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">지정하면 테이블이 로그되지 않은 테이블로 작성됩니다. 기록되지 않은 테이블에 기록 된 데이터는 미리 기록 로그에 기록되지 않으므로 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;29 장&lt;/a&gt; 참조 ) 일반 테이블보다 훨씬 빠릅니다. 그러나 충돌 안전 상태는 아닙니다. 충돌 또는 부정확 한 종료 후에 로그되지 않은 테이블이 자동으로 잘립니다. 로깅되지 않은 테이블의 내용도 대기 서버로 복제되지 않습니다. 기록되지 않은 테이블에서 작성된 모든 색인도 자동으로 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8596f70e4f839c2549fada82806079e6705f6bb" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">지정된 경우 테이블은 로그되지 않은 테이블로 생성됩니다. 로그되지 않은 테이블에 기록 된 데이터는 미리 쓰기 로그 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;29 장&lt;/a&gt; 참조 )에 기록되지 않으므로 일반 테이블보다 훨씬 빠릅니다. 그러나 크래시로부터 안전하지 않습니다. 로그되지 않은 테이블은 크래시 또는 비정상 종료 후 자동으로 잘립니다. 로그되지 않은 테이블의 내용도 대기 서버로 복제되지 않습니다. 로그되지 않은 테이블에 생성 된 인덱스도 자동으로 로그 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="498ade4fa6d89cb5e928b12b79fbd85a2d4b6bc5" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">지정하면 테이블이 로그되지 않은 테이블로 작성됩니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55118ee1dbd9adb1bf85c53f18502dc86e8b6ddb" translate="yes" xml:space="preserve">
          <source>If specified, the view is created as a temporary view. Temporary views are automatically dropped at the end of the current session. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">지정하면보기가 임시보기로 작성됩니다. 현재 세션이 끝나면 임시 뷰가 자동으로 삭제됩니다. 동일한 이름의 기존 영구 관계는 스키마 규정 이름으로 참조되지 않는 한 임시보기가 존재하는 동안 현재 세션에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b5dcbb0812dddc20d9371b9207b1cdb23e05524" translate="yes" xml:space="preserve">
          <source>If still not found, throw an error.</source>
          <target state="translated">여전히 찾을 수 없으면 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="47cfc3e95fb2a4c5ace1abe2c232997982b636d2" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without a problem. If streaming replication is in progress then WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">스트리밍 복제가 비활성화되면 일시 중지 된 상태가 문제없이 무기한 계속 될 수 있습니다. 스트리밍 복제가 진행중인 경우 WAL 레코드가 계속 수신되며 일시 중지 기간, WAL 생성 속도 및 사용 가능한 디스크 공간에 따라 결국 사용 가능한 디스크 공간을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="07af580d9fd90f0744560609d17c425a1c0582ea" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without problem. While streaming replication is in progress WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">스트리밍 복제가 비활성화되면 일시 중지 된 상태가 문제없이 무한정 계속 될 수 있습니다. 스트리밍 복제가 진행되는 동안 WAL 레코드가 계속 수신되어 일시 중지 기간, WAL 생성 속도 및 사용 가능한 디스크 공간에 따라 사용 가능한 디스크 공간이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="226224ac165619e504532207642e17cb378b9939" translate="yes" xml:space="preserve">
          <source>If syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.</source>
          <target state="translated">syslog가 궁극적으로 텍스트 파일에 로깅하는 경우 효과는 어느 쪽이든 동일하며 대부분의 syslog 구현은 큰 메시지를 처리 ​​할 수 ​​없거나 처리하도록 특별히 구성해야하므로 설정을 유지하는 것이 가장 좋습니다. 그러나 syslog가 궁극적으로 다른 매체에 쓰는 경우 메시지를 논리적으로 함께 유지하는 것이 필요하거나 더 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5afa6f87265a39e1ce0df6a7d2ec06e5f9b70a1e" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (including shared memory) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">systemd를 사용중인 경우 IPC 리소스 (공유 메모리 포함)가 운영 체제에 의해 조기에 제거되지 않도록주의해야합니다. 이것은 소스에서 PostgreSQL을 설치할 때 특히 중요합니다. PostgreSQL 배포 패키지 사용자는 일반적으로 &lt;code&gt;postgres&lt;/code&gt; 사용자가 시스템 사용자로 생성되기 때문에 영향을받을 가능성이 적습니다 .</target>
        </trans-unit>
        <trans-unit id="0c9f61d1e280ce039975396a48eef3020a367753" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (shared memory and semaphores) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">systemd를 사용하는 경우 운영 체제에서 IPC 리소스 (공유 메모리 및 세마포어)를 조기에 제거하지 않도록주의해야합니다. 이것은 소스에서 PostgreSQL을 설치할 때 특히 중요합니다. 는 AS의 PostgreSQL 배포 패키지의 사용자는 영향을받을 가능성이 적습니다 &lt;code&gt;postgres&lt;/code&gt; 사용자가 다음 일반적으로 시스템 사용자로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0cc78b460318c43d7e2a2ae058784201d032436a" translate="yes" xml:space="preserve">
          <source>If table is a partition (see &lt;code&gt;relispartition&lt;/code&gt;), internal representation of the partition bound</source>
          <target state="translated">테이블이 파티션 인 경우 ( &lt;code&gt;relispartition&lt;/code&gt; 참조 ) 파티션의 내부 표현</target>
        </trans-unit>
        <trans-unit id="2f2df2648f2943188802b9abf232f2ee4f995a24" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;Access privileges&amp;rdquo; column is empty for a given object, it means the object has default privileges (that is, its privileges entry in the relevant system catalog is null). Default privileges always include all privileges for the owner, and can include some privileges for &lt;code&gt;PUBLIC&lt;/code&gt; depending on the object type, as explained above. The first &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; on an object will instantiate the default privileges (producing, for example, &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt;) and then modify them per the specified request. Similarly, entries are shown in &amp;ldquo;Column privileges&amp;rdquo; only for columns with nondefault privileges. (Note: for this purpose, &amp;ldquo;default privileges&amp;rdquo; always means the built-in default privileges for the object's type. An object whose privileges have been affected by an &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; command will always be shown with an explicit privilege entry that includes the effects of the &lt;code&gt;ALTER&lt;/code&gt;.)</source>
          <target state="translated">주어진 오브젝트에 대해 &quot;액세스 권한&quot;열이 비어있는 경우, 오브젝트에 기본 권한이 있음을 의미합니다 (즉, 관련 시스템 카탈로그의 해당 권한 항목이 널임). 기본 권한은 항상 소유자에 대한 모든 권한을 포함하며 위에서 설명한대로 오브젝트 유형에 따라 &lt;code&gt;PUBLIC&lt;/code&gt; 에 대한 일부 권한을 포함 할 수 있습니다 . 객체 의 첫 번째 &lt;code&gt;GRANT&lt;/code&gt; 또는 &lt;code&gt;REVOKE&lt;/code&gt; 는 기본 권한을 인스턴스화합니다 (예 : &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt; 생성).)을 지정한 다음 지정된 요청에 따라 수정하십시오. 마찬가지로 항목은 기본 권한이 아닌 열에 대해서만&amp;ldquo;열 권한&amp;rdquo;에 표시됩니다. (참고 :이 목적에서 &quot;기본 권한&quot;은 항상 개체 유형에 대한 기본 제공 기본 권한을 의미합니다. 권한이 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 명령의 영향을받은 개체 는 항상 효과가 포함 된 명시 적 권한 항목으로 표시됩니다. 의 &lt;code&gt;ALTER&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ef8285ef018dbe08eadaac46ca6f457ffb7737a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--check&lt;/code&gt; option was used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">경우 &lt;code&gt;--check&lt;/code&gt; 옵션을 사용, 기존의 클러스터는 수정되지 않은이었다; 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5231ab37a455b02818813f84dceafd365dc3d243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was &lt;em&gt;not&lt;/em&gt; used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">경우 &lt;code&gt;--link&lt;/code&gt; 옵션이되었다 &lt;em&gt;없습니다&lt;/em&gt; 사용, 기존의 클러스터는 수정되지 않은이었다; 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eaa5641cd34b4f83c2c8d2f48ba3f445ae08243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was used, the data files might be shared between the old and new cluster:</source>
          <target state="translated">경우 &lt;code&gt;--link&lt;/code&gt; 옵션이 사용 된 데이터 파일은 이전과 새 클러스터간에 공유 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e5bb770bf0c6c53be90a08f4aadc13d0d045351b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DELETE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) deleted by the command.</source>
          <target state="translated">경우 &lt;code&gt;DELETE&lt;/code&gt; 명령이 포함 &lt;code&gt;RETURNING&lt;/code&gt; 절을, 결과는의 그것과 유사합니다 &lt;code&gt;SELECT&lt;/code&gt; 에 정의 열과 값을 포함하는 문장 &lt;code&gt;RETURNING&lt;/code&gt; 행 (들)을 통해 계산 된 목록을 명령에 의해 삭제.</target>
        </trans-unit>
        <trans-unit id="3edf0bee0b1a18174b6275c32dcc72778ff7f983" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;&lt;code&gt;HAVING&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;GROUP BY&lt;/code&gt; 절이 지정 집계 함수 호출이있는 경우, 또는, 출력은 하나 이상의 값 및 집계 함수의 결과에 일치 계산되는 행의 그룹으로 결합된다. &lt;code&gt;HAVING&lt;/code&gt; 절이 있으면 주어진 조건을 만족하지 않는 그룹을 제거합니다. (아래의 &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 조항&lt;/a&gt; 및 &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt; &lt;code&gt;HAVING&lt;/code&gt; 조항을&lt;/a&gt; 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="8cba5ea5fe4b174dd3b26b5824e3815a353de168" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;GROUP BY Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;HAVING Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;GROUP BY&lt;/code&gt; 절이 지정 집계 함수 호출이있는 경우, 또는, 출력은 하나 이상의 값 및 집계 함수의 결과에 일치 계산되는 행의 그룹으로 결합된다. &lt;code&gt;HAVING&lt;/code&gt; 절이 있으면 주어진 조건을 만족하지 않는 그룹을 제거합니다. (아래의 &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;GROUP BY 절&lt;/a&gt; 및 &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;HAVING 절을&lt;/a&gt; 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e73996306e544b116d96395fc6c635fa64541db1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSERT&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) inserted or updated by the command.</source>
          <target state="translated">경우] &lt;code&gt;INSERT&lt;/code&gt; 의 명령이 포함 &lt;code&gt;RETURNING&lt;/code&gt; 절, 결과는 마찬가지 일 것이다 &lt;code&gt;SELECT&lt;/code&gt; 에 정의 열 및 값 함유 문 &lt;code&gt;RETURNING&lt;/code&gt; 행 (들)을 통해 계산 된리스트에 삽입 또는 명령에 의해 갱신한다.</target>
        </trans-unit>
        <trans-unit id="0cef0ec98d8f962ff98a56a4b6b305bd357183c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;LIMIT&lt;/code&gt; (또는 &lt;code&gt;FETCH FIRST&lt;/code&gt; ) 또는 &lt;code&gt;OFFSET&lt;/code&gt; 절이 지정되면, &lt;code&gt;SELECT&lt;/code&gt; 문은 결과 행의 하위 집합을 반환합니다. (아래 &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 조항&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="4a75230035fa0b522f04007a43794f1e0d2bb911" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;LIMIT&lt;/code&gt; (또는 &lt;code&gt;FETCH FIRST&lt;/code&gt; ) 또는 &lt;code&gt;OFFSET&lt;/code&gt; 절이 지정되면, &lt;code&gt;SELECT&lt;/code&gt; 문은 결과 행의 하위 집합을 반환합니다. (아래의 &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT 조항을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="72d3a656a8d2961c5ae7c07dee89a103497dda43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;ORDER BY&lt;/code&gt; 절이 지정, 반환 된 행은 지정된 순서로 정렬됩니다. 경우 &lt;code&gt;ORDER BY&lt;/code&gt; 가 지정되지, 행이 어떤 순서로 시스템의 발견 가장 빠른 생산에 반환됩니다. (아래의 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 조항을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d8ea2efbcef004128bc9ee33fa0b309eb98d431a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; below.)</source>
          <target state="translated">는 IF &lt;code&gt;ORDER BY&lt;/code&gt; 절이 지정, 반환 된 행은 지정된 순서로 정렬됩니다. 경우 &lt;code&gt;ORDER BY&lt;/code&gt; 가 지정되지, 행이 어떤 순서로 시스템의 발견 가장 빠른 생산에 반환됩니다. (아래의 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="fcc9caa8fd8396a40199c537204044cd80b03fd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; command fails for any reason, it becomes a &lt;code&gt;ROLLBACK&lt;/code&gt;: the current transaction is canceled.</source>
          <target state="translated">경우 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 의 명령이 어떤 이유로 실패, 그것은된다 &lt;code&gt;ROLLBACK&lt;/code&gt; : 현재 트랜잭션이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="049a6b3315aa2fcc9292bf280d3fbac8f17f8faa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE&lt;/code&gt; statement that created the statement specified some parameters, a compatible set of parameters must be passed to the &lt;code&gt;EXECUTE&lt;/code&gt; statement, or else an error is raised. Note that (unlike functions) prepared statements are not overloaded based on the type or number of their parameters; the name of a prepared statement must be unique within a database session.</source>
          <target state="translated">경우 &lt;code&gt;PREPARE&lt;/code&gt; 문을 만든 문이 일부 매개 변수를 지정, 매개 변수의 호환 세트는 전달해야 &lt;code&gt;EXECUTE&lt;/code&gt; 문, 그렇지 않으면 오류가 발생합니다. (함수와 달리) 준비된 명령문은 매개 변수의 유형 또는 수에 따라 오버로드되지 않습니다. 준비된 명령문의 이름은 데이터베이스 세션 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e671e1df94a35c63462372f63dbaab316b08304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UPDATE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) updated by the command.</source>
          <target state="translated">경우] &lt;code&gt;UPDATE&lt;/code&gt; 명령이 포함 &lt;code&gt;RETURNING&lt;/code&gt; 절, 결과는 마찬가지 일 것이다 &lt;code&gt;SELECT&lt;/code&gt; 에 정의 열 및 값 함유 문 &lt;code&gt;RETURNING&lt;/code&gt; 명령에 의해 갱신 된 행 (들)을 통해 계산 된리스트.</target>
        </trans-unit>
        <trans-unit id="e2d169320d1dac51b305dc4371af2fd872eb335a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">경우 &lt;code&gt;WHERE&lt;/code&gt; 의 절이 지정, 조건을 만족하지 않는 모든 행은 출력에서 제거됩니다. (아래의 &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; 절&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="4af20d29d9d1228c78339d28ff758ffb08bbfc49" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;WHERE Clause&lt;/a&gt; below.)</source>
          <target state="translated">경우 &lt;code&gt;WHERE&lt;/code&gt; 의 절이 지정, 조건을 만족하지 않는 모든 행은 출력에서 제거됩니다. (아래 &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;WHERE 절&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="92b918e82e1dbdff8d47052fc332ee8551811a46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is specified, an additional column of type &lt;code&gt;bigint&lt;/code&gt; will be added to the function result columns. This column numbers the rows of the function result set, starting from 1. (This is a generalization of the SQL-standard syntax for &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt;.) By default, the ordinal column is called &lt;code&gt;ordinality&lt;/code&gt;, but a different column name can be assigned to it using an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">경우] &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 절이 지정된 입력의 추가 열 &lt;code&gt;bigint&lt;/code&gt; 함수 결과 컬럼에 첨가한다. 이 열은 1부터 시작하여 함수 결과 집합의 행에 번호를 &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt; (이것은 UNNEST ... WITH ORDINALITY에 대한 SQL 표준 구문의 일반화입니다 .) 기본적으로 서수 열은 &lt;code&gt;ordinality&lt;/code&gt; 라고 하지만 열 이름은 다릅니다 &lt;code&gt;AS&lt;/code&gt; 절을 사용하여 할당 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a9a2b1e5b5de3befe9a4b97f742aa542e0145cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;count&lt;/code&gt; expression evaluates to NULL, it is treated as &lt;code&gt;LIMIT ALL&lt;/code&gt;, i.e., no limit. If &lt;code&gt;start&lt;/code&gt; evaluates to NULL, it is treated the same as &lt;code&gt;OFFSET 0&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;count&lt;/code&gt; NULL로 표현 평가하여, 그것은으로 처리됩니다 &lt;code&gt;LIMIT ALL&lt;/code&gt; 즉, 제한 없음. &lt;code&gt;start&lt;/code&gt; 가 NULL로 평가 되면 &lt;code&gt;OFFSET 0&lt;/code&gt; 과 동일하게 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="b469c74a0f6fb197601cf70011bbae3b5c0a8cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dictionary&lt;/code&gt; argument is omitted, the text search dictionary named &lt;code&gt;unaccent&lt;/code&gt; and appearing in the same schema as the &lt;code&gt;unaccent()&lt;/code&gt; function itself is used.</source>
          <target state="translated">경우 &lt;code&gt;dictionary&lt;/code&gt; 인수를 생략 텍스트는 사전 이름 검색 &lt;code&gt;unaccent&lt;/code&gt; 과 같은 스키마에 나타나는 &lt;code&gt;unaccent()&lt;/code&gt; 자체가 사용하는 기능.</target>
        </trans-unit>
        <trans-unit id="8e92f2cba043fc31ab92cbc203c691c2c492c8d7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;expression&lt;/code&gt; is row-valued, then &lt;code&gt;IS NULL&lt;/code&gt; is true when the row expression itself is null or when all the row's fields are null, while &lt;code&gt;IS NOT NULL&lt;/code&gt; is true when the row expression itself is non-null and all the row's fields are non-null. Because of this behavior, &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; do not always return inverse results for row-valued expressions; in particular, a row-valued expression that contains both null and non-null fields will return false for both tests. In some cases, it may be preferable to write &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; or &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt;, which will simply check whether the overall row value is null without any additional tests on the row fields.</source>
          <target state="translated">는 IF &lt;code&gt;expression&lt;/code&gt; 행 값이며, 다음 &lt;code&gt;IS NULL&lt;/code&gt; 행 표현 자체가 null 인 경우 또는 사실이지만 모든 행의 필드는 null의 경우 &lt;code&gt;IS NOT NULL&lt;/code&gt; 는 행 식 자체가 null이며 모든 행의 필드는 때 사실이다 널이 아닙니다. 이 동작으로 인해 &lt;code&gt;IS NULL&lt;/code&gt; 및 &lt;code&gt;IS NOT NULL&lt;/code&gt; 이 행 값 식에 대해 항상 역 결과를 반환하지는 않습니다. 특히 null 필드와 null이 아닌 필드를 모두 포함하는 행 값 식은 두 테스트 모두에 대해 false를 반환합니다. 경우에 따라 &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; 또는 &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt; 을 쓰는 것이 바람직 할 수 있습니다.행 필드에 대한 추가 테스트없이 전체 행 값이 null인지 간단히 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8a9d5cf7323804505a12a8a728eb4b811573a010" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system-username&lt;/code&gt; field starts with a slash (&lt;code&gt;/&lt;/code&gt;), the remainder of the field is treated as a regular expression. (See &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;Section 9.7.3.1&lt;/a&gt; for details of PostgreSQL's regular expression syntax.) The regular expression can include a single capture, or parenthesized subexpression, which can then be referenced in the &lt;code&gt;database-username&lt;/code&gt; field as &lt;code&gt;\1&lt;/code&gt; (backslash-one). This allows the mapping of multiple user names in a single line, which is particularly useful for simple syntax substitutions. For example, these entries</source>
          <target state="translated">는 IF &lt;code&gt;system-username&lt;/code&gt; 필드에 슬래시 (시작 &lt;code&gt;/&lt;/code&gt; ), 필드의 나머지는 정규 표현식으로 처리됩니다. ( PostgreSQL의 정규 표현식 구문에 대한 자세한 내용 &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;은 9.7.3.1 절을&lt;/a&gt; 참조하십시오 .) 정규 표현식에는 단일 캡처 또는 괄호로 묶인 하위 표현식이 포함될 수 있으며, &lt;code&gt;database-username&lt;/code&gt; 필드에서 &lt;code&gt;\1&lt;/code&gt; (백 슬래시-원) 으로 참조 될 수 있습니다 . 이를 통해 한 줄에 여러 사용자 이름을 매핑 할 수 있으며 이는 간단한 구문 대체에 특히 유용합니다. 예를 들어, 이러한 항목</target>
        </trans-unit>
        <trans-unit id="482a504d7c75e328098ffe22edcbb1378a3f6faa" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;values&lt;/code&gt;&lt;/em&gt; arrays are specified, an &lt;em&gt;armor header&lt;/em&gt; is added to the armored format for each key/value pair. Both arrays must be single-dimensional, and they must be of the same length. The keys and values cannot contain any non-ASCII characters.</source>
          <target state="translated">상기 중간 &lt;em&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/em&gt; 와 &lt;em&gt; &lt;code&gt;values&lt;/code&gt; &lt;/em&gt; 어레이가 지정되며, &lt;em&gt;아머 헤더는&lt;/em&gt; 각각의 키 / 값 쌍에 대한 장갑 형태에 추가된다. 두 배열은 모두 1 차원이어야하며 길이는 같아야합니다. 키와 값은 ASCII가 아닌 문자를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7327537568cbffaa257fef6fbd8b81996eaef858" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; argument is specified and has the &lt;code&gt;true&lt;/code&gt; value, these functions suppress the same errors as the &lt;code&gt;@?&lt;/code&gt; and &lt;code&gt;@@&lt;/code&gt; operators.</source>
          <target state="translated">는 IF &lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt; 인수가 지정이되어 &lt;code&gt;true&lt;/code&gt; 가치를,이 기능은 같은 오류 억제 &lt;code&gt;@?&lt;/code&gt; 그리고 &lt;code&gt;@@&lt;/code&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="ceede46190dd53d528fe2b583d1ccadb6cf588b2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; argument is specified, it provides an object containing named variables to be substituted into a &lt;code&gt;jsonpath&lt;/code&gt; expression.</source>
          <target state="translated">경우] &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 인수가 지정되며, 그것은라는 변수를 포함하는 객체에 대입 될 제공 &lt;code&gt;jsonpath&lt;/code&gt; 의 발현.</target>
        </trans-unit>
        <trans-unit id="a173c623ff67d4c364c8db6dbe6ae6c5c5c1b9dd" translate="yes" xml:space="preserve">
          <source>If the S2K key is to be used directly, then only S2K settings will be put into the session key packet. Otherwise the session key will be encrypted with the S2K key and put into the session key packet.</source>
          <target state="translated">S2K 키를 직접 사용하는 경우 S2K 설정 만 세션 키 패킷에 저장됩니다. 그렇지 않으면 세션 키가 S2K 키로 암호화되어 세션 키 패킷에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cd334923ca7f6a61f76d5cc9802fe6d4f79f8249" translate="yes" xml:space="preserve">
          <source>If the Serializable transaction isolation level is used for all writes and for all reads which need a consistent view of the data, no other effort is required to ensure consistency. Software from other environments which is written to use serializable transactions to ensure consistency should &amp;ldquo;just work&amp;rdquo; in this regard in PostgreSQL.</source>
          <target state="translated">일관된 데이터보기가 필요한 모든 쓰기 및 모든 읽기에 대해 직렬화 가능 트랜잭션 격리 레벨을 사용하는 경우 일관성을 유지하기 위해 다른 노력이 필요하지 않습니다. 일관성을 보장하기 위해 직렬화 가능 트랜잭션을 사용하도록 작성된 다른 환경의 소프트웨어는 PostgreSQL에서 이와 관련하여 &quot;작동&quot;해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3a85d8941e78b61fa6dfe5e13735d5c695c638d" translate="yes" xml:space="preserve">
          <source>If the argument begins with &lt;code&gt;|&lt;/code&gt;, then the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">인수가 &lt;code&gt;|&lt;/code&gt; 그런 다음 행의 전체 나머지 를 실행 &lt;code&gt;command&lt;/code&gt; 으로 사용하고 변수 보간이나 백 따옴표 확장을 수행하지 않습니다. 나머지 줄은 문자 그대로 쉘로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c120a5d678ef79b9fdd905518c659ce62747d5d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;json_strip_nulls&lt;/code&gt; contains duplicate field names in any object, the result could be semantically somewhat different, depending on the order in which they occur. This is not an issue for &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; since &lt;code&gt;jsonb&lt;/code&gt; values never have duplicate object field names.</source>
          <target state="translated">&lt;code&gt;json_strip_nulls&lt;/code&gt; 에 대한 인수가 임의의 오브젝트에 중복 필드 이름을 포함하는 경우, 결과의 순서에 따라 결과적으로 의미가 약간 다를 수 있습니다. 이에 대한 문제가되지 않습니다 &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; 때문에 &lt;code&gt;jsonb&lt;/code&gt; 의 값이 결코 중복 된 개체 필드 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="da41d6b70ef3eb6374e923e599dfca0a856e8010" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ALL&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ALL&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no false comparison result is obtained, the result of &lt;code&gt;ALL&lt;/code&gt; will be null, not true (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">배열 표현식이 널 배열을 생성하면 &lt;code&gt;ALL&lt;/code&gt; 의 결과는 널이됩니다. 왼쪽 표현식이 널을 생성하는 경우 &lt;code&gt;ALL&lt;/code&gt; 의 결과 는 일반적으로 널입니다 (엄격하지 않은 비교 연산자는 다른 결과를 생성 할 수 있음). 또한 오른쪽 배열에 null 요소가 포함되어 있고 잘못된 비교 결과가 없으면 &lt;code&gt;ALL&lt;/code&gt; 의 결과는 true가 아닌 null이됩니다 (엄격한 비교 연산자를 가정 할 때). 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ae942e08ca17c439fb984995bab2b3f4a2ace54c" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ANY&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ANY&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no true comparison result is obtained, the result of &lt;code&gt;ANY&lt;/code&gt; will be null, not false (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">배열 표현식이 널 배열을 생성하면 &lt;code&gt;ANY&lt;/code&gt; 의 결과는 널이됩니다. 왼쪽 표현식이 널을 생성하는 경우 &lt;code&gt;ANY&lt;/code&gt; 의 결과 는 일반적으로 널입니다 (엄격하지 않은 비교 연산자는 다른 결과를 생성 할 수 있음). 또한 오른쪽 배열에 null 요소가 포함되어 있고 실제 비교 결과를 얻지 못하면 &lt;code&gt;ANY&lt;/code&gt; 의 결과는 false가 아닌 null이됩니다 (엄격한 비교 연산자를 가정 할 때). 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f33f8fbf54f510b9f47b6952f447521e0e216bb8" translate="yes" xml:space="preserve">
          <source>If the backup process monitors and ensures that all WAL segment files required for the backup are successfully archived then the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter (which defaults to true) can be set to false to have &lt;code&gt;pg_stop_backup&lt;/code&gt; return as soon as the stop backup record is written to the WAL. By default, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait until all WAL has been archived, which can take some time. This option must be used with caution: if WAL archiving is not monitored correctly then the backup might not include all of the WAL files and will therefore be incomplete and not able to be restored.</source>
          <target state="translated">백업 프로세스가 백업에 필요한 모든 WAL 세그먼트 파일을 모니터링하고 성공적으로 아카이브 한 경우 &lt;code&gt;wait_for_archive&lt;/code&gt; 매개 변수 (기본값은 true)는 백업 중지 백업 레코드가 WAL에 기록되는 즉시 &lt;code&gt;pg_stop_backup&lt;/code&gt; 이 리턴 되도록 false로 설정 될 수 있습니다. . 기본적으로 &lt;code&gt;pg_stop_backup&lt;/code&gt; 은 모든 WAL이 보관 될 때까지 대기하며 시간이 다소 걸릴 수 있습니다. 이 옵션은주의해서 사용해야합니다. WAL 보관이 올바르게 모니터링되지 않으면 백업에 모든 WAL 파일이 포함되지 않을 수 있으므로 불완전하여 복원 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c791af34bd6ddf53748d0f35d1bff063098edcb5" translate="yes" xml:space="preserve">
          <source>If the backup was taken with file checksums enabled, the following keys will be present:</source>
          <target state="translated">파일 체크섬이 활성화 된 상태에서 백업을 수행 한 경우 다음 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="38dbd4a01a3f520d833ada1c842bc701e68bca1c" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; then it can be invoked implicitly when assigning a value to a column of the target data type. For example, supposing that &lt;code&gt;foo.f1&lt;/code&gt; is a column of type &lt;code&gt;text&lt;/code&gt;, then:</source>
          <target state="translated">캐스트가 &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; 로 표시 되면 대상 데이터 유형의 열에 값을 지정할 때 내재적으로 호출 될 수 있습니다. 예를 들어, &lt;code&gt;foo.f1&lt;/code&gt; 이 &lt;code&gt;text&lt;/code&gt; 유형의 열 이라고 가정하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a854dcb7d27eca4b3717769b2da567eec36f84ca" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; then it can be invoked implicitly in any context, whether assignment or internally in an expression. (We generally use the term &lt;em&gt;implicit cast&lt;/em&gt; to describe this kind of cast.) For example, consider this query:</source>
          <target state="translated">캐스트가 &lt;code&gt;AS IMPLICIT&lt;/code&gt; 로 표시되면 할당이든 내부적 으로든 표현식에서 내재적으로 호출 할 수 있습니다. 일반적으로 이러한 유형의 캐스트를 설명하기 위해 &lt;em&gt;암시 적 캐스트&lt;/em&gt; 라는 용어를 사용합니다 . 예를 들어 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="61cd1b288599e699dce186b3244d616ce3ce9c86" translate="yes" xml:space="preserve">
          <source>If the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for a column, and a data entry has that same value, &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; will omit it from the data file. This keeps the data representation compact.</source>
          <target state="translated">카탈로그의 &lt;code&gt;.h&lt;/code&gt; 파일이 열의 기본값을 지정하고 데이터 항목의 값이 동일한 경우 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 은 데이터 파일에서이를 생략합니다. 이렇게하면 데이터 표현이 간결 해집니다.</target>
        </trans-unit>
        <trans-unit id="e457eb8bdc9731b8c1605b478c130085944e5e2a" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. (However, if the server's character set is not &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server will still check that incoming data is valid for that encoding; so the net effect is as though the client character set were the same as the server's.) Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">클라이언트 문자 집합이 &lt;code&gt;SQL_ASCII&lt;/code&gt; 로 정의 된 경우 서버의 문자 집합에 관계없이 인코딩 변환이 비활성화됩니다. (그러나 서버의 문자 집합이 &lt;code&gt;SQL_ASCII&lt;/code&gt; 가 아닌 경우 서버는 들어오는 데이터가 해당 인코딩에 유효한지 계속 확인합니다. 따라서 클라이언트 문자 집합이 서버의 문자 집합과 동일한 것처럼 최종 효과가 나타납니다.) 서버와 마찬가지로 , &lt;code&gt;SQL_ASCII&lt;/code&gt; 의 사용은 모든 ASCII 데이터로 작업하지 않는 한 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bae7f3745b8c55d9daa52727f8674ef5381e42f5" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">클라이언트 문자 세트가 &lt;code&gt;SQL_ASCII&lt;/code&gt; 로 정의 되면 서버의 문자 세트에 관계없이 인코딩 변환이 사용 불가능합니다. 서버 와 마찬가지로 모든 ASCII 데이터로 작업하지 않는 한 &lt;code&gt;SQL_ASCII&lt;/code&gt; 를 사용하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c4deed9a95ca57073b155e9cb8a0f5097708705" translate="yes" xml:space="preserve">
          <source>If the command is written as &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; and the foreign table does not exist, no error is thrown. A notice is issued in this case.</source>
          <target state="translated">명령이 &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; 로 작성되고 외부 테이블이 존재하지 않으면 오류가 발생하지 않습니다. 이 경우 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="63d051a50066f7b8f700301bed696001489f1857" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written and the database will proceed to start up anyway. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), the database will not proceed with startup.</source>
          <target state="translated">명령이 0이 아닌 종료 상태를 리턴하면 경고 로그 메시지가 작성되고 데이터베이스는 어쨌든 시작됩니다. 예외는 명령에 의해 신호 또는 오류 (예 : 명령을 찾을 수 없음)로 종료 된 경우 데이터베이스가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="557bcc8e46db9e939ccd6eb079fcf5557fc3e866" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), a fatal error will be raised.</source>
          <target state="translated">명령이 0이 아닌 종료 상태를 리턴하면 경고 로그 메시지가 작성됩니다. 단, 신호로 인해 명령이 종료되거나 쉘에 의해 오류 (예 : 명령을 찾을 수 없음)가 있으면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a74eec2662a9cc1d1ed60748980c12a4bf53d33" translate="yes" xml:space="preserve">
          <source>If the commands themselves contain &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;COMMIT&lt;/code&gt;, or &lt;code&gt;ROLLBACK&lt;/code&gt;, this option will not have the desired effects. Also, if an individual command cannot be executed inside a transaction block, specifying this option will cause the whole transaction to fail.</source>
          <target state="translated">명령 자체에 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;COMMIT&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK&lt;/code&gt; 이 포함 된 경우이 옵션은 원하는 효과를 갖지 않습니다. 또한 트랜잭션 블록 내에서 개별 명령을 실행할 수없는 경우이 옵션을 지정하면 전체 트랜잭션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="02b4ea2a996ab5d0d7b4386241306a8c9bd92e8f" translate="yes" xml:space="preserve">
          <source>If the compared values are of a collatable data type, the appropriate collation OID will be passed to the comparison support function, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">비교 된 값이 배열 가능한 데이터 유형 인 경우 표준 &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; 메커니즘을 사용하여 적절한 데이터 정렬 OID가 비교 지원 함수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="29c5e362afd4a1ac0e7c03190fce4c0374d970bb" translate="yes" xml:space="preserve">
          <source>If the compress method is lossy for leaf entries, the operator class cannot support index-only scans, and must not define a &lt;code&gt;fetch&lt;/code&gt; function.</source>
          <target state="translated">리프 항목에 대해 compress 메소드가 손실 된 경우 연산자 클래스는 색인 전용 스캔을 지원할 수 없으며 &lt;code&gt;fetch&lt;/code&gt; 함수를 정의하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="f7447741114d4403590357da345ba571953f8d76" translate="yes" xml:space="preserve">
          <source>If the configuration file contains syntax errors or invalid parameter names, the server will not attempt to apply any settings from it, and therefore all the &lt;code&gt;applied&lt;/code&gt; fields will read as false. In such a case there will be one or more rows with non-null &lt;code&gt;error&lt;/code&gt; fields indicating the problem(s). Otherwise, individual settings will be applied if possible. If an individual setting cannot be applied (e.g., invalid value, or the setting cannot be changed after server start) it will have an appropriate message in the &lt;code&gt;error&lt;/code&gt; field. Another way that an entry might have &lt;code&gt;applied&lt;/code&gt; = false is that it is overridden by a later entry for the same parameter name; this case is not considered an error so nothing appears in the &lt;code&gt;error&lt;/code&gt; field.</source>
          <target state="translated">구성 파일에 구문 오류 또는 유효하지 않은 매개 변수 이름이 포함 된 경우 서버는 해당 설정을 적용하려고 시도하지 않으므로 &lt;code&gt;applied&lt;/code&gt; 모든 필드가 false로 읽 힙니다. 이러한 경우 문제를 나타내는 널이 아닌 &lt;code&gt;error&lt;/code&gt; 필드 가있는 하나 이상의 행이 있습니다 . 그렇지 않으면 가능하면 개별 설정이 적용됩니다. 개별 설정을 적용 할 수없는 경우 (예 : 유효하지 않은 값 또는 서버 시작 후 설정을 변경할 수없는 경우) &lt;code&gt;error&lt;/code&gt; 필드 에 적절한 메시지가 표시 됩니다. 항목이 &lt;code&gt;applied&lt;/code&gt; 되었을 수있는 다른 방법 = false는 동일한 매개 변수 이름에 대한 이후 항목으로 대체됩니다. 아무것도 나타나지 않습니다이 경우는 오류로 간주되지 않는 &lt;code&gt;error&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="6846426f89420f86ff7e1053a00d20ad214d1c83" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is &lt;code&gt;off&lt;/code&gt;, then PostgreSQL recognizes backslash escapes in both regular and escape string constants. However, as of PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt;, meaning that backslash escapes are recognized only in escape string constants. This behavior is more standards-compliant, but might break applications which rely on the historical behavior, where backslash escapes were always recognized. As a workaround, you can set this parameter to &lt;code&gt;off&lt;/code&gt;, but it is better to migrate away from using backslash escapes. If you need to use a backslash escape to represent a special character, write the string constant with an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">구성 매개 변수 &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; 가 &lt;code&gt;off&lt;/code&gt; 이면 PostgreSQL은 일반 및 이스케이프 문자열 상수에서 백 슬래시 이스케이프를 인식합니다. 그러나 PostgreSQL 9.1에서 기본값은 &lt;code&gt;on&lt;/code&gt; 이므로 백 슬래시 이스케이프는 이스케이프 문자열 상수에서만 인식됩니다. 이 동작은보다 표준을 준수하지만 백 슬래시 이스케이프가 항상 인식 된 이전 동작에 의존하는 응용 프로그램을 중단 할 수 있습니다. 이 문제를 해결하려면이 매개 변수를 &lt;code&gt;off&lt;/code&gt; 로 설정할 수 있지만 백 슬래시 이스케이프를 사용하지 않는 것이 좋습니다. 특수 문자를 나타 내기 위해 백 슬래시 이스케이프를 사용해야하는 경우 문자열 상수를 &lt;code&gt;E&lt;/code&gt; 로 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e2bc2b10438374418a16365e82e01c5a0e70ba5" translate="yes" xml:space="preserve">
          <source>If the connection could not be made for any reason (e.g., insufficient privileges, server is not running on the targeted host, etc.), psql will return an error and terminate.</source>
          <target state="translated">어떤 이유로 든 연결할 수없는 경우 (예 : 권한 부족, 대상 호스트에서 서버가 실행되지 않는 등) psql은 오류를 반환하고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="02930b22f9d6ca1f7733ab529d9a22a91b3fe5c0" translate="yes" xml:space="preserve">
          <source>If the connection is lost, or if it cannot be initially established, with a non-fatal error, pg_receivewal will retry the connection indefinitely, and reestablish streaming as soon as possible. To avoid this behavior, use the &lt;code&gt;-n&lt;/code&gt; parameter.</source>
          <target state="translated">치명적이지 않은 오류로 연결이 끊어 지거나 초기에 설정할 수없는 경우 pg_receivewal은 연결을 무기한 재 시도하고 가능한 빨리 스트리밍을 다시 설정합니다. 이 동작을 피하려면 &lt;code&gt;-n&lt;/code&gt; 매개 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e7cb7e5b7e9cfa96c974efa30e7317e321f657f" translate="yes" xml:space="preserve">
          <source>If the conversion of a particular character is not possible &amp;mdash; suppose you chose &lt;code&gt;EUC_JP&lt;/code&gt; for the server and &lt;code&gt;LATIN1&lt;/code&gt; for the client, and some Japanese characters are returned that do not have a representation in &lt;code&gt;LATIN1&lt;/code&gt; &amp;mdash; an error is reported.</source>
          <target state="translated">특정 문자의 변환이 불가능한 경우 - 사용자가 선택한 가정 &lt;code&gt;EUC_JP&lt;/code&gt; 를 서버와 대한 &lt;code&gt;LATIN1&lt;/code&gt; 클라이언트에 대한, 일부 일본어 문자에서 표현하지 않아도 반환되는 &lt;code&gt;LATIN1&lt;/code&gt; 를 - 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="5a6f84dd517ea12fd77c796a6737968d24f658ee" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is described instead.</source>
          <target state="translated">현재 쿼리 버퍼가 비어 있으면 가장 최근에 보낸 쿼리가 대신 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="2c57feb4352b9d0e5fa18cf7867721a0200da9c9" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead.</source>
          <target state="translated">현재 쿼리 버퍼가 비어 있으면 가장 최근에 보낸 쿼리가 대신 다시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b8dce5eee9d2655efdc5121439aeb8029c6a8bb6" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without an argument is essentially equivalent to a semicolon. A &lt;code&gt;\g&lt;/code&gt; with argument is a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command.</source>
          <target state="translated">현재 쿼리 버퍼가 비어 있으면 가장 최근에 보낸 쿼리가 대신 다시 실행됩니다. 그 동작을 제외하고 , 인수가없는 &lt;code&gt;\g&lt;/code&gt; 는 기본적으로 세미콜론과 같습니다. 인수가 있는 &lt;code&gt;\g&lt;/code&gt; 는 &lt;code&gt;\o&lt;/code&gt; 명령 의 &quot;일회성&quot;대안 입니다.</target>
        </trans-unit>
        <trans-unit id="8f856d88c69c6abc126b1520b07a26de33c6da81" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without any arguments is essentially equivalent to a semicolon. With arguments, &lt;code&gt;\g&lt;/code&gt; provides a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command, and additionally allows one-shot adjustments of the output formatting options normally set by &lt;code&gt;\pset&lt;/code&gt;.</source>
          <target state="translated">현재 쿼리 버퍼가 비어 있으면 가장 최근에 보낸 쿼리가 대신 다시 실행됩니다. 그 동작을 제외하고 인수가없는 &lt;code&gt;\g&lt;/code&gt; 는 본질적으로 세미콜론과 동일합니다. 인수를 사용하면 &lt;code&gt;\g&lt;/code&gt; 는 &lt;code&gt;\o&lt;/code&gt; 명령 에 대한 &quot;일회성&quot;대안을 제공 하고 추가로 일반적으로 &lt;code&gt;\pset&lt;/code&gt; 의해 설정되는 출력 형식화 옵션의 일회성 조정을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="9c1be77262ade382bd3daec36a4b4f5dfa260c3f" translate="yes" xml:space="preserve">
          <source>If the current table output format is unaligned, it is switched to aligned. If it is not unaligned, it is set to unaligned. This command is kept for backwards compatibility. See &lt;code&gt;\pset&lt;/code&gt; for a more general solution.</source>
          <target state="translated">현재 테이블 출력 형식이 정렬되지 않은 경우 정렬로 전환됩니다. 정렬되지 않은 경우 정렬되지 않은 것으로 설정됩니다. 이 명령은 이전 버전과의 호환성을 위해 유지됩니다. 보다 일반적인 해결책 은 &lt;code&gt;\pset&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6fb10bfb27f2916d0fe2c64c42424fe0e7351c4" translate="yes" xml:space="preserve">
          <source>If the cursor's query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;, then returned rows are locked at the time they are first fetched, in the same way as for a regular &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command with these options. In addition, the returned rows will be the most up-to-date versions; therefore these options provide the equivalent of what the SQL standard calls a &amp;ldquo;sensitive cursor&amp;rdquo;. (Specifying &lt;code&gt;INSENSITIVE&lt;/code&gt; together with &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt; is an error.)</source>
          <target state="translated">커서 조회에 &lt;code&gt;FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;FOR SHARE&lt;/code&gt; 가 포함 된 경우, 이러한 옵션 을 사용하는 일반 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 명령과 같은 방식으로 리턴 된 행이 처음 페치 될 때 잠 깁니다 . 또한 반환 된 행은 최신 버전이됩니다. 따라서이 옵션은 SQL 표준이 &quot;민감한 커서&quot;라고 부르는 것과 동일합니다. &lt;code&gt;FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;FOR SHARE&lt;/code&gt; 와 함께 &lt;code&gt;INSENSITIVE&lt;/code&gt; 를 지정 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="41b7137b15f53bed5b5687626dcf24e407280bf1" translate="yes" xml:space="preserve">
          <source>If the data directory allows group read access then certificate files may need to be located outside of the data directory in order to conform to the security requirements outlined above. Generally, group access is enabled to allow an unprivileged user to backup the database, and in that case the backup software will not be able to read the certificate files and will likely error.</source>
          <target state="translated">데이터 디렉토리가 그룹 읽기 액세스를 허용하는 경우, 위에서 설명한 보안 요구 사항을 준수하기 위해 인증서 파일이 데이터 디렉토리 외부에 위치해야합니다. 일반적으로 권한이없는 사용자가 데이터베이스를 백업 할 수 있도록 그룹 액세스가 가능하며,이 경우 백업 소프트웨어는 인증서 파일을 읽을 수 없으며 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a675fdbbcb3f3826a4060560a5255875fb5f5fae" translate="yes" xml:space="preserve">
          <source>If the database crashes during the risk window between an asynchronous commit and the writing of the transaction's WAL records, then changes made during that transaction &lt;em&gt;will&lt;/em&gt; be lost. The duration of the risk window is limited because a background process (the &amp;ldquo;WAL writer&amp;rdquo;) flushes unwritten WAL records to disk every &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; milliseconds. The actual maximum duration of the risk window is three times &lt;code&gt;wal_writer_delay&lt;/code&gt; because the WAL writer is designed to favor writing whole pages at a time during busy periods.</source>
          <target state="translated">데이터베이스가 비동기 커밋 트랜잭션의 WAL 기록의 작성과 위험 기간 동안 충돌하는 경우 트랜잭션이 중 다음 만든 변경됩니다 &lt;em&gt;것이다&lt;/em&gt; 손실. 백그라운드 프로세스 ( &quot;WAL 기록기&quot;)가 기록되지 않은 WAL 레코드를 &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; 밀리 초 마다 디스크로 플러시하기 때문에 위험 기간이 제한 됩니다. WAL 기록기는 사용량이 많은 기간 동안 한 번에 전체 페이지를 작성하도록 설계 되었기 때문에 위험 윈도우의 실제 최대 기간은 &lt;code&gt;wal_writer_delay&lt;/code&gt; 의 3 배 입니다.</target>
        </trans-unit>
        <trans-unit id="74cf7d60a58d8b38555b75db3e52ebabab25c716" translate="yes" xml:space="preserve">
          <source>If the distance function returns &lt;code&gt;*recheck = true&lt;/code&gt; for any leaf node, the original ordering operator's return type must be &lt;code&gt;float8&lt;/code&gt; or &lt;code&gt;float4&lt;/code&gt;, and the distance function's result values must be comparable to those of the original ordering operator, since the executor will sort using both distance function results and recalculated ordering-operator results. Otherwise, the distance function's result values can be any finite &lt;code&gt;float8&lt;/code&gt; values, so long as the relative order of the result values matches the order returned by the ordering operator. (Infinity and minus infinity are used internally to handle cases such as nulls, so it is not recommended that &lt;code&gt;distance&lt;/code&gt; functions return these values.)</source>
          <target state="translated">리프 노드에 대해 거리 함수가 &lt;code&gt;*recheck = true&lt;/code&gt; 를 반환 하면 원래 순서 연산자의 반환 유형은 &lt;code&gt;float8&lt;/code&gt; 또는 &lt;code&gt;float4&lt;/code&gt; 여야하며 거리 함수의 결과 값은 원래 순서 연산자의 결과 값과 비교할 수 있어야합니다. 거리 함수 결과 및 재 계산 된 순서 연산자 결과. 그렇지 않으면 결과 값 의 상대 순서가 순서 연산자가 반환 한 순서와 일치하는 한 거리 함수의 결과 값은 임의의 &lt;code&gt;float8&lt;/code&gt; 값일 수 있습니다 . (무한 및 마이너스 무한대는 내부적으로 null과 같은 경우를 처리하는 데 사용되므로 &lt;code&gt;distance&lt;/code&gt; 함수가 이러한 값을 반환 하지 않는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="ad60be7600e8f04e894b95d59df12f985784fcd2" translate="yes" xml:space="preserve">
          <source>If the expression for any column is not of the correct data type, automatic type conversion will be attempted.</source>
          <target state="translated">컬럼의 표현식이 올바른 데이터 유형이 아닌 경우 자동 유형 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="fd093b6fb186aee51925fae308b6305eb633a2c9" translate="yes" xml:space="preserve">
          <source>If the extension specifies a &lt;code&gt;schema&lt;/code&gt; parameter in its control file, then that schema cannot be overridden with a &lt;code&gt;SCHEMA&lt;/code&gt; clause. Normally, an error will be raised if a &lt;code&gt;SCHEMA&lt;/code&gt; clause is given and it conflicts with the extension's &lt;code&gt;schema&lt;/code&gt; parameter. However, if the &lt;code&gt;CASCADE&lt;/code&gt; clause is also given, then &lt;code&gt;schema_name&lt;/code&gt; is ignored when it conflicts. The given &lt;code&gt;schema_name&lt;/code&gt; will be used for installation of any needed extensions that do not specify &lt;code&gt;schema&lt;/code&gt; in their control files.</source>
          <target state="translated">확장 이 제어 파일에 &lt;code&gt;schema&lt;/code&gt; 매개 변수를 지정하면 해당 스키마를 &lt;code&gt;SCHEMA&lt;/code&gt; 절로 대체 할 수 없습니다 . 일반적으로 &lt;code&gt;SCHEMA&lt;/code&gt; 절이 제공되고 확장의 &lt;code&gt;schema&lt;/code&gt; 매개 변수 와 충돌 하면 오류가 발생합니다 . 그러나 &lt;code&gt;CASCADE&lt;/code&gt; 절도 제공되면 &lt;code&gt;schema_name&lt;/code&gt; 은 충돌 할 때 무시됩니다. 주어진 &lt;code&gt;schema_name&lt;/code&gt; 은 제어 파일에 &lt;code&gt;schema&lt;/code&gt; 를 지정하지 않는 필요한 확장을 설치하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4e9fcc86b43f21a64730501e9eaf321852f905e" translate="yes" xml:space="preserve">
          <source>If the file name is not an absolute path, it is taken as relative to the directory containing the referencing configuration file. Inclusions can be nested.</source>
          <target state="translated">파일 이름이 절대 경로가 아닌 경우 참조 구성 파일이 포함 된 디렉토리를 기준으로합니다. 포함은 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="932910bcbd5980a518e91a591612aedc56d65e69" translate="yes" xml:space="preserve">
          <source>If the final function is declared &amp;ldquo;strict&amp;rdquo;, then it will not be called when the ending state value is null; instead a null result will be returned automatically. (Of course this is just the normal behavior of strict functions.) In any case the final function has the option of returning a null value. For example, the final function for &lt;code&gt;avg&lt;/code&gt; returns null when it sees there were zero input rows.</source>
          <target state="translated">최종 함수가 &quot;strict&quot;로 선언되면 종료 상태 값이 null 일 때 호출되지 않습니다. 대신 null 결과가 자동으로 반환됩니다. (물론 이것은 엄격한 함수의 정상적인 동작입니다.) 어쨌든 최종 함수에는 null 값을 반환하는 옵션이 있습니다. 예를 들어, 입력 행이없는 경우 &lt;code&gt;avg&lt;/code&gt; 의 최종 함수 는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ca5420e4e4f7f8c6273c3bc64bbb9997a4e67c8" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written (nor is the first argument).</source>
          <target state="translated">첫 번째 인수가 인용되지 않은 &lt;code&gt;-n&lt;/code&gt; 이면 후행 개행이 기록되지 않습니다 (첫 번째 인수도 아닙니다).</target>
        </trans-unit>
        <trans-unit id="6a7650c2a7562a29717aee3a080c7db1eba72918" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written.</source>
          <target state="translated">첫 번째 인수가 인용되지 않은 &lt;code&gt;-n&lt;/code&gt; 이면 후행 줄 바꿈이 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62fe782183ded831fa81846fd49b8967105614ff" translate="yes" xml:space="preserve">
          <source>If the function has been defined as returning the &lt;code&gt;record&lt;/code&gt; data type, then an alias or the key word &lt;code&gt;AS&lt;/code&gt; must be present, followed by a column definition list in the form &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt;. The column definition list must match the actual number and types of columns returned by the function.</source>
          <target state="translated">함수가 &lt;code&gt;record&lt;/code&gt; 데이터 유형 을 리턴하는 것으로 정의 된 경우 별명 또는 키워드 &lt;code&gt;AS&lt;/code&gt; 가 있어야하고 양식 &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt; 형식의 열 정의 목록이 있어야합니다 . 열 정의 목록은 함수가 반환 한 실제 열 수와 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbc510e12f6154bfb8e0fdb71a70e5f4d7892b1d" translate="yes" xml:space="preserve">
          <source>If the function name is unique in its schema, it can be referred to without an argument list:</source>
          <target state="translated">함수 이름이 스키마에서 고유 한 경우 인수 목록없이 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02e65f28de3d6ebb00042e2e3e922f9485dd13f2" translate="yes" xml:space="preserve">
          <source>If the index AM wishes to cache data across successive index insertions within a SQL statement, it can allocate space in &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; and store a pointer to the data in &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (which will be NULL initially).</source>
          <target state="translated">인덱스 AM은 SQL 문 내에서 연속 인덱스 삽입에 걸쳐 데이터를 캐시에 원하는 경우에 공간을 할당 할 수 &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; 와의 데이터에 대한 포인터를 저장 &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (처음에 NULL이됩니다).</target>
        </trans-unit>
        <trans-unit id="152cfa54f1f6aaa3c6f3e246889a7fbd92291904" translate="yes" xml:space="preserve">
          <source>If the index marked &lt;code&gt;INVALID&lt;/code&gt; is suffixed &lt;code&gt;ccnew&lt;/code&gt;, then it corresponds to the transient index created during the concurrent operation, and the recommended recovery method is to drop it using &lt;code&gt;DROP INDEX&lt;/code&gt;, then attempt &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; again. If the invalid index is instead suffixed &lt;code&gt;ccold&lt;/code&gt;, it corresponds to the original index which could not be dropped; the recommended recovery method is to just drop said index, since the rebuild proper has been successful.</source>
          <target state="translated">&lt;code&gt;INVALID&lt;/code&gt; 로 표시된 인덱스 가 &lt;code&gt;ccnew&lt;/code&gt; 접미사 인 경우 동시 작업 중에 생성 된 임시 인덱스에 해당하며 권장되는 복구 방법은 &lt;code&gt;DROP INDEX&lt;/code&gt; 를 사용하여 삭제 한 다음 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 를 다시 시도하는 것 입니다. 유효하지 않은 색인이 대신 &lt;code&gt;ccold&lt;/code&gt; 접미사가 붙은 경우 삭제할 수없는 원래 색인에 해당합니다. 권장되는 복구 방법은 적절한 재 구축이 성공 했으므로 해당 인덱스를 삭제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="65ff53fe7f3af3df2bf9787931d50cb513ad0685" translate="yes" xml:space="preserve">
          <source>If the index stores the original indexed data values (and not some lossy representation of them), it is useful to support &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt;, in which the index returns the actual data not just the TID of the heap tuple. This will only avoid I/O if the visibility map shows that the TID is on an all-visible page; else the heap tuple must be visited anyway to check MVCC visibility. But that is no concern of the access method's.</source>
          <target state="translated">인덱스가 원래 인덱싱 된 데이터 값을 저장하고 손실이없는 경우 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;인덱스 전용 스캔&lt;/a&gt; 을 지원 하면 인덱스 튜플의 TID뿐만 아니라 실제 데이터 만 반환합니다. 가시성 맵에 TID가 모든 표시 가능한 페이지에있는 것으로 표시되는 경우에만 I / O를 피합니다. 그렇지 않으면 MVCC 가시성을 확인하기 위해 힙 튜플을 방문해야합니다. 그러나 그것은 액세스 방법에 대한 걱정이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b10149280f25e55a72b1c339ba61c4a0b943ec93" translate="yes" xml:space="preserve">
          <source>If the index supports &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt; (i.e., &lt;code&gt;amcanreturn&lt;/code&gt; returns true for it), then on success the AM must also check &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt;, and if that is true it must return the originally indexed data for the index entry. The data can be returned in the form of an &lt;code&gt;IndexTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt;; or in the form of a &lt;code&gt;HeapTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt;. (The latter format should be used when reconstructing data that might possibly not fit into an &lt;code&gt;IndexTuple&lt;/code&gt;.) In either case, management of the data referenced by the pointer is the access method's responsibility. The data must remain good at least until the next &lt;code&gt;amgettuple&lt;/code&gt;, &lt;code&gt;amrescan&lt;/code&gt;, or &lt;code&gt;amendscan&lt;/code&gt; call for the scan.</source>
          <target state="translated">인덱스가 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;인덱스 전용 스캔을&lt;/a&gt; 지원하는 경우 (예 : &lt;code&gt;amcanreturn&lt;/code&gt; 이이를 리턴하면) 성공시 AM은 &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt; 도 확인해야 하며 , true 인 경우 인덱스 항목에 대해 원래 인덱스 된 데이터를 리턴해야합니다. 데이터는 &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt; 에 저장된 &lt;code&gt;IndexTuple&lt;/code&gt; 포인터 의 형식 으로 튜플 디스크립터 &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt; ; 또는 tuple 디스크립터 &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt; 와 함께 &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt; 에 저장된 &lt;code&gt;HeapTuple&lt;/code&gt; 포인터 형태로 . 후자의 형식은 &lt;code&gt;IndexTuple&lt;/code&gt; 에 맞지 않는 데이터를 재구성 할 때 사용해야합니다..) 어느 경우 든 포인터가 참조하는 데이터 관리는 액세스 방법의 책임입니다. 다음 &lt;code&gt;amgettuple&lt;/code&gt; , &lt;code&gt;amrescan&lt;/code&gt; 또는 &lt;code&gt;amendscan&lt;/code&gt; 이 스캔을 호출 할 때까지 데이터는 양호하게 유지되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5145a56a8fb3d00823c8f07c0c1ff1ea7857b4" translate="yes" xml:space="preserve">
          <source>If the indexed column is of a collatable data type, the index collation will be passed to all the support methods, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">인덱싱 된 열이 배열 가능한 데이터 형식 인 경우 표준 &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; 메커니즘을 사용하여 인덱스 데이터 정렬이 모든 지원 방법으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d0af38ac011e98a3b87862ced9f4ed1d8303136" translate="yes" xml:space="preserve">
          <source>If the installation process completes without error, you can now start the server normally.</source>
          <target state="translated">설치 프로세스가 오류없이 완료되면 이제 서버를 정상적으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="801fad259abb36ce1c379ee710b758c893dc848e" translate="yes" xml:space="preserve">
          <source>If the internal structure of &lt;code&gt;box&lt;/code&gt; were an array of four &lt;code&gt;float4&lt;/code&gt; elements, we might instead use:</source>
          <target state="translated">&lt;code&gt;box&lt;/code&gt; 의 내부 구조가 4 개의 &lt;code&gt;float4&lt;/code&gt; 요소 의 배열 인 경우 대신 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0cb06bd991e3803ab381ac962733573ec921a97" translate="yes" xml:space="preserve">
          <source>If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed.</source>
          <target state="translated">분리 레벨, 읽기 / 쓰기 모드 또는 지연 가능 모드가 지정된 경우 새 트랜잭션은 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 이 실행 된 것처럼 이러한 특성을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="635140eb0238daad7904445c051be894be230f98" translate="yes" xml:space="preserve">
          <source>If the item to retrieve is an element of an array, you have to unnest this array using the &lt;code&gt;[*]&lt;/code&gt; operator. For example, the following path will return location coordinates for all the available track segments:</source>
          <target state="translated">검색 할 항목이 배열의 요소 인 경우 &lt;code&gt;[*]&lt;/code&gt; 연산자를 사용하여이 배열을 풀어야합니다 . 예를 들어 다음 경로는 사용 가능한 모든 트랙 세그먼트에 대한 위치 좌표를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97c86aa6976c29ec1d54566b16ef172364cf2f75" translate="yes" xml:space="preserve">
          <source>If the key is larger than the hash block size it will first be hashed and the result will be used as key.</source>
          <target state="translated">키가 해시 블록 크기보다 크면 먼저 해시되고 결과는 키로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa8d866b0b556edb093be4c9a0ab389395324da" translate="yes" xml:space="preserve">
          <source>If the last path item is an object key, it will be created if it is absent and given the new value. If the last path item is an array index, if it is positive the item to set is found by counting from the left, and if negative by counting from the right - &lt;code&gt;-1&lt;/code&gt; designates the rightmost element, and so on. If the item is out of the range -array_length .. array_length -1, and create_missing is true, the new value is added at the beginning of the array if the item is negative, and at the end of the array if it is positive.</source>
          <target state="translated">마지막 경로 항목이 객체 키인 경우 해당 키가 없으면 새 키가 제공됩니다. 마지막 경로 항목이 배열 인덱스 인 경우 양수인 경우 왼쪽부터 계산하여 설정할 항목을 찾고, 오른쪽부터 계산하여 음수 인 경우 &lt;code&gt;-1&lt;/code&gt; 지정하면 가장 오른쪽에있는 요소가 지정됩니다. 항목이 -array_length .. array_length -1 범위를 벗어나 있고 create_missing이 true 인 경우, 항목이 음수이면 배열의 시작 부분에 양수이면 배열의 끝에 새 값이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2188ba6147e78aaca8d5a46e0dc7277dd7c3324b" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;n&lt;/code&gt; (&amp;ldquo;nested&amp;rdquo;) is used, or a pattern is specified, then non-root partitioned relations are included, and a column is shown displaying the parent of each partitioned relation.</source>
          <target state="translated">수정 자 &lt;code&gt;n&lt;/code&gt; (&amp;ldquo;중첩&amp;rdquo;)을 사용하거나 패턴을 지정하면 루트가 아닌 분할 관계가 포함되고 각 분할 관계의 부모를 표시하는 열이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="954bfa7fec82935e3cdcd8281374d6651335948e" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt failed (wrong user name, access denied, etc.), the previous connection will only be kept if psql is in interactive mode. When executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">새 연결에 성공하면 이전 연결이 닫힙니다. 연결 시도가 실패한 경우 (잘못된 사용자 이름, 액세스 거부 등) psql이 대화식 모드 인 경우에만 이전 연결이 유지됩니다. 비 대화식 스크립트를 실행하면 처리가 즉시 오류와 함께 중지됩니다. 이 구별은 한편으로는 오타에 대한 사용자 편의성과 스크립트가 실수로 잘못된 데이터베이스에 작동하지 않는 안전 메커니즘으로 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="f53d72a1eae9ceb05fc2fcc17f8301adebb27e79" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt fails (wrong user name, access denied, etc.), the previous connection will be kept if psql is in interactive mode. But when executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">새 연결이 성공적으로 이루어지면 이전 연결이 닫힙니다. 연결 시도가 실패하면 (잘못된 사용자 이름, 액세스 거부 등) psql이 대화 형 모드이면 이전 연결이 유지됩니다. 그러나 비대화 형 스크립트를 실행하면 오류와 함께 처리가 즉시 중지됩니다. 이 구별은 한편으로는 오타에 대한 사용자 편의성과 다른 한편으로는 스크립트가 실수로 잘못된 데이터베이스에서 작동하지 않는 안전 메커니즘으로 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="2a5e26aea388ddd76a8f217c381769165be706df" translate="yes" xml:space="preserve">
          <source>If the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; about constraints on the foreign table.)</source>
          <target state="translated">새 파티션이 외부 테이블 인 경우 외부 테이블의 모든 행이 파티션 제한 조건을 준수하는지 확인하기 위해 아무것도 수행되지 않습니다. 외부 테이블의 제한 조건에 대해서는 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f277321bdd9057205b2810a53bafd6facd91f266" translate="yes" xml:space="preserve">
          <source>If the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a valid &lt;code&gt;CHECK&lt;/code&gt; constraint to the table that allows only rows satisfying the desired partition constraint before running this command. The &lt;code&gt;CHECK&lt;/code&gt; constraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not accept &lt;code&gt;NULL&lt;/code&gt; values. If attaching a list partition that will not accept &lt;code&gt;NULL&lt;/code&gt; values, also add &lt;code&gt;NOT NULL&lt;/code&gt; constraint to the partition key column, unless it's an expression.</source>
          <target state="translated">새 파티션이 일반 테이블 인 경우 테이블의 기존 행이 파티션 제한 조건을 위반하지 않는지 확인하기 위해 전체 테이블 스캔이 수행됩니다. 이 명령을 실행하기 전에 원하는 파티션 제한 조건을 만족시키는 행만 허용하는 테이블에 유효한 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건을 추가하여이 스캔을 피할 수 있습니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 테이블이 파티션의 제약 조건을 검증하기 위해 스캔 할 필요가 없다는 것을 결정하는 데 사용됩니다. 그러나 파티션 키 중 하나가 표현식이고 파티션이 &lt;code&gt;NULL&lt;/code&gt; 값을 허용하지 않는 경우에는 작동하지 않습니다 . &lt;code&gt;NULL&lt;/code&gt; 값을 허용하지 않는 목록 파티션을 첨부하는 경우 &lt;code&gt;NOT NULL&lt;/code&gt; 도 추가하십시오. 식이 아닌 경우 파티션 키 열에 대한 제약 조건.</target>
        </trans-unit>
        <trans-unit id="48a04ec2659d2ed3b669f8d3fed6c4aa6cc05212" translate="yes" xml:space="preserve">
          <source>If the new value is inconsistent with the tuple prefix, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgSplitTuple&lt;/code&gt;. This action moves all the existing nodes into a new lower-level inner tuple, and replaces the existing inner tuple with a tuple having a single downlink pointing to the new lower-level inner tuple. Set &lt;code&gt;prefixHasPrefix&lt;/code&gt; to indicate whether the new upper tuple should have a prefix, and if so set &lt;code&gt;prefixPrefixDatum&lt;/code&gt; to the prefix value. This new prefix value must be sufficiently less restrictive than the original to accept the new value to be indexed. Set &lt;code&gt;prefixNNodes&lt;/code&gt; to the number of nodes needed in the new tuple, and set &lt;code&gt;prefixNodeLabels&lt;/code&gt; to a palloc'd array holding their labels, or to NULL if node labels are not required. Note that the total size of the new upper tuple must be no more than the total size of the tuple it is replacing; this constrains the lengths of the new prefix and new labels. Set &lt;code&gt;childNodeN&lt;/code&gt; to the index (from zero) of the node that will downlink to the new lower-level inner tuple. Set &lt;code&gt;postfixHasPrefix&lt;/code&gt; to indicate whether the new lower-level inner tuple should have a prefix, and if so set &lt;code&gt;postfixPrefixDatum&lt;/code&gt; to the prefix value. The combination of these two prefixes and the downlink node's label (if any) must have the same meaning as the original prefix, because there is no opportunity to alter the node labels that are moved to the new lower-level tuple, nor to change any child index entries. After the node has been split, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the replacement inner tuple. That call may return an &lt;code&gt;spgAddNode&lt;/code&gt; result, if no suitable node was created by the &lt;code&gt;spgSplitTuple&lt;/code&gt; action. Eventually &lt;code&gt;choose&lt;/code&gt; must return &lt;code&gt;spgMatchNode&lt;/code&gt; to allow the insertion to descend to the next level.</source>
          <target state="translated">새 값이 튜플 접두사와 일치하지 않으면 &lt;code&gt;resultType&lt;/code&gt; 을 &lt;code&gt;spgSplitTuple&lt;/code&gt; 로 설정 하십시오 . 이 조치는 기존의 모든 노드를 새로운 하위 레벨 내부 튜플로 이동하고 기존 내부 튜플을 새 하위 레벨 내부 튜플을 가리키는 단일 다운 링크가있는 튜플로 대체합니다. 설정 &lt;code&gt;prefixHasPrefix&lt;/code&gt; 은 이렇게 설정하면 새로운 상위 튜플이 접두사를해야하는지 여부를 표시하고하는 &lt;code&gt;prefixPrefixDatum&lt;/code&gt; 을 접두사 값. 이 새로운 접두어 값은 색인화 할 새 값을 허용하기 위해 원본보다 충분히 덜 제한적이어야합니다. &lt;code&gt;prefixNNodes&lt;/code&gt; 를 새 튜플에 필요한 노드 수로 설정하고 prefixNodeLabels 를 설정 &lt;code&gt;prefixNodeLabels&lt;/code&gt; 레이블을 보유한 palloc의 배열 또는 노드 레이블이 필요하지 않은 경우 NULL 새 상단 튜플의 총 크기는 교체하는 튜플의 총 크기를 초과하지 않아야합니다. 새 접두사와 새 레이블의 길이를 제한합니다. 집합 &lt;code&gt;childNodeN&lt;/code&gt; 새로운 하위 레벨 내측 튜플 다운 링크 것이다 노드 (제로)에서의 인덱스이다. &lt;code&gt;postfixHasPrefix&lt;/code&gt; 를 설정 하여 새로운 하위 레벨 내부 튜플에 접두사가 있어야하는지 여부를 표시하고, 그렇다면 &lt;code&gt;postfixPrefixDatum&lt;/code&gt; 을 설정 하십시오.접두사 값으로. 이 두 접두사와 다운 링크 노드의 레이블 (있는 경우)의 조합은 원래 접두사와 동일한 의미를 가져야합니다. 새로운 하위 수준 튜플로 이동 한 노드 레이블을 변경하거나 다른 레이블을 변경할 수있는 기회가 없기 때문입니다. 하위 색인 항목. 노드가 분할 된 후 대체 내부 튜플과 함께 &lt;code&gt;choose&lt;/code&gt; 함수가 다시 호출됩니다. &lt;code&gt;spgSplitTuple&lt;/code&gt; 작업으로 적합한 노드를 만들지 않은 경우 해당 호출은 &lt;code&gt;spgAddNode&lt;/code&gt; 결과를 반환 할 수 있습니다 . 결국 &lt;code&gt;choose&lt;/code&gt; 반환해야합니다 &lt;code&gt;spgMatchNode&lt;/code&gt; 를 다음 단계로 내려 삽입을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad207ddb2eaf025fe9a90fd7f853c4606a19762" translate="yes" xml:space="preserve">
          <source>If the new value matches one of the existing child nodes, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgMatchNode&lt;/code&gt;. Set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) of that node in the node array. Set &lt;code&gt;levelAdd&lt;/code&gt; to the increment in &lt;code&gt;level&lt;/code&gt; caused by descending through that node, or leave it as zero if the operator class does not use levels. Set &lt;code&gt;restDatum&lt;/code&gt; to equal &lt;code&gt;leafDatum&lt;/code&gt; if the operator class does not modify datums from one level to the next, or otherwise set it to the modified value to be used as &lt;code&gt;leafDatum&lt;/code&gt; at the next level.</source>
          <target state="translated">새 값이 기존 하위 노드 중 하나와 일치하면 &lt;code&gt;resultType&lt;/code&gt; 을 &lt;code&gt;spgMatchNode&lt;/code&gt; 로 설정 하십시오 . &lt;code&gt;nodeN&lt;/code&gt; 을 노드 배열에서 해당 노드의 인덱스 (0부터)로 설정하십시오 . 해당 노드를 통해 내림차순으로 발생하는 &lt;code&gt;level&lt;/code&gt; 증분으로 &lt;code&gt;levelAdd&lt;/code&gt; 를 설정 하거나 연산자 클래스가 레벨을 사용하지 않는 경우 0으로 두십시오. 집합 &lt;code&gt;restDatum&lt;/code&gt; 은 동일하기 &lt;code&gt;leafDatum&lt;/code&gt; 를 조작 클래스가 한 레벨에서 다음 레벨 데이텀을 수정하지 않는 경우, 또는 달리로서 사용되는 변형 된 값으로 설정 &lt;code&gt;leafDatum&lt;/code&gt; 다음 레벨.</target>
        </trans-unit>
        <trans-unit id="b192c266d3e1a4a0032d805a8345acd4fec22c20" translate="yes" xml:space="preserve">
          <source>If the non-unknown inputs are not all of the same type category, fail.</source>
          <target state="translated">알 수없는 입력이 모두 같은 유형 범주가 아닌 경우 실패합니다.</target>
        </trans-unit>
        <trans-unit id="21b9de4f5d381ca1caadda7c1730c20093d98952" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a colon (&lt;code&gt;:&lt;/code&gt;), this is a time string. Include all subsequent digits and colons.</source>
          <target state="translated">(숫자 토큰에 콜론이 포함되어있는 경우 &lt;code&gt;:&lt;/code&gt; ),이 시간 문자열입니다. 모든 후속 숫자와 콜론을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="31a587270029792d925fa073ce1717b2b1a5ee50" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a dash (&lt;code&gt;-&lt;/code&gt;), slash (&lt;code&gt;/&lt;/code&gt;), or two or more dots (&lt;code&gt;.&lt;/code&gt;), this is a date string which might have a text month. If a date token has already been seen, it is instead interpreted as a time zone name (e.g., &lt;code&gt;America/New_York&lt;/code&gt;).</source>
          <target state="translated">숫자 토큰에 대시 ( &lt;code&gt;-&lt;/code&gt; ), 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 또는 둘 이상의 점 ( &lt;code&gt;.&lt;/code&gt; )이 포함 된 경우 텍스트 월이있는 날짜 문자열입니다. 날짜 토큰이 이미 표시된 경우 시간대 이름 (예 : &lt;code&gt;America/New_York&lt;/code&gt; )으로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ee076bf4dbead171f4fb25426abca0b1193f6e2" translate="yes" xml:space="preserve">
          <source>If the operating system provides support for using multiple locales within a single program (&lt;code&gt;newlocale&lt;/code&gt; and related functions), or if support for ICU is configured, then when a database cluster is initialized, &lt;code&gt;initdb&lt;/code&gt; populates the system catalog &lt;code&gt;pg_collation&lt;/code&gt; with collations based on all the locales it finds in the operating system at the time.</source>
          <target state="translated">운영 체제가 단일 프로그램 내에서 여러 로케일을 사용하여 지원 (제공하는 경우 &lt;code&gt;newlocale&lt;/code&gt; 및 관련 기능)을 ICU에 대한 지원이 구성된 경우, 또는 다음, 데이터베이스 클러스터가 초기화 될 때 &lt;code&gt;initdb&lt;/code&gt; 를 채우는 시스템 카탈로그 &lt;code&gt;pg_collation&lt;/code&gt; 을 로케일 모든 기반으로 데이터 정렬 당시 운영 체제에서 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ac5399d971a7de7c9b73abf76e58c0bf1b2aae3d" translate="yes" xml:space="preserve">
          <source>If the operation does not complete within the timeout (see option &lt;code&gt;-t&lt;/code&gt;), then &lt;code&gt;pg_ctl&lt;/code&gt; exits with a nonzero exit status. But note that the operation might continue in the background and eventually succeed.</source>
          <target state="translated">작업이 시간 초과 내에 완료되지 않으면 (옵션 &lt;code&gt;-t&lt;/code&gt; 참조 ) &lt;code&gt;pg_ctl&lt;/code&gt; 은 0이 아닌 종료 상태로 종료됩니다. 그러나 작업이 백그라운드에서 계속되고 결국 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ab0f7eed5fb08edbafe519f61a48bda6216b85" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;NO CYCLE&lt;/code&gt; key word is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, the old cycle behavior will be maintained.</source>
          <target state="translated">선택적 &lt;code&gt;NO CYCLE&lt;/code&gt; 키워드를 지정 하면 시퀀스가 ​​최대 값에 도달 한 후 &lt;code&gt;nextval&lt;/code&gt; 을 호출 하면 오류가 반환됩니다. &lt;code&gt;CYCLE&lt;/code&gt; 또는 &lt;code&gt;NO CYCLE&lt;/code&gt; 을 지정 하지 않으면 이전주기 동작이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc933189fc3de8b16aa112ce975759af1f0b257" translate="yes" xml:space="preserve">
          <source>If the optional Boolean parameter &lt;code&gt;collatable&lt;/code&gt; is true, column definitions and expressions of the type may carry collation information through use of the &lt;code&gt;COLLATE&lt;/code&gt; clause. It is up to the implementations of the functions operating on the type to actually make use of the collation information; this does not happen automatically merely by marking the type collatable.</source>
          <target state="translated">선택적 부울 매개 변수 &lt;code&gt;collatable&lt;/code&gt; 이 true 인 경우, 컬럼 정의 및 유형의 표현식은 &lt;code&gt;COLLATE&lt;/code&gt; 절 을 사용하여 데이터 정렬 정보를 전달할 수 있습니다 . 데이터 정렬 정보를 실제로 사용하는 것은 형식에서 작동하는 함수의 구현에 달려 있습니다. 이것은 단순히 유형을 collatable로 표시하여 자동으로 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdfeb01a261949b7092b2cbd814cde7a65edc244" translate="yes" xml:space="preserve">
          <source>If the ordering of siblings of the same parent is important, include the &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter to specify which field to order siblings by. This field can be of any sortable data type. The output column list must include a final integer serial-number column, if and only if &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; is specified.</source>
          <target state="translated">동일한 상위의 형제 순서가 중요한 경우 형제 순서를 지정할 필드를 지정 하려면 &lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt; 매개 변수를 포함하십시오 . 이 필드는 정렬 가능한 데이터 유형이 될 수 있습니다. &lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt; 가 지정된 경우에만 출력 열 목록에 최종 정수 일련 번호 열이 포함되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="3ed5ab7fc15ec983050d9cabedbfee6290fa8126" translate="yes" xml:space="preserve">
          <source>If the output column is a composite (row) type, and the JSON value is a JSON object, the fields of the object are converted to columns of the output row type by recursive application of these rules.</source>
          <target state="translated">출력 열이 복합 (행) 유형이고 JSON 값이 JSON 객체 인 경우 이러한 규칙을 반복적으로 적용하여 객체의 필드가 출력 행 유형의 열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c25ff23eb72be3bfb20da8609dc04d07dc26b478" translate="yes" xml:space="preserve">
          <source>If the output column is of type &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;, the JSON value is just reproduced exactly.</source>
          <target state="translated">출력 열이 &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt; 유형 인 경우 JSON 값이 그대로 재현됩니다.</target>
        </trans-unit>
        <trans-unit id="50b9656459eac8e751efab8869d145ae99f220b8" translate="yes" xml:space="preserve">
          <source>If the password is encrypted with SCRAM-SHA-256, it has the format:</source>
          <target state="translated">암호가 SCRAM-SHA-256으로 암호화 된 경우 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0f9a0afdced3c84c5a56565915bd16c67d24a36" translate="yes" xml:space="preserve">
          <source>If the path expression returns an empty node-set (typically, when it does not match) for a given row, the column will be set to &lt;code&gt;NULL&lt;/code&gt;, unless a &lt;code&gt;default_expression&lt;/code&gt; is specified; then the value resulting from evaluating that expression is used.</source>
          <target state="translated">주어진 행에 대해 경로 표현식이 빈 노드 세트 (일반적으로 일치하지 않는 경우)를 &lt;code&gt;NULL&lt;/code&gt; 하면 &lt;code&gt;default_expression&lt;/code&gt; 이 지정 되지 않은 한 열이 NULL 로 설정 됩니다. 그런 다음 해당 표현식을 평가 한 결과 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c947f55da31c1d5c1555adf98bd354dc366c84" translate="yes" xml:space="preserve">
          <source>If the primary is isolated from remaining standby servers you should fail over to the best candidate of those other remaining standby servers.</source>
          <target state="translated">기본 서버가 나머지 대기 서버와 분리되어 있으면 나머지 나머지 대기 서버 중 가장 적합한 후보로 장애 조치해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa67ddcebd2151f0eb68edd839f12d39677af43a" translate="yes" xml:space="preserve">
          <source>If the primary server fails and the standby server becomes the new primary, and then the old primary restarts, you must have a mechanism for informing the old primary that it is no longer the primary. This is sometimes known as STONITH (Shoot The Other Node In The Head), which is necessary to avoid situations where both systems think they are the primary, which will lead to confusion and ultimately data loss.</source>
          <target state="translated">기본 서버가 실패하고 대기 서버가 새 기본 서버가 된 후 이전 기본 서버가 다시 시작되면 이전 기본 서버에 더 이상 기본 서버가 아니라고 알리는 메커니즘이 있어야합니다. 이를 STONITH (Shoot The Other Node In The Head)라고도하며, 두 시스템이 모두 기본 시스템이라고 생각하는 상황을 피해야하므로 혼란과 궁극적으로 데이터 손실이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef10647b0698fbedd9383d4669217342caae5e0" translate="yes" xml:space="preserve">
          <source>If the primary server fails then the standby server should begin failover procedures.</source>
          <target state="translated">기본 서버에 장애가 발생하면 대기 서버는 장애 조치 절차를 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c8481924c3ba4dda86247ddbf4dd7292be6f835" translate="yes" xml:space="preserve">
          <source>If the private key is protected with a passphrase, the server will prompt for the passphrase and will not start until it has been entered. Using a passphrase by default disables the ability to change the server's SSL configuration without a server restart, but see &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload&lt;/a&gt;. Furthermore, passphrase-protected private keys cannot be used at all on Windows.</source>
          <target state="translated">개인 키가 암호로 보호되어 있으면 서버는 암호를 입력하라는 메시지가 표시되고 암호가 입력 될 때까지 시작되지 않습니다. 비밀번호 문구를 기본적으로 사용하면 서버를 다시 시작하지 않고도 서버의 SSL 구성을 변경하는 기능이 비활성화되지만 &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload를&lt;/a&gt; 참조하십시오 . 또한 암호 구로 보호 된 개인 키는 Windows에서 전혀 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="48f80ecbcca6b903e77ef9cdbab43d62afcd07ee" translate="yes" xml:space="preserve">
          <source>If the procedure has any output parameters, then a result row will be returned, containing the values of those parameters.</source>
          <target state="translated">프로 시저에 출력 매개 변수가 있으면 해당 매개 변수의 값을 포함하는 결과 행이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1290513a0720d5678ce9e07e692a24b4a58d5efd" translate="yes" xml:space="preserve">
          <source>If the products table is set up so that, say, &lt;code&gt;product_id&lt;/code&gt; is the primary key, then it would be enough to group by &lt;code&gt;product_id&lt;/code&gt; in the above example, since name and price would be &lt;em&gt;functionally dependent&lt;/em&gt; on the product ID, and so there would be no ambiguity about which name and price value to return for each product ID group.</source>
          <target state="translated">제품 테이블을 말하자면, 너무 설정되어있는 경우 &lt;code&gt;product_id&lt;/code&gt; 기본 키입니다, 그것은에 의해 그룹에 충분하다 &lt;code&gt;product_id&lt;/code&gt; 이름과 가격이 될 것이기 때문에, 위의 예에서 &lt;em&gt;기능적으로 의존하는&lt;/em&gt; 제품 ID에 등이있을 것 각 제품 ID 그룹에 대해 반환 할 이름과 가격 값에 대한 모호함이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e03a5d6f408539b4e08801b317931a00ecee94a9" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">쿼리에 창 기능이 포함 된 경우 ( &lt;a href=&quot;tutorial-window&quot;&gt;섹션 3.5&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;섹션 9.21&lt;/a&gt; 및 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;섹션 4.2.8&lt;/a&gt; 참조) 이러한 기능은 그룹화, 집계 및 &lt;code&gt;HAVING&lt;/code&gt; 필터링이 수행 된 후에 평가 됩니다. 즉, 쿼리가 집계, &lt;code&gt;GROUP BY&lt;/code&gt; 또는 &lt;code&gt;HAVING&lt;/code&gt; 을 사용하는 경우, 창 함수가 보는 행은 &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; 의 원래 테이블 행 대신 그룹 행 입니다.</target>
        </trans-unit>
        <trans-unit id="a48d893df2efd76b2d73680b987bd53b81b2adad" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">쿼리에 창 함수가 포함 된 경우 ( &lt;a href=&quot;tutorial-window&quot;&gt;섹션 3.5&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;섹션 9.22&lt;/a&gt; 및 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;섹션 4.2.8&lt;/a&gt; 참조) 이러한 함수는 그룹화, 집계 및 &lt;code&gt;HAVING&lt;/code&gt; 필터링이 수행 된 후에 평가 됩니다. 즉, 쿼리가 집계, &lt;code&gt;GROUP BY&lt;/code&gt; 또는 &lt;code&gt;HAVING&lt;/code&gt; 을 사용하는 경우 창 함수에 표시되는 행은 &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; 의 원래 테이블 행 대신 그룹 행 입니다.</target>
        </trans-unit>
        <trans-unit id="e83ebc0874906fce6a1aa2d76fdc21590b6b98b1" translate="yes" xml:space="preserve">
          <source>If the query fails or does not return one row, no variables are changed.</source>
          <target state="translated">쿼리가 실패하거나 하나의 행을 반환하지 않으면 변수가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="baf42f0acc3f09fcc4a0d0dd54cac78d65c286a5" translate="yes" xml:space="preserve">
          <source>If the query requires joining two or more relations, plans for joining relations are considered after all feasible plans have been found for scanning single relations. The three available join strategies are:</source>
          <target state="translated">쿼리에 둘 이상의 관계 가입이 필요한 경우 단일 관계를 검색하기위한 모든 실행 가능한 계획을 찾은 후 관계 가입 계획이 고려됩니다. 사용 가능한 세 가지 조인 전략은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e9c3a0d6f1b6d02143aa6739bb627c7730a051b" translate="yes" xml:space="preserve">
          <source>If the query uses fewer than &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; relations, a near-exhaustive search is conducted to find the best join sequence. The planner preferentially considers joins between any two relations for which there exist a corresponding join clause in the &lt;code&gt;WHERE&lt;/code&gt; qualification (i.e., for which a restriction like &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; exists). Join pairs with no join clause are considered only when there is no other choice, that is, a particular relation has no available join clauses to any other relation. All possible plans are generated for every join pair considered by the planner, and the one that is (estimated to be) the cheapest is chosen.</source>
          <target state="translated">쿼리가 &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; 관계 보다 적은 수를 사용 하는 경우 최상의 조인 시퀀스를 찾기 위해 거의 포괄적 인 검색이 수행됩니다. 플래너는 &lt;code&gt;WHERE&lt;/code&gt; 자격 에 해당하는 조인 절이 존재하는 두 관계 (즉, &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; 와 같은 제한 사항) 사이의 조인을 우선적으로 고려합니다 . 조인 절이없는 조인 쌍은 다른 선택이없는 경우에만, 즉 특정 관계에 다른 관계에 사용 가능한 조인 절이없는 경우에만 고려됩니다. 플래너가 고려한 모든 조인 쌍에 대해 가능한 모든 계획이 생성되며 가장 저렴한 계획이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb1910db08273fa485c28070ee9179ceccf3c73" translate="yes" xml:space="preserve">
          <source>If the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently.</source>
          <target state="translated">참조 된 열을 자주 변경하는 경우 외래 키 제약 조건과 관련된 참조 작업을보다 효율적으로 수행 할 수 있도록 참조 열에 인덱스를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2e6cbc38cc65944231eb0e20f1c30488fbd5652a" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;GRANT&lt;/code&gt; holds the required privileges indirectly via more than one role membership path, it is unspecified which containing role will be recorded as having done the grant. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;GRANT&lt;/code&gt; as.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; 를 실행하는 역할이 둘 이상의 역할 멤버쉽 경로를 통해 간접적으로 필요한 권한을 보유하는 경우 부여를 수행 한 것으로 기록 할 포함 역할이 지정되지 않습니다. 이러한 경우 &lt;code&gt;SET ROLE&lt;/code&gt; 을 사용 하여 &lt;code&gt;GRANT&lt;/code&gt; 를 수행하려는 특정 역할이되는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="24d9b80ef7c6da193a9a22333ae220223fd8b0ac" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;REVOKE&lt;/code&gt; holds privileges indirectly via more than one role membership path, it is unspecified which containing role will be used to perform the command. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;REVOKE&lt;/code&gt; as. Failure to do so might lead to revoking privileges other than the ones you intended, or not revoking anything at all.</source>
          <target state="translated">&lt;code&gt;REVOKE&lt;/code&gt; 를 실행하는 역할이 둘 이상의 역할 멤버쉽 경로를 통해 간접적으로 권한을 보유하는 경우 명령을 수행하는 데 사용할 포함 역할이 지정되지 않습니다. 이러한 경우 &lt;code&gt;SET ROLE&lt;/code&gt; 을 사용 하여 &lt;code&gt;REVOKE&lt;/code&gt; 를 수행하려는 특정 역할이되는 것이 가장 좋습니다 . 그렇게하지 않으면 의도 한 권한 이외의 권한을 취소하거나 전혀 권한을 취소하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9127d1a2bf0d40475f431a0daa0c09f299f8d847" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times from the same transaction with identical payload strings, the database server can decide to deliver a single notification only. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">동일한 페이로드 문자열을 가진 동일한 트랜잭션에서 동일한 채널 이름이 여러 번 시그널링되면 데이터베이스 서버는 단일 알림 만 전달하기로 결정할 수 있습니다. 반면, 고유 한 페이로드 문자열이있는 알림은 항상 고유 한 알림으로 전달됩니다. 마찬가지로 다른 거래의 알림은 하나의 알림으로 접히지 않습니다. &lt;code&gt;NOTIFY&lt;/code&gt; 는 이후의 중복 알림 인스턴스를 삭제하는 것을 제외하고 동일한 트랜잭션의 알림이 전송 된 순서대로 배달되도록합니다. 서로 다른 트랜잭션의 메시지가 트랜잭션이 커밋 된 순서대로 전달되는 것도 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="eed847052fd81f5459f65863d508269d92317295" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times with identical payload strings within the same transaction, only one instance of the notification event is delivered to listeners. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">동일한 채널 이름이 동일한 트랜잭션 내에서 동일한 페이로드 문자열로 여러 번 신호를 받으면 알림 이벤트의 한 인스턴스 만 리스너에게 전달됩니다. 반면에 고유 한 페이로드 문자열이있는 알림은 항상 고유 한 알림으로 전달됩니다. 마찬가지로 다른 트랜잭션의 알림은 하나의 알림으로 접히지 않습니다. 나중에 중복 알림 인스턴스를 삭제하는 경우를 제외하고 &lt;code&gt;NOTIFY&lt;/code&gt; 는 동일한 트랜잭션의 알림이 전송 된 순서대로 전달되도록 보장합니다. 또한 서로 다른 트랜잭션의 메시지가 트랜잭션이 커밋 된 순서대로 전달되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="25d36a41307a4d14aa722349a681e2f2a7b7eb16" translate="yes" xml:space="preserve">
          <source>If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.</source>
          <target state="translated">동일한 컬럼 이름이 둘 이상의 상위 테이블에 존재하는 경우 컬럼의 데이터 유형이 각 상위 테이블에서 일치하지 않으면 오류가보고됩니다. 충돌이 없으면 중복 된 열이 병합되어 새 테이블에서 단일 열을 형성합니다. 새 테이블의 열 이름 목록에 상속 된 열 이름이 포함 된 경우 데이터 유형도 상속 된 열과 일치해야하며 열 정의가 하나로 병합됩니다. 새 테이블이 열의 기본값을 명시 적으로 지정하면이 기본값은 상속 된 열 선언의 기본값을 대체합니다. 그렇지 않으면 열의 기본값을 지정하는 모든 상위가 모두 동일한 기본값을 지정해야합니다. 그렇지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="52777f31338be443c8719518578a441085b3242b" translate="yes" xml:space="preserve">
          <source>If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits. Then, if the number of digits to the left of the decimal point exceeds the declared precision minus the declared scale, an error is raised.</source>
          <target state="translated">저장할 값의 스케일이 선언 된 열 스케일보다 크면 시스템은 지정된 소수 자릿수로 값을 반올림합니다. 그런 다음 소수점 왼쪽의 자릿수가 선언 된 정밀도에서 선언 된 스케일을 뺀 값을 초과하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="02e920dfe841eca3127cd2deda87b1b0038bf35c" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple functions of identical argument types, only the one appearing earliest in the path is considered. Functions of different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">검색 경로에서 동일한 인수 유형의 여러 함수를 찾으면 경로에서 가장 먼저 나타나는 함수 만 고려됩니다. 다른 인수 유형의 함수는 검색 경로 위치에 관계없이 동일한 기반으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="846c48a5a96c2f9f31d852fa93bd025a2ae37209" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple operators with identical argument types, only the one appearing earliest in the path is considered. Operators with different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">검색 경로에서 동일한 인수 유형을 가진 여러 연산자를 찾으면 경로에서 가장 빠른 연산자 만 고려됩니다. 인수 유형이 다른 연산자는 검색 경로 위치에 관계없이 동일한 기반으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2b252638ccabfce3f83bfcd21c45870e0c2d0f5f" translate="yes" xml:space="preserve">
          <source>If the server encoding is not UTF-8, the Unicode code point identified by one of these escape sequences is converted to the actual server encoding; an error is reported if that's not possible.</source>
          <target state="translated">서버 인코딩이 UTF-8이 아닌 경우 이러한 이스케이프 시퀀스 중 하나로 식별되는 유니 코드 코드 포인트가 실제 서버 인코딩으로 변환됩니다. 불가능한 경우 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="d768fe47d52ad5a0b026e7ffb256e492ca409f05" translate="yes" xml:space="preserve">
          <source>If the server requires password authentication and a password is not available from other sources such as a &lt;code&gt;.pgpass&lt;/code&gt; file, psql will prompt for a password in any case. However, psql will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">서버에 암호 인증이 필요하고 &lt;code&gt;.pgpass&lt;/code&gt; 파일 과 같은 다른 소스에서 암호를 사용할 수없는 경우 psql은 어떤 경우에도 암호를 입력하라는 메시지를 표시합니다. 그러나 psql은 서버가 암호를 원한다는 것을 알아내는 연결 시도를 낭비합니다. 경우에 따라 추가 연결 시도를 피하기 위해 &lt;code&gt;-W&lt;/code&gt; 를 입력 할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c9b16d6feb91ed4af38eb28e886ad3416c7d722" translate="yes" xml:space="preserve">
          <source>If the session user is a database superuser, then a &lt;code&gt;#&lt;/code&gt;, otherwise a &lt;code&gt;&amp;gt;&lt;/code&gt;. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">세션 사용자가 데이터베이스 수퍼 유저 인 경우 &lt;code&gt;#&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 명령의 결과로 데이터베이스 세션 중에이 값의 확장이 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21d4dfd38c56bb0f6178a7f714085ed7cf4b3207" translate="yes" xml:space="preserve">
          <source>If the specified table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the specified table is a partition, an error will occur if one of the input rows violates the partition constraint.</source>
          <target state="translated">지정된 테이블이 파티션 된 테이블 인 경우 각 행은 해당 파티션으로 라우트되어 삽입됩니다. 지정된 테이블이 파티션 인 경우 입력 행 중 하나가 파티션 제한 조건을 위반하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b245f2cb2a99bf0f8cbbb31a4d055f1ead828c3" translate="yes" xml:space="preserve">
          <source>If the standard and predefined collations are not sufficient, users can create their own collation objects using the SQL command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;.</source>
          <target state="translated">표준 및 사전 정의 된 데이터 정렬이 충분하지 않은 경우 사용자는 SQL 명령 &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION을&lt;/a&gt; 사용하여 고유 한 데이터 정렬 오브젝트를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b1c783904332e93ac1d7897a9080ae105b88d5b" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to be primary during backup, the backup fails.</source>
          <target state="translated">백업 중에 대기가 기본으로 승격되면 백업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae6c2a2f4f7ec1ece5d1140f847b0d38361211e2" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to the master during online backup, the backup fails.</source>
          <target state="translated">온라인 백업 중에 대기가 마스터로 승격되면 백업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="170908acbec1d5cb0f56e23febc172e3426f4e91" translate="yes" xml:space="preserve">
          <source>If the standby server fails then no failover need take place. If the standby server can be restarted, even some time later, then the recovery process can also be restarted immediately, taking advantage of restartable recovery. If the standby server cannot be restarted, then a full new standby server instance should be created.</source>
          <target state="translated">대기 서버에 장애가 발생하면 장애 조치가 필요하지 않습니다. 대기 서버를 나중에 다시 시작할 수 있으면 나중에 다시 시작 가능한 복구를 이용하여 복구 프로세스를 즉시 다시 시작할 수도 있습니다. 대기 서버를 다시 시작할 수 없으면 완전히 새로운 대기 서버 인스턴스를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="05b0c76b7db4a1477637a64b2d47050fce69810a" translate="yes" xml:space="preserve">
          <source>If the standby servers are still running, stop them now using the above instructions.</source>
          <target state="translated">대기 서버가 여전히 실행중인 경우 위의 지시 사항을 사용하여 대기 서버를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="6049edf261150bf348be6f8bb80514f565d9d8f9" translate="yes" xml:space="preserve">
          <source>If the state transition function is declared &amp;ldquo;strict&amp;rdquo;, then it cannot be called with null inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is null, then at the first row with all-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at each subsequent row with all-nonnull input values. This is handy for implementing aggregates like &lt;code&gt;max&lt;/code&gt;. Note that this behavior is only available when &lt;code&gt;state_data_type&lt;/code&gt; is the same as the first &lt;code&gt;arg_data_type&lt;/code&gt;. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function.</source>
          <target state="translated">상태 전이 함수가 &quot;엄격&quot;으로 선언되면 널 입력으로 호출 할 수 없습니다. 이러한 전환 기능을 사용하면 집계 실행은 다음과 같이 작동합니다. 널 입력 값이있는 행은 무시됩니다 (함수가 호출되지 않고 이전 상태 값이 유지됨). 초기 상태 값이 널인 경우, 첫 번째 행에서 모두 널이 아닌 입력 값으로, 첫 번째 인수 값이 상태 값을 대체하고, 이후의 각 행에서 모든 널이 아닌 입력 값으로 전이 함수가 호출됩니다. &lt;code&gt;max&lt;/code&gt; 와 같은 집계를 구현하는 데 편리합니다 . 이 동작은 &lt;code&gt;state_data_type&lt;/code&gt; 이 첫 번째 &lt;code&gt;arg_data_type&lt;/code&gt; 과 동일한 경우에만 사용할 수 있습니다.. 이러한 유형이 다르면 null이 아닌 초기 조건을 제공하거나 엄격하지 않은 전환 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6d30b33fa764833043e35a291ca75c71eaca53e" translate="yes" xml:space="preserve">
          <source>If the state transition function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null state values for itself. This allows the aggregate author to have full control over the aggregate's handling of null values.</source>
          <target state="translated">상태 전이 함수가 엄격하지 않으면 각 입력 행에서 무조건 호출되며 널 입력 및 널 상태 값 자체를 처리해야합니다. 이렇게하면 집계 작성자가 집계의 null 값 처리를 완전히 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="244bd5a12cbdca1f48ebb0a6febfdca5da532447" translate="yes" xml:space="preserve">
          <source>If the string is declared to be of type &lt;code&gt;varchar&lt;/code&gt;, as might be the case if it comes from a table, then the parser will try to convert it to become &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">문자열이 테이블에서 온 것처럼 &lt;code&gt;varchar&lt;/code&gt; 유형으로 선언 되면 파서는 &lt;code&gt;text&lt;/code&gt; 로 변환하려고 시도 합니다 .</target>
        </trans-unit>
        <trans-unit id="2dcfcecbf90e5089ccafce06b4b0be1f8904c94c" translate="yes" xml:space="preserve">
          <source>If the subtype is considered to have discrete rather than continuous values, the &lt;code&gt;CREATE TYPE&lt;/code&gt; command should specify a &lt;code&gt;canonical&lt;/code&gt; function. The canonicalization function takes an input range value, and must return an equivalent range value that may have different bounds and formatting. The canonical output for two ranges that represent the same set of values, for example the integer ranges &lt;code&gt;[1, 7]&lt;/code&gt; and &lt;code&gt;[1, 8)&lt;/code&gt;, must be identical. It doesn't matter which representation you choose to be the canonical one, so long as two equivalent values with different formattings are always mapped to the same value with the same formatting. In addition to adjusting the inclusive/exclusive bounds format, a canonicalization function might round off boundary values, in case the desired step size is larger than what the subtype is capable of storing. For instance, a range type over &lt;code&gt;timestamp&lt;/code&gt; could be defined to have a step size of an hour, in which case the canonicalization function would need to round off bounds that weren't a multiple of an hour, or perhaps throw an error instead.</source>
          <target state="translated">부속 유형이 연속 값이 아닌 개별 값을 갖는 것으로 간주되는 경우 &lt;code&gt;CREATE TYPE&lt;/code&gt; 명령은 &lt;code&gt;canonical&lt;/code&gt; 함수를 지정해야 합니다. 정규화 함수는 입력 범위 값을 사용하며 범위와 형식이 다른 등가 범위 값을 반환해야합니다. 동일한 값 세트를 나타내는 두 범위의 표준 출력 (예 : 정수 범위 &lt;code&gt;[1, 7]&lt;/code&gt; 및 &lt;code&gt;[1, 8)&lt;/code&gt; 동일해야합니다. 형식이 다른 두 개의 동등한 값이 항상 같은 형식의 동일한 값에 맵핑되는 한 표준 표현으로 선택한 표현은 중요하지 않습니다. 포함 / 제외 바운드 형식을 조정하는 것 외에도 표준 함수는 원하는 단계 크기가 하위 유형이 저장할 수있는 것보다 큰 경우 경계 값을 반올림 할 수 있습니다. 예를 들어 &lt;code&gt;timestamp&lt;/code&gt; 따른 범위 유형 은 단계 크기가 1 시간으로 정의 될 수 있으며,이 경우 정규화 함수는 1 시간의 배수가 아닌 범위를 반올림하거나 대신 오류를 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="417d560f70c3f29f36f195f746fd3ca8a01a2c42" translate="yes" xml:space="preserve">
          <source>If the system administrator for the server's machine cannot be trusted, it is necessary for the client to encrypt the data; this way, unencrypted data never appears on the database server. Data is encrypted on the client before being sent to the server, and database results have to be decrypted on the client before being used.</source>
          <target state="translated">서버 시스템의 시스템 관리자를 신뢰할 수없는 경우 클라이언트가 데이터를 암호화해야합니다. 이런 식으로 암호화되지 않은 데이터는 데이터베이스 서버에 나타나지 않습니다. 데이터는 서버로 전송되기 전에 클라이언트에서 암호화되며 데이터베이스 결과는 사용하기 전에 클라이언트에서 해독해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b3f5f95bd715dfe464206f06b66a58f56802c50" translate="yes" xml:space="preserve">
          <source>If the table as a whole is exclusive-locked by someone else, &lt;code&gt;pgrowlocks&lt;/code&gt; will be blocked.</source>
          <target state="translated">테이블 전체가 다른 사람에 의해 독점적으로 잠긴 경우 &lt;code&gt;pgrowlocks&lt;/code&gt; 가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="b50348338bc555a4ab7d45126bfb8dabd633e20f" translate="yes" xml:space="preserve">
          <source>If the table being analyzed has one or more children, &lt;code&gt;ANALYZE&lt;/code&gt; will gather statistics twice: once on the rows of the parent table only, and a second time on the rows of the parent table with all of its children. This second set of statistics is needed when planning queries that traverse the entire inheritance tree. The autovacuum daemon, however, will only consider inserts or updates on the parent table itself when deciding whether to trigger an automatic analyze for that table. If that table is rarely inserted into or updated, the inheritance statistics will not be up to date unless you run &lt;code&gt;ANALYZE&lt;/code&gt; manually.</source>
          <target state="translated">분석중인 테이블에 하나 이상의 하위가있는 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 는 통계를 두 번 수집합니다. 상위 테이블의 행에서만 한 번, 모든 하위 테이블이있는 상위 테이블의 행에서 두 번째입니다. 이 두 번째 통계 세트는 전체 상속 트리를 통과하는 쿼리를 계획 할 때 필요합니다. 그러나 autovacuum 데몬은 해당 테이블에 대한 자동 분석을 트리거할지 여부를 결정할 때 상위 테이블 자체에 대한 삽입 또는 업데이트 만 고려합니다. 해당 테이블이 거의 삽입되거나 업데이트되지 않으면 &lt;code&gt;ANALYZE&lt;/code&gt; 를 수동으로 실행하지 않으면 상속 통계가 최신 상태가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b96d4460f730e99ad2f5da4b8998b3d561a93287" translate="yes" xml:space="preserve">
          <source>If the table being analyzed is completely empty, &lt;code&gt;ANALYZE&lt;/code&gt; will not record new statistics for that table. Any existing statistics will be retained.</source>
          <target state="translated">분석중인 테이블이 완전히 비어 있으면 &lt;code&gt;ANALYZE&lt;/code&gt; 는 해당 테이블에 대한 새 통계를 기록하지 않습니다. 기존 통계는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="52dc63831209a4c7bb3899cf1fb2ddca1ef42d36" translate="yes" xml:space="preserve">
          <source>If the table is being scanned using an index, this is the OID of the index being used; otherwise, it is zero.</source>
          <target state="translated">인덱스를 사용하여 테이블을 스캔하는 경우 사용중인 인덱스의 OID입니다. 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="dd0fa542dae151db3f272ca82de26368bfb9872f" translate="yes" xml:space="preserve">
          <source>If the target directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar contents will be written to standard output, suitable for piping to (for example) gzip. This is only allowed if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">대상 디렉토리가 &lt;code&gt;-&lt;/code&gt; (대시) 로 지정 되면 tar 내용이 표준 출력에 기록되며, 예를 들어 gzip으로 파이프하는 데 적합합니다. 이는 클러스터에 추가 테이블 스페이스가없고 WAL 스트리밍이 사용되지 않는 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9dfb9ffd9573334faeebb68db3d3df9b1f1f0724" translate="yes" xml:space="preserve">
          <source>If the token is an alphabetic string, match up with possible strings:</source>
          <target state="translated">토큰이 알파벳 문자열 인 경우 가능한 문자열과 일치 시키십시오.</target>
        </trans-unit>
        <trans-unit id="4f40be80901959628e05aea1c30e86478bf9dbb2" translate="yes" xml:space="preserve">
          <source>If the token is numeric only, then it is either a single field or an ISO 8601 concatenated date (e.g., &lt;code&gt;19990113&lt;/code&gt; for January 13, 1999) or time (e.g., &lt;code&gt;141516&lt;/code&gt; for 14:15:16).</source>
          <target state="translated">토큰이 숫자 인 경우 단일 필드 또는 ISO 8601 연결 날짜 (예 : &lt;code&gt;19990113&lt;/code&gt; 년 1 월 13 일의 경우 19990113 ) 또는 시간 (예 : &lt;code&gt;141516&lt;/code&gt; 경우 141516)입니다.</target>
        </trans-unit>
        <trans-unit id="003398a89e69d2198b671a9677907bb24f534582" translate="yes" xml:space="preserve">
          <source>If the token is three digits and a year has already been read, then interpret as day of year.</source>
          <target state="translated">토큰이 3 자리이고 1 년을 이미 읽은 경우 연도의 일자로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="d3ac616dded1315bedadfd2b91efaa1cf49163f8" translate="yes" xml:space="preserve">
          <source>If the token starts with a plus (&lt;code&gt;+&lt;/code&gt;) or minus (&lt;code&gt;-&lt;/code&gt;), then it is either a numeric time zone or a special field.</source>
          <target state="translated">토큰이 더하기 ( &lt;code&gt;+&lt;/code&gt; ) 또는 빼기 ( &lt;code&gt;-&lt;/code&gt; )로 시작하면 숫자 시간대 또는 특수 필드입니다.</target>
        </trans-unit>
        <trans-unit id="611739a43cf34a105bb65434365f4074cf8756df" translate="yes" xml:space="preserve">
          <source>If the transaction modified any run-time parameters with &lt;code&gt;SET&lt;/code&gt; (without the &lt;code&gt;LOCAL&lt;/code&gt; option), those effects persist after &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, and will not be affected by any later &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. Thus, in this one respect &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; acts more like &lt;code&gt;COMMIT&lt;/code&gt; than &lt;code&gt;ROLLBACK&lt;/code&gt;.</source>
          <target state="translated">트랜잭션이 &lt;code&gt;SET&lt;/code&gt; ( &lt;code&gt;LOCAL&lt;/code&gt; 옵션 없이)을 사용하여 런타임 매개 변수를 수정 한 경우 해당 효과는 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 후에도 지속 되며 이후 &lt;code&gt;COMMIT PREPARED&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 의 영향을받지 않습니다 . 따라서이 관점에서 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 은 &lt;code&gt;ROLLBACK&lt;/code&gt; 보다 &lt;code&gt;COMMIT&lt;/code&gt; 와 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="07ad8422becd50d9414841f3815863dc01f955f6" translate="yes" xml:space="preserve">
          <source>If the type being ordered (&lt;code&gt;type1&lt;/code&gt;) is collatable, the appropriate collation OID will be passed to the &lt;code&gt;in_range&lt;/code&gt; function, using the standard PG_GET_COLLATION() mechanism.</source>
          <target state="translated">주문한 유형 ( &lt;code&gt;type1&lt;/code&gt; )을 정리할 수있는 경우 표준 PG_GET_COLLATION () 메커니즘을 사용하여 적절한 조합 OID가 &lt;code&gt;in_range&lt;/code&gt; 함수 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0affc2c3fcf33ac8518f76b37e69d5d8764c5216" translate="yes" xml:space="preserve">
          <source>If the unique constraint is deferrable, there is additional complexity: we need to be able to insert an index entry for a new row, but defer any uniqueness-violation error until end of statement or even later. To avoid unnecessary repeat searches of the index, the index access method should do a preliminary uniqueness check during the initial insertion. If this shows that there is definitely no conflicting live tuple, we are done. Otherwise, we schedule a recheck to occur when it is time to enforce the constraint. If, at the time of the recheck, both the inserted tuple and some other tuple with the same key are live, then the error must be reported. (Note that for this purpose, &amp;ldquo;live&amp;rdquo; actually means &amp;ldquo;any tuple in the index entry's HOT chain is live&amp;rdquo;.) To implement this, the &lt;code&gt;aminsert&lt;/code&gt; function is passed a &lt;code&gt;checkUnique&lt;/code&gt; parameter having one of the following values:</source>
          <target state="translated">고유 제한 조건이 지연 가능한 경우 추가 복잡성이 있습니다. 새 행에 대한 색인 항목을 삽입 할 수 있어야하지만 명령문이 끝날 때까지 또는 이후에 고유성 위반 오류를 지연시켜야합니다. 인덱스의 불필요한 반복 검색을 피하기 위해 인덱스 액세스 방법은 초기 삽입 중에 예비 고유성 검사를 수행해야합니다. 이것이 충돌하는 라이브 튜플이 없다는 것을 보여 주면 완료됩니다. 그렇지 않으면 구속 조건을 시행 할 때 재확인이 발생하도록 스케줄합니다. 다시 검사 할 때 삽입 된 튜플과 동일한 키를 가진 다른 튜플이 모두 활성화 된 경우 오류를보고해야합니다. (이 목적을 위해, &quot;live&quot;는 실제로 &quot;인덱스 항목의 HOT 체인에있는 모든 튜플이 작동 함&quot;을 의미합니다.)이를 구현하기 위해 &lt;code&gt;aminsert&lt;/code&gt; 함수가 전달됩니다. &lt;code&gt;checkUnique&lt;/code&gt; 다음 값 중 하나를 갖는 checkUnique 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="0ccba0a1dbc7e9db8732870253e268a51ede19e4" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;-&lt;/code&gt; (dash) is specified as target directory, the tar contents will be written to standard output, suitable for piping to for example gzip. This is only possible if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">값 &lt;code&gt;-&lt;/code&gt; (대시)가 대상 디렉토리로 지정되면 tar 컨텐츠는 표준 출력에 기록되며, 예를 들어 gzip으로의 파이프에 적합합니다. 클러스터에 추가 테이블 스페이스가없고 WAL 스트리밍이 사용되지 않는 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="444b2da78b5aef7c45b208ec5e7f996fc4602364" translate="yes" xml:space="preserve">
          <source>If the value is 1 (the default) or above, float values are output in shortest-precise format; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt;. The actual number of digits generated depends only on the value being output, not on the value of this parameter. At most 17 digits are required for &lt;code&gt;float8&lt;/code&gt; values, and 9 for &lt;code&gt;float4&lt;/code&gt; values. This format is both fast and precise, preserving the original binary float value exactly when correctly read. For historical compatibility, values up to 3 are permitted.</source>
          <target state="translated">값이 1 (기본값) 이상이면 부동 소수점 값이 가장 짧은 형식으로 출력됩니다. &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;섹션 8.1.3&lt;/a&gt; 참조 . 생성되는 실제 자릿수는이 매개 변수의 값이 아니라 출력되는 값에만 의존합니다. &lt;code&gt;float8&lt;/code&gt; 값 에는 최대 17 자리가 , &lt;code&gt;float4&lt;/code&gt; 값에는 9 자리가 필요 합니다. 이 형식은 빠르고 정확하게 사용할 수 있으며 정확하게 읽을 때 원래 이진 부동 소수점 값을 유지합니다. 기록 호환성을 위해 최대 3 개의 값이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b8c00d10368663be17d060a1553cbcac67af360" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;always&lt;/code&gt;, then color is used.</source>
          <target state="translated">값이 &lt;code&gt;always&lt;/code&gt; 이면 색상이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3241b1b5ac7bee371703180a8744c53db79636d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;auto&lt;/code&gt; and the standard error stream is associated with a terminal device, then color is used.</source>
          <target state="translated">값이 &lt;code&gt;auto&lt;/code&gt; 이고 표준 오류 스트림이 터미널 장치와 연관된 경우 색상이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0cc84e480979f938d4633f92cd03d8f6fccf694" translate="yes" xml:space="preserve">
          <source>If the value is zero or negative, then the output is rounded to a given decimal precision. The precision used is the standard number of digits for the type (&lt;code&gt;FLT_DIG&lt;/code&gt; or &lt;code&gt;DBL_DIG&lt;/code&gt; as appropriate) reduced according to the value of this parameter. (For example, specifying -1 will cause &lt;code&gt;float4&lt;/code&gt; values to be output rounded to 5 significant digits, and &lt;code&gt;float8&lt;/code&gt; values rounded to 14 digits.) This format is slower and does not preserve all the bits of the binary float value, but may be more human-readable.</source>
          <target state="translated">값이 0 또는 음수이면 출력은 주어진 10 진수 정밀도로 반올림됩니다. 사용되는 정밀도 는이 매개 변수의 값에 따라 줄어든 유형의 표준 자릿수 ( 적절한 경우 &lt;code&gt;FLT_DIG&lt;/code&gt; 또는 &lt;code&gt;DBL_DIG&lt;/code&gt; )입니다. 예를 들어, -1을 지정하면 &lt;code&gt;float4&lt;/code&gt; 값이 유효 숫자 5 자리로 반올림 되고 &lt;code&gt;float8&lt;/code&gt; 값이 14 자리로 반올림됩니다.이 형식은 속도가 느리고 이진 float 값의 모든 비트를 보존하지는 않지만 더 많을 수 있습니다. 인간이 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bde8627196fca1b915cdbfcafe6a9bc91cc16ce" translate="yes" xml:space="preserve">
          <source>If the value written for an element is &lt;code&gt;NULL&lt;/code&gt; (in any case variant), the element is taken to be NULL. The presence of any quotes or backslashes disables this and allows the literal string value &amp;ldquo;NULL&amp;rdquo; to be entered. Also, for backward compatibility with pre-8.2 versions of PostgreSQL, the &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt; configuration parameter can be turned &lt;code&gt;off&lt;/code&gt; to suppress recognition of &lt;code&gt;NULL&lt;/code&gt; as a NULL.</source>
          <target state="translated">요소에 대해 작성된 값이 &lt;code&gt;NULL&lt;/code&gt; (경우에 따라 변형) 인 경우 요소는 NULL로 간주됩니다. 따옴표 나 백 슬래시가 있으면이를 비활성화하고 리터럴 문자열 값 &quot;NULL&quot;을 입력 할 수 있습니다. 또한 8.2 이전 버전의 PostgreSQL과의 호환성 을 위해 &lt;code&gt;NULL&lt;/code&gt; 로 NULL 을 인식 &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;하지 못하도록 array_nulls&lt;/a&gt; 구성 매개 변수를 &lt;code&gt;off&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c41c4c976de57b5cc72ea9d7bfdcc6564b8b256b" translate="yes" xml:space="preserve">
          <source>If the view is automatically updatable the system will convert any &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement on the view into the corresponding statement on the underlying base relation. &lt;code&gt;INSERT&lt;/code&gt; statements that have an &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; clause are fully supported.</source>
          <target state="translated">뷰를 자동으로 업데이트 할 수있는 경우 시스템은 뷰의 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 문을 기본 관계의 해당 문으로 변환합니다. &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; 절이 있는 &lt;code&gt;INSERT&lt;/code&gt; 문 이 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="650d690f75ae406d20b34e538980576f232072f4" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">너비가 함수 인수에서 오는 경우 해당 인수는 형식 지정자 값에 사용되는 인수보다 먼저 사용됩니다. width 인수가 음수이면 결과는 length &lt;code&gt;abs&lt;/code&gt; ( &lt;code&gt;width&lt;/code&gt; ) 필드 내 에서 &lt;code&gt;-&lt;/code&gt; 플래그가 지정된 것처럼 정렬 된 상태로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="8438b6c9a8a0c469032906dcee3641b321408b8e" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt;).</source>
          <target state="translated">너비가 함수 인수에서 오는 경우 해당 인수는 형식 지정자의 값에 사용되는 인수보다 먼저 사용됩니다. width 인수가 음수이면 결과는 길이가 &lt;code&gt;abs&lt;/code&gt; ( &lt;em&gt; &lt;code&gt;width&lt;/code&gt; &lt;/em&gt; ) 인 필드 내에서 왼쪽으로 정렬됩니다 ( &lt;code&gt;-&lt;/code&gt; 플래그가 지정된 것처럼 ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee835cdf2017b10d24cc5c26f6abffc684a96735" translate="yes" xml:space="preserve">
          <source>If there are both &lt;code&gt;unknown&lt;/code&gt; and known-type arguments, and all the known-type arguments have the same type, assume that the &lt;code&gt;unknown&lt;/code&gt; arguments are also of that type, and check which candidates can accept that type at the &lt;code&gt;unknown&lt;/code&gt;-argument positions. If exactly one candidate passes this test, use it. Otherwise, fail.</source>
          <target state="translated">모두가있는 경우 &lt;code&gt;unknown&lt;/code&gt; 및 알려진 타입의 인수 및 알려진 모든 유형의 인수는, 동일한 유형을 가지고 있다고 가정 &lt;code&gt;unknown&lt;/code&gt; 인수는 해당 유형의, 그리고 후보가에서 해당 유형 받아 들일 수 체크 &lt;code&gt;unknown&lt;/code&gt; -argument 위치를. 정확히 하나의 응시자가이 시험을 통과하면 사용하십시오. 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="13cac4b83f93f0a857eb5390b899f2b2b2cbf1c2" translate="yes" xml:space="preserve">
          <source>If there are conflicting non-default implicit collations among the input expressions, then the combination is deemed to have indeterminate collation. This is not an error condition unless the particular function being invoked requires knowledge of the collation it should apply. If it does, an error will be raised at run-time.</source>
          <target state="translated">입력 표현식간에 기본이 아닌 암시 적 데이터 정렬이 충돌하는 경우 조합에 불확실한 데이터 정렬이있는 것으로 간주됩니다. 호출되는 특정 함수에 적용 할 데이터 정렬에 대한 지식이 필요한 경우가 아니면 오류 조건이 아닙니다. 그렇다면 런타임에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="28d65a2d08624ffa80deb6c7246a1682969ee379" translate="yes" xml:space="preserve">
          <source>If there are eight or six digits, and if no other date fields have been previously read, then interpret as a &amp;ldquo;concatenated date&amp;rdquo; (e.g., &lt;code&gt;19990118&lt;/code&gt; or &lt;code&gt;990118&lt;/code&gt;). The interpretation is &lt;code&gt;YYYYMMDD&lt;/code&gt; or &lt;code&gt;YYMMDD&lt;/code&gt;.</source>
          <target state="translated">8 자리 또는 6 자리가 있고 이전에 읽은 다른 날짜 필드가없는 경우 &quot;연결 날짜&quot;(예 : &lt;code&gt;19990118&lt;/code&gt; 또는 &lt;code&gt;990118&lt;/code&gt; )로 해석 하십시오. 해석은 &lt;code&gt;YYYYMMDD&lt;/code&gt; 또는 &lt;code&gt;YYMMDD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06c3232f6496ea373f86e0b58b23d8cc590947a5" translate="yes" xml:space="preserve">
          <source>If there are separate indexes on several of the columns referenced in &lt;code&gt;WHERE&lt;/code&gt;, the planner might choose to use an AND or OR combination of the indexes:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 에서 참조 된 여러 열에 별도의 인덱스가있는 경우 플래너는 인덱스의 AND 또는 OR 조합을 사용하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99c2725fb0d24809952a5ff770d9ef79057a3c26" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">대상 테이블에 트리거가있는 경우 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;38 장&lt;/a&gt; ) &lt;code&gt;RETURNING&lt;/code&gt; 에 사용 가능한 데이터 는 트리거에 의해 수정 된 행입니다. 따라서 트리거로 계산 된 열을 검사하는 것이 &lt;code&gt;RETURNING&lt;/code&gt; 의 또 다른 일반적인 사용 사례입니다 .</target>
        </trans-unit>
        <trans-unit id="531c18479c37e8661718c4bf106b66a87df84c58" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">대상 테이블에 트리거 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;38 장&lt;/a&gt; ) 가있는 경우 &lt;code&gt;RETURNING&lt;/code&gt; 에 사용할 수있는 데이터 는 트리거에 의해 수정 된 행입니다. 따라서 트리거로 계산 된 열을 검사하는 것은 &lt;code&gt;RETURNING&lt;/code&gt; 의 또 다른 일반적인 사용 사례입니다 .</target>
        </trans-unit>
        <trans-unit id="5b8c31e042fe2150c30030dae6c6269655420443" translate="yes" xml:space="preserve">
          <source>If there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:</source>
          <target state="translated">창 계산을 수행 한 후 행을 필터링하거나 그룹화해야하는 경우 하위 선택을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cffa77db1a4b360ae7233f9c0f0ce7a0bc209389" translate="yes" xml:space="preserve">
          <source>If there is a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be processed.</source>
          <target state="translated">LSN이 &lt;code&gt;lsn&lt;/code&gt; 과 정확히 같은 레코드가 있으면 레코드가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="83cce96057188d3a7386156bf2623596a5029da8" translate="yes" xml:space="preserve">
          <source>If there is an index and we use a query with an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, &lt;code&gt;EXPLAIN&lt;/code&gt; might show a different plan:</source>
          <target state="translated">인덱스가 있고 인덱스 가능한 &lt;code&gt;WHERE&lt;/code&gt; 조건을 가진 쿼리를 사용하는 경우 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 다른 계획을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed6480e8e6205c3cafadde0e83045f72ff5c9888" translate="yes" xml:space="preserve">
          <source>If there is more than one direct parent for a child table (multiple inheritance), this number tells the order in which the inherited columns are to be arranged. The count starts at 1.</source>
          <target state="translated">자식 테이블에 대한 직접 부모가 둘 이상인 경우 (다중 상속)이 숫자는 상속 된 열이 정렬되는 순서를 나타냅니다. 카운트는 1부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b83d35fcbb1d8a1926cc7ad31b3e2d51f2485b81" translate="yes" xml:space="preserve">
          <source>If there is no setting named &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;, &lt;code&gt;current_setting&lt;/code&gt; throws an error unless &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is supplied and is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">라는 이름의 설정이없는 경우 &lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; &lt;/em&gt; , &lt;code&gt;current_setting&lt;/code&gt; 이 되지 않는 오류가 발생 &lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; 가&lt;/em&gt; 공급하고 있습니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="993f6bab11125bc0a23a8d9c66d2ae0ec051d5b8" translate="yes" xml:space="preserve">
          <source>If there's a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be output.</source>
          <target state="translated">LSN이 정확히 &lt;code&gt;lsn&lt;/code&gt; 과 동일한 레코드가 있으면 레코드가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="51e95a5e2098ab1866ec414690874be8c0926635" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">이 두 가지 기본 요구 사항이 충족되면 쿼리에 필요한 모든 데이터 값을 인덱스에서 사용할 수 있으므로 인덱스 전용 검색이 실제로 가능합니다. 그러나 PostgreSQL에는 테이블 스캔에 대한 추가 요구 사항이 있습니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장&lt;/a&gt; 에서 설명한 것처럼 검색된 각 행이 쿼리의 MVCC 스냅 샷에 &quot;표시&quot;되는지 확인해야합니다.. 가시성 정보는 인덱스 항목에 저장되지 않고 힙 항목에만 저장됩니다. 언뜻보기에 모든 행 검색에는 힙 액세스가 필요할 것 같습니다. 그리고 최근에 테이블 행이 수정 된 경우에도 마찬가지입니다. 그러나 데이터를 거의 변경하지 않으면이 문제를 해결할 수있는 방법이 있습니다. PostgreSQL은 테이블 힙의 각 페이지에 대해 해당 페이지에 저장된 모든 행이 현재 및 미래의 모든 트랜잭션에서 볼 수있을 정도로 오래되었는지 여부를 추적합니다. 이 정보는 테이블의 &lt;em&gt;가시성 맵에&lt;/em&gt; 약간 저장 &lt;em&gt;됩니다&lt;/em&gt;. 후보 인덱스 항목을 찾은 후 인덱스 전용 스캔은 해당 힙 페이지에 대한 가시성 맵 비트를 확인합니다. 설정된 경우 행이 표시되어 더 이상 작업하지 않고도 데이터를 반환 할 수 있습니다. 설정되지 않은 경우 힙 항목을 방문하여 가시적인지 여부를 확인해야하므로 표준 인덱스 스캔에 비해 성능 이점이 없습니다. 성공적인 경우에도이 방법은 가시성 맵 액세스를 힙 액세스로 교환합니다. 그러나 가시성 맵은 설명하는 힙보다 4 배 크기가 작으므로 액세스하기 위해 훨씬 적은 물리적 I / O가 필요합니다. 대부분의 상황에서 가시성 맵은 항상 메모리에 캐시 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="56f8e9d448a32277ad7decf19037ed4798402174" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">이 두 가지 기본 요구 사항이 충족되면 쿼리에 필요한 모든 데이터 값을 인덱스에서 사용할 수 있으므로 인덱스 전용 스캔이 물리적으로 가능합니다. 그러나 PostgreSQL의 테이블 스캔에 대한 추가 요구 사항이 있습니다. &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;13 장&lt;/a&gt; 에서 설명한 것처럼 검색된 각 행이 쿼리의 MVCC 스냅 샷에 &quot;표시&quot;되는지 확인해야합니다.. 가시성 정보는 인덱스 항목에 저장되지 않고 힙 항목에만 저장됩니다. 따라서 언뜻보기에 모든 행 검색에는 어쨌든 힙 액세스가 필요합니다. 그리고 이것은 실제로 테이블 행이 최근에 수정 된 경우입니다. 그러나 거의 변경되지 않는 데이터의 경우이 문제를 해결할 수있는 방법이 있습니다. PostgreSQL은 테이블 힙의 각 페이지에 대해 해당 페이지에 저장된 모든 행이 현재 및 미래의 모든 트랜잭션에서 볼 수있을만큼 오래되었는지 여부를 추적합니다. 이 정보는 테이블의 &lt;em&gt;가시성 맵에&lt;/em&gt; 약간 저장 &lt;em&gt;됩니다.&lt;/em&gt;. 인덱스 전용 스캔은 후보 인덱스 항목을 찾은 후 해당 힙 페이지에 대한 가시성 맵 비트를 확인합니다. 설정된 경우 행이 표시되므로 추가 작업없이 데이터를 반환 할 수 있습니다. 설정되지 않은 경우 힙 항목이 표시되는지 확인하기 위해 방문해야하므로 표준 인덱스 스캔에 비해 성능 이점이 없습니다. 성공한 경우에도이 접근 방식은 힙 액세스에 대한 가시성 맵 액세스를 교환합니다. 그러나 가시성 맵은 설명하는 힙보다 4 배 더 작기 때문에 액세스하는 데 훨씬 적은 물리적 I / O가 필요합니다. 대부분의 상황에서 가시성 맵은 항상 메모리에 캐시 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8eca355b7b540d6c38ac123a39e5c7bfe77f82a8" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">이 절이 지정되면 ID 열에 제공된 모든 값이 무시되고 기본 시퀀스 생성 값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c547d5a570870983467a7ef7a622b57db3de5cb6" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns defined as &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">이 절을 지정하면 &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; 로 정의 된 식별 컬럼에 제공된 모든 값 이 무시되고 기본 시퀀스 생성 값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="33eceb951fc008dd28e5a104ea6147dca30fa083" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns will override the default sequence-generated values.</source>
          <target state="translated">이 절이 지정되면 식별 열에 제공된 모든 값이 기본 시퀀스 생성 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="bc20641c7b7db884166e9f2d507911850e3a7612" translate="yes" xml:space="preserve">
          <source>If this file exists in the data directory, pg_ctl (in &lt;code&gt;restart&lt;/code&gt; mode) will pass the contents of the file as options to postgres, unless overridden by the &lt;code&gt;-o&lt;/code&gt; option. The contents of this file are also displayed in &lt;code&gt;status&lt;/code&gt; mode.</source>
          <target state="translated">이 파일이 데이터 디렉토리에 존재하면 pg_ctl ( &lt;code&gt;restart&lt;/code&gt; 모드에서)은 &lt;code&gt;-o&lt;/code&gt; 옵션으로 재정의되지 않는 한 파일 내용을 postgres에 옵션으로 전달합니다 . 이 파일의 내용도 &lt;code&gt;status&lt;/code&gt; 모드로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="50767742cba8dcb6350d1c58ae8e0156ac5a9fe6" translate="yes" xml:space="preserve">
          <source>If this happens, you will see a kernel message that looks like this (consult your system documentation and configuration on where to look for such a message):</source>
          <target state="translated">이 경우 다음과 같은 커널 메시지가 표시됩니다 (해당 메시지를 찾을 위치에 대한 시스템 설명서 및 구성을 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="2441da5aa28be6dd0d7fce7180a9ead106be298e" translate="yes" xml:space="preserve">
          <source>If this is a composite type (see &lt;code&gt;typtype&lt;/code&gt;), then this column points to the &lt;code&gt;pg_class&lt;/code&gt; entry that defines the corresponding table. (For a free-standing composite type, the &lt;code&gt;pg_class&lt;/code&gt; entry doesn't really represent a table, but it is needed anyway for the type's &lt;code&gt;pg_attribute&lt;/code&gt; entries to link to.) Zero for non-composite types.</source>
          <target state="translated">이것이 복합 유형 인 경우 ( &lt;code&gt;typtype&lt;/code&gt; 참조 )이 열 은 해당 테이블을 정의하는 &lt;code&gt;pg_class&lt;/code&gt; 항목을 가리 킵니다 . 독립형 복합 유형의 경우 &lt;code&gt;pg_class&lt;/code&gt; 항목은 실제로 테이블을 나타내지는 않지만 유형의 &lt;code&gt;pg_attribute&lt;/code&gt; 항목을 링크하려면 어쨌든 필요합니다 . 비 복합 유형의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="e7bc989c1a71dcf27e6c15912a9e239eb02b9ff1" translate="yes" xml:space="preserve">
          <source>If this is a domain (see &lt;code&gt;typtype&lt;/code&gt;), then &lt;code&gt;typbasetype&lt;/code&gt; identifies the type that this one is based on. Zero if this type is not a domain.</source>
          <target state="translated">이것이 도메인 인 경우 ( &lt;code&gt;typtype&lt;/code&gt; 참조 ) &lt;code&gt;typbasetype&lt;/code&gt; 은이 도메인의 기반이되는 유형을 식별합니다. 이 유형이 도메인이 아닌 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="69cd51fd1807ea0656502f0a70cd88e1db17db63" translate="yes" xml:space="preserve">
          <source>If this is a table or an index, the access method used (heap, B-tree, hash, etc.)</source>
          <target state="translated">이것이 테이블 또는 인덱스 인 경우 사용 된 액세스 방법 (힙, B- 트리, 해시 등)</target>
        </trans-unit>
        <trans-unit id="a337fd1770acfe173207c700a1060f857464ec35" translate="yes" xml:space="preserve">
          <source>If this is enabled, &lt;code&gt;TRUNCATE&lt;/code&gt; operations performed directly on partitions are not replicated.</source>
          <target state="translated">이 기능이 활성화되면 파티션에서 직접 수행되는 &lt;code&gt;TRUNCATE&lt;/code&gt; 작업이 복제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6657b3960fa7e0cd88d2aa8dcc3b355ae7df8c2d" translate="yes" xml:space="preserve">
          <source>If this is on, you should create users as &lt;code&gt;username@dbname&lt;/code&gt;. When &lt;code&gt;username&lt;/code&gt; is passed by a connecting client, &lt;code&gt;@&lt;/code&gt; and the database name are appended to the user name and that database-specific user name is looked up by the server. Note that when you create users with names containing &lt;code&gt;@&lt;/code&gt; within the SQL environment, you will need to quote the user name.</source>
          <target state="translated">켜져 있으면 &lt;code&gt;username@dbname&lt;/code&gt; 으로 사용자를 작성해야합니다 . 연결 클라이언트가 &lt;code&gt;username&lt;/code&gt; 을 전달 하면 &lt;code&gt;@&lt;/code&gt; 및 데이터베이스 이름이 사용자 이름에 추가되고 해당 데이터베이스 별 사용자 이름이 서버에서 조회됩니다. SQL 환경에서 &lt;code&gt;@&lt;/code&gt; 가 포함 된 이름을 가진 사용자를 만들 때는 사용자 이름을 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8483faa9a2017341557263992633a169be114a21" translate="yes" xml:space="preserve">
          <source>If this option is enabled along with &lt;code&gt;compat_realm&lt;/code&gt;, the user name from the Kerberos UPN is used for authentication. If it is disabled (the default), the SAM-compatible user name is used. By default, these two names are identical for new user accounts.</source>
          <target state="translated">이 옵션을 &lt;code&gt;compat_realm&lt;/code&gt; 과 함께 사용하면 Kerberos UPN의 사용자 이름이 인증에 사용됩니다. 비활성화 된 경우 (기본값) SAM 호환 사용자 이름이 사용됩니다. 기본적으로이 두 이름은 새 사용자 계정에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="371ee180f233c6aad73716af3849b71651b391c0" translate="yes" xml:space="preserve">
          <source>If this option is not specified and the server supports temporary replication slots (version 10 and later), then a temporary replication slot is automatically used for WAL streaming.</source>
          <target state="translated">이 옵션을 지정하지 않고 서버가 임시 복제 슬롯 (버전 10 이상)을 지원하면 WAL 스트리밍에 임시 복제 슬롯이 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f8215b3963efef20de5d0e001e32b15d0b1fd74" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;Section 33.1&lt;/a&gt; for more information.</source>
          <target state="translated">이 매개 변수에 &lt;code&gt;=&lt;/code&gt; 기호 가 포함 되거나 유효한 URI 접두사 ( &lt;code&gt;postgresql://&lt;/code&gt; 또는 &lt;code&gt;postgres://&lt;/code&gt; )로 시작하면 &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; 문자열 로 처리됩니다 . 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;33.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb980e2e2f9be562491c46b5659937146807845b" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information.</source>
          <target state="translated">이 매개 변수에 &lt;code&gt;=&lt;/code&gt; 기호 가 포함 되거나 유효한 URI 접두사 ( &lt;code&gt;postgresql://&lt;/code&gt; 또는 &lt;code&gt;postgres://&lt;/code&gt; )로 시작하면 &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; 문자열 로 처리됩니다 . 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;33.1.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e5a94a371e1e757fb5a74a0f350e7a31fdc8b2c2" translate="yes" xml:space="preserve">
          <source>If this parameter is on, the PostgreSQL server will try to make sure that updates are physically written to disk, by issuing &lt;code&gt;fsync()&lt;/code&gt; system calls or various equivalent methods (see &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;). This ensures that the database cluster can recover to a consistent state after an operating system or hardware crash.</source>
          <target state="translated">이 매개 변수가 설정되어 있으면 PostgreSQL 서버는 &lt;code&gt;fsync()&lt;/code&gt; 시스템 호출 또는 이와 동등한 다양한 메소드 를 실행하여 업데이트가 실제로 디스크에 기록되도록 합니다 ( &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; 참조 ). 이를 통해 운영 체제 또는 하드웨어 충돌 후 데이터베이스 클러스터가 일관된 상태로 복구 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdad70218c14320d183b5258a94b057b0b9b82eb" translate="yes" xml:space="preserve">
          <source>If this produces no response then this step was successful and you can skip over the remainder of this section.</source>
          <target state="translated">이렇게해도 응답이 없으면이 단계는 성공한 것이므로이 섹션의 나머지 부분을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3214ef4d2c8d678533f9cd4aff300140581f95e6" translate="yes" xml:space="preserve">
          <source>If this table is a partition, one cannot perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on a column if it is marked &lt;code&gt;NOT NULL&lt;/code&gt; in the parent table. To drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint from all the partitions, perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on the parent table. Even if there is no &lt;code&gt;NOT NULL&lt;/code&gt; constraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.</source>
          <target state="translated">이 테이블이 파티션 인 경우 , 상위 테이블에서 &lt;code&gt;NOT NULL&lt;/code&gt; 로 표시되면 컬럼에서 &lt;code&gt;DROP NOT NULL&lt;/code&gt; 을 수행 할 수 없습니다 . 모든 파티션에서 &lt;code&gt;NOT NULL&lt;/code&gt; 제한 조건 을 삭제하려면 상위 테이블에서 &lt;code&gt;DROP NOT NULL&lt;/code&gt; 을 수행 하십시오. 부모에 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건 이 없더라도 원하는 경우 이러한 제약 조건을 개별 파티션에 계속 추가 할 수 있습니다. 즉, 부모가 허용하더라도 자식은 null을 허용하지 않지만 다른 방법으로는 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8738e67f4faaa26be7e54ea9f241452e99abdc6a" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 값이 0 (기본값)이면 시간 초과가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f32c0180b724efe2a022fcb4332eb4cf7431bae9" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as minutes. A value of &lt;code&gt;-1&lt;/code&gt; (the default) disables this feature, effectively setting the snapshot age limit to infinity. This parameter can only be set at server start.</source>
          <target state="translated">이 값을 단위없이 지정하면 분으로 간주됩니다. &lt;code&gt;-1&lt;/code&gt; (기본값) 값은 이 기능을 비활성화하여 스냅 샷 보존 기간을 무한대로 효과적으로 설정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ab1040fa10ec473399bfff4fa508c435a17bc0" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;ignorespace&lt;/code&gt;, lines which begin with a space are not entered into the history list. If set to a value of &lt;code&gt;ignoredups&lt;/code&gt;, lines matching the previous history line are not entered. A value of &lt;code&gt;ignoreboth&lt;/code&gt; combines the two options. If set to &lt;code&gt;none&lt;/code&gt; (the default), all lines read in interactive mode are saved on the history list.</source>
          <target state="translated">이 변수가 &lt;code&gt;ignorespace&lt;/code&gt; 로 설정 되면 공백으로 시작하는 행이 히스토리 목록에 입력되지 않습니다. &lt;code&gt;ignoredups&lt;/code&gt; 값으로 설정 하면 이전 히스토리 라인과 일치하는 라인이 입력되지 않습니다. &lt;code&gt;ignoreboth&lt;/code&gt; 값은 두 가지 옵션을 결합합니다. &lt;code&gt;none&lt;/code&gt; (기본값)으로 설정하면 대화식 모드에서 읽은 모든 행이 기록 목록에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7d49403e63b47e4513b7ffed0983ad8f1cca01fe" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;true&lt;/code&gt;, a table's access method details are not displayed. This is mainly useful for regression tests.</source>
          <target state="translated">이 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 테이블의 액세스 방법 세부 사항이 표시되지 않습니다. 이것은 주로 회귀 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a5769546d2d4414640c8fa6c471f59d18a32f49e" translate="yes" xml:space="preserve">
          <source>If this variable is set to an integer value greater than zero, the results of &lt;code&gt;SELECT&lt;/code&gt; queries are fetched and displayed in groups of that many rows, rather than the default behavior of collecting the entire result set before display. Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to 1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail after having already displayed some rows.</source>
          <target state="translated">이 변수를 0보다 큰 정수 값으로 설정하면 &lt;code&gt;SELECT&lt;/code&gt; 쿼리 결과가 표시되기 전에 전체 결과 세트를 수집하는 기본 동작이 아니라 여러 행의 그룹으로 페치되어 표시됩니다. 따라서 결과 집합의 크기에 관계없이 제한된 양의 메모리 만 사용됩니다. 이 기능을 활성화 할 때 일반적으로 100 ~ 1000의 설정이 사용됩니다. 이 기능을 사용할 때 이미 일부 행을 표시 한 후 쿼리가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76778bde620595af53b04af23a5daa5bc5441843" translate="yes" xml:space="preserve">
          <source>If three or more digits and no date fields have yet been found, interpret as a year (this forces yy-mm-dd ordering of the remaining date fields).</source>
          <target state="translated">세 개 이상의 숫자가 있고 아직 날짜 필드가 없으면 연도로 해석하십시오 (나머지 날짜 필드의 yy-mm-dd 순서를 강제 함).</target>
        </trans-unit>
        <trans-unit id="81e3a3432036cda1be2139bb1761dc976c1a75c5" translate="yes" xml:space="preserve">
          <source>If true this index has been chosen as &amp;ldquo;replica identity&amp;rdquo; using &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt;</source>
          <target state="translated">참이면이 인덱스가 &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt; 사용한 교체 ID를 사용하여&amp;ldquo;복제본 ID&amp;rdquo;로 선택되었습니다 ...</target>
        </trans-unit>
        <trans-unit id="fb3a87dcd25f91900b7d1fcaa4ea022c5ef4621a" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;DELETE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">true이면 게시의 테이블에 대해 &lt;code&gt;DELETE&lt;/code&gt; 작업이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="31ebf4870608c0167855b7d0283c52cc09a7d931" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;INSERT&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">참이면 게시의 테이블에 대해 &lt;code&gt;INSERT&lt;/code&gt; 작업이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="16194e2fdde132d1c172f912b491836e60827cdc" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TRUNCATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">true이면 게시의 테이블에 대해 &lt;code&gt;TRUNCATE&lt;/code&gt; 작업이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad3497d81a37523e3d7068e040be2588a6f2a7f" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;UPDATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">true이면 게시의 테이블에 대해 &lt;code&gt;UPDATE&lt;/code&gt; 작업이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="f3f8473e6cf008d85556519e04a9be2df3d673dd" translate="yes" xml:space="preserve">
          <source>If true, operations on a leaf partition are replicated using the identity and schema of its topmost partitioned ancestor mentioned in the publication instead of its own.</source>
          <target state="translated">true 인 경우 리프 파티션에 대한 작업은 자체 대신 게시에 언급 된 최상위 파티션 된 상위 항목의 ID와 스키마를 사용하여 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="ec6d4eb0a14744c8cf642983fb247ca8af2c665e" translate="yes" xml:space="preserve">
          <source>If true, queries must not use the index until the &lt;code&gt;xmin&lt;/code&gt; of this &lt;code&gt;pg_index&lt;/code&gt; row is below their &lt;code&gt;TransactionXmin&lt;/code&gt; event horizon, because the table may contain broken HOT chains with incompatible rows that they can see</source>
          <target state="translated">true 인 경우, 이 &lt;code&gt;pg_index&lt;/code&gt; 행 의 &lt;code&gt;xmin&lt;/code&gt; 이 &lt;code&gt;TransactionXmin&lt;/code&gt; 이벤트 수평선 아래 에 올 때까지 쿼리는 인덱스를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e8ec7f29c2269b6f390b904f6368378dd35f78e8" translate="yes" xml:space="preserve">
          <source>If true, the index is currently ready for inserts. False means the index must be ignored by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations.</source>
          <target state="translated">true 인 경우 색인은 현재 삽입 준비가되었습니다. False는 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 조작으로 색인을 무시해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6c0fcf74070493f9e01640902cbfc0c6b38f7360" translate="yes" xml:space="preserve">
          <source>If true, the index is currently valid for queries. False means the index is possibly incomplete: it must still be modified by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations, but it cannot safely be used for queries. If it is unique, the uniqueness property is not guaranteed true either.</source>
          <target state="translated">true 인 경우 인덱스는 현재 쿼리에 유효합니다. False는 인덱스가 불완전 할 수 있음을 의미합니다. &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 조작으로 여전히 수정해야 하지만 쿼리에는 안전하게 사용할 수 없습니다. 고유 한 경우 고유성 속성도 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab6de0df41664d3b3675c49edb64211adc3a12b2" translate="yes" xml:space="preserve">
          <source>If true, the stats include inheritance child columns, not just the values in the specified relation</source>
          <target state="translated">true 인 경우 통계에는 지정된 관계의 값뿐만 아니라 상속 하위 열도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7718b7881ae44cc98ca7be7fa2735272d5a098" translate="yes" xml:space="preserve">
          <source>If true, the subscription is enabled and should be replicating.</source>
          <target state="translated">true 인 경우 구독이 활성화되어 복제 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="aa9a0941d117d4d0d6546de8ecf8d6c048b76081" translate="yes" xml:space="preserve">
          <source>If true, the table was last clustered on this index</source>
          <target state="translated">true 인 경우 테이블이이 인덱스에서 마지막으로 클러스터되었습니다</target>
        </trans-unit>
        <trans-unit id="0629da4ff91f39f869bbe66ce6c66a0e0b5d1ffd" translate="yes" xml:space="preserve">
          <source>If true, the uniqueness check is enforced immediately on insertion (irrelevant if &lt;code&gt;indisunique&lt;/code&gt; is not true)</source>
          <target state="translated">참인 경우 삽입시 고유성 검사가 즉시 적용됩니다 ( &lt;code&gt;indisunique&lt;/code&gt; 이 사실이 아닌 경우 에는 관련 이 없음)</target>
        </trans-unit>
        <trans-unit id="588ebeeb8e4b96440c5bf3cc0c1bd5854026d4e7" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false (the default), then only superusers or the owner of the database can clone it.</source>
          <target state="translated">true 인 경우이 데이터베이스는 &lt;code&gt;CREATEDB&lt;/code&gt; 권한을 가진 모든 사용자가 복제 할 수 있습니다 . false (기본값) 인 경우 수퍼 유저 또는 데이터베이스 소유자 만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d71cd9fec73126b99ae1f7d42db7f62a2b72e24" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false, then only superusers or the owner of the database can clone it.</source>
          <target state="translated">true 인 경우이 데이터베이스는 &lt;code&gt;CREATEDB&lt;/code&gt; 권한을 가진 모든 사용자가 복제 할 수 있습니다 . false 인 경우 수퍼 유저 또는 데이터베이스 소유자 만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1accbb6daee5f69b5c0f42943992a092e4ba1074" translate="yes" xml:space="preserve">
          <source>If true, this index represents the primary key of the table (&lt;code&gt;indisunique&lt;/code&gt; should always be true when this is true)</source>
          <target state="translated">true의 경우,이 지수는 테이블의 기본 키 (대표 &lt;code&gt;indisunique&lt;/code&gt; 이 이에 해당하는 경우 항상 참이어야 함)</target>
        </trans-unit>
        <trans-unit id="0f6e2116d6074f49b9f7bdf86e12bdd873ed8149" translate="yes" xml:space="preserve">
          <source>If true, this index supports an exclusion constraint</source>
          <target state="translated">true 인 경우이 인덱스는 제외 제약 조건을 지원합니다</target>
        </trans-unit>
        <trans-unit id="eb9d897ba2f316e5badcbcf694b6980e5d7c7ad0" translate="yes" xml:space="preserve">
          <source>If true, this is a unique index</source>
          <target state="translated">참이면 고유 인덱스입니다</target>
        </trans-unit>
        <trans-unit id="6763aa747866133b7f56f2197fde582b044036d1" translate="yes" xml:space="preserve">
          <source>If true, this publication automatically includes all tables in the database, including any that will be created in the future.</source>
          <target state="translated">true 인 경우이 발행물에는 향후 생성 될 테이블을 포함하여 데이터베이스의 모든 테이블이 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2b4a0e4917a40fa5601228c6bffce7ba0283b004" translate="yes" xml:space="preserve">
          <source>If true, this row includes inheritance child columns, not just the values in the specified table</source>
          <target state="translated">true 인 경우이 행에는 지정된 테이블의 값뿐만 아니라 상속 하위 열도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b5af22ae5132cfdb3c63b86048053d7c0759cd52" translate="yes" xml:space="preserve">
          <source>If two such transactions concurrently try to change the balance of account 12345, we clearly want the second transaction to start with the updated version of the account's row. Because each command is affecting only a predetermined row, letting it see the updated version of the row does not create any troublesome inconsistency.</source>
          <target state="translated">이러한 두 거래가 동시에 계정 잔액 12345를 변경하려고하면 두 번째 거래가 계정 행의 업데이트 된 버전으로 시작되기를 원합니다. 각 명령은 미리 결정된 행에만 영향을 미치므로 행의 업데이트 된 버전을 볼 수있게한다고해서 번거로운 불일치가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="286da9748bbda59905be5dc346e8fae92aa0edfb" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, begin your session by removing publicly-writable schemas from &lt;code&gt;search_path&lt;/code&gt;. One can add &lt;code&gt;options=-csearch_path=&lt;/code&gt; to the connection string or issue &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; before other SQL commands. This consideration is not specific to psql; it applies to every interface for executing arbitrary SQL commands.</source>
          <target state="translated">신뢰할 수없는 사용자가 &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;보안 스키마 사용 패턴을&lt;/a&gt; 채택하지 않은 데이터베이스에 액세스 할 수있는 경우 &lt;code&gt;search_path&lt;/code&gt; 에서 공개적으로 쓰기 가능한 스키마를 제거하여 세션을 시작하십시오 . 연결 문자열 에 &lt;code&gt;options=-csearch_path=&lt;/code&gt; 옵션 을 추가 하거나 다른 SQL 명령 전에 &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; 를 발행 할 수 있습니다 . 이 고려 사항은 psql에만 국한되지 않습니다. 임의의 SQL 명령을 실행하기위한 모든 인터페이스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="768ed7df41fe42c9b25945d5dff896541bf55b4f" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, do not run pgbench in that database. pgbench uses unqualified names and does not manipulate the search path.</source>
          <target state="translated">신뢰할 수없는 사용자가 &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;보안 스키마 사용 패턴을&lt;/a&gt; 채택하지 않은 데이터베이스에 액세스 할 수있는 경우 해당 데이터베이스에서 pgbench를 실행하지 마십시오. pgbench는 규정되지 않은 이름을 사용하며 검색 경로를 조작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91d0d0478151e73c50542244d9425b00c1130633" translate="yes" xml:space="preserve">
          <source>If using WAL archiving or streaming replication, consider disabling them during the restore. To do that, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;minimal&lt;/code&gt;, and &lt;code&gt;max_wal_senders&lt;/code&gt; to zero before loading the dump. Afterwards, set them back to the right values and take a fresh base backup.</source>
          <target state="translated">WAL 보관 또는 스트리밍 복제를 사용하는 경우 복원 중에 사용하지 않도록 설정하십시오. 이렇게하려면 덤프를로드하기 전에 &lt;code&gt;archive_mode&lt;/code&gt; 를 &lt;code&gt;off&lt;/code&gt; 로 , &lt;code&gt;wal_level&lt;/code&gt; 을 &lt;code&gt;minimal&lt;/code&gt; 로 , &lt;code&gt;max_wal_senders&lt;/code&gt; 를 0으로 설정하십시오. 그런 다음 올바른 값으로 다시 설정하고 새로운 기본 백업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="82f833ab3393a0e44827283b4406b6a15d35b9df" translate="yes" xml:space="preserve">
          <source>If using a pre-9.1 old server that is using a non-default Unix-domain socket directory or a default that differs from the default of the new cluster, set &lt;code&gt;PGHOST&lt;/code&gt; to point to the old server's socket location. (This is not relevant on Windows.)</source>
          <target state="translated">기본이 아닌 Unix 도메인 소켓 디렉토리를 사용하는 9.1 이전의 이전 서버 또는 새 클러스터의 기본값과 다른 기본값을 사용하는 경우 &lt;code&gt;PGHOST&lt;/code&gt; 가 이전 서버의 소켓 위치를 가리 키도록 설정 하십시오 . (Windows와는 관련이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="1fc1fe1aaf9532782aa2ed49cabaa7db59b86f4e" translate="yes" xml:space="preserve">
          <source>If waiting is disabled, the requested action is triggered, but there is no feedback about its success. In that case, the server log file or an external monitoring system would have to be used to check the progress and success of the operation.</source>
          <target state="translated">대기가 비활성화되면 요청 된 작업이 트리거되지만 성공에 대한 피드백은 없습니다. 이 경우 서버 로그 파일 또는 외부 모니터링 시스템을 사용하여 작업 진행률과 성공 여부를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b03befc0afa9f43bd61408ea6224efc69f041cf" translate="yes" xml:space="preserve">
          <source>If we change the query's selectivity a bit, we might get a very different join plan:</source>
          <target state="translated">쿼리의 선택성을 약간 변경하면 매우 다른 조인 계획을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3514492aa3ac15aedee53bae788660dc8e748122" translate="yes" xml:space="preserve">
          <source>If we continuously feed the series of WAL files to another machine that has been loaded with the same base backup file, we have a &lt;em&gt;warm standby&lt;/em&gt; system: at any point we can bring up the second machine and it will have a nearly-current copy of the database.</source>
          <target state="translated">동일한 기본 백업 파일이로드 된 다른 머신에 일련의 WAL 파일을 지속적으로 공급하면 &lt;em&gt;웜 스탠바이&lt;/em&gt; 시스템이 있습니다. 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="a739f17951b6e075a348a61e8bb0affec3a10686" translate="yes" xml:space="preserve">
          <source>If we declared &lt;code&gt;cities&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt; to be &lt;code&gt;UNIQUE&lt;/code&gt; or a &lt;code&gt;PRIMARY KEY&lt;/code&gt;, this would not stop the &lt;code&gt;capitals&lt;/code&gt; table from having rows with names duplicating rows in &lt;code&gt;cities&lt;/code&gt;. And those duplicate rows would by default show up in queries from &lt;code&gt;cities&lt;/code&gt;. In fact, by default &lt;code&gt;capitals&lt;/code&gt; would have no unique constraint at all, and so could contain multiple rows with the same name. You could add a unique constraint to &lt;code&gt;capitals&lt;/code&gt;, but this would not prevent duplication compared to &lt;code&gt;cities&lt;/code&gt;.</source>
          <target state="translated">우리가 &lt;code&gt;cities&lt;/code&gt; 를 선언한다면 . &lt;code&gt;name&lt;/code&gt; 은 &lt;code&gt;UNIQUE&lt;/code&gt; 또는 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 이므로 &lt;code&gt;capitals&lt;/code&gt; 테이블이 &lt;code&gt;cities&lt;/code&gt; 에서 행을 복제하는 이름을 가진 행을 가지지 않습니다 . 중복 된 행은 기본적으로 &lt;code&gt;cities&lt;/code&gt; 쿼리에 표시됩니다 . 실제로 기본적으로 &lt;code&gt;capitals&lt;/code&gt; 는 고유 제한 조건이 없으므로 동일한 이름을 가진 여러 행을 포함 할 수 있습니다. &lt;code&gt;capitals&lt;/code&gt; 고유 한 제약 조건을 추가 할 수 있지만 &lt;code&gt;cities&lt;/code&gt; 비해 중복을 방지 할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="347337a04b51d83bd4c64fbb8fed60949423b25a" translate="yes" xml:space="preserve">
          <source>If we wanted to know what city (or cities) that reading occurred in, we might try:</source>
          <target state="translated">읽는 도시가 무엇인지 알고 싶다면 다음을 시도해보십시오.</target>
        </trans-unit>
        <trans-unit id="d101ff564aae9ba45b998f26d6b5819ae89be6cf" translate="yes" xml:space="preserve">
          <source>If we were to declare this index &lt;code&gt;UNIQUE&lt;/code&gt;, it would prevent creation of rows whose &lt;code&gt;col1&lt;/code&gt; values differ only in case, as well as rows whose &lt;code&gt;col1&lt;/code&gt; values are actually identical. Thus, indexes on expressions can be used to enforce constraints that are not definable as simple unique constraints.</source>
          <target state="translated">이 인덱스를 &lt;code&gt;UNIQUE&lt;/code&gt; 로 선언하면 &lt;code&gt;col1&lt;/code&gt; 값이 실제로 동일한 행뿐만 아니라 &lt;code&gt;col1&lt;/code&gt; 값이 다른 행만 작성할 수 없습니다 . 따라서 표현식의 인덱스를 사용하여 단순한 고유 제한 조건으로 정의 할 수없는 제한 조건을 시행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26385616d9682a5e8b9897f0b99ebecc8622b226" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">지속적으로 유지되는 일관성 보장이 아니라 행 삽입시 다른 행에 대해 일회성 검사를 원하는 경우 사용자 지정 &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;트리거&lt;/a&gt; 를 사용하여이를 구현할 수 있습니다. (이 방법은 pg_dump가 데이터를 다시로드 한 후에 트리거를 다시 설치하지 않으므로 덤프 / 다시로드 문제가 발생하지 않으므로 덤프 / 다시로드 중에 확인이 적용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="bccf2a93440f14e5520a966b4714acd9fc9f1297" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">원하는 것이 연속적으로 유지되는 일관성 보장이 아니라 행 삽입시 다른 행에 대한 일회성 검사 인 경우 사용자 지정 &lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;트리거&lt;/a&gt; 를 사용하여이를 구현할 수 있습니다. (이 방법은 pg_dump가 데이터를 다시로드 할 때까지 트리거를 다시 설치하지 않으므로 덤프 / 다시로드 중에 검사가 시행되지 않기 때문에 덤프 / 다시로드 문제를 방지합니다.)</target>
        </trans-unit>
        <trans-unit id="1a14ecb62361bc225683313f20ed64062f67ccd0" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">이미 큰 개체가 있거나 고아 인 것으로 의심되는 경우 &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; 모듈을 참조하여 정리하십시오. &lt;code&gt;lo_manage&lt;/code&gt; 트리거 에 대한 백스톱 으로 vacuumlo를 가끔 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9d59e957767c53445cccc5f8621efd7719624cb5" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/13/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">고아가 된 대형 개체가 이미 있거나 있다고 의심되는 경우, 이를 정리하는 데 도움이 되는 &lt;a href=&quot;https://www.postgresql.org/docs/13/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; 모듈을 참조하십시오 . &lt;code&gt;lo_manage&lt;/code&gt; 트리거 에 대한 백스톱으로 가끔 vacuumlo를 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f390f29503d5d3e24b107064bb2a33c6ee6ea964" translate="yes" xml:space="preserve">
          <source>If you are adding large amounts of data to an existing table, it might be a win to drop the indexes, load the table, and then recreate the indexes. Of course, the database performance for other users might suffer during the time the indexes are missing. One should also think twice before dropping a unique index, since the error checking afforded by the unique constraint will be lost while the index is missing.</source>
          <target state="translated">기존 테이블에 많은 양의 데이터를 추가하는 경우 인덱스를 삭제하고 테이블을로드 한 다음 인덱스를 다시 작성하는 것이 좋습니다. 물론 인덱스가 누락 된 동안 다른 사용자의 데이터베이스 성능이 저하 될 수 있습니다. 고유 제한 조건에 의해 제공된 오류 점검은 색인이 누락 된 동안 유실되므로 고유 색인을 삭제하기 전에 두 번 생각해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9e2dec1d154e8ddecdda1dfc7964b3ebcabb443" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">PostgreSQL을 직접 설치하는 경우 설치 지침은 &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;16 장&lt;/a&gt; 을 참조 하고 설치가 완료되면이 안내서로 돌아가십시오. 적절한 환경 변수 설정에 대한 섹션을 자세히 따르십시오.</target>
        </trans-unit>
        <trans-unit id="cd8e24142c807e0a347a699916b6cae27e9af283" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">PostgreSQL을 직접 설치하는 경우 &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;16 장&lt;/a&gt; 에서 설치 지침 을 참조 하고 설치가 완료되면이 가이드로 돌아 오십시오. 적절한 환경 변수 설정에 대한 섹션을 자세히 따르십시오.</target>
        </trans-unit>
        <trans-unit id="deb64bee8b7a2efcbeba6cf8a6dff70e83085729" translate="yes" xml:space="preserve">
          <source>If you are loading a freshly created table, the fastest method is to create the table, bulk load the table's data using &lt;code&gt;COPY&lt;/code&gt;, then create any indexes needed for the table. Creating an index on pre-existing data is quicker than updating it incrementally as each row is loaded.</source>
          <target state="translated">새로 작성된 테이블을로드하는 경우 가장 빠른 방법은 테이블을 작성하고 &lt;code&gt;COPY&lt;/code&gt; 를 사용하여 테이블의 데이터를 대량로드 한 다음 테이블에 필요한 인덱스를 작성하는 것입니다. 기존 데이터에 대한 인덱스를 만드는 것이 각 행이로드 될 때 점차적으로 업데이트하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d87d9e34c581612e87603daaced88774ab9fe111" translate="yes" xml:space="preserve">
          <source>If you are not planning to use prepared transactions, this parameter should be set to zero to prevent accidental creation of prepared transactions. If you are using prepared transactions, you will probably want &lt;code&gt;max_prepared_transactions&lt;/code&gt; to be at least as large as &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;, so that every session can have a prepared transaction pending.</source>
          <target state="translated">준비된 트랜잭션을 사용하지 않으려는 경우 실수로 준비된 트랜잭션이 작성되지 않도록이 매개 변수를 0으로 설정해야합니다. 준비된 트랜잭션을 사용 하는 경우 모든 세션이 준비된 트랜잭션 보류를 가질 수 있도록 &lt;code&gt;max_prepared_transactions&lt;/code&gt; 가 최소한 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; 만큼 커지길 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ca7f65648bc353887b727a182f8f612fdb9429de" translate="yes" xml:space="preserve">
          <source>If you are not sure whether PostgreSQL is already available or whether you can use it for your experimentation then you can install it yourself. Doing so is not hard and it can be a good exercise. PostgreSQL can be installed by any unprivileged user; no superuser (root) access is required.</source>
          <target state="translated">PostgreSQL이 이미 사용 가능한지 또는 실험에 사용할 수 있는지 확실하지 않은 경우 직접 설치할 수 있습니다. 그렇게하는 것은 어렵지 않으며 좋은 운동이 될 수 있습니다. 권한이없는 사용자는 PostgreSQL을 설치할 수 있습니다. 수퍼 유저 (루트) 액세스가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c854ded65666fb7e53665772a506fafbd718961" translate="yes" xml:space="preserve">
          <source>If you are running file-based log shipping (&quot;warm standby&quot;), you might need to wait until the next WAL file arrives, which could be as long as the &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary.</source>
          <target state="translated">파일 기반 로그 전달 ( &quot;warm standby&quot;)을 실행중인 경우 다음 WAL 파일이 도착할 때까지 기다려야 할 수 있습니다 .이 값은 기본 에서 &lt;code&gt;archive_timeout&lt;/code&gt; 설정일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="100df6210b436366664b5674494d353d329c78c1" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g. &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">구성 파일 전용 디렉토리를 사용하는 PostgreSQL 9.2 이전 클러스터를 업그레이드하는 경우 실제 데이터 디렉토리 위치를 pg_upgrade로 전달하고 구성 디렉토리 위치를 서버로 전달해야합니다 (예 : &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc55bda54288eb26294b0ebbfc29f843e85f5f66" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g., &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">구성 파일 전용 디렉토리를 사용하는 PostgreSQL 9.2 이전 클러스터를 업그레이드하는 경우 실제 데이터 디렉토리 위치를 pg_upgrade에 전달하고 구성 디렉토리 위치를 서버에 전달해야합니다 (예 : &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6433dfa1c8ec93408de2c79d0f13ec3cb038d812" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, change &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;replica&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;10 단계에&lt;/a&gt; 요약 된 방법을 사용하여 대기 서버를 업그레이드 하는 경우 이전 기본 및 대기 클러스터에 대해 pg_controldata를 실행하여 이전 대기 서버가 걸리는지 확인하십시오. &amp;ldquo;최신 체크 포인트 위치&amp;rdquo;값이 모든 클러스터에서 일치하는지 확인하십시오. (이전 대기 서버가 이전 기본 서버 이전에 종료되었거나 이전 대기 서버가 여전히 실행중인 경우 불일치가 발생합니다.) 또한 새 기본 클러스터 의 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 에서 &lt;code&gt;wal_level&lt;/code&gt; 을 &lt;code&gt;replica&lt;/code&gt; 로 변경 하십시오.</target>
        </trans-unit>
        <trans-unit id="a25fedf0ac6ffff68a2762449d5371eee093e033" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, make sure &lt;code&gt;wal_level&lt;/code&gt; is not set to &lt;code&gt;minimal&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;10 단계&lt;/a&gt; 섹션에 설명 된 방법을 사용하여 대기 서버를 업그레이드 하는 경우 이전 기본 및 대기 클러스터에 대해 pg_controldata를 실행하여 이전 대기 서버가 포착되었는지 확인합니다. &quot;최신 체크 포인트 위치&quot;값이 모든 클러스터에서 일치하는지 확인합니다. (이전 대기 서버가 이전 기본 서버보다 먼저 종료되었거나 이전 대기 서버가 여전히 실행중인 경우 불일치가 발생합니다.) 또한 새 기본 클러스터 의 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 에서 &lt;code&gt;wal_level&lt;/code&gt; 이 &lt;code&gt;minimal&lt;/code&gt; 로 설정되어 있지 않은지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f73d78215cef8d2ef14222445477bdca411ef71" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;-X none&lt;/code&gt;, there is no guarantee that all WAL files required for the backup are archived at the end of backup.</source>
          <target state="translated">&lt;code&gt;-X none&lt;/code&gt; 을 사용 하는 경우 백업에 필요한 모든 WAL 파일이 백업 종료시 아카이브된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d0f772d8182283e7e8eeabb4a80f986e054e96a" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, and you used its provisions for starting the server, then you should also use its provisions for stopping the server. Consult the package-level documentation for details.</source>
          <target state="translated">PostgreSQL의 사전 패키지 버전을 사용 중이고 서버 시작에 해당 프로비저닝을 사용한 경우 해당 프로비저닝도 서버 중지에 사용해야합니다. 자세한 내용은 패키지 수준 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc432d389e68b3790013be9ab641ccb60838ff96" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, it almost certainly includes provisions for running the server as a background task according to the conventions of your operating system. Using the package's infrastructure to start the server will be much less work than figuring out how to do this yourself. Consult the package-level documentation for details.</source>
          <target state="translated">PostgreSQL의 사전 패키지 버전을 사용하는 경우 운영 체제의 규칙에 따라 서버를 백그라운드 작업으로 실행하기위한 조항이 거의 확실하게 포함됩니다. 패키지의 인프라를 사용하여 서버를 시작하는 것은 직접 수행하는 방법을 알아내는 것보다 훨씬 적은 작업입니다. 자세한 내용은 패키지 수준 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ec81265be63b85cd110675b546ea20c69a22e29" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, it may well have a specific convention for where to place the data directory, and it may also provide a script for creating the data directory. In that case you should use that script in preference to running &lt;code&gt;initdb&lt;/code&gt; directly. Consult the package-level documentation for details.</source>
          <target state="translated">PostgreSQL의 사전 패키지 버전을 사용하는 경우 데이터 디렉터리를 배치 할 위치에 대한 특정 규칙이있을 수 있으며 데이터 디렉터리를 생성하기위한 스크립트도 제공 할 수 있습니다. 이 경우 &lt;code&gt;initdb&lt;/code&gt; 를 직접 실행하는 것보다 해당 스크립트를 사용해야합니다 . 자세한 내용은 패키지 수준 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e87540bbfb46f5ca553285a02a78a4413f99dfe1" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g. &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">버전 별 설치 디렉토리 (예 : &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt; )를 사용하는 경우 이전 클러스터를 이동할 필요가 없습니다. 그래픽 설치 프로그램은 모두 버전 별 설치 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d8bbcc7b0eac5395154e7966b802a1726a037170" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g., &lt;code&gt;/opt/PostgreSQL/13&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">버전 별 설치 디렉토리 (예 : &lt;code&gt;/opt/PostgreSQL/13&lt;/code&gt; )를 사용하는 경우 이전 클러스터를 이동할 필요가 없습니다. 그래픽 설치 프로그램은 모두 버전 별 설치 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="afb6b5bbb35f9c84113d155adac8b2ce50841366" translate="yes" xml:space="preserve">
          <source>If you are using manual &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; commands, don't forget that you need to run them on each child table individually. A command like:</source>
          <target state="translated">수동 &lt;code&gt;VACUUM&lt;/code&gt; 또는 &lt;code&gt;ANALYZE&lt;/code&gt; 명령을 사용하는 경우 각 하위 테이블에서 개별적으로 명령을 실행해야합니다. 다음과 같은 명령 :</target>
        </trans-unit>
        <trans-unit id="657742cf08661b004524bce37cea4f60251b3473" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g. solid-state drives, might also be better modeled with a lower value for random_page_cost.</source>
          <target state="translated">90 %의 캐시 속도가 워크로드에 대해 잘못된 가정이라고 생각되면 random_page_cost를 증가시켜 실제 스토리지 읽기 비용을 더 잘 반영 할 수 있습니다. 따라서 데이터베이스가 총 서버 메모리보다 작은 경우와 같이 데이터가 캐시에 완전히있을 가능성이있는 경우 random_page_cost를 줄이는 것이 적절할 수 있습니다. 순차 드라이브 (예 : 솔리드 스테이트 드라이브)에 비해 랜덤 읽기 비용이 낮은 스토리지는 random_page_cost 값이 낮을수록 더 잘 모델링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01590de3b1a45b503095ec546feb704e9b7a0246" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g., solid-state drives, might also be better modeled with a lower value for random_page_cost, e.g., &lt;code&gt;1.1&lt;/code&gt;.</source>
          <target state="translated">90 % 캐시 비율이 워크로드에 대한 잘못된 가정이라고 생각되면 random_page_cost를 늘려 임의 스토리지 읽기의 실제 비용을 더 잘 반영 할 수 있습니다. 따라서 데이터베이스가 전체 서버 메모리보다 작은 경우와 같이 데이터가 완전히 캐시에있을 가능성이있는 경우 random_page_cost를 줄이는 것이 적절할 수 있습니다. 순차에 비해 무작위 읽기 비용이 낮은 스토리지 (예 : 솔리드 스테이트 드라이브)는 random_page_cost 값 (예 : &lt;code&gt;1.1&lt;/code&gt; ) 을 더 낮게 설정하는 것이 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="de352785d4d320deb71e5335924b75625cf49620" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;\set&lt;/code&gt; without a second argument, the variable is set to an empty-string value. To unset (i.e., delete) a variable, use the command &lt;code&gt;\unset&lt;/code&gt;. To show the values of all variables, call &lt;code&gt;\set&lt;/code&gt; without any argument.</source>
          <target state="translated">두 번째 인수없이 &lt;code&gt;\set&lt;/code&gt; 을 호출 하면 변수가 빈 문자열 값으로 설정됩니다. 변수를 설정 해제 (즉, 삭제)하려면 &lt;code&gt;\unset&lt;/code&gt; 명령을 사용하십시오 . 모든 변수의 값을 표시하려면 인수없이 &lt;code&gt;\set&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="0259699cb6f3b30e1cd0e413c4e39248024e19a0" translate="yes" xml:space="preserve">
          <source>If you cannot free up additional space on the disk by deleting other things, you can move some of the database files to other file systems by making use of tablespaces. See &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt; for more information about that.</source>
          <target state="translated">다른 항목을 삭제하여 디스크의 추가 공간을 확보 할 수없는 경우 테이블 스페이스를 사용하여 일부 데이터베이스 파일을 다른 파일 시스템으로 이동할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;22.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6b2ee409cca3f880cf89818705f66642823737c" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;code&gt;COPY&lt;/code&gt;, it might help to use &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; to create a prepared &lt;code&gt;INSERT&lt;/code&gt; statement, and then use &lt;code&gt;EXECUTE&lt;/code&gt; as many times as required. This avoids some of the overhead of repeatedly parsing and planning &lt;code&gt;INSERT&lt;/code&gt;. Different interfaces provide this facility in different ways; look for &amp;ldquo;prepared statements&amp;rdquo; in the interface documentation.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 를 사용할 수없는 경우 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; 를 사용하여 준비된 &lt;code&gt;INSERT&lt;/code&gt; 문 을 작성한 후 &lt;code&gt;EXECUTE&lt;/code&gt; 를 필요한만큼 사용 하는 것이 도움이 될 수 있습니다 . 이렇게하면 &lt;code&gt;INSERT&lt;/code&gt; 반복 구문 분석 및 계획의 오버 헤드가 발생하지 않습니다 . 인터페이스마다 다른 방식으로이 기능을 제공합니다. 인터페이스 설명서에서 &quot;준비된 명령문&quot;을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="f74f5e82fb19007ba8087ea69c4af7c169641fbd" translate="yes" xml:space="preserve">
          <source>If you cannot, then better do crypto inside client application.</source>
          <target state="translated">당신이 할 수 없다면, 클라이언트 응용 프로그램 내부에서 암호화를하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6938a67160fbaea3812e5c1afc009d637ef7fc7" translate="yes" xml:space="preserve">
          <source>If you declare a column as &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt;, the implicitly generated index is case-sensitive. So it's useless for case-insensitive searches, and it won't enforce uniqueness case-insensitively.</source>
          <target state="translated">열을 &lt;code&gt;UNIQUE&lt;/code&gt; 또는 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 로 선언 하면 내재적으로 생성 된 인덱스는 대소 문자를 구분합니다. 따라서 대소 문자를 구분하지 않는 검색에는 쓸모가 없으며 대소 문자를 구분하지 않고 고유성을 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bab8b24944cb37a1a0e9e93c41e90f5a2cb6ccb4" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; start the new cluster, the old cluster was unmodified except that, when linking started, a &lt;code&gt;.old&lt;/code&gt; suffix was appended to &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;. To reuse the old cluster, remove the &lt;code&gt;.old&lt;/code&gt; suffix from &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;; you can then restart the old cluster.</source>
          <target state="translated">당신이 않았다면 &lt;em&gt;하지&lt;/em&gt; 시작 링크 할 때 새 클러스터를 시작, 기존 클러스터는 점을 제외하고 수정되지 않은했다,하는 &lt;code&gt;.old&lt;/code&gt; 로 접미사에 추가 된 &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; . 이전 클러스터를 재사용하려면 &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; 에서 &lt;code&gt;.old&lt;/code&gt; 접미 부를 제거하십시오 . 그런 다음 이전 클러스터를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b2adb362a08de49cfa1c83dea8a83d9bb2213c" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; use link mode, do not have or do not want to use rsync, or want an easier solution, skip the instructions in this section and simply recreate the standby servers once pg_upgrade completes and the new primary is running.</source>
          <target state="translated">당신이 않은 경우 &lt;em&gt;하지&lt;/em&gt; 링크 모드를 사용하지 않거나 rsync를 사용하지 않거나, 쉬운 솔루션을 원하는,이 섹션의 지침을 건너 뛰고 pg_upgrade이 완료 및 새 기본이 실행되면 대기 서버를 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="90981d7a01c90cf36de6cae3508f26abcc450f7b" translate="yes" xml:space="preserve">
          <source>If you did start the new cluster, it has written to shared files and it is unsafe to use the old cluster. The old cluster will need to be restored from backup in this case.</source>
          <target state="translated">새 클러스터를 시작한 경우 공유 파일에 기록되었으며 이전 클러스터를 사용하는 것이 안전하지 않습니다. 이 경우 이전 클러스터를 백업에서 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="47fd87d8debe284e9f481467ae1affc261e54ea8" translate="yes" xml:space="preserve">
          <source>If you do not like the output format for &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; values, try the functions &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, and &lt;code&gt;abbrev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 또는 &lt;code&gt;cidr&lt;/code&gt; 값 의 출력 형식이 마음에 들지 않으면 &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;text&lt;/code&gt; 및 &lt;code&gt;abbrev&lt;/code&gt; 함수를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="f96a8ec302a42bc03e998712a66f544972ee1509" translate="yes" xml:space="preserve">
          <source>If you do not succeed in adjusting the costs to be more appropriate, then you might have to resort to forcing index usage explicitly. You might also want to contact the PostgreSQL developers to examine the issue.</source>
          <target state="translated">비용을보다 적절하게 조정하는 데 성공하지 못하면 인덱스 사용을 명시 적으로 강제해야합니다. PostgreSQL 개발자에게 문의하여 문제를 조사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4cd7de986e411178ee91fc3fe47680a23518cd4" translate="yes" xml:space="preserve">
          <source>If you do not supply the database name then it will default to your user account name. You already discovered this scheme in the previous section using &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">데이터베이스 이름을 제공하지 않으면 기본적으로 사용자 계정 이름이 사용됩니다. 이전 섹션에서 &lt;code&gt;createdb&lt;/code&gt; 를 사용하여이 체계를 이미 발견했습니다 .</target>
        </trans-unit>
        <trans-unit id="be339a6a88d4d2b9b65bab603b8e3c0d2fd399fd" translate="yes" xml:space="preserve">
          <source>If you do not want to use your database anymore you can remove it. For example, if you are the owner (creator) of the database &lt;code&gt;mydb&lt;/code&gt;, you can destroy it using the following command:</source>
          <target state="translated">더 이상 데이터베이스를 사용하지 않으려면 제거 할 수 있습니다. 예를 들어, &lt;code&gt;mydb&lt;/code&gt; 데이터베이스의 소유자 (작성자) 인 경우 다음 명령을 사용하여 데이터베이스 를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e08381cd8f923213bb0bae5a2a61f673142186" translate="yes" xml:space="preserve">
          <source>If you don't have values for all the columns, you can omit some of them. In that case, the columns will be filled with their default values. For example:</source>
          <target state="translated">모든 열에 대한 값이없는 경우 일부 열을 생략 할 수 있습니다. 이 경우 열이 기본값으로 채워집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="404e82d0a58303983c4b5022b612f1fb6248be48" translate="yes" xml:space="preserve">
          <source>If you drop and then recreate a function, the new function is not the same entity as the old; you will have to drop existing rules, views, triggers, etc. that refer to the old function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; to change a function definition without breaking objects that refer to the function. Also, &lt;code&gt;ALTER FUNCTION&lt;/code&gt; can be used to change most of the auxiliary properties of an existing function.</source>
          <target state="translated">함수를 삭제 한 다음 다시 작성하면 새 함수는 이전 함수와 동일한 엔티티가 아닙니다. 기존 기능을 참조하는 기존 규칙,보기, 트리거 등을 삭제해야합니다. 함수를 참조하는 오브젝트를 손상시키지 않고 함수 정의를 변경 하려면 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 을 사용 하십시오. 또한 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 을 사용하여 기존 기능의 대부분의 보조 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be307ca6bbc030429d0d787ca8543b0973b17c65" translate="yes" xml:space="preserve">
          <source>If you encounter problems starting &lt;code&gt;psql&lt;/code&gt; then go back to the previous section. The diagnostics of &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;psql&lt;/code&gt; are similar, and if the former worked the latter should work as well.</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; 을 시작하는 데 문제가 발생 하면 이전 섹션으로 돌아가십시오. &lt;code&gt;createdb&lt;/code&gt; 및 &lt;code&gt;psql&lt;/code&gt; 의 진단 은 비슷하며 전자가 작동하면 후자가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b13cd3cf02514f3a86f3431f0fe84ad64d68a6f3" translate="yes" xml:space="preserve">
          <source>If you feel you need more introductory material, please visit the PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;web site&lt;/a&gt; for links to more resources.</source>
          <target state="translated">더 많은 소개 자료가 필요하다고 생각되면 PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;웹 사이트&lt;/a&gt; 를 방문하여 더 많은 리소스에 대한 링크를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="27223facca9dbba24447f51ca3cc46e2a4d4b2ed" translate="yes" xml:space="preserve">
          <source>If you get an &amp;ldquo;illegal system call&amp;rdquo; error, it is likely that shared memory or semaphores are not supported in your kernel at all. In that case your only option is to reconfigure the kernel to enable these features.</source>
          <target state="translated">&quot;잘못된 시스템 호출&quot;오류가 발생하면 커널에서 공유 메모리 또는 세마포어가 전혀 지원되지 않을 수 있습니다. 이 경우 유일한 기능은 이러한 기능을 사용하도록 커널을 재구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7aa554ad85b0e28436475081421e4e00eaf4dd3c" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; turned off, any backslashes you write in literal string constants will need to be doubled. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; 를 끈 경우 리터럴 문자열 상수로 쓰는 백 슬래시를 두 배로 늘려야합니다. 자세한 정보는 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;4.1.2.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f61cc65bca02db4eb1ea500b6eae076fd93f0491" translate="yes" xml:space="preserve">
          <source>If you have a dedicated database server with 1GB or more of RAM, a reasonable starting value for &lt;code&gt;shared_buffers&lt;/code&gt; is 25% of the memory in your system. There are some workloads where even larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; are effective, but because PostgreSQL also relies on the operating system cache, it is unlikely that an allocation of more than 40% of RAM to &lt;code&gt;shared_buffers&lt;/code&gt; will work better than a smaller amount. Larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; usually require a corresponding increase in &lt;code&gt;max_wal_size&lt;/code&gt;, in order to spread out the process of writing large quantities of new or changed data over a longer period of time.</source>
          <target state="translated">RAM이 1GB 이상인 전용 데이터베이스 서버가있는 경우 &lt;code&gt;shared_buffers&lt;/code&gt; 의 합리적인 시작 값은 시스템 메모리의 25 %입니다. &lt;code&gt;shared_buffers&lt;/code&gt; 에 대한 더 큰 설정 이 효과적인 워크로드가 있지만 PostgreSQL도 운영 체제 캐시에 의존하기 때문에 &lt;code&gt;shared_buffers&lt;/code&gt; 에 RAM의 40 % 이상이 더 적은 양보다 더 잘 할당되지는 않습니다 . &lt;code&gt;shared_buffers&lt;/code&gt; 에 대한 더 큰 설정은 일반적으로 더 많은 양의 새로운 또는 변경된 데이터를 작성하는 프로세스를 더 오랜 기간에 걸쳐 확산시키기 위해 &lt;code&gt;max_wal_size&lt;/code&gt; 의 해당 증가를 필요로합니다 .</target>
        </trans-unit>
        <trans-unit id="5955ce4878872fc7d42a5cf4a3feceaf0ce085c2" translate="yes" xml:space="preserve">
          <source>If you have a table that contains both billed and unbilled orders, where the unbilled orders take up a small fraction of the total table and yet those are the most-accessed rows, you can improve performance by creating an index on just the unbilled rows. The command to create the index would look like this:</source>
          <target state="translated">청구되지 않은 주문과 청구되지 않은 주문이 모두 포함 된 테이블이있는 경우, 청구되지 않은 주문이 전체 테이블의 일부를 차지하지만 가장 많이 액세스되는 행인 경우 청구되지 않은 행에 대해서만 색인을 작성하여 성능을 향상시킬 수 있습니다. 색인을 작성하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3db868f1aa52b4182eabc5a6aaef64ca58b29be3" translate="yes" xml:space="preserve">
          <source>If you have a table whose entire contents are deleted on a periodic basis, consider doing it with &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; rather than using &lt;code&gt;DELETE&lt;/code&gt; followed by &lt;code&gt;VACUUM&lt;/code&gt;. &lt;code&gt;TRUNCATE&lt;/code&gt; removes the entire content of the table immediately, without requiring a subsequent &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; to reclaim the now-unused disk space. The disadvantage is that strict MVCC semantics are violated.</source>
          <target state="translated">전체 내용이 주기적으로 삭제 된 테이블이있는 경우 &lt;code&gt;DELETE&lt;/code&gt; 와 &lt;code&gt;VACUUM&lt;/code&gt; 을 사용하지 말고 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE를&lt;/a&gt; 사용하여 수행 하십시오 . &lt;code&gt;TRUNCATE&lt;/code&gt; 는 현재 사용하지 않는 디스크 공간을 되찾기 위해 후속 &lt;code&gt;VACUUM&lt;/code&gt; 또는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 요구하지 않고 테이블의 전체 내용을 즉시 제거합니다 . 단점은 엄격한 MVCC 시맨틱이 위반된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="edada2f4a0ea8a1fe6f35435a51d724440a997b9" translate="yes" xml:space="preserve">
          <source>If you have a user account but it does not have the privileges required to create a database, you will see the following:</source>
          <target state="translated">사용자 계정이 있지만 데이터베이스를 작성하는 데 필요한 권한이없는 경우 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e1ffd7834998be91b2b3ef3885c4c95ac1fca94" translate="yes" xml:space="preserve">
          <source>If you have an embedded SQL C source file named &lt;code&gt;prog1.pgc&lt;/code&gt;, you can create an executable program using the following sequence of commands:</source>
          <target state="translated">&lt;code&gt;prog1.pgc&lt;/code&gt; 라는 내장 SQL C 소스 파일이있는 경우 다음 명령 시퀀스를 사용하여 실행 가능 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a617edae0e90918be65ecbfa41a4edb3f6fbb0d" translate="yes" xml:space="preserve">
          <source>If you have dug into the details of the file system layout of the database, you might be tempted to try to back up or restore only certain individual tables or databases from their respective files or directories. This will &lt;em&gt;not&lt;/em&gt; work because the information contained in these files is not usable without the commit log files, &lt;code&gt;pg_xact/*&lt;/code&gt;, which contain the commit status of all transactions. A table file is only usable with this information. Of course it is also impossible to restore only a table and the associated &lt;code&gt;pg_xact&lt;/code&gt; data because that would render all other tables in the database cluster useless. So file system backups only work for complete backup and restoration of an entire database cluster.</source>
          <target state="translated">데이터베이스의 파일 시스템 레이아웃에 대한 세부 사항을 파헤친 경우 해당 파일 또는 디렉토리에서 특정 개별 테이블 또는 데이터베이스 만 백업하거나 복원하려고 시도 할 수 있습니다. 이 의지 &lt;em&gt;하지&lt;/em&gt; (가) 로그 파일을 커밋하지 않고 작업은이 파일에 포함 된 정보는 사용할 수 없습니다 때문에 &lt;code&gt;pg_xact/*&lt;/code&gt; 는 모든 트랜잭션의 상태를 커밋이 포함되어있다. 이 정보만으로 테이블 파일을 사용할 수 있습니다. 물론 데이터베이스 클러스터의 다른 모든 테이블을 쓸모 없게 만들므로 테이블과 관련 &lt;code&gt;pg_xact&lt;/code&gt; 데이터 만 복원하는 것도 불가능합니다 . 따라서 파일 시스템 백업은 전체 데이터베이스 클러스터의 완전한 백업 및 복원에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b1fdfd0de9a85f5bba1c48c08c54c2308c8c0754" translate="yes" xml:space="preserve">
          <source>If you have not set up an external transaction manager to track prepared transactions and ensure they get closed out promptly, it is best to keep the prepared-transaction feature disabled by setting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; to zero. This will prevent accidental creation of prepared transactions that might then be forgotten and eventually cause problems.</source>
          <target state="translated">준비된 트랜잭션을 추적하고 즉시 닫히도록 외부 트랜잭션 관리자를 설정하지 않은 경우 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; 를 0 으로 설정하여 준비된 트랜잭션 기능을 사용하지 않는 것이 가장 좋습니다 . 이렇게하면 실수로 준비된 트랜잭션이 생성되지 않고 잊혀져 결국에는 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4113594099b8ceaba5516ae6559f67b321dd3f1a" translate="yes" xml:space="preserve">
          <source>If you have pattern matching needs that go beyond this, consider writing a user-defined function in Perl or Tcl.</source>
          <target state="translated">이 이상의 패턴 일치 요구가있는 경우 Perl 또는 Tcl에서 사용자 정의 함수 작성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aedcf3e1663bdb52e36d3e2d02ae7396863fa330" translate="yes" xml:space="preserve">
          <source>If you have relocated &lt;code&gt;pg_wal&lt;/code&gt; outside the data directories, rsync must be run on those directories too.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; 을 데이터 디렉토리 외부 로 재배치 한 경우 해당 디렉토리에서도 rsync를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="66e124e77e26c68b2716b8eb55653604cd884707" translate="yes" xml:space="preserve">
          <source>If you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;, you might also want to configure your kernel to lock System V shared memory into RAM and prevent it from being paged out to swap. This can be accomplished using the &lt;code&gt;sysctl&lt;/code&gt; setting &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_memory_type&lt;/code&gt; 을 &lt;code&gt;sysv&lt;/code&gt; 로 설정 한 경우 System V 공유 메모리를 RAM에 잠그고 스왑을 위해 페이지 아웃되지 않도록 커널을 구성 할 수도 있습니다. 이는 &lt;code&gt;sysctl&lt;/code&gt; 설정 &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt; 를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a07426ce8ecfc80c9d7a4edfcb98cf0ba611138f" translate="yes" xml:space="preserve">
          <source>If you have tablespaces, you will need to run a similar rsync command for each tablespace directory, e.g.:</source>
          <target state="translated">테이블 스페이스가있는 경우 각 테이블 스페이스 디렉토리에 대해 유사한 rsync 명령을 실행해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="74d92589027830b748d75a72665251c799371e5f" translate="yes" xml:space="preserve">
          <source>If you have the space to do so, copy the whole cluster data directory and any tablespaces to a temporary location in case you need them later. Note that this precaution will require that you have enough free space on your system to hold two copies of your existing database. If you do not have enough space, you should at least save the contents of the cluster's &lt;code&gt;pg_wal&lt;/code&gt; subdirectory, as it might contain logs which were not archived before the system went down.</source>
          <target state="translated">필요한 공간이 있으면 나중에 필요할 경우 전체 클러스터 데이터 디렉토리 및 테이블 스페이스를 임시 위치에 복사하십시오. 이 예방 조치를 수행하려면 시스템에 기존 데이터베이스의 두 사본을 보유 할 수있는 충분한 여유 공간이 있어야합니다. 공간이 충분하지 않으면 시스템이 다운되기 전에 아카이브되지 않은 로그를 포함 할 수 있으므로 적어도 클러스터의 &lt;code&gt;pg_wal&lt;/code&gt; 서브 디렉토리 의 내용을 저장해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c405c350a4bec28b591f01ed6531218b06904979" translate="yes" xml:space="preserve">
          <source>If you have to &amp;ldquo;hop&amp;rdquo; to the database server via some login host, one possible setup could look like this:</source>
          <target state="translated">일부 로그인 호스트를 통해 데이터베이스 서버에 &quot;홉&quot;해야하는 경우 가능한 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1467a82f0f1d2aed2302c816a743bd03ff5d6fe" translate="yes" xml:space="preserve">
          <source>If you have turned off &lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt; then the activity indicator is not updated; the process title is set only once when a new process is launched. On some platforms this saves a measurable amount of per-command overhead; on others it's insignificant.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt; 을 끄면 활동 표시기가 업데이트되지 않습니다. 프로세스 제목은 새 프로세스가 시작될 때 한 번만 설정됩니다. 일부 플랫폼에서는 측정 가능한 명령 당 오버 헤드가 줄어 듭니다. 다른 사람들에게는 그것은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cdc8af27dd93a99e3339ed60a27d59629c7d68fb" translate="yes" xml:space="preserve">
          <source>If you have unarchived WAL segment files that you saved in step 2, copy them into &lt;code&gt;pg_wal/&lt;/code&gt;. (It is best to copy them, not move them, so you still have the unmodified files if a problem occurs and you have to start over.)</source>
          <target state="translated">2 단계에서 저장 한 WAL 세그먼트 파일을 아카이브하지 않은 경우 &lt;code&gt;pg_wal/&lt;/code&gt; 복사하십시오 . (복사하지 말고 복사하는 것이 가장 좋습니다. 따라서 문제가 발생하여 다시 시작해야하는 경우 수정되지 않은 파일이 남아 있습니다.)</target>
        </trans-unit>
        <trans-unit id="f602421c44c7955b1682bc7b3fca54acb52d429c" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g. &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 를 수정 한 경우 원래 설정을 복원하십시오. 이전 클러스터와 일치하도록 새 클러스터의 다른 구성 파일 (예 : &lt;code&gt;postgresql.conf&lt;/code&gt; ) 을 조정해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbf1fa6cfeb52f4146529fb315f1682db9559aaa" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g., &lt;code&gt;postgresql.conf&lt;/code&gt; (and any files included by it), &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 를 수정 한 경우 원래 설정을 복원하십시오. 이전 클러스터와 일치하도록 새 클러스터의 다른 구성 파일을 조정해야 할 수도 있습니다 ( 예 : &lt;code&gt;postgresql.conf&lt;/code&gt; (및 여기에 포함 된 모든 파일), &lt;code&gt;postgresql.auto.conf&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="9316b03fae64e8c508527fbd0a6b640ef4256fda" translate="yes" xml:space="preserve">
          <source>If you modify files in &lt;code&gt;.../share/timezonesets/&lt;/code&gt;, it is up to you to make backups &amp;mdash; a normal database dump will not include this directory.</source>
          <target state="translated">&lt;code&gt;.../share/timezonesets/&lt;/code&gt; 에서 파일을 수정 하면 백업을 수행하는 것은 사용자의 책임입니다. 일반적인 데이터베이스 덤프에는이 디렉토리가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a80020f6d5771b4994b2b6087bde0a758b0dbcc3" translate="yes" xml:space="preserve">
          <source>If you need to modify a table that already exists, see &lt;a href=&quot;ddl-alter&quot;&gt;Section 5.6&lt;/a&gt; later in this chapter.</source>
          <target state="translated">이미 존재하는 테이블을 수정해야 할 경우이 장의 뒷부분에 나오는 &lt;a href=&quot;ddl-alter&quot;&gt;5.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2efd34e960254e7fbc24d4c21228c55d47bceff1" translate="yes" xml:space="preserve">
          <source>If you need to re-create a standby server while transactions are waiting, make sure that the commands pg_start_backup() and pg_stop_backup() are run in a session with &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt;, otherwise those requests will wait forever for the standby to appear.</source>
          <target state="translated">트랜잭션이 대기중인 동안 대기 서버를 다시 작성해야하는 경우 pg_start_backup () 및 pg_stop_backup () 명령이 &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt; 세션에서 실행되는지 확인하십시오 . 그렇지 않으면 해당 요청이 대기가 나타날 때까지 영원히 대기합니다.</target>
        </trans-unit>
        <trans-unit id="335eb5a28fe752ac43ab7d0bdb87c591351c3327" translate="yes" xml:space="preserve">
          <source>If you no longer need a table, you can remove it using the &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; command. For example:</source>
          <target state="translated">더 이상 테이블이 필요하지 않으면 &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; 명령을 사용하여 테이블을 제거 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b094a7de4e477575e2b8864dd2a1871a2ac7be9" translate="yes" xml:space="preserve">
          <source>If you only need randomly-generated (version 4) UUIDs, consider using the &lt;code&gt;gen_random_uuid()&lt;/code&gt; function from the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module instead.</source>
          <target state="translated">임의로 생성 된 (버전 4) UUID 만 필요한 경우 &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; 모듈 에서 &lt;code&gt;gen_random_uuid()&lt;/code&gt; 함수를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="c7ec64742024abd88ac376b90c1b4516681087ea" translate="yes" xml:space="preserve">
          <source>If you really cannot keep as many synchronous standbys as requested then you should decrease the number of synchronous standbys that transaction commits must wait for responses from in &lt;code&gt;synchronous_standby_names&lt;/code&gt; (or disable it) and reload the configuration file on the primary server.</source>
          <target state="translated">요청 된 동기 대기 수를 실제로 유지할 수없는 경우 트랜잭션 커밋이 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 에서 응답을 대기 (또는 비활성화)하고 기본 서버에서 구성 파일을 다시로드 해야하는 동기 대기 수를 줄여야 합니다.</target>
        </trans-unit>
        <trans-unit id="afb9b1746ef64ef43e1c6a611287b8838f8bab6f" translate="yes" xml:space="preserve">
          <source>If you really need to do something like that, you can either write a custom operator or add explicit casts to your query:</source>
          <target state="translated">실제로 이와 같은 작업을 수행해야하는 경우 사용자 지정 연산자를 작성하거나 쿼리에 명시 적 캐스트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6cec6fc682547181945340072f15c49a175a52" translate="yes" xml:space="preserve">
          <source>If you require exact storage and calculations (such as for monetary amounts), use the &lt;code&gt;numeric&lt;/code&gt; type instead.</source>
          <target state="translated">정확한 저장 및 계산이 필요한 경우 (예 : 화폐 금액) &lt;code&gt;numeric&lt;/code&gt; 유형을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dda0ebbf2c21ed8ce369ceb9f7962ccab8e8d4c2" translate="yes" xml:space="preserve">
          <source>If you see a message similar to:</source>
          <target state="translated">다음과 유사한 메시지가 표시되는 경우 :</target>
        </trans-unit>
        <trans-unit id="5944bf42cb7e9bed827543dce0bb5da3eb25aaf4" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;select-only&lt;/code&gt; built-in (also &lt;code&gt;-S&lt;/code&gt;), only the &lt;code&gt;SELECT&lt;/code&gt; is issued.</source>
          <target state="translated">당신이 선택하면 &lt;code&gt;select-only&lt;/code&gt; 내장 (또한 &lt;code&gt;-S&lt;/code&gt; ) 만 &lt;code&gt;SELECT&lt;/code&gt; 가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="c440cbb3c75274ef5533f9dc20d09bc792bb4404" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;simple-update&lt;/code&gt; built-in (also &lt;code&gt;-N&lt;/code&gt;), steps 4 and 5 aren't included in the transaction. This will avoid update contention on these tables, but it makes the test case even less like TPC-B.</source>
          <target state="translated">&lt;code&gt;simple-update&lt;/code&gt; 기본 제공 (또한 &lt;code&gt;-N&lt;/code&gt; ) 을 선택하면 4 단계와 5 단계가 트랜잭션에 포함되지 않습니다. 이렇게하면 이러한 테이블에서 업데이트 경합이 발생하지 않지만 테스트 사례는 TPC-B와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="2410e185ebe01d4bbafd07fc62d71b97897582e4" translate="yes" xml:space="preserve">
          <source>If you set a nonempty value for &lt;code&gt;log_line_prefix&lt;/code&gt;, you should usually make its last character be a space, to provide visual separation from the rest of the log line. A punctuation character can be used too.</source>
          <target state="translated">&lt;code&gt;log_line_prefix&lt;/code&gt; 에 비어 있지 않은 값을 설정하면 일반적으로 마지막 로그 문자를 공백으로 만들어야 나머지 로그 라인과 시각적으로 분리 할 수 ​​있습니다. 문장 부호 문자도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="293043269744dfe0b2be9f58f146808d29c819d1" translate="yes" xml:space="preserve">
          <source>If you simply direct the stderr of &lt;code&gt;postgres&lt;/code&gt; into a file, you will have log output, but the only way to truncate the log file is to stop and restart the server. This might be acceptable if you are using PostgreSQL in a development environment, but few production servers would find this behavior acceptable.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 의 stderr을 파일로 보내면 로그 출력이 표시되지만 로그 파일을 자르는 유일한 방법은 서버를 중지했다가 다시 시작하는 것입니다. 개발 환경에서 PostgreSQL을 사용하는 경우이 방법이 적합 할 수 있지만이 동작이 허용되는 프로덕션 서버는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ce920b3e4b27527a0945161fb81196b0962a822" translate="yes" xml:space="preserve">
          <source>If you simply write:</source>
          <target state="translated">당신이 단순히 쓰는 경우 :</target>
        </trans-unit>
        <trans-unit id="86278d59973a9bff1da8685bc91d01d4bca2172c" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;prefix&lt;/code&gt;, that string is prepended to the query's column names to create the variable names to use:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 를 지정하면 해당 문자열은 쿼리의 열 이름 앞에 추가되어 사용할 변수 이름을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4293f633ad719b6229d97888e7c493efba01b4c4" translate="yes" xml:space="preserve">
          <source>If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the entire disk. In releases prior to 8.4, if no &lt;code&gt;%&lt;/code&gt; escapes were present, PostgreSQL would append the epoch of the new log file's creation time, but this is no longer the case.</source>
          <target state="translated">이스케이프없이 파일 이름을 지정하면 결국 전체 디스크를 채우지 않도록 로그 회전 유틸리티를 사용해야합니다. 8.4 이전의 릴리스에서 &lt;code&gt;%&lt;/code&gt; 이스케이프가 없으면 PostgreSQL은 새 로그 파일 작성 시간의 시대를 추가하지만 더 이상 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd2bed205787104a93fce03bc6421721af1bc122" translate="yes" xml:space="preserve">
          <source>If you specify columns, you probably have to escape the parentheses from the shell. (See examples below.)</source>
          <target state="translated">열을 지정하면 셸에서 괄호를 이스케이프해야 할 수도 있습니다. (아래 예 참조)</target>
        </trans-unit>
        <trans-unit id="c697983f7b5aa306c7f0f7a672c31b1b3cec3536" translate="yes" xml:space="preserve">
          <source>If you suspect corruption of an index on a user table, you can simply rebuild that index, or all indexes on the table, using &lt;code&gt;REINDEX INDEX&lt;/code&gt; or &lt;code&gt;REINDEX TABLE&lt;/code&gt;.</source>
          <target state="translated">사용자 테이블에서 인덱스의 손상이 의심되는 경우 &lt;code&gt;REINDEX INDEX&lt;/code&gt; 또는 &lt;code&gt;REINDEX TABLE&lt;/code&gt; 을 사용하여 해당 인덱스 또는 테이블의 모든 인덱스를 재 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="634ba98da8d49a37a8349e78baa14c6e91b78095" translate="yes" xml:space="preserve">
          <source>If you use link mode, the upgrade will be much faster (no file copying) and use less disk space, but you will not be able to access your old cluster once you start the new cluster after the upgrade. Link mode also requires that the old and new cluster data directories be in the same file system. (Tablespaces and &lt;code&gt;pg_wal&lt;/code&gt; can be on different file systems.) Clone mode provides the same speed and disk space advantages but does not cause the old cluster to be unusable once the new cluster is started. Clone mode also requires that the old and new data directories be in the same file system. This mode is only available on certain operating systems and file systems.</source>
          <target state="translated">링크 모드를 사용하면 업그레이드 속도가 훨씬 빨라지고 (파일 복사 안 됨) 디스크 공간이 줄어들지 만 업그레이드 후 새 클러스터를 시작하면 이전 클러스터에 액세스 할 수 없습니다. 또한 링크 모드에서는 이전 및 새 클러스터 데이터 디렉토리가 동일한 파일 시스템에 있어야합니다. (테이블 스페이스와 &lt;code&gt;pg_wal&lt;/code&gt; 은 다른 파일 시스템에 있을 수 있습니다.) 복제 모드는 동일한 속도 및 디스크 공간 이점을 제공하지만 새 클러스터가 시작된 후에는 이전 클러스터를 사용할 수 없습니다. 복제 모드에서는 이전 및 새 데이터 디렉토리가 동일한 파일 시스템에 있어야합니다. 이 모드는 특정 운영 체제 및 파일 시스템에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9e0a997d4a5f8ab6d05deb3608c7b48d1004eb" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_segments&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">파일 기반 연속 아카이브없이 스트리밍 복제를 사용하는 경우 서버는 대기가 수신하기 전에 이전 WAL 세그먼트를 재활용 할 수 있습니다. 이 경우 대기는 새 기본 백업에서 다시 초기화해야합니다. &lt;code&gt;wal_keep_segments&lt;/code&gt; 를 WAL 세그먼트가 너무 빨리 재순환되지 않도록 충분한 값 으로 설정 하거나 대기에 대한 복제 슬롯을 구성하여 이를 피할 수 있습니다 . 대기에서 액세스 할 수있는 WAL 아카이브를 설정 한 경우 대기는 항상 충분한 세그먼트를 보유한 경우 아카이브를 사용하여 따라 잡을 수 있으므로 이러한 솔루션은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3198519c857584cca4870e5482467b87f1de4701" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_size&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">파일 기반 연속 아카이브없이 스트리밍 복제를 사용하는 경우 서버는 대기가 수신하기 전에 이전 WAL 세그먼트를 재활용 할 수 있습니다. 이 경우 새 기본 백업에서 대기를 다시 초기화해야합니다. WAL 세그먼트가 너무 일찍 재활용되지 않도록 &lt;code&gt;wal_keep_size&lt;/code&gt; 를 충분히 큰 값 으로 설정 하거나 대기에 대한 복제 슬롯을 구성하여 이를 방지 할 수 있습니다 . 대기에서 액세스 할 수있는 WAL 아카이브를 설정하는 경우 대기가 충분한 세그먼트를 보유하는 경우 항상 아카이브를 사용하여 따라 잡을 수 있기 때문에 이러한 솔루션이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="410c6fd96b75590acd8e3654ea56e9babc9667ce" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command.</source>
          <target state="translated">&lt;code&gt;\o&lt;/code&gt; 명령을 사용 하여 조회 출력을 재지 &lt;code&gt;\qecho&lt;/code&gt; 경우이 명령 대신 \ qecho 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0373a56e2165e1341cdef2084a1dbcf9d28e7801" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command. See also &lt;code&gt;\warn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\o&lt;/code&gt; 명령을 사용 하여 쿼리 출력을 리디렉션 하는 경우이 명령 대신 &lt;code&gt;\qecho&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;\warn&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dacf2afd67d1d9e6693b9e34a44e3f31343f07b9" translate="yes" xml:space="preserve">
          <source>If you used link mode and have Streaming Replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) or Log-Shipping (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) standby servers, you can follow these steps to quickly upgrade them. You will not be running pg_upgrade on the standby servers, but rather rsync on the primary. Do not start any servers yet.</source>
          <target state="translated">링크 모드를 사용하고 스트리밍 복제 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;26.2.5&lt;/a&gt; 참조 ) 또는 로그 전달 ( &lt;a href=&quot;warm-standby&quot;&gt;26.2&lt;/a&gt; 참조 ) 대기 서버가있는 경우 다음 단계에 따라 빠르게 업그레이드 할 수 있습니다. 대기 서버에서는 pg_upgrade를 실행하지 않고 기본 서버에서는 rsync를 실행합니다. 아직 서버를 시작하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="46579b8a1d951df62d56dbc7236dffbdfa323aee" translate="yes" xml:space="preserve">
          <source>If you want an empty string rather than NULL, write double quotes:</source>
          <target state="translated">NULL이 아닌 빈 문자열을 원하면 큰 따옴표를 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="e23816131f85edfcf8ebf4baf1b8f5a4f82e1a1c" translate="yes" xml:space="preserve">
          <source>If you want the digest as a hexadecimal string, use &lt;code&gt;encode()&lt;/code&gt; on the result. For example:</source>
          <target state="translated">16 진수 문자열로 다이제스트를 원하면 결과에 &lt;code&gt;encode()&lt;/code&gt; 를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7212923c1936242a3a328b31eba624a84bab3c5" translate="yes" xml:space="preserve">
          <source>If you want the system to behave as if it had no locale support, use the special locale name &lt;code&gt;C&lt;/code&gt;, or equivalently &lt;code&gt;POSIX&lt;/code&gt;.</source>
          <target state="translated">시스템이 로케일을 지원하지 않는 것처럼 작동하려면 특수 로케일 이름 &lt;code&gt;C&lt;/code&gt; 또는 이와 동등한 &lt;code&gt;POSIX&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f51609486b727fbe8393280c5551d1122917313" translate="yes" xml:space="preserve">
          <source>If you want to add a new method of making the data representation smaller, you must implement it in &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; and also teach &lt;code&gt;Catalog::ParseData()&lt;/code&gt; how to expand the data back into the full representation.</source>
          <target state="translated">데이터 표현을 더 작게 만드는 새로운 방법을 추가하려면 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 에서 구현하고 &lt;code&gt;Catalog::ParseData()&lt;/code&gt; 에 데이터를 다시 전체 표현으로 확장하는 방법을 가르쳐야 합니다.</target>
        </trans-unit>
        <trans-unit id="7f058b6974f7c4fc1a4fda33213fb953c4c820d2" translate="yes" xml:space="preserve">
          <source>If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.</source>
          <target state="translated">중요한 경우에 대해 이러한 유형을 사용하여 복잡한 계산을 수행하려는 경우, 특히 경계 사례 (무한도, 언더 플로)의 특정 동작에 의존하는 경우 구현을 신중하게 평가해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8d0dd9f6c3474fc520b6c68678cb5772392894d" translate="yes" xml:space="preserve">
          <source>If you want to have a double quote in the output you must precede it with a backslash, for example &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt;. Backslashes are not otherwise special outside of double-quoted strings. Within a double-quoted string, a backslash causes the next character to be taken literally, whatever it is (but this has no special effect unless the next character is a double quote or another backslash).</source>
          <target state="translated">출력에 큰 따옴표를 사용하려면 백 슬래시를 선행해야합니다 (예 : &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt; . 백 슬래시는 큰 따옴표로 묶인 문자열 외부에서 특별하지 않습니다. 큰 따옴표로 묶인 문자열 내에서 백 슬래시는 다음 문자를 문자 그대로 취합니다 (그러나 다음 문자가 큰 따옴표 나 다른 백 슬래시가 아닌 한 특별한 효과는 없습니다).</target>
        </trans-unit>
        <trans-unit id="b08912c8afafc035000c2b91395d4762ff623ba7" translate="yes" xml:space="preserve">
          <source>If you want to recover to some previous point in time (say, right before the junior DBA dropped your main transaction table), just specify the required &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;stopping point&lt;/a&gt;. You can specify the stop point, known as the &amp;ldquo;recovery target&amp;rdquo;, either by date/time, named restore point or by completion of a specific transaction ID. As of this writing only the date/time and named restore point options are very usable, since there are no tools to help you identify with any accuracy which transaction ID to use.</source>
          <target state="translated">주니어 DBA가 메인 트랜잭션 테이블을 삭제하기 직전의 이전 시점으로 복구하려면 필요한 &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;중지 지점을&lt;/a&gt; 지정하십시오 . 날짜 / 시간, 명명 된 복원 지점 또는 특정 트랜잭션 ID를 완료하여 &quot;복구 대상&quot;이라고하는 중지 지점을 지정할 수 있습니다. 이 글을 쓰는 시점에서 날짜 / 시간 및 명명 된 복원 지점 옵션 만 사용할 수 있습니다. 사용할 트랜잭션 ID를 정확하게 식별 할 수있는 도구가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f2799eac42b252d1fdead69c5594bb2d3a2059fa" translate="yes" xml:space="preserve">
          <source>If you want to run a parallel dump of a pre-9.2 server, you need to make sure that the database content doesn't change from between the time the master connects to the database until the last worker job has connected to the database. The easiest way to do this is to halt any data modifying processes (DDL and DML) accessing the database before starting the backup. You also need to specify the &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; parameter when running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 PostgreSQL server.</source>
          <target state="translated">9.2 이전 서버의 병렬 덤프를 실행하려면 마스터가 데이터베이스에 연결 한 시간부터 마지막 ​​작업자 작업이 데이터베이스에 연결될 때까지 데이터베이스 내용이 변경되지 않아야합니다. 가장 쉬운 방법은 백업을 시작하기 전에 데이터베이스에 액세스하는 데이터 수정 프로세스 (DDL 및 DML)를 중지하는 것입니다. 또한 9.2 이전 PostgreSQL 서버에 대해 &lt;code&gt;pg_dump -j&lt;/code&gt; 를 실행할 때 &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; 매개 변수 를 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1235d6c60bdf10ad9cf9d8bf29ece023d11255aa" translate="yes" xml:space="preserve">
          <source>If you want to see the lines on the screen as they are read you must set the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">읽을 때 화면에서 행을 보려면 &lt;code&gt;ECHO&lt;/code&gt; 변수 를 &lt;code&gt;all&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d777fa853e95af192514bf1aeb804e6308b39ad2" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g. &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">링크 모드를 사용하고 새 클러스터가 시작될 때 이전 클러스터를 수정하지 않으려면 복제 모드 사용을 고려하십시오. 사용할 수없는 경우 이전 클러스터의 사본을 작성하고 링크 모드에서 업그레이드하십시오. 이전 클러스터의 유효한 사본 을 작성하려면 서버가 실행중인 동안 &lt;code&gt;rsync&lt;/code&gt; 를 사용하여 이전 클러스터 의 더티 사본을 작성한 다음 이전 서버를 종료하고 &lt;code&gt;rsync --checksum&lt;/code&gt; 을 다시 실행 하여 사본을 변경하여 사본을 갱신하십시오. 일관된. ( &lt;code&gt;rsync&lt;/code&gt; 에는 1 초의 파일 수정 시간 단위 만 있기 때문에 &lt;code&gt;--checksum&lt;/code&gt; 이 필요 합니다.) &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;섹션 25.3.3에&lt;/a&gt; 설명 된대로 &lt;code&gt;postmaster.pid&lt;/code&gt; 와 같은 일부 파일을 제외 할 수 있습니다.. 파일 시스템이 파일 시스템 스냅 샷 또는 COW (Copy-On-Write) 파일 사본을 지원하는 경우 스냅 샷과 사본을 동시에 작성하거나 데이터베이스 서버가 작동 중지 된 상태에서 작성해야하지만이를 사용하여 이전 클러스터와 테이블 공간을 백업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a968160add8cfcbfd7bfae07842aa9c1a4f8617c" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g., &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">링크 모드를 사용하고 새 클러스터가 시작될 때 이전 클러스터를 수정하지 않으려면 복제 모드 사용을 고려하십시오. 사용할 수없는 경우 이전 클러스터의 복사본을 만들고 링크 모드에서 업그레이드합니다. 이전 클러스터의 유효한 복사본 을 만들려면 &lt;code&gt;rsync&lt;/code&gt; 를 사용하여 서버가 실행되는 동안 이전 클러스터의 더티 복사본을 만든 다음 이전 서버를 종료하고 &lt;code&gt;rsync --checksum&lt;/code&gt; 을 다시 실행 하여 변경 사항으로 복사본을 업데이트합니다. 일관된. ( &lt;code&gt;rsync&lt;/code&gt; 는 파일 수정 시간 단위가 1 초 이므로 &lt;code&gt;--checksum&lt;/code&gt; 이 필요 합니다.) &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;25.3.3 절에&lt;/a&gt; 설명 된대로 일부 파일 (예 : &lt;code&gt;postmaster.pid&lt;/code&gt; ) 을 제외 할 수 있습니다.. 파일 시스템이 파일 시스템 스냅 샷 또는 COW (Copy-On-Write) 파일 복사본을 지원하는 경우 스냅 샷과 복사본을 동시에 생성해야하거나 데이터베이스 서버가 다운 된 동안에도이를 사용하여 이전 클러스터 및 테이블 스페이스의 백업을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548498a07974c2669fa7d265bb5ed01fd29f2726" translate="yes" xml:space="preserve">
          <source>If you want to use psql to connect to several servers of different major versions, it is recommended that you use the newest version of psql. Alternatively, you can keep around a copy of psql from each major version and be sure to use the version that matches the respective server. But in practice, this additional complication should not be necessary.</source>
          <target state="translated">psql을 사용하여 다른 주요 버전의 여러 서버에 연결하려면 최신 버전의 psql을 사용하는 것이 좋습니다. 또는 각 주요 버전의 psql 사본을 보관하고 해당 서버와 일치하는 버전을 사용해야합니다. 그러나 실제로이 추가 합병증은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c83197bfbed6d42e302edf49770400c3bb7ffc90" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, fill in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; with a libpq connection string, including the host name (or IP address) and any additional details needed to connect to the primary server. If the primary needs a password for authentication, the password needs to be specified in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; as well.</source>
          <target state="translated">스트리밍 복제를 사용 하려면 호스트 이름 (또는 IP 주소) 및 기본 서버에 연결하는 데 필요한 추가 세부 사항을 포함하여 libpq 연결 문자열 로 &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; 를 채우십시오 . 기본에 인증을 위해 암호가 필요한 경우 &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; 에도 암호를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8304e11449eef667491dd46bf0e842007ab0620d" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, set up authentication on the primary server to allow replication connections from the standby server(s); that is, create a role and provide a suitable entry or entries in &lt;code&gt;pg_hba.conf&lt;/code&gt; with the database field set to &lt;code&gt;replication&lt;/code&gt;. Also ensure &lt;code&gt;max_wal_senders&lt;/code&gt; is set to a sufficiently large value in the configuration file of the primary server. If replication slots will be used, ensure that &lt;code&gt;max_replication_slots&lt;/code&gt; is set sufficiently high as well.</source>
          <target state="translated">스트리밍 복제를 사용하려면 기본 서버에서 인증을 설정하여 대기 서버에서 복제 연결을 허용하십시오. 즉, 역할을 만들고 데이터베이스 필드가 &lt;code&gt;replication&lt;/code&gt; 으로 설정된 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 적절한 항목을 제공하십시오 . 또한 기본 서버의 구성 파일에서 &lt;code&gt;max_wal_senders&lt;/code&gt; 가 충분히 큰 값으로 설정되어 있는지 확인 하십시오 . 복제 슬롯을 사용하는 경우 &lt;code&gt;max_replication_slots&lt;/code&gt; 도 충분히 높게 설정되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d505643f0e154d892e49d0ce311315a8a63b86fd" translate="yes" xml:space="preserve">
          <source>If you wish to create a new superuser, you must connect as a superuser, not merely with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. Being a superuser implies the ability to bypass all access permission checks within the database, so superuserdom should not be granted lightly.</source>
          <target state="translated">새 수퍼 유저를 만들려면 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이 아닌 수퍼 유저로 연결해야합니다 . 수퍼 유저는 데이터베이스 내에서 모든 액세스 권한 검사를 무시할 수있는 능력을 의미하므로 수퍼 유저에게 가볍게 부여해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="dba6f63305bb053e32c8873d900ab4a929146d0b" translate="yes" xml:space="preserve">
          <source>If you wish to drop a role for which the default privileges have been altered, it is necessary to reverse the changes in its default privileges or use &lt;code&gt;DROP OWNED BY&lt;/code&gt; to get rid of the default privileges entry for the role.</source>
          <target state="translated">기본 권한이 변경된 역할을 삭제하려면 기본 권한의 변경 사항을 되돌 리거나 &lt;code&gt;DROP OWNED BY&lt;/code&gt; 를 사용 하여 역할의 기본 권한 항목을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe513e6fe150eda65f8a240b4c5ab71cf30d3ea3" translate="yes" xml:space="preserve">
          <source>If you wish to keep the configuration files elsewhere than the data directory, the &lt;code&gt;postgres&lt;/code&gt;&lt;code&gt;-D&lt;/code&gt; command-line option or &lt;code&gt;PGDATA&lt;/code&gt; environment variable must point to the directory containing the configuration files, and the &lt;code&gt;data_directory&lt;/code&gt; parameter must be set in &lt;code&gt;postgresql.conf&lt;/code&gt; (or on the command line) to show where the data directory is actually located. Notice that &lt;code&gt;data_directory&lt;/code&gt; overrides &lt;code&gt;-D&lt;/code&gt; and &lt;code&gt;PGDATA&lt;/code&gt; for the location of the data directory, but not for the location of the configuration files.</source>
          <target state="translated">구성 파일을 데이터 디렉토리 이외의 위치에 유지하려면 &lt;code&gt;postgres&lt;/code&gt; &lt;code&gt;-D&lt;/code&gt; 명령 행 옵션 또는 &lt;code&gt;PGDATA&lt;/code&gt; 환경 변수가 구성 파일이 포함 된 디렉토리를 &lt;code&gt;data_directory&lt;/code&gt; 야하며 data_directory 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; (또는 on 데이터 디렉토리가 실제로 위치한 위치를 표시합니다. 공지 사항이 &lt;code&gt;data_directory&lt;/code&gt; 오버라이드 (override) &lt;code&gt;-D&lt;/code&gt; 및 &lt;code&gt;PGDATA&lt;/code&gt; 데이터 디렉토리의 위치가 아니라 구성 파일의 위치.</target>
        </trans-unit>
        <trans-unit id="5e43ef9c20e530883e37f2ea188b5ba2ab7b89db" translate="yes" xml:space="preserve">
          <source>If you wish, you can specify the configuration file names and locations individually using the parameters &lt;code&gt;config_file&lt;/code&gt;, &lt;code&gt;hba_file&lt;/code&gt; and/or &lt;code&gt;ident_file&lt;/code&gt;. &lt;code&gt;config_file&lt;/code&gt; can only be specified on the &lt;code&gt;postgres&lt;/code&gt; command line, but the others can be set within the main configuration file. If all three parameters plus &lt;code&gt;data_directory&lt;/code&gt; are explicitly set, then it is not necessary to specify &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">원하는 경우 &lt;code&gt;config_file&lt;/code&gt; , &lt;code&gt;hba_file&lt;/code&gt; 및 / 또는 &lt;code&gt;ident_file&lt;/code&gt; 매개 변수를 사용하여 구성 파일 이름 및 위치를 개별적으로 지정할 수 있습니다 . &lt;code&gt;config_file&lt;/code&gt; 은 &lt;code&gt;postgres&lt;/code&gt; 명령 행 에서만 지정할 수 있지만 다른 구성은 기본 구성 파일 내에서 설정할 수 있습니다. 세 개의 매개 변수와 &lt;code&gt;data_directory&lt;/code&gt; 를 모두 명시 적으로 설정 한 경우 &lt;code&gt;-D&lt;/code&gt; 또는 &lt;code&gt;PGDATA&lt;/code&gt; 를 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="32daceaa2cf366c2fe6d0715c4458443ee88a963" translate="yes" xml:space="preserve">
          <source>If you're setting up the standby server for high availability purposes, set up WAL archiving, connections and authentication like the primary server, because the standby server will work as a primary server after failover.</source>
          <target state="translated">고 가용성을 위해 대기 서버를 설정하는 경우 장애 조치 후에 대기 서버가 기본 서버로 작동하므로 기본 서버와 같은 WAL 보관, 연결 및 인증을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c5ac9027a677c31c54f143f0fe38940b45904e3a" translate="yes" xml:space="preserve">
          <source>If you're using a WAL archive, its size can be minimized using the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; parameter to remove files that are no longer required by the standby server. The pg_archivecleanup utility is designed specifically to be used with &lt;code&gt;archive_cleanup_command&lt;/code&gt; in typical single-standby configurations, see &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt;. Note however, that if you're using the archive for backup purposes, you need to retain files needed to recover from at least the latest base backup, even if they're no longer needed by the standby.</source>
          <target state="translated">WAL 아카이브를 사용하는 경우 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; 매개 변수를 사용하여 WAL 아카이브의 크기를 최소화하여 더 이상 대기 서버에 필요하지 않은 파일을 제거 할 수 있습니다 . pg_archivecleanup 유틸리티는 일반적인 단일 대기 구성에서 &lt;code&gt;archive_cleanup_command&lt;/code&gt; 와 함께 사용하도록 특별히 설계되었습니다 ( &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt; 참조) . 그러나 백업 목적으로 아카이브를 사용하는 경우 대기에서 더 이상 필요하지 않더라도 최소한 최신 기본 백업에서 복구하는 데 필요한 파일을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="eede8f4eab7ac7c7f42522f0f50f00f83f33b103" translate="yes" xml:space="preserve">
          <source>If your application needs to use other forms of partitioning not listed above, alternative methods such as inheritance and &lt;code&gt;UNION ALL&lt;/code&gt; views can be used instead. Such methods offer flexibility but do not have some of the performance benefits of built-in declarative partitioning.</source>
          <target state="translated">애플리케이션이 위에 나열되지 않은 다른 형식의 파티셔닝을 사용해야하는 경우 상속 및 &lt;code&gt;UNION ALL&lt;/code&gt; 보기 와 같은 대체 방법을 대신 사용할 수 있습니다. 이러한 방법은 유연성을 제공하지만 내장 된 선언적 파티셔닝의 일부 성능 이점은 없습니다.</target>
        </trans-unit>
        <trans-unit id="693883e4d7e5062d3b1b4e420d1dcd21d56fe252" translate="yes" xml:space="preserve">
          <source>If your database cluster has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to restore the output of pg_dump into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">데이터베이스 클러스터에 &lt;code&gt;template1&lt;/code&gt; 데이터베이스에 로컬로 추가 된 것이 있으면 pg_dump의 출력을 진정으로 비어있는 데이터베이스로 복원하십시오. 그렇지 않으면 추가 된 객체의 중복 정의로 인해 오류가 발생할 수 있습니다. 로컬 추가없이 빈 데이터베이스를 만들려면 &lt;code&gt;template0&lt;/code&gt; 아닌 &lt;code&gt;template1&lt;/code&gt; 에서 복사하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfe8c7a1e0073145cfd43127c90a639a57c975f4" translate="yes" xml:space="preserve">
          <source>If your database is spread across multiple file systems, there might not be any way to obtain exactly-simultaneous frozen snapshots of all the volumes. For example, if your data files and WAL log are on different disks, or if tablespaces are on different file systems, it might not be possible to use snapshot backup because the snapshots &lt;em&gt;must&lt;/em&gt; be simultaneous. Read your file system documentation very carefully before trusting the consistent-snapshot technique in such situations.</source>
          <target state="translated">데이터베이스가 여러 파일 시스템에 분산 된 경우 모든 볼륨의 정확히 동시에 고정 된 스냅 샷을 얻을 수있는 방법이 없을 수 있습니다. 예를 들어, 데이터 파일과 WAL 로그가 다른 디스크에 있거나 테이블 공간이 다른 파일 시스템에있는 경우 스냅 샷 이 동시에 &lt;em&gt;이루어져야&lt;/em&gt; 하므로 스냅 샷 백업을 사용하지 못할 수 있습니다 . 이러한 상황에서 일관된 스냅 샷 기술을 신뢰하기 전에 파일 시스템 설명서를주의해서 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="89affde528d7a785d4590b760f08553f5fba2e5e" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g. &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">설치 디렉토리가 특정 버전이 아닌 경우 (예 : &lt;code&gt;/usr/local/pgsql&lt;/code&gt; ) , 현재 PostgreSQL 설치 디렉토리를 이동하여 새 PostgreSQL 설치를 방해하지 않도록해야합니다. 현재 PostgreSQL 서버가 종료되면 PostgreSQL 설치 디렉토리의 이름을 바꾸는 것이 안전합니다. 이전 디렉토리가 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; 이라고 가정하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b225941ba48c705a72d951ae004bd3007fba63eb" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g., &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">설치 디렉토리가 버전별로 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; 않은 경우 (예 : / usr / local / pgsql ) 새 PostgreSQL 설치를 방해하지 않도록 현재 PostgreSQL 설치 디렉토리를 이동해야합니다. 현재 PostgreSQL 서버가 종료되면 PostgreSQL 설치 디렉토리의 이름을 바꾸는 것이 안전합니다. 이전 디렉토리가 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; 이라고 가정하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd01544b621df2f2698aa331ec7e1d502c246c7e" translate="yes" xml:space="preserve">
          <source>If your installation has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to load the output of pg_restore into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">설치에 &lt;code&gt;template1&lt;/code&gt; 데이터베이스에 로컬로 추가 된 것이 있으면 pg_restore의 출력을 진정으로 비어있는 데이터베이스로로드하십시오. 그렇지 않으면 추가 된 객체의 중복 정의로 인해 오류가 발생할 수 있습니다. 로컬 추가없이 빈 데이터베이스를 만들려면 &lt;code&gt;template0&lt;/code&gt; 아닌 &lt;code&gt;template1&lt;/code&gt; 에서 복사하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb5ad20ebf8b8594ba828c2e14073cc42a290699" translate="yes" xml:space="preserve">
          <source>If your needs go beyond the capabilities of these conditional expressions, you might want to consider writing a server-side function in a more expressive programming language.</source>
          <target state="translated">이러한 조건식의 기능을 넘어서야하는 경우보다 표현적인 프로그래밍 언어로 서버 측 함수를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="092f5bf3a3fbeb060b8f061dfe4479d40fe497ca" translate="yes" xml:space="preserve">
          <source>If your site administrator has not set things up in the default way, you might have some more work to do. For example, if the database server machine is a remote machine, you will need to set the &lt;code&gt;PGHOST&lt;/code&gt; environment variable to the name of the database server machine. The environment variable &lt;code&gt;PGPORT&lt;/code&gt; might also have to be set. The bottom line is this: if you try to start an application program and it complains that it cannot connect to the database, you should consult your site administrator or, if that is you, the documentation to make sure that your environment is properly set up. If you did not understand the preceding paragraph then read the next section.</source>
          <target state="translated">사이트 관리자가 기본 방식으로 설정하지 않은 경우 추가 작업이 필요할 수 있습니다. 예를 들어, 데이터베이스 서버 시스템이 원격 시스템 인 경우 &lt;code&gt;PGHOST&lt;/code&gt; 환경 변수를 데이터베이스 서버 시스템의 이름으로 설정해야 합니다. 환경 변수 &lt;code&gt;PGPORT&lt;/code&gt; 도 설정해야합니다. 결론은 다음과 같습니다. 응용 프로그램을 시작하려고하는데 데이터베이스에 연결할 수 없다고 불평하는 경우, 사이트 관리자에게 문의하거나 해당하는 경우 문서를 참조하여 환경이 올바르게 설정되었는지 확인하십시오 . 이전 단락을 이해하지 못하면 다음 섹션을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="0e26c0628db89c4d17246b09878aa1c2d36a0d98" translate="yes" xml:space="preserve">
          <source>If your system supports per-user disk quotas, then the database will naturally be subject to whatever quota is placed on the user the server runs as. Exceeding the quota will have the same bad effects as running out of disk space entirely.</source>
          <target state="translated">시스템이 사용자 별 디스크 할당량을 지원하는 경우 데이터베이스는 당연히 서버가 실행되는 사용자의 할당량에 따라 달라집니다. 할당량을 초과하면 디스크 공간이 완전히 소진되는 것과 같은 나쁜 영향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7e317a782d39f676e51dc31fbaf9497cd40b79f" translate="yes" xml:space="preserve">
          <source>If your table is large enough that a single index really is a bad idea, you should look into using partitioning instead (see &lt;a href=&quot;ddl-partitioning&quot;&gt;Section 5.11&lt;/a&gt;). With that mechanism, the system does understand that the tables and indexes are non-overlapping, so far better performance is possible.</source>
          <target state="translated">테이블이 충분히 커서 단일 인덱스가 정말 좋지 않다면 대신 파티셔닝을 사용해야합니다 ( &lt;a href=&quot;ddl-partitioning&quot;&gt;섹션 5.11&lt;/a&gt; 참조 ). 이 메커니즘을 통해 시스템은 테이블과 인덱스가 겹치지 않는다는 것을 이해하므로 훨씬 더 나은 성능이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="db517070c58b7073cbfea804db0649d1169a5342" translate="yes" xml:space="preserve">
          <source>If, after running &lt;code&gt;pg_upgrade&lt;/code&gt;, you wish to revert to the old cluster, there are several options:</source>
          <target state="translated">&lt;code&gt;pg_upgrade&lt;/code&gt; 를 실행 한 후 이전 클러스터로 되돌리려면 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1101febd9e8e65c65ae1f196aecd9bf8175188c4" translate="yes" xml:space="preserve">
          <source>If, partway through the transaction, we decide we do not want to commit (perhaps we just noticed that Alice's balance went negative), we can issue the command &lt;code&gt;ROLLBACK&lt;/code&gt; instead of &lt;code&gt;COMMIT&lt;/code&gt;, and all our updates so far will be canceled.</source>
          <target state="translated">트랜잭션을 도중에 커밋하지 않기로 결정한 경우 (아마도 Alice의 잔액이 마이너스가 된 것으로 &lt;code&gt;ROLLBACK&lt;/code&gt; ) &lt;code&gt;COMMIT&lt;/code&gt; 대신 ROLLBACK 명령을 실행할 수 있으며 지금까지의 모든 업데이트가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="f5024d286e4914e76d806049ed9ed5a9adde6b60" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables (but still update the indexes when modifying the tables). This is useful when recovering from damaged system indexes. This parameter cannot be changed after session start.</source>
          <target state="translated">시스템 테이블을 읽을 때는 시스템 인덱스를 무시하십시오 (그러나 테이블을 수정할 때는 인덱스를 업데이트하십시오). 손상된 시스템 인덱스에서 복구 할 때 유용합니다. 세션 시작 후에는이 매개 변수를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71db18d1300170d2010c351c48755c19862c8762" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables, but still update the indexes when modifying the tables. This is useful when recovering from damaged system indexes.</source>
          <target state="translated">시스템 테이블을 읽을 때는 시스템 인덱스를 무시하고 테이블을 수정할 때는 인덱스를 업데이트하십시오. 손상된 시스템 인덱스에서 복구 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e6a48d212210667b487bb3381daba46c6747f8cd" translate="yes" xml:space="preserve">
          <source>Ignore the specified file or directory, which should be expressed as a relative path name, when comparing the list of data files actually present in the backup to those listed in the &lt;code&gt;backup_manifest&lt;/code&gt; file. If a directory is specified, this option affects the entire subtree rooted at that location. Complaints about extra files, missing files, file size differences, or checksum mismatches will be suppressed if the relative path name matches the specified path name. This option can be specified multiple times.</source>
          <target state="translated">백업에 실제로 존재하는 데이터 파일 목록과 &lt;code&gt;backup_manifest&lt;/code&gt; 파일에 나열된 파일 목록을 비교할 때 상대 경로 이름으로 표시되어야하는 지정된 파일 또는 디렉토리를 무시 하십시오. 디렉토리가 지정된 경우이 옵션은 해당 위치에있는 전체 하위 트리에 영향을줍니다. 상대 경로 이름이 지정된 경로 이름과 일치하면 추가 파일, 누락 된 파일, 파일 크기 차이 또는 체크섬 불일치에 대한 불만이 표시되지 않습니다. 이 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78fee1435d74666b84850cd5e82c18229351da5d" translate="yes" xml:space="preserve">
          <source>Ignored</source>
          <target state="translated">Ignored</target>
        </trans-unit>
        <trans-unit id="0bbd8cc216c54e73f7ea687a30b566c0b2c97cbb" translate="yes" xml:space="preserve">
          <source>Ignored for compatibility. Use of these keywords is deprecated; refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">호환성을 무시했습니다. 이 키워드는 더 이상 사용되지 않습니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b3a3e33cda0750b99611590eb50e57574fe1fbbc" translate="yes" xml:space="preserve">
          <source>Ignored for conformance with the SQL standard.</source>
          <target state="translated">SQL 표준 준수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="007d15b16f1f1a7b26e745777a0d9b8f646f2090" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt;, below.</source>
          <target state="translated">이러한 다양한 형식의 모양에 대한 그림은 아래의 &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;예&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61522d42e0f29a20214f69c85ea7d7e480669670" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in the &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt; section.</source>
          <target state="translated">이러한 다양한 형식이 어떻게 보이는지에 대한 그림은 &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;예제&lt;/a&gt; 섹션 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce170f0162eadf29cca12cc3cb0e2275dc4e6504" translate="yes" xml:space="preserve">
          <source>Image equality is &lt;em&gt;almost&lt;/em&gt; the same condition as simple bitwise equality. There is one subtle difference: When indexing a varlena data type, the on-disk representation of two image equal datums may not be bitwise equal due to inconsistent application of TOAST compression on input. Formally, when an operator class's &lt;code&gt;equalimage&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt;, it is safe to assume that the &lt;code&gt;datum_image_eq()&lt;/code&gt; C function will always agree with the operator class's &lt;code&gt;order&lt;/code&gt; function (provided that the same collation OID is passed to both the &lt;code&gt;equalimage&lt;/code&gt; and &lt;code&gt;order&lt;/code&gt; functions).</source>
          <target state="translated">이미지 평등은 단순한 비트 평등과 &lt;em&gt;거의&lt;/em&gt; 동일한 조건입니다. 한 가지 미묘한 차이가 있습니다. varlena 데이터 유형을 인덱싱 할 때 두 개의 이미지가 동일한 데이터의 온 디스크 표현은 입력시 TOAST 압축의 일관성없는 적용으로 인해 비트가 동일하지 않을 수 있습니다. 공식적으로 연산자 클래스의 &lt;code&gt;equalimage&lt;/code&gt; 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 &lt;code&gt;datum_image_eq()&lt;/code&gt; C 함수가 항상 연산자 클래스의 &lt;code&gt;order&lt;/code&gt; 함수 와 일치 한다고 가정하는 것이 안전 합니다 (동일한 데이터 정렬 OID가 &lt;code&gt;equalimage&lt;/code&gt; 및 &lt;code&gt;order&lt;/code&gt; 함수 에 모두 전달되는 경우 ).</target>
        </trans-unit>
        <trans-unit id="bf50e138c7fa8f736f41cea1cb795eaf265d80f2" translate="yes" xml:space="preserve">
          <source>Immediately after connecting as role &lt;code&gt;joe&lt;/code&gt;, a database session will have use of privileges granted directly to &lt;code&gt;joe&lt;/code&gt; plus any privileges granted to &lt;code&gt;admin&lt;/code&gt;, because &lt;code&gt;joe&lt;/code&gt;&amp;ldquo;inherits&amp;rdquo;&lt;code&gt;admin&lt;/code&gt;'s privileges. However, privileges granted to &lt;code&gt;wheel&lt;/code&gt; are not available, because even though &lt;code&gt;joe&lt;/code&gt; is indirectly a member of &lt;code&gt;wheel&lt;/code&gt;, the membership is via &lt;code&gt;admin&lt;/code&gt; which has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. After:</source>
          <target state="translated">즉시 역할로 연결 한 후 &lt;code&gt;joe&lt;/code&gt; , 데이터베이스 세션에 직접 부여 된 권한을 사용해야합니다 &lt;code&gt;joe&lt;/code&gt; 에게 부여 및 모든 권한 &lt;code&gt;admin&lt;/code&gt; 하기 때문에 &lt;code&gt;joe&lt;/code&gt; &quot;상속&quot; &lt;code&gt;admin&lt;/code&gt; 의 권한. 그러나 &lt;code&gt;joe&lt;/code&gt; 가 간접적으로 &lt;code&gt;wheel&lt;/code&gt; 의 멤버이지만 멤버가 &lt;code&gt;NOINHERIT&lt;/code&gt; 속성을 가진 &lt;code&gt;admin&lt;/code&gt; 을 통해 이루어 지기 때문에 &lt;code&gt;wheel&lt;/code&gt; 에 부여 된 권한 은 사용할 수 없습니다 . 후:</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="23167d1539b634954643857fda589f9a1f99fc34" translate="yes" xml:space="preserve">
          <source>Implementation language or call interface of this function</source>
          <target state="translated">이 함수의 구현 언어 또는 호출 인터페이스</target>
        </trans-unit>
        <trans-unit id="41f7b8a75bd6e29a246db5c9ce4b0884fc5122fa" translate="yes" xml:space="preserve">
          <source>Implementation: B-Tree Structure</source>
          <target state="translated">구현 : B- 트리 구조</target>
        </trans-unit>
        <trans-unit id="4bd8f1da2c7641aff5a1e24cb79dcae5ba805a8b" translate="yes" xml:space="preserve">
          <source>Implementation: Deduplication</source>
          <target state="translated">구현 : 중복 제거</target>
        </trans-unit>
        <trans-unit id="261a75d84276a41b101b0b0b2ac4d845072c8241" translate="yes" xml:space="preserve">
          <source>Implicit conversions should never have surprising or unpredictable outcomes.</source>
          <target state="translated">암시 적 변환에는 결코 놀라운 결과 나 예측할 수없는 결과가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="4a78c79f95926318ef6fec9862a700583e71fbd0" translate="yes" xml:space="preserve">
          <source>Implicit unit of the parameter</source>
          <target state="translated">매개 변수의 암시 적 단위</target>
        </trans-unit>
        <trans-unit id="60fa0aba1042461c4c2f1fe75e803d3f36549dc2" translate="yes" xml:space="preserve">
          <source>Import only foreign tables matching one of the given table names. Other tables existing in the foreign schema will be ignored.</source>
          <target state="translated">주어진 테이블 이름 중 하나와 일치하는 외부 테이블 만 가져옵니다. 외부 스키마에 존재하는 다른 테이블은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2775c7ad42c3e8d71ae7e18124278fff473728e1" translate="yes" xml:space="preserve">
          <source>Import operating system collations</source>
          <target state="translated">운영 체제 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="bd09d7d5cbde0f6a55b8befe57d5d6baee4d6f2b" translate="yes" xml:space="preserve">
          <source>Import table definitions from a remote schema &lt;code&gt;foreign_films&lt;/code&gt; on server &lt;code&gt;film_server&lt;/code&gt;, creating the foreign tables in local schema &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;film_server&lt;/code&gt; 서버 의 원격 스키마 &lt;code&gt;foreign_films&lt;/code&gt; 에서 테이블 정의를 가져 와서 로컬 스키마 &lt;code&gt;films&lt;/code&gt; 에 외부 테이블을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="40baa6b48d8c1dc060a4acaef47611a694c99ef3" translate="yes" xml:space="preserve">
          <source>Importing behavior can be customized with the following options (given in the &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command):</source>
          <target state="translated">&lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; 명령 에서 제공되는 다음 옵션을 사용하여 가져 오기 동작을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cdac824d2a40a7779c6dcbb8d843dee4847ebb5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;delta&lt;/code&gt; denote floating-point numbers. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, but not &lt;code&gt;delta&lt;/code&gt;, can be preceded by a certainty indicator.</source>
          <target state="translated">에서는 &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;표 F.26&lt;/a&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , 및 &lt;code&gt;delta&lt;/code&gt; 나타내고 부동 소수. &lt;code&gt;delta&lt;/code&gt; 가 아닌 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 앞에 확실성 표시기가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42729a410f5a9327e00095fef5d98f4dbb7419a2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; in the column for PostgreSQL we classify as &amp;ldquo;non-reserved&amp;rdquo; those key words that are explicitly known to the parser but are allowed as column or table names. Some key words that are otherwise non-reserved cannot be used as function or data type names and are marked accordingly. (Most of these words represent built-in functions or data types with special syntax. The function or type is still available but it cannot be redefined by the user.) Labeled &amp;ldquo;reserved&amp;rdquo; are those tokens that are not allowed as column or table names. Some reserved key words are allowable as names for functions or data types; this is also shown in the table. If not so marked, a reserved key word is only allowed as an &amp;ldquo;AS&amp;rdquo; column label name.</source>
          <target state="translated">PostgreSQL 열의 &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;표 C.1&lt;/a&gt; 에서는 파서에 명시 적으로 알려져 있지만 열 또는 테이블 이름으로 허용되는 키워드를 &quot;비 예약&quot;으로 분류합니다. 그렇지 않으면 예약되지 않은 일부 키워드는 함수 또는 데이터 유형 이름으로 사용할 수 없으며 그에 따라 표시됩니다. (대부분의 이러한 단어는 특수 구문이있는 내장 함수 또는 데이터 유형을 나타냅니다. 함수 또는 유형은 여전히 ​​사용 가능하지만 사용자가 다시 정의 할 수는 없습니다.) &quot;예약 됨&quot;이라는 레이블이 붙은 토큰은 열 또는 테이블 이름으로 사용할 수 없습니다. . 일부 예약 된 키워드는 함수 또는 데이터 유형의 이름으로 사용할 수 있습니다. 이것은 표에도 나와 있습니다. 그렇게 표시되지 않은 경우 예약 키워드는 &quot;AS&quot;열 레이블 이름으로 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fee127e33ba4c6342d0b89b7e063498409c73cb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN. If specified when not in &lt;code&gt;--start&lt;/code&gt; mode, an error is raised.</source>
          <target state="translated">에서 &lt;code&gt;--start&lt;/code&gt; 에 도달에게 지정된 LSN을 수신 할 때 모드, 자동으로 정상 종료 상태 0 복제 및 종료를 중지합니다. &lt;code&gt;--start&lt;/code&gt; 모드에 있지 않을 때 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3bfcd6bf2f68dc3b43c9cf872d41f5d653495d00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">에서 &lt;code&gt;--start&lt;/code&gt; 모드, 주어진 LSN에서 복제를 시작합니다. 이 효과에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;52.4 절의&lt;/a&gt; 설명서를 참조하십시오 . 다른 모드에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f9c2a488b212b2dfc605f566bbd946f2f95b3b7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">에서 &lt;code&gt;--start&lt;/code&gt; 모드, 주어진 LSN에서 복제를 시작합니다. 이 효과에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;48 장&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;섹션 52.4&lt;/a&gt; 의 설명서를 참조하십시오 . 다른 모드에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="12bbea7ca03f59c395276fdbf0ca262376507500" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, use the existing logical replication slot named &lt;code&gt;slot_name&lt;/code&gt;. In &lt;code&gt;--create-slot&lt;/code&gt; mode, create the slot with this name. In &lt;code&gt;--drop-slot&lt;/code&gt; mode, delete the slot with this name.</source>
          <target state="translated">에서 &lt;code&gt;--start&lt;/code&gt; 모드에서는 기존 논리 복제 슬롯 이름을 사용 &lt;code&gt;slot_name&lt;/code&gt; . 에서 &lt;code&gt;--create-slot&lt;/code&gt; 모드,이 이름 슬롯을 만들 수 있습니다. 에서 &lt;code&gt;--drop-slot&lt;/code&gt; 모드,이 이름 슬롯을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="18d7da29e783f36fa5dffa6644b2287183a78875" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CSV&lt;/code&gt; format, all characters are significant. A quoted value surrounded by white space, or any characters other than &lt;code&gt;DELIMITER&lt;/code&gt;, will include those characters. This can cause errors if you import data from a system that pads &lt;code&gt;CSV&lt;/code&gt; lines with white space out to some fixed width. If such a situation arises you might need to preprocess the &lt;code&gt;CSV&lt;/code&gt; file to remove the trailing white space, before importing the data into PostgreSQL.</source>
          <target state="translated">에서 &lt;code&gt;CSV&lt;/code&gt; 의 형식, 모든 문자가 중요합니다. 공백 또는 &lt;code&gt;DELIMITER&lt;/code&gt; 이외의 문자로 둘러싸인 인용 된 값 에는 해당 문자가 포함됩니다. 공백이있는 &lt;code&gt;CSV&lt;/code&gt; 행을 일정한 너비로 채우는 시스템에서 데이터를 가져 오는 경우 오류가 발생할 수 있습니다 . 이러한 상황이 발생하면 PostgreSQL로 데이터를 가져 오기 전에 &lt;code&gt;CSV&lt;/code&gt; 파일을 사전 처리 하여 후행 공백을 제거 해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0153f75e36e8f0039d3aa08af5bcc40422e9783b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;FROM&lt;/code&gt; items, both the standard and PostgreSQL allow &lt;code&gt;AS&lt;/code&gt; to be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.</source>
          <target state="translated">에서 &lt;code&gt;FROM&lt;/code&gt; 항목, 표준 및 PostgreSQL을 모두 허용 &lt;code&gt;AS&lt;/code&gt; 예약되지 않은 키워드입니다 별명 전에 생략 할 수있다. 그러나 이것은 구문상의 모호성 때문에 출력 열 이름에는 비실용적입니다.</target>
        </trans-unit>
        <trans-unit id="0a49988bfaefe7a720bbc33d73d20e3ed846b39f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of &lt;em&gt;peer groups&lt;/em&gt; before or after the current row's peer group, where a peer group is a set of rows that are equivalent in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. (There must be an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the window definition to use &lt;code&gt;GROUPS&lt;/code&gt; mode.)</source>
          <target state="translated">에서는 &lt;code&gt;GROUPS&lt;/code&gt; 의 모드에서는 &lt;code&gt;offset&lt;/code&gt; 다시 비 - 널, 음이 아닌 정수이고, 상기 선택 수단을 산출해야하는 프레임의 시작 또는 끝 지정된 수의 &lt;em&gt;피어 그룹&lt;/em&gt; 피어 그룹 A는 현재 행의 피어 그룹 전후 &lt;code&gt;ORDER BY&lt;/code&gt; 순서 와 동등한 행 세트 . &lt;code&gt;GROUPS&lt;/code&gt; 모드 를 사용하려면 창 정의에 &lt;code&gt;ORDER BY&lt;/code&gt; 절이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="948c542b2b357818bb888566376ebb0a4005a123" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; mode, these options require that the &lt;code&gt;ORDER BY&lt;/code&gt; clause specify exactly one column. The &lt;code&gt;offset&lt;/code&gt; specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the &lt;code&gt;offset&lt;/code&gt; expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. For example, if the ordering column is of type &lt;code&gt;date&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt;, one could write &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt;. The &lt;code&gt;offset&lt;/code&gt; is still required to be non-null and non-negative, though the meaning of &amp;ldquo;non-negative&amp;rdquo; depends on its data type.</source>
          <target state="translated">에서 &lt;code&gt;RANGE&lt;/code&gt; 의 모드 이러한 옵션은해야 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 정확히 하나의 열을 지정합니다. &lt;code&gt;offset&lt;/code&gt; 지정 현재 행에 해당 열의 값 또는 이전 프레임의 행을 다음의 값 사이의 최대 차이. 의 데이터 유형 &lt;code&gt;offset&lt;/code&gt; 식은 순서 열의 데이터 종류에 따라 달라진다. 숫자 순서 열의 경우 일반적으로 순서 열과 동일한 유형이지만 날짜 시간 순서 열의 경우 &lt;code&gt;interval&lt;/code&gt; 입니다. 예를 들어, 주문 열이 &lt;code&gt;date&lt;/code&gt; 또는 &lt;code&gt;timestamp&lt;/code&gt; 유형 인 경우 &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt; 쓸 수 있습니다. 그만큼 &lt;code&gt;offset&lt;/code&gt; &quot;음수가 아닌&quot;의 의미는 데이터 유형에 따라 다르지만 오프셋 은 여전히 ​​널이 아니며 음이 아닌 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1408d5e7e21bd209b1b9bfad149903cd4485729a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode, a &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame starts with the current row's first &lt;em&gt;peer&lt;/em&gt; row (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts as equivalent to the current row), while a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame ends with the current row's last peer row. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; simply means the current row.</source>
          <target state="translated">에서는 &lt;code&gt;RANGE&lt;/code&gt; 또는 &lt;code&gt;GROUPS&lt;/code&gt; 모드, &lt;code&gt;frame_start&lt;/code&gt; 의 &lt;code&gt;CURRENT ROW&lt;/code&gt; 현재 행의 첫 번째와 프레임 시작 수단 &lt;em&gt;피어&lt;/em&gt; (윈도우의 것을 로우 행 &lt;code&gt;ORDER BY&lt;/code&gt; , 현재 행과 동등 절 종류)가 잠시 &lt;code&gt;frame_end&lt;/code&gt; 의 &lt;code&gt;CURRENT ROW&lt;/code&gt; 가 프레임 단부 수단을 현재 행의 마지막 피어 행과 함께. 에서 &lt;code&gt;ROWS&lt;/code&gt; 의 모드, &lt;code&gt;CURRENT ROW&lt;/code&gt; 단순히 현재의 행을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="30675f2bd0c7573e3e074baf89463cecdcac064e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row.</source>
          <target state="translated">에서는 &lt;code&gt;ROWS&lt;/code&gt; 모드에서는 &lt;code&gt;offset&lt;/code&gt; NULL이 아닌 양의 정수를 산출하며, 상기 선택 수단이 상기 프레임의 시작 또는 끝 지정된 행수를 이전 또는 현재 행 후에.</target>
        </trans-unit>
        <trans-unit id="8f056c7130dbabcd038c08071d28f6253ddeb0d1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt;, each array element is compared to the searched value using &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics.</source>
          <target state="translated">에서는 &lt;code&gt;array_position&lt;/code&gt; 및 &lt;code&gt;array_positions&lt;/code&gt; 이용하여 검색된 값에, 각각의 어레이 소자는 비교 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 의미.</target>
        </trans-unit>
        <trans-unit id="58eb966bf75cf56a14e39b6e0b483088ba13994e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned if the value is not found.</source>
          <target state="translated">에서 &lt;code&gt;array_position&lt;/code&gt; , &lt;code&gt;NULL&lt;/code&gt; 은 값이없는 경우 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6fb1576a237f50776165c9127d1d61a80997b7ea" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_positions&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned only if the array is &lt;code&gt;NULL&lt;/code&gt;; if the value is not found in the array, an empty array is returned instead.</source>
          <target state="translated">에서 &lt;code&gt;array_positions&lt;/code&gt; , &lt;code&gt;NULL&lt;/code&gt; 이 배열 인 경우에만 반환 &lt;code&gt;NULL&lt;/code&gt; ; 배열에 값이 없으면 빈 배열이 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="42867f00aff6799a35548d7b4a45bb429b8b6f41" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;encrypt_iv&lt;/code&gt; and &lt;code&gt;decrypt_iv&lt;/code&gt;, the &lt;em&gt;&lt;code&gt;iv&lt;/code&gt;&lt;/em&gt; parameter is the initial value for the CBC mode; it is ignored for ECB. It is clipped or padded with zeroes if not exactly block size. It defaults to all zeroes in the functions without this parameter.</source>
          <target state="translated">에서는 &lt;code&gt;encrypt_iv&lt;/code&gt; 및 &lt;code&gt;decrypt_iv&lt;/code&gt; 상기 &lt;em&gt; &lt;code&gt;iv&lt;/code&gt; &lt;/em&gt; 파라미터는 CBC 모드 용 초기 값이고; ECB에서는 무시됩니다. 정확하게 블록 크기가 아닌 경우 0으로 클리핑되거나 채워집니다. 이 매개 변수가없는 함수의 기본값은 모두 0입니다.</target>
        </trans-unit>
        <trans-unit id="74b9c4f74b2383573102ae88dc002c3f78bfc6aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;init&lt;/code&gt; mode, this option analogously specifies the location of the &lt;code&gt;initdb&lt;/code&gt; executable.</source>
          <target state="translated">에서 &lt;code&gt;init&lt;/code&gt; 모드,이 옵션은 유사의 위치를 지정 &lt;code&gt;initdb&lt;/code&gt; 를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4b893445cf37926dce5c6e98df69fc0726a60722" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g. &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">에서는 &lt;code&gt;latex-longtable&lt;/code&gt; 포맷이 제어 좌측 정렬 된 데이터 타입을 포함하는 각 컬럼의 폭에 비례. 공백으로 구분 된 값 목록으로 지정됩니다 (예 : &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; ) . 지정되지 않은 출력 열은 마지막으로 지정된 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cf4911342f242c7e8a426e1e90cc4a102540577f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g., &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">에서는 &lt;code&gt;latex-longtable&lt;/code&gt; 포맷이 제어 좌측 정렬 된 데이터 타입을 포함하는 각 컬럼의 폭에 비례. 공백으로 구분 된 값 목록으로 지정됩니다 (예 : &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; ) . 지정되지 않은 출력 열은 마지막으로 지정된 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9860fa02b7dab9c5038f80534079df8148445840" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;logical&lt;/code&gt; level, the same information is logged as with &lt;code&gt;replica&lt;/code&gt;, plus information needed to allow extracting logical change sets from the WAL. Using a level of &lt;code&gt;logical&lt;/code&gt; will increase the WAL volume, particularly if many tables are configured for &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; and many &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements are executed.</source>
          <target state="translated">&lt;code&gt;logical&lt;/code&gt; 수준 에서는 &lt;code&gt;replica&lt;/code&gt; 와 동일한 정보와 WAL에서 논리적 변경 세트를 추출하는 데 필요한 정보가 기록됩니다 . &lt;code&gt;logical&lt;/code&gt; 레벨을 사용하면 특히 많은 테이블이 &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; 에 대해 구성 되고 많은 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 문이 실행되는 경우 WAL 볼륨이 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="19415b9e6aa0d531e04e643500bbdc24d23674cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, WAL-logging of some bulk operations can be safely skipped, which can make those operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations in which this optimization can be applied include:</source>
          <target state="translated">에서 &lt;code&gt;minimal&lt;/code&gt; 수준, 일부 대량 작업의 WAL 로깅 안전하게 할 수 있습니다 (더 빠르게 그 작업을 할 수있는 생략 &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;제 14.4.7을&lt;/a&gt; ). 이 최적화를 적용 할 수있는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b6bdb288d87683bcb61f09bf26e72e3f74194ad" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, no information is logged for permanent relations for the remainder of a transaction that creates or rewrites them. This can make operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations that initiate this optimization include:</source>
          <target state="translated">&lt;code&gt;minimal&lt;/code&gt; 수준 에서는 이를 생성하거나 재 작성하는 나머지 트랜잭션에 대한 영구 관계에 대한 정보가 기록되지 않습니다. 이렇게하면 작업이 훨씬 더 빨라질 수 있습니다 ( &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;14.4.7 섹션&lt;/a&gt; 참조 ). 이 최적화를 시작하는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61bcfc364ae05487e8e54b4d5f3e06b75ec150ff" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;psql&lt;/code&gt;, you will be greeted with the following message:</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; 에서는 다음 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d81bf71ad3ee9adb26530d123722b695887e96a2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the delimiter parameter is NULL, each character in the input string will become a separate element in the resulting array. If the delimiter is an empty string, then the entire input string is returned as a one-element array. Otherwise the input string is split at each occurrence of the delimiter string.</source>
          <target state="translated">에서는 &lt;code&gt;string_to_array&lt;/code&gt; 구분 파라미터가 NULL 인 경우, 상기 입력 문자열의 각 문자가 생성 된 어레이의 개별 요소가 될 것이다. 분리 문자가 빈 문자열이면 전체 입력 문자열이 단일 요소 배열로 리턴됩니다. 그렇지 않으면 입력 문자열이 구분자 문자열이 나타날 때마다 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="ecd995c62df4a3324cc5c0dfdf5609bb28cc962a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the null-string parameter is omitted or NULL, none of the substrings of the input will be replaced by NULL. In &lt;code&gt;array_to_string&lt;/code&gt;, if the null-string parameter is omitted or NULL, any null elements in the array are simply skipped and not represented in the output string.</source>
          <target state="translated">에서는 &lt;code&gt;string_to_array&lt;/code&gt; 널 문자열 파라미터가 NULL 또는 생략 된 경우, 상기 입력 문자열의 어느 것도 NULL로 대체되지 않는다. 에서는 &lt;code&gt;array_to_string&lt;/code&gt; 널 문자열 파라미터가 생략되거나 null이면, 어레이의 모든 요소는 널 스킵 단순히 출력 문자열로 표현되지 않는다.</target>
        </trans-unit>
        <trans-unit id="b1222507b269ef568691d0a9d753a3eda5a5d8e5" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_number&lt;/code&gt;, if non-data template patterns such as &lt;code&gt;L&lt;/code&gt; or &lt;code&gt;TH&lt;/code&gt; are used, the corresponding number of input characters are skipped, whether or not they match the template pattern, unless they are data characters (that is, digits, sign, decimal point, or comma). For example, &lt;code&gt;TH&lt;/code&gt; would skip two non-data characters.</source>
          <target state="translated">에서는 &lt;code&gt;to_number&lt;/code&gt; 같은 비 데이터 템플릿 패턴 경우, &lt;code&gt;L&lt;/code&gt; 또는 &lt;code&gt;TH&lt;/code&gt; 가 사용되며, 입력 문자의 해당 숫자들은 데이터 문자 (이며, 숫자, 기호, 소수점이 아니라면들은 템플릿 패턴과 일치하는지 여부를, 스킵 또는 쉼표). 예를 들어, &lt;code&gt;TH&lt;/code&gt; 는 두 개의 비 데이터 문자를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="da01a26180a4b78ca506a4e26d673346bc64efee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, an ISO 8601 week-numbering date (as distinct from a Gregorian date) can be specified in one of two ways:</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; (양력 날짜는 별개로)는 ISO 8601 일주일 번호 날짜 두 가지 방법 중 하나를 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f9d931e068d7388b5b9791ba73a39ccc4330b961" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g. &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g. &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; , 올해 형식 사양 이하 네 자리 숫자, 예를 들어, 경우 &lt;code&gt;YYY&lt;/code&gt; 를 예를 들면, 및 제공된 년 이하 네 자리 숫자보다 올해가 2020 년에 가장 가까운로 조정 될 것이다 &lt;code&gt;95&lt;/code&gt; 1995이된다.</target>
        </trans-unit>
        <trans-unit id="d8f4914c4ba597d9e2b92d0c671f4d7641758160" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g., &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g., &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; , 올해 형식 사양은, 예를 들면, 이하 네 자리 인 경우 &lt;code&gt;YYY&lt;/code&gt; 를 , 및 제공된 년 이하 네 자리 숫자보다 올해는 예를 들어 2020 년에 가장 가까운로 조절 될 것이다 &lt;code&gt;95&lt;/code&gt; 1995이된다.</target>
        </trans-unit>
        <trans-unit id="551a2fa16ad6836b39b0369ec3903da168ff58bb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, negative years are treated as signifying BC. If you write both a negative year and an explicit &lt;code&gt;BC&lt;/code&gt; field, you get AD again. An input of year zero is treated as 1 BC.</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; , 부정적인 년 BC를 의미로 처리됩니다. 음수 연도와 명시적인 &lt;code&gt;BC&lt;/code&gt; 필드를 모두 쓰면 AD를 다시 얻습니다. 0 년의 입력은 BC 1로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4dcc47dcfb30c72df039620b4818cb5cae63885b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;CC&lt;/code&gt; (century) field is accepted but ignored if there is a &lt;code&gt;YYY&lt;/code&gt;, &lt;code&gt;YYYY&lt;/code&gt; or &lt;code&gt;Y,YYY&lt;/code&gt; field. If &lt;code&gt;CC&lt;/code&gt; is used with &lt;code&gt;YY&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt; then the result is computed as that year in the specified century. If the century is specified but the year is not, the first year of the century is assumed.</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; 는 &lt;code&gt;CC&lt;/code&gt; (세기) 필드는 가능하지만,이 경우 무시됩니다 &lt;code&gt;YYY&lt;/code&gt; , &lt;code&gt;YYYY&lt;/code&gt; 또는 &lt;code&gt;Y,YYY&lt;/code&gt; 의 필드. 경우 &lt;code&gt;CC&lt;/code&gt; 가 사용됩니다 &lt;code&gt;YY&lt;/code&gt; 또는 &lt;code&gt;Y&lt;/code&gt; , 결과는 지정된 세기에 그 해로 계산됩니다. 세기가 지정되었지만 연도가 지정되지 않은 경우 세기의 첫해가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="34928f49bb5512bad729a0eba587c351c3b66a70" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; conversion has a restriction when processing years with more than 4 digits. You must use some non-digit character or template after &lt;code&gt;YYYY&lt;/code&gt;, otherwise the year is always interpreted as 4 digits. For example (with the year 20000): &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; will be interpreted as a 4-digit year; instead use a non-digit separator after the year, like &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; or &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; 상기 &lt;code&gt;YYYY&lt;/code&gt; 에 4 개 이상의 자리 년을 처리 할 때 변환은 제한이있다. &lt;code&gt;YYYY&lt;/code&gt; 뒤에 숫자가 아닌 문자 나 템플릿을 사용해야합니다 . 그렇지 않으면 연도는 항상 4 자리로 해석됩니다. 예를 들어 (20000 년) : &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; 는 4 자리 연도로 해석됩니다. 대신 &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; 또는 &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt; 와 같이 연도 이후에 숫자가 아닌 구분 기호를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="544ec57993b0d566b29bfdeb2a8cf47932beafef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, weekday names or numbers (&lt;code&gt;DAY&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and related field types) are accepted but are ignored for purposes of computing the result. The same is true for quarter (&lt;code&gt;Q&lt;/code&gt;) fields.</source>
          <target state="translated">에서 &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; , 요일의 이름이나 숫자 ( &lt;code&gt;DAY&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; , 및 관련 분야 유형) 허용됩니다하지만 결과를 계산의 목적을 위해 무시됩니다. 분기 ( &lt;code&gt;Q&lt;/code&gt; ) 필드에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="8902e096eb8211a3103ef8a03507a1e1c0b7839c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt;, millisecond (&lt;code&gt;MS&lt;/code&gt;) or microsecond (&lt;code&gt;US&lt;/code&gt;) fields are used as the seconds digits after the decimal point. For example &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; is not 3 milliseconds, but 300, because the conversion treats it as 12 + 0.3 seconds. So, for the format &lt;code&gt;SS.MS&lt;/code&gt;, the input values &lt;code&gt;12.3&lt;/code&gt;, &lt;code&gt;12.30&lt;/code&gt;, and &lt;code&gt;12.300&lt;/code&gt; specify the same number of milliseconds. To get three milliseconds, one must write &lt;code&gt;12.003&lt;/code&gt;, which the conversion treats as 12 + 0.003 = 12.003 seconds.</source>
          <target state="translated">에서는 &lt;code&gt;to_timestamp&lt;/code&gt; , 밀리 세컨드 ( &lt;code&gt;MS&lt;/code&gt; ) 또는 마이크로 ( &lt;code&gt;US&lt;/code&gt; ) 필드는 소수점 이후의 초 디지트로서 사용된다. 예를 들어 &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; 는 3 밀리 초가 아니라 300입니다. 변환은 12 + 0.3 초로 처리하기 때문입니다. 따라서 &lt;code&gt;SS.MS&lt;/code&gt; 형식의 경우 입력 값 &lt;code&gt;12.3&lt;/code&gt; , &lt;code&gt;12.30&lt;/code&gt; 및 &lt;code&gt;12.300&lt;/code&gt; 은 동일한 밀리 초 수를 지정합니다. 3 밀리 초를 얻으려면 &lt;code&gt;12.003&lt;/code&gt; 을 작성해야 하며 변환은 12 + 0.003 = 12.003 초로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="64a9c48229747c676385712712a92e7a02f4a20e" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; followed by an alphanumeric character is either an escape or an error, while in previous releases, it was just another way of writing the alphanumeric. This should not be much of a problem because there was no reason to write such a sequence in earlier releases.</source>
          <target state="translated">ARE에서 &lt;code&gt;\&lt;/code&gt; 다음에 영숫자 문자가 이스케이프 또는 오류 인 반면, 이전 릴리스에서는 영숫자를 작성하는 또 다른 방법이었습니다. 이전 릴리스에서 이러한 시퀀스를 작성할 이유가 없었기 때문에 이는 큰 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fd039b2f7ce31cb27cef33f4f533a9fac0c1fbd" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; remains a special character within &lt;code&gt;[]&lt;/code&gt;, so a literal &lt;code&gt;\&lt;/code&gt; within a bracket expression must be written &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">ARE에서 &lt;code&gt;\&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; 내에 특수 문자로 남아 있으므로 대괄호 표현식 내의 리터럴 &lt;code&gt;\&lt;/code&gt; 는 &lt;code&gt;\\&lt;/code&gt; 로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb3ffc95899379ce4e17b50af19efa046a482415" translate="yes" xml:space="preserve">
          <source>In HTML format, this specifies attributes to be placed inside the &lt;code&gt;table&lt;/code&gt; tag. This could for example be &lt;code&gt;cellpadding&lt;/code&gt; or &lt;code&gt;bgcolor&lt;/code&gt;. Note that you probably don't want to specify &lt;code&gt;border&lt;/code&gt; here, as that is already taken care of by &lt;code&gt;\pset border&lt;/code&gt;. If no &lt;code&gt;value&lt;/code&gt; is given, the table attributes are unset.</source>
          <target state="translated">HTML 형식에서 이것은 &lt;code&gt;table&lt;/code&gt; 태그 안에 배치 될 속성을 지정합니다 . 예를 들어 &lt;code&gt;cellpadding&lt;/code&gt; 또는 &lt;code&gt;bgcolor&lt;/code&gt; 일 수 있습니다. &lt;code&gt;\pset border&lt;/code&gt; 가 이미 처리 했으므로 여기서 &lt;code&gt;border&lt;/code&gt; 를 지정하고 싶지 않을 수도 있습니다 . &lt;code&gt;value&lt;/code&gt; 을 지정 하지 않으면 테이블 속성이 설정 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="814a324a3771e36f5c269dff83adcdc2f6482fa5" translate="yes" xml:space="preserve">
          <source>In Linux 2.4 and later, the default virtual memory behavior is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="translated">Linux 2.4 이상에서 기본 가상 메모리 동작은 PostgreSQL에 최적이 아닙니다. 커널이 메모리 오버 커밋을 구현하는 방식으로 인해 PostgreSQL 또는 다른 프로세스의 메모리 요구로 인해 시스템에 가상 메모리가 부족한 경우 커널은 PostgreSQL 포스트 마스터 (마스터 서버 프로세스)를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9db993d9ed52b850a8119db5ab8d068b60a0509" translate="yes" xml:space="preserve">
          <source>In NetBSD 5.0 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">NetBSD 5.0 ​​이상에서 &lt;code&gt;sysctl&lt;/code&gt; 을 사용하여 IPC 매개 변수를 조정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33cf5a32119e2012e85b594bd01ed746ff893ad5" translate="yes" xml:space="preserve">
          <source>In OpenBSD 3.3 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">OpenBSD 3.3 이상에서 &lt;code&gt;sysctl&lt;/code&gt; 을 사용하여 IPC 매개 변수를 조정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d469c640f950b7673c7ae58a9ecc0f315265b7c1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.0, large objects did not have access privileges and were, therefore, always readable and writable by all users. Setting this variable to &lt;code&gt;on&lt;/code&gt; disables the new privilege checks, for compatibility with prior releases. The default is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">9.0 이전의 PostgreSQL 릴리스에서는 큰 객체에 액세스 권한이 없었으므로 모든 사용자가 항상 읽고 쓸 수있었습니다. 이 변수를 &lt;code&gt;on&lt;/code&gt; 으로 설정하면 이전 릴리스와의 호환성을 위해 새 권한 검사가 비활성화됩니다. 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22cd8a67509e8ca7db080a3ecd0b854c45395a98" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.3, &lt;code&gt;commit_delay&lt;/code&gt; behaved differently and was much less effective: it affected only commits, rather than all WAL flushes, and waited for the entire configured delay even if the WAL flush was completed sooner. Beginning in PostgreSQL 9.3, the first process that becomes ready to flush waits for the configured interval, while subsequent processes wait only until the leader completes the flush operation.</source>
          <target state="translated">9.3 이전의 PostgreSQL 릴리스에서는 &lt;code&gt;commit_delay&lt;/code&gt; 가 다르게 작동하고 훨씬 덜 효과적이었습니다. 모든 WAL 플러시가 아닌 커밋에만 영향을 미쳤으며 WAL 플러시가 더 빨리 완료된 경우에도 구성된 전체 지연을 기다렸습니다. PostgreSQL 9.3부터 플러시 준비가 된 첫 번째 프로세스는 구성된 간격 동안 대기하고 후속 프로세스는 리더가 플러시 작업을 완료 할 때까지만 대기합니다.</target>
        </trans-unit>
        <trans-unit id="b3a09d320c0eb1af5ebf6fc539b70645d7fbc828" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions 8.0 through 8.2, the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; would be canceled by releasing an earlier savepoint, or by successful exit from a PL/pgSQL exception block. This behavior has been changed because it was deemed unintuitive.</source>
          <target state="translated">PostgreSQL 버전 8.0에서 8.2까지 &lt;code&gt;SET LOCAL&lt;/code&gt; 의 효과 는 이전 저장 점을 해제하거나 PL / pgSQL 예외 블록을 성공적으로 종료하여 취소됩니다. 이 동작은 직관적이지 않은 것으로 간주되어 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="a2a2f1f614c98ca12a5b32b40e076079264d9c76" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was customary to avoid creating a shell type at all, by replacing the functions' forward references to the type name with the placeholder pseudo-type &lt;code&gt;opaque&lt;/code&gt;. The &lt;code&gt;cstring&lt;/code&gt; arguments and results also had to be declared as &lt;code&gt;opaque&lt;/code&gt; before 7.3. To support loading of old dump files, &lt;code&gt;CREATE TYPE&lt;/code&gt; will accept I/O functions declared using &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function declarations to use the correct types.</source>
          <target state="translated">7.3 이전의 PostgreSQL 버전에서는 형식 이름에 대한 함수의 순방향 참조를 자리 표시 자 pseudo-type &lt;code&gt;opaque&lt;/code&gt; 로 바꾸어 쉘 형식을 만드는 것을 피하는 것이 일반적이었습니다 . &lt;code&gt;cstring&lt;/code&gt; 인수 및 결과도로 선언했다 &lt;code&gt;opaque&lt;/code&gt; 7.3 전에. 기존 덤프 파일로드를 지원하기 위해 &lt;code&gt;CREATE TYPE&lt;/code&gt; 은 &lt;code&gt;opaque&lt;/code&gt; 를 사용하여 선언 된 I / O 함수를 허용 하지만, 올바른 유형을 사용하도록 통지를 발행하고 함수 선언을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b355acb666b0ad4cd57d90f2927cbffb2b6ed9ef" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare handler functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;language_handler&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">7.3 이전의 PostgreSQL 버전에서는 핸들러 함수를 &lt;code&gt;language_handler&lt;/code&gt; 가 아닌 플레이스 홀더 유형을 &lt;code&gt;opaque&lt;/code&gt; 로 리턴하는 것으로 선언해야했습니다 . 기존 덤프 파일의로드를 지원하기 위해 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 는 &lt;code&gt;opaque&lt;/code&gt; 반환으로 선언 된 함수를 허용 하지만 통지를 발행하고 함수의 선언 된 리턴 유형을 &lt;code&gt;language_handler&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="c16c4aa970c78b968d9f432a8088edb5d24051d5" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare trigger functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;trigger&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;trigger&lt;/code&gt;.</source>
          <target state="translated">7.3 이전의 PostgreSQL 버전에서는 트리거 함수를 &lt;code&gt;trigger&lt;/code&gt; 대신 플레이스 홀더 유형을 &lt;code&gt;opaque&lt;/code&gt; 리턴하는 것으로 선언해야했습니다 . 기존 덤프 파일로드를 지원하기 위해 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 는 &lt;code&gt;opaque&lt;/code&gt; 반환으로 선언 된 함수를 허용 하지만 통지를 발행하고 함수의 선언 된 리턴 유형을 &lt;code&gt;trigger&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="3c68aa880bfe2dcd90559cbb12f6681d9282ddb1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 9.4, freezing was implemented by actually replacing a row's insertion XID with &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which was visible in the row's &lt;code&gt;xmin&lt;/code&gt; system column. Newer versions just set a flag bit, preserving the row's original &lt;code&gt;xmin&lt;/code&gt; for possible forensic use. However, rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2) may still be found in databases pg_upgrade'd from pre-9.4 versions.</source>
          <target state="translated">9.4 이전의 PostgreSQL 버전에서는 행의 삽입 XID를 실제로 행의 &lt;code&gt;xmin&lt;/code&gt; 시스템 열에 표시되는 &lt;code&gt;FrozenTransactionId&lt;/code&gt; 로 대체하여 고정을 구현했습니다 . 최신 버전 은 가능한 한 법 의학적 사용을 위해 행의 원래 &lt;code&gt;xmin&lt;/code&gt; 을 유지하면서 플래그 비트를 설정했습니다 . 그러나 &lt;code&gt;xmin&lt;/code&gt; 이 &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2) 와 같은 행은 9.4 이전 버전의 pg_upgrade'd 데이터베이스에서 계속 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="671f1f8fc18839cfcffc25653d6a82f0e2f7003b" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, &lt;em&gt;Class&lt;/em&gt; is an archaic synonym for &lt;em&gt;relation&lt;/em&gt;.</source>
          <target state="translated">PostgreSQL에서 &lt;em&gt;Class&lt;/em&gt; 는 &lt;em&gt;relation&lt;/em&gt; 의 오래된 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="eadad43cc831b2ff40334680f58601d4f7a10c43" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a reference to a table name (or alias) in a query is effectively a reference to the composite value of the table's current row. For example, if we had a table &lt;code&gt;inventory_item&lt;/code&gt; as shown &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;above&lt;/a&gt;, we could write:</source>
          <target state="translated">PostgreSQL에서 쿼리의 테이블 이름 (또는 별칭)에 대한 참조는 실제로 테이블의 현재 행의 복합 값에 대한 참조입니다. 예를 들어 &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;위에&lt;/a&gt; 표시된 것처럼 &lt;code&gt;inventory_item&lt;/code&gt; 테이블이 있으면 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a86fbee986217732dc6e120d53c8e8d4a6c9100" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">PostgreSQL에서 테이블은 0 개 이상의 다른 테이블에서 상속 할 수 있으며 쿼리는 테이블의 모든 행 또는 테이블의 모든 행과 모든 하위 테이블을 참조 할 수 있습니다. 후자의 동작이 기본값입니다. 예를 들어 다음 쿼리는 주 수도를 포함하여 500 피트 이상의 고도에있는 모든 도시의 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="5bbc940645cf942038016bf2339fe7d4f2c180e0" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an elevation over 500 feet:</source>
          <target state="translated">PostgreSQL에서 테이블은 0 개 이상의 다른 테이블에서 상속 할 수 있으며 쿼리는 테이블의 모든 행 또는 테이블의 모든 행과 모든 하위 테이블을 참조 할 수 있습니다. 후자의 동작이 기본값입니다. 예를 들어 다음 쿼리는 수도를 포함하여 고도가 500 피트 이상인 모든 도시의 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="74efdce9636de27e76a8b8265ce6cb497dd89fdf" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a transaction is set up by surrounding the SQL commands of the transaction with &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; commands. So our banking transaction would actually look like:</source>
          <target state="translated">PostgreSQL에서 트랜잭션의 SQL 명령을 &lt;code&gt;BEGIN&lt;/code&gt; 및 &lt;code&gt;COMMIT&lt;/code&gt; 명령 으로 묶어 트랜잭션을 설정 합니다. 따라서 은행 거래는 실제로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba3eb2b425968ebc072af7dd5475bc71e9126bfd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL에서 행 의 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 는 이전 버전의 행을 즉시 제거하지 않습니다. 이 방법은 다중 버전 동시성 제어 (MVCC, &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조 ) 의 이점을 얻기 위해 필요합니다 . 행 버전이 다른 트랜잭션에 여전히 보이는 동안 삭제되지 않아야합니다. 그러나 결국 오래되거나 삭제 된 행 버전은 더 이상 트랜잭션에 관심이 없습니다. 디스크 공간 요구 사항이 무한대로 증가하지 않도록하려면 새 행에서 재사용 할 수 있도록 차지하는 공간을 다시 확보해야합니다. &lt;code&gt;VACUUM&lt;/code&gt; 을 실행하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="6391c36f8926e9d031902999f670ae49ff9d23c6" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL에서 행 의 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 는 이전 버전의 행을 즉시 제거하지 않습니다. 이 접근 방식은 다중 버전 동시성 제어 (MVCC, &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조 ) 의 이점을 얻기 위해 필요합니다 . 행 버전은 잠재적으로 다른 트랜잭션에 표시되는 동안 삭제해서는 안됩니다. 그러나 결국 오래되거나 삭제 된 행 버전은 더 이상 트랜잭션에 관심이 없습니다. 그런 다음 차지하는 공간은 디스크 공간 요구 사항의 무한한 증가를 방지하기 위해 새 행에서 재사용 할 수 있도록 재생되어야합니다. &lt;code&gt;VACUUM&lt;/code&gt; 을 실행하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="b304e14a0ece97ffe0ae3c2773ba82b02c4d00d4" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, the term &lt;em&gt;cluster&lt;/em&gt; is also sometimes used to refer to an instance. (Don't confuse this term with the SQL command &lt;code&gt;CLUSTER&lt;/code&gt;.)</source>
          <target state="translated">PostgreSQL에서 &lt;em&gt;클러스터&lt;/em&gt; 라는 용어 는 인스턴스를 가리키는데도 사용됩니다. (이 용어를 SQL 명령 &lt;code&gt;CLUSTER&lt;/code&gt; 와 혼동하지 마십시오 .)</target>
        </trans-unit>
        <trans-unit id="bbda6fce7f63ccb95f1398e8c5c8a9c6bb83f492" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e. PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">PostgreSQL에서는 4 가지 표준 트랜잭션 격리 수준 중 하나를 요청할 수 있지만 내부적으로 3 개의 개별 격리 수준 만 구현됩니다. 즉, PostgreSQL의 Uncommitted 모드는 Read Committed와 같이 작동합니다. 표준 격리 수준을 PostgreSQL의 다중 버전 동시성 제어 아키텍처에 매핑 할 수있는 유일한 방법이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="83cd5c09f1c331276300cecbfba985d6b8844acd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e., PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">PostgreSQL에서는 4 개의 표준 트랜잭션 격리 수준 중 하나를 요청할 수 있지만 내부적으로는 세 가지 격리 수준 만 구현됩니다. 즉, PostgreSQL의 커밋되지 않은 읽기 모드는 커밋 된 읽기와 같이 작동합니다. 이는 표준 격리 수준을 PostgreSQL의 다중 버전 동시성 제어 아키텍처에 매핑하는 유일한 현명한 방법이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="759eb406805a5a1c000f22431f41b882c8790352" translate="yes" xml:space="preserve">
          <source>In SCRAM without channel binding, the server chooses a random number that is transmitted to the client to be mixed with the user-supplied password in the transmitted password hash. While this prevents the password hash from being successfully retransmitted in a later session, it does not prevent a fake server between the real server and client from passing through the server's random value and successfully authenticating.</source>
          <target state="translated">채널 바인딩이없는 SCRAM에서 서버는 클라이언트로 전송 된 난수를 선택하여 전송 된 비밀번호 해시에서 사용자 제공 비밀번호와 혼합합니다. 이렇게하면 이후 세션에서 암호 해시가 성공적으로 재전송되지 않지만 실제 서버와 클라이언트 사이의 가짜 서버가 서버의 임의의 값을 통과하여 성공적으로 인증되는 것을 막을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bbe3d8277f59658a3be0c65846387947fe489961" translate="yes" xml:space="preserve">
          <source>In SQL:2006 and later, both directions of conversion between standard SQL data types and the XML Schema types are specified precisely. However, the rules are expressed using the types and semantics of XQuery/XPath, and have no direct application to the different data model of XPath 1.0.</source>
          <target state="translated">SQL : 2006 이상에서는 표준 SQL 데이터 유형과 XML 스키마 유형 간의 변환 방향이 모두 정확하게 지정됩니다. 그러나 규칙은 XQuery / XPath의 유형과 의미를 사용하여 표현되며 XPath 1.0의 다른 데이터 모델에 직접 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cddd15d85853fd05a956af5b4c400072d8cd616" translate="yes" xml:space="preserve">
          <source>In Solaris 10 and later, and OpenSolaris, the default shared memory and semaphore settings are good enough for most PostgreSQL applications. Solaris now defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="translated">Solaris 10 이상 및 OpenSolaris에서 기본 공유 메모리 및 세마포어 설정은 대부분의 PostgreSQL 응용 프로그램에 충분합니다. Solaris는 기본적으로 시스템 RAM의 1/4 인 &lt;code&gt;SHMMAX&lt;/code&gt; 로 설정됩니다. 이 설정을 추가로 조정하려면 &lt;code&gt;postgres&lt;/code&gt; 사용자 와 관련된 프로젝트 설정을 사용하십시오. 예를 들어, &lt;code&gt;root&lt;/code&gt; 다음을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2711fad286d67111c91bf5304258de9bff55609" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;BEFORE&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just before the function is or would be executed, so using &lt;code&gt;WHEN&lt;/code&gt; is not materially different from testing the same condition at the beginning of the trigger function. Note in particular that the &lt;code&gt;NEW&lt;/code&gt; row seen by the condition is the current value, as possibly modified by earlier triggers. Also, a &lt;code&gt;BEFORE&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition is not allowed to examine the system columns of the &lt;code&gt;NEW&lt;/code&gt; row (such as &lt;code&gt;ctid&lt;/code&gt;), because those won't have been set yet.</source>
          <target state="translated">A의 &lt;code&gt;BEFORE&lt;/code&gt; 트리거는 &lt;code&gt;WHEN&lt;/code&gt; 조건은 함수 또는 그렇게하여 실행된다 직전 평가 &lt;code&gt;WHEN&lt;/code&gt; 트리거 함수의 시작 부분에 동일한 조건을 테스트 실질적으로 다르지 않다. 특히 조건에 표시되는 &lt;code&gt;NEW&lt;/code&gt; 행은 이전 트리거에 의해 수정 될 수있는 현재 값입니다. 또한 &lt;code&gt;BEFORE&lt;/code&gt; 트리거의 &lt;code&gt;WHEN&lt;/code&gt; 조건은 아직 설정되지 않았기 때문에 &lt;code&gt;NEW&lt;/code&gt; 행 의 시스템 열 (예 : &lt;code&gt;ctid&lt;/code&gt; ) 을 검사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ce810944c17541339c741b40b793201537de044" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DELETE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the content of the deleted row. For example:</source>
          <target state="translated">A의 &lt;code&gt;DELETE&lt;/code&gt; , 사용할 수있는 데이터 &lt;code&gt;RETURNING&lt;/code&gt; 삭제 된 행의 내용이다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d3bf14e9dc0493ac82721df4faae7ba81c88992" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DROP FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support must be specified.</source>
          <target state="translated">A의 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 절 피연산자 데이터 타입 (들) 함수를 지원하기위한 지정해야한다.</target>
        </trans-unit>
        <trans-unit id="85532f42163c3739d7f5a6244714ead077b8baea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">A의 &lt;code&gt;FUNCTION&lt;/code&gt; 의 절 피연산자 데이터 타입 (들)는 함수에 대한 (또는 클래스의 데이터 타입 (B 트리 비교 기능 및 해시 함수에 대한) 입력 데이터 타입 (들) 함수와 다를 경우, 지지체 의도 B- 트리 정렬은 GiST, SP-GiST, GIN 및 BRIN 연산자 클래스의 기능 및 모든 기능을 지원합니다. 이러한 기본값은 정확하므로 크로스 데이터 유형 비교를 지원하는 B- 트리 정렬 지원 함수의 경우를 제외하고는 &lt;code&gt;op_type&lt;/code&gt; 을 &lt;code&gt;FUNCTION&lt;/code&gt; 절에 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="48b115e1e3ffc8870fd0440011ed57528dd63c06" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions, B-tree equal image functions, and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">A의 &lt;code&gt;FUNCTION&lt;/code&gt; 의 절 피연산자 데이터 타입 (들)는 함수에 대한 (또는 클래스의 데이터 타입 (B 트리 비교 기능 및 해시 함수에 대한) 입력 데이터 타입 (들) 함수와 다를 경우, 지지체 의도 B- 트리 정렬 지원 기능, B- 트리 동일 이미지 기능 및 GiST, SP-GiST, GIN 및 BRIN 연산자 클래스의 모든 기능). 이러한 기본값은 올바르므로 데이터 유형 간 비교를 지원하는 B- 트리 정렬 지원 함수의 경우를 제외하고는 &lt;code&gt;op_type&lt;/code&gt; 을 &lt;code&gt;FUNCTION&lt;/code&gt; 절에 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6f9bb9a1e74c73e631d5463da369a9644506e4f0" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SELECT&lt;/code&gt; command, these two policies are combined using &lt;code&gt;OR&lt;/code&gt;, with the net effect being that all rows can be selected. In other command types, only the second policy applies, so that the effects are the same as before.</source>
          <target state="translated">A의 &lt;code&gt;SELECT&lt;/code&gt; 명령,이 두 가지 정책을 사용하여 결합 &lt;code&gt;OR&lt;/code&gt; 모든 행이 선택 될 수있는 그물 효과. 다른 명령 유형에서는 효과가 이전과 동일하도록 두 번째 정책 만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="300ce212406203fa6b094fb383bde2b25f44a159" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;pg_hba.conf&lt;/code&gt; record specifying certificate authentication, the authentication option &lt;code&gt;clientcert&lt;/code&gt; is assumed to be &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;, and it cannot be turned off since a client certificate is necessary for this method. What the &lt;code&gt;cert&lt;/code&gt; method adds to the basic &lt;code&gt;clientcert&lt;/code&gt; certificate validity test is a check that the &lt;code&gt;cn&lt;/code&gt; attribute matches the database user name.</source>
          <target state="translated">인증서 인증을 지정 하는 &lt;code&gt;pg_hba.conf&lt;/code&gt; 레코드에서 인증 옵션 &lt;code&gt;clientcert&lt;/code&gt; 는 &lt;code&gt;verify-ca&lt;/code&gt; 또는 &lt;code&gt;verify-full&lt;/code&gt; 로 간주 되며이 방법에는 클라이언트 인증서가 필요하므로 해제 할 수 없습니다. 무엇 &lt;code&gt;cert&lt;/code&gt; 방법은 기본에 추가 &lt;code&gt;clientcert&lt;/code&gt; 의 인증서 유효 검사하면하는 검사입니다 &lt;code&gt;cn&lt;/code&gt; 속성은 데이터베이스 사용자 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f05e815aa51edd32e8f243de544f1a7fed6f4907" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;to_char&lt;/code&gt; output template string, there are certain patterns that are recognized and replaced with appropriately-formatted data based on the given value. Any text that is not a template pattern is simply copied verbatim. Similarly, in an input template string (for the other functions), template patterns identify the values to be supplied by the input data string. If there are characters in the template string that are not template patterns, the corresponding characters in the input data string are simply skipped over (whether or not they are equal to the template string characters).</source>
          <target state="translated">A의 &lt;code&gt;to_char&lt;/code&gt; 출력 템플릿 문자열 인식 주어진 값에 기초하여 적절하게 포맷 된 데이터로 대체되는 특정 패턴이있다. 템플릿 패턴이 아닌 텍스트는 그대로 그대로 복사됩니다. 마찬가지로 입력 템플릿 문자열 (다른 기능의 경우)에서 템플릿 패턴은 입력 데이터 문자열이 제공 할 값을 식별합니다. 템플릿 문자열에 템플릿 패턴이 아닌 문자가있는 경우 입력 데이터 문자열의 해당 문자를 건너 뜁니다 (템플릿 문자열 문자와 같은지 여부).</target>
        </trans-unit>
        <trans-unit id="78e3bba2064f9d9c2fee2733a54ca75d990eba66" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;hash join&lt;/em&gt; (without the &quot;parallel&quot; prefix), the inner side is executed in full by every cooperating process to build identical copies of the hash table. This may be inefficient if the hash table is large or the plan is expensive. In a &lt;em&gt;parallel hash join&lt;/em&gt;, the inner side is a &lt;em&gt;parallel hash&lt;/em&gt; that divides the work of building a shared hash table over the cooperating processes.</source>
          <target state="translated">A의 &lt;em&gt;해시 조인&lt;/em&gt; (이하 &quot;평행&quot;접두어없이) 내측은 해시 테이블의 동일한 복사본을 만들 모든 협력 프로세스 전체에서 실행된다. 해시 테이블이 크거나 계획이 비싸면 비효율적 일 수 있습니다. (A)에 &lt;em&gt;평행 한 해시 조인&lt;/em&gt; , 내측은 인 &lt;em&gt;병렬 해시&lt;/em&gt; 분할하는 협력 과정을 통해 공유 해시 테이블을 구축하는 작업.</target>
        </trans-unit>
        <trans-unit id="3480286d445961d6181c445c4ffd40322b928fd9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;merge join&lt;/em&gt;, the inner side is always a non-parallel plan and therefore executed in full. This may be inefficient, especially if a sort must be performed, because the work and resulting data are duplicated in every cooperating process.</source>
          <target state="translated">A의 &lt;em&gt;병합 조인&lt;/em&gt; , 내측 항상 평행하지 않은 평면이므로 전체 실행. 작업 및 결과 데이터가 모든 협력 프로세스에서 복제되므로 특히 정렬을 수행해야하는 경우 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="400e7c200fdc3546ddf00f5c7ed10cb2ab42e4c0" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;nested loop join&lt;/em&gt;, the inner side is always non-parallel. Although it is executed in full, this is efficient if the inner side is an index scan, because the outer tuples and thus the loops that look up values in the index are divided over the cooperating processes.</source>
          <target state="translated">(A)에 &lt;em&gt;중첩 루프 조인&lt;/em&gt; , 내측 항상 비 - 평행하다. 전체가 실행 되더라도 외부 튜플과 인덱스의 값을 찾는 루프가 협력 프로세스로 나누어 져 있기 때문에 내부가 인덱스 스캔 인 경우에 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="dea6a7ade41e8f01fb686c080220d4159b567183" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel bitmap heap scan&lt;/em&gt;, one process is chosen as the leader. That process performs a scan of one or more indexes and builds a bitmap indicating which table blocks need to be visited. These blocks are then divided among the cooperating processes as in a parallel sequential scan. In other words, the heap scan is performed in parallel, but the underlying index scan is not.</source>
          <target state="translated">(A)에 &lt;em&gt;평행 한 비트 맵 힙 주사&lt;/em&gt; 한 프로세스는 리더로서 선택된다. 이 프로세스는 하나 이상의 인덱스를 스캔하고 방문해야 할 테이블 블록을 나타내는 비트 맵을 작성합니다. 이 블록들은 병렬 순차 스캔에서와 같이 협력 프로세스들 사이에서 분할된다. 즉, 힙 스캔은 병렬로 수행되지만 기본 인덱스 스캔은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8227deba10aefb19ed8caa11f69ff745de460ae7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other process can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">A의 &lt;em&gt;스캔 인덱스 평행&lt;/em&gt; 또는 &lt;em&gt;평행 인덱스 만 스캔&lt;/em&gt; , 협력 프로세스는 인덱스로부터 데이터를 판독 돌아가며. 현재 병렬 인덱스 스캔은 btree 인덱스에 대해서만 지원됩니다. 각 프로세스는 단일 인덱스 블록을 요구하며 해당 블록이 참조하는 모든 튜플을 스캔하고 반환합니다. 다른 프로세스는 동시에 다른 인덱스 블록에서 튜플을 반환 할 수 있습니다. 병렬 btree 스캔 결과는 각 작업자 프로세스 내에서 정렬 된 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="76601edb0fbc4f9ce17e08d79102a74db01983a7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other processes can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">A의 &lt;em&gt;스캔 인덱스 평행&lt;/em&gt; 또는 &lt;em&gt;평행 인덱스 만 스캔&lt;/em&gt; , 협력 프로세스는 인덱스로부터 데이터를 판독 돌아가며. 현재 병렬 인덱스 스캔은 btree 인덱스에 대해서만 지원됩니다. 각 프로세스는 단일 인덱스 블록을 요구하고 해당 블록이 참조하는 모든 튜플을 스캔하고 반환합니다. 다른 프로세스는 동시에 다른 인덱스 블록에서 튜플을 반환 할 수 있습니다. 병렬 btree 스캔의 결과는 각 작업자 프로세스 내에서 정렬 된 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9434bbdc8aace98fbdb811c879672bca3c9b835e" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel sequential scan&lt;/em&gt;, the table's blocks will be divided among the cooperating processes. Blocks are handed out one at a time, so that access to the table remains sequential.</source>
          <target state="translated">(A)에 &lt;em&gt;병렬로 순차 검색&lt;/em&gt; 테이블의 블록 협력 프로세스간에 분할된다. 블록은 한 번에 하나씩 전달되므로 테이블에 대한 액세스는 순차적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f3fefb800e2db94c9c9a41bf996e2bc5c5260e63" translate="yes" xml:space="preserve">
          <source>In a B-tree leaf page, &lt;code&gt;ctid&lt;/code&gt; points to a heap tuple. In an internal page, the block number part of &lt;code&gt;ctid&lt;/code&gt; points to another page in the index itself, while the offset part (the second number) is ignored and is usually 1.</source>
          <target state="translated">B- 트리 리프 페이지에서 &lt;code&gt;ctid&lt;/code&gt; 는 힙 튜플을 가리 킵니다. 내부 페이지에서 &lt;code&gt;ctid&lt;/code&gt; 의 블록 번호 부분은 인덱스 자체의 다른 페이지를 가리키는 반면 오프셋 부분 (두 번째 숫자)은 무시되며 보통 1입니다.</target>
        </trans-unit>
        <trans-unit id="d0a6087a10f85c3bb150e6308e3861061574aa67" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">동시 인덱스 빌드에서 인덱스는 실제로 하나의 트랜잭션으로 시스템 카탈로그에 입력 된 다음 두 개의 추가 트랜잭션에서 두 개의 테이블 스캔이 발생합니다. 각 테이블 스캔 전에 인덱스 빌드는 테이블을 수정 한 기존 트랜잭션이 종료 될 때까지 기다려야합니다. 두 번째 스캔 후 인덱스 빌드는 두 번째 스캔보다 우선 하는 스냅 샷 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조)이있는 트랜잭션이 종료 될 때까지 기다려야합니다 . 그런 다음 마지막으로 색인을 사용할 준비가되었음을 표시하고 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령을 종료합니다. 그럼에도 불구하고 인덱스는 쿼리에 즉시 사용 가능하지 않을 수 있습니다. 최악의 경우 인덱스 빌드 시작 이전의 트랜잭션이 존재하는 한 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c15278182867851c1af83a8c951f5ef55e2fcbe1" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">동시 인덱스 빌드에서 인덱스는 실제로 하나의 트랜잭션에서 시스템 카탈로그에 입력 된 다음 두 개의 추가 트랜잭션에서 두 개의 테이블 스캔이 발생합니다. 각 테이블 스캔 전에 인덱스 빌드는 테이블을 수정 한 기존 트랜잭션이 종료 될 때까지 기다려야합니다. 두 번째 스캔 후 인덱스 빌드는 두 번째 스캔 이전의 스냅 샷 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조)이있는 트랜잭션이 종료 될 때까지 기다려야합니다 . 그런 다음 마지막으로 인덱스를 사용할 준비가 된 것으로 표시하고 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령이 종료됩니다. 그러나 그럼에도 불구하고 인덱스는 쿼리에 즉시 사용할 수 없습니다. 최악의 경우 인덱스 빌드 시작 이전에 트랜잭션이 존재하는 한 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4a542d58c1d654f7da71e85731698e5120795a1" translate="yes" xml:space="preserve">
          <source>In a default installation, none of the above parameters are set explicitly. Instead, the data directory is specified by the &lt;code&gt;-D&lt;/code&gt; command-line option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable, and the configuration files are all found within the data directory.</source>
          <target state="translated">기본 설치에서는 위의 매개 변수 중 어느 것도 명시 적으로 설정되지 않습니다. 대신, 데이터 디렉토리는 &lt;code&gt;-D&lt;/code&gt; 명령 행 옵션 또는 &lt;code&gt;PGDATA&lt;/code&gt; 환경 변수에 의해 지정되며 구성 파일은 모두 데이터 디렉토리 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ade0e33e559fe0711e0dbe8eb460618e29475014" translate="yes" xml:space="preserve">
          <source>In a dropped column's &lt;code&gt;pg_attribute&lt;/code&gt; entry, &lt;code&gt;atttypid&lt;/code&gt; is reset to zero, but &lt;code&gt;attlen&lt;/code&gt; and the other fields copied from &lt;code&gt;pg_type&lt;/code&gt; are still valid. This arrangement is needed to cope with the situation where the dropped column's data type was later dropped, and so there is no &lt;code&gt;pg_type&lt;/code&gt; row anymore. &lt;code&gt;attlen&lt;/code&gt; and the other fields can be used to interpret the contents of a row of the table.</source>
          <target state="translated">삭제 된 열의 &lt;code&gt;pg_attribute&lt;/code&gt; 항목에서 &lt;code&gt;atttypid&lt;/code&gt; 는 0으로 재설정되지만 &lt;code&gt;attlen&lt;/code&gt; 및 &lt;code&gt;pg_type&lt;/code&gt; 에서 복사 된 다른 필드 는 여전히 유효합니다. 삭제 된 열의 데이터 유형이 나중에 삭제 된 상황에 대처하기 위해이 배열이 필요하므로 더 이상 &lt;code&gt;pg_type&lt;/code&gt; 행이 없습니다. &lt;code&gt;attlen&lt;/code&gt; 및 기타 필드를 사용하여 테이블 행의 내용을 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="919410546242ad36460212f72d578356bff6291e" translate="yes" xml:space="preserve">
          <source>In a literal that has been determined to be &lt;code&gt;timestamp without time zone&lt;/code&gt;, PostgreSQL will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.</source>
          <target state="translated">&lt;code&gt;timestamp without time zone&lt;/code&gt; 것으로 확인 된 리터럴 에서 PostgreSQL은 모든 표준 시간대 표시를 자동으로 무시합니다. 즉, 결과 값은 입력 값의 날짜 / 시간 필드에서 파생되며 시간대에 맞게 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe8c5382c7df4fd888e297e6990fce336207e731" translate="yes" xml:space="preserve">
          <source>In a priority-based synchronous replication, the standbys whose names appear earlier in the list will be used as synchronous standbys. Standbys listed after these will take over the role of synchronous standby if one of current ones should fail.</source>
          <target state="translated">우선 순위 기반 동기식 복제에서는 목록에서 이름이 일찍 표시되는 대기가 동기식 대기로 사용됩니다. 다음에 나열된 대기는 현재 대기 중 하나가 실패하는 경우 동기 대기의 역할을 대신합니다.</target>
        </trans-unit>
        <trans-unit id="6be13ad3386e50cb4bfa2ce22e78dd04cec9a6ab" translate="yes" xml:space="preserve">
          <source>In a quorum-based synchronous replication, all the standbys appearing in the list will be used as candidates for synchronous standbys. Even if one of them should fail, the other standbys will keep performing the role of candidates of synchronous standby.</source>
          <target state="translated">쿼럼 기반 동기 복제에서는 목록에 나타나는 모든 대기가 동기 대기의 후보로 사용됩니다. 이들 중 하나가 실패하더라도 다른 대기는 동기 대기 후보의 역할을 계속 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a6cdb6331798b6847433d71683fa652dae3c0858" translate="yes" xml:space="preserve">
          <source>In a rule for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; on a view, you can add a &lt;code&gt;RETURNING&lt;/code&gt; clause that emits the view's columns. This clause will be used to compute the outputs if the rule is triggered by an &lt;code&gt;INSERT RETURNING&lt;/code&gt;, &lt;code&gt;UPDATE RETURNING&lt;/code&gt;, or &lt;code&gt;DELETE RETURNING&lt;/code&gt; command respectively. When the rule is triggered by a command without &lt;code&gt;RETURNING&lt;/code&gt;, the rule's &lt;code&gt;RETURNING&lt;/code&gt; clause will be ignored. The current implementation allows only unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules to contain &lt;code&gt;RETURNING&lt;/code&gt;; furthermore there can be at most one &lt;code&gt;RETURNING&lt;/code&gt; clause among all the rules for the same event. (This ensures that there is only one candidate &lt;code&gt;RETURNING&lt;/code&gt; clause to be used to compute the results.) &lt;code&gt;RETURNING&lt;/code&gt; queries on the view will be rejected if there is no &lt;code&gt;RETURNING&lt;/code&gt; clause in any available rule.</source>
          <target state="translated">뷰의 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 규칙 에서 뷰의 열을 생성 하는 &lt;code&gt;RETURNING&lt;/code&gt; 절을 추가 할 수 있습니다 . 이 절은 규칙이 각각 &lt;code&gt;INSERT RETURNING&lt;/code&gt; , &lt;code&gt;UPDATE RETURNING&lt;/code&gt; 또는 &lt;code&gt;DELETE RETURNING&lt;/code&gt; 명령 에 의해 트리거되는 경우 출력을 계산하는 데 사용됩니다 . &lt;code&gt;RETURNING&lt;/code&gt; 이 없는 명령에 의해 규칙이 트리거 되면 규칙의 &lt;code&gt;RETURNING&lt;/code&gt; 절이 무시됩니다. 현재 구현에서는 무조건 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙 만 &lt;code&gt;RETURNING&lt;/code&gt; 을 포함 할 수 있습니다 . 또한 최대 하나의 &lt;code&gt;RETURNING&lt;/code&gt; 이있을 수 있습니다.동일한 이벤트에 대한 모든 규칙 중 조항. 이렇게하면 결과를 계산하는 데 사용할 후보 &lt;code&gt;RETURNING&lt;/code&gt; 절이 하나만 있게됩니다. 사용 가능한 규칙에 &lt;code&gt;RETURNING&lt;/code&gt; 절이 없으면 뷰의 &lt;code&gt;RETURNING&lt;/code&gt; 쿼리가 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="b30170def17c750dae562bb19e988c5bae9da5a7" translate="yes" xml:space="preserve">
          <source>In a simple join query, such as:</source>
          <target state="translated">다음과 같은 간단한 조인 쿼리에서</target>
        </trans-unit>
        <trans-unit id="3e1f4464d1af94cd74998edaeff888eee6d91174" translate="yes" xml:space="preserve">
          <source>In a standby server that exists primarily for high availability, it's best to set the delay parameters relatively short, so that the server cannot fall far behind the primary due to delays caused by standby queries. However, if the standby server is meant for executing long-running queries, then a high or even infinite delay value may be preferable. Keep in mind however that a long-running query could cause other sessions on the standby server to not see recent changes on the primary, if it delays application of WAL records.</source>
          <target state="translated">주로 고 가용성을 위해 존재하는 대기 서버에서는 지연 매개 변수를 비교적 짧게 설정하는 것이 가장 좋습니다. 따라서 대기 쿼리로 인한 지연으로 인해 서버가 기본 서버보다 훨씬 떨어지지 않게됩니다. 그러나 대기 서버가 장기 실행 쿼리를 실행하기위한 것이면 높거나 무한한 지연 값이 바람직 할 수 있습니다. 그러나 장기 실행 쿼리로 인해 대기 서버의 다른 세션에서 기본 세션의 WAL 레코드 적용이 지연되는 경우 기본 세션의 최근 변경 사항을 보지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9a7bd917eb1db2204b6427584eda8a4fd3adfe" translate="yes" xml:space="preserve">
          <source>In a table definition, default values are listed after the column data type. For example:</source>
          <target state="translated">테이블 정의에서 기본값은 열 데이터 유형 뒤에 나열됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea0511eba225911c6d4bd1330fecc7bed6e9ecc3" translate="yes" xml:space="preserve">
          <source>In addition these settings can be preserved between reboots in the file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. Doing that is highly recommended.</source>
          <target state="translated">또한이 설정은 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 파일에서 재부팅 할 때에도 유지 될 수 있습니다 . 그렇게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="096299b269c3119f5fd70cea143f131c4bf07844" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;postgresql.conf&lt;/code&gt;, a PostgreSQL data directory contains a file &lt;code&gt;postgresql.auto.conf&lt;/code&gt;, which has the same format as &lt;code&gt;postgresql.conf&lt;/code&gt; but is intended to be edited automatically, not manually. This file holds settings provided through the &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command. This file is read whenever &lt;code&gt;postgresql.conf&lt;/code&gt; is, and its settings take effect in the same way. Settings in &lt;code&gt;postgresql.auto.conf&lt;/code&gt; override those in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 외에도 PostgreSQL 데이터 디렉토리에는 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 와 형식은 동일 하지만 수동이 아닌 자동으로 편집되도록 고안된 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일이 포함되어 있습니다. 이 파일은 &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; 명령을 통해 제공된 설정을 보유 합니다. 이 파일은 &lt;code&gt;postgresql.conf&lt;/code&gt; 가 있을 때마다 읽히고 설정은 같은 방식으로 적용됩니다. 의 설정 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 은 의 그 무시 &lt;code&gt;postgresql.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b72ebbfc32b5c7dc9d476e5e61c36ae4f704bc0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;public&lt;/code&gt; and user-created schemas, each database contains a &lt;code&gt;pg_catalog&lt;/code&gt; schema, which contains the system tables and all the built-in data types, functions, and operators. &lt;code&gt;pg_catalog&lt;/code&gt; is always effectively part of the search path. If it is not named explicitly in the path then it is implicitly searched &lt;em&gt;before&lt;/em&gt; searching the path's schemas. This ensures that built-in names will always be findable. However, you can explicitly place &lt;code&gt;pg_catalog&lt;/code&gt; at the end of your search path if you prefer to have user-defined names override built-in names.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 및 사용자 작성 스키마 외에도 각 데이터베이스에는 시스템 테이블과 모든 내장 데이터 유형, 함수 및 연산자 가 포함 된 &lt;code&gt;pg_catalog&lt;/code&gt; 스키마가 포함됩니다. &lt;code&gt;pg_catalog&lt;/code&gt; 는 항상 효과적으로 검색 경로의 일부입니다. 경로에서 명시 적으로 이름이 지정되지 않은 경우 경로의 스키마를 검색 &lt;em&gt;하기 전에&lt;/em&gt; 내재적으로 검색 됩니다. 이를 통해 내장 이름을 항상 찾을 수 있습니다. 그러나 사용자 정의 이름이 내장 이름보다 우선하도록하려면 검색 경로 끝에 &lt;code&gt;pg_catalog&lt;/code&gt; 를 명시 적으로 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f70bc34b6f3d01fe499b2933dfc1efba4688427d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;standard_conforming_strings&lt;/code&gt;, the configuration parameters &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; and &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote&lt;/a&gt; govern treatment of backslashes in string constants.</source>
          <target state="translated">뿐만 아니라 &lt;code&gt;standard_conforming_strings&lt;/code&gt; , 구성 매개 변수 &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote는&lt;/a&gt; 문자열 상수의 백 슬래시의 치료에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca198320ff48380e299bcbd7319925ded5a95535" translate="yes" xml:space="preserve">
          <source>In addition to individual parameter settings, the &lt;code&gt;postgresql.conf&lt;/code&gt; file can contain &lt;em&gt;include directives&lt;/em&gt;, which specify another file to read and process as if it were inserted into the configuration file at this point. This feature allows a configuration file to be divided into physically separate parts. Include directives simply look like:</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 파일에는 개별 매개 변수 설정 외에도 &lt;em&gt;include 지시문&lt;/em&gt; 이 포함될 수 있습니다. &lt;em&gt;이 지시문&lt;/em&gt; 은이 시점에서 구성 파일에 삽입 된 것처럼 읽고 처리 할 다른 파일을 지정합니다. 이 기능을 사용하면 구성 파일을 물리적으로 분리 된 부분으로 나눌 수 있습니다. 지시문 포함은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e670e7bf52fa0455274db822ce4cd6907d528db9" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the &lt;code&gt;numeric&lt;/code&gt; type allows the special value &lt;code&gt;NaN&lt;/code&gt;, meaning &amp;ldquo;not-a-number&amp;rdquo;. Any operation on &lt;code&gt;NaN&lt;/code&gt; yields another &lt;code&gt;NaN&lt;/code&gt;. When writing this value as a constant in an SQL command, you must put quotes around it, for example &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt;. On input, the string &lt;code&gt;NaN&lt;/code&gt; is recognized in a case-insensitive manner.</source>
          <target state="translated">일반 숫자 값 외에도 &lt;code&gt;numeric&lt;/code&gt; 유형은 &quot;숫자가 아님&quot;을 의미 하는 특수 값 &lt;code&gt;NaN&lt;/code&gt; 을 허용합니다 . &lt;code&gt;NaN&lt;/code&gt; 에 대한 작업 은 다른 &lt;code&gt;NaN&lt;/code&gt; 을 생성 합니다. SQL 명령에서이 값을 상수로 쓸 때 &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt; 과 같이 따옴표를 묶어야합니다 . 입력시 문자열 &lt;code&gt;NaN&lt;/code&gt; 은 대소 문자를 구분하지 않고 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="e4bbcc684e36efbca1c2d0b6de3932866401bc9a" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the floating-point types have several special values:</source>
          <target state="translated">일반 숫자 값 외에도 부동 소수점 유형에는 몇 가지 특수 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="19311d87cac186ad5be7afccb28d88535be2bd00" translate="yes" xml:space="preserve">
          <source>In addition to setting global defaults or attaching overrides at the database or role level, you can pass settings to PostgreSQL via shell facilities. Both the server and libpq client library accept parameter values via the shell.</source>
          <target state="translated">데이터베이스 또는 역할 수준에서 전역 기본값을 설정하거나 재정의를 첨부하는 것 외에도 셸 기능을 통해 설정을 PostgreSQL로 전달할 수 있습니다. 서버 및 libpq 클라이언트 라이브러리는 모두 쉘을 통해 매개 변수 값을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="a22166b5786a29ccaf8b6526c1e48730c5b76cde" translate="yes" xml:space="preserve">
          <source>In addition to simply finding the rows to be returned by a query, an index may be able to deliver them in a specific sorted order. This allows a query's &lt;code&gt;ORDER BY&lt;/code&gt; specification to be honored without a separate sorting step. Of the index types currently supported by PostgreSQL, only B-tree can produce sorted output &amp;mdash; the other index types return matching rows in an unspecified, implementation-dependent order.</source>
          <target state="translated">쿼리에서 반환 할 행을 찾는 것 외에도 인덱스는 특정 정렬 순서로 행을 전달할 수 있습니다. 이를 통해 별도의 정렬 단계없이 쿼리의 &lt;code&gt;ORDER BY&lt;/code&gt; 사양을 유지할 수 있습니다. 현재 PostgreSQL에서 지원하는 인덱스 유형 중 B- 트리 만 정렬 된 출력을 생성 할 수 있습니다. 다른 인덱스 유형은 지정되지 않은 구현 종속 순서로 일치하는 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ba1e6913eefc780040c670e81ceade68f518709" translate="yes" xml:space="preserve">
          <source>In addition to supporting ordinary index scans, some types of index may wish to support &lt;em&gt;parallel index scans&lt;/em&gt;, which allow multiple backends to cooperate in performing an index scan. The index access method should arrange things so that each cooperating process returns a subset of the tuples that would be performed by an ordinary, non-parallel index scan, but in such a way that the union of those subsets is equal to the set of tuples that would be returned by an ordinary, non-parallel index scan. Furthermore, while there need not be any global ordering of tuples returned by a parallel scan, the ordering of that subset of tuples returned within each cooperating backend must match the requested ordering. The following functions may be implemented to support parallel index scans:</source>
          <target state="translated">일반 인덱스 스캔을 지원하는 것 외에도 일부 유형의 인덱스는 &lt;em&gt;병렬 인덱스 스캔&lt;/em&gt; 을 지원 하여 여러 백엔드가 인덱스 스캔을 수행하는 데 협력 할 수 있습니다. 인덱스 액세스 방법은 각 협력 프로세스가 일반적인 비평 행 인덱스 스캔에 의해 수행 될 터플의 서브 세트를 리턴하지만 해당 서브 세트의 합집합이 터플 세트와 같은 방식으로 리턴하도록 항목을 배열해야합니다. 이는 병렬이 아닌 일반 인덱스 스캔에 의해 리턴됩니다. 또한, 병렬 스캔에 의해 리턴 된 튜플의 전체 순서는 필요하지 않지만, 각 협력 백엔드 내에서 리턴 된 해당 튜플 서브 세트의 순서는 요청 된 순서와 일치해야합니다. 병렬 인덱스 스캔을 지원하기 위해 다음 기능이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2240e6efaaf6aaec400aa311d695b65a5cb9013d" translate="yes" xml:space="preserve">
          <source>In addition to table and row locks, page-level share/exclusive locks are used to control read/write access to table pages in the shared buffer pool. These locks are released immediately after a row is fetched or updated. Application developers normally need not be concerned with page-level locks, but they are mentioned here for completeness.</source>
          <target state="translated">테이블 및 행 잠금 외에도 페이지 레벨 공유 / 독점 잠금은 공유 버퍼 풀의 테이블 페이지에 대한 읽기 / 쓰기 액세스를 제어하는 ​​데 사용됩니다. 이러한 잠금은 행을 가져 오거나 업데이트 한 직후 해제됩니다. 응용 프로그램 개발자는 일반적으로 페이지 수준 잠금에 대해 걱정할 필요는 없지만 완전성을 위해 여기에 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="87509ac7479eedd6c62071274770036abf56ee4c" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row.</source>
          <target state="translated">테이블 수준 잠금 외에도 행 수준 잠금이 있으며 PostgreSQL에서 자동으로 사용되는 컨텍스트와 함께 아래에 나열됩니다. 전체 행 수준 잠금 충돌 표는 &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;표 13.3&lt;/a&gt; 을 참조하십시오 . 트랜잭션은 다른 서브 트랜잭션에서도 동일한 행에서 충돌 잠금을 보유 할 수 있습니다. 그러나 그 이외의 두 트랜잭션은 동일한 행에서 충돌하는 잠금을 보유 할 수 없습니다. 행 수준 잠금은 데이터 쿼리에 영향을 미치지 않습니다. 같은 행에 대한 &lt;em&gt;기록기 및 로커&lt;/em&gt; 만 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="af43dbc6cfa4c0067d413cdf9c6cdab394d34e58" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row. Row-level locks are released at transaction end or during savepoint rollback, just like table-level locks.</source>
          <target state="translated">테이블 수준 잠금 외에도 PostgreSQL에서 자동으로 사용되는 컨텍스트와 함께 아래와 같이 나열되는 행 수준 잠금이 있습니다. 행 수준 잠금 충돌에 대한 전체 표는 &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;표 13.3&lt;/a&gt; 을 참조하십시오 . 트랜잭션은 다른 서브 트랜잭션에서도 동일한 행에 충돌 잠금을 보유 할 수 있습니다. 그러나 그 외에는 두 개의 트랜잭션이 동일한 행에서 충돌하는 잠금을 유지할 수 없습니다. 행 수준 잠금은 데이터 쿼리에 영향을주지 않습니다. 그들은 같은 행에 &lt;em&gt;작가와 사물함&lt;/em&gt; 만 차단합니다 . 행 수준 잠금은 테이블 수준 잠금과 마찬가지로 트랜잭션 종료 또는 저장 점 롤백 중에 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="eefa082a90a01551ee9f7be83fe0ecef6e330ce1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">앞에서 언급 한 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 외에도 PostgreSQL은 수동으로 편집 한 두 개의 다른 구성 파일을 사용하여 클라이언트 인증을 제어합니다 (사용 방법은 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 에서 설명합니다 ). 기본적으로 세 가지 구성 파일은 모두 데이터베이스 클러스터의 데이터 디렉토리에 저장됩니다. 이 섹션에서 설명하는 매개 변수를 사용하면 구성 파일을 다른 곳에 배치 할 수 있습니다. 이렇게하면 관리가 쉬워 질 수 있습니다. 특히 구성 파일을 별도로 보관할 때 구성 파일을 올바르게 백업하는 것이 더 쉬운 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="c048077d9e3551a271c60d45220784829e1b676a" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">이미 언급 한 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 외에도 PostgreSQL은 클라이언트 인증을 제어하는 ​​두 개의 다른 수동 편집 구성 파일을 사용합니다 (사용 방법은 &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 에서 설명합니다 ). 기본적으로 세 가지 구성 파일은 모두 데이터베이스 클러스터의 데이터 디렉토리에 저장됩니다. 이 섹션에서 설명하는 매개 변수를 사용하면 구성 파일을 다른 곳에 배치 할 수 있습니다. (그렇게하면 관리가 쉬워집니다. 특히 구성 파일이 별도로 보관 될 때 적절하게 백업되었는지 확인하는 것이 더 쉽습니다.)</target>
        </trans-unit>
        <trans-unit id="06a5b24df3b5e27969bb36917a3a17ae8bb1189b" translate="yes" xml:space="preserve">
          <source>In addition to the SQL-standard &lt;a href=&quot;ddl-priv&quot;&gt;privilege system&lt;/a&gt; available through &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;, tables can have &lt;em&gt;row security policies&lt;/em&gt; that restrict, on a per-user basis, which rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as &lt;em&gt;Row-Level Security&lt;/em&gt;. By default, tables do not have any policies, so that if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating.</source>
          <target state="translated">&lt;a href=&quot;sql-grant&quot;&gt;GRANT를&lt;/a&gt; 통해 사용할 수 있는 SQL 표준 &lt;a href=&quot;ddl-priv&quot;&gt;권한 시스템&lt;/a&gt; 외에도 테이블에는 사용자별로 기준 쿼리를 반환하거나 데이터 수정 명령으로 삽입, 업데이트 또는 삭제할 수있는 &lt;em&gt;행 보안 정책&lt;/em&gt; 이 있습니다. 이 기능은 &lt;em&gt;행 수준 보안&lt;/em&gt; 이라고도 합니다. 기본적으로 테이블에는 정책이 없으므로 사용자가 SQL 권한 시스템에 따라 테이블에 대한 액세스 권한을 가지고 있으면 테이블 내의 모든 행을 쿼리하거나 업데이트 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d446f6389cb4793dfefdac41ed8ee8243d8cf0f3" translate="yes" xml:space="preserve">
          <source>In addition to the above operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for type &lt;code&gt;cube&lt;/code&gt;. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column. Otherwise, this ordering is not of much practical use.</source>
          <target state="translated">위의 연산자 외에도 &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1에&lt;/a&gt; 표시된 일반적인 비교 연산자를 &lt;code&gt;cube&lt;/code&gt; 유형에 사용할 수 있습니다 . 이러한 연산자는 먼저 첫 번째 좌표를 비교하고, 두 좌표가 같으면 두 번째 좌표 등을 비교합니다. 이들은 주로 &lt;code&gt;cube&lt;/code&gt; 에 대한 b- 트리 인덱스 연산자 클래스를 지원하기 위해 존재 합니다. 예를 들어 UNIQUE 제약 조건을 원하는 경우 유용 할 수 있습니다. &lt;code&gt;cube&lt;/code&gt; 열입니다. 그렇지 않으면이 순서는 그다지 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a9f075e58ee1768924e20835361c077d43e9c97" translate="yes" xml:space="preserve">
          <source>In addition to the above operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for type &lt;code&gt;seg&lt;/code&gt;. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="translated">위의 연산자 외에도 &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1에&lt;/a&gt; 표시된 일반적인 비교 연산자를 &lt;code&gt;seg&lt;/code&gt; 유형에 사용할 수 있습니다 . 이 연산자는 먼저 (a)와 (c)를 비교하고 이들이 같으면 (b)와 (d)를 비교합니다. 그 결과 대부분의 경우 상당히 좋은 정렬이 이루어지며,이 유형에 ORDER BY를 사용하려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="58a68bf9280d646b1a85ebb074d2b6ecfecda3df" translate="yes" xml:space="preserve">
          <source>In addition to the format specifiers described above, the special sequence &lt;code&gt;%%&lt;/code&gt; may be used to output a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">위에서 설명한 형식 지정자 외에도 특수 시퀀스 &lt;code&gt;%%&lt;/code&gt; 를 사용하여 리터럴 &lt;code&gt;%&lt;/code&gt; 문자 를 출력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bfea922b7478af1fb30846a7ffdd145169e7fe7" translate="yes" xml:space="preserve">
          <source>In addition to the functions listed in this section, there are a number of functions related to the statistics system that also provide system information. See &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;Section 27.2.2&lt;/a&gt; for more information.</source>
          <target state="translated">이 섹션에 나열된 기능 외에도 시스템 정보를 제공하는 통계 시스템과 관련된 여러 기능이 있습니다. 자세한 정보는 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;27.2.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2dc53d9aa025a55feab0c728607a475dd6480573" translate="yes" xml:space="preserve">
          <source>In addition to the generic lookup mechanisms, there is a special convention that &lt;code&gt;PGNSP&lt;/code&gt; is replaced by the OID of the &lt;code&gt;pg_catalog&lt;/code&gt; schema, and &lt;code&gt;PGUID&lt;/code&gt; is replaced by the OID of the bootstrap superuser role. These usages are somewhat historical but so far there hasn't been a need to generalize them.</source>
          <target state="translated">일반 조회 메커니즘 외에도 &lt;code&gt;PGNSP&lt;/code&gt; 가 &lt;code&gt;pg_catalog&lt;/code&gt; 스키마 의 OID로 대체되고 &lt;code&gt;PGUID&lt;/code&gt; 가 부트 스트랩 수퍼 유저 역할 의 OID로 대체 된다는 특별한 규칙이 있습니다. 이러한 사용법은 다소 역사적이지만 지금까지 일반화 할 필요는 없었습니다.</target>
        </trans-unit>
        <trans-unit id="671caebf932d9cdddfa02cea4a21319996df3fc1" translate="yes" xml:space="preserve">
          <source>In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available.</source>
          <target state="translated">위에서 설명한 주요 구문 외에도 몇 가지 특수한 형식과 기타 구문 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfdcb8c233fbe99bb0dea34235cb119f257b9a78" translate="yes" xml:space="preserve">
          <source>In addition to the method-specific options listed below, there is one method-independent authentication option &lt;code&gt;clientcert&lt;/code&gt;, which can be specified in any &lt;code&gt;hostssl&lt;/code&gt; record. This option can be set to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. Both options require the client to present a valid (trusted) SSL certificate, while &lt;code&gt;verify-full&lt;/code&gt; additionally enforces that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the username or an applicable mapping. This behavior is similar to the &lt;code&gt;cert&lt;/code&gt; authentication method (see &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt;) but enables pairing the verification of client certificates with any authentication method that supports &lt;code&gt;hostssl&lt;/code&gt; entries.</source>
          <target state="translated">아래에 나열된 방법 별 옵션 외에도 방법 독립적 인 인증 옵션 &lt;code&gt;clientcert&lt;/code&gt; 가 있으며 , 이는 &lt;code&gt;hostssl&lt;/code&gt; 레코드에 지정할 수 있습니다 . 이 옵션은 &lt;code&gt;verify-ca&lt;/code&gt; 또는 &lt;code&gt;verify-full&lt;/code&gt; 로 설정할 수 있습니다 . 두 옵션 모두 클라이언트가 유효한 (신뢰할 수있는) SSL 인증서를 제시해야하지만 &lt;code&gt;verify-full&lt;/code&gt; 은 인증서 의 &lt;code&gt;cn&lt;/code&gt; (공통 이름)이 사용자 이름 또는 적용 가능한 매핑과 일치하도록 추가로 강제합니다 . 이 동작은 &lt;code&gt;cert&lt;/code&gt; 인증 방법 ( &lt;a href=&quot;auth-cert&quot;&gt;20.12 절&lt;/a&gt; 참조 )과 유사 하지만 클라이언트 인증서 확인을 &lt;code&gt;hostssl&lt;/code&gt; 을 지원하는 인증 방법과 쌍을 이룰 수 있습니다. 항목.</target>
        </trans-unit>
        <trans-unit id="ddf91010c34fa3b26374dd73b3df519e9da0fd2a" translate="yes" xml:space="preserve">
          <source>In addition to the operators shown in the table, the ordinary B-tree comparison operators (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, etc) are defined for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">표에 표시된 연산자 외에도 일반 B- 트리 비교 연산자 ( &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; 등)는 &lt;code&gt;tsvector&lt;/code&gt; 및 &lt;code&gt;tsquery&lt;/code&gt; 유형에 대해 정의됩니다 . 텍스트 검색에는 유용하지 않지만 예를 들어 이러한 유형의 열에 고유 인덱스를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c46db92025ad200f49ee2517827b67ca69ce01" translate="yes" xml:space="preserve">
          <source>In addition to the socket file itself, which is named &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; where &lt;code&gt;nnnn&lt;/code&gt; is the server's port number, an ordinary file named &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; will be created in each of the &lt;code&gt;unix_socket_directories&lt;/code&gt; directories. Neither file should ever be removed manually.</source>
          <target state="translated">소켓 파일 자체 ( &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; )( 여기서 &lt;code&gt;nnnn&lt;/code&gt; 은 서버의 포트 번호 &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; 이라는 일반 파일 이 각 &lt;code&gt;unix_socket_directories&lt;/code&gt; 디렉토리에 작성됩니다. 파일을 수동으로 제거해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f961899526c4ec4b91a471972a05e3809476d8c4" translate="yes" xml:space="preserve">
          <source>In addition to the system catalogs, PostgreSQL provides a number of built-in views. Some system views provide convenient access to some commonly used queries on the system catalogs. Other views provide access to internal server state.</source>
          <target state="translated">시스템 카탈로그 이외에도 PostgreSQL은 여러 내장 뷰를 제공합니다. 일부 시스템 뷰는 시스템 카탈로그에서 일반적으로 사용되는 일부 쿼리에 편리하게 액세스 할 수 있습니다. 다른보기는 내부 서버 상태에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e99de7dbe2b503398057fb045bf3c995d4ba6e3" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications of the form &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;DST&lt;/code&gt;, where &lt;code&gt;STD&lt;/code&gt; is a zone abbreviation, &lt;code&gt;offset&lt;/code&gt; is a numeric offset in hours west from UTC, and &lt;code&gt;DST&lt;/code&gt; is an optional daylight-savings zone abbreviation, assumed to stand for one hour ahead of the given offset. For example, if &lt;code&gt;EST5EDT&lt;/code&gt; were not already a recognized zone name, it would be accepted and would be functionally equivalent to United States East Coast time. In this syntax, a zone abbreviation can be a string of letters, or an arbitrary string surrounded by angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;). When a daylight-savings zone abbreviation is present, it is assumed to be used according to the same daylight-savings transition rules used in the IANA time zone database's &lt;code&gt;posixrules&lt;/code&gt; entry. In a standard PostgreSQL installation, &lt;code&gt;posixrules&lt;/code&gt; is the same as &lt;code&gt;US/Eastern&lt;/code&gt;, so that POSIX-style time zone specifications follow USA daylight-savings rules. If needed, you can adjust this behavior by replacing the &lt;code&gt;posixrules&lt;/code&gt; file.</source>
          <target state="translated">표준 시간대 이름과 약어 외에도 PostgreSQL은 &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 또는 &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;DST&lt;/code&gt; 형식의 POSIX 스타일 시간대 사양을 허용합니다 . 여기서 &lt;code&gt;STD&lt;/code&gt; 는 영역 약어이고 &lt;code&gt;offset&lt;/code&gt; 은 UTC에서 서쪽으로 몇 시간 단위로 숫자 오프셋이며 &lt;code&gt;DST&lt;/code&gt; 는 지정된 오프셋보다 1 시간 앞서있는 것으로 가정되는 일광 절약 영역 약어 (선택 사항). 예를 들어, &lt;code&gt;EST5EDT&lt;/code&gt; 가 아직 인식되는 영역 이름이 아닌 경우 미국 동부 해안 시간과 동일하게 적용됩니다. 이 구문에서 영역 약어는 문자 문자열이거나 꺾쇠 괄호 ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ). 일광 절약 영역 약어가 있으면 IANA 시간대 데이터베이스의 &lt;code&gt;posixrules&lt;/code&gt; 항목에 사용 된 것과 동일한 일광 절약 변환 규칙에 따라 사용되는 것으로 가정합니다 . 표준 PostgreSQL 설치에서 &lt;code&gt;posixrules&lt;/code&gt; 는 &lt;code&gt;US/Eastern&lt;/code&gt; 과 동일 하므로 POSIX 스타일 시간대 사양은 미국 일광 절약 규칙을 따릅니다. 필요한 경우 &lt;code&gt;posixrules&lt;/code&gt; 파일 을 교체하여이 동작을 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fea3b58443a344cc0a50c8d3b3c320b181f8be81" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications, as described in &lt;a href=&quot;datetime-posix-timezone-specs&quot;&gt;Section B.5&lt;/a&gt;. This option is not normally preferable to using a named time zone, but it may be necessary if no suitable IANA time zone entry is available.</source>
          <target state="translated">시간대 이름 및 약어 외에도 PostgreSQL은 &lt;a href=&quot;datetime-posix-timezone-specs&quot;&gt;섹션 B.5에&lt;/a&gt; 설명 된대로 POSIX 스타일 시간대 사양을 허용 합니다. 이 옵션은 일반적으로 명명 된 시간대를 사용하는 것보다 바람직하지 않지만 적합한 IANA 시간대 항목을 사용할 수없는 경우 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5639f9b8e3c76507298cdef9442456212dc91a3a" translate="yes" xml:space="preserve">
          <source>In addition to the typical B-tree search operators, &lt;code&gt;btree_gist&lt;/code&gt; also provides index support for &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (&amp;ldquo;not equals&amp;rdquo;). This may be useful in combination with an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt;, as described below.</source>
          <target state="translated">일반적인 B- 트리 검색 연산자 &lt;code&gt;btree_gist&lt;/code&gt; 는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에 대한 인덱스 지원 (&amp;ldquo;같지 않음&amp;rdquo;) 도 제공합니다 . 아래 설명과 같이 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;제외 제약 조건&lt;/a&gt; 과 함께 사용하면 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7456acfa95fcaf383cf25fda8119cc53ab8322a" translate="yes" xml:space="preserve">
          <source>In addition to the usual (&lt;em&gt;tight&lt;/em&gt;) RE syntax, in which all characters are significant, there is an &lt;em&gt;expanded&lt;/em&gt; syntax, available by specifying the embedded &lt;code&gt;x&lt;/code&gt; option. In the expanded syntax, white-space characters in the RE are ignored, as are all characters between a &lt;code&gt;#&lt;/code&gt; and the following newline (or the end of the RE). This permits paragraphing and commenting a complex RE. There are three exceptions to that basic rule:</source>
          <target state="translated">모든 문자가 중요한 일반적인 ( &lt;em&gt;긴급한&lt;/em&gt; ) RE 구문 외에도 Embedded &lt;code&gt;x&lt;/code&gt; 옵션 을 지정하여 사용할 수 있는 &lt;em&gt;확장 된&lt;/em&gt; 구문이 있습니다 . 확장 구문에서 &lt;code&gt;#&lt;/code&gt; 과 다음 줄 바꾸기 (또는 RE의 끝) 사이의 모든 문자와 마찬가지로 RE의 공백 문자는 무시됩니다 . 이를 통해 복잡한 RE를 단락하고 주석을 달 수 있습니다. 해당 기본 규칙에는 세 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da522f31f6ebf1b8a6e0efd3ead6600864945861" translate="yes" xml:space="preserve">
          <source>In addition to these facilities borrowed from &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; supports these pattern-matching metacharacters borrowed from POSIX regular expressions:</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 에서 빌린 이러한 기능 외에도 &lt;code&gt;SIMILAR TO&lt;/code&gt; 는 POSIX 정규식에서 빌린 다음 패턴 일치 메타 문자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d5ad168deb41cb8cd3104e11c297f4193822a79b" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined general-purpose or statistical aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as non-window aggregates and return a single row for the entire set.</source>
          <target state="translated">이러한 기능 외에도 모든 내장 또는 사용자 정의 범용 또는 통계 집계 (즉, 순서 집합 또는 가정 집합 집합이 아님)를 창 함수로 사용할 수 있습니다. 내장 집계 목록 은 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.20&lt;/a&gt; 을 참조하십시오 . 집계 함수는 &lt;code&gt;OVER&lt;/code&gt; 절이 호출을 따르는 경우에만 창 함수로 작동합니다 . 그렇지 않으면 비 창구 집계로 작동하고 전체 세트에 대해 단일 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac449e0956beab252b7444b739cfec2b77010587" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined ordinary aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as plain aggregates and return a single row for the entire set.</source>
          <target state="translated">이러한 함수 외에도 내장 또는 사용자 정의 일반 집계 (즉, 정렬 된 집합 또는 가상 집합 집계가 아님)를 창 함수로 사용할 수 있습니다. 내장 집계 목록 은 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.21&lt;/a&gt; 을 참조하십시오 . 집계 함수는 &lt;code&gt;OVER&lt;/code&gt; 절이 호출 다음에 올 때만 창 함수로 작동합니다 . 그렇지 않으면 일반 집계로 작동하고 전체 집합에 대해 단일 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b254c4c7b10faf7e76791fc77c4b40ffb55a623" translate="yes" xml:space="preserve">
          <source>In addition to these functions, the SQL &lt;code&gt;OVERLAPS&lt;/code&gt; operator is supported:</source>
          <target state="translated">이러한 기능 외에도 SQL &lt;code&gt;OVERLAPS&lt;/code&gt; 연산자가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8ce6df37789f3f1d085846c8faae3d98a71b95bb" translate="yes" xml:space="preserve">
          <source>In addition to these specialized operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">이러한 특수 연산자 외에도 &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;표 9.1에&lt;/a&gt; 표시된 일반적인 비교 연산자를 &lt;code&gt;tsvector&lt;/code&gt; 및 &lt;code&gt;tsquery&lt;/code&gt; 유형에 사용할 수 있습니다 . 이들은 텍스트 검색에 그다지 유용하지 않지만 예를 들어 이러한 유형의 열에 고유 인덱스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918debfa135a3ee3b32c08e005bfe3898a987217" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">이 목록 외에도 표현식으로 분류 할 수 있지만 일반적인 구문 규칙을 따르지 않는 많은 구성이 있습니다. 이것들은 일반적으로 함수 또는 연산자의 의미를 가지며 &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장의&lt;/a&gt; 적절한 위치에 설명되어 있습니다. 예는 &lt;code&gt;IS NULL&lt;/code&gt; 절입니다.</target>
        </trans-unit>
        <trans-unit id="81a1f6a58eced1ed99e15fcd136cfd9bbcd242dd" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">이 목록 외에도 식으로 분류 할 수 있지만 일반적인 구문 규칙을 따르지 않는 여러 구성이 있습니다. 이들은 일반적으로 함수 또는 연산자의 의미를 가지며 &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;9 장의&lt;/a&gt; 적절한 위치에 설명되어 있습니다. 예는 &lt;code&gt;IS NULL&lt;/code&gt; 절입니다.</target>
        </trans-unit>
        <trans-unit id="1eea807026cd270d625f43d7ed3f99bcbf28a0f1" translate="yes" xml:space="preserve">
          <source>In addition, B-tree and hash indexes can be created for table columns of range types. For these index types, basically the only useful range operation is equality. There is a B-tree sort ordering defined for range values, with corresponding &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators, but the ordering is rather arbitrary and not usually useful in the real world. Range types' B-tree and hash support is primarily meant to allow sorting and hashing internally in queries, rather than creation of actual indexes.</source>
          <target state="translated">또한 범위 유형의 테이블 열에 대해 B- 트리 및 해시 인덱스를 만들 수 있습니다. 이러한 인덱스 유형의 경우 기본적으로 유일하게 유용한 범위 연산은 평등입니다. 해당 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자를 사용 하여 범위 값에 대해 정의 된 B- 트리 정렬 순서가 있지만 순서는 다소 임의적이며 일반적으로 현실에서는 유용하지 않습니다. 범위 유형의 B- 트리 및 해시 지원은 기본적으로 실제 인덱스를 작성하지 않고 쿼리에서 내부적으로 정렬 및 해싱을 허용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec168afc08cf14d67db79d5a556441966649b178" translate="yes" xml:space="preserve">
          <source>In addition, GIN must have a way to sort the key values stored in the index. The operator class can define the sort ordering by specifying a comparison method:</source>
          <target state="translated">또한 GIN에는 인덱스에 저장된 키 값을 정렬 할 수있는 방법이 있어야합니다. 연산자 클래스는 비교 방법을 지정하여 정렬 순서를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f602065328e166c6745869bc0a8f779ad09a07b" translate="yes" xml:space="preserve">
          <source>In addition, PostgreSQL provides the &lt;code&gt;text&lt;/code&gt; type, which stores strings of any length. Although the type &lt;code&gt;text&lt;/code&gt; is not in the SQL standard, several other SQL database management systems have it as well.</source>
          <target state="translated">또한 PostgreSQL은 모든 길이의 문자열을 저장 하는 &lt;code&gt;text&lt;/code&gt; 유형을 제공합니다 . 유형 &lt;code&gt;text&lt;/code&gt; 는 SQL 표준이 아니지만 다른 여러 SQL 데이터베이스 관리 시스템에도 있습니다.</target>
        </trans-unit>
        <trans-unit id="17853e1fa32c480ecb510d4ac68c8ac2c772dace" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;code&gt;cube&lt;/code&gt; GiST index can be used to find nearest neighbors using the metric operators &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; in &lt;code&gt;ORDER BY&lt;/code&gt; clauses. For example, the nearest neighbor of the 3-D point (0.5, 0.5, 0.5) could be found efficiently with:</source>
          <target state="translated">또한 &lt;code&gt;cube&lt;/code&gt; GiST 인덱스를 사용하여 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서 메트릭 연산자 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 을 사용하여 가장 가까운 이웃을 찾을 수 있습니다 . 예를 들어, 3D 점 (0.5, 0.5, 0.5)의 가장 가까운 이웃은 다음을 통해 효율적으로 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5ace0daf0d94ba630977ad9ab486e9b148c9ae" translate="yes" xml:space="preserve">
          <source>In addition, any range type that is meant to be used with GiST or SP-GiST indexes should define a subtype difference, or &lt;code&gt;subtype_diff&lt;/code&gt;, function. (The index will still work without &lt;code&gt;subtype_diff&lt;/code&gt;, but it is likely to be considerably less efficient than if a difference function is provided.) The subtype difference function takes two input values of the subtype, and returns their difference (i.e., &lt;code&gt;X&lt;/code&gt; minus &lt;code&gt;Y&lt;/code&gt;) represented as a &lt;code&gt;float8&lt;/code&gt; value. In our example above, the function &lt;code&gt;float8mi&lt;/code&gt; that underlies the regular &lt;code&gt;float8&lt;/code&gt; minus operator can be used; but for any other subtype, some type conversion would be necessary. Some creative thought about how to represent differences as numbers might be needed, too. To the greatest extent possible, the &lt;code&gt;subtype_diff&lt;/code&gt; function should agree with the sort ordering implied by the selected operator class and collation; that is, its result should be positive whenever its first argument is greater than its second according to the sort ordering.</source>
          <target state="translated">또한 GiST 또는 SP-GiST 인덱스와 함께 사용되는 모든 범위 유형은 하위 유형 차이 또는 &lt;code&gt;subtype_diff&lt;/code&gt; 함수를 정의해야 합니다. 인덱스는 여전히 &lt;code&gt;subtype_diff&lt;/code&gt; 없이 작동 하지만 차이 함수가 제공되는 경우보다 효율이 떨어질 수 있습니다. 하위 유형 차이 함수는 하위 유형의 두 입력 값을 가져 와서 그 차이 (예 : &lt;code&gt;X&lt;/code&gt; 빼기 &lt;code&gt;Y&lt;/code&gt; )를 리턴합니다. &lt;code&gt;float8&lt;/code&gt; 값 으로 표시됩니다 . 위의 예 에서 일반 &lt;code&gt;float8&lt;/code&gt; 의 기본이되는 &lt;code&gt;float8mi&lt;/code&gt; 함수빼기 연산자를 사용할 수 있습니다. 그러나 다른 하위 유형의 경우 일부 유형 변환이 필요합니다. 숫자가 필요할 때 차이를 표현하는 방법에 대한 창의적인 생각도 있습니다. &lt;code&gt;subtype_diff&lt;/code&gt; 함수는 가능한 한 선택된 연산자 클래스 및 데이터 정렬에 의해 암시 된 정렬 순서와 일치해야합니다. 즉, 정렬 순서에 따라 첫 번째 인수가 두 번째 인수보다 클 때마다 결과가 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f89a62ed614652316ac7f29133e1961a27612ba6" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Casting an integer to &lt;code&gt;bit(n)&lt;/code&gt; copies the rightmost &lt;code&gt;n&lt;/code&gt; bits. Casting an integer to a bit string width wider than the integer itself will sign-extend on the left. Some examples:</source>
          <target state="translated">또한 &lt;code&gt;bit&lt;/code&gt; 형식으로 정수 값을 캐스팅 할 수 있습니다 . 정수를 &lt;code&gt;bit(n)&lt;/code&gt; 캐스팅하면 가장 오른쪽에있는 &lt;code&gt;n&lt;/code&gt; 비트가 복사 됩니다. 정수를 정수 자체보다 넓은 비트 문자열 너비로 캐스팅하면 왼쪽에서 부호 확장됩니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="64cf011fc0c858e7c59c2382a3c5f7cd4046f0f4" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Some examples:</source>
          <target state="translated">또한 정수형 값을 &lt;code&gt;bit&lt;/code&gt; 유형으로 캐스트 할 수 있습니다 . 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="326abf040e9ce0b0f36784412502b6466458ab9f" translate="yes" xml:space="preserve">
          <source>In addition, the following functions are available to produce analogous mappings of entire schemas or the entire current database:</source>
          <target state="translated">또한 다음 함수를 사용하여 전체 스키마 또는 전체 현재 데이터베이스의 유사한 매핑을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63461f5526d594ea86f45b63caca8ffcfa146455" translate="yes" xml:space="preserve">
          <source>In addition, the system must not be running in single-user mode. Since the entire database system is running in single process in this situation, no background workers will be available.</source>
          <target state="translated">또한 시스템이 단일 사용자 모드에서 실행되어서는 안됩니다. 이 상황에서 전체 데이터베이스 시스템이 단일 프로세스로 실행되므로 백그라운드 작업자가 사용 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="860432a001dab9d2b568ed0f1f81316664226bda" translate="yes" xml:space="preserve">
          <source>In addition, the system view &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; can be used to view and change session-local values:</source>
          <target state="translated">또한 시스템 뷰 &lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt; 를 사용하여 세션 로컬 값을보고 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f9e194dfe6bf7349c8ee21bf8580964a36a952" translate="yes" xml:space="preserve">
          <source>In addition, triggers may be defined to fire for &lt;code&gt;TRUNCATE&lt;/code&gt;, though only &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 에만 &lt;code&gt;TRUNCATE&lt;/code&gt; 에 대해 트리거하도록 트리거를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4414e8f828cfe6654891bf2913265775446349f" translate="yes" xml:space="preserve">
          <source>In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The &lt;code&gt;ON DELETE&lt;/code&gt; clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the &lt;code&gt;ON UPDATE&lt;/code&gt; clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the &lt;code&gt;NO ACTION&lt;/code&gt; check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:</source>
          <target state="translated">또한 참조 된 열의 데이터가 변경되면이 테이블 열의 데이터에 대해 특정 작업이 수행됩니다. &lt;code&gt;ON DELETE&lt;/code&gt; 절은 참조 테이블의 참조 행이 삭제 될 때 수행 할 작업을 지정합니다. 마찬가지로 &lt;code&gt;ON UPDATE&lt;/code&gt; 절은 참조 된 테이블의 참조 된 열이 새 값으로 업데이트 될 때 수행 할 조치를 지정합니다. 행이 업데이트되었지만 참조 된 열이 실제로 변경되지 않은 경우 아무 작업도 수행되지 않습니다. 제한 조건이 연기 가능하다고 선언 되더라도 &lt;code&gt;NO ACTION&lt;/code&gt; 점검 이외의 참조 조치 는 지연 될 수 없습니다. 각 절에 대해 가능한 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b40467991cf35c44406fccb1f30c153b6ab6d3c" translate="yes" xml:space="preserve">
          <source>In addition, you can define your own range types; see &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more information.</source>
          <target state="translated">또한 고유 한 범위 유형을 정의 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2973b0fbaf7ec1930d4939e2d5982623781db68" translate="yes" xml:space="preserve">
          <source>In addition, you can find rows where the array has all values equal to 10000 with:</source>
          <target state="translated">또한 다음과 함께 배열의 모든 값이 10000 인 행을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f950ca6f038e5a1c55d020b4e0e3f34ce9c10d7" translate="yes" xml:space="preserve">
          <source>In all binary operations on differently-dimensioned cubes, I assume the lower-dimensional one to be a Cartesian projection, i. e., having zeroes in place of coordinates omitted in the string representation. The above examples are equivalent to:</source>
          <target state="translated">다른 차원의 큐브에 대한 모든 이진 연산에서, 저 차원 차원은 데카르트 투영이라고 가정합니다. 즉, 문자열 표현에서 생략 된 좌표 대신 0이 있습니다. 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1f9a66372442ec0201db0ed9f98b148d01d359a" translate="yes" xml:space="preserve">
          <source>In all but the simplest applications, there are various combinations of indexes that might be useful, and the database developer must make trade-offs to decide which indexes to provide. Sometimes multicolumn indexes are best, but sometimes it's better to create separate indexes and rely on the index-combination feature. For example, if your workload includes a mix of queries that sometimes involve only column &lt;code&gt;x&lt;/code&gt;, sometimes only column &lt;code&gt;y&lt;/code&gt;, and sometimes both columns, you might choose to create two separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, relying on index combination to process the queries that use both columns. You could also create a multicolumn index on &lt;code&gt;(x, y)&lt;/code&gt;. This index would typically be more efficient than index combination for queries involving both columns, but as discussed in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;, it would be almost useless for queries involving only &lt;code&gt;y&lt;/code&gt;, so it should not be the only index. A combination of the multicolumn index and a separate index on &lt;code&gt;y&lt;/code&gt; would serve reasonably well. For queries involving only &lt;code&gt;x&lt;/code&gt;, the multicolumn index could be used, though it would be larger and hence slower than an index on &lt;code&gt;x&lt;/code&gt; alone. The last alternative is to create all three indexes, but this is probably only reasonable if the table is searched much more often than it is updated and all three types of query are common. If one of the types of query is much less common than the others, you'd probably settle for creating just the two indexes that best match the common types.</source>
          <target state="translated">가장 단순한 응용 프로그램을 제외하고는 유용 할 수있는 다양한 색인 조합이 있으며 데이터베이스 개발자는 제공 할 색인을 결정하기 위해 절충해야합니다. 여러 열 인덱스가 가장 좋은 경우도 있지만 별도의 인덱스를 만들고 인덱스 조합 기능을 사용하는 것이 좋습니다. 예를 들어, 워크로드에 때때로 &lt;code&gt;x&lt;/code&gt; , 때로는 &lt;code&gt;y&lt;/code&gt; , 때로는 두 열만 포함하는 여러 쿼리가 포함 된 경우 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 에 두 개의 개별 인덱스를 작성하도록 선택 하고 인덱스 조합에 따라 두 열을 모두 사용하십시오. &lt;code&gt;(x, y)&lt;/code&gt; 에 여러 열 인덱스를 만들 수도 있습니다.. 이 인덱스는 일반적으로 두 열을 모두 포함하는 쿼리에 대해 인덱스 조합보다 효율적이지만 &lt;a href=&quot;indexes-multicolumn&quot;&gt;11.3 절&lt;/a&gt; 에서 논의한 것처럼 &lt;code&gt;y&lt;/code&gt; 만 포함하는 쿼리에는 거의 쓸모 가 없으므로 유일한 인덱스가 아니어야합니다. 다중 열 인덱스와 &lt;code&gt;y&lt;/code&gt; 의 개별 인덱스의 조합은 합리적으로 잘 작동합니다. &lt;code&gt;x&lt;/code&gt; 만 포함 된 쿼리의 경우 다중 열 인덱스를 사용할 수 있지만 &lt;code&gt;x&lt;/code&gt; 의 인덱스보다 크거나 느릴 수 있습니다.혼자. 마지막 대안은 세 개의 인덱스를 모두 작성하는 것이지만 테이블을 업데이트하는 것보다 훨씬 자주 검색하고 세 가지 유형의 쿼리가 공통 인 경우에만 적합합니다. 쿼리 유형 중 하나가 다른 유형보다 훨씬 덜 일반적인 경우 공통 유형과 가장 일치하는 두 개의 인덱스 만 작성하면됩니다.</target>
        </trans-unit>
        <trans-unit id="56df2ff3801249dc12f58c24112c401131ecca16" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_depend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">모든 경우에 &lt;code&gt;pg_depend&lt;/code&gt; 항목은 종속 객체를 삭제하지 않고 참조 된 객체를 삭제할 수 없음을 나타냅니다. 그러나, 식별 여러 subflavors있다 &lt;code&gt;deptype&lt;/code&gt; 는 :</target>
        </trans-unit>
        <trans-unit id="05533c0a7856fcfbbc14bb309ca83a1575bf0034" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_shdepend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">모든 경우에 &lt;code&gt;pg_shdepend&lt;/code&gt; 항목은 종속 객체를 삭제하지 않고 참조 된 객체를 삭제할 수 없음을 나타냅니다. 그러나, 식별 여러 subflavors있다 &lt;code&gt;deptype&lt;/code&gt; 는 :</target>
        </trans-unit>
        <trans-unit id="dbd9abe4557bc81e394c2c9fabde17d6899807f9" translate="yes" xml:space="preserve">
          <source>In all cases, the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node will have exactly one child plan, which is the portion of the plan that will be executed in parallel. If the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node is at the very top of the plan tree, then the entire query will execute in parallel. If it is somewhere else in the plan tree, then only the portion of the plan below it will run in parallel. In the example above, the query accesses only one table, so there is only one plan node other than the &lt;code&gt;Gather&lt;/code&gt; node itself; since that plan node is a child of the &lt;code&gt;Gather&lt;/code&gt; node, it will run in parallel.</source>
          <target state="translated">모든 경우에 &lt;code&gt;Gather&lt;/code&gt; 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 노드에는 정확히 하나의 하위 계획이 있으며 이는 계획의 일부로 병렬로 실행됩니다. &lt;code&gt;Gather&lt;/code&gt; 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 노드가 계획 트리의 맨 위에 있으면 전체 쿼리가 병렬로 실행됩니다. 계획 트리의 다른 곳에 있으면 계획의 아래 부분 만 병렬로 실행됩니다. 위의 예에서 쿼리는 하나의 테이블에만 액세스하므로 &lt;code&gt;Gather&lt;/code&gt; 노드 자체 이외의 계획 노드는 하나만 있습니다. 해당 계획 노드는 &lt;code&gt;Gather&lt;/code&gt; 노드 의 하위 노드이므로 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cf1068a339ca5023c2d3ccdb75130df4a1abc8" translate="yes" xml:space="preserve">
          <source>In all cases, the UTC offset associated with a timestamp can be specified explicitly, using either a numeric UTC offset or a time zone abbreviation that corresponds to a fixed UTC offset. The rule just given applies only when it is necessary to infer a UTC offset for a time zone in which the offset varies.</source>
          <target state="translated">모든 경우에, 타임 스탬프와 연관된 UTC 오프셋은 숫자 UTC 오프셋 또는 고정 UTC 오프셋에 해당하는 시간대 약어를 사용하여 명시 적으로 지정할 수 있습니다. 방금 주어진 규칙은 오프셋이 다른 시간대에 대해 UTC 오프셋을 유추해야하는 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="14ea16f2c03b44cd074521f1c44532d0da377b9a" translate="yes" xml:space="preserve">
          <source>In all cases, timezone names and abbreviations are recognized case-insensitively. (This is a change from PostgreSQL versions prior to 8.2, which were case-sensitive in some contexts but not others.)</source>
          <target state="translated">모든 경우에 시간대 이름과 약어는 대소 문자를 구분하지 않고 인식됩니다. (이것은 8.2 이전의 PostgreSQL 버전에서 변경된 것으로 일부 상황에서는 대소 문자를 구분하지만 다른 상황에서는 그렇지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e488767cd28888258245f00283eb8b0744ce50a3" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">에서 &lt;code&gt;ADD FUNCTION&lt;/code&gt; 절 피연산자 데이터 타입 (들)이 기능은 지원하고자하는 함수의 입력 데이터 타입 (들)와 다를 경우. B- 트리 비교 함수 및 해시 함수의 경우 함수의 입력 데이터 형식이 항상 올바른 형식이므로 &lt;code&gt;op_type&lt;/code&gt; 을 지정할 필요가 없습니다 . Gi-ST, SP-GiST 및 GIN 연산자 클래스의 B- 트리 정렬 지원 함수 및 모든 함수의 경우 함수와 함께 사용할 피연산자 데이터 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fcb4d0603695c9c5c79f801a2ccda42d2230338" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions, B-Tree equal image functions, and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">에서 &lt;code&gt;ADD FUNCTION&lt;/code&gt; 절 피연산자 데이터 타입 (들)이 기능은 지원하고자하는 함수의 입력 데이터 타입 (들)와 다를 경우. B- 트리 비교 함수 및 해시 함수의 경우 함수의 입력 데이터 유형이 항상 사용할 올바른 유형이므로 &lt;code&gt;op_type&lt;/code&gt; 을 지정할 필요가 없습니다 . B- 트리 정렬 지원 함수, B- 트리 동일 이미지 함수 및 GiST, SP-GiST 및 GIN 연산자 클래스의 모든 함수의 경우 함수와 함께 사용할 피연산자 데이터 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe60e9f5f727af57aa7582cb64633b2e4aa0e193" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;AFTER&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement. So when an &lt;code&gt;AFTER&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition does not return true, it is not necessary to queue an event nor to re-fetch the row at end of statement. This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows.</source>
          <target state="translated">에서 &lt;code&gt;AFTER&lt;/code&gt; 의 트리거는 &lt;code&gt;WHEN&lt;/code&gt; 조건은 행의 갱신이 발생 직후 평가하고, 이벤트가 문장의 끝에서 트리거를 발생하는 대기할지 여부를 결정합니다. 따라서 &lt;code&gt;AFTER&lt;/code&gt; 트리거의 &lt;code&gt;WHEN&lt;/code&gt; 조건이 true를 리턴하지 않으면, 이벤트를 큐에 넣거나 명령문 끝에서 행을 다시 페치 할 필요가 없습니다. 이로 인해 몇 개의 행에 대해 트리거 만 실행하면 많은 행을 수정하는 명령문에서 속도가 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e75cc4e94385e5f68a8354a430b322f15ebd9bc" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt; command, if &lt;code&gt;ALWAYS&lt;/code&gt; is selected, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is selected, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="translated">에서 &lt;code&gt;INSERT&lt;/code&gt; 의 경우 명령, &lt;code&gt;ALWAYS&lt;/code&gt; 선택되어있는 경우, 사용자가 지정한 값은 허용됩니다 &lt;code&gt;INSERT&lt;/code&gt; 의 문 지정이 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; . 경우 &lt;code&gt;BY DEFAULT&lt;/code&gt; 선택되어, 사용자 지정 값이 우선합니다. 자세한 내용은 &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; 를 참조하십시오. ( &lt;code&gt;COPY&lt;/code&gt; 명령에서 사용자 지정 값은이 설정과 관계없이 항상 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="14d94f7fbda5ba6b714c8d7012a6a4025037bb6e" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as it was inserted. This is not so useful in trivial inserts, since it would just repeat the data provided by the client. But it can be very handy when relying on computed default values. For example, when using a &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;&lt;code&gt;serial&lt;/code&gt;&lt;/a&gt; column to provide unique identifiers, &lt;code&gt;RETURNING&lt;/code&gt; can return the ID assigned to a new row:</source>
          <target state="translated">에서 &lt;code&gt;INSERT&lt;/code&gt; , 사용할 수있는 데이터 &lt;code&gt;RETURNING&lt;/code&gt; 가 삽입되었을 때의 행이다. 이것은 클라이언트가 제공 한 데이터를 반복하기 때문에 간단한 삽입에는 그다지 유용하지 않습니다. 그러나 계산 된 기본값에 의존 할 때 매우 유용 할 수 있습니다. 예를 들어, 고유 식별자를 제공하기 위해 &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt; &lt;code&gt;serial&lt;/code&gt; &lt;/a&gt; 열을 사용하는 경우 &lt;code&gt;RETURNING&lt;/code&gt; 은 새 행에 지정된 ID를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b88536e851b3251cb15ede193475eddbb40caec" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. The operand data types can be omitted in the normal case where they are the same as the operator class's data type.</source>
          <target state="translated">에서 &lt;code&gt;OPERATOR&lt;/code&gt; 절, 오퍼레이터, 또는 피연산자 데이터 타입 (들) &lt;code&gt;NONE&lt;/code&gt; 은 A-단항 왼쪽 또는 오른쪽 단항 연산자를 의미한다. 피연산자 데이터 형식은 연산자 클래스의 데이터 형식과 동일한 일반적인 경우에는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3136757e2f5b87e470c589e7ef9c299933261292" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. Unlike the comparable syntax in &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt;, the operand data types must always be specified.</source>
          <target state="translated">에서 &lt;code&gt;OPERATOR&lt;/code&gt; 절, 오퍼레이터, 또는 피연산자 데이터 타입 (들) &lt;code&gt;NONE&lt;/code&gt; 은 A-단항 왼쪽 또는 오른쪽 단항 연산자를 의미한다. &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 의 비교 가능한 구문과 달리 피연산자 데이터 유형은 항상 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec2c43425fabe719ab28338af92c22c87b424e40" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt; command, if &lt;code&gt;ALWAYS&lt;/code&gt; is selected, any update of the column to any value other than &lt;code&gt;DEFAULT&lt;/code&gt; will be rejected. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is selected, the column can be updated normally. (There is no &lt;code&gt;OVERRIDING&lt;/code&gt; clause for the &lt;code&gt;UPDATE&lt;/code&gt; command.)</source>
          <target state="translated">에서 &lt;code&gt;UPDATE&lt;/code&gt; 하는 경우 명령 &lt;code&gt;ALWAYS&lt;/code&gt; 를 선택하고, 이외의 값 열의 모든 업데이트 &lt;code&gt;DEFAULT&lt;/code&gt; 는 거부 될 것이다. 경우 &lt;code&gt;BY DEFAULT&lt;/code&gt; 선택하면 열은 일반적으로 업데이트 할 수 있습니다. ( &lt;code&gt;UPDATE&lt;/code&gt; 명령에 대한 &lt;code&gt;OVERRIDING&lt;/code&gt; 절이 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="4f4865a4556be6b18a0efd231e79cc53e7a18167" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the new content of the modified row. For example:</source>
          <target state="translated">에서 &lt;code&gt;UPDATE&lt;/code&gt; , 사용할 수있는 데이터 &lt;code&gt;RETURNING&lt;/code&gt; 수정 된 행의 새로운 콘텐츠이다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9d42b6946ae8752c916da7ef8c706a7f5db4d3a" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;amgetbitmap&lt;/code&gt; index scan, the access method does not keep an index pin on any of the returned tuples. Therefore it is only safe to use such scans with MVCC-compliant snapshots.</source>
          <target state="translated">에서 &lt;code&gt;amgetbitmap&lt;/code&gt; 의 인덱스 스캔, 액세스 방법은 반환 된 튜플의에 인덱스 핀을 유지하지 않습니다. 따라서 MVCC 호환 스냅 샷과 함께 이러한 스캔을 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="565ae755fcf3f7ba63623b03ac7404b46ed4ecef" translate="yes" xml:space="preserve">
          <source>In an abstract sense, a running PostgreSQL system produces an indefinitely long sequence of WAL records. The system physically divides this sequence into WAL &lt;em&gt;segment files&lt;/em&gt;, which are normally 16MB apiece (although the segment size can be altered during initdb). The segment files are given numeric names that reflect their position in the abstract WAL sequence. When not using WAL archiving, the system normally creates just a few segment files and then &amp;ldquo;recycles&amp;rdquo; them by renaming no-longer-needed segment files to higher segment numbers. It's assumed that segment files whose contents precede the last checkpoint are no longer of interest and can be recycled.</source>
          <target state="translated">추상적 의미에서 PostgreSQL 시스템을 실행하면 무한정 긴 WAL 레코드 시퀀스가 ​​생성됩니다. 시스템은이 시퀀스를 물리적 으로 16MB 크기의 WAL &lt;em&gt;세그먼트 파일&lt;/em&gt; 로 물리적으로 나눕니다 (initdb 동안 세그먼트 크기를 변경할 수는 있지만). 세그먼트 파일에는 추상 WAL 시퀀스에서의 위치를 ​​나타내는 숫자 이름이 제공됩니다. WAL 아카이빙을 사용하지 않는 경우, 시스템은 일반적으로 단지 몇 개의 세그먼트 파일을 만든 다음 더 이상 필요하지 않은 세그먼트 파일의 이름을 더 높은 세그먼트 번호로 바꾸어 &quot;재활용&quot;합니다. 내용이 마지막 체크 포인트 이전의 세그먼트 파일은 더 이상 관심이없고 재활용 될 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f8ac0a1e1d2b4929b34c74cce531be5f95182b00" translate="yes" xml:space="preserve">
          <source>In an exclusive backup, &lt;code&gt;pg_stop_backup&lt;/code&gt; removes the label file and, if it exists, the &lt;code&gt;tablespace_map&lt;/code&gt; file created by &lt;code&gt;pg_start_backup&lt;/code&gt;. In a non-exclusive backup, the contents of the &lt;code&gt;backup_label&lt;/code&gt; and &lt;code&gt;tablespace_map&lt;/code&gt; are returned in the result of the function, and should be written to files in the backup (and not in the data directory). There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the &lt;code&gt;pg_stop_backup&lt;/code&gt; will return immediately after the backup is completed without waiting for WAL to be archived. This behavior is only useful for backup software which independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. When this parameter is set to true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled; on the standby, this means that it will wait only when &lt;code&gt;archive_mode = always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.</source>
          <target state="translated">독점 백업에서 &lt;code&gt;pg_stop_backup&lt;/code&gt; 은 레이블 파일과 존재하는 경우 &lt;code&gt;pg_start_backup&lt;/code&gt; 에 의해 작성된 &lt;code&gt;tablespace_map&lt;/code&gt; 파일을 제거합니다 . 비 독점 백업에서 &lt;code&gt;backup_label&lt;/code&gt; 및 &lt;code&gt;tablespace_map&lt;/code&gt; 의 내용은 함수 결과로 리턴되며 백업의 파일 (데이터 디렉토리가 아닌)에 기록되어야합니다. &lt;code&gt;boolean&lt;/code&gt; 유형의 선택적 두 번째 매개 변수가 있습니다. false 인 경우 &lt;code&gt;pg_stop_backup&lt;/code&gt; WAL이 보관 될 때까지 기다리지 않고 백업이 완료되면 즉시 반환됩니다. 이 동작은 WAL 보관을 독립적으로 모니터링하는 백업 소프트웨어에만 유용합니다. 그렇지 않으면 백업 일관성을 유지하는 데 필요한 WAL이 누락되어 백업을 쓸모 없게 만들 수 있습니다. 이 매개 변수가 true로 설정되면 &lt;code&gt;pg_stop_backup&lt;/code&gt; 은 아카이브가 활성화 될 때 WAL이 아카이브 될 때까지 기다립니다. 대기에서 이는 &lt;code&gt;archive_mode = always&lt;/code&gt; 때만 대기 함을 의미합니다 . 기본에서 쓰기 활동이 적은 경우, 즉시 세그먼트 스위치를 트리거하기 위해 기본에서 &lt;code&gt;pg_switch_wal&lt;/code&gt; 을 실행하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7db342c2003b24a0078e3f7501e15f251fcabd3" translate="yes" xml:space="preserve">
          <source>In an index scan, the index access method is responsible for regurgitating the TIDs of all the tuples it has been told about that match the &lt;em&gt;scan keys&lt;/em&gt;. The access method is &lt;em&gt;not&lt;/em&gt; involved in actually fetching those tuples from the index's parent table, nor in determining whether they pass the scan's visibility test or other conditions.</source>
          <target state="translated">인덱스 스캔에서 인덱스 액세스 방법은 &lt;em&gt;스캔 키&lt;/em&gt; 와 일치한다고 알려주는 모든 튜플의 TID를 역류시키는 역할을 &lt;em&gt;합니다&lt;/em&gt; . 액세스 방법은 실제로 인덱스의 상위 테이블에서 해당 튜플을 가져 오거나 스캔의 가시성 테스트 또는 다른 조건을 통과하는지 여부를 결정하는 데 관여 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2aea61eca91fb7f3cae5718d047d4ef52faf5a35" translate="yes" xml:space="preserve">
          <source>In an internal page (not shown), the block number part of &lt;code&gt;ctid&lt;/code&gt; is a &amp;ldquo;downlink&amp;rdquo;, which is a block number of another page in the index itself. The offset part (the second number) of &lt;code&gt;ctid&lt;/code&gt; stores encoded information about the tuple, such as the number of columns present (suffix truncation may have removed unneeded suffix columns). Truncated columns are treated as having the value &amp;ldquo;minus infinity&amp;rdquo;.</source>
          <target state="translated">내부 페이지 (표시되지 않음)에서 &lt;code&gt;ctid&lt;/code&gt; 의 블록 번호 부분은 색인 자체에있는 다른 페이지의 블록 번호 인 &quot;다운 링크&quot;입니다. &lt;code&gt;ctid&lt;/code&gt; 의 오프셋 부분 (두 번째 숫자)은 존재하는 열 수 (접미사 잘림으로 인해 불필요한 접미사 열이 제거되었을 수 있음)와 같은 튜플에 대한 인코딩 된 정보를 저장합니다. 잘린 열은 &quot;무한대 마이너스&quot;값을 갖는 것으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f28fd11104e5b0da0e35b4fc535d8db587de4795" translate="yes" xml:space="preserve">
          <source>In an unmodified installation, the file &lt;code&gt;Default&lt;/code&gt; contains all the non-conflicting time zone abbreviations for most of the world. Additional files &lt;code&gt;Australia&lt;/code&gt; and &lt;code&gt;India&lt;/code&gt; are provided for those regions: these files first include the &lt;code&gt;Default&lt;/code&gt; file and then add or modify abbreviations as needed.</source>
          <target state="translated">수정되지 않은 설치에서 &lt;code&gt;Default&lt;/code&gt; 파일 에는 대부분의 세계에서 충돌하지 않는 모든 시간대 약어가 포함됩니다. 추가 파일 &lt;code&gt;Australia&lt;/code&gt; 와 &lt;code&gt;India&lt;/code&gt; 는 해당 지역에 제공됩니다.이 파일에는 먼저 &lt;code&gt;Default&lt;/code&gt; 파일이 포함 된 다음 필요에 따라 약어를 추가 또는 수정합니다.</target>
        </trans-unit>
        <trans-unit id="f4e4ae3ee0675010eaef475c4b41d41082a6a6e7" translate="yes" xml:space="preserve">
          <source>In any case, if a recovery target is configured but the archive recovery ends before the target is reached, the server will shut down with a fatal error.</source>
          <target state="translated">어쨌든 복구 대상이 구성되어 있지만 대상에 도달하기 전에 아카이브 복구가 종료되면 서버가 치명적인 오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6faf2b1db0e643ecf8d471d0c7a2c045089265e3" translate="yes" xml:space="preserve">
          <source>In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere.</source>
          <target state="translated">어쨌든, 프레임 끝까지의 거리는 파티션 끝까지의 거리에 의해 제한되므로, 파티션 끝 근처의 행에 대해 프레임이 다른 곳보다 적은 수의 행을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a8baad62a92191ed853f5bfffb689d16144b1a" translate="yes" xml:space="preserve">
          <source>In archive recovery or standby mode, the server periodically performs &lt;em&gt;restartpoints&lt;/em&gt;, which are similar to checkpoints in normal operation: the server forces all its state to disk, updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again, and then recycles any old log segment files in the &lt;code&gt;pg_wal&lt;/code&gt; directory. Restartpoints can't be performed more frequently than checkpoints in the master because restartpoints can only be performed at checkpoint records. A restartpoint is triggered when a checkpoint record is reached if at least &lt;code&gt;checkpoint_timeout&lt;/code&gt; seconds have passed since the last restartpoint, or if WAL size is about to exceed &lt;code&gt;max_wal_size&lt;/code&gt;. However, because of limitations on when a restartpoint can be performed, &lt;code&gt;max_wal_size&lt;/code&gt; is often exceeded during recovery, by up to one checkpoint cycle's worth of WAL. (&lt;code&gt;max_wal_size&lt;/code&gt; is never a hard limit anyway, so you should always leave plenty of headroom to avoid running out of disk space.)</source>
          <target state="translated">아카이브 복구 또는 대기 모드에서 서버는 정기적으로 &lt;em&gt;재시작 지점을&lt;/em&gt; 수행 &lt;em&gt;하는데&lt;/em&gt; , 이는 정상 작동 상태의 체크 포인트와 유사합니다. 서버는 모든 상태를 디스크로 강제하고 &lt;code&gt;pg_control&lt;/code&gt; 파일을 업데이트 하여 이미 처리 된 WAL 데이터를 다시 스캔 할 필요가 없음을 나타냅니다. 그런 다음 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리의 오래된 로그 세그먼트 파일을 재활용합니다 . 재시작 지점은 체크 포인트 레코드에서만 수행 할 수 있기 때문에 마스터의 체크 포인트보다 더 자주 다시 시작할 수 없습니다. 마지막 다시 시작 지점 이후 최소 &lt;code&gt;checkpoint_timeout&lt;/code&gt; 초가 지난 경우 또는 WAL 크기가 &lt;code&gt;max_wal_size&lt;/code&gt; 를 초과 하려고하는 경우 검사 점 레코드에 도달하면 다시 시작점이 트리거됩니다.. 그러나 재시작 지점을 수행 할 수있는시기에 대한 제한으로 인해 &lt;code&gt;max_wal_size&lt;/code&gt; 는 복구 중에 최대 1 개의 체크 포인트주기에 해당하는 WAL만큼 초과되는 경우가 많습니다. ( &lt;code&gt;max_wal_size&lt;/code&gt; 는 절대 하드 제한이 아니므로 디스크 공간이 부족하지 않도록 항상 충분한 여유 공간을 두어야합니다.)</target>
        </trans-unit>
        <trans-unit id="e983613b50e43472d70dff9ae2842d52027c35fe" translate="yes" xml:space="preserve">
          <source>In autocommit-off mode, you must explicitly abandon any failed transaction by entering &lt;code&gt;ABORT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;. Also keep in mind that if you exit the session without committing, your work will be lost.</source>
          <target state="translated">자동 커미트 오프 모드에서는 &lt;code&gt;ABORT&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK&lt;/code&gt; 을 입력하여 실패한 트랜잭션을 명시 적으로 포기해야합니다 . 또한 커밋하지 않고 세션을 종료하면 작업 내용이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="b247fa1a8bf50d6b99053c3d0eeaa42c7ba06baa" translate="yes" xml:space="preserve">
          <source>In both cases, the current row of &lt;code&gt;inventory_item&lt;/code&gt; is passed to the function as a single composite-valued argument. Even though &lt;code&gt;.*&lt;/code&gt; does nothing in such cases, using it is good style, since it makes clear that a composite value is intended. In particular, the parser will consider &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;c.*&lt;/code&gt; to refer to a table name or alias, not to a column name, so that there is no ambiguity; whereas without &lt;code&gt;.*&lt;/code&gt;, it is not clear whether &lt;code&gt;c&lt;/code&gt; means a table name or a column name, and in fact the column-name interpretation will be preferred if there is a column named &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;inventory_item&lt;/code&gt; 의 현재 행이 단일 복합 값 인수로 함수에 전달됩니다. 이러한 경우에 &lt;code&gt;.*&lt;/code&gt; 는 아무 것도 수행하지 않지만 복합 값이 의도 된 것임을 명확히하기 때문에 좋은 스타일을 사용하는 것이 좋습니다. 특히, 파서는 &lt;code&gt;c&lt;/code&gt; . 에서 &lt;code&gt;c.*&lt;/code&gt; 를 고려 하여 열 이름이 아닌 테이블 이름 또는 별명을 참조하므로 모호성이 없습니다. 반면없이 &lt;code&gt;.*&lt;/code&gt; , 있는지 명확하지 &lt;code&gt;c&lt;/code&gt; 테이블 이름 또는 열 이름을 의미하고, 실제로 열 이름 해석은 열 이름이 있다면 바람직 할 것이다 &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f76739639f03e7f45a4a9297ea3a846e096a82c7" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5db2bd59ec0063d8b571ff86647485295dec81a2" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 인 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba5e7fcf43f6a46fa23c849e18652c98a11d276" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 인 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6eaaf99e6c52738ae42a85a2ea51714fc0796916" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="94b403e1d0cfae4a4d06e5a4c5a48eb222d916e0" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e7c380013a6560b8ccf88c49ec21236d61ed865e" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려움이있는 경우 잠재적 문제점 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a390aa69b768b09463593395199c846120ecabb8" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">어려운 경우 잠재적 문제 및 오류 메시지에 대한 설명 은 &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 및 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 을 참조 하십시오 . 데이터베이스 서버는 대상 호스트에서 실행 중이어야합니다. 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2030ab1905e77cb31a87a361f54b214bc88ef0f8" translate="yes" xml:space="preserve">
          <source>In case of multiple inheritance, if one parent column is a generated column, then all parent columns must be generated columns and with the same expression.</source>
          <target state="translated">다중 상속의 경우 하나의 상위 열이 생성 된 열이면 모든 상위 열은 동일한 표현식으로 생성 된 열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="93f46ad3e6977f8b4097e1a0c73d806eccff9805" translate="yes" xml:space="preserve">
          <source>In cases where you are accessing single rows randomly within a table, the actual order of the data in the table is unimportant. However, if you tend to access some data more than others, and there is an index that groups them together, you will benefit from using &lt;code&gt;CLUSTER&lt;/code&gt;. If you are requesting a range of indexed values from a table, or a single indexed value that has multiple rows that match, &lt;code&gt;CLUSTER&lt;/code&gt; will help because once the index identifies the table page for the first row that matches, all other rows that match are probably already on the same table page, and so you save disk accesses and speed up the query.</source>
          <target state="translated">테이블 내에서 단일 행에 무작위로 액세스하는 경우 테이블에있는 데이터의 실제 순서는 중요하지 않습니다. 그러나 다른 데이터보다 더 많은 데이터에 액세스하려는 경향이 있고이를 그룹화하는 인덱스가있는 경우 &lt;code&gt;CLUSTER&lt;/code&gt; 를 사용하면 도움이됩니다 . 테이블에서 일치하는 여러 행이있는 단일 인덱스 값 또는 인덱스 된 값의 범위를 요청하는 경우 인덱스가 일치 하는 첫 번째 행의 테이블 페이지를 식별하면 일치하는 다른 모든 행이 아마도 &lt;code&gt;CLUSTER&lt;/code&gt; 에 도움이됩니다. 이미 동일한 테이블 페이지에 있으므로 디스크 액세스를 저장하고 쿼리 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="74c2cf6ed852f4b751c92fd9888cb548968dc00d" translate="yes" xml:space="preserve">
          <source>In certain cases using advisory locking methods, especially in queries involving explicit ordering and &lt;code&gt;LIMIT&lt;/code&gt; clauses, care must be taken to control the locks acquired because of the order in which SQL expressions are evaluated. For example:</source>
          <target state="translated">권고 잠금 메소드를 사용하는 경우, 특히 명시 적 순서 지정 및 &lt;code&gt;LIMIT&lt;/code&gt; 절이 포함 된 쿼리 에서 SQL 표현식이 평가되는 순서로 인해 획득 된 잠금을 제어하도록주의를 기울여야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a44c40b70d09319f4150cf272b9356e9931bfa6f" translate="yes" xml:space="preserve">
          <source>In combination with the &lt;code&gt;convert_from&lt;/code&gt; function, this function can be used to read a text file in a specified encoding and convert to the database's encoding:</source>
          <target state="translated">와 결합 &lt;code&gt;convert_from&lt;/code&gt; 의 기능이 기능은 데이터베이스의 인코딩에 지정된 인코딩 및 변환 텍스트 파일을 읽을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c672c01926d5e97ed50c99a3d3247bc55643b756" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt; does not allow to specify properties like a table's access method with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt;&lt;code&gt;USING method&lt;/code&gt;&lt;/a&gt; or the table's tablespace with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt;&lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS&lt;/a&gt; if necessary. Therefore, the default table access method is chosen for the new table. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">대조적으로 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; , &lt;code&gt;SELECT INTO&lt;/code&gt; 가 있는 테이블의 액세스 방법과 같은 속성을 지정할 수없는 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt; &lt;code&gt;USING method&lt;/code&gt; &lt;/a&gt; 하거나으로 테이블의 테이블 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt; &lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt; &lt;/a&gt; . 필요한 경우 &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS를&lt;/a&gt; 사용하십시오 . 따라서 새 테이블에 기본 테이블 액세스 방법이 선택됩니다. 자세한 정보는 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61279093682c79c9f5568d5da222628b6973c973" translate="yes" xml:space="preserve">
          <source>In contrast to a &lt;code&gt;setval&lt;/code&gt; call, a &lt;code&gt;RESTART&lt;/code&gt; operation on a sequence is transactional and blocks concurrent transactions from obtaining numbers from the same sequence. If that's not the desired mode of operation, &lt;code&gt;setval&lt;/code&gt; should be used.</source>
          <target state="translated">&lt;code&gt;setval&lt;/code&gt; 호출 과 달리 시퀀스 의 &lt;code&gt;RESTART&lt;/code&gt; 작업은 트랜잭션이며 동시 트랜잭션이 동일한 시퀀스에서 번호를 얻지 못하도록 차단합니다. 원하는 작동 모드가 아닌 경우 &lt;code&gt;setval&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8047479f58f45c6933e1e0d8cbc566b58e46ed0" translate="yes" xml:space="preserve">
          <source>In database jargon, PostgreSQL uses a client/server model. A PostgreSQL session consists of the following cooperating processes (programs):</source>
          <target state="translated">데이터베이스 전문 용어에서 PostgreSQL은 클라이언트 / 서버 모델을 사용합니다. PostgreSQL 세션은 다음과 같은 협력 프로세스 (프로그램)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4ebcdbe0c3b4b06ac68e78641d8a5ee88bcf9f9b" translate="yes" xml:space="preserve">
          <source>In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. (Note that checkpoints, which are managed by a separate, dedicated auxiliary process, are unaffected.) The default value is 100 buffers. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">각 라운드에서이 많은 버퍼는 백그라운드 라이터가 작성합니다. 이것을 0으로 설정하면 백그라운드 쓰기가 비활성화됩니다. (별도의 전용 보조 프로세스에 의해 관리되는 체크 포인트는 영향을받지 않습니다.) 기본값은 100 개의 버퍼입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccd9c3c470f6cf3a148b1b2c45132bef7b97eb77" translate="yes" xml:space="preserve">
          <source>In either case the data to be encrypted is processed as follows:</source>
          <target state="translated">두 경우 모두 암호화 할 데이터는 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="306aa7e6b40f133245f13ca709da9e87be03e6ed" translate="yes" xml:space="preserve">
          <source>In either input mode, if you type a semicolon that is not just before or part of a command entry terminator, it is considered a command separator. When you do type a command entry terminator, the multiple statements you've entered will be executed as a single transaction.</source>
          <target state="translated">입력 모드에서 명령 입력 종결 자 직전 또는 일부가 아닌 세미콜론을 입력하면 명령 구분자로 간주됩니다. 명령 입력 종결자를 입력하면 입력 한 여러 명령문이 단일 트랜잭션으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="52ebde367582fd620a8c225e745609692ba01e89" translate="yes" xml:space="preserve">
          <source>In either notation, parameters that have default values given in the function declaration need not be written in the call at all. But this is particularly useful in named notation, since any combination of parameters can be omitted; while in positional notation parameters can only be omitted from right to left.</source>
          <target state="translated">두 표기법 모두 함수 선언에 기본값이 지정된 매개 변수는 호출에 전혀 쓸 필요가 없습니다. 그러나 이는 매개 변수 조합을 생략 할 수 있으므로 명명 된 표기법에 특히 유용합니다. 위치 표기법에서 매개 변수는 오른쪽에서 왼쪽으로 만 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d831af293a1db32dece4f56906f01bbc94d110b4" translate="yes" xml:space="preserve">
          <source>In fact all the options that can be applied to a column description in &lt;code&gt;CREATE TABLE&lt;/code&gt; can be used here. Keep in mind however that the default value must satisfy the given constraints, or the &lt;code&gt;ADD&lt;/code&gt; will fail. Alternatively, you can add constraints later (see below) after you've filled in the new column correctly.</source>
          <target state="translated">실제로 &lt;code&gt;CREATE TABLE&lt;/code&gt; 의 열 설명에 적용 할 수있는 모든 옵션을 여기에서 사용할 수 있습니다. 그러나 기본값이 주어진 제한 조건을 만족해야합니다 . 그렇지 않으면 &lt;code&gt;ADD&lt;/code&gt; 가 실패합니다. 또는 새 열을 올바르게 입력 한 후 나중에 제약 조건을 추가 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="783e59eb801df832fa056e21e4887ace28a8cded" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. The data directory must be initialized before being used, using the program &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; which is installed with PostgreSQL.</source>
          <target state="translated">파일 시스템 용어로 데이터베이스 클러스터는 모든 데이터가 저장되는 단일 디렉토리입니다. 이를 &lt;em&gt;데이터 디렉토리&lt;/em&gt; 또는 &lt;em&gt;데이터 영역이라고&lt;/em&gt; 합니다. 데이터 저장 위치는 전적으로 귀하에게 달려 있습니다. 기본값은 없지만 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 또는 &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; 와 같은 위치 가 널리 사용됩니다. 데이터 디렉토리는 PostgreSQL과 함께 설치된 프로그램 &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; 를 사용하여 사용하기 전에 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5989a14e7d9d5d4126144b5b3e9ac84c1a4ebc4b" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. To initialize a database cluster, use the command &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;, which is installed with PostgreSQL. The desired file system location of your database cluster is indicated by the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="translated">파일 시스템 용어로 데이터베이스 클러스터는 모든 데이터가 저장되는 단일 디렉토리입니다. 이것을 &lt;em&gt;데이터 디렉토리&lt;/em&gt; 또는 &lt;em&gt;데이터 영역이라고&lt;/em&gt; 합니다. 데이터를 저장하기로 선택한 곳은 전적으로 귀하에게 달려 있습니다. &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 또는 &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; 와 같은 위치가 많이 사용되지만 기본값은 없습니다 . 데이터베이스 클러스터를 초기화하려면 PostgreSQL과 함께 설치된 &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; 명령을 사용하십시오 . 데이터베이스 클러스터의 원하는 파일 시스템 위치는 &lt;code&gt;-D&lt;/code&gt; 옵션으로 표시됩니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="c6dec459ff41edebdbf286e5c7e7fa61bacc87ff" translate="yes" xml:space="preserve">
          <source>In general it is unsafe to access tables referenced in rebuild scripts until the rebuild scripts have run to completion; doing so could yield incorrect results or poor performance. Tables not referenced in rebuild scripts can be accessed immediately.</source>
          <target state="translated">일반적으로 재 빌드 스크립트가 완료 될 때까지 재 빌드 스크립트에서 참조되는 테이블에 액세스하는 것은 안전하지 않습니다. 그렇게하면 잘못된 결과 나 성능이 저하 될 수 있습니다. 재 구축 스크립트에서 참조되지 않은 테이블에 즉시 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d408ce8d9c6617962a7ddfab014057b11931d1" translate="yes" xml:space="preserve">
          <source>In general the array &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be subscripted is just a column reference or positional parameter. Also, multiple subscripts can be concatenated when the original array is multidimensional. For example:</source>
          <target state="translated">일반적으로 배열 &lt;code&gt;expression&lt;/code&gt; 괄호로 묶어야하지만 첨자식이 열 참조 또는 위치 매개 변수 인 경우 괄호를 생략 할 수 있습니다. 또한 원래 배열이 다차원 일 때 여러 첨자를 연결할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a233c74a23b1b0f950c13008071a2c4108299433" translate="yes" xml:space="preserve">
          <source>In general the row &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be selected from is just a table reference or positional parameter. For example:</source>
          <target state="translated">일반적으로 행 &lt;code&gt;expression&lt;/code&gt; 은 괄호로 묶어야하지만 선택할 표현식이 테이블 참조 또는 위치 매개 변수 인 경우 괄호를 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c0b63d62e29b9c5a3a626356a3b517fe18e88f9" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;amcheck&lt;/code&gt; can only prove the presence of corruption; it cannot prove its absence.</source>
          <target state="translated">일반적으로 &lt;code&gt;amcheck&lt;/code&gt; 는 손상이 있음을 증명할 수 있습니다. 그것의 부재를 증명할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e2bc9fd37cc10d6d4e2c0ce13c42250e4fbbee6" translate="yes" xml:space="preserve">
          <source>In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. However, two null values are never considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior conforms to the SQL standard, but we have heard that other SQL databases might not follow this rule. So be careful when developing applications that are intended to be portable.</source>
          <target state="translated">일반적으로, 테이블에 제한 조건에 포함 된 모든 열의 값이 동일한 행이 둘 이상 있으면 고유 제한 조건이 위반됩니다. 그러나이 비교에서 두 개의 널값은 동일한 것으로 간주되지 않습니다. 즉, 고유 제한 조건이있는 경우에도 제한된 열 중 하나 이상에 널값이 포함 된 중복 행을 저장할 수 있습니다. 이 동작은 SQL 표준을 준수하지만 다른 SQL 데이터베이스가이 규칙을 따르지 않을 수 있다고 들었습니다. 따라서 이식성이 뛰어난 응용 프로그램을 개발할 때는주의하십시오.</target>
        </trans-unit>
        <trans-unit id="2348b93b2ef61033a339bed35843085ef2b630c2" translate="yes" xml:space="preserve">
          <source>In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, it is probably best to label functions as &lt;code&gt;UNSAFE&lt;/code&gt;.</source>
          <target state="translated">일반적으로 함수가 제한되거나 안전하지 않을 때 안전하다고 레이블이 지정되거나 실제로 안전하지 않을 때 제한됨으로 레이블이 지정되면 병렬 쿼리에 사용될 때 오류가 발생하거나 잘못된 응답을 생성 할 수 있습니다. 시스템이 임의의 C 코드로부터 자신을 보호 할 방법이 없기 때문에 C 언어 함수는 이론적으로 잘못 레이블이 지정되면 완전히 정의되지 않은 동작을 나타낼 수 있지만, 대부분의 경우 결과는 다른 함수보다 나쁘지 않습니다. 의심 &lt;code&gt;UNSAFE&lt;/code&gt; 함수를 UNSAFE 로 레이블링하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a7edd5220f4e78ad60a17c1f93de6471bf8d5e1f" translate="yes" xml:space="preserve">
          <source>In general, if a table is grouped, columns that are not listed in &lt;code&gt;GROUP BY&lt;/code&gt; cannot be referenced except in aggregate expressions. An example with aggregate expressions is:</source>
          <target state="translated">일반적으로 테이블이 그룹화 된 경우 집계 표현식을 제외하고 &lt;code&gt;GROUP BY&lt;/code&gt; 에 나열되지 않은 열은 참조 할 수 없습니다. 집계 표현식의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1c3c9f3417fc6beedd0acdb2d294853319e6a73" translate="yes" xml:space="preserve">
          <source>In general, log shipping between servers running different major PostgreSQL release levels is not possible. It is the policy of the PostgreSQL Global Development Group not to make changes to disk formats during minor release upgrades, so it is likely that running different minor release levels on primary and standby servers will work successfully. However, no formal support for that is offered and you are advised to keep primary and standby servers at the same release level as much as possible. When updating to a new minor release, the safest policy is to update the standby servers first &amp;mdash; a new minor release is more likely to be able to read WAL files from a previous minor release than vice versa.</source>
          <target state="translated">일반적으로 다른 주요 PostgreSQL 릴리스 레벨을 실행하는 서버 간의 로그 전달은 불가능합니다. 부 릴리스 업그레이드 중에 디스크 형식을 변경하지 않는 것이 PostgreSQL 글로벌 개발 그룹의 정책이므로 주 서버와 대기 서버에서 다른 부 릴리스 레벨을 실행하면 성공적으로 작동 할 수 있습니다. 그러나 이에 대한 공식적인 지원은 제공되지 않으며 기본 및 대기 서버를 가능한 한 동일한 릴리스 레벨로 유지하는 것이 좋습니다. 새 부 릴리스로 업데이트 할 때 가장 안전한 정책은 대기 서버를 먼저 업데이트하는 것입니다. 새 부 릴리스는 이전 부 릴리스에서 WAL 파일을 읽을 가능성이 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="379f9f035821f16216f7bd05e1c59664a2c062ce" translate="yes" xml:space="preserve">
          <source>In general, most applications should prefer to store JSON data as &lt;code&gt;jsonb&lt;/code&gt;, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys.</source>
          <target state="translated">일반적으로 객체 키 순서에 대한 레거시 가정과 같은 특수한 요구가없는 한 대부분의 애플리케이션은 JSON 데이터를 &lt;code&gt;jsonb&lt;/code&gt; 로 저장하는 것을 선호 합니다.</target>
        </trans-unit>
        <trans-unit id="b5f07f22b350f8a6e38078060fd0e008a551cf3e" translate="yes" xml:space="preserve">
          <source>In general, refer to the documentation of a specific module for the recommended way to load that module.</source>
          <target state="translated">일반적으로 해당 모듈을로드하는 권장 방법은 특정 모듈의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee2e987300579f41179429fff2833d7671d0a6f4" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they are useful for GIN testing and as a base for developing other GIN operator classes. Also, for queries that test both a GIN-indexable column and a B-tree-indexable column, it might be more efficient to create a multicolumn GIN index that uses one of these operator classes than to create two separate indexes that would have to be combined via bitmap ANDing.</source>
          <target state="translated">일반적으로 이러한 연산자 클래스는 동등한 표준 B- 트리 인덱스 방법보다 성능이 우수하지 않으며 표준 B- 트리 코드의 주요 기능 중 하나 인 고유성을 강화하는 기능이 없습니다. 그러나 GIN 테스트에 유용하고 다른 GIN 연산자 클래스를 개발하기위한 기반으로 유용합니다. 또한 GIN 인덱싱 가능 열과 B- 트리 인덱싱 가능 열을 모두 테스트하는 쿼리의 경우 이러한 연산자 클래스 중 하나를 사용하는 여러 열 GIN 인덱스를 만드는 것이 두 개의 별도 인덱스를 만드는 것보다 더 효율적일 수 있습니다. 비트 맵 ANDing을 통해 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="d2aa893456da765ab903af76d8c63108ae26c6ce" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they provide some other features that are not available with a B-tree index, as described below. Also, these operator classes are useful when a multicolumn GiST index is needed, wherein some of the columns are of data types that are only indexable with GiST but other columns are just simple data types. Lastly, these operator classes are useful for GiST testing and as a base for developing other GiST operator classes.</source>
          <target state="translated">일반적으로 이러한 연산자 클래스는 동등한 표준 B- 트리 인덱스 방법보다 성능이 우수하지 않으며 표준 B- 트리 코드의 주요 기능 중 하나 인 고유성을 강화하는 기능이 없습니다. 그러나 아래 설명과 같이 B- 트리 인덱스에서 사용할 수없는 다른 기능도 제공합니다. 또한이 연산자 클래스는 다중 열 GiST 인덱스가 필요할 때 유용합니다. 여기서 일부 열은 GiST로만 인덱싱 할 수있는 데이터 형식이지만 다른 열은 단순한 데이터 형식입니다. 마지막으로,이 연산자 클래스는 GiST 테스트 및 다른 GiST 연산자 클래스 개발의 기반으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="050ef9f5f9df87b4cced8b5539a1b041812d5f42" translate="yes" xml:space="preserve">
          <source>In large tables, performance will be poor unless there is an index on the parent-key field.</source>
          <target state="translated">큰 테이블에서 부모 키 필드에 인덱스가 없으면 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="4765e35412cfd4a863f019aa0033f2c20c5f4705" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. An advantage of these methods is that they bound the space requirement for &lt;code&gt;pg_wal&lt;/code&gt;; there is currently no way to do this using replication slots.</source>
          <target state="translated">복제 슬롯을 사용하는 대신 &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; 를 사용하거나 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command를&lt;/a&gt; 사용하여 아카이브에 세그먼트를 저장 하여 기존 WAL 세그먼트가 제거되는 것을 방지 할 수 있습니다 . 그러나 이러한 방법으로 인해 필요한 것보다 많은 WAL 세그먼트가 유지되는 반면 복제 슬롯에는 필요한 것으로 알려진 수의 세그먼트 만 유지됩니다. 이 메소드의 장점은 &lt;code&gt;pg_wal&lt;/code&gt; 에 필요한 공간을 제한한다는 것입니다 . 현재 복제 슬롯을 사용하여이 작업을 수행 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="29c3b7a7ac22ed19dd75a4554e5969e671d90aa0" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. On the other hand, replication slots can retain so many WAL segments that they fill up the space allocated for &lt;code&gt;pg_wal&lt;/code&gt;; &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; limits the size of WAL files retained by replication slots.</source>
          <target state="translated">복제 슬롯을 사용하는 대신 &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; 를 사용하거나 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command를&lt;/a&gt; 사용하여 아카이브에 세그먼트를 저장 하여 이전 WAL 세그먼트의 제거를 방지 할 수 있습니다 . 그러나 이러한 방법은 종종 필요한 것보다 더 많은 WAL 세그먼트를 유지하는 반면, 복제 슬롯은 필요한 것으로 알려진 세그먼트 수만 유지합니다. 반면에 복제 슬롯은 &lt;code&gt;pg_wal&lt;/code&gt; 에 할당 된 공간을 채울 정도로 많은 WAL 세그먼트를 보유 할 수 있습니다 . &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; 는 복제 슬롯이 보유하는 WAL 파일의 크기를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="84baf4a0766c72c5ea2542a507182c8520343dbe" translate="yes" xml:space="preserve">
          <source>In macOS 10.2 and earlier, instead edit these commands in the file &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt;.</source>
          <target state="translated">macOS 10.2 이하에서는 &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt; 파일에서이 명령을 편집하십시오 .</target>
        </trans-unit>
        <trans-unit id="6203855ca7fcb59eaeec22abadb1b2a4087a8203" translate="yes" xml:space="preserve">
          <source>In many practical situations, this assumption is usually satisfied; for example, there might be a GUI in the application that only allows selecting compatible city and ZIP code values to use in a query. But if that's not the case, functional dependencies may not be a viable option.</source>
          <target state="translated">많은 실제 상황에서이 가정은 일반적으로 충족됩니다. 예를 들어, 응용 프로그램에 쿼리에 사용할 호환 가능한 도시 및 우편 번호 값만 선택할 수있는 GUI가있을 수 있습니다. 그러나 그렇지 않은 경우 기능적 종속성이 실행 가능한 옵션이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b1075485e703bf16e8ab73df82eb829ce78c033" translate="yes" xml:space="preserve">
          <source>In many situations, turning off &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; for noncritical transactions can provide much of the potential performance benefit of turning off &lt;code&gt;fsync&lt;/code&gt;, without the attendant risks of data corruption.</source>
          <target state="translated">많은 상황에서 중요하지 않은 트랜잭션에 대해 &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; 을 끄면 데이터 손상 위험없이 &lt;code&gt;fsync&lt;/code&gt; 를 끄면 잠재적 인 성능 이점을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="194f1c0784b754fb38f29c78dc946b25933f09f6" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;regexp_matches()&lt;/code&gt; should be used with the &lt;code&gt;g&lt;/code&gt; flag, since if you only want the first match, it's easier and more efficient to use &lt;code&gt;regexp_match()&lt;/code&gt;. However, &lt;code&gt;regexp_match()&lt;/code&gt; only exists in PostgreSQL version 10 and up. When working in older versions, a common trick is to place a &lt;code&gt;regexp_matches()&lt;/code&gt; call in a sub-select, for example:</source>
          <target state="translated">대부분의 경우, &lt;code&gt;regexp_matches()&lt;/code&gt; 는 &lt;code&gt;g&lt;/code&gt; 플래그 와 함께 사용해야합니다 . 첫 번째 일치 만 원하면 &lt;code&gt;regexp_match()&lt;/code&gt; 를 사용하는 것이 더 쉽고 효율적이기 때문 입니다. 그러나 &lt;code&gt;regexp_match()&lt;/code&gt; 는 PostgreSQL 버전 10 이상에서만 존재합니다. 이전 버전에서 작업 할 때 일반적인 트릭은 다음 과 같이 하위 선택에 &lt;code&gt;regexp_matches()&lt;/code&gt; 호출 을 배치하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d60a20da168de2a263b74b28aa44a9c52da8b217" translate="yes" xml:space="preserve">
          <source>In most cases a &lt;code&gt;DELETE&lt;/code&gt; command also needs to read data from columns in the relation that it is deleting from (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;DELETE&lt;/code&gt; policies. Thus the user must have access to the row(s) being deleted through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to delete the row(s) via a &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;DELETE&lt;/code&gt; 명령은 삭제할 관계의 열 (예 : &lt;code&gt;WHERE&lt;/code&gt; 절 또는 &lt;code&gt;RETURNING&lt;/code&gt; 절) 에서 데이터를 읽어야합니다 . 이 경우 관계에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한도 필요 하며 &lt;code&gt;DELETE&lt;/code&gt; 정책 외에 적절한 &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;ALL&lt;/code&gt; 정책이 적용됩니다 . 따라서 사용자는 &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;ALL&lt;/code&gt; 정책을 통해 행을 삭제할 수있는 권한이 부여 될뿐만 아니라 &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;ALL&lt;/code&gt; 정책을 통해 삭제되는 행에 액세스 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="82c5561a0275adcd2a2a51ebef8a40a5f37109da" translate="yes" xml:space="preserve">
          <source>In most database designs the majority of columns should be marked not null.</source>
          <target state="translated">대부분의 데이터베이스 디자인에서 대부분의 열은 null이 아닌 것으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="158c99420a44bba9aff343cb614d9616cbae7fa4" translate="yes" xml:space="preserve">
          <source>In most implementations of the &amp;ldquo;not-a-number&amp;rdquo; concept, &lt;code&gt;NaN&lt;/code&gt; is not considered equal to any other numeric value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow &lt;code&gt;numeric&lt;/code&gt; values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">&quot;숫자 가 아님 &quot;개념의 대부분의 구현에서 &lt;code&gt;NaN&lt;/code&gt; 은 다른 숫자 값 ( &lt;code&gt;NaN&lt;/code&gt; 포함 ) 과 동일하게 간주되지 않습니다 . 트리 기반 인덱스에서 &lt;code&gt;numeric&lt;/code&gt; 값을 정렬하고 사용할 수 있도록 PostgreSQL은 &lt;code&gt;NaN&lt;/code&gt; 값을 동일하고 &lt;code&gt;NaN&lt;/code&gt; 이 아닌 모든 값 보다 큰 것으로 간주 합니다.</target>
        </trans-unit>
        <trans-unit id="cd61e39655eeef5b9bf240531ec53c538d27ed8e" translate="yes" xml:space="preserve">
          <source>In named notation, each argument's name is specified using &lt;code&gt;=&amp;gt;&lt;/code&gt; to separate it from the argument expression. For example:</source>
          <target state="translated">명명 된 표기법에서 각 인수의 이름은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 를 사용 하여 인수 표현식과 구분 하여 지정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a49a039bda09447cda5b6ba6fb7b5f06a1662cb" translate="yes" xml:space="preserve">
          <source>In nearly all cases, you'll need some options to make a useful test. The most important options are &lt;code&gt;-c&lt;/code&gt; (number of clients), &lt;code&gt;-t&lt;/code&gt; (number of transactions), &lt;code&gt;-T&lt;/code&gt; (time limit), and &lt;code&gt;-f&lt;/code&gt; (specify a custom script file). See below for a full list.</source>
          <target state="translated">거의 모든 경우에 유용한 테스트를 수행하려면 몇 가지 옵션이 필요합니다. 가장 중요한 옵션은 &lt;code&gt;-c&lt;/code&gt; (클라이언트 수), &lt;code&gt;-t&lt;/code&gt; (트랜잭션 수), &lt;code&gt;-T&lt;/code&gt; (시간 제한) 및 &lt;code&gt;-f&lt;/code&gt; (사용자 지정 스크립트 파일 지정)입니다. 전체 목록은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a8686c8bc573efc7c7f314b50a2faaa5e4253e1" translate="yes" xml:space="preserve">
          <source>In non-fragment-based headline generation, &lt;code&gt;ts_headline&lt;/code&gt; locates matches for the given &lt;code&gt;query&lt;/code&gt; and chooses a single one to display, preferring matches that have more query words within the allowed headline length. In fragment-based headline generation, &lt;code&gt;ts_headline&lt;/code&gt; locates the query matches and splits each match into &amp;ldquo;fragments&amp;rdquo; of no more than &lt;code&gt;MaxWords&lt;/code&gt; words each, preferring fragments with more query words, and when possible &amp;ldquo;stretching&amp;rdquo; fragments to include surrounding words. The fragment-based mode is thus more useful when the query matches span large sections of the document, or when it's desirable to display multiple matches. In either mode, if no query matches can be identified, then a single fragment of the first &lt;code&gt;MinWords&lt;/code&gt; words in the document will be displayed.</source>
          <target state="translated">조각 기반이 아닌 헤드 라인 생성에서 &lt;code&gt;ts_headline&lt;/code&gt; 은 주어진 &lt;code&gt;query&lt;/code&gt; 대한 일치 항목을 찾고 표시 할 단일 항목을 선택하여 허용 된 헤드 라인 길이 내에 더 많은 쿼리 단어가있는 일치 항목을 선호합니다. 조각 기반 헤드 라인 생성에서 &lt;code&gt;ts_headline&lt;/code&gt; 은 쿼리 일치를 찾고 각 일치 항목을 각각 &lt;code&gt;MaxWords&lt;/code&gt; 단어 이하의 &quot;조각&quot;으로 분할하여 더 많은 쿼리 단어가있는 조각을 선호하며 가능한 경우 주변 단어를 포함하도록 조각을 &quot;확장&quot;합니다. 따라서 조각 기반 모드는 쿼리 일치가 문서의 큰 섹션에 걸쳐 있거나 여러 일치 항목을 표시하는 것이 바람직한 경우에 더 유용합니다. 두 모드에서 일치하는 쿼리가 없으면 첫 번째 &lt;code&gt;MinWords&lt;/code&gt; 문서의 MinWords 단어가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fac5d16972792c7bd805065c712c623a51151c8c" translate="yes" xml:space="preserve">
          <source>In none of these cases is there any provision for schema-qualification; all objects created during bootstrap are expected to be in the &lt;code&gt;pg_catalog&lt;/code&gt; schema.</source>
          <target state="translated">이 중 어느 경우에도 스키마 검증에 대한 규정은 없습니다. 부트 스트랩 중에 생성 된 모든 객체는 &lt;code&gt;pg_catalog&lt;/code&gt; 스키마에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f2409be7cd8d4efc7e947e3b436a132ef0c47174" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user &amp;mdash; they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">일반 (비 복구) 모드에서 로그인 기능이있는 역할에 대해 &lt;code&gt;DROP USER&lt;/code&gt; 또는 &lt;code&gt;DROP ROLE&lt;/code&gt; 을 실행하면 해당 사용자가 여전히 연결되어있는 동안 연결된 사용자에게 아무 일도 일어나지 않고 연결된 상태로 유지됩니다. 그러나 사용자는 다시 연결할 수 없습니다. 이 동작은 복구에도 적용되므로 기본 의 &lt;code&gt;DROP USER&lt;/code&gt; 는 대기에서 해당 사용자의 연결을 끊지 않습니다.</target>
        </trans-unit>
        <trans-unit id="909fab97f09523721a77cc835152b274f406d63c" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user - they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">일반 (복구하지 않음) 모드에서 해당 사용자가 여전히 연결되어있는 동안 로그인 기능이있는 역할에 대해 &lt;code&gt;DROP USER&lt;/code&gt; 또는 &lt;code&gt;DROP ROLE&lt;/code&gt; 을 발행 하면 연결된 사용자에게 아무런 변화가 없습니다. 그러나 사용자는 다시 연결할 수 없습니다. 이 동작은 복구에도 적용되므로 기본 의 &lt;code&gt;DROP USER&lt;/code&gt; 가 대기에서 해당 사용자의 연결을 끊지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1729ae1f718e0b63bffb08ae3066f0eb0e77ca2" translate="yes" xml:space="preserve">
          <source>In normal operation, &amp;ldquo;read-only&amp;rdquo; transactions are allowed to use &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt;, so Hot Standby sessions operate under slightly tighter restrictions than ordinary read-only sessions. It is possible that some of these restrictions might be loosened in a future release.</source>
          <target state="translated">정상 작동에서 &quot;읽기 전용&quot;트랜잭션은 &lt;code&gt;LISTEN&lt;/code&gt; 및 &lt;code&gt;NOTIFY&lt;/code&gt; 를 사용할 수 있으므로 핫 스탠바이 세션은 일반 읽기 전용 세션보다 약간 엄격한 제한 하에서 작동합니다. 다음 릴리스에서는 이러한 제한 중 일부가 완화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3560745e5e4a4c446630441931abacb2898af6f" translate="yes" xml:space="preserve">
          <source>In normal operation, psql provides a prompt with the name of the database to which psql is currently connected, followed by the string &lt;code&gt;=&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">정상적인 작동에서 psql은 psql이 현재 연결된 데이터베이스 이름과 프롬프트 &lt;code&gt;=&amp;gt;&lt;/code&gt; 를 프롬프트합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd286c2214fff2e0be18b3ddfb09dfdd0278ddbf" translate="yes" xml:space="preserve">
          <source>In older OpenBSD versions, you will need to build a custom kernel to change the IPC parameters. Make sure that the options &lt;code&gt;SYSVSHM&lt;/code&gt; and &lt;code&gt;SYSVSEM&lt;/code&gt; are enabled, too. (They are by default.) The following shows an example of how to set the various parameters in the kernel configuration file:</source>
          <target state="translated">이전 OpenBSD 버전에서는 IPC 매개 변수를 변경하기 위해 사용자 정의 커널을 빌드해야합니다. &lt;code&gt;SYSVSHM&lt;/code&gt; 및 &lt;code&gt;SYSVSEM&lt;/code&gt; 옵션 도 활성화 해야합니다 . (기본적으로 설정되어 있습니다.) 다음은 커널 구성 파일에서 다양한 매개 변수를 설정하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="43d5f374be9ab2b9f725372748b33884cde122b3" translate="yes" xml:space="preserve">
          <source>In older macOS versions, you will need to reboot to have changes in the shared memory parameters take effect. As of 10.5 it is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="translated">이전 macOS 버전에서는 공유 메모리 매개 변수의 변경 사항을 적용하려면 재부팅해야합니다. 10.5부터 sysctl을 사용하여 &lt;code&gt;SHMMNI&lt;/code&gt; 를 제외한 모든 것을 즉시 변경할 수 있습니다 . 그러나 재부팅 할 때마다 값이 유지되도록 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 를 통해 원하는 값을 설정하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="882a1a9442374dfd65845651f73b92d43f44074e" translate="yes" xml:space="preserve">
          <source>In order for the tunnel setup to succeed you must be allowed to connect via &lt;code&gt;ssh&lt;/code&gt; as &lt;code&gt;joe@foo.com&lt;/code&gt;, just as if you had attempted to use &lt;code&gt;ssh&lt;/code&gt; to create a terminal session.</source>
          <target state="translated">터널 설정이 성공 하려면 &lt;code&gt;ssh&lt;/code&gt; 를 사용하여 터미널 세션을 생성 한 것처럼 &lt;code&gt;ssh&lt;/code&gt; 를 통해 &lt;code&gt;joe@foo.com&lt;/code&gt; 으로 연결할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d646fc6f64023e87f7f5096950ae7ce2f2e80423" translate="yes" xml:space="preserve">
          <source>In order to access any schema object, &lt;code&gt;db_schema:search&lt;/code&gt; permission is required on the containing schema. When an object is referenced without schema qualification, schemas on which this permission is not present will not be searched (just as if the user did not have &lt;code&gt;USAGE&lt;/code&gt; privilege on the schema). If an explicit schema qualification is present, an error will occur if the user does not have the requisite permission on the named schema.</source>
          <target state="translated">스키마 객체에 액세스 하려면 포함하는 스키마에 &lt;code&gt;db_schema:search&lt;/code&gt; 권한이 필요합니다. 스키마 자격없이 개체를 참조하면이 권한이없는 스키마는 사용자 에게 스키마에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한 이없는 것처럼 검색되지 않습니다 . 명시 적 스키마 규정이 있으면 사용자에게 명명 된 스키마에 대한 필수 권한이없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="233299fd5dfd7550c24147ba5661abe08d2d0d86" translate="yes" xml:space="preserve">
          <source>In order to allow the PostgreSQL query planner to make reasonably informed decisions when optimizing queries, the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; data should be up-to-date for all tables used in the query. Normally the &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum daemon&lt;/a&gt; will take care of that automatically. But if a table has recently had substantial changes in its contents, you might need to do a manual &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; rather than wait for autovacuum to catch up with the changes.</source>
          <target state="translated">PostgreSQL 쿼리 플래너가 쿼리를 최적화 할 때 합리적인 정보에 근거한 결정을 내리 려면 쿼리에 사용 된 모든 테이블에 대해 &lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt; 데이터가 최신 상태 여야합니다. 일반적으로 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum 데몬&lt;/a&gt; 이 자동으로 처리합니다. 그러나 최근 테이블의 내용이 크게 변경된 경우 autovacuum이 변경 사항을 따라 잡을 때까지 기다리지 않고 수동 &lt;a href=&quot;sql-analyze&quot;&gt;분석&lt;/a&gt; 을 수행해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bbf891d4248cf5667df821377cc8cc7768e14e9" translate="yes" xml:space="preserve">
          <source>In order to be able to copy the initial table data, the role used for the replication connection must have the &lt;code&gt;SELECT&lt;/code&gt; privilege on a published table (or be a superuser).</source>
          <target state="translated">초기 테이블 데이터를 복사하려면 복제 연결에 사용 된 역할 에 게시 된 테이블에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 있어야 합니다 (또는 수퍼 유저).</target>
        </trans-unit>
        <trans-unit id="fcaf64f5cce00b8df1baf8d751f9011467d9dba7" translate="yes" xml:space="preserve">
          <source>In order to bootstrap the database system, a freshly initialized system always contains one predefined role. This role is always a &amp;ldquo;superuser&amp;rdquo;, and by default (unless altered when running &lt;code&gt;initdb&lt;/code&gt;) it will have the same name as the operating system user that initialized the database cluster. Customarily, this role will be named &lt;code&gt;postgres&lt;/code&gt;. In order to create more roles you first have to connect as this initial role.</source>
          <target state="translated">데이터베이스 시스템을 부트 스트랩하기 위해 새로 초기화 된 시스템에는 항상 하나의 사전 정의 된 역할이 포함됩니다. 이 역할은 항상&amp;ldquo;수퍼 유저&amp;rdquo;이며 기본적으로 ( &lt;code&gt;initdb&lt;/code&gt; 를 실행할 때 변경되지 않는 한 ) 데이터베이스 클러스터를 초기화 한 운영 체제 사용자와 이름이 같습니다. 일반적으로이 역할의 이름은 &lt;code&gt;postgres&lt;/code&gt; 입니다. 더 많은 역할을 만들려면 먼저이 초기 역할로 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0b6ace4aa733c9f867afeaddbd70b1a3a0b54f3" translate="yes" xml:space="preserve">
          <source>In order to calculate the union, intersection, or difference of two queries, the two queries must be &amp;ldquo;union compatible&amp;rdquo;, which means that they return the same number of columns and the corresponding columns have compatible data types, as described in &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;.</source>
          <target state="translated">두 쿼리의 합집합, 교집합 또는 차이를 계산하려면 두 쿼리가 &quot;유니언 호환 가능&quot;해야합니다. 즉, &lt;a href=&quot;typeconv-union-case&quot;&gt;10.5 절&lt;/a&gt; 에서 설명한대로 동일한 수의 열을 반환하고 해당 열은 호환 가능한 데이터 형식을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="4415b6dbba894170e74bcc6996dbfa1fb24cd8d1" translate="yes" xml:space="preserve">
          <source>In order to create a database, the PostgreSQL server must be up and running (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;).</source>
          <target state="translated">데이터베이스를 생성하려면 PostgreSQL 서버가 가동되어 실행 중이어야합니다 ( &lt;a href=&quot;server-start&quot;&gt;섹션 18.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3f22ae189397eeb8d6d5706a9610e0f700d2bec8" translate="yes" xml:space="preserve">
          <source>In order to emulate a case-insensitive collation as closely as possible, there are &lt;code&gt;citext&lt;/code&gt;-specific versions of a number of string-processing operators and functions. So, for example, the regular expression operators &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; exhibit the same behavior when applied to &lt;code&gt;citext&lt;/code&gt;: they both match case-insensitively. The same is true for &lt;code&gt;!~&lt;/code&gt; and &lt;code&gt;!~*&lt;/code&gt;, as well as for the &lt;code&gt;LIKE&lt;/code&gt; operators &lt;code&gt;~~&lt;/code&gt; and &lt;code&gt;~~*&lt;/code&gt;, and &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt;. If you'd like to match case-sensitively, you can cast the operator's arguments to &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">대소 문자를 구분하지 않는 데이터 정렬을 가능한 한 가깝게 에뮬레이트하기 위해 여러 문자열 처리 연산자 및 함수의 &lt;code&gt;citext&lt;/code&gt; 특정 버전이 있습니다. 예를 들어, 정규 표현식 연산자 인 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~*&lt;/code&gt; 는 &lt;code&gt;citext&lt;/code&gt; 에 적용 할 때 동일한 동작을 나타 냅니다 . 둘 다 대소 문자를 구분하지 않습니다. 동일은 마찬가지입니다 &lt;code&gt;!~&lt;/code&gt; 와 &lt;code&gt;!~*&lt;/code&gt; 뿐만 아니라에 대한 &lt;code&gt;LIKE&lt;/code&gt; 의 사업자 &lt;code&gt;~~&lt;/code&gt; 와 &lt;code&gt;~~*&lt;/code&gt; ,와 &lt;code&gt;!~~&lt;/code&gt; 와 &lt;code&gt;!~~*&lt;/code&gt; . 대소 문자를 구분하여 일치 시키려면 연산자의 인수를 &lt;code&gt;text&lt;/code&gt; 로 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13c4603c579f552910275f0bbcb4deae55ef3a7a" translate="yes" xml:space="preserve">
          <source>In order to function, this module must be loaded via &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">작동하려면 &lt;code&gt;postgresql.conf&lt;/code&gt; 의&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; 를 통해이 모듈을로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d81c2662b5a84aa8d5b82fab0b4d606e39ebda86" translate="yes" xml:space="preserve">
          <source>In order to measure the run-time cost of each node in the execution plan, the current implementation of &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; adds profiling overhead to query execution. As a result, running &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on a query can sometimes take significantly longer than executing the query normally. The amount of overhead depends on the nature of the query, as well as the platform being used. The worst case occurs for plan nodes that in themselves require very little time per execution, and on machines that have relatively slow operating system calls for obtaining the time of day.</source>
          <target state="translated">실행 계획에서 각 노드의 런타임 비용을 측정하기 위해 현재 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 구현은 쿼리 실행에 프로파일 링 오버 헤드를 추가합니다. 결과적으로 쿼리 에서 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 를 실행하면 쿼리를 정상적으로 실행하는 것보다 시간이 훨씬 오래 걸릴 수 있습니다. 오버 헤드의 양은 사용중인 플랫폼뿐만 아니라 쿼리의 특성에 따라 다릅니다. 최악의 경우는 실행 당 시간이 거의 필요하지 않은 계획 노드와 시간을 얻기 위해 운영 체제 호출이 상대적으로 느린 시스템에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ef25cb15d96bc5ee47cb922c3476dbfcb096c17" translate="yes" xml:space="preserve">
          <source>In order to prevent this, the following applies to all built-in selectivity estimation functions. When planning a query, in order to be able to use stored statistics, the current user must either have &lt;code&gt;SELECT&lt;/code&gt; privilege on the table or the involved columns, or the operator used must be &lt;code&gt;LEAKPROOF&lt;/code&gt; (more accurately, the function that the operator is based on). If not, then the selectivity estimator will behave as if no statistics are available, and the planner will proceed with default or fall-back assumptions.</source>
          <target state="translated">이를 방지하기 위해 다음은 모든 내장 선택성 추정 기능에 적용됩니다. 쿼리를 계획 할 때 저장된 통계를 사용하려면 현재 사용자 에게 테이블 또는 관련 열에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한이 있거나 사용 된 연산자가 &lt;code&gt;LEAKPROOF&lt;/code&gt; (보다 정확하게는 연산자의 기반이되는 기능) 여야합니다 . ). 그렇지 않은 경우 선택성 추정기는 사용 가능한 통계가없는 것처럼 작동하며 플래너는 기본 또는 폴백 가정을 진행합니다.</target>
        </trans-unit>
        <trans-unit id="6b9560d0a190cd0915dff71499a691135e350ab1" translate="yes" xml:space="preserve">
          <source>In ordinary usage, these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt;, although superusers can alter them on-the-fly within their own sessions. Typical usage might be:</source>
          <target state="translated">일반적인 사용에서 이러한 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정되어 있지만 수퍼 유저는 자체 세션 내에서 즉시 변경할 수 있습니다. 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70a9b455eedcd0013740b57c24d0da08e7b71441" translate="yes" xml:space="preserve">
          <source>In parameters that specify support function names, you can write a schema name if needed, for example &lt;code&gt;SFUNC = public.sum&lt;/code&gt;. Do not write argument types there, however &amp;mdash; the argument types of the support functions are determined from other parameters.</source>
          <target state="translated">지원 함수 이름을 지정하는 매개 변수에서 필요한 경우 스키마 이름을 작성할 수 있습니다 (예 : &lt;code&gt;SFUNC = public.sum&lt;/code&gt; . 그러나 여기에 인수 유형을 쓰지 마십시오. 지원 함수의 인수 유형은 다른 매개 변수에서 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e6503b355c17e530acb3ce1cf1b630a12d5c662a" translate="yes" xml:space="preserve">
          <source>In particular, if there's an index on &lt;code&gt;key&lt;/code&gt;, it will probably be used to fetch just the rows having &lt;code&gt;key = 123&lt;/code&gt;. On the other hand, in</source>
          <target state="translated">특히 &lt;code&gt;key&lt;/code&gt; 에 인덱스가 있으면 &lt;code&gt;key = 123&lt;/code&gt; 행만 가져 오는 데 사용됩니다 . 반면에</target>
        </trans-unit>
        <trans-unit id="e4a5dbfbe9955b3dd014a081adfefb7a2337bd07" translate="yes" xml:space="preserve">
          <source>In particular, when a superuser chooses to &lt;code&gt;SET ROLE&lt;/code&gt; to a non-superuser role, they lose their superuser privileges.</source>
          <target state="translated">특히, 수퍼 유저가 비 수퍼 유저 역할 로 &lt;code&gt;SET ROLE&lt;/code&gt; 을 설정 하면 수퍼 유저 권한이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="f584b379c3631dcc4c7bd92f0443efdccb5ba563" translate="yes" xml:space="preserve">
          <source>In plain format, tablespaces will be backed up to the same path they have on the source server, unless the option &lt;code&gt;--tablespace-mapping&lt;/code&gt; is used. Without this option, running a plain format base backup on the same host as the server will not work if tablespaces are in use, because the backup would have to be written to the same directory locations as the original tablespaces.</source>
          <target state="translated">일반 형식에서는 &lt;code&gt;--tablespace-mapping&lt;/code&gt; 옵션을 사용 하지 않는 한 테이블 스페이스가 소스 서버에있는 것과 동일한 경로로 백업 됩니다. 이 옵션이 없으면 테이블 스페이스가 사용중인 경우 서버와 동일한 호스트에서 일반 형식 기본 백업을 실행하면 백업이 원래 테이블 스페이스와 동일한 디렉토리 위치에 기록되어야하기 때문에 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc733581aa12ac8119d8135b89e36cf1d9d3b31b" translate="yes" xml:space="preserve">
          <source>In practice one usually relies on the search path for operators, so as not to have to write anything so ugly as that.</source>
          <target state="translated">실제로는 일반적으로 연산자의 검색 경로에 의존하므로 추악한 것을 작성하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="a48f8184fbeadfd296ca8b91bd2766492182e822" translate="yes" xml:space="preserve">
          <source>In practice the &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; query should always specify &lt;code&gt;ORDER BY 1&lt;/code&gt; to ensure that values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together. However, ordering of the categories within a group is not important. Also, it is essential to be sure that the order of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query's output matches the specified output column order.</source>
          <target state="translated">실제로 &lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt; 쿼리는 항상 &lt;code&gt;row_name&lt;/code&gt; 이 동일한 값을 가져 오도록 &lt;code&gt;ORDER BY 1&lt;/code&gt; 을 지정해야 합니다. 그러나 그룹 내의 범주 순서는 중요하지 않습니다. 또한 &lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt; 쿼리의 출력 순서가 지정된 출력 열 순서와 일치 하는지 확인해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1937c987be0e7b4e7465a2a7029e3f9255be3a60" translate="yes" xml:space="preserve">
          <source>In practice the SQL query should always specify &lt;code&gt;ORDER BY 1,2&lt;/code&gt; to ensure that the input rows are properly ordered, that is, values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together and correctly ordered within the row. Notice that &lt;code&gt;crosstab&lt;/code&gt; itself does not pay any attention to the second column of the query result; it's just there to be ordered by, to control the order in which the third-column values appear across the page.</source>
          <target state="translated">실제로 SQL 쿼리는 항상 &lt;code&gt;ORDER BY 1,2&lt;/code&gt; 를 지정 하여 입력 행이 올바르게 정렬되도록합니다. 즉, 동일한 &lt;code&gt;row_name&lt;/code&gt; 을 갖는 값 이 행 내에서 함께 올바르게 정렬됩니다. 공지 사항 &lt;code&gt;crosstab&lt;/code&gt; 쿼리 결과의 두 번째 열에 어떤 관심을 지불하지 않는 자체; 페이지에서 세 번째 열 값이 표시되는 순서를 제어하기 위해 순서대로 정렬하면됩니다.</target>
        </trans-unit>
        <trans-unit id="81fbb389dcb4a22896ff56ba2f6a26d52f9a0053" translate="yes" xml:space="preserve">
          <source>In practice, it might be best to check the newest child first, if most inserts go into that child. For simplicity, we have shown the trigger's tests in the same order as in other parts of this example.</source>
          <target state="translated">실제로 대부분의 인서트가 해당 어린이에 들어가면 최신 어린이를 먼저 확인하는 것이 가장 좋습니다. 간단하게하기 위해이 예제의 다른 부분과 동일한 순서로 트리거 테스트를 보여주었습니다.</target>
        </trans-unit>
        <trans-unit id="06e0b2a62cd9f4eb01f119bc558152c7a9b61c4c" translate="yes" xml:space="preserve">
          <source>In practice, these commands would be wrapped up in an extension.</source>
          <target state="translated">실제로 이러한 명령은 확장으로 싸여 있습니다.</target>
        </trans-unit>
        <trans-unit id="79f48feff09a5e6beb49de65d5ed928eb6a28410" translate="yes" xml:space="preserve">
          <source>In principle, cross-references from one initial catalog row to another could be written just by writing the preassigned OID of the referenced row in the referencing field. However, that is against project policy, because it is error-prone, hard to read, and subject to breakage if a newly-assigned OID is renumbered. Therefore &lt;code&gt;genbki.pl&lt;/code&gt; provides mechanisms to write symbolic references instead. The rules are as follows:</source>
          <target state="translated">원칙적으로, 참조 필드에 참조 된 행의 사전 할당 된 OID를 작성하여 하나의 초기 카탈로그 행에서 다른 초기 카탈로그 행으로의 상호 참조를 작성할 수 있습니다. 그러나 새로 할당 된 OID의 번호가 다시 매겨지면 오류가 발생하기 쉽고 읽기 어려우며 손상 될 수 있으므로 프로젝트 정책에 위배됩니다. 따라서 &lt;code&gt;genbki.pl&lt;/code&gt; 은 대신 기호 참조를 작성하는 메커니즘을 제공합니다. 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="760cef4da4decce6f6d9b7cb2f206b14f10f3fa4" translate="yes" xml:space="preserve">
          <source>In principle, index-only scans can be used with expression indexes. For example, given an index on &lt;code&gt;f(x)&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a table column, it should be possible to execute</source>
          <target state="translated">원칙적으로 인덱스 전용 스캔은 표현식 인덱스와 함께 사용할 수 있습니다. 예를 들어, 소정의 인덱스 &lt;code&gt;f(x)&lt;/code&gt; 여기서, &lt;code&gt;x&lt;/code&gt; 인 테이블 열, 그것을 실행하는 것이 가능해야</target>
        </trans-unit>
        <trans-unit id="50939af3586cb58faf973e37d044bc572b91198e" translate="yes" xml:space="preserve">
          <source>In principle, one can use &lt;code&gt;to_tsquery&lt;/code&gt; if you quote the argument:</source>
          <target state="translated">원칙적으로 인수를 인용하면 &lt;code&gt;to_tsquery&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25c4a2a950655d8b26ffa359e0be687cbb7c81cd" translate="yes" xml:space="preserve">
          <source>In principle, we could do an index-only scan on this index to satisfy a query like</source>
          <target state="translated">원칙적으로이 인덱스에 대해 인덱스 전용 스캔을 수행하여</target>
        </trans-unit>
        <trans-unit id="5a138e4bb79a7d66b0d4bfaffdffcdcbb5964acf" translate="yes" xml:space="preserve">
          <source>In prior releases of PostgreSQL, this was the default except for the &lt;code&gt;stop&lt;/code&gt; mode.</source>
          <target state="translated">PostgreSQL의 이전 릴리스에서는 &lt;code&gt;stop&lt;/code&gt; 모드를 제외하고 이것이 기본값이었습니다 .</target>
        </trans-unit>
        <trans-unit id="75324ba26fc4965d2196117750a2a1059aac25a6" translate="yes" xml:space="preserve">
          <source>In prompt 1 normally &lt;code&gt;=&lt;/code&gt;, but &lt;code&gt;@&lt;/code&gt; if the session is in an inactive branch of a conditional block, or &lt;code&gt;^&lt;/code&gt; if in single-line mode, or &lt;code&gt;!&lt;/code&gt; if the session is disconnected from the database (which can happen if &lt;code&gt;\connect&lt;/code&gt; fails). In prompt 2 &lt;code&gt;%R&lt;/code&gt; is replaced by a character that depends on why psql expects more input: &lt;code&gt;-&lt;/code&gt; if the command simply wasn't terminated yet, but &lt;code&gt;*&lt;/code&gt; if there is an unfinished &lt;code&gt;/* ... */&lt;/code&gt; comment, a single quote if there is an unfinished quoted string, a double quote if there is an unfinished quoted identifier, a dollar sign if there is an unfinished dollar-quoted string, or &lt;code&gt;(&lt;/code&gt; if there is an unmatched left parenthesis. In prompt 3 &lt;code&gt;%R&lt;/code&gt; doesn't produce anything.</source>
          <target state="translated">프롬프트 1에서 보통 &lt;code&gt;=&lt;/code&gt; 이지만 세션이 조건부 블록의 비활성 분기에 있으면 &lt;code&gt;@&lt;/code&gt; , 또는 단일 행 모드에 있으면 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; 세션이 데이터베이스에서 연결이 끊어진 경우 ( &lt;code&gt;\connect&lt;/code&gt; 가 실패하면 발생할 수 있음 ) 프롬프트 2에서 &lt;code&gt;%R&lt;/code&gt; 은 psql이 더 많은 입력을 요구하는 이유에 따라 다른 문자로 대체됩니다 &lt;code&gt;-&lt;/code&gt; 명령이 아직 종료되지 않았지만 &lt;code&gt;*&lt;/code&gt; 완료되지 않은 &lt;code&gt;/* ... */&lt;/code&gt; 주석이 있으면 작은 따옴표 미완성 된 따옴표로 묶인 문자열, 미완성 된 따옴표로 묶인 식별자가있는 경우 큰 따옴표, 미완성 된 달러로 인용 된 문자열이있는 경우 달러 기호 또는 &lt;code&gt;(&lt;/code&gt; 일치하지 않는 왼쪽 괄호가있는 경우 프롬프트 3 &lt;code&gt;%R&lt;/code&gt; 은 아무것도 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55492f505092f7907e8e04b3d9f069e610e9bef1" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt;: the fact that its value cannot be broken down into smaller components.</source>
          <target state="translated">A와 기준에 &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;자료&lt;/a&gt; 의 값이 작은 구성 요소로 분해 할 수 없다는 사실 :.</target>
        </trans-unit>
        <trans-unit id="e2af2f18b8bb379f6a3aaec125d379cfd0547daa" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-PARTITIONED-TABLE&quot;&gt;partitioned table&lt;/a&gt;: One of the tables that each contain part of the data of the partitioned table, which is said to be the &lt;em&gt;parent&lt;/em&gt;. The partition is itself a table, so it can also be queried directly; at the same time, a partition can sometimes be a partitioned table, allowing hierarchies to be created.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-PARTITIONED-TABLE&quot;&gt;파티션을 나눈 테이블&lt;/a&gt; 과 관련하여 : 파티션 된 테이블 의 데이터 일부를 포함하는 테이블 중 하나이며 &lt;em&gt;부모&lt;/em&gt; 라고합니다 . 파티션 자체는 테이블이므로 직접 쿼리 할 수도 있습니다. 동시에 파티션은 때때로 파티션 된 테이블이되어 계층을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c9e089ab97a2e09bac9e2f25d906ab6733e4ee0" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;database transaction&lt;/a&gt;: see &lt;a href=&quot;glossary#GLOSSARY-ATOMICITY&quot;&gt;atomicity&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;데이터베이스 트랜잭션&lt;/a&gt; 과 관련하여 : &lt;a href=&quot;glossary#GLOSSARY-ATOMICITY&quot;&gt;원 자성&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="f06a3856f982e3b72fb625608048db8b0f9e532d" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;window function&lt;/a&gt; in a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt;, a partition is a user-defined criterion that identifies which neighboring &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; of the &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;query's result set&lt;/a&gt; can be considered by the function.</source>
          <target state="translated">(A)에 대한 참조에서 &lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;윈도우 함수&lt;/a&gt; A의 &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;질의&lt;/a&gt; , 격벽은 이웃하는 식별하는 사용자 정의 기준이다 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;행&lt;/a&gt; 의 &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;쿼리의 결과 집합&lt;/a&gt; 함수로 간주 될 수있다.</target>
        </trans-unit>
        <trans-unit id="ce53e0d0da47b411803cd409013625a3f9ae5431" translate="yes" xml:space="preserve">
          <source>In releases of PostgreSQL before 13 there was no &lt;code&gt;xid8&lt;/code&gt; type, so variants of these functions were provided that used &lt;code&gt;bigint&lt;/code&gt; to represent a 64-bit XID, with a correspondingly distinct snapshot data type &lt;code&gt;txid_snapshot&lt;/code&gt;. These older functions have &lt;code&gt;txid&lt;/code&gt; in their names. They are still supported for backward compatibility, but may be removed from a future release. See &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.76&lt;/a&gt;.</source>
          <target state="translated">13 이전의 PostgreSQL 릴리스에는 &lt;code&gt;xid8&lt;/code&gt; 유형 이 없었기 때문에 &lt;code&gt;bigint&lt;/code&gt; 를 사용 하여 64 비트 XID를 나타내며 이에 상응하는 고유 한 스냅 샷 데이터 유형 &lt;code&gt;txid_snapshot&lt;/code&gt; 을 사용하는 이러한 함수의 변형이 제공 되었습니다 . 이러한 이전 함수에는 이름에 &lt;code&gt;txid&lt;/code&gt; 가 있습니다. 이전 버전과의 호환성을 위해 계속 지원되지만 향후 릴리스에서 제거 될 수 있습니다. &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;표 9.76을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2a64129f0b1da1e51ed964ad4579c4ce899b50b" translate="yes" xml:space="preserve">
          <source>In releases prior to 9.6, this parameter also allowed the values &lt;code&gt;archive&lt;/code&gt; and &lt;code&gt;hot_standby&lt;/code&gt;. These are still accepted but mapped to &lt;code&gt;replica&lt;/code&gt;.</source>
          <target state="translated">9.6 이전 릴리스에서이 매개 변수는 값 &lt;code&gt;archive&lt;/code&gt; 및 &lt;code&gt;hot_standby&lt;/code&gt; 도 허용했습니다 . 이들은 여전히 ​​허용되지만 &lt;code&gt;replica&lt;/code&gt; 에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa88d3807e10330acdc1940359127a25a966338d" translate="yes" xml:space="preserve">
          <source>In short then, the most general recipe for removing a role that has been used to own objects is:</source>
          <target state="translated">간단히 말해 객체를 소유하는 데 사용 된 역할을 제거하는 가장 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d436b991362b7fed721dd789926c009b129d872d" translate="yes" xml:space="preserve">
          <source>In short, this is the difference between abbreviations and full names: abbreviations represent a specific offset from UTC, whereas many of the full names imply a local daylight-savings time rule, and so have two possible UTC offsets. As an example, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; represents noon local time in New York, which for this particular date was Eastern Daylight Time (UTC-4). So &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; specifies that same time instant. But &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; specifies noon Eastern Standard Time (UTC-5), regardless of whether daylight savings was nominally in effect on that date.</source>
          <target state="translated">간단히 말해 이것은 약어와 전체 이름의 차이입니다. 약어는 UTC와의 특정 오프셋을 나타내는 반면, 많은 전체 이름은 현지 일광 절약 시간제 규칙을 나타내므로 두 가지 가능한 UTC 오프셋이 있습니다. 예를 들어, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; 는 뉴욕의 정오 현지 시간을 나타내며이 날짜는 동부 일광 절약 시간 (UTC-4)입니다. 따라서 &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; 는 같은 시간 순간을 지정합니다. 그러나 &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; 는 일광 절약 시간이 명목상 해당 날짜에 적용되는지 여부에 관계없이 정오 동부 표준시 (UTC-5)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6f11576d9f6f09df7ddccd8a08208061f234c7e9" translate="yes" xml:space="preserve">
          <source>In short, when an RE contains both greedy and non-greedy subexpressions, the total match length is either as long as possible or as short as possible, according to the attribute assigned to the whole RE. The attributes assigned to the subexpressions only affect how much of that match they are allowed to &amp;ldquo;eat&amp;rdquo; relative to each other.</source>
          <target state="translated">요컨대, RE가 욕심과 비 욕심 하위 표현을 모두 포함하는 경우, 전체 일치 길이는 전체 RE에 할당 된 속성에 따라 가능한 한 길거나 짧습니다. 하위 표현식에 지정된 속성은 해당 항목이 서로 &quot;먹을&quot;수있는 일치 정도에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="aee830ec2c7b69b7f24b10ee81fb051f88d3ea9e" translate="yes" xml:space="preserve">
          <source>In short, while an index-only scan is possible given the two fundamental requirements, it will be a win only if a significant fraction of the table's heap pages have their all-visible map bits set. But tables in which a large fraction of the rows are unchanging are common enough to make this type of scan very useful in practice.</source>
          <target state="translated">간단히 말해, 두 가지 기본 요구 사항이 주어지면 인덱스 전용 스캔이 가능하지만 테이블 힙 페이지의 상당 부분에 모든 가시적 맵 비트가 설정되어있는 경우에만 승리 할 수 ​​있습니다. 그러나 대부분의 행이 변경되지 않은 테이블은 이러한 유형의 스캔을 실제로 유용하게 사용할 수있을만큼 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="81308d755ee35ef99db2fb46ff2f6ea4fdc54a8b" translate="yes" xml:space="preserve">
          <source>In simple cases, the concatenation operator discussed above is preferred over direct use of these functions. However, because the concatenation operator is overloaded to serve all three cases, there are situations where use of one of the functions is helpful to avoid ambiguity. For example consider:</source>
          <target state="translated">간단한 경우에, 위에서 논의 된 연결 연산자는 이러한 기능을 직접 사용하는 것보다 선호됩니다. 그러나 연결 연산자는 세 가지 경우 모두를 처리하기 위해 오버로드되므로 기능 중 하나를 사용하는 것이 모호성을 피하는 데 도움이되는 상황이 있습니다. 예를 들어 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5a889e9ac805b7a61b2cef1759227b4c01dc82" translate="yes" xml:space="preserve">
          <source>In some cases &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; shows additional execution statistics beyond the plan node execution times and row counts. For example, Sort and Hash nodes provide extra information:</source>
          <target state="translated">경우에 따라 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 는 계획 노드 실행 시간 및 행 수를 넘어서 추가 실행 통계를 표시합니다. 예를 들어, 정렬 및 해시 노드는 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e8c81b00bcb69c8ee6819bdd31891ee097641a10" translate="yes" xml:space="preserve">
          <source>In some cases it is possible for a single SQL command to fire more than one kind of trigger. For instance an &lt;code&gt;INSERT&lt;/code&gt; with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause may cause both insert and update operations, so it will fire both kinds of triggers as needed. The transition relations supplied to triggers are specific to their event type; thus an &lt;code&gt;INSERT&lt;/code&gt; trigger will see only the inserted rows, while an &lt;code&gt;UPDATE&lt;/code&gt; trigger will see only the updated rows.</source>
          <target state="translated">경우에 따라 단일 SQL 명령이 여러 종류의 트리거를 발생시킬 수 있습니다. 인스턴스의 &lt;code&gt;INSERT&lt;/code&gt; 와 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 의 필요에 따라 트리거 두 종류의 화재 있도록 절은 모두 삽입 및 업데이트 작업을 일으킬 수 있습니다. 트리거에 제공되는 전환 관계는 이벤트 유형에 따라 다릅니다. 따라서 &lt;code&gt;INSERT&lt;/code&gt; 트리거에는 삽입 된 행만 표시되고 &lt;code&gt;UPDATE&lt;/code&gt; 트리거에는 업데이트 된 행만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f8731dce3dc14a003f46fc2608e777589eba29c9" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt; with no &lt;code&gt;OUT&lt;/code&gt; parameters. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">어떤 경우에는 호출 방법에 따라 다른 열 세트를 리턴 할 수있는 테이블 함수를 정의하는 것이 유용합니다. 이를 지원하기 위해 테이블 ​​함수는 &lt;code&gt;OUT&lt;/code&gt; 매개 변수 없이 의사 유형 &lt;code&gt;record&lt;/code&gt; 를 리턴하도록 선언 할 수 있습니다 . 이러한 함수가 쿼리에 사용되는 경우 시스템이 쿼리를 구문 분석하고 계획하는 방법을 알 수 있도록 예상되는 행 구조를 쿼리 자체에 지정해야합니다. 이 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="200831069c2086edb298c7a6b5677910ac8d156b" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt;. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">어떤 경우에는 호출 방법에 따라 다른 열 세트를 리턴 할 수있는 테이블 함수를 정의하는 것이 유용합니다. 이를 지원하기 위해 테이블 ​​함수는 의사 유형 &lt;code&gt;record&lt;/code&gt; 를 리턴하는 것으로 선언 될 수 있습니다 . 이러한 함수가 쿼리에 사용될 때 시스템은 쿼리 구문 분석 및 계획 방법을 알 수 있도록 예상되는 행 구조를 쿼리 자체에 지정해야합니다. 이 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d89a4f32e25e9b6f4b0aae8fa4c3b33eb2b87fd" translate="yes" xml:space="preserve">
          <source>In some cases it might also be necessary to increase &lt;code&gt;SEMMAP&lt;/code&gt; to be at least on the order of &lt;code&gt;SEMMNS&lt;/code&gt;. If the system has this parameter (many do not), it defines the size of the semaphore resource map, in which each contiguous block of available semaphores needs an entry. When a semaphore set is freed it is either added to an existing entry that is adjacent to the freed block or it is registered under a new map entry. If the map is full, the freed semaphores get lost (until reboot). Fragmentation of the semaphore space could over time lead to fewer available semaphores than there should be.</source>
          <target state="translated">경우에 따라 &lt;code&gt;SEMMAP&lt;/code&gt; 을 &lt;code&gt;SEMMNS&lt;/code&gt; 이상으로 늘려야 할 수도 있습니다 . 시스템에이 매개 변수가있는 경우 (다수는 아님) 사용 가능한 세마포어의 각 연속 블록에 항목이 필요한 세마포어 자원 맵의 크기가 정의됩니다. 세마포어 세트가 해제되면 해제 된 블록에 인접한 기존 항목에 추가되거나 새 맵 항목 아래에 등록됩니다. 맵이 가득 차면 해제 된 세마포어가 손실됩니다 (재부팅 할 때까지). 세마포어 공간의 조각화는 시간이 지남에 따라 사용 가능한 세마포어 수가 적을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2c835a0ebddfd298ae5463818241acfed988912" translate="yes" xml:space="preserve">
          <source>In some cases several distinct distributions are needed which don't correlate with each other and this is when implicit seed parameter comes in handy:</source>
          <target state="translated">어떤 경우에는 서로 관련이없는 몇 가지 뚜렷한 분포가 필요하며 이는 암시 적 시드 매개 변수가 유용한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="b659c8baf607682082fc2a028333f1abc817539f" translate="yes" xml:space="preserve">
          <source>In some cases the join style is easier to write or faster to execute than the sub-select style.</source>
          <target state="translated">경우에 따라 결합 스타일이 하위 선택 스타일보다 작성하기가 더 빠르거나 실행하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="cc280a2801256511a801ad6396d782aaf11a1fd5" translate="yes" xml:space="preserve">
          <source>In some cases the planner will prefer a &amp;ldquo;simple&amp;rdquo; index scan plan:</source>
          <target state="translated">경우에 따라 플래너는 &quot;간단한&quot;인덱스 스캔 계획을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="0752bfbb1e8e2f35c9e16d26381cb349bc520d2f" translate="yes" xml:space="preserve">
          <source>In some cases you might wish to know which table a particular row originated from. There is a system column called &lt;code&gt;tableoid&lt;/code&gt; in each table which can tell you the originating table:</source>
          <target state="translated">경우에 따라 특정 행이 시작된 테이블을 알고 싶을 수도 있습니다. 각 테이블 에는 &lt;code&gt;tableoid&lt;/code&gt; 라는 시스템 열이 있으며,이 테이블은 원래 테이블을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="85aa180babf965f446d9b4ca6c81be1df71986fd" translate="yes" xml:space="preserve">
          <source>In some cases, a user will know that a given XPath query will return only a single result (perhaps a unique document identifier) &amp;mdash; if used alongside an XPath query returning multiple results, the single-valued result will appear only on the first row of the result. The solution to this is to use the key field as part of a join against a simpler XPath query. As an example:</source>
          <target state="translated">경우에 따라 사용자는 지정된 XPath 쿼리가 단일 결과 (아마도 고유 한 문서 식별자) 만 반환한다는 것을 알고 있습니다. 여러 결과를 반환하는 XPath 쿼리와 함께 사용하면 단일 값 결과가 첫 번째 행에만 나타납니다. 결과. 이에 대한 해결책은 간단한 XPath 쿼리에 대한 조인의 일부로 키 필드를 사용하는 것입니다. 예로서:</target>
        </trans-unit>
        <trans-unit id="ca377880ca6732de73ffe88d7d610d10f88a2a04" translate="yes" xml:space="preserve">
          <source>In some cases, an external storage product can be accessed either via NFS or a lower-level protocol such as iSCSI. In the latter case, the storage appears as a block device and any available file system can be created on it. That approach might relieve the DBA from having to deal with some of the idiosyncrasies of NFS, but of course the complexity of managing remote storage then happens at other levels.</source>
          <target state="translated">경우에 따라 NFS 또는 iSCSI와 같은 하위 수준 프로토콜을 통해 외부 저장소 제품에 액세스 할 수 있습니다. 후자의 경우 스토리지는 블록 장치로 표시되며 사용 가능한 파일 시스템을 만들 수 있습니다. 이러한 접근 방식은 DBA가 NFS의 특이성을 처리하지 않아도되지만 원격 스토리지 관리의 복잡성은 다른 수준에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4cdce5fe180ac016fd38728542336a4cccb6659d" translate="yes" xml:space="preserve">
          <source>In some cases, queries with visibly different texts might get merged into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry. Normally this will happen only for semantically equivalent queries, but there is a small chance of hash collisions causing unrelated queries to be merged into one entry. (This cannot happen for queries belonging to different users or databases, however.)</source>
          <target state="translated">경우에 따라 텍스트가 다른 쿼리는 단일 &lt;code&gt;pg_stat_statements&lt;/code&gt; 항목 으로 병합 될 수 있습니다 . 일반적으로 이는 의미 적으로 동등한 쿼리에 대해서만 발생하지만 해시 충돌로 인해 관련없는 쿼리가 하나의 항목으로 병합 될 가능성이 적습니다. 그러나 다른 사용자 나 데이터베이스에 속한 쿼리에는이 문제가 발생할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3587765c2705ba8328ac5e625d50c99ae816e4fe" translate="yes" xml:space="preserve">
          <source>In some contexts it is important to be sure that row security is not being applied. For example, when taking a backup, it could be disastrous if row security silently caused some rows to be omitted from the backup. In such a situation, you can set the &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; configuration parameter to &lt;code&gt;off&lt;/code&gt;. This does not in itself bypass row security; what it does is throw an error if any query's results would get filtered by a policy. The reason for the error can then be investigated and fixed.</source>
          <target state="translated">일부 상황에서는 행 보안이 적용되지 않는 것이 중요합니다. 예를 들어, 백업을 수행 할 때 행 보안으로 인해 일부 행이 백업에서 생략 된 경우 비참 할 수 있습니다. 이러한 상황에서는 &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; 구성 매개 변수를 &lt;code&gt;off&lt;/code&gt; 로 설정할 수 있습니다 . 이것은 그 자체로는 행 보안을 우회하지 않습니다. 쿼리 결과가 정책에 의해 필터링되면 오류가 발생합니다. 그런 다음 오류의 원인을 조사하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ce77934cf9885a03a2ac3b7887461d3a1cb010" translate="yes" xml:space="preserve">
          <source>In some contexts, backslashes must be doubled compared to what is shown above, because the generic string-literal parser will also reduce pairs of backslashes to one data character; see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;.</source>
          <target state="translated">일부 문맥에서, 일반 문자열 리터럴 파서는 백 슬래시 쌍을 하나의 데이터 문자로 줄이기 때문에 백 슬래시는 위에 표시된 것과 비교하여 두 배가되어야합니다. &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;섹션 4.1.2.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="ad2914b6fce7d3aa951198848f0bae1a566122fb" translate="yes" xml:space="preserve">
          <source>In some query plans, it is possible for a subplan node to be executed more than once. For example, the inner index scan will be executed once per outer row in the above nested-loop plan. In such cases, the &lt;code&gt;loops&lt;/code&gt; value reports the total number of executions of the node, and the actual time and rows values shown are averages per-execution. This is done to make the numbers comparable with the way that the cost estimates are shown. Multiply by the &lt;code&gt;loops&lt;/code&gt; value to get the total time actually spent in the node. In the above example, we spent a total of 0.220 milliseconds executing the index scans on &lt;code&gt;tenk2&lt;/code&gt;.</source>
          <target state="translated">일부 쿼리 계획에서는 하위 계획 노드가 두 번 이상 실행될 수 있습니다. 예를 들어, 내부 인덱스 스캔은 위의 중첩 루프 계획에서 외부 행당 한 번 실행됩니다. 이러한 경우 &lt;code&gt;loops&lt;/code&gt; 값은 노드의 총 실행 수를보고하며 표시된 실제 시간 및 행 값은 실행 당 평균입니다. 이것은 비용 추정치가 표시되는 방식과 숫자를 비교하기 위해 수행됩니다. &lt;code&gt;loops&lt;/code&gt; 값을 곱하면 실제로 노드에서 보낸 총 시간을 얻을 수 있습니다. 위의 예에서 &lt;code&gt;tenk2&lt;/code&gt; 에서 인덱스 스캔을 실행하는 데 총 0.220 밀리 초가 소요 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="225981494667f7eae039a8f3a624ead9ac2ba414" translate="yes" xml:space="preserve">
          <source>In some situations it is worthwhile to rebuild indexes periodically with the &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; command or a series of individual rebuilding steps.</source>
          <target state="translated">경우에 따라 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; 명령 또는 일련의 개별 재 구축 단계를 사용하여 정기적으로 색인을 재 구축하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e0f45ec00183e0785ecaf537d621d39641ace7" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">경우에 따라 쿼리를 실행할 수있는 각 가능한 방법을 검사하면 시간과 메모리 공간이 지나치게 많이 걸립니다. 특히 많은 조인 작업과 관련된 쿼리를 실행할 때 발생합니다. 합리적인 시간 내에 합리적인 (최상의 최적은 아님) 쿼리 계획을 결정하기 위해 PostgreSQL은 조인 수가 임계 값을 초과 할 때 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;제 59 장&lt;/a&gt; 참조) &lt;em&gt;Genetic Query Optimizer를&lt;/em&gt; 사용합니다 ( &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="02656e92c47f92204fc3dc37bed1c7e28f95de50" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">경우에 따라 쿼리를 실행할 수있는 가능한 각 방법을 검사하는 데 시간과 메모리 공간이 너무 많이 소요됩니다. 특히 이것은 많은 수의 조인 작업이 포함 된 쿼리를 실행할 때 발생합니다. 합리적인 시간 내에 합리적인 (반드시 최적 일 필요는 아님) 쿼리 계획을 결정하기 위해 PostgreSQL은 조인 수가 임계 값을 초과 할 때 &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; ( &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;59 장&lt;/a&gt; 참조 )를 사용합니다 ( &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b44a40fdd52559ad494c2c8c248a6de473d41182" translate="yes" xml:space="preserve">
          <source>In standby mode, the server continuously applies WAL received from the master server. The standby server can read WAL from a WAL archive (see &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;) or directly from the master over a TCP connection (streaming replication). The standby server will also attempt to restore any WAL found in the standby cluster's &lt;code&gt;pg_wal&lt;/code&gt; directory. That typically happens after a server restart, when the standby replays again WAL that was streamed from the master before the restart, but you can also manually copy files to &lt;code&gt;pg_wal&lt;/code&gt; at any time to have them replayed.</source>
          <target state="translated">대기 모드에서 서버는 마스터 서버로부터받은 WAL을 지속적으로 적용합니다. 대기 서버는 WAL 아카이브 ( &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 참조 )에서 또는 TCP 연결을 통해 마스터에서 직접 WAL을 읽을 수 있습니다 (스트리밍 복제). 대기 서버는 또한 대기 클러스터의 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리 에있는 모든 WAL을 복원하려고 시도합니다 . 일반적으로 서버를 다시 시작한 후 대기가 다시 시작하기 전에 마스터에서 스트리밍 된 WAL을 다시 재생할 때 발생하지만 언제든지 수동으로 파일을 &lt;code&gt;pg_wal&lt;/code&gt; 에 복사 하여 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe531d3ac4f289af249052c7bd344a8eccac974a" translate="yes" xml:space="preserve">
          <source>In strict SQL, &lt;code&gt;GROUP BY&lt;/code&gt; can only group by columns of the source table but PostgreSQL extends this to also allow &lt;code&gt;GROUP BY&lt;/code&gt; to group by columns in the select list. Grouping by value expressions instead of simple column names is also allowed.</source>
          <target state="translated">엄격한 SQL에서 &lt;code&gt;GROUP BY&lt;/code&gt; 는 소스 테이블의 열을 기준으로 만 그룹화 할 수 있지만 PostgreSQL은이를 확장하여 &lt;code&gt;GROUP BY&lt;/code&gt; 가 선택 목록의 열을 기준으로 그룹화 할 수도 있습니다 . 간단한 열 이름 대신 값 표현식으로 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="925d63461b4ad93eaf09cda8debcd8a2f6185160" translate="yes" xml:space="preserve">
          <source>In such a column, all entries must use the symbolic format except when writing &lt;code&gt;0&lt;/code&gt; for InvalidOid. (If the column is declared &lt;code&gt;regproc&lt;/code&gt;, you can optionally write &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;.) &lt;code&gt;genbki.pl&lt;/code&gt; will warn about unrecognized names.</source>
          <target state="translated">이러한 열에서 InvalidOid에 &lt;code&gt;0&lt;/code&gt; 을 쓸 때를 제외하고 모든 항목은 기호 형식을 사용해야 합니다. (열이 선언되면 &lt;code&gt;regproc&lt;/code&gt; 를 , 선택적으로 쓸 수 있습니다 &lt;code&gt;-&lt;/code&gt; 대신 &lt;code&gt;0&lt;/code&gt; .) &lt;code&gt;genbki.pl&lt;/code&gt; 가 인식 할 수없는 이름에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="f44470ab677292f080ad629e5021dd422bb50329" translate="yes" xml:space="preserve">
          <source>In synchronous multimaster replication, each server can accept write requests, and modified data is transmitted from the original server to every other server before each transaction commits. Heavy write activity can cause excessive locking and commit delays, leading to poor performance. Read requests can be sent to any server. Some implementations use shared disk to reduce the communication overhead. Synchronous multimaster replication is best for mostly read workloads, though its big advantage is that any server can accept write requests &amp;mdash; there is no need to partition workloads between master and standby servers, and because the data changes are sent from one server to another, there is no problem with non-deterministic functions like &lt;code&gt;random()&lt;/code&gt;.</source>
          <target state="translated">동기식 다중 마스터 복제에서 각 서버는 쓰기 요청을 수락 할 수 있으며 수정 된 데이터는 각 트랜잭션이 커밋되기 전에 원본 서버에서 다른 모든 서버로 전송됩니다. 쓰기 작업이 많으면 과도한 잠금 및 커밋 지연이 발생하여 성능이 저하 될 수 있습니다. 읽기 요청은 모든 서버로 보낼 수 있습니다. 일부 구현에서는 공유 디스크를 사용하여 통신 오버 헤드를 줄입니다. 동기식 멀티 마스터 복제는 대부분의 읽기 워크로드에 가장 적합하지만 모든 서버가 쓰기 요청을 수락 할 수 있다는 장점이 있습니다. 마스터 서버와 대기 서버간에 워크로드를 분할 할 필요가 없으며 데이터 변경이 한 서버에서 다른 서버로 전송되기 때문입니다. &lt;code&gt;random()&lt;/code&gt; 과 같은 비 결정적 함수에는 문제가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7c4b878fdf07a28c13f143cacc8a5bb3f8880019" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.affix&lt;/code&gt; file every affix flag is described in the following format:</source>
          <target state="translated">에서 &lt;code&gt;.affix&lt;/code&gt; 의 파일마다 접사 플래그는 다음과 같은 형식으로 설명되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="08a1ad04eb220026fbfc94b398836d4cbc2cae8c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame options, the &lt;code&gt;offset&lt;/code&gt; must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the &lt;code&gt;offset&lt;/code&gt; depends on the frame mode:</source>
          <target state="translated">에서 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; 프레임 옵션의 &lt;code&gt;offset&lt;/code&gt; 모든 변수 집합 함수 또는 윈도우 함수를 함유하지 않은 식이어야한다. &lt;code&gt;offset&lt;/code&gt; 의 의미 는 프레임 모드에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="27bf78dd19410e50d81449e21eeb4a9c340ecbaa" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;prepared&lt;/code&gt; mode, pgbench reuses the parse analysis result starting from the second query iteration, so pgbench runs faster than in other modes.</source>
          <target state="translated">에서 &lt;code&gt;prepared&lt;/code&gt; 모드, pgbench 그렇게 pgbench 빠르게 실행 다른 모드에 비해, 두 번째 쿼리의 반복에서 시작하는 구문 분석 분석 결과를 다시 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7dd20a44a8914e7e3854e6b8cc2dd765d950b1b2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;template0&lt;/code&gt; database, it could be useful to create collations whose encoding does not match the database encoding, since they could match the encodings of databases later cloned from &lt;code&gt;template0&lt;/code&gt;. This would currently have to be done manually.</source>
          <target state="translated">에서 &lt;code&gt;template0&lt;/code&gt; 의 그들이 나중에에서 복제 된 데이터베이스의 인코딩과 일치 할 수 있기 때문에 데이터베이스, 누구의 인코딩 데이터베이스 인코딩과 일치하지 않는 데이터 정렬을 만드는 데 유용 할 수 &lt;code&gt;template0&lt;/code&gt; 를 . 이 작업은 현재 수동으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee7442c19df868ba3ec76972f6eb3be85838007a" translate="yes" xml:space="preserve">
          <source>In the ISO week-numbering system, it is possible for early-January dates to be part of the 52nd or 53rd week of the previous year, and for late-December dates to be part of the first week of the next year. For example, &lt;code&gt;2005-01-01&lt;/code&gt; is part of the 53rd week of year 2004, and &lt;code&gt;2006-01-01&lt;/code&gt; is part of the 52nd week of year 2005, while &lt;code&gt;2012-12-31&lt;/code&gt; is part of the first week of 2013. It's recommended to use the &lt;code&gt;isoyear&lt;/code&gt; field together with &lt;code&gt;week&lt;/code&gt; to get consistent results.</source>
          <target state="translated">ISO 주 번호 매기기 시스템에서 1 월 초 날짜는 전년도 52 주 또는 53 주에 속하고 12 월 말 날짜는 내년 첫 주에 속할 수 있습니다. 예를 들어 &lt;code&gt;2005-01-01&lt;/code&gt; 은 2004 년 53 번째 주에 속하고 &lt;code&gt;2006-01-01&lt;/code&gt; 은 2005 년 52 주에 속하고 &lt;code&gt;2012-12-31&lt;/code&gt; 은 2013 년 첫 주에 속합니다. 일관된 결과를 얻으려면 &lt;code&gt;isoyear&lt;/code&gt; 필드를 &lt;code&gt;week&lt;/code&gt; 와 함께 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e2cd521bd47287d9192e9d5c00cd5e2a6b143afe" translate="yes" xml:space="preserve">
          <source>In the PostgreSQL parser life is a bit more complicated. There are several different classes of tokens ranging from those that can never be used as an identifier to those that have absolutely no special status in the parser as compared to an ordinary identifier. (The latter is usually the case for functions specified by SQL.) Even reserved key words are not completely reserved in PostgreSQL, but can be used as column labels (for example, &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt;, even though &lt;code&gt;CHECK&lt;/code&gt; is a reserved key word).</source>
          <target state="translated">PostgreSQL 파서 수명은 조금 더 복잡합니다. 식별자로 사용할 수없는 토큰부터 일반 식별자와 비교할 때 파서에서 특별한 상태가없는 토큰에 이르기까지 여러 종류의 토큰이 있습니다. (후자는 일반적으로 SQL로 지정된 함수의 경우입니다.) 예약 된 키워드조차도 PostgreSQL에서 완전히 예약되지 않았지만 열 레이블로 사용될 수 있습니다 (예 : &lt;code&gt;CHECK&lt;/code&gt; 가 예약 된 키워드 임에도 불구하고 &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt; ). .</target>
        </trans-unit>
        <trans-unit id="c06a771ae535ebcc1c02437d6d6edcaa369ff63e" translate="yes" xml:space="preserve">
          <source>In the SQL and POSTGRES styles, day appears before month if DMY field ordering has been specified, otherwise month appears before day. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;Section 8.5.1&lt;/a&gt; for how this setting also affects interpretation of input values.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;Table 8.15&lt;/a&gt; shows examples.</source>
          <target state="translated">SQL 및 POSTGRES 스타일에서 DMY 필드 순서를 지정하면 월이 전날에 나타나고, 그렇지 않으면 월이 전날에 나타납니다. ( 이 설정이 입력 값 해석에 어떻게 영향을 미치는지에 대해서는 &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;8.5.1 절을&lt;/a&gt; 참조하십시오 .) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;표 8.15&lt;/a&gt; 는 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="84b70dca4dd2a2a4e41665aeb47157cc98221d20" translate="yes" xml:space="preserve">
          <source>In the SQL standard, sequences only have a &lt;code&gt;USAGE&lt;/code&gt; privilege, which controls the use of the &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression, which is equivalent to the function &lt;code&gt;nextval&lt;/code&gt; in PostgreSQL. The sequence privileges &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; are PostgreSQL extensions. The application of the sequence &lt;code&gt;USAGE&lt;/code&gt; privilege to the &lt;code&gt;currval&lt;/code&gt; function is also a PostgreSQL extension (as is the function itself).</source>
          <target state="translated">SQL 표준에서 시퀀스에는 &lt;code&gt;USAGE&lt;/code&gt; 권한 만 있으며 이는 PostgreSQL의 &lt;code&gt;nextval&lt;/code&gt; 함수와 동일한 &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 표현식 의 사용을 제어합니다 . &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 시퀀스 권한 은 PostgreSQL 확장입니다. &lt;code&gt;currval&lt;/code&gt; 함수에 시퀀스 &lt;code&gt;USAGE&lt;/code&gt; 권한을 적용하는 것도 PostgreSQL 확장입니다 (함수 자체도 마찬가지 임).</target>
        </trans-unit>
        <trans-unit id="fcd4626eefede972e087ae6e07462757a1b0e1ce" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the &lt;code&gt;xmlexists&lt;/code&gt; function evaluates an expression in the XML Query language, but PostgreSQL allows only an XPath 1.0 expression, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="translated">SQL 표준에서 &lt;code&gt;xmlexists&lt;/code&gt; 함수는 XML 쿼리 언어의 표현식을 평가하지만 PostgreSQL은 &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;섹션 D.3.1&lt;/a&gt; 에서 설명한대로 XPath 1.0 표현식 만 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="58d7a869224d4569093b25b6e2276773eb285b56" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the &lt;code&gt;xmltable&lt;/code&gt; function evaluates expressions in the XML Query language, but PostgreSQL allows only XPath 1.0 expressions, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="translated">SQL 표준에서 &lt;code&gt;xmltable&lt;/code&gt; 함수는 XML 쿼리 언어의 표현식을 평가하지만 PostgreSQL은 &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;섹션 D.3.1&lt;/a&gt; 에서 설명한대로 XPath 1.0 표현식 만 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="9660d94d0a1b58a81d974d699a1bce336010b697" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of &lt;code&gt;user_name.table_name&lt;/code&gt;. This is how PostgreSQL will effectively behave if you create a per-user schema for every user.</source>
          <target state="translated">SQL 표준에는 다른 사용자가 소유 한 동일한 스키마의 오브젝트 개념이 존재하지 않습니다. 또한 일부 구현에서는 소유자와 이름이 다른 스키마를 만들 수 없습니다. 실제로 스키마와 사용자의 개념은 표준에 지정된 기본 스키마 지원 만 구현하는 데이터베이스 시스템에서 거의 동일합니다. 따라서 많은 사용자는 규정 된 이름이 실제로 &lt;code&gt;user_name.table_name&lt;/code&gt; 으로 구성되는 것으로 간주 합니다. 모든 사용자에 대해 사용자 별 스키마를 생성 할 경우 PostgreSQL이 효과적으로 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="bce55523e60490fd9a9b255e77d45bae3da990ba" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the optional key word &lt;code&gt;AS&lt;/code&gt; can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword). PostgreSQL is slightly more restrictive: &lt;code&gt;AS&lt;/code&gt; is required if the new column name matches any keyword at all, reserved or not. Recommended practice is to use &lt;code&gt;AS&lt;/code&gt; or double-quote output column names, to prevent any possible conflict against future keyword additions.</source>
          <target state="translated">SQL 표준에서, 선택적 컬럼 단어 &lt;code&gt;AS&lt;/code&gt; 는 새 컬럼 이름이 유효한 컬럼 이름 (즉, 예약 된 키워드와 동일하지 않음) 일 때마다 출력 컬럼 이름 앞에 생략 될 수 있습니다. PostgreSQL은 약간 더 제한적입니다. 새 열 이름이 키워드와 일치하거나 예약 여부에 관계없이 &lt;code&gt;AS&lt;/code&gt; 가 필요합니다. 향후 키워드 추가와의 충돌 가능성을 방지 하기 위해 &lt;code&gt;AS&lt;/code&gt; 또는 큰 따옴표 출력 열 이름을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60fb33ea7714daeb182a1d8cf938445a4efd08dd" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is a clear distinction between users and roles, and users do not automatically inherit privileges while roles do. This behavior can be obtained in PostgreSQL by giving roles being used as SQL roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, while giving roles being used as SQL users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. However, PostgreSQL defaults to giving all roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, for backward compatibility with pre-8.1 releases in which users always had use of permissions granted to groups they were members of.</source>
          <target state="translated">SQL 표준에는 사용자와 역할이 명확하게 구분되어 있으며 사용자는 역할을 수행하는 동안 자동으로 권한을 상속하지 않습니다. 이 동작은 SQL 역할로 사용되는 역할을 &lt;code&gt;INHERIT&lt;/code&gt; 속성으로 제공하고 SQL 사용자로 사용되는 역할은 &lt;code&gt;NOINHERIT&lt;/code&gt; 속성 으로 제공하여 PostgreSQL에서 얻을 수 있습니다 . 그러나 PostgreSQL은 기본적으로 모든 역할에 &lt;code&gt;INHERIT&lt;/code&gt; 속성을 부여하여 사용자가 항상 소속 그룹에 부여 된 권한을 사용하는 8.1 이전 버전과의 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4d55ecfda5316639c09ff6bb19e9602eb2f98338" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is one other transaction characteristic that can be set with these commands: the size of the diagnostics area. This concept is specific to embedded SQL, and therefore is not implemented in the PostgreSQL server.</source>
          <target state="translated">SQL 표준에는 진단 영역의 크기와 같은 명령으로 설정할 수있는 다른 트랜잭션 특성이 있습니다. 이 개념은 내장 SQL에만 적용되므로 PostgreSQL 서버에서는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed36ad7d98cb4d8fee32b855fb6fed744837b0e0" translate="yes" xml:space="preserve">
          <source>In the SQL-92 standard, an &lt;code&gt;ORDER BY&lt;/code&gt; clause can only use output column names or numbers, while a &lt;code&gt;GROUP BY&lt;/code&gt; clause can only use expressions based on input column names. PostgreSQL extends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity). PostgreSQL also allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.</source>
          <target state="translated">SQL-92 표준에서 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 출력 열 이름 또는 숫자 만 사용할 수 있는 반면 &lt;code&gt;GROUP BY&lt;/code&gt; 절은 입력 열 이름을 기반으로하는 표현식 만 사용할 수 있습니다. PostgreSQL은 이러한 각 절을 확장하여 다른 선택도 허용합니다 (그러나 모호한 경우 표준 해석을 사용합니다). PostgreSQL을 사용하면 두 절 모두에서 임의의 표현식을 지정할 수 있습니다. 식에 나타나는 이름은 항상 출력 열 이름이 아니라 입력 열 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b054bfec2bce610e705197d361e44d3c2768bb83" translate="yes" xml:space="preserve">
          <source>In the XQuery/XPath data model, a &lt;em&gt;document node&lt;/em&gt; can have either document form (i.e., exactly one top-level element, with only comments and processing instructions outside of it) or content form (with those constraints relaxed). Its equivalent in XPath 1.0, the &lt;em&gt;root node&lt;/em&gt;, can only be in document form. This is part of the reason an &lt;code&gt;xml&lt;/code&gt; value passed as the context item to any PostgreSQL XPath-based function must be in document form.</source>
          <target state="translated">XQuery / XPath 데이터 모델에서 &lt;em&gt;문서 노드&lt;/em&gt; 는 문서 형식 (즉, 주석과 처리 명령 만있는 최상위 요소 하나만 포함) 또는 콘텐츠 형식 (제약 조건이 완화 된)을 가질 수 있습니다. &lt;em&gt;루트 노드&lt;/em&gt; 인 XPath 1.0과 동일하며 문서 형식 만 가능합니다. 이는 PostgreSQL XPath 기반 함수에 컨텍스트 항목으로 전달 된 &lt;code&gt;xml&lt;/code&gt; 값이 문서 형식이어야 하는 이유 중 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="907c04147bb1d71b5f0459b5e753db080d794777" translate="yes" xml:space="preserve">
          <source>In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">위의 예에서는 매월 새 파티션을 작성하므로 필요한 DDL을 자동으로 생성하는 스크립트를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="652407089ebdeac3fe06a048bf54ac1385a35fc9" translate="yes" xml:space="preserve">
          <source>In the above example, the new password isn't actually echoed when typed, but we show what was typed for clarity. As you see, the password is encrypted before it is sent to the client.</source>
          <target state="translated">위의 예에서 입력 할 때 새 비밀번호는 실제로 에코되지 않지만 명확성을 위해 입력 된 비밀번호를 보여줍니다. 보시다시피, 암호는 클라이언트로 전송되기 전에 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="a28671e837ffe13c54dd539a74a6f7de604de65e" translate="yes" xml:space="preserve">
          <source>In the above output, the free space figures may not match the &lt;code&gt;pgstattuple&lt;/code&gt; output exactly, because the free space map gives us an exact figure, but is not guaranteed to be accurate to the byte.</source>
          <target state="translated">위의 출력 에서 사용 가능한 공간 맵은 정확한 그림을 제공하지만 바이트에 대해서는 정확하지 않기 때문에 &lt;code&gt;pgstattuple&lt;/code&gt; 출력과 정확하게 일치 하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfee998fb713aa32e0b0a461f86fb14fa87aa018" translate="yes" xml:space="preserve">
          <source>In the above queries, the second form is dangerous because the &lt;code&gt;LIMIT&lt;/code&gt; is not guaranteed to be applied before the locking function is executed. This might cause some locks to be acquired that the application was not expecting, and hence would fail to release (until it ends the session). From the point of view of the application, such locks would be dangling, although still viewable in &lt;code&gt;pg_locks&lt;/code&gt;.</source>
          <target state="translated">위의 쿼리에서 두 번째 형식은 잠금 기능이 실행되기 전에 &lt;code&gt;LIMIT&lt;/code&gt; 가 적용되지 않을 수 있으므로 위험합니다 . 이로 인해 응용 프로그램이 예상하지 못했던 일부 잠금이 획득되어 세션이 종료 될 때까지 해제되지 않을 수 있습니다. 응용 프로그램의 관점에서 볼 때 이러한 잠금은 &lt;code&gt;pg_locks&lt;/code&gt; 에서 여전히 볼 수 있지만 매달려 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0422400fe004db1267465196296a34921629ca1c" translate="yes" xml:space="preserve">
          <source>In the above query, the arguments &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are specified positionally, while &lt;code&gt;uppercase&lt;/code&gt; is specified by name. In this example, that adds little except documentation. With a more complex function having numerous parameters that have default values, named or mixed notation can save a great deal of writing and reduce chances for error.</source>
          <target state="translated">위의 쿼리에서 인수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 위치 적 으로 지정되고 &lt;code&gt;uppercase&lt;/code&gt; 는 이름으로 지정됩니다. 이 예제에서는 문서를 제외하고 거의 추가하지 않습니다. 명명 된 또는 혼합 표기법은 기본값을 갖는 수많은 매개 변수를 갖는보다 복잡한 함수를 사용하면 많은 양의 쓰기를 저장하고 오류 가능성을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523e1fdbf28526b9fd09539320b970501acbeb30" translate="yes" xml:space="preserve">
          <source>In the absence of any explicit quantifier, the default for a star symbol is to match any number of labels (that is, &lt;code&gt;{,}&lt;/code&gt;) while the default for a non-star item is to match exactly once (that is, &lt;code&gt;{1}&lt;/code&gt;).</source>
          <target state="translated">명시 적 수량자가없는 경우 별표 기호의 기본값은 모든 레이블 (즉, &lt;code&gt;{,}&lt;/code&gt; )과 일치하는 반면 별표가 아닌 항목의 기본값은 정확히 한 번 일치 (즉, &lt;code&gt;{1}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="12fe4f57925256d624bd6eb274cf2330b45da284" translate="yes" xml:space="preserve">
          <source>In the absence of fatal errors, pg_receivewal will run until terminated by the SIGINT signal (&lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;C&lt;/strong&gt;).</source>
          <target state="translated">치명적인 오류가 없으면 pg_receivewal은 SIGINT 신호 ( &lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;C&lt;/strong&gt; )에 의해 종료 될 때까지 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6c9650fa107be76e508c9f6a766e1575673cf8c" translate="yes" xml:space="preserve">
          <source>In the alternative format:</source>
          <target state="translated">다른 형식으로 :</target>
        </trans-unit>
        <trans-unit id="c2e1ceee33301b36828cf2caae1f68eec137b740" translate="yes" xml:space="preserve">
          <source>In the case of a parallel dump, the snapshot name defined by this option is used rather than taking a new snapshot.</source>
          <target state="translated">병렬 덤프의 경우이 옵션으로 정의 된 스냅 샷 이름이 새 스냅 샷을 생성하는 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a04ddae39deed0bb63ddc81c6701d5c2ad86b55" translate="yes" xml:space="preserve">
          <source>In the case of a partitioned table, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually a &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation.</source>
          <target state="translated">파티션 된 테이블의 경우 행을 업데이트하면 더 이상 포함하는 파티션의 파티션 제한 조건을 충족시키지 못할 수 있습니다. 이 경우, 파티션 트리에이 행이 파티션 제한 조건을 만족시키는 다른 파티션이 있으면 행이 해당 파티션으로 이동됩니다. 그러한 파티션이 없으면 오류가 발생합니다. 무대 뒤에서 행 이동은 실제로 &lt;code&gt;DELETE&lt;/code&gt; 및 &lt;code&gt;INSERT&lt;/code&gt; 작업입니다.</target>
        </trans-unit>
        <trans-unit id="5544906e3d293a0a9ad12a92567f1204d11f1dd6" translate="yes" xml:space="preserve">
          <source>In the case of an exclusion constraint, &lt;code&gt;conkey&lt;/code&gt; is only useful for constraint elements that are simple column references. For other cases, a zero appears in &lt;code&gt;conkey&lt;/code&gt; and the associated index must be consulted to discover the expression that is constrained. (&lt;code&gt;conkey&lt;/code&gt; thus has the same contents as &lt;code&gt;pg_index&lt;/code&gt;.&lt;code&gt;indkey&lt;/code&gt; for the index.)</source>
          <target state="translated">제외 제약 조건의 경우 &lt;code&gt;conkey&lt;/code&gt; 는 간단한 열 참조 인 제약 조건 요소에만 유용합니다. 다른 경우에는 &lt;code&gt;conkey&lt;/code&gt; 에 0이 나타나고 제한된 표현식을 찾기 위해 관련 인덱스를 참조해야합니다. ( &lt;code&gt;conkey&lt;/code&gt; 은 이와 같은 내용을 가지고 &lt;code&gt;pg_index&lt;/code&gt; . &lt;code&gt;indkey&lt;/code&gt; 인덱스를위한).</target>
        </trans-unit>
        <trans-unit id="e4fef774ebd3ff2e38db3236bd03a350ace1f35c" translate="yes" xml:space="preserve">
          <source>In the common case where you just want the whole matching substring or &lt;code&gt;NULL&lt;/code&gt; for no match, write something like</source>
          <target state="translated">전체 일치하는 부분 문자열을 원하거나 일치 하지 않는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 원하는 일반적인 경우 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d8de3d9b49ffb3cc570c884fc7d3dde953f8a262" translate="yes" xml:space="preserve">
          <source>In the context of &lt;code&gt;INSERT&lt;/code&gt;, entries of a &lt;code&gt;VALUES&lt;/code&gt; list can be &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the column default should be used here instead of specifying a value:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 컨텍스트 에서 &lt;code&gt;VALUES&lt;/code&gt; 목록의 항목을 &lt;code&gt;DEFAULT&lt;/code&gt; 로 설정하여 값을 지정하는 대신 열 기본값을 사용해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0a8a6bb89f9ea4433f27de55629e036adfed0508" translate="yes" xml:space="preserve">
          <source>In the current implementation, the fitness of each candidate join sequence is estimated by running the standard planner's join selection and cost estimation code from scratch. To the extent that different candidates use similar sub-sequences of joins, a great deal of work will be repeated. This could be made significantly faster by retaining cost estimates for sub-joins. The problem is to avoid expending unreasonable amounts of memory on retaining that state.</source>
          <target state="translated">현재 구현에서, 각 후보 조인 시퀀스의 적합성은 표준 플래너의 조인 선택 및 비용 추정 코드를 처음부터 실행함으로써 추정된다. 다른 후보들이 유사한 조인의 서브 시퀀스를 사용하는 한, 많은 작업이 반복 될 것입니다. 하위 조인에 대한 비용 추정치를 유지하여이를 훨씬 빠르게 만들 수 있습니다. 문제는 해당 상태를 유지하는 데 불합리한 메모리 양을 늘리지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b88d112fefbb18a9a94530a4a12e322eca2805d" translate="yes" xml:space="preserve">
          <source>In the default PostgreSQL configuration, the autovacuum daemon (see &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;) takes care of automatic analyzing of tables when they are first loaded with data, and as they change throughout regular operation. When autovacuum is disabled, it is a good idea to run &lt;code&gt;ANALYZE&lt;/code&gt; periodically, or just after making major changes in the contents of a table. Accurate statistics will help the planner to choose the most appropriate query plan, and thereby improve the speed of query processing. A common strategy for read-mostly databases is to run &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; once a day during a low-usage time of day. (This will not be sufficient if there is heavy update activity.)</source>
          <target state="translated">기본 PostgreSQL 구성에서 autovacuum 데몬 ( &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6&lt;/a&gt; 참조 )은 데이터가 처음로드 될 때와 정기적 인 작업에서 변경 될 때 자동으로 테이블을 분석합니다. autovacuum이 비활성화 된 경우 주기적으로 또는 테이블 내용을 크게 변경 한 직후에 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하는 것이 좋습니다 . 정확한 통계는 플래너가 가장 적합한 쿼리 계획을 선택하여 쿼리 처리 속도를 향상시키는 데 도움이됩니다. 읽기 전용 데이터베이스의 일반적인 전략은 사용량이 적은 시간대에 하루에 한 번 &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 및 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행 하는 것입니다. (업데이트 활동이 많은 경우에는 충분하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="4ce2b63a8b5343bbf7125e0114e2a04ce0d2bde8" translate="yes" xml:space="preserve">
          <source>In the default setup this returns:</source>
          <target state="translated">기본 설정에서 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="596bcd2b70e5eeabccdcbaf0d79d2c517c798e21" translate="yes" xml:space="preserve">
          <source>In the event of a binary upgrade, upward compatibility is maintained by having the new code recognize old-format data. This will entail a slight performance penalty when processing data that has not yet been modified by the new code. It is possible to force an upgrade of all values in a table column by doing an &lt;code&gt;UPDATE&lt;/code&gt; statement as follows:</source>
          <target state="translated">이진 업그레이드의 경우 새 코드가 이전 형식의 데이터를 인식하도록하여 호환성이 유지됩니다. 새 코드로 아직 수정되지 않은 데이터를 처리 할 때 약간의 성능 저하가 발생합니다. 다음과 같이 &lt;code&gt;UPDATE&lt;/code&gt; 문을 수행하여 테이블 열의 모든 값을 강제로 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a7ad5f630b85b752ae07e66abff996aa3b1a24" translate="yes" xml:space="preserve">
          <source>In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, either the longest possible match or the shortest possible match will be taken, depending on whether the RE is &lt;em&gt;greedy&lt;/em&gt; or &lt;em&gt;non-greedy&lt;/em&gt;.</source>
          <target state="translated">RE가 지정된 문자열의 둘 이상의 하위 문자열과 일치 할 수있는 경우 RE는 문자열에서 가장 빠른 시작과 일치합니다. 재생 에너지는, 그 시점에서 시작하는 하위 문자열 하나보다 더 일치 할 수 있다면 가장 긴 일치 또는 최단 경기 중 하나는 RE인지 여부에 따라 이동합니다 &lt;em&gt;욕심&lt;/em&gt; 또는 &lt;em&gt;비 욕심&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="474b9960977cbbea61dc4ac5b333f0b736c6264c" translate="yes" xml:space="preserve">
          <source>In the example above we see that the resulting &lt;code&gt;tsvector&lt;/code&gt; does not contain the words &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, or &lt;code&gt;it&lt;/code&gt;, the word &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt;, and the punctuation sign &lt;code&gt;-&lt;/code&gt; was ignored.</source>
          <target state="translated">이 예에서 우리는 결과로 볼 위에 &lt;code&gt;tsvector&lt;/code&gt; 이 단어가 포함되어 있지 않습니다 , &lt;code&gt;on&lt;/code&gt; , 또는 &lt;code&gt;it&lt;/code&gt; 단어의 &lt;code&gt;rats&lt;/code&gt; 되었다 &lt;code&gt;rat&lt;/code&gt; 와 문장 부호 &lt;code&gt;-&lt;/code&gt; 무시되었다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="200ce56337643046a5aa2dd5558bb50f57584421" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;WHERE&lt;/code&gt; clause is selecting rows by a column that is not grouped (the expression is only true for sales during the last four weeks), while the &lt;code&gt;HAVING&lt;/code&gt; clause restricts the output to groups with total gross sales over 5000. Note that the aggregate expressions do not necessarily need to be the same in all parts of the query.</source>
          <target state="translated">위의 예에서 &lt;code&gt;WHERE&lt;/code&gt; 절은 그룹화되지 않은 열 (행은 지난 4 주 동안의 판매에만 해당됨)로 행을 선택하는 반면 &lt;code&gt;HAVING&lt;/code&gt; 절은 총 총 판매액이 5000을 초과하는 그룹으로 출력을 제한합니다. 집계 표현식이 쿼리의 모든 부분에서 반드시 동일 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="31c0dc4f6c95bec1ccb804da7ba6806c38ecea92" translate="yes" xml:space="preserve">
          <source>In the example above, the working table has just a single row in each step, and it takes on the values from 1 through 100 in successive steps. In the 100th step, there is no output because of the &lt;code&gt;WHERE&lt;/code&gt; clause, and so the query terminates.</source>
          <target state="translated">위의 예에서 작업 테이블은 각 단계마다 단일 행을 가지며 연속 단계에서 1에서 100 사이의 값을 취합니다. 100 번째 단계에서는 &lt;code&gt;WHERE&lt;/code&gt; 절로 인해 출력이 없으므로 쿼리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="652a8b18a910fe23a9af73c94ce5d441558f1e6b" translate="yes" xml:space="preserve">
          <source>In the examples above, the parser sees an integer array on one side of the concatenation operator, and a constant of undetermined type on the other. The heuristic it uses to resolve the constant's type is to assume it's of the same type as the operator's other input &amp;mdash; in this case, integer array. So the concatenation operator is presumed to represent &lt;code&gt;array_cat&lt;/code&gt;, not &lt;code&gt;array_append&lt;/code&gt;. When that's the wrong choice, it could be fixed by casting the constant to the array's element type; but explicit use of &lt;code&gt;array_append&lt;/code&gt; might be a preferable solution.</source>
          <target state="translated">위의 예에서 파서는 연결 연산자의 한쪽에 정수 배열이 있고 다른쪽에는 결정되지 않은 상수가 있습니다. 상수 유형을 확인하는 데 사용하는 휴리스틱은 연산자의 다른 입력 (이 경우 정수 배열)과 동일한 유형이라고 가정합니다. 따라서 연결 연산자는 &lt;code&gt;array_cat&lt;/code&gt; 가 아닌 &lt;code&gt;array_append&lt;/code&gt; 를 나타내는 것으로 간주됩니다 . 이것이 잘못된 선택 일 경우, 상수를 배열의 요소 유형으로 캐스팅하여 수정 될 수 있습니다. 그러나 &lt;code&gt;array_append&lt;/code&gt; 를 명시 적으로 사용 하는 것이 바람직한 해결책 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb28c6ea0190f478c6d1ce0ce5ab123177f2281" translate="yes" xml:space="preserve">
          <source>In the examples above, the policy expressions consider only the current values in the row to be accessed or updated. This is the simplest and best-performing case; when possible, it's best to design row security applications to work this way. If it is necessary to consult other rows or other tables to make a policy decision, that can be accomplished using sub-&lt;code&gt;SELECT&lt;/code&gt;s, or functions that contain &lt;code&gt;SELECT&lt;/code&gt;s, in the policy expressions. Be aware however that such accesses can create race conditions that could allow information leakage if care is not taken. As an example, consider the following table design:</source>
          <target state="translated">위의 예에서 정책 표현식은 행의 현재 값만 액세스하거나 업데이트 할 것으로 간주합니다. 가장 단순하고 가장 성능이 좋은 경우입니다. 가능하면 행 보안 응용 프로그램을 설계하여 이러한 방식으로 작동하는 것이 가장 좋습니다. 정책 결정을 위해 다른 행이나 다른 테이블을 참조해야하는 경우 정책 표현식에서 하위 &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;SELECT&lt;/code&gt; 가 포함 된 함수를 사용하여 수행 할 수 있습니다 . 그러나 그러한 액세스는주의를 기울이지 않으면 정보 유출을 허용 할 수있는 경쟁 조건을 만들 수 있습니다. 예를 들어, 다음 테이블 디자인을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2808c388963b5d35c9a7c014fc0aef8465d89479" translate="yes" xml:space="preserve">
          <source>In the examples that follow, we assume that you have created a database named &lt;code&gt;mydb&lt;/code&gt;, as described in the previous chapter, and have been able to start psql.</source>
          <target state="translated">다음 예 에서는 이전 장에서 설명한대로 &lt;code&gt;mydb&lt;/code&gt; 라는 데이터베이스를 작성했으며 psql을 시작할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="4bb59306b891fbea63056e89cb36560d344851b8" translate="yes" xml:space="preserve">
          <source>In the first case, the RE as a whole is greedy because &lt;code&gt;Y*&lt;/code&gt; is greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the longest possible string starting there, i.e., &lt;code&gt;Y123&lt;/code&gt;. The output is the parenthesized part of that, or &lt;code&gt;123&lt;/code&gt;. In the second case, the RE as a whole is non-greedy because &lt;code&gt;Y*?&lt;/code&gt; is non-greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the shortest possible string starting there, i.e., &lt;code&gt;Y1&lt;/code&gt;. The subexpression &lt;code&gt;[0-9]{1,3}&lt;/code&gt; is greedy but it cannot change the decision as to the overall match length; so it is forced to match just &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">첫 번째 경우, &lt;code&gt;Y*&lt;/code&gt; 가 탐욕 스럽기 때문에 RE 전체가 탐욕 스럽다. &lt;code&gt;Y&lt;/code&gt; 에서 시작하여 일치 할 수 있으며 &lt;code&gt;Y123&lt;/code&gt; 에서 시작하는 가장 긴 문자열과 일치합니다 . 출력은 괄호로 묶은 부분 또는 &lt;code&gt;123&lt;/code&gt; 입니다. 두 번째 경우, 전체 RE는 &lt;code&gt;Y*?&lt;/code&gt; 욕심이 없습니다. &lt;code&gt;Y&lt;/code&gt; 에서 시작하여 일치 할 수 있으며 &lt;code&gt;Y1&lt;/code&gt; 에서 시작하는 가장 짧은 문자열과 일치합니다 . 하위 식 &lt;code&gt;[0-9]{1,3}&lt;/code&gt; 은 욕심이 많지만 전체 일치 길이에 대한 결정을 변경할 수는 없습니다. 따라서 &lt;code&gt;1&lt;/code&gt; 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0afff82ca92cc5d65344944313d08b5825c3e875" translate="yes" xml:space="preserve">
          <source>In the first place, &lt;em&gt;never&lt;/em&gt; believe any test that runs for only a few seconds. Use the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-T&lt;/code&gt; option to make the run last at least a few minutes, so as to average out noise. In some cases you could need hours to get numbers that are reproducible. It's a good idea to try the test run a few times, to find out if your numbers are reproducible or not.</source>
          <target state="translated">우선, 몇 초 동안 만 실행되는 테스트는 &lt;em&gt;절대&lt;/em&gt; 믿지 &lt;em&gt;마십시오&lt;/em&gt; . 사용 &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;-T&lt;/code&gt; 그래서 평균 출력 잡음으로, 마지막으로 적어도 몇 분 실행할 수 있도록하는 옵션을 선택합니다. 어떤 경우에는 재현 가능한 숫자를 얻기 위해 몇 시간이 필요할 수 있습니다. 테스트 실행을 몇 번 시도하여 숫자를 재현 할 수 있는지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d312d02ebaa05f528de247ffd592135c96644932" translate="yes" xml:space="preserve">
          <source>In the first string, the set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt;. In the second string, the ordered set of trigrams is &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;. The most similar extent of an ordered set of trigrams in the second string is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt;, and the similarity is &lt;code&gt;0.8&lt;/code&gt;.</source>
          <target state="translated">첫 번째 문자열에서 트라이 그램 세트는 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt; 입니다. 두 번째 문자열에서 순서가 지정된 trigram은 &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; . 두 번째 문자열에서 순서가 지정된 트리 그램의 가장 유사한 범위는 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt; 이고 유사성은 &lt;code&gt;0.8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56225072f8eae4ad3b64ee516719e58b357f9e0a" translate="yes" xml:space="preserve">
          <source>In the following explanation, a &lt;em&gt;byte&lt;/em&gt; is assumed to contain 8 bits. In addition, the term &lt;em&gt;item&lt;/em&gt; refers to an individual data value that is stored on a page. In a table, an item is a row; in an index, an item is an index entry.</source>
          <target state="translated">다음 설명에서 &lt;em&gt;바이트&lt;/em&gt; 는 8 비트를 포함한다고 가정합니다. 또한 &lt;em&gt;항목&lt;/em&gt; 이라는 용어 는 페이지에 저장된 개별 데이터 값을 나타냅니다. 테이블에서 항목은 행입니다. 색인에서 항목은 색인 항목입니다.</target>
        </trans-unit>
        <trans-unit id="fe808d43052245254bcdc480fec58d6c194f111b" translate="yes" xml:space="preserve">
          <source>In the following sections we will cover each of the above listed items in more detail to give a better understanding of PostgreSQL's internal control and data structures.</source>
          <target state="translated">다음 섹션에서는 PostgreSQL의 내부 제어 및 데이터 구조에 대한 이해를 돕기 위해 위에 나열된 각 항목에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f022f75654e730419aa401f110023452d899d615" translate="yes" xml:space="preserve">
          <source>In the following we describe the implementation of a &lt;em&gt;genetic algorithm&lt;/em&gt; to solve the join ordering problem in a manner that is efficient for queries involving large numbers of joins.</source>
          <target state="translated">다음에서는 많은 수의 조인을 포함하는 쿼리에 효율적인 방식으로 조인 순서 문제를 해결하기 위한 &lt;em&gt;유전자 알고리즘&lt;/em&gt; 의 구현에 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="294ebe645001a682897e9beebf5caf16a1bf1ca5" translate="yes" xml:space="preserve">
          <source>In the general case where more than one field needs to be checked to recognize a cycle, use an array of rows. For example, if we needed to compare fields &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;:</source>
          <target state="translated">사이클을 인식하기 위해 둘 이상의 필드를 점검해야하는 일반적인 경우에는 행 배열을 사용하십시오. 예를 들어, 필드 &lt;code&gt;f1&lt;/code&gt; 과 &lt;code&gt;f2&lt;/code&gt; 를 비교해야하는 경우 :</target>
        </trans-unit>
        <trans-unit id="919090babfd7b1e0453e16ae1bb909dd12feef28" translate="yes" xml:space="preserve">
          <source>In the old syntax for &lt;code&gt;CREATE AGGREGATE&lt;/code&gt;, the input data type is specified by a &lt;code&gt;basetype&lt;/code&gt; parameter rather than being written next to the aggregate name. Note that this syntax allows only one input parameter. To define a zero-argument aggregate function with this syntax, specify the &lt;code&gt;basetype&lt;/code&gt; as &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; (not &lt;code&gt;*&lt;/code&gt;). Ordered-set aggregates cannot be defined with the old syntax.</source>
          <target state="translated">&lt;code&gt;CREATE AGGREGATE&lt;/code&gt; 의 이전 구문 에서 입력 데이터 유형은 집계 이름 옆에 기록되지 않고 &lt;code&gt;basetype&lt;/code&gt; 유형 매개 변수로 지정됩니다 . 이 구문은 하나의 입력 매개 변수 만 허용합니다. 이 구문을 사용하여 &lt;code&gt;basetype&lt;/code&gt; 집계 함수를 정의하려면 기본 유형 을 &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; ( &lt;code&gt;*&lt;/code&gt; 아님) 로 지정하십시오 아님) . 정렬 된 집합은 이전 구문으로 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="405922ab6e8351d0cf2aca13f11379b1afd63c78" translate="yes" xml:space="preserve">
          <source>In the previous chapter we have covered the basics of using SQL to store and access your data in PostgreSQL. We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your data. Finally, we will look at some PostgreSQL extensions.</source>
          <target state="translated">이전 장에서는 SQL을 사용하여 PostgreSQL에서 데이터를 저장하고 액세스하는 기본 사항을 설명했습니다. 이제 관리를 단순화하고 데이터 손실 또는 손상을 방지하는 SQL의 고급 기능에 대해 설명합니다. 마지막으로 PostgreSQL 확장에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a8c0fa4c3a367177ef284ccecde1c150bc096697" translate="yes" xml:space="preserve">
          <source>In the previous example, we can apply the city name restriction in &lt;code&gt;WHERE&lt;/code&gt;, since it needs no aggregate. This is more efficient than adding the restriction to &lt;code&gt;HAVING&lt;/code&gt;, because we avoid doing the grouping and aggregate calculations for all rows that fail the &lt;code&gt;WHERE&lt;/code&gt; check.</source>
          <target state="translated">이전 예에서는 집계가 필요하지 않으므로 도시 이름 제한을 &lt;code&gt;WHERE&lt;/code&gt; 로 적용 할 수 있습니다 . &lt;code&gt;WHERE&lt;/code&gt; 검사에 실패한 모든 행에 대해 그룹화 및 집계 계산을 수행하지 않으므로 &lt;code&gt;HAVING&lt;/code&gt; 에 제한을 추가하는 것보다이 방법이 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="9f29ede0900e9fd39d495275c897cbd33557a707" translate="yes" xml:space="preserve">
          <source>In the previous sections we created tables without specifying any schema names. By default such tables (and other objects) are automatically put into a schema named &amp;ldquo;public&amp;rdquo;. Every new database contains such a schema. Thus, the following are equivalent:</source>
          <target state="translated">이전 섹션에서는 스키마 이름을 지정하지 않고 테이블을 만들었습니다. 기본적으로 이러한 테이블 (및 기타 개체)은 &quot;public&quot;이라는 스키마에 자동으로 저장됩니다. 모든 새 데이터베이스에는 이러한 스키마가 포함됩니다. 따라서 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0e8d742b91769afdfb8fcfcc89d91cd8ba42839b" translate="yes" xml:space="preserve">
          <source>In the remote sessions opened by &lt;code&gt;postgres_fdw&lt;/code&gt;, the &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; parameter is set to just &lt;code&gt;pg_catalog&lt;/code&gt;, so that only built-in objects are visible without schema qualification. This is not an issue for queries generated by &lt;code&gt;postgres_fdw&lt;/code&gt; itself, because it always supplies such qualification. However, this can pose a hazard for functions that are executed on the remote server via triggers or rules on remote tables. For example, if a remote table is actually a view, any functions used in that view will be executed with the restricted search path. It is recommended to schema-qualify all names in such functions, or else attach &lt;code&gt;SET search_path&lt;/code&gt; options (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;) to such functions to establish their expected search path environment.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 에 의해 열린 원격 세션 에서 &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; 매개 변수는 &lt;code&gt;pg_catalog&lt;/code&gt; 로 설정되어 내장 된 객체 만 스키마 검증없이 볼 수 있습니다. &lt;code&gt;postgres_fdw&lt;/code&gt; 자체에 의해 생성 된 쿼리는 항상 그러한 자격을 제공하기 때문에 문제가되지 않습니다 . 그러나 이는 원격 테이블의 트리거 또는 규칙을 통해 원격 서버에서 실행되는 기능에 위험을 초래할 수 있습니다. 예를 들어, 원격 테이블이 실제로 뷰인 경우 해당 뷰에 사용 된 모든 함수는 제한된 검색 경로로 실행됩니다. 이러한 함수에서 모든 이름을 스키마로 한정하거나 &lt;code&gt;SET search_path&lt;/code&gt; 옵션을 첨부하는 것이 좋습니다 ( &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 참조). 를 해당 함수에 하여 예상 검색 경로 환경을 설정하는 .</target>
        </trans-unit>
        <trans-unit id="251756f685410e433b657f5b30520cf41b101c14" translate="yes" xml:space="preserve">
          <source>In the same connection as before, issue the command:</source>
          <target state="translated">이전과 동일한 연결로 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9a85cd84a5c1ae886a05b3cc6a64ec7fb7c99a58" translate="yes" xml:space="preserve">
          <source>In the second form of &lt;code&gt;ALTER POLICY&lt;/code&gt;, the role list, &lt;code&gt;using_expression&lt;/code&gt;, and &lt;code&gt;check_expression&lt;/code&gt; are replaced independently if specified. When one of those clauses is omitted, the corresponding part of the policy is unchanged.</source>
          <target state="translated">&lt;code&gt;ALTER POLICY&lt;/code&gt; 의 두 번째 양식 에서 역할 목록, &lt;code&gt;using_expression&lt;/code&gt; 및 &lt;code&gt;check_expression&lt;/code&gt; 은 지정된 경우 독립적으로 바뀝니다. 이러한 조항 중 하나가 생략되면 정책의 해당 부분이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c142401003467ed2967cc5251153e2a0bab24fa" translate="yes" xml:space="preserve">
          <source>In the second mode, which we will call the search+bind mode, the server first binds to the LDAP directory with a fixed user name and password, specified with &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt;, and performs a search for the user trying to log in to the database. If no user and password is configured, an anonymous bind will be attempted to the directory. The search will be performed over the subtree at &lt;code&gt;ldapbasedn&lt;/code&gt;, and will try to do an exact match of the attribute specified in &lt;code&gt;ldapsearchattribute&lt;/code&gt;. Once the user has been found in this search, the server disconnects and re-binds to the directory as this user, using the password specified by the client, to verify that the login is correct. This mode is the same as that used by LDAP authentication schemes in other software, such as Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; and &lt;code&gt;pam_ldap&lt;/code&gt;. This method allows for significantly more flexibility in where the user objects are located in the directory, but will cause two separate connections to the LDAP server to be made.</source>
          <target state="translated">검색 + 바인드 모드를 호출하는 두 번째 모드에서 서버는 먼저 &lt;code&gt;ldapbinddn&lt;/code&gt; 및 &lt;code&gt;ldapbindpasswd&lt;/code&gt; 로 지정된 고정 사용자 이름 및 비밀번호를 사용하여 LDAP 디렉토리에 바인드 하고 로그인하려는 사용자를 검색합니다. 데이터 베이스. 사용자 및 비밀번호가 구성되지 않은 경우 디렉토리에 대한 익명 바인드가 시도됩니다. 검색은 &lt;code&gt;ldapbasedn&lt;/code&gt; 의 서브 트리에서 수행 되며 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 에 지정된 속성과 정확히 일치하도록 시도합니다.. 이 검색에서 사용자를 찾으면 서버는 클라이언트가 지정한 비밀번호를 사용하여 연결을 끊고이 사용자로 디렉토리에 다시 바인딩하여 로그인이 올바른지 확인합니다. 이 모드는 Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; 및 &lt;code&gt;pam_ldap&lt;/code&gt; 와 같은 다른 소프트웨어의 LDAP 인증 체계에서 사용하는 것과 동일 합니다. 이 방법을 사용하면 사용자 객체가 디렉토리에있는 위치에서 훨씬 더 융통성이 있지만 LDAP 서버에 대한 두 개의 개별 연결이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="138833bfe13a3d8412530f69bb62c741e625ccde" translate="yes" xml:space="preserve">
          <source>In the second query, we could not have written &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt;, because there is no single value for the column &lt;code&gt;y&lt;/code&gt; that could be associated with each group. The grouped-by columns can be referenced in the select list since they have a single value in each group.</source>
          <target state="translated">두 번째 쿼리에서는 각 그룹과 연관 될 수있는 열 &lt;code&gt;y&lt;/code&gt; 에 대한 단일 값이 없으므로 &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt; 쓸 수 없습니다 . 그룹화 기준 컬럼은 각 그룹에 단일 값이 있으므로 선택 목록에서 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f53fb06ae3c0e076406bae29678cb14017000e" translate="yes" xml:space="preserve">
          <source>In the standard, it is not necessary to issue &lt;code&gt;START TRANSACTION&lt;/code&gt; to start a transaction block: any SQL command implicitly begins a block. PostgreSQL's behavior can be seen as implicitly issuing a &lt;code&gt;COMMIT&lt;/code&gt; after each command that does not follow &lt;code&gt;START TRANSACTION&lt;/code&gt; (or &lt;code&gt;BEGIN&lt;/code&gt;), and it is therefore often called &amp;ldquo;autocommit&amp;rdquo;. Other relational database systems might offer an autocommit feature as a convenience.</source>
          <target state="translated">표준에서 트랜잭션 블록을 시작하기 위해 &lt;code&gt;START TRANSACTION&lt;/code&gt; 을 발행 할 필요는 없습니다 . SQL 명령은 암시 적으로 블록을 시작합니다. PostgreSQL의 동작은 &lt;code&gt;START TRANSACTION&lt;/code&gt; (또는 &lt;code&gt;BEGIN&lt;/code&gt; )을 따르지 않는 각 명령 후에 암시 적으로 &lt;code&gt;COMMIT&lt;/code&gt; 를 발행하는 것으로 볼 수 있으므로 종종 &quot;자동 커밋&quot;이라고합니다. 다른 관계형 데이터베이스 시스템은 편의상 자동 커밋 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="127829a1cca08de1cd77d4d1d0c73fe0bf22ed39" translate="yes" xml:space="preserve">
          <source>In the standard, the &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; clause is required; in PostgreSQL it is optional.</source>
          <target state="translated">표준에서 &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; 절이 필요합니다. PostgreSQL에서는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7f27aa8e0141e367b925aa8c528ef6250799f203" translate="yes" xml:space="preserve">
          <source>In the strict mode, the specified path must exactly match the structure of the queried JSON document to return an SQL/JSON item, so using this path expression will cause an error. To get the same result as in the lax mode, you have to explicitly unwrap the &lt;code&gt;segments&lt;/code&gt; array:</source>
          <target state="translated">엄격 모드에서 지정된 경로는 쿼리 된 JSON 문서의 구조와 정확히 일치해야 SQL / JSON 항목을 리턴하므로이 경로 표현식을 사용하면 오류가 발생합니다. lax 모드에서와 동일한 결과를 얻으려면 &lt;code&gt;segments&lt;/code&gt; 배열 을 명시 적으로 랩 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="351d4063e5553403441da5e92374ad1230527978" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; 구문 에서 키워드 &lt;code&gt;FUNCTION&lt;/code&gt; 및 &lt;code&gt;PROCEDURE&lt;/code&gt; 는 동일하지만 참조 된 함수는 어쨌든 프로 시저가 아닌 함수 여야합니다. 여기서 &lt;code&gt;PROCEDURE&lt;/code&gt; 키워드를 사용하는 것은 과거와 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78472b8a63814954829d3aaff5becf4efc83edf2" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE OPERATOR&lt;/code&gt; 구문 에서 키워드 &lt;code&gt;FUNCTION&lt;/code&gt; 및 &lt;code&gt;PROCEDURE&lt;/code&gt; 는 동일하지만 참조 된 함수는 어쨌든 프로 시저가 아닌 함수 여야합니다. 여기서 &lt;code&gt;PROCEDURE&lt;/code&gt; 키워드를 사용하는 것은 과거와 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57ba8dd34e548ca54ffce2f60f391e867e594c9e" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; 구문 에서 키워드 &lt;code&gt;FUNCTION&lt;/code&gt; 및 &lt;code&gt;PROCEDURE&lt;/code&gt; 는 동일하지만 참조 된 함수는 어쨌든 프로 시저가 아닌 함수 여야합니다. 여기서 &lt;code&gt;PROCEDURE&lt;/code&gt; 키워드를 사용하는 것은 과거와 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9e4c8cc0471f863f66674a10b7573f32e28c279" translate="yes" xml:space="preserve">
          <source>In the text form of a range, an inclusive lower bound is represented by &amp;ldquo;&lt;code&gt;[&lt;/code&gt;&amp;rdquo; while an exclusive lower bound is represented by &amp;ldquo;&lt;code&gt;(&lt;/code&gt;&amp;rdquo;. Likewise, an inclusive upper bound is represented by &amp;ldquo;&lt;code&gt;]&lt;/code&gt;&amp;rdquo;, while an exclusive upper bound is represented by &amp;ldquo;&lt;code&gt;)&lt;/code&gt;&amp;rdquo;. (See &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;Section 8.17.5&lt;/a&gt; for more details.)</source>
          <target state="translated">범위의 텍스트 형식에서 포함 하한은 &quot; &lt;code&gt;[&lt;/code&gt; &quot;로 표시되고 배타 하한은 &quot; &lt;code&gt;(&lt;/code&gt; &quot;로 표시됩니다 . 마찬가지로 포함 상한은 &quot; &lt;code&gt;]&lt;/code&gt; &quot;로 표시되고 배타적 상한은 &quot;&quot;로 표시됩니다. &quot;에 의해 &lt;code&gt;)&lt;/code&gt; &quot;. (자세한 내용 &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;은 8.17.5 절&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="87e71fe4fdbdcfebf301c0661fd38f3ccfa52a22" translate="yes" xml:space="preserve">
          <source>In the verbose input format, and in some fields of the more compact input formats, field values can have fractional parts; for example &lt;code&gt;'1.5 week'&lt;/code&gt; or &lt;code&gt;'01:02:03.45'&lt;/code&gt;. Such input is converted to the appropriate number of months, days, and seconds for storage. When this would result in a fractional number of months or days, the fraction is added to the lower-order fields using the conversion factors 1 month = 30 days and 1 day = 24 hours. For example, &lt;code&gt;'1.5 month'&lt;/code&gt; becomes 1 month and 15 days. Only seconds will ever be shown as fractional on output.</source>
          <target state="translated">자세한 입력 형식 및보다 간단한 입력 형식의 일부 필드에서 필드 값은 소수 부분을 가질 수 있습니다. 예를 들어 &lt;code&gt;'1.5 week'&lt;/code&gt; 또는 &lt;code&gt;'01:02:03.45'&lt;/code&gt; 입니다. 이러한 입력은 저장을 위해 적절한 월, 일 및 초 수로 변환됩니다. 이로 인해 소수의 월 또는 일이 발생하는 경우 전환 계수 1 개월 = 30 일 및 1 일 = 24 시간을 사용하여 분수가 하위 필드에 추가됩니다. 예를 들어 &lt;code&gt;'1.5 month'&lt;/code&gt; 은 1 개월 15 일이됩니다. 출력에서는 초만 분수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="352c1b7bd2689ed0c741aae1f8598e4432b2e419" translate="yes" xml:space="preserve">
          <source>In the world of measurements, 6.50 is not the same as 6.5. It may sometimes be critically different. The experimenters usually write down (and publish) the digits they trust. 6.50 is actually a fuzzy interval contained within a bigger and even fuzzier interval, 6.5, with their center points being (probably) the only common feature they share. We definitely do not want such different data items to appear the same.</source>
          <target state="translated">측정 세계에서 6.50은 6.5와 동일하지 않습니다. 때로는 비판적으로 다를 수 있습니다. 실험자들은 일반적으로 그들이 신뢰하는 숫자를 기록 (및 게시)합니다. 6.50은 실제로 더 큰 퍼지 간격 (6.5) 내에 포함 된 퍼지 간격으로, 중심점은 (아마도) 공유하는 유일한 공통 기능입니다. 우리는 분명히 다른 데이터 항목이 동일하게 표시되는 것을 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d16185ffce558efd6646fae1f89738ca57d3dd9c" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text string (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">이 표현에서 원하는 시간대 &lt;code&gt;zone&lt;/code&gt; 텍스트 문자열로 중 하나를 지정할 수 있습니다 (예를 들어, &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ) 또는 간격 (예를 들어, 같은 &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; ). 텍스트의 경우 표준 시간대 이름은 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3 섹션에&lt;/a&gt; 설명 된 방법 중 하나로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccebf94cbd61b9484dc9b7fa83da6e0dd760a88b" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text value (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;. The interval case is only useful for zones that have fixed offsets from UTC, so it is not very common in practice.</source>
          <target state="translated">이러한 식으로, 원하는 시간대 &lt;code&gt;zone&lt;/code&gt; 텍스트 값 중 특정 할 수있다 (예를 들어, &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ) 또는 간격 (예로서 &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; ). 텍스트의 경우 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;섹션 8.5.3에&lt;/a&gt; 설명 된 방법 중 하나로 시간대 이름을 지정할 수 있습니다 . 간격 케이스는 UTC로부터 고정 오프셋이있는 영역에만 유용하므로 실제로는 흔하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13d5bca14d2cfde080255e10973a28114214ea10" translate="yes" xml:space="preserve">
          <source>In this case the parser looks to see if there is an operator taking &lt;code&gt;text&lt;/code&gt; for both arguments. Since there is, it assumes that the second argument should be interpreted as type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">이 경우 파서는 두 인수 모두에 대해 &lt;code&gt;text&lt;/code&gt; 를 취하는 연산자가 있는지 확인합니다 . 이 때문에 두 번째 인수는 &lt;code&gt;text&lt;/code&gt; 유형으로 해석되어야한다고 가정 합니다 .</target>
        </trans-unit>
        <trans-unit id="d2822670753f6c1107e46ff79d0892389494ad1a" translate="yes" xml:space="preserve">
          <source>In this case there is no MCV information for &lt;code&gt;unique2&lt;/code&gt; because all the values appear to be unique, so we use an algorithm that relies only on the number of distinct values for both relations together with their null fractions:</source>
          <target state="translated">이 경우 &lt;code&gt;unique2&lt;/code&gt; 에 대한 MCV 정보가 없습니다. 모든 값이 고유 한 것으로 보이므로 두 관계에 대한 고유 값의 수와 null 비율 만 사용하는 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="454dfb68a36b15232f0a47fef88c353fb8b457de" translate="yes" xml:space="preserve">
          <source>In this case there is no initial hint for which type to use, since no types are specified in the query. So, the parser looks for all candidate operators and finds that there are candidates accepting both string-category and bit-string-category inputs. Since string category is preferred when available, that category is selected, and then the preferred type for strings, &lt;code&gt;text&lt;/code&gt;, is used as the specific type to resolve the unknown-type literals as.</source>
          <target state="translated">이 경우 쿼리에 형식이 지정되어 있지 않으므로 사용할 형식에 대한 초기 힌트가 없습니다. 따라서 파서는 모든 후보 연산자를 찾고 문자열 범주 및 비트 문자열 범주 입력을 모두 허용하는 후보가 있음을 찾습니다. 사용 가능한 경우 문자열 범주가 선호되므로 해당 범주가 선택된 다음 문자열에 대한 기본 유형 인 &lt;code&gt;text&lt;/code&gt; 가 알 수없는 유형 리터럴을 확인하는 특정 유형으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="643fc82591ff3cc1a1f002cde4bff205b2405706" translate="yes" xml:space="preserve">
          <source>In this case, a regular user cannot reference &lt;code&gt;customer.credit&lt;/code&gt; directly, but a trusted procedure &lt;code&gt;show_credit&lt;/code&gt; allows the user to print the credit card numbers of customers with some of the digits masked out.</source>
          <target state="translated">이 경우 일반 사용자는 &lt;code&gt;customer.credit&lt;/code&gt; 를 직접 참조 할 수 없지만 신뢰할 수있는 프로 시저 &lt;code&gt;show_credit&lt;/code&gt; 를 사용하면 일부 숫자가 마스킹 된 고객의 신용 카드 번호를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d737c289d22cb958cf827fb7f26271e5be10a1e7" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;altitude&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. State capitals have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">이 경우의 행 &lt;code&gt;capitals&lt;/code&gt; &lt;em&gt;상속&lt;/em&gt; 모든 열 ( &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;population&lt;/code&gt; , 그리고 &lt;code&gt;altitude&lt;/code&gt; 의에서) &lt;em&gt;부모&lt;/em&gt; , &lt;code&gt;cities&lt;/code&gt; . 열 &lt;code&gt;name&lt;/code&gt; 의 유형 은 &lt;code&gt;text&lt;/code&gt; , 가변 길이 문자열에 대한 기본 PostgreSQL의 유형입니다. 국가의 수도는 여분의 열이 &lt;code&gt;state&lt;/code&gt; , 그 프로그램의 상태를. PostgreSQL에서 테이블은 0 개 이상의 다른 테이블에서 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5c8500d7c402e7f06456adc9676ed53904411ff" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;elevation&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. The &lt;code&gt;capitals&lt;/code&gt; table has an additional column, &lt;code&gt;state&lt;/code&gt;, which shows its state abbreviation. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">이 경우 &lt;code&gt;capitals&lt;/code&gt; 행은 &lt;em&gt;상위 항목&lt;/em&gt; 인 &lt;code&gt;cities&lt;/code&gt; 에서 모든 열 ( &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;population&lt;/code&gt; 및 &lt;code&gt;elevation&lt;/code&gt; )을 &lt;em&gt;상속&lt;/em&gt; 합니다 . 컬럼의 유형 &lt;code&gt;name&lt;/code&gt; 입니다 &lt;code&gt;text&lt;/code&gt; , 가변 길이 문자열에 대한 기본 PostgreSQL의 유형입니다. &lt;code&gt;capitals&lt;/code&gt; 표 추가 열 보유 &lt;code&gt;state&lt;/code&gt; 상태의 약어를 나타낸다. PostgreSQL에서 테이블은 0 개 이상의 다른 테이블에서 상속 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="613ba4c32d099503d94bd47a030a2a2ad44892dd" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;capitals&lt;/code&gt; table &lt;em&gt;inherits&lt;/em&gt; all the columns of its parent table, &lt;code&gt;cities&lt;/code&gt;. State capitals also have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state.</source>
          <target state="translated">이 경우, &lt;code&gt;capitals&lt;/code&gt; 테이블 &lt;em&gt;상속&lt;/em&gt; 부모 테이블의 모든 열 &lt;code&gt;cities&lt;/code&gt; . 국가의 수도는 여분의 열이 &lt;code&gt;state&lt;/code&gt; , 그 프로그램의 상태를.</target>
        </trans-unit>
        <trans-unit id="af318a98fb799d225d9e923e2e4473ff3043a3f6" translate="yes" xml:space="preserve">
          <source>In this configuration, the sample &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; above takes 115.9 ms. That's 1061 ns of timing overhead, again a small multiple of what's measured directly by this utility. That much timing overhead means the actual query itself is only taking a tiny fraction of the accounted for time, most of it is being consumed in overhead instead. In this configuration, any &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; totals involving many timed operations would be inflated significantly by timing overhead.</source>
          <target state="translated">이 구성에서 샘플 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 위 는 115.9ms가 걸립니다. 이는 1061ns의 타이밍 오버 헤드이며,이 유틸리티에서 직접 측정 한 것의 작은 배수입니다. 타이밍 오버 헤드가 너무 크다는 것은 실제 쿼리 자체가 시간을 거의 고려하지 않고 대부분 오버 헤드로 소비되고 있음을 의미합니다. 이 구성에서 많은 시간이 지정된 작업과 관련된 모든 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 총계는 타이밍 오버 헤드에 의해 크게 팽창됩니다.</target>
        </trans-unit>
        <trans-unit id="abed36bdd05542db8e718c1091a76817a77d802e" translate="yes" xml:space="preserve">
          <source>In this example above we were allowed to switch from the larger MCS range &lt;code&gt;c1.c1023&lt;/code&gt; to the smaller range &lt;code&gt;c1.c4&lt;/code&gt;, but switching back was denied.</source>
          <target state="translated">위의 예에서 우리는 더 큰 MCS 범위 &lt;code&gt;c1.c1023&lt;/code&gt; 에서 더 작은 범위 로 전환 할 수있었습니다 &lt;code&gt;c1.c4&lt;/code&gt; 로 전환 할 수 있었지만 다시 전환은 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7326012a121c41d2c47ed971d8505d7a7de76bf" translate="yes" xml:space="preserve">
          <source>In this example the Update node needs to consider three child tables as well as the originally-mentioned parent table. So there are four input scanning subplans, one per table. For clarity, the Update node is annotated to show the specific target tables that will be updated, in the same order as the corresponding subplans. (These annotations are new as of PostgreSQL 9.5; in prior versions the reader had to intuit the target tables by inspecting the subplans.)</source>
          <target state="translated">이 예에서 업데이트 노드는 원래 언급 된 상위 테이블뿐만 아니라 3 개의 하위 테이블을 고려해야합니다. 따라서 테이블 당 하나씩 4 개의 입력 스캐닝 하위 계획이 있습니다. 명확하게하기 위해 업데이트 노드에는 해당 하위 계획과 동일한 순서로 업데이트 될 특정 대상 테이블을 표시하도록 주석이 달립니다. (이 주석은 PostgreSQL 9.5부터 새로 추가되었습니다. 이전 버전에서는 독자가 하위 계획을 검사하여 대상 테이블을 작성해야했습니다.)</target>
        </trans-unit>
        <trans-unit id="90020459ceef361caea70168cdc85c26559a0eb6" translate="yes" xml:space="preserve">
          <source>In this example the join's output row count is the same as the product of the two scans' row counts, but that's not true in all cases because there can be additional &lt;code&gt;WHERE&lt;/code&gt; clauses that mention both tables and so can only be applied at the join point, not to either input scan. Here's an example:</source>
          <target state="translated">이 예에서 조인의 출력 행 수는 두 스캔의 행 수의 곱과 동일하지만 두 테이블을 모두 언급하는 추가 &lt;code&gt;WHERE&lt;/code&gt; 절이 있을 수 있으므로 조인 지점에서만 적용 할 수 있기 때문에 모든 경우에 해당되지 않습니다. 입력 스캔이 아닙니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f68e5dbd48ccbde70e786ec3f6ee97430aeb6b1e" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;(none)&lt;/code&gt;, null is returned, otherwise the value of &lt;code&gt;value&lt;/code&gt; is returned.</source>
          <target state="translated">이 예에서 &lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;(none)&lt;/code&gt; 이면 null이 반환되고, 그렇지 않으면 value &lt;code&gt;value&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6956c57a06842052520c448c372cfcf4ca7298a5" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, the two standbys &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; will be chosen as synchronous standbys because their names appear early in the list of standby names. &lt;code&gt;s3&lt;/code&gt; is a potential synchronous standby and will take over the role of synchronous standby when either of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; fails. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">이 예제에서 4 개의 대기 서버 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; 및 &lt;code&gt;s4&lt;/code&gt; 가 실행중인 경우 두 대기 &lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 는 이름이 대기 이름 목록의 초기에 나타나기 때문에 동기 대기로 선택됩니다. &lt;code&gt;s3&lt;/code&gt; 은 잠재적 인 동기 대기이며 &lt;code&gt;s1&lt;/code&gt; 또는 &lt;code&gt;s2&lt;/code&gt; 중 하나 가 실패하면 동기 대기의 역할을 대신 합니다. &lt;code&gt;s4&lt;/code&gt; 는 이름이 목록에 없기 때문에 비동기 대기입니다.</target>
        </trans-unit>
        <trans-unit id="5ecb1dc9291b661bf70c843bbe812e41c22f83de" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, transaction commits will wait for replies from at least any two standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; and &lt;code&gt;s3&lt;/code&gt;. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">이 예제에서 4 개의 대기 서버 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; 및 &lt;code&gt;s4&lt;/code&gt; 가 실행중인 경우 트랜잭션 커미트는 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; 및 &lt;code&gt;s3&lt;/code&gt; 중 적어도 두 개의 대기에서 응답을 기다립니다 . &lt;code&gt;s4&lt;/code&gt; 는 이름이 목록에 없기 때문에 비동기 대기입니다.</target>
        </trans-unit>
        <trans-unit id="52a2cd0a65091e20d376dc71b4672a80c22c4d96" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;TEMPLATE template0&lt;/code&gt; clause is required if the specified locale is different from the one in &lt;code&gt;template1&lt;/code&gt;. (If it is not, then specifying the locale explicitly is redundant.)</source>
          <target state="translated">이 예제 에서 지정된 로케일이 &lt;code&gt;template1&lt;/code&gt; 의 것과 다른 경우 &lt;code&gt;TEMPLATE template0&lt;/code&gt; 절이 필요합니다. . 그렇지 않은 경우 로케일을 명시 적으로 지정하면 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="8c5f7d8e9b592b4d5a3f718483f7acd727a00e09" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;len&lt;/code&gt; column is omitted and therefore it will have the default value:</source>
          <target state="translated">이 예에서 &lt;code&gt;len&lt;/code&gt; 열은 생략되므로 기본값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3694c54d9cfcf70eda6933c152be42b7c937c601" translate="yes" xml:space="preserve">
          <source>In this example, the columns &lt;code&gt;product_id&lt;/code&gt;, &lt;code&gt;p.name&lt;/code&gt;, and &lt;code&gt;p.price&lt;/code&gt; must be in the &lt;code&gt;GROUP BY&lt;/code&gt; clause since they are referenced in the query select list (but see below). The column &lt;code&gt;s.units&lt;/code&gt; does not have to be in the &lt;code&gt;GROUP BY&lt;/code&gt; list since it is only used in an aggregate expression (&lt;code&gt;sum(...)&lt;/code&gt;), which represents the sales of a product. For each product, the query returns a summary row about all sales of the product.</source>
          <target state="translated">이 예에서 &lt;code&gt;product_id&lt;/code&gt; , &lt;code&gt;p.name&lt;/code&gt; 및 &lt;code&gt;p.price&lt;/code&gt; 열 은 쿼리 선택 목록에서 참조되므로 &lt;code&gt;GROUP BY&lt;/code&gt; 절 에 있어야 합니다 (아래 참조). &lt;code&gt;s.units&lt;/code&gt; 열 은 제품의 판매량을 나타내는 집계 표현식 ( &lt;code&gt;sum(...)&lt;/code&gt; ) 에만 사용되므로 &lt;code&gt;GROUP BY&lt;/code&gt; 목록 에있을 필요는 없습니다 . 각 제품에 대해 쿼리는 제품의 모든 판매에 대한 요약 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08a0e2d4d5bc94672e2506daf9e09dfe471fae09" translate="yes" xml:space="preserve">
          <source>In this example, the data type of the second parameter is not specified, so it is inferred from the context in which &lt;code&gt;$2&lt;/code&gt; is used.</source>
          <target state="translated">이 예에서는 두 번째 매개 변수의 데이터 유형이 지정되지 않았으므로 &lt;code&gt;$2&lt;/code&gt; 가 사용되는 컨텍스트에서 추론 됩니다.</target>
        </trans-unit>
        <trans-unit id="9ecac118ba12d038d39cec07567975d6d66efcef" translate="yes" xml:space="preserve">
          <source>In this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do:</source>
          <target state="translated">이 예에서는 정렬 순서가 완전히 지정되지 않았으므로 샌프란시스코 행을 어느 순서로나 가져올 수 있습니다. 그러나 다음과 같은 경우 항상 위의 결과가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="afe2100b24dbf1294da5f781636d42d62e4bc563" translate="yes" xml:space="preserve">
          <source>In this example, the word &lt;code&gt;Brightest&lt;/code&gt; was recognized by the parser as an &lt;code&gt;ASCII word&lt;/code&gt; (alias &lt;code&gt;asciiword&lt;/code&gt;). For this token type the dictionary list is &lt;code&gt;english_ispell&lt;/code&gt; and &lt;code&gt;english_stem&lt;/code&gt;. The word was recognized by &lt;code&gt;english_ispell&lt;/code&gt;, which reduced it to the noun &lt;code&gt;bright&lt;/code&gt;. The word &lt;code&gt;supernovaes&lt;/code&gt; is unknown to the &lt;code&gt;english_ispell&lt;/code&gt; dictionary so it was passed to the next dictionary, and, fortunately, was recognized (in fact, &lt;code&gt;english_stem&lt;/code&gt; is a Snowball dictionary which recognizes everything; that is why it was placed at the end of the dictionary list).</source>
          <target state="translated">이 예에서 &lt;code&gt;Brightest&lt;/code&gt; 라는 단어 는 파서에서 &lt;code&gt;ASCII word&lt;/code&gt; (별칭 &lt;code&gt;asciiword&lt;/code&gt; ) 로 인식되었습니다 . 이 토큰 유형의 사전 목록은 &lt;code&gt;english_ispell&lt;/code&gt; 및 &lt;code&gt;english_stem&lt;/code&gt; 입니다. 이 단어는 &lt;code&gt;english_ispell&lt;/code&gt; 에 의해 인식되었으며 ,이를 명사 &lt;code&gt;bright&lt;/code&gt; 였습니다. 단어 &lt;code&gt;supernovaes&lt;/code&gt; 는 알 수없는입니다 &lt;code&gt;english_ispell&lt;/code&gt; 사전이 다행히 (사실, 인정되었다, 다음 사전에 전달하고, 그래서 &lt;code&gt;english_stem&lt;/code&gt; 이 모든 것을 인식하는 눈덩이 사전이며,이 사전 목록의 끝에 배치 된 이유입니다 ).</target>
        </trans-unit>
        <trans-unit id="3c50776020e0abdc78addf8fd7c7082700a16f21" translate="yes" xml:space="preserve">
          <source>In this example, transaction 82 was late, because its latency (6.173 ms) was over the 5 ms limit. The next two transactions were skipped, because they were already late before they were even started.</source>
          <target state="translated">이 예에서 지연 시간 (6.173ms)이 5ms 제한을 초과했기 때문에 트랜잭션 82가 늦었습니다. 다음 두 트랜잭션은 시작하기 전에 이미 늦었 기 때문에 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="25785dae89df6c58b5b98e5a8b5a16cf8ba5c166" translate="yes" xml:space="preserve">
          <source>In this form, &lt;code&gt;n&lt;/code&gt; counts from 1 to 365, and February 29 is not counted even if it is present. (Thus, a transition occurring on February 29 could not be specified this way. However, days after February have the same numbers whether it's a leap year or not, so that this form is usually more useful than the plain-integer form for transitions on fixed dates.)</source>
          <target state="translated">이 형식에서 &lt;code&gt;n&lt;/code&gt; 은 1부터 365까지 계산되며 2 월 29 일은 존재하더라도 계산되지 않습니다. (따라서 2 월 29 일에 발생하는 전환은이 방법으로 지정할 수 없습니다. 그러나 2 월 이후의 날은 윤년이든 아니든간에 동일한 숫자를 가지므로이 형식은 일반적으로 전환을위한 일반 정수 형식보다 유용합니다. 고정 날짜.)</target>
        </trans-unit>
        <trans-unit id="630dd124cc8b0f85590f44f07e341462147cb0a6" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dit&lt;/code&gt; lists indexes and tables. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its physical size on disk and its associated description, if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">이 명령 그룹에서 문자 &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 각각 외부 테이블, 인덱스, 구체화 된 뷰, 시퀀스, 테이블 및 뷰를 나타냅니다. 이러한 문자 중 일부 또는 전부를 임의의 순서로 지정하여 이러한 유형의 개체 목록을 얻을 수 있습니다. 예를 들어, &lt;code&gt;\dit&lt;/code&gt; 는 인덱스와 테이블을 나열합니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되어, 각 개체는 디스크의 물리적 크기와 관련 설명 (있는 경우)로 나열됩니다. 경우 &lt;code&gt;pattern&lt;/code&gt; 지정된 경우에만 이름이 패턴과 일치하는 나열되어 객체. 기본적으로 사용자가 만든 개체 만 표시됩니다. 패턴 또는 &lt;code&gt;S&lt;/code&gt; 를 공급 시스템 객체를 포함하는 수정 자.</target>
        </trans-unit>
        <trans-unit id="e1a2b0abebbac2543bf7c44bb0372db4d5e5c034" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dti&lt;/code&gt; lists tables and indexes. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its persistence status (permanent, temporary, or unlogged), physical size on disk, and associated description if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">이 명령 그룹에서 문자 &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 는 각각 외부 테이블, 인덱스, 구체화 된 뷰, 시퀀스, 테이블 및 뷰를 나타냅니다. 순서에 관계없이 이러한 문자의 일부 또는 전체를 지정하여 이러한 유형의 개체 목록을 얻을 수 있습니다. 예를 들어, &lt;code&gt;\dti&lt;/code&gt; 는 테이블과 인덱스를 나열합니다. 경우 &lt;code&gt;+&lt;/code&gt; 는 명령 이름에 추가되어, 각 개체의 상태 지속성 디스크 (영구 임시 또는 로깅되지 않은) 실제 크기로 나열하고있는 경우를 설명 연관된다. If &lt;code&gt;pattern&lt;/code&gt; 지정되면 이름이 패턴과 일치하는 오브젝트 만 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="76a2e5dcbe213e98e1493b7e930a93660a65d1fc" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">이 모듈에서 지구는 완전히 구형 인 것으로 가정합니다. (너무 정확하지 않은 경우 &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; 프로젝트 를 볼 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="d0ed0a5a7df9c6e41189a38e83864f5642c8ac48" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;https://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">이 모듈에서 지구는 완벽하게 구형이라고 가정합니다. (너무 정확하지 않다면 &lt;a href=&quot;https://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; 프로젝트 를 살펴보세요 .)</target>
        </trans-unit>
        <trans-unit id="fdbad3a8ee3be25a94e567ee2f1c55ff6b62875e" translate="yes" xml:space="preserve">
          <source>In this particular example, the correction from the MCV list is fairly small, because the column distribution is actually quite flat (the statistics showing these particular values as being more common than others are mostly due to sampling error). In a more typical case where some values are significantly more common than others, this complicated process gives a useful improvement in accuracy because the selectivity for the most common values is found exactly.</source>
          <target state="translated">이 특정 예에서 열 분포가 실제로 매우 평탄하기 때문에 MCV 목록의 수정은 상당히 작습니다 (이러한 특정 값을 다른 값보다 일반적으로 표시하는 통계는 대부분 샘플링 오류로 인한 것입니다). 일부 값이 다른 값보다 훨씬 더 일반적인 경우에이 복잡한 프로세스는 가장 일반적인 값의 선택성이 정확하게 발견되므로 정확도가 유용하게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="35b50273596d3b9b0a5ab879d1dff2a027177930" translate="yes" xml:space="preserve">
          <source>In this plan, we have a nested-loop join node with two table scans as inputs, or children. The indentation of the node summary lines reflects the plan tree structure. The join's first, or &amp;ldquo;outer&amp;rdquo;, child is a bitmap scan similar to those we saw before. Its cost and row count are the same as we'd get from &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; because we are applying the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; at that node. The &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; clause is not relevant yet, so it doesn't affect the row count of the outer scan. The nested-loop join node will run its second, or &amp;ldquo;inner&amp;rdquo; child once for each row obtained from the outer child. Column values from the current outer row can be plugged into the inner scan; here, the &lt;code&gt;t1.unique2&lt;/code&gt; value from the outer row is available, so we get a plan and costs similar to what we saw above for a simple &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case. (The estimated cost is actually a bit lower than what was seen above, as a result of caching that's expected to occur during the repeated index scans on &lt;code&gt;t2&lt;/code&gt;.) The costs of the loop node are then set on the basis of the cost of the outer scan, plus one repetition of the inner scan for each outer row (10 * 7.91, here), plus a little CPU time for join processing.</source>
          <target state="translated">이 계획에서는 입력으로 두 개의 테이블 스캔 또는 하위가있는 중첩 루프 조인 노드가 있습니다. 노드 요약 라인의 들여 쓰기는 계획 트리 구조를 반영합니다. 조인의 첫 번째 또는 &quot;외부&quot;자식은 이전에 본 것과 유사한 비트 맵 스캔입니다. 해당 노드에서 &lt;code&gt;WHERE&lt;/code&gt; 절 &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; 을 적용하기 때문에 비용과 행 수는 &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; 에서 얻을 수있는 것과 같습니다 . &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; 는 외부 스캔의 행 수에 영향을주지 않도록 절은, 아직 관련이 없습니다. 중첩 루프 결합 노드는 외부 하위에서 얻은 각 행에 대해 두 번째 또는 &quot;내부&quot;하위를 한 번 실행합니다. 현재 외부 행의 열 값을 내부 스캔에 꽂을 수 있습니다. 여기 &lt;code&gt;t1.unique2&lt;/code&gt; 외부 행의 값을 사용할 수 있으므로 간단한 &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case에 대해 위에서 본 것과 비슷한 계획과 비용이 발생합니다. ( &lt;code&gt;t2&lt;/code&gt; 에서 반복적 인 인덱스 스캔 중에 발생할 것으로 예상되는 캐싱의 결과로 예상 비용은 실제로 위에서 본 것보다 약간 낮습니다 .) 그런 다음 루프 노드의 비용은 외부 스캔, 각 외부 행에 대한 내부 스캔 반복 (10 * 7.91), 결합 처리를위한 약간의 CPU 시간.</target>
        </trans-unit>
        <trans-unit id="92ba779e5f5f15aa09f4dc327e10902ae3870fba" translate="yes" xml:space="preserve">
          <source>In this syntax, a zone abbreviation can be a string of letters, such as &lt;code&gt;EST&lt;/code&gt;, or an arbitrary string surrounded by angle brackets, such as &lt;code&gt;&amp;lt;UTC-05&amp;gt;&lt;/code&gt;. Note that the zone abbreviations given here are only used for output, and even then only in some timestamp output formats. The zone abbreviations recognized in timestamp input are determined as explained in &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;.</source>
          <target state="translated">이 구문에서 영역 약어는 &lt;code&gt;EST&lt;/code&gt; 와 같은 문자 문자열 이거나 &lt;code&gt;&amp;lt;UTC-05&amp;gt;&lt;/code&gt; 와 같이 꺾쇠 괄호로 둘러싸인 임의의 문자열 일 수 있습니다 . 여기에 제공된 영역 약어는 출력에만 사용되며 일부 타임 스탬프 출력 형식에서만 사용됩니다. 타임 스탬프 입력에서 인식되는 영역 약어는 &lt;a href=&quot;datetime-config-files&quot;&gt;섹션 B.4에&lt;/a&gt; 설명 된대로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a65ed7368072bf4eca944cd69c42b40f3442c1c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">이 구문에서 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;count&lt;/code&gt; 값은 표준에서 리터럴 상수, 매개 변수 또는 변수 이름이어야합니다. PostgreSQL 확장으로 다른 표현식도 허용되지만 모호성을 피하려면 일반적으로 괄호로 묶어야합니다. &lt;code&gt;FETCH&lt;/code&gt; 절 에서 &lt;code&gt;count&lt;/code&gt; 가 생략 되면 기본값은 1입니다. &lt;code&gt;ROW&lt;/code&gt; 및 &lt;code&gt;ROWS&lt;/code&gt; 와 &lt;code&gt;FIRST&lt;/code&gt; 및 &lt;code&gt;NEXT&lt;/code&gt; 는 이러한 절의 영향에 영향을 미치지 않는 노이즈 단어입니다. 표준에 따르면, &lt;code&gt;OFFSET&lt;/code&gt; 절이 둘 다 존재하는 경우 &lt;code&gt;FETCH&lt;/code&gt; 절 앞에 와야합니다 . 그러나 PostgreSQL은 laxer이며 어느 쪽이든 주문할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aad7367e4cf00d23ec40e47a1df35bb1446273c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. The &lt;code&gt;WITH TIES&lt;/code&gt; option is used to return any additional rows that tie for the last place in the result set according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause; &lt;code&gt;ORDER BY&lt;/code&gt; is mandatory in this case. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">이 구문에서 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;count&lt;/code&gt; 값은 리터럴 상수, 매개 변수 또는 변수 이름이되도록 표준에 필요합니다. PostgreSQL 확장으로 다른 표현식이 허용되지만 일반적으로 모호성을 피하기 위해 괄호로 묶어야합니다. &lt;code&gt;FETCH&lt;/code&gt; 절 에서 &lt;code&gt;count&lt;/code&gt; 가 생략 되면 기본값은 1입니다. &lt;code&gt;WITH TIES&lt;/code&gt; 옵션은 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에 따라 결과 집합의 마지막 위치에 연결된 추가 행을 반환하는 데 사용됩니다 . 이 경우 &lt;code&gt;ORDER BY&lt;/code&gt; 는 필수입니다. &lt;code&gt;ROW&lt;/code&gt; 및 &lt;code&gt;ROWS&lt;/code&gt; , &lt;code&gt;FIRST&lt;/code&gt; 및 &lt;code&gt;NEXT&lt;/code&gt; 이 절의 효과에 영향을주지 않는 노이즈 단어입니다. 표준에 따르면 &lt;code&gt;OFFSET&lt;/code&gt; 절은 둘 다있는 경우 &lt;code&gt;FETCH&lt;/code&gt; 절 앞에 와야합니다 . 그러나 PostgreSQL은 느슨하며 두 가지 주문을 모두 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6b9893e81c5b40e27434e52e7429139f563d867e" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">이 유형의 계획에서 테이블 행은 인덱스 순서로 페치되어 읽기 비용이 훨씬 많이 들지만 행 위치를 정렬하는 데 드는 추가 비용이 그다지 가치가 없습니다. 단일 행만 가져 오는 쿼리에 대해이 계획 유형이 가장 자주 나타납니다. &lt;code&gt;ORDER BY&lt;/code&gt; 조건을 만족 하는 ORDER BY 조건 이있는 쿼리에도 자주 사용됩니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 를 충족시키기 위해 추가 정렬 단계가 필요하지 않기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="f14120df06086beebf2309a0093abef8ae36a3dc" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;. In this example, adding &lt;code&gt;ORDER BY unique1&lt;/code&gt; would use the same plan because the index already implicitly provides the requested ordering.</source>
          <target state="translated">이 유형의 계획에서는 테이블 행을 인덱스 순서로 가져 오므로 읽기 비용이 훨씬 더 많이 들지만 행 위치를 정렬하는 데 드는 추가 비용은 그만한 가치가 없습니다. 단일 행만 가져 오는 쿼리에 대해이 계획 유형이 가장 자주 표시됩니다. 또한 인덱스 순서와 일치 하는 &lt;code&gt;ORDER BY&lt;/code&gt; 조건 이있는 쿼리에도 자주 사용됩니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 를 충족하는 데 추가 정렬 단계가 필요하지 않기 때문 입니다. 이 예에서 &lt;code&gt;ORDER BY unique1&lt;/code&gt; 을 추가 하면 인덱스가 이미 요청 된 순서를 암시 적으로 제공하므로 동일한 계획을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="84eb5898e8d8ec4083399d85009281a59b8ba4c6" translate="yes" xml:space="preserve">
          <source>In versions prior to PostgreSQL 9.6, this flag matched only tables, not any other type of relation.</source>
          <target state="translated">PostgreSQL 9.6 이전 버전에서이 플래그는 다른 유형의 관계가 아닌 테이블 만 일치했습니다.</target>
        </trans-unit>
        <trans-unit id="cccb2030fa433816cbfff6cfc31e7b85686eadc9" translate="yes" xml:space="preserve">
          <source>In writing your archive command, you should assume that the file names to be archived can be up to 64 characters long and can contain any combination of ASCII letters, digits, and dots. It is not necessary to preserve the original relative path (&lt;code&gt;%p&lt;/code&gt;) but it is necessary to preserve the file name (&lt;code&gt;%f&lt;/code&gt;).</source>
          <target state="translated">아카이브 명령을 작성할 때 아카이브 할 파일 이름의 길이는 최대 64 자이며 ASCII 문자, 숫자 및 점의 조합을 포함 할 수 있다고 가정해야합니다. 원래 상대 경로를 유지할 필요는 없습니다 ( &lt;code&gt;%p&lt;/code&gt; ) 되지만 파일 이름 ( &lt;code&gt;%f&lt;/code&gt; ) 은 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="faddf9df2a3466cccf3377b581482849c1fd5256" translate="yes" xml:space="preserve">
          <source>Inaccurate time keeping can result in system instability. Test any change to the clock source very carefully. Operating system defaults are sometimes made to favor reliability over best accuracy. And if you are using a virtual machine, look into the recommended time sources compatible with it. Virtual hardware faces additional difficulties when emulating timers, and there are often per operating system settings suggested by vendors.</source>
          <target state="translated">시간이 정확하지 않으면 시스템이 불안정해질 수 있습니다. 클럭 소스의 변경 사항을 매우 신중하게 테스트하십시오. 운영 체제 기본값은 때때로 최고 정확도보다 안정성을 선호합니다. 가상 머신을 사용하는 경우 가상 머신과 호환되는 권장 시간 소스를 살펴보십시오. 가상 하드웨어는 타이머를 에뮬레이션 할 때 추가적인 어려움에 직면하며 공급 업체가 제안한 운영 체제 별 설정이 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4bae0608aa0bb22c524d2d34a5bb2a1f5386f27" translate="yes" xml:space="preserve">
          <source>Incidentally, the &lt;code&gt;BEGIN&lt;/code&gt; key word is used for a different purpose in embedded SQL. You are advised to be careful about the transaction semantics when porting database applications.</source>
          <target state="translated">또한 &lt;code&gt;BEGIN&lt;/code&gt; 키워드는 Embedded SQL에서 다른 목적으로 사용됩니다. 데이터베이스 응용 프로그램을 이식 할 때 트랜잭션 의미론에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f56a8df3508e9ed5684baab06fa5e61cef26eebf" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;pg_trace.h&lt;/code&gt; if it is not already present in the module(s) containing the probe points, and insert &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; probe macros at the desired locations in the source code</source>
          <target state="translated">포함 &lt;code&gt;pg_trace.h&lt;/code&gt; 를 이미 모듈 (들)에 존재하는 프로브의 포인트를 포함하지 않으며, 삽입하면 &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; 의 소스 코드에서 원하는 위치에 프로브 매크로</target>
        </trans-unit>
        <trans-unit id="2d8b7df7f5c4b05fc8f7d8518fd909017b7c32d2" translate="yes" xml:space="preserve">
          <source>Include SQL commands to clean (drop) databases before recreating them. &lt;code&gt;DROP&lt;/code&gt; commands for roles and tablespaces are added as well.</source>
          <target state="translated">데이터베이스를 재 작성하기 전에 정리 (삭제)하는 SQL 명령을 포함하십시오. 역할 및 테이블 스페이스에 대한 &lt;code&gt;DROP&lt;/code&gt; 명령도 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="15af567ab13e6ebab28e457206713f05e4dcc212" translate="yes" xml:space="preserve">
          <source>Include actual startup time and time spent in each node in the output. The overhead of repeatedly reading the system clock can slow down the query significantly on some systems, so it may be useful to set this parameter to &lt;code&gt;FALSE&lt;/code&gt; when only actual row counts, and not exact times, are needed. Run time of the entire statement is always measured, even when node-level timing is turned off with this option. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">출력의 각 노드에서 소요 된 실제 시작 시간과 시간을 포함하십시오. 시스템 클럭을 반복해서 읽는 오버 헤드로 인해 일부 시스템에서 쿼리 속도가 크게 느려질 수 있으므로 정확한 시간이 아닌 실제 행 개수 만 필요한 경우이 매개 변수를 &lt;code&gt;FALSE&lt;/code&gt; 로 설정하면 유용 할 수 있습니다 . 이 옵션을 사용하여 노드 레벨 타이밍을 끄더라도 전체 명령문의 런타임은 항상 측정됩니다. 이 매개 변수는 &lt;code&gt;ANALYZE&lt;/code&gt; 일 때만 사용할 수 있습니다 가 활성화 된 사용할 수 있습니다. 기본값은 &lt;code&gt;TRUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69fd997380e1370b3a2e3a89721390495f72294b" translate="yes" xml:space="preserve">
          <source>Include files or directories can be used to logically separate portions of the database configuration, rather than having a single large &lt;code&gt;postgresql.conf&lt;/code&gt; file. Consider a company that has two database servers, each with a different amount of memory. There are likely elements of the configuration both will share, for things such as logging. But memory-related parameters on the server will vary between the two. And there might be server specific customizations, too. One way to manage this situation is to break the custom configuration changes for your site into three files. You could add this to the end of your &lt;code&gt;postgresql.conf&lt;/code&gt; file to include them:</source>
          <target state="translated">하나의 큰 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일이 아닌 포함 파일 또는 디렉토리를 사용하여 데이터베이스 구성의 일부를 논리적으로 분리 할 수 ​​있습니다 . 각각 다른 양의 메모리를 가진 두 개의 데이터베이스 서버가있는 회사를 생각해보십시오. 로깅과 같은 것들에 대해 둘 다 공유 할 구성 요소가있을 수 있습니다. 그러나 서버의 메모리 관련 매개 변수는 둘 사이에서 다릅니다. 또한 서버 별 사용자 정의가있을 수 있습니다. 이 상황을 관리하는 한 가지 방법은 사이트의 사용자 정의 구성 변경을 세 개의 파일로 나누는 것입니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 의 끝에 이것을 추가 하여 포함시킬 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="12ee2acead9dafe36942e1a0338b4e8cb8ee012c" translate="yes" xml:space="preserve">
          <source>Include information on WAL record generation. Specifically, include the number of records, number of full page images (fpi) and amount of WAL bytes generated. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">WAL 레코드 생성에 대한 정보를 포함합니다. 특히 레코드 수, 전체 페이지 이미지 (fpi) 수 및 생성 된 WAL 바이트 양을 포함합니다. 텍스트 형식에서는 0이 아닌 값만 인쇄됩니다. 이 매개 변수는 &lt;code&gt;ANALYZE&lt;/code&gt; 도 활성화 된 경우에만 사용할 수 있습니다. 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="47b7156430746d586783036a5e783795b65f9965" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">버퍼 사용량에 대한 정보를 포함하십시오. 구체적으로, 적중, 읽기, 더티 및 기록 된 공유 블록 수, 적중, 읽기, 더티 및 기록 된 로컬 블록 수 및 읽고 쓴 임시 블록 수를 포함하십시오. A는 &lt;em&gt;공격&lt;/em&gt; 필요할 때 블록이 캐시에 이미 발견 되었기 때문에 읽기 피할 것을 의미합니다. 공유 블록에는 일반 테이블 및 인덱스의 데이터가 포함됩니다. 로컬 블록에는 임시 테이블 및 인덱스의 데이터가 포함됩니다. 임시 블록에는 정렬, 해시, 구체화 계획 노드 및 이와 유사한 경우에 사용되는 단기 작업 데이터가 포함됩니다. 블록의 수 &lt;em&gt;더러워은&lt;/em&gt; 이 쿼리에 의해 변경되었습니다 이전에 수정되지 않은 블록의 수를 나타냅니다; 블록의 수 동안&lt;em&gt; 쓰여진&lt;/em&gt;쿼리 처리 중에이 백엔드가 캐시에서 제거한 이전에 제거 된 블록 수를 나타냅니다. 상위 레벨 노드에 대해 표시된 블록 수에는 모든 하위 노드에서 사용되는 블록 수가 포함됩니다. 텍스트 형식에서는 0이 아닌 값만 인쇄됩니다. 이 매개 변수는 &lt;code&gt;ANALYZE&lt;/code&gt; 가 활성화 된 경우에만 사용할 수 있습니다. 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="42e6828248f4c65573605405eae9a72feadb86b8" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, the number of temp blocks read and written, and the time spent reading and writing data file blocks (in milliseconds) if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">버퍼 사용에 대한 정보를 포함합니다. 특히, 적중, 읽기, 더티 및 쓰기 공유 블록 수, 적중, 읽기, 더티 및 쓰기 로컬 블록 수, 읽고 쓴 임시 블록 수, 데이터 파일 블록을 읽고 쓰는 데 소요 된 시간을 포함합니다. (밀리 초) &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; 이 활성화 된 경우. A는 &lt;em&gt;공격&lt;/em&gt; 필요할 때 블록이 캐시에 이미 발견 되었기 때문에 읽기 피할 것을 의미합니다. 공유 블록에는 일반 테이블 및 인덱스의 데이터가 포함됩니다. 로컬 블록에는 임시 테이블 및 인덱스의 데이터가 포함됩니다. 임시 블록에는 정렬, 해시, Materialise 계획 노드 및 유사한 경우에 사용되는 단기 작업 데이터가 포함됩니다. &lt;em&gt;더럽혀진&lt;/em&gt; 블록 수&lt;em&gt;&lt;/em&gt;이 쿼리에 의해 변경된 이전에 수정되지 않은 블록의 수를 나타냅니다. &lt;em&gt;쓰여진&lt;/em&gt; 블록 수는 쿼리 처리 중에이 백엔드에 의해 캐시에서 제거 된 이전에 더럽혀진 블록 수를 나타냅니다. 상위 레벨 노드에 대해 표시되는 블록 수에는 모든 하위 노드에서 사용하는 블록 수가 포함됩니다. 텍스트 형식에서는 0이 아닌 값만 인쇄됩니다. 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5cf950011b674c52ed53fd1187206feef3854c98" translate="yes" xml:space="preserve">
          <source>Include information on configuration parameters. Specifically, include options affecting query planning with value different from the built-in default value. This parameter defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">구성 매개 변수에 대한 정보를 포함하십시오. 특히 기본 제공 기본값과 다른 값으로 쿼리 계획에 영향을주는 옵션을 포함하십시오. 이 매개 변수의 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd7df900c420c99916abebaeb86bc9b9487e3ff6" translate="yes" xml:space="preserve">
          <source>Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row. This parameter defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">각 계획 노드의 예상 시작 및 총 비용, 예상 행 수 및 각 행의 예상 너비에 대한 정보를 포함하십시오. 이 매개 변수의 기본값은 &lt;code&gt;TRUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5b5e034a15e397016c3928803cda54f49c8fb74" translate="yes" xml:space="preserve">
          <source>Include large objects in the dump. This is the default behavior except when &lt;code&gt;--schema&lt;/code&gt;, &lt;code&gt;--table&lt;/code&gt;, or &lt;code&gt;--schema-only&lt;/code&gt; is specified. The &lt;code&gt;-b&lt;/code&gt; switch is therefore only useful to add large objects to dumps where a specific schema or table has been requested. Note that blobs are considered data and therefore will be included when &lt;code&gt;--data-only&lt;/code&gt; is used, but not when &lt;code&gt;--schema-only&lt;/code&gt; is.</source>
          <target state="translated">덤프에 큰 오브젝트를 포함하십시오. &lt;code&gt;--schema&lt;/code&gt; , &lt;code&gt;--table&lt;/code&gt; 또는 &lt;code&gt;--schema-only&lt;/code&gt; 가 지정된 경우를 제외하고는 기본 동작 입니다. 따라서 &lt;code&gt;-b&lt;/code&gt; 스위치는 특정 스키마 나 테이블이 요청 된 덤프에 큰 객체를 추가 할 때만 유용합니다. Blob은 데이터로 간주되므로 &lt;code&gt;--data-only&lt;/code&gt; 를 사용할 때는 포함 되지만 &lt;code&gt;--schema-only&lt;/code&gt; 는 사용할 때는 포함 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="08c7d11c8d4a8d10c948989b5a35951818754be1" translate="yes" xml:space="preserve">
          <source>Include summary information (e.g., totaled timing information) after the query plan. Summary information is included by default when &lt;code&gt;ANALYZE&lt;/code&gt; is used but otherwise is not included by default, but can be enabled using this option. Planning time in &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; includes the time required to fetch the plan from the cache and the time required for re-planning, if necessary.</source>
          <target state="translated">쿼리 계획 후 요약 정보 (예 : 총 타이밍 정보)를 포함하십시오. &lt;code&gt;ANALYZE&lt;/code&gt; 를 사용 하면 요약 정보가 기본적으로 포함 되지만 그렇지 않으면 기본적으로 포함되지 않지만이 옵션을 사용하여 활성화 할 수 있습니다. 계획 시간 &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; 의 에는 캐시에서 계획을 가져 오는 데 필요한 시간과 필요한 경우 다시 계획하는 데 필요한 시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2cb48cc7645d02e5f49dead86862d11be771ed" translate="yes" xml:space="preserve">
          <source>Includes the required WAL (write-ahead log) files in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster in the target directory without the need to consult the log archive, thus making the output a completely standalone backup.</source>
          <target state="translated">백업에 필요한 WAL (미리 쓰기 로그) 파일을 포함합니다. 여기에는 백업 중에 생성 된 모든 미리 쓰기 로그가 포함됩니다. &lt;code&gt;none&lt;/code&gt; 방법을 지정 하지 않으면 로그 아카이브를 참조 할 필요없이 대상 디렉토리에서 포스트 마스터를 시작할 수 있으므로 출력이 완전히 독립형 백업이됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
