<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="2c1cd79ab101e360e9a13e652ea38bf6edc2d76e" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt; to enforce the rule that a cage at a zoo can contain only one kind of animal:</source>
          <target state="translated">동물원의 케이지가 한 종류의 동물 만 포함 할 수 있다는 규칙을 시행하려면 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;제외 제약 조건&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed495ec2e832a44d27151818dc3a53eb05f6485b" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="translated">데이터 페이지에서 체크섬을 사용하면 I / O 시스템에 의한 자동 손상을 감지 할 수 있습니다. 체크섬을 활성화하면 눈에 띄는 성능 저하가 발생할 수 있습니다. 설정된 경우 모든 데이터베이스의 모든 개체에 대해 체크섬이 계산됩니다. 모든 체크섬 실패는 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; 보기에 보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce023d8439552305d2edc6e2bf4149ad204ec26c" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">조건부 명령 (예 : &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 )을 사용하여 데이터베이스 개체를 삭제하십시오. &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d755e67717cdd34225a86cde8e3134de7095e52a" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">조건부 명령을 사용하여 (예 : &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 ) 데이터베이스 및 기타 개체를 삭제하십시오. &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="723b15fd565cd7b73cc4c9f69508e6bb65d787d0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">데이터베이스 개체를 정리할 때 조건부 명령을 사용하십시오 (예 : &lt;code&gt;IF EXISTS&lt;/code&gt; 절 추가 ). &lt;code&gt;--clean&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f8dc23b011f6f1a62e695d4c31ea4636fb489dcc" translate="yes" xml:space="preserve">
          <source>Use efficient file cloning (also known as &amp;ldquo;reflinks&amp;rdquo; on some systems) instead of copying files to the new cluster. This can result in near-instantaneous copying of the data files, giving the speed advantages of &lt;code&gt;-k&lt;/code&gt;/&lt;code&gt;--link&lt;/code&gt; while leaving the old cluster untouched.</source>
          <target state="translated">파일을 새 클러스터로 복사하는 대신 효율적인 파일 복제 (일부 시스템에서는 &quot;참조&quot;라고도 함)를 사용하십시오. 이로 인해 데이터 파일을 거의 즉시 복사 할 수 있으며, 이전 클러스터는 그대로두고 &lt;code&gt;-k&lt;/code&gt; / &lt;code&gt;--link&lt;/code&gt; 의 속도 이점을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="717457386c7410d1c0caadadb8bcf5cee9b94ef2" translate="yes" xml:space="preserve">
          <source>Use genetic query optimization to plan queries with at least this many &lt;code&gt;FROM&lt;/code&gt; items involved. (Note that a &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; construct counts as only one &lt;code&gt;FROM&lt;/code&gt; item.) The default is 12. For simpler queries it is usually best to use the regular, exhaustive-search planner, but for queries with many tables the exhaustive search takes too long, often longer than the penalty of executing a suboptimal plan. Thus, a threshold on the size of the query is a convenient way to manage use of GEQO.</source>
          <target state="translated">유전자 쿼리 최적화를 사용하여 최소한이 &lt;code&gt;FROM&lt;/code&gt; 항목이 포함 된 쿼리를 계획하십시오 . (주 &amp;bull; 그래도 &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; 은 하나 같이 구조의 수를 &lt;code&gt;FROM&lt;/code&gt; 기본이 정규, 철저한 검색 플래너를 사용하는 것이 가장 좋습니다 간단한 쿼리의 12입니다. 항목), 그러나 많은 테이블 쿼리에 대한 철저한 검색이 너무 오래 걸리 차선책을 실행하는 데 따르는 형벌보다 더 긴 경우가 많습니다. 따라서 쿼리 크기의 임계 값은 GEQO 사용을 관리하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a0976de4de13332a56e83de88d1173b0054dd784" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;INHERITS&lt;/code&gt; creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; 를 사용 하면 새 하위 테이블과 해당 상위 테이블간에 지속적인 관계가 생성됩니다. 부모에 대한 스키마 수정은 일반적으로 자식에도 전파되며 기본적으로 자식 테이블의 데이터는 부모 스캔에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4eb26aa371684361e3e419e078890b371282ac" translate="yes" xml:space="preserve">
          <source>Use of most of these functions requires PostgreSQL to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">이러한 대부분의 기능을 사용하려면 PostgreSQL이 &lt;code&gt;configure --with-libxml&lt;/code&gt; 로 빌드되어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="c68e27d415e6287dfc4c6988546eee3d268cda34" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g. &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">&lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; 을 열 정의 에 첨부하여 특정 카탈로그 열에서 기호 참조를 사용할 수 있습니다 . 여기서 &lt;code&gt;lookuprule&lt;/code&gt; 은 참조 된 카탈로그의 이름입니다 (예 : &lt;code&gt;pg_proc&lt;/code&gt; ) . &lt;code&gt;BKI_LOOKUP&lt;/code&gt; 은 &lt;code&gt;Oid&lt;/code&gt; , &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;oidvector&lt;/code&gt; 또는 &lt;code&gt;Oid[]&lt;/code&gt; 유형의 열에 첨부 될 수 있습니다 . 후자의 두 경우에는 배열의 각 요소에 대한 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7de245d3c3aa0bf5e90f594f4cb93e3038943a92" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;RETURNING&lt;/code&gt; clause requires &lt;code&gt;SELECT&lt;/code&gt; privilege on all columns mentioned in &lt;code&gt;RETURNING&lt;/code&gt;. If you use the &lt;code&gt;query&lt;/code&gt; clause to insert rows from a query, you of course need to have &lt;code&gt;SELECT&lt;/code&gt; privilege on any table or column used in the query.</source>
          <target state="translated">의 사용 &lt;code&gt;RETURNING&lt;/code&gt; 절은 필요 &lt;code&gt;SELECT&lt;/code&gt; 에 언급 된 모든 컬럼에 대한 권한을 &lt;code&gt;RETURNING&lt;/code&gt; . &lt;code&gt;query&lt;/code&gt; 절을 사용하여 쿼리 에서 행을 삽입하는 경우 물론 쿼리에 사용 된 테이블 또는 열에 대해 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2aa84cc2dc2791298c5a401376b7bb182eec75e7" translate="yes" xml:space="preserve">
          <source>Use real data for experimentation. Using test data for setting up indexes will tell you what indexes you need for the test data, but that is all.</source>
          <target state="translated">실험에 실제 데이터를 사용하십시오. 인덱스 설정에 테스트 데이터를 사용하면 테스트 데이터에 필요한 인덱스가 무엇인지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="740a1a424b9afbaad4fd5f97eac328593356e696" translate="yes" xml:space="preserve">
          <source>Use semicolon followed by two newlines, rather than just newline, as the command entry terminator.</source>
          <target state="translated">세미콜론 다음에 명령 줄 종결 자로 줄 바꿈 대신 두 줄 바꿈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="493672dde3eb1e21802c93c463663707684dc28f" translate="yes" xml:space="preserve">
          <source>Use separate session key. Public-key encryption always uses a separate session key; this option is for symmetric-key encryption, which by default uses the S2K key directly.</source>
          <target state="translated">별도의 세션 키를 사용하십시오. 공개 키 암호화는 항상 별도의 세션 키를 사용합니다. 이 옵션은 대칭 키 암호화를위한 것으로 기본적으로 S2K 키를 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93c526253accc03345c125a338a69425d93d7a5c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; statement to drop views.</source>
          <target state="translated">&lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; 문을 사용하여 보기 를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="0d8fcf6d0e2c0c387fa9db23f6382b953340061f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션을 사용하십시오 . 자세한 내용은 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49e85f329c30105292985206289324c8f90af224" translate="yes" xml:space="preserve">
          <source>Use the alternative column-list syntax to do the same update:</source>
          <target state="translated">대체 열 목록 구문을 사용하여 동일한 업데이트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9ae2307b8f401e6a987e3d05544bf2939cd859f9" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_COLLATE&lt;/code&gt; locale category.</source>
          <target state="translated">&lt;code&gt;LC_COLLATE&lt;/code&gt; 로캘 범주에 지정된 운영 체제 로캘을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="55a394e7b9e61f2a206b4b6967eab6c67d2c7b7c" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale category.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 로캘 범주에 지정된 운영 체제 로캘을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2aa6b91b4c4ba84fa390b2a6da37aa75a60894a" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.87&lt;/a&gt; for more details).</source>
          <target state="translated">데이터베이스 덤프시 지정된 동기화 된 스냅 샷을 사용하십시오 ( 자세한 내용 은 &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;표 9.87&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="ee78ab2ce0e01deb66fa480713a33b2c2b35d2ab" translate="yes" xml:space="preserve">
          <source>Use the specified value of &lt;code&gt;extra_float_digits&lt;/code&gt; when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">부동 소수점 데이터를 덤프 할 때 사용 가능한 최대 정밀도 대신 &lt;code&gt;extra_float_digits&lt;/code&gt; 의 지정된 값을 사용하십시오 . 백업 목적으로 작성된 루틴 덤프는이 옵션을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="af4516f566a55d94c31709c01f556432e3bd7291" translate="yes" xml:space="preserve">
          <source>Use the specified value of extra_float_digits when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">부동 소수점 데이터를 덤프 할 때 사용 가능한 최대 정밀도 대신 extra_float_digits의 지정된 값을 사용하십시오. 백업 목적으로 작성된 루틴 덤프는이 옵션을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6f31da9aa85cb07454372ac17645a52a84247324" translate="yes" xml:space="preserve">
          <source>Use this sequence in an &lt;code&gt;INSERT&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 명령 에서이 순서를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="29370364d5a3aa7edfb47c0679c084d535a999d7" translate="yes" xml:space="preserve">
          <source>Used to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on any column appearing within &lt;code&gt;index_predicate&lt;/code&gt; is required.</source>
          <target state="translated">부분 고유 인덱스를 유추하는 데 사용됩니다. 술어를 만족시키는 인덱스 (실제로 인덱스 일 필요는 없음)가 유추 될 수 있습니다. &lt;code&gt;CREATE INDEX&lt;/code&gt; 형식을 따릅니다 . &lt;code&gt;index_predicate&lt;/code&gt; 내에 나타나는 모든 열에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1bfbb286795d184b793a60a1094e6c47b8ed4218" translate="yes" xml:space="preserve">
          <source>Useful values for production work probably range from a small number of hours to a few days. Small values (such as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1min&lt;/code&gt;) are only allowed because they may sometimes be useful for testing. While a setting as high as &lt;code&gt;60d&lt;/code&gt; is allowed, please note that in many workloads extreme bloat or transaction ID wraparound may occur in much shorter time frames.</source>
          <target state="translated">생산 작업에 유용한 값은 몇 시간에서 며칠까지입니다. 작은 값 (예 : &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1min&lt;/code&gt; )은 때때로 테스트에 유용 할 수 있기 때문에 허용됩니다. &lt;code&gt;60d&lt;/code&gt; 의 높은 설정 이 허용되는 동안 많은 워크로드에서 극단적 인 팽창 또는 트랜잭션 ID 랩 어라운드가 훨씬 짧은 시간 프레임에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aa9c997122e493dfcfb31ff0542b184a558e6ef" translate="yes" xml:space="preserve">
          <source>User Name Maps</source>
          <target state="translated">사용자 이름 맵</target>
        </trans-unit>
        <trans-unit id="657c8b98d31db02ca6e2f49846863d392059fe65" translate="yes" xml:space="preserve">
          <source>User bypasses every row level security policy, see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt; for more information.</source>
          <target state="translated">사용자는 모든 행 수준 보안 정책을 무시합니다 . 자세한 내용 은 &lt;a href=&quot;ddl-rowsecurity&quot;&gt;섹션 5.8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="17a367250b51dc731bdf8cbd166e2c6618238172" translate="yes" xml:space="preserve">
          <source>User can create databases</source>
          <target state="translated">사용자는 데이터베이스를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0cd638046cbfe5c1f3e3cd84a3d83b310d114f21" translate="yes" xml:space="preserve">
          <source>User can initiate streaming replication and put the system in and out of backup mode.</source>
          <target state="translated">사용자는 스트리밍 복제를 시작하고 시스템을 백업 모드로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62ff3be7aa18f82b61ae56cce7156698ab778283" translate="yes" xml:space="preserve">
          <source>User is a superuser</source>
          <target state="translated">사용자가 수퍼 유저</target>
        </trans-unit>
        <trans-unit id="0381065a82fe9d6c10d8cd3e9089f5c14f9312b8" translate="yes" xml:space="preserve">
          <source>User mapping specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;keyword = value&amp;rdquo;문자열과 같은 사용자 매핑 특정 옵션</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">사용자 이름</target>
        </trans-unit>
        <trans-unit id="0966c5e99e856745941e09bf863b1894eaa04766" translate="yes" xml:space="preserve">
          <source>User name for the user to run the service as. For domain users, use the format &lt;code&gt;DOMAIN\username&lt;/code&gt;.</source>
          <target state="translated">서비스를 실행할 사용자의 사용자 이름입니다. 도메인 사용자의 경우 &lt;code&gt;DOMAIN\username&lt;/code&gt; 형식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae03b2f53e94d67697836cc9ddba3d24303f1bd3" translate="yes" xml:space="preserve">
          <source>User name maps are defined in the ident map file, which by default is named &lt;code&gt;pg_ident.conf&lt;/code&gt; and is stored in the cluster's data directory. (It is possible to place the map file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; configuration parameter.) The ident map file contains lines of the general form:</source>
          <target state="translated">사용자 이름 맵은 기본적으로 &lt;code&gt;pg_ident.conf&lt;/code&gt; 라는 이름의 ident map 파일에 정의되며 클러스터의 데이터 디렉토리에 저장됩니다. 그러나 맵 파일을 다른 곳에 배치 할 수 있습니다 . &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; 구성 매개 변수를 참조하십시오 . ident 맵 파일에는 다음과 같은 일반적인 형식의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="26c83bd5ba1faee58ca4dfcad77ca8603bcdb897" translate="yes" xml:space="preserve">
          <source>User name of the mapping. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. &lt;code&gt;PUBLIC&lt;/code&gt; is used to match all present and future user names in the system.</source>
          <target state="translated">매핑의 사용자 이름 &lt;code&gt;CURRENT_USER&lt;/code&gt; 및 &lt;code&gt;USER&lt;/code&gt; 는 현재 사용자의 이름과 일치합니다. &lt;code&gt;PUBLIC&lt;/code&gt; 은 시스템에서 현재와 미래의 모든 사용자 이름을 일치시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f782be03fcdc443b383e428fe084103c7519032" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to create).</source>
          <target state="translated">연결할 사용자 이름 (생성 할 사용자 이름이 아님).</target>
        </trans-unit>
        <trans-unit id="58a48e5ec3f1ddd8734180ce7a8bcf7ce3e61813" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to drop).</source>
          <target state="translated">연결할 사용자 이름입니다 (삭제할 사용자 이름이 아님).</target>
        </trans-unit>
        <trans-unit id="6c7c5d855fc83ff64eb10669f8523b7d11212f01" translate="yes" xml:space="preserve">
          <source>User name to connect as.</source>
          <target state="translated">연결할 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="104f2eb40da0056ec5533c282848e3fce154c0c2" translate="yes" xml:space="preserve">
          <source>User name to connect as. Defaults to current operating system user name.</source>
          <target state="translated">연결할 사용자 이름입니다. 현재 운영 체제 사용자 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d47cce93b040f97f45693a064d2ec0fe0d47cbfa" translate="yes" xml:space="preserve">
          <source>User-defined constraint triggers (created with &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt;) also give rise to an entry in this table.</source>
          <target state="translated">&lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt; 로 작성된 사용자 정의 제한 조건 트리거 도이 테이블의 항목을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">사용자 정의 유형</target>
        </trans-unit>
        <trans-unit id="08a19bf7678e0c925ef7e00adabbc0a5965212bf" translate="yes" xml:space="preserve">
          <source>Users (roles) that are to be added to or removed from the group. The users must already exist; &lt;code&gt;ALTER GROUP&lt;/code&gt; does not create or drop users.</source>
          <target state="translated">그룹에 추가되거나 그룹에서 제거 될 사용자 (역할). 사용자는 이미 존재해야합니다. &lt;code&gt;ALTER GROUP&lt;/code&gt; 은 사용자를 만들거나 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c368e154de403e348ebf85b5c480f63c95e940b6" translate="yes" xml:space="preserve">
          <source>Users accustomed to working with other SQL database management systems might be disappointed by the performance of the &lt;code&gt;count&lt;/code&gt; aggregate when it is applied to the entire table. A query like:</source>
          <target state="translated">다른 SQL 데이터베이스 관리 시스템 작업에 익숙한 사용자는 성능에 실망 될 수 &lt;code&gt;count&lt;/code&gt; 가 전체 테이블에 적용 할 때 집계. 다음과 같은 쿼리 :</target>
        </trans-unit>
        <trans-unit id="ec14cfda8b568c538e7a2b35ec4764216fe766a6" translate="yes" xml:space="preserve">
          <source>Users can define their own range types. The most common reason to do this is to use ranges over subtypes not provided among the built-in range types. For example, to define a new range type of subtype &lt;code&gt;float8&lt;/code&gt;:</source>
          <target state="translated">사용자는 자신의 범위 유형을 정의 할 수 있습니다. 가장 일반적인 이유는 내장 된 범위 유형 중에서 제공되지 않은 하위 유형에 대한 범위를 사용하기 때문입니다. 예를 들어, 새로운 범위의 하위 유형 &lt;code&gt;float8&lt;/code&gt; 을 정의하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4944fa9df06f02dea3273ddeb97bb2eab5830741" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of user names means that there cannot be different users named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">클러스터 사용자는 반드시 클러스터의 모든 데이터베이스에 액세스 할 수있는 권한이 없습니다. 사용자 이름을 공유한다는 것은 동일한 클러스터의 두 데이터베이스에 &lt;code&gt;joe&lt;/code&gt; 라는 다른 사용자가있을 수 없음을 의미 합니다. 그러나 &lt;code&gt;joe&lt;/code&gt; 가 일부 데이터베이스에만 액세스 할 수 있도록 시스템을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="655defefcbd5cf77a94fb403c6b891d5f809540a" translate="yes" xml:space="preserve">
          <source>Users should be clear that tables that are regularly and heavily updated on the primary server will quickly cause cancellation of longer running queries on the standby. In such cases the setting of a finite value for &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; can be considered similar to setting &lt;code&gt;statement_timeout&lt;/code&gt;.</source>
          <target state="translated">사용자는 기본 서버에서 정기적으로 많이 업데이트 된 테이블이 대기에서 더 오래 실행되는 쿼리를 신속하게 취소 할 수 있음을 분명히해야합니다. 이러한 경우 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 또는 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 에 대한 유한 값 설정은 &lt;code&gt;statement_timeout&lt;/code&gt; 설정과 유사한 것으로 간주 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc34515c6a1d7984b3e11718da650ce1ef5ed348" translate="yes" xml:space="preserve">
          <source>Users sometimes try to declare operators applying just to a domain type. This is possible but is not nearly as useful as it might seem, because the operator resolution rules are designed to select operators applying to the domain's base type. As an example consider</source>
          <target state="translated">사용자는 때때로 도메인 유형에만 적용되는 연산자를 선언하려고합니다. 운영자 확인 규칙은 도메인의 기본 유형에 적용되는 운영자를 선택하도록 설계 되었기 때문에 이것이 가능하지만 거의 유용하지는 않습니다. 예를 들어 고려</target>
        </trans-unit>
        <trans-unit id="1772f82727e2e70cce145a14908f76eba9dee789" translate="yes" xml:space="preserve">
          <source>Users sometimes wonder why host names are handled in this seemingly complicated way, with two name resolutions including a reverse lookup of the client's IP address. This complicates use of the feature in case the client's reverse DNS entry is not set up or yields some undesirable host name. It is done primarily for efficiency: this way, a connection attempt requires at most two resolver lookups, one reverse and one forward. If there is a resolver problem with some address, it becomes only that client's problem. A hypothetical alternative implementation that only did forward lookups would have to resolve every host name mentioned in &lt;code&gt;pg_hba.conf&lt;/code&gt; during every connection attempt. That could be quite slow if many names are listed. And if there is a resolver problem with one of the host names, it becomes everyone's problem.</source>
          <target state="translated">사용자는 때때로 호스트 이름이 클라이언트처럼 보이는 IP 주소의 역방향 조회를 포함하여 두 가지 이름 확인을 통해 이처럼 복잡한 방식으로 처리되는 이유를 궁금해합니다. 이는 클라이언트의 역방향 DNS 항목이 설정되지 않았거나 바람직하지 않은 호스트 이름을 생성 할 경우이 기능의 사용을 복잡하게합니다. 이는 주로 효율성을 위해 수행됩니다. 이러한 방식으로 연결을 시도하려면 최대 2 개의 리졸버 조회가 필요합니다 (하나는 역방향 및 하나는 정방향). 일부 주소에 대한 리졸버 문제가있는 경우 해당 클라이언트의 문제 만됩니다. 정방향 조회 만 수행 한 가상의 대체 구현은 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 언급 된 모든 호스트 이름을 확인해야합니다.모든 연결 시도 중에. 많은 이름이 나열되면 상당히 느려질 수 있습니다. 호스트 이름 중 하나에 해결 자 문제가 있으면 모두의 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="4adcca052990f33f0c6c8200c5c596110e4cd88f" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">사용자는 &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; 를 실행하여 세션이 읽기 전용인지 여부를 알 수 있습니다 . 또한 일련의 기능 ( &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;표 9.85&lt;/a&gt; )을 통해 사용자는 대기 서버에 대한 정보에 액세스 할 수 있습니다. 이를 통해 데이터베이스의 현재 상태를 인식하는 프로그램을 작성할 수 있습니다. 이를 통해 복구 진행률을 모니터링하거나 데이터베이스를 특정 상태로 복원하는 복잡한 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28e2bf0df748000aab563d6b102d035c272f7dd2" translate="yes" xml:space="preserve">
          <source>Users will stop waiting if a fast shutdown is requested. However, as when using asynchronous replication, the server will not fully shutdown until all outstanding WAL records are transferred to the currently connected standby servers.</source>
          <target state="translated">빠른 종료가 요청되면 사용자는 대기를 중단합니다. 그러나 비동기 복제를 사용할 때와 같이 모든 미해결 WAL 레코드가 현재 연결된 대기 서버로 전송 될 때까지 서버가 완전히 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00379b69f39e7e2d3d7c05f05b12ede542302d0d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; on an object additionally requires &lt;code&gt;relabelfrom&lt;/code&gt; permission for the object in conjunction with its old security label and &lt;code&gt;relabelto&lt;/code&gt; permission for the object in conjunction with its new security label. (In cases where multiple label providers are installed and the user tries to set a security label, but it is not managed by SELinux, only &lt;code&gt;setattr&lt;/code&gt; should be checked here. This is currently not done due to implementation restrictions.)</source>
          <target state="translated">사용하여 &lt;a href=&quot;sql-security-label&quot;&gt;보안 레이블을&lt;/a&gt; 개체에 대한 것은 추가로 필요 &lt;code&gt;relabelfrom&lt;/code&gt; 의 옛 보안 레이블과와 함께 개체에 대한 권한을 &lt;code&gt;relabelto&lt;/code&gt; 새로운 보안 레이블과 함께 개체에 대한 권한을. (여러 레이블 제공자가 설치되어 있고 사용자가 보안 레이블을 설정하려고하지만 SELinux에서 관리하지 않는 경우 여기서 &lt;code&gt;setattr&lt;/code&gt; 만 점검해야합니다. 현재 구현 제한으로 인해 수행되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="7ba7d6f6db215ecebd0a0dd010a3ef4d72762c57" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; on this view, specifically updating the &lt;code&gt;setting&lt;/code&gt; column, is the equivalent of issuing &lt;code&gt;SET&lt;/code&gt; commands. For example, the equivalent of</source>
          <target state="translated">사용 &lt;a href=&quot;sql-update&quot;&gt;UPDATE를&lt;/a&gt; 구체적 갱신이보기 &lt;code&gt;setting&lt;/code&gt; 항목을 실행하는 것과 동일 &lt;code&gt;SET&lt;/code&gt; 의 명령. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9f4a279994eeee7b66ef6f4b6c4072e3efe337a2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ALL&lt;/code&gt; for a policy means that it will apply to all commands, regardless of the type of command. If an &lt;code&gt;ALL&lt;/code&gt; policy exists and more specific policies exist, then both the &lt;code&gt;ALL&lt;/code&gt; policy and the more specific policy (or policies) will be applied. Additionally, &lt;code&gt;ALL&lt;/code&gt; policies will be applied to both the selection side of a query and the modification side, using the &lt;code&gt;USING&lt;/code&gt; expression for both cases if only a &lt;code&gt;USING&lt;/code&gt; expression has been defined.</source>
          <target state="translated">정책에 &lt;code&gt;ALL&lt;/code&gt; 을 사용하면 명령 유형에 관계없이 모든 명령에 적용됩니다. 는 IF &lt;code&gt;ALL&lt;/code&gt; 의 다음 정책이 존재하고보다 구체적인 정책이 존재하는 양쪽 &lt;code&gt;ALL&lt;/code&gt; 정책과보다 구체적인 정책 (또는 정책) 적용됩니다. 또한 &lt;code&gt;ALL&lt;/code&gt; 정책은 사용하는 쿼리의 선택 측과 변형 양면에 적용되는 &lt;code&gt;USING&lt;/code&gt; 단지 두 경우 모두에 대한 식을 &lt;code&gt;USING&lt;/code&gt; 발현이 정의되었다.</target>
        </trans-unit>
        <trans-unit id="b1caa6904d1b2e3c70cf23410fccedf2e858e4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;DELETE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;DELETE&lt;/code&gt; commands. Only rows that pass this policy will be seen by a &lt;code&gt;DELETE&lt;/code&gt; command. There can be rows that are visible through a &lt;code&gt;SELECT&lt;/code&gt; that are not available for deletion, if they do not pass the &lt;code&gt;USING&lt;/code&gt; expression for the &lt;code&gt;DELETE&lt;/code&gt; policy.</source>
          <target state="translated">사용 &lt;code&gt;DELETE&lt;/code&gt; 가 적용하는 정책 수단에 대한 &lt;code&gt;DELETE&lt;/code&gt; 명령을. 이 정책을 통과 한 행만 &lt;code&gt;DELETE&lt;/code&gt; 명령 으로 표시됩니다 . &lt;code&gt;DELETE&lt;/code&gt; 정책에 대한 &lt;code&gt;USING&lt;/code&gt; 표현식을 전달하지 않으면 삭제할 수없는 &lt;code&gt;SELECT&lt;/code&gt; 를 통해 볼 수있는 행이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ba736c87dfcbb2c8e16a4a5fbcf41dc4d34ae6e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;INSERT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;INSERT&lt;/code&gt; commands. Rows being inserted that do not pass this policy will result in a policy violation error, and the entire &lt;code&gt;INSERT&lt;/code&gt; command will be aborted. An &lt;code&gt;INSERT&lt;/code&gt; policy cannot have a &lt;code&gt;USING&lt;/code&gt; expression, as it only applies in cases where records are being added to the relation.</source>
          <target state="translated">사용하여 &lt;code&gt;INSERT&lt;/code&gt; 를 이 적용됩니다있는 정책 수단에 대한 &lt;code&gt;INSERT&lt;/code&gt; 의 명령. 이 정책을 통과하지 않은 행을 삽입하면 정책 위반 오류가 발생하고 전체 &lt;code&gt;INSERT&lt;/code&gt; 명령이 중단됩니다. &lt;code&gt;INSERT&lt;/code&gt; 의 정책은 가질 수 없습니다 &lt;code&gt;USING&lt;/code&gt; 이 레코드 만의 관계에 추가되는 경우에 적용되는 표현입니다.</target>
        </trans-unit>
        <trans-unit id="4584b8b01123eb82dc7847c4d9677c40b0e5bba4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ONLY&lt;/code&gt; to add or drop a constraint on only the partitioned table is supported as long as there are no partitions. Once partitions exist, using &lt;code&gt;ONLY&lt;/code&gt; will result in an error as adding or dropping constraints on only the partitioned table, when partitions exist, is not supported. Instead, constraints on the partitions themselves can be added and (if they are not present in the parent table) dropped.</source>
          <target state="translated">파티션이없는 한 파티션 테이블에만 제한 조건을 추가하거나 삭제하기 위해 &lt;code&gt;ONLY&lt;/code&gt; 를 사용 하는 것이 지원됩니다. 파티션이 존재하면 &lt;code&gt;ONLY&lt;/code&gt; 를 사용하면 파티션이 존재 하는 경우 파티션 된 테이블에 대한 제한 조건 추가 또는 삭제가 지원되지 않으므로 오류가 발생합니다. 대신 파티션 자체에 대한 제약 조건을 추가하고 부모 테이블에없는 경우에는 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9191967f0b2195c21483c93a60dfe19fe3e18ef8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;. If the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; is defined in the client's environment, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">&lt;code&gt;PGCLIENTENCODING&lt;/code&gt; 사용 . 환경 변수 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; 이 클라이언트 환경에 정의되어 있으면 서버에 연결할 때 해당 클라이언트 인코딩이 자동으로 선택됩니다. (이는 위에서 언급 한 다른 방법을 사용하여 무시할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="de75f251dab5b0ad3801e8b63609c603b9f339f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SELECT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;SELECT&lt;/code&gt; queries and whenever &lt;code&gt;SELECT&lt;/code&gt; permissions are required on the relation the policy is defined for. The result is that only those records from the relation that pass the &lt;code&gt;SELECT&lt;/code&gt; policy will be returned during a &lt;code&gt;SELECT&lt;/code&gt; query, and that queries that require &lt;code&gt;SELECT&lt;/code&gt; permissions, such as &lt;code&gt;UPDATE&lt;/code&gt;, will also only see those records that are allowed by the &lt;code&gt;SELECT&lt;/code&gt; policy. A &lt;code&gt;SELECT&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being retrieved from the relation.</source>
          <target state="translated">사용하여 &lt;code&gt;SELECT&lt;/code&gt; 를 가 적용하는 정책 수단에 대한 &lt;code&gt;SELECT&lt;/code&gt; 쿼리를 때마다 &lt;code&gt;SELECT&lt;/code&gt; 권한이 관계에 필요한 정책이 정의됩니다. 결과적으로 &lt;code&gt;SELECT&lt;/code&gt; 정책 을 통과 한 관계의 레코드 만 &lt;code&gt;SELECT&lt;/code&gt; 쿼리 중에 반환 되고 &lt;code&gt;UPDATE&lt;/code&gt; 와 같은 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 필요한 쿼리 도 &lt;code&gt;SELECT&lt;/code&gt; 정책에 의해 허용 된 레코드 만 볼 수 있습니다. &lt;code&gt;SELECT&lt;/code&gt; 정책은있을 수 없습니다 &lt;code&gt;WITH CHECK&lt;/code&gt; 에만 기록이 관계로부터 검색되는 경우에 적용되는 표현.</target>
        </trans-unit>
        <trans-unit id="8ea11f118aea185625aef767542a580e19f76285" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SET client_encoding TO&lt;/code&gt;. Setting the client encoding can be done with this SQL command:</source>
          <target state="translated">사용 &lt;code&gt;SET client_encoding TO&lt;/code&gt; . 클라이언트 인코딩 설정은 다음 SQL 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e9a2e659e09abe2efa2c5be22d40b62c3aee16" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Type=notify&lt;/code&gt; requires that the server binary was built with &lt;code&gt;configure --with-systemd&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;Type=notify&lt;/code&gt; 서버 바이너리로 지어진 것을 요구 &lt;code&gt;configure --with-systemd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f17447546dfac5a3cba43658b86d3ae11e9f49a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;UPDATE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands, as well as auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clauses of &lt;code&gt;INSERT&lt;/code&gt; commands. Since &lt;code&gt;UPDATE&lt;/code&gt; involves pulling an existing record and replacing it with a new modified record, &lt;code&gt;UPDATE&lt;/code&gt; policies accept both a &lt;code&gt;USING&lt;/code&gt; expression and a &lt;code&gt;WITH CHECK&lt;/code&gt; expression. The &lt;code&gt;USING&lt;/code&gt; expression determines which records the &lt;code&gt;UPDATE&lt;/code&gt; command will see to operate against, while the &lt;code&gt;WITH CHECK&lt;/code&gt; expression defines which modified rows are allowed to be stored back into the relation.</source>
          <target state="translated">정책에 &lt;code&gt;UPDATE&lt;/code&gt; 를 사용하면 &lt;code&gt;INSERT&lt;/code&gt; 명령 의 보조 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절 뿐만 아니라 &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 명령에도 적용됩니다 . 이후 &lt;code&gt;UPDATE&lt;/code&gt; 기존 기록을 당겨 새로운 수정 된 레코드로 교체 포함, &lt;code&gt;UPDATE&lt;/code&gt; 의 정책은 모두 받아 &lt;code&gt;USING&lt;/code&gt; 표현하고 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현. &lt;code&gt;USING&lt;/code&gt; 레코드를 결정 식 &lt;code&gt;UPDATE&lt;/code&gt; 명령은 동작에 대해 표시되는 동안 &lt;code&gt;WITH CHECK&lt;/code&gt; expression은 수정 된 행을 관계에 다시 저장할 수 있도록 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4872b905960b3b0bb609a1d1f16d8a8085172d7f" translate="yes" xml:space="preserve">
          <source>Using WAL results in a significantly reduced number of disk writes, because only the log file needs to be flushed to disk to guarantee that a transaction is committed, rather than every data file changed by the transaction. The log file is written sequentially, and so the cost of syncing the log is much less than the cost of flushing the data pages. This is especially true for servers handling many small transactions touching different parts of the data store. Furthermore, when the server is processing many small concurrent transactions, one &lt;code&gt;fsync&lt;/code&gt; of the log file may suffice to commit many transactions.</source>
          <target state="translated">WAL을 사용하면 트랜잭션에 의해 변경된 모든 데이터 파일이 아니라 트랜잭션이 커밋되도록 로그 파일 만 디스크로 플러시되어야하기 때문에 디스크 쓰기 수가 크게 줄어 듭니다. 로그 파일은 순차적으로 작성되므로 로그 동기화 비용은 데이터 페이지 플러시 비용보다 훨씬 적습니다. 이는 데이터 저장소의 다른 부분에 닿는 많은 소규모 트랜잭션을 처리하는 서버에서 특히 그렇습니다. 또한 서버가 여러 개의 작은 동시 트랜잭션을 처리 할 때 많은 트랜잭션을 커밋하기 위해 로그 파일의 한 &lt;code&gt;fsync&lt;/code&gt; 로 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e62e4e51350449dc0eec4f1e12ec4aa76a1f3f9" translate="yes" xml:space="preserve">
          <source>Using a separate script file is advisable any time you want to use more than a single command in the archiving process. This allows all complexity to be managed within the script, which can be written in a popular scripting language such as bash or perl.</source>
          <target state="translated">아카이브 프로세스에서 둘 이상의 명령을 사용하려는 경우에는 별도의 스크립트 파일을 사용하는 것이 좋습니다. 이를 통해 스크립트 내에서 모든 복잡성을 관리 할 수 ​​있으며 bash 또는 perl과 같은 널리 사용되는 스크립팅 언어로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b28cc95da9f9c8ec1f9441e5caff1c654ea239b4" translate="yes" xml:space="preserve">
          <source>Using a simple integer &lt;code&gt;offset&lt;/code&gt; is preferred when defining an abbreviation whose offset from UTC has never changed, as such abbreviations are much cheaper to process than those that require consulting a time zone definition.</source>
          <target state="translated">UTC에서 오프셋이 변경되지 않은 약어를 정의 할 때는 시간대 정의를 참조해야하는 약어보다 처리가 훨씬 저렴 하므로 간단한 정수 &lt;code&gt;offset&lt;/code&gt; 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d159535298801ecd67e86d11daf24d3f29bae4e5" translate="yes" xml:space="preserve">
          <source>Using a table:</source>
          <target state="translated">테이블 사용하기 :</target>
        </trans-unit>
        <trans-unit id="97a7d609ae1fc837ff854c4a8fe8b3cbd1349e8b" translate="yes" xml:space="preserve">
          <source>Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial.</source>
          <target state="translated">pgAdmin과 같은 기존 그래픽 프론트 엔드 도구 또는 ODBC 또는 JDBC 지원 기능이있는 오피스 스위트를 사용하여 데이터베이스를 작성하고 조작합니다. 이러한 가능성은이 튜토리얼에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b0ce3043e87fd971bf85082c10b3ea412051c05" translate="yes" xml:space="preserve">
          <source>Using filter expressions at different nesting levels is also allowed. The following example first filters all segments by location, and then returns high heart rate values for these segments, if available:</source>
          <target state="translated">서로 다른 중첩 수준에서 필터 식을 사용할 수도 있습니다. 다음 예제는 먼저 위치별로 모든 세그먼트를 필터링 한 다음 가능한 경우 해당 세그먼트에 대한 높은 심박수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f87542d489a5d09a003c3d32c1fdd090240fb1a" translate="yes" xml:space="preserve">
          <source>Using huge pages reduces overhead when using large contiguous chunks of memory, as PostgreSQL does, particularly when using large values of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;. To use this feature in PostgreSQL you need a kernel with &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; and &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt;. You will also have to adjust the kernel setting &lt;code&gt;vm.nr_hugepages&lt;/code&gt;. To estimate the number of huge pages needed, start PostgreSQL without huge pages enabled and check the postmaster's anonymous shared memory segment size, as well as the system's huge page size, using the &lt;code&gt;/proc&lt;/code&gt; file system. This might look like:</source>
          <target state="translated">큰 페이지를 사용하면 PostgreSQL과 같이 특히 큰 값의 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers를&lt;/a&gt; 사용할 때 큰 연속 메모리 청크를 사용할 때 오버 헤드가 줄어 듭니다 . PostgreSQL에서이 기능을 사용하려면 &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; 및 &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt; 인 커널이 필요합니다 . 커널 설정 &lt;code&gt;vm.nr_hugepages&lt;/code&gt; 도 조정해야합니다 . 필요한 대용량 페이지 수를 추정하려면 대용량 페이지를 사용하지 않고 PostgreSQL을 시작하고 &lt;code&gt;/proc&lt;/code&gt; 파일 시스템을 사용하여 포스트 마스터의 익명 공유 메모리 세그먼트 크기와 시스템의 대용량 페이지 크기를 확인하십시오 . 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0f4579fb33ddb8969cb60774c58272e5c781549" translate="yes" xml:space="preserve">
          <source>Using just common sense, it appears more convenient to store such data as intervals, rather than pairs of numbers. In practice, it even turns out more efficient in most applications.</source>
          <target state="translated">상식을 사용하면 숫자 쌍이 아닌 간격으로 데이터를 저장하는 것이 더 편리합니다. 실제로 대부분의 응용 프로그램에서 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a8fc95773ce3956bab8c2e8bf2027d9e849d1b1f" translate="yes" xml:space="preserve">
          <source>Using psql on a recently vacuumed or analyzed database, you can issue queries to see the disk usage of any table:</source>
          <target state="translated">최근에 정리되었거나 분석 된 데이터베이스에서 psql을 사용하면 쿼리를 실행하여 테이블의 디스크 사용량을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65181e02239e5820a5b7c0dec699536af98e9eef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command recurse to objects owned by other users.</source>
          <target state="translated">&lt;code&gt;CASCADE&lt;/code&gt; 옵션을 사용하면 다른 사용자가 소유 한 객체로 명령이 재귀 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3919689ac7e30c1a7b51bdbeb0b298903ed7b06" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command remove objects in other schemas besides the one(s) named.</source>
          <target state="translated">은 Using &lt;code&gt;CASCADE&lt;/code&gt; 의 옵션은 이름의 한 (들) 이외의 다른 스키마에서 명령 제거 개체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d956f8965b7e70f75d823768214bbad6a425210" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;\encoding&lt;/code&gt; command in psql. &lt;code&gt;\encoding&lt;/code&gt; allows you to change client encoding on the fly. For example, to change the encoding to &lt;code&gt;SJIS&lt;/code&gt;, type:</source>
          <target state="translated">psql에서 &lt;code&gt;\encoding&lt;/code&gt; 명령 사용 &lt;code&gt;\encoding&lt;/code&gt; 사용하면 클라이언트 인코딩을 즉시 변경할 수 있습니다. 예를 들어, 인코딩을 &lt;code&gt;SJIS&lt;/code&gt; 로 변경하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="ce95ab1950e8fbb1a63e8b189b58b6a856d611e2" translate="yes" xml:space="preserve">
          <source>Using the configuration variable &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;. If the &lt;code&gt;client_encoding&lt;/code&gt; variable is set, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">구성 변수 &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding 사용&lt;/a&gt; . 경우] &lt;code&gt;client_encoding&lt;/code&gt; 변수가 설정되어 서버에 연결되면, 해당 클라이언트 인코딩이 자동으로 선택된다. (이는 위에서 언급 한 다른 방법을 사용하여 무시할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="7b44d852d97da519564a9d99f8e49c858203cdb6" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;&lt;code&gt;UNION&lt;/code&gt; Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;&lt;code&gt;INTERSECT&lt;/code&gt; Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;&lt;code&gt;EXCEPT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">연산자 &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; 및 &lt;code&gt;EXCEPT&lt;/code&gt; 를 사용하면 둘 이상의 &lt;code&gt;SELECT&lt;/code&gt; 문의 출력을 결합하여 단일 결과 집합을 구성 할 수 있습니다. &lt;code&gt;UNION&lt;/code&gt; 오퍼레이터는 결과 세트 중 하나 또는 모두에 모든 행을 반환한다. &lt;code&gt;INTERSECT&lt;/code&gt; 의 연산자는 두 결과 집합에 엄격 모든 행을 반환합니다. &lt;code&gt;EXCEPT&lt;/code&gt; 연산자는 최초 결과 집합 아니라 초에 행을 반환한다. 하지 않는 한 세 가지 경우 모두, 중복 행은 제거되고 &lt;code&gt;ALL&lt;/code&gt; 을 지정 됩니다. 중복 단어 제거를 명시 적으로 지정하기 위해 노이즈 단어 &lt;code&gt;DISTINCT&lt;/code&gt; 를 추가 할 수 있습니다. 그주의 &lt;code&gt;DISTINCT&lt;/code&gt; 를여기서는 &lt;code&gt;ALL&lt;/code&gt; 이 &lt;code&gt;SELECT&lt;/code&gt; 자체 의 기본값 이지만 기본 동작 입니다. (아래의 &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt; &lt;code&gt;UNION&lt;/code&gt; 절&lt;/a&gt;&lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt; &lt;code&gt;EXCEPT&lt;/code&gt; &lt;/a&gt; 절을 참조하십시오.), &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt; &lt;code&gt;INTERSECT&lt;/code&gt; 조항&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="345d4ccffce95dcf05491c18eea8197735fd71fd" translate="yes" xml:space="preserve">
          <source>Using this command, it is possible to either add privileges or restrict one's privileges. If the session user role has the &lt;code&gt;INHERIT&lt;/code&gt; attribute, then it automatically has all the privileges of every role that it could &lt;code&gt;SET ROLE&lt;/code&gt; to; in this case &lt;code&gt;SET ROLE&lt;/code&gt; effectively drops all the privileges assigned directly to the session user and to the other roles it is a member of, leaving only the privileges available to the named role. On the other hand, if the session user role has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, &lt;code&gt;SET ROLE&lt;/code&gt; drops the privileges assigned directly to the session user and instead acquires the privileges available to the named role.</source>
          <target state="translated">이 명령을 사용하여 권한을 추가하거나 권한을 제한 할 수 있습니다. 세션 사용자 역할에 &lt;code&gt;INHERIT&lt;/code&gt; 속성이 있으면 &lt;code&gt;SET ROLE&lt;/code&gt; 이 할 수있는 모든 역할의 모든 권한이 자동으로 부여 됩니다. 이 경우 &lt;code&gt;SET ROLE&lt;/code&gt; 은 세션 사용자 및 해당 구성원이 속한 다른 역할에 직접 할당 된 모든 권한을 효과적으로 삭제하고 명명 된 역할에 사용 가능한 권한 만 남겨 둡니다. 반면 세션 사용자 역할에 &lt;code&gt;NOINHERIT&lt;/code&gt; 속성 이 있으면 &lt;code&gt;SET ROLE&lt;/code&gt; 은 세션 사용자에게 직접 지정된 권한을 삭제하고 대신 지정된 역할에 사용 가능한 권한을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="bf3833196f5808681a4549e6dae3e11c17ff7d14" translate="yes" xml:space="preserve">
          <source>Using this option is subtly different from writing &lt;code&gt;psql &amp;lt; filename&lt;/code&gt;. In general, both will do what you expect, but using &lt;code&gt;-f&lt;/code&gt; enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand.</source>
          <target state="translated">이 옵션을 사용하는 것은 &lt;code&gt;psql &amp;lt; filename&lt;/code&gt; 작성과 미묘하게 다릅니다 . 일반적으로 두 가지 모두 예상대로 작동하지만 &lt;code&gt;-f&lt;/code&gt; 를 사용하면 줄 번호가있는 오류 메시지와 같은 멋진 기능이 활성화됩니다. 이 옵션을 사용하면 시작 오버 헤드가 줄어들 가능성이 약간 있습니다. 반면에 쉘의 입력 경로 재 지정을 사용하는 변형은 이론적으로는 모든 것을 직접 입력했을 때와 동일한 출력을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="bb94658d71fedbd45e9091422be0f40e3960ad97" translate="yes" xml:space="preserve">
          <source>Usually, a row reflecting an incorrect entry will have values for only the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; fields.</source>
          <target state="translated">일반적으로 잘못된 항목을 반영하는 행에는 &lt;code&gt;line_number&lt;/code&gt; 및 &lt;code&gt;error&lt;/code&gt; 필드 의 값만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="615ff5ce2e5448f0eae82299f9e03df2b83f7a7d" translate="yes" xml:space="preserve">
          <source>VACUUM &amp;mdash; garbage-collect and optionally analyze a database</source>
          <target state="translated">VACUUM &amp;mdash; 가비지 수집 및 선택적으로 데이터베이스 분석</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="7e2bb4ebd8bb3d86c6acc1d3b34b4607a8278459" translate="yes" xml:space="preserve">
          <source>VALUES &amp;mdash; compute a set of rows</source>
          <target state="translated">값 &amp;mdash; 행 집합 계산</target>
        </trans-unit>
        <trans-unit id="df605145d9028810fbbd6bb82ba2cbbdf49fe2f6" translate="yes" xml:space="preserve">
          <source>VALUES Lists</source>
          <target state="translated">값 목록</target>
        </trans-unit>
        <trans-unit id="49310dbe4a27690da5f29db4c406ef0b0e02e27a" translate="yes" xml:space="preserve">
          <source>Vacuum all databases.</source>
          <target state="translated">모든 데이터베이스를 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="d78bc05489ae0681fdd181a90fe2d3af72c88331" translate="yes" xml:space="preserve">
          <source>Vacuum all four standard tables before running the test. With neither &lt;code&gt;-n&lt;/code&gt; nor &lt;code&gt;-v&lt;/code&gt;, pgbench will vacuum the &lt;code&gt;pgbench_tellers&lt;/code&gt; and &lt;code&gt;pgbench_branches&lt;/code&gt; tables, and will truncate &lt;code&gt;pgbench_history&lt;/code&gt;.</source>
          <target state="translated">테스트를 실행하기 전에 4 개의 표준 테이블을 모두 진공 청소기로 청소하십시오. 도 함께 &lt;code&gt;-n&lt;/code&gt; 도 &lt;code&gt;-v&lt;/code&gt; , pgbench는 진공 청소기로 청소한다 &lt;code&gt;pgbench_tellers&lt;/code&gt; 및 &lt;code&gt;pgbench_branches&lt;/code&gt; 것이다 잘라 내기 테이블을, 그리고 &lt;code&gt;pgbench_history&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="558c7ef6cec7040888bc23237bf5bc10ac6c115d" translate="yes" xml:space="preserve">
          <source>Vacuum also allows removal of old files from the &lt;code&gt;pg_xact&lt;/code&gt; subdirectory, which is why the default is a relatively low 200 million transactions. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="translated">Vacuum은 또한 &lt;code&gt;pg_xact&lt;/code&gt; 서브 디렉토리 에서 오래된 파일을 제거 할 수있게 하므로 기본값은 2 억 건의 트랜잭션입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있지만 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 줄일 수 있습니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4af123f2e65a46f53e9a9ee64ca03a1079be929" translate="yes" xml:space="preserve">
          <source>Vacuum maintains a &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; for each table to keep track of which pages contain only tuples that are known to be visible to all active transactions (and all future transactions, until the page is again modified). This has two purposes. First, vacuum itself can skip such pages on the next run, since there is nothing to clean up.</source>
          <target state="translated">Vacuum 은 각 테이블에 대한 &lt;a href=&quot;storage-vm&quot;&gt;가시성 맵&lt;/a&gt; 을 유지하여 모든 활성 트랜잭션 (및 페이지가 다시 수정 될 때까지 모든 미래 트랜잭션에 표시되는 것으로 알려진 튜플 만 포함)을 추적하는 페이지를 추적합니다. 이것은 두 가지 목적이 있습니다. 첫째, 진공 청소 자체는 정리할 것이 없기 때문에 다음 실행에서 이러한 페이지를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fb0ba1bca8b404cfdbdb7679f9f4d296fc6f1fa" translate="yes" xml:space="preserve">
          <source>Vacuuming multixacts also allows removal of old files from the &lt;code&gt;pg_multixact/members&lt;/code&gt; and &lt;code&gt;pg_multixact/offsets&lt;/code&gt; subdirectories, which is why the default is a relatively low 400 million multixacts. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="translated">multixact를 진공 청소기로 청소하면 &lt;code&gt;pg_multixact/members&lt;/code&gt; 및 &lt;code&gt;pg_multixact/offsets&lt;/code&gt; 서브 디렉토리 에서 오래된 파일을 제거 할 수 있습니다. 이것이 기본값이 4 억 개의 multixact입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있지만 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 줄일 수 있습니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;24.1.5.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac19d033655fd012b97b53639462b257da978e6a" translate="yes" xml:space="preserve">
          <source>Valid Types</source>
          <target state="translated">유효한 유형</target>
        </trans-unit>
        <trans-unit id="c7e5f1bbc3dc93b5ff6072a3bc81757a3ed075d7" translate="yes" xml:space="preserve">
          <source>Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional &lt;code&gt;AD&lt;/code&gt; or &lt;code&gt;BC&lt;/code&gt;. (Alternatively, &lt;code&gt;AD&lt;/code&gt;/&lt;code&gt;BC&lt;/code&gt; can appear before the time zone, but this is not the preferred ordering.) Thus:</source>
          <target state="translated">타임 스탬프 유형에 유효한 입력은 날짜와 시간을 연결 한 다음 선택적 시간대와 선택적 &lt;code&gt;AD&lt;/code&gt; 또는 &lt;code&gt;BC&lt;/code&gt; 로 구성 됩니다. (대체 &lt;code&gt;AD&lt;/code&gt; / &lt;code&gt;BC&lt;/code&gt; 시간대 앞에 가 나타날 수 있지만이 순서는 선호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3fd0054c277594413eaed1c75df986510128d67" translate="yes" xml:space="preserve">
          <source>Valid input for these types consists of a time of day followed by an optional time zone. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;Table 8.11&lt;/a&gt; and &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;Table 8.12&lt;/a&gt;.) If a time zone is specified in the input for &lt;code&gt;time without time zone&lt;/code&gt;, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as &lt;code&gt;America/New_York&lt;/code&gt;. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the &lt;code&gt;time with time zone&lt;/code&gt; value.</source>
          <target state="translated">이 유형에 유효한 입력은 시간대와 선택적 시간대로 구성됩니다. ( &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;표 8.11&lt;/a&gt; 및 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;표 8.12&lt;/a&gt; 참조 ) 시간대가 &lt;code&gt;time without time zone&lt;/code&gt; 에 대한 입력에 시간대가 지정된 경우 자동 무시됩니다. 날짜를 지정할 수도 있지만 &lt;code&gt;America/New_York&lt;/code&gt; 와 같은 일광 절약 규칙이 포함 된 시간대 이름을 사용하는 경우를 제외하고는 날짜가 무시됩니다 . 이 경우 표준 또는 일광 절약 시간이 적용되는지 확인하려면 날짜를 지정해야합니다. 적절한 시간대 오프셋은 &lt;code&gt;time with time zone&lt;/code&gt; 값이 있는 시간에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="844edfde8ce5da216439f5cc862b141254fb9d4a" translate="yes" xml:space="preserve">
          <source>Valid memory units are &lt;code&gt;B&lt;/code&gt; (bytes), &lt;code&gt;kB&lt;/code&gt; (kilobytes), &lt;code&gt;MB&lt;/code&gt; (megabytes), &lt;code&gt;GB&lt;/code&gt; (gigabytes), and &lt;code&gt;TB&lt;/code&gt; (terabytes). The multiplier for memory units is 1024, not 1000.</source>
          <target state="translated">유효한 메모리 단위는 &lt;code&gt;B&lt;/code&gt; (바이트), &lt;code&gt;kB&lt;/code&gt; (킬로바이트), &lt;code&gt;MB&lt;/code&gt; (메가 바이트), &lt;code&gt;GB&lt;/code&gt; (기가 바이트) 및 &lt;code&gt;TB&lt;/code&gt; (테라 바이트)입니다. 메모리 단위의 승수는 1000이 아니라 1024입니다.</target>
        </trans-unit>
        <trans-unit id="239bf25206857881980ea876d3982e5ae2994831" translate="yes" xml:space="preserve">
          <source>Valid starting points for standby queries are generated at each checkpoint on the master. If the standby is shut down while the master is in a shutdown state, it might not be possible to re-enter Hot Standby until the primary is started up, so that it generates further starting points in the WAL logs. This situation isn't a problem in the most common situations where it might happen. Generally, if the primary is shut down and not available anymore, that's likely due to a serious failure that requires the standby being converted to operate as the new primary anyway. And in situations where the primary is being intentionally taken down, coordinating to make sure the standby becomes the new primary smoothly is also standard procedure.</source>
          <target state="translated">대기 조회에 대한 유효한 시작점이 마스터의 각 체크 포인트에서 생성됩니다. 마스터가 종료 상태에있는 동안 대기가 종료되면 기본이 시작될 때까지 핫 스탠바이를 다시 입력하지 못할 수 있으므로 WAL 로그에 추가 시작점이 생성됩니다. 이 상황은 발생할 수있는 가장 일반적인 상황에서는 문제가되지 않습니다. 일반적으로 1 차가 종료되어 더 이상 사용할 수없는 경우 대기가 새 1 차로 작동하도록 변환해야하는 심각한 장애가 원인 일 수 있습니다. 1 차가 의도적으로 중단되는 상황에서 대기가 새 1 차가 순조롭게되도록 조정하는 것도 표준 절차입니다.</target>
        </trans-unit>
        <trans-unit id="36d562c59f538b4cf6287a1bc49b7023b220600a" translate="yes" xml:space="preserve">
          <source>Valid time units are &lt;code&gt;us&lt;/code&gt; (microseconds), &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), &lt;code&gt;min&lt;/code&gt; (minutes), &lt;code&gt;h&lt;/code&gt; (hours), and &lt;code&gt;d&lt;/code&gt; (days).</source>
          <target state="translated">유효한 시간 단위는 &lt;code&gt;us&lt;/code&gt; (마이크로 초), &lt;code&gt;ms&lt;/code&gt; (밀리 초), &lt;code&gt;s&lt;/code&gt; (초), &lt;code&gt;min&lt;/code&gt; (분), &lt;code&gt;h&lt;/code&gt; (시간) 및 &lt;code&gt;d&lt;/code&gt; (일)입니다.</target>
        </trans-unit>
        <trans-unit id="dfda311a4ab9af803299c88d82467b20a4636196" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;field&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 의 유효한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e71de8159ccd805dfaf84c4abe0cc37c7fd0bef" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">유효한 변수 이름은 문자, 숫자 및 밑줄을 포함 할 수 있습니다. 자세한 내용은 아래 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수&lt;/a&gt; 섹션 을 참조하십시오. 변수 이름은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="6495bdc388499bc5f8ab2cec7e4d413da357e199" translate="yes" xml:space="preserve">
          <source>Validate the catalog entries for the specified operator class, so far as the access method can reasonably do that. For example, this might include testing that all required support functions are provided. The &lt;code&gt;amvalidate&lt;/code&gt; function must return false if the opclass is invalid. Problems should be reported with &lt;code&gt;ereport&lt;/code&gt; messages.</source>
          <target state="translated">액세스 메소드가 합리적으로 수행 할 수있는 한, 지정된 연산자 클래스의 카탈로그 항목을 유효성 검증하십시오. 예를 들어 여기에는 필요한 모든 지원 기능이 제공되는지 테스트하는 것이 포함될 수 있습니다. &lt;code&gt;amvalidate&lt;/code&gt; 의 opclass가 무효 인 경우 함수는 false를 반환해야합니다. &lt;code&gt;ereport&lt;/code&gt; 메시지 와 함께 문제를보고해야 합니다.</target>
        </trans-unit>
        <trans-unit id="89711f6e0ac15ee4534c22e657dbb299816df29f" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag)</source>
          <target state="translated">유효하지 않은 숫자를 확인합니다 (유효하지 않은 플래그를 지 웁니다).</target>
        </trans-unit>
        <trans-unit id="a914a2300c495dde9a239ee72a952fef70648b1b" translate="yes" xml:space="preserve">
          <source>Value Example</source>
          <target state="translated">가치 예</target>
        </trans-unit>
        <trans-unit id="892634b1322b72a29145754cdb909390816e79df" translate="yes" xml:space="preserve">
          <source>Value Expressions</source>
          <target state="translated">가치 표현</target>
        </trans-unit>
        <trans-unit id="b69a17e345014c4860d42b3ea12bfd1d74a98205" translate="yes" xml:space="preserve">
          <source>Value Expressions: Aggregate Expressions</source>
          <target state="translated">값 표현 : 집계 표현</target>
        </trans-unit>
        <trans-unit id="62258d667ea100846bebdafcf33e6ba0d80bc0cf" translate="yes" xml:space="preserve">
          <source>Value Expressions: Array Constructors</source>
          <target state="translated">값 표현 : 배열 생성자</target>
        </trans-unit>
        <trans-unit id="538d0773b42800a1dced9ebd66981d039270223a" translate="yes" xml:space="preserve">
          <source>Value Expressions: Collation Expressions</source>
          <target state="translated">값 식 : 데이터 정렬 식</target>
        </trans-unit>
        <trans-unit id="09b3d5a6d9bce4eae0f96433329fd2780b515b1d" translate="yes" xml:space="preserve">
          <source>Value Expressions: Column References</source>
          <target state="translated">값 표현식 : 열 참조</target>
        </trans-unit>
        <trans-unit id="0f5899e3893a9e71da04384ff81d2b0668b66cce" translate="yes" xml:space="preserve">
          <source>Value Expressions: Expression Evaluation Rules</source>
          <target state="translated">값 표현 : 표현 평가 규칙</target>
        </trans-unit>
        <trans-unit id="7a33243a5a764268dbc19c7b5d5ffb815f2b2494" translate="yes" xml:space="preserve">
          <source>Value Expressions: Field Selection</source>
          <target state="translated">값 표현 : 필드 선택</target>
        </trans-unit>
        <trans-unit id="fc2734409ea30f439f8007a816c89fd5d4964498" translate="yes" xml:space="preserve">
          <source>Value Expressions: Function Calls</source>
          <target state="translated">값 표현 : 함수 호출</target>
        </trans-unit>
        <trans-unit id="06ab5a8d541c803b5a6f5f5baa72444250b7d0c9" translate="yes" xml:space="preserve">
          <source>Value Expressions: Operator Invocations</source>
          <target state="translated">값 표현 : 연산자 호출</target>
        </trans-unit>
        <trans-unit id="e5f7f7098e87803a977afb22b3e716623af90f8e" translate="yes" xml:space="preserve">
          <source>Value Expressions: Positional Parameters</source>
          <target state="translated">값 표현 : 위치 매개 변수</target>
        </trans-unit>
        <trans-unit id="c58f459ac2b52cf9d74d05fef53f0cf74dcac929" translate="yes" xml:space="preserve">
          <source>Value Expressions: Row Constructors</source>
          <target state="translated">값 표현 : 행 생성자</target>
        </trans-unit>
        <trans-unit id="2c538998fa55638c7ded3a8a283b8e9feb0bd885" translate="yes" xml:space="preserve">
          <source>Value Expressions: Scalar Subqueries</source>
          <target state="translated">값 표현 : 스칼라 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="1da69c14dd40700afb2c0a8abd86f7b740450e6f" translate="yes" xml:space="preserve">
          <source>Value Expressions: Subscripts</source>
          <target state="translated">값 표현 : 첨자</target>
        </trans-unit>
        <trans-unit id="cccb4f69d3a8cb038ef6a413bb2c663923cd9fc0" translate="yes" xml:space="preserve">
          <source>Value Expressions: Type Casts</source>
          <target state="translated">값 표현 : 타입 캐스트</target>
        </trans-unit>
        <trans-unit id="3715da19fdcfeeba7fe50bb93e020a8b25f6a530" translate="yes" xml:space="preserve">
          <source>Value Expressions: Window Function Calls</source>
          <target state="translated">값 표현식 : 창 함수 호출</target>
        </trans-unit>
        <trans-unit id="bf4f8a0decbb4b4fd4371821f1c74ba9a1594ce9" translate="yes" xml:space="preserve">
          <source>Value Storage</source>
          <target state="translated">가치 저장</target>
        </trans-unit>
        <trans-unit id="2977eb7ab7cb1230619c6002ed4cbbc6cc756fa6" translate="yes" xml:space="preserve">
          <source>Value expressions are used in a variety of contexts, such as in the target list of the &lt;code&gt;SELECT&lt;/code&gt; command, as new column values in &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or in search conditions in a number of commands. The result of a value expression is sometimes called a &lt;em&gt;scalar&lt;/em&gt;, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called &lt;em&gt;scalar expressions&lt;/em&gt; (or even simply &lt;em&gt;expressions&lt;/em&gt;). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations.</source>
          <target state="translated">값 표현식은 &lt;code&gt;SELECT&lt;/code&gt; 명령 의 대상 목록 , &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 의 새 열 값 또는 여러 명령의 검색 조건 과 같은 다양한 컨텍스트에서 사용됩니다. 테이블 표현식 (테이블)의 결과와 구별하기 위해 값 표현식의 결과를 &lt;em&gt;스칼라&lt;/em&gt; 라고도합니다 . 따라서 값 표현식은 &lt;em&gt;스칼라 표현식&lt;/em&gt; (또는 단순히 &lt;em&gt;표현식&lt;/em&gt; ) 이라고도 합니다. 표현식 구문을 사용하면 산술, 논리, 집합 및 기타 연산을 사용하여 기본 부분의 값을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="114f96aeed1ddb1f81a693ccadc122b00691f706" translate="yes" xml:space="preserve">
          <source>Value that &lt;code&gt;RESET&lt;/code&gt; would reset the parameter to in the current session</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 이 현재 세션에서 매개 변수를 재설정하는 값</target>
        </trans-unit>
        <trans-unit id="28c18b9457473dab8964985ffc208f4a1973292c" translate="yes" xml:space="preserve">
          <source>Value to be assigned to the parameter</source>
          <target state="translated">파라미터에 할당 할 값</target>
        </trans-unit>
        <trans-unit id="f84541e98210f793e8890e82c64afbe27a9c9a73" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;false&lt;/code&gt; literal</source>
          <target state="translated">JSON &lt;code&gt;false&lt;/code&gt; 리터럴 과 비교하는 데 사용되는 값</target>
        </trans-unit>
        <trans-unit id="f129faa853bacb07b12134ac4fd986301a263b11" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;null&lt;/code&gt; value</source>
          <target state="translated">JSON &lt;code&gt;null&lt;/code&gt; 값 과 비교하는 데 사용되는 값</target>
        </trans-unit>
        <trans-unit id="8a792873148b2fe92c538941fe93212a85f960e9" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;true&lt;/code&gt; literal</source>
          <target state="translated">JSON &lt;code&gt;true&lt;/code&gt; 리터럴 과 비교하는 데 사용되는 값</target>
        </trans-unit>
        <trans-unit id="e8086792911df062e24caa3131a5135743c9b16c" translate="yes" xml:space="preserve">
          <source>Value/Predicate</source>
          <target state="translated">Value/Predicate</target>
        </trans-unit>
        <trans-unit id="1f1cb2e6759dab2334119644e8cf129ac32ce11d" translate="yes" xml:space="preserve">
          <source>Values are stored internally as 64-bit floating point numbers. This means that numbers with more than about 16 significant digits will be truncated.</source>
          <target state="translated">값은 내부적으로 64 비트 부동 소수점 숫자로 저장됩니다. 즉, 유효 숫자가 약 16보다 큰 숫자는 잘립니다.</target>
        </trans-unit>
        <trans-unit id="6d7efb522647e3ca74917dae6abd528277b3ab9e" translate="yes" xml:space="preserve">
          <source>Values needed to run one PostgreSQL instance</source>
          <target state="translated">하나의 PostgreSQL 인스턴스를 실행하는 데 필요한 값</target>
        </trans-unit>
        <trans-unit id="8d380e11f26f75eaba033d74818adbe55ddca1de" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; data types can be cast to &lt;code&gt;money&lt;/code&gt;. Conversion from the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; data types can be done by casting to &lt;code&gt;numeric&lt;/code&gt; first, for example:</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; 및 &lt;code&gt;bigint&lt;/code&gt; 데이터 유형의 값은 &lt;code&gt;money&lt;/code&gt; 으로 캐스트 될 수 있습니다 . 로부터 변환 &lt;code&gt;real&lt;/code&gt; 및 &lt;code&gt;double precision&lt;/code&gt; 데이터 형식에 캐스팅하여 수행 할 수 있습니다 &lt;code&gt;numeric&lt;/code&gt; , 예를 들면, 첫째 :</target>
        </trans-unit>
        <trans-unit id="6a94b34531e2a116d1ab90afc1f71919f7dc0067" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; can be obtained only from the &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list&lt;/code&gt; 의 값은 &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; 열 에서만 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b87bdbb02446940728e896c08b8825bde2b21b0" translate="yes" xml:space="preserve">
          <source>Values of this domain are allowed to be null. This is the default.</source>
          <target state="translated">이 도메인의 값은 null이 될 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d29119abb7de6b63218065ed67e351db8dc51728" translate="yes" xml:space="preserve">
          <source>Values of this domain are prevented from being null (but see notes below).</source>
          <target state="translated">이 도메인의 값은 널이 될 수 없습니다 (하지만 아래 참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="0d30cecbfdbc76e7857e49ac92bd25f13ef34d9b" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;character&lt;/code&gt; are physically padded with spaces to the specified width &lt;code&gt;n&lt;/code&gt;, and are stored and displayed that way. However, trailing spaces are treated as semantically insignificant and disregarded when comparing two values of type &lt;code&gt;character&lt;/code&gt;. In collations where whitespace is significant, this behavior can produce unexpected results; for example &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; returns true, even though &lt;code&gt;C&lt;/code&gt; locale would consider a space to be greater than a newline. Trailing spaces are removed when converting a &lt;code&gt;character&lt;/code&gt; value to one of the other string types. Note that trailing spaces &lt;em&gt;are&lt;/em&gt; semantically significant in &lt;code&gt;character varying&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; values, and when using pattern matching, that is &lt;code&gt;LIKE&lt;/code&gt; and regular expressions.</source>
          <target state="translated">&lt;code&gt;character&lt;/code&gt; 유형의 값은 지정된 너비 &lt;code&gt;n&lt;/code&gt; 까지의 공백으로 물리적으로 채워 지며, 그런 식으로 저장 및 표시됩니다. 그러나 &lt;code&gt;character&lt;/code&gt; 유형의 두 값을 비교할 때 후행 공백은 의미 상 중요하지 않은 것으로 간주되고 무시됩니다 . 공백이 중요한 데이터 정렬에서이 동작은 예기치 않은 결과를 생성 할 수 있습니다. 예를 들어, &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; 는 &lt;code&gt;C&lt;/code&gt; 로케일이 공백을 줄 바꾸기보다 큰 것으로 간주 하더라도 true를 리턴합니다 . &lt;code&gt;character&lt;/code&gt; 값을 다른 문자열 유형 중 하나로 변환 할 때 후행 공백이 제거됩니다 . 후행 공백 &lt;em&gt;은&lt;/em&gt; 의미 상 의미가 있습니다. &lt;code&gt;character varying&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 값, 패턴 일치 사용시 &lt;code&gt;LIKE&lt;/code&gt; 및 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="0d0e8ddc497a1b9c951f5949c5d9e1b70b9a22cd" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;path&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d80b51f9c7fc6e7a8b7e3fe299274555e9a2ae02" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;polygon&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">&lt;code&gt;polygon&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a16467bfe399e24f49eb7fdb667ccec5d8723e" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER DATABASE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt; are applied only when starting a fresh database session. They override values obtained from the configuration files or server command line, and constitute defaults for the rest of the session. Note that some settings cannot be changed after server start, and so cannot be set with these commands (or the ones listed below).</source>
          <target state="translated">&lt;code&gt;ALTER DATABASE&lt;/code&gt; 및 &lt;code&gt;ALTER ROLE&lt;/code&gt; 로 설정된 값 은 새로운 데이터베이스 세션을 시작할 때만 적용됩니다. 구성 파일 또는 서버 명령 행에서 얻은 값을 대체하고 나머지 세션의 기본값을 구성합니다. 서버를 시작한 후에는 일부 설정을 변경할 수 없으므로 이러한 명령 (또는 아래 나열된 항목)을 사용하여 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="818a4a9f523da08f985a8d7bb8387b916781ef1a" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will be effective after the next server configuration reload, or after the next server restart in the case of parameters that can only be changed at server start. A server configuration reload can be commanded by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, running &lt;code&gt;pg_ctl reload&lt;/code&gt;, or sending a SIGHUP signal to the main server process.</source>
          <target state="translated">&lt;code&gt;ALTER SYSTEM&lt;/code&gt; 으로 설정된 값 은 다음 서버 구성을 다시로드 한 후 또는 서버 시작시에만 변경할 수있는 매개 변수의 경우 다음 서버를 다시 시작한 후에 적용됩니다. SQL 함수 &lt;code&gt;pg_reload_conf()&lt;/code&gt; 를 호출 하거나 &lt;code&gt;pg_ctl reload&lt;/code&gt; 를 실행 하거나 SIGHUP 신호를 주 서버 프로세스로 보내서 서버 구성 재로드를 명령 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e2a94acd55e77d304a8881179a17d08010c723b" translate="yes" xml:space="preserve">
          <source>Values to be inserted into a table are converted to the destination column's data type according to the following steps.</source>
          <target state="translated">테이블에 삽입 할 값은 다음 단계에 따라 대상 열의 데이터 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="543a387448ddbbf661178992c3adaa7b069168fb" translate="yes" xml:space="preserve">
          <source>Values: 0 - Without salt. Dangerous! 1 - With salt but with fixed iteration count. 3 - Variable iteration count. Default: 3 Applies to: pgp_sym_encrypt</source>
          <target state="translated">값 : 0-소금이 없습니다. 위험한! 1-소금은 있지만 반복 횟수는 고정되어 있습니다. 3-가변 반복 횟수. 기본값 : 3 적용 대상 : pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e85fa17c91ce0d6924e2ed0119f352ea3f8fb549" translate="yes" xml:space="preserve">
          <source>Values: 0 - no compression 1 - ZIP compression 2 - ZLIB compression (= ZIP plus meta-data and block CRCs) Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">값 : 0-압축 안함 1-ZIP 압축 2-ZLIB 압축 (= ZIP + 메타 데이터 및 블록 CRC) 기본값 : 0 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="52218ba89357173a5dfb8618986a1e8fdfb757a3" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt</source>
          <target state="translated">값 : 0, 1 기본값 : 0 적용 대상 : pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="922303e052dbc79ebb5e801b79cffb9186efe35c" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">값 : 0, 1 기본값 : 0 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="bbe411494b7a8541ba3eda983d9fa94b6f7dde40" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</source>
          <target state="translated">값 : 0, 1 기본값 : 0 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</target>
        </trans-unit>
        <trans-unit id="87f52252bc49eca143f466418a46bf231d397765" translate="yes" xml:space="preserve">
          <source>Values: 0, 1-9 Default: 6 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">값 : 0, 1-9 기본값 : 6 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="631bb9d3f376659e6d97cddb0d8676370c2c08b3" translate="yes" xml:space="preserve">
          <source>Values: bf, aes, aes128, aes192, aes256 Default: use cipher-algo Applies to: pgp_sym_encrypt</source>
          <target state="translated">값 : bf, aes, aes128, aes192, aes256 기본값 : cipher-algo 사용 적용 대상 : pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e9d1d35bfb5be3f756eb7a018b33d9e394f847ba" translate="yes" xml:space="preserve">
          <source>Values: bf, aes128, aes192, aes256 (OpenSSL-only: &lt;code&gt;3des&lt;/code&gt;, &lt;code&gt;cast5&lt;/code&gt;) Default: aes128 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">값 : bf, aes128, aes192, aes256 (OpenSSL 전용 : &lt;code&gt;3des&lt;/code&gt; , &lt;code&gt;cast5&lt;/code&gt; ) 기본값 : aes128 적용 대상 : pgp_sym_encrypt, pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="777af837f1de8927748898b65d1060bc773bad7b" translate="yes" xml:space="preserve">
          <source>Values: md5, sha1 Default: sha1 Applies to: pgp_sym_encrypt</source>
          <target state="translated">값 : md5, sha1 기본값 : sha1 적용 대상 : pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a0b72534c52ce05719721c1bfff6524b4aef3cf8" translate="yes" xml:space="preserve">
          <source>Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as &lt;code&gt;':foo'&lt;/code&gt; doesn't work to produce a quoted literal from a variable's value (and it would be unsafe if it did work, since it wouldn't correctly handle quotes embedded in the value).</source>
          <target state="translated">인용 된 SQL 리터럴 및 식별자 내에서는 변수 보간이 수행되지 않습니다. 따라서 &lt;code&gt;':foo'&lt;/code&gt; 와 같은 구성 은 변수 값에서 따옴표 붙은 리터럴을 생성하는 데 작동하지 않습니다 (그리고 값에 포함 된 따옴표를 올바르게 처리하지 않으므로 작동하면 안전하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f20578601408732c8ea02e8d928be3d22ba16637" translate="yes" xml:space="preserve">
          <source>Variables that control psql's behavior generally cannot be unset or set to invalid values. An &lt;code&gt;\unset&lt;/code&gt; command is allowed but is interpreted as setting the variable to its default value. A &lt;code&gt;\set&lt;/code&gt; command without a second argument is interpreted as setting the variable to &lt;code&gt;on&lt;/code&gt;, for control variables that accept that value, and is rejected for others. Also, control variables that accept the values &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; will also accept other common spellings of Boolean values, such as &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">psql의 동작을 제어하는 ​​변수는 일반적으로 설정을 해제하거나 유효하지 않은 값으로 설정할 수 없습니다. &lt;code&gt;\unset&lt;/code&gt; 명령은 허용되지만 기본 값으로 변수를 설정하는 것으로 해석된다. &lt;code&gt;\set&lt;/code&gt; 두 번째 인수없이 명령에 변수를 설정으로 해석됩니다 &lt;code&gt;on&lt;/code&gt; 그 값을 수락 제어 변수, 그리고 다른 사람에 대한 거부됩니다. 또한, 값 동의를 제어 변수 &lt;code&gt;on&lt;/code&gt; 와 &lt;code&gt;off&lt;/code&gt; 또한 다음과 같은 부울 값의 다른 일반적인 철자, 받아 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71d1d14c3d8bef73e900f87a2c49118ec1795b0b" translate="yes" xml:space="preserve">
          <source>Various other settings related to &amp;ldquo;semaphore undo&amp;rdquo;, such as &lt;code&gt;SEMMNU&lt;/code&gt; and &lt;code&gt;SEMUME&lt;/code&gt;, do not affect PostgreSQL.</source>
          <target state="translated">&lt;code&gt;SEMMNU&lt;/code&gt; 및 &lt;code&gt;SEMUME&lt;/code&gt; 와 같은 &quot;세마포어 실행 취소&quot;와 관련된 다양한 기타 설정 은 PostgreSQL에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd6240cba4fe3aa73d43764309d30fb6d3d037a4" translate="yes" xml:space="preserve">
          <source>Various parameters have been mentioned above in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt; and &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;Section 26.5.3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;섹션 26.5.2&lt;/a&gt; 및 &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;섹션 26.5.3&lt;/a&gt; 에서 다양한 매개 변수가 위에서 언급되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d5b3325956fac55ce90bb38fba311678783c4a5a" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">검증은 인덱스 스캔 자체에서 사용하는 것과 동일한 절차를 사용하여 수행되며, 이는 사용자 정의 연산자 클래스 코드 일 수 있습니다. 예를 들어, B-Tree 인덱스 검증은 하나 이상의 B-Tree 지원 기능 1 루틴을 사용한 비교에 의존합니다. 연산자 클래스 지원 함수에 대한 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;은 37.16.3 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="875530bb85a9bc9a572c1b81ee549fe16ccb6d4b" translate="yes" xml:space="preserve">
          <source>Version and Platform Compatibility</source>
          <target state="translated">버전 및 플랫폼 호환성</target>
        </trans-unit>
        <trans-unit id="1d9929f1f28bbd8834745a088bfee2450b12d5d8" translate="yes" xml:space="preserve">
          <source>Version name</source>
          <target state="translated">버전 이름</target>
        </trans-unit>
        <trans-unit id="2597e3332e662024a1086db859f74acc32e53a21" translate="yes" xml:space="preserve">
          <source>Version name for the extension</source>
          <target state="translated">확장의 버전 이름</target>
        </trans-unit>
        <trans-unit id="29156f5ef29fca0492cf46682a435025e1953ccd" translate="yes" xml:space="preserve">
          <source>Version number</source>
          <target state="translated">버전 번호</target>
        </trans-unit>
        <trans-unit id="637ea0ea7f40808c77700c1c4f68ba0087e0490c" translate="yes" xml:space="preserve">
          <source>Version of SSL in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">사용중인 SSL 버전 또는이 연결에서 SSL을 사용하지 않는 경우 NULL</target>
        </trans-unit>
        <trans-unit id="20a77b4ce23e6a598792ebba9c5fa53b934c43a3" translate="yes" xml:space="preserve">
          <source>Version of the server (optional)</source>
          <target state="translated">서버 버전 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="2002aefc5b11f637b7466ee1a13c20a9e6171391" translate="yes" xml:space="preserve">
          <source>Vertical tab (ASCII 11)</source>
          <target state="translated">세로 탭 (ASCII 11)</target>
        </trans-unit>
        <trans-unit id="9fe85f9993f6a26e677373400348d89af1072a3c" translate="yes" xml:space="preserve">
          <source>Very long-lived write transactions</source>
          <target state="translated">매우 장기적인 쓰기 트랜잭션</target>
        </trans-unit>
        <trans-unit id="30f98f07baa783307d6eeb3e956be798331b0ca1" translate="yes" xml:space="preserve">
          <source>Victor Wagner &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Cryptocom LTD</source>
          <target state="translated">빅터 바그너 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Cryptocom LTD</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="bf0400b0f3aafc0bb49249e45dc8694f8cdb7fdb" translate="yes" xml:space="preserve">
          <source>View Name</source>
          <target state="translated">뷰 이름</target>
        </trans-unit>
        <trans-unit id="33ef89bbb476e8982fc98b280a43e4c9b99ae10c" translate="yes" xml:space="preserve">
          <source>View all the locks currently outstanding, all the locks on relations in a particular database, all the locks on a particular relation, or all the locks held by a particular PostgreSQL session.</source>
          <target state="translated">현재 미해결 된 모든 잠금, 특정 데이터베이스의 관계에 대한 모든 잠금, 특정 관계에 대한 모든 잠금 또는 특정 PostgreSQL 세션이 보유한 모든 잠금을 봅니다.</target>
        </trans-unit>
        <trans-unit id="cbe38ed5293f170b37453ef21637367ceda0f0b8" translate="yes" xml:space="preserve">
          <source>View definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">뷰 정의 (재구성 된 &lt;code&gt;SELECT&lt;/code&gt; 쿼리)</target>
        </trans-unit>
        <trans-unit id="94f66a08ed3a699a66860df21a573d573a238197" translate="yes" xml:space="preserve">
          <source>Viewing Locks</source>
          <target state="translated">잠금 장치보기</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c43c0cfc302cb10077693176e5e074e56b5aa3e7" translate="yes" xml:space="preserve">
          <source>Views can be used in almost any place a real table can be used. Building views upon other views is not uncommon.</source>
          <target state="translated">실제 테이블을 사용할 수있는 거의 모든 장소에서 뷰를 사용할 수 있습니다. 다른 뷰에 뷰를 구축하는 것은 드문 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8e39d0decda3838416b25ba5106b0efbe06c4023" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction targeted by the lock, or null if the target is not a virtual transaction ID</source>
          <target state="translated">잠금이 대상으로하는 트랜잭션의 가상 ID. 대상이 가상 트랜잭션 ID가 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="811a0b30888086bd25c748477319220487f25d50" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction that is holding or awaiting this lock</source>
          <target state="translated">이 잠금을 보류 중이거나 대기중인 트랜잭션의 가상 ID</target>
        </trans-unit>
        <trans-unit id="4e4ba211a7e69b2432d26b396c51c526655c765b" translate="yes" xml:space="preserve">
          <source>Virtual transaction ID (backendID/localXID)</source>
          <target state="translated">가상 트랜잭션 ID (backendID / localXID)</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="588c142955d93338aefe3c6dd59baf541f7f60c7" translate="yes" xml:space="preserve">
          <source>WAL</source>
          <target state="translated">WAL</target>
        </trans-unit>
        <trans-unit id="1d1c95a48c1cec72e7cde457f1faf1b2311bbdfd" translate="yes" xml:space="preserve">
          <source>WAL Configuration</source>
          <target state="translated">WAL 구성</target>
        </trans-unit>
        <trans-unit id="dc7b27e2b628547b61cdbe01ad5b4d44572d2c25" translate="yes" xml:space="preserve">
          <source>WAL Internals</source>
          <target state="translated">WAL 내부</target>
        </trans-unit>
        <trans-unit id="cd824454d5f714596ff079dcd401902ac18dd100" translate="yes" xml:space="preserve">
          <source>WAL also makes it possible to support on-line backup and point-in-time recovery, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. By archiving the WAL data we can support reverting to any time instant covered by the available WAL data: we simply install a prior physical backup of the database, and replay the WAL log just as far as the desired time. What's more, the physical backup doesn't have to be an instantaneous snapshot of the database state &amp;mdash; if it is made over some period of time, then replaying the WAL log for that period will fix any internal inconsistencies.</source>
          <target state="translated">또한 WAL을 사용하면 &lt;a href=&quot;continuous-archiving&quot;&gt;섹션 25.3에&lt;/a&gt; 설명 된대로 온라인 백업 및 특정 시점 복구를 지원할 수 있습니다 . WAL 데이터를 보관하면 사용 가능한 WAL 데이터가 적용되는 즉시 복구 할 수 있습니다. 데이터베이스의 사전 물리적 백업을 설치하고 원하는 시간까지 WAL 로그를 재생하면됩니다. 또한 실제 백업은 데이터베이스 상태의 즉각적인 스냅 샷일 필요는 없습니다. 일정 기간 동안 만들어진 경우 해당 기간 동안 WAL 로그를 재생하면 내부 불일치가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="e4adb460b94535160dc5514c2f3243fad9448dc8" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g. &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">복구 중에 WAL 파일 제어 명령이 작동하지 않습니다 (예 : &lt;code&gt;pg_start_backup&lt;/code&gt; , &lt;code&gt;pg_switch_wal&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="9b2801865ae804dc7013c1520108c058b7f6c30a" translate="yes" xml:space="preserve">
          <source>WAL is automatically enabled; no action is required from the administrator except ensuring that the disk-space requirements for the WAL logs are met, and that any necessary tuning is done (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;).</source>
          <target state="translated">WAL이 자동으로 활성화됩니다. WAL 로그의 디스크 공간 요구 사항이 충족되고 필요한 조정이 완료되었는지 확인하는 것 외에는 관리자의 조치가 필요하지 않습니다 ( &lt;a href=&quot;wal-configuration&quot;&gt;29.4 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c356b4888573bfd6af6c126f717a43c96a7d21b4" translate="yes" xml:space="preserve">
          <source>WAL location at which to start reading. The default is to start reading the first valid log record found in the earliest file found.</source>
          <target state="translated">읽기 시작 WAL 위치. 기본값은 가장 오래된 파일에서 찾은 첫 번째 유효한 로그 레코드를 읽기 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4873b80cfe4fe4ff618ed5cd62f9b47043675a98" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000000&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">WAL 로그는 일반적으로 크기가 각각 16MB 인 세그먼트 파일 세트로 데이터 디렉토리 아래의 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리에 저장 되지만 크기는 &lt;code&gt;--wal-segsize&lt;/code&gt; initdb 옵션 을 변경하여 변경할 수 있습니다 . 각 세그먼트는 일반적으로 각 페이지 당 8kB로 분할됩니다 (이 크기는 &lt;code&gt;--with-wal-blocksize&lt;/code&gt; 구성 옵션을 통해 변경할 수 있음 ). 로그 레코드 헤더는 &lt;code&gt;access/xlogrecord.h&lt;/code&gt; 에 설명되어 있습니다 . 레코드 내용은 기록중인 이벤트 유형에 따라 다릅니다. 세그먼트 파일에는 &lt;code&gt;000000010000000000000000&lt;/code&gt; 에서 시작하여 점점 더 많은 숫자가 이름으로 제공됩니다 . 숫자는 줄 바꿈되지 않지만 사용 가능한 숫자를 소진하는 데 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="5fa55cdd1f960e02b270cbf81d5d051cfdadab50" translate="yes" xml:space="preserve">
          <source>WAL record construction can be canceled between any of the above steps by calling &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt;. This will discard all changes to the page image copies.</source>
          <target state="translated">&lt;code&gt;GenericXLogAbort(state)&lt;/code&gt; 호출하여 위의 단계 중 하나에서 WAL 레코드 구성을 취소 할 수 있습니다 . 페이지 이미지 사본에 대한 모든 변경 사항이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0756aa72f12460643a103d61be69d319455e3e" translate="yes" xml:space="preserve">
          <source>WAL records are appended to the WAL logs as each new record is written. The insert position is described by a Log Sequence Number (LSN) that is a byte offset into the logs, increasing monotonically with each new record. LSN values are returned as the datatype &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;. Values can be compared to calculate the volume of WAL data that separates them, so they are used to measure the progress of replication and recovery.</source>
          <target state="translated">각각의 새 레코드가 작성 될 때 WAL 레코드가 WAL 로그에 추가됩니다. 삽입 위치는 로그에 바이트 오프셋 인 LSN (Log Sequence Number)으로 설명되며, 각 새 레코드마다 단조 증가합니다. LSN 값은 데이터 유형 &lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; 으로&lt;/a&gt; 반환됩니다 . 값을 비교하여 WAL 데이터를 분리하는 볼륨을 계산할 수 있으므로 복제 및 복구 진행률을 측정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85207d0ebcdb97d98e8f6e4d0d99438888bd2967" translate="yes" xml:space="preserve">
          <source>WAL segments that cannot be found in the archive will be sought in &lt;code&gt;pg_wal/&lt;/code&gt;; this allows use of recent un-archived segments. However, segments that are available from the archive will be used in preference to files in &lt;code&gt;pg_wal/&lt;/code&gt;.</source>
          <target state="translated">아카이브에서 찾을 수없는 WAL 세그먼트는 &lt;code&gt;pg_wal/&lt;/code&gt; 에서 찾을 수 있습니다 . 이를 통해 최근의 보관되지 않은 세그먼트를 사용할 수 있습니다. 그러나 아카이브에서 사용 가능한 세그먼트는 &lt;code&gt;pg_wal/&lt;/code&gt; 파일보다 우선적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="670936924f36e223ed7101a5577c1a95fc54d46f" translate="yes" xml:space="preserve">
          <source>WIDE Project</source>
          <target state="translated">와이드 프로젝트</target>
        </trans-unit>
        <trans-unit id="0c238a027f49a7325c81b6fcad74df656598a8d1" translate="yes" xml:space="preserve">
          <source>WITH Queries</source>
          <target state="translated">쿼리</target>
        </trans-unit>
        <trans-unit id="62c72223105cadaf945f1907d7cca51ac5e11a9a" translate="yes" xml:space="preserve">
          <source>WITH Queries: Data-Modifying Statements in WITH</source>
          <target state="translated">WITH 쿼리 : WITH의 데이터 수정 명령문</target>
        </trans-unit>
        <trans-unit id="81a33ebe9b068dc28117b34d20aebb31ffcc15d4" translate="yes" xml:space="preserve">
          <source>WITH Queries: SELECT in WITH</source>
          <target state="translated">WITH 쿼리 : WITH에서 선택</target>
        </trans-unit>
        <trans-unit id="b3c1b6ed1901fdc76c7650d703ade5c43c418ba9" translate="yes" xml:space="preserve">
          <source>Wait Event Name</source>
          <target state="translated">대기 이벤트 이름</target>
        </trans-unit>
        <trans-unit id="cfecc9a9e7dbc0650b752c6d733646645d5d3acd" translate="yes" xml:space="preserve">
          <source>Wait Event Type</source>
          <target state="translated">대기 이벤트 유형</target>
        </trans-unit>
        <trans-unit id="7d1dd06a2c6e4048cfa872860c567be1efcd7c2b" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">백엔드가 현재 대기중인 경우 이벤트 이름을 대기하고 그렇지 않으면 NULL입니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;표 27.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0d176395064480d6a06595b0b0b2f5082eb7376" translate="yes" xml:space="preserve">
          <source>Wait event type name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">백엔드가 현재 대기중인 경우 대기 이벤트 유형 이름이고, 그렇지 않으면 NULL입니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;표 27.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d814f74425edb745c0f36dde73fdb494bc74e548" translate="yes" xml:space="preserve">
          <source>Wait for the operation to complete. This is supported for the modes &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;restart&lt;/code&gt;, &lt;code&gt;promote&lt;/code&gt;, and &lt;code&gt;register&lt;/code&gt;, and is the default for those modes.</source>
          <target state="translated">작업이 완료 될 때까지 기다리십시오. 이는 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;restart&lt;/code&gt; , &lt;code&gt;promote&lt;/code&gt; 및 &lt;code&gt;register&lt;/code&gt; 모드에서 지원되며 해당 모드 의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="dd618adedec17e6469d06a5651fc5072c2cb8b33" translate="yes" xml:space="preserve">
          <source>Waiting a new WAL segment created by copying an existing one to reach stable storage.</source>
          <target state="translated">안정적인 스토리지에 도달하기 위해 기존 세그먼트를 복사하여 생성 된 새 WAL 세그먼트를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7b263c588c8a9b03696257b8f7a21247383c1982" translate="yes" xml:space="preserve">
          <source>Waiting during base backup when throttling activity.</source>
          <target state="translated">활동을 제한 할 때 기본 백업 중 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="d62ddea7d6b1ce8c2e8479d95982f02c6ba59204" translate="yes" xml:space="preserve">
          <source>Waiting for I/O a subtransaction buffer.</source>
          <target state="translated">서브 트랜잭션 버퍼 입출력 대기 중.</target>
        </trans-unit>
        <trans-unit id="10b267052de8e5af8879f9629c8e82adc667c91f" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a clog (transaction status) buffer.</source>
          <target state="translated">막힘 (트랜잭션 상태) 버퍼에서 I / O 대기 중</target>
        </trans-unit>
        <trans-unit id="8bbc9325a896b8fd7a70abd45c23e5faa43a813b" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a data page.</source>
          <target state="translated">데이터 페이지에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="8a704e423e485baf39382a4b61985268bdbe9816" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset buffer.</source>
          <target state="translated">멀티 액션 오프셋 버퍼에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="567d45c24a3c7adfee8a01424ebb678b04e38b31" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact_member buffer.</source>
          <target state="translated">multixact_member 버퍼에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="f5580fedd445b2fc16dfac5701d5e862d784f551" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a replication slot.</source>
          <target state="translated">복제 슬롯에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="8eda0ee8cd8803033853db58b70b41cefa970a11" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an async (notify) buffer.</source>
          <target state="translated">비동기 (알림) 버퍼에서 I / O 대기 중</target>
        </trans-unit>
        <trans-unit id="abba94e34c19d07b07ce80f08b906e7d03736163" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an oldserxid buffer.</source>
          <target state="translated">oldserxid 버퍼에서 입출력 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="89be09a6258d69b36b9e65eae64f0556be147bdd" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on commit timestamp buffer.</source>
          <target state="translated">커밋 타임 스탬프 버퍼에서 I / O 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="da4c5fd8e7b43af2a409040c541ebf56ba090a42" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage during a checkpoint or database shutdown.</source>
          <target state="translated">체크 포인트 또는 데이터베이스 종료 중에 SLRU 데이터가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="a795b2d3551897df90d4dc06b1de18f13711e4ef" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage following a page write.</source>
          <target state="translated">페이지 쓰기 후 SLRU 데이터가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="3f43eca07331b8b4d48d83deb11f1187e3222c57" translate="yes" xml:space="preserve">
          <source>Waiting for SSL while attempting connection.</source>
          <target state="translated">연결을 시도하는 동안 SSL을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="cea499b505dfbcd4c53729e4e78e2f60a5e0dfa9" translate="yes" xml:space="preserve">
          <source>Waiting for TBM shared iterator lock.</source>
          <target state="translated">TBM 공유 반복자 잠금 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="28f5fe1f96a90cf6f89027f31d1f8fff440aadd4" translate="yes" xml:space="preserve">
          <source>Waiting for WAL buffers to be written to disk.</source>
          <target state="translated">WAL 버퍼가 디스크에 기록되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e5f443781f65a70ffb9eadd8d00b62bec73ed570" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from a stream at recovery.</source>
          <target state="translated">복구시 스트림에서 WAL을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ce0b3cbfc2a21133aecfeb0025076a64608b1920" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from any kind of source (local, archive or stream) at recovery.</source>
          <target state="translated">복구시 모든 종류의 소스 (로컬, 아카이브 또는 스트림)에서 WAL을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="c3d04b47f170d0a017b5a8840ab7fd732b861077" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to be flushed in WAL sender process.</source>
          <target state="translated">WAL 발신자 프로세스에서 WAL이 플러시되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="35934124d45c41b66cac20041da4f7acc6c09234" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach stable storage during bootstrapping.</source>
          <target state="translated">부트 스트랩 중 WAL이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2347bde945d2a1ac488cc00b97f03eb25edf886c" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach stable storage.</source>
          <target state="translated">WAL 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b64554949a794fe8845162525251d4f832f615ae" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to complete.</source>
          <target state="translated">검사 점이 완료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fbe85ec49696086b315ad919340a19fe4137e208" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to start.</source>
          <target state="translated">검사 점이 시작되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="a86020a20952ecd2adfecfb302ee0a5d59b93de9" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach stable storage.</source>
          <target state="translated">새로 작성된 타임 라인 히스토리 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="6fe40708f510b2425a56df962113c332035d1ebb" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach stable storage.</source>
          <target state="translated">새로 초기화 된 WAL 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="a99635b6aefa182932d6d8ac35e0fadee6f58362" translate="yes" xml:space="preserve">
          <source>Waiting for a read during a file copy operation.</source>
          <target state="translated">파일 복사 작업 중에 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1b1c7ee0bc940e8ff954a9dc21e088de25e160e7" translate="yes" xml:space="preserve">
          <source>Waiting for a read during recheck of the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일을 다시 확인하는 동안 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="9ae33919f01ffd845bcfe367fc1ce42274883982" translate="yes" xml:space="preserve">
          <source>Waiting for a read during reorder buffer management.</source>
          <target state="translated">재정렬 버퍼 관리 중 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="21b0b22bdd6995f4c8facc815a7958bc78a4df11" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a WAL file.</source>
          <target state="translated">WAL 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7c0a57a09d41e3dd4b6c43069589a550983cdfbc" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a buffered file.</source>
          <target state="translated">버퍼링 된 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="9d7f43727962110ab0f659fc3569b92c09e1e4c3" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a relation data file.</source>
          <target state="translated">관계 데이터 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b5434d2dc36bc6e479cf33762dac4cdbbad013ab" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a replication slot control file.</source>
          <target state="translated">복제 슬롯 제어 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="0d8e0677108348e6cb25c6439df96979d79370b4" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during walsender timeline command.</source>
          <target state="translated">walsender 타임 라인 명령 중에 타임 라인 히스토리 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="bb87f9075b737550478460fe92ea81d5a8e44f1b" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the control file.</source>
          <target state="translated">제어 파일에서 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b13a29b976f4d9243fad247169f0d2821ffe4aa3" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a logical mapping during reorder buffer management.</source>
          <target state="translated">재정렬 버퍼 관리 중 논리 맵핑 읽기를 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="94303f5f840422428a360dcb8cf874ed8d7188d8" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a serialized historical catalog snapshot.</source>
          <target state="translated">직렬화 된 히스토리 카탈로그 스냅 샷 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2ab04c92d0fda0e18fe65ce97ed4f4a6278c8bda" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a timeline history file.</source>
          <target state="translated">타임 라인 히스토리 파일 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="c0e334fe7275467445ed31f445bb0d89fc42ea11" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a two phase state file.</source>
          <target state="translated">2 단계 상태 파일 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="24f5541db52af4f2f83a5aff926cb570ad37ea9a" translate="yes" xml:space="preserve">
          <source>Waiting for a read of an SLRU page.</source>
          <target state="translated">SLRU 페이지 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ab3bd50798c846431f5c99cd295ac155af5c3628" translate="yes" xml:space="preserve">
          <source>Waiting for a read of the relation map file.</source>
          <target state="translated">관계 맵 파일 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="653fed415a1560b6108907354641e1d02603af7f" translate="yes" xml:space="preserve">
          <source>Waiting for a read when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">기존 WAL 세그먼트를 복사하여 새 WAL 세그먼트를 작성할 때 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8b50fdc4779713a2250434752ac096729a9b9e3d" translate="yes" xml:space="preserve">
          <source>Waiting for a read while adding a line to the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일에 행을 추가하는 동안 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="764d5f916fab0f4117b0be0cbd2e731f54a839fb" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be extended.</source>
          <target state="translated">관계 데이터 파일이 확장되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2d4550cc931e0694f7888372505856f6d3c09005" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be truncated.</source>
          <target state="translated">관계 데이터 파일이 잘릴 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="196784ad8df1886187ea3f9758445468708682d5" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach stable storage.</source>
          <target state="translated">관계 데이터 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2c6dd21f72774436bf4201a14e0bef224865f318" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive to be dropped.</source>
          <target state="translated">복제 오리진이 비활성화되기를 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="51efea4b8a37a030875e22581e67a71b2c0b921b" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage while restoring it to memory.</source>
          <target state="translated">복제 슬롯 제어 파일이 메모리에 복원되는 동안 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="3360d7e3a23f4e402f25182926d976cf44db39f3" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage.</source>
          <target state="translated">복제 슬롯 제어 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="199501dcba57d5c5271ac74b95e191bf236cb733" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive to be dropped.</source>
          <target state="translated">복제 슬롯이 비활성화되기를 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="863f50afd3c1563b85fb65b1a42b5b1ae705dfb7" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach stable storage.</source>
          <target state="translated">직렬화 된 히스토리 카탈로그 스냅 샷이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b66c979e7938ef913ce663fc865d33095c21de87" translate="yes" xml:space="preserve">
          <source>Waiting for a snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">&lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; 트랜잭션 의 스냅 샷 대기 중입니다 .</target>
        </trans-unit>
        <trans-unit id="e483dd61b2e17583a1594dcda6e591f3ac3e513f" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach stable storage.</source>
          <target state="translated">스트리밍 복제를 통해 수신 된 타임 라인 히스토리 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2853dc0fde120da340c58317ae296218c97a1c94" translate="yes" xml:space="preserve">
          <source>Waiting for a transaction to finish.</source>
          <target state="translated">거래가 완료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="157ed476e7697e7a1cadb6976248a98472434e0a" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach stable storage.</source>
          <target state="translated">2 단계 상태 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="85a6ffd0d68eb37b547774e0919378d07b939300" translate="yes" xml:space="preserve">
          <source>Waiting for a write during a file copy operation.</source>
          <target state="translated">파일 복사 작업 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="32492adb76e65f3fe0a6e72f8951521baef55fec" translate="yes" xml:space="preserve">
          <source>Waiting for a write during reorder buffer management.</source>
          <target state="translated">재정렬 버퍼 관리 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ba450cd205c3dd8e5640b537d57ff27410f1253d" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a WAL page during bootstrapping.</source>
          <target state="translated">부트 스트랩 중 WAL 페이지 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8705f070fa23d795eb616cd9e31b50566ca67cc3" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a newly created timeline history file.</source>
          <target state="translated">새로 작성된 타임 라인 히스토리 파일의 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8d1760404310ebeadc931ff2c4124968d47b107a" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a serialized historical catalog snapshot.</source>
          <target state="translated">직렬화 된 히스토리 카탈로그 스냅 샷의 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b37297f957be6d38118691421e743bea3d403b7c" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a timeline history file received via streaming replication.</source>
          <target state="translated">스트리밍 복제를 통해 수신 된 타임 라인 기록 파일 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="be49d8c0c1b4685519fdd85850348ecd44be9749" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a two phase state file.</source>
          <target state="translated">2 단계 상태 파일의 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="53aeb8cdb283bc1d47f777ad7b24ec161b846ee7" translate="yes" xml:space="preserve">
          <source>Waiting for a write of an SLRU page.</source>
          <target state="translated">SLRU 페이지 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1465353979b7faf0b115892be0b212bb41254cd5" translate="yes" xml:space="preserve">
          <source>Waiting for a write of logical rewrite mappings.</source>
          <target state="translated">논리적 다시 쓰기 매핑의 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="262bd0eebb54ede821d500429e0af687cc713958" translate="yes" xml:space="preserve">
          <source>Waiting for a write of mapping data during a logical rewrite.</source>
          <target state="translated">논리적 다시 쓰기 중 매핑 데이터 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="3b9bd51d9cae106255dd99b45134793e8fe5ca42" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a WAL file.</source>
          <target state="translated">WAL 파일 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="251086a074c439cbe743d7c3bb152d463c21bb7b" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a buffered file.</source>
          <target state="translated">버퍼링 된 파일에 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8b47e588513cf133674bba56df9090d2883dd101" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a relation data file.</source>
          <target state="translated">관계 데이터 파일에 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="299b50c23e70d2d279fbb4a9694963e890bfee88" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a replication slot control file.</source>
          <target state="translated">복제 슬롯 제어 파일에 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="f26411046b5f9c53b1644f439224f22b40020be7" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the control file.</source>
          <target state="translated">제어 파일에 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="f75228f5ef22ab61abd11733484809e768dbf43c" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the relation map file.</source>
          <target state="translated">관계 맵 파일에 대한 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="d4dc5be0a61a88b12bee2628ecf09d1b773c4c35" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the control file.</source>
          <target state="translated">쓰기가 제어 파일을 업데이트하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="610d140534d98776f4ceaac82401a792839d1b45" translate="yes" xml:space="preserve">
          <source>Waiting for a write when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">기존 WAL 세그먼트를 복사하여 새 WAL 세그먼트를 작성할 때 쓰기 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="e8e6f804ba2f5656426f9c3ccd5ba5ebd95a87d4" translate="yes" xml:space="preserve">
          <source>Waiting for a write while adding a line to the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일에 행을 추가하는 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="0696197c3d3d4067137d8fe428f74da050d0c268" translate="yes" xml:space="preserve">
          <source>Waiting for a write while creating the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일을 작성하는 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2fa5fc8fd5be1292b1cb40d3c83b93e702c367e3" translate="yes" xml:space="preserve">
          <source>Waiting for a write while initializing a new WAL file.</source>
          <target state="translated">새 WAL 파일을 초기화하는 중 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="734b565bcfa5ca2fc97c773bf856a02689576213" translate="yes" xml:space="preserve">
          <source>Waiting for action on logical replication worker to finish.</source>
          <target state="translated">논리적 복제 작업자의 작업이 완료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="a1613179ffe75070217dd36a5f12906b74afc2ab" translate="yes" xml:space="preserve">
          <source>Waiting for activity from child process when executing &lt;code&gt;Gather&lt;/code&gt; node.</source>
          <target state="translated">&lt;code&gt;Gather&lt;/code&gt; 노드를 실행할 때 하위 프로세스의 활동을 기다리는 중입니다 .</target>
        </trans-unit>
        <trans-unit id="6126b8aaccca6a7a91b7220ca50f325ae2373721" translate="yes" xml:space="preserve">
          <source>Waiting for an asynchronous prefetch from a relation data file.</source>
          <target state="translated">관계 데이터 파일에서 비동기 프리 페치를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7ceade57b19a1c5eb1845d4c821b850186cc2839" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">선출 된 Parallel Hash 참가자가 해시 테이블을 할당하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7ae35732e2bfced9301c45c422a5bb06a774ed38" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate more batches.</source>
          <target state="translated">선출 된 Parallel Hash 참가자가 더 많은 배치를 할당하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fb366154c77101be0d76ea7c08df266aa7b65be9" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">선출 된 병렬 해시 참가자가 초기 해시 테이블을 할당하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7cf1c258cd35461c3f1727fa0a9eacebdd04769c" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">선출 된 Parallel Hash 참가자가 향후 배치 성장을 결정할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="07635fd669dda3c946a486e6f1b23b449441353e" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</source>
          <target state="translated">선출 된 Parallel Hash 참가자가 더 많은 버킷 할당을 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="4e246fb175c5f149773d0331209040875fd42182" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to stable storage.</source>
          <target state="translated">안정적인 스토리지에 관계 데이터 파일의 즉각적인 동기화를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="95d64a2fc217b281e035d77c750609359d54019d" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the control file to reach stable storage.</source>
          <target state="translated">제어 파일의 업데이트가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fcf18468a43ecee10b4dea21dad9d1ae0888b697" translate="yes" xml:space="preserve">
          <source>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</source>
          <target state="translated">WAL 발신자 프로세스에서 WAL 수신자의 응답을 처리 할 때 활동을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="27bad1ed6561f03baa1813e29bc1d6a9f97d039b" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to shut down.</source>
          <target state="translated">백그라운드 작업자가 종료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="17b78b2404a9c8efe7417660102cb11bcbc99fa4" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to start up.</source>
          <target state="translated">백그라운드 작업자가 시작하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="121ce51ab6e249cf929aa9e0635dd5196c724d55" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach stable storage.</source>
          <target state="translated">안정적인 스토리지에 도달하기 위해 관계 데이터 파일의 변경을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7aedff25c55dbcd34ea828efe5df0cac10c04231" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from remote server during synchronous replication.</source>
          <target state="translated">동기 복제 중 원격 서버에서 확인을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e096887a303519506fcd67516869ace11ad3e59e" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while adding a line to the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일에 행을 추가하는 동안 데이터가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fe0ab1a16e2329bfa52c27e76aa50ab788d415cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while assigning WAL sync method.</source>
          <target state="translated">WAL 동기화 방법을 할당하는 동안 데이터가 안정적인 저장소에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="0a67fcfeb93618a5687879b86795e36261b23961" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while creating the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일을 작성하는 동안 데이터가 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1f817023f7f1aeed83afe73b277506f04bbf5f51" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to clear transaction id at transaction end.</source>
          <target state="translated">그룹 리더가 트랜잭션 종료시 트랜잭션 ID를 지울 때까지 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9ad12c44c511affe8e5b28dfe797e5442cb69ba2" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to update transaction status at transaction end.</source>
          <target state="translated">그룹 리더가 트랜잭션 종료시 트랜잭션 상태를 업데이트하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="6303bec3edc9303d1de1e17ffbef9d10deeb2ec7" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to change state.</source>
          <target state="translated">논리적 복제 원격 서버가 상태를 변경하기를 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="a171ef7b847c02147b5330baa42032a3b728b099" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">논리적 복제 원격 서버가 초기 테이블 동기화를 위해 데이터를 전송하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="a1252663514ce3e310a8ccaa53abc308558932c1" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage during a checkpoint.</source>
          <target state="translated">검사 점 동안 논리적 다시 쓰기 매핑이 안정적인 저장소에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="754897ce0cd2e99fe42e75806589d9d45f48b612" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage.</source>
          <target state="translated">논리적 재 작성 매핑이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ddcc4581e90866cae66b033e94adc36e9d35b43d" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach stable storage during a logical rewrite.</source>
          <target state="translated">논리적 재 작성 중 데이터 맵핑이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b8552e94ff493c563b97bc367629ad56d62866bf" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish hashing the inner relation.</source>
          <target state="translated">다른 Parallel Hash 참가자가 내부 관계 해시를 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e11479178e59844fd7fe15f1ce4eb490d0773d60" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</source>
          <target state="translated">다른 Parallel Hash 참가자가 새 버킷에 튜플 삽입을 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7c11b60c1a40d4f8d29e90353a8affe9075ec7f0" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish loading a hash table.</source>
          <target state="translated">다른 Parallel Hash 참가자가 해시 테이블로드를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5413b25ebacbf60f6298ddfd13544237708b4afd" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</source>
          <target state="translated">다른 Parallel Hash 참가자가 외부 관계 분할을 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="6ddf8230dce1afc618c7942a19d13a4e06fbab65" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finishing repartitioning.</source>
          <target state="translated">다른 Parallel Hash 참가자가 재 파티션을 마치기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="7ddcd3a1c9792343c59de081cc3c348d37cc1494" translate="yes" xml:space="preserve">
          <source>Waiting for other process to be attached in shared message queue.</source>
          <target state="translated">다른 프로세스가 공유 메시지 큐에 첨부되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ea1e4d605c6dfe012718f5d6b6342a2c1167a5ba" translate="yes" xml:space="preserve">
          <source>Waiting for parallel &lt;code&gt;CREATE INDEX&lt;/code&gt; workers to finish heap scan.</source>
          <target state="translated">병렬 &lt;code&gt;CREATE INDEX&lt;/code&gt; 작업자가 힙 스캔을 완료하기를 기다리는 중입니다 .</target>
        </trans-unit>
        <trans-unit id="2c0e5b890525a78c621a8bd9247fc1bb58a1d9d0" translate="yes" xml:space="preserve">
          <source>Waiting for parallel bitmap scan to become initialized.</source>
          <target state="translated">병렬 비트 맵 스캔이 초기화되기를 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="54d8ebcdd8df7afcbc1ca990a46b504e44b8711d" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation lock.</source>
          <target state="translated">병렬 쿼리 동적 공유 메모리 할당 잠금을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="6b2ad8cbb3533dbd2f7a9b18414fee3c1da25764" translate="yes" xml:space="preserve">
          <source>Waiting for parallel workers to finish computing.</source>
          <target state="translated">병렬 작업자가 컴퓨팅을 완료하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="d884014cf602749f289dbc7c7fc61acad84fa09d" translate="yes" xml:space="preserve">
          <source>Waiting for standby promotion.</source>
          <target state="translated">대기 프로모션 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="8cb227e761e8b1bc97dcd2f57c98b273168fa6eb" translate="yes" xml:space="preserve">
          <source>Waiting for startup process to send initial data for streaming replication.</source>
          <target state="translated">스트리밍 복제를 위해 시작 프로세스가 초기 데이터를 전송하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="4de10813baf47bfe4c27cf4c7969243299b919ed" translate="yes" xml:space="preserve">
          <source>Waiting for the control file to reach stable storage.</source>
          <target state="translated">제어 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="681bd23f805b6da445bd3d82fc4a46addc600e13" translate="yes" xml:space="preserve">
          <source>Waiting for the page number needed to continue a parallel B-tree scan to become available.</source>
          <target state="translated">병렬 B- 트리 스캔을 계속 사용하는 데 필요한 페이지 번호를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="c939d0ba9c27dac2f7d8824016725fedd49ef586" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach stable storage.</source>
          <target state="translated">관계 맵 파일이 안정적인 스토리지에 도달하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="c7be20b27094dae3303ee1fadc67011cd3751be8" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to establish connection to remote server.</source>
          <target state="translated">원격 서버에 연결하기 위해 WAL 수신자 대기 중.</target>
        </trans-unit>
        <trans-unit id="8b6df6362589c923614f910bed59cf34ff945324" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to receive data from remote server.</source>
          <target state="translated">원격 서버에서 데이터를 수신하기 위해 WAL 수신자 대기 중.</target>
        </trans-unit>
        <trans-unit id="bb83e82efa5858b6db8ad5949e98eced2a90463a" translate="yes" xml:space="preserve">
          <source>Waiting in an extension.</source>
          <target state="translated">내선에서 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="feb270e93605e72d07d6bcedd0737f5a39e22df0" translate="yes" xml:space="preserve">
          <source>Waiting in background writer process, hibernating.</source>
          <target state="translated">백그라운드 라이터 프로세스에서 대기중인 동면.</target>
        </trans-unit>
        <trans-unit id="88eefbfbae399c6feea1548c69357a5e9736f5ab" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL receiver process.</source>
          <target state="translated">WAL 수신기 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="375265f881add8dd9c33130678344167b52a9588" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL sender process.</source>
          <target state="translated">WAL 발신자 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="f5e173311caac73154fc23d76aed32502c099d08" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL writer process.</source>
          <target state="translated">WAL 라이터 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="7acb76585737d883d007ddb658d4cfd89597eb50" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of autovacuum launcher process.</source>
          <target state="translated">autovacuum 런처 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="7e6e41b3df7e89238ff4283ef4198a69ebe76109" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process background worker.</source>
          <target state="translated">배경 작가 프로세스 배경 작업자의 메인 루프에서 기다리고.</target>
        </trans-unit>
        <trans-unit id="d193be75953171ebbce3b3db2cde50e60c132491" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of checkpointer process.</source>
          <target state="translated">검사 점 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="db02418c7eb01a5eb05765091cb30a31f71aa88d" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical apply process.</source>
          <target state="translated">논리적 적용 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="82a745dd84bf90f7ae367a6c7dc035147ac68293" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical launcher process.</source>
          <target state="translated">논리 실행기 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="1e0772397293bff630517da7bd7ffb1ab81b17f5" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of syslogger process.</source>
          <target state="translated">syslogger 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="54f59b1a36db7407d20232e85176d4c1a23692f4" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the archiver process.</source>
          <target state="translated">아카이버 프로세스의 메인 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="212f0884ddfbc91689a2a97c09aafbcd3f389116" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the statistics collector process.</source>
          <target state="translated">통계 콜렉터 프로세스의 기본 루프에서 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="3b4ceca9ff1b34dd3a21d5a1be2bf8a9aa711a70" translate="yes" xml:space="preserve">
          <source>Waiting in process that called &lt;code&gt;pg_sleep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; 이라는 프로세스를 기다리는 중입니다 .</target>
        </trans-unit>
        <trans-unit id="0184a02009f44f4d2a88cbd98d9dfe8231fceb5e" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of finished serializable transactions.</source>
          <target state="translated">완료된 직렬화 가능 트랜잭션 목록에 액세스하려고 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="453521c4c18069faa9fd0afad3d83ca7731d1096" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a non-relation database object.</source>
          <target state="translated">비 관계형 데이터베이스 오브젝트에 대한 잠금 획득을 기다리는 중.</target>
        </trans-unit>
        <trans-unit id="e1e200aae0e4f2353a2c19cd08c7d6ee7ce7f912" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a relation.</source>
          <target state="translated">관계에 대한 잠금을 획득하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="caf9078aaa0a5a46ce631268ce4c46ea2cb0e198" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a tuple.</source>
          <target state="translated">튜플에서 잠금을 획득하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="20d61e9ac29e8e57ca0786825f9ae212af87d782" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on page of a relation.</source>
          <target state="translated">관계의 페이지에서 잠금을 획득하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="60529117b6f828f517a439e0152cfca12a03780e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a pin on a buffer.</source>
          <target state="translated">버퍼에서 핀을 얻기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9dff15d412549524e8b05e08b4e658a978321307" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a speculative insertion lock.</source>
          <target state="translated">투기 삽입 잠금을 얻기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="6f1d92a10ff6e0f42c232bac9cd39b9515b5e1f1" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a user lock.</source>
          <target state="translated">사용자 잠금 획득을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="feee645b171eddc5255ea3172e0b6eaae2f3531e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual xid lock.</source>
          <target state="translated">가상 xid 잠금 획득을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="0cff112c15e1e7f938ee8722e01003e541c3a9b9" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an advisory user lock.</source>
          <target state="translated">권고 사용자 잠금 획득을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="f4b782a596b50a85963931c1ce8ff87a36ab9e82" translate="yes" xml:space="preserve">
          <source>Waiting to add a message in shared invalidation queue.</source>
          <target state="translated">공유 무효화 큐에 메시지 추가 대기 중.</target>
        </trans-unit>
        <trans-unit id="a30c5b64b9088c9bea1b788c2d9cad490d0feadc" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine locks for backends, or waiting to join or exit a locking group (used by parallel query).</source>
          <target state="translated">백엔드에 대한 잠금을 추가 또는 검사하기 위해 대기 중이거나 잠금 그룹에 참여 또는 종료하기 위해 대기 중 (병렬 쿼리에서 사용)</target>
        </trans-unit>
        <trans-unit id="4234f3768471935481a7a5ac70e216c3b3196d0a" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine predicate lock information.</source>
          <target state="translated">술어 잠금 정보 추가 또는 검사 대기 중</target>
        </trans-unit>
        <trans-unit id="922ece807fb5d0e3eca745374502101b8e2f9883" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign a transaction id.</source>
          <target state="translated">트랜잭션 ID 할당 또는 할당을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="4df1187e247ec9e3885764b731ccac5a81693366" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign an OID.</source>
          <target state="translated">OID 할당 또는 할당을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="36e78f99b93b8582ddda9533616d35bad0cb3435" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or exchange a chunk of memory or update counters during Parallel Hash plan execution.</source>
          <target state="translated">Parallel Hash 계획 실행 중 메모리 청크 또는 업데이트 카운터 할당 또는 교환을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="aea0084a8686cdd126b6dc0b70e3bb510372f940" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or free a replication slot.</source>
          <target state="translated">복제 슬롯 할당 또는 해제 대기 중</target>
        </trans-unit>
        <trans-unit id="392b0fcbf6923b50ad00d9bcdf711922567f010a" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL at recovery because it is delayed.</source>
          <target state="translated">WAL이 지연되어 복구시 WAL 적용 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="417e2e4d470ba2ea215e899c1f2f47a808b6cd1d" translate="yes" xml:space="preserve">
          <source>Waiting to associate a data block with a buffer in the buffer pool.</source>
          <target state="translated">버퍼 풀의 버퍼와 데이터 블록 연결을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="0b5eba1b1476e67df8c9026fe8a8423164cbbbaf" translate="yes" xml:space="preserve">
          <source>Waiting to choose the next subplan during Parallel Append plan execution.</source>
          <target state="translated">병렬 추가 계획 실행 중 다음 하위 계획을 선택하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="11402cb956b4c4ad7b4f3ee48f5957e1d0e2837b" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop the tablespace.</source>
          <target state="translated">테이블 스페이스 작성 또는 삭제 대기 중</target>
        </trans-unit>
        <trans-unit id="ef13562f4466bb31b5bf871e5d3f767784c48032" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that the table it has selected for a vacuum still needs vacuuming.</source>
          <target state="translated">진공을 위해 선택한 테이블이 여전히 진공 상태를 유지하도록 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="7d2e90490a1d7b7d270317787f40bff2e1d72ee9" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;txid_status&lt;/code&gt; or update the oldest transaction id available to it.</source>
          <target state="translated">&lt;code&gt;txid_status&lt;/code&gt; 를 실행 하거나 사용 가능한 가장 오래된 트랜잭션 ID를 기다리는 중 입니다.</target>
        </trans-unit>
        <trans-unit id="905b59818613073e2e260c6b0fb7d68bf3c39843" translate="yes" xml:space="preserve">
          <source>Waiting to extend a relation.</source>
          <target state="translated">관계 확장을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="f8b7f54188ceea3dc5def955dc47ae1f28373839" translate="yes" xml:space="preserve">
          <source>Waiting to find or allocate space in shared memory.</source>
          <target state="translated">공유 메모리에서 공간을 찾거나 할당하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="fb53c073cc374cfb75fd8b826e6b4d7eb6cc9003" translate="yes" xml:space="preserve">
          <source>Waiting to get a snapshot or clearing a transaction id at transaction end.</source>
          <target state="translated">트랜잭션 종료시 스냅 샷을 확보하거나 트랜잭션 ID를 지우는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e384d346b49ba85024e06c032fcf3ccf1737b636" translate="yes" xml:space="preserve">
          <source>Waiting to get the start location of a scan on a table for synchronized scans.</source>
          <target state="translated">동기화 된 스캔을 위해 테이블에서 스캔 시작 위치를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="9a6beee315605623099d06c2371ae56da6b46cc7" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL into a memory buffer.</source>
          <target state="translated">메모리 버퍼에 WAL 삽입을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="fe4ce59b2db271f1abfb91f4099370c7dcadc0ae" translate="yes" xml:space="preserve">
          <source>Waiting to manage fsync requests.</source>
          <target state="translated">fsync 요청 관리를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e3141c5d05c342451c8644a34df11be83dd434ad" translate="yes" xml:space="preserve">
          <source>Waiting to manage space allocation in shared memory.</source>
          <target state="translated">공유 메모리에서 공간 할당 관리를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b97c8584b996285f48aeab64ef02658839acbba9" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a list of locks held by serializable transactions.</source>
          <target state="translated">직렬화 가능 트랜잭션이 보유한 잠금 목록에서 조작을 수행하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="d8589a1b8c66d6f8e4debafdd099f1a4b71a5b13" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a serializable transaction in a parallel query.</source>
          <target state="translated">병렬 쿼리에서 직렬화 가능 트랜잭션에 대한 작업을 수행하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="d2ade432e382335fbb1d6fb86bda4500ee8c2cbb" translate="yes" xml:space="preserve">
          <source>Waiting to perform checkpoint.</source>
          <target state="translated">검사 점 수행을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="1908bfbabea7a0ab1bbde739ebc0330fc7517b79" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client.</source>
          <target state="translated">클라이언트에서 데이터 읽기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="05dd640e8c1d54ebf01054c0befd12ca4f14b63e" translate="yes" xml:space="preserve">
          <source>Waiting to read or record conflicting serializable transactions.</source>
          <target state="translated">충돌하는 직렬화 가능 트랜잭션을 읽거나 기록하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="0afe38ebe7d995583b3d1a5cd94b6fbc8cf1b845" translate="yes" xml:space="preserve">
          <source>Waiting to read or truncate multixact information.</source>
          <target state="translated">multixact 정보를 읽거나 자르기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="a018a1a15593b5af23414939d50aec3fcb48c5cb" translate="yes" xml:space="preserve">
          <source>Waiting to read or update background worker state.</source>
          <target state="translated">백그라운드 작업자 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="cea27617060567594092b7422c38330bfc2e5ee2" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory state.</source>
          <target state="translated">동적 공유 메모리 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="5b94e34a6c9a38b9de8ddbf38266ea41569caa0e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about synchronous replicas.</source>
          <target state="translated">동기 복제본에 대한 정보를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="7be479f3c24eeb847b5e44a9bf4f341c29d1834b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact member mappings.</source>
          <target state="translated">multixact 멤버 맵핑을 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="548a78a89a3c004e9ad475a70fb6f1bb50c1151e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact offset mappings.</source>
          <target state="translated">multixact 오프셋 맵핑을 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="ed18ac469b6f870e80be0efbf5c76a4d5c79b754" translate="yes" xml:space="preserve">
          <source>Waiting to read or update notification messages.</source>
          <target state="translated">알림 메시지를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="76d4dfb568ccc6112df58f601dc5c426ad5d62a8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update old snapshot control information.</source>
          <target state="translated">오래된 스냅 샷 제어 정보를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="6ce0cc66a076e07f94b764161b2bddd57ada2509" translate="yes" xml:space="preserve">
          <source>Waiting to read or update replication slot state.</source>
          <target state="translated">복제 슬롯 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="fff67315163276ff44c96c0a78a1830dd666732b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared multixact state.</source>
          <target state="translated">공유 멀티 플렉스 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="b79ef3c6f580409e99c1e495bc8e24c202fbe7ed" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared notification state.</source>
          <target state="translated">공유 알림 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="af64ba8ecf87cac9594cd6dc3c61c2e7ddf060d1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update sub-transaction information.</source>
          <target state="translated">서브 트랜잭션 정보를 읽거나 갱신하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="bdb0edf32466a645cdde40c21227abb2a0bb1f30" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the control file or creation of a new WAL file.</source>
          <target state="translated">제어 파일을 읽거나 업데이트하기 위해 대기 중이거나 새 WAL 파일을 작성 중입니다.</target>
        </trans-unit>
        <trans-unit id="221da797b029fb896c5fbaed99fd507a4ef2a941" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the fast-path lock information.</source>
          <target state="translated">빠른 경로 잠금 정보를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="e9baf36ef5d66bb0ea1e99230d14314cf70bc406" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for the transaction timestamp.</source>
          <target state="translated">트랜잭션 타임 스탬프에 설정된 마지막 값을 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="15f6ffef563dec9ba786a7f233d5003f5ed45d14" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the replication progress.</source>
          <target state="translated">복제 진행률을 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="defd9a9d465fec9edd19efb8c557ca9acbf7364b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of prepared transactions.</source>
          <target state="translated">준비된 트랜잭션의 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="3dc7e6836006d3d5cbb7a9151c1a348063bbcc88" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction commit timestamps.</source>
          <target state="translated">트랜잭션 커밋 타임 스탬프를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="22fb7890af933754ae7b2b3d81b6bd6e23c2cc52" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction status.</source>
          <target state="translated">트랜잭션 상태를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="1691bd5ffa74ce0764d59f613b874fce42907700" translate="yes" xml:space="preserve">
          <source>Waiting to read or update vacuum-related information for a B-tree index.</source>
          <target state="translated">B- 트리 인덱스에 대한 진공 관련 정보를 읽거나 업데이트하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="7909f678b84800f1b2a16328d0f20ff93a738a0c" translate="yes" xml:space="preserve">
          <source>Waiting to read or write a data page in memory.</source>
          <target state="translated">메모리에서 데이터 페이지를 읽거나 쓰기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="ba3f3c6d87b25a2add5f41dc054490a6748416d8" translate="yes" xml:space="preserve">
          <source>Waiting to read or write relation cache initialization file.</source>
          <target state="translated">관계 캐시 초기화 파일 읽기 또는 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="56e29e2fa37b4e49226f461d31f27cc492afa177" translate="yes" xml:space="preserve">
          <source>Waiting to read while creating the data directory lock file.</source>
          <target state="translated">데이터 디렉토리 잠금 파일을 작성하는 중 읽기 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="22b6a17e9f6b4570d83c86bfc0b1331afbfa69c0" translate="yes" xml:space="preserve">
          <source>Waiting to receive bytes from a shared message queue.</source>
          <target state="translated">공유 메시지 큐에서 바이트를 받기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="9ce53a35add68653a7082475749be3845de4e91c" translate="yes" xml:space="preserve">
          <source>Waiting to replace a page in WAL buffers.</source>
          <target state="translated">WAL 버퍼에서 페이지 교체를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="e3b17dffde0ea5035f1032f34d22df0ea10ab951" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or remove messages from shared invalidation queue.</source>
          <target state="translated">공유 무효화 큐에서 메시지를 검색하거나 제거하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="4f507f65bfda2fa748e9dfb44f6b949cbab52bf9" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or store information about serializable transactions.</source>
          <target state="translated">직렬화 가능 트랜잭션에 대한 정보를 검색하거나 저장하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="c9928fb30a8b9bafde30f4c1a7932ab2be3ad802" translate="yes" xml:space="preserve">
          <source>Waiting to send bytes to a shared message queue.</source>
          <target state="translated">공유 메시지 큐에 바이트를 보내기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="352defc191b1b37d8d934ce574b79689999451d7" translate="yes" xml:space="preserve">
          <source>Waiting to setup, drop or use replication origin.</source>
          <target state="translated">복제 원본을 설정, 삭제 또는 사용하기 위해 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="99b1822a05f8be538a4edd0d27d811178799d3aa" translate="yes" xml:space="preserve">
          <source>Waiting to update the &lt;code&gt;postgresql.auto.conf&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;postgresql.auto.conf&lt;/code&gt; 파일 업데이트를 기다리는 중 입니다.</target>
        </trans-unit>
        <trans-unit id="7f7ad4b1674906a82b48581d682f5005d47dd119" translate="yes" xml:space="preserve">
          <source>Waiting to update the relation map file used to store catalog to filenode mapping.</source>
          <target state="translated">카탈로그 대 파일 노드 맵핑을 저장하는 데 사용되는 관계 맵 파일 업데이트를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8dc204f5803f3077a290dca7bb374395f034529e" translate="yes" xml:space="preserve">
          <source>Waiting to write a protocol message to a shared message queue.</source>
          <target state="translated">공유 메시지 큐에 프로토콜 메시지 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="2d0728d153f9f18004a22e4fb271924454b6a556" translate="yes" xml:space="preserve">
          <source>Waiting to write data to the client.</source>
          <target state="translated">클라이언트에 데이터 쓰기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="65a1974782cb646a2959736cb6599731cefd99f2" translate="yes" xml:space="preserve">
          <source>Waiting to write zero bytes to a dynamic shared memory backing file.</source>
          <target state="translated">동적 공유 메모리 백업 파일에 0 바이트 쓰기를 대기 중입니다.</target>
        </trans-unit>
        <trans-unit id="0929df55dd9f72fd6c1d910f07bdae3bd6e941bb" translate="yes" xml:space="preserve">
          <source>Warm and hot standby servers can be kept current by reading a stream of write-ahead log (WAL) records. If the main server fails, the standby contains almost all of the data of the main server, and can be quickly made the new master database server. This can be synchronous or asynchronous and can only be done for the entire database server.</source>
          <target state="translated">WAL (Write-Ahead Log) 레코드 스트림을 읽으면 웜 및 핫 대기 서버를 최신 상태로 유지할 수 있습니다. 주 서버에 장애가 발생하면 대기에는 주 서버의 거의 모든 데이터가 포함되며 새 마스터 데이터베이스 서버를 신속하게 만들 수 있습니다. 이는 동기식 또는 비동기식 일 수 있으며 전체 데이터베이스 서버에 대해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="a016c375864acf9c142cbb1359e053c54d4d9438" translate="yes" xml:space="preserve">
          <source>We already saw that &lt;code&gt;ORDER BY&lt;/code&gt; can be omitted if the ordering of rows is not important. It is also possible to omit &lt;code&gt;PARTITION BY&lt;/code&gt;, in which case there is a single partition containing all rows.</source>
          <target state="translated">행 순서가 중요하지 않은 경우 &lt;code&gt;ORDER BY&lt;/code&gt; 를 생략 할 수 있음 을 이미 확인했습니다. &lt;code&gt;PARTITION BY&lt;/code&gt; 를 생략 할 수도 있습니다 .이 경우 모든 행을 포함하는 단일 파티션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="836ee2eeb6e7ae6444006848acb871065ea3b213" translate="yes" xml:space="preserve">
          <source>We already saw the MCV information for &lt;code&gt;stringu1&lt;/code&gt;, and here is its histogram:</source>
          <target state="translated">우리는 이미 &lt;code&gt;stringu1&lt;/code&gt; 에 대한 MCV 정보를 보았으며 다음 은 히스토그램입니다.</target>
        </trans-unit>
        <trans-unit id="4916a888ae7040005cd716f2c3e28e1930fe1e1c" translate="yes" xml:space="preserve">
          <source>We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has indeed been permanently recorded and won't be lost even if a crash ensues shortly thereafter. For example, if we are recording a cash withdrawal by Bob, we do not want any chance that the debit to his account will disappear in a crash just after he walks out the bank door. A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.</source>
          <target state="translated">또한 데이터베이스 시스템에서 트랜잭션을 완료하고 승인 한 후에는 실제로 영구적으로 기록되어 그 이후에 충돌이 발생하더라도 손실되지 않는다는 보장을 원합니다. 예를 들어, Bob이 현금 인출을 기록하는 경우 은행 계좌 밖으로 나간 직후에 계좌에서 차변이 사라질 가능성을 원하지 않습니다. 트랜잭션 데이터베이스는 트랜잭션이 완료된 것으로보고되기 전에 트랜잭션에 의해 이루어진 모든 업데이트가 영구 저장소 (즉, 디스크)에 기록되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6743dd465747bd2e107f6841f4c88e12a10fdc63" translate="yes" xml:space="preserve">
          <source>We can also access arbitrary rectangular slices of an array, or subarrays. An array slice is denoted by writing &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; for one or more array dimensions. For example, this query retrieves the first item on Bill's schedule for the first two days of the week:</source>
          <target state="translated">배열의 임의의 직사각형 슬라이스 또는 하위 배열에 액세스 할 수도 있습니다. 배열 슬라이스는 하나 이상의 배열 차원에 대해 &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; 을 쓰면 표시됩니다 . 예를 들어,이 쿼리는 Bill의 일정에서 주 중 처음 2 일 동안 첫 번째 항목을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="26d5e00c2932aa021f71e1c7987bbc84382d9b85" translate="yes" xml:space="preserve">
          <source>We can also choose to return &lt;code&gt;NULL&lt;/code&gt;, instead of the lower-cased word, if it is not found in the stop words file. This behavior is selected by setting the dictionary's &lt;code&gt;Accept&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt;. Continuing the example:</source>
          <target state="translated">중지 단어 파일에서 찾을 수없는 경우 소문자 단어 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환하도록 선택할 수도 있습니다 . 이 동작은 사전의 &lt;code&gt;Accept&lt;/code&gt; 매개 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하면 선택됩니다 . 예제 계속하기 :</target>
        </trans-unit>
        <trans-unit id="dfd312f5fc4d67101d851237062bdba159c0ec59" translate="yes" xml:space="preserve">
          <source>We can also join a table against itself. This is called a &lt;em&gt;self join&lt;/em&gt;. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of each &lt;code&gt;weather&lt;/code&gt; row to the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of all other &lt;code&gt;weather&lt;/code&gt; rows. We can do this with the following query:</source>
          <target state="translated">테이블 자체를 조인 할 수도 있습니다. 이를 &lt;em&gt;자체 조인&lt;/em&gt; 이라고합니다 . 예를 들어, 다른 날씨 기록의 온도 범위에있는 모든 날씨 기록을 찾으려고 가정합니다. 따라서 각 &lt;code&gt;weather&lt;/code&gt; 행의 &lt;code&gt;temp_lo&lt;/code&gt; 및 &lt;code&gt;temp_hi&lt;/code&gt; 열을 다른 모든 &lt;code&gt;weather&lt;/code&gt; 행 의 &lt;code&gt;temp_lo&lt;/code&gt; 및 &lt;code&gt;temp_hi&lt;/code&gt; 열과 비교해야합니다 . 다음과 같은 쿼리로이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc6beb3b0e1bef62d183184143ea3d3ef810b4c" translate="yes" xml:space="preserve">
          <source>We can change the rewriting rules just by updating the table:</source>
          <target state="translated">테이블을 업데이트하여 다시 쓰기 규칙을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee2618785314089b8d336377e9a207db9405d3b4" translate="yes" xml:space="preserve">
          <source>We can create a GIN index (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;) to speed up text searches:</source>
          <target state="translated">텍스트 검색 속도를 높이기 위해 GIN 색인 ( &lt;a href=&quot;textsearch-indexes&quot;&gt;섹션 12.9&lt;/a&gt; )을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7821bbb704a2ac952eb9690616bfdd424400d47" translate="yes" xml:space="preserve">
          <source>We can do inheritance:</source>
          <target state="translated">우리는 상속을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d91685339d290a8a5e3f0243e992defd515e095f" translate="yes" xml:space="preserve">
          <source>We can then see that an administrator connecting over a network will not see any records, due to the restrictive policy:</source>
          <target state="translated">그런 다음 제한적인 정책으로 인해 네트워크를 통해 연결하는 관리자가 레코드를 볼 수 없음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e7ee16addc76bca0dc0a634456700165327da1e" translate="yes" xml:space="preserve">
          <source>We can update an individual subfield of a composite column:</source>
          <target state="translated">복합 열의 개별 하위 필드를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbaecdebc4248cd30d99181acc6ee4648ce55281" translate="yes" xml:space="preserve">
          <source>We choose not to index or search some token types that the built-in configuration does handle:</source>
          <target state="translated">내장 구성이 처리하는 일부 토큰 유형을 색인화하거나 검색하지 않기로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f68910847b8b293ecced82107bbdb7c9e86be5f0" translate="yes" xml:space="preserve">
          <source>We could also have written:</source>
          <target state="translated">우리는 또한 다음과 같이 쓸 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="1af074a97ee1433a54eef949ce0f504465ee61b0" translate="yes" xml:space="preserve">
          <source>We could simplify this by creating a SQL function that inserts a label at a specified position in a path:</source>
          <target state="translated">경로의 지정된 위치에 레이블을 삽입하는 SQL 함수를 작성하여이를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ed1bedde4f0b0f00a9838d665bf3bd179f0836" translate="yes" xml:space="preserve">
          <source>We define the synonym dictionary like this:</source>
          <target state="translated">동의어 사전은 다음과 같이 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d488cdbcb41070244eeea7399c07a12ab608b66e" translate="yes" xml:space="preserve">
          <source>We do not need a perfectly consistent file system backup as the starting point. Any internal inconsistency in the backup will be corrected by log replay (this is not significantly different from what happens during crash recovery). So we do not need a file system snapshot capability, just tar or a similar archiving tool.</source>
          <target state="translated">시작 지점으로 완벽하게 일관된 파일 시스템 백업이 필요하지 않습니다. 백업의 내부 불일치는 로그 재생을 통해 수정됩니다 (충돌 복구 중 발생하는 것과 크게 다르지 않음). 따라서 파일 시스템 스냅 샷 기능이 필요하지 않으며 tar 또는 유사한 아카이브 도구 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7d9a8fa7a3f06527b3bcf2908ca8717c376647ee" translate="yes" xml:space="preserve">
          <source>We have already discussed constants in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The following sections discuss the remaining options.</source>
          <target state="translated">&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;4.1.2 절&lt;/a&gt; 에서 상수에 대해 이미 논의했습니다 . 다음 섹션에서는 나머지 옵션에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a1ef9ac43045748116a115e49374f363a8ba372f" translate="yes" xml:space="preserve">
          <source>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data. In this situation we can use partitioning to help us meet all of our different requirements for the measurements table.</source>
          <target state="translated">이 표의 주요 용도는 관리를 위해 온라인 보고서를 준비하는 것이기 때문에 대부분의 쿼리는 지난 주, 월 또는 분기 데이터에만 액세스한다는 것을 알고 있습니다. 저장해야 할 오래된 데이터의 양을 줄이려면 최근 3 년 분량의 데이터 만 유지하기로합니다. 매월 초에 가장 오래된 월의 데이터를 제거합니다. 이 상황에서 파티셔닝을 사용하여 측정 테이블에 대한 다양한 요구 사항을 모두 충족 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a993aca05617d8df040114000bd6876b7a6bbb8" translate="yes" xml:space="preserve">
          <source>We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:</source>
          <target state="translated">외래 키로 인해 제품과 관련이없는 주문을 만들 수 없습니다. 그러나 제품을 참조하는 주문이 작성된 후 제품을 제거하면 어떻게됩니까? SQL을 사용하면이를 처리 할 수 ​​있습니다. 직관적으로 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afd1ca25954ba7db5e426cd93dec87fb2f18cad3" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">우리는 데이터가 어떻게 든 &lt;code&gt;capitals&lt;/code&gt; 테이블 로 라우팅되기를 원할 수도 있지만 이런 일은 일어나지 않습니다. &lt;code&gt;INSERT&lt;/code&gt; 는 항상 지정된 테이블에 정확하게 삽입됩니다. 경우에 따라 규칙을 사용하여 삽입을 리디렉션 할 수 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;40 장&lt;/a&gt; 참조 ). 그러나 &lt;code&gt;cities&lt;/code&gt; 테이블에 열 &lt;code&gt;state&lt;/code&gt; 가 포함되어 있지 않으므로 위의 경우에는 도움이되지 않으므로 규칙을 적용하기 전에 명령이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="668bafcded25fc8a525c39fc8ba11f8e8e98aa03" translate="yes" xml:space="preserve">
          <source>We might want to insert data and have the server automatically locate the child table into which the row should be added. We could do this with a more complex trigger function, for example:</source>
          <target state="translated">데이터를 삽입하고 서버가 행을 추가 할 하위 테이블을 자동으로 찾도록 할 수 있습니다. 보다 복잡한 트리거 기능으로이를 수행 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1aa4d9dcdf43d5b53cef629cb08b1cf507249faa" translate="yes" xml:space="preserve">
          <source>We must redefine the trigger function each month so that it always points to the current child table. The trigger definition does not need to be updated, however.</source>
          <target state="translated">항상 현재 자식 테이블을 가리 키도록 트리거 함수를 매달 재정의해야합니다. 그러나 트리거 정의를 업데이트 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1597c32eb07ab6cca066ebab3e65392f57896307" translate="yes" xml:space="preserve">
          <source>We recommend that active production databases be vacuumed frequently (at least nightly), in order to remove dead rows. After adding or deleting a large number of rows, it might be a good idea to issue a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; command for the affected table. This will update the system catalogs with the results of all recent changes, and allow the PostgreSQL query planner to make better choices in planning queries.</source>
          <target state="translated">죽은 행을 제거하기 위해 활성 프로덕션 데이터베이스를 자주 (적어도 밤마다) 청소하는 것이 좋습니다. 많은 수의 행을 추가하거나 삭제 한 후 영향을받는 테이블에 대해 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 명령을 실행 하는 것이 좋습니다 . 그러면 모든 최근 변경 결과로 시스템 카탈로그가 업데이트되고 PostgreSQL 쿼리 플래너가 쿼리 계획에서 더 나은 선택을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e67abf5ade818ba6d22ea4bc6d74fa648515393" translate="yes" xml:space="preserve">
          <source>We reject the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command across the board, because any module loaded could easily circumvent security policy enforcement.</source>
          <target state="translated">로드 된 모든 모듈이 보안 정책 시행을 쉽게 우회 할 수 있으므로 보드 전체 에서 &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; 명령을 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="977603731abefa85626583cf9841c1f7f86bb5c7" translate="yes" xml:space="preserve">
          <source>We require the index access method to apply these tests itself, which means that it must reach into the heap to check the commit status of any row that is shown to have a duplicate key according to the index contents. This is without a doubt ugly and non-modular, but it saves redundant work: if we did a separate probe then the index lookup for a conflicting row would be essentially repeated while finding the place to insert the new row's index entry. What's more, there is no obvious way to avoid race conditions unless the conflict check is an integral part of insertion of the new index entry.</source>
          <target state="translated">이러한 테스트 자체를 적용하려면 인덱스 액세스 방법이 필요합니다. 즉, 인덱스 내용에 따라 중복 키가있는 것으로 표시된 행의 커밋 상태를 확인하려면 힙에 도달해야합니다. 이것은 추악하고 모듈화되지 않은 의심의 여지가 없지만 중복 작업을 절약합니다. 별도의 프로브를 사용하면 충돌하는 행에 대한 인덱스 조회가 본질적으로 반복되어 새 행의 인덱스 항목을 삽입 할 위치를 찾습니다. 또한 충돌 검사가 새 인덱스 항목을 삽입하는 데 필수적인 부분이 아닌 한 경쟁 조건을 피할 수있는 확실한 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="61809ffaa1e9bec3b74e00f63e536c6b27a9b1ac" translate="yes" xml:space="preserve">
          <source>We say that in this situation the orders table is the &lt;em&gt;referencing&lt;/em&gt; table and the products table is the &lt;em&gt;referenced&lt;/em&gt; table. Similarly, there are referencing and referenced columns.</source>
          <target state="translated">이 상황에서 orders 테이블은 &lt;em&gt;참조&lt;/em&gt; 테이블이고 products 테이블은 &lt;em&gt;참조&lt;/em&gt; 테이블이라고합니다. 마찬가지로 참조 및 참조 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="926fa8d618ecd63d98d203881339877369fb9e8a" translate="yes" xml:space="preserve">
          <source>We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:</source>
          <target state="translated">처음 두 제약 조건은 열 제약 조건 인 반면 세 번째 제약 조건은 하나의 열 정의와 별도로 작성되므로 테이블 제약 조건이라고합니다. 열 제약 조건은 테이블 제약 조건으로 작성할 수도 있지만 열 제약 조건은 연결된 열만 참조해야하기 때문에 그 반대의 경우가 반드시 필요한 것은 아닙니다. PostgreSQL은이 규칙을 적용하지 않지만 테이블 정의가 다른 데이터베이스 시스템과 작동하도록하려면 규칙을 따라야합니다. 위의 예제는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ad12c01cac6b9fd7b6ff658816ff5bf8b904a2" translate="yes" xml:space="preserve">
          <source>We store these documents in a table named &lt;code&gt;api&lt;/code&gt;, in a &lt;code&gt;jsonb&lt;/code&gt; column named &lt;code&gt;jdoc&lt;/code&gt;. If a GIN index is created on this column, queries like the following can make use of the index:</source>
          <target state="translated">이러한 문서는 &lt;code&gt;api&lt;/code&gt; 라는 테이블 , &lt;code&gt;jsonb&lt;/code&gt; 이라는 &lt;code&gt;jdoc&lt;/code&gt; 열에 저장 합니다. 이 열에 GIN 색인이 작성되면 다음과 같은 조회가 색인을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00287a4e7374c9957df5b25550d2f8b5bf2d466" translate="yes" xml:space="preserve">
          <source>We use the following terms below: The &lt;em&gt;precision&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The &lt;em&gt;scale&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.</source>
          <target state="translated">아래의 용어를 사용합니다 . &lt;code&gt;numeric&lt;/code&gt; 의 &lt;em&gt;정밀도&lt;/em&gt; 는 정수의 유효 자릿수 총계, 즉 소수점 양쪽의 자릿수입니다. &lt;code&gt;numeric&lt;/code&gt; 의 &lt;em&gt;스케일&lt;/em&gt; 은 소수점 오른쪽에있는 소수 부분의 소수 자릿수입니다. 따라서 숫자 23.5141의 정밀도는 6이고 스케일은 4입니다. 정수는 스케일이 0 인 것으로 간주 될 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a22e103a166cab5bebeb6c6bf8216ec0f41d1ce6" translate="yes" xml:space="preserve">
          <source>We use the same &lt;code&gt;measurement&lt;/code&gt; table we used above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">위에서 사용한 것과 동일한 &lt;code&gt;measurement&lt;/code&gt; 표를 사용합니다. 상속을 사용하여 파티셔닝을 구현하려면 다음 단계를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="87bb5356e299e65f3820ac3133d7b4e088f6bde2" translate="yes" xml:space="preserve">
          <source>We use the word &lt;em&gt;item&lt;/em&gt; to refer to a composite value that is to be indexed, and the word &lt;em&gt;key&lt;/em&gt; to refer to an element value. GIN always stores and searches for keys, not item values per se.</source>
          <target state="translated">인덱싱 할 복합 값을 나타내는 단어 &lt;em&gt;항목&lt;/em&gt; 을 사용하고 요소 값을 나타내는 단어 &lt;em&gt;키&lt;/em&gt; 를 사용합니다. GIN은 항상 항목 값이 아닌 키를 저장하고 검색합니다.</target>
        </trans-unit>
        <trans-unit id="aaac10448fb5e7278bf16580755bd9621bfb54f1" translate="yes" xml:space="preserve">
          <source>We want our application to be able to say &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; and have the data be redirected into the appropriate child table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest child, we can use a very simple trigger function:</source>
          <target state="translated">우리는 어플리케이션이 &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; 을 말할 수 있기를 원 하고 데이터를 적절한 자식 테이블로 리디렉션합니다. 우리는 적절한 트리거 함수를 마스터 테이블에 첨부하여이를 정렬 할 수 있습니다. 데이터가 최신 자식에만 추가되는 경우 매우 간단한 트리거 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc05935dfdf1c41e4dbff177f8b502be331c045" translate="yes" xml:space="preserve">
          <source>We will use a PostgreSQL-specific synonym list and store it in &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt;. The file contents look like:</source>
          <target state="translated">PostgreSQL 관련 동의어 목록을 사용하여 &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt; 에 저장합니다 . 파일 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="963adbfe40be253cf091e436ca27447ef3a470bc" translate="yes" xml:space="preserve">
          <source>Wed, Weds</source>
          <target state="translated">수, 수</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="fdeddc33f6adb1db2fc6d6142f8a57019f70774f" translate="yes" xml:space="preserve">
          <source>Weights are typically used to reflect document structure, for example by marking title words differently from body words. Text search ranking functions can assign different priorities to the different weight markers.</source>
          <target state="translated">가중치는 일반적으로 제목 단어를 본문 단어와 다르게 표시하여 문서 구조를 반영하는 데 사용됩니다. 텍스트 검색 순위 기능은 다른 가중치 마커에 다른 우선 순위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="683c9370be61bfcd03e58355d7c86c6e1369d2d9" translate="yes" xml:space="preserve">
          <source>Western European</source>
          <target state="translated">서유럽</target>
        </trans-unit>
        <trans-unit id="e82bc7cf6e54b2e4257e788dff104c1e42da4e0b" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?</source>
          <target state="translated">JIT 컴파일이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9d446878c466219c122696ab7b32c54ff789d87e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Inlining</source>
          <target state="translated">JIT 컴파일이란? : 인라이닝</target>
        </trans-unit>
        <trans-unit id="ca44cc7300ef1dcac2b672637a01e3b0a0da90f7" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: JIT Accelerated Operations</source>
          <target state="translated">JIT 컴파일이란? : JIT 가속화 작업</target>
        </trans-unit>
        <trans-unit id="760d95b57cc4647ff2722b6cf5ee7f34082cc25e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Optimization</source>
          <target state="translated">JIT 컴파일이란? : 최적화</target>
        </trans-unit>
        <trans-unit id="6026d88e883e805146a8bbfee4583738ccfd77d8" translate="yes" xml:space="preserve">
          <source>What Is the &amp;ldquo;Transaction&amp;rdquo; Actually Performed in pgbench?</source>
          <target state="translated">pgbench에서 실제로 수행되는 &quot;트랜잭션&quot;은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6c8a97eccbb7e55f60d7659738855ee30c65e97d" translate="yes" xml:space="preserve">
          <source>What has really happened here is that the two unknown literals are resolved to &lt;code&gt;text&lt;/code&gt; by default, allowing the &lt;code&gt;||&lt;/code&gt; operator to be resolved as &lt;code&gt;text&lt;/code&gt; concatenation. Then the &lt;code&gt;text&lt;/code&gt; result of the operator is converted to &lt;code&gt;bpchar&lt;/code&gt; (&amp;ldquo;blank-padded char&amp;rdquo;, the internal name of the &lt;code&gt;character&lt;/code&gt; data type) to match the target column type. (Since the conversion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;bpchar&lt;/code&gt; is binary-coercible, this conversion does not insert any real function call.) Finally, the sizing function &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; is found in the system catalog and applied to the operator's result and the stored column length. This type-specific function performs the required length check and addition of padding spaces.</source>
          <target state="translated">여기서 실제로 일어난 일은 두 개의 알 수없는 리터럴이 기본적 으로 &lt;code&gt;text&lt;/code&gt; 로 해석되어 &lt;code&gt;||&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 연결 로 해석되는 연산자입니다. 그런 다음 연산자 의 &lt;code&gt;text&lt;/code&gt; 결과 는 대상 열 유형과 일치 하도록 &lt;code&gt;bpchar&lt;/code&gt; ( &lt;code&gt;character&lt;/code&gt; 데이터 유형 의 내부 이름 인 &quot;공백으로 채워진 문자&quot; )로 변환됩니다. ( &lt;code&gt;text&lt;/code&gt; 에서 &lt;code&gt;bpchar&lt;/code&gt; 로의 변환 은 이진 강제 변환 이므로이 변환은 실제 함수 호출을 삽입하지 않습니다.) 마지막으로 사이징 함수 &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; 시스템 카탈로그에 있으며 운영자 결과 및 저장된 열 길이에 적용됩니다. 이 유형별 기능은 필요한 길이 확인 및 패딩 공간 추가를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dfcede4e6134968fca6be5ab22337a4021df7d2f" translate="yes" xml:space="preserve">
          <source>What is a &amp;ldquo;system user&amp;rdquo; is determined at systemd compile time from the &lt;code&gt;SYS_UID_MAX&lt;/code&gt; setting in &lt;code&gt;/etc/login.defs&lt;/code&gt;.</source>
          <target state="translated">&quot;시스템 사용자&quot;는 시스템 컴파일 시간 에 &lt;code&gt;/etc/login.defs&lt;/code&gt; 의 &lt;code&gt;SYS_UID_MAX&lt;/code&gt; 설정에서 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3b062bdc5b358d8bc1d0ea5b87500675ecf488c" translate="yes" xml:space="preserve">
          <source>What is essentially happening here is a join between &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;producers&lt;/code&gt;, with all successfully joined &lt;code&gt;films&lt;/code&gt; rows being marked for deletion. This syntax is not standard. A more standard way to do it is:</source>
          <target state="translated">본질적으로 여기서 일어나는 것은 &lt;code&gt;films&lt;/code&gt; 와 &lt;code&gt;producers&lt;/code&gt; 사이의 조인 이며 , 성공적으로 조인 된 모든 &lt;code&gt;films&lt;/code&gt; 행은 삭제 표시됩니다. 이 구문은 표준이 아닙니다. 더 표준적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6eec3dfd99f17e2a6e53d2f854ed352bd2c2826" translate="yes" xml:space="preserve">
          <source>What locales are available on your system under what names depends on what was provided by the operating system vendor and what was installed. On most Unix systems, the command &lt;code&gt;locale -a&lt;/code&gt; will provide a list of available locales. Windows uses more verbose locale names, such as &lt;code&gt;German_Germany&lt;/code&gt; or &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt;, but the principles are the same.</source>
          <target state="translated">어떤 이름으로 시스템에서 사용 가능한 로케일은 운영 체제 공급 업체에서 제공 한 내용과 설치된 내용에 따라 다릅니다. 대부분의 Unix 시스템에서 &lt;code&gt;locale -a&lt;/code&gt; 명령 은 사용 가능한 로케일 목록을 제공합니다. Windows는 &lt;code&gt;German_Germany&lt;/code&gt; 또는 &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt; 와 같이 더 자세한 로케일 이름을 사용 하지만 원칙은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="40680439c20fb6866bd543023ba55a7dbd37c92b" translate="yes" xml:space="preserve">
          <source>What this does is to record the links created by pg_upgrade's link mode that connect files in the old and new clusters on the primary server. It then finds matching files in the standby's old cluster and creates links for them in the standby's new cluster. Files that were not linked on the primary are copied from the primary to the standby. (They are usually small.) This provides rapid standby upgrades. Unfortunately, rsync needlessly copies files associated with temporary and unlogged tables because these files don't normally exist on standby servers.</source>
          <target state="translated">이 작업은 주 서버의 기존 클러스터와 새 클러스터의 파일을 연결하는 pg_upgrade의 링크 모드로 생성 된 링크를 기록하는 것입니다. 그런 다음 대기의 이전 클러스터에서 일치하는 파일을 찾고 대기의 새 클러스터에서 해당 파일에 대한 링크를 작성합니다. 기본에서 링크되지 않은 파일은 기본에서 대기로 복사됩니다. (일반적으로 작습니다.) 빠른 대기 업그레이드를 제공합니다. 불행하게도 rsync는 불필요하게 임시 테이블과 기록되지 않은 테이블과 관련된 파일을 불필요하게 복사합니다. 이러한 파일은 일반적으로 대기 서버에 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a446c8d9e480b9f0f6cbcd76fef7e2bcda6c700b" translate="yes" xml:space="preserve">
          <source>What's more, when you load data into a table with existing foreign key constraints, each new row requires an entry in the server's list of pending trigger events (since it is the firing of a trigger that checks the row's foreign key constraint). Loading many millions of rows can cause the trigger event queue to overflow available memory, leading to intolerable swapping or even outright failure of the command. Therefore it may be &lt;em&gt;necessary&lt;/em&gt;, not just desirable, to drop and re-apply foreign keys when loading large amounts of data. If temporarily removing the constraint isn't acceptable, the only other recourse may be to split up the load operation into smaller transactions.</source>
          <target state="translated">또한 기존 외래 키 제약 조건이있는 테이블에 데이터를로드 할 때 각 새 행에는 서버의 보류중인 트리거 이벤트 목록에 항목이 필요합니다 (행의 외래 키 제약 조건을 확인하는 트리거가 실행되므로). 수백만 행을로드하면 트리거 이벤트 큐가 사용 가능한 메모리를 오버플로하여 참을 수없는 스와핑 또는 명령이 완전히 실패 할 수 있습니다. 따라서 많은 양의 데이터를로드 할 때 외래 키를 삭제하고 다시 적용하는 것이 바람직 할뿐만 아니라 &lt;em&gt;필요할&lt;/em&gt; 수도 있습니다 . 제약 조건을 일시적으로 제거 할 수없는 경우 다른 유일한 방법은로드 작업을 더 작은 트랜잭션으로 분할하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0604f8d2119324fb427a16a8668c529701bc1a2" translate="yes" xml:space="preserve">
          <source>Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding &lt;code&gt;CASCADE&lt;/code&gt;:</source>
          <target state="translated">열에 있던 데이터가 사라집니다. 열과 관련된 테이블 제약 조건도 삭제됩니다. 그러나 열이 다른 테이블의 외래 키 제약 조건에 의해 참조되는 경우 PostgreSQL은 해당 제약 조건을 자동으로 삭제하지 않습니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 추가하여 열에 종속 된 모든 항목을 삭제하도록 승인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="a60fe559ad2643627bd47ea3eceb6f63037101eb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt; is set, this parameter also determines the amount of time to wait before a log message is issued about the lock wait. If you are trying to investigate locking delays you might want to set a shorter than normal &lt;code&gt;deadlock_timeout&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits가&lt;/a&gt; 설정 로그 메시지가 잠금 대기에 대해 발행되기 전에,이 매개 변수는 또한 대기 시간을 결정한다. 잠금 지연을 조사하려는 경우 일반 &lt;code&gt;deadlock_timeout&lt;/code&gt; 보다 짧게 설정하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57e37b6a94a28e9acbd6287be1d60c38f8541fd8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;--source-server&lt;/code&gt; 옵션이 사용된다 pg_rewind libpq로 지원되는 환경 변수를 사용한다 (참조 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;섹션을 33.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1854281aa73e4f5b1f721e95b9f05123b0ade134" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-n&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected schema(s) might depend upon. Therefore, there is no guarantee that the results of a specific-schema dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">때 &lt;code&gt;-n&lt;/code&gt; 가 지정되면 pg_dump를 선택한 스키마 (들)에 의존 수도 다른 데이터베이스 개체를 덤프하는 것이 아니다. 따라서 특정 스키마 덤프의 결과가 자체적으로 깨끗한 데이터베이스로 성공적으로 복원 될 수 있다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5fef81c501efe3e088f4b73c9a697af2561cb6dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that the results of a specific-table dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">때 &lt;code&gt;-t&lt;/code&gt; 가 지정되면 pg_dump를 선택한 테이블 (들)에 의존 수도 다른 데이터베이스 개체를 덤프하는 것이 아니다. 따라서 특정 테이블 덤프 결과를 자체적으로 깨끗한 데이터베이스로 성공적으로 복원 할 수 있다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c86589858bd9989813c8435013ddbc1a41c69f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_restore makes no attempt to restore any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that a specific-table restore into a clean database will succeed.</source>
          <target state="translated">때 &lt;code&gt;-t&lt;/code&gt; 가 지정되어, pg_restore에 선택한 테이블 (들)에 의존 수도 다른 데이터베이스 오브젝트를 복원하는 것이 아니다. 따라서 클린 데이터베이스로의 특정 테이블 복원이 성공할 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6dd3feb588f68391e70d37037327ad64b7721fd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALTER&lt;/code&gt; command is executed, &lt;code&gt;setattr&lt;/code&gt; will be checked on the object being modified for each object types, except for subsidiary objects such as the indexes or triggers of a table, where permissions are instead checked on the parent object. In some cases, additional permissions are required:</source>
          <target state="translated">경우 &lt;code&gt;ALTER&lt;/code&gt; 의 명령이 실행되고, &lt;code&gt;setattr&lt;/code&gt; 객체가 각 객체 종류에 대해 수정되는에 체크한다 자회사 제외하면 인덱스 또는 권한이 아니라 부모 오브젝트에 체크 테이블의 트리거와 같은 개체. 경우에 따라 추가 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="95ea06756271ccb08739b45bacb4e5cf14e003e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE INDEX&lt;/code&gt; is invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If the &lt;code&gt;ONLY&lt;/code&gt; option is specified, no recursion is done, and the index is marked invalid. (&lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; marks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future using &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; will automatically have a matching index, regardless of whether &lt;code&gt;ONLY&lt;/code&gt; is specified.</source>
          <target state="translated">파티션 된 테이블에서 &lt;code&gt;CREATE INDEX&lt;/code&gt; 가 호출 될 때 기본 동작은 모든 파티션으로 재귀하여 모든 인덱스가 일치하는지 확인하는 것입니다. 각 파티션은 먼저 동등한 색인이 이미 존재하는지 판별하기 위해 점검되며, 존재하는 경우 해당 색인은 작성중인 색인에 파티션 색인으로 첨부되어 상위 색인이됩니다. 일치하는 색인이 없으면 새 색인이 작성되어 자동으로 첨부됩니다. 각 파티션의 새 인덱스 이름은 명령에 인덱스 이름이 지정되지 않은 것처럼 결정됩니다. 는 IF &lt;code&gt;ONLY&lt;/code&gt; 옵션을 지정, 더 재귀이 완료되지 않고, 인덱스가 유효하지 않은 것으로 표시됩니다. ( &lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; 모든 파티션이 일치하는 인덱스를 획득하면 인덱스가 유효한 것으로 표시됩니다.) 그러나 &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; 사용하여 나중에 생성되는 파티션은 &lt;code&gt;ONLY&lt;/code&gt; 의 지정 여부에 관계없이 자동으로 일치하는 인덱스를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0c15e2e86d36f47a57239a8f802301f2d222dbb6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; is used to replace an existing function, the ownership and permissions of the function do not change. All other function properties are assigned the values specified or implied in the command. You must own the function to replace it (this includes being a member of the owning role).</source>
          <target state="translated">때 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 는 기존의 기능을 대체하는 데 사용됩니다, 함수의 소유권과 권한은 변경되지 않습니다. 다른 모든 기능 속성에는 명령에 지정되거나 암시 된 값이 할당됩니다. 이를 대체 할 기능을 소유해야합니다 (소유 역할의 구성원이 포함됨).</target>
        </trans-unit>
        <trans-unit id="db55d63efcb8b5298291fde068a29837b503dfcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; is used to replace an existing procedure, the ownership and permissions of the procedure do not change. All other procedure properties are assigned the values specified or implied in the command. You must own the procedure to replace it (this includes being a member of the owning role).</source>
          <target state="translated">때 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 기존 절차를 대체하기 위해 사용되는 절차의 소유권과 권한은 변경되지 않습니다. 다른 모든 프로 시저 속성에는 명령에 지정되거나 암시 된 값이 할당됩니다. 교체 절차를 소유해야합니다 (소유 역할의 구성원이 포함됨).</target>
        </trans-unit>
        <trans-unit id="11b7e02139c0fd56fa0d0c0d7e02cacf1863b7dd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; is used on an existing view, only the view's defining SELECT rule is changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).</source>
          <target state="translated">때 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 가 기존 뷰에서 사용되는,보기 만의 정의 SELECT 규칙이 변경됩니다. 소유권, 권한 및 비 SELECT 규칙을 포함한 다른보기 속성은 변경되지 않습니다. 뷰를 바꾸려면 뷰를 소유해야합니다 (소유 역할의 구성원이 포함됨).</target>
        </trans-unit>
        <trans-unit id="b2b68d33a4076adb362da4bb710ac3317fb09cf8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DROP&lt;/code&gt; command is executed, &lt;code&gt;drop&lt;/code&gt; will be checked on the object being removed. Permissions will be also checked for objects dropped indirectly via &lt;code&gt;CASCADE&lt;/code&gt;. Deletion of objects contained within a particular schema (tables, views, sequences and procedures) additionally requires &lt;code&gt;remove_name&lt;/code&gt; on the schema.</source>
          <target state="translated">경우 &lt;code&gt;DROP&lt;/code&gt; 의 명령이 실행되고, &lt;code&gt;drop&lt;/code&gt; 객체가 제거되기에 체크한다. &lt;code&gt;CASCADE&lt;/code&gt; 를 통해 간접적으로 삭제 된 개체에 대한 권한도 확인됩니다 . 특정 스키마 (테이블, 뷰, 시퀀스 및 프로 시저)에 포함 된 객체를 삭제하려면 스키마에서 &lt;code&gt;remove_name&lt;/code&gt; 이 추가로 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f47c9d6dc4a8942d1dd522d4978fe59346f8ad48" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GROUP BY&lt;/code&gt; is present, or any aggregate functions are present, it is not valid for the &lt;code&gt;SELECT&lt;/code&gt; list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.</source>
          <target state="translated">때 &lt;code&gt;GROUP BY&lt;/code&gt; 가 존재, 또는 집계 함수가 존재하는, 그것은 유효하지 않습니다 &lt;code&gt;SELECT&lt;/code&gt; 그렇지 않으면 더있을 것이기 때문에 그룹이 해제 된 열이 그룹화 컬럼에 기능적으로 의존하는 경우 목록 표현이 집계 함수에서 제외 그룹화되지 않은 열을 참조하거나 그룹화되지 않은 열에 대해 하나 이상의 가능한 값을 반환합니다. 그룹화 된 열 (또는 그 서브 세트)이 그룹화되지 않은 열을 포함하는 테이블의 기본 키인 경우 기능 종속성이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a61a8feeb668ae119fbcd691b6fc8464f954d0c9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NOTIFY&lt;/code&gt; is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the &lt;code&gt;NOTIFY&lt;/code&gt; in a statement trigger that is triggered by table updates. In this way, notification happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it.</source>
          <target state="translated">때 &lt;code&gt;NOTIFY&lt;/code&gt; 특정 테이블에 대한 변경 사항의 발생을 신호하는 데 사용되는 유용한 프로그래밍 기법은 넣어하는 것입니다 &lt;code&gt;NOTIFY&lt;/code&gt; 테이블 업데이트로 트리거 명령문 트리거. 이러한 방식으로, 테이블이 변경되면 알림이 자동으로 발생하며 응용 프로그램 프로그래머는 실수로이를 잊을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96d946d891d853517e02080ffe41ee5e79e55c40" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. This is unlike the normal behavior of &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt;. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">때 &lt;code&gt;RESTART IDENTITY&lt;/code&gt; 이 지정되면, 묵시적 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 의 작업은 트랜잭션 완료; 즉, 주변 트랜잭션이 커밋되지 않으면 롤백됩니다. 이것은 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 의 정상적인 동작과 다릅니다 . 트랜잭션이 롤백되기 전에 다시 시작된 시퀀스에서 추가 시퀀스 작업이 수행되면 시퀀스에 대한 이러한 작업의 영향은 롤백되지만 &lt;code&gt;currval()&lt;/code&gt; 에 대한 영향은 아닙니다 . 즉, 트랜잭션 &lt;code&gt;currval()&lt;/code&gt; 이후시퀀스 자체가 더 이상 일치하지 않더라도 실패한 트랜잭션 내에서 얻은 마지막 시퀀스 값을 계속 반영합니다. 이는 트랜잭션 실패 후 &lt;code&gt;currval()&lt;/code&gt; 의 일반적인 동작과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="1dd38b054f6c38892cf4b53376368a92afaa9614" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; changes the mode of a constraint from &lt;code&gt;DEFERRED&lt;/code&gt; to &lt;code&gt;IMMEDIATE&lt;/code&gt;, the new mode takes effect retroactively: any outstanding data modifications that would have been checked at the end of the transaction are instead checked during the execution of the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. If any such constraint is violated, the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; fails (and does not change the constraint mode). Thus, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; can be used to force checking of constraints to occur at a specific point in a transaction.</source>
          <target state="translated">때 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 에서 제약 조건의 모드를 변경 &lt;code&gt;DEFERRED&lt;/code&gt; 로 &lt;code&gt;IMMEDIATE&lt;/code&gt; , 새로운 모드는 소급 적용됩니다 : 트랜잭션의 끝에서 확인 된 것이다 미결제 데이터 수정이 대신 실행하는 동안 체크 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 명령. 이러한 제한 조건을 위반하면 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 가 실패하고 제한 조건 모드를 변경하지 않습니다. 따라서 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 를 사용하여 트랜잭션의 특정 지점에서 제한 조건 확인을 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b169cb5b7cb17bff71441e629815508752132d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VALUES&lt;/code&gt; is used in &lt;code&gt;INSERT&lt;/code&gt;, the values are all automatically coerced to the data type of the corresponding destination column. When it's used in other contexts, it might be necessary to specify the correct data type. If the entries are all quoted literal constants, coercing the first is sufficient to determine the assumed type for all:</source>
          <target state="translated">때는 &lt;code&gt;VALUES&lt;/code&gt; 사용된다 &lt;code&gt;INSERT&lt;/code&gt; , 값이 모두 자동으로 해당 대상 칼럼의 데이터 형식으로 강제된다. 다른 컨텍스트에서 사용될 경우 올바른 데이터 유형을 지정해야 할 수도 있습니다. 항목이 모두 인용 리터럴 상수 인 경우 첫 번째 항목을 강제 변환하면 모든 가정 유형을 결정하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="45ae9ff8fa95f77c4ea16390adcefafbd4f890d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;ANALYZE&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">경우 &lt;code&gt;VERBOSE&lt;/code&gt; 가 지정되면 &lt;code&gt;ANALYZE&lt;/code&gt; 을 방출 현재 처리되고있는 테이블을 표시하기 위해 메시지를 진행. 테이블에 대한 다양한 통계도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="14f1458fcf796362f90bd6b53ff757eaee1e2939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;VACUUM&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">경우 &lt;code&gt;VERBOSE&lt;/code&gt; 가 지정되어, &lt;code&gt;VACUUM&lt;/code&gt; 을 방출들은 현재 처리되고있는 테이블을 표시하기 위해 메시지를 진행. 테이블에 대한 다양한 통계도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f54823d23e5df73c9472414a7a83e6ba082b1ce2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, or &lt;code&gt;\ev&lt;/code&gt; is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user's editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples:</source>
          <target state="translated">때 &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\ef&lt;/code&gt; , 또는 &lt;code&gt;\ev&lt;/code&gt; 행 번호의 인수와 함께 사용되며,이 변수의 지정은 사용 된 명령 줄 인수는 사용자의 편집기로 시작하는 행 번호를 전달합니다. Emacs 또는 vi와 같은 편집기의 경우 이는 더하기 부호입니다. 옵션 이름과 행 번호 사이에 공백이 필요한 경우 변수 값에 후행 공백을 포함하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="880bf87755564e46a3f310f5734ab8ac6764465b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;archive_mode&lt;/code&gt; is enabled, completed WAL segments are sent to archive storage by setting &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. In addition to &lt;code&gt;off&lt;/code&gt;, to disable, there are two modes: &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;always&lt;/code&gt;. During normal operation, there is no difference between the two modes, but when set to &lt;code&gt;always&lt;/code&gt; the WAL archiver is enabled also during archive recovery or standby mode. In &lt;code&gt;always&lt;/code&gt; mode, all files restored from the archive or streamed with streaming replication will be archived (again). See &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;Section 26.2.9&lt;/a&gt; for details.</source>
          <target state="translated">때 &lt;code&gt;archive_mode&lt;/code&gt; 가 활성화되어, 완성 된 WAL 세그먼트 설정하여 아카이브 스토리지로 전송됩니다 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command를&lt;/a&gt; . &lt;code&gt;off&lt;/code&gt; 외에도 비활성화하기 위해 &lt;code&gt;on&lt;/code&gt; 과 &lt;code&gt;always&lt;/code&gt; 의 두 가지 모드가 있습니다 . 정상 작동 중에는 두 모드간에 차이가 없지만 &lt;code&gt;always&lt;/code&gt; 설정 하면 WAL 아카이버가 아카이브 복구 또는 대기 모드 중에도 활성화됩니다. &lt;code&gt;always&lt;/code&gt; 모드 에서는 아카이브에서 복원되거나 스트리밍 복제로 스트리밍 된 모든 파일이 (다시) 아카이브됩니다. 자세한 내용 &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;은 26.2.9 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46cdaf5a9c68bb7dda3e95a7d23c6fce30bcf59a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;commit_delay&lt;/code&gt; is set to zero (the default), it is still possible for a form of group commit to occur, but each group will consist only of sessions that reach the point where they need to flush their commit records during the window in which the previous flush operation (if any) is occurring. At higher client counts a &amp;ldquo;gangway effect&amp;rdquo; tends to occur, so that the effects of group commit become significant even when &lt;code&gt;commit_delay&lt;/code&gt; is zero, and thus explicitly setting &lt;code&gt;commit_delay&lt;/code&gt; tends to help less. Setting &lt;code&gt;commit_delay&lt;/code&gt; can only help when (1) there are some concurrently committing transactions, and (2) throughput is limited to some degree by commit rate; but with high rotational latency this setting can be effective in increasing transaction throughput with as few as two clients (that is, a single committing client with one sibling transaction).</source>
          <target state="translated">&lt;code&gt;commit_delay&lt;/code&gt; 가 0 (기본값)으로 설정되어 있으면 그룹 커밋 형식이 여전히 발생할 수 있지만 각 그룹은 해당 창에서 커밋 레코드를 플러시해야하는 시점에 도달하는 세션으로 만 구성됩니다. 이전 플러시 작업 (있는 경우)이 발생합니다. 클라이언트 수가 많을수록 &quot;갱 웨이 효과&quot;가 발생하는 경향이 있으므로 &lt;code&gt;commit_delay&lt;/code&gt; 가 0 인 경우에도 그룹 커밋의 효과가 현저 해 지므로 &lt;code&gt;commit_delay&lt;/code&gt; 를 명시 적으로 설정 하면 덜 도움이됩니다. &lt;code&gt;commit_delay&lt;/code&gt; 설정(1) 일부 동시 커밋 트랜잭션이 있고 (2) 처리량이 커밋 비율에 따라 어느 정도 제한되는 경우에만 도움이됩니다. 그러나 높은 회전 대기 시간으로이 설정은 클라이언트 수가 2 개 (즉, 하나의 형제 트랜잭션이있는 단일 커밋 클라이언트)로 트랜잭션 처리량을 증가시키는 데 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="639e6544c619e9aa79e7a25d85adc789836438b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;default_tablespace&lt;/code&gt; is set to anything but an empty string, it supplies an implicit &lt;code&gt;TABLESPACE&lt;/code&gt; clause for &lt;code&gt;CREATE TABLE&lt;/code&gt; and &lt;code&gt;CREATE INDEX&lt;/code&gt; commands that do not have an explicit one.</source>
          <target state="translated">&lt;code&gt;default_tablespace&lt;/code&gt; 가 빈 문자열 이외의 값으로 설정 되면 명시 적 명령이없는 &lt;code&gt;CREATE TABLE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령에 대한 암시 적 &lt;code&gt;TABLESPACE&lt;/code&gt; 절을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="26b9fcc2ea9102afd846d23d5a3d7acf06ea6fcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extractQuery&lt;/code&gt; returns a null key in &lt;code&gt;queryKeys[]&lt;/code&gt;, the corresponding &lt;code&gt;check[]&lt;/code&gt; element is true if the indexed item contains a null key; that is, the semantics of &lt;code&gt;check[]&lt;/code&gt; are like &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt;. The &lt;code&gt;consistent&lt;/code&gt; function can examine the corresponding &lt;code&gt;nullFlags[]&lt;/code&gt; element if it needs to tell the difference between a regular value match and a null match.</source>
          <target state="translated">경우 &lt;code&gt;extractQuery&lt;/code&gt; 이 있는 널 키 반환 &lt;code&gt;queryKeys[]&lt;/code&gt; , 해당 &lt;code&gt;check[]&lt;/code&gt; 인덱싱 항목 널 키 요소를 포함하는 경우 사실이다; 즉, &lt;code&gt;check[]&lt;/code&gt; 의 의미는 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 과 같습니다 . &lt;code&gt;consistent&lt;/code&gt; 함수는 대응하는 검사 할 &lt;code&gt;nullFlags[]&lt;/code&gt; 는 일정한 값이 일치하고 널 매치를 구별 할 필요가있는 경우 소자.</target>
        </trans-unit>
        <trans-unit id="e521d3acb4576333ab5bee010106dc1a1c2bc018" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">&lt;code&gt;geqo_threshold&lt;/code&gt; 가 초과 되면 &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;59 장에&lt;/a&gt; 설명 된대로 휴리스틱에 의해 고려되는 결합 시퀀스가 ​​결정됩니다 . 그렇지 않으면 프로세스는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d28ef38bf9e5530ece862031c842201d36ddd349" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the directory in which log files will be created. It can be specified as an absolute path, or relative to the cluster data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;log&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수는 로그 파일이 생성 될 디렉토리를 결정합니다. 절대 경로로 지정하거나 클러스터 데이터 디렉토리를 기준으로 지정할 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;log&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3acb8f6d64e7dee8bb588e16430447375cec4a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum amount of time to use an individual log file, after which a new log file will be created. If this value is specified without units, it is taken as minutes. The default is 24 hours. Set to zero to disable time-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">경우 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 파라미터는 새로운 로그 파일이 생성 될 후에 개별 로그 파일을 사용할 수있는 최대 시간을 결정한다. 이 값을 단위없이 지정하면 분으로 간주됩니다. 기본값은 24 시간입니다. 새 로그 파일의 시간 기반 작성을 사용하지 않으려면 0으로 설정하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ba6806c5a61bd0e7df256b20d72936b6dfff344" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum size of an individual log file. After this amount of data has been emitted into a log file, a new log file will be created. If this value is specified without units, it is taken as kilobytes. The default is 10 megabytes. Set to zero to disable size-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">경우 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수는 개별 로그 파일의 최대 사이즈를 결정한다. 이 양의 데이터가 로그 파일로 방출 된 후 새 로그 파일이 작성됩니다. 이 값을 단위없이 지정하면 킬로바이트로 간주됩니다. 기본값은 10MB입니다. 새 로그 파일의 크기 기반 작성을 사용하지 않으려면 0으로 설정하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33d04df6ccc65336486b417a686759bd20169c58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수는 생성 된 로그 파일의 파일 이름을 설정합니다. 값은 &lt;code&gt;strftime&lt;/code&gt; 패턴 으로 처리 되므로 &lt;code&gt;%&lt;/code&gt; -escapes를 사용하여 시변 파일 이름을 지정할 수 있습니다. 표준 시간대에 따른 &lt;code&gt;%&lt;/code&gt; 이스케이프가있는 경우 계산은 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone에&lt;/a&gt; 지정된 영역에서 수행됩니다 . 지원되는 &lt;code&gt;%&lt;/code&gt; 이스케이프는 Open Group의 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; 사양에 나열된 것과 유사합니다 . 시스템의 &lt;code&gt;strftime&lt;/code&gt; 은 직접 사용되지 않으므로 플랫폼 별 (비표준) 확장은 작동하지 않습니다. 기본값은 &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="912a8bc2db1f94954749b8b7569bc346c69e11ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter will cause PostgreSQL to truncate (overwrite), rather than append to, any existing log file of the same name. However, truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation. When off, pre-existing files will be appended to in all cases. For example, using this setting in combination with a &lt;code&gt;log_filename&lt;/code&gt; like &lt;code&gt;postgresql-%H.log&lt;/code&gt; would result in generating twenty-four hourly log files and then cyclically overwriting them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">때 &lt;code&gt;logging_collector&lt;/code&gt; 이 활성화되어,이 매개 변수 잘라 내기 (덮어 쓰기)에 PostgreSQL의 원인이됩니다보다는에 추가, 같은 이름의 기존 로그 파일. 그러나 서버 시작 또는 크기 기반 회전이 아닌 시간 기반 회전으로 인해 새 파일을 열 때만 잘림이 발생합니다. 해제하면 기존 파일이 모든 경우에 추가됩니다. 예를 들어, &lt;code&gt;postgresql-%H.log&lt;/code&gt; 와 같은 &lt;code&gt;log_filename&lt;/code&gt; 과 함께이 설정을 사용하면 24 시간마다 로그 파일을 생성 한 다음 주기적으로 덮어 씁니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac2a30741ea2b8dcb498e785772cf2a514f01258" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;on&lt;/code&gt; (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL command. When &lt;code&gt;off&lt;/code&gt; or unset, SQL commands are not committed until you explicitly issue &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;. The autocommit-off mode works by issuing an implicit &lt;code&gt;BEGIN&lt;/code&gt; for you, just before any command that is not already in a transaction block and is not itself a &lt;code&gt;BEGIN&lt;/code&gt; or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as &lt;code&gt;VACUUM&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;on&lt;/code&gt; (기본값), 각 SQL 명령은 자동으로 성공적으로 완료되면 최선을 다하고 있습니다. 이 모드에서 커미트를 연기하려면 &lt;code&gt;BEGIN&lt;/code&gt; 또는 &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL 명령을 입력해야합니다 . &lt;code&gt;off&lt;/code&gt; 하거나 설정 해제 하면 &lt;code&gt;COMMIT&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 를 명시 적으로 발행 할 때까지 SQL 명령이 커미트되지 않습니다 . 자동 커미트 오프 모드는 아직 트랜잭션 블록에없고 &lt;code&gt;BEGIN&lt;/code&gt; 또는 다른 트랜잭션 제어 명령이 아닌 명령이나 트랜잭션 블록 내에서 실행할 수없는 명령 직전에 암시 적 &lt;code&gt;BEGIN&lt;/code&gt; 을 발행하여 작동 합니다. (예 : &lt;code&gt;VACUUM&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c85a8f652ce31ff087a3b7cc628918aedc0afe36" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pg_stat_statements&lt;/code&gt; is loaded, it tracks statistics across all databases of the server. To access and manipulate these statistics, the module provides a view, &lt;code&gt;pg_stat_statements&lt;/code&gt;, and the utility functions &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; and &lt;code&gt;pg_stat_statements&lt;/code&gt;. These are not available globally but can be enabled for a specific database with &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;pg_stat_statements&lt;/code&gt; 가 로드, 서버의 모든 데이터베이스에서 통계를 추적합니다. 이 통계에 액세스하고 조작하기 위해 모듈은 &lt;code&gt;pg_stat_statements&lt;/code&gt; 뷰 와 &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; 및 &lt;code&gt;pg_stat_statements&lt;/code&gt; 유틸리티 기능을 제공합니다 . 전역 적으로 사용할 수는 없지만 &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt; 를 사용하여 특정 데이터베이스에 대해 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c48693eca5bd4dca7f7f71afdfbb3d41be3ea38" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;postgres_fdw&lt;/code&gt; encounters a join between foreign tables on the same foreign server, it sends the entire join to the foreign server, unless for some reason it believes that it will be more efficient to fetch rows from each table individually, or unless the table references involved are subject to different user mappings. While sending the &lt;code&gt;JOIN&lt;/code&gt; clauses, it takes the same precautions as mentioned above for the &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">때 &lt;code&gt;postgres_fdw&lt;/code&gt; 만남은 같은 외국 서버에서 외부 테이블 간의 조인 몇 가지 이유는 테이블 참조가 관여하지 않는 한 개별적으로 각 테이블에서 행을 인출하는 것이 더 효율적, 또는 것이라고 생각하지 않는 한, 그것은 전체가 외국 서버에 가입 전송 다른 사용자 매핑이 적용됩니다. &lt;code&gt;JOIN&lt;/code&gt; 절을 전송하는 동안 &lt;code&gt;WHERE&lt;/code&gt; 절에 대해 위에서 언급 한 것과 동일한 예방 조치가 취해집니다 .</target>
        </trans-unit>
        <trans-unit id="8c8497bbbc5c881081d121fdf01a588723979b05" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;program&lt;/code&gt; is specified, &lt;code&gt;command&lt;/code&gt; is executed by psql and the data passed from or to &lt;code&gt;command&lt;/code&gt; is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">때 &lt;code&gt;program&lt;/code&gt; 지정, &lt;code&gt;command&lt;/code&gt; psql의에 의해 실행되고, 또는에 전달 된 데이터 &lt;code&gt;command&lt;/code&gt; 서버와 클라이언트 사이에 라우팅됩니다. 다시 실행 권한은 서버가 아닌 로컬 사용자의 권한이며 SQL 슈퍼 유저 권한은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6840df87dd751c0fab0c6f46649358f6b34c5849" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;slot_name&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, there will be no replication slot associated with the subscription. This can be used if the replication slot will be created later manually. Such subscriptions must also have both &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;create_slot&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;slot_name&lt;/code&gt; 이 &lt;code&gt;NONE&lt;/code&gt; 으로 설정 되면 구독과 연관된 복제 슬롯이 없습니다. 나중에 복제 슬롯을 수동으로 생성 할 경우에 사용할 수 있습니다. 이러한 구독은 &lt;code&gt;enabled&lt;/code&gt; 및 &lt;code&gt;create_slot&lt;/code&gt; 을 모두 &lt;code&gt;false&lt;/code&gt; 로 설정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d3788a4cfcb030ae27460c4ddd94f0d92885c664" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;temp_tablespaces&lt;/code&gt; is set interactively, specifying a nonexistent tablespace is an error, as is specifying a tablespace for which the user does not have &lt;code&gt;CREATE&lt;/code&gt; privilege. However, when using a previously set value, nonexistent tablespaces are ignored, as are tablespaces for which the user lacks &lt;code&gt;CREATE&lt;/code&gt; privilege. In particular, this rule applies when using a value set in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;temp_tablespaces&lt;/code&gt; 가 대화 형으로 설정되어, 존재하지 않는 테이블 스페이스를 지정하면 같은 사용자가 없습니다있는 테이블 스페이스 지정되고, 오류가 &lt;code&gt;CREATE&lt;/code&gt; 권한을. 그러나 이전에 설정 한 값을 사용하는 경우 사용자에게 &lt;code&gt;CREATE&lt;/code&gt; 권한 이없는 테이블 스페이스와 같이 존재하지 않는 테이블 스페이스는 무시 됩니다. 특히이 규칙은 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정된 값을 사용할 때 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c068d98cbad8e288e90e4c1dd972e7c59abbaa3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;tgconstraint&lt;/code&gt; is nonzero, &lt;code&gt;tgconstrrelid&lt;/code&gt;, &lt;code&gt;tgconstrindid&lt;/code&gt;, &lt;code&gt;tgdeferrable&lt;/code&gt;, and &lt;code&gt;tginitdeferred&lt;/code&gt; are largely redundant with the referenced &lt;code&gt;pg_constraint&lt;/code&gt; entry. However, it is possible for a non-deferrable trigger to be associated with a deferrable constraint: foreign key constraints can have some deferrable and some non-deferrable triggers.</source>
          <target state="translated">때 &lt;code&gt;tgconstraint&lt;/code&gt; 이 제로이며, &lt;code&gt;tgconstrrelid&lt;/code&gt; , &lt;code&gt;tgconstrindid&lt;/code&gt; , &lt;code&gt;tgdeferrable&lt;/code&gt; 및 &lt;code&gt;tginitdeferred&lt;/code&gt; 크게 참조와 중복되는 &lt;code&gt;pg_constraint&lt;/code&gt; 의 항목. 그러나 지연 불가능한 트리거가 지연 가능한 제한 조건과 연관 될 수 있습니다. 외래 키 제한 조건은 지연 가능하고 지연 불가능한 트리거를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19d575b88117ece85c7a87c6ea7ead5a6532b19a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trust&lt;/code&gt; authentication is specified, PostgreSQL assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the &lt;code&gt;database&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</source>
          <target state="translated">때 &lt;code&gt;trust&lt;/code&gt; 인증이 지정되어, PostgreSQL는 서버에 연결할 수 누군가가 (심지어 수퍼 유저 이름)를 지정 어떤 데이터베이스 사용자 이름으로 데이터베이스에 액세스 할 수있는 권한을 가정합니다. 물론 &lt;code&gt;database&lt;/code&gt; 및 &lt;code&gt;user&lt;/code&gt; 열의 제한 사항이 여전히 적용됩니다. 이 방법은 서버 연결에 적절한 운영 체제 수준의 보호가있는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="966280f7c40171987c3cbc983291b38e3a71017e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_remote_estimate&lt;/code&gt; is true, &lt;code&gt;postgres_fdw&lt;/code&gt; obtains row count and cost estimates from the remote server and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. When &lt;code&gt;use_remote_estimate&lt;/code&gt; is false, &lt;code&gt;postgres_fdw&lt;/code&gt; performs local row count and cost estimation and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. This local estimation is unlikely to be very accurate unless local copies of the remote table's statistics are available. Running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the foreign table is the way to update the local statistics; this will perform a scan of the remote table and then calculate and store statistics just as though the table were local. Keeping local statistics can be a useful way to reduce per-query planning overhead for a remote table &amp;mdash; but if the remote table is frequently updated, the local statistics will soon be obsolete.</source>
          <target state="translated">경우 &lt;code&gt;use_remote_estimate&lt;/code&gt; 는 사실이다 &lt;code&gt;postgres_fdw&lt;/code&gt; 다음 얻 행수 및 원격 서버로부터 예상 비용 및 추가 &lt;code&gt;fdw_startup_cost&lt;/code&gt; 및 &lt;code&gt;fdw_tuple_cost&lt;/code&gt; 을 비용 추정치. 경우 &lt;code&gt;use_remote_estimate&lt;/code&gt; 이 거짓, &lt;code&gt;postgres_fdw&lt;/code&gt; 된 후 수행 로컬 로우 카운트 및 비용 추정 및 추가 &lt;code&gt;fdw_startup_cost&lt;/code&gt; 및 &lt;code&gt;fdw_tuple_cost&lt;/code&gt; 비용 추정치. 리모트 테이블 통계의 로컬 사본이 사용 가능하지 않으면이 로컬 추정이 매우 정확하지 않을 수 있습니다. &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 실행외부 테이블에는 로컬 통계를 업데이트하는 방법이 있습니다. 이것은 원격 테이블의 스캔을 수행 한 다음 테이블이 로컬 인 것처럼 통계를 계산하고 저장합니다. 로컬 통계를 유지하면 원격 테이블에 대한 쿼리 별 계획 오버 헤드를 줄일 수있는 유용한 방법이 될 수 있습니다. 그러나 원격 테이블이 자주 업데이트되는 경우 로컬 통계는 곧 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="f04447293cfe5a43fce5bd6f976cc350e753a232" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; some SQL commands are optimized to avoid WAL logging, as described in &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;. If archiving or streaming replication were turned on during execution of one of these statements, WAL would not contain enough information for archive recovery. (Crash recovery is unaffected.) For this reason, &lt;code&gt;wal_level&lt;/code&gt; can only be changed at server start. However, &lt;code&gt;archive_command&lt;/code&gt; can be changed with a configuration file reload. If you wish to temporarily stop archiving, one way to do it is to set &lt;code&gt;archive_command&lt;/code&gt; to the empty string (&lt;code&gt;''&lt;/code&gt;). This will cause WAL files to accumulate in &lt;code&gt;pg_wal/&lt;/code&gt; until a working &lt;code&gt;archive_command&lt;/code&gt; is re-established.</source>
          <target state="translated">경우 &lt;code&gt;wal_level&lt;/code&gt; 가 인 &lt;code&gt;minimal&lt;/code&gt; 에 설명 된 어떤 SQL 명령, WAL 로깅을 방지하기 위해 최적화 &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;섹션 14.4.7&lt;/a&gt; . 이러한 명령문 중 하나를 실행하는 동안 아카이브 또는 스트리밍 복제가 설정된 경우 WAL에 아카이브 복구에 필요한 정보가 충분하지 않습니다. (충돌 복구는 영향을받지 않습니다.) 이런 이유로 &lt;code&gt;wal_level&lt;/code&gt; 은 서버 시작시에만 변경할 수 있습니다. 그러나 구성 파일을 다시로드하여 &lt;code&gt;archive_command&lt;/code&gt; 를 변경할 수 있습니다. 보관을 일시적으로 중지하려는 경우, 한 가지 방법은 &lt;code&gt;archive_command&lt;/code&gt; 를 빈 문자열 ( &lt;code&gt;''&lt;/code&gt; )로 설정하는 것입니다. 이렇게하면 WAL 파일 이 작업 할 때까지 &lt;code&gt;pg_wal/&lt;/code&gt; 에 누적됩니다 &lt;code&gt;archive_command&lt;/code&gt; 가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc54463c4a91042c587b320f65f275bd091c2193" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed, there is generally a greatly increased chance of detecting single-bit errors, since strict binary equality is tested, and the indexed attributes within the heap are tested.</source>
          <target state="translated">때 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 검증이 수행되어, 엄격한 진 평등을 테스트하기 때문에, 일반적으로 단일 비트 오류를 검출하는 크게 증가 기회이며, 힙 내에서 인덱스 속성을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="668fe437dfa47692f950b23dc7849bfb4637dcda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; is greater than one, the returned numbers should be averages expected for any one scan of the index.</source>
          <target state="translated">때 &lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; 이&lt;/em&gt; 보다 큰 하나이며, 반환 된 숫자는 지수의 1 스캔 예상 평균해야한다.</target>
        </trans-unit>
        <trans-unit id="36ef5495d24b79877e9b0ce1d70303e79e6501c2" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned for &lt;code&gt;NULL&lt;/code&gt; inputs. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">때 &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 긍정적 인 경우, 제로 행이 반환되는 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 보다 큰 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; . 반대로, &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 가 음수이면 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 가 &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt; 보다 작은 경우 0 개의 행이 반환됩니다 . &lt;code&gt;NULL&lt;/code&gt; 입력에 대해서는 제로 행도 리턴 됩니다 . &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; 가 0 이되는 것은 오류입니다 . 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d1d230678ad6398ea1b726af7844a229cc8f13e" translate="yes" xml:space="preserve">
          <source>When Can Parallel Query Be Used?</source>
          <target state="translated">병렬 쿼리는 언제 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8c5a55e381f3b4b99fc5f9dc03b78c3fc758ed84" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">GSSAPI는 Kerberos를 사용하는 경우 &lt;code&gt;servicename/hostname@realm&lt;/code&gt; 형식의 표준 사용자를 사용합니다 . PostgreSQL 서버는 서버가 사용하는 키탭에 포함 된 프린시 펄을 승인하지만 &lt;code&gt;krbsrvname&lt;/code&gt; 연결 매개 변수를 사용하여 클라이언트에서 연결할 때 올바른 프린시 펄 세부 사항을 지정하도록주의를 기울여야합니다 . ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;33.1.2 절&lt;/a&gt; 참조 ) 설치 기본값은 빌드시 &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; 를 사용하여 기본 &lt;code&gt;postgres&lt;/code&gt; 에서 변경할 수 있습니다.. 대부분의 환경에서이 매개 변수는 변경할 필요가 없습니다. 일부 Kerberos 구현에는 서비스 이름이 대문자 여야하는 Microsoft Active Directory와 같은 다른 서비스 이름이 필요할 수 있습니다 ( &lt;code&gt;POSTGRES&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb176371849755f8e3fddd6c5c7996731ba8719c" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_archive_delay&lt;/code&gt; applies when WAL data is being read from WAL archive (and is therefore not current). If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">핫 스탠바이가 활성화되면이 매개 변수는 &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;26.5.2 절에&lt;/a&gt; 설명 된대로 적용 할 WAL 항목과 충돌하는 스탠바이 쿼리를 취소하기 전에 스탠바이 서버가 대기해야하는 시간을 결정합니다 . &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 는 WAL 데이터를 WAL 아카이브에서 읽을 때 적용되므로 현재가 아닙니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 30 초입니다. 값이 -1이면 대기 쿼리가 충돌하는 쿼리가 완료 될 때까지 영원히 대기 할 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ec8116773102304d6d7b1390f1e98f30e3bb2ff" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; applies when WAL data is being received via streaming replication. If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">핫 스탠바이가 활성화되면이 매개 변수는 &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;26.5.2 절에&lt;/a&gt; 설명 된대로 적용 할 WAL 항목과 충돌하는 스탠바이 쿼리를 취소하기 전에 스탠바이 서버가 대기해야하는 시간을 결정합니다 . &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 는 WAL 데이터가 스트리밍 복제를 통해 수신 될 때 적용됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 30 초입니다. 값이 -1이면 대기 쿼리가 충돌하는 쿼리가 완료 될 때까지 영원히 대기 할 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f0d78fac0ffb73c1a9e09c7cc14d11764cc7556" translate="yes" xml:space="preserve">
          <source>When PostgreSQL maps SQL data values to XML (as in &lt;code&gt;xmlelement&lt;/code&gt;), or XML to SQL (as in the output columns of &lt;code&gt;xmltable&lt;/code&gt;), except for a few cases treated specially, PostgreSQL simply assumes that the XML data type's XPath 1.0 string form will be valid as the text-input form of the SQL datatype, and conversely. This rule has the virtue of simplicity while producing, for many data types, results similar to the mappings specified in the standard.</source>
          <target state="translated">PostgreSQL이 특별히 처리 된 몇 가지 경우를 제외하고 SQL 데이터 값을 &lt;code&gt;xmlelement&lt;/code&gt; 의 XML 또는 XML &lt;code&gt;xmltable&lt;/code&gt; 의 출력 열에 매핑 할 때 PostgreSQL은 단순히 XML 데이터 유형의 XPath 1.0 문자열 형식이 다음 과 같다고 가정합니다. SQL 데이터 유형의 텍스트 입력 형식으로 유효합니다. 이 규칙은 많은 데이터 유형에 대해 표준에 지정된 매핑과 유사한 결과를 생성하는 동안 단순성이라는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4181958cdfd24c8fd1ab7073c5b2ff83fa0a559f" translate="yes" xml:space="preserve">
          <source>When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name that the client sends in the &lt;code&gt;client-first-message&lt;/code&gt;. The user name that was already sent in the startup message is used instead. PostgreSQL supports multiple character encodings, while SCRAM dictates UTF-8 to be used for the user name, so it might be impossible to represent the PostgreSQL user name in UTF-8.</source>
          <target state="translated">PostgreSQL에서 SCRAM-SHA-256을 사용하는 경우 서버는 클라이언트가 &lt;code&gt;client-first-message&lt;/code&gt; 에서 보내는 사용자 이름을 무시합니다 . 시작 메시지에 이미 전송 된 사용자 이름이 대신 사용됩니다. PostgreSQL은 다중 문자 인코딩을 지원하지만 SCRAM은 UTF-8이 사용자 이름으로 사용되도록 지시하므로 PostgreSQL 사용자 이름을 UTF-8로 표현하는 것이 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd20efcfa95fdaaa37532258734ec47bc3eda12" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_list&lt;/code&gt;, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">때 &lt;code&gt;FROM&lt;/code&gt; 절이, 본질적으로 어떤 일이 목표 테이블은 언급 된 테이블에 결합된다는 것이다 &lt;code&gt;from_list&lt;/code&gt; 및 조인의 각 출력 행 목표 테이블에 대한 갱신 동작을 나타낸다. &lt;code&gt;FROM&lt;/code&gt; 을 사용할 때 결합은 각 행이 수정 될 때마다 최대 하나의 출력 행을 생성해야합니다. 즉, 대상 행이 다른 테이블에서 둘 이상의 행에 조인되어서는 안됩니다. 그렇다면 조인 행 중 하나만 대상 행을 업데이트하는 데 사용되지만 어느 행을 사용할지는 쉽게 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a80d67f6221f67e848e31748e5e7aded5d6746e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; item contains &lt;code&gt;LATERAL&lt;/code&gt; cross-references, evaluation proceeds as follows: for each row of the &lt;code&gt;FROM&lt;/code&gt; item providing the cross-referenced column(s), or set of rows of multiple &lt;code&gt;FROM&lt;/code&gt; items providing the columns, the &lt;code&gt;LATERAL&lt;/code&gt; item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).</source>
          <target state="translated">때 &lt;code&gt;FROM&lt;/code&gt; 항목이 포함 된 &lt;code&gt;LATERAL&lt;/code&gt; 은 다음과 같이 상호 참조 평가를 진행하여 다음의 각 행 &lt;code&gt;FROM&lt;/code&gt; 항목 복수의 행들의 상호 참조 컬럼 (들), 또는 세트 제공 &lt;code&gt;FROM&lt;/code&gt; 열을 제공하는 상품의 &lt;code&gt;LATERAL&lt;/code&gt; 항목으로 평가되고 해당 행 또는 행 집합의 열 값 결과 행은 평소처럼 계산 된 행과 결합됩니다. 이는 열 소스 테이블에서 각 행 또는 행 세트에 대해 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="9131be6a2fce2c0e060d15eb98b8c743d3328da0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint is not deferrable, PostgreSQL checks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint as &lt;code&gt;DEFERRABLE&lt;/code&gt; but not deferred (i.e., &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;). Be aware that this can be significantly slower than immediate uniqueness checking.</source>
          <target state="translated">때 &lt;code&gt;UNIQUE&lt;/code&gt; 또는 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 의 제약 연기 아니다 고유성 PostgreSQL의 검사 행 삽입 또는 수정 될 때마다 즉시. SQL 표준에 따르면 명령문의 끝에서만 고유성이 적용되어야합니다. 예를 들어 단일 명령이 여러 키 값을 업데이트 할 때 차이가 있습니다. 표준 호환 동작을 얻으려면 제약 조건을 &lt;code&gt;DEFERRABLE&lt;/code&gt; 로 선언 하지만 지연되지는 않습니다 (즉, &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; ). 이는 즉시 고유성 검사보다 속도가 상당히 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7633f6759da586e80f43626088973d06a48ea56" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;pg_cast&lt;/code&gt; entry has different source and target types and a function that takes more than one argument, it represents converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">때 &lt;code&gt;pg_cast&lt;/code&gt; 의 항목이 상이한 소스 및 타겟 유형 및 하나 개 이상의 인자를하는 기능을 갖고, 그 한 유형에서 다른 유형으로 변환하여 단일 단계로 길이 강제 적용 나타낸다. 이러한 항목을 사용할 수없는 경우 유형 수정자를 사용하는 유형으로 강제 변환하려면 두 가지 단계가 필요합니다. 하나는 데이터 유형간에 변환하고 다른 하나는 수정자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="88f0e69da747f3bb16cb53c469a234fbf587434e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;timestamp with time zone&lt;/code&gt; value is output, it is always converted from UTC to the current &lt;code&gt;timezone&lt;/code&gt; zone, and displayed as local time in that zone. To see the time in another time zone, either change &lt;code&gt;timezone&lt;/code&gt; or use the &lt;code&gt;AT TIME ZONE&lt;/code&gt; construct (see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;Section 9.9.3&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;timestamp with time zone&lt;/code&gt; 값이 있는 타임 스탬프 가 출력되면 항상 UTC에서 현재 &lt;code&gt;timezone&lt;/code&gt; 로 변환 되어 해당 시간대의 현지 시간으로 표시됩니다. 다른 시간대의 시간을 보려면 &lt;code&gt;timezone&lt;/code&gt; 를 변경 하거나 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 구문을 사용 하십시오 ( &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;섹션 9.9.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="27629e4b11182354bc4cc1d2c2660d2bd8a7f20c" translate="yes" xml:space="preserve">
          <source>When a cast has different source and target types and a function that takes more than one argument, it supports converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two cast steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">캐스트에 다른 소스 및 대상 유형과 둘 이상의 인수를 사용하는 함수가 있으면 한 유형에서 다른 유형으로 변환하고 단일 단계에서 길이 강제 적용을 지원합니다. 이러한 항목을 사용할 수없는 경우 유형 수정자를 사용하는 유형으로 강제 변환하려면 두 가지 캐스트 단계가 필요합니다. 하나는 데이터 유형간에 변환하고 다른 하나는 수정자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="49788d41c6b6cbdafb9c157dde66cc21e7ad5c8d" translate="yes" xml:space="preserve">
          <source>When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type).</source>
          <target state="translated">알려진 유형의 값 표현식에 캐스트가 적용되면 런타임 유형 변환을 나타냅니다. 캐스트는 적합한 유형 변환 조작이 정의 된 경우에만 성공합니다. 이것은 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;4.1.2.7 절&lt;/a&gt; 에서 보여 지듯이 상수를 가진 캐스트를 사용하는 것과는 미묘한 차이가 있음을 주목 하라 . 비공식 문자열 리터럴에 적용된 캐스트는 리터럴 상수 값에 대한 유형의 초기 할당을 나타내므로 모든 유형에 대해 성공합니다 (문자열 리터럴의 내용이 데이터 유형에 허용되는 입력 구문 인 경우).</target>
        </trans-unit>
        <trans-unit id="cf5e183edf65b04ea968b8cbec71c03d82d34814" translate="yes" xml:space="preserve">
          <source>When a character string value is cast to or from type &lt;code&gt;xml&lt;/code&gt; without going through &lt;code&gt;XMLPARSE&lt;/code&gt; or &lt;code&gt;XMLSERIALIZE&lt;/code&gt;, respectively, the choice of &lt;code&gt;DOCUMENT&lt;/code&gt; versus &lt;code&gt;CONTENT&lt;/code&gt; is determined by the &amp;ldquo;XML option&amp;rdquo;  session configuration parameter, which can be set using the standard command:</source>
          <target state="translated">문자열 값이 각각 &lt;code&gt;XMLPARSE&lt;/code&gt; 또는 &lt;code&gt;XMLSERIALIZE&lt;/code&gt; 를 거치지 않고 &lt;code&gt;xml&lt;/code&gt; 유형으로 캐스트되거나 xml 유형에서 캐스트 될 때 &lt;code&gt;DOCUMENT&lt;/code&gt; 대 &lt;code&gt;CONTENT&lt;/code&gt; 의 선택은 &quot;XML 옵션&quot;세션 구성 매개 변수에 의해 결정되며 표준 명령을 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42fc13aa34e4743bab6d0037fe542f1b13a66649" translate="yes" xml:space="preserve">
          <source>When a column is added with &lt;code&gt;ADD COLUMN&lt;/code&gt; and a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If no &lt;code&gt;DEFAULT&lt;/code&gt; is specified, NULL is used. In neither case is a rewrite of the table required.</source>
          <target state="translated">&lt;code&gt;ADD COLUMN&lt;/code&gt; 을 사용하여 열을 추가 하고 비 휘발성 &lt;code&gt;DEFAULT&lt;/code&gt; 를 지정하면 명령문의 시점과 기본값이 테이블의 메타 데이터에 저장 될 때 기본값이 평가됩니다. 이 값은 모든 기존 행의 열에 사용됩니다. &lt;code&gt;DEFAULT&lt;/code&gt; 를 지정 하지 않으면 NULL이 사용됩니다. 두 경우 모두 테이블을 다시 쓰지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="4617ca746c05eccbac9e1250d759f5bd44319fcd" translate="yes" xml:space="preserve">
          <source>When a conflicting query is short, it's typically desirable to allow it to complete by delaying WAL application for a little bit; but a long delay in WAL application is usually not desirable. So the cancel mechanism has parameters, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;, that define the maximum allowed delay in WAL application. Conflicting queries will be canceled once it has taken longer than the relevant delay setting to apply any newly-received WAL data. There are two parameters so that different delay values can be specified for the case of reading WAL data from an archive (i.e., initial recovery from a base backup or &amp;ldquo;catching up&amp;rdquo; a standby server that has fallen far behind) versus reading WAL data via streaming replication.</source>
          <target state="translated">충돌하는 쿼리가 짧은 경우 일반적으로 WAL 응용 프로그램을 약간 지연 시켜서 완료하는 것이 바람직합니다. 그러나 WAL 응용 프로그램의 긴 지연은 일반적으로 바람직하지 않습니다. 따라서 취소 메커니즘에는 WAL 애플리케이션에서 허용되는 최대 지연을 정의하는 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; 매개 변수가 있습니다. 새로 수신 된 WAL 데이터를 적용하기 위해 관련 지연 설정보다 오래 걸리면 충돌 쿼리가 취소됩니다. 아카이브에서 WAL 데이터를 읽는 경우 (즉, 기본 백업에서 초기 복구 또는 멀리 떨어진 대기 서버를 &quot;캐치&quot;) 다른 방법을 통해 WAL 데이터를 읽는 경우 다른 지연 값을 지정할 수 있도록 두 개의 매개 변수가 있습니다 스트리밍 복제.</target>
        </trans-unit>
        <trans-unit id="fe9942af75508e96643f23b2bb2b19c3cb29a5d8" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind anonymously (since &lt;code&gt;ldapbinddn&lt;/code&gt; was not specified) to the LDAP server, perform a search for &lt;code&gt;(uid=someuser)&lt;/code&gt; under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</source>
          <target state="translated">데이터베이스 사용자 &lt;code&gt;someuser&lt;/code&gt; 로 데이터베이스 서버에 대한 연결 이 요청되면 PostgreSQL은 ( &lt;code&gt;ldapbinddn&lt;/code&gt; 이 지정되지 않았으므로) LDAP 서버에 익명으로 바인딩하려고 시도 하고 지정된 기본 DN에서 &lt;code&gt;(uid=someuser)&lt;/code&gt; 를 검색합니다 . 항목이 발견되면 클라이언트가 제공 한 찾은 정보와 비밀번호를 사용하여 바인드를 시도합니다. 두 번째 연결에 성공하면 데이터베이스 액세스 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="48781ec5a4acd4a7481b8c8839149e95712b5009" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind to the LDAP server using the DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; and the password provided by the client. If that connection succeeds, the database access is granted.</source>
          <target state="translated">데이터베이스 사용자 &lt;code&gt;someuser&lt;/code&gt; 로 데이터베이스 서버에 대한 연결 이 요청되면 PostgreSQL은 DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; 및 클라이언트가 제공 한 비밀번호를 사용하여 LDAP 서버에 바인딩하려고 시도합니다 . 해당 연결에 성공하면 데이터베이스 액세스 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="c225436eedb2c4fcd16a275b1ddffc50962ab028" translate="yes" xml:space="preserve">
          <source>When a constant's value has been ignored for purposes of matching the query to other queries, the constant is replaced by a parameter symbol, such as &lt;code&gt;$1&lt;/code&gt;, in the &lt;code&gt;pg_stat_statements&lt;/code&gt; display. The rest of the query text is that of the first query that had the particular &lt;code&gt;queryid&lt;/code&gt; hash value associated with the &lt;code&gt;pg_stat_statements&lt;/code&gt; entry.</source>
          <target state="translated">조회를 다른 조회와 일치시키기 위해 상수 값이 무시 된 경우, &lt;code&gt;pg_stat_statements&lt;/code&gt; 표시 에서 상수는 &lt;code&gt;$1&lt;/code&gt; 과 같은 매개 변수 기호로 대체 됩니다. 나머지 쿼리 텍스트는 &lt;code&gt;pg_stat_statements&lt;/code&gt; 항목 과 관련된 특정 &lt;code&gt;queryid&lt;/code&gt; 해시 값 을 가진 첫 번째 쿼리의 텍스트입니다 .</target>
        </trans-unit>
        <trans-unit id="ecb409e448668771f827d8fbf0e7974aed415eec" translate="yes" xml:space="preserve">
          <source>When a data-only dump is chosen and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_dump emits commands to disable triggers on user tables before inserting the data, and then commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">데이터 전용 덤프가 선택되고 &lt;code&gt;--disable-triggers&lt;/code&gt; 옵션 이 사용되면 pg_dump는 데이터를 삽입하기 전에 사용자 테이블에서 트리거를 비활성화하는 명령을 내 보낸 다음 데이터가 삽입 된 후 다시 활성화하는 명령을 내 보냅니다. 중간에 복원이 중지되면 시스템 카탈로그가 잘못된 상태로 남아있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bb4292f30931b17f0bc254f84df53dc22a84368" translate="yes" xml:space="preserve">
          <source>When a direct database connection is specified using the &lt;code&gt;-d&lt;/code&gt; option, pg_restore internally executes SQL statements. If you have problems running pg_restore, make sure you are able to select information from the database using, for example, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 옵션을 사용하여 직접 데이터베이스 연결을 지정하면 pg_restore는 내부적으로 SQL 문을 실행합니다. pg_restore를 실행하는 데 문제가있는 경우 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 등을 사용하여 데이터베이스에서 정보를 선택할 수 있는지 확인하십시오 . 또한 libpq 프론트 엔드 라이브러리에서 사용되는 기본 연결 설정 및 환경 변수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="70b0a551bd1d82e60af1e6e20328604ac27e04a2" translate="yes" xml:space="preserve">
          <source>When a domain has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested in alphabetical order by name. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">도메인에 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 이 여러 개 있으면 이름순으로 사전 순으로 테스트됩니다. 9.5 이전의 PostgreSQL 버전은 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건에 대한 특정 실행 순서를 따르지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="82ae6b8670e18414fb24938a0f2cc8a6d1070788" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the output which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절의 함수에 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 가 접미 부로 지정 되면 &lt;code&gt;bigint&lt;/code&gt; 열이 출력에 추가되어 1에서 시작하여 함수 출력의 각 행에 대해 1 씩 증가합니다. 이것은 &lt;code&gt;unnest()&lt;/code&gt; 와 같은 반환 함수를 설정하는 경우에 가장 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="cc5d8fb3f4d70c3c0f1dea589130a29e4dae23e6" translate="yes" xml:space="preserve">
          <source>When a heap entry is to be deleted (by &lt;code&gt;VACUUM&lt;/code&gt;), all its index entries must be removed first.</source>
          <target state="translated">힙 항목을 삭제하려면 ( &lt;code&gt;VACUUM&lt;/code&gt; ) 모든 색인 항목을 먼저 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="00af93fe8454ff02af34b94554824196fc81e8fc" translate="yes" xml:space="preserve">
          <source>When a locking clause appears at the top level of a &lt;code&gt;SELECT&lt;/code&gt; query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a &lt;code&gt;LIMIT&lt;/code&gt; is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by &lt;code&gt;OFFSET&lt;/code&gt; will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 절의 최상위 레벨에 잠금 절이 표시되면 잠긴 행은 쿼리에 의해 리턴 된 행과 정확히 일치합니다. 조인 쿼리의 경우 잠긴 행은 반환 된 조인 행에 기여하는 행입니다. 또한, 스냅 샷 이후에 갱신되어 쿼리 조건을 만족시키지 않으면 리턴되지 않지만 쿼리 스냅 샷 시점의 쿼리 조건을 만족하는 행은 잠 깁니다. &lt;code&gt;LIMIT&lt;/code&gt; 가 사용되는 경우, 한계 를 만족시키기에 충분한 행이 리턴되면 잠금이 중지됩니다 (그러나 &lt;code&gt;OFFSET&lt;/code&gt; 에 의해 건너 뛴 행 은 잠금 됨에 유의하십시오 ). 마찬가지로, 커서 쿼리에서 잠금 절을 사용하면 실제로 커서로 가져 오거나 한 단계 씩 지난 행만 잠 깁니다.</target>
        </trans-unit>
        <trans-unit id="ef95b8a60ebd804a0c28a2e00cab45258a43a0d6" translate="yes" xml:space="preserve">
          <source>When a locking clause appears in a sub-&lt;code&gt;SELECT&lt;/code&gt;, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,</source>
          <target state="translated">하위 &lt;code&gt;SELECT&lt;/code&gt; 에 잠금 절이 표시되면 잠긴 행은 하위 쿼리에 의해 외부 쿼리로 반환되는 행입니다. 외부 쿼리의 조건을 사용하여 하위 쿼리의 실행을 최적화 할 수 있으므로 하위 쿼리 만 검사하는 것보다 적은 수의 행이 필요할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bfc7a3d97debfcf5d558fe06d1809283c70c4abd" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;GRANT&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options. The &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">객체의 소유자가 아닌 사람 이 객체에 대한 권한 을 &lt;code&gt;GRANT&lt;/code&gt; 하려고 하면 사용자에게 객체에 대한 권한이없는 경우 명령이 실패합니다. 사용 가능한 권한이 있으면 명령이 진행되지만 사용자에게 권한 부여 옵션이있는 권한 만 부여됩니다. &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; 에는 그랜트 옵션을 보유하지 않으면 특별히 명령에 명명 된 권한의 교부금 옵션이 유지되지 않을 경우 다른 형태의 경고를 발행 반면 양식은 경고 메시지를 발행합니다. (이러한 진술은 원칙적으로 개체 소유자에게도 적용되지만 소유자는 항상 모든 보조금 옵션을 보유한 것으로 간주되므로 해당 사례가 발생할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="89d5be09265c0f260930da66e4dbc18e249c5a52" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;REVOKE&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options. The &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">개체의 비 소유자가 개체 에 대한 권한 을 &lt;code&gt;REVOKE&lt;/code&gt; 하려고 하면 사용자에게 개체에 대한 권한이없는 경우 명령이 실패합니다. 사용 가능한 권한이 있으면 명령이 진행되지만 사용자에게 권한 부여 옵션이있는 권한 만 취소됩니다. &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; 에는 그랜트 옵션을 보유하지 않으면 특별히 명령에 명명 된 권한의 교부금 옵션이 유지되지 않을 경우 다른 형태의 경고를 발행 반면 양식은 경고 메시지를 발행합니다. (이러한 진술은 원칙적으로 개체 소유자에게도 적용되지만 소유자는 항상 모든 보조금 옵션을 보유한 것으로 간주되므로 해당 사례가 발생할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="81fc5d42be5663314dba2e99345c9e9036540107" translate="yes" xml:space="preserve">
          <source>When a password is specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, this parameter determines the algorithm to use to encrypt the password. The default value is &lt;code&gt;md5&lt;/code&gt;, which stores the password as an MD5 hash (&lt;code&gt;on&lt;/code&gt; is also accepted, as alias for &lt;code&gt;md5&lt;/code&gt;). Setting this parameter to &lt;code&gt;scram-sha-256&lt;/code&gt; will encrypt the password with SCRAM-SHA-256.</source>
          <target state="translated">&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 또는 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; 에 비밀번호가 지정된 경우이 매개 변수는 비밀번호를 암호화하는 데 사용할 알고리즘을 결정합니다. 기본값은 &lt;code&gt;md5&lt;/code&gt; 이며, 비밀번호를 MD5 해시로 저장합니다 ( &lt;code&gt;on&lt;/code&gt; 은 &lt;code&gt;md5&lt;/code&gt; 의 별명으로도 허용됨 ). 이 매개 변수를 &lt;code&gt;scram-sha-256&lt;/code&gt; 으로 설정하면 SCRAM-SHA-256을 사용하여 비밀번호를 암호화합니다.</target>
        </trans-unit>
        <trans-unit id="a045ad36bdf763a5564eafc812cd1f70e538ac02" translate="yes" xml:space="preserve">
          <source>When a query involves multiple window functions, it is possible to write out each one with a separate &lt;code&gt;OVER&lt;/code&gt; clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a &lt;code&gt;WINDOW&lt;/code&gt; clause and then referenced in &lt;code&gt;OVER&lt;/code&gt;. For example:</source>
          <target state="translated">쿼리에 여러 개의 창 함수가 포함 된 경우 별도의 &lt;code&gt;OVER&lt;/code&gt; 절을 사용하여 각 창을 작성할 수 있지만 여러 함수에 대해 동일한 창 동작이 필요한 경우 중복되고 오류가 발생하기 쉽습니다. 대신, 각 윈도우 동작은 &lt;code&gt;WINDOW&lt;/code&gt; 절 에서 이름을 지정한 다음 &lt;code&gt;OVER&lt;/code&gt; 에서 참조 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b051ff28261e8c6e18971fa6cb50736f0add4f7" translate="yes" xml:space="preserve">
          <source>When a query only involves two or three tables, there aren't many join orders to worry about. But the number of possible join orders grows exponentially as the number of tables expands. Beyond ten or so input tables it's no longer practical to do an exhaustive search of all the possibilities, and even for six or seven tables planning might take an annoyingly long time. When there are too many input tables, the PostgreSQL planner will switch from exhaustive search to a &lt;em&gt;genetic&lt;/em&gt; probabilistic search through a limited number of possibilities. (The switch-over threshold is set by the &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; run-time parameter.) The genetic search takes less time, but it won't necessarily find the best possible plan.</source>
          <target state="translated">쿼리에 두 개 또는 세 개의 테이블 만 포함되는 경우 걱정할 조인 순서가 많지 않습니다. 그러나 가능한 조인 순서의 수는 테이블 수가 늘어남에 따라 기하 급수적으로 증가합니다. 입력 테이블이 10 개 이상이면 모든 가능성을 철저히 검색하는 것이 더 이상 실용적이지 않으며 6 개 또는 7 개의 테이블 계획에도 성가신 시간이 오래 걸릴 수 있습니다. 입력 테이블이 너무 많으면 PostgreSQL 플래너는 제한된 수의 가능성을 통해 철저한 검색에서 &lt;em&gt;유전자&lt;/em&gt; 확률 &lt;em&gt;적&lt;/em&gt; 검색으로 전환 합니다. 전환 임계 값은 &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; 런타임 매개 변수 로 설정됩니다 . 유전자 검색에는 시간이 덜 걸리지 만 반드시 최상의 계획을 찾을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="52a265f5fc62979fde73128f8ace62054feb152e" translate="yes" xml:space="preserve">
          <source>When a schema-qualified operator name is used in the &lt;code&gt;OPERATOR&lt;/code&gt; syntax, as for example in:</source>
          <target state="translated">스키마 규정 연산자 이름이 &lt;code&gt;OPERATOR&lt;/code&gt; 구문에서 사용되는 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="07d688620d10b715a262026cbd31ef1489999e7d" translate="yes" xml:space="preserve">
          <source>When a sequential scan and sort is used, a temporary sort file is also created, so that the peak temporary space requirement is as much as double the table size, plus the index sizes. This method is often faster than the index scan method, but if the disk space requirement is intolerable, you can disable this choice by temporarily setting &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">순차 스캔 및 정렬을 사용하는 경우 임시 정렬 파일도 작성되므로 최대 임시 공간 요구 사항은 테이블 크기와 인덱스 크기의 두 배에 해당합니다. 이 방법은 종종 색인 스캔 방법보다 빠르지 만 디스크 공간 요구 사항을 견딜 수없는 경우 &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; 를 일시적 으로 &lt;code&gt;off&lt;/code&gt; 로 설정하여이 선택을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0770f15e6049d266a12140bc7f33a5609b9c35a" translate="yes" xml:space="preserve">
          <source>When a single element is pushed onto either the beginning or end of a one-dimensional array, the result is an array with the same lower bound subscript as the array operand. For example:</source>
          <target state="translated">단일 요소를 1 차원 배열의 시작 또는 끝으로 밀면 결과는 배열 피연산자와 동일한 하한 첨자를 가진 배열입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f80cd58c4f6747cdabdfc227aecb194029c6f93d" translate="yes" xml:space="preserve">
          <source>When a standby first attaches to the primary, it will not yet be properly synchronized. This is described as &lt;code&gt;catchup&lt;/code&gt; mode. Once the lag between standby and primary reaches zero for the first time we move to real-time &lt;code&gt;streaming&lt;/code&gt; state. The catch-up duration may be long immediately after the standby has been created. If the standby is shut down, then the catch-up period will increase according to the length of time the standby has been down. The standby is only able to become a synchronous standby once it has reached &lt;code&gt;streaming&lt;/code&gt; state. This state can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">대기가 기본 서버에 처음 연결되면 아직 제대로 동기화되지 않습니다. 이것을 &lt;code&gt;catchup&lt;/code&gt; 모드라고합니다. 대기 및 기본 간의 지연이 처음으로 0에 도달하면 실시간 &lt;code&gt;streaming&lt;/code&gt; 상태 로 이동합니다 . 대기 시간이 생성 된 직후 캐치 업 시간이 길어질 수 있습니다. 대기가 종료되면 대기가 종료 된 시간에 따라 캐치 업 기간이 증가합니다. 대기는 &lt;code&gt;streaming&lt;/code&gt; 상태에 도달 한 후에 만 ​​동기 대기가 될 수 있습니다. 이 상태는 &lt;code&gt;pg_stat_replication&lt;/code&gt; 보기를 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad5c61ffccbfb5effcfe0a2c8686ec7385263d29" translate="yes" xml:space="preserve">
          <source>When a subscription is dropped and recreated, the synchronization information is lost. This means that the data has to be resynchronized afterwards.</source>
          <target state="translated">구독을 삭제하고 다시 만들면 동기화 정보가 손실됩니다. 즉, 나중에 데이터를 다시 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b46a9ad23681ef38bc14d25148f1365c37846a4e" translate="yes" xml:space="preserve">
          <source>When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate &lt;code&gt;CHECK&lt;/code&gt; constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.</source>
          <target state="translated">테이블에 기본 파티션이있는 경우 새 파티션을 정의하면 기본 파티션의 파티션 제약 조건이 변경됩니다. 기본 파티션은 새 파티션으로 이동해야하는 행을 포함 할 수 없으며, 존재하지 않는지 확인하기 위해 스캔됩니다. 적절한 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건이 있으면 새 파티션의 스캔과 같이이 스캔을 피할 수 있습니다 . 새 파티션의 스캔과 마찬가지로 기본 파티션이 외부 테이블 인 경우 항상 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="152306185769e157a52b3f97557867eb083f11a7" translate="yes" xml:space="preserve">
          <source>When a table has an existing &lt;code&gt;DEFAULT&lt;/code&gt; partition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.</source>
          <target state="translated">테이블에 기존 &lt;code&gt;DEFAULT&lt;/code&gt; 파티션이 있고 새 파티션이 추가되면 새 파티션에 올바르게 속하는 행이 포함되어 있지 않은지 확인하기 위해 기본 파티션을 스캔해야합니다. 기본 파티션에 많은 수의 행이 있으면 속도가 느려질 수 있습니다. 기본 파티션이 외부 테이블이거나 새 파티션에 배치해야하는 행을 포함 할 수 없다는 제한 조건이있는 경우 스캔을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="43b2ea07826933a7c581c975e04300af317cf31d" translate="yes" xml:space="preserve">
          <source>When a table has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested for each row in alphabetical order by name, after checking &lt;code&gt;NOT NULL&lt;/code&gt; constraints. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">테이블에 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 이 여러 개 있으면 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건 을 확인한 후 이름별로 알파벳 순서로 각 행에 대해 테스트 됩니다 . 9.5 이전의 PostgreSQL 버전은 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건에 대한 특정 실행 순서를 따르지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="082c9f9ffee26ce9be34e1d589e0da24d6b1e31a" translate="yes" xml:space="preserve">
          <source>When a table is being clustered, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock is acquired on it. This prevents any other database operations (both reads and writes) from operating on the table until the &lt;code&gt;CLUSTER&lt;/code&gt; is finished.</source>
          <target state="translated">테이블이 클러스터 될 때 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금이 획득됩니다. 이렇게하면 &lt;code&gt;CLUSTER&lt;/code&gt; 가 완료 될 때까지 다른 데이터베이스 작업 (읽기 및 쓰기)이 테이블에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7d4eb9118baea2c47a40ccbe4939e2face5ca64c" translate="yes" xml:space="preserve">
          <source>When a table is clustered, PostgreSQL remembers which index it was clustered by. The form &lt;code&gt;CLUSTER table_name&lt;/code&gt; reclusters the table using the same index as before. You can also use the &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; forms of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to set the index to be used for future cluster operations, or to clear any previous setting.</source>
          <target state="translated">테이블이 클러스터링되면 PostgreSQL은 클러스터 된 인덱스를 기억합니다. &lt;code&gt;CLUSTER table_name&lt;/code&gt; 양식 은 이전과 동일한 색인을 사용하여 테이블을 다시 클러스터링합니다. 또한 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 의 &lt;code&gt;CLUSTER&lt;/code&gt; 또는 &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; 양식을 사용하여 향후 클러스터 조작에 사용될 인덱스를 설정하거나 이전 설정을 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb320e131f3533a19b92cb04f708af68aba5d79" translate="yes" xml:space="preserve">
          <source>When a table is clustered, it is physically reordered based on the index information. Clustering is a one-time operation: when the table is subsequently updated, the changes are not clustered. That is, no attempt is made to store new or updated rows according to their index order. (If one wishes, one can periodically recluster by issuing the command again. Also, setting the table's &lt;code&gt;fillfactor&lt;/code&gt; storage parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are kept on the same page if enough space is available there.)</source>
          <target state="translated">테이블이 클러스터되면 인덱스 정보에 따라 물리적으로 재정렬됩니다. 클러스터링은 일회성 작업입니다. 이후에 테이블을 업데이트하면 변경 내용이 클러스터되지 않습니다. 즉, 인덱스 순서에 따라 새 행이나 업데이트 된 행을 저장하려고 시도하지 않습니다. (원하는 경우 명령을 다시 실행하여 주기적으로 재 클러스터 할 수 있습니다. 또한 테이블의 &lt;code&gt;fillfactor&lt;/code&gt; 스토리지 매개 변수를 100 % 미만으로 설정하면 업데이트 중에 행이 충분한 경우 공간이 동일한 경우 업데이트 된 행이 동일한 페이지에 유지되므로 업데이트 중에 클러스터 순서를 유지하는 데 도움이 될 수 있습니다 거기에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="49a3d5e22ae2844ff5c06f47ba492689eb79f5ba" translate="yes" xml:space="preserve">
          <source>When a table is created, it contains no data. The first thing to do before a database can be of much use is to insert data. Data is conceptually inserted one row at a time. Of course you can also insert more than one row, but there is no way to insert less than one row. Even if you know only some column values, a complete row must be created.</source>
          <target state="translated">테이블이 작성되면 데이터가 포함되지 않습니다. 데이터베이스를 많이 사용하기 전에 가장 먼저해야 할 일은 데이터를 삽입하는 것입니다. 데이터는 개념적으로 한 번에 한 행씩 삽입됩니다. 물론 둘 이상의 행을 삽입 할 수도 있지만 둘 이상의 행을 삽입 할 방법은 없습니다. 일부 열 값만 알고 있더라도 완전한 행을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="85bad0d57dfc672246f13e6ad8d8a435cc923083" translate="yes" xml:space="preserve">
          <source>When a table or index exceeds 1 GB, it is divided into gigabyte-sized &lt;em&gt;segments&lt;/em&gt;. The first segment's file name is the same as the filenode; subsequent segments are named filenode.1, filenode.2, etc. This arrangement avoids problems on platforms that have file size limitations. (Actually, 1 GB is just the default segment size. The segment size can be adjusted using the configuration option &lt;code&gt;--with-segsize&lt;/code&gt; when building PostgreSQL.) In principle, free space map and visibility map forks could require multiple segments as well, though this is unlikely to happen in practice.</source>
          <target state="translated">테이블 또는 인덱스가 1GB를 초과하면 기가 바이트 크기의 &lt;em&gt;세그먼트&lt;/em&gt; 로 나뉩니다 . 첫 번째 세그먼트의 파일 이름은 파일 노드와 동일합니다. 후속 세그먼트의 이름은 filenode.1, filenode.2 등입니다.이 배열은 파일 크기 제한이있는 플랫폼에서 문제를 방지합니다. (실제로 1GB는 기본 세그먼트 크기 &lt;code&gt;--with-segsize&lt;/code&gt; 입니다. PostgreSQL을 빌드 할 때 --with-segsize 구성 옵션을 사용하여 세그먼트 크기를 조정할 수 있습니다 .) 원칙적으로 여유 공간 맵과 가시성 맵 포크에는 여러 세그먼트가 필요할 수 있습니다. 이것은 실제로 일어날 가능성이 적습니다.</target>
        </trans-unit>
        <trans-unit id="10a45cc60012ed72f0453155b208d80983750321" translate="yes" xml:space="preserve">
          <source>When a table reference names a table that is the parent of a table inheritance hierarchy, the table reference produces rows of not only that table but all of its descendant tables, unless the key word &lt;code&gt;ONLY&lt;/code&gt; precedes the table name. However, the reference produces only the columns that appear in the named table &amp;mdash; any columns added in subtables are ignored.</source>
          <target state="translated">테이블 참조 이름 테이블 상속 계층의 부모 테이블은 테이블 참조가 해당 테이블 그러나 그 자손 테이블의 모든 단지의 행을 생성 할 때 핵심 단어는하지 않는 &lt;code&gt;ONLY&lt;/code&gt; 테이블 이름 앞에. 그러나 참조는 명명 된 테이블에 나타나는 열만 생성합니다. 서브 테이블에 추가 된 모든 열은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="238107619ce9861ed394df0ebec618f90c2d4272" translate="yes" xml:space="preserve">
          <source>When a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by the &lt;code&gt;CREATE TABLE&lt;/code&gt; command. But the &lt;code&gt;CREATE TABLE&lt;/code&gt; command can add defaults and constraints to the table and can specify storage parameters.</source>
          <target state="translated">유형이 지정된 테이블이 작성 될 때 열의 데이터 유형은 기본 복합 유형에 의해 결정되며 &lt;code&gt;CREATE TABLE&lt;/code&gt; 명령으로 지정되지 않습니다 . 그러나 &lt;code&gt;CREATE TABLE&lt;/code&gt; 명령은 테이블에 기본값 및 제한 조건을 추가하고 스토리지 매개 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40ca1a4315d7efd053d1772d2a1868caf568479c" translate="yes" xml:space="preserve">
          <source>When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way:</source>
          <target state="translated">값이 SQL 리터럴 또는 식별자로 사용되는 경우 인용되도록 정렬하는 것이 가장 안전합니다. 변수의 값을 SQL 리터럴로 인용하려면 콜론과 변수 이름을 작은 따옴표로 묶으십시오. 값을 SQL 식별자로 인용하려면 콜론 뒤에 변수 이름을 큰 따옴표로 묶으십시오. 이러한 구문은 변수 값에 포함 된 따옴표 및 기타 특수 문자를 올바르게 처리합니다. 이전 예제는 다음과 같이보다 안전하게 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="55eaed5a13493b2841925c6347f0f009f1c69d52" translate="yes" xml:space="preserve">
          <source>When a view is locked, all relations appearing in the view definition query are also locked recursively with the same lock mode.</source>
          <target state="translated">뷰가 잠기면 뷰 정의 쿼리에 나타나는 모든 관계도 동일한 잠금 모드로 재귀 적으로 잠 깁니다.</target>
        </trans-unit>
        <trans-unit id="0731d9c33a2135d592b4234920022cbe73ac4232" translate="yes" xml:space="preserve">
          <source>When acquiring locks automatically for commands that reference tables, PostgreSQL always uses the least restrictive lock mode possible. &lt;code&gt;LOCK TABLE&lt;/code&gt; provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the &lt;code&gt;READ COMMITTED&lt;/code&gt; isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain &lt;code&gt;SHARE&lt;/code&gt; lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because &lt;code&gt;SHARE&lt;/code&gt; lock mode conflicts with the &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; lock acquired by writers, and your &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; statement will wait until any concurrent holders of &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode locks commit or roll back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock.</source>
          <target state="translated">테이블을 참조하는 명령에 대해 자동으로 잠금을 획득하면 PostgreSQL은 항상 가능한 가장 제한적인 잠금 모드를 사용합니다. &lt;code&gt;LOCK TABLE&lt;/code&gt; 은보다 제한적인 잠금이 필요할 수있는 경우를 제공합니다. 예를 들어, 응용 프로그램이 &lt;code&gt;READ COMMITTED&lt;/code&gt; 분리 레벨 에서 트랜잭션을 실행하고 트랜잭션 기간 동안 테이블의 데이터가 안정적으로 유지되도록해야 한다고 가정 하십시오. 이를 위해 쿼리하기 전에 테이블에서 &lt;code&gt;SHARE&lt;/code&gt; 잠금 모드를 얻을 수 있습니다 . &lt;code&gt;SHARE&lt;/code&gt; 잠금 모드 가 기록기에서 획득 한 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 잠금 과 충돌 하므로 &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; 문은 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 모드 잠금 의 동시 보유자가 커밋하거나 롤백 할 때까지 기다립니다 . 따라서 일단 잠금을 확보하면 커밋되지 않은 쓰기 미해결이 없습니다. 또한 잠금을 해제 할 때까지 아무것도 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71a870f6af21f8dafd4cc733a991bd99fd9d13ef" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;CST7CDT&lt;/code&gt;, &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; will produce &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt;, while adding &lt;code&gt;interval '24 hours'&lt;/code&gt; to the same initial &lt;code&gt;timestamp with time zone&lt;/code&gt; produces &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt;, as there is a change in daylight saving time at &lt;code&gt;2005-04-03 02:00&lt;/code&gt; in time zone &lt;code&gt;CST7CDT&lt;/code&gt;.</source>
          <target state="translated">가산하면 &lt;code&gt;interval&lt;/code&gt; 에 값 (또는 감산 &lt;code&gt;interval&lt;/code&gt; 값에서)는 &lt;code&gt;timestamp with time zone&lt;/code&gt; 일 값을, 발전 요소 또는 일 감소 &lt;code&gt;timestamp with time zone&lt;/code&gt; 일 수에 의하여 지시한다. 일광 절약 시간제 변경 (세션 시간대가 DST를 인식하는 시간대로 설정된 경우)에서 &lt;code&gt;interval '1 day'&lt;/code&gt; 은 반드시 &lt;code&gt;interval '24 hours'&lt;/code&gt; 과 같지 않습니다 . 예를 들어, 세션 시간대로 설정된 &lt;code&gt;CST7CDT&lt;/code&gt; , &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; 생산할 예정 &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt; ,추가하는 동안 &lt;code&gt;interval '24 hours'&lt;/code&gt; &lt;code&gt;timestamp with time zone&lt;/code&gt; 가 있는 동일한 초기 타임 스탬프 에 대한 '24 시간 '간격 &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt; 인 타임 스탬프를 생성합니다 . &lt;code&gt;2005-04-03 02:00&lt;/code&gt; 의 일광 절약 시간 제가 변경되었습니다 . 시간대 &lt;code&gt;CST7CDT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1434d3ccf06b603b0c31a66fe4b553e885790f9" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;Append&lt;/code&gt; node is used in a parallel plan, each process will execute the child plans in the order in which they appear, so that all participating processes cooperate to execute the first child plan until it is complete and then move to the second plan at around the same time. When a &lt;code&gt;Parallel Append&lt;/code&gt; is used instead, the executor will instead spread out the participating processes as evenly as possible across its child plans, so that multiple child plans are executed simultaneously. This avoids contention, and also avoids paying the startup cost of a child plan in those processes that never execute it.</source>
          <target state="translated">때 &lt;code&gt;Append&lt;/code&gt; 노드가 병렬 계획에 사용되는 각 프로세스가 완료 될 때까지 모든 참여 프로세스가 첫 번째 자식 계획을 실행하기 위해 협력 그래서, 그들이 나타나는 순서대로 하위 계획을 실행하고 그 다음에 두 번째 계획으로 이동합니다 같은 시간에. 때 &lt;code&gt;Parallel Append&lt;/code&gt; 대신 사용됩니다, 집행자 대신 여러 하위 계획이 동시에 실행되도록 균등 하위 계획에서 가능한 한 참여 과정을 확산됩니다. 이렇게하면 경합을 피할 수 있으며이를 실행하지 않는 프로세스에서 하위 계획의 시작 비용을 지불하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="5e4864e701f86b03083b18f6c388ffa7cee629fe" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;INSERT&lt;/code&gt; command has an auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause, if the &lt;code&gt;UPDATE&lt;/code&gt; path is taken, the row to be updated is first checked against the &lt;code&gt;USING&lt;/code&gt; expressions of any &lt;code&gt;UPDATE&lt;/code&gt; policies, and then the new updated row is checked against the &lt;code&gt;WITH CHECK&lt;/code&gt; expressions. Note, however, that unlike a standalone &lt;code&gt;UPDATE&lt;/code&gt; command, if the existing row does not pass the &lt;code&gt;USING&lt;/code&gt; expressions, an error will be thrown (the &lt;code&gt;UPDATE&lt;/code&gt; path will &lt;em&gt;never&lt;/em&gt; be silently avoided).</source>
          <target state="translated">때 &lt;code&gt;INSERT&lt;/code&gt; 의 명령이 보조가 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절을 경우, &lt;code&gt;UPDATE&lt;/code&gt; 의 경로가 촬영되는 행이 먼저 확인됩니다 업데이트 할 &lt;code&gt;USING&lt;/code&gt; 어떤 표현 &lt;code&gt;UPDATE&lt;/code&gt; 정책 및 다음 새 업데이트 된 행이에 대해 확인 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현 . 그러나 독립형 &lt;code&gt;UPDATE&lt;/code&gt; 명령 과 달리 기존 행이 &lt;code&gt;USING&lt;/code&gt; 표현식을 전달하지 않으면 오류가 발생합니다 ( &lt;code&gt;UPDATE&lt;/code&gt; 경로는 자동으로 피할 수 &lt;em&gt;없습니다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="f5ddde61a4b6e8647a9abfe81db27fb6ec9b4388" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;N&lt;/code&gt;-dimensional array is pushed onto the beginning or end of an &lt;code&gt;N+1&lt;/code&gt;-dimensional array, the result is analogous to the element-array case above. Each &lt;code&gt;N&lt;/code&gt;-dimensional sub-array is essentially an element of the &lt;code&gt;N+1&lt;/code&gt;-dimensional array's outer dimension. For example:</source>
          <target state="translated">때 &lt;code&gt;N&lt;/code&gt; 차원 배열이 시작 또는 끝으로 푸시 &lt;code&gt;N+1&lt;/code&gt; 차원 배열의 결과는 상기 소자 배열의 경우와 유사하다. 각각의 &lt;code&gt;N&lt;/code&gt; 차원 서브 어레이는 본질적으로 &lt;code&gt;N+1&lt;/code&gt; 차원 어레이의 외부 차원의 요소이다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31260cf4fd42afa924c8ee13fbb974bf90d187b0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; command affects an inheritance hierarchy, the output might look like this:</source>
          <target state="translated">때 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 명령은 상속 계층 구조에 영향을 미치는, 출력은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="5c47d72e8415ae2214a0b4c8ffca096b8ee4f7c5" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">하위 쿼리에 집계식이 나타나는 경우 ( &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;4.2.11 &lt;/a&gt;&lt;a href=&quot;functions-subquery&quot;&gt;단원&lt;/a&gt; 및 9.22 섹션 참조 ) 집계는 일반적으로 하위 쿼리의 행에 대해 평가됩니다. 그러나 집계의 인수 (있는 경우 &lt;code&gt;filter_clause&lt;/code&gt; )에 외부 레벨 변수 만 포함 된 경우 예외가 발생합니다. 그런 다음 집계는 가장 가까운 외부 레벨에 속하며 해당 쿼리의 행에 대해 평가됩니다. 전체 집계 표현식은 하위 쿼리에 대한 외부 참조이며 해당 하위 쿼리에 대한 하나의 평가에 대해 상수 역할을합니다. 결과 목록 또는 &lt;code&gt;HAVING&lt;/code&gt; 절 에만 표시되는 것에 대한 제한 사항은 집계가 속한 쿼리 레벨과 관련하여 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="34d2b87c80e1af3054e4c9d4d3c71d80a5607eb6" translate="yes" xml:space="preserve">
          <source>When an aggregate function is used as a window function, it aggregates over the rows within the current row's window frame. An aggregate used with &lt;code&gt;ORDER BY&lt;/code&gt; and the default window frame definition produces a &amp;ldquo;running sum&amp;rdquo; type of behavior, which may or may not be what's wanted. To obtain aggregation over the whole partition, omit &lt;code&gt;ORDER BY&lt;/code&gt; or use &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt;. Other frame specifications can be used to obtain other effects.</source>
          <target state="translated">집계 함수가 창 함수로 사용되면 현재 행의 창 프레임 내 행에 대해 집계됩니다. &lt;code&gt;ORDER BY&lt;/code&gt; 및 기본 창 프레임 정의와 함께 사용되는 집계 는 &quot;실행 합계&quot;유형의 동작을 생성하며, 원하는 유형일 수도 있고 아닐 수도 있습니다. 전체 파티션에 대한 집계를 얻으려면 &lt;code&gt;ORDER BY&lt;/code&gt; 를 생략 하거나 &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt; 사용하십시오 . 다른 프레임 사양을 사용하여 다른 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64b60eb6cf1570c88f1c1631b3c6e4c5824a2f8b" translate="yes" xml:space="preserve">
          <source>When an alias is applied to the output of a &lt;code&gt;JOIN&lt;/code&gt; clause, the alias hides the original name(s) within the &lt;code&gt;JOIN&lt;/code&gt;. For example:</source>
          <target state="translated">별명이 출력에 적용될 때 &lt;code&gt;JOIN&lt;/code&gt; (가)에서 절 별명 수피 원래 이름 (들) &lt;code&gt;JOIN&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0151521ad4c1bed3dd275586a7870760908f04a0" translate="yes" xml:space="preserve">
          <source>When an application receives this error message, it should abort the current transaction and retry the whole transaction from the beginning. The second time through, the transaction will see the previously-committed change as part of its initial view of the database, so there is no logical conflict in using the new version of the row as the starting point for the new transaction's update.</source>
          <target state="translated">응용 프로그램이이 오류 메시지를 받으면 현재 트랜잭션을 중단하고 전체 트랜잭션을 처음부터 다시 시도해야합니다. 두 번째로, 트랜잭션은 데이터베이스의 초기보기의 일부로 이전에 커밋 된 변경 사항을 볼 수 있으므로 새 버전의 행을 새 트랜잭션 업데이트의 시작점으로 사용하는 데 논리적 충돌이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ee9b3bf4967c5d2fb0d054d753f418145337cf0" translate="yes" xml:space="preserve">
          <source>When an enum type is created, its members are assigned sort-order positions 1..&lt;code&gt;n&lt;/code&gt;. But members added later might be given negative or fractional values of &lt;code&gt;enumsortorder&lt;/code&gt;. The only requirement on these values is that they be correctly ordered and unique within each enum type.</source>
          <target state="translated">열거 형이 작성되면 해당 멤버에는 정렬 순서 위치 1.가 지정됩니다. &lt;code&gt;n&lt;/code&gt; . 그러나 나중에 추가 된 멤버에는 &lt;code&gt;enumsortorder&lt;/code&gt; 의 음수 또는 분수 값이 제공 될 수 있습니다 . 이러한 값에 대한 유일한 요구 사항은 각 열거 형 유형 내에서 올바르게 정렬되고 고유해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0950043f7233c157a718d379ee2b34585d4ee731" translate="yes" xml:space="preserve">
          <source>When an index is declared unique, multiple table rows with equal indexed values are not allowed. Null values are not considered equal. A multicolumn unique index will only reject cases where all indexed columns are equal in multiple rows.</source>
          <target state="translated">인덱스가 고유 한 것으로 선언되면 인덱스 값이 동일한 여러 테이블 행이 허용되지 않습니다. 널값은 동일하지 않은 것으로 간주됩니다. 다중 열 고유 인덱스는 모든 인덱스 열이 여러 행에서 동일한 경우 만 거부합니다.</target>
        </trans-unit>
        <trans-unit id="4aa9424b6df0026312433f3f9260dd9161451961" translate="yes" xml:space="preserve">
          <source>When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page.</source>
          <target state="translated">인덱스 페이지 분할이 필요한 경우이 기능은 페이지의 어떤 항목이 이전 페이지에 남아 있고 어떤 항목이 새 페이지로 이동 할지를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d0d21498c252827ceaa7947111042a06bc38a5a5" translate="yes" xml:space="preserve">
          <source>When an index scan is used, a temporary copy of the table is created that contains the table data in the index order. Temporary copies of each index on the table are created as well. Therefore, you need free space on disk at least equal to the sum of the table size and the index sizes.</source>
          <target state="translated">인덱스 스캔이 사용되면 인덱스 순서로 테이블 데이터가 포함 된 테이블의 임시 사본이 작성됩니다. 테이블에서 각 인덱스의 임시 사본도 작성됩니다. 따라서 최소한 테이블 크기와 인덱스 크기의 합과 같은 디스크 여유 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dad624a33f1e64269d27c153de83dc5212addec4" translate="yes" xml:space="preserve">
          <source>When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, &lt;em&gt;privileges&lt;/em&gt; must be granted.</source>
          <target state="translated">객체가 생성되면 소유자에게 할당됩니다. 소유자는 일반적으로 작성 문을 실행 한 역할입니다. 대부분의 종류의 객체에서 초기 상태는 소유자 (또는 수퍼 유저)만이 객체로 무엇이든 할 수 있다는 것입니다. 다른 역할이이를 사용하려면 &lt;em&gt;권한&lt;/em&gt; 이 부여되어야합니다.</target>
        </trans-unit>
        <trans-unit id="016db50c093e11f2c3975978fc13dbb74ccca023" translate="yes" xml:space="preserve">
          <source>When an operator or function of the underlying type is applied to a domain value, the domain is automatically down-cast to the underlying type. Thus, for example, the result of &lt;code&gt;mytable.id - 1&lt;/code&gt; is considered to be of type &lt;code&gt;integer&lt;/code&gt; not &lt;code&gt;posint&lt;/code&gt;. We could write &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; to cast the result back to &lt;code&gt;posint&lt;/code&gt;, causing the domain's constraints to be rechecked. In this case, that would result in an error if the expression had been applied to an &lt;code&gt;id&lt;/code&gt; value of 1. Assigning a value of the underlying type to a field or variable of the domain type is allowed without writing an explicit cast, but the domain's constraints will be checked.</source>
          <target state="translated">기본 유형의 연산자 또는 기능이 도메인 값에 적용되면 도메인은 기본 유형으로 자동 다운 캐스트됩니다. 따라서, 예를 들어, 결과 &lt;code&gt;mytable.id - 1&lt;/code&gt; 타입의 것으로 간주된다 &lt;code&gt;integer&lt;/code&gt; 하지 &lt;code&gt;posint&lt;/code&gt; . 우리는 쓸 수 &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; 에 캐스팅 결과 다시 &lt;code&gt;posint&lt;/code&gt; 도메인의 제약 조건을 다시 검사하는 원인. 이 경우 표현식이 &lt;code&gt;id&lt;/code&gt; 값 1 에 적용된 경우 오류가 발생합니다. 기본 유형의 값을 도메인 유형의 필드 또는 변수에 지정하는 것은 명시 적 캐스트를 작성하지 않고 허용되지만 도메인의 구속 조건이 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="9d220c80b589197cba0d859444da322b0880222c" translate="yes" xml:space="preserve">
          <source>When archiving WAL data, we need to capture the contents of each segment file once it is filled, and save that data somewhere before the segment file is recycled for reuse. Depending on the application and the available hardware, there could be many different ways of &amp;ldquo;saving the data somewhere&amp;rdquo;: we could copy the segment files to an NFS-mounted directory on another machine, write them onto a tape drive (ensuring that you have a way of identifying the original name of each file), or batch them together and burn them onto CDs, or something else entirely. To provide the database administrator with flexibility, PostgreSQL tries not to make any assumptions about how the archiving will be done. Instead, PostgreSQL lets the administrator specify a shell command to be executed to copy a completed segment file to wherever it needs to go. The command could be as simple as a &lt;code&gt;cp&lt;/code&gt;, or it could invoke a complex shell script &amp;mdash; it's all up to you.</source>
          <target state="translated">WAL 데이터를 보관할 때는 각 세그먼트 파일의 내용이 채워지면 캡처하고 재사용을 위해 세그먼트 파일을 재활용하기 전에 해당 데이터를 어딘가에 저장해야합니다. 응용 프로그램 및 사용 가능한 하드웨어에 따라&amp;ldquo;어딘가에 데이터를 저장하는&amp;rdquo;방법에는 여러 가지가있을 수 있습니다. 세그먼트 파일을 다른 시스템의 NFS 마운트 디렉토리에 복사하여 테이프 드라이브에 기록 할 수 있습니다 ( 각 파일의 원래 이름을 식별하는 방법) 또는 함께 배치하여 CD 또는 다른 것으로 완전히 굽습니다. 데이터베이스 관리자에게 유연성을 제공하기 위해 PostgreSQL은 아카이브 수행 방법에 대한 어떠한 가정도하지 않습니다. 대신, 관리자는 PostgreSQL을 사용하여 완료된 세그먼트 파일을 필요한 곳으로 복사하기 위해 실행할 쉘 명령을 지정할 수 있습니다.명령은 다음과 같이 간단 할 수 있습니다. &lt;code&gt;cp&lt;/code&gt; 또는 복잡한 쉘 스크립트를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3d93c6ecb33c6eb94db27d2fba2d265ff994790" translate="yes" xml:space="preserve">
          <source>When autosummarization is enabled, each time a page range is filled a request is sent to autovacuum for it to execute a targeted summarization for that range, to be fulfilled at the end of the next worker run on the same database. If the request queue is full, the request is not recorded and a message is sent to the server log:</source>
          <target state="translated">자동 요약이 활성화되면 페이지 범위가 채워질 때마다 동일한 데이터베이스에서 다음 작업자 실행이 끝날 때 해당 범위에 대한 대상 요약이 실행되도록 요청이 autovacuum으로 전송됩니다. 요청 큐가 가득 찬 경우 요청이 기록되지 않고 서버 로그로 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f660851bc52c800a20554ffeb6a7df92726f03b4" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-b&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are given, the behavior is to output large objects, when data is being dumped, see the &lt;code&gt;-b&lt;/code&gt; documentation.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; 와 &lt;code&gt;-B&lt;/code&gt; 가 둘 다 주어지면, 데이터를 덤프 할 때 큰 오브젝트를 출력하는 것이 작동 합니다. &lt;code&gt;-b&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad45f5349fac03bd7966e305b187db06383f5ed7" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given for the same schema name, the &lt;code&gt;-N&lt;/code&gt; switch wins and the schema is excluded.</source>
          <target state="translated">두 경우 &lt;code&gt;-n&lt;/code&gt; 와 &lt;code&gt;-N&lt;/code&gt; 이 같은 스키마 이름 주어진다는 &lt;code&gt;-N&lt;/code&gt; 스위치 승 스키마는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="ede3b8af7caafd954943fe5f04f3a1cc429ba018" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given, the behavior is to dump just the schemas that match at least one &lt;code&gt;-n&lt;/code&gt; switch but no &lt;code&gt;-N&lt;/code&gt; switches. If &lt;code&gt;-N&lt;/code&gt; appears without &lt;code&gt;-n&lt;/code&gt;, then schemas matching &lt;code&gt;-N&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">두 경우 &lt;code&gt;-n&lt;/code&gt; 와 &lt;code&gt;-N&lt;/code&gt; 이 제공되며, 동작이 일치하는 적어도 하나 개의 단지 스키마를 덤프하는 것입니다 &lt;code&gt;-n&lt;/code&gt; 스위치하지만 &lt;code&gt;-N&lt;/code&gt; 스위치. 경우 &lt;code&gt;-N&lt;/code&gt; 나타납니다없이 &lt;code&gt;-n&lt;/code&gt; , 다음 스키마 일치 &lt;code&gt;-N&lt;/code&gt; 는 달리 일반 덤프 무엇에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="031547c5dfb59556734ca49134f210c68e4c5520" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-T&lt;/code&gt; are given, the behavior is to dump just the tables that match at least one &lt;code&gt;-t&lt;/code&gt; switch but no &lt;code&gt;-T&lt;/code&gt; switches. If &lt;code&gt;-T&lt;/code&gt; appears without &lt;code&gt;-t&lt;/code&gt;, then tables matching &lt;code&gt;-T&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">두 경우 &lt;code&gt;-t&lt;/code&gt; 및 &lt;code&gt;-T&lt;/code&gt; 가 주어진 동작이 일치하는 적어도 하나 개의 단지 테이블을 덤프하는 것입니다 &lt;code&gt;-t&lt;/code&gt; 스위치하지만 &lt;code&gt;-T&lt;/code&gt; 스위치. 경우 &lt;code&gt;-T&lt;/code&gt; 가 없이 나타납니다 &lt;code&gt;-t&lt;/code&gt; , 일치하는 다음 테이블 &lt;code&gt;-T&lt;/code&gt; 는 달리 일반 덤프 무엇에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="6e63ae1dfc17974e0be483ba0ff638bbea32a3b3" translate="yes" xml:space="preserve">
          <source>When casting from &lt;code&gt;EAN13&lt;/code&gt; to another type, there is a run-time check that the value is within the domain of the other type, and an error is thrown if not. The other casts are simply relabelings that will always succeed.</source>
          <target state="translated">&lt;code&gt;EAN13&lt;/code&gt; 에서 다른 유형으로 캐스트 할 때 값이 다른 유형의 도메인 내에 있는지 런타임 검사가 있으며 그렇지 않은 경우 오류가 발생합니다. 다른 캐스트는 단순히 성공할 레이블을 다시 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b112e4a8b6a5ae3071dcef7339526c0bc3d3e45" translate="yes" xml:space="preserve">
          <source>When changing this value, consider also adjusting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;.</source>
          <target state="translated">이 값을 변경할 때 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; 조정도 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="db437265a89a8152322953823332b5732e1c0d00" translate="yes" xml:space="preserve">
          <source>When choosing OIDs for a patch that is not expected to be committed immediately, best practice is to use a group of more-or-less consecutive OIDs starting with some random choice in the range 8000&amp;mdash;9999. This minimizes the risk of OID collisions with other patches being developed concurrently. To keep the 8000&amp;mdash;9999 range free for development purposes, after a patch has been committed to the master git repository its OIDs should be renumbered into available space below that range. Typically, this will be done near the end of each development cycle, moving all OIDs consumed by patches committed in that cycle at the same time. The script &lt;code&gt;renumber_oids.pl&lt;/code&gt; can be used for this purpose. If an uncommitted patch is found to have OID conflicts with some recently-committed patch, &lt;code&gt;renumber_oids.pl&lt;/code&gt; may also be useful for recovering from that situation.</source>
          <target state="translated">즉시 커밋되지 않을 패치에 대해 OID를 선택할 때 가장 좋은 방법은 8000-9999 범위에서 임의의 선택으로 시작하여 다소 연속적인 OID 그룹을 사용하는 것입니다. 이렇게하면 다른 패치와 동시에 개발되는 OID 충돌의 위험이 최소화됩니다. 개발 목적으로 8000-9999 범위를 자유롭게 유지하려면 패치가 마스터 git 저장소에 커밋 된 후 OID의 번호가 해당 범위 아래의 사용 가능한 공간으로 다시 지정되어야합니다. 일반적으로 이는 각 개발주기가 끝날 무렵에 수행되어 해당주기에서 커밋 된 패치가 소비하는 모든 OID를 동시에 이동합니다. &lt;code&gt;renumber_oids.pl&lt;/code&gt; 스크립트 를이 목적으로 사용할 수 있습니다. 커밋되지 않은 패치가 최근에 커밋 된 패치와 OID 충돌이있는 것으로 확인되면 &lt;code&gt;renumber_oids.pl&lt;/code&gt; 해당 상황에서 복구하는 데 유용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9881b7b2a51c119b916b26c12b2f50a595bc868b" translate="yes" xml:space="preserve">
          <source>When compiled with OpenSSL, there will be more algorithms available. Also public-key encryption functions will be faster as OpenSSL has more optimized BIGNUM functions.</source>
          <target state="translated">OpenSSL로 컴파일하면 더 많은 알고리즘을 사용할 수 있습니다. 또한 OpenSSL에 최적화 된 BIGNUM 기능이 있으므로 공개 키 암호화 기능이 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="5f2a4f35ae5e876b04f4e8702b5ef942899c0855" translate="yes" xml:space="preserve">
          <source>When compiled with zlib, PGP encryption functions are able to compress data before encrypting.</source>
          <target state="translated">zlib로 컴파일하면 PGP 암호화 기능은 암호화 전에 데이터를 압축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4526356cc9d2b5524d1c0613a2cac8e5545975fc" translate="yes" xml:space="preserve">
          <source>When compiling the preprocessed C code files, the compiler needs to be able to find the ECPG header files in the PostgreSQL include directory. Therefore, you might have to use the &lt;code&gt;-I&lt;/code&gt; option when invoking the compiler (e.g., &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt;).</source>
          <target state="translated">사전 처리 된 C 코드 파일을 컴파일 할 때 컴파일러는 PostgreSQL 포함 디렉토리에서 ECPG 헤더 파일을 찾을 수 있어야합니다. 따라서 컴파일러를 호출 할 때 &lt;code&gt;-I&lt;/code&gt; 옵션 을 사용해야 할 수도 있습니다 (예 : &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6cfdda77ce1539f64bc346b96c3160b7466725a" translate="yes" xml:space="preserve">
          <source>When computing the selectivity for a query involving functionally dependent columns, the planner adjusts the per-condition selectivity estimates using the dependency coefficients so as not to produce an underestimate.</source>
          <target state="translated">기능적으로 종속 된 열이 포함 된 쿼리에 대한 선택성을 계산할 때 플래너는 과소 평가를 생성하지 않도록 종속성 계수를 사용하여 조건 별 선택성 추정치를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="29ea042e28fa2362fa9c26ca7e49e9bd0ec5e906" translate="yes" xml:space="preserve">
          <source>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name &lt;code&gt;fred&lt;/code&gt;, principal &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; would be able to connect. To also allow principal &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt;, use a user name map, as described in &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;.</source>
          <target state="translated">데이터베이스에 연결할 때 요청 된 데이터베이스 사용자 이름과 일치하는 프린시 펄에 대한 티켓이 있는지 확인하십시오. 예를 들어, 데이터베이스 사용자 이름 &lt;code&gt;fred&lt;/code&gt; 의 경우 프린시 &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; 을 연결할 수 있습니다. 프린시 &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt; 을 허용하려면 &lt;a href=&quot;auth-username-maps&quot;&gt;섹션 20.2에&lt;/a&gt; 설명 된대로 사용자 이름 맵을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fb2d529ca9e4c06995d0fca116b867907b7f0d6" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify in its connection request the name of the database it wants to connect to. It is not possible to access more than one database per connection. However, an application is not restricted in the number of connections it opens to the same or other databases. Databases are physically separated and access control is managed at the connection level. If one PostgreSQL server instance is to house projects or users that should be separate and for the most part unaware of each other, it is therefore recommended to put them into separate databases. If the projects or users are interrelated and should be able to use each other's resources, they should be put in the same database but possibly into separate schemas. Schemas are a purely logical structure and who can access what is managed by the privilege system. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 서버에 연결할 때 클라이언트는 연결 요청에서 연결할 데이터베이스 이름을 지정해야합니다. 연결 당 둘 이상의 데이터베이스에 액세스 할 수 없습니다. 그러나 응용 프로그램은 동일하거나 다른 데이터베이스에 열려있는 연결 수에 제한이 없습니다. 데이터베이스는 물리적으로 분리되어 있으며 액세스 제어는 연결 수준에서 관리됩니다. 하나의 PostgreSQL 서버 인스턴스가 분리되어야하고 대부분 서로를 알지 못하는 프로젝트 나 사용자를 수용하는 경우 별도의 데이터베이스에 배치하는 것이 좋습니다. 프로젝트 또는 사용자가 서로 관련되어 있고 서로의 리소스를 사용할 수 있어야하는 경우 동일한 데이터베이스에 배치되지만 별도의 스키마에 있어야합니다.스키마는 순전히 논리적 인 구조이며 권한 시스템이 관리하는 것에 액세스 할 수있는 사람입니다. 스키마 관리에 대한 자세한 정보는&lt;a href=&quot;ddl-schemas&quot;&gt;섹션 5.9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12d0d4ecddcc515b05d012f2d76c53d27fb85b80" translate="yes" xml:space="preserve">
          <source>When continuous WAL archiving is used in a standby, there are two different scenarios: the WAL archive can be shared between the primary and the standby, or the standby can have its own WAL archive. When the standby has its own WAL archive, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt;, and the standby will call the archive command for every WAL segment it receives, whether it's by restoring from the archive or by streaming replication. The shared archive can be handled similarly, but the &lt;code&gt;archive_command&lt;/code&gt; must test if the file being archived exists already, and if the existing file has identical contents. This requires more care in the &lt;code&gt;archive_command&lt;/code&gt;, as it must be careful to not overwrite an existing file with different contents, but return success if the exactly same file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive the same file at the same time.</source>
          <target state="translated">대기에서 연속 WAL 보관을 사용하는 경우 두 가지 시나리오가 있습니다. WAL 보관은 기본 및 대기간에 공유되거나 대기에는 자체 WAL 보관이있을 수 있습니다. 대기에 자체 WAL 아카이브가있는 경우 &lt;code&gt;archive_mode&lt;/code&gt; 를 &lt;code&gt;always&lt;/code&gt; 로 설정 하면 대기는 아카이브에서 복원하거나 스트리밍 복제를 통해 수신하는 모든 WAL 세그먼트에 대해 archive 명령을 호출합니다. 공유 아카이브는 비슷하게 처리 할 수 ​​있지만 &lt;code&gt;archive_command&lt;/code&gt; 는 아카이브중인 파일이 이미 존재하는지와 기존 파일의 내용이 동일한 지 테스트해야합니다. &lt;code&gt;archive_command&lt;/code&gt; 에서 더주의해야합니다.내용이 다른 기존 파일을 덮어 쓰지 않도록주의해야하지만 정확히 동일한 파일이 두 번 아카이브되면 성공을 리턴합니다. 두 서버가 동일한 파일을 동시에 아카이브하려고 시도하는 경우 경쟁 조건이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="206b825e98c6a586acace075380fd147e6696a55" translate="yes" xml:space="preserve">
          <source>When converting textual JSON input into &lt;code&gt;jsonb&lt;/code&gt;, the primitive types described by RFC 7159 are effectively mapped onto native PostgreSQL types, as shown in &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;Table 8.23&lt;/a&gt;. Therefore, there are some minor additional constraints on what constitutes valid &lt;code&gt;jsonb&lt;/code&gt; data that do not apply to the &lt;code&gt;json&lt;/code&gt; type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, &lt;code&gt;jsonb&lt;/code&gt; will reject numbers that are outside the range of the PostgreSQL &lt;code&gt;numeric&lt;/code&gt; data type, while &lt;code&gt;json&lt;/code&gt; will not. Such implementation-defined restrictions are permitted by RFC 7159. However, in practice such problems are far more likely to occur in other implementations, as it is common to represent JSON's &lt;code&gt;number&lt;/code&gt; primitive type as IEEE 754 double precision floating point (which RFC 7159 explicitly anticipates and allows for). When using JSON as an interchange format with such systems, the danger of losing numeric precision compared to data originally stored by PostgreSQL should be considered.</source>
          <target state="translated">텍스트 JSON 입력을 &lt;code&gt;jsonb&lt;/code&gt; 로 변환 할 때 RFC 7159에 설명 된 기본 유형은 &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;표 8.23에&lt;/a&gt; 표시된대로 기본 PostgreSQL 유형에 효과적으로 맵핑 됩니다. 따라서 &lt;code&gt;json&lt;/code&gt; 유형에 적용되지 않는 유효한 &lt;code&gt;jsonb&lt;/code&gt; 데이터를 구성하는 요소와 추상 데이터의 JSON에는 기본 데이터 유형으로 표시 할 수있는 항목의 한계에 해당하는 약간의 추가 제한 사항 이 있습니다. 특히 &lt;code&gt;jsonb&lt;/code&gt; 는 PostgreSQL &lt;code&gt;numeric&lt;/code&gt; 데이터 유형 의 범위를 벗어난 숫자를 거부 하지만 &lt;code&gt;json&lt;/code&gt; 은하지 않을 것이다. 이러한 구현 정의 된 제한은 RFC 7159에 의해 허용됩니다. 그러나 실제로 이러한 문제는 다른 구현에서 발생할 가능성이 훨씬 높습니다 .JSON의 &lt;code&gt;number&lt;/code&gt; 기본 유형을 IEEE 754 배정 밀도 부동 소수점 (RFC 7159가 명시 적으로 예상 함)으로 나타내는 것이 일반적이기 때문입니다. 허용). 이러한 시스템에서 JSON을 교환 형식으로 사용하는 경우 원래 PostgreSQL에 저장된 데이터와 비교할 때 숫자 정밀도가 손실 될 위험이 고려되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e063ec55d6b5085c54d075810d580142922489d3" translate="yes" xml:space="preserve">
          <source>When creating a comment on a constraint, a trigger, a rule or a policy these parameters specify the name of the table or domain on which that object is defined.</source>
          <target state="translated">제한 조건, 트리거, 규칙 또는 정책에 대한 주석을 작성할 때이 매개 변수는 해당 오브젝트가 정의 된 테이블 또는 도메인의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="696e17ed5a7d60938c1cece83fb1d6b1c0903390" translate="yes" xml:space="preserve">
          <source>When creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.</source>
          <target state="translated">해시 파티션을 만들 때 모듈러스와 나머지를 지정해야합니다. 모듈러스는 양의 정수 여야하고 나머지는 모듈러스보다 작은 음이 아닌 정수 여야합니다. 일반적으로 해시 파티션 된 테이블을 처음 설정할 때 파티션 수와 동일한 모듈러스를 선택하고 모든 테이블에 동일한 모듈러스와 다른 나머지를 지정해야합니다 (아래 예 참조). 그러나 모든 파티션이 동일한 계수를 가질 필요는 없으며, 해시 파티션 된 테이블의 파티션 중 발생하는 모든 계수는 다음으로 큰 계수의 요소 일뿐입니다. 따라서 모든 데이터를 한 번에 이동할 필요없이 파티션 수를 증 분식으로 늘릴 수 있습니다. 예를 들어, 8 개의 파티션을 가진 해시 파티션 된 테이블이 있고 각 파티션에는 모듈러스가 8이라고 가정합니다.모듈 수 8 파티션 중 하나를 분리하고 키 공간의 동일한 부분을 차지하는 두 개의 새로운 모듈 수 16 파티션을 생성 할 수 있습니다 (하나는 나머지는 나머지와 동일 함). 분리 된 파티션, 나머지는 그 값에 8을 더한 값을 더한 8)로 나누고 데이터로 다시 채 웁니다. 그런 다음 아무 것도 남지 않을 때까지 각 계수 -8 파티션에 대해이 작업을 나중에 다시 반복 할 수 있습니다. 여기에는 각 단계에서 여전히 많은 양의 데이터 이동이 포함될 수 있지만 완전히 새로운 테이블을 작성하고 모든 데이터를 한 번에 이동하는 것보다 낫습니다.나머지는 그 값에 8을 더한 나머지 8), 데이터로 다시 채 웁니다. 그런 다음 아무 것도 남지 않을 때까지 각 계수 -8 파티션에 대해이 작업을 나중에 다시 반복 할 수 있습니다. 여기에는 각 단계에서 여전히 많은 양의 데이터 이동이 포함될 수 있지만 완전히 새로운 테이블을 작성하고 모든 데이터를 한 번에 이동하는 것보다 낫습니다.나머지는 그 값에 8을 더한 나머지 8), 데이터로 다시 채 웁니다. 그런 다음 아무 것도 남지 않을 때까지 각 계수 -8 파티션에 대해이 작업을 나중에 다시 반복 할 수 있습니다. 여기에는 각 단계에서 여전히 많은 양의 데이터 이동이 포함될 수 있지만 완전히 새로운 테이블을 작성하고 모든 데이터를 한 번에 이동하는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="dc592c55de3b2852cc094ece1e21e03a790645cd" translate="yes" xml:space="preserve">
          <source>When creating a list partition, &lt;code&gt;NULL&lt;/code&gt; can be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table. &lt;code&gt;NULL&lt;/code&gt; cannot be specified for range partitions.</source>
          <target state="translated">목록 파티션을 작성할 때 파티션 키 파티션이 &lt;code&gt;NULL&lt;/code&gt; 이 될 수 있음을 나타 내기 위해 NULL을 지정할 수 있습니다. 그러나 주어진 상위 테이블에 대해 그러한 목록 파티션을 두 개 이상 가질 수는 없습니다. 범위 파티션에 &lt;code&gt;NULL&lt;/code&gt; 을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="959c4be92ae7a89cd93733c9fb53bfb204d0cf54" translate="yes" xml:space="preserve">
          <source>When creating a range partition involving more than one column, it can also make sense to use &lt;code&gt;MAXVALUE&lt;/code&gt; as part of the lower bound, and &lt;code&gt;MINVALUE&lt;/code&gt; as part of the upper bound. For example, a partition defined using &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined using &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; allows any rows where the first partition key column starts with &quot;a&quot;.</source>
          <target state="translated">둘 이상의 열을 포함하는 범위 파티션을 작성할 때 &lt;code&gt;MAXVALUE&lt;/code&gt; 를 하한의 일부로 사용 하고 &lt;code&gt;MINVALUE&lt;/code&gt; 를 상한의 일부로 사용하는 것이 좋습니다. 예를 들어, &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; 사용하여 정의 된 파티션 은 첫 번째 파티션 키 열이 0보다 크고 10보다 작거나 같은 모든 행을 허용합니다. 마찬가지로, &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; 는 첫 번째 파티션 키 열이 &quot;a&quot;로 시작하는 모든 행을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="57bc08d42f10eaae11d2af1199ad3605b863277f" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">범위 파티션을 작성할 때 &lt;code&gt;FROM&lt;/code&gt; 으로 지정된 하한 은 포함 범위이고 &lt;code&gt;TO&lt;/code&gt; 로 지정된 상한 은 배타적입니다. 즉, &lt;code&gt;FROM&lt;/code&gt; 목록에 지정된 값은이 파티션에 해당하는 파티션 키 열의 유효한 값이지만 &lt;code&gt;TO&lt;/code&gt; 목록의 값은 유효 하지 않습니다. 이 문장은 행 단위 비교 규칙 ( &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;9.23.5 절&lt;/a&gt; ) 에 따라 이해되어야합니다 . 예를 들어 &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; 가 주어지면 파티션 바운드 &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; 는 &lt;code&gt;x=1&lt;/code&gt; 은 &lt;code&gt;y&amp;gt;=2&lt;/code&gt; 이고 &lt;code&gt;x=2&lt;/code&gt; 는 null이 아닌 &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;x=3&lt;/code&gt; 임의와 &lt;code&gt;y&amp;lt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="812122c3d99be13340fb205c1949bf12eabae44b" translate="yes" xml:space="preserve">
          <source>When creating a replication slot (the default behavior), &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">복제 슬롯을 만들 때 (기본 동작) 트랜잭션 블록 안에서 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="de7cd6bf9e49c5d84cc8863ddd6e1c17c3e9e579" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">슬롯을 만들 때 지정된 논리적 디코딩 출력 플러그인을 사용하십시오. &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;48 장을&lt;/a&gt; 참조하십시오 . 슬롯이 이미 존재하는 경우이 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="005a2c498e4cc6e0542ca9414edc2d0ef17812bb" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the remote host is not reachable or in an unclear state. In that case, the subscription can be created using the &lt;code&gt;connect = false&lt;/code&gt; option. The remote host will then not be contacted at all. This is what pg_dump uses. The remote replication slot will then have to be created manually before the subscription can be activated.</source>
          <target state="translated">구독을 만들 때 원격 호스트에 연결할 수 없거나 불분명 한 상태가 아닙니다. 이 경우, &lt;code&gt;connect = false&lt;/code&gt; 옵션을 사용하여 구독을 작성할 수 있습니다 . 그러면 원격 호스트에 전혀 연결되지 않습니다. 이것이 pg_dump가 사용하는 것입니다. 그러면 구독을 활성화하기 전에 원격 복제 슬롯을 수동으로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="34ca2fb6b711dd16e241f960cfce7ef591df396f" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the replication slot already exists. In that case, the subscription can be created using the &lt;code&gt;create_slot = false&lt;/code&gt; option to associate with the existing slot.</source>
          <target state="translated">가입을 생성 할 때 복제 슬롯이 이미 존재합니다. 이 경우 기존 슬롯과 연관시키기 위해 &lt;code&gt;create_slot = false&lt;/code&gt; 옵션을 사용하여 구독을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16abed6745cbdfc58355b822cc58590cd4574664" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the number of partitions on which the index has been completed.</source>
          <target state="translated">파티션 된 테이블에서 인덱스를 작성할 때이 열은 인덱스가 완료된 파티션 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0cf84112606c62d754e9e14623f4cabe94d1c440" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the total number of partitions on which the index is to be created.</source>
          <target state="translated">파티션 된 테이블에서 인덱스를 작성할 때이 컬럼은 인덱스를 작성할 총 파티션 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0f225feca5ba0ff2fa1c5fa9fb76ca1ce05ad30d" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, a &lt;code&gt;choose&lt;/code&gt; result of &lt;code&gt;spgMatchNode&lt;/code&gt; is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied &lt;code&gt;nodeN&lt;/code&gt; value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since that would make the nodes not all equivalent; the &lt;code&gt;spgSplitTuple&lt;/code&gt; action must be used if the value to be inserted doesn't match the existing nodes.</source>
          <target state="translated">를 다룰 때 &lt;code&gt;allTheSame&lt;/code&gt; 의 튜플, a는 &lt;code&gt;choose&lt;/code&gt; 의 결과 &lt;code&gt;spgMatchNode&lt;/code&gt; 가 새로운 값이 해당 노드 중 하나에 할당 할 수 있음을 의미하는 것으로 해석된다; 코어 코드는 제공된 &lt;code&gt;nodeN&lt;/code&gt; 값을 무시하고 임의로 노드 중 하나로 내려갑니다 (트리 균형을 유지하기 위해). &lt;code&gt;spgAddNode&lt;/code&gt; 를 리턴 &lt;code&gt;choose&lt;/code&gt; 하면 오류가 발생 하는데 , 이는 노드가 모두 동일하지는 않기 때문입니다. &lt;code&gt;spgSplitTuple&lt;/code&gt; 의 값이 기존 노드와 일치하지 않는 삽입 할 경우 작업을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc81dfaf2529806492d6926ee92f707f3d6c4c1b" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, the &lt;code&gt;inner_consistent&lt;/code&gt; function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the &lt;code&gt;inner_consistent&lt;/code&gt; function normally assumes about the meaning of the nodes.</source>
          <target state="translated">&lt;code&gt;allTheSame&lt;/code&gt; 튜플을 처리 할 때 &lt;code&gt;inner_consistent&lt;/code&gt; 함수는 노드가 모두 동일하므로 인덱스 검색을 계속하기위한 대상으로 노드를 모두 또는 전혀 반환하지 않아야합니다. &lt;code&gt;inner_consistent&lt;/code&gt; 함수가 일반적으로 노드의 의미에 대해 얼마나 많이 가정 하는지에 따라 특수 코드가 필요할 수도 있고 필요하지 않을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b32b90019e8bbf81fee22cbcc2778aa7cfddfd6c" translate="yes" xml:space="preserve">
          <source>When dealing with multiple-argument aggregate functions, note that the &lt;code&gt;ORDER BY&lt;/code&gt; clause goes after all the aggregate arguments. For example, write this:</source>
          <target state="translated">다중 인수 집계 함수를 처리 할 때 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 모든 집계 인수 뒤에옵니다. 예를 들어 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ec8f5c244f8f3ee5e69ba2a3cc1d82f9a3714553" translate="yes" xml:space="preserve">
          <source>When dealing with outer joins, you might see join plan nodes with both &amp;ldquo;Join Filter&amp;rdquo; and plain &amp;ldquo;Filter&amp;rdquo; conditions attached. Join Filter conditions come from the outer join's &lt;code&gt;ON&lt;/code&gt; clause, so a row that fails the Join Filter condition could still get emitted as a null-extended row. But a plain Filter condition is applied after the outer-join rules and so acts to remove rows unconditionally. In an inner join there is no semantic difference between these types of filters.</source>
          <target state="translated">외부 조인을 처리 할 때&amp;ldquo;조인 필터&amp;rdquo;와 일반&amp;ldquo;필터&amp;rdquo;조건이 모두 연결된 조인 계획 노드가 표시 될 수 있습니다. 조인 필터 조건은 외부 조인의 &lt;code&gt;ON&lt;/code&gt; 절에서 가져 오므로 조인 필터 조건에 실패한 행은 여전히 ​​널 확장 행으로 생성 될 수 있습니다. 그러나 일반 조인 조건은 외부 조인 규칙 뒤에 적용되므로 무조건 행을 제거하는 역할을합니다. 내부 조인에서는 이러한 유형의 필터간에 의미 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a4bff252219a510e2ce0b73debb16a2f8ba45f1" translate="yes" xml:space="preserve">
          <source>When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: &lt;code&gt;bb*&lt;/code&gt; matches the three middle characters of &lt;code&gt;abbbc&lt;/code&gt;; &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; matches all ten characters of &lt;code&gt;weeknights&lt;/code&gt;; when &lt;code&gt;(.*).*&lt;/code&gt; is matched against &lt;code&gt;abc&lt;/code&gt; the parenthesized subexpression matches all three characters; and when &lt;code&gt;(a*)*&lt;/code&gt; is matched against &lt;code&gt;bc&lt;/code&gt; both the whole RE and the parenthesized subexpression match an empty string.</source>
          <target state="translated">더 길거나 더 짧은 일치 항목을 결정할 때 일치 길이는 요소를 대조하지 않고 문자로 측정됩니다. 빈 문자열은 전혀 일치하지 않는 것으로 간주됩니다. 예를 들어, &lt;code&gt;bb*&lt;/code&gt; 는 &lt;code&gt;abbbc&lt;/code&gt; 의 세 중간 문자와 일치합니다 . &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; 모두 10 자와 일치 &lt;code&gt;weeknights&lt;/code&gt; ; 시 &lt;code&gt;(.*).*&lt;/code&gt; 에 대해 일치 &lt;code&gt;abc&lt;/code&gt; 괄호 표현식은 세 개의 문자와 일치; 때 &lt;code&gt;(a*)*&lt;/code&gt; 에 대해 일치 &lt;code&gt;bc&lt;/code&gt; 전체 RE와 괄호 표현식 모두 빈 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f51f30bba3581f1e69eb69eac04311486d90890a" translate="yes" xml:space="preserve">
          <source>When defining the path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similar to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">경로를 정의 할 때 SQL 의 &lt;code&gt;WHERE&lt;/code&gt; 절 과 유사한 하나 이상의 &lt;em&gt;필터 표현식&lt;/em&gt; 을 사용할 수도 있습니다 . 필터 표현식은 물음표로 시작하고 괄호 안에 조건을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="359ea83f4fdb1b7fa655731f901be35273bbf743" translate="yes" xml:space="preserve">
          <source>When dropping a subscription that is associated with a replication slot on the remote host (the normal state), &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will connect to the remote host and try to drop the replication slot as part of its operation. This is necessary so that the resources allocated for the subscription on the remote host are released. If this fails, either because the remote host is not reachable or because the remote replication slot cannot be dropped or does not exist or never existed, the &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; command will fail. To proceed in this situation, disassociate the subscription from the replication slot by executing &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt;. After that, &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will no longer attempt any actions on a remote host. Note that if the remote replication slot still exists, it should then be dropped manually; otherwise it will continue to reserve WAL and might eventually cause the disk to fill up. See also &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;Section 30.2.1&lt;/a&gt;.</source>
          <target state="translated">원격 호스트의 복제 슬롯 (정상 상태)과 관련된 구독을 삭제하면 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 이 원격 호스트에 연결하고 작업의 일부로 복제 슬롯을 삭제하려고 시도합니다. 이는 원격 호스트에서 구독에 할당 된 자원이 해제되도록하는 데 필요합니다. 원격 호스트에 도달 할 수 없거나 원격 복제 슬롯을 삭제할 수 없거나 존재하지 않거나 존재하지 않기 때문에이 작업 이 실패 하면 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 명령이 실패합니다. 이 상황을 진행하려면 &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt; 을 실행하여 구독을 복제 슬롯에서 연결 해제하십시오 . 그 후 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 더 이상 원격 호스트에서 조치를 시도하지 않습니다. 원격 복제 슬롯이 여전히 존재하면 수동으로 삭제해야합니다. 그렇지 않으면 WAL이 계속 예약되어 결국 디스크가 가득 찰 수 있습니다. &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;섹션 30.2.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="16b8b09fc04797b1f4bd77cb938d65220f3c98d4" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the remote host is not reachable. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription. If the remote database instance no longer exists, no further action is then necessary. If, however, the remote database instance is just unreachable, the replication slot should then be dropped manually; otherwise it would continue to reserve WAL and might eventually cause the disk to fill up. Such cases should be carefully investigated.</source>
          <target state="translated">구독을 삭제하면 원격 호스트에 연결할 수 없습니다. 이 경우 구독 을 삭제하기 전에 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; 을 사용하여 구독에서 슬롯을 분리하십시오 . 원격 데이터베이스 인스턴스가 더 이상 존재하지 않으면 추가 조치가 필요하지 않습니다. 그러나 원격 데이터베이스 인스턴스에 도달 할 수없는 경우 복제 슬롯을 수동으로 삭제해야합니다. 그렇지 않으면 WAL이 계속 예약되어 결국 디스크가 가득 찰 수 있습니다. 이러한 경우를 면밀히 조사해야합니다.</target>
        </trans-unit>
        <trans-unit id="aef261ef51923658a5c92b355545488277ab638d" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the replication slot should be kept. This could be useful when the subscriber database is being moved to a different host and will be activated from there. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription.</source>
          <target state="translated">구독을 삭제할 때 복제 슬롯을 유지해야합니다. 이는 구독자 데이터베이스가 다른 호스트로 이동되고 거기서 활성화 될 때 유용 할 수 있습니다. 이 경우 구독 을 삭제하기 전에 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; 을 사용하여 구독에서 슬롯을 분리하십시오 .</target>
        </trans-unit>
        <trans-unit id="7012bb7adb09426a92f880209bcb563fe9379138" translate="yes" xml:space="preserve">
          <source>When dumping data for a table partition, make the &lt;code&gt;COPY&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt; statements target the root of the partitioning hierarchy that contains it, rather than the partition itself. This causes the appropriate partition to be re-determined for each row when the data is loaded. This may be useful when reloading data on a server where rows do not always fall into the same partitions as they did on the original server. That could happen, for example, if the partitioning column is of type text and the two systems have different definitions of the collation used to sort the partitioning column.</source>
          <target state="translated">테이블 파티션에 대한 데이터를 덤프 할 때 &lt;code&gt;COPY&lt;/code&gt; 또는 &lt;code&gt;INSERT&lt;/code&gt; 문이 파티션 자체가 아니라이를 포함하는 파티션 계층의 루트를 대상으로하십시오. 이로 인해 데이터가로드 될 때 각 행에 대해 적절한 파티션이 다시 결정됩니다. 이것은 행이 항상 원래 서버에서와 동일한 파티션에 속하지 않는 서버에서 데이터를 다시로드 할 때 유용 할 수 있습니다. 예를 들어, 파티션 컬럼이 텍스트 유형이고 두 시스템이 파티션 컬럼을 정렬하는 데 사용되는 조합의 정의가 다른 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c4665e18254fa2583d0b9a6ca4200ef73e4faf" translate="yes" xml:space="preserve">
          <source>When dumping logical replication subscriptions, pg_dump will generate &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; commands that use the &lt;code&gt;connect = false&lt;/code&gt; option, so that restoring the subscription does not make remote connections for creating a replication slot or for initial table copy. That way, the dump can be restored without requiring network access to the remote servers. It is then up to the user to reactivate the subscriptions in a suitable way. If the involved hosts have changed, the connection information might have to be changed. It might also be appropriate to truncate the target tables before initiating a new full table copy.</source>
          <target state="translated">논리적 복제 구독을 덤프 할 때 pg_dump는 &lt;code&gt;connect = false&lt;/code&gt; 옵션 을 사용하는 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 명령을 생성 하므로 구독을 복원해도 복제 슬롯을 만들거나 초기 테이블 복사를 위해 원격으로 연결되지 않습니다. 이렇게하면 원격 서버에 대한 네트워크 액세스없이 덤프를 복원 할 수 있습니다. 그러면 적절한 방식으로 구독을 재 활성화하는 것은 사용자의 몫입니다. 관련 호스트가 변경된 경우 연결 정보를 변경해야합니다. 새 전체 테이블 복사를 시작하기 전에 대상 테이블을 자르는 것이 적절할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="edeac7aa265daa84ac15a79b57465693d865b8ff" translate="yes" xml:space="preserve">
          <source>When either stderr or csvlog are included, the file &lt;code&gt;current_logfiles&lt;/code&gt; is created to record the location of the log file(s) currently in use by the logging collector and the associated logging destination. This provides a convenient way to find the logs currently in use by the instance. Here is an example of this file's content:</source>
          <target state="translated">stderr 또는 csvlog가 포함되면 &lt;code&gt;current_logfiles&lt;/code&gt; 파일 이 작성되어 로깅 수집기 및 관련 로깅 대상에서 현재 사용중인 로그 파일의 위치를 ​​기록합니다. 이를 통해 인스턴스에서 현재 사용중인 로그를 편리하게 찾을 수 있습니다. 이 파일 내용의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bf7e84c79ef7d8674ff36f5bd69afa904df5b94" translate="yes" xml:space="preserve">
          <source>When encrypting with a public key:</source>
          <target state="translated">공개 키로 암호화하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d8c4c4accb682e67b5f8b1813c77704fe93cbcb0" translate="yes" xml:space="preserve">
          <source>When encrypting with a symmetric key (i.e., a password):</source>
          <target state="translated">대칭 키 (예 : 비밀번호)로 암호화하는 경우 :</target>
        </trans-unit>
        <trans-unit id="db0cd6f3816a8188a89deee57f710a1baaa98cf3" translate="yes" xml:space="preserve">
          <source>When entering &lt;code&gt;bytea&lt;/code&gt; values in escape format, octets of certain values &lt;em&gt;must&lt;/em&gt; be escaped, while all octet values &lt;em&gt;can&lt;/em&gt; be escaped. In general, to escape an octet, convert it into its three-digit octal value and precede it by a backslash. Backslash itself (octet decimal value 92) can alternatively be represented by double backslashes. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; shows the characters that must be escaped, and gives the alternative escape sequences where applicable.</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 값을 이스케이프 형식으로 입력 할 때 특정 값의 옥텟을 이스케이프 &lt;em&gt;해야&lt;/em&gt; 하며 모든 옥텟 값 &lt;em&gt;을&lt;/em&gt; 이스케이프 &lt;em&gt;할 수&lt;/em&gt; 있습니다. 일반적으로 8 진수를 이스케이프하려면 3 자리 8 진수 값으로 변환 한 다음 백 슬래시를 선행시킵니다. 백 슬래시 자체 (10 진수 10 진수 값 92)는 이중 백 슬래시로 표시 될 수도 있습니다. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;표 8.7&lt;/a&gt; 은 이스케이프해야하는 문자를 보여 주며 해당되는 경우 대체 이스케이프 시퀀스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b723af7e86ecb6fa9f1f4fcf436b5692ddd09fd" translate="yes" xml:space="preserve">
          <source>When establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.</source>
          <target state="translated">다중 레벨 파티션 계층 구조에 대한 고유 제한 조건을 설정할 때 대상 파티션 된 테이블의 파티션 키에있는 모든 열과 모든 하위 파티션 된 테이블의 열이 제한 조건 정의에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5828ba22818bd784c0d1de682badc9fdcf5283f1" translate="yes" xml:space="preserve">
          <source>When estimating the selectivity, the planner applies all the conditions on items in the MCV list, and then sums the frequencies of the matching ones. See &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; in &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; for details.</source>
          <target state="translated">선택도를 추정 할 때 플래너는 MCV 목록의 항목에 대한 모든 조건을 적용한 다음 일치하는 항목의 빈도를 합합니다. 참조 &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; 의 &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="716da7567a674fa423040a77262890c91b3b1491" translate="yes" xml:space="preserve">
          <source>When estimating with functional dependencies, the planner assumes that conditions on the involved columns are compatible and hence redundant. If they are incompatible, the correct estimate would be zero rows, but that possibility is not considered. For example, given a query like</source>
          <target state="translated">기능적 종속성으로 추정 할 때 플래너는 관련 열의 조건이 호환 가능하므로 중복되는 것으로 가정합니다. 호환되지 않는 경우 올바른 추정값은 0 행이지만 해당 가능성은 고려되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="064d226f0b61cda9a60ca08881b4d97cee01ca7a" translate="yes" xml:space="preserve">
          <source>When executed on a primary, the function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. The return value is the backup's ending write-ahead log location (which again can be ignored). After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">기본에서 실행되면이 기능은 미리 쓰기 로그 아카이브 영역에 백업 히스토리 파일을 작성합니다. 히스토리 파일에는 &lt;code&gt;pg_start_backup&lt;/code&gt; 에 지정된 레이블 , 백업 시작 및 종료 미리 쓰기 로그 위치, 백업 시작 및 종료 시간이 포함됩니다. 리턴 값은 백업의 종료 미리 쓰기 로그 위치입니다 (다시 무시할 수 있음). 종료 위치를 기록한 후 현재 미리 쓰기 로그 삽입 지점이 다음 미리 쓰기 로그 파일로 자동으로 진행되므로 백업을 완료하기 위해 즉시 미리 쓰기 로그 파일을 보관할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b575c812fb039c331ed73bad6b9599e79ed09b9b" translate="yes" xml:space="preserve">
          <source>When executed, the example D script gives output such as:</source>
          <target state="translated">실행될 때 예제 D 스크립트는 다음과 같은 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9b9cbbd3bd8e290879a575143872c711e1071acb" translate="yes" xml:space="preserve">
          <source>When executing a parallel plan, you can use &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; to display per-worker statistics for each plan node. This may be useful in determining whether the work is being evenly distributed between all plan nodes and more generally in understanding the performance characteristics of the plan.</source>
          <target state="translated">병렬 계획을 실행할 때 &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; 을 사용하여 각 계획 노드에 대한 작업자 별 통계를 표시 할 수 있습니다 . 이는 작업이 모든 계획 노드간에 균등하게 분배되는지 여부를 결정하고보다 일반적으로 계획의 성능 특성을 이해하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5c9db9afb12cc927dcae6f85bc0fefc8f88ecba" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion so as its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">최근 승격 된 소스로 온라인 클러스터를 사용하여 pg_rewind를 실행하는 경우 제어 파일이 최신 타임 라인 정보를 반영하도록 제어 파일이 대상 클러스터가 사용할 수 있는지 확인하기 위해 제어 파일이 최신 타임 라인 정보를 반영하도록 승격 후 &lt;code&gt;CHECKPOINT&lt;/code&gt; 를 실행 해야합니다. 지정된 소스 클러스터를 사용하여 다시 감습니다.</target>
        </trans-unit>
        <trans-unit id="45578e8de56cf79c1bab7717b9b7f3794e4ce080" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source, a role having sufficient permissions to execute the functions used by pg_rewind on the source cluster can be used instead of a superuser. Here is how to create such a role, named &lt;code&gt;rewind_user&lt;/code&gt; here:</source>
          <target state="translated">온라인 클러스터를 소스로 사용하여 pg_rewind를 실행하는 경우 수퍼 유저 대신 소스 클러스터에서 pg_rewind가 사용하는 기능을 실행할 수있는 권한이있는 역할을 사용할 수 있습니다. &lt;code&gt;rewind_user&lt;/code&gt; 라는 역할을 만드는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9d8da664aa55aa1d9ba572665740c9977324d898" translate="yes" xml:space="preserve">
          <source>When false, the command will not try to refresh table information. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; should then be executed separately. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">false 인 경우 명령은 테이블 정보를 새로 고치려고 시도하지 않습니다. 그런 다음 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 을 별도로 실행해야합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d12b7ebd6720c102addd509acf7a1b3a9bca1905" translate="yes" xml:space="preserve">
          <source>When host names are specified in &lt;code&gt;pg_hba.conf&lt;/code&gt;, you should make sure that name resolution is reasonably fast. It can be of advantage to set up a local name resolution cache such as &lt;code&gt;nscd&lt;/code&gt;. Also, you may wish to enable the configuration parameter &lt;code&gt;log_hostname&lt;/code&gt; to see the client's host name instead of the IP address in the log.</source>
          <target state="translated">호스트 이름이 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에 지정되면 이름 확인 속도가 상당히 빨라야합니다. &lt;code&gt;nscd&lt;/code&gt; 와 같은 로컬 이름 확인 캐시를 설정하는 것이 유리할 수 있습니다 . 또한 구성 매개 변수 &lt;code&gt;log_hostname&lt;/code&gt; 을 사용하여 로그의 IP 주소 대신 클라이언트의 호스트 이름을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b7c985f760c5c9e2832f32ef829164b2539557" translate="yes" xml:space="preserve">
          <source>When ident is specified for a local (non-TCP/IP) connection, peer authentication (see &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt;) will be used instead.</source>
          <target state="translated">로컬 (비 TCP / IP) 연결에 ident가 지정되면 피어 인증 ( &lt;a href=&quot;auth-peer&quot;&gt;20.9&lt;/a&gt; 참조 )이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="81c1aa17a38d25550246efe2b31fe8f5cb3b0dba" translate="yes" xml:space="preserve">
          <source>When indexes are not used, it can be useful for testing to force their use. There are run-time parameters that can turn off various plan types (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;). For instance, turning off sequential scans (&lt;code&gt;enable_seqscan&lt;/code&gt;) and nested-loop joins (&lt;code&gt;enable_nestloop&lt;/code&gt;), which are the most basic plans, will force the system to use a different plan. If the system still chooses a sequential scan or nested-loop join then there is probably a more fundamental reason why the index is not being used; for example, the query condition does not match the index. (What kind of query can use what kind of index is explained in the previous sections.)</source>
          <target state="translated">인덱스를 사용하지 않으면 강제로 사용하도록 테스트하는 데 유용 할 수 있습니다. 다양한 계획 유형을 끌 수있는 런타임 매개 변수가 있습니다 ( &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;19.7.1 절 참조&lt;/a&gt; ). 예를 들어, 가장 기본적인 계획 인 순차 스캔 ( &lt;code&gt;enable_seqscan&lt;/code&gt; ) 및 중첩 루프 조인 ( &lt;code&gt;enable_nestloop&lt;/code&gt; )을 끄면 시스템에서 다른 계획을 사용하게됩니다. 시스템이 여전히 순차적 스캔 또는 중첩 루프 조인을 선택하는 경우 인덱스를 사용하지 않는 더 근본적인 이유가있을 수 있습니다. 예를 들어 쿼리 조건이 인덱스와 일치하지 않습니다. (이전 섹션에서 설명 된 인덱스 종류를 사용할 수있는 쿼리 종류는 무엇입니까?)</target>
        </trans-unit>
        <trans-unit id="9e50d0004d8680329345366b2774f5ebb4ad654f" translate="yes" xml:space="preserve">
          <source>When inserting a lot of data at the same time, consider using the &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. It is not as flexible as the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command, but is more efficient. Refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt; for more information on improving bulk loading performance.</source>
          <target state="translated">많은 양의 데이터를 동시에 삽입 할 때는 &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; 명령 사용을 고려하십시오 . &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; 명령 만큼 유연 하지는 않지만보다 효율적입니다. 벌크 로딩 성능 개선에 대한 자세한 내용 &lt;a href=&quot;populate&quot;&gt;은 14.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfb95bd9b76a1aa6b1bb1f21c135d8d5ba87cb03" translate="yes" xml:space="preserve">
          <source>When issuing queries in a database where some users mistrust other users, observe security precautions from &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt; when writing function calls.</source>
          <target state="translated">일부 사용자가 다른 사용자를 불신하는 데이터베이스에서 쿼리를 발행 할 때는 함수 호출을 작성할 때 &lt;a href=&quot;typeconv-func&quot;&gt;섹션 10.3의&lt;/a&gt; 보안 예방 조치를 준수하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ed9176dec0c08e99a6d40ec733c0b7bac5bbcf2" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.17&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">평가 순서를 강제 &lt;a href=&quot;functions-conditional&quot;&gt;해야하는&lt;/a&gt; 경우 &lt;code&gt;CASE&lt;/code&gt; 구문 ( 섹션 9.17 참조 )을 사용할 수 있습니다. 예를 들어, &lt;code&gt;WHERE&lt;/code&gt; 절 에서 0으로 나누지 않으려는 신뢰할 수없는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="d43ae9852bbd4e7fca0407119c0359f8ae17da03" translate="yes" xml:space="preserve">
          <source>When loading large amounts of data into an installation that uses WAL archiving or streaming replication, it might be faster to take a new base backup after the load has completed than to process a large amount of incremental WAL data. To prevent incremental WAL logging while loading, disable archiving and streaming replication, by setting &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; to &lt;code&gt;minimal&lt;/code&gt;, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;, and &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; to zero. But note that changing these settings requires a server restart.</source>
          <target state="translated">WAL 보관 또는 스트리밍 복제를 사용하는 설비에 대량의 데이터를로드 할 경우로드가 완료된 후 대량의 증분 WAL 데이터를 처리하는 것보다 새로운 기본 백업을 수행하는 것이 더 빠를 수 있습니다. 로드하는 동안 증분 WAL 로깅을 방지하려면 &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; 을 &lt;code&gt;minimal&lt;/code&gt; 로 , &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; 를 &lt;code&gt;off&lt;/code&gt; 로 , &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; 를 0 으로 설정하여 보관 및 스트리밍 복제를 비활성화하십시오 . 그러나이 설정을 변경하면 서버를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="a320947bd6f8b1714ed336d766e812f876be824d" translate="yes" xml:space="preserve">
          <source>When logging to event log is enabled, this parameter determines the program name used to identify PostgreSQL messages in the log. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이벤트 로그에 로깅이 활성화되면이 매개 변수는 로그에서 PostgreSQL 메시지를 식별하는 데 사용되는 프로그램 이름을 결정합니다. 기본값은 &lt;code&gt;PostgreSQL&lt;/code&gt; 입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="688b202e83ca61ee5187e2a33b6d2092af8c2739" translate="yes" xml:space="preserve">
          <source>When logging to syslog and this is on (the default), then each message will be prefixed by an increasing sequence number (such as &lt;code&gt;[2]&lt;/code&gt;). This circumvents the &amp;ldquo;--- last message repeated N times ---&amp;rdquo; suppression that many syslog implementations perform by default. In more modern syslog implementations, repeated message suppression can be configured (for example, &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; in rsyslog), so this might not be necessary. Also, you could turn this off if you actually want to suppress repeated messages.</source>
          <target state="translated">syslog에 로깅 할 때이 값이 켜져 있으면 (기본값) 각 메시지 앞에 일련 번호가 증가합니다 (예 : &lt;code&gt;[2]&lt;/code&gt; ). 이로 인해 많은 syslog 구현이 기본적으로 수행하는 &quot;--- 마지막 메시지 N 번 반복 ---&quot;억제를 피할 수 있습니다. 보다 현대적인 syslog 구현에서는 반복되는 메시지 억제를 구성 할 수 있으므로 (예 : rsyslog의 &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; ) 필요하지 않을 수 있습니다. 또한 실제로 반복되는 메시지를 표시하지 않으려면이 기능을 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba8a396481d44a42fb2aa24b4ad06150638300e9" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines how messages are delivered to syslog. When on (the default), messages are split by lines, and long lines are split so that they will fit into 1024 bytes, which is a typical size limit for traditional syslog implementations. When off, PostgreSQL server log messages are delivered to the syslog service as is, and it is up to the syslog service to cope with the potentially bulky messages.</source>
          <target state="translated">syslog에 로깅이 사용 가능한 경우이 매개 변수는 메시지가 syslog에 전달되는 방법을 결정합니다. 설정하면 (기본값) 메시지가 한 줄씩 분할되고 긴 줄은 1024 바이트에 맞도록 분할됩니다. 이는 전통적인 syslog 구현의 일반적인 크기 제한입니다. 해제하면 PostgreSQL 서버 로그 메시지가 그대로 syslog 서비스로 전달되며 잠재적으로 부피가 큰 메시지에 대처하는 것은 syslog 서비스의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="80ff0840aef3199452ea4eb2990b10a8d1c55939" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the program name used to identify PostgreSQL messages in syslog logs. The default is &lt;code&gt;postgres&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">syslog에 로깅이 사용 가능한 경우이 매개 변수는 syslog 로그에서 PostgreSQL 메시지를 식별하는 데 사용되는 프로그램 이름을 결정합니다. 기본값은 &lt;code&gt;postgres&lt;/code&gt; 입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="985b03993881f4457d8f0c3b34d9b7b01342f4d8" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the syslog &amp;ldquo;facility&amp;rdquo; to be used. You can choose from &lt;code&gt;LOCAL0&lt;/code&gt;, &lt;code&gt;LOCAL1&lt;/code&gt;, &lt;code&gt;LOCAL2&lt;/code&gt;, &lt;code&gt;LOCAL3&lt;/code&gt;, &lt;code&gt;LOCAL4&lt;/code&gt;, &lt;code&gt;LOCAL5&lt;/code&gt;, &lt;code&gt;LOCAL6&lt;/code&gt;, &lt;code&gt;LOCAL7&lt;/code&gt;; the default is &lt;code&gt;LOCAL0&lt;/code&gt;. See also the documentation of your system's syslog daemon. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">syslog에 로깅이 사용 가능한 경우이 매개 변수는 사용할 syslog &quot;기능&quot;을 결정합니다. &lt;code&gt;LOCAL0&lt;/code&gt; , &lt;code&gt;LOCAL1&lt;/code&gt; , &lt;code&gt;LOCAL2&lt;/code&gt; , &lt;code&gt;LOCAL3&lt;/code&gt; , &lt;code&gt;LOCAL4&lt;/code&gt; , &lt;code&gt;LOCAL5&lt;/code&gt; , &lt;code&gt;LOCAL6&lt;/code&gt; , &lt;code&gt;LOCAL7&lt;/code&gt; 중에서 선택할 수 있습니다 . 기본값은 &lt;code&gt;LOCAL0&lt;/code&gt; 입니다. 시스템의 syslog 데몬 설명서도 참조하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b30985843aab3e94f2bd3bce331e8a5523cabcbb" translate="yes" xml:space="preserve">
          <source>When more than one expression is specified, the later values are used to sort rows that are equal according to the earlier values. Each expression can be followed by an optional &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; keyword to set the sort direction to ascending or descending. &lt;code&gt;ASC&lt;/code&gt; order is the default. Ascending order puts smaller values first, where &amp;ldquo;smaller&amp;rdquo; is defined in terms of the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. Similarly, descending order is determined with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">둘 이상의 표현식이 지정되면 나중 값은 이전 값과 동일한 행을 정렬하는 데 사용됩니다. 각 표현식 뒤에 선택적인 &lt;code&gt;ASC&lt;/code&gt; 또는 &lt;code&gt;DESC&lt;/code&gt; 키워드 가 오면 정렬 방향을 오름차순 또는 내림차순으로 설정할 수 있습니다 . &lt;code&gt;ASC&lt;/code&gt; 순서가 기본값입니다. 오름차순은 더 작은 값을 먼저 설정하며, 여기서 &quot;작은&quot;은 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자로 정의됩니다 . 마찬가지로 내림차순은 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자로 결정됩니다 . &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11912d8e839cffb71f2e5fc45344859e046a9cbc" translate="yes" xml:space="preserve">
          <source>When more than one row is specified, all the rows must have the same number of elements. The data types of the resulting table's columns are determined by combining the explicit or inferred types of the expressions appearing in that column, using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="translated">둘 이상의 행이 지정되면 모든 행에 동일한 수의 요소가 있어야합니다. 결과 테이블 열의 데이터 유형은 &lt;code&gt;UNION&lt;/code&gt; 과 동일한 규칙을 사용하여 해당 열에 나타나는 명시 적 또는 유추 된 표현식 유형을 결합하여 결정됩니다 ( &lt;a href=&quot;typeconv-union-case&quot;&gt;10.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="dcff81a7a0194a63301c74dc5ce189cffc265222" translate="yes" xml:space="preserve">
          <source>When multiple policies apply to a given query, they are combined using either &lt;code&gt;OR&lt;/code&gt; (for permissive policies, which are the default) or using &lt;code&gt;AND&lt;/code&gt; (for restrictive policies). This is similar to the rule that a given role has the privileges of all roles that they are a member of. Permissive vs. restrictive policies are discussed further below.</source>
          <target state="translated">지정된 쿼리에 여러 정책이 적용되면 &lt;code&gt;OR&lt;/code&gt; (기본값 인 허용 정책의 경우) 또는 &lt;code&gt;AND&lt;/code&gt; (제한 정책의 경우)를 사용하여 결합 됩니다. 이는 주어진 역할이 자신이 속한 모든 역할의 권한을 갖는다는 규칙과 유사합니다. 허용 정책과 제한 정책은 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="269b9ef4adee76f3240604e5767201bc6ee01e71" translate="yes" xml:space="preserve">
          <source>When multiple policies of different command types apply to the same command (for example, &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; policies applied to an &lt;code&gt;UPDATE&lt;/code&gt; command), then the user must have both types of permissions (for example, permission to select rows from the relation as well as permission to update them). Thus the expressions for one type of policy are combined with the expressions for the other type of policy using the &lt;code&gt;AND&lt;/code&gt; operator.</source>
          <target state="translated">다른 명령 유형의 여러 정책이 동일한 명령에 적용되는 경우 (예 : &lt;code&gt;UPDATE&lt;/code&gt; 명령에 적용된 &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 정책 ) 사용자는 두 가지 유형의 권한 (예 : 관계에서 행을 선택할 수있는 권한 및 업데이트 권한). 따라서 한 유형의 정책에 대한 표현식은 &lt;code&gt;AND&lt;/code&gt; 연산자를 사용하여 다른 유형의 정책에 대한 표현식과 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="556057cb09a8742cb36bd19c1657e03ac61a815b" translate="yes" xml:space="preserve">
          <source>When multiple policies of the same command type apply to the same command, then there must be at least one &lt;code&gt;PERMISSIVE&lt;/code&gt; policy granting access to the relation, and all of the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policies must pass. Thus all the &lt;code&gt;PERMISSIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;OR&lt;/code&gt;, all the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;AND&lt;/code&gt;, and the results are combined using &lt;code&gt;AND&lt;/code&gt;. If there are no &lt;code&gt;PERMISSIVE&lt;/code&gt; policies, then access is denied.</source>
          <target state="translated">동일한 명령 유형의 여러 정책이 동일한 명령에 적용 되면 관계에 대한 액세스 권한을 부여하는 &lt;code&gt;PERMISSIVE&lt;/code&gt; 정책이 하나 이상 있어야 하며 모든 &lt;code&gt;RESTRICTIVE&lt;/code&gt; 정책이 통과해야합니다. 따라서 모든 &lt;code&gt;PERMISSIVE&lt;/code&gt; 정책 표현식은 &lt;code&gt;OR&lt;/code&gt; 을 사용하여 결합 되고 모든 &lt;code&gt;RESTRICTIVE&lt;/code&gt; 정책 표현식은 &lt;code&gt;AND&lt;/code&gt; 를 사용하여 결합 되며 결과는 &lt;code&gt;AND&lt;/code&gt; 를 사용하여 결합됩니다 . &lt;code&gt;PERMISSIVE&lt;/code&gt; 정책 이 없으면 액세스가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="5d6d15be5ddf45a51b853b506d5d1a1d2068106c" translate="yes" xml:space="preserve">
          <source>When multiple window functions are used, all the window functions having syntactically equivalent &lt;code&gt;PARTITION BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; clauses in their window definitions are guaranteed to be evaluated in a single pass over the data. Therefore they will see the same sort ordering, even if the &lt;code&gt;ORDER BY&lt;/code&gt; does not uniquely determine an ordering. However, no guarantees are made about the evaluation of functions having different &lt;code&gt;PARTITION BY&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; specifications. (In such cases a sort step is typically required between the passes of window function evaluations, and the sort is not guaranteed to preserve ordering of rows that its &lt;code&gt;ORDER BY&lt;/code&gt; sees as equivalent.)</source>
          <target state="translated">여러 개의 창 함수를 사용 하는 경우 창 정의에서 구문 상 동등한 &lt;code&gt;PARTITION BY&lt;/code&gt; 및 &lt;code&gt;ORDER BY&lt;/code&gt; 절을 갖는 모든 창 함수 는 데이터에 대한 단일 패스로 평가됩니다. 따라서 &lt;code&gt;ORDER BY&lt;/code&gt; 가 순서를 고유하게 결정하지 않더라도 동일한 정렬 순서를 보게됩니다 . 그러나 &lt;code&gt;PARTITION BY&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 스펙 이 다른 기능의 평가에 대해서는 보증하지 않습니다 . (이러한 경우 일반적으로 창 함수 평가 단계 사이에 정렬 단계가 필요하며 &lt;code&gt;ORDER BY&lt;/code&gt; 가 동등한 행 순서를 유지한다고 정렬이 보장되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="34f31d5224ac605a926f4e92907e12ec5add9474" translate="yes" xml:space="preserve">
          <source>When multiple workers are running, the autovacuum cost delay parameters (see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt;) are &amp;ldquo;balanced&amp;rdquo; among all the running workers, so that the total I/O impact on the system is the same regardless of the number of workers actually running. However, any workers processing tables whose per-table &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; or &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; storage parameters have been set are not considered in the balancing algorithm.</source>
          <target state="translated">여러 작업자가 실행중인 경우, 모든 &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;진공&lt;/a&gt; 작업자간에 autovacuum 비용 지연 매개 변수 ( 섹션 19.4.4 참조 )가 &quot;균형 조정&quot;되므로 시스템에 대한 총 I / O 영향은 실제로 실행중인 작업자 수에 관계없이 동일합니다 . 그러나 테이블 당 &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; 또는 &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; 스토리지 매개 변수가 설정된 테이블을 처리하는 작업자 는 밸런싱 알고리즘에서 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84f11ff5e7225ec364ea450b05da5b31bd525923" translate="yes" xml:space="preserve">
          <source>When no final &lt;code&gt;ELSE&lt;/code&gt; clause is provided to a &lt;code&gt;CASE&lt;/code&gt;, the default value is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 에 최종 &lt;code&gt;ELSE&lt;/code&gt; 절이 제공 되지 않으면 기본값은 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb2d002b299026c6a8e3abc29ae594e572a6b112" translate="yes" xml:space="preserve">
          <source>When non-serializable writes are possible, to ensure the current validity of a row and protect it against concurrent updates one must use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or an appropriate &lt;code&gt;LOCK TABLE&lt;/code&gt; statement. (&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; lock just the returned rows against concurrent updates, while &lt;code&gt;LOCK TABLE&lt;/code&gt; locks the whole table.) This should be taken into account when porting applications to PostgreSQL from other environments.</source>
          <target state="translated">직렬화 할 수없는 쓰기가 가능한 경우, 행의 현재 유효성을 보장하고 동시 갱신으로부터이를 보호하려면 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 또는 적절한 &lt;code&gt;LOCK TABLE&lt;/code&gt; 문을 사용해야 합니다. ( &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 는 동시 업데이트에 대해 반환 된 행만 잠그는 반면 &lt;code&gt;LOCK TABLE&lt;/code&gt; 은 전체 테이블을 잠급니다.) 다른 환경에서 응용 프로그램을 PostgreSQL로 이식 할 때는이 점을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d5d4ed5a8f5b52f15315d7a651b9128c1d498f8" translate="yes" xml:space="preserve">
          <source>When not all owned objects are to be transferred to the same successor owner, it's best to handle the exceptions manually and then perform the above steps to mop up.</source>
          <target state="translated">소유 한 모든 객체를 동일한 후속 소유자에게 전송하지 않을 경우 예외를 수동으로 처리 한 다음 위의 단계를 수행하여 정리하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ed8afcb65f27d90b88c36a924e96931352e55b61" translate="yes" xml:space="preserve">
          <source>When not using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, the &lt;code&gt;column_definition&lt;/code&gt; list replaces the column alias list that could otherwise be attached to the &lt;code&gt;FROM&lt;/code&gt; item; the names in the column definitions serve as column aliases. When using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, a &lt;code&gt;column_definition&lt;/code&gt; list can be attached to each member function separately; or if there is only one member function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause, a &lt;code&gt;column_definition&lt;/code&gt; list can be written in place of a column alias list following &lt;code&gt;ROWS FROM()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ROWS FROM()&lt;/code&gt; 구문을 사용하지 않는 경우 &lt;code&gt;column_definition&lt;/code&gt; 목록은 &lt;code&gt;FROM&lt;/code&gt; 항목에 첨부 될 수있는 열 별명 목록을 대체합니다 . 열 정의의 이름은 열 별칭으로 사용됩니다. 사용시 &lt;code&gt;ROWS FROM()&lt;/code&gt; 구문하는 &lt;code&gt;column_definition&lt;/code&gt; 의 리스트는 별도로 각 기능 부재에 부착 될 수있다; 또는 멤버 함수가 하나만 있고 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 절이 없는 경우 &lt;code&gt;ROWS FROM()&lt;/code&gt; 다음에 열 별명 목록 대신 &lt;code&gt;column_definition&lt;/code&gt; 목록을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89c266fb8eeefdc22c382f51ddfa36d2cdf3fd08" translate="yes" xml:space="preserve">
          <source>When objects are created without specifying a particular target schema, they will be placed in the first valid schema named in &lt;code&gt;search_path&lt;/code&gt;. An error is reported if the search path is empty.</source>
          <target state="translated">특정 대상 스키마를 지정하지 않고 객체를 &lt;code&gt;search_path&lt;/code&gt; 이름이 지정된 첫 번째 유효한 스키마에 배치됩니다 . 검색 경로가 비어 있으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="99ff2ff0bf302907b157207503609b9e0138a5a9" translate="yes" xml:space="preserve">
          <source>When on, a warning is issued if a backslash (&lt;code&gt;\&lt;/code&gt;) appears in an ordinary string literal (&lt;code&gt;'...'&lt;/code&gt; syntax) and &lt;code&gt;standard_conforming_strings&lt;/code&gt; is off. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">설정하면 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )가 일반 문자열 리터럴 ( &lt;code&gt;'...'&lt;/code&gt; 구문)에 나타나고 &lt;code&gt;standard_conforming_strings&lt;/code&gt; 가 해제 된 경우 경고가 발행됩니다 . 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a39a26ef7d5c306f15cfec242fa1908a71ae3775" translate="yes" xml:space="preserve">
          <source>When on, expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; (or &lt;code&gt;NULL = expr&lt;/code&gt;) are treated as &lt;code&gt;expr IS NULL&lt;/code&gt;, that is, they return true if &lt;code&gt;expr&lt;/code&gt; evaluates to the null value, and false otherwise. The correct SQL-spec-compliant behavior of &lt;code&gt;expr = NULL&lt;/code&gt; is to always return null (unknown). Therefore this parameter defaults to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">설정하면 &lt;code&gt;expr = NULL&lt;/code&gt; (또는 &lt;code&gt;NULL = expr&lt;/code&gt; ) 형식의 표현식은 &lt;code&gt;expr IS NULL&lt;/code&gt; 로 처리됩니다. 즉 &lt;code&gt;expr&lt;/code&gt; 이 널값으로 평가 되면 true를 리턴 하고 그렇지 않으면 false를 리턴합니다. &lt;code&gt;expr = NULL&lt;/code&gt; 의 올바른 SQL 스펙 호환 동작은 항상 널 (알 수 없음)을 리턴하는 것입니다. 따라서이 매개 변수의 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd83814e734e8771d44c1de9842876866f19a1c6" translate="yes" xml:space="preserve">
          <source>When on, the parser will emit a warning for any construct that might have changed meanings since PostgreSQL 9.4 as a result of changes in operator precedence. This is useful for auditing applications to see if precedence changes have broken anything; but it is not meant to be kept turned on in production, since it will warn about some perfectly valid, standard-compliant SQL code. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">설정하면 파서에서 PostgreSQL 9.4 이후 연산자 우선 순위가 변경되어 의미가 변경되었을 수있는 모든 구문에 대해 경고를 표시합니다. 이 기능은 응용 프로그램을 감사하여 우선 순위 변경으로 인해 문제가 발생했는지 확인하는 데 유용합니다. 그러나 완벽하게 유효한 표준 호환 SQL 코드에 대해 경고하므로 프로덕션 환경에서 계속 켜져 있지는 않습니다. 디폴트는 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f61f3e69afe30c64a291d60390d7c29326445c47" translate="yes" xml:space="preserve">
          <source>When operators and support functions are added to a family with &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;, they are not part of any specific operator class within the family, but are just &amp;ldquo;loose&amp;rdquo; within the family. This indicates that these operators and functions are compatible with the family's semantics, but are not required for correct functioning of any specific index. (Operators and functions that are so required should be declared as part of an operator class, instead; see &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS&lt;/a&gt;.) PostgreSQL will allow loose members of a family to be dropped from the family at any time, but members of an operator class cannot be dropped without dropping the whole class and any indexes that depend on it. Typically, single-data-type operators and functions are part of operator classes because they are needed to support an index on that specific data type, while cross-data-type operators and functions are made loose members of the family.</source>
          <target state="translated">운영자 및 지원 기능이 &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 가있는 패밀리에 추가되면 해당 패밀리 내의 특정 운영자 클래스의 일부가 아니라 패밀리 내에서 &quot;느슨한&quot;것입니다. 이는 이러한 연산자 및 기능이 제품군의 의미와 호환되지만 특정 색인의 올바른 기능에 필요하지는 않음을 나타냅니다. (필요한 연산자와 함수는 대신 연산자 클래스의 일부로 선언해야합니다. &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS를&lt;/a&gt; 참조하십시오..) PostgreSQL을 사용하면 언제든지 패밀리의 느슨한 멤버를 패밀리에서 삭제할 수 있지만 전체 클래스와 그에 종속 된 인덱스를 삭제하지 않고 운영자 클래스의 멤버를 삭제할 수 없습니다. 일반적으로 단일 데이터 유형 연산자 및 함수는 해당 특정 데이터 유형에 대한 색인을 지원하는 데 필요하기 때문에 연산자 데이터의 일부이며, 교차 데이터 유형 연산자 및 함수는 계열의 느슨한 구성원이됩니다.</target>
        </trans-unit>
        <trans-unit id="0f2ad4b5a54137b2f0c70ae82420f67c0b1b6ea3" translate="yes" xml:space="preserve">
          <source>When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table.</source>
          <target state="translated">쿼리 또는 업데이트가 단일 파티션의 많은 비율에 액세스 할 때 전체 테이블에 분산 된 인덱스 및 임의 액세스 읽기를 사용하는 대신 해당 파티션의 순차적 스캔을 활용하여 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2540d43e50d1abeb1a847d9db340690266815c23" translate="yes" xml:space="preserve">
          <source>When relying on Serializable transactions to prevent anomalies, it is important that any data read from a permanent user table not be considered valid until the transaction which read it has successfully committed. This is true even for read-only transactions, except that data read within a &lt;em&gt;deferrable&lt;/em&gt; read-only transaction is known to be valid as soon as it is read, because such a transaction waits until it can acquire a snapshot guaranteed to be free from such problems before starting to read any data. In all other cases applications must not depend on results read during a transaction that later aborted; instead, they should retry the transaction until it succeeds.</source>
          <target state="translated">예외를 방지하기 위해 직렬화 가능 트랜잭션에 의존하는 경우 영구 사용자 테이블에서 읽은 데이터는 트랜잭션을 성공적으로 커밋 할 때까지 유효하지 않은 것으로 간주해야합니다. 이는 &lt;em&gt;지연 가능한&lt;/em&gt; 읽기 전용 트랜잭션 내에서 읽은 데이터가 읽히는 즉시 유효한 것으로 알려져 있다는 점을 제외하고는 읽기 전용 트랜잭션의 경우에도 해당됩니다. 이러한 트랜잭션은 해당 트랜잭션이없는 스냅 샷을 확보 할 수있을 때까지 대기하기 때문입니다. 데이터를 읽기 전에 문제가 발생합니다. 다른 모든 경우에 응용 프로그램은 나중에 중단 된 트랜잭션 동안 읽은 결과에 의존해서는 안됩니다. 대신 성공할 때까지 트랜잭션을 재 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f545c1f8d440a6a74e5e5cae7b49a8321ce778e" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE FUNCTION&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">반복 된 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 호출이 동일한 오브젝트 파일을 참조하면 파일은 세션 당 한 번만로드됩니다. 파일을 언로드하고 다시로드하려면 (아마 개발 중에) 새 세션을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="63cb3d013e86db6ef5ef57500326cdf863814f3a" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">&lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 호출이 동일한 오브젝트 파일을 반복 하면 파일은 세션 당 한 번만로드됩니다. 파일을 언로드하고 다시로드하려면 (아마 개발 중에) 새 세션을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b358e9fc6a1b297fd0b37a45eac263be99236636" translate="yes" xml:space="preserve">
          <source>When replacing an existing definition, the argument types, result type, and number of direct arguments may not be changed. Also, the new definition must be of the same kind (ordinary aggregate, ordered-set aggregate, or hypothetical-set aggregate) as the old one.</source>
          <target state="translated">기존 정의를 대체 할 때 인수 유형, 결과 유형 및 직접 인수 수는 변경되지 않을 수 있습니다. 또한 새 정의는 이전 정의와 동일한 종류 (일반 집계, 순서 집합 집계 또는 가정 집합 집합) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="bf16a952f545e26cfee0e603603bfd07e12cf881" translate="yes" xml:space="preserve">
          <source>When replacing an existing function with &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;, there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function's result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced.</source>
          <target state="translated">기존 함수를 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 으로 바꾸는 경우 매개 변수 이름 변경에 제한이 있습니다. 입력 매개 변수에 이미 지정된 이름은 변경할 수 없습니다 (이전에없는 매개 변수에는 이름을 추가 할 수 있음). 출력 매개 변수가 두 개 이상인 경우 출력 매개 변수의 이름을 변경할 수 없습니다. 그 결과 함수의 결과를 설명하는 익명 복합 유형의 열 이름이 변경되기 때문입니다. 이러한 제한 사항은 함수의 기존 호출이 교체 될 때 작동을 중지하지 않도록하기 위해 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="80773f67cc3b08f5dcb6c36638c7da08b5a16582" translate="yes" xml:space="preserve">
          <source>When requesting synchronous replication, each commit of a write transaction will wait until confirmation is received that the commit has been written to the write-ahead log on disk of both the primary and standby server. The only possibility that data can be lost is if both the primary and the standby suffer crashes at the same time. This can provide a much higher level of durability, though only if the sysadmin is cautious about the placement and management of the two servers. Waiting for confirmation increases the user's confidence that the changes will not be lost in the event of server crashes but it also necessarily increases the response time for the requesting transaction. The minimum wait time is the round-trip time between primary to standby.</source>
          <target state="translated">동기식 복제를 요청할 때 쓰기 트랜잭션의 각 커밋은 커밋이 기본 및 대기 서버의 디스크의 미리 쓰기 로그에 기록되었다는 확인이 수신 될 때까지 기다립니다. 기본 및 대기가 동시에 충돌하는 경우 데이터가 유실 될 수있는 유일한 가능성입니다. 이것은 sysadmin이 두 서버의 배치 및 관리에 대해 신중한 경우에만 훨씬 높은 수준의 내구성을 제공 할 수 있습니다. 확인 대기는 서버 충돌시 변경 사항이 손실되지 않는다는 사용자의 확신을 높이지만 요청 트랜잭션에 대한 응답 시간을 늘릴 수도 있습니다. 최소 대기 시간은 기본에서 대기 사이의 왕복 시간입니다.</target>
        </trans-unit>
        <trans-unit id="7cbfd2d18fb6178afa3088b0725b2bc3fcdf04fe" translate="yes" xml:space="preserve">
          <source>When restoring data to a pre-existing table and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_restore emits commands to disable triggers on user tables before inserting the data, then emits commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">기존 테이블로 데이터를 복원하고 &lt;code&gt;--disable-triggers&lt;/code&gt; 옵션을 사용하는 경우 pg_restore는 데이터를 삽입하기 전에 사용자 테이블에서 트리거를 비활성화하는 명령을 생성 한 다음 데이터가 삽입 된 후 다시 활성화하는 명령을 생성합니다. 중간에 복원이 중지되면 시스템 카탈로그가 잘못된 상태로 남아있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ade7c8c975218ba23dcef154671330d11fa5728d" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">역할 멤버 자격을 취소 할 때 &lt;code&gt;GRANT OPTION&lt;/code&gt; 을 &lt;code&gt;ADMIN OPTION&lt;/code&gt; 이라고 하지만 동작은 비슷합니다. 이 명령 형식에서는 노이즈 단어 &lt;code&gt;GROUP&lt;/code&gt; 이 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f68adac31376cf57c26d631be30fdfc9650022d2" translate="yes" xml:space="preserve">
          <source>When revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect.</source>
          <target state="translated">테이블에 대한 권한을 취소하면 해당 열 권한 (있는 경우)도 테이블의 각 열에 대해 자동으로 취소됩니다. 반면, 역할에 테이블에 대한 권한이 부여 된 경우 개별 열에서 동일한 권한을 취소해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="300dad807edac8d993f28c0997a914c75b99f4bc" translate="yes" xml:space="preserve">
          <source>When rounding values, the &lt;code&gt;numeric&lt;/code&gt; type rounds ties away from zero, while (on most machines) the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; types round ties to the nearest even number. For example:</source>
          <target state="translated">값을 반올림 할 때 &lt;code&gt;numeric&lt;/code&gt; 유형은 0에서 멀어 지도록 반올림하지만 &lt;code&gt;real&lt;/code&gt; 및 &lt;code&gt;double precision&lt;/code&gt; 유형은 가장 가까운 짝수로 반올림합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f76f7c7b77ca49ded558a0639a8d27cc09a3811" translate="yes" xml:space="preserve">
          <source>When row security is enabled on a table (with &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt;), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as &lt;code&gt;TRUNCATE&lt;/code&gt; and &lt;code&gt;REFERENCES&lt;/code&gt;, are not subject to row security.</source>
          <target state="translated">테이블에서 행 보안이 사용 가능한 경우 ( &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY 사용&lt;/a&gt; ) 행 보안 정책에 의해 행 선택 또는 행 수정을 위해 테이블에 대한 모든 일반 액세스가 허용되어야합니다. 그러나 테이블 소유자는 일반적으로 행 보안 정책의 적용을받지 않습니다. 테이블에 대한 정책이 없으면 기본 거부 정책이 사용되므로 행이 표시되지 않거나 수정할 수 없습니다. &lt;code&gt;TRUNCATE&lt;/code&gt; 및 &lt;code&gt;REFERENCES&lt;/code&gt; 와 같이 전체 테이블에 적용되는 조작 에는 행 보안이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="226f5e12ea7fb1c629a76bb1b3cc1943cd4502fc" translate="yes" xml:space="preserve">
          <source>When running a long test on hardware that can handle a lot of transactions, the log files can become very large. The &lt;code&gt;--sampling-rate&lt;/code&gt; option can be used to log only a random sample of transactions.</source>
          <target state="translated">많은 트랜잭션을 처리 할 수있는 하드웨어에서 장기간 테스트를 실행하면 로그 파일이 매우 커질 수 있습니다. &lt;code&gt;--sampling-rate&lt;/code&gt; 옵션 거래의 무작위 표본을 기록하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4051fc47591e058546d74bee2aa79ca3ea360af8" translate="yes" xml:space="preserve">
          <source>When running a standby server, you must set this parameter to the same or higher value than on the master server. Otherwise, queries will not be allowed in the standby server.</source>
          <target state="translated">대기 서버를 실행할 때이 매개 변수를 마스터 서버와 같거나 더 높은 값으로 설정해야합니다. 그렇지 않으면 대기 서버에서 조회가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0becdbc99cfe7674fb7d475f00ec87ca3a5a28cc" translate="yes" xml:space="preserve">
          <source>When running at the &lt;code&gt;serializable&lt;/code&gt; isolation level, a deferrable read-only SQL transaction may be delayed before it is allowed to proceed. However, once it begins executing it does not incur any of the overhead required to ensure serializability; so serialization code will have no reason to force it to abort because of concurrent updates, making this option suitable for long-running read-only transactions.</source>
          <target state="translated">&lt;code&gt;serializable&lt;/code&gt; 격리 레벨 에서 실행될 때 지연 가능한 읽기 전용 SQL 트랜잭션이 진행되기 전에 지연 될 수 있습니다. 그러나 일단 실행이 시작되면 직렬화 가능성을 보장하는 데 필요한 오버 헤드가 발생하지 않습니다. 따라서 직렬화 코드는 동시 업데이트로 인해 강제로 중단 될 이유가 없으므로이 옵션은 장기 실행 읽기 전용 트랜잭션에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d1a67057ea54f0f16f47cefbf38d78344e7ecca6" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;on&lt;/code&gt;, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to &lt;code&gt;interactive&lt;/code&gt;, such errors are only ignored in interactive sessions, and not when reading script files. When set to &lt;code&gt;off&lt;/code&gt; (the default), a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit &lt;code&gt;SAVEPOINT&lt;/code&gt; for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 으로 설정되면 트랜잭션 블록의 명령문이 오류를 생성하면 오류가 무시되고 트랜잭션이 계속됩니다. &lt;code&gt;interactive&lt;/code&gt; 로 설정하면 이러한 오류는 스크립트 파일을 읽을 때가 아니라 대화식 세션에서만 무시됩니다. &lt;code&gt;off&lt;/code&gt; (기본값)로 설정 하면 오류를 생성하는 트랜잭션 블록의 명령문이 전체 트랜잭션을 중단합니다. 오류 롤백 모드 는 트랜잭션 블록에있는 각 명령 바로 전에 암시 적 &lt;code&gt;SAVEPOINT&lt;/code&gt; 를 발행 한 다음 명령이 실패하면 저장 점으로 롤백하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="43e9cba78fc8dadeb25eba89d19fc5d8c6ee61b8" translate="yes" xml:space="preserve">
          <source>When set to off, which is the default, PostgreSQL will raise a PANIC-level error on failure to flush modified data files to the file system. This causes the database server to crash. This parameter can only be set at server start.</source>
          <target state="translated">기본값 인 off로 설정하면 PostgreSQL은 수정 된 데이터 파일을 파일 시스템으로 플러시하지 못할 때 PANIC 수준 오류를 발생시킵니다. 이로 인해 데이터베이스 서버가 중단됩니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbaca794cc78ed3c2b124781f712501c0ff4934" translate="yes" xml:space="preserve">
          <source>When set to on, which is the default, PostgreSQL will automatically reinitialize after a backend crash. Leaving this value set to on is normally the best way to maximize the availability of the database. However, in some circumstances, such as when PostgreSQL is being invoked by clusterware, it may be useful to disable the restart so that the clusterware can gain control and take any actions it deems appropriate.</source>
          <target state="translated">기본값 인 on으로 설정하면 PostgreSQL은 백엔드 충돌 후 자동으로 다시 초기화됩니다. 이 값을 설정 한 상태로 두는 것이 일반적으로 데이터베이스의 가용성을 최대화하는 가장 좋은 방법입니다. 그러나 PostgreSQL이 클러스터웨어에 의해 호출되는 경우와 같은 일부 상황에서는 클러스터웨어가 제어를 얻고 적절한 것으로 간주되는 조치를 취할 수 있도록 재시작을 비활성화하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b55871d6d7b3f171d441751dee834b0868dec6" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;debug_pretty_print&lt;/code&gt; indents the messages produced by &lt;code&gt;debug_print_parse&lt;/code&gt;, &lt;code&gt;debug_print_rewritten&lt;/code&gt;, or &lt;code&gt;debug_print_plan&lt;/code&gt;. This results in more readable but much longer output than the &amp;ldquo;compact&amp;rdquo; format used when it is off. It is on by default.</source>
          <target state="translated">설정되면 &lt;code&gt;debug_pretty_print&lt;/code&gt; 는 &lt;code&gt;debug_print_parse&lt;/code&gt; , &lt;code&gt;debug_print_rewritten&lt;/code&gt; 또는 &lt;code&gt;debug_print_plan&lt;/code&gt; 에 의해 생성 된 메시지를 들여 씁니다 . 따라서 꺼져있을 때 사용되는 &quot;컴팩트&quot;형식보다 더 읽기 쉽고 출력이 훨씬 길어집니다. 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9655c6cce4ab0fb89202aa42165255e7c2310c07" translate="yes" xml:space="preserve">
          <source>When setting any of these parameters, a relative path will be interpreted with respect to the directory in which &lt;code&gt;postgres&lt;/code&gt; is started.</source>
          <target state="translated">이러한 매개 변수를 설정하면 &lt;code&gt;postgres&lt;/code&gt; 가 시작된 디렉토리와 관련하여 상대 경로가 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5cba5ccebd44827dbe97e5c58205ecd19cd5549" translate="yes" xml:space="preserve">
          <source>When several data types share near-identical sorting semantics, their operator classes can be grouped into an operator family. Doing so is advantageous because it allows the planner to make deductions about cross-type comparisons. Each operator class within the family should contain the single-type operators (and associated support functions) for its input data type, while cross-type comparison operators and support functions are &amp;ldquo;loose&amp;rdquo; in the family. It is recommendable that a complete set of cross-type operators be included in the family, thus ensuring that the planner can represent any comparison conditions that it deduces from transitivity.</source>
          <target state="translated">여러 데이터 유형이 거의 동일한 정렬 의미를 공유하는 경우 해당 연산자 클래스를 연산자 제품군으로 그룹화 할 수 있습니다. 그렇게하면 플래너가 교차 유형 비교에 대해 추론 할 수 있기 때문에 유리합니다. 제품군 내의 각 연산자 클래스에는 입력 데이터 유형에 대한 단일 유형 연산자 (및 관련 지원 기능)가 포함되어야하며, 교차 유형 비교 연산자 및 지원 기능은 제품군에서 &quot;느슨합니다&quot;. 전체 교차 유형 연산자 세트를 제품군에 포함시키는 것이 좋습니다. 따라서 플래너는 전이성에서 추론하는 비교 조건을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb221d1e490779006a131832600e7b4ca11a22c2" translate="yes" xml:space="preserve">
          <source>When showing progress (option &lt;code&gt;-P&lt;/code&gt;), use a timestamp (Unix epoch) instead of the number of seconds since the beginning of the run. The unit is in seconds, with millisecond precision after the dot. This helps compare logs generated by various tools.</source>
          <target state="translated">진행률을 표시 할 때 (옵션 &lt;code&gt;-P&lt;/code&gt; ), 실행 시작 이후 시간 (초) 대신 시간 소인 (Unix epoch)을 사용하십시오. 단위는 초 단위이며 도트 뒤에 밀리 초 단위로 표시됩니다. 이를 통해 다양한 도구로 생성 된 로그를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc026cecf0c9d705d368f497265f6e7182739df8" translate="yes" xml:space="preserve">
          <source>When sorting &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; data types, IPv4 addresses will always sort before IPv6 addresses, including IPv4 addresses encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::ffff:10.4.3.2.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 또는 &lt;code&gt;cidr&lt;/code&gt; 데이터 유형을 정렬 할 때 IPv4 주소는 :: 10.2.3.4 또는 :: ffff : 10.4.3.2와 같이 IPv6 주소에 캡슐화되거나 매핑 된 IPv4 주소를 포함하여 IPv6 주소보다 항상 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="00112c1a0dfb2756ee57aac0f953ab1b28e8aa6b" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">지정된 경우, 대응하는 위임 &lt;code&gt;index_column_name&lt;/code&gt; 또는 &lt;code&gt;index_expression&lt;/code&gt; 을 위해 특정 정렬을 사용 추론 중에 일치한다. 데이터 정렬은 일반적으로 제약 조건 위반이 발생하는지 여부에 영향을 미치지 않으므로 일반적으로 생략됩니다. &lt;code&gt;CREATE INDEX&lt;/code&gt; 형식을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="49ab9aed56a17743958b35c4487c001e52ad9448" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use particular operator class in order to be matched during inference. Typically this is omitted, as the &lt;em&gt;equality&lt;/em&gt; semantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">지정된 경우, 대응하는 위임 &lt;code&gt;index_column_name&lt;/code&gt; 또는 &lt;code&gt;index_expression&lt;/code&gt; 을 위해 특별한 연산자 클래스를 사용하여 추론 중에 일치한다. 일반적으로 &lt;em&gt;항등&lt;/em&gt; 시맨틱은 유형의 연산자 클래스에서 동일하거나 정의 된 고유 색인에 적절한 항등 정의가 있다고 신뢰하기에 충분하므로 일반적으로 생략됩니다 . &lt;code&gt;CREATE INDEX&lt;/code&gt; 형식을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="f47b14844e6f65e1969fe664f76645a83ada8978" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;program&lt;/code&gt; option, keep in mind that the option string is executed by the shell. If you need to pass any arguments to the command that come from an untrusted source, you must be careful to strip or escape any characters that might have special meaning to the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">&lt;code&gt;program&lt;/code&gt; 옵션을 지정할 때 옵션 문자열은 쉘에 의해 실행됩니다. 신뢰할 수없는 소스에서 온 명령에 인수를 전달해야하는 경우 쉘에 특별한 의미가있는 문자를 제거하거나 이스케이프해야합니다. 보안상의 이유로 고정 명령 문자열을 사용하거나 사용자 입력을 전달하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a86f4916e3e42d9bf0f446f6ed8f6c9365f0b9b8" translate="yes" xml:space="preserve">
          <source>When starting a client session via libpq, parameter settings can be specified using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable. Settings established in this way constitute defaults for the life of the session, but do not affect other sessions. For historical reasons, the format of &lt;code&gt;PGOPTIONS&lt;/code&gt; is similar to that used when launching the &lt;code&gt;postgres&lt;/code&gt; command; specifically, the &lt;code&gt;-c&lt;/code&gt; flag must be specified. For example,</source>
          <target state="translated">libpq를 통해 클라이언트 세션을 시작할 때 &lt;code&gt;PGOPTIONS&lt;/code&gt; 환경 변수를 사용하여 매개 변수 설정을 지정할 수 있습니다 . 이러한 방식으로 설정된 설정은 세션 수명 동안 기본값을 구성하지만 다른 세션에는 영향을 미치지 않습니다. 역사적 이유로 &lt;code&gt;PGOPTIONS&lt;/code&gt; 의 형식은 &lt;code&gt;postgres&lt;/code&gt; 명령을 시작할 때 사용 된 형식 과 유사합니다 . 특히, &lt;code&gt;-c&lt;/code&gt; 플래그를 지정해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="80810b3a36d5394cd36078211fe98f572205f903" translate="yes" xml:space="preserve">
          <source>When suitable, query results can be shown in a crosstab representation with the &lt;code&gt;\crosstabview&lt;/code&gt; command:</source>
          <target state="translated">적절한 경우 쿼리 결과는 &lt;code&gt;\crosstabview&lt;/code&gt; 명령을 사용하여 크로스 탭 표현으로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a46f34ffb8c110010cfd3fe050b49b5689c1e534" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, it is the user's responsibility to unpack each tar file before starting the PostgreSQL server. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar 형식 모드를 사용하는 경우 PostgreSQL 서버를 시작하기 전에 각 tar 파일의 압축을 풀어야합니다. 추가 테이블 스페이스가있는 경우 해당 테이블 스페이스의 tar 파일을 올바른 위치에 압축 해제해야합니다. 이 경우, 해당 테이블 공간에 대한 기호 링크 는 &lt;code&gt;base.tar&lt;/code&gt; 파일에 포함 된 &lt;code&gt;tablespace_map&lt;/code&gt; 파일 의 내용에 따라 서버에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="34c7d99e4e21933c48e46c135fcf1d89d1aca09e" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">tar 형식 모드를 사용하는 경우 미리 쓰기 로그 파일은 &lt;code&gt;pg_wal.tar&lt;/code&gt; 라는 별도의 파일에 기록됩니다 (서버가 10보다 이전 버전 인 경우 파일 이름은 &lt;code&gt;pg_xlog.tar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13bf3c4060b6a548c1c5420c5acc0dd3edcdfdfa" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar 형식 모드를 사용하면 미리 쓰기 로그 파일이 &lt;code&gt;base.tar&lt;/code&gt; 파일에 기록 됩니다.</target>
        </trans-unit>
        <trans-unit id="f11ae7cfc9d8e7c9709340ffb2024d1b68d62efb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; parameter is set to true on a standby server, it will begin accepting connections once the recovery has brought the system to a consistent state. All such connections are strictly read-only; not even temporary tables may be written.</source>
          <target state="translated">대기 서버 에서 &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; 매개 변수가 true로 설정되면 복구가 시스템을 일관된 상태로 만들면 연결을 수락하기 시작합니다. 이러한 연결은 모두 읽기 전용입니다. 임시 테이블조차 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7959e96ecaba15e9d39e3fc41cafc94b8dcfae7f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CONSTRAINT&lt;/code&gt; option is specified, this command creates a &lt;em&gt;constraint trigger&lt;/em&gt;. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;. Constraint triggers must be &lt;code&gt;AFTER ROW&lt;/code&gt; triggers on plain tables (not foreign tables). They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be &lt;em&gt;deferred&lt;/em&gt;. A pending deferred-trigger firing can also be forced to happen immediately by using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</source>
          <target state="translated">때 &lt;code&gt;CONSTRAINT&lt;/code&gt; 옵션을 지정,이 명령은 생성 &lt;em&gt;제약 조건 트리거를&lt;/em&gt; . 이는 &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS를&lt;/a&gt; 사용하여 트리거 발생 타이밍을 조정할 수 있다는 점을 제외하면 일반 트리거와 동일합니다 . 제한 조건 트리거는 외부 테이블이 아닌 일반 테이블에서 &lt;code&gt;AFTER ROW&lt;/code&gt; 트리거 여야합니다 . 트리거 이벤트를 발생시키는 명령문의 끝 또는 포함 트랜잭션의 끝에서 실행될 수 있습니다. 후자의 경우에는 &lt;em&gt;연기&lt;/em&gt; 된다고한다 . &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 를 사용하여 보류중인 지연 트리거 발생을 즉시 강제 할 수도 있습니다 . 구속 조건 트리거는 구현 한 구속 조건을 위반할 때 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="df5c7d4a7ad0b452626a13ac455de82c0906adea" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;SELECT&lt;/code&gt; is one arm of a &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) construct, or when it appears within &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, this rule is not applied since rules given in preceding sections take precedence. The type of an unspecified-type literal can be taken from the other &lt;code&gt;UNION&lt;/code&gt; arm in the first case, or from the destination column in the second case.</source>
          <target state="translated">경우 &lt;code&gt;SELECT&lt;/code&gt; 는 하나 개의 암이다 &lt;code&gt;UNION&lt;/code&gt; (또는 &lt;code&gt;INTERSECT&lt;/code&gt; 또는 &lt;code&gt;EXCEPT&lt;/code&gt; ) 구조, 또는 그 안에 나타날 때 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; ,이 규칙은 섹션 우선 이전에 주어진 규칙 때문에 적용되지 않는다. 지정되지 않은 유형 리터럴의 유형 은 첫 번째 경우 의 다른 &lt;code&gt;UNION&lt;/code&gt; 암 또는 두 번째 경우의 대상 열에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f2ffb48d56de0e4aaa18bb9efa3e04da4e9e279" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;WHERE&lt;/code&gt; clause is present, a &lt;em&gt;partial index&lt;/em&gt; is created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to use &lt;code&gt;WHERE&lt;/code&gt; with &lt;code&gt;UNIQUE&lt;/code&gt; to enforce uniqueness over a subset of a table. See &lt;a href=&quot;indexes-partial&quot;&gt;Section 11.8&lt;/a&gt; for more discussion.</source>
          <target state="translated">때 &lt;code&gt;WHERE&lt;/code&gt; 의 조항이 존재하는 &lt;em&gt;부분의 인덱스가&lt;/em&gt; 생성된다. 부분 인덱스는 테이블의 일부에 대한 항목, 일반적으로 나머지 테이블보다 인덱싱에 더 유용한 항목을 포함하는 인덱스입니다. 예를 들어, 청구되지 않은 주문이 총 테이블의 작은 부분을 차지하지만 자주 사용되는 섹션 인 청구 및 미 청구 주문이 모두 포함 된 테이블이있는 경우 해당 부분에 대해서만 색인을 작성하여 성능을 향상시킬 수 있습니다. 또 다른 가능한 응용 프로그램은 &lt;code&gt;WHERE&lt;/code&gt; 를 &lt;code&gt;UNIQUE&lt;/code&gt; 와 함께 사용 하여 테이블의 하위 집합에 고유성을 적용하는 것입니다. 자세한 내용 &lt;a href=&quot;indexes-partial&quot;&gt;은 11.8 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c185ac9497904ca6d14d82c8dc0a0e1690d4901" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ampredlocks&lt;/code&gt; flag is not set, any scan using that index access method within a serializable transaction will acquire a nonblocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations.</source>
          <target state="translated">때 &lt;code&gt;ampredlocks&lt;/code&gt; 의 플래그는 전체 인덱스에 블로킹 술어 잠금을 획득하는 직렬화 가능 트랜잭션 내에서 해당 인덱스 액세스 방법을 사용하여 임의의 스캔 설정되어 있지 않습니다. 이렇게하면 동시 직렬화 가능 트랜잭션에 의해 해당 인덱스에 튜플을 삽입 할 때 읽기 / 쓰기 충돌이 발생합니다. 일련의 동시 직렬화 가능 트랜잭션 세트에서 특정 패턴의 읽기 / 쓰기 충돌이 감지되면 해당 트랜잭션 중 하나가 취소되어 데이터 무결성을 보호 할 수 있습니다. 플래그가 설정되면 이는 인덱스 액세스 방법이보다 세분화 된 술어 잠금을 구현하므로 이러한 트랜잭션 취소 빈도를 줄이는 경향이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32c110466857121d054324f74c8a38f9bb5212e4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;border&lt;/code&gt; setting is greater than zero, the &lt;code&gt;linestyle&lt;/code&gt; option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them.</source>
          <target state="translated">때 &lt;code&gt;border&lt;/code&gt; 설정이 0보다 크면 &lt;code&gt;linestyle&lt;/code&gt; 옵션은 경계선이 그려있는 문자를 결정합니다. 일반 ASCII 문자는 모든 곳에서 작동하지만 유니 코드 문자는이를 인식하는 디스플레이에서 더보기 좋습니다.</target>
        </trans-unit>
        <trans-unit id="00d6a0dfb20c2e25ada6bca76d0486b409be8ef1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;off&lt;/code&gt;, the pager program is not used. When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;on&lt;/code&gt;, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The &lt;code&gt;pager&lt;/code&gt; option can also be set to &lt;code&gt;always&lt;/code&gt;, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. &lt;code&gt;\pset pager&lt;/code&gt; without a &lt;code&gt;value&lt;/code&gt; toggles pager use on and off.</source>
          <target state="translated">때 &lt;code&gt;pager&lt;/code&gt; 옵션은 &lt;code&gt;off&lt;/code&gt; , 페이저 프로그램은 사용되지 않습니다. &lt;code&gt;pager&lt;/code&gt; 옵션이 &lt;code&gt;on&lt;/code&gt; 있으면 호출기가 적절한 경우, 즉 출력이 터미널에 있고 화면에 맞지 않을 때 사용됩니다. &lt;code&gt;pager&lt;/code&gt; 옵션은 설정할 수 있습니다 &lt;code&gt;always&lt;/code&gt; 관계없이 화면에 맞는지의 모든 터미널 출력에 사용되는 호출기가 발생한다. &lt;code&gt;value&lt;/code&gt; 없는 &lt;code&gt;\pset pager&lt;/code&gt; 는 호출기 사용을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="81a140433737ca4c23a575624ce695fcc511dede" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_buffercache&lt;/code&gt; view is accessed, internal buffer manager locks are taken for long enough to copy all the buffer state data that the view will display. This ensures that the view produces a consistent set of results, while not blocking normal buffer activity longer than necessary. Nonetheless there could be some impact on database performance if this view is read often.</source>
          <target state="translated">때 &lt;code&gt;pg_buffercache&lt;/code&gt; 된 뷰를 액세스하고, 내부 버퍼 관리자 잠금 뷰가 표시하는 모든 버퍼 상태 데이터를 복사하기 위해 충분히 오래 소요된다. 이렇게하면 뷰가 일관된 결과 세트를 생성하는 동시에 정상 버퍼 활동을 필요 이상으로 차단하지 않습니다. 그럼에도 불구하고이 뷰를 자주 읽으면 데이터베이스 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd60a2856753e705f8fe475e92d422e142a5a733" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_prepared_xacts&lt;/code&gt; view is accessed, the internal transaction manager data structures are momentarily locked, and a copy is made for the view to display. This ensures that the view produces a consistent set of results, while not blocking normal operations longer than necessary. Nonetheless there could be some impact on database performance if this view is frequently accessed.</source>
          <target state="translated">때 &lt;code&gt;pg_prepared_xacts&lt;/code&gt; 의 뷰를 액세스 내부 트랜잭션 관리 데이터 구조를 잠깐 고정되며, 복사본 디스플레이 뷰에 대해 이루어진다. 이렇게하면 뷰가 일관된 결과 집합을 생성하는 동시에 정상 작업을 필요 이상으로 차단하지 않습니다. 그럼에도 불구하고이 뷰에 자주 액세스하면 데이터베이스 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ee8be71b9dbdb6fe9839b8abd30a5d0ca45b722" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;text&lt;/code&gt; format is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null. &lt;code&gt;COPY FROM&lt;/code&gt; will raise an error if any line of the input file contains more or fewer columns than are expected.</source>
          <target state="translated">때 &lt;code&gt;text&lt;/code&gt; 형식을 사용하는 데이터를 읽거나 테이블 행 당 하나의 선으로 텍스트 파일입니다 작성. 행의 열은 구분 문자로 구분됩니다. 열 값 자체는 각 속성 데이터 유형의 출력 함수에 의해 생성되거나 입력 함수에 허용되는 문자열입니다. 널이 아닌 열 대신 지정된 널 문자열이 사용됩니다. 입력 파일의 행에 예상보다 많은 열이 포함되어 있으면 &lt;code&gt;COPY FROM&lt;/code&gt; 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1c4c47cbbcff114da7b14a508ba7d65a0b19eac7" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; argument to verification functions is &lt;code&gt;true&lt;/code&gt;, an additional phase of verification is performed against the table associated with the target index relation. This consists of a &amp;ldquo;dummy&amp;rdquo;&lt;code&gt;CREATE INDEX&lt;/code&gt; operation, which checks for the presence of all hypothetical new index tuples against a temporary, in-memory summarizing structure (this is built when needed during the basic first phase of verification). The summarizing structure &amp;ldquo;fingerprints&amp;rdquo; every tuple found within the target index. The high level principle behind &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is that a new index that is equivalent to the existing, target index must only have entries that can be found in the existing structure.</source>
          <target state="translated">검증 함수에 대한 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우 대상 인덱스 관계와 연관된 테이블에 대해 추가 검증 단계가 수행됩니다. 이것은 &quot;더미&quot; &lt;code&gt;CREATE INDEX&lt;/code&gt; 연산으로 구성되며 , 임시 인 메모리 요약 구조 (기본 검증 단계에서 필요할 때 작성 됨)에 대해 모든 가상의 새 인덱스 튜플이 있는지 확인합니다. 요약 구조는 대상 인덱스에서 찾은 모든 튜플을 &quot;지문&quot;합니다. &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 인덱스 &lt;em&gt;화&lt;/em&gt; 검증의 기본 원리 는 기존의 대상 인덱스와 동일한 새 인덱스가 기존 구조에서 찾을 수있는 항목 만 가져야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4898e6eb712c6c928410a4432225d77730464bb" translate="yes" xml:space="preserve">
          <source>When the backup is in tar mode, and the directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar file will be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">백업이 tar 모드이고 디렉토리가 &lt;code&gt;-&lt;/code&gt; (대시) 로 지정 되면 tar 파일이 &lt;code&gt;stdout&lt;/code&gt; 에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bf62b247e8d0c8ddb36cb4a11374b1155c5b650" translate="yes" xml:space="preserve">
          <source>When the client application uses the &amp;ldquo;extended query&amp;rdquo; protocol to issue a &lt;code&gt;FETCH&lt;/code&gt; command, the Bind protocol message specifies whether data is to be retrieved in text or binary format. This choice overrides the way that the cursor is defined. The concept of a binary cursor as such is thus obsolete when using extended query protocol &amp;mdash; any cursor can be treated as either text or binary.</source>
          <target state="translated">클라이언트 응용 프로그램이 &quot;확장 조회&quot;프로토콜을 사용하여 &lt;code&gt;FETCH&lt;/code&gt; 명령 을 발행 할 때 바인드 프로토콜 메시지는 데이터를 텍스트 또는 2 진 형식으로 검색할지 여부를 지정합니다. 이 선택은 커서가 정의 된 방식을 대체합니다. 따라서 이진 커서 개념은 확장 쿼리 프로토콜을 사용할 때는 더 이상 사용되지 않습니다. 모든 커서는 텍스트 또는 이진으로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef2bc6393c8c4a9107edf2302ecf0f071877452" translate="yes" xml:space="preserve">
          <source>When the connection to the server is lost, do not retry in a loop, just exit.</source>
          <target state="translated">서버와의 연결이 끊어지면 루프에서 다시 시도하지 말고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="c8229aa8ad36a0b0c5e6146511e976844f24d945" translate="yes" xml:space="preserve">
          <source>When the database generates SQL, force all identifiers to be quoted, even if they are not (currently) keywords. This will affect the output of &lt;code&gt;EXPLAIN&lt;/code&gt; as well as the results of functions like &lt;code&gt;pg_get_viewdef&lt;/code&gt;. See also the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option of &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; and &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;.</source>
          <target state="translated">데이터베이스가 SQL을 생성 할 때 (현재) 키워드가 아니더라도 모든 식별자를 인용하도록합니다. 이것은 &lt;code&gt;pg_get_viewdef&lt;/code&gt; 와 같은 함수의 결과뿐만 아니라 &lt;code&gt;EXPLAIN&lt;/code&gt; 의 출력에도 영향을 미칩니다 . &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; 및 &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt; 의 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea2bc8f44657321dd80c423b48806c42005dbc7a" translate="yes" xml:space="preserve">
          <source>When the database system has to perform an ordering or a character classification, it uses the collation of the input expression. This happens, for example, with &lt;code&gt;ORDER BY&lt;/code&gt; clauses and function or operator calls such as &lt;code&gt;&amp;lt;&lt;/code&gt;. The collation to apply for an &lt;code&gt;ORDER BY&lt;/code&gt; clause is simply the collation of the sort key. The collation to apply for a function or operator call is derived from the arguments, as described below. In addition to comparison operators, collations are taken into account by functions that convert between lower and upper case letters, such as &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt;; by pattern matching operators; and by &lt;code&gt;to_char&lt;/code&gt; and related functions.</source>
          <target state="translated">데이터베이스 시스템은 순서화 또는 문자 분류를 수행해야하는 경우 입력 표현식의 데이터 정렬을 사용합니다. 예를 들어 &lt;code&gt;ORDER BY&lt;/code&gt; 절과 함수 또는 연산자 호출 ( &lt;code&gt;&amp;lt;&lt;/code&gt; 등)을 사용하면 이러한 상황이 발생합니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 절 에 적용 할 데이터 정렬 은 단순히 정렬 키의 데이터 정렬입니다. 함수 또는 연산자 호출에 적용 할 데이터 정렬은 아래 설명 된대로 인수에서 파생됩니다. 비교 연산자 외에도 &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; 및 &lt;code&gt;initcap&lt;/code&gt; 과 같이 소문자와 대문자를 변환하는 함수에 의해 데이터 정렬이 고려됩니다 . 패턴 매칭 연산자에 의해; &lt;code&gt;to_char&lt;/code&gt; 및 관련 함수에 의해 .</target>
        </trans-unit>
        <trans-unit id="cf20c03f9a438d0f6675629396820f040d752814" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">기본값이 정확하지 않은 경우 환경 변수 &lt;code&gt;PGDATABASE&lt;/code&gt; , &lt;code&gt;PGHOST&lt;/code&gt; , &lt;code&gt;PGPORT&lt;/code&gt; 및 / 또는 &lt;code&gt;PGUSER&lt;/code&gt; 를 적절한 값 으로 설정하여 입력을 절약 할 수 있습니다 . (추가 환경 변수에 대해서는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;33.14 절을&lt;/a&gt; 참조하십시오 .) 정기적으로 암호를 입력하지 않도록 &lt;code&gt;~/.pgpass&lt;/code&gt; 파일을 사용 하는 것이 편리 합니다. 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;33.15 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58644d348761a861122023ab84e086a5de61b1bd" translate="yes" xml:space="preserve">
          <source>When the input value is +/-Infinity, &lt;code&gt;extract&lt;/code&gt; returns +/-Infinity for monotonically-increasing fields (&lt;code&gt;epoch&lt;/code&gt;, &lt;code&gt;julian&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;isoyear&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, and &lt;code&gt;millennium&lt;/code&gt;). For other fields, NULL is returned. PostgreSQL versions before 9.6 returned zero for all cases of infinite input.</source>
          <target state="translated">입력 값이 +/- Infinity 인 경우 &lt;code&gt;extract&lt;/code&gt; 는 단조 증가하는 필드 ( &lt;code&gt;epoch&lt;/code&gt; , &lt;code&gt;julian&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;isoyear&lt;/code&gt; , &lt;code&gt;decade&lt;/code&gt; , &lt;code&gt;century&lt;/code&gt; 및 &lt;code&gt;millennium&lt;/code&gt; )에 대해 +/- Infinity를 반환합니다 . 다른 필드의 경우 NULL이 반환됩니다. 9.6 이전의 PostgreSQL 버전은 모든 무한 입력의 경우 0을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="ca7b95a2bfd76e66a3b9a3c283932ae7ceb9d1f3" translate="yes" xml:space="preserve">
          <source>When the input value is of type &lt;code&gt;timestamp with time zone&lt;/code&gt;, the truncation is performed with respect to a particular time zone; for example, truncation to &lt;code&gt;day&lt;/code&gt; produces a value that is midnight in that zone. By default, truncation is done with respect to the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, but the optional &lt;code&gt;time_zone&lt;/code&gt; argument can be provided to specify a different time zone. The time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">입력 값이 &lt;code&gt;timestamp with time zone&lt;/code&gt; 가있는 타임 스탬프 유형 인 경우 절단은 특정 시간대에 대해 수행됩니다. 예를 들어, &lt;code&gt;day&lt;/code&gt; 자르기 는 해당 영역의 자정 값을 생성합니다. 기본적으로 현재 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;시간대&lt;/a&gt; 설정 과 관련하여 잘림이 수행 되지만 다른 시간대를 지정하기 위해 선택적 &lt;code&gt;time_zone&lt;/code&gt; 인수를 제공 할 수 있습니다. 표준 시간대 이름은 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3 절에&lt;/a&gt; 설명 된 방법 중 하나로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb992423a64d9af4e9c24a6d03361c5985029c38" translate="yes" xml:space="preserve">
          <source>When the node at the top of the parallel portion of the plan is &lt;code&gt;Gather Merge&lt;/code&gt; rather than &lt;code&gt;Gather&lt;/code&gt;, it indicates that each process executing the parallel portion of the plan is producing tuples in sorted order, and that the leader is performing an order-preserving merge. In contrast, &lt;code&gt;Gather&lt;/code&gt; reads tuples from the workers in whatever order is convenient, destroying any sort order that may have existed.</source>
          <target state="translated">평면의 평행 부 상단의 노드 인 경우에는 &lt;code&gt;Gather Merge&lt;/code&gt; 보다는 &lt;code&gt;Gather&lt;/code&gt; , 상기 평면의 평행 부분의 실행 각 프로세스 정렬 된 순서 튜플 제조되어, 상기 선두 명령 보존 병합을 수행하고 있음을 나타낸다 . 반대로, &lt;code&gt;Gather&lt;/code&gt; 는 편리한 순서대로 작업자로부터 튜플을 읽으며 존재하는 정렬 순서를 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="3c8d54f7450d49b82cd5a8da77194f4c25e5cdb1" translate="yes" xml:space="preserve">
          <source>When the operating system sends a write request to the storage hardware, there is little it can do to make sure the data has arrived at a truly non-volatile storage area. Rather, it is the administrator's responsibility to make certain that all storage components ensure integrity for both data and file-system metadata. Avoid disk controllers that have non-battery-backed write caches. At the drive level, disable write-back caching if the drive cannot guarantee the data will be written before shutdown. If you use SSDs, be aware that many of these do not honor cache flush commands by default. You can test for reliable I/O subsystem behavior using &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt;&lt;code&gt;diskchecker.pl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">운영 체제가 스토리지 하드웨어에 쓰기 요청을 보낼 때 데이터가 실제로 비 휘발성 스토리지 영역에 도착했는지 확인하는 방법은 거의 없습니다. 오히려 모든 스토리지 구성 요소가 데이터 및 파일 시스템 메타 데이터에 대한 무결성을 보장하도록하는 것은 관리자의 책임입니다. 배터리가 지원되지 않는 쓰기 캐시가있는 디스크 컨트롤러를 피하십시오. 드라이브 수준에서 드라이브가 종료 전에 데이터 쓰기를 보장 할 수없는 경우 후기 입 캐싱을 비활성화하십시오. SSD를 사용하는 경우,이 중 다수는 기본적으로 캐시 플러시 명령을 따르지 않습니다. &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt; &lt;code&gt;diskchecker.pl&lt;/code&gt; 을&lt;/a&gt; 사용하여 안정적인 I / O 하위 시스템 동작을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d33bb04f73c12f42af37757660638f7bf07dd0c" translate="yes" xml:space="preserve">
          <source>When the optimizer determines that parallel query is the fastest execution strategy for a particular query, it will create a query plan which includes a &lt;em&gt;Gather&lt;/em&gt; or &lt;em&gt;Gather Merge&lt;/em&gt; node. Here is a simple example:</source>
          <target state="translated">옵티마이 저가 병렬 쿼리가 특정 쿼리에 대한 가장 빠른 실행 전략이라고 판단하면 &lt;em&gt;수집&lt;/em&gt; 또는 &lt;em&gt;병합 병합&lt;/em&gt; 노드 를 포함하는 쿼리 계획을 생성 합니다. 다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="01b643d7a7954ad91561b8c24a008664f59d15dd" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. The parenthesized syntax was added in PostgreSQL 11; the unparenthesized syntax is deprecated.</source>
          <target state="translated">옵션 목록을 괄호로 묶으면 옵션을 임의의 순서로 작성할 수 있습니다. 괄호로 묶은 구문이 PostgreSQL 11에 추가되었습니다. 괄호로 묶지 않은 구문은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abee5df8a890efa75529bd092cf02d64e5f74e41" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. Without parentheses, options must be specified in exactly the order shown above. The parenthesized syntax was added in PostgreSQL 9.0; the unparenthesized syntax is deprecated.</source>
          <target state="translated">옵션 목록을 괄호로 묶으면 옵션을 임의의 순서로 작성할 수 있습니다. 괄호없이 옵션은 위에 표시된 순서대로 정확하게 지정해야합니다. 괄호로 묶은 구문은 PostgreSQL 9.0에서 추가되었습니다. 괄호로 묶지 않은 구문은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e9dc738f4097cde58c9e8bf1cce2f13a3e0faff" translate="yes" xml:space="preserve">
          <source>When the query executor is running a statement using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, individual operations are timed as well as showing a summary. The overhead of your system can be checked by counting rows with the psql program:</source>
          <target state="translated">쿼리 실행자가 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 를 사용하여 명령문을 실행하는 경우 개별 조작의 시간이 지정되고 요약이 표시됩니다. psql 프로그램으로 행을 계산하여 시스템의 오버 헤드를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4efc71382094156bb1e14ebb8922c4bbfee26e8" translate="yes" xml:space="preserve">
          <source>When the query involves more than two relations, the final result must be built up by a tree of join steps, each with two inputs. The planner examines different possible join sequences to find the cheapest one.</source>
          <target state="translated">쿼리에 두 개 이상의 관계가 포함 된 경우 최종 결과는 각각 두 개의 입력이있는 조인 단계 트리로 구성해야합니다. 플래너는 가능한 다른 조인 시퀀스를 검사하여 가장 저렴한 조인 시퀀스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f91c3e21cf6bd9480dad3eeeece86758f55a90e3" translate="yes" xml:space="preserve">
          <source>When the query involves outer joins, the planner has less freedom than it does for plain (inner) joins. For example, consider:</source>
          <target state="translated">쿼리에 외부 조인이 포함되면 플래너는 일반 (내부) 조인보다 자유도가 떨어집니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="53d57a11c26095ca3bee53a6ad82668d9cd1b948" translate="yes" xml:space="preserve">
          <source>When the replication client of pg_receivewal is configured on the server as a synchronous standby, then using a replication slot will report the flush position to the server, but only when a WAL file is closed. Therefore, that configuration will cause transactions on the primary to wait for a long time and effectively not work satisfactorily. The option &lt;code&gt;--synchronous&lt;/code&gt; (see below) must be specified in addition to make this work correctly.</source>
          <target state="translated">pg_receivewal의 복제 클라이언트가 서버에서 동기 대기로 구성된 경우 복제 슬롯을 사용하면 서버에 플러시 위치가보고되지만 WAL 파일이 닫힐 때만 해당됩니다. 따라서 해당 구성으로 인해 기본의 트랜잭션이 오랫동안 대기하고 효과적으로 작동하지 않습니다. 이 작업을 올바르게 수행하려면 &lt;code&gt;--synchronous&lt;/code&gt; (아래 참조) 옵션을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e97e877617ee50758f9c1ed0038c82401b37ff4" translate="yes" xml:space="preserve">
          <source>When the server finds an entry in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog for the given language name, it will use the catalog data even if the command includes language parameters. This behavior simplifies loading of old dump files, which are likely to contain out-of-date information about language support functions.</source>
          <target state="translated">서버는 주어진 언어 이름 에 대한 &lt;code&gt;pg_pltemplate&lt;/code&gt; 카탈로그 에서 항목을 찾으면 명령에 언어 매개 변수가 포함되어 있어도 카탈로그 데이터를 사용합니다. 이 동작은 언어 지원 기능에 대한 오래된 정보를 포함 할 수있는 이전 덤프 파일의로드를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="5acf91c2009ea693cf720914c5dcc7ec25263a3f" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a walreceiver process in the standby, and a corresponding walsender process in the primary.</source>
          <target state="translated">대기가 시작되고 &lt;code&gt;primary_conninfo&lt;/code&gt; 가 올바르게 설정되면 아카이브에서 사용 가능한 모든 WAL 파일을 재생 한 후 대기가 기본에 연결됩니다. 연결이 성공적으로 완료되면 대기에서 Walreceiver 프로세스가 표시되고 기본에서 해당 Walsender 프로세스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eedf68c3267fbf09aabeff8e3149a2fc6e02e4a5" translate="yes" xml:space="preserve">
          <source>When the system is forced to combine multiple page-level predicate locks into a single relation-level predicate lock because the predicate lock table is short of memory, an increase in the rate of serialization failures may occur. You can avoid this by increasing &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;, &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;, and/or &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt;.</source>
          <target state="translated">술어 잠금 테이블에 메모리가 부족하여 시스템이 여러 페이지 레벨 술어 잠금을 단일 관계 레벨 술어 잠금으로 결합하면 직렬화 실패 비율이 증가 할 수 있습니다. &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt; , &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt; 및 / 또는 &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt; 를 늘려 이를 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e5d69b735badff5a43514c3f20c29f9fa27a5a4" translate="yes" xml:space="preserve">
          <source>When the target server is started for the first time after running pg_rewind, it will go into recovery mode and replay all WAL generated in the source server after the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and configuring suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">pg_rewind를 실행 한 후 대상 서버를 처음 시작하면 복구 모드로 전환되어 분기 지점 이후에 소스 서버에서 생성 된 모든 WAL을 재생합니다. pg_rewind가 실행될 때 소스 서버에서 일부 WAL을 더 이상 사용할 수 없어서 pg_rewind 세션으로 복사 할 수없는 경우 대상 서버가 시작될 때 사용할 수 있어야합니다. 대상 데이터 디렉토리에 &lt;code&gt;recovery.signal&lt;/code&gt; 파일 을 작성하고 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 적절한 &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 를 구성하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="46d8ca3256e28b3a76b80a636c768a65a62af8f1" translate="yes" xml:space="preserve">
          <source>When the token is a number or number field:</source>
          <target state="translated">토큰이 숫자 또는 숫자 필드 인 경우 :</target>
        </trans-unit>
        <trans-unit id="13de437cb552624377cc1efe8012608874203a3b" translate="yes" xml:space="preserve">
          <source>When there are &lt;code&gt;OUT&lt;/code&gt; or &lt;code&gt;INOUT&lt;/code&gt; parameters, the &lt;code&gt;RETURNS&lt;/code&gt; clause can be omitted. If present, it must agree with the result type implied by the output parameters: &lt;code&gt;RECORD&lt;/code&gt; if there are multiple output parameters, or the same type as the single output parameter.</source>
          <target state="translated">있을 때 &lt;code&gt;OUT&lt;/code&gt; 또는 &lt;code&gt;INOUT&lt;/code&gt; 파라미터의 &lt;code&gt;RETURNS&lt;/code&gt; 의 항은 생략 될 수있다. 존재하는 경우 출력 매개 변수가 암시하는 결과 유형과 일치해야합니다. 여러 출력 매개 변수가있는 경우 &lt;code&gt;RECORD&lt;/code&gt; 또는 단일 출력 매개 변수와 동일한 유형.</target>
        </trans-unit>
        <trans-unit id="086da7e4c8252cf99eea2a26d212bfca20a89638" translate="yes" xml:space="preserve">
          <source>When there are no &lt;code&gt;GIN_MAYBE&lt;/code&gt; values in the &lt;code&gt;check&lt;/code&gt; vector, a &lt;code&gt;GIN_MAYBE&lt;/code&gt; return value is the equivalent of setting the &lt;code&gt;recheck&lt;/code&gt; flag in the Boolean &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; 벡터 에 &lt;code&gt;GIN_MAYBE&lt;/code&gt; 값 이없는 경우 &lt;code&gt;GIN_MAYBE&lt;/code&gt; 반환 값은 부울 &lt;code&gt;consistent&lt;/code&gt; 함수 에서 &lt;code&gt;recheck&lt;/code&gt; 플래그 를 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6d0ae32f2046467b15848b335dcbaffbcaf195f8" translate="yes" xml:space="preserve">
          <source>When this command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="translated">이 명령이 사용되면, 위의 SQL 쿼리의 열은 열 이름을 따서 변수에 저장하고, 접두어 번 행을 리턴 할 것으로 예상된다 &lt;code&gt;prefix&lt;/code&gt; 제공된 경우.</target>
        </trans-unit>
        <trans-unit id="d01a63b618f24f934c421a450096ebe3b2d3fb7a" translate="yes" xml:space="preserve">
          <source>When this feature is enabled, freed space at the end of a relation cannot be released to the operating system, since that could remove information needed to detect the &amp;ldquo;snapshot too old&amp;rdquo; condition. All space allocated to a relation remains associated with that relation for reuse only within that relation unless explicitly freed (for example, with &lt;code&gt;VACUUM FULL&lt;/code&gt;).</source>
          <target state="translated">이 기능을 사용하면 관계의 끝에서 사용 가능한 공간을 운영 체제로 해제 할 수 없습니다. 이렇게하면 &quot;스냅 샷이 너무 오래된&quot;상태를 감지하는 데 필요한 정보가 제거 될 수 있습니다. 관계에 할당 된 모든 공간은 명시 적으로 해제되지 않은 경우 (예 : &lt;code&gt;VACUUM FULL&lt;/code&gt; ) 해당 관계 내에서만 재사용하기 위해 해당 관계와 연관된 상태로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="edeb5910da7722ed71fd344bba96eef32a3f6641" translate="yes" xml:space="preserve">
          <source>When this happens, the range will be summarized normally during the next regular vacuum of the table.</source>
          <target state="translated">이 경우, 테이블의 다음 정기 진공 청소 중에 범위가 정상적으로 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="e4570af0f67cc29537d90c659afba5db93e8b7f0" translate="yes" xml:space="preserve">
          <source>When this is enabled, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent.</source>
          <target state="translated">이 기능이 활성화되면 전체 데이터베이스의 크기를 열거하여 백업을 시작한 다음 돌아가서 실제 내용을 보냅니다. 이로 인해 백업 시간이 약간 길어질 수 있으며 특히 첫 번째 데이터가 전송되기까지 시간이 더 걸립니다.</target>
        </trans-unit>
        <trans-unit id="28c1776ab93887297f059584c258d507675ecdfe" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 PostgreSQL은 테이블에서 동시 삽입, 업데이트 또는 삭제를 방지하는 잠금을 수행하지 않고 인덱스를 빌드합니다. 반면 표준 인덱스 빌드는 완료 될 때까지 테이블에 대한 쓰기 (읽지 않지만 읽기)를 잠급니다. 이 옵션을 사용할 때주의해야 할 몇 가지주의 사항이 있습니다 . &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;동시에 색인 작성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="469c5b3c25ebc28298d0a68f767fa4e6b9232f83" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 PostgreSQL은 테이블에서 동시 삽입, 업데이트 또는 삭제를 방지하는 잠금을 수행하지 않고 인덱스를 다시 작성합니다. 반면 표준 인덱스 재 구축은 테이블이 완료 될 때까지 테이블에 대한 쓰기를 잠급니다. 이 옵션을 사용할 때주의해야 할 몇 가지주의 사항이 있습니다 ( &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;동시에 인덱스 다시 작성&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="8c3757e4ca86742c07911d6404be9ee33ce2c815" translate="yes" xml:space="preserve">
          <source>When this option is used, psql will connect to the database &lt;code&gt;postgres&lt;/code&gt;, unless a different database is named on the command line (option &lt;code&gt;-d&lt;/code&gt; or non-option argument, possibly via a service entry, but not via an environment variable).</source>
          <target state="translated">이 옵션을 사용 하면 다른 데이터베이스가 명령 행에 지정되지 않는 한 ( p 옵션은 옵션 &lt;code&gt;-d&lt;/code&gt; 또는 비 옵션 인수, 가능하면 환경 변수가 아닌 서비스 항목을 통해 ) psql은 데이터베이스 &lt;code&gt;postgres&lt;/code&gt; 에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="2bc222201723d0a9f83d166df5e42c7cf99836b6" translate="yes" xml:space="preserve">
          <source>When this option is used, the database named with &lt;code&gt;-d&lt;/code&gt; is used only to issue the initial &lt;code&gt;DROP DATABASE&lt;/code&gt; and &lt;code&gt;CREATE DATABASE&lt;/code&gt; commands. All data is restored into the database name that appears in the archive.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;-d&lt;/code&gt; 로 이름 지정된 데이터베이스 는 초기 &lt;code&gt;DROP DATABASE&lt;/code&gt; 및 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 명령 을 발행하는 데만 사용됩니다 . 모든 데이터는 아카이브에 나타나는 데이터베이스 이름으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="3390cee1b88ac1d254da2a22a816a53421d2e870" translate="yes" xml:space="preserve">
          <source>When this parameter allows it for a particular table, the planner compares query conditions with the table's &lt;code&gt;CHECK&lt;/code&gt; constraints, and omits scanning tables for which the conditions contradict the constraints. For example:</source>
          <target state="translated">이 매개 변수가 특정 테이블에 대해이를 허용하면 플래너는 쿼리 조건을 테이블의 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건과 비교 하고 조건이 제약 조건과 상충되는 스캔 테이블을 생략합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70be33b4f92d88452bcc535d531cf8223b72afbc" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server compresses a full page image written to WAL when &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is on or during a base backup. A compressed page image will be decompressed during WAL replay. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">이 매개 변수가 &lt;code&gt;on&lt;/code&gt; 있으면 PostgreSQL 서버 는 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 가 켜져 있거나 기본 백업 중에 WAL에 기록 된 전체 페이지 이미지를 압축합니다 . 압축 된 페이지 이미지는 WAL 재생 중에 압축 해제됩니다. 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="095a2e6ccc43e3049250993f0343788b4a6a861a" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint, even for non-critical modifications of so-called hint bits.</source>
          <target state="translated">이 매개 변수가 &lt;code&gt;on&lt;/code&gt; 있으면 PostgreSQL 서버는 체크 포인트 후 해당 페이지를 처음 수정하는 동안 (소위 힌트 비트의 중요하지 않은 수정의 경우에도) 각 디스크 페이지의 전체 내용을 WAL에 씁니다.</target>
        </trans-unit>
        <trans-unit id="ff47b09b0654ad59cedec7d15e17e9fba55f3e2b" translate="yes" xml:space="preserve">
          <source>When this parameter is on, &lt;code&gt;sepgsql&lt;/code&gt; functions in permissive mode, even if SELinux in general is working in enforcing mode. This parameter is primarily useful for testing purposes.</source>
          <target state="translated">이 매개 변수가 설정되면 &lt;code&gt;sepgsql&lt;/code&gt; 은 일반적으로 SELinux가 강제 모드에서 작동하더라도 허용 모드에서 작동합니다. 이 매개 변수는 주로 테스트 목적으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b664e492ac1b6b5bd7bf06b57282c7f341a60102" translate="yes" xml:space="preserve">
          <source>When this parameter is on, per-plan-node timing occurs for all statements executed, whether or not they run long enough to actually get logged. This can have an extremely negative impact on performance. Turning off &lt;code&gt;auto_explain.log_timing&lt;/code&gt; ameliorates the performance cost, at the price of obtaining less information.</source>
          <target state="translated">이 매개 변수가 설정되면 실제로 기록 될 정도로 오래 실행되는지 여부에 관계없이 실행 된 모든 명령문에 대해 계획 노드 당 타이밍이 발생합니다. 이는 성능에 매우 부정적인 영향을 줄 수 있습니다. &lt;code&gt;auto_explain.log_timing&lt;/code&gt; 을 끄면 적은 정보를 얻는 대가로 성능 비용이 개선됩니다.</target>
        </trans-unit>
        <trans-unit id="d4e134d46721d701b088fe76d2d53da371f96514" translate="yes" xml:space="preserve">
          <source>When this parameter is on, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint. This is needed because a page write that is in process during an operating system crash might be only partially completed, leading to an on-disk page that contains a mix of old and new data. The row-level change data normally stored in WAL will not be enough to completely restore such a page during post-crash recovery. Storing the full page image guarantees that the page can be correctly restored, but at the price of increasing the amount of data that must be written to WAL. (Because WAL replay always starts from a checkpoint, it is sufficient to do this during the first change of each page after a checkpoint. Therefore, one way to reduce the cost of full-page writes is to increase the checkpoint interval parameters.)</source>
          <target state="translated">이 매개 변수가 설정되어 있으면 PostgreSQL 서버는 검사 점 이후 해당 페이지를 처음 수정하는 동안 각 디스크 페이지의 전체 내용을 WAL에 씁니다. 이것은 운영 체제 충돌 중에 처리중인 페이지 쓰기가 부분적으로 만 완료되어 오래된 데이터와 새 데이터가 혼합 된 디스크 페이지로 이어질 수 있기 때문에 필요합니다. WAL에 일반적으로 저장된 행 레벨 변경 데이터로는 충돌 후 복구 중에 이러한 페이지를 완전히 복원하기에 충분하지 않습니다. 전체 페이지 이미지를 저장하면 페이지를 올바르게 복원 할 수 있지만 WAL에 기록해야하는 데이터 양이 증가합니다. WAL 재생은 항상 검사 점에서 시작하므로 검사 점 다음에 각 페이지를 처음 변경하는 동안이를 수행하면 충분합니다.전체 페이지 쓰기 비용을 줄이는 한 가지 방법은 검사 점 간격 매개 변수를 늘리는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="5a1902b314fccc53fa419bb9d1c5d0a54674b4cd" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;on&lt;/code&gt; and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch &lt;code&gt;-E&lt;/code&gt;.) If you set this variable to the value &lt;code&gt;noexec&lt;/code&gt;, the queries are just shown but are not actually sent to the server and executed. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">이 변수가 &lt;code&gt;on&lt;/code&gt; 으로 설정되고 백 슬래시 명령이 데이터베이스를 쿼리하면 쿼리가 먼저 표시됩니다. 이 기능을 사용하면 PostgreSQL 내부를 연구하고 자신의 프로그램에서 유사한 기능을 제공 할 수 있습니다. (프로그램 시작시이 동작을 선택하려면 스위치 &lt;code&gt;-E&lt;/code&gt; 를 사용하십시오 .)이 변수를 &lt;code&gt;noexec&lt;/code&gt; 값으로 설정 하면 쿼리가 방금 표시되지만 실제로 서버로 전송되어 실행되지는 않습니다. 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a31ece5bfbb183043ca04edf566185c4d24f24d" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="translated">제한이 활성화되면 실행이 끝날 때보고 된 트랜잭션 대기 시간이 예약 된 시작 시간에서 계산되므로 각 트랜잭션이 이전 트랜잭션이 완료되기를 기다려야하는 시간이 포함됩니다. 대기 시간을 스케줄 지연 시간이라고하며 평균 및 최대 값도 별도로보고됩니다. 실제 트랜잭션 시작 시간, 즉 데이터베이스에서 트랜잭션을 실행하는 데 소요 된 시간에 대한 트랜잭션 대기 시간은보고 된 대기 시간에서 일정 지연 시간을 빼서 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a5ce62fea33e48d7ca4dcdb6fc1d49b58833f9" translate="yes" xml:space="preserve">
          <source>When throttling is used (&lt;code&gt;--rate=...&lt;/code&gt;), transactions that lag behind schedule by more than &lt;code&gt;limit&lt;/code&gt; ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as &lt;em&gt;skipped&lt;/em&gt;.</source>
          <target state="translated">제한이 사용되는 경우 ( &lt;code&gt;--rate=...&lt;/code&gt; ), &lt;code&gt;limit&lt;/code&gt; ms 이상으로 일정보다 뒤쳐져 지연 시간 제한을 충족 할 수없는 트랜잭션 은 전혀 서버로 전송되지 않습니다. 그것들은 별도로 &lt;em&gt;건너 뛴&lt;/em&gt; 것으로 계산되고보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0431d629c5fa2195a09522dc9eddb52b7d7ef5d" translate="yes" xml:space="preserve">
          <source>When to JIT?</source>
          <target state="translated">언제 JIT해야합니까?</target>
        </trans-unit>
        <trans-unit id="c212a8c30b6a166bd84fdfc048fb956853e7ba65" translate="yes" xml:space="preserve">
          <source>When two arrays with an equal number of dimensions are concatenated, the result retains the lower bound subscript of the left-hand operand's outer dimension. The result is an array comprising every element of the left-hand operand followed by every element of the right-hand operand. For example:</source>
          <target state="translated">동일한 수의 차원을 가진 두 개의 배열이 연결되면 결과는 왼쪽 피연산자의 외부 차원의 하한 첨자를 유지합니다. 결과는 왼쪽 피연산자의 모든 요소와 오른쪽 피연산자의 모든 요소로 구성된 배열입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a09c4eb9b4b598594720766db600d02893739065" translate="yes" xml:space="preserve">
          <source>When used as a standalone program all WAL files logically preceding the &lt;code&gt;oldestkeptwalfile&lt;/code&gt; will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. In this mode, if you specify a &lt;code&gt;.partial&lt;/code&gt; or &lt;code&gt;.backup&lt;/code&gt; file name, then only the file prefix will be used as the &lt;code&gt;oldestkeptwalfile&lt;/code&gt;. This treatment of &lt;code&gt;.backup&lt;/code&gt; file name allows you to remove all WAL files archived prior to a specific base backup without error. For example, the following example will remove all files older than WAL file name &lt;code&gt;000000010000003700000010&lt;/code&gt;:</source>
          <target state="translated">독립 실행 형 프로그램으로 사용하면 가장 &lt;code&gt;oldestkeptwalfile&lt;/code&gt; 파일 앞에 논리적으로있는 모든 WAL 파일 이 &lt;code&gt;archivelocation&lt;/code&gt; 에서 제거됩니다 . 이 모드에서 &lt;code&gt;.partial&lt;/code&gt; 또는 &lt;code&gt;.backup&lt;/code&gt; 파일 이름 을 지정 하면 파일 접두사 만 &lt;code&gt;oldestkeptwalfile&lt;/code&gt; 로 사용됩니다 . &lt;code&gt;.backup&lt;/code&gt; 파일 이름을 처리 하면 특정 기본 백업 전에 아카이브 된 모든 WAL 파일을 오류없이 제거 할 수 있습니다. 예를 들어 다음 예제는 WAL 파일 이름 &lt;code&gt;000000010000003700000010&lt;/code&gt; 이전의 모든 파일을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="b4f92bbabc1b26d77780494bcd623901f19d77be" translate="yes" xml:space="preserve">
          <source>When used with one of the archive file formats and combined with pg_restore, pg_dump provides a flexible archival and transfer mechanism. pg_dump can be used to backup an entire database, then pg_restore can be used to examine the archive and/or select which parts of the database are to be restored. The most flexible output file formats are the &amp;ldquo;custom&amp;rdquo; format (&lt;code&gt;-Fc&lt;/code&gt;) and the &amp;ldquo;directory&amp;rdquo; format (&lt;code&gt;-Fd&lt;/code&gt;). They allow for selection and reordering of all archived items, support parallel restoration, and are compressed by default. The &amp;ldquo;directory&amp;rdquo; format is the only format that supports parallel dumps.</source>
          <target state="translated">아카이브 파일 형식 중 하나와 함께 사용하고 pg_restore와 함께 사용되는 경우 pg_dump는 유연한 보관 및 전송 메커니즘을 제공합니다. pg_dump를 사용하여 전체 데이터베이스를 백업 한 다음 pg_restore를 사용하여 아카이브를 검사하거나 복원 할 데이터베이스 부분을 선택할 수 있습니다. 가장 유연한 출력 파일 형식은 &quot;custom&quot;형식 ( &lt;code&gt;-Fc&lt;/code&gt; ) 및 &quot;directory&quot;형식 ( &lt;code&gt;-Fd&lt;/code&gt; )입니다. 모든 아카이브 된 항목을 선택하고 재정렬 할 수 있으며 병렬 복원을 지원하며 기본적으로 압축됩니다. &quot;디렉토리&quot;형식은 병렬 덤프를 지원하는 유일한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7fe14a6b317961785cf4d152bc27d49064bcda5a" translate="yes" xml:space="preserve">
          <source>When used within &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;, all WAL files logically preceding the value of the &lt;code&gt;%r&lt;/code&gt; argument will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. This minimizes the number of files that need to be retained, while preserving crash-restart capability. Use of this parameter is appropriate if the &lt;code&gt;archivelocation&lt;/code&gt; is a transient staging area for this particular standby server, but &lt;em&gt;not&lt;/em&gt; when the &lt;code&gt;archivelocation&lt;/code&gt; is intended as a long-term WAL archive area, or when multiple standby servers are recovering from the same archive location.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; 내에서 사용될 경우, &lt;code&gt;%r&lt;/code&gt; 인수 의 값보다 논리적으로 선행하는 모든 WAL 파일 이 &lt;code&gt;archivelocation&lt;/code&gt; 에서 제거됩니다 . 이는 충돌 재시작 기능을 유지하면서 보유해야하는 파일 수를 최소화합니다. 경우이 매개 변수의 사용은 적절한 &lt;code&gt;archivelocation&lt;/code&gt; 는 이 특정 대기 서버에 대한 과도 준비 영역이지만, &lt;em&gt;하지&lt;/em&gt; 때 &lt;code&gt;archivelocation&lt;/code&gt; 가 여러 대기 서버가 동일한 아카이브 위치에서 회복 될 때 장기 WAL 아카이브 영역으로 구성되어, 또는.</target>
        </trans-unit>
        <trans-unit id="7051b09dcb61945ea4e0d3beb1e52e65c9014732" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;COPY FROM&lt;/code&gt;, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used with &lt;code&gt;COPY TO&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; 을 사용 하는 경우이 문자열과 일치하는 모든 데이터 항목이 널값으로 저장되므로 &lt;code&gt;COPY TO&lt;/code&gt; 와 함께 사용한 것과 동일한 문자열을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8b5d7a27b46e73dc32c1b851c7dfef0ad7fe8a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is a good idea to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows &amp;mdash; you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;LIMIT&lt;/code&gt; 를 , 그것은 사용하는 좋은 아이디어이다 &lt;code&gt;ORDER BY&lt;/code&gt; 고유 순서로 결과 행을 제한 절. 그렇지 않으면 쿼리 행의 예측할 수없는 부분 집합을 얻게됩니다. 10 번째에서 20 번째 행을 요구할 수 있지만 10 번째에서 20 번째 순서는 무엇입니까? &lt;code&gt;ORDER BY&lt;/code&gt; 를 지정하지 않으면 어떤 순서를 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="481c23a58e8db851baee87afbfd06f8aa525bda9" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is important to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;LIMIT&lt;/code&gt; 를 , 사용하는 것이 중요하다 &lt;code&gt;ORDER BY&lt;/code&gt; 고유 순서로 결과 행을 제한 조항. 그렇지 않으면 예측할 수없는 쿼리 행의 하위 집합이 표시됩니다. 열 번째 열두 번째 열을 요구할 수도 있지만 열 두 번째 열을 어떤 순서로 요구할 수 있습니까? &lt;code&gt;ORDER BY&lt;/code&gt; 를 지정하지 않으면 순서를 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f85dc3be9cb7f009d076c5eedd8386addcb8b584" translate="yes" xml:space="preserve">
          <source>When using Kerberos authentication, SSPI works the same way GSSAPI does; see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details.</source>
          <target state="translated">Kerberos 인증을 사용할 때 SSPI는 GSSAPI와 동일한 방식으로 작동합니다. 자세한 내용 &lt;a href=&quot;gssapi-auth&quot;&gt;은 20.6 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc80b0e9ed4294e8911057b0a0a50261a196de62" translate="yes" xml:space="preserve">
          <source>When using POSIX semaphores, the number of semaphores needed is the same as for System V, that is one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;). On the platforms where this option is preferred, there is no specific kernel limit on the number of POSIX semaphores.</source>
          <target state="translated">POSIX 세마포어를 사용할 때 필요한 세마포어 수는 System V의 경우와 동일합니다. 즉 허용 된 연결 당 하나의 세마포어 ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; ), 허용 된 자동 진공 작업자 프로세스 ( &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; ) 및 허용 된 백그라운드 프로세스 ( &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; )입니다. 이 옵션이 선호되는 플랫폼에서는 POSIX 세마포 수에 대한 특정 커널 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d87a93d2de1be22dab32dcbbc5446297da3c6d5" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="translated">RADIUS 인증을 사용하면 액세스 요청 메시지가 구성된 RADIUS 서버로 전송됩니다. 이 요청은 &lt;code&gt;Authenticate Only&lt;/code&gt; 유형 이며 &lt;code&gt;user name&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; (암호화) 및 &lt;code&gt;NAS Identifier&lt;/code&gt; 대한 매개 변수를 포함 합니다 . 요청은 서버와 공유 된 비밀을 사용하여 암호화됩니다. RADIUS 서버는이 서버에 &lt;code&gt;Access Accept&lt;/code&gt; 또는 &lt;code&gt;Access Reject&lt;/code&gt; 중 하나로 응답합니다 . RADIUS 계정은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df1ce6f4ba5a71b98d3f24da1f9c50898361216d" translate="yes" xml:space="preserve">
          <source>When using System V semaphores, PostgreSQL uses one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;), in sets of 16. Each such set will also contain a 17th semaphore which contains a &amp;ldquo;magic number&amp;rdquo;, to detect collision with semaphore sets used by other applications. The maximum number of semaphores in the system is set by &lt;code&gt;SEMMNS&lt;/code&gt;, which consequently must be at least as high as &lt;code&gt;max_connections&lt;/code&gt; plus &lt;code&gt;autovacuum_max_workers&lt;/code&gt; plus &lt;code&gt;max_wal_senders&lt;/code&gt;, plus &lt;code&gt;max_worker_processes&lt;/code&gt;, plus one extra for each 16 allowed connections plus workers (see the formula in &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;Table 18.1&lt;/a&gt;). The parameter &lt;code&gt;SEMMNI&lt;/code&gt; determines the limit on the number of semaphore sets that can exist on the system at one time. Hence this parameter must be at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt;. Lowering the number of allowed connections is a temporary workaround for failures, which are usually confusingly worded &amp;ldquo;No space left on device&amp;rdquo;, from the function &lt;code&gt;semget&lt;/code&gt;.</source>
          <target state="translated">System V 세마포어를 사용하는 경우 PostgreSQL은 허용되는 연결 ( &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; ), 허용 된 autovacuum 작업자 프로세스 ( &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; ) 및 허용 된 백그라운드 프로세스 ( &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; ) 당 하나의 세마포어 를 16 세트로 사용합니다. 이러한 각 세트에는 &quot; 다른 응용 프로그램에서 사용하는 세마포어 세트와의 충돌을 감지합니다. 시스템의 최대 세마포어 수는 &lt;code&gt;SEMMNS&lt;/code&gt; 에 의해 설정되며 , 결과적으로 최소한 &lt;code&gt;max_connections&lt;/code&gt; + &lt;code&gt;autovacuum_max_workers&lt;/code&gt; + &lt;code&gt;max_wal_senders&lt;/code&gt; 및 &lt;code&gt;max_worker_processes&lt;/code&gt; 만큼 높아야합니다 ., 16 개의 허용 된 연결 및 작업자에 대해 1 개의 추가 추가 ( &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;표 18.1&lt;/a&gt; 의 공식 참조 ). &lt;code&gt;SEMMNI&lt;/code&gt; 매개 변수 는 한 번에 시스템에 존재할 수있는 세마포어 세트 수의 한계를 판별합니다. 따라서이 매개 변수는 최소한 &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; 이어야합니다 . 허용되는 연결 수를 낮추는 것은 실패에 대한 임시 해결 방법이며, 일반적으로 함수 &lt;code&gt;semget&lt;/code&gt; 에서 &quot;장치에 남은 공간 없음&quot;으로 혼동 됩니다.</target>
        </trans-unit>
        <trans-unit id="c8382eef968bcd1841af0a45f03df20722ebed18" translate="yes" xml:space="preserve">
          <source>When using a replication setup with tools which perform direct copies of relation file blocks (for example &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;), enabling or disabling checksums can lead to page corruptions in the shape of incorrect checksums if the operation is not done consistently across all nodes. When enabling or disabling checksums in a replication setup, it is thus recommended to stop all the clusters before switching them all consistently. Destroying all standbys, performing the operation on the primary and finally recreating the standbys from scratch is also safe.</source>
          <target state="translated">관계 파일 블록의 직접 복사를 수행하는 도구 (예 : &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; ) 와 함께 복제 설정을 사용하는 경우, 모든 노드에서 작업이 일관되게 수행되지 않으면 체크섬을 활성화 또는 비활성화하면 잘못된 체크섬 모양으로 페이지가 손상 될 수 있습니다. 복제 설정에서 체크섬을 활성화 또는 비활성화 할 때 모든 클러스터를 일관되게 전환하기 전에 모든 클러스터를 중지하는 것이 좋습니다. 모든 대기를 제거하고 기본에서 작업을 수행 한 후 마지막으로 대기를 처음부터 다시 작성하는 것도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="eac93956f94fd1f4ae45bb87df2631e194bcbe28" translate="yes" xml:space="preserve">
          <source>When using a separate column to store the &lt;code&gt;tsvector&lt;/code&gt; representation of your documents, it is necessary to create a trigger to update the &lt;code&gt;tsvector&lt;/code&gt; column when the document content columns change. Two built-in trigger functions are available for this, or you can write your own.</source>
          <target state="translated">별도의 열을 사용 하여 문서 의 &lt;code&gt;tsvector&lt;/code&gt; 표현 을 저장하는 경우 문서 컨텐츠 열이 변경 될 때 &lt;code&gt;tsvector&lt;/code&gt; 열 을 업데이트하는 트리거를 작성해야합니다 . 이를 위해 2 개의 내장 트리거 기능을 사용하거나 직접 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9150f1a85447666f80a11e9912230df80685449c" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;archive_command&lt;/code&gt; script, it's desirable to enable &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;. Any messages written to stderr from the script will then appear in the database server log, allowing complex configurations to be diagnosed easily if they fail.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;archive_command&lt;/code&gt; 의 스크립트를, 그것을 가능하게하는 것이 바람직의 &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector을&lt;/a&gt; . 스크립트에서 stderr에 기록 된 모든 메시지는 데이터베이스 서버 로그에 표시되어 복잡한 구성이 실패한 경우 쉽게 진단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="953b500ebbfdd4983d6d154f36b232db63c79506" translate="yes" xml:space="preserve">
          <source>When using an external authentication system such as Ident or GSSAPI, the name of the operating system user that initiated the connection might not be the same as the database user (role) that is to be used. In this case, a user name map can be applied to map the operating system user name to a database user. To use user name mapping, specify &lt;code&gt;map&lt;/code&gt;=&lt;code&gt;map-name&lt;/code&gt; in the options field in &lt;code&gt;pg_hba.conf&lt;/code&gt;. This option is supported for all authentication methods that receive external user names. Since different mappings might be needed for different connections, the name of the map to be used is specified in the &lt;code&gt;map-name&lt;/code&gt; parameter in &lt;code&gt;pg_hba.conf&lt;/code&gt; to indicate which map to use for each individual connection.</source>
          <target state="translated">Ident 또는 GSSAPI와 같은 외부 인증 시스템을 사용하는 경우 연결을 시작한 운영 체제 사용자 이름이 사용할 데이터베이스 사용자 (역할)와 같지 않을 수 있습니다. 이 경우, 운영 체제 사용자 이름을 데이터베이스 사용자에 맵핑하기 위해 사용자 이름 맵을 적용 할 수 있습니다. 사용자 이름 매핑을 사용하려면 &lt;code&gt;pg_hba.conf&lt;/code&gt; 의 옵션 필드에 &lt;code&gt;map&lt;/code&gt; = &lt;code&gt;map-name&lt;/code&gt; 을 지정 하십시오 . 이 옵션은 외부 사용자 이름을받는 모든 인증 방법에 지원됩니다. 다른 연결에 대해 다른 매핑이 필요할 수 있으므로 사용할 &lt;code&gt;map-name&lt;/code&gt; 은 &lt;code&gt;pg_hba.conf&lt;/code&gt; 의 map-name 매개 변수에 지정되어 각 개별 연결에 사용할 맵을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="492838d017254285805f7e847c1bb4763dffb265" translate="yes" xml:space="preserve">
          <source>When using binary mode to pass query parameters to the server and query results back to the client, no encoding conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that PostgreSQL does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.</source>
          <target state="translated">이진 모드를 사용하여 쿼리 매개 변수를 서버로 전달하고 쿼리 결과를 클라이언트로 다시 쿼리하면 인코딩 변환이 수행되지 않으므로 상황이 다릅니다. 이 경우 XML 데이터의 인코딩 선언이 관찰되며,없는 경우 데이터는 UTF-8로 간주됩니다 (XML 표준에 따라 PostgreSQL은 UTF-16을 지원하지 않습니다) . 출력시, 클라이언트 인코딩이 UTF-8이 아닌 한, 데이터는 클라이언트 인코딩을 지정하는 인코딩 선언을 갖습니다.이 경우 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="56607247aff04e4e074b7797ef04095046172c94" translate="yes" xml:space="preserve">
          <source>When using collations provided by the ICU library, the ICU-specific version of the collator is recorded in the system catalog when the collation object is created. When the collation is used, the current version is checked against the recorded version, and a warning is issued when there is a mismatch, for example:</source>
          <target state="translated">ICU 라이브러리에서 제공 한 데이터 정렬을 사용하는 경우 데이터 정렬 개체가 생성 될 때 ICU 특정 버전의 데이터 생성기가 시스템 카탈로그에 기록됩니다. 데이터 정렬을 사용하면 현재 버전이 기록 된 버전과 비교하여 확인되고 일치하지 않는 경우 경고가 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de5896493e8d94d607ede6725d8b75b29f2f0f82" translate="yes" xml:space="preserve">
          <source>When using cost-based vacuuming, appropriate values for &lt;code&gt;vacuum_cost_delay&lt;/code&gt; are usually quite small, perhaps less than 1 millisecond. While &lt;code&gt;vacuum_cost_delay&lt;/code&gt; can be set to fractional-millisecond values, such delays may not be measured accurately on older platforms. On such platforms, increasing &lt;code&gt;VACUUM&lt;/code&gt;'s throttled resource consumption above what you get at 1ms will require changing the other vacuum cost parameters. You should, nonetheless, keep &lt;code&gt;vacuum_cost_delay&lt;/code&gt; as small as your platform will consistently measure; large delays are not helpful.</source>
          <target state="translated">비용 기반 진공 청소기를 사용할 때 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 의 적절한 값 은 일반적으로 1 밀리 초 미만으로 매우 작습니다. &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 를 분수 밀리 초 값으로 설정할 수 있지만 이러한 지연은 이전 플랫폼에서 정확하게 측정되지 않을 수 있습니다. 이러한 플랫폼에서 &lt;code&gt;VACUUM&lt;/code&gt; 의 조절 된 리소스 소비를 1ms 이상으로 늘리 려면 다른 진공 비용 매개 변수를 변경해야합니다. 그럼에도 불구하고 플랫폼이 지속적으로 측정 할 수있는 한 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 를 작게 유지해야합니다 . 큰 지연은 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75aee5f97d42018467b21311d706aa5a647707a9" translate="yes" xml:space="preserve">
          <source>When using exclusive backup mode, it is absolutely imperative to ensure that &lt;code&gt;pg_stop_backup&lt;/code&gt; completes successfully at the end of the backup. Even if the backup itself fails, for example due to lack of disk space, failure to call &lt;code&gt;pg_stop_backup&lt;/code&gt; will leave the server in backup mode indefinitely, causing future backups to fail and increasing the risk of a restart failure during the time that &lt;code&gt;backup_label&lt;/code&gt; exists.</source>
          <target state="translated">단독 백업 모드를 사용하는 경우 백업 종료시 &lt;code&gt;pg_stop_backup&lt;/code&gt; 이 성공적으로 완료 되도록해야합니다 . 디스크 공간 부족으로 인해 백업 자체가 실패하더라도 &lt;code&gt;pg_stop_backup&lt;/code&gt; 을 호출 하지 않으면 서버가 무기한 백업 모드로 유지되어 향후 백업이 실패하고 &lt;code&gt;backup_label&lt;/code&gt; 이 존재 하는 동안 재시작 실패의 위험이 증가 합니다.</target>
        </trans-unit>
        <trans-unit id="ec73be80732f41a040847bc00566e73f63c25a96" translate="yes" xml:space="preserve">
          <source>When using link mode, standby servers can be quickly upgraded using rsync. To accomplish this, from a directory on the primary server that is above the old and new database cluster directories, run this on the &lt;em&gt;primary&lt;/em&gt; for each standby server:</source>
          <target state="translated">링크 모드를 사용하면 rsync를 사용하여 대기 서버를 빠르게 업그레이드 할 수 있습니다. 이를 수행하려면 이전 및 새 데이터베이스 클러스터 디렉토리 위에있는 1 차 서버의 디렉토리에서 각 대기 서버 의 &lt;em&gt;1 차&lt;/em&gt; 서버 에서이를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d1e98ef020032cfb9faf29c2d74acac7b1c192c" translate="yes" xml:space="preserve">
          <source>When using multiple &lt;code&gt;INSERT&lt;/code&gt;s, turn off autocommit and just do one commit at the end. (In plain SQL, this means issuing &lt;code&gt;BEGIN&lt;/code&gt; at the start and &lt;code&gt;COMMIT&lt;/code&gt; at the end. Some client libraries might do this behind your back, in which case you need to make sure the library does it when you want it done.) If you allow each insertion to be committed separately, PostgreSQL is doing a lot of work for each row that is added. An additional benefit of doing all insertions in one transaction is that if the insertion of one row were to fail then the insertion of all rows inserted up to that point would be rolled back, so you won't be stuck with partially loaded data.</source>
          <target state="translated">여러 개의 &lt;code&gt;INSERT&lt;/code&gt; 를 사용하는 경우 자동 커밋을 끄고 마지막에 한 번의 커밋을 수행하십시오. (일반 SQL에서 이것은 시작시 &lt;code&gt;BEGIN&lt;/code&gt; 을 발행 하고 끝에서 &lt;code&gt;COMMIT&lt;/code&gt; 을 발행 함을 의미 합니다. 일부 클라이언트 라이브러리는이 작업을 수행 할 수 있습니다.이 경우 원하는 경우 라이브러리가이를 수행하도록해야합니다.) 각 삽입은 별도로 커밋되므로 PostgreSQL은 추가 된 각 행에 대해 많은 작업을 수행합니다. 한 트랜잭션에서 모든 삽입을 수행 할 경우의 또 다른 이점은 하나의 행 삽입이 실패하면 해당 지점까지 삽입 된 모든 행의 삽입이 롤백되므로 부분적으로로드 된 데이터가 고착되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8692847b55239c8542d72c31d947ca1f69e8f98c" translate="yes" xml:space="preserve">
          <source>When using pg_receivewal instead of &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; as the main WAL backup method, it is strongly recommended to use replication slots. Otherwise, the server is free to recycle or remove write-ahead log files before they are backed up, because it does not have any information, either from &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; or the replication slots, about how far the WAL stream has been archived. Note, however, that a replication slot will fill up the server's disk space if the receiver does not keep up with fetching the WAL data.</source>
          <target state="translated">기본 WAL 백업 방법 으로 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; 대신 pg_receivewal 을 사용하는 경우 복제 슬롯을 사용하는 것이 좋습니다. 그렇지 않으면 서버는 WAL 스트림이 아카이브 된 거리에 대한 정보가 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; 또는 복제 슬롯에 없기 때문에 백업하기 전에 미리 쓰기 로그 파일을 재활용하거나 제거 할 수 있습니다 . 그러나 리시버가 WAL 데이터를 페치하지 않으면 복제 슬롯이 서버의 디스크 공간을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="7805e078bb69ca14f943ca44e9ff4b57cc0c775e" translate="yes" xml:space="preserve">
          <source>When using search+bind mode, the search can be performed using a single attribute specified with &lt;code&gt;ldapsearchattribute&lt;/code&gt;, or using a custom search filter specified with &lt;code&gt;ldapsearchfilter&lt;/code&gt;. Specifying &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; is equivalent to specifying &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt;. If neither option is specified the default is &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt;.</source>
          <target state="translated">검색 + 결합 모드를 사용하는 경우, 탐색은 지정된 단일 속성을 사용하여 수행 될 수 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 을 , 또는 지정된 사용자 검색 필터 사용 &lt;code&gt;ldapsearchfilter&lt;/code&gt; 를 . 지정 &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; 는 것은 지정하는 것과 같습니다 &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt; . 옵션이 지정되지 않은 경우 기본값은 &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ccf2c531c08aa10ba699a8b190067e047b3e70bf" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this timeframe. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="translated">정적 로그 파일 이름을 사용할 때 최대 파일 열기 한계에 도달하거나 파일 테이블 오버 플로우가 발생하면 서버가 로그 파일을 다시 열지 못할 수 있습니다. 이 경우 로그 메시지는 성공적인 로그 회전까지 이전 로그 파일로 전송됩니다. logrotate가 로그 파일을 압축하고 삭제하도록 구성된 경우 서버는이 시간대에 기록 된 메시지를 잃을 수 있습니다. 이 문제를 피하기 위해 로그 파일 이름을 동적으로 할당하고 사전 &lt;code&gt;prerotate&lt;/code&gt; 스크립트를 사용하여 열린 로그 파일을 무시 하도록 로깅 수집기를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddcdbf5154b4eb280778c5288af6f89414cb4462" translate="yes" xml:space="preserve">
          <source>When using systemd, you can use the following service unit file (e.g., at &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt;):</source>
          <target state="translated">systemd를 사용할 때 다음 서비스 유닛 파일을 사용할 수 있습니다 (예 : &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa4f4b5954d77c90199a922670870bbe00993316" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; 모듈을 사용할 때 외부 서버 이름을 &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; 함수 의 인수로 사용 하여 연결 매개 변수를 표시 할 수 있습니다 . 이런 방식으로 사용하려면 외부 서버에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="bd246a1d45857b9944b119a71ad8342fdd069e69" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. A column definition list can be placed after the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; construct only if there's just a single function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause.</source>
          <target state="translated">사용시 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 구문 기능 중 하나는 열 정의리스트를 요구하는 경우, 내부에 함수를 호출 한 후 열 정의 목록을 넣어 바람직한 것 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; . &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 절이 없고 단일 함수 만있는 경우에만 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 구문 뒤에 열 정의 목록을 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98b68f1005505d22ba3f1b802a0a0796977dd397" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;extensions&lt;/code&gt; option, &lt;em&gt;it is the user's responsibility&lt;/em&gt; that the listed extensions exist and behave identically on both the local and remote servers. Otherwise, remote queries may fail or behave unexpectedly.</source>
          <target state="translated">&lt;code&gt;extensions&lt;/code&gt; 옵션을 사용 하는 경우 나열된 확장이 존재하고 로컬 및 원격 서버에서 동일하게 작동 &lt;em&gt;하는&lt;/em&gt; 것은 &lt;em&gt;사용자의 책임&lt;/em&gt; 입니다. 그렇지 않으면 원격 쿼리가 실패하거나 예기치 않게 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e797775100fdafb459cefc34e37395f8e226c9b6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;libc&lt;/code&gt; collation provider, the locale must be applicable to the current database encoding. See &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; for the precise rules.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 데이터 정렬 제공자를 사용하는 경우 로케일이 현재 데이터베이스 인코딩에 적용 가능해야합니다. 정확한 규칙 은 &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33347a458dabb91eee87e22ef8743db48a2953ba" translate="yes" xml:space="preserve">
          <source>When using the statistics to monitor collected data, it is important to realize that the information does not update instantaneously. Each individual server process transmits new statistical counts to the collector just before going idle; so a query or transaction still in progress does not affect the displayed totals. Also, the collector itself emits a new report at most once per &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; milliseconds (500 ms unless altered while building the server). So the displayed information lags behind actual activity. However, current-query information collected by &lt;code&gt;track_activities&lt;/code&gt; is always up-to-date.</source>
          <target state="translated">통계를 사용하여 수집 된 데이터를 모니터링 할 때 정보가 즉시 업데이트되지 않는다는 것을 인식해야합니다. 각 개별 서버 프로세스는 유휴 상태가되기 직전에 새로운 통계 계수를 수집기로 전송합니다. 따라서 진행중인 쿼리 또는 트랜잭션은 표시된 총계에 영향을 미치지 않습니다. 또한 콜렉터 자체는 &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; 밀리 초당 최대 한 번 (새 서버를 빌드하는 동안 변경하지 않는 한 500ms) 새 보고서를 발행 합니다. 따라서 표시된 정보는 실제 활동보다 뒤떨어집니다. 그러나 &lt;code&gt;track_activities&lt;/code&gt; 에 의해 수집 된 현재 쿼리 정보 는 항상 최신 정보입니다.</target>
        </trans-unit>
        <trans-unit id="869040936f3cd63714aedfeb674cbbcb51ecde9f" translate="yes" xml:space="preserve">
          <source>When using this option together with &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, the text of statements that are logged because of &lt;code&gt;log_statement&lt;/code&gt; will not be repeated in the duration log message. If you are not using syslog, it is recommended that you log the PID or session ID using &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; so that you can link the statement message to the later duration message using the process ID or session ID.</source>
          <target state="translated">와 함께이 옵션을 사용할 때 &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt; , 때문에 로그인 문장의 텍스트 &lt;code&gt;log_statement&lt;/code&gt; 는 기간의 로그 메시지에서 반복되지 않습니다. syslog를 사용하지 않는 경우 프로세스 ID 또는 세션 ID를 사용하여 명령문 메시지를 이후 지속 기간 메시지에 링크 할 수 있도록 &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix를&lt;/a&gt; 사용하여 PID 또는 세션 ID를 로그하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f56584dae166e0f5d41c03bae8959fb67da882b7" translate="yes" xml:space="preserve">
          <source>When using this technique, it will avoid creating an unnecessary burden for application programmers if the application software goes through a framework which automatically retries transactions which are rolled back with a serialization failure. It may be a good idea to set &lt;code&gt;default_transaction_isolation&lt;/code&gt; to &lt;code&gt;serializable&lt;/code&gt;. It would also be wise to take some action to ensure that no other transaction isolation level is used, either inadvertently or to subvert integrity checks, through checks of the transaction isolation level in triggers.</source>
          <target state="translated">이 기술을 사용할 때 응용 프로그램 소프트웨어가 직렬화 실패로 롤백 된 트랜잭션을 자동으로 재 시도하는 프레임 워크를 통과하는 경우 응용 프로그램 프로그래머에게 불필요한 부담을주지 않습니다. &lt;code&gt;default_transaction_isolation&lt;/code&gt; 을 &lt;code&gt;serializable&lt;/code&gt; 로 설정하는 것이 좋습니다 . 트리거에서 트랜잭션 격리 수준을 검사하여 실수로 무결성 검사를 파괴하거나 다른 트랜잭션 격리 수준을 사용하지 않도록 조치를 취하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e33ed6ffb66e09afb90b2aa31b40f235c917227" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="translated">체크섬을 확인할 때 클러스터의 모든 파일이 검사됩니다. 체크섬을 활성화하면 클러스터의 모든 파일이 다시 작성됩니다. 체크섬을 비활성화하면 &lt;code&gt;pg_control&lt;/code&gt; 파일 만 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="fda53778d06f68bfde32b3023f6347b2be67790d" translate="yes" xml:space="preserve">
          <source>When waiting, &lt;code&gt;pg_ctl&lt;/code&gt; repeatedly checks the server's PID file, sleeping for a short amount of time between checks. Startup is considered complete when the PID file indicates that the server is ready to accept connections. Shutdown is considered complete when the server removes the PID file. &lt;code&gt;pg_ctl&lt;/code&gt; returns an exit code based on the success of the startup or shutdown.</source>
          <target state="translated">대기 할 때 &lt;code&gt;pg_ctl&lt;/code&gt; 은 반복적으로 서버의 PID 파일을 점검하고 점검 사이에 짧은 시간 동안 휴면 상태를 유지합니다. PID 파일이 서버가 연결을 수락 할 준비가되었음을 표시하면 시작이 완료된 것으로 간주됩니다. 서버가 PID 파일을 제거하면 종료가 완료된 것으로 간주됩니다. &lt;code&gt;pg_ctl&lt;/code&gt; 은 시작 또는 종료 성공에 따라 종료 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="319a6ac32ba7d37c93ad8b3aed41a7b25d9cd283" translate="yes" xml:space="preserve">
          <source>When we speak of inheriting the locale from the execution environment, this means the following on most operating systems: For a given locale category, say the collation, the following environment variables are consulted in this order until one is found to be set: &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; (or the variable corresponding to the respective category), &lt;code&gt;LANG&lt;/code&gt;. If none of these environment variables are set then the locale defaults to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">실행 환경에서 로케일을 상속한다고 할 때, 이는 대부분의 운영 체제에서 다음을 의미합니다. 주어진 로케일 범주의 경우 데이터 정렬을 말하면 다음 환경 변수가 설정 될 때까지 순서대로 참조됩니다. &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; (또는 각각의 카테고리에 대응하는 변수) &lt;code&gt;LANG&lt;/code&gt; . 이러한 환경 변수가 설정되지 않은 경우 로케일의 기본값은 &lt;code&gt;C&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09870d0ba2815a6a474afa8adde88701322779a5" translate="yes" xml:space="preserve">
          <source>When we write</source>
          <target state="translated">우리가 쓸 때</target>
        </trans-unit>
        <trans-unit id="5f55fad869d686971a61de9989dadab77ae5eb95" translate="yes" xml:space="preserve">
          <source>When working with an inner tuple having unlabeled nodes, it is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since the set of nodes is supposed to be fixed in such cases.</source>
          <target state="translated">레이블이 지정되지 않은 노드가있는 내부 튜플을 사용하는 경우 노드 세트가 수정되어야하므로 &lt;code&gt;spgAddNode&lt;/code&gt; 를 반환 &lt;code&gt;choose&lt;/code&gt; 하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="513c84ce8934fc59619703510a7a572aaca0c319" translate="yes" xml:space="preserve">
          <source>When working with multiple tables, it can also be useful to ask for all the columns of a particular table:</source>
          <target state="translated">여러 테이블로 작업 할 때 특정 테이블의 모든 열을 요청하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f387116d6a98de65f13445ebf4c25f94df15576" translate="yes" xml:space="preserve">
          <source>When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a left unary operator named &lt;code&gt;@&lt;/code&gt;, you cannot write &lt;code&gt;X*@Y&lt;/code&gt;; you must write &lt;code&gt;X* @Y&lt;/code&gt; to ensure that PostgreSQL reads it as two operator names not one.</source>
          <target state="translated">비 SQL 표준 연산자 이름으로 작업 할 때는 일반적으로 모호성을 피하기 위해 인접한 연산자를 공백으로 구분해야합니다. 예를 들어, &lt;code&gt;@&lt;/code&gt; 이라는 왼쪽 단항 연산자를 정의한 경우 &lt;code&gt;X*@Y&lt;/code&gt; 쓸 수 없습니다 . PostgreSQL &lt;code&gt;X* @Y&lt;/code&gt; 를 하나의 연산자가 아닌 두 개의 연산자 이름으로 읽도록 X * @Y 를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ec3a2849e7e7665d1ef0586b393970fa38e06c50" translate="yes" xml:space="preserve">
          <source>When working with recursive queries it is important to be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. Sometimes, using &lt;code&gt;UNION&lt;/code&gt; instead of &lt;code&gt;UNION ALL&lt;/code&gt; can accomplish this by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are completely duplicate: it may be necessary to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the already-visited values. For example, consider the following query that searches a table &lt;code&gt;graph&lt;/code&gt; using a &lt;code&gt;link&lt;/code&gt; field:</source>
          <target state="translated">재귀 쿼리로 작업 할 때 쿼리의 재귀 부분이 결국 튜플을 반환하지 않거나 쿼리가 무기한 반복되도록해야합니다. 때로는 &lt;code&gt;UNION ALL&lt;/code&gt; 대신 &lt;code&gt;UNION&lt;/code&gt; 을 사용하면 이전 출력 행을 복제하는 행을 삭제하여이 작업을 수행 할 수 있습니다. 그러나주기에 완전히 중복되는 출력 행이 포함되지 않는 경우가 있습니다. 동일한 포인트에 도달했는지 확인하기 위해 하나 또는 몇 개의 필드 만 확인해야 할 수도 있습니다. 이러한 상황을 처리하는 표준 방법은 이미 방문한 값의 배열을 계산하는 것입니다. 예를 들어, &lt;code&gt;link&lt;/code&gt; 필드를 사용하여 테이블 &lt;code&gt;graph&lt;/code&gt; 를 검색하는 다음 쿼리를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5718cfeb2fe2d91286009aaf2e77c006f835bbe" translate="yes" xml:space="preserve">
          <source>When writing an interval constant with a &lt;code&gt;fields&lt;/code&gt; specification, or when assigning a string to an interval column that was defined with a &lt;code&gt;fields&lt;/code&gt; specification, the interpretation of unmarked quantities depends on the &lt;code&gt;fields&lt;/code&gt;. For example &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; is read as 1 year, whereas &lt;code&gt;INTERVAL '1'&lt;/code&gt; means 1 second. Also, field values &amp;ldquo;to the right&amp;rdquo; of the least significant field allowed by the &lt;code&gt;fields&lt;/code&gt; specification are silently discarded. For example, writing &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; results in dropping the seconds field, but not the day field.</source>
          <target state="translated">으로 일정한 간격을 작성할 때 &lt;code&gt;fields&lt;/code&gt; 데이터 유형으로 정의 된 간격 열 문자열을 할당 할 때 명세서 또는 &lt;code&gt;fields&lt;/code&gt; 사양, 수량의 도장이 해석은에 따라 &lt;code&gt;fields&lt;/code&gt; . 예를 들어 &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; 는 1 년으로 읽히지 만 &lt;code&gt;INTERVAL '1'&lt;/code&gt; 은 1 초를 나타냅니다. 또한 &lt;code&gt;fields&lt;/code&gt; 스펙에 의해 허용되는 최하위 필드의 &quot;오른쪽에있는&quot;필드 값 은 자동으로 삭제됩니다. 예를 들어, &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; 초 필드는 삭제되지만 일 필드는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="988ef8be5d9c8af4c97d0fc59910f990922134e4" translate="yes" xml:space="preserve">
          <source>When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.</source>
          <target state="translated">테이블을 만들 때 실수를했거나 응용 프로그램의 요구 사항이 변경되었다는 것을 알게되면 테이블을 삭제하고 다시 만들 수 있습니다. 그러나 테이블이 이미 데이터로 채워져 있거나 다른 데이터베이스 개체 (예 : 외래 키 제약 조건)에서 테이블을 참조하는 경우 편리한 옵션이 아닙니다. 따라서 PostgreSQL은 기존 테이블을 수정하기위한 명령 군을 제공합니다. 이것은 개념적으로 테이블에 포함 된 데이터를 변경하는 것과 구별됩니다. 여기서는 테이블의 정의 또는 구조를 변경하는 데 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a09c13346cb20d8d1dd7186def1b2a2f01cbc1" translate="yes" xml:space="preserve">
          <source>When you create complex database structures involving many tables with foreign key constraints, views, triggers, functions, etc. you implicitly create a net of dependencies between the objects. For instance, a table with a foreign key constraint depends on the table it references.</source>
          <target state="translated">외래 키 제약 조건, 뷰, 트리거, 함수 등을 사용하여 많은 테이블이 포함 된 복잡한 데이터베이스 구조를 만들면 개체간에 종속성이 생길 수 있습니다. 예를 들어 외래 키 제약 조건이있는 테이블은 참조하는 테이블에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b9a5344aa581794cb8d710e210bdb65e511f2134" translate="yes" xml:space="preserve">
          <source>When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other.</source>
          <target state="translated">서로 관련된 많은 테이블을 만들 때는 테이블과 열에 대해 일관된 이름 지정 패턴을 선택하는 것이 좋습니다. 예를 들어, 테이블 이름에 단수 또는 복수 명사를 사용할 수 있습니다. 둘 다 일부 이론가 또는 다른 사람들이 선호합니다.</target>
        </trans-unit>
        <trans-unit id="593e96c33f6f0aab676c4ca184c4ca854f13bc97" translate="yes" xml:space="preserve">
          <source>When you insert invalid numbers in a table using the weak mode, the number will be inserted with the corrected check digit, but it will be displayed with an exclamation mark (&lt;code&gt;!&lt;/code&gt;) at the end, for example &lt;code&gt;0-11-000322-5!&lt;/code&gt;. This invalid marker can be checked with the &lt;code&gt;is_valid&lt;/code&gt; function and cleared with the &lt;code&gt;make_valid&lt;/code&gt; function.</source>
          <target state="translated">약한 모드를 사용하여 테이블에 유효하지 않은 숫자를 삽입하면 수정 된 체크 숫자와 함께 숫자가 삽입되지만 끝에 느낌표 ( &lt;code&gt;!&lt;/code&gt; ) 가 표시됩니다 ( 예 : &lt;code&gt;0-11-000322-5!&lt;/code&gt; . 이 유효하지 않은 마커는 &lt;code&gt;is_valid&lt;/code&gt; 함수 로 확인 하고 &lt;code&gt;make_valid&lt;/code&gt; 함수로 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bf59c49779a368d436367de404fed33cad74dcd" translate="yes" xml:space="preserve">
          <source>When you query JSON data, the path expression may not match the actual JSON data structure. An attempt to access a non-existent member of an object or element of an array results in a structural error. SQL/JSON path expressions have two modes of handling structural errors:</source>
          <target state="translated">JSON 데이터를 쿼리 할 때 경로 표현식이 실제 JSON 데이터 구조와 일치하지 않을 수 있습니다. 객체 또는 배열 요소의 존재하지 않는 멤버에 액세스하려고하면 구조적 오류가 발생합니다. SQL / JSON 경로 표현식에는 구조적 오류를 처리하는 두 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3780caf73c39bd4ac2d31b375fc0dd6e1923bd0" translate="yes" xml:space="preserve">
          <source>When you write the argument of a sequence function as an unadorned literal string, it becomes a constant of type &lt;code&gt;regclass&lt;/code&gt;. Since this is really just an OID, it will track the originally identified sequence despite later renaming, schema reassignment, etc. This &amp;ldquo;early binding&amp;rdquo; behavior is usually desirable for sequence references in column defaults and views. But sometimes you might want &amp;ldquo;late binding&amp;rdquo; where the sequence reference is resolved at run time. To get late-binding behavior, force the constant to be stored as a &lt;code&gt;text&lt;/code&gt; constant instead of &lt;code&gt;regclass&lt;/code&gt;:</source>
          <target state="translated">시퀀스 함수의 인수를 비 인수 리터럴 문자열로 쓰면 &lt;code&gt;regclass&lt;/code&gt; 유형의 상수가됩니다 . 이것은 실제로 OID 일 뿐이므로 나중에 이름 변경, 스키마 재 할당 등에도 불구하고 원래 식별 된 시퀀스를 추적합니다.이 &quot;초기 바인딩&quot;동작은 일반적으로 열 기본값 및 뷰의 시퀀스 참조에 바람직합니다. 그러나 때때로 시퀀스 참조가 런타임에 해결되는 &quot;late binding&quot;을 원할 수도 있습니다. 늦은 바인딩 동작을 얻으려면 상수를 &lt;code&gt;regclass&lt;/code&gt; 대신 &lt;code&gt;text&lt;/code&gt; 상수 로 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="2507ec70331a5deab93cd40d826b1bdba44ecbc3" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; view will contain a row for each backend that is currently running either command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; 또는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 이 실행될 때마다 &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; 보기에는 현재 두 명령 중 하나를 실행중인 각 백엔드에 대한 행이 포함됩니다. 아래 표는보고 될 정보를 설명하고 해석 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="51b73a7d0ff3b39db66ff19d5f58e0f20613bb45" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; view will contain one row for each backend that is currently creating indexes. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; 또는 &lt;code&gt;REINDEX&lt;/code&gt; 가 실행될 때마다 &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; 보기는 현재 색인을 작성중인 각 백엔드마다 하나의 행을 포함합니다. 아래 표는보고 될 정보를 설명하고 해석 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0da2e4c266065ef5b47dc244d1142646be363723" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 실행될 때마다 &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; 보기는 현재 진공 상태 인 각 백엔드 (자동 진공 작업자 프로세스 포함)에 대해 하나의 행을 포함합니다. 아래 표는보고 될 정보를 설명하고 해석 방법에 대한 정보를 제공합니다. 진행을 위해 &lt;code&gt;VACUUM FULL&lt;/code&gt; 명령을 통해보고 &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; 모두 있기 때문에 &lt;code&gt;VACUUM FULL&lt;/code&gt; 와 &lt;code&gt;CLUSTER&lt;/code&gt; 가 테이블을 재 작성 규칙적인 반면, &lt;code&gt;VACUUM&lt;/code&gt; 유일한 장소에서 그것을 수정합니다. &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;섹션 27.4.3&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="48d664025546cdeafdfe0701b9fa38130d919c75" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; scans any part of a table, it will replace any multixact ID it encounters which is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;, an aggressive vacuum is forced. As discussed in the previous section, an aggressive vacuum means that only those pages which are known to be all-frozen will be skipped. &lt;code&gt;mxid_age()&lt;/code&gt; can be used on &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; to find its age.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 테이블의 일부를 스캔 할 때마다 &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; 보다 오래된 멀티 플렉스 ID를 다른 값으로 대체 합니다 (0 값, 단일 트랜잭션 ID 또는 최신 멀티 플렉스 ID). 각 테이블의 경우, &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relminmxid&lt;/code&gt; 는 해당 테이블의 튜플에 여전히 나타나는 가장 오래된 가능한 멀티 플렉스 ID를 저장합니다. 이 값이 &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt; 보다 오래된 경우 공격적인 진공이 발생합니다. 이전 섹션에서 설명한 바와 같이 공격적인 진공 상태는 완전히 고정 된 것으로 알려진 페이지 만 건너 뜁니다. &lt;code&gt;pg_class&lt;/code&gt; 에서 &lt;code&gt;mxid_age()&lt;/code&gt; 사용할 수 있습니다 . &lt;code&gt;relminmxid&lt;/code&gt; 나이를 찾기 위해.</target>
        </trans-unit>
        <trans-unit id="5f844cc225201cbe85cbdde3d905d07e347e61a8" translate="yes" xml:space="preserve">
          <source>Whenever PostgreSQL needs to combine rows from multiple sources into a single result set, it uses an &lt;code&gt;Append&lt;/code&gt; or &lt;code&gt;MergeAppend&lt;/code&gt; plan node. This commonly happens when implementing &lt;code&gt;UNION ALL&lt;/code&gt; or when scanning a partitioned table. Such nodes can be used in parallel plans just as they can in any other plan. However, in a parallel plan, the planner may instead use a &lt;code&gt;Parallel Append&lt;/code&gt; node.</source>
          <target state="translated">PostgreSQL은 여러 소스의 행을 단일 결과 집합으로 결합해야 할 때마다 &lt;code&gt;Append&lt;/code&gt; 또는 &lt;code&gt;MergeAppend&lt;/code&gt; 계획 노드를 사용합니다. 이는 일반적으로 &lt;code&gt;UNION ALL&lt;/code&gt; 을 구현 하거나 파티션 된 테이블을 스캔 할 때 발생 합니다. 이러한 노드는 다른 계획에서와 마찬가지로 병렬 계획에서 사용될 수 있습니다. 그러나 병렬 계획에서 플래너는 대신 &lt;code&gt;Parallel Append&lt;/code&gt; 노드 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85e82d59ea38cfaea7777dbbbcc2b327247984a8" translate="yes" xml:space="preserve">
          <source>Whenever a command is executed, psql also polls for asynchronous notification events generated by &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;.</source>
          <target state="translated">명령이 실행될 때마다 psql은 &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; 및 &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY에&lt;/a&gt; 의해 생성 된 비동기 알림 이벤트를 폴링합니다 .</target>
        </trans-unit>
        <trans-unit id="fe283c15f98e1d6878cfeeadd5bbfd6c5078c552" translate="yes" xml:space="preserve">
          <source>Whenever a user-defined type is created, PostgreSQL automatically creates an associated array type, whose name consists of the element type's name prepended with an underscore, and truncated if necessary to keep it less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long. (If the name so generated collides with an existing type name, the process is repeated until a non-colliding name is found.) This implicitly-created array type is variable length and uses the built-in input and output functions &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. The array type tracks any changes in its element type's owner or schema, and is dropped if the element type is.</source>
          <target state="translated">사용자 정의 형식이 생성 될 때마다 PostgreSQL은 연관된 배열 형식을 자동으로 생성합니다.이 형식의 이름은 밑줄이 앞에 붙은 요소 형식의 이름으로 구성되며 필요한 경우 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 바이트 보다 작게 유지해야합니다 . 생성 된 이름이 기존 유형 이름과 충돌하는 경우 충돌하지 않는 이름을 찾을 때까지 프로세스가 반복됩니다. 암시 적으로 생성 된이 배열 유형은 가변 길이이며 내장 입력 및 출력 함수 &lt;code&gt;array_in&lt;/code&gt; 및 &lt;code&gt;array_out&lt;/code&gt; 을 사용 합니다. 배열 유형은 요소 유형 소유자 또는 스키마의 모든 변경 사항을 추적하고 요소 유형 인 경우 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c317e2f18ac74c5065186374d831c55658598512" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by a single backend, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;0&lt;/code&gt;, i.e., no forced writeback. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the maximum value scales proportionally to it.)</source>
          <target state="translated">단일 백엔드가이 양보다 많은 양의 데이터를 기록 할 때마다 OS가 기본 스토리지에 이러한 쓰기를 실행하도록합니다. 이렇게하면 커널의 페이지 캐시에있는 더티 데이터의 양이 제한되어 검사 점이 끝날 때 &lt;code&gt;fsync&lt;/code&gt; 가 발행되거나 OS가 백그라운드에서 더 큰 배치로 데이터를 다시 쓸 때 중단 될 가능성이 줄어 듭니다 . 종종 트랜잭션 대기 시간이 크게 줄어드는 경우가 있지만 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 보다 크지 만 성능이 저하 될 수있는 OS의 페이지 캐시보다 작은 워크로드의 경우도 있습니다. 이 설정은 일부 플랫폼에 영향을 미치지 않을 수 있습니다. 이 값을 단위없이 지정하면 블록으로 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트, 일반적으로 8kB 유효한 범위는 &lt;code&gt;0&lt;/code&gt; 이며 강제 쓰기 저장을 사용하지 않으며 &lt;code&gt;2MB&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다 . 즉 강제 쓰기 저장이 없습니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8kB가 아닌 경우 최대 값은 비례 적으로 비례합니다.)</target>
        </trans-unit>
        <trans-unit id="de89b6016c756123d6b9441e22d55848a32a9ab3" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;512kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">백그라운드 작성기가 이보다 많은 양의 데이터를 쓸 때마다 OS가 기본 쓰기 저장소에 이러한 쓰기를 실행하도록합니다. 이렇게하면 커널의 페이지 캐시에있는 더티 데이터의 양이 제한되어 검사 점이 끝날 때 &lt;code&gt;fsync&lt;/code&gt; 가 발행되거나 OS가 백그라운드에서 더 큰 배치로 데이터를 다시 쓸 때 중단 될 가능성이 줄어 듭니다 . 종종 트랜잭션 대기 시간이 크게 줄어드는 경우가 있지만 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 보다 크지 만 성능이 저하 될 수있는 OS의 페이지 캐시보다 작은 워크로드의 경우도 있습니다. 이 설정은 일부 플랫폼에 영향을 미치지 않을 수 있습니다. 이 값을 단위없이 지정하면 블록으로 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트, 일반적으로 8kB 유효한 범위는 &lt;code&gt;0&lt;/code&gt; 이며 강제 쓰기 저장을 사용하지 않으며 &lt;code&gt;2MB&lt;/code&gt; 입니다. 기본값은 Linux에서 &lt;code&gt;512kB&lt;/code&gt; 이고 다른 곳 에서는 &lt;code&gt;0&lt;/code&gt; 입니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8kB가 아닌 경우 기본값과 최대 값이 비례 적으로 조정됩니다.)이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 행 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41035af23763d236bc43d7713084261d3a812120" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written while performing a checkpoint, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of the checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;256kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">검사 점을 수행하는 동안 이보다 많은 양의 데이터가 기록 될 때마다 OS가 기본 쓰기 저장소에 이러한 쓰기를 실행하도록합니다. 이렇게하면 커널의 페이지 캐시에서 더티 데이터의 양이 제한되어 검사 점 끝에서 &lt;code&gt;fsync&lt;/code&gt; 가 발행되거나 OS가 백그라운드에서 더 큰 배치로 데이터를 다시 쓸 때 중단 될 가능성이 줄어 듭니다 . 종종 트랜잭션 대기 시간이 크게 줄어드는 경우가 있지만 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 보다 크지 만 성능이 저하 될 수있는 OS의 페이지 캐시보다 작은 워크로드의 경우도 있습니다. 이 설정은 일부 플랫폼에 영향을 미치지 않을 수 있습니다. 이 값을 단위없이 지정하면 블록으로 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트, 일반적으로 8kB 유효한 범위는 &lt;code&gt;0&lt;/code&gt; 이며 강제 쓰기 저장을 사용하지 않으며 &lt;code&gt;2MB&lt;/code&gt; 입니다. 기본값은 Linux에서 &lt;code&gt;256kB&lt;/code&gt; 이고 다른 곳 에서는 &lt;code&gt;0&lt;/code&gt; 입니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8kB가 아닌 경우 기본값과 최대 값이 비례 적으로 조정됩니다.)이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 행 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cafdfe0e40c272ef5695922c2a975f51df9e1cea" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;pattern&lt;/code&gt; parameter is omitted completely, the &lt;code&gt;\d&lt;/code&gt; commands display all objects that are visible in the current schema search path &amp;mdash; this is equivalent to using &lt;code&gt;*&lt;/code&gt; as the pattern. (An object is said to be &lt;em&gt;visible&lt;/em&gt; if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use &lt;code&gt;*.*&lt;/code&gt; as the pattern.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 매개 변수가 완전히 생략 될 때마다 &lt;code&gt;\d&lt;/code&gt; 명령은 현재 스키마 검색 경로에 보이는 모든 오브젝트를 표시합니다 . 이는 &lt;code&gt;*&lt;/code&gt; 를 패턴 으로 사용하는 것과 같습니다 . (객체가 될 수라고 &lt;em&gt;볼 수&lt;/em&gt; 는 포함 스키마가 검색 경로에 동일한 종류와 이름의 객체가 검색 경로에서 이전에 나타납니다없는 경우.이 객체가 명시 적 스키마없이 이름으로 참조 할 수있는 문에 해당 가시성에 관계없이 데이터베이스의 모든 오브젝트를 보려면 패턴으로 &lt;code&gt;*.*&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2dffd7d6d50f37b1f139649fc2afe46f33411c06" translate="yes" xml:space="preserve">
          <source>Whenever the command &lt;code&gt;NOTIFY channel&lt;/code&gt; is invoked, either by this session or another one connected to the same database, all the sessions currently listening on that notification channel are notified, and each will in turn notify its connected client application.</source>
          <target state="translated">이 세션 또는 동일한 데이터베이스에 연결된 다른 세션에서 &lt;code&gt;NOTIFY channel&lt;/code&gt; 명령을 호출 할 때마다 해당 알림 채널에서 현재 수신 대기중인 모든 세션에 알림이 표시되고 각 세션은 연결된 클라이언트 응용 프로그램에 알립니다.</target>
        </trans-unit>
        <trans-unit id="464c9a84b9274c416e8217076cf62d6ce77919b2" translate="yes" xml:space="preserve">
          <source>Whenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. This only happens at login time; executing &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; or &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; does not cause new configuration values to be set. Settings set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.</source>
          <target state="translated">이후에 역할이 새 세션을 시작할 때마다 지정된 값이 세션 기본값이되어 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 있거나 &lt;code&gt;postgres&lt;/code&gt; 명령 줄 에서받은 설정을 무시 합니다. 이것은 로그인시에만 발생합니다. &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 또는 &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION을&lt;/a&gt; 실행 해도 새로운 구성 값이 설정되지 않습니다. 모든 데이터베이스에 대해 설정된 설정은 역할에 연결된 데이터베이스 별 설정으로 대체됩니다. 특정 데이터베이스 또는 특정 역할에 대한 설정이 모든 역할에 대한 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1cb07a399aec26555c15e193c16effe1e79f48af" translate="yes" xml:space="preserve">
          <source>Whenever you create a table, a composite type is also automatically created, with the same name as the table, to represent the table's row type. For example, had we said:</source>
          <target state="translated">테이블을 작성할 때마다 테이블의 행 유형을 나타 내기 위해 테이블과 동일한 이름으로 복합 유형도 자동으로 작성됩니다. 예를 들어 다음과 같이 말한 적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72417af150626f41547b564cc2af3102889d282f" translate="yes" xml:space="preserve">
          <source>Whenever you have significantly altered the distribution of data within a table, running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; is strongly recommended. This includes bulk loading large amounts of data into the table. Running &lt;code&gt;ANALYZE&lt;/code&gt; (or &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;) ensures that the planner has up-to-date statistics about the table. With no statistics or obsolete statistics, the planner might make poor decisions during query planning, leading to poor performance on any tables with inaccurate or nonexistent statistics. Note that if the autovacuum daemon is enabled, it might run &lt;code&gt;ANALYZE&lt;/code&gt; automatically; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">테이블 내에서 데이터 분포를 크게 변경 한 경우에는 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE를&lt;/a&gt; 실행 하는 것이 좋습니다. 여기에는 대량의 데이터를 테이블에 대량로드하는 것이 포함됩니다. &lt;code&gt;ANALYZE&lt;/code&gt; (또는 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; )를 실행 하면 플래너가 테이블에 대한 최신 통계를 갖습니다. 통계가 없거나 사용되지 않는 통계가 없으면 플래너는 쿼리 계획 중에 의사 결정을 잘못하여 통계가 부정확하거나 존재하지 않는 테이블에서 성능이 저하 될 수 있습니다. autovacuum 데몬이 활성화되면 &lt;code&gt;ANALYZE&lt;/code&gt; 가 자동으로 실행될 수 있습니다 . 참조 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;섹션 24.1.3&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6을&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="70267c330cb08a0ff5a2a298e316262a59a144c4" translate="yes" xml:space="preserve">
          <source>Where interoperability with other systems is a concern, for some data types, it may be necessary to use data type formatting functions (such as those in &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) explicitly to produce the standard mappings.</source>
          <target state="translated">다른 시스템과의 상호 운용성이 중요한 경우, 일부 데이터 유형의 경우 표준 맵핑을 생성하기 위해 명시 적으로 데이터 유형 형식화 기능 (예 : &lt;a href=&quot;functions-formatting&quot;&gt;섹션 9.8&lt;/a&gt; ) 을 사용해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de87765a2f74958f3598da9f1ae5cd4df124304a" translate="yes" xml:space="preserve">
          <source>Where the command omits database name, user, host, or port, the new connection can reuse values from the previous connection. By default, values from the previous connection are reused except when processing a &lt;code&gt;conninfo&lt;/code&gt; string. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. When the command neither specifies nor reuses a particular parameter, the libpq default is used. Specifying any of &lt;code&gt;dbname&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter. If &lt;code&gt;hostaddr&lt;/code&gt; was specified in the original connection's &lt;code&gt;conninfo&lt;/code&gt;, that address is reused for the new connection (disregarding any other host specification).</source>
          <target state="translated">명령이 데이터베이스 이름, 사용자, 호스트 또는 포트를 생략하면 새 연결은 이전 연결의 값을 재사용 할 수 있습니다. 기본적으로 &lt;code&gt;conninfo&lt;/code&gt; 문자열을 처리 할 때를 제외하고 이전 연결의 값이 재사용됩니다 . &lt;code&gt;-reuse-previous=on&lt;/code&gt; 또는 &lt;code&gt;-reuse-previous=off&lt;/code&gt; 의 첫 번째 인수를 전달하면 해당 기본값이 무시됩니다. 명령이 특정 매개 변수를 지정하거나 재사용하지 않으면 libpq 기본값이 사용됩니다. &lt;code&gt;dbname&lt;/code&gt; , &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;host&lt;/code&gt; 또는 &lt;code&gt;port&lt;/code&gt; 를 &lt;code&gt;-&lt;/code&gt; 로 지정하는 것은 해당 매개 변수를 생략하는 것과 같습니다. 원래 연결의 &lt;code&gt;conninfo&lt;/code&gt; 에 &lt;code&gt;hostaddr&lt;/code&gt; 이 지정된 경우이 주소는 다른 호스트 사양을 무시하고 새 연결에 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b1968453a400f5fd07425f7b52ed24d9c6b52b" translate="yes" xml:space="preserve">
          <source>Where the current standard provides a family of XML data types to hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo; in untyped or XML Schema-typed variants, and a type &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; to hold arbitrary pieces of XML content, PostgreSQL provides the single &lt;code&gt;xml&lt;/code&gt; type, which can hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo;. There is no equivalent of the standard's &amp;ldquo;sequence&amp;rdquo; type.</source>
          <target state="translated">현재 표준이 유형이 지정되지 않은 XML 스키마 유형 변형에서 &quot;문서&quot;또는 &quot;콘텐츠&quot;를 보유하는 XML 데이터 유형 군을 제공하고 임의의 XML 컨텐츠를 보유하는 &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; 유형을 제공하는 경우 PostgreSQL은 단일 &lt;code&gt;xml&lt;/code&gt; 유형을 제공합니다. '문서'또는 '콘텐츠'를 보유 할 수 있습니다. 표준의 &quot;시퀀스&quot;유형과 동등한 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9be0ce89e49423198dedc7c03fd710b9a77c7468" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;pgstattuple&lt;/code&gt; always performs a full-table scan and returns an exact count of live and dead tuples (and their sizes) and free space, &lt;code&gt;pgstattuple_approx&lt;/code&gt; tries to avoid the full-table scan and returns exact dead tuple statistics along with an approximation of the number and size of live tuples and free space.</source>
          <target state="translated">반면 &lt;code&gt;pgstattuple&lt;/code&gt; 은 항상 전체 테이블을 스캔 및 반품 라이브와 죽은 튜플 (및 크기)의 정확한 수와 여유 공간을 수행 &lt;code&gt;pgstattuple_approx&lt;/code&gt; 의 시도는 스캔 전체 테이블을 피하기 위해 반환 숫자의 근사치와 함께 죽은 튜플 통계를 정확한 라이브 튜플과 여유 공간의 크기.</target>
        </trans-unit>
        <trans-unit id="9ec341d8bc6b0b4825eb80f0ff91c4f3ae8eee3b" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;aggfinalfn&lt;/code&gt; modifies the transition state value: &lt;code&gt;r&lt;/code&gt; if it is read-only, &lt;code&gt;s&lt;/code&gt; if the &lt;code&gt;aggtransfn&lt;/code&gt; cannot be applied after the &lt;code&gt;aggfinalfn&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; if it writes on the value</source>
          <target state="translated">&lt;code&gt;aggfinalfn&lt;/code&gt; 이 전이 상태 값을 수정 하는지 여부 : &lt;code&gt;r&lt;/code&gt; 읽기 전용 인 경우 &lt;code&gt;s&lt;/code&gt; &lt;code&gt;aggtransfn&lt;/code&gt; 이후에 &lt;code&gt;aggfinalfn&lt;/code&gt; 적용 할 수없는 경우 s 또는 값을 쓰는 경우 &lt;code&gt;w&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b63ddfd6a1548ba35d00a888f441158a5e09419b" translate="yes" xml:space="preserve">
          <source>Whether an RE is greedy or not is determined by the following rules:</source>
          <target state="translated">RE가 욕심인지 아닌지는 다음 규칙에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="a052d21cc109877e0a34f6fceb8177147b8e054e" translate="yes" xml:space="preserve">
          <source>Whether the sequence cycles</source>
          <target state="translated">시퀀스 사이클 여부</target>
        </trans-unit>
        <trans-unit id="099ca603e257bb42c8d0080a36e8a200732df4c1" translate="yes" xml:space="preserve">
          <source>Whether to convert &lt;code&gt;\n&lt;/code&gt; into &lt;code&gt;\r\n&lt;/code&gt; when encrypting and &lt;code&gt;\r\n&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; when decrypting. RFC 4880 specifies that text data should be stored using &lt;code&gt;\r\n&lt;/code&gt; line-feeds. Use this to get fully RFC-compliant behavior.</source>
          <target state="translated">암호화 할 때 &lt;code&gt;\n&lt;/code&gt; 을 &lt;code&gt;\r\n&lt;/code&gt; \ n 으로 변환 하고 해독 할 때 &lt;code&gt;\r\n&lt;/code&gt; 을 &lt;code&gt;\n&lt;/code&gt; 으로 변환할지 여부 . RFC 4880은 &lt;code&gt;\r\n&lt;/code&gt; 줄 바꿈을 사용하여 텍스트 데이터를 저장하도록 지정합니다 . 이를 사용하여 RFC를 완벽하게 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="6a913bec72a9d1cd9190d3ca3274a90d4c381b09" translate="yes" xml:space="preserve">
          <source>Whether to convert textual data from database internal encoding to UTF-8 and back. If your database already is UTF-8, no conversion will be done, but the message will be tagged as UTF-8. Without this option it will not be.</source>
          <target state="translated">데이터베이스 내부 인코딩에서 UTF-8로 텍스트 데이터를 변환할지 여부. 데이터베이스가 이미 UTF-8 인 경우 변환이 수행되지 않지만 메시지는 UTF-8로 태그 지정됩니다. 이 옵션이 없으면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d0908bbd26e431175b3928caa067e2b55410af7" translate="yes" xml:space="preserve">
          <source>Which S2K algorithm to use.</source>
          <target state="translated">사용할 S2K 알고리즘</target>
        </trans-unit>
        <trans-unit id="1b435ac17c99f4ed78933b5d05d5b47d3dfdd820" translate="yes" xml:space="preserve">
          <source>Which cipher algorithm to use.</source>
          <target state="translated">사용할 암호 알고리즘</target>
        </trans-unit>
        <trans-unit id="4215d6c5a786cf08cc1b93732554ac25c2ba7716" translate="yes" xml:space="preserve">
          <source>Which cipher to use for encrypting separate session key.</source>
          <target state="translated">별도의 세션 키를 암호화하는 데 사용할 암호</target>
        </trans-unit>
        <trans-unit id="8c9643312802b96a36d211d4bd8a2d4fbec5df7d" translate="yes" xml:space="preserve">
          <source>Which compression algorithm to use. Only available if PostgreSQL was built with zlib.</source>
          <target state="translated">사용할 압축 알고리즘. PostgreSQL이 zlib로 빌드 된 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36178694d36e0d8b9b4d6953d14f4cb84f698946" translate="yes" xml:space="preserve">
          <source>Which digest algorithm to use in S2K calculation.</source>
          <target state="translated">S2K 계산에 사용할 다이제스트 알고리즘</target>
        </trans-unit>
        <trans-unit id="5b9d8c9d7eb5636216a755086b48fa5a8cd067ff" translate="yes" xml:space="preserve">
          <source>Which one of these you use is mainly a matter of style. The &lt;code&gt;JOIN&lt;/code&gt; syntax in the &lt;code&gt;FROM&lt;/code&gt; clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the &lt;code&gt;FROM&lt;/code&gt; clause. The &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause of an outer join is &lt;em&gt;not&lt;/em&gt; equivalent to a &lt;code&gt;WHERE&lt;/code&gt; condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result.</source>
          <target state="translated">이 중 어느 것을 사용 하느냐는 주로 스타일의 문제입니다. (가) &lt;code&gt;JOIN&lt;/code&gt; 에서 구문을 &lt;code&gt;FROM&lt;/code&gt; 절하면이 SQL 표준에 경우에도 아마 다른 SQL 데이터베이스 관리 시스템으로 이식 할 수 없습니다. 외부 조인의 경우 선택의 여지가 없습니다 . &lt;code&gt;FROM&lt;/code&gt; 절 에서 수행해야합니다 . 외부 조인 의 &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;USING&lt;/code&gt; 절은 &lt;code&gt;WHERE&lt;/code&gt; 조건 과 동일 &lt;em&gt;하지 않습니다.&lt;/em&gt; 결과 가 &lt;em&gt;일치하지&lt;/em&gt; 않는 입력 행의 경우 행이 추가되고 최종 결과에서 행이 제거되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f207dff92fd241726ec3f780d5ff085d75648337" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="translated">존재하는 특정 연산자와 단항인지 이진인지는 시스템이나 사용자가 정의한 연산자에 따라 다릅니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장&lt;/a&gt; 에서는 내장 연산자에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8189028b5d12d59cd50147d702e5a513253a68c3" translate="yes" xml:space="preserve">
          <source>Which row(s) to update</source>
          <target state="translated">업데이트 할 행</target>
        </trans-unit>
        <trans-unit id="a8a5e55dc1620d200691892efc7a7c676cbd8264" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CREATE INDEX&lt;/code&gt; with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션이 있는 &lt;code&gt;CREATE INDEX&lt;/code&gt; 는 특별한 제한없이 병렬 빌드를 지원 하지만 실제로 첫 번째 테이블 스캔 만 병렬로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="714b73638a1ef948dee8dfe7820683df70955357" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;UNIQUE&lt;/code&gt; is a natural constraint for scalar values, it is usually unsuitable for range types. Instead, an exclusion constraint is often more appropriate (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt;). Exclusion constraints allow the specification of constraints such as &amp;ldquo;non-overlapping&amp;rdquo; on a range type. For example:</source>
          <target state="translated">반면 &lt;code&gt;UNIQUE&lt;/code&gt; 은 스칼라 값의 자연 제약, 그것은 다양한 유형 통상 부적합하다. 대신, 제외 제약 조건이 종종 더 적합합니다 ( &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE 참조&lt;/a&gt; ). 제외 제약 조건을 사용하면 범위 유형에 &quot;비 중복&quot;과 같은 제약 조건을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a9577e86cf0dfccc12f0ecf60188a3b6040e454" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;pg_resetwal&lt;/code&gt; will set the WAL starting address beyond the latest existing WAL segment file, some segment size changes can cause previous WAL file names to be reused. It is recommended to use &lt;code&gt;-l&lt;/code&gt; together with this option to manually set the WAL starting address if WAL file name overlap will cause problems with your archiving strategy.</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; 은 기존의 최신 WAL 세그먼트 파일을 넘어 WAL 시작 주소를 설정 하지만 일부 세그먼트 크기 변경으로 인해 이전 WAL 파일 이름이 재사용 될 수 있습니다. WAL 파일 이름이 겹치면 아카이브 전략에 문제가 발생할 경우이 옵션과 함께 &lt;code&gt;-l&lt;/code&gt; 을 사용 하여 WAL 시작 주소를 수동으로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="01708a73847573f321d3d2da0f455cb9f949df75" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;to_date&lt;/code&gt; will reject a mixture of Gregorian and ISO week-numbering date fields, &lt;code&gt;to_char&lt;/code&gt; will not, since output format specifications like &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; can be useful. But avoid writing something like &lt;code&gt;IYYY-MM-DD&lt;/code&gt;; that would yield surprising results near the start of the year. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt; for more information.)</source>
          <target state="translated">&lt;code&gt;to_date&lt;/code&gt; 는 Gregorian과 ISO 주 번호 매기기 날짜 필드의 혼합을 거부 하지만 &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; 와 같은 출력 형식 사양 이 유용 할 수 있으므로 &lt;code&gt;to_char&lt;/code&gt; 는 그렇지 않습니다 . 그러나 &lt;code&gt;IYYY-MM-DD&lt;/code&gt; 와 같은 것을 쓰지 마십시오 . 그것은 연초에 놀라운 결과를 낳을 것입니다. (자세한 내용 &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;은 9.9.1 절&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e362e9f328b5aa2d887a4c59191ea1b7f9721dc4" translate="yes" xml:space="preserve">
          <source>While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql.</source>
          <target state="translated">C 스타일 블록 주석은 처리 및 제거를 위해 서버로 전달되지만 SQL 표준 주석은 psql에 의해 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5d725442e0975d9459afb2abfae7302730928d6f" translate="yes" xml:space="preserve">
          <source>While PostgreSQL's Serializable transaction isolation level only allows concurrent transactions to commit if it can prove there is a serial order of execution that would produce the same effect, it doesn't always prevent errors from being raised that would not occur in true serial execution. In particular, it is possible to see unique constraint violations caused by conflicts with overlapping Serializable transactions even after explicitly checking that the key isn't present before attempting to insert it. This can be avoided by making sure that &lt;em&gt;all&lt;/em&gt; Serializable transactions that insert potentially conflicting keys explicitly check if they can do so first. For example, imagine an application that asks the user for a new key and then checks that it doesn't exist already by trying to select it first, or generates a new key by selecting the maximum existing key and adding one. If some Serializable transactions insert new keys directly without following this protocol, unique constraints violations might be reported even in cases where they could not occur in a serial execution of the concurrent transactions.</source>
          <target state="translated">PostgreSQL의 Serializable 트랜잭션 격리 수준은 동일한 효과를 생성하는 일련의 실행 순서가 있음을 증명할 수있는 경우 동시 트랜잭션 만 커밋 할 수 있지만 실제 직렬 실행에서는 발생하지 않는 오류가 발생하는 것을 항상 막지는 않습니다. 특히, 키를 삽입하기 전에 키가 존재하지 않는지 명시 적으로 확인한 후에도 겹치는 직렬화 가능 트랜잭션과의 충돌로 인한 고유 제한 조건 위반을 볼 수 있습니다. 이것은 &lt;em&gt;모든&lt;/em&gt; 것을 확인함으로써 피할 수 있습니다&lt;em&gt;&lt;/em&gt;충돌 가능성이있는 키를 삽입하는 직렬화 가능 트랜잭션은 먼저 수행 할 수 있는지 명시 적으로 확인합니다. 예를 들어, 사용자에게 새 키를 요청한 다음 먼저 키를 선택하여 존재하지 않는지 확인하거나 기존의 최대 키를 선택하고 추가하여 새 키를 생성하는 응용 프로그램을 상상해보십시오. 일부 직렬화 가능 트랜잭션이이 프로토콜을 따르지 않고 직접 새 키를 삽입하는 경우 동시 트랜잭션의 직렬 실행에서 발생할 수없는 경우에도 고유 제한 조건 위반이보고 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594dab457c5441b59c42227020751df6f6f62a48" translate="yes" xml:space="preserve">
          <source>While XQuery/XPath provides all of the types defined in XML Schema and many operators and functions over those types, XPath 1.0 has only node-sets and the three atomic types &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">XQuery / XPath는 XML 스키마에 정의 된 모든 유형과 해당 유형에 대한 많은 연산자 및 함수를 제공하지만 XPath 1.0에는 노드 세트와 3 개의 원자 유형 &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a627fd0ca096f765ec57a0f53e97d18839b3a4e" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;LIKE&lt;/code&gt; clause exists in the SQL standard, many of the options that PostgreSQL accepts for it are not in the standard, and some of the standard's options are not implemented by PostgreSQL.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 절이 SQL 표준에 존재 하지만 PostgreSQL이이를 수락하는 많은 옵션은 표준이 아니며 일부 표준 옵션은 PostgreSQL에 의해 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcdd2fd3f430f1ca01d2b3670c0f594bdee786bb" translate="yes" xml:space="preserve">
          <source>While a Repeatable Read transaction has a stable view of the data throughout its execution, there is a subtle issue with using MVCC snapshots for data consistency checks, involving something known as &lt;em&gt;read/write conflicts&lt;/em&gt;. If one transaction writes data and a concurrent transaction attempts to read the same data (whether before or after the write), it cannot see the work of the other transaction. The reader then appears to have executed first regardless of which started first or which committed first. If that is as far as it goes, there is no problem, but if the reader also writes data which is read by a concurrent transaction there is now a transaction which appears to have run before either of the previously mentioned transactions. If the transaction which appears to have executed last actually commits first, it is very easy for a cycle to appear in a graph of the order of execution of the transactions. When such a cycle appears, integrity checks will not work correctly without some help.</source>
          <target state="translated">반복 가능한 읽기 트랜잭션은 실행 전체에서 데이터를 안정적으로 볼 수 있지만 &lt;em&gt;읽기 / 쓰기 충돌&lt;/em&gt; 로 알려진 데이터 일관성 검사를 위해 MVCC 스냅 샷을 사용하는 데 미묘한 문제가 &lt;em&gt;있습니다.&lt;/em&gt;. 한 트랜잭션이 데이터를 쓰고 동시 트랜잭션이 같은 데이터를 쓰려고 시도하는 경우 (쓰기 전 또는 후에) 다른 트랜잭션의 작업을 볼 수 없습니다. 그런 다음 독자가 어느 것이 먼저 시작했는지 또는 어느 것이 먼저 커밋되었는지에 관계없이 먼저 실행 한 것으로 보입니다. 그것이 가능한 한 문제는 없지만 독자가 동시 트랜잭션에서 읽은 데이터를 쓰면 이전에 언급 된 트랜잭션 중 하나보다 먼저 실행 된 트랜잭션이있는 것입니다. 마지막으로 실행 된 것으로 보이는 트랜잭션이 실제로 먼저 커밋되면 트랜잭션 실행 순서의 그래프에주기가 나타나는 것이 매우 쉽습니다. 이러한주기가 나타나면 도움이 없으면 무결성 검사가 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a87fa7f9afe44920c1e825c81201c0429df3a1c" translate="yes" xml:space="preserve">
          <source>While a self-signed certificate can be used for testing, a certificate signed by a certificate authority (CA) (usually an enterprise-wide root CA) should be used in production.</source>
          <target state="translated">자체 서명 된 인증서를 사용하여 테스트 할 수 있지만 인증 기관 (CA) (일반적으로 전사적 루트 CA)이 서명 한 인증서를 프로덕션에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cdc31b216171332e350cb9df34dfb0418ab3630e" translate="yes" xml:space="preserve">
          <source>While designing your archiving setup, consider what will happen if the archive command fails repeatedly because some aspect requires operator intervention or the archive runs out of space. For example, this could occur if you write to tape without an autochanger; when the tape fills, nothing further can be archived until the tape is swapped. You should ensure that any error condition or request to a human operator is reported appropriately so that the situation can be resolved reasonably quickly. The &lt;code&gt;pg_wal/&lt;/code&gt; directory will continue to fill with WAL segment files until the situation is resolved. (If the file system containing &lt;code&gt;pg_wal/&lt;/code&gt; fills up, PostgreSQL will do a PANIC shutdown. No committed transactions will be lost, but the database will remain offline until you free some space.)</source>
          <target state="translated">보관 설정을 설계하는 동안 운영자의 개입이 필요하거나 보관 공간이 부족하여 보관 명령이 반복적으로 실패하면 어떻게되는지 고려하십시오. 예를 들어, Autochanger없이 테이프에 쓰면이 문제가 발생할 수 있습니다. 테이프가 가득 차면 테이프를 교체 할 때까지 더 이상 아카이브 할 수 없습니다. 상황이 합리적으로 신속하게 해결 될 수 있도록 오류 조건이나 작업자에게 요청한 내용이 적절하게보고되도록해야합니다. &lt;code&gt;pg_wal/&lt;/code&gt; 디렉토리는 상황이 해결 될 때까지 WAL 세그먼트 파일을 채울 것입니다. ( &lt;code&gt;pg_wal/&lt;/code&gt; 포함하는 파일 시스템이 가득 차면 PostgreSQL은 PANIC 종료를 수행합니다. 커밋 된 트랜잭션은 손실되지 않지만 공간을 확보 할 때까지 데이터베이스는 오프라인 상태를 유지합니다.)</target>
        </trans-unit>
        <trans-unit id="ed48d255fcc854a30e92ea66bfc2714ea9b2abf4" translate="yes" xml:space="preserve">
          <source>While forcing data to the disk platters periodically might seem like a simple operation, it is not. Because disk drives are dramatically slower than main memory and CPUs, several layers of caching exist between the computer's main memory and the disk platters. First, there is the operating system's buffer cache, which caches frequently requested disk blocks and combines disk writes. Fortunately, all operating systems give applications a way to force writes from the buffer cache to disk, and PostgreSQL uses those features. (See the &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; parameter to adjust how this is done.)</source>
          <target state="translated">디스크 플래터에 데이터를 주기적으로 강제하는 것은 간단한 작업처럼 보이지만 그렇지 않습니다. 디스크 드라이브는 주 메모리 및 CPU보다 속도가 매우 느리기 때문에 컴퓨터의 주 메모리와 디스크 플래터 사이에 여러 계층의 캐싱이 있습니다. 첫째, 자주 요청되는 디스크 블록을 캐시하고 디스크 쓰기를 결합하는 운영 체제의 버퍼 캐시가 있습니다. 다행히 모든 운영 체제는 응용 프로그램에 버퍼 캐시에서 디스크로의 쓰기를 강제 할 수있는 방법을 제공하며 PostgreSQL은 이러한 기능을 사용합니다. 이 방법을 조정 하려면 &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; 매개 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae2f9725af5b866105aef02d826c3c21674b82a5" translate="yes" xml:space="preserve">
          <source>While it is possible to obtain information about which processes block which other processes by joining &lt;code&gt;pg_locks&lt;/code&gt; against itself, this is very difficult to get right in detail. Such a query would have to encode knowledge about which lock modes conflict with which others. Worse, the &lt;code&gt;pg_locks&lt;/code&gt; view does not expose information about which processes are ahead of which others in lock wait queues, nor information about which processes are parallel workers running on behalf of which other client sessions. It is better to use the &lt;code&gt;pg_blocking_pids()&lt;/code&gt; function (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;Table 9.63&lt;/a&gt;) to identify which process(es) a waiting process is blocked behind.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; 를 자신과 결합하여 어떤 프로세스가 어떤 프로세스를 차단하는지에 대한 정보를 얻을 수는 있지만 ,이를 자세히 이해하기는 매우 어렵습니다. 이러한 쿼리는 어떤 잠금 모드가 다른 잠금 모드와 충돌하는지에 대한 지식을 인코딩해야합니다. 더 나쁜 것은 &lt;code&gt;pg_locks&lt;/code&gt; 뷰는 어떤 프로세스가 잠금 대기 큐에서 다른 프로세스보다 앞선 정보인지, 어떤 프로세스가 다른 클라이언트 세션을 대신하여 실행중인 병렬 작업자인지에 대한 정보를 노출시키지 않습니다. 그것은 사용하는 것이 좋습니다 &lt;code&gt;pg_blocking_pids()&lt;/code&gt; 함수 (참조 &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;표 9.63을&lt;/a&gt; 대기 프로세스가 뒤에 차단되는 과정 (들)을 식별하기 위해).</target>
        </trans-unit>
        <trans-unit id="17d114999ab92dc3c41f0deae7314e26f77d91d6" translate="yes" xml:space="preserve">
          <source>While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout.</source>
          <target state="translated">대부분의 정규 표현식 검색을 매우 빠르게 실행할 수 있지만 처리하는 데 임의의 시간과 메모리가 필요한 정규 표현식을 고려할 수 있습니다. 적대적인 소스로부터 정규식 검색 패턴을 받아들이는 것에주의하십시오. 그렇게해야하는 경우, 명령문 시간 종료를 적용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4544bbaee7531ef45a0e42c59e09a0908293364f" translate="yes" xml:space="preserve">
          <source>While most timezone abbreviations represent fixed offsets from UTC, there are some that have historically varied in value (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt; for more information). In such cases this view presents their current meaning.</source>
          <target state="translated">대부분의 시간대 약어는 UTC와의 고정 오프셋을 나타내지 만 역사적으로 값이 다른 것이 있습니다 ( 자세한 내용 은 &lt;a href=&quot;datetime-config-files&quot;&gt;섹션 B.4&lt;/a&gt; 참조 ). 이러한 경우이보기는 현재 의미를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="64e20acb9a4d1b2d1994838c4133180e7c30312a" translate="yes" xml:space="preserve">
          <source>While not required, it is recommended that you continue to follow this old convention of naming cast implementation functions after the target data type. Many users are used to being able to cast data types using a function-style notation, that is &lt;code&gt;typename&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;). This notation is in fact nothing more nor less than a call of the cast implementation function; it is not specially treated as a cast. If your conversion functions are not named to support this convention then you will have surprised users. Since PostgreSQL allows overloading of the same function name with different argument types, there is no difficulty in having multiple conversion functions from different types that all use the target type's name.</source>
          <target state="translated">필수는 아니지만 대상 데이터 유형 뒤에이 캐스트 구현 기능의 기존 규칙을 계속 따르는 것이 좋습니다. 많은 사용자가 함수 스타일 표기법, 즉 &lt;code&gt;typename&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )을 사용하여 데이터 유형을 캐스트 할 수있었습니다 . 이 표기법은 실제로 캐스트 구현 함수의 호출에 지나지 않습니다. 특별히 캐스트로 취급되지 않습니다. 이 컨벤션을 지원하도록 변환 기능의 이름이 지정되지 않은 경우 사용자를 놀라게 할 것입니다. PostgreSQL은 인수 유형이 다른 동일한 함수 이름을 오버로드 할 수 있으므로 대상 유형의 이름을 모두 사용하는 다른 유형의 여러 변환 함수를 사용하는 데 어려움이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e3fedf4b54ce85919b4142394d398f5b611a696" translate="yes" xml:space="preserve">
          <source>While policies will be applied for explicit queries against tables in the database, they are not applied when the system is performing internal referential integrity checks or validating constraints. This means there are indirect ways to determine that a given value exists. An example of this is attempting to insert a duplicate value into a column that is a primary key or has a unique constraint. If the insert fails then the user can infer that the value already exists. (This example assumes that the user is permitted by policy to insert records which they are not allowed to see.) Another example is where a user is allowed to insert into a table which references another, otherwise hidden table. Existence can be determined by the user inserting values into the referencing table, where success would indicate that the value exists in the referenced table. These issues can be addressed by carefully crafting policies to prevent users from being able to insert, delete, or update records at all which might possibly indicate a value they are not otherwise able to see, or by using generated values (e.g., surrogate keys) instead of keys with external meanings.</source>
          <target state="translated">데이터베이스의 테이블에 대한 명시 적 쿼리에는 정책이 적용되지만 시스템이 내부 참조 무결성 검사 또는 유효성 검사 제약 조건을 수행 할 때는 적용되지 않습니다. 이는 주어진 값이 존재하는지 확인하는 간접적 인 방법이 있음을 의미합니다. 이에 대한 예로는 기본 키이거나 고유 제한 조건이있는 열에 중복 값을 삽입하려고합니다. 삽입에 실패하면 사용자는 값이 이미 존재한다고 유추 할 수 있습니다. (이 예에서는 사용자가 볼 수없는 레코드를 삽입 할 수 있도록 정책에 의해 사용자가 허용된다고 가정합니다.) 다른 예는 사용자가 다른 숨겨진 테이블을 참조하는 테이블에 사용자를 삽입 할 수있는 위치입니다. 존재 여부는 사용자가 참조 테이블에 값을 삽입하여 결정할 수 있습니다.성공은 참조 된 테이블에 값이 존재 함을 나타냅니다. 이러한 문제는 사용자가 다른 방법으로는 볼 수없는 값을 나타내거나 생성 된 값 (예 : 대리 키)을 사용하여 레코드를 삽입, 삭제 또는 업데이트 할 수 없도록 정책을 신중하게 작성하여 해결할 수 있습니다. 외부 의미를 가진 키 대신.</target>
        </trans-unit>
        <trans-unit id="5fbe4c0896d37fe14f081d1ac25be59617f075b0" translate="yes" xml:space="preserve">
          <source>While recovery is paused no further database changes are applied. If in hot standby, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="translated">복구가 일시 정지 된 동안에는 추가 데이터베이스 변경 사항이 적용되지 않습니다. 상시 대기 상태 인 경우 모든 새 쿼리는 데이터베이스의 동일한 일관된 스냅 샷을보고 복구가 다시 시작될 때까지 더 이상 쿼리 충돌이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67bee53c255823e86d8c23b4190b410627254abc" translate="yes" xml:space="preserve">
          <source>While rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">행을 로컬 파티션에서 외부 테이블 파티션으로 이동할 수 있지만 (외부 데이터 랩퍼가 튜플 라우팅을 지원하는 경우) 외부 테이블 파티션에서 다른 파티션으로 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7158e641e335f398bdfc35c274f36a1760cfa0bc" translate="yes" xml:space="preserve">
          <source>While running pg_dump, one should examine the output for any warnings (printed on standard error), especially in light of the limitations listed below.</source>
          <target state="translated">pg_dump를 실행하는 동안, 특히 아래 나열된 제한 사항에 비추어 경고 (표준 오류로 인쇄)에 대한 출력을 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="891b0584891eb2794e238a1971ed31f1c215e841" translate="yes" xml:space="preserve">
          <source>While that doesn't look all that bad by itself, it's still oversimplified. A far more complicated sub-select would be needed to select the right OID if there are multiple tables named &lt;code&gt;mytable&lt;/code&gt; in different schemas. The &lt;code&gt;regclass&lt;/code&gt; input converter handles the table lookup according to the schema path setting, and so it does the &amp;ldquo;right thing&amp;rdquo; automatically. Similarly, casting a table's OID to &lt;code&gt;regclass&lt;/code&gt; is handy for symbolic display of a numeric OID.</source>
          <target state="translated">그 자체가 그렇게 나쁘게 보이지는 않지만 여전히 지나치게 단순화되어 있습니다. 다른 스키마에 &lt;code&gt;mytable&lt;/code&gt; 이라는 여러 테이블이있는 경우 올바른 OID를 선택하려면 훨씬 더 복잡한 하위 선택이 필요 합니다. &lt;code&gt;regclass&lt;/code&gt; 형의 입력 컨버터는 스키마 경로 설정에 따라 테이블 조회를 처리하고 자동으로 &quot;옳은 일&quot;않도록. 마찬가지로 테이블의 OID를 &lt;code&gt;regclass&lt;/code&gt; 로 캐스트하는 것은 숫자 OID의 기호 표시에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="d982cd814f64616912cda4d88166e9a69d28b85b" translate="yes" xml:space="preserve">
          <source>While that particular example might seem silly, related cases that don't obviously involve constants can occur in queries executed within functions, since the values of function arguments and local variables can be inserted into queries as constants for planning purposes. Within PL/pgSQL functions, for example, using an &lt;code&gt;IF&lt;/code&gt;-&lt;code&gt;THEN&lt;/code&gt;-&lt;code&gt;ELSE&lt;/code&gt; statement to protect a risky computation is much safer than just nesting it in a &lt;code&gt;CASE&lt;/code&gt; expression.</source>
          <target state="translated">이 특정 예제는 어리석은 것처럼 보일 수 있지만 함수 인수와 로컬 변수의 값은 계획 목적을 위해 상수로 쿼리에 삽입 될 수 있으므로 함수 내에서 실행되는 쿼리에서 분명히 상수를 포함하지 않는 관련 사례가 발생할 수 있습니다. 예를 들어 PL / pgSQL 함수 내에서 &lt;code&gt;IF&lt;/code&gt; - &lt;code&gt;THEN&lt;/code&gt; - &lt;code&gt;ELSE&lt;/code&gt; 문을 사용하여 위험한 계산을 보호하는 것은 &lt;code&gt;CASE&lt;/code&gt; 표현식 에 중첩시키는 것보다 훨씬 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="cfcd6cf6959e988635a363ac7fbe48c4622cc9ea" translate="yes" xml:space="preserve">
          <source>While the built-in declarative partitioning is suitable for most common use cases, there are some circumstances where a more flexible approach may be useful. Partitioning can be implemented using table inheritance, which allows for several features not supported by declarative partitioning, such as:</source>
          <target state="translated">내장 된 선언적 파티셔닝이 가장 일반적인 사용 사례에 적합하지만보다 유연한 접근 방식이 유용한 상황이 있습니다. 테이블 상속을 사용하여 파티셔닝을 구현할 수 있으며, 다음과 같은 선언적 파티셔닝에서 지원되지 않는 몇 가지 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f761cf19de1d987297c4bdb87e576a9e8ef5e265" translate="yes" xml:space="preserve">
          <source>While the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations is retained, &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; does not order the generated rows based on this property. If you want the data to be ordered upon generation, you must use an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the backing query.</source>
          <target state="translated">향후 &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 조작에 대한 기본 색인 은 유지되지만 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; 는이 특성을 기반으로 생성 된 행을 정렬하지 않습니다. 생성시 데이터를 정렬 하려면 백업 조회에서 &lt;code&gt;ORDER BY&lt;/code&gt; 절을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="89bb80c5dc369e5a7b8dcef839df901e5b397bf5" translate="yes" xml:space="preserve">
          <source>While the details of the new type's internal representation are only known to the I/O functions and other functions you create to work with the type, there are several properties of the internal representation that must be declared to PostgreSQL. Foremost of these is &lt;code&gt;internallength&lt;/code&gt;. Base data types can be fixed-length, in which case &lt;code&gt;internallength&lt;/code&gt; is a positive integer, or variable-length, indicated by setting &lt;code&gt;internallength&lt;/code&gt; to &lt;code&gt;VARIABLE&lt;/code&gt;. (Internally, this is represented by setting &lt;code&gt;typlen&lt;/code&gt; to -1.) The internal representation of all variable-length types must start with a 4-byte integer giving the total length of this value of the type. (Note that the length field is often encoded, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;; it's unwise to access it directly.)</source>
          <target state="translated">새 유형의 내부 표현에 대한 세부 사항은 I / O 함수 및 유형에 대해 작업하기 위해 생성하는 다른 함수에만 알려져 있지만 PostgreSQL에 선언해야하는 내부 표현의 여러 속성이 있습니다. 이들 중 가장 중요한 것은 &lt;code&gt;internallength&lt;/code&gt; 입니다. 기본 데이터 유형은 고정 길이 일 수 있으며,이 경우 &lt;code&gt;internallength&lt;/code&gt; 는 양의 정수이거나 variablelength는 &lt;code&gt;internallength&lt;/code&gt; 를 &lt;code&gt;VARIABLE&lt;/code&gt; 로 설정 하여 표시됩니다 . 내부적으로는 &lt;code&gt;typlen&lt;/code&gt; 을 -1 로 설정 하여 표시됩니다 . 모든 가변 길이 유형의 내부 표현은이 유형 값의 총 길이를 제공하는 4 바이트 정수로 시작해야합니다. (길이 필드는 종종&lt;a href=&quot;storage-toast&quot;&gt;섹션 68.2&lt;/a&gt; ; 직접 액세스하는 것은 현명하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="915068b5c9a0a4207ecd95ee0a72471b7e35a59c" translate="yes" xml:space="preserve">
          <source>While the examples for these functions use constants, the typical use would be to reference a table in the &lt;code&gt;FROM&lt;/code&gt; clause and use one of its &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; columns as an argument to the function. Extracted key values can then be referenced in other parts of the query, like &lt;code&gt;WHERE&lt;/code&gt; clauses and target lists. Extracting multiple values in this way can improve performance over extracting them separately with per-key operators.</source>
          <target state="translated">이러한 함수의 예는 상수를 사용하지만 일반적으로 &lt;code&gt;FROM&lt;/code&gt; 절 에서 테이블을 참조하고 해당 &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt; 열 중 하나를 함수의 인수로 사용합니다. 그런 다음 추출 된 키 값은 &lt;code&gt;WHERE&lt;/code&gt; 절 및 대상 목록과 같은 쿼리의 다른 부분에서 참조 될 수 있습니다 . 이러한 방식으로 여러 값을 추출하면 키별 연산자로 개별적으로 추출하는 것보다 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c09c1945f14d262f5a989a6b1b7f78a8869fb1b" translate="yes" xml:space="preserve">
          <source>While the server is running, it is not possible for a malicious user to take the place of the normal database server. However, when the server is down, it is possible for a local user to spoof the normal server by starting their own server. The spoof server could read passwords and queries sent by clients, but could not return any data because the &lt;code&gt;PGDATA&lt;/code&gt; directory would still be secure because of directory permissions. Spoofing is possible because any user can start a database server; a client cannot identify an invalid server unless it is specially configured.</source>
          <target state="translated">서버가 실행되는 동안 악의적 인 사용자가 일반 데이터베이스 서버를 대신 할 수 없습니다. 그러나 서버가 다운되면 로컬 사용자가 자신의 서버를 시작하여 일반 서버를 스푸핑 할 수 있습니다. 스푸핑 서버는 클라이언트가 보낸 비밀번호와 쿼리를 읽을 수 있지만 디렉토리 권한으로 인해 &lt;code&gt;PGDATA&lt;/code&gt; 디렉토리는 여전히 안전하므로 데이터를 반환 할 수 없습니다 . 스푸핑은 모든 사용자가 데이터베이스 서버를 시작할 수 있기 때문에 가능합니다. 클라이언트가 특별히 구성되어 있지 않으면 유효하지 않은 서버를 식별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8b90c7536148bdec5e290019a51b2379ecb8d63" translate="yes" xml:space="preserve">
          <source>While the server is running, its PID is stored in the file &lt;code&gt;postmaster.pid&lt;/code&gt; in the data directory. This is used to prevent multiple server instances from running in the same data directory and can also be used for shutting down the server.</source>
          <target state="translated">서버가 실행되는 동안 PID는 데이터 디렉토리의 &lt;code&gt;postmaster.pid&lt;/code&gt; 파일에 저장됩니다 . 이는 여러 서버 인스턴스가 동일한 데이터 디렉토리에서 실행되는 것을 방지하고 서버를 종료하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03c807444bf3594110c4d388ec7b0a59f62a431" translate="yes" xml:space="preserve">
          <source>While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes or backslashes, since each of those must be doubled. To allow more readable queries in such situations, PostgreSQL provides another way, called &amp;ldquo;dollar quoting&amp;rdquo;, to write string constants. A dollar-quoted string constant consists of a dollar sign (&lt;code&gt;$&lt;/code&gt;), an optional &amp;ldquo;tag&amp;rdquo; of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string &amp;ldquo;Dianne's horse&amp;rdquo; using dollar quoting:</source>
          <target state="translated">문자열 상수를 지정하는 표준 구문은 일반적으로 편리하지만 각 문자열을 두 배로 늘려야하므로 원하는 문자열에 작은 따옴표 나 백 슬래시가 많은 경우 이해하기 어려울 수 있습니다. 이러한 상황에서 더 읽기 쉬운 쿼리를 허용하기 위해 PostgreSQL은 &quot;달러 인용&quot;이라는 다른 방법을 사용하여 문자열 상수를 작성합니다. 달러 인용 문자열 상수는 달러 기호 ( &lt;code&gt;$&lt;/code&gt; ), 0 개 이상의 문자로 구성된 선택적 &quot;태그&quot;, 다른 달러 기호, 문자열 내용을 구성하는 임의의 문자 시퀀스, 달러 기호, 동일한 태그로 구성됩니다. 이 달러 따옴표와 달러 기호를 시작했습니다. 예를 들어, 달러 인용을 사용하여 문자열 &quot;Dianne 's horse&quot;를 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="97a03d15b6274d3b06d93b14cfe041b66ef2af72" translate="yes" xml:space="preserve">
          <source>While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed.</source>
          <target state="translated">이 기능은 한 달의 경우보다 복잡하지만 필요에 따라 분기를 추가 할 수 있으므로 자주 업데이트 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb917c6d1ba7f34837342b8b023d8fdc99add536" translate="yes" xml:space="preserve">
          <source>While this is the only way to convert character strings into XML values according to the SQL standard, the PostgreSQL-specific syntaxes:</source>
          <target state="translated">이것이 SQL 표준에 따라 문자열을 XML 값으로 변환하는 유일한 방법이지만 PostgreSQL 관련 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13b118c29b5eac33252cf8f05a41900068035eae" translate="yes" xml:space="preserve">
          <source>While transition table names for &lt;code&gt;AFTER&lt;/code&gt; triggers are specified using the &lt;code&gt;REFERENCING&lt;/code&gt; clause in the standard way, the row variables used in &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers may not be specified in a &lt;code&gt;REFERENCING&lt;/code&gt; clause. They are available in a manner that is dependent on the language in which the trigger function is written, but is fixed for any one language. Some languages effectively behave as though there is a &lt;code&gt;REFERENCING&lt;/code&gt; clause containing &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AFTER&lt;/code&gt; 트리거의 전이 테이블 이름 은 표준 방식으로 &lt;code&gt;REFERENCING&lt;/code&gt; 절을 사용하여 지정 되지만 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 트리거에 사용 된 행 변수 는 &lt;code&gt;REFERENCING&lt;/code&gt; 절에 지정되지 않을 수 있습니다 . 트리거 기능이 작성되는 언어에 따라 달라 지지만 한 언어로 고정되어 있습니다. 일부 언어는 &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt; 를 포함 하는 &lt;code&gt;REFERENCING&lt;/code&gt; 절이 있는 것처럼 효과적으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0775e3a82644839414e547fda3c53cda5989eee1" translate="yes" xml:space="preserve">
          <source>While turning off &lt;code&gt;fsync&lt;/code&gt; is often a performance benefit, this can result in unrecoverable data corruption in the event of a power failure or system crash. Thus it is only advisable to turn off &lt;code&gt;fsync&lt;/code&gt; if you can easily recreate your entire database from external data.</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; 를 끄는 것이 성능상의 이점 인 경우가 많지만 정전 또는 시스템 충돌시 데이터를 복구 할 수 없습니다. 따라서 외부 데이터에서 전체 데이터베이스를 쉽게 다시 만들 수있는 경우 에만 &lt;code&gt;fsync&lt;/code&gt; 를 끄는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5d9f7345f5e4a9cecb1d3a73e9e82a30d0080279" translate="yes" xml:space="preserve">
          <source>White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (&amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo;) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above).</source>
          <target state="translated">공백 (예 : 공백, 탭 및 개행)은 SQL 명령에서 자유롭게 사용할 수 있습니다. 즉, 명령을 위와 다르게 정렬하거나 한 줄에 모두 입력 할 수 있습니다. 두 개의 대시 (&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo;)는 주석을 소개합니다. 뒤 따르는 것은 줄 끝까지 무시됩니다. SQL은 대소 문자를 구분하기 위해 식별자가 큰 따옴표로 묶인 경우를 제외하고 키워드와 식별자에 대해 대소 문자를 구분하지 않습니다 (위에서 수행하지 않음).</target>
        </trans-unit>
        <trans-unit id="58bd91fff64a844973a8238af97e34efc8a5c324" translate="yes" xml:space="preserve">
          <source>White space is ignored on input, so &lt;code&gt;[(x),(y)]&lt;/code&gt; is the same as &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt;.</source>
          <target state="translated">공백이므로, 입력을 무시 &lt;code&gt;[(x),(y)]&lt;/code&gt; 동일하다 &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac41fe428645044123abfe95a020b4d162465d70" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed before and after the range value, but any whitespace between the parentheses or brackets is taken as part of the lower or upper bound value. (Depending on the element type, it might or might not be significant.)</source>
          <target state="translated">범위 값 전후에 공백이 허용되지만 괄호 또는 대괄호 사이의 공백은 하한 또는 상한 값의 일부로 사용됩니다. 요소 유형에 따라 중요하거나 중요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc40c3d855977fc828d35a4c20284c43f252dc0" translate="yes" xml:space="preserve">
          <source>Why would you want to use the weak mode? Well, it could be that you have a huge collection of ISBN numbers, and that there are so many of them that for weird reasons some have the wrong check digit (perhaps the numbers were scanned from a printed list and the OCR got the numbers wrong, perhaps the numbers were manually captured... who knows). Anyway, the point is you might want to clean the mess up, but you still want to be able to have all the numbers in your database and maybe use an external tool to locate the invalid numbers in the database so you can verify the information and validate it more easily; so for example you'd want to select all the invalid numbers in the table.</source>
          <target state="translated">왜 약한 모드를 사용하고 싶습니까? 글쎄, 당신은 ISBN 번호가 엄청나게 많을 수도 있고, 너무 많은 숫자가있어 이상한 이유로 일부 체크 숫자가 잘못되었을 수도 있습니다 (아마도 인쇄 된 목록에서 숫자가 스캔되고 OCR에서 숫자가 잘못되었을 수 있습니다) , 아마도 숫자는 수동으로 잡혔을 것입니다. 어쨌든 요점은 엉망을 정리하고 싶지만 데이터베이스에 모든 숫자를 가질 수 있고 외부 도구를 사용하여 데이터베이스에서 유효하지 않은 숫자를 찾아 정보를 확인할 수 있기를 원한다는 것입니다. 더 쉽게 확인하십시오. 예를 들어 테이블에서 유효하지 않은 모든 숫자를 선택하려고합니다.</target>
        </trans-unit>
        <trans-unit id="70a7ce99eb76502ad0a6210d94039f0b40c3419d" translate="yes" xml:space="preserve">
          <source>Wildcard array element accessor that returns all array elements.</source>
          <target state="translated">모든 배열 요소를 반환하는 와일드 카드 배열 요소 접근 자</target>
        </trans-unit>
        <trans-unit id="cd2106ae04d09a5386f20710a015aa4219dc3f6c" translate="yes" xml:space="preserve">
          <source>Wildcard member accessor that returns the values of all members located at the top level of the current object.</source>
          <target state="translated">현재 개체의 최상위 수준에있는 모든 멤버의 값을 반환하는 와일드 카드 멤버 접근 자</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="01267df331f99498a90196b34760cb7aa229a46d" translate="yes" xml:space="preserve">
          <source>Window function calls are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query.</source>
          <target state="translated">창 함수 호출은 조회 의 &lt;code&gt;SELECT&lt;/code&gt; 목록 및 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c367a920e4a4ea3efbe3a1a798085a3a023e6741" translate="yes" xml:space="preserve">
          <source>Window functions are described in detail in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">윈도우 기능은 &lt;a href=&quot;tutorial-window&quot;&gt;3.5&lt;/a&gt; , &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;4.2.8&lt;/a&gt; 및 &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;7.2.5 &lt;/a&gt;섹션 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f451b621911f3a41da7c18da4aff7cdb55589c1" translate="yes" xml:space="preserve">
          <source>Window functions are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query. They are forbidden elsewhere, such as in &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.</source>
          <target state="translated">창 함수는 조회 의 &lt;code&gt;SELECT&lt;/code&gt; 목록 및 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서만 허용됩니다 . &lt;code&gt;GROUP BY&lt;/code&gt; , &lt;code&gt;HAVING&lt;/code&gt; 및 &lt;code&gt;WHERE&lt;/code&gt; 절 과 같은 다른 곳에서는 금지되어 있습니다 . 이는 해당 절을 처리 한 후에 논리적으로 실행되기 때문입니다. 또한 창 함수는 비창 합 집계 함수 후에 실행됩니다. 이것은 윈도우 함수의 인수에 집계 함수 호출을 포함하는 것이 유효하지만 그 반대의 경우는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="79e789d251d694ff69667eed3b6a1eef1b73bc73" translate="yes" xml:space="preserve">
          <source>Window: cume_dist</source>
          <target state="translated">창 : cume_dist</target>
        </trans-unit>
        <trans-unit id="1e7f6a60bbd5fd2e82c3412bbb88bea212c4bdb7" translate="yes" xml:space="preserve">
          <source>Window: dense_rank</source>
          <target state="translated">창 : dense_rank</target>
        </trans-unit>
        <trans-unit id="08d36b418003a8b9c0e9b2dd2a6f2bff70e5a8ac" translate="yes" xml:space="preserve">
          <source>Window: first_value</source>
          <target state="translated">창 : first_value</target>
        </trans-unit>
        <trans-unit id="b5f178a106cd7cba1da80bdc71ec514eea37f26d" translate="yes" xml:space="preserve">
          <source>Window: lag</source>
          <target state="translated">창 : 시차</target>
        </trans-unit>
        <trans-unit id="fabaa17e6490da4ec5451b3b47ee388b70cf91b0" translate="yes" xml:space="preserve">
          <source>Window: last_value</source>
          <target state="translated">창 : last_value</target>
        </trans-unit>
        <trans-unit id="994efd60b559fadbd405573c301089b7cf18f884" translate="yes" xml:space="preserve">
          <source>Window: lead</source>
          <target state="translated">창 : 납</target>
        </trans-unit>
        <trans-unit id="757db4a854089f2de8d98fd39c8889ef5116458d" translate="yes" xml:space="preserve">
          <source>Window: nth_value</source>
          <target state="translated">창 : nth_value</target>
        </trans-unit>
        <trans-unit id="e7f90d6e0544bf0f16ab443f5e02ee4cd6fe42bc" translate="yes" xml:space="preserve">
          <source>Window: ntile</source>
          <target state="translated">창 : 니블</target>
        </trans-unit>
        <trans-unit id="bb901cf4a6350aa408d137094086445ef7a0cf50" translate="yes" xml:space="preserve">
          <source>Window: percent_rank</source>
          <target state="translated">창 : percent_rank</target>
        </trans-unit>
        <trans-unit id="c0ecbc78e1223c489bcdc839303f81579d301dbd" translate="yes" xml:space="preserve">
          <source>Window: rank</source>
          <target state="translated">창 : 계급</target>
        </trans-unit>
        <trans-unit id="31c13454a2137d228d57d97a95bb16f2559129e2" translate="yes" xml:space="preserve">
          <source>Window: row_number</source>
          <target state="translated">창 : row_number</target>
        </trans-unit>
        <trans-unit id="afb3a4bfc7eab0371f71e7828e71cca0cb17b3c3" translate="yes" xml:space="preserve">
          <source>Windows CP1250</source>
          <target state="translated">Windows CP1250</target>
        </trans-unit>
        <trans-unit id="9a2c00b8e44a047e41a03f1caab3a7b4b6689695" translate="yes" xml:space="preserve">
          <source>Windows CP1251</source>
          <target state="translated">Windows CP1251</target>
        </trans-unit>
        <trans-unit id="ee9d69428625d1ff5f15b6e3dcde936a0fd1f094" translate="yes" xml:space="preserve">
          <source>Windows CP1252</source>
          <target state="translated">Windows CP1252</target>
        </trans-unit>
        <trans-unit id="cc78a0c32f91f66c55ae633ccbcefebb486eb07a" translate="yes" xml:space="preserve">
          <source>Windows CP1253</source>
          <target state="translated">Windows CP1253</target>
        </trans-unit>
        <trans-unit id="5f231ed423cb65bf660816b30028087f1a8e8ce5" translate="yes" xml:space="preserve">
          <source>Windows CP1254</source>
          <target state="translated">Windows CP1254</target>
        </trans-unit>
        <trans-unit id="a23b534f177679e438c10751dd8cd9af7ceda942" translate="yes" xml:space="preserve">
          <source>Windows CP1255</source>
          <target state="translated">Windows CP1255</target>
        </trans-unit>
        <trans-unit id="6790dc03b7d5b6e6f32fcb36c60e23323fb868ac" translate="yes" xml:space="preserve">
          <source>Windows CP1256</source>
          <target state="translated">Windows CP1256</target>
        </trans-unit>
        <trans-unit id="2de6d342a6a1f91fe73d1aed1c38e985a216e16e" translate="yes" xml:space="preserve">
          <source>Windows CP1257</source>
          <target state="translated">Windows CP1257</target>
        </trans-unit>
        <trans-unit id="640bb2a94fe66a43ea03427875c71fa7af756764" translate="yes" xml:space="preserve">
          <source>Windows CP1258</source>
          <target state="translated">Windows CP1258</target>
        </trans-unit>
        <trans-unit id="e95532249be79aa59a141ea1dc6d988132a7c104" translate="yes" xml:space="preserve">
          <source>Windows CP866</source>
          <target state="translated">Windows CP866</target>
        </trans-unit>
        <trans-unit id="69925dc2d1afa064badeb7131e0815ad04126da3" translate="yes" xml:space="preserve">
          <source>Windows CP874</source>
          <target state="translated">Windows CP874</target>
        </trans-unit>
        <trans-unit id="c6d589f8c6c9e727468855e6a54c0d6dfb5cce47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, pg_restore also restores the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also restored, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--create&lt;/code&gt; 를 사용하면 pg_restore는 데이터베이스의 주석 및이 데이터베이스에 특정한 구성 변수 설정, 즉 &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 및 &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; 도 복원합니다 . 이 데이터베이스를 언급하는 SET ... 명령 &lt;code&gt;--no-acl&lt;/code&gt; 을 지정 하지 않으면 데이터베이스 자체에 대한 액세스 권한도 복원 됩니다.</target>
        </trans-unit>
        <trans-unit id="8fdece12f1fb080c2dbfd8709cabeca4afb1d172" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, the output also includes the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also dumped, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--create&lt;/code&gt; 를 사용 하면 데이터베이스의 주석 및이 데이터베이스에 특정한 구성 변수 설정 (즉, &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 및 &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; 이 데이터베이스를 언급하는 SET ... 명령. &lt;code&gt;--no-acl&lt;/code&gt; 을 지정 하지 않으면 데이터베이스 자체에 대한 액세스 권한도 덤프 됩니다.</target>
        </trans-unit>
        <trans-unit id="f453a9fafc8b310f8a3de3fda65ed4c38e9ca283" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1, this forces the planner to join A to B before joining them to other tables, but doesn't constrain its choices otherwise. In this example, the number of possible join orders is reduced by a factor of 5.</source>
          <target state="translated">&lt;code&gt;join_collapse_limit&lt;/code&gt; = 1을 사용 하면 플래너가 다른 테이블에 조인하기 전에 A를 B에 조인해야하지만 그렇지 않은 경우에는 선택을 제한하지 않습니다. 이 예에서는 가능한 조인 순서 수가 5 배 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="fe49ef2ae18f846d2f24144892dcb7436b22edbb" translate="yes" xml:space="preserve">
          <source>With ICU, it is not sensible to enumerate all possible locale names. ICU uses a particular naming system for locales, but there are many more ways to name a locale than there are actually distinct locales. &lt;code&gt;initdb&lt;/code&gt; uses the ICU APIs to extract a set of distinct locales to populate the initial set of collations. Collations provided by ICU are created in the SQL environment with names in BCP 47 language tag format, with a &amp;ldquo;private use&amp;rdquo; extension &lt;code&gt;-x-icu&lt;/code&gt; appended, to distinguish them from libc locales.</source>
          <target state="translated">ICU를 사용하면 가능한 모든 로캘 이름을 열거하는 것이 합리적이지 않습니다. ICU는 로케일에 특정 이름 지정 시스템을 사용하지만 실제로 구별되는 로케일보다 로케일의 이름을 지정하는 방법이 더 많습니다. &lt;code&gt;initdb&lt;/code&gt; 는 ICU API를 사용하여 고유 한 로케일 세트를 추출하여 초기 데이터 정렬 세트를 채 웁니다. ICU에서 제공하는 데이터 정렬 은 libc 로켈과 구별하기 위해 &quot;private use&quot;확장명 &lt;code&gt;-x-icu&lt;/code&gt; 가 추가 된 BCP 47 언어 태그 형식의 이름을 가진 SQL 환경에서 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0ce6e945d75c0e017cd4582a6ce07fb85c72b6" translate="yes" xml:space="preserve">
          <source>With OpenSSL</source>
          <target state="translated">OpenSSL로</target>
        </trans-unit>
        <trans-unit id="8fa1343fb87dfb28347c1e7e66e33ba69c59c2ca" translate="yes" xml:space="preserve">
          <source>With SSL support compiled in, the PostgreSQL server can be started with SSL enabled by setting the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The server will listen for both normal and SSL connections on the same TCP port, and will negotiate with any connecting client on whether to use SSL. By default, this is at the client's option; see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about how to set up the server to require use of SSL for some or all connections.</source>
          <target state="translated">SSL 지원이 컴파일 된 상태 에서 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; 매개 변수 를 &lt;code&gt;on&lt;/code&gt; 으로 설정하여 SSL을 사용하여 PostgreSQL 서버를 시작할 수 있습니다 . 서버는 동일한 TCP 포트에서 일반 연결과 SSL 연결을 모두 수신하고 SSL 사용 여부에 대한 연결 클라이언트와 협상합니다. 기본적으로 이것은 클라이언트의 옵션입니다. 일부 또는 모든 연결에 SSL을 사용하도록 서버를 설정하는 방법에 대해서는 &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;20.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d13ab27fd57668592221b667df2e40b0bb1e2e4" translate="yes" xml:space="preserve">
          <source>With a cluster distributed across multiple geographic locations, using different values per location brings more flexibility in the cluster management. A smaller value is useful for faster failure detection with a standby having a low-latency network connection, and a larger value helps in judging better the health of a standby if located on a remote location, with a high-latency network connection.</source>
          <target state="translated">여러 지리적 위치에 분산 된 클러스터의 경우 위치마다 다른 값을 사용하면 클러스터 관리에 유연성이 향상됩니다. 값이 작을수록 지연 시간이 짧은 네트워크 연결을 가진 대기 상태에서 오류를 빠르게 감지하는 데 유용하며 값이 클수록 대기 시간이 긴 네트워크 연결로 원격 위치에있는 경우 대기 상태를보다 잘 판단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2817eb5fe50b4283e89c69a97c63500ae24da2d7" translate="yes" xml:space="preserve">
          <source>With a parameter, turns displaying of how long each SQL statement takes on or off. Without a parameter, toggles the display between on and off. The display is in milliseconds; intervals longer than 1 second are also shown in minutes:seconds format, with hours and days fields added if needed.</source>
          <target state="translated">매개 변수를 사용하면 각 SQL 문이 얼마나 오래 걸리는지 표시합니다. 매개 변수가 없으면 디스플레이를 켜거나 끕니다. 디스플레이는 밀리 초 단위입니다. 1 초보다 긴 간격도 분 : 초 형식으로 표시되며 필요한 경우 시간 및 일 필드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="862b8683e39578b4e7d997552333b9aad19243ce" translate="yes" xml:space="preserve">
          <source>With constraint exclusion enabled, this &lt;code&gt;SELECT&lt;/code&gt; will not scan &lt;code&gt;child1000&lt;/code&gt; at all, improving performance.</source>
          <target state="translated">제약 조건 제외가 활성화되면이 &lt;code&gt;SELECT&lt;/code&gt; 는 &lt;code&gt;child1000&lt;/code&gt; 을 전혀 검색하지 않으므로 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="281288184f75c730f93254833c37347e0fc29fe4" translate="yes" xml:space="preserve">
          <source>With data warehouse type workloads, it can make sense to use a larger number of partitions than with an OLTP type workload. Generally, in data warehouses, query planning time is less of a concern as the majority of processing time is spent during query execution. With either of these two types of workload, it is important to make the right decisions early, as re-partitioning large quantities of data can be painfully slow. Simulations of the intended workload are often beneficial for optimizing the partitioning strategy. Never assume that more partitions are better than fewer partitions and vice-versa.</source>
          <target state="translated">데이터웨어 하우스 유형의 워크로드를 사용하면 OLTP 유형의 워크로드보다 많은 수의 파티션을 사용하는 것이 좋습니다. 일반적으로 데이터웨어 하우스에서 대부분의 처리 시간이 쿼리 실행 중에 소비되므로 쿼리 계획 시간은 그다지 중요하지 않습니다. 이 두 가지 유형의 워크로드 중 하나를 사용하면 대량의 데이터를 다시 파티션하는 데 어려움이있을 수 있으므로 올바른 결정을 일찍 내리는 것이 중요합니다. 의도 한 워크로드의 시뮬레이션은 파티셔닝 전략을 최적화하는 데 종종 도움이됩니다. 더 많은 파티션이 더 적은 파티션보다 낫다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3766650cc974cf1ed93fe99df3e842788c554914" translate="yes" xml:space="preserve">
          <source>With no advance preparation, the system would have to scan the entire &lt;code&gt;test1&lt;/code&gt; table, row by row, to find all matching entries. If there are many rows in &lt;code&gt;test1&lt;/code&gt; and only a few rows (perhaps zero or one) that would be returned by such a query, this is clearly an inefficient method. But if the system has been instructed to maintain an index on the &lt;code&gt;id&lt;/code&gt; column, it can use a more efficient method for locating matching rows. For instance, it might only have to walk a few levels deep into a search tree.</source>
          <target state="translated">사전 준비가 없으면 시스템은 전체 &lt;code&gt;test1&lt;/code&gt; 테이블을 한 행씩 스캔하여 일치하는 모든 항목을 찾아야합니다. &lt;code&gt;test1&lt;/code&gt; 에 많은 행 이 있고 그러한 쿼리에 의해 반환되는 몇 개의 행 (아마도 0 또는 1 개) 만있는 경우 이는 분명히 비효율적 인 방법입니다. 그러나 시스템이 &lt;code&gt;id&lt;/code&gt; 열에서 색인을 유지하도록 지시받은 경우 일치하는 행을 찾는 데 더 효율적인 방법을 사용할 수 있습니다. 예를 들어, 검색 트리에 몇 단계 깊숙히 들어가야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d718f6eccff45185b0a45095de6fde081eea1bba" translate="yes" xml:space="preserve">
          <source>With no argument, escapes to a sub-shell; psql resumes when the sub-shell exits. With an argument, executes the shell command &lt;code&gt;command&lt;/code&gt;.</source>
          <target state="translated">논증없이, 서브 쉘로 탈출합니다. 서브 쉘이 종료되면 psql이 재개됩니다. 인수로 쉘 명령 &lt;code&gt;command&lt;/code&gt; 를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="9514950fe011b56b473f75097880ade2b163bceb" translate="yes" xml:space="preserve">
          <source>With statement-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="translated">명령문 기반 복제 미들웨어를 사용하면 프로그램이 모든 SQL 쿼리를 가로 채서 하나 또는 모든 서버로 보냅니다. 각 서버는 독립적으로 작동합니다. 모든 서버가 변경 사항을 수신 할 수 있도록 읽기 / 쓰기 쿼리를 모든 서버로 보내야합니다. 그러나 읽기 전용 쿼리는 단 하나의 서버로 전송 될 수 있으므로 읽기 작업 부하가 서버간에 분산 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4094d09ba0d0f0a9849aa3ea46bb7d77a767e980" translate="yes" xml:space="preserve">
          <source>With synchronous replication options specified at the application level (on the primary) we can offer synchronous replication for the most important changes, without slowing down the bulk of the total workload. Application level options are an important and practical tool for allowing the benefits of synchronous replication for high performance applications.</source>
          <target state="translated">애플리케이션 수준 (기본)에 지정된 동기식 복제 옵션을 사용하면 전체 워크로드를 크게 줄이지 않고도 가장 중요한 변경 사항에 대한 동기식 복제를 제공 할 수 있습니다. 응용 프로그램 수준 옵션은 고성능 응용 프로그램에 대한 동기 복제의 이점을 허용하는 중요하고 실용적인 도구입니다.</target>
        </trans-unit>
        <trans-unit id="e625f82083935e0517f3c7cf1a804070d41f41f5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--aggregate-interval&lt;/code&gt; option, a different format is used for the log files:</source>
          <target state="translated">으로 &lt;code&gt;--aggregate-interval&lt;/code&gt; 옵션, 다른 형식 로그 파일에 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="21c13395c6ff50aca429bd803e2b410319037881" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-l&lt;/code&gt; option (but without the &lt;code&gt;--aggregate-interval&lt;/code&gt; option), pgbench writes information about each transaction to a log file. The log file will be named &lt;code&gt;prefix.nnn&lt;/code&gt;, where &lt;code&gt;prefix&lt;/code&gt; defaults to &lt;code&gt;pgbench_log&lt;/code&gt;, and &lt;code&gt;nnn&lt;/code&gt; is the PID of the pgbench process. The prefix can be changed by using the &lt;code&gt;--log-prefix&lt;/code&gt; option. If the &lt;code&gt;-j&lt;/code&gt; option is 2 or higher, so that there are multiple worker threads, each will have its own log file. The first worker will use the same name for its log file as in the standard single worker case. The additional log files for the other workers will be named &lt;code&gt;prefix.nnn.mmm&lt;/code&gt;, where &lt;code&gt;mmm&lt;/code&gt; is a sequential number for each worker starting with 1.</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; 옵션을 사용하면 ( &lt;code&gt;--aggregate-interval&lt;/code&gt; 옵션 제외) pgbench는 각 트랜잭션에 대한 정보를 로그 파일에 기록합니다. 로그 파일의 이름은 &lt;code&gt;prefix.nnn&lt;/code&gt; 이며 &lt;code&gt;prefix&lt;/code&gt; 기본값은 &lt;code&gt;pgbench_log&lt;/code&gt; 이며 &lt;code&gt;nnn&lt;/code&gt; 은 pgbench 프로세스의 PID입니다. &lt;code&gt;--log-prefix&lt;/code&gt; 옵션 을 사용하여 접두사를 변경할 수 있습니다 . 경우 &lt;code&gt;-j&lt;/code&gt; 옵션은 2 이상이고, 여러 작업자 스레드가 그래서, 각각 자신의 로그 파일이있을 것이다. 첫 번째 작업자는 표준 단일 작업자 사례와 동일한 이름의 로그 파일을 사용합니다. 다른 작업자의 추가 로그 파일 이름은 &lt;code&gt;prefix.nnn.mmm&lt;/code&gt; 이며 여기서 &lt;code&gt;mmm&lt;/code&gt; 은 1부터 시작하는 각 작업자의 순차적 번호입니다.</target>
        </trans-unit>
        <trans-unit id="dea12aa8ce2a4f9481a6f03ad5ce52c7d1882b2a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-r&lt;/code&gt; option, pgbench collects the elapsed transaction time of each statement executed by every client. It then reports an average of those values, referred to as the latency for each statement, after the benchmark has finished.</source>
          <target state="translated">&lt;code&gt;-r&lt;/code&gt; 옵션을 사용하면 pgbench는 모든 클라이언트가 실행 한 각 명령문의 경과 된 트랜잭션 시간을 수집합니다. 그런 다음 벤치 마크가 완료된 후 각 명령문의 대기 시간이라고하는 해당 값의 평균을보고합니다.</target>
        </trans-unit>
        <trans-unit id="b0d0adcb9fc8fc9dddac0cfadc06d179ba840172" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;, it is only useful to place a &lt;code&gt;simple&lt;/code&gt; dictionary at the end of a list of dictionaries, since it will never pass on any token to a following dictionary. Conversely, &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; is only useful when there is at least one following dictionary.</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; 의 기본 설정 을 사용하면 다음 사전에 토큰을 전달하지 않으므로 사전 목록의 끝에 &lt;code&gt;simple&lt;/code&gt; 사전 을 배치하는 것만 유용합니다 . 반대로 &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 는 다음 사전이 하나 이상있을 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1679a02524be37201556be412a6d701fa1ad4ae3" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="translated">지금까지 설명한 도구를 사용하면 완전한 기능의 테이블을 만들 수 있습니다. 이 장의 나머지 부분에서는 데이터 무결성, 보안 또는 편의를 보장하기 위해 테이블 ​​정의에 기능을 추가하는 방법에 대해 설명합니다. 이제 데이터로 테이블을 채우고 싶다면 &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;6 장으로&lt;/a&gt; 건너 뛰고이 장의 나머지 부분을 나중에 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="37674f638cca87d9f8a3c6dc8d132c3743ff6b7c" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g. &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="translated">이 매개 변수를 사용하면 여전히 일반 글로벌 사용자를 작성할 수 있습니다. 클라이언트에서 사용자 이름을 지정할 때 간단히 &lt;code&gt;@&lt;/code&gt; 를 추가하십시오 ( 예 : &lt;code&gt;joe@&lt;/code&gt; . &lt;code&gt;@&lt;/code&gt; 는 사용자 이름이 서버에 의해보고되기 전에 벗겨됩니다.</target>
        </trans-unit>
        <trans-unit id="de39e9b44ca28bac2cf5d078925f7311c5e84abb" translate="yes" xml:space="preserve">
          <source>With this preparation, a backup can be taken using a script like the following:</source>
          <target state="translated">이 준비를 통해 다음과 같은 스크립트를 사용하여 백업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d93925105d3192c92e0036610fccacd28a3de6" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;, the special table names &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt; can be used to refer to values in the referenced table. &lt;code&gt;NEW&lt;/code&gt; is valid in &lt;code&gt;ON INSERT&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; rules to refer to the new row being inserted or updated. &lt;code&gt;OLD&lt;/code&gt; is valid in &lt;code&gt;ON UPDATE&lt;/code&gt; and &lt;code&gt;ON DELETE&lt;/code&gt; rules to refer to the existing row being updated or deleted.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 및 &lt;code&gt;command&lt;/code&gt; 내 에서 특수 테이블 이름 &lt;code&gt;NEW&lt;/code&gt; 및 &lt;code&gt;OLD&lt;/code&gt; 를 사용하여 참조 된 테이블의 값을 참조 할 수 있습니다. &lt;code&gt;NEW&lt;/code&gt; 는 삽입 또는 업데이트되는 새 행을 참조하기 위해 &lt;code&gt;ON INSERT&lt;/code&gt; 및 &lt;code&gt;ON UPDATE&lt;/code&gt; 규칙 에서 유효합니다 . &lt;code&gt;OLD&lt;/code&gt; 는 업데이트 또는 삭제중인 기존 행을 참조하기 위해 &lt;code&gt;ON UPDATE&lt;/code&gt; 및 &lt;code&gt;ON DELETE&lt;/code&gt; 규칙 에서 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="b7c7983937789ea59f666ccaa3b6dc10f18e4489" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;tsquery&lt;/code&gt;, the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) operator specifies that both its arguments must appear in the document to have a match. Similarly, the &lt;code&gt;|&lt;/code&gt; (OR) operator specifies that at least one of its arguments must appear, while the &lt;code&gt;!&lt;/code&gt; (NOT) operator specifies that its argument must &lt;em&gt;not&lt;/em&gt; appear in order to have a match. For example, the query &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; matches documents that contain &lt;code&gt;fat&lt;/code&gt; but not &lt;code&gt;rat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 내 에서 &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) 연산자는 두 인수가 모두 일치하도록 문서에 나타나도록 지정합니다. 마찬가지로 &lt;code&gt;|&lt;/code&gt; (OR) 연산자는 적어도 하나의 인수가 나타나도록 지정하고 &lt;code&gt;!&lt;/code&gt; (NOT) 인수가 있어야 운영자를 지정 &lt;em&gt;하지&lt;/em&gt; 일치를 위해 표시를. 예를 들어, 쿼리 &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; 는 &lt;code&gt;fat&lt;/code&gt; 은 포함 하지만 &lt;code&gt;rat&lt;/code&gt; 는 포함 하지 않은 문서와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="f2368cc4cb5a919d014b1e03cda4cf0d9819b781" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a &lt;code&gt;ch&lt;/code&gt; collating element, then the RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; matches the first five characters of &lt;code&gt;chchcc&lt;/code&gt;.</source>
          <target state="translated">대괄호 표현식 내에서 조합 요소 (문자, 단일 문자 인 것처럼 조합하는 다중 문자 시퀀스 또는 둘 중 하나의 조합 순서 이름)는 &lt;code&gt;[.&lt;/code&gt; 와 &lt;code&gt;.]&lt;/code&gt; 그 조합 요소의 문자 순서를 의미합니다. 시퀀스는 대괄호 표현식 목록의 단일 요소로 취급됩니다. 이렇게하면 여러 문자 조합 요소를 포함하는 대괄호 표현식이 둘 이상의 문자와 일치 할 수 있습니다. 예를 들어 조합 순서에 &lt;code&gt;ch&lt;/code&gt; 조합 요소가 포함 된 경우 RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; 는 &lt;code&gt;chchcc&lt;/code&gt; 의 처음 다섯 문자와 일치합니다. .</target>
        </trans-unit>
        <trans-unit id="5e1fe750b2061555e551fa7ddfd0d60d1ac81517" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element enclosed in &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; is an &lt;em&gt;equivalence class&lt;/em&gt;, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt;.) For example, if &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt; are the members of an equivalence class, then &lt;code&gt;[[=o=]]&lt;/code&gt;, &lt;code&gt;[[=^=]]&lt;/code&gt;, and &lt;code&gt;[o^]&lt;/code&gt; are all synonymous. An equivalence class cannot be an endpoint of a range.</source>
          <target state="translated">대괄호 표현식 내에서 &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; 로 묶인 조합 요소 는 &lt;em&gt;등가 클래스&lt;/em&gt; 이며, 그 자체를 포함하여 해당 조합 요소와 동등한 모든 조합 요소의 문자 시퀀스를 나타냅니다. (등가 배열 요소가없는 경우 처리는 둘러싸는 분리 문자가 &lt;code&gt;[.&lt;/code&gt; 및 &lt;code&gt;.]&lt;/code&gt; 인 것처럼 처리됩니다 .) 예를 들어 &lt;code&gt;o&lt;/code&gt; 와 &lt;code&gt;^&lt;/code&gt; 가 동등성 클래스의 구성원 인 경우 &lt;code&gt;[[=o=]]&lt;/code&gt; , &lt;code&gt;[[=^=]]&lt;/code&gt; 및 &lt;code&gt;[o^]&lt;/code&gt; 는 모두 동의어입니다. 동등성 클래스는 범위의 끝 점이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="abb82d076f25a7be9aee0f56365d178b74a1a2ff" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, the name of a character class enclosed in &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; stands for the list of all characters belonging to that class. A character class cannot be used as an endpoint of a range. The POSIX standard defines these character class names: &lt;code&gt;alnum&lt;/code&gt; (letters and numeric digits), &lt;code&gt;alpha&lt;/code&gt; (letters), &lt;code&gt;blank&lt;/code&gt; (space and tab), &lt;code&gt;cntrl&lt;/code&gt; (control characters), &lt;code&gt;digit&lt;/code&gt; (numeric digits), &lt;code&gt;graph&lt;/code&gt; (printable characters except space), &lt;code&gt;lower&lt;/code&gt; (lower-case letters), &lt;code&gt;print&lt;/code&gt; (printable characters including space), &lt;code&gt;punct&lt;/code&gt; (punctuation), &lt;code&gt;space&lt;/code&gt; (any white space), &lt;code&gt;upper&lt;/code&gt; (upper-case letters), and &lt;code&gt;xdigit&lt;/code&gt; (hexadecimal digits). The behavior of these standard character classes is generally consistent across platforms for characters in the 7-bit ASCII set. Whether a given non-ASCII character is considered to belong to one of these classes depends on the &lt;em&gt;collation&lt;/em&gt; that is used for the regular-expression function or operator (see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;), or by default on the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting (see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;). The classification of non-ASCII characters can vary across platforms even in similarly-named locales. (But the &lt;code&gt;C&lt;/code&gt; locale never considers any non-ASCII characters to belong to any of these classes.) In addition to these standard character classes, PostgreSQL defines the &lt;code&gt;ascii&lt;/code&gt; character class, which contains exactly the 7-bit ASCII set.</source>
          <target state="translated">대괄호 표현식 내에서 &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; 로 묶인 문자 클래스의 이름은 해당 클래스에 속하는 모든 문자 목록을 나타냅니다. 문자 클래스는 범위의 끝점으로 사용할 수 없습니다. POSIX 표준은 다음과 같은 문자 클래스 이름을 정의합니다. &lt;code&gt;alnum&lt;/code&gt; (문자 및 숫자), &lt;code&gt;alpha&lt;/code&gt; (문자), &lt;code&gt;blank&lt;/code&gt; (공백 및 탭), &lt;code&gt;cntrl&lt;/code&gt; (제어 문자), &lt;code&gt;digit&lt;/code&gt; (숫자), &lt;code&gt;graph&lt;/code&gt; (공백을 제외한 문자), &lt;code&gt;lower&lt;/code&gt; (소문자), &lt;code&gt;print&lt;/code&gt; (공백을 포함하여 인쇄 가능한 문자), &lt;code&gt;punct&lt;/code&gt; (문장), &lt;code&gt;space&lt;/code&gt; (공백), &lt;code&gt;upper&lt;/code&gt; (대문자) 및 &lt;code&gt;xdigit&lt;/code&gt; (16 진수). 이러한 표준 문자 클래스의 동작은 일반적으로 7 비트 ASCII 세트의 문자에 대해 플랫폼간에 일관됩니다. 주어진 비 ASCII 문자가 이러한 클래스 중 하나에 속하는 것으로 간주되는지 여부는 정규식 함수 또는 연산자에 사용되는 &lt;em&gt;데이터 정렬&lt;/em&gt; ( &lt;a href=&quot;collation&quot;&gt;섹션 23.2&lt;/a&gt; 참조 ) 또는 기본적으로 데이터베이스의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로캘 설정 ( &lt;a href=&quot;locale&quot;&gt;섹션 23.1&lt;/a&gt; 참조 ) 에 따라 다릅니다. ). 비 ASCII 문자의 분류는 비슷한 이름의 로케일에서도 플랫폼마다 다를 수 있습니다. (그러나 &lt;code&gt;C&lt;/code&gt; locale은 ASCII가 아닌 문자가 이러한 클래스에 속하는 것으로 간주하지 않습니다.) 이러한 표준 문자 클래스 외에도 PostgreSQL은 정확히 7 비트 ASCII 세트를 포함 하는 &lt;code&gt;ascii&lt;/code&gt; 문자 클래스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d35bef27a0203dd6547cf96a8cb6d957c5595d5c" translate="yes" xml:space="preserve">
          <source>Within a pattern, &lt;code&gt;*&lt;/code&gt; matches any sequence of characters (including no characters) and &lt;code&gt;?&lt;/code&gt; matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, &lt;code&gt;\dt int*&lt;/code&gt; displays tables whose names begin with &lt;code&gt;int&lt;/code&gt;. But within double quotes, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; lose these special meanings and are just matched literally.</source>
          <target state="translated">패턴 내에서 &lt;code&gt;*&lt;/code&gt; 는 모든 문자 시퀀스 (문자 제외)와 일치하고 &lt;code&gt;?&lt;/code&gt; 단일 문자와 일치합니다. (이 표기법은 Unix 쉘 파일 이름 패턴과 비슷합니다.) 예를 들어, &lt;code&gt;\dt int*&lt;/code&gt; 는 이름이 &lt;code&gt;int&lt;/code&gt; 로 시작하는 테이블을 표시합니다 . 그러나 큰 따옴표 안에 &lt;code&gt;*&lt;/code&gt; 와 &lt;code&gt;?&lt;/code&gt; 이 특별한 의미를 잃어 버리고 문자 그대로 일치합니다</target>
        </trans-unit>
        <trans-unit id="323b9b12ce6cec030c2782c77172b386cffa6487" translate="yes" xml:space="preserve">
          <source>Within an argument, text that is enclosed in backquotes (&lt;code&gt;`&lt;/code&gt;) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. Within the text enclosed in backquotes, no special quoting or other processing occurs, except that appearances of &lt;code&gt;:variable_name&lt;/code&gt; where &lt;code&gt;variable_name&lt;/code&gt; is a psql variable name are replaced by the variable's value. Also, appearances of &lt;code&gt;:'variable_name'&lt;/code&gt; are replaced by the variable's value suitably quoted to become a single shell command argument. (The latter form is almost always preferable, unless you are very sure of what is in the variable.) Because carriage return and line feed characters cannot be safely quoted on all platforms, the &lt;code&gt;:'variable_name'&lt;/code&gt; form prints an error message and does not substitute the variable value when such characters appear in the value.</source>
          <target state="translated">인수 내에서 큰 따옴표 ( &lt;code&gt;`&lt;/code&gt; )로 묶인 텍스트 는 셸에 전달되는 명령 줄로 사용됩니다. 명령의 출력 (후행 줄 바꿈이 제거 된)은 인용 된 텍스트를 대체합니다. 백 따옴표로 묶인 텍스트 내에서 &lt;code&gt;:variable_name&lt;/code&gt; 의 모양 ( 여기서 &lt;code&gt;variable_name&lt;/code&gt; 은 psql 변수 이름 임) 이 변수 값으로 대체 된다는 점을 제외하고는 특별한 인용 또는 기타 처리가 발생하지 않습니다 . 또한 &lt;code&gt;:'variable_name'&lt;/code&gt; 의 모양단일 쉘 명령 인수가되도록 적절하게 인용 된 변수 값으로 대체됩니다. (변수에 무엇이 있는지 확실하지 않으면 후자의 형식이 거의 항상 선호됩니다.) 캐리지 리턴 및 줄 바꿈 문자를 모든 플랫폼에서 안전하게 인용 할 수 없으므로 &lt;code&gt;:'variable_name'&lt;/code&gt; 형식은 오류 메시지를 인쇄하지만 그렇지 않습니다. 이러한 문자가 값에 나타나면 변수 값을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="02446a7929ab10f300f87f18642a172ae6a7fbfe" translate="yes" xml:space="preserve">
          <source>Within any particular database, only collations that use that database's encoding are of interest. Other entries in &lt;code&gt;pg_collation&lt;/code&gt; are ignored. Thus, a stripped collation name such as &lt;code&gt;de_DE&lt;/code&gt; can be considered unique within a given database even though it would not be unique globally. Use of the stripped collation names is recommended, since it will make one less thing you need to change if you decide to change to another database encoding. Note however that the &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; collations can be used regardless of the database encoding.</source>
          <target state="translated">특정 데이터베이스 내에서 해당 데이터베이스의 인코딩을 사용하는 데이터 정렬 만 관심 대상입니다. &lt;code&gt;pg_collation&lt;/code&gt; 의 다른 항목 은 무시됩니다. 따라서 &lt;code&gt;de_DE&lt;/code&gt; 와 같은 제거 된 조합 이름 은 전체적으로 고유하지 않더라도 주어진 데이터베이스 내에서 고유 한 것으로 간주 될 수 있습니다. 제거 된 데이터 정렬 이름을 사용하는 것이 좋습니다. 다른 데이터베이스 인코딩으로 변경하기로 결정한 경우 변경해야 할 사항이 더 적기 때문입니다. 그러나 데이터베이스 인코딩에 관계없이 &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;POSIX&lt;/code&gt; 데이터 정렬을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a80b578691f1b5a7af0065fe86a5cb4aa2ce86a" translate="yes" xml:space="preserve">
          <source>Within bracket expressions, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; lose their outer brackets, and &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt; are illegal. (So, for example, &lt;code&gt;[a-c\d]&lt;/code&gt; is equivalent to &lt;code&gt;[a-c[:digit:]]&lt;/code&gt;. Also, &lt;code&gt;[a-c\D]&lt;/code&gt;, which is equivalent to &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt;, is illegal.)</source>
          <target state="translated">대괄호 표현식 내에서 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 는 외부 대괄호를 잃어 버리고 &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; 및 &lt;code&gt;\W&lt;/code&gt; 는 불법입니다. (예를 들어 &lt;code&gt;[a-c\d]&lt;/code&gt; 는 &lt;code&gt;[a-c[:digit:]]&lt;/code&gt; 와 동일합니다 . 또한 &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt; 와 동일한 &lt;code&gt;[a-c\D]&lt;/code&gt; 는 불법입니다.)</target>
        </trans-unit>
        <trans-unit id="2542957abf2f09b64545fb48b800de1036c8c62f" translate="yes" xml:space="preserve">
          <source>Within each FSM page is a binary tree, stored in an array with one byte per node. Each leaf node represents a heap page, or a lower level FSM page. In each non-leaf node, the higher of its children's values is stored. The maximum value in the leaf nodes is therefore stored at the root.</source>
          <target state="translated">각 FSM 페이지에는 이진 트리가 있으며 노드 당 1 바이트로 배열에 저장됩니다. 각 리프 노드는 힙 페이지 또는 하위 레벨 FSM 페이지를 나타냅니다. 각 비 리프 노드에는 하위 값 중 높은 값이 저장됩니다. 따라서 리프 노드의 최대 값은 루트에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="eb8d6e1ae92682e55948b9d998dc41d07bd4d9ee" translate="yes" xml:space="preserve">
          <source>Within each catalog row, write comma-separated &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The allowed &lt;code&gt;key&lt;/code&gt;s are the names of the catalog's columns, plus the metadata keys &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt;. (The use of &lt;code&gt;oid&lt;/code&gt; and &lt;code&gt;oid_symbol&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;Section 69.2.2&lt;/a&gt; below, while &lt;code&gt;array_type_oid&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;Section 69.2.4&lt;/a&gt;. &lt;code&gt;descr&lt;/code&gt; supplies a description string for the object, which will be inserted into &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_shdescription&lt;/code&gt; as appropriate.) While the metadata keys are optional, the catalog's defined columns must all be provided, except when the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for the column. (In the example above, the &lt;code&gt;datdba&lt;/code&gt; field has been omitted because &lt;code&gt;pg_database.h&lt;/code&gt; supplies a suitable default value for it.)</source>
          <target state="translated">각 카탈로그 행 내에 쉼표로 구분 된 &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 쌍을 작성하십시오. 허용되는 &lt;code&gt;key&lt;/code&gt; 는 카탈로그 열의 이름과 메타 데이터 키 &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;oid_symbol&lt;/code&gt; , &lt;code&gt;array_type_oid&lt;/code&gt; 및 &lt;code&gt;descr&lt;/code&gt; 입니다. ( &lt;code&gt;oid&lt;/code&gt; 와 &lt;code&gt;oid_symbol&lt;/code&gt; 의 사용법 은 아래 &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;69.2.2 절에&lt;/a&gt; 설명되어 있으며, &lt;code&gt;array_type_oid&lt;/code&gt; 는 &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;69.2.4 절에&lt;/a&gt; 설명되어 있습니다. &lt;code&gt;descr&lt;/code&gt; 은 &lt;code&gt;pg_description&lt;/code&gt; 또는 &lt;code&gt;pg_shdescription&lt;/code&gt; 에 삽입 될 객체에 대한 설명 문자열을 제공합니다 .메타 데이터 키는 선택 사항이지만 카탈로그의 &lt;code&gt;.h&lt;/code&gt; 파일이 열의 기본값을 지정하는 경우를 제외하고 카탈로그의 정의 된 열을 모두 제공해야합니다 . (위의 예에서 &lt;code&gt;datdba&lt;/code&gt; 가 적절한 기본값을 제공 하기 때문에 &lt;code&gt;pg_database.h&lt;/code&gt; 필드는 생략되었습니다 .)</target>
        </trans-unit>
        <trans-unit id="3b70f85093aa93c4bd37783889d55ab04e575f61" translate="yes" xml:space="preserve">
          <source>Within each pair of curly braces, the metadata fields &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt; (if present) come first, in that order, then the catalog's own fields appear in their defined order.</source>
          <target state="translated">각 중괄호 쌍 내에서 메타 데이터 필드 &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;oid_symbol&lt;/code&gt; , &lt;code&gt;array_type_oid&lt;/code&gt; 및 &lt;code&gt;descr&lt;/code&gt; (있는 경우) 이이 순서대로 먼저 나온 다음 카탈로그의 자체 필드가 ​​정의 된 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7877c1484b515b178eb13d5365bc7aee43c3498f" translate="yes" xml:space="preserve">
          <source>Within larger commands, &lt;code&gt;VALUES&lt;/code&gt; is syntactically allowed anywhere that &lt;code&gt;SELECT&lt;/code&gt; is. Because it is treated like a &lt;code&gt;SELECT&lt;/code&gt; by the grammar, it is possible to use the &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt; (or equivalently &lt;code&gt;FETCH FIRST&lt;/code&gt;), and &lt;code&gt;OFFSET&lt;/code&gt; clauses with a &lt;code&gt;VALUES&lt;/code&gt; command.</source>
          <target state="translated">더 큰 명령 내에서 &lt;code&gt;VALUES&lt;/code&gt; 는 &lt;code&gt;SELECT&lt;/code&gt; 가있는 모든 위치에서 구문 적으로 허용 됩니다. 문법 으로 &lt;code&gt;SELECT&lt;/code&gt; 처럼 취급되므로 &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; (또는 &lt;code&gt;FETCH FIRST&lt;/code&gt; ) 및 &lt;code&gt;OFFSET&lt;/code&gt; 절을 &lt;code&gt;VALUES&lt;/code&gt; 명령 과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b2c20b975865db54e88c092240735063656bf9" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;ANALYZE&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to analyze. With a list, &lt;code&gt;ANALYZE&lt;/code&gt; processes only those table(s). It is further possible to give a list of column names for a table, in which case only the statistics for those columns are collected.</source>
          <target state="translated">&lt;code&gt;table_and_columns&lt;/code&gt; 목록이 없으면 &lt;code&gt;ANALYZE&lt;/code&gt; 는 현재 사용자가 분석 할 권한이있는 현재 데이터베이스의 모든 테이블 및 구체화 된보기를 처리합니다. &lt;code&gt;ANALYZE&lt;/code&gt; 는 목록을 사용하여 해당 테이블 만 처리합니다. 테이블에 대한 열 이름 목록을 제공 할 수도 있으며,이 경우 해당 열에 대한 통계 만 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd2342b55fa6fe36f0fd7dea1e8abcfbe35286d" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;VACUUM&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to vacuum. With a list, &lt;code&gt;VACUUM&lt;/code&gt; processes only those table(s).</source>
          <target state="translated">&lt;code&gt;table_and_columns&lt;/code&gt; 목록이 없으면 &lt;code&gt;VACUUM&lt;/code&gt; 은 현재 사용자가 진공 권한을 가지고있는 현재 데이터베이스의 모든 테이블 및 구체화 된보기를 처리합니다. &lt;code&gt;VACUUM&lt;/code&gt; 은 목록을 사용하여 해당 테이블 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2564642da39c57e6f0da0af32cec7b221b00e6cf" translate="yes" xml:space="preserve">
          <source>Without a qualification, &lt;code&gt;DELETE&lt;/code&gt; will remove &lt;em&gt;all&lt;/em&gt; rows from the given table, leaving it empty. The system will not request confirmation before doing this!</source>
          <target state="translated">규정이 없으면 &lt;code&gt;DELETE&lt;/code&gt; 는 주어진 테이블에서 &lt;em&gt;모든&lt;/em&gt; 행을 제거 하고 비워 둡니다. 시스템은이를 수행하기 전에 확인을 요청하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="63fcdcc5d8356bd3ccce31a7a0f56d4a3af85303" translate="yes" xml:space="preserve">
          <source>Without functional-dependency statistics, the planner would assume that the two &lt;code&gt;WHERE&lt;/code&gt; conditions are independent, and would multiply their selectivities together to arrive at a much-too-small row count estimate. With such statistics, the planner recognizes that the &lt;code&gt;WHERE&lt;/code&gt; conditions are redundant and does not underestimate the row count.</source>
          <target state="translated">기능적 의존성 통계가 없으면, 계획자는 두 &lt;code&gt;WHERE&lt;/code&gt; 조건이 독립적 이라고 가정 하고 선택성을 곱하여 너무 작은 행 수 추정치에 도달합니다. 이러한 통계를 통해 플래너는 &lt;code&gt;WHERE&lt;/code&gt; 조건이 중복되고 행 수를 과소 평가하지 않음을 인식합니다 .</target>
        </trans-unit>
        <trans-unit id="dc783547ace7f2e9e22e7b50a67f3d97784d6474" translate="yes" xml:space="preserve">
          <source>Without partition pruning, the above query would scan each of the partitions of the &lt;code&gt;measurement&lt;/code&gt; table. With partition pruning enabled, the planner will examine the definition of each partition and prove that the partition need not be scanned because it could not contain any rows meeting the query's &lt;code&gt;WHERE&lt;/code&gt; clause. When the planner can prove this, it excludes (&lt;em&gt;prunes&lt;/em&gt;) the partition from the query plan.</source>
          <target state="translated">파티션 프 루닝이 없으면 위의 쿼리는 &lt;code&gt;measurement&lt;/code&gt; 테이블 의 각 파티션을 스캔 합니다. 파티션 정리를 사용하면 플래너는 각 파티션의 정의를 검사하고 쿼리의 &lt;code&gt;WHERE&lt;/code&gt; 절을 충족하는 행을 포함 할 수 없으므로 파티션을 스캔 할 필요가 없음을 증명합니다 . 플래너는 이것을 증명할 수있는 때 (제외 &lt;em&gt;자두&lt;/em&gt; ) 쿼리 계획에서 파티션을.</target>
        </trans-unit>
        <trans-unit id="23034486b72d6e700160ee9f0facdf636985eee4" translate="yes" xml:space="preserve">
          <source>Without quotes, &lt;code&gt;to_tsquery&lt;/code&gt; will generate a syntax error for tokens that are not separated by an AND, OR, or FOLLOWED BY operator.</source>
          <target state="translated">따옴표가 없으면 &lt;code&gt;to_tsquery&lt;/code&gt; 는 AND, OR 또는 FOLLOWED BY 연산자로 구분되지 않은 토큰에 대해 구문 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8d1c012acaa571247fa7393ff98695c754cfacba" translate="yes" xml:space="preserve">
          <source>Without the extra parentheses, this will generate a syntax error.</source>
          <target state="translated">추가 괄호가 없으면 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3003268a98f289ec381313920f30367739bc175f" translate="yes" xml:space="preserve">
          <source>Without the third rule, it is possible for an index reader to see an index entry just before it is removed by &lt;code&gt;VACUUM&lt;/code&gt;, and then to arrive at the corresponding heap entry after that was removed by &lt;code&gt;VACUUM&lt;/code&gt;. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by &lt;code&gt;heap_fetch()&lt;/code&gt;. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as &lt;code&gt;SnapshotAny&lt;/code&gt;), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be &amp;ldquo;in flight&amp;rdquo; from the index entry to the matching heap entry. Making &lt;code&gt;ambulkdelete&lt;/code&gt; block on such a pin ensures that &lt;code&gt;VACUUM&lt;/code&gt; cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict.</source>
          <target state="translated">인덱스 리더가 제거되기 직전에 인덱스 항목을 참조하는 제 규칙 없이는 가능 &lt;code&gt;VACUUM&lt;/code&gt; 그 의해 제거한 후 해당 힙 입구에 도착 후, 그리고 &lt;code&gt;VACUUM&lt;/code&gt; . 빈 항목 슬롯은 &lt;code&gt;heap_fetch()&lt;/code&gt; 의해 무시되므로, 항목 번호가 판독기에 도달 할 때 해당 항목 번호를 여전히 사용하지 않으면 심각한 문제가 발생하지 않습니다 . 그러나 세 번째 백엔드에서 이미 아이템 슬롯을 다른 용도로 재사용 한 경우 어떻게해야합니까? MVCC 호환 스냅 샷을 사용하는 경우, 슬롯의 새 점유자가 스냅 샷 테스트를 통과하기에는 너무 새롭기 때문에 문제가 없습니다. 그러나 비 MVCC 호환 스냅 샷 (예 : &lt;code&gt;SnapshotAny&lt;/code&gt; )), 실제로 스캔 키와 일치하지 않는 행을 승인하고 리턴 할 수 있습니다. 모든 경우에 힙 키에 대해 스캔 키를 다시 확인하도록함으로써이 시나리오를 막을 수는 있지만 너무 비쌉니다. 대신, 색인 페이지의 핀을 프록시로 사용하여 독자가 색인 항목에서 일치하는 힙 항목으로 &quot;비행 중&quot;임을 나타낼 수 있습니다. 이러한 핀에 &lt;code&gt;ambulkdelete&lt;/code&gt; 블록을 만들면 판독기가 완료되기 전에 &lt;code&gt;VACUUM&lt;/code&gt; 이 힙 항목을 삭제할 수 없습니다. 이 솔루션은 런타임 비용이 거의 들지 않으며 실제로 충돌이 발생하는 드문 경우에만 블로킹 오버 헤드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fdba0729d7141c4dc983525f28420a370b378b16" translate="yes" xml:space="preserve">
          <source>Without this clause, it is an error to specify an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) for an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;. This clause overrides that restriction.</source>
          <target state="translated">이 절이 없으면 &lt;code&gt;GENERATED ALWAYS&lt;/code&gt; 로 정의 된 식별 컬럼에 명시 적 값 ( &lt;code&gt;DEFAULT&lt;/code&gt; 이외 ) 을 지정하는 것은 오류 입니다. 이 절은 해당 제한을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5de5c631615b4050dbf3abcb11bda852949d1d49" translate="yes" xml:space="preserve">
          <source>Word, all ASCII letters</source>
          <target state="translated">단어, 모든 ASCII 문자</target>
        </trans-unit>
        <trans-unit id="cd638519c2bb50f94881c41d59edcf0f4b988187" translate="yes" xml:space="preserve">
          <source>Word, all letters</source>
          <target state="translated">단어, 모든 글자</target>
        </trans-unit>
        <trans-unit id="d929261f89fb5edc0a55361dccd5a42cfafc1e28" translate="yes" xml:space="preserve">
          <source>Word, letters and digits</source>
          <target state="translated">단어, 문자 및 숫자</target>
        </trans-unit>
        <trans-unit id="1c821c5f35490070199526bcafeccdc95331fb80" translate="yes" xml:space="preserve">
          <source>Work is still needed to improve the genetic algorithm parameter settings. In file &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt;, routines &lt;code&gt;gimme_pool_size&lt;/code&gt; and &lt;code&gt;gimme_number_generations&lt;/code&gt;, we have to find a compromise for the parameter settings to satisfy two competing demands:</source>
          <target state="translated">유전자 알고리즘 매개 변수 설정을 개선하기위한 작업이 여전히 필요합니다. 파일에서 &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt; , 루틴 &lt;code&gt;gimme_pool_size&lt;/code&gt; 및 &lt;code&gt;gimme_number_generations&lt;/code&gt; 는 , 우리는이 개 경쟁하는 요구를 충족 할 수있는 매개 변수 설정에 대한 타협을 찾을 수있다 :</target>
        </trans-unit>
        <trans-unit id="3ae6871c604e1194dadbdf1baf868fa3278d7cc4" translate="yes" xml:space="preserve">
          <source>Write Ahead Log</source>
          <target state="translated">미리 기록</target>
        </trans-unit>
        <trans-unit id="3f9793b6786fb282a995505c49ca5c8dab4849b1" translate="yes" xml:space="preserve">
          <source>Write a message to the server log if checkpoints caused by the filling of WAL segment files happen closer together than this amount of time (which suggests that &lt;code&gt;max_wal_size&lt;/code&gt; ought to be raised). If this value is specified without units, it is taken as seconds. The default is 30 seconds (&lt;code&gt;30s&lt;/code&gt;). Zero disables the warning. No warnings will be generated if &lt;code&gt;checkpoint_timeout&lt;/code&gt; is less than &lt;code&gt;checkpoint_warning&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WAL 세그먼트 파일 채우기로 인한 체크 포인트가이 시간보다 더 긴 시간에 근접하면 서버 로그에 메시지를 작성하십시오 ( &lt;code&gt;max_wal_size&lt;/code&gt; 가 높아져야 함을 나타냄 ). 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 기본값은 30 초입니다 ( &lt;code&gt;30s&lt;/code&gt; ). 0은 경고를 비활성화합니다. &lt;code&gt;checkpoint_timeout&lt;/code&gt; 이 &lt;code&gt;checkpoint_warning&lt;/code&gt; 보다 작은 경우 경고가 생성되지 않습니다 . 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79f29b256742ae32a7ee610c6c80dec55fe4bb44" translate="yes" xml:space="preserve">
          <source>Write all query output into file &lt;code&gt;filename&lt;/code&gt;, in addition to the normal output destination.</source>
          <target state="translated">일반 출력 대상 외에 모든 쿼리 출력을 파일 &lt;code&gt;filename&lt;/code&gt; 에 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="ced9f94f9040a73c60549d122b831459c11a3fbf" translate="yes" xml:space="preserve">
          <source>Write information about each transaction to a log file. See below for details.</source>
          <target state="translated">각 트랜잭션에 대한 정보를 로그 파일에 기록하십시오. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e33b6c1a70b5c50c6203011bb22d6394a5061934" translate="yes" xml:space="preserve">
          <source>Write received and decoded transaction data into this file. Use &lt;code&gt;-&lt;/code&gt; for stdout.</source>
          <target state="translated">수신 및 디코딩 된 트랜잭션 데이터를이 파일에 씁니다. stdout에 &lt;code&gt;-&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="660438e8219803d5c64d3c38fd0601dbee576ac1" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the current data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the server.</source>
          <target state="translated">현재 데이터 디렉토리 및 테이블 스페이스와 동일한 레이아웃으로 출력을 일반 파일로 작성하십시오. 클러스터에 추가 테이블 스페이스가 없으면 전체 데이터베이스가 대상 디렉토리에 배치됩니다. 클러스터에 추가 테이블 스페이스가 포함 된 경우 기본 데이터 디렉토리는 대상 디렉토리에 배치되지만 다른 모든 테이블 스페이스는 서버에서와 동일한 절대 경로에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc92c3f4b6de8494f22f127e95dec8313f91169" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and all other tablespaces will be named after the tablespace OID.</source>
          <target state="translated">출력을 대상 디렉토리에 tar 파일로 작성하십시오. 기본 데이터 디렉토리는 &lt;code&gt;base.tar&lt;/code&gt; 라는 파일에 작성되며 다른 모든 테이블 스페이스는 테이블 스페이스 OID의 이름을 따서 명명됩니다.</target>
        </trans-unit>
        <trans-unit id="12aba288e98df3f05ebad1cf7143b1a4df822af8" translate="yes" xml:space="preserve">
          <source>Write, or append to, a text file</source>
          <target state="translated">텍스트 파일 쓰기 또는 추가</target>
        </trans-unit>
        <trans-unit id="73694598d4f6dd9ae50f65c44a8d5357103fbda0" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log</source>
          <target state="translated">미리 쓰기 로그</target>
        </trans-unit>
        <trans-unit id="32219ea741aab08cd4b2cc75491ff92cd882b3c1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Shipping</source>
          <target state="translated">미리 쓰기 로그 배송</target>
        </trans-unit>
        <trans-unit id="674bcf8c81a59458958b21d0660da76f6ba332b5" translate="yes" xml:space="preserve">
          <source>Writes the current query buffer to the file &lt;code&gt;filename&lt;/code&gt; or pipes it to the shell command &lt;code&gt;command&lt;/code&gt;. If the current query buffer is empty, the most recently executed query is written instead.</source>
          <target state="translated">현재 쿼리 버퍼를 파일 파일 &lt;code&gt;filename&lt;/code&gt; 쓰거나 쉘 명령 &lt;code&gt;command&lt;/code&gt; 파이프합니다 . 현재 쿼리 버퍼가 비어 있으면 가장 최근에 실행 된 쿼리가 대신 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b84228914215a42dbe6fe7e926dad3ab9b4cf367" translate="yes" xml:space="preserve">
          <source>Writes the generated LLVM IR out to the file system, inside &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;. This is only useful for working on the internals of the JIT implementation. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be changed by a superuser.</source>
          <target state="translated">생성 된 LLVM IR을 &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt; 내의 파일 시스템에 기록 합니다. 이것은 JIT 구현의 내부 작업에만 유용합니다. 기본 설정은 &lt;code&gt;off&lt;/code&gt; 입니다. 이 매개 변수는 수퍼 유저 만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5af6404c7f764d57f9d5c62315cdf9f310e1309" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;*&lt;/code&gt; is not necessary, since this behavior is always the default. However, this syntax is still supported for compatibility with older releases where the default could be changed.</source>
          <target state="translated">작성 &lt;code&gt;*&lt;/code&gt; 것은 이 동작은 항상 기본이기 때문에, 필요하지 않습니다. 그러나이 구문은 기본값을 변경할 수있는 이전 릴리스와의 호환성을 위해 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6151e701c60f047c7b832b2686813d1310a12fca" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;ALL&lt;/code&gt; in place of a specific privilege grants all privileges that are relevant for the object type.</source>
          <target state="translated">특정 권한 대신 &lt;code&gt;ALL&lt;/code&gt; 을 쓰면 개체 유형과 관련된 모든 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="f43277b6f1b770dadde2ceed80f27334202f924f" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;SECURITY DEFINER&lt;/code&gt; Functions Safely</source>
          <target state="translated">&lt;code&gt;SECURITY DEFINER&lt;/code&gt; 함수를 안전하게 작성</target>
        </trans-unit>
        <trans-unit id="ffbf328be37b139670f7ef37c6af175473c5c705" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 여러 언어 바인딩 중 하나를 사용하여 사용자 지정 응용 프로그램 작성 이러한 가능성에 대해서는 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;4 부&lt;/a&gt; 에서 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="de5165fc57d1f9a5e5c5994fec1932df3a128a9e" translate="yes" xml:space="preserve">
          <source>Writing the actual numeric value of any OID in C code is considered very bad form; always use a macro, instead. Direct references to &lt;code&gt;pg_proc&lt;/code&gt; OIDs are common enough that there's a special mechanism to create the necessary macros automatically; see &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt;. Similarly &amp;mdash; but, for historical reasons, not done the same way &amp;mdash; there's an automatic method for creating macros for &lt;code&gt;pg_type&lt;/code&gt; OIDs. &lt;code&gt;oid_symbol&lt;/code&gt; entries are therefore not necessary in those two catalogs. Likewise, macros for the &lt;code&gt;pg_class&lt;/code&gt; OIDs of system catalogs and indexes are set up automatically. For all other system catalogs, you have to manually specify any macros you need via &lt;code&gt;oid_symbol&lt;/code&gt; entries.</source>
          <target state="translated">C 코드에서 OID의 실제 숫자 값을 쓰는 것은 매우 나쁜 형태로 간주됩니다. 대신 항상 매크로를 사용하십시오. &lt;code&gt;pg_proc&lt;/code&gt; OID에 대한 직접적인 참조 는 필요한 매크로를 자동으로 생성하는 특별한 메커니즘이있을 정도로 일반적입니다. &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt; 을 참조하십시오 . 마찬가지로 역사적으로 같은 방식으로 수행되지는 않았지만 &lt;code&gt;pg_type&lt;/code&gt; OID에 대한 매크로를 자동으로 생성하는 방법이 있습니다. 따라서 &lt;code&gt;oid_symbol&lt;/code&gt; 항목은이 두 카탈로그에서 필요하지 않습니다. 마찬가지로 시스템 카탈로그 및 인덱스 의 &lt;code&gt;pg_class&lt;/code&gt; OID에 대한 매크로가 자동으로 설정됩니다. 다른 모든 시스템 카탈로그의 경우 &lt;code&gt;oid_symbol&lt;/code&gt; 항목을 통해 필요한 매크로를 수동으로 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="d5409f1461aa5b5298ee6d5c93002f7a27e50654" translate="yes" xml:space="preserve">
          <source>XID</source>
          <target state="translated">XID</target>
        </trans-unit>
        <trans-unit id="70fc167721857c5174dbbe545fe597100e840cd6" translate="yes" xml:space="preserve">
          <source>XID for VACUUM operation moving a row version</source>
          <target state="translated">행 버전을 이동하는 VACUUM 조 작용 XID</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="6dbc2e3a95bd424284a60fab71bfd99ecc6aa480" translate="yes" xml:space="preserve">
          <source>XML Functions</source>
          <target state="translated">XML 함수</target>
        </trans-unit>
        <trans-unit id="677fbcd727fb96243fff280b768de17534da204d" translate="yes" xml:space="preserve">
          <source>XML Limits and Conformance to SQL/XML</source>
          <target state="translated">SQL / XML에 대한 XML 제한 및 적합성</target>
        </trans-unit>
        <trans-unit id="be1200e7280e074bb09cc29b489d7736fa9c3b13" translate="yes" xml:space="preserve">
          <source>XML Type</source>
          <target state="translated">XML 타입</target>
        </trans-unit>
        <trans-unit id="72f6e6e18c4cf2cdf2736a3171665401b5f531b0" translate="yes" xml:space="preserve">
          <source>XML data</source>
          <target state="translated">XML 데이터</target>
        </trans-unit>
        <trans-unit id="9bc2b7976718250ab1463410139c7c00b0f2e7ce" translate="yes" xml:space="preserve">
          <source>XML declarations, if present, are combined as follows. If all argument values have the same XML version declaration, that version is used in the result, else no version is used. If all argument values have the standalone declaration value &amp;ldquo;yes&amp;rdquo;, then that value is used in the result. If all argument values have a standalone declaration value and at least one is &amp;ldquo;no&amp;rdquo;, then that is used in the result. Else the result will have no standalone declaration. If the result is determined to require a standalone declaration but no version declaration, a version declaration with version 1.0 will be used because XML requires an XML declaration to contain a version declaration. Encoding declarations are ignored and removed in all cases.</source>
          <target state="translated">XML 선언이있는 경우 다음과 같이 결합됩니다. 모든 인수 값이 동일한 XML 버전 선언을 갖는 경우 해당 버전이 결과에 사용되며, 그렇지 않으면 버전이 사용되지 않습니다. 모든 인수 값에 독립형 선언 값 &quot;yes&quot;가 있으면 해당 값이 결과에 사용됩니다. 모든 인수 값에 독립형 선언 값이 있고 하나 이상이 &quot;아니오&quot;이면 결과에 사용됩니다. 그렇지 않으면 결과에 독립형 선언이 없습니다. 결과에 독립형 선언이 필요하지만 버전 선언은 필요하지 않은 것으로 판명되면 XML에 버전 선언을 포함하는 XML 선언이 필요하므로 버전 1.0의 버전 선언이 사용됩니다. 인코딩 선언은 모든 경우에 무시되고 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="93db77a518a3a65df06b8910ae3df05493323aa8" translate="yes" xml:space="preserve">
          <source>XML entity</source>
          <target state="translated">XML 엔터티</target>
        </trans-unit>
        <trans-unit id="41d948a6e01de6c3d4845c4fb6a9cd77bb4a345f" translate="yes" xml:space="preserve">
          <source>XML format is left as an exercise for the reader.</source>
          <target state="translated">XML 형식은 독자의 연습으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="c648229e46576f92e57966e5bb6a169947ab07af" translate="yes" xml:space="preserve">
          <source>XML tag</source>
          <target state="translated">XML 태그</target>
        </trans-unit>
        <trans-unit id="b7b6740d5d3d1f4067adb9c002cd0cc814ec4855" translate="yes" xml:space="preserve">
          <source>XML: IS DOCUMENT</source>
          <target state="translated">XML : 문서</target>
        </trans-unit>
        <trans-unit id="863fe78f50c66a6f7d93b18bf787a5d0aa670b5c" translate="yes" xml:space="preserve">
          <source>XML: IS NOT DOCUMENT</source>
          <target state="translated">XML : 문서가 아님</target>
        </trans-unit>
        <trans-unit id="708b35917f64aea4aecf43902f9f6861b388f0a3" translate="yes" xml:space="preserve">
          <source>XML: XMLEXISTS</source>
          <target state="translated">XML : XMLEXISTS</target>
        </trans-unit>
        <trans-unit id="7aea648b2b4e07c316d48e040a2dfe07aea119ed" translate="yes" xml:space="preserve">
          <source>XML: xml_is_well_formed</source>
          <target state="translated">XML : xml_is_well_formed</target>
        </trans-unit>
        <trans-unit id="3eca7373df1b8e0c5ed4c506c73dcc360d0c1000" translate="yes" xml:space="preserve">
          <source>XML: xmlagg</source>
          <target state="translated">XML : xmlagg</target>
        </trans-unit>
        <trans-unit id="31986b6f48c236780bb28b6f7a97cd2e7fe2fbbc" translate="yes" xml:space="preserve">
          <source>XML: xmlcomment</source>
          <target state="translated">XML : xmlcomment</target>
        </trans-unit>
        <trans-unit id="3336319324aa48adbaa76e0cbbf9934042dd41f7" translate="yes" xml:space="preserve">
          <source>XML: xmlconcat</source>
          <target state="translated">XML : xmlconcat</target>
        </trans-unit>
        <trans-unit id="c269b1860c6e177984dcd77f1f2f9180f500a7b1" translate="yes" xml:space="preserve">
          <source>XML: xmlelement</source>
          <target state="translated">XML : xmlelement</target>
        </trans-unit>
        <trans-unit id="f6f6cd60dad73c2efa2b22421846170fa537daf4" translate="yes" xml:space="preserve">
          <source>XML: xmlforest</source>
          <target state="translated">XML : xmlforest</target>
        </trans-unit>
        <trans-unit id="b4c3ab3b44e0a9d5e8cf4d618e5fb213a70446ae" translate="yes" xml:space="preserve">
          <source>XML: xmlpi</source>
          <target state="translated">XML : xmlpi</target>
        </trans-unit>
        <trans-unit id="2cb9abaad07f3be72c6b803b64719f6ad9373b8b" translate="yes" xml:space="preserve">
          <source>XML: xmlroot</source>
          <target state="translated">XML : xmlroot</target>
        </trans-unit>
        <trans-unit id="fe1c1afeea56eb4d61a6d5854b178d21b29bd194" translate="yes" xml:space="preserve">
          <source>XML: xmltable</source>
          <target state="translated">XML : xmltable</target>
        </trans-unit>
        <trans-unit id="943bcc21921946abacf747784b147601338c43bb" translate="yes" xml:space="preserve">
          <source>XML: xpath</source>
          <target state="translated">XML : xpath</target>
        </trans-unit>
        <trans-unit id="112eb0200c63c2f0de87632cdeab3a1c8a706831" translate="yes" xml:space="preserve">
          <source>XML: xpath_exists</source>
          <target state="translated">XML : xpath_exists</target>
        </trans-unit>
        <trans-unit id="a417f6430ccc4b644617c160b0d4f1b2c80cd5e2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 blurs the distinction between &lt;em&gt;value comparisons&lt;/em&gt; and &lt;em&gt;general comparisons&lt;/em&gt; as XQuery/XPath define them. Both &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; and &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; are existentially quantified comparisons, true if there is any &lt;code&gt;sale&lt;/code&gt; with the given value for the attribute, but &lt;code&gt;sale/@taxable = false()&lt;/code&gt; is a value comparison to the &lt;em&gt;effective boolean value&lt;/em&gt; of a whole node-set. It is true only if no &lt;code&gt;sale&lt;/code&gt; has a &lt;code&gt;taxable&lt;/code&gt; attribute at all.</source>
          <target state="translated">XPath 1.0 은 XQuery / XPath에서 정의한 &lt;em&gt;값 비교&lt;/em&gt; 와 &lt;em&gt;일반 비교&lt;/em&gt; 의 차이점을 흐리게 합니다. &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; 및 &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; 는 모두 실질적으로 정량화 된 비교 입니다. 속성에 대해 주어진 값을 가진 &lt;code&gt;sale&lt;/code&gt; 있는 경우 true 이지만 &lt;code&gt;sale/@taxable = false()&lt;/code&gt; 는 전체 노드 세트의 &lt;em&gt;유효 부울 값 &lt;/em&gt; &lt;code&gt;taxable&lt;/code&gt; 속성 이 없는 &lt;code&gt;sale&lt;/code&gt; 없는 경우에만 해당됩니다 .</target>
        </trans-unit>
        <trans-unit id="f37617c0d5dc43deba6ebd523a1e7daa408818b2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 does not specify an order for nodes in a node-set, so code that relies on a particular order of the results will be implementation-dependent. Details can be found in &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;Section D.3.1.2&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0은 노드 세트의 노드 순서를 지정하지 않으므로 결과의 특정 순서에 의존하는 코드는 구현에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;섹션 D.3.1.2&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccec9b819d48fea6e95ee65b1f2c2363e5212016" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no conditional operator. An XQuery/XPath expression such as &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; has no XPath 1.0 equivalent.</source>
          <target state="translated">XPath 1.0에는 조건부 연산자가 없습니다. &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; 과 같은 XQuery / XPath 표현식 에는 XPath 1.0에 해당하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="575a5727a0aaf2dc929963572ab31f3a07d3b31b" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no ordering comparison operator for strings. Both &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; and &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; are false, because each is a numeric comparison of two &lt;code&gt;NaN&lt;/code&gt;s. In contrast, &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; do compare the strings as strings.</source>
          <target state="translated">XPath 1.0에는 문자열에 대한 순서 비교 연산자가 없습니다. 모두 &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; 각각 두 개의 숫자 비교이기 때문에, 거짓 &lt;code&gt;NaN&lt;/code&gt; 이 들. 반대로 &lt;code&gt;=&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; 는 문자열을 문자열로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="8c4149ee47a54aa2c037b2786d8549ef1627ad8e" translate="yes" xml:space="preserve">
          <source>XQuery allows declaration and use of local functions.</source>
          <target state="translated">XQuery는 로컬 함수의 선언 및 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="818970bcffceb4be8cc185fddd03719babd24f42" translate="yes" xml:space="preserve">
          <source>XQuery character class elements using &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; or the inverse &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; are not supported.</source>
          <target state="translated">&lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; 또는 역 &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; 사용하는 XQuery 문자 클래스 요소 는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f9675f91b1bee552c1436f5af897518b9d66036" translate="yes" xml:space="preserve">
          <source>XQuery character class shorthands &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\i&lt;/code&gt;, and &lt;code&gt;\I&lt;/code&gt; are not supported.</source>
          <target state="translated">XQuery 문자 클래스 속기 &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\C&lt;/code&gt; , &lt;code&gt;\i&lt;/code&gt; 및 &lt;code&gt;\I&lt;/code&gt; 는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e05d40877e991191e09256daf83989a5f47e5557" translate="yes" xml:space="preserve">
          <source>XQuery character class subtraction is not supported. An example of this feature is using the following to match only English consonants: &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt;.</source>
          <target state="translated">XQuery 문자 클래스 빼기는 지원되지 않습니다. 이 기능의 예는 다음을 사용하여 영어 자음 만 일치시킵니다. &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ba7fb2ffaaf928a3568f9854442e7071379dc9" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">XQuery에는 lookahead 또는 lookbehind 제약 조건이 없으며 &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;표 9.21에&lt;/a&gt; 설명 된 제약 조건 이스케이프가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="41577214ab7c5c54db475c958675a49fbb00b4a6" translate="yes" xml:space="preserve">
          <source>XQuery does not support the &lt;code&gt;[:name:]&lt;/code&gt; syntax for character classes within bracket expressions.</source>
          <target state="translated">XQuery는 대괄호 표현식 내의 문자 클래스에 대해 &lt;code&gt;[:name:]&lt;/code&gt; 구문을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e0c3c6ff5da1ba3d8311b799d1cf51c7385d7c2" translate="yes" xml:space="preserve">
          <source>XQuery expressions can construct and return new XML nodes, in addition to all possible XPath values. XPath can create and return values of the atomic types (numbers, strings, and so on) but can only return XML nodes that were already present in documents supplied as input to the expression.</source>
          <target state="translated">XQuery 표현식은 가능한 모든 XPath 값 외에도 새로운 XML 노드를 구성하고 리턴 할 수 있습니다. XPath는 원자 유형 (숫자, 문자열 등)의 값을 작성하고 리턴 할 수 있지만 표현식의 입력으로 제공된 문서에 이미 존재하는 XML 노드 만 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d07dea26dd7592af4147bb1ae9d21c709ece2a7" translate="yes" xml:space="preserve">
          <source>XQuery has control constructs for iteration, sorting, and grouping.</source>
          <target state="translated">XQuery에는 반복, 정렬 및 그룹화를위한 제어 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9add350a4eb532be8a2c9c9d393be8bd03cceb66" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;s&lt;/code&gt; (allow dot to match newline) and &lt;code&gt;m&lt;/code&gt; (allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines) flags provide access to the same behaviors as POSIX's &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; flags, but they do &lt;em&gt;not&lt;/em&gt; match the behavior of POSIX's &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; flags. Note in particular that dot-matches-newline is the default behavior in POSIX but not XQuery.</source>
          <target state="translated">XQuery의 &lt;code&gt;s&lt;/code&gt; (개행과 일치하는 도트 허용) 및 &lt;code&gt;m&lt;/code&gt; ( 개행과 일치 하는 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 허용 ) 플래그는 POSIX의 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;w&lt;/code&gt; 플래그 와 동일한 동작에 액세스 할 수 있지만 POSIX의 &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;m&lt;/code&gt; 플래그 의 동작과 일치 하지 &lt;em&gt;않습니다.&lt;/em&gt; . 특히 dot-matches-newline은 POSIX의 기본 동작이지만 XQuery는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0fbdf61430816231b42e0b59499fabbec39b5ae3" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;x&lt;/code&gt; (ignore whitespace in pattern) flag is noticeably different from POSIX's expanded-mode flag. POSIX's &lt;code&gt;x&lt;/code&gt; flag also allows &lt;code&gt;#&lt;/code&gt; to begin a comment in the pattern, and POSIX will not ignore a whitespace character after a backslash.</source>
          <target state="translated">XQuery의 &lt;code&gt;x&lt;/code&gt; (패턴에서 공백 무시) 플래그는 POSIX의 확장 모드 플래그와 현저히 다릅니다. POSIX의 &lt;code&gt;x&lt;/code&gt; 플래그는 또한 &lt;code&gt;#&lt;/code&gt; 이 패턴에서 주석을 시작할 수있게 하며 POSIX는 백 슬래시 후 공백 문자를 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="cb29757e458776404c0d0c4f5c75b0740d559b1c" translate="yes" xml:space="preserve">
          <source>Year and day of year: for example &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; also returns &lt;code&gt;2006-10-19&lt;/code&gt;.</source>
          <target state="translated">연도 및 연도 : 예를 들어 &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; 는 &lt;code&gt;2006-10-19&lt;/code&gt; 도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fc5a18c267810c3dc6c5d4fdd0b02c9e146fd0f1" translate="yes" xml:space="preserve">
          <source>Year, week number, and weekday: for example &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; returns the date &lt;code&gt;2006-10-19&lt;/code&gt;. If you omit the weekday it is assumed to be 1 (Monday).</source>
          <target state="translated">연도, 주 번호 및 요일 : 예를 들어 &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; 는 &lt;code&gt;2006-10-19&lt;/code&gt; 날짜를 반환합니다 . 평일을 생략하면 1 (월요일)로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7abdb2567a06fc713cd1d6b57e90f634441b367e" translate="yes" xml:space="preserve">
          <source>Year-Month Interval</source>
          <target state="translated">년-월 간격</target>
        </trans-unit>
        <trans-unit id="96f997bcecb36502ed4b296a795f72aff9d6bfe7" translate="yes" xml:space="preserve">
          <source>Years</source>
          <target state="translated">Years</target>
        </trans-unit>
        <trans-unit id="3cfd5c7e576642a9c9f3bbe4db929041cea0177f" translate="yes" xml:space="preserve">
          <source>Years in the 1900s are in the second millennium. The third millennium started January 1, 2001.</source>
          <target state="translated">1900 년대는 2 천년입니다. 세 번째 밀레니엄은 2001 년 1 월 1 일에 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="6dd15150afde3fb668c9c37b5570c9f350a42483" translate="yes" xml:space="preserve">
          <source>You can (and, for most purposes, probably should) increase the number of rows by using the &lt;code&gt;-s&lt;/code&gt; (scale factor) option. The &lt;code&gt;-F&lt;/code&gt; (fillfactor) option might also be used at this point.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; (scale factor) 옵션 을 사용하여 행 수를 늘릴 수 있습니다 (대부분의 경우 아마도 ). &lt;code&gt;-F&lt;/code&gt; (FILLFACTOR) 옵션은이 시점에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="145c00d5953681c62f21c82b058caafeee2a8310" translate="yes" xml:space="preserve">
          <source>You can adapt this module to your needs by changing the source code. For example, you can use &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; to check passwords &amp;mdash; this only requires uncommenting two lines in the &lt;code&gt;Makefile&lt;/code&gt; and rebuilding the module. (We cannot include CrackLib by default for license reasons.) Without CrackLib, the module enforces a few simple rules for password strength, which you can modify or extend as you see fit.</source>
          <target state="translated">소스 코드를 변경하여이 모듈을 필요에 맞게 조정할 수 있습니다. 예를 들어 &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; 을 사용 하여 비밀번호를 확인할 수 있습니다 . &lt;code&gt;Makefile&lt;/code&gt; 에서 두 줄의 주석 처리를 제거 하고 모듈을 다시 작성하면됩니다. 라이센스 이유로 인해 기본적으로 CrackLib을 포함 할 수 없습니다. CrackLib이 없으면 모듈은 비밀번호 강도에 대한 몇 가지 간단한 규칙을 적용하며, 사용자가 원하는대로 수정하거나 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28dae3ce662983a3720ca411f5e625f764893bf1" translate="yes" xml:space="preserve">
          <source>You can add whitespace before a left brace or after a right brace. You can also add whitespace before or after any individual item string. In all of these cases the whitespace will be ignored. However, whitespace within double-quoted elements, or surrounded on both sides by non-whitespace characters of an element, is not ignored.</source>
          <target state="translated">왼쪽 괄호 앞이나 오른쪽 괄호 뒤에 공백을 추가 할 수 있습니다. 개별 항목 문자열 앞뒤에 공백을 추가 할 수도 있습니다. 이 모든 경우에 공백은 무시됩니다. 그러나 큰 따옴표로 묶은 요소 내의 공백이나 요소의 공백이 아닌 문자로 양쪽에 둘러싸인 공백은 무시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="569893ff6c39724a565a145b8a3ad3a0b9606463" translate="yes" xml:space="preserve">
          <source>You can adjust the ordering of a B-tree index by including the options &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; when creating the index; for example:</source>
          <target state="translated">인덱스를 만들 때 &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; , &lt;code&gt;NULLS FIRST&lt;/code&gt; 및 / 또는 &lt;code&gt;NULLS LAST&lt;/code&gt; 옵션을 포함시켜 B- 트리 인덱스의 순서를 조정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b7d9d02889a217be36bf8f71750c721f9d62b3a" translate="yes" xml:space="preserve">
          <source>You can also control the order in which rows are processed by window functions using &lt;code&gt;ORDER BY&lt;/code&gt; within &lt;code&gt;OVER&lt;/code&gt;. (The window &lt;code&gt;ORDER BY&lt;/code&gt; does not even have to match the order in which the rows are output.) Here is an example:</source>
          <target state="translated">&lt;code&gt;OVER&lt;/code&gt; 내에서 &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용하여 창 함수에 의해 행이 처리되는 순서를 제어 할 수도 있습니다 . ( &lt;code&gt;ORDER BY&lt;/code&gt; 창 은 행이 출력되는 순서와 일치하지 않아도됩니다.) 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8031e0a82c5477e58a31c17656bff548035b193" translate="yes" xml:space="preserve">
          <source>You can also create databases with other names. PostgreSQL allows you to create any number of databases at a given site. Database names must have an alphabetic first character and are limited to 63 bytes in length. A convenient choice is to create a database with the same name as your current user name. Many tools assume that database name as the default, so it can save you some typing. To create that database, simply type:</source>
          <target state="translated">다른 이름으로 데이터베이스를 만들 수도 있습니다. PostgreSQL을 사용하면 특정 사이트에서 여러 데이터베이스를 만들 수 있습니다. 데이터베이스 이름은 알파벳 첫 문자를 가져야하며 길이는 63 바이트로 제한됩니다. 편리한 선택은 현재 사용자 이름과 동일한 이름으로 데이터베이스를 작성하는 것입니다. 많은 도구가 데이터베이스 이름을 기본값으로 가정하므로 일부 입력을 저장할 수 있습니다. 해당 데이터베이스를 작성하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="2855332ddeec7909c633615734e0f09916910215" translate="yes" xml:space="preserve">
          <source>You can also define constraints on the column at the same time, using the usual syntax:</source>
          <target state="translated">일반적인 구문을 사용하여 열에 대한 제약 조건을 동시에 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1e40e96d3d99c788ff89c86039beb4c7ae5ad3" translate="yes" xml:space="preserve">
          <source>You can also force the insertion of invalid numbers even when not in the weak mode, by appending the &lt;code&gt;!&lt;/code&gt; character at the end of the number.</source>
          <target state="translated">약한 모드가 아닌 경우에도 &lt;code&gt;!&lt;/code&gt; 를 추가하여 유효하지 않은 숫자를 강제로 삽입 할 수도 있습니다 . 숫자 끝에있는 문자.</target>
        </trans-unit>
        <trans-unit id="e92dd9f79aa93357545022991d035db8fa3c697a" translate="yes" xml:space="preserve">
          <source>You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:</source>
          <target state="translated">구속 조건에 별도의 이름을 지정할 수도 있습니다. 오류 메시지를 명확하게하고 변경해야 할 때 제약 조건을 참조 할 수 있습니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c0e733bb8f77339cb0554d27f0faf1999d777b7" translate="yes" xml:space="preserve">
          <source>You can also nest filter expressions within each other:</source>
          <target state="translated">필터 표현식을 서로 중첩시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="540c7cc55f43958519f25aa973c9e5a2c6dcb66b" translate="yes" xml:space="preserve">
          <source>You can also search an array using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, which checks whether the left operand overlaps with the right operand. For instance:</source>
          <target state="translated">왼쪽 피연산자가 오른쪽 피연산자와 겹치는 지 확인 하는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자를 사용하여 배열을 검색 할 수도 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="7317ad78770ade20f7fc205d1692cc3871b32860" translate="yes" xml:space="preserve">
          <source>You can also search for specific values in an array using the &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt; functions. The former returns the subscript of the first occurrence of a value in an array; the latter returns an array with the subscripts of all occurrences of the value in the array. For example:</source>
          <target state="translated">&lt;code&gt;array_position&lt;/code&gt; 및 &lt;code&gt;array_positions&lt;/code&gt; 함수를 사용하여 배열에서 특정 값을 검색 할 수도 있습니다. 전자는 배열에서 처음 나타나는 값의 첨자를 반환합니다. 후자는 배열에서 모든 값의 첨자 배열을 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72011efb5669336e4615ad697b69c64d57f8e812" translate="yes" xml:space="preserve">
          <source>You can also shorten the above command to:</source>
          <target state="translated">위 명령을 단축하여 다음을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="362c18912cf35df18fb18daa4743d6a04f75f78b" translate="yes" xml:space="preserve">
          <source>You can also write &lt;code&gt;all&lt;/code&gt; to match any IP address, &lt;code&gt;samehost&lt;/code&gt; to match any of the server's own IP addresses, or &lt;code&gt;samenet&lt;/code&gt; to match any address in any subnet that the server is directly connected to.</source>
          <target state="translated">당신은 또한 쓸 수있는 &lt;code&gt;all&lt;/code&gt; 모든 IP 주소와 일치하는 &lt;code&gt;samehost&lt;/code&gt; 서버의 자신의 IP 주소와 일치하거나 &lt;code&gt;samenet&lt;/code&gt; 을 서버가 직접 연결되어 있는지 어떤 서브넷의 모든 주소와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="81719f677a0ec0af21aab7f90315c40b111bfbd1" translate="yes" xml:space="preserve">
          <source>You can also write the table name with a trailing &lt;code&gt;*&lt;/code&gt; to explicitly specify that descendant tables are included:</source>
          <target state="translated">또한 후행 &lt;code&gt;*&lt;/code&gt; 가 포함 된 테이블 이름을 작성하여 하위 테이블이 포함되도록 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5703517ac040c492127e1fb49e5ced3da0debc99" translate="yes" xml:space="preserve">
          <source>You can ask for all fields of a composite value by writing &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 를 쓰면 복합 값의 모든 필드를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc07d5e0044a9e8829c097c35614fb4ad2ee919" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a foreign key constraint, in the usual way.</source>
          <target state="translated">일반적인 방식으로 외래 키 제약 조건에 고유 한 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78537f8a74bec7b625797355864a6e8b33eb27d6" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a unique constraint, in the usual way:</source>
          <target state="translated">일반적인 방식으로 고유 제한 조건에 고유 한 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4029bdb8227766d867d39118fde7beadbd5eab" translate="yes" xml:space="preserve">
          <source>You can avoid always having to write out a &lt;code&gt;FROM&lt;/code&gt; clause to define the output columns, by setting up a custom crosstab function that has the desired output row type wired into its definition. This is described in the next section. Another possibility is to embed the required &lt;code&gt;FROM&lt;/code&gt; clause in a view definition.</source>
          <target state="translated">원하는 출력 행 유형이 정의에 연결되어있는 사용자 정의 크로스 탭 함수를 설정하여 출력 열을 정의 하기 위해 항상 &lt;code&gt;FROM&lt;/code&gt; 절 을 작성하지 않아도됩니다 . 이에 대해서는 다음 섹션에서 설명합니다. 또 다른 가능성은 뷰 정의에 필수 &lt;code&gt;FROM&lt;/code&gt; 절 을 포함시키는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="564b000e3befed57b182cb04e1dbb1e1574bf5b5" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas. Default privileges that are specified per-schema are added to whatever the global default privileges are for the particular object type.</source>
          <target state="translated">본인 또는 회원이 수행 한 역할에 의해 생성되는 개체에 대해서만 기본 권한을 변경할 수 있습니다. 특권은 전체적으로 (즉, 현재 데이터베이스에서 작성된 모든 오브젝트에 대해) 또는 지정된 스키마에서 작성된 오브젝트에 대해서만 설정할 수 있습니다. 스키마별로 지정된 기본 권한은 특정 개체 유형에 대한 전역 기본 권한에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce7b82cbd1c40e5d5b3f5f38a6fd3d98a532714" translate="yes" xml:space="preserve">
          <source>You can combine these approaches by setting up logrotate to collect log files produced by PostgreSQL built-in logging collector. In this case, the logging collector defines the names and location of the log files, while logrotate periodically archives these files. When initiating log rotation, logrotate must ensure that the application sends further output to the new file. This is commonly done with a &lt;code&gt;postrotate&lt;/code&gt; script that sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the application, which then reopens the log file. In PostgreSQL, you can run &lt;code&gt;pg_ctl&lt;/code&gt; with the &lt;code&gt;logrotate&lt;/code&gt; option instead. When the server receives this command, the server either switches to a new log file or reopens the existing file, depending on the logging configuration (see &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL 내장 로깅 수집기에서 생성 된 로그 파일을 수집하도록 logrotate를 설정하여 이러한 접근 방식을 결합 할 수 있습니다. 이 경우 로깅 수집기는 로그 파일의 이름과 위치를 정의하고 logrotate는 이러한 파일을 정기적으로 보관합니다. 로그 회전을 시작할 때 logrotate는 애플리케이션이 새 파일로 추가 출력을 보내도록해야합니다. 이는 일반적으로 &lt;code&gt;SIGHUP&lt;/code&gt; 신호를 응용 프로그램으로 전송 한 후 로그 파일을 다시 여는 &lt;code&gt;postrotate&lt;/code&gt; 스크립트로 수행 됩니다. PostgreSQL에서는 대신 &lt;code&gt;logrotate&lt;/code&gt; 옵션을 사용 하여 &lt;code&gt;pg_ctl&lt;/code&gt; 을 실행할 수 있습니다 . 서버가이 명령을 수신하면 서버는 로깅 구성에 따라 새 로그 파일로 전환하거나 기존 파일을 다시 엽니 다 (참조&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;섹션 19.8.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5b0f94e4408c19791436a634fd6c150fbb5fd164" translate="yes" xml:space="preserve">
          <source>You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example:</source>
          <target state="translated">빈 배열을 만들 수는 있지만 형식이없는 배열을 사용할 수 없으므로 빈 배열을 원하는 형식으로 명시 적으로 캐스팅해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="769ef112866ecb5c170f43630a2adb624d294a3a" translate="yes" xml:space="preserve">
          <source>You can convert an epoch value back to a time stamp with &lt;code&gt;to_timestamp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; 를 사용하여 에포크 값을 타임 스탬프로 다시 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ea1e38b69360026f2565a2133b9cc41f674fbe6" translate="yes" xml:space="preserve">
          <source>You can create a new table by specifying the table name, along with all column names and their types:</source>
          <target state="translated">모든 열 이름 및 유형과 함께 테이블 이름을 지정하여 새 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2293b489a80bd69ba669dbf459fa76acfff7a213" translate="yes" xml:space="preserve">
          <source>You can create a replication slot like this:</source>
          <target state="translated">다음과 같이 복제 슬롯을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3025b62033e69c38fff841b12fa1dec6f73605a" translate="yes" xml:space="preserve">
          <source>You can create predefined functions to avoid having to write out the result column names and types in each query. See the examples in the previous section. The underlying C function for this form of &lt;code&gt;crosstab&lt;/code&gt; is named &lt;code&gt;crosstab_hash&lt;/code&gt;.</source>
          <target state="translated">각 쿼리에서 결과 열 이름과 유형을 작성하지 않아도되도록 사전 정의 된 함수를 작성할 수 있습니다. 이전 섹션의 예를 참조하십시오. 이 형태의 &lt;code&gt;crosstab&lt;/code&gt; 대한 기본 C 함수의 이름은 &lt;code&gt;crosstab_hash&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05fb579365a5f238d0a6df67c0b79ce59d0a29c6" translate="yes" xml:space="preserve">
          <source>You can create the illusion of an updatable view by defining &lt;code&gt;ON INSERT&lt;/code&gt;, &lt;code&gt;ON UPDATE&lt;/code&gt;, and &lt;code&gt;ON DELETE&lt;/code&gt; rules (or any subset of those that's sufficient for your purposes) to replace update actions on the view with appropriate updates on other tables. If you want to support &lt;code&gt;INSERT RETURNING&lt;/code&gt; and so on, then be sure to put a suitable &lt;code&gt;RETURNING&lt;/code&gt; clause into each of these rules.</source>
          <target state="translated">&lt;code&gt;ON INSERT&lt;/code&gt; , &lt;code&gt;ON UPDATE&lt;/code&gt; 및 &lt;code&gt;ON DELETE&lt;/code&gt; 규칙 (또는 목적에 충분한 규칙 중 일부)을 정의하여 뷰의 업데이트 동작을 다른 테이블의 적절한 업데이트로 대체 하여 업데이트 가능한 뷰의 환상을 만들 수 있습니다 . &lt;code&gt;INSERT RETURNING&lt;/code&gt; 등 을 지원 하려면 각 규칙에 적절한 &lt;code&gt;RETURNING&lt;/code&gt; 절 을 넣어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0fd26f2da3bc0e528eb70dd91043a00be53f7e3" translate="yes" xml:space="preserve">
          <source>You can define a cast as an &lt;em&gt;I/O conversion cast&lt;/em&gt; by using the &lt;code&gt;WITH INOUT&lt;/code&gt; syntax. An I/O conversion cast is performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type. In many common cases, this feature avoids the need to write a separate cast function for conversion. An I/O conversion cast acts the same as a regular function-based cast; only the implementation is different.</source>
          <target state="translated">&lt;code&gt;WITH INOUT&lt;/code&gt; 구문 을 사용하여 &lt;em&gt;캐스트&lt;/em&gt; 를 &lt;em&gt;I / O 변환&lt;/em&gt; 캐스트로 정의 할 수 있습니다 . I / O 변환 캐스트는 소스 데이터 유형의 출력 함수를 호출하고 결과 문자열을 대상 데이터 유형의 입력 함수에 전달하여 수행됩니다. 많은 경우,이 기능은 변환을 위해 별도의 캐스트 함수를 작성할 필요가 없습니다. I / O 변환 캐스트는 일반 함수 기반 캐스트와 동일하게 작동합니다. 구현 만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="986b5339acb3c76e9d88ad629ad134c8af474edf" translate="yes" xml:space="preserve">
          <source>You can display tables in different ways by using the &lt;code&gt;\pset&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; 명령 을 사용하여 다른 방법으로 테이블을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16683852e12279f72c19abb8cc240108de7e38a2" translate="yes" xml:space="preserve">
          <source>You can do the same thing more verbosely with an explicitly named composite type:</source>
          <target state="translated">명시 적으로 명명 된 복합 유형을 사용하여 동일한 작업을 더 자세하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="647bf3e05906b80225fe1b4782288902652983a3" translate="yes" xml:space="preserve">
          <source>You can easily display index sizes, too:</source>
          <target state="translated">색인 크기도 쉽게 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a376faf67a062024c4f071a8c440875731b4314a" translate="yes" xml:space="preserve">
          <source>You can enter this into &lt;code&gt;psql&lt;/code&gt; with the line breaks. &lt;code&gt;psql&lt;/code&gt; will recognize that the command is not terminated until the semicolon.</source>
          <target state="translated">줄 바꿈 으로 &lt;code&gt;psql&lt;/code&gt; 에 이것을 입력 할 수 있습니다 . &lt;code&gt;psql&lt;/code&gt; 은 세미콜론까지 명령이 종료되지 않음을 인식합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
