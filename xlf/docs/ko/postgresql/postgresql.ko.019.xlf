<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="f129f8fd6cdd385b6670be37b85854c18e599a18" translate="yes" xml:space="preserve">
          <source>Seldom-used data can be migrated to cheaper and slower storage media.</source>
          <target state="translated">거의 사용하지 않는 데이터는보다 저렴하고 느린 스토리지 미디어로 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="f4f426e9d2458ca0360610ad52f88837489e82bc" translate="yes" xml:space="preserve">
          <source>Select the first non-unknown input type as the candidate type, then consider each other non-unknown input type, left to right. &lt;a href=&quot;#ftn.id-1.5.9.10.9.6.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.6.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt; If the candidate type can be implicitly converted to the other type, but not vice-versa, select the other type as the new candidate type. Then continue considering the remaining inputs. If, at any stage of this process, a preferred type is selected, stop considering additional inputs.</source>
          <target state="translated">첫 번째 알 수없는 입력 유형을 후보 유형으로 선택한 다음 서로 알 수없는 입력 유형을 왼쪽에서 오른쪽으로 고려합니다. &lt;a href=&quot;#ftn.id-1.5.9.10.9.6.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.6.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt; 후보의 유형을 암시 적으로 다른 유형으로 변환 할 수 있지만 그 반대 할 수있는 경우, 새로운 후보의 유형과 다른 유형을 선택합니다. 그런 다음 나머지 입력을 계속 고려하십시오. 이 프로세스의 어느 단계에서든 선호하는 유형이 선택되면 추가 입력 고려를 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="72dd4bb7db3a13c8c0d3ad0c5e46b386c41b24d3" translate="yes" xml:space="preserve">
          <source>Select the functions to be considered from the &lt;code&gt;pg_proc&lt;/code&gt; system catalog. If a non-schema-qualified function name was used, the functions considered are those with the matching name and argument count that are visible in the current search path (see &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATH&quot;&gt;Section 5.9.3&lt;/a&gt;). If a qualified function name was given, only functions in the specified schema are considered.</source>
          <target state="translated">&lt;code&gt;pg_proc&lt;/code&gt; 시스템 카탈로그 에서 고려할 기능을 선택하십시오 . 스키마에 한정되지 않은 함수 이름이 사용 된 경우 고려되는 함수는 현재 검색 경로에 표시되는 일치하는 이름과 인수 개수를 가진 함수입니다 ( &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATH&quot;&gt;5.9.3 단원&lt;/a&gt; 참조 ). 규정 된 함수 이름이 제공된 경우 지정된 스키마의 함수 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="32f3a5d205bcf542d1aadfba60d5d681cb0b232e" translate="yes" xml:space="preserve">
          <source>Select the next number from this sequence:</source>
          <target state="translated">이 순서에서 다음 숫자를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe440be095ce2bd7b29f542095771fe0791634d" translate="yes" xml:space="preserve">
          <source>Select the operators to be considered from the &lt;code&gt;pg_operator&lt;/code&gt; system catalog. If a non-schema-qualified operator name was used (the usual case), the operators considered are those with the matching name and argument count that are visible in the current search path (see &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATH&quot;&gt;Section 5.9.3&lt;/a&gt;). If a qualified operator name was given, only operators in the specified schema are considered.</source>
          <target state="translated">&lt;code&gt;pg_operator&lt;/code&gt; 시스템 카탈로그 에서 고려할 연산자를 선택하십시오 . 스키마에 한정되지 않은 연산자 이름이 사용 된 경우 (일반적인 경우) 고려되는 연산자는 현재 검색 경로에 표시되는 일치하는 이름과 인수 개수를 가진 연산자입니다 ( &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATH&quot;&gt;5.9.3 절&lt;/a&gt; 참조 ). 규정 된 연산자 이름이 제공된 경우 지정된 스키마의 연산자 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="840bcfd867c3072390d17401d02c8a88816dd10d" translate="yes" xml:space="preserve">
          <source>Selectivity estimation functions contained in third-party extensions that potentially operate on statistics with user-defined operators should follow the same security rules. Consult the PostgreSQL source code for guidance.</source>
          <target state="translated">사용자 정의 연산자가있는 통계에서 잠재적으로 작동하는 타사 확장에 포함 된 선택성 추정 기능은 동일한 보안 규칙을 따라야합니다. 지침은 PostgreSQL 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4835ab696629d27e900e8b7a2bb8c66cf1bce1f4" translate="yes" xml:space="preserve">
          <source>Selects &amp;ldquo;full&amp;rdquo; vacuum, which can reclaim more space, but takes much longer and exclusively locks the table. This method also requires extra disk space, since it writes a new copy of the table and doesn't release the old copy until the operation is complete. Usually this should only be used when a significant amount of space needs to be reclaimed from within the table.</source>
          <target state="translated">더 많은 공간을 회수 할 수 있지만 훨씬 더 오래 걸리고 독점적으로 테이블을 잠그는 &quot;전체&quot;진공을 선택합니다. 이 방법은 테이블의 새 복사본을 작성하고 작업이 완료 될 때까지 이전 복사본을 해제하지 않기 때문에 추가 디스크 공간이 필요합니다. 일반적으로 이는 테이블 내에서 많은 양의 공간을 확보해야하는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d54bcb32f97a80be7795ef5e2affcbe745306a9" translate="yes" xml:space="preserve">
          <source>Selects aggressive &amp;ldquo;freezing&amp;rdquo; of tuples. Specifying &lt;code&gt;FREEZE&lt;/code&gt; is equivalent to performing &lt;code&gt;VACUUM&lt;/code&gt; with the &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt; and &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; parameters set to zero. Aggressive freezing is always performed when the table is rewritten, so this option is redundant when &lt;code&gt;FULL&lt;/code&gt; is specified.</source>
          <target state="translated">튜플의 공격적인 &quot;동결&quot;을 선택합니다. &lt;code&gt;FREEZE&lt;/code&gt; 를 지정 하는 것은 &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; 매개 변수를 0으로 설정하여 &lt;code&gt;VACUUM&lt;/code&gt; 을 수행하는 것과 같습니다 . 테이블을 다시 쓸 때는 항상 적극적인 동결이 수행되므로 &lt;code&gt;FULL&lt;/code&gt; 을 지정 하면이 옵션이 중복됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a7ef3279cc984e60f2c4ecb9d098beadd8d4c12" translate="yes" xml:space="preserve">
          <source>Selects each item in the JSON document that is requested by the &lt;em&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/em&gt; and converts each one to a &lt;code&gt;tsvector&lt;/code&gt;, normalizing words according to the specified or default configuration. The results are then concatenated in document order to produce the output. Position information is generated as though one stopword exists between each pair of selected items. (Beware that &amp;ldquo;document order&amp;rdquo; of the fields of a JSON object is implementation-dependent when the input is &lt;code&gt;jsonb&lt;/code&gt;.) The &lt;em&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/em&gt; must be a &lt;code&gt;jsonb&lt;/code&gt; array containing zero or more of these keywords: &lt;code&gt;&quot;string&quot;&lt;/code&gt; (to include all string values), &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; (to include all numeric values), &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; (to include all boolean values), &lt;code&gt;&quot;key&quot;&lt;/code&gt; (to include all keys), or &lt;code&gt;&quot;all&quot;&lt;/code&gt; (to include all the above). As a special case, the &lt;em&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/em&gt; can also be a simple JSON value that is one of these keywords.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/em&gt; 요청한 JSON 문서의 각 항목을 선택하고 각 항목을 &lt;code&gt;tsvector&lt;/code&gt; 로 변환 하여 지정된 구성 또는 기본 구성에 따라 단어를 정규화합니다. 그런 다음 결과를 문서 순서대로 연결하여 출력을 생성합니다. 선택한 항목의 각 쌍 사이에 하나의 불용어가있는 것처럼 위치 정보가 생성됩니다. (입력이 &lt;code&gt;jsonb&lt;/code&gt; 인 경우 JSON 객체 필드의 &quot;문서 순서&quot;는 구현에 따라 다릅니다 .) &lt;em&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/em&gt; 는 0 개 이상의 키워드 &lt;code&gt;&quot;string&quot;&lt;/code&gt; (모든 문자열 값 포함)을 포함 하는 &lt;code&gt;jsonb&lt;/code&gt; 배열 이어야합니다 . , &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; (모든 숫자 값 포함), &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; (모든 부울 값 포함), &lt;code&gt;&quot;key&quot;&lt;/code&gt; (모든 키 포함) 또는 &lt;code&gt;&quot;all&quot;&lt;/code&gt; (위의 모든 값 포함). 특수한 경우 &lt;em&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/em&gt; 는 이러한 키워드 중 하나 인 간단한 JSON 값일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb406a237c3e2b99d630b93253eab9916932357" translate="yes" xml:space="preserve">
          <source>Selects only elements with the given &lt;em&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/em&gt; from the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;vector&lt;/code&gt; &lt;/em&gt; 에서 주어진 &lt;em&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/em&gt; 를 가진 요소 만 선택합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="329cab98b2e7b277730223d8da005110fee2ce14" translate="yes" xml:space="preserve">
          <source>Selects run-time behavior. &lt;code&gt;Option&lt;/code&gt; can be one of the following:</source>
          <target state="translated">런타임 동작을 선택합니다. &lt;code&gt;Option&lt;/code&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30560935504cb508b22a03e31a19e5c0b9eff148" translate="yes" xml:space="preserve">
          <source>Selects the data format to be read or written: &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;csv&lt;/code&gt; (Comma Separated Values), or &lt;code&gt;binary&lt;/code&gt;. The default is &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">읽거나 쓸 데이터 형식을 선택합니다 : &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;csv&lt;/code&gt; (쉼표로 구분 된 값) 또는 &lt;code&gt;binary&lt;/code&gt; . 기본값은 &lt;code&gt;text&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b1bb679a3701e627e6a88c7eaa8ec36e9390aa34" translate="yes" xml:space="preserve">
          <source>Selects the encoding of the template database. This will also be the default encoding of any database you create later, unless you override it there. The default is derived from the locale, or &lt;code&gt;SQL_ASCII&lt;/code&gt; if that does not work. The character sets supported by the PostgreSQL server are described in &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;Section 23.3.1&lt;/a&gt;.</source>
          <target state="translated">템플릿 데이터베이스의 인코딩을 선택합니다. 또한 재정의하지 않는 한 나중에 만든 데이터베이스의 기본 인코딩이됩니다. 기본값은 로케일 또는 &lt;code&gt;SQL_ASCII&lt;/code&gt; 에서 작동하지 않는 경우에 파생됩니다 . PostgreSQL 서버가 지원하는 문자 세트는 &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;23.3.1 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c1d13e961dcca6fe5a4b3d6a9c0638c2cea516" translate="yes" xml:space="preserve">
          <source>Selects the format for the output. &lt;code&gt;format&lt;/code&gt; can be one of the following:</source>
          <target state="translated">출력 형식을 선택합니다. &lt;code&gt;format&lt;/code&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6b62f3170d3d486af26f832f1af22a99e7d95a8" translate="yes" xml:space="preserve">
          <source>Selects the format of the output. &lt;code&gt;format&lt;/code&gt; can be one of the following:</source>
          <target state="translated">출력 형식을 선택합니다. &lt;code&gt;format&lt;/code&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b1e2692c490d0090c1beb6bc6c86ce1decd9232" translate="yes" xml:space="preserve">
          <source>Selects the largest value among the arguments.</source>
          <target state="translated">인수 중 가장 큰 값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="afc533a4481d9542840f8ed6b66fa98fa2d1291c" translate="yes" xml:space="preserve">
          <source>Selects the single-user mode. This must be the first argument on the command line.</source>
          <target state="translated">단일 사용자 모드를 선택합니다. 명령 행에서 첫 번째 인수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="db08e243447aa95556eef45145c32986f8f9a105" translate="yes" xml:space="preserve">
          <source>Selects the smallest value among the arguments.</source>
          <target state="translated">인수 중 가장 작은 값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="8d91db2e07b2a67479eef75a9ec73a4ac5d36972" translate="yes" xml:space="preserve">
          <source>Selects the text search configuration that is used by those variants of the text search functions that do not have an explicit argument specifying the configuration. See &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for further information. The built-in default is &lt;code&gt;pg_catalog.simple&lt;/code&gt;, but initdb will initialize the configuration file with a setting that corresponds to the chosen &lt;code&gt;lc_ctype&lt;/code&gt; locale, if a configuration matching that locale can be identified.</source>
          <target state="translated">구성을 지정하는 명시적인 인수가없는 텍스트 검색 기능의 변형에서 사용되는 텍스트 검색 구성을 선택합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장을&lt;/a&gt; 참조하십시오 . 내장 된 기본값은 &lt;code&gt;pg_catalog.simple&lt;/code&gt; 이지만, 해당 로케일과 일치하는 구성을 식별 할 수있는 경우 initdb는 선택된 &lt;code&gt;lc_ctype&lt;/code&gt; 로케일에 해당하는 설정으로 구성 파일을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="8c21a8a6468c7a9d1ab2cba00d1eed474020057d" translate="yes" xml:space="preserve">
          <source>Selects the text search configuration that is used by those variants of the text search functions that do not have an explicit argument specifying the configuration. See &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for further information. The built-in default is &lt;code&gt;pg_catalog.simple&lt;/code&gt;, but initdb will initialize the configuration file with a setting that corresponds to the chosen &lt;code&gt;lc_ctype&lt;/code&gt; locale, if a configuration matching that locale can be identified.</source>
          <target state="translated">구성을 지정하는 명시 적 인수가없는 텍스트 검색 기능의 변형에서 사용되는 텍스트 검색 구성을 선택합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;12 장을&lt;/a&gt; 참조하십시오 . 기본 제공 기본값은 &lt;code&gt;pg_catalog.simple&lt;/code&gt; 이지만 initdb는 해당 로케일과 일치하는 구성을 식별 할 수있는 경우 선택한 &lt;code&gt;lc_ctype&lt;/code&gt; 로케일에 해당하는 설정으로 구성 파일을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="e2ed9afd3ab43731b8b497dd1a35f07512ff896f" translate="yes" xml:space="preserve">
          <source>Selects the user name of the database superuser. This defaults to the name of the effective user running &lt;code&gt;initdb&lt;/code&gt;. It is really not important what the superuser's name is, but one might choose to keep the customary name postgres, even if the operating system user's name is different.</source>
          <target state="translated">데이터베이스 수퍼 유저의 사용자 이름을 선택합니다. &lt;code&gt;initdb&lt;/code&gt; 를 실행하는 유효 사용자의 이름이 기본값 입니다. 수퍼 유저 이름은 중요하지 않지만 운영 체제 사용자 이름이 다른 경우에도 관례 이름 postgres를 유지하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43dcee11d979703dc4a6f78428bb60696686afea" translate="yes" xml:space="preserve">
          <source>Semi-Internal Options</source>
          <target state="translated">반 내부 옵션</target>
        </trans-unit>
        <trans-unit id="95ba5a1965fee51378c8670f078becf7e031cfc1" translate="yes" xml:space="preserve">
          <source>Semicolons start a comment, and the numbers at the start of lines refer to the internal archive ID assigned to each item.</source>
          <target state="translated">세미콜론은 주석을 시작하고 줄 시작 부분의 숫자는 각 항목에 지정된 내부 아카이브 ID를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="116281428e559c13e4155e2fe5084c2909518e2d" translate="yes" xml:space="preserve">
          <source>Send all server log output to &lt;code&gt;filename&lt;/code&gt;. This option is only honored when supplied as a command-line option.</source>
          <target state="translated">모든 서버 로그 출력을 &lt;code&gt;filename&lt;/code&gt; 으로 보냅니다 . 이 옵션은 명령 행 옵션으로 제공된 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd03a98afc597876d66d83f82adeba8f47c5f9e2" translate="yes" xml:space="preserve">
          <source>Send output to the specified file. If this is omitted, the standard output is used.</source>
          <target state="translated">지정된 파일로 출력을 보냅니다. 이를 생략하면 표준 출력이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9497b91e004e52409080481445f38595a6426702" translate="yes" xml:space="preserve">
          <source>Send output to the specified file. This parameter can be omitted for file based output formats, in which case the standard output is used. It must be given for the directory output format however, where it specifies the target directory instead of a file. In this case the directory is created by &lt;code&gt;pg_dump&lt;/code&gt; and must not exist before.</source>
          <target state="translated">지정된 파일로 출력을 보냅니다. 파일 기반 출력 형식의 경우이 매개 변수를 생략 할 수 있으며이 경우 표준 출력이 사용됩니다. 그러나 파일 대신 대상 디렉토리를 지정하는 디렉토리 출력 형식으로 제공해야합니다. 이 경우 디렉토리는 &lt;code&gt;pg_dump&lt;/code&gt; 에 의해 생성되며 이전에는 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c28a4a94a5a072f0608dad3b338d2a4f05e4f66a" translate="yes" xml:space="preserve">
          <source>Send time of last message received from origin WAL sender</source>
          <target state="translated">발신 WAL 발신자에게서 마지막으로받은 메시지 전송 시간</target>
        </trans-unit>
        <trans-unit id="11441f01c656a7a6e5fb17c1dad36715c7d4fb27" translate="yes" xml:space="preserve">
          <source>Send time of last reply message received from standby server</source>
          <target state="translated">대기 서버로부터받은 마지막 응답 메시지의 시간 보내기</target>
        </trans-unit>
        <trans-unit id="cc978e97728271c70f7aa6c537cf5121fe8cc19b" translate="yes" xml:space="preserve">
          <source>Sends the current query buffer to the server and stores the query's output into psql variables (see &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below). The query to be executed must return exactly one row. Each column of the row is stored into a separate variable, named the same as the column. For example:</source>
          <target state="translated">현재 쿼리 버퍼를 서버에 보내고 쿼리 출력을 psql 변수에 저장합니다 (아래 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수&lt;/a&gt; 참조). 실행할 쿼리는 정확히 하나의 행을 반환해야합니다. 행의 각 열은 열과 이름이 같은 별도의 변수에 저장됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="827bcfb8dc975e32ea5886d951bc1ade5a13c496" translate="yes" xml:space="preserve">
          <source>Sends the current query buffer to the server and stores the query's output into psql variables (see &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;). The query to be executed must return exactly one row. Each column of the row is stored into a separate variable, named the same as the column. For example:</source>
          <target state="translated">현재 쿼리 버퍼를 서버로 보내고 쿼리의 출력을 psql 변수에 저장합니다 ( &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; 참조 ). 실행할 쿼리는 정확히 하나의 행을 반환해야합니다. 행의 각 열은 열과 동일한 별도의 변수에 저장됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04064d85ede30854aae6653cfd5d7b79121b3220" translate="yes" xml:space="preserve">
          <source>Sends the current query buffer to the server for execution.</source>
          <target state="translated">실행을 위해 현재 쿼리 버퍼를 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e34f4142455c22708bec5bb66edc23659021e08e" translate="yes" xml:space="preserve">
          <source>Sends the current query buffer to the server for execution. If an argument is given, the query's output is written to the named file or piped to the given shell command, instead of displaying it as usual. The file or command is written to only if the query successfully returns zero or more tuples, not if the query fails or is a non-data-returning SQL command.</source>
          <target state="translated">실행하기 위해 현재 쿼리 버퍼를 서버로 보냅니다. 인수가 제공되면 조회 출력이 이름 지정된 파일에 기록되거나 평상시처럼 표시되지 않고 지정된 쉘 명령으로 파이프됩니다. 쿼리가 실패하거나 데이터를 반환하지 않는 SQL 명령이 아닌 경우 쿼리에서 0 개 이상의 튜플을 성공적으로 반환하는 경우에만 파일 또는 명령이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="16c6228f3c84dd51ad99bdc12059c6d42048bc72" translate="yes" xml:space="preserve">
          <source>Sends the current query buffer to the server, then treats each column of each row of the query's output (if any) as a SQL statement to be executed. For example, to create an index on each column of &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">현재 쿼리 버퍼를 서버로 보낸 다음 쿼리 출력의 각 행 (있는 경우)의 각 열을 실행할 SQL 문으로 처리합니다. 예를 들어, &lt;code&gt;my_table&lt;/code&gt; 의 각 열에 색인을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6910dde6996e8d930104bdf1016b0bc2d0405a12" translate="yes" xml:space="preserve">
          <source>Sep, Sept</source>
          <target state="translated">9 월 9 월</target>
        </trans-unit>
        <trans-unit id="1c542e79c9b4257e640ccf72974d61fd590a5c26" translate="yes" xml:space="preserve">
          <source>September</source>
          <target state="translated">September</target>
        </trans-unit>
        <trans-unit id="5c8f4e0e1a2281faf562976c2410f76c3d8fbc95" translate="yes" xml:space="preserve">
          <source>Sequence</source>
          <target state="translated">Sequence</target>
        </trans-unit>
        <trans-unit id="7426565397d353bfc6cc44aaccea198d8b34fcaa" translate="yes" xml:space="preserve">
          <source>Sequence (relation)</source>
          <target state="translated">순서 (관계)</target>
        </trans-unit>
        <trans-unit id="07bc489e5c22ab662328dfdad5c7b347ebdfe88e" translate="yes" xml:space="preserve">
          <source>Sequence Functions</source>
          <target state="translated">시퀀스 함수</target>
        </trans-unit>
        <trans-unit id="bd909067e54211c270c1065205750578dcc199ab" translate="yes" xml:space="preserve">
          <source>Sequence Functions: UPDATE</source>
          <target state="translated">시퀀스 함수 : UPDATE</target>
        </trans-unit>
        <trans-unit id="70f857aec9b3a45a97d7d79576572874e27bfcfd" translate="yes" xml:space="preserve">
          <source>Sequence Functions: USAGE</source>
          <target state="translated">시퀀스 함수 : USAGE</target>
        </trans-unit>
        <trans-unit id="aa301e805997f1a99cfb41977fb6c8ab1f1b6154" translate="yes" xml:space="preserve">
          <source>Sequence Functions: currval</source>
          <target state="translated">시퀀스 함수 : currval</target>
        </trans-unit>
        <trans-unit id="65d5b5594b5e62f50beacf4e27fd4850c186b574" translate="yes" xml:space="preserve">
          <source>Sequence Functions: is_called</source>
          <target state="translated">시퀀스 함수 : is_called</target>
        </trans-unit>
        <trans-unit id="30e5044af29a5e75a7c62a260ffd2a07b89083a7" translate="yes" xml:space="preserve">
          <source>Sequence Functions: lastval</source>
          <target state="translated">시퀀스 함수 : lastval</target>
        </trans-unit>
        <trans-unit id="1ea626544c964041267072d55619008b1c0a51f1" translate="yes" xml:space="preserve">
          <source>Sequence Functions: nextval</source>
          <target state="translated">시퀀스 함수 : nextval</target>
        </trans-unit>
        <trans-unit id="21d95a03113a24a4ed178a05cc8de033d3d8ab56" translate="yes" xml:space="preserve">
          <source>Sequence Functions: setval</source>
          <target state="translated">시퀀스 함수 : setval</target>
        </trans-unit>
        <trans-unit id="5bd032907a26ee7f0a23a1af0498a469eb893726" translate="yes" xml:space="preserve">
          <source>Sequence data is not replicated. The data in serial or identity columns backed by sequences will of course be replicated as part of the table, but the sequence itself would still show the start value on the subscriber. If the subscriber is used as a read-only database, then this should typically not be a problem. If, however, some kind of switchover or failover to the subscriber database is intended, then the sequences would need to be updated to the latest values, either by copying the current data from the publisher (perhaps using &lt;code&gt;pg_dump&lt;/code&gt;) or by determining a sufficiently high value from the tables themselves.</source>
          <target state="translated">시퀀스 데이터는 복제되지 않습니다. 시퀀스로 지원되는 일련 번호 또는 ID 열의 데이터는 물론 테이블의 일부로 복제되지만 시퀀스 자체는 여전히 가입자의 시작 값을 표시합니다. 구독자가 읽기 전용 데이터베이스로 사용되는 경우 일반적으로 문제가되지 않습니다. 그러나 가입자 데이터베이스에 대한 일종의 전환 또는 페일 오버가 의도 된 경우, 게시자로부터 현재 데이터를 복사하거나 ( &lt;code&gt;pg_dump&lt;/code&gt; 사용 ) 충분히 높은 값을 결정 하여 시퀀스를 최신 값으로 업데이트해야합니다. 테이블 자체의 가치.</target>
        </trans-unit>
        <trans-unit id="97234aae16b6ff095ff213aca26dc80ddef220ef" translate="yes" xml:space="preserve">
          <source>Sequence of object's key-value pairs represented as array of items containing three fields (&lt;code&gt;&quot;key&quot;&lt;/code&gt;, &lt;code&gt;&quot;value&quot;&lt;/code&gt;, and &lt;code&gt;&quot;id&quot;&lt;/code&gt;). &lt;code&gt;&quot;id&quot;&lt;/code&gt; is a unique identifier of the object key-value pair belongs to.</source>
          <target state="translated">객체의 키-값 쌍의 시퀀스는 세 개의 필드 ( &lt;code&gt;&quot;key&quot;&lt;/code&gt; , &lt;code&gt;&quot;value&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;id&quot;&lt;/code&gt; )를 포함하는 항목의 배열로 표시됩니다 . &lt;code&gt;&quot;id&quot;&lt;/code&gt; 는 객체 키-값 쌍이 속하는 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="251f5dac0aca5e7ac9c42b47c12bdc19ca30c8be" translate="yes" xml:space="preserve">
          <source>Sequence updates - &lt;code&gt;nextval()&lt;/code&gt;, &lt;code&gt;setval()&lt;/code&gt;</source>
          <target state="translated">시퀀스 업데이트 &lt;code&gt;nextval()&lt;/code&gt; , &lt;code&gt;setval()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0880b8c58459b620daf895c61751f6f914dc4d8e" translate="yes" xml:space="preserve">
          <source>Sequence updates: &lt;code&gt;nextval()&lt;/code&gt;, &lt;code&gt;setval()&lt;/code&gt;</source>
          <target state="translated">시퀀스 업데이트 : &lt;code&gt;nextval()&lt;/code&gt; , &lt;code&gt;setval()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19265d915c7caffbad5ffe481ad6585135aae0da" translate="yes" xml:space="preserve">
          <source>Sequences are based on &lt;code&gt;bigint&lt;/code&gt; arithmetic, so the range cannot exceed the range of an eight-byte integer (-9223372036854775808 to 9223372036854775807).</source>
          <target state="translated">시퀀스는 &lt;code&gt;bigint&lt;/code&gt; 산술을 기반으로 하므로 범위는 8 바이트 정수 (-9223372036854775808 ~ 9223372036854775807)의 범위를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd35ab2ab61ca9152a68f0dda4d3d2eddfefe916" translate="yes" xml:space="preserve">
          <source>Serial number of the client certificate, or NULL if no client certificate was supplied or if SSL is not in use on this connection. The combination of certificate serial number and certificate issuer uniquely identifies a certificate (unless the issuer erroneously reuses serial numbers).</source>
          <target state="translated">클라이언트 인증서의 일련 번호. 클라이언트 인증서가 제공되지 않았거나이 연결에서 SSL을 사용하지 않는 경우 NULL입니다. 인증서 일련 번호와 인증서 발급자의 조합은 인증서를 고유하게 식별합니다 (발급자가 일련 번호를 잘못 재사용하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="dc1f3c2690cec070768cf5dde8291f16c094e668" translate="yes" xml:space="preserve">
          <source>Serializable</source>
          <target state="translated">Serializable</target>
        </trans-unit>
        <trans-unit id="ad0e6e010a3b8ec3d572049722baa6ae80e6ba2a" translate="yes" xml:space="preserve">
          <source>Serialization Anomaly</source>
          <target state="translated">직렬화 이상</target>
        </trans-unit>
        <trans-unit id="91defb67bd083b4dbe25fedc563e29b2b50751d9" translate="yes" xml:space="preserve">
          <source>Serialization function (zero if none)</source>
          <target state="translated">직렬화 기능 (없는 경우 0)</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="ac5f12a7cf2c4bb81c6db95b524f8fe37dd72bd4" translate="yes" xml:space="preserve">
          <source>Server C-language API</source>
          <target state="translated">서버 C 언어 API</target>
        </trans-unit>
        <trans-unit id="99bf7f202420ce369158974abb061f91cfba7f8d" translate="yes" xml:space="preserve">
          <source>Server Character Set</source>
          <target state="translated">서버 문자 세트</target>
        </trans-unit>
        <trans-unit id="add5557e5f62829e10b2473a14ff984c6ddb6075" translate="yes" xml:space="preserve">
          <source>Server Configuration</source>
          <target state="translated">서버 구성</target>
        </trans-unit>
        <trans-unit id="098c3ece35362ab15eb34ffc7a84bcf142c7c154" translate="yes" xml:space="preserve">
          <source>Server Programming Interface</source>
          <target state="translated">서버 프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="14436173aa6b5cb94cb403c2e8bb58b03facf70f" translate="yes" xml:space="preserve">
          <source>Server Setup and Operation</source>
          <target state="translated">서버 설정 및 운영</target>
        </trans-unit>
        <trans-unit id="f10b934bc2ab4c078f78fee28fd61f5fee243d3c" translate="yes" xml:space="preserve">
          <source>Server name of the user mapping.</source>
          <target state="translated">사용자 매핑의 서버 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5ac699bcfdb977f7d37e2683ee34b784a0d8bd8c" translate="yes" xml:space="preserve">
          <source>Server sends an AuthenticationSASLContinue message, with a SCRAM &lt;code&gt;server-first-message&lt;/code&gt; as the content.</source>
          <target state="translated">서버는 SCRAM &lt;code&gt;server-first-message&lt;/code&gt; 를 내용으로하여 AuthenticationSASLContinue 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="dba72e67c7eed9c742c9c3dbf2ce3c14c9d5ff5d" translate="yes" xml:space="preserve">
          <source>Server sends an AuthenticationSASLFinal message, with the SCRAM &lt;code&gt;server-final-message&lt;/code&gt;, followed immediately by an AuthenticationOk message.</source>
          <target state="translated">서버는 SCRAM &lt;code&gt;server-final-message&lt;/code&gt; 와 함께 AuthenticationSASLFinal 메시지를 보낸 다음 AuthenticationOk 메시지를 즉시 보냅니다.</target>
        </trans-unit>
        <trans-unit id="221a7c6119dff8264ec9639fcc0447d548c97324" translate="yes" xml:space="preserve">
          <source>Server?</source>
          <target state="translated">Server?</target>
        </trans-unit>
        <trans-unit id="f7f1997c6cd1aa051279675742272a956e7db628" translate="yes" xml:space="preserve">
          <source>Session</source>
          <target state="translated">Session</target>
        </trans-unit>
        <trans-unit id="b13a196b7010a3bc6833221bad2d39a01c70cfa1" translate="yes" xml:space="preserve">
          <source>Session ID: see below</source>
          <target state="translated">세션 ID : 아래 참조</target>
        </trans-unit>
        <trans-unit id="aab4bf6a8ec7c39317f36d91f044715f0ea2755b" translate="yes" xml:space="preserve">
          <source>Session defaults for run-time configuration variables</source>
          <target state="translated">런타임 구성 변수의 세션 기본값</target>
        </trans-unit>
        <trans-unit id="5f9b0ae1082a65481e36e0822adc544170af3179" translate="yes" xml:space="preserve">
          <source>Session only</source>
          <target state="translated">세션 만</target>
        </trans-unit>
        <trans-unit id="7c8411785f58288914255d3b580ee51d4ac2476e" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;hasPrefix&lt;/code&gt; to indicate whether the new inner tuple should have a prefix, and if so set &lt;code&gt;prefixDatum&lt;/code&gt; to the prefix value. Set &lt;code&gt;nNodes&lt;/code&gt; to indicate the number of nodes that the new inner tuple will contain, and set &lt;code&gt;nodeLabels&lt;/code&gt; to an array of their label values, or to NULL if node labels are not required. Set &lt;code&gt;mapTuplesToNodes&lt;/code&gt; to an array that gives the index (from zero) of the node that each leaf tuple should be assigned to. Set &lt;code&gt;leafTupleDatums&lt;/code&gt; to an array of the values to be stored in the new leaf tuples (these will be the same as the input &lt;code&gt;datums&lt;/code&gt; if the operator class does not modify datums from one level to the next). Note that the &lt;code&gt;picksplit&lt;/code&gt; function is responsible for palloc'ing the &lt;code&gt;nodeLabels&lt;/code&gt;, &lt;code&gt;mapTuplesToNodes&lt;/code&gt; and &lt;code&gt;leafTupleDatums&lt;/code&gt; arrays.</source>
          <target state="translated">새로운 내부 튜플에 접두사가 있어야하는지 여부를 나타내 &lt;code&gt;hasPrefix&lt;/code&gt; 를 설정 하고, 그렇다면 &lt;code&gt;prefixDatum&lt;/code&gt; 을 접두사 값으로 설정하십시오. 설정 &lt;code&gt;nNodes&lt;/code&gt; 는 새로운 내부 튜플이 포함됩니다 노드 및 세트의 수를 나타냅니다 &lt;code&gt;nodeLabels&lt;/code&gt; 노드 레이블이 필요하지 않은 경우, 또는 NULL에 자신의 레이블 값의 배열입니다. &lt;code&gt;mapTuplesToNodes&lt;/code&gt; 를 각 리프 튜플에 할당해야하는 노드의 인덱스 (0부터)를 제공하는 배열로 설정하십시오 . &lt;code&gt;leafTupleDatums&lt;/code&gt; 를 새 리프 튜플에 저장할 값의 배열로 설정 합니다 (연산자 클래스가 한 수준에서 다음 수준으로 기준을 수정하지 않는 경우 입력 &lt;code&gt;datums&lt;/code&gt; 과 동일 합니다). 합니다 &lt;code&gt;picksplit&lt;/code&gt; 이 함수는 &lt;code&gt;nodeLabels&lt;/code&gt; , &lt;code&gt;mapTuplesToNodes&lt;/code&gt; 및 &lt;code&gt;leafTupleDatums&lt;/code&gt; 배열의 위치 를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="d3bd8dc1589d6249d5649e32bb4d93b0f924fa44" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;log_filename&lt;/code&gt; and &lt;code&gt;log_rotation_age&lt;/code&gt; to provide a consistent, predictable naming scheme for your log files. This lets you predict what the file name will be and know when an individual log file is complete and therefore ready to be imported.</source>
          <target state="translated">로그 파일에 일관되고 예측 가능한 이름 지정 체계를 제공하도록 &lt;code&gt;log_filename&lt;/code&gt; 및 &lt;code&gt;log_rotation_age&lt;/code&gt; 를 설정 하십시오. 이를 통해 파일 이름을 예측하고 개별 로그 파일이 완료되어 가져올 준비가 된시기를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7471a027645aaf9e67db15a19684eddb9ac4cf12" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;log_rotation_size&lt;/code&gt; to 0 to disable size-based log rotation, as it makes the log file name difficult to predict.</source>
          <target state="translated">로그 파일 이름을 예측하기 어렵 기 때문에 크기 기반 로그 회전을 비활성화하려면 &lt;code&gt;log_rotation_size&lt;/code&gt; 를 0으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db880e519eeac98cb7ade3da9cd8cb0a3aead01" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt; so that old log data isn't mixed with the new in the same file.</source>
          <target state="translated">이전 로그 데이터가 동일한 파일의 새 로그 데이터와 혼합되지 않도록 &lt;code&gt;log_truncate_on_rotation&lt;/code&gt; 을 &lt;code&gt;on&lt;/code&gt; 으로 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="3d9c416ee539d70a1d91adea4bb99fbaeceefb8b" translate="yes" xml:space="preserve">
          <source>Set Returning Functions</source>
          <target state="translated">반환 기능 설정</target>
        </trans-unit>
        <trans-unit id="fa8cb94350f85c1e0de0f21612f572ed56fc0188" translate="yes" xml:space="preserve">
          <source>Set Returning Functions: generate_series</source>
          <target state="translated">반환 함수 설정 : generate_series</target>
        </trans-unit>
        <trans-unit id="67304188db740577889de74eb33fb05853ef9fb4" translate="yes" xml:space="preserve">
          <source>Set Returning Functions: generate_subscripts</source>
          <target state="translated">반환 함수 설정 : generate_subscripts</target>
        </trans-unit>
        <trans-unit id="60e443d11f81d2fe080ec8d571308a3a3ea3c083" translate="yes" xml:space="preserve">
          <source>Set a compatibility mode. &lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;INFORMIX&lt;/code&gt;, &lt;code&gt;INFORMIX_SE&lt;/code&gt;, or &lt;code&gt;ORACLE&lt;/code&gt;.</source>
          <target state="translated">호환성 모드를 설정하십시오. &lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;INFORMIX&lt;/code&gt; , &lt;code&gt;INFORMIX_SE&lt;/code&gt; 또는 &lt;code&gt;ORACLE&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3c328fb303d188846faa57ec644dd452b85cfe9" translate="yes" xml:space="preserve">
          <source>Set a maximum number of connections for the new user. The default is to set no limit.</source>
          <target state="translated">새 사용자의 최대 연결 수를 설정하십시오. 기본값은 무제한을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="51b6bdc39cce328ed5f5d8b1d6e61e21b8c3e054" translate="yes" xml:space="preserve">
          <source>Set appropriate (i.e., larger than normal) values for &lt;code&gt;maintenance_work_mem&lt;/code&gt; and &lt;code&gt;max_wal_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;maintenance_work_mem&lt;/code&gt; 및 &lt;code&gt;max_wal_size&lt;/code&gt; 에 적절한 (즉, 정상보다 큰) 값을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="84ac01b40d3c10a0aea679cf301cee7cdd55289a" translate="yes" xml:space="preserve">
          <source>Set bit in string</source>
          <target state="translated">문자열에 비트 설정</target>
        </trans-unit>
        <trans-unit id="f2c28bae18a058e2ea0c39d89999ab33172a4394" translate="yes" xml:space="preserve">
          <source>Set byte in string</source>
          <target state="translated">문자열에서 바이트 설정</target>
        </trans-unit>
        <trans-unit id="f275ac0255129308183e3644a900ef6092d9b3bd" translate="yes" xml:space="preserve">
          <source>Set of currently active backend ID numbers (from 1 to the number of active backends)</source>
          <target state="translated">현재 활성 백엔드 ID 번호 세트 (1에서 활성 백엔드 수까지)</target>
        </trans-unit>
        <trans-unit id="588fb0566e74c531a513e11adb480d0679df040c" translate="yes" xml:space="preserve">
          <source>Set or change the planner support function to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">이 기능에 사용할 플래너 지원 기능을 설정하거나 변경하십시오. 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;은 37.11 절&lt;/a&gt; 을 참조하십시오. 이 옵션을 사용하려면 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="59a92766235d087ba9432dda6242fa0effe1766c" translate="yes" xml:space="preserve">
          <source>Set or change the planner support function to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">이 기능에 사용할 플래너 지원 기능을 설정하거나 변경합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;섹션 37.11&lt;/a&gt; 을 참조하십시오. 이 옵션을 사용하려면 수퍼 유저 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ccffbb66ab26cee6787c7d40f463f548a96b9dec" translate="yes" xml:space="preserve">
          <source>Set random generator seed. Seeds the system random number generator, which then produces a sequence of initial generator states, one for each thread. Values for &lt;code&gt;SEED&lt;/code&gt; may be: &lt;code&gt;time&lt;/code&gt; (the default, the seed is based on the current time), &lt;code&gt;rand&lt;/code&gt; (use a strong random source, failing if none is available), or an unsigned decimal integer value. The random generator is invoked explicitly from a pgbench script (&lt;code&gt;random...&lt;/code&gt; functions) or implicitly (for instance option &lt;code&gt;--rate&lt;/code&gt; uses it to schedule transactions). When explicitly set, the value used for seeding is shown on the terminal. Any value allowed for &lt;code&gt;SEED&lt;/code&gt; may also be provided through the environment variable &lt;code&gt;PGBENCH_RANDOM_SEED&lt;/code&gt;. To ensure that the provided seed impacts all possible uses, put this option first or use the environment variable.</source>
          <target state="translated">랜덤 생성기 시드를 설정하십시오. 시스템 난수 생성기를 시드 한 다음 각 스레드마다 하나씩 초기 생성기 상태 시퀀스를 생성합니다. 의 값 &lt;code&gt;SEED&lt;/code&gt; 가 될 수있다 : &lt;code&gt;time&lt;/code&gt; (기본값 씨가 현재 시간을 기준으로), &lt;code&gt;rand&lt;/code&gt; (사용할 수없는 경우는 실패, 강력한 임의의 소스를 사용) 또는 부호없는 진수 정수 값입니다. 랜덤 생성기는 pgbench 스크립트 ( &lt;code&gt;random...&lt;/code&gt; 함수) 에서 명시 적으로 또는 암시 적으로 호출됩니다 (예 : &lt;code&gt;--rate&lt;/code&gt; 옵션을 사용하여 트랜잭션을 예약합니다). 명시 적으로 설정하면 시드에 사용 된 값이 터미널에 표시됩니다. &lt;code&gt;SEED&lt;/code&gt; 에 허용 된 모든 값 은 환경 변수 &lt;code&gt;PGBENCH_RANDOM_SEED&lt;/code&gt; 를 통해 제공 될 수도 있습니다.. 제공된 시드가 가능한 모든 사용에 영향을 미치려면이 옵션을 먼저 두거나 환경 변수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1a26971e09cfe611ac6e9413719dc2f41613dabc" translate="yes" xml:space="preserve">
          <source>Set random generator seed. Seeds the system random number generator, which then produces a sequence of initial generator states, one for each thread. Values for &lt;code&gt;seed&lt;/code&gt; may be: &lt;code&gt;time&lt;/code&gt; (the default, the seed is based on the current time), &lt;code&gt;rand&lt;/code&gt; (use a strong random source, failing if none is available), or an unsigned decimal integer value. The random generator is invoked explicitly from a pgbench script (&lt;code&gt;random...&lt;/code&gt; functions) or implicitly (for instance option &lt;code&gt;--rate&lt;/code&gt; uses it to schedule transactions). When explicitly set, the value used for seeding is shown on the terminal. Any value allowed for &lt;code&gt;seed&lt;/code&gt; may also be provided through the environment variable &lt;code&gt;PGBENCH_RANDOM_SEED&lt;/code&gt;. To ensure that the provided seed impacts all possible uses, put this option first or use the environment variable.</source>
          <target state="translated">랜덤 생성기 시드를 설정합니다. 시스템 난수 생성기를 시드 한 다음 각 스레드에 대해 하나씩 일련의 초기 생성기 상태를 생성합니다. 의 값 &lt;code&gt;seed&lt;/code&gt; 될 수있다 : &lt;code&gt;time&lt;/code&gt; (기본값 씨가 현재 시간을 기준으로), &lt;code&gt;rand&lt;/code&gt; (사용할 수없는 경우는 실패, 강력한 임의의 소스를 사용) 또는 부호없는 진수 정수 값입니다. 랜덤 생성기는 pgbench 스크립트 ( &lt;code&gt;random...&lt;/code&gt; 함수) 에서 명시 적으로 호출 되거나 암시 적으로 (예 : &lt;code&gt;--rate&lt;/code&gt; 옵션이 트랜잭션을 예약하는 데 사용합니다 ) 호출됩니다 . 명시 적으로 설정하면 시드에 사용 된 값이 터미널에 표시됩니다. &lt;code&gt;seed&lt;/code&gt; 에 허용되는 모든 값 은 환경 변수 &lt;code&gt;PGBENCH_RANDOM_SEED&lt;/code&gt; 를 통해 제공 될 수도 있습니다.. 제공된 시드가 가능한 모든 사용에 영향을 미치도록하려면이 옵션을 먼저 배치하거나 환경 변수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b9159888d66506fdf072bd581af715b59097beff" translate="yes" xml:space="preserve">
          <source>Set recovery configuration settings in &lt;code&gt;postgresql.conf&lt;/code&gt; (see &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY&quot;&gt;Section 19.5.4&lt;/a&gt;) and create a file &lt;code&gt;recovery.signal&lt;/code&gt; in the cluster data directory. You might also want to temporarily modify &lt;code&gt;pg_hba.conf&lt;/code&gt; to prevent ordinary users from connecting until you are sure the recovery was successful.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 에서 복구 구성 설정을 설정 하고 ( &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY&quot;&gt;섹션 19.5.4&lt;/a&gt; 참조 ) 클러스터 데이터 디렉토리에 &lt;code&gt;recovery.signal&lt;/code&gt; 파일을 작성 하십시오 . 복구가 성공적으로 완료 될 때까지 일반 사용자가 연결하지 못하도록 &lt;code&gt;pg_hba.conf&lt;/code&gt; 를 임시로 수정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ead6355d6453693c27e28bafe7302da83d8bfe3" translate="yes" xml:space="preserve">
          <source>Set replication progress for the given node to the given location. This primarily is useful for setting up the initial location or a new location after configuration changes and similar. Be aware that careless use of this function can lead to inconsistently replicated data.</source>
          <target state="translated">지정된 노드의 복제 진행률을 지정된 위치로 설정하십시오. 이것은 주로 구성 변경 및 유사 후 초기 위치 또는 새 위치를 설정하는 데 유용합니다. 이 기능을 부주의하게 사용하면 데이터가 일관되지 않게 복제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be58e3ee4067339cb19889acfdd49b7d21f4e8bc" translate="yes" xml:space="preserve">
          <source>Set sequence's current value</source>
          <target state="translated">시퀀스의 현재 값 설정</target>
        </trans-unit>
        <trans-unit id="d6bae9769dd9f455c8ef2a9e96d75f9cdc12a0f4" translate="yes" xml:space="preserve">
          <source>Set sequence's current value and &lt;code&gt;is_called&lt;/code&gt; flag</source>
          <target state="translated">시퀀스의 현재 값과 &lt;code&gt;is_called&lt;/code&gt; 플래그 설정</target>
        </trans-unit>
        <trans-unit id="eeb3f03a4c8992b077c228c6248eaf67d7a9fc10" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;timezone&lt;/code&gt; configuration variable to its default value:</source>
          <target state="translated">&lt;code&gt;timezone&lt;/code&gt; 구성 변수를 기본값으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c736ffb9f27232dc710a4363cc3c7a992295fb5" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;wal_level&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;wal_level&lt;/code&gt; 을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="708fa20cd3910bbb838bff343155417452fdabab" translate="yes" xml:space="preserve">
          <source>Set the &lt;em&gt;WAL segment size&lt;/em&gt;, in megabytes. This is the size of each individual file in the WAL log. The default size is 16 megabytes. The value must be a power of 2 between 1 and 1024 (megabytes). This option can only be set during initialization, and cannot be changed later.</source>
          <target state="translated">&lt;em&gt;WAL 세그먼트 크기&lt;/em&gt; 를 MB 단위로 설정하십시오 . 이것은 WAL 로그에있는 각 개별 파일의 크기입니다. 기본 크기는 16MB입니다. 값은 1과 1024 (MB) 사이의 2의 거듭 제곱이어야합니다. 이 옵션은 초기화 중에 만 설정할 수 있으며 나중에 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82e3bec9ca58f477e298d1bdc71c691481216998" translate="yes" xml:space="preserve">
          <source>Set the code page by entering &lt;strong&gt;&lt;code&gt;cmd.exe /c chcp 1252&lt;/code&gt;&lt;/strong&gt;. (1252 is a code page that is appropriate for German; replace it with your value.) If you are using Cygwin, you can put this command in &lt;code&gt;/etc/profile&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;cmd.exe /c chcp 1252&lt;/code&gt; &lt;/strong&gt; 입력하여 코드 페이지를 설정하십시오 . (1252는 독일어에 적합한 코드 페이지입니다. 값으로 바꾸십시오.) Cygwin을 사용하는 경우이 명령을 &lt;code&gt;/etc/profile&lt;/code&gt; 에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6bec4d792538a673a4f60f64189450e971808bc" translate="yes" xml:space="preserve">
          <source>Set the column to its default value (which will be NULL if no specific default expression has been assigned to it).</source>
          <target state="translated">열을 기본값으로 설정하십시오 (특정 기본 표현식이 지정되지 않은 경우 NULL 임).</target>
        </trans-unit>
        <trans-unit id="eda25b25d24b6b170702ad18f43f0b72079461b5" translate="yes" xml:space="preserve">
          <source>Set the column to its default value (which will be NULL if no specific default expression has been assigned to it). An identity column will be set to a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.</source>
          <target state="translated">열을 기본값으로 설정합니다 (특정 기본 표현식이 할당되지 않은 경우 NULL이 됨). 식별 컬럼은 연관된 시퀀스에 의해 생성 된 새 값으로 설정됩니다. 생성 된 열의 경우이를 지정하는 것이 허용되지만 해당 생성 표현식에서 열을 계산하는 정상적인 동작 만 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2895983a156ee68c70321bd7cfef33e4ab2bd9e0" translate="yes" xml:space="preserve">
          <source>Set the console font to &lt;code&gt;Lucida Console&lt;/code&gt;, because the raster font does not work with the ANSI code page.</source>
          <target state="translated">래스터 글꼴이 ANSI 코드 페이지에서 작동하지 않으므로 콘솔 글꼴을 &lt;code&gt;Lucida Console&lt;/code&gt; 로 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="12d6fdd540d771975adb3546fb00e4e6d7961bdc" translate="yes" xml:space="preserve">
          <source>Set the field separator for unaligned output to a zero byte. This is equivalent to &lt;code&gt;\pset fieldsep_zero&lt;/code&gt;.</source>
          <target state="translated">정렬되지 않은 출력의 필드 구분 기호를 0 바이트로 설정하십시오. 이것은 &lt;code&gt;\pset fieldsep_zero&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="52d2aca222ee84cda82dfff67e7e4f3011c415d8" translate="yes" xml:space="preserve">
          <source>Set the filename prefix for the log files created by &lt;code&gt;--log&lt;/code&gt;. The default is &lt;code&gt;pgbench_log&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--log&lt;/code&gt; 로 만든 로그 파일의 파일 이름 접두사를 설정하십시오 . 기본값은 &lt;code&gt;pgbench_log&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e5dbce7ba05546ca573be289cbde8e726b566ab3" translate="yes" xml:space="preserve">
          <source>Set the fraction of transactions whose statements are all logged, in addition to statements logged for other reasons. It applies to each new transaction regardless of its statements' durations. The default is &lt;code&gt;0&lt;/code&gt;, meaning not to log statements from any additional transaction. Setting this to &lt;code&gt;1&lt;/code&gt; logs all statements for all transactions. &lt;code&gt;log_transaction_sample_rate&lt;/code&gt; is helpful to track a sample of transaction. Only superusers can change this setting.</source>
          <target state="translated">다른 이유로 로그 된 명령문 외에 명령문이 모두 로그 된 트랜잭션의 비율을 설정하십시오. 성명 기간에 관계없이 각각의 새로운 거래에 적용됩니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 이며 추가 트랜잭션의 명령문을 기록하지 않습니다. 이것을 &lt;code&gt;1&lt;/code&gt; 로 설정하면 모든 트랜잭션에 대한 모든 명령문 이 기록됩니다. &lt;code&gt;log_transaction_sample_rate&lt;/code&gt; 는 트랜잭션 샘플을 추적하는 데 도움이됩니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c59ee63956f28bcccd652b600e48fb099e42097a" translate="yes" xml:space="preserve">
          <source>Set the maximum number of concurrent connections from the standby servers (see &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; for details).</source>
          <target state="translated">대기 서버에서 최대 동시 연결 수를 설정하십시오 (자세한 내용은 &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="87fbf2d5d0cfc148e22d33324829fd6df34456c7" translate="yes" xml:space="preserve">
          <source>Set the new WAL segment size, in megabytes. The value must be set to a power of 2 between 1 and 1024 (megabytes). See the same option of &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; for more information.</source>
          <target state="translated">새 WAL 세그먼트 크기를 MB 단위로 설정하십시오. 값은 1에서 1024 (MB) 사이의 2의 거듭 제곱으로 설정해야합니다. 자세한 내용은 동일한 &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; 옵션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c312d39ce47081cae0df0986fb7f1e54f7fd0cb0" translate="yes" xml:space="preserve">
          <source>Set the record separator for unaligned output to a zero byte. This is useful for interfacing, for example, with &lt;code&gt;xargs -0&lt;/code&gt;. This is equivalent to &lt;code&gt;\pset recordsep_zero&lt;/code&gt;.</source>
          <target state="translated">정렬되지 않은 출력의 레코드 구분 기호를 0 바이트로 설정하십시오. 이것은 예를 들어 &lt;code&gt;xargs -0&lt;/code&gt; 과의 인터페이스에 유용합니다 . 이것은 &lt;code&gt;\pset recordsep_zero&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="930ef6885c00cc97435a715386680dcde7714694" translate="yes" xml:space="preserve">
          <source>Set the referencing column(s) to null.</source>
          <target state="translated">참조 열을 null로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4d9cd2328de0ac3ebe9aaea25390e3d3b8a5586e" translate="yes" xml:space="preserve">
          <source>Set the referencing column(s) to their default values. (There must be a row in the referenced table matching the default values, if they are not null, or the operation will fail.)</source>
          <target state="translated">참조 열을 기본값으로 설정하십시오. (참조 값이 널이 아닌 경우 기본값과 일치하는 행이 있어야합니다. 그렇지 않으면 조작이 실패합니다.)</target>
        </trans-unit>
        <trans-unit id="1ab8a3ed57ed5cc7dcd55edbdf7b03e75089bdff" translate="yes" xml:space="preserve">
          <source>Set the schema search path:</source>
          <target state="translated">스키마 검색 경로를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c2e8112fccc0d9b0690c85d167011ecb3d68df74" translate="yes" xml:space="preserve">
          <source>Set the statistics-gathering target for an expression index:</source>
          <target state="translated">표현식 인덱스에 대한 통계 수집 대상을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6c1a40c0a63382cbfde8c839977e818bedccccad" translate="yes" xml:space="preserve">
          <source>Set the style of date to traditional POSTGRES with &amp;ldquo;day before month&amp;rdquo; input convention:</source>
          <target state="translated">&quot;월 전날&quot;입력 규칙을 사용하여 날짜 스타일을 전통적인 POSTGRES로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="83ff14acdf29bad9c0b8e0edf50b709bf2c57639" translate="yes" xml:space="preserve">
          <source>Set the time zone for Berkeley, California:</source>
          <target state="translated">캘리포니아 버클리의 시간대를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9fcfc84885ac79cefce8ee11634afa4ff9a1e342" translate="yes" xml:space="preserve">
          <source>Set the time zone for Italy:</source>
          <target state="translated">이탈리아의 시간대를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ba6f75276f3a6ed816228af5900a7701f7509f56" translate="yes" xml:space="preserve">
          <source>Set the time zone to your local time zone (that is, the server's default value of &lt;code&gt;timezone&lt;/code&gt;).</source>
          <target state="translated">시간대를 로컬 시간대 (즉, 서버의 기본값 인 &lt;code&gt;timezone&lt;/code&gt; )로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9c69df8586fe91a449a340c15070908c685ac07f" translate="yes" xml:space="preserve">
          <source>Set this database's session default for the specified configuration parameter to the given value. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the database-specific setting is removed, so the system-wide default setting will be inherited in new sessions. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all database-specific settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the session's current value of the parameter as the database-specific value.</source>
          <target state="translated">지정된 구성 매개 변수에 대해이 데이터베이스의 세션 기본값을 제공된 값으로 설정하십시오. 경우 &lt;code&gt;value&lt;/code&gt; 이다 &lt;code&gt;DEFAULT&lt;/code&gt; 또는, 동등하게, &lt;code&gt;RESET&lt;/code&gt; 은 시스템 전체의 기본 설정은 새로운 세션에서 상속됩니다 사용되는 데이터베이스 고유의 설정이 제거됩니다, 그래서. &lt;code&gt;RESET ALL&lt;/code&gt; 을 사용 하여 모든 데이터베이스 별 설정을 지우십시오. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 매개 변수의 현재 세션 값을 데이터베이스 특정 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="68f5bcb6816068647c401920a5c1c25a3d69bf1c" translate="yes" xml:space="preserve">
          <source>Set this role's session default for the specified configuration parameter to the given value. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the role-specific variable setting is removed, so the role will inherit the system-wide default setting in new sessions. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all role-specific settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the session's current value of the parameter as the role-specific value. If &lt;code&gt;IN DATABASE&lt;/code&gt; is specified, the configuration parameter is set or removed for the given role and database only.</source>
          <target state="translated">지정된 구성 매개 변수에 대해이 역할의 세션 기본값을 제공된 값으로 설정하십시오. 경우 &lt;code&gt;value&lt;/code&gt; 입니다 &lt;code&gt;DEFAULT&lt;/code&gt; 또는, 동등하게, &lt;code&gt;RESET&lt;/code&gt; 을 사용하는 경우, 역할 별 변수 설정이 제거되고, 역할이 새로운 세션에서 시스템 전체의 기본 설정을 상속합니다 그래서. 모든 역할 별 설정을 지우려면 모두 &lt;code&gt;RESET ALL&lt;/code&gt; 사용하십시오 . &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 세션의 현재 매개 변수 값을 역할 별 값으로 저장합니다. 경우 &lt;code&gt;IN DATABASE&lt;/code&gt; 지정, 구성 매개 변수를 설정하거나 주어진 역할과 데이터베이스 만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6c6a35312ef12da1fe2d822f8332fdc98e7c69d9" translate="yes" xml:space="preserve">
          <source>Set to 1 to make the connection between PostgreSQL and the LDAP server use TLS encryption. This uses the &lt;code&gt;StartTLS&lt;/code&gt; operation per RFC 4513. See also the &lt;code&gt;ldapscheme&lt;/code&gt; option for an alternative.</source>
          <target state="translated">PostgreSQL과 LDAP 서버 간의 연결이 TLS 암호화를 사용하도록하려면 1로 설정하십시오. 이것은 RFC 4513에 따라 &lt;code&gt;StartTLS&lt;/code&gt; 조작을 사용합니다 . 대안 은 &lt;code&gt;ldapscheme&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="683669090494412f70884ca6fb430512580817c6" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;ldaps&lt;/code&gt; to use LDAPS. This is a non-standard way of using LDAP over SSL, supported by some LDAP server implementations. See also the &lt;code&gt;ldaptls&lt;/code&gt; option for an alternative.</source>
          <target state="translated">LDAPS를 사용 하려면 &lt;code&gt;ldaps&lt;/code&gt; 로 설정하십시오 . 이는 일부 LDAP 서버 구현에서 지원되는 SSL을 통한 LDAP 사용의 비표준 방법입니다. 대안 은 &lt;code&gt;ldaptls&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e660238c05164064387bf1a9d83bcf539151bd62" translate="yes" xml:space="preserve">
          <source>Set to correlation coefficient between index scan order and underlying table's order</source>
          <target state="translated">인덱스 스캔 순서와 기본 테이블 순서 사이의 상관 계수로 설정</target>
        </trans-unit>
        <trans-unit id="2330a55e7653c2a15d3ce13913d3523e6bfc30ad" translate="yes" xml:space="preserve">
          <source>Set to cost of index start-up processing</source>
          <target state="translated">인덱스 시작 처리 비용으로 설정</target>
        </trans-unit>
        <trans-unit id="6182156409a90176ef213757ef2fcb929216fcc9" translate="yes" xml:space="preserve">
          <source>Set to index selectivity</source>
          <target state="translated">인덱스 선택 도로 설정</target>
        </trans-unit>
        <trans-unit id="220b564cf30074d79f0445248bd40d06d084fc32" translate="yes" xml:space="preserve">
          <source>Set to number of index leaf pages</source>
          <target state="translated">인덱스 리프 페이지 수로 설정</target>
        </trans-unit>
        <trans-unit id="5c98d7fe8a451d4163d65a6edb590b39ce4b61a5" translate="yes" xml:space="preserve">
          <source>Set to total cost of index processing</source>
          <target state="translated">총 인덱스 처리 비용으로 설정</target>
        </trans-unit>
        <trans-unit id="5359a9498756c3b228b42db08b2eda0230fec090" translate="yes" xml:space="preserve">
          <source>Set up continuous archiving from the primary to a WAL archive directory on the standby server. Ensure that &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt;, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; and &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; are set appropriately on the primary (see &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;Section 25.3.1&lt;/a&gt;).</source>
          <target state="translated">기본 서버에서 대기 서버의 WAL 아카이브 디렉토리로 연속 아카이브를 설정하십시오. &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; , &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; 이 기본에 적절하게 설정되어 있는지 확인하십시오 ( &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;25.3.1 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9f9ede509821bafb716f13390c574a64efb7c48b" translate="yes" xml:space="preserve">
          <source>Set up continuous archiving on the primary to an archive directory accessible from the standby, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. The archive location should be accessible from the standby even when the master is down, i.e. it should reside on the standby server itself or another trusted server, not on the master server.</source>
          <target state="translated">&lt;a href=&quot;continuous-archiving&quot;&gt;25.3 절에&lt;/a&gt; 설명 된대로 기본 서버에서 연속 아카이브를 대기에서 액세스 할 수있는 아카이브 디렉토리로 설정하십시오 . 마스터가 다운 된 경우에도 대기에서 아카이브 위치에 액세스 할 수 있어야합니다. 즉, 마스터 서버가 아닌 대기 서버 자체 또는 다른 신뢰할 수있는 서버에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a09c020999ab50b34569b86fb12bb08c44504e5" translate="yes" xml:space="preserve">
          <source>Set up continuous archiving on the primary to an archive directory accessible from the standby, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. The archive location should be accessible from the standby even when the master is down, i.e., it should reside on the standby server itself or another trusted server, not on the master server.</source>
          <target state="translated">&lt;a href=&quot;continuous-archiving&quot;&gt;섹션 25.3에&lt;/a&gt; 설명 된대로 대기에서 액세스 할 수있는 아카이브 디렉토리로 기본에서 연속 아카이브를 설정합니다 . 아카이브 위치는 마스터가 다운 된 경우에도 대기에서 액세스 할 수 있어야합니다. 즉, 마스터 서버가 아닌 대기 서버 자체 또는 다른 신뢰할 수있는 서버에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ba3c1c98673b5e6457689ce72c3830f8e0271e7f" translate="yes" xml:space="preserve">
          <source>Set up primary and standby systems as nearly identical as possible, including two identical copies of PostgreSQL at the same release level.</source>
          <target state="translated">동일한 릴리스 레벨에서 동일한 PostgreSQL 사본 두 개를 포함하여 기본 시스템과 대기 시스템을 최대한 동일하게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f2fcee7256a27aba62c3ac4f3a3e22e85e96077c" translate="yes" xml:space="preserve">
          <source>Set-Returning Function</source>
          <target state="translated">복귀 기능</target>
        </trans-unit>
        <trans-unit id="ff72e3e8793e95db8e23e10b2453273ef2da7b0b" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;functions-binarystring#FUNCTIONS-ZEROBASED-NOTE&quot;&gt;n'th&lt;/a&gt; bit in binary string to &lt;em&gt;&lt;code&gt;newvalue&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">설정 &lt;a href=&quot;functions-binarystring#FUNCTIONS-ZEROBASED-NOTE&quot;&gt;n 번째&lt;/a&gt; 이진 문자열의 비트 &lt;em&gt; &lt;code&gt;newvalue&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="10b9a9929f938ec1acaa3aa7d2ab9655203ced85" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;functions-binarystring#FUNCTIONS-ZEROBASED-NOTE&quot;&gt;n'th&lt;/a&gt; byte in binary string to &lt;em&gt;&lt;code&gt;newvalue&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">설정 &lt;a href=&quot;functions-binarystring#FUNCTIONS-ZEROBASED-NOTE&quot;&gt;n 번째&lt;/a&gt; 이진 문자열의 바이트 &lt;em&gt; &lt;code&gt;newvalue&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6daaf36bacc368a44e7d98c57effb9301c4e42ec" translate="yes" xml:space="preserve">
          <source>Sets &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;'th bit in bit string to &lt;em&gt;&lt;code&gt;newvalue&lt;/code&gt;&lt;/em&gt;; the first (leftmost) bit is bit 0.</source>
          <target state="translated">설정 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; '에 비트 문자열 번째 비트 &lt;em&gt; &lt;code&gt;newvalue&lt;/code&gt; &lt;/em&gt; ; 첫 번째 (가장 왼쪽) 비트는 비트 0입니다.</target>
        </trans-unit>
        <trans-unit id="0b0c1ea3def792585ed0dea855bd1a53e789d41d" translate="yes" xml:space="preserve">
          <source>Sets a name that identifies this database cluster (instance) for various purposes. The cluster name appears in the process title for all server processes in this cluster. Moreover, it is the default application name for a standby connection (see &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt;.)</source>
          <target state="translated">다양한 목적으로이 데이터베이스 클러스터 (인스턴스)를 식별하는 이름을 설정합니다. 클러스터 이름은이 클러스터의 모든 서버 프로세스에 대한 프로세스 제목에 나타납니다. 또한 대기 연결의 기본 애플리케이션 이름입니다 ( &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ed735bd783061dca7982171b5c9ebe7a346a5c11" translate="yes" xml:space="preserve">
          <source>Sets a named run-time parameter. The configuration parameters supported by PostgreSQL are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. Most of the other command line options are in fact short forms of such a parameter assignment. &lt;code&gt;-c&lt;/code&gt; can appear multiple times to set multiple parameters.</source>
          <target state="translated">명명 된 런타임 매개 변수를 설정합니다. PostgreSQL에서 지원하는 구성 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 설명되어 있습니다. 다른 명령 행 옵션의 대부분은 실제로 그러한 매개 변수 지정의 짧은 형식입니다. &lt;code&gt;-c&lt;/code&gt; 는 여러 번 나타나서 여러 매개 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1983d8f8faef6474812f64ab07ff8833dd4f08b2" translate="yes" xml:space="preserve">
          <source>Sets a named run-time parameter. The configuration parameters supported by PostgreSQL are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. Most of the other command line options are in fact short forms of such a parameter assignment. &lt;code&gt;-c&lt;/code&gt; can appear multiple times to set multiple parameters.</source>
          <target state="translated">명명 된 런타임 매개 변수를 설정합니다. PostgreSQL에서 지원하는 구성 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 설명되어 있습니다. 대부분의 다른 명령 줄 옵션은 실제로 이러한 매개 변수 할당의 짧은 형식입니다. &lt;code&gt;-c&lt;/code&gt; 는 여러 매개 변수를 설정하기 위해 여러 번 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31043e3327e97d20dfb6d1539baa1a874e2c002d" translate="yes" xml:space="preserve">
          <source>Sets a named run-time parameter; a shorter form of &lt;code&gt;-c&lt;/code&gt;.</source>
          <target state="translated">명명 된 런타임 매개 변수를 설정합니다. 짧은 형태 &lt;code&gt;-c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5da8c217bb1dba6c6d867dd666bfa4ff9e021ba" translate="yes" xml:space="preserve">
          <source>Sets an external command to be invoked when a passphrase for decrypting an SSL file such as a private key needs to be obtained. By default, this parameter is empty, which means the built-in prompting mechanism is used.</source>
          <target state="translated">개인 키와 같은 SSL 파일을 암호 해독하기위한 암호를 얻어야 할 때 외부 명령이 호출되도록 설정합니다. 기본적으로이 매개 변수는 비어 있습니다. 이는 내장 된 프롬프트 메커니즘이 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dc6ce3b991bc5b15c28df298e7bc5c83c4e57c95" translate="yes" xml:space="preserve">
          <source>Sets checkpoint mode to fast (immediate) or spread (default) (see &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;).</source>
          <target state="translated">검사 점 모드를 빠른 (즉시) 또는 스프레드 (기본값)로 설정합니다 ( &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;섹션 25.3.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="761e082eef9ae04432abb168f69a6264eede6a2a" translate="yes" xml:space="preserve">
          <source>Sets checkpoint mode to fast (immediate) or spread (the default) (see &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;).</source>
          <target state="translated">체크 포인트 모드를 고속 (즉시) 또는 확산 (기본값)으로 설정합니다 ( &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;섹션 25.3.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a78247a7e33823edc1dad3d6f55aca8c9cf244e9" translate="yes" xml:space="preserve">
          <source>Sets how binary values are to be encoded in XML. This applies for example when &lt;code&gt;bytea&lt;/code&gt; values are converted to XML by the functions &lt;code&gt;xmlelement&lt;/code&gt; or &lt;code&gt;xmlforest&lt;/code&gt;. Possible values are &lt;code&gt;base64&lt;/code&gt; and &lt;code&gt;hex&lt;/code&gt;, which are both defined in the XML Schema standard. The default is &lt;code&gt;base64&lt;/code&gt;. For further information about XML-related functions, see &lt;a href=&quot;functions-xml&quot;&gt;Section 9.14&lt;/a&gt;.</source>
          <target state="translated">이진 값을 XML로 인코딩하는 방법을 설정합니다. 예를 들어 &lt;code&gt;bytea&lt;/code&gt; 값이 &lt;code&gt;xmlelement&lt;/code&gt; 또는 &lt;code&gt;xmlforest&lt;/code&gt; 함수에 의해 XML로 변환 될 때 적용됩니다 . 가능한 값은 &lt;code&gt;base64&lt;/code&gt; 및 &lt;code&gt;hex&lt;/code&gt; 이며 둘 다 XML 스키마 표준에 정의되어 있습니다. 기본값은 &lt;code&gt;base64&lt;/code&gt; 입니다. XML 관련 함수에 대한 자세한 내용은 &lt;a href=&quot;functions-xml&quot;&gt;9.14 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5dbde1f4b22be1d587babeebf97b17b1f0844037" translate="yes" xml:space="preserve">
          <source>Sets how binary values are to be encoded in XML. This applies for example when &lt;code&gt;bytea&lt;/code&gt; values are converted to XML by the functions &lt;code&gt;xmlelement&lt;/code&gt; or &lt;code&gt;xmlforest&lt;/code&gt;. Possible values are &lt;code&gt;base64&lt;/code&gt; and &lt;code&gt;hex&lt;/code&gt;, which are both defined in the XML Schema standard. The default is &lt;code&gt;base64&lt;/code&gt;. For further information about XML-related functions, see &lt;a href=&quot;functions-xml&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">이진 값을 XML로 인코딩하는 방법을 설정합니다. 예를 들어 &lt;code&gt;bytea&lt;/code&gt; 값이 &lt;code&gt;xmlelement&lt;/code&gt; 또는 &lt;code&gt;xmlforest&lt;/code&gt; 함수에 의해 XML로 변환 될 때 적용됩니다 . 가능한 값은 모두 XML 스키마 표준에 정의 된 &lt;code&gt;base64&lt;/code&gt; 및 &lt;code&gt;hex&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;base64&lt;/code&gt; 입니다. XML 관련 함수에 대한 자세한 내용은 &lt;a href=&quot;functions-xml&quot;&gt;섹션 9.15를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15a96440e720528fbfdee2a4bdf9de98f4038bad" translate="yes" xml:space="preserve">
          <source>Sets maximum number of concurrent connections that can be made to this database. -1 means no limit.</source>
          <target state="translated">이 데이터베이스에 만들 수있는 최대 동시 연결 수를 설정합니다. -1은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9a0e551e8702d55f0e306d4663110fa615f5d1aa" translate="yes" xml:space="preserve">
          <source>Sets or resets a view option. Currently supported options are:</source>
          <target state="translated">보기 옵션을 설정하거나 재설정합니다. 현재 지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="679b9629c4460c677f4963908686e11816d4c62f" translate="yes" xml:space="preserve">
          <source>Sets or toggles expanded table formatting mode. As such it is equivalent to &lt;code&gt;\pset expanded&lt;/code&gt;.</source>
          <target state="translated">확장 테이블 서식 모드를 설정하거나 토글합니다. 따라서 &lt;code&gt;\pset expanded&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d08f56cc33f4370d07f44f3e6691b7f4cc178fdf" translate="yes" xml:space="preserve">
          <source>Sets replication progress for the given node to the given location. This is primarily useful for setting up the initial location, or setting a new location after configuration changes and similar. Be aware that careless use of this function can lead to inconsistently replicated data.</source>
          <target state="translated">지정된 노드의 복제 진행률을 지정된 위치로 설정합니다. 이것은 주로 초기 위치를 설정하거나 구성 변경 등의 후 새 위치를 설정하는 데 유용합니다. 이 기능을 부주의하게 사용하면 데이터가 일관성없이 복제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f787d4e05342766ae66cb286e975f3ae204daac" translate="yes" xml:space="preserve">
          <source>Sets the 7th bit of the address to one, creating what is known as modified EUI-64, for inclusion in an IPv6 address.</source>
          <target state="translated">주소의 7 번째 비트를 1로 설정하여 IPv6 주소에 포함 할 수정 된 EUI-64를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1167314e9da9165a4ecfbeaf5207efeb06fbb7ff" translate="yes" xml:space="preserve">
          <source>Sets the access permissions of the Unix-domain socket(s). Unix-domain sockets use the usual Unix file system permission set. The parameter value is expected to be a numeric mode specified in the format accepted by the &lt;code&gt;chmod&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; system calls. (To use the customary octal format the number must start with a &lt;code&gt;0&lt;/code&gt; (zero).)</source>
          <target state="translated">Unix 도메인 소켓의 액세스 권한을 설정합니다. 유닉스 도메인 소켓은 일반적인 유닉스 파일 시스템 권한 세트를 사용합니다. 매개 변수 값은 &lt;code&gt;chmod&lt;/code&gt; 및 &lt;code&gt;umask&lt;/code&gt; 시스템 호출 에서 허용하는 형식으로 지정된 숫자 모드 여야 합니다. (일반적인 8 진수 형식을 사용하려면 숫자는 &lt;code&gt;0&lt;/code&gt; 으로 시작해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="5a6f469f1d1f928ad6a1d54c66c5b13a6529fbff" translate="yes" xml:space="preserve">
          <source>Sets the amount of memory the database server uses for shared memory buffers. The default is typically 128 megabytes (&lt;code&gt;128MB&lt;/code&gt;), but might be less if your kernel settings will not support it (as determined during initdb). This setting must be at least 128 kilobytes. However, settings significantly higher than the minimum are usually needed for good performance. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. (Non-default values of &lt;code&gt;BLCKSZ&lt;/code&gt; change the minimum value.) This parameter can only be set at server start.</source>
          <target state="translated">데이터베이스 서버가 공유 메모리 버퍼에 사용하는 메모리의 양을 설정합니다. 기본값은 일반적으로 &lt;code&gt;128MB&lt;/code&gt; ( 128MB )이지만 커널 설정이이를 지원하지 않는 경우 (initdb 중에 결정된 경우) 더 적을 수 있습니다. 이 설정은 128 킬로바이트 이상이어야합니다. 그러나 성능을 높이려면 일반적으로 최소값보다 훨씬 높은 설정이 필요합니다. 이 값을 단위없이 지정하면 블록으로, 즉 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트 (일반적으로 8kB)로 사용됩니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 의 기본값이 아닌 경우 최소값이 변경됩니다.)이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ad69115b88cf303bab0325a6499b217ed1693e" translate="yes" xml:space="preserve">
          <source>Sets the base maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files. If this value is specified without units, it is taken as kilobytes. The default value is four megabytes (&lt;code&gt;4MB&lt;/code&gt;). Note that for a complex query, several sort or hash operations might be running in parallel; each operation will generally be allowed to use as much memory as this value specifies before it starts to write data into temporary files. Also, several running sessions could be doing such operations concurrently. Therefore, the total memory used could be many times the value of &lt;code&gt;work_mem&lt;/code&gt;; it is necessary to keep this fact in mind when choosing the value. Sort operations are used for &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, and merge joins. Hash tables are used in hash joins, hash-based aggregation, and hash-based processing of &lt;code&gt;IN&lt;/code&gt; subqueries.</source>
          <target state="translated">임시 디스크 파일에 쓰기 전에 쿼리 작업 (예 : 정렬 또는 해시 테이블)에서 사용할 기본 최대 메모리 양을 설정합니다. 이 값이 단위없이 지정되면 킬로바이트로 간주됩니다. 기본값은 &lt;code&gt;4MB&lt;/code&gt; ( 4MB )입니다. 복잡한 쿼리의 경우 여러 정렬 또는 해시 작업이 병렬로 실행될 수 있습니다. 각 작업은 일반적으로 임시 파일에 데이터 쓰기를 시작하기 전에이 값이 지정한만큼의 메모리를 사용할 수 있습니다. 또한 실행중인 여러 세션에서 이러한 작업을 동시에 수행 할 수 있습니다. 따라서 사용 된 총 메모리는 &lt;code&gt;work_mem&lt;/code&gt; 값의 여러 배가 될 수 있습니다 . 값을 선택할 때이 사실을 염두에 두어야합니다. 정렬 작업은 &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;DISTINCT&lt;/code&gt; 에 사용됩니다., 병합 조인. 해시 테이블은 해시 조인, 해시 기반 집계 및 &lt;code&gt;IN&lt;/code&gt; 하위 쿼리 의 해시 기반 처리에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="c11997d5801d5d90ca41a32aba2e1420ec14bb67" translate="yes" xml:space="preserve">
          <source>Sets the border drawing style for the &lt;code&gt;unicode&lt;/code&gt; line style to one of &lt;code&gt;single&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 선 스타일 의 테두리 그리기 스타일을 &lt;code&gt;single&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ddca1c468c89d3c635fe6142fe9c8ec3e8bfb309" translate="yes" xml:space="preserve">
          <source>Sets the border line drawing style to one of &lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;old-ascii&lt;/code&gt;, or &lt;code&gt;unicode&lt;/code&gt;. Unique abbreviations are allowed. (That would mean one letter is enough.) The default setting is &lt;code&gt;ascii&lt;/code&gt;. This option only affects the &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;wrapped&lt;/code&gt; output formats.</source>
          <target state="translated">경계선 그리기 스타일을 &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;old-ascii&lt;/code&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 중 하나로 설정합니다 . 고유 한 약어가 허용됩니다. (이것은 하나의 문자로 충분하다는 것을 의미합니다.) 기본 설정은 &lt;code&gt;ascii&lt;/code&gt; 입니다. 이 옵션은 &lt;code&gt;aligned&lt;/code&gt; 및 줄 &lt;code&gt;wrapped&lt;/code&gt; 출력 형식 에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="ccf918125330a91b0b053e186744cbdc511c1139" translate="yes" xml:space="preserve">
          <source>Sets the client character set encoding. Without an argument, this command shows the current encoding.</source>
          <target state="translated">클라이언트 문자 세트 인코딩을 설정합니다. 인수가 없으면이 명령은 현재 인코딩을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9ca3459955f1a2d16536b1e1a6629645bad3442f" translate="yes" xml:space="preserve">
          <source>Sets the client-side encoding (character set). The default is to use the database encoding. The character sets supported by the PostgreSQL server are described in &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;Section 23.3.1&lt;/a&gt;.</source>
          <target state="translated">클라이언트 측 인코딩 (문자 세트)을 설정합니다. 디폴트는 데이터베이스 인코딩을 사용하는 것입니다. PostgreSQL 서버가 지원하는 문자 세트는 &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;23.3.1 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="101420fb1bdd363bfb4fc74209fc3ce35a1f2232" translate="yes" xml:space="preserve">
          <source>Sets the collection of time zone abbreviations that will be accepted by the server for datetime input. The default is &lt;code&gt;'Default'&lt;/code&gt;, which is a collection that works in most of the world; there are also &lt;code&gt;'Australia'&lt;/code&gt; and &lt;code&gt;'India'&lt;/code&gt;, and other collections can be defined for a particular installation. See &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt; for more information.</source>
          <target state="translated">날짜 / 시간 입력을 위해 서버에서 허용 할 시간대 약어 콜렉션을 설정합니다. 기본값은 &lt;code&gt;'Default'&lt;/code&gt; 이며 대부분의 세계에서 작동하는 모음입니다. 이 또한 &lt;code&gt;'Australia'&lt;/code&gt; 와 &lt;code&gt;'India'&lt;/code&gt; , 그리고 다른 컬렉션은 특정 설치에 대해 정의 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;datetime-config-files&quot;&gt;섹션 B.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d2d6fab3f45f53eef51a7610b019e27ca0455e3" translate="yes" xml:space="preserve">
          <source>Sets the column drawing style for the &lt;code&gt;unicode&lt;/code&gt; line style to one of &lt;code&gt;single&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 선 스타일 의 열 그리기 스타일을 &lt;code&gt;single&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="427af7ca184d1754159de0f7314e9d25355f3e91" translate="yes" xml:space="preserve">
          <source>Sets the current similarity threshold that is used by the &lt;code&gt;%&lt;/code&gt; operator. The threshold must be between 0 and 1 (default is 0.3).</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 연산자 가 사용하는 현재 유사성 임계 값을 설정합니다 . 임계 값은 0과 1 사이 여야합니다 (기본값은 0.3).</target>
        </trans-unit>
        <trans-unit id="b140843aaa99b7a0771486bfccf71022252d8ea5" translate="yes" xml:space="preserve">
          <source>Sets the current similarity threshold that is used by the &lt;code&gt;%&lt;/code&gt; operator. The threshold must be between 0 and 1 (default is 0.3). Returns the same value passed in (&lt;em&gt;deprecated&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 연산자 가 사용하는 현재 유사성 임계 값을 설정합니다 . 임계 값은 0과 1 사이 여야합니다 (기본값은 0.3). 전달 된 동일한 값 ( &lt;em&gt;더 이상 사용되지 않음&lt;/em&gt; )을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d95cb99c076664de73db507783174348c33e3f33" translate="yes" xml:space="preserve">
          <source>Sets the current similarity threshold that is used by the &lt;code&gt;%&lt;/code&gt; operator. The threshold must be between 0 and 1 (default is 0.3). Returns the same value passed in. (&lt;em&gt;Deprecated&lt;/em&gt;; instead use &lt;code&gt;SET&lt;/code&gt;&lt;code&gt;pg_trgm.similarity_threshold&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 연산자 가 사용하는 현재 유사성 임계 값을 설정합니다 . 임계 값은 0과 1 사이 여야합니다 (기본값은 0.3). 전달 된 동일한 값을 반환합니다. ( &lt;em&gt;사용되지 않음&lt;/em&gt; , 대신 &lt;code&gt;SET&lt;/code&gt; &lt;code&gt;pg_trgm.similarity_threshold&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="eb3fcef8539dc55176e548b2fc3a9288bdd92da4" translate="yes" xml:space="preserve">
          <source>Sets the current strict word similarity threshold that is used by the &lt;code&gt;&amp;lt;&amp;lt;%&lt;/code&gt; and &lt;code&gt;%&amp;gt;&amp;gt;&lt;/code&gt; operators. The threshold must be between 0 and 1 (default is 0.5).</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;%&lt;/code&gt; 및 &lt;code&gt;%&amp;gt;&amp;gt;&lt;/code&gt; 연산자 가 사용하는 현재 엄격한 단어 유사성 임계 값을 설정합니다 . 임계 값은 0과 1 사이 여야합니다 (기본값은 0.5).</target>
        </trans-unit>
        <trans-unit id="90e66a2fef8e334523508ce94ca84f7873e520fe" translate="yes" xml:space="preserve">
          <source>Sets the current word similarity threshold that is used by the &lt;code&gt;&amp;lt;%&lt;/code&gt; and &lt;code&gt;%&amp;gt;&lt;/code&gt; operators. The threshold must be between 0 and 1 (default is 0.6).</source>
          <target state="translated">&lt;code&gt;&amp;lt;%&lt;/code&gt; 및 &lt;code&gt;%&amp;gt;&lt;/code&gt; 연산자 가 사용하는 현재 단어 유사성 임계 값을 설정합니다 . 임계 값은 0과 1 사이 여야합니다 (기본값은 0.6).</target>
        </trans-unit>
        <trans-unit id="cf67a99f64dcda3530942c13f616f4059128e0ee" translate="yes" xml:space="preserve">
          <source>Sets the debug level. The higher this value is set, the more debugging output is written to the server log. Values are from 1 to 5. It is also possible to pass &lt;code&gt;-d 0&lt;/code&gt; for a specific session, which will prevent the server log level of the parent &lt;code&gt;postgres&lt;/code&gt; process from being propagated to this session.</source>
          <target state="translated">디버그 레벨을 설정합니다. 이 값이 높을수록 서버 로그에 더 많은 디버깅 출력이 기록됩니다. 값은 &lt;code&gt;-d 0&lt;/code&gt; 입니다. 특정 세션에 대해 -d 0 을 전달할 수도 있습니다 . 이렇게 하면 상위 &lt;code&gt;postgres&lt;/code&gt; 프로세스 의 서버 로그 수준 이이 세션으로 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1d3d71e9ac2216b846e079b3b77a36ef85e95c4" translate="yes" xml:space="preserve">
          <source>Sets the default date style to &amp;ldquo;European&amp;rdquo;, that is &lt;code&gt;DMY&lt;/code&gt; ordering of input date fields. This also causes the day to be printed before the month in certain date output formats. See &lt;a href=&quot;datatype-datetime&quot;&gt;Section 8.5&lt;/a&gt; for more information.</source>
          <target state="translated">기본 날짜 스타일을 &quot;유럽어&quot;, 즉 입력 날짜 필드의 &lt;code&gt;DMY&lt;/code&gt; 순서로 설정합니다. 이로 인해 특정 날짜 출력 형식으로 해당 월 이전에 날짜가 인쇄됩니다. 자세한 정보는 &lt;a href=&quot;datatype-datetime&quot;&gt;8.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06b8835c9925b9c88a1677189417ca7070f5914d" translate="yes" xml:space="preserve">
          <source>Sets the default locale for the database cluster. If this option is not specified, the locale is inherited from the environment that &lt;code&gt;initdb&lt;/code&gt; runs in. Locale support is described in &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 클러스터의 기본 로케일을 설정합니다. 이 옵션을 지정하지 않으면, 로케일은 &lt;code&gt;initdb&lt;/code&gt; 가 실행 되는 환경에서 상속 됩니다 . 로케일 지원은 &lt;a href=&quot;locale&quot;&gt;23.1 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c091ced8eaab5eee9ba74488a133cd6ae8630c" translate="yes" xml:space="preserve">
          <source>Sets the default statistics target for table columns without a column-specific target set via &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;. Larger values increase the time needed to do &lt;code&gt;ANALYZE&lt;/code&gt;, but might improve the quality of the planner's estimates. The default is 100. For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 를 통해 열별 대상이 설정되지 않은 테이블 열의 기본 통계 대상을 설정합니다 . 값이 클수록 &lt;code&gt;ANALYZE&lt;/code&gt; 수행에 필요한 시간이 증가 하지만 플래너 추정치의 품질이 향상 될 수 있습니다. 기본값은 100입니다. PostgreSQL 쿼리 플래너가 통계를 사용하는 방법에 대한 자세한 내용 &lt;a href=&quot;planner-stats&quot;&gt;은 14.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29f7d62c6b1f3372d7f449e1d8c27e26ee5c3430" translate="yes" xml:space="preserve">
          <source>Sets the default text search configuration. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; for further information.</source>
          <target state="translated">기본 텍스트 검색 구성을 설정합니다. 자세한 정보는 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab4ee0bd00aa149c3079a604b266282122001246" translate="yes" xml:space="preserve">
          <source>Sets the directory to store temporary statistics data in. This can be a path relative to the data directory or an absolute path. The default is &lt;code&gt;pg_stat_tmp&lt;/code&gt;. Pointing this at a RAM-based file system will decrease physical I/O requirements and can lead to improved performance. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">임시 통계 데이터를 저장할 디렉토리를 설정합니다. 데이터 디렉토리에 대한 상대 경로이거나 절대 경로 일 수 있습니다. 기본값은 &lt;code&gt;pg_stat_tmp&lt;/code&gt; 입니다. 이를 RAM 기반 파일 시스템으로 지정하면 물리적 I / O 요구 사항이 줄어들고 성능이 향상 될 수 있습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c94a6dad26557a50a1ff5c6f3f4e5528025a1d4" translate="yes" xml:space="preserve">
          <source>Sets the directory to write WAL (write-ahead log) files to. By default WAL files will be placed in the &lt;code&gt;pg_wal&lt;/code&gt; subdirectory of the target directory, but this option can be used to place them elsewhere. &lt;code&gt;waldir&lt;/code&gt; must be an absolute path. As with the main target directory, &lt;code&gt;waldir&lt;/code&gt; need not exist already, but if it does exist it must be empty. This option can only be specified when the backup is in plain format.</source>
          <target state="translated">WAL (Write-Ahead Log) 파일을 기록 할 디렉토리를 설정합니다. 기본적으로 WAL 파일은 대상 디렉토리 의 &lt;code&gt;pg_wal&lt;/code&gt; 하위 디렉토리에 배치 되지만이 옵션을 사용하여 다른 곳에 배치 할 수 있습니다. &lt;code&gt;waldir&lt;/code&gt; 는 절대 경로 여야합니다. 기본 대상 디렉토리와 &lt;code&gt;waldir&lt;/code&gt; 는 이미 존재하지 않아도되지만 존재하는 경우 비어 있어야합니다. 이 옵션은 백업이 일반 형식 인 경우에만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de41f7a43d918ac8425108d9af6484110715198" translate="yes" xml:space="preserve">
          <source>Sets the display format for date and time values, as well as the rules for interpreting ambiguous date input values. For historical reasons, this variable contains two independent components: the output format specification (&lt;code&gt;ISO&lt;/code&gt;, &lt;code&gt;Postgres&lt;/code&gt;, &lt;code&gt;SQL&lt;/code&gt;, or &lt;code&gt;German&lt;/code&gt;) and the input/output specification for year/month/day ordering (&lt;code&gt;DMY&lt;/code&gt;, &lt;code&gt;MDY&lt;/code&gt;, or &lt;code&gt;YMD&lt;/code&gt;). These can be set separately or together. The keywords &lt;code&gt;Euro&lt;/code&gt; and &lt;code&gt;European&lt;/code&gt; are synonyms for &lt;code&gt;DMY&lt;/code&gt;; the keywords &lt;code&gt;US&lt;/code&gt;, &lt;code&gt;NonEuro&lt;/code&gt;, and &lt;code&gt;NonEuropean&lt;/code&gt; are synonyms for &lt;code&gt;MDY&lt;/code&gt;. See &lt;a href=&quot;datatype-datetime&quot;&gt;Section 8.5&lt;/a&gt; for more information. The built-in default is &lt;code&gt;ISO, MDY&lt;/code&gt;, but initdb will initialize the configuration file with a setting that corresponds to the behavior of the chosen &lt;code&gt;lc_time&lt;/code&gt; locale.</source>
          <target state="translated">모호한 날짜 입력 값을 해석하기위한 규칙뿐만 아니라 날짜 및 시간 값의 표시 형식을 설정합니다. 역사적 이유로이 변수에는 출력 형식 스펙 ( &lt;code&gt;ISO&lt;/code&gt; , &lt;code&gt;Postgres&lt;/code&gt; , &lt;code&gt;SQL&lt;/code&gt; 또는 &lt;code&gt;German&lt;/code&gt; )과 년 / 월 / 일 순서 ( &lt;code&gt;DMY&lt;/code&gt; , &lt;code&gt;MDY&lt;/code&gt; 또는 &lt;code&gt;YMD&lt;/code&gt; ) 의 입력 / 출력 스펙 이라는 두 개의 독립 컴포넌트가 포함됩니다 . 이들은 개별적으로 또는 함께 설정할 수 있습니다. &lt;code&gt;Euro&lt;/code&gt; 및 &lt;code&gt;European&lt;/code&gt; 키워드 는 &lt;code&gt;DMY&lt;/code&gt; 와 동의어입니다 . 키워드 &lt;code&gt;US&lt;/code&gt; , &lt;code&gt;NonEuro&lt;/code&gt; 및 &lt;code&gt;NonEuropean&lt;/code&gt; 은 &lt;code&gt;MDY&lt;/code&gt; 의 동의어입니다.. 자세한 정보는 &lt;a href=&quot;datatype-datetime&quot;&gt;8.5 절&lt;/a&gt; 을 참조하십시오. 내장 된 기본값은 &lt;code&gt;ISO, MDY&lt;/code&gt; 이지만 initdb는 선택한 &lt;code&gt;lc_time&lt;/code&gt; 로케일 의 동작에 해당하는 설정으로 구성 파일을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="58f48ffade96607de7baf0ad73b8b8a85d198fbe" translate="yes" xml:space="preserve">
          <source>Sets the display format for interval values. The value &lt;code&gt;sql_standard&lt;/code&gt; will produce output matching SQL standard interval literals. The value &lt;code&gt;postgres&lt;/code&gt; (which is the default) will produce output matching PostgreSQL releases prior to 8.4 when the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter was set to &lt;code&gt;ISO&lt;/code&gt;. The value &lt;code&gt;postgres_verbose&lt;/code&gt; will produce output matching PostgreSQL releases prior to 8.4 when the &lt;code&gt;DateStyle&lt;/code&gt; parameter was set to non-&lt;code&gt;ISO&lt;/code&gt; output. The value &lt;code&gt;iso_8601&lt;/code&gt; will produce output matching the time interval &amp;ldquo;format with designators&amp;rdquo; defined in section 4.4.3.2 of ISO 8601.</source>
          <target state="translated">간격 값의 표시 형식을 설정합니다. &lt;code&gt;sql_standard&lt;/code&gt; 값 은 SQL 표준 간격 리터럴과 일치하는 출력을 생성합니다. &lt;code&gt;postgres&lt;/code&gt; 값 (기본값)은 &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; 매개 변수가 &lt;code&gt;ISO&lt;/code&gt; 로 설정된 8.4 이전의 PostgreSQL 릴리스와 일치하는 출력을 생성합니다 . &lt;code&gt;postgres_verbose&lt;/code&gt; 값 은 &lt;code&gt;DateStyle&lt;/code&gt; 매개 변수가 &lt;code&gt;ISO&lt;/code&gt; 가 아닌 출력 으로 설정된 8.4 이전의 PostgreSQL 릴리스와 일치하는 출력을 생성 합니다. &lt;code&gt;iso_8601&lt;/code&gt; 값 은 ISO 8601의 4.4.3.2 섹션에 정의 된 &quot;지정자를 가진 형식&quot;시간 간격과 일치하는 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a20dec33eef22411e9b425e2640de61886335226" translate="yes" xml:space="preserve">
          <source>Sets the environment variable &lt;code&gt;name&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, or if the &lt;code&gt;value&lt;/code&gt; is not supplied, unsets the environment variable. Example:</source>
          <target state="translated">환경 변수 &lt;code&gt;name&lt;/code&gt; 을 &lt;code&gt;value&lt;/code&gt; 로 설정하거나 &lt;code&gt;value&lt;/code&gt; 제공하지 않으면 환경 변수를 설정 해제합니다. 예:</target>
        </trans-unit>
        <trans-unit id="190bfe6a04ad011d88e91ad5c787ffb49764249c" translate="yes" xml:space="preserve">
          <source>Sets the field separator for unaligned query output. The default is the vertical bar (&lt;code&gt;|&lt;/code&gt;). It is equivalent to &lt;code&gt;\pset fieldsep&lt;/code&gt;.</source>
          <target state="translated">정렬되지 않은 쿼리 출력에 대한 필드 구분 기호를 설정합니다. 기본값은 세로 막대 ( &lt;code&gt;|&lt;/code&gt; )입니다. &lt;code&gt;\pset fieldsep&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f305ecb1e8b3a8014c6025983d81717acb3fea" translate="yes" xml:space="preserve">
          <source>Sets the field separator to use in unaligned output format to a zero byte.</source>
          <target state="translated">정렬되지 않은 출력 형식으로 사용할 필드 구분 기호를 0 바이트로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bcdc99e181447b7321532649ed3a630ceac01f28" translate="yes" xml:space="preserve">
          <source>Sets the fraction of transactions whose statements are all logged, in addition to statements logged for other reasons. It applies to each new transaction regardless of its statements' durations. Sampling is stochastic, for example &lt;code&gt;0.1&lt;/code&gt; means there is statistically one chance in ten that any given transaction will be logged. &lt;code&gt;log_transaction_sample_rate&lt;/code&gt; can be helpful to construct a sample of transactions. The default is &lt;code&gt;0&lt;/code&gt;, meaning not to log statements from any additional transactions. Setting this to &lt;code&gt;1&lt;/code&gt; logs all statements of all transactions. Only superusers can change this setting.</source>
          <target state="translated">다른 이유로 기록 된 문 외에 문이 모두 기록되는 트랜잭션의 비율을 설정합니다. 명세서의 기간에 관계없이 각각의 새로운 거래에 적용됩니다. 샘플링은 확률 적입니다. 예를 들어 &lt;code&gt;0.1&lt;/code&gt; 은 주어진 트랜잭션이 기록 될 확률이 통계적으로 10 분의 1임을 의미합니다. &lt;code&gt;log_transaction_sample_rate&lt;/code&gt; 는 트랜잭션 샘플을 구성하는 데 도움이 될 수 있습니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 이며 추가 트랜잭션의 명령문을 기록하지 않음을 의미합니다. &lt;code&gt;1&lt;/code&gt; 로 설정하면 모든 트랜잭션의 모든 문이 기록됩니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9bd0c99ab221f4b5cce5fa4dcdbdf55e4b30001" translate="yes" xml:space="preserve">
          <source>Sets the header drawing style for the &lt;code&gt;unicode&lt;/code&gt; line style to one of &lt;code&gt;single&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 선 스타일 의 헤더 그리기 스타일을 &lt;code&gt;single&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="61676b650256c9e48818ba185a4d7c07cedcd9dd" translate="yes" xml:space="preserve">
          <source>Sets the internal seed for the random number generator (the function &lt;code&gt;random&lt;/code&gt;). Allowed values are floating-point numbers between -1 and 1, which are then multiplied by 2&lt;sup&gt;31&lt;/sup&gt;-1.</source>
          <target state="translated">난수 생성기의 내부 시드 ( &lt;code&gt;random&lt;/code&gt; 함수 )를 설정합니다. 허용되는 값은 -1과 1 사이의 부동 소수점 숫자이며 2 &lt;sup&gt;31&lt;/sup&gt; -1 을 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="647334bfd6eb7d1d85a2abc8c5d1eb68432c393b" translate="yes" xml:space="preserve">
          <source>Sets the label for the backup. If none is specified, a default value of &amp;ldquo;&lt;code&gt;pg_basebackup base backup&lt;/code&gt;&amp;rdquo; will be used.</source>
          <target state="translated">백업 레이블을 설정합니다. 아무 것도 지정하지 않으면 기본값&amp;ldquo; &lt;code&gt;pg_basebackup base backup&lt;/code&gt; &amp;rdquo;이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fca2623008438b82b0df89fa815664dd1ab59762" translate="yes" xml:space="preserve">
          <source>Sets the language in which messages are displayed. Acceptable values are system-dependent; see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; for more information. If this variable is set to the empty string (which is the default) then the value is inherited from the execution environment of the server in a system-dependent way.</source>
          <target state="translated">메시지가 표시되는 언어를 설정합니다. 허용되는 값은 시스템에 따라 다릅니다. 참조 &lt;a href=&quot;locale&quot;&gt;섹션 23.1을&lt;/a&gt; 자세한 내용은. 이 변수가 빈 문자열 (기본값)로 설정되면 값은 시스템에 따라 서버의 실행 환경에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="f86597cde9579a2959758f35faffc7076c2ece56" translate="yes" xml:space="preserve">
          <source>Sets the last 3 bytes of the address to zero. The remaining prefix can be associated with a particular manufacturer (using data not included in PostgreSQL).</source>
          <target state="translated">주소의 마지막 3 바이트를 0으로 설정합니다. 나머지 접두사는 특정 제조업체와 연결될 수 있습니다 (PostgreSQL에 포함되지 않은 데이터 사용).</target>
        </trans-unit>
        <trans-unit id="06a3127d0f56471d6c1295ebb849c5bc8a583fbf" translate="yes" xml:space="preserve">
          <source>Sets the last 5 bytes of the address to zero. The remaining prefix can be associated with a particular manufacturer (using data not included in PostgreSQL).</source>
          <target state="translated">주소의 마지막 5 바이트를 0으로 설정합니다. 나머지 접두사는 특정 제조업체와 연결될 수 있습니다 (PostgreSQL에 포함되지 않은 데이터 사용).</target>
        </trans-unit>
        <trans-unit id="5f58b8840f32cb51a47487307892919cbbf1ec7b" translate="yes" xml:space="preserve">
          <source>Sets the locale to use for formatting dates and times, for example with the &lt;code&gt;to_char&lt;/code&gt; family of functions. Acceptable values are system-dependent; see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; for more information. If this variable is set to the empty string (which is the default) then the value is inherited from the execution environment of the server in a system-dependent way.</source>
          <target state="translated">&lt;code&gt;to_char&lt;/code&gt; 계열 함수 와 같이 날짜 및 시간 형식에 사용할 로케일을 설정합니다 . 허용되는 값은 시스템에 따라 다릅니다. 참조 &lt;a href=&quot;locale&quot;&gt;섹션 23.1을&lt;/a&gt; 자세한 내용은. 이 변수가 빈 문자열 (기본값)로 설정되면 값은 시스템에 따라 서버의 실행 환경에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="36dc6691ab4feec6ef81633d17f3adde91e85fc9" translate="yes" xml:space="preserve">
          <source>Sets the locale to use for formatting monetary amounts, for example with the &lt;code&gt;to_char&lt;/code&gt; family of functions. Acceptable values are system-dependent; see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; for more information. If this variable is set to the empty string (which is the default) then the value is inherited from the execution environment of the server in a system-dependent way.</source>
          <target state="translated">통화량을 형식화하는 데 사용할 로케일을 설정합니다 (예 : &lt;code&gt;to_char&lt;/code&gt; 함수 계열). 허용되는 값은 시스템에 따라 다릅니다. 참조 &lt;a href=&quot;locale&quot;&gt;섹션 23.1을&lt;/a&gt; 자세한 내용은. 이 변수가 빈 문자열 (기본값)로 설정되면 값은 시스템에 따라 서버의 실행 환경에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f798489e929f8e1b573ab1fae913b9e3237244" translate="yes" xml:space="preserve">
          <source>Sets the locale to use for formatting numbers, for example with the &lt;code&gt;to_char&lt;/code&gt; family of functions. Acceptable values are system-dependent; see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; for more information. If this variable is set to the empty string (which is the default) then the value is inherited from the execution environment of the server in a system-dependent way.</source>
          <target state="translated">&lt;code&gt;to_char&lt;/code&gt; 계열 함수 와 같이 숫자 서식에 사용할 로캘을 설정합니다 . 허용되는 값은 시스템에 따라 다릅니다. 참조 &lt;a href=&quot;locale&quot;&gt;섹션 23.1을&lt;/a&gt; 자세한 내용은. 이 변수가 빈 문자열 (기본값)로 설정되면 값은 시스템에 따라 서버의 실행 환경에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="2888edc2876a08d9cef6033805ad6d16c80fdc37" translate="yes" xml:space="preserve">
          <source>Sets the location of the Kerberos server key file. See &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Kerberos 서버 키 파일의 위치를 ​​설정합니다. 자세한 내용 &lt;a href=&quot;gssapi-auth&quot;&gt;은 20.6 절&lt;/a&gt; 을 참조하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b10f255fd2eee6dc0fc02af3d1fe3c233206e1f5" translate="yes" xml:space="preserve">
          <source>Sets the maximum SSL/TLS protocol version to use. Valid values are as for &lt;a href=&quot;runtime-config-connection#GUC-SSL-MIN-PROTOCOL-VERSION&quot;&gt;ssl_min_protocol_version&lt;/a&gt;, with addition of an empty string, which allows any protocol version. The default is to allow any version. Setting the maximum protocol version is mainly useful for testing or if some component has issues working with a newer protocol.</source>
          <target state="translated">사용할 최대 SSL / TLS 프로토콜 버전을 설정합니다. 유효한 값은 &lt;a href=&quot;runtime-config-connection#GUC-SSL-MIN-PROTOCOL-VERSION&quot;&gt;ssl_min_protocol_version&lt;/a&gt; 과 같 으며 빈 문자열이 추가되어 모든 프로토콜 버전이 허용됩니다. 기본값은 모든 버전을 허용하는 것입니다. 최대 프로토콜 버전을 설정하면 테스트 또는 일부 구성 요소에 최신 프로토콜 작업에 문제가있는 경우 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="09e9a95788728bb2c52e5c5666264c555f3b58da" translate="yes" xml:space="preserve">
          <source>Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files. If this value is specified without units, it is taken as kilobytes. The default value is four megabytes (&lt;code&gt;4MB&lt;/code&gt;). Note that for a complex query, several sort or hash operations might be running in parallel; each operation will be allowed to use as much memory as this value specifies before it starts to write data into temporary files. Also, several running sessions could be doing such operations concurrently. Therefore, the total memory used could be many times the value of &lt;code&gt;work_mem&lt;/code&gt;; it is necessary to keep this fact in mind when choosing the value. Sort operations are used for &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, and merge joins. Hash tables are used in hash joins, hash-based aggregation, and hash-based processing of &lt;code&gt;IN&lt;/code&gt; subqueries.</source>
          <target state="translated">임시 디스크 파일에 쓰기 전에 쿼리 작업 (예 : 정렬 또는 해시 테이블)에서 사용할 최대 메모리 양을 설정합니다. 이 값을 단위없이 지정하면 킬로바이트로 간주됩니다. 기본값은 &lt;code&gt;4MB&lt;/code&gt; ( 4MB )입니다. 복잡한 쿼리의 경우 여러 정렬 또는 해시 작업이 병렬로 실행될 수 있습니다. 각 작업은 데이터를 임시 파일에 쓰기 시작하기 전에이 값이 지정한만큼의 메모리를 사용할 수 있습니다. 또한 여러 실행 세션이 동시에 이러한 작업을 수행 할 수 있습니다. 따라서 사용 된 총 메모리는 &lt;code&gt;work_mem&lt;/code&gt; 값의 몇 배가 될 수 있습니다 . 값을 선택할 때이 사실을 명심해야합니다. 정렬 조작은 &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;DISTINCT&lt;/code&gt; 에 사용됩니다.및 결합 조인. 해시 테이블은 해시 조인, 해시 기반 집계 및 &lt;code&gt;IN&lt;/code&gt; 하위 쿼리 의 해시 기반 처리에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf7df0bb598dbc5d886a0bfa616392c0f6b9e9dc" translate="yes" xml:space="preserve">
          <source>Sets the maximum amount of memory used for temporary buffers within each database session. These are session-local buffers used only for access to temporary tables. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The default is eight megabytes (&lt;code&gt;8MB&lt;/code&gt;). (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default value scales proportionally to it.) This setting can be changed within individual sessions, but only before the first use of temporary tables within the session; subsequent attempts to change the value will have no effect on that session.</source>
          <target state="translated">각 데이터베이스 세션 내에서 임시 버퍼에 사용되는 최대 메모리 양을 설정합니다. 이들은 임시 테이블에 액세스 할 때만 사용되는 세션 로컬 버퍼입니다. 이 값을 단위없이 지정하면 블록으로, 즉 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트 (일반적으로 8kB)로 사용됩니다. 기본값은 &lt;code&gt;8MB&lt;/code&gt; 입니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8kB가 아닌 경우 기본값 은 이에 비례하여 조정됩니다.)이 설정은 개별 세션 내에서 변경할 수 있지만 세션 내에서 임시 테이블을 처음 사용하기 전에 만 가능합니다. 이후의 값 변경 시도는 해당 세션에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b238dcae0530019aa71ba04893255065ce2a75eb" translate="yes" xml:space="preserve">
          <source>Sets the maximum number of background processes that the system can support. This parameter can only be set at server start. The default is 8.</source>
          <target state="translated">시스템이 지원할 수있는 최대 백그라운드 프로세스 수를 설정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 기본값은 8입니다.</target>
        </trans-unit>
        <trans-unit id="cc86721860c86c00054caddc811c14f4bec785c4" translate="yes" xml:space="preserve">
          <source>Sets the maximum number of client connections that this server will accept. The default value of this parameter is chosen automatically by initdb. Specifying this option is equivalent to setting the &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; configuration parameter.</source>
          <target state="translated">이 서버가 허용 할 최대 클라이언트 연결 수를 설정합니다. 이 매개 변수의 기본값은 initdb에 의해 자동으로 선택됩니다. 이 옵션을 지정하는 것은 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; 구성 매개 변수 를 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="debab47e934ebb882a2dcd5b3e8d15b9861eabec" translate="yes" xml:space="preserve">
          <source>Sets the maximum number of parallel workers that can be started by a single utility command. Currently, the only parallel utility command that supports the use of parallel workers is &lt;code&gt;CREATE INDEX&lt;/code&gt;, and only when building a B-tree index. Parallel workers are taken from the pool of processes established by &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;, limited by &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;. Note that the requested number of workers may not actually be available at run time. If this occurs, the utility operation will run with fewer workers than expected. The default value is 2. Setting this value to 0 disables the use of parallel workers by utility commands.</source>
          <target state="translated">단일 유틸리티 명령으로 시작할 수있는 최대 병렬 작업자 수를 설정합니다. 현재 병렬 작업자 사용을 지원하는 유일한 병렬 유틸리티 명령은 &lt;code&gt;CREATE INDEX&lt;/code&gt; 이며 B- 트리 인덱스를 빌드 할 때만 가능합니다. &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers에&lt;/a&gt; 의해 제한되는 &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; 에 의해 설정된 프로세스 풀에서 병렬 작업자를 가져 옵니다 . 요청 된 작업자 수는 실제로 런타임에 사용 가능하지 않을 수 있습니다. 이 경우 유틸리티 작업이 예상보다 적은 작업자로 실행됩니다. 기본값은 2입니다.이 값을 0으로 설정하면 유틸리티 명령으로 병렬 작업자를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebc72db6ddf51a02b2afcc0b69ec56c9bd22586d" translate="yes" xml:space="preserve">
          <source>Sets the maximum number of parallel workers that can be started by a single utility command. Currently, the parallel utility commands that support the use of parallel workers are &lt;code&gt;CREATE INDEX&lt;/code&gt; only when building a B-tree index, and &lt;code&gt;VACUUM&lt;/code&gt; without &lt;code&gt;FULL&lt;/code&gt; option. Parallel workers are taken from the pool of processes established by &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;, limited by &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;. Note that the requested number of workers may not actually be available at run time. If this occurs, the utility operation will run with fewer workers than expected. The default value is 2. Setting this value to 0 disables the use of parallel workers by utility commands.</source>
          <target state="translated">단일 유틸리티 명령으로 시작할 수있는 최대 병렬 작업자 수를 설정합니다. 현재 병렬 워커 사용을 지원하는 병렬 유틸리티 명령 은 B-tree 인덱스를 구축 할 때만 &lt;code&gt;CREATE INDEX&lt;/code&gt; 이고 &lt;code&gt;FULL&lt;/code&gt; 옵션이 없는 &lt;code&gt;VACUUM&lt;/code&gt; 입니다. 병렬 작업자는 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers로&lt;/a&gt; 제한되는 &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; 에 의해 설정된 프로세스 풀에서 가져 옵니다 . 요청 된 작업자 수는 실제로 런타임에 사용 가능하지 않을 수 있습니다. 이 경우 유틸리티 작업은 예상보다 적은 수의 작업자로 실행됩니다. 기본값은 2입니다.이 값을 0으로 설정하면 유틸리티 명령에서 병렬 작업자를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af96d1a1eaf1d9c2283b575d813d2dc98425a564" translate="yes" xml:space="preserve">
          <source>Sets the maximum number of simultaneously open files allowed to each server subprocess. The default is one thousand files. If the kernel is enforcing a safe per-process limit, you don't need to worry about this setting. But on some platforms (notably, most BSD systems), the kernel will allow individual processes to open many more files than the system can actually support if many processes all try to open that many files. If you find yourself seeing &amp;ldquo;Too many open files&amp;rdquo; failures, try reducing this setting. This parameter can only be set at server start.</source>
          <target state="translated">각 서버 서브 프로세스에 허용되는 동시에 열린 파일의 최대 수를 설정합니다. 기본값은 1,000 개의 파일입니다. 커널이 안전한 프로세스 별 제한을 적용하는 경우이 설정에 대해 걱정할 필요가 없습니다. 그러나 일부 플랫폼 (특히 대부분의 BSD 시스템)에서 커널은 많은 프로세스가 모두 그 많은 파일을 열려고 시도하는 경우 시스템이 실제로 지원할 수있는 것보다 개별 프로세스가 더 많은 파일을 열도록 허용합니다. &quot;너무 많은 열린 파일&quot;오류가 발생하면이 설정을 줄이십시오. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="025e061fa08a60d41ce046d952f0b4c07bca9418" translate="yes" xml:space="preserve">
          <source>Sets the maximum number of transactions that can be in the &amp;ldquo;prepared&amp;rdquo; state simultaneously (see &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;). Setting this parameter to zero (which is the default) disables the prepared-transaction feature. This parameter can only be set at server start.</source>
          <target state="translated">&quot;준비된&quot;상태에 동시에있을 수있는 최대 트랜잭션 수를 설정합니다 ( &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREFARE TRANSACTION&lt;/a&gt; 참조 ). 이 매개 변수를 0 (기본값)으로 설정하면 준비된 트랜잭션 기능이 비활성화됩니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fa1dc4040c19ad52dfaf5872a4b49622cd52f7c" translate="yes" xml:space="preserve">
          <source>Sets the maximum number of workers that can be started by a single &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node. Parallel workers are taken from the pool of processes established by &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;, limited by &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;. Note that the requested number of workers may not actually be available at run time. If this occurs, the plan will run with fewer workers than expected, which may be inefficient. The default value is 2. Setting this value to 0 disables parallel query execution.</source>
          <target state="translated">단일 &lt;code&gt;Gather&lt;/code&gt; 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 노드에서 시작할 수있는 최대 작업자 수를 설정 합니다. &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers에&lt;/a&gt; 의해 제한되는 &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; 에 의해 설정된 프로세스 풀에서 병렬 작업자를 가져 옵니다 . 요청 된 작업자 수는 실제로 런타임에 사용 가능하지 않을 수 있습니다. 이 경우 계획이 예상보다 적은 인력으로 실행되므로 비효율적 일 수 있습니다. 기본값은 2입니다.이 값을 0으로 설정하면 병렬 쿼리 실행이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="155702d6d50f2cff0b9a4dfa528f017610f80f8c" translate="yes" xml:space="preserve">
          <source>Sets the maximum number of workers that the system can support for parallel operations. The default value is 8. When increasing or decreasing this value, consider also adjusting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;. Also, note that a setting for this value which is higher than &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; will have no effect, since parallel workers are taken from the pool of worker processes established by that setting.</source>
          <target state="translated">시스템이 병렬 작업을 지원할 수있는 최대 작업자 수를 설정합니다. 기본값은 8입니다.이 값을 늘리거나 줄일 때 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; 조정도 고려 하십시오 . 또한 &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt; 보다 높은이 값의 설정은 영향을 미치지 않습니다. 병렬 작업자는 해당 설정에 의해 설정된 작업자 프로세스 풀에서 가져 오기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fb8251d8b842feccb9f6584d9b39c67f02c7e6ac" translate="yes" xml:space="preserve">
          <source>Sets the maximum size of a GIN index's pending list, which is used when &lt;code&gt;fastupdate&lt;/code&gt; is enabled. If the list grows larger than this maximum size, it is cleaned up by moving the entries in it to the index's main GIN data structure in bulk. If this value is specified without units, it is taken as kilobytes. The default is four megabytes (&lt;code&gt;4MB&lt;/code&gt;). This setting can be overridden for individual GIN indexes by changing index storage parameters. See &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; and &lt;a href=&quot;gin-tips&quot;&gt;Section 66.5&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;fastupdate&lt;/code&gt; 가 활성화 될 때 사용되는 GIN 인덱스 보류 목록의 최대 크기를 설정합니다 . 목록이이 최대 크기보다 커지면 목록의 항목을 인덱스의 기본 GIN 데이터 구조로 대량으로 이동하여 정리합니다. 이 값을 단위없이 지정하면 킬로바이트로 간주됩니다. 기본값은 &lt;code&gt;4MB&lt;/code&gt; 입니다 ( 4MB ). 인덱스 스토리지 매개 변수를 변경하여 개별 GIN 인덱스에 대해이 설정을 대체 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;섹션 66.4.1&lt;/a&gt; 및 &lt;a href=&quot;gin-tips&quot;&gt;섹션 66.5&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1d6a43e3c3e8c92b3d039b82cb3d62192d2abba" translate="yes" xml:space="preserve">
          <source>Sets the maximum transfer rate at which data is collected from the source server. This can be useful to limit the impact of pg_basebackup on the server. Values are in kilobytes per second. Use a suffix of &lt;code&gt;M&lt;/code&gt; to indicate megabytes per second. A suffix of &lt;code&gt;k&lt;/code&gt; is also accepted, and has no effect. Valid values are between 32 kilobytes per second and 1024 megabytes per second.</source>
          <target state="translated">원본 서버에서 데이터를 수집하는 최대 전송 속도를 설정합니다. 이것은 pg_basebackup이 서버에 미치는 영향을 제한하는 데 유용 할 수 있습니다. 값은 초당 킬로바이트입니다. 초당 메가 바이트를 표시 하려면 접미사 &lt;code&gt;M&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;k&lt;/code&gt; 접미사 도 허용되며 효과가 없습니다. 유효한 값은 초당 32KB에서 초당 1024MB 사이입니다.</target>
        </trans-unit>
        <trans-unit id="fef49339de480b7d24f8a4f307af2d786eb4a359" translate="yes" xml:space="preserve">
          <source>Sets the minimum SSL/TLS protocol version to use. Valid values are currently: &lt;code&gt;TLSv1&lt;/code&gt;, &lt;code&gt;TLSv1.1&lt;/code&gt;, &lt;code&gt;TLSv1.2&lt;/code&gt;, &lt;code&gt;TLSv1.3&lt;/code&gt;. Older versions of the OpenSSL library do not support all values; an error will be raised if an unsupported setting is chosen. Protocol versions before TLS 1.0, namely SSL version 2 and 3, are always disabled.</source>
          <target state="translated">사용할 최소 SSL / TLS 프로토콜 버전을 설정합니다. 유효한 값은 현재 : &lt;code&gt;TLSv1&lt;/code&gt; 의 , &lt;code&gt;TLSv1.1&lt;/code&gt; , &lt;code&gt;TLSv1.2&lt;/code&gt; , &lt;code&gt;TLSv1.3&lt;/code&gt; . 이전 버전의 OpenSSL 라이브러리는 모든 값을 지원하지는 않습니다. 지원되지 않는 설정을 선택하면 오류가 발생합니다. TLS 1.0 이전의 프로토콜 버전, 즉 SSL 버전 2 및 3은 항상 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f97ae0260e3c3fd55b1ee24f2c37bb1286524f6" translate="yes" xml:space="preserve">
          <source>Sets the minimum amount of index data that must be scanned in order for a parallel scan to be considered. Note that a parallel index scan typically won't touch the entire index; it is the number of pages which the planner believes will actually be touched by the scan which is relevant. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The default is 512 kilobytes (&lt;code&gt;512kB&lt;/code&gt;).</source>
          <target state="translated">병렬 스캔을 고려하기 위해 스캔해야하는 최소 인덱스 데이터 양을 설정합니다. 병렬 인덱스 스캔은 일반적으로 전체 인덱스를 건드리지 않습니다. 플래너가 실제로 관련 스캔에 의해 터치 될 것이라고 믿는 페이지 수입니다. 이 값을 단위없이 지정하면 블록으로, 즉 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트 (일반적으로 8kB)로 사용됩니다. 기본값은 512 킬로바이트 ( &lt;code&gt;512kB&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="32c98525d6098c003eb4a9dd67f38b718bc8f296" translate="yes" xml:space="preserve">
          <source>Sets the minimum amount of index data that must be scanned in order for a parallel scan to be considered. Note that a parallel index scan typically won't touch the entire index; it is the number of pages which the planner believes will actually be touched by the scan which is relevant. This parameter is also used to decide whether a particular index can participate in a parallel vacuum. See &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The default is 512 kilobytes (&lt;code&gt;512kB&lt;/code&gt;).</source>
          <target state="translated">병렬 스캔을 고려하기 위해 스캔해야하는 인덱스 데이터의 최소량을 설정합니다. 병렬 인덱스 스캔은 일반적으로 전체 인덱스를 건드리지 않습니다. 플래너가 실제로 관련된 스캔에 의해 터치 될 것이라고 생각하는 페이지 수입니다. 이 매개 변수는 특정 인덱스가 병렬 진공에 참여할 수 있는지 여부를 결정하는데도 사용됩니다. &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM을&lt;/a&gt; 참조 하십시오 . 이 값이 단위없이 지정되면 블록, 즉 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트 (일반적으로 8kB )로 간주 됩니다. 기본값은 512KB ( &lt;code&gt;512kB&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0e775314fe6483204313c3388bb03f121406fcfa" translate="yes" xml:space="preserve">
          <source>Sets the minimum amount of table data that must be scanned in order for a parallel scan to be considered. For a parallel sequential scan, the amount of table data scanned is always equal to the size of the table, but when indexes are used the amount of table data scanned will normally be less. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The default is 8 megabytes (&lt;code&gt;8MB&lt;/code&gt;).</source>
          <target state="translated">병렬 스캔을 고려하기 위해 스캔해야하는 최소 테이블 데이터 양을 설정합니다. 병렬 순차 스캔의 경우 스캔 된 테이블 데이터의 양은 항상 테이블 크기와 동일하지만 인덱스를 사용하는 경우 스캔 된 테이블 데이터의 양은 일반적으로 적습니다. 이 값을 단위없이 지정하면 블록으로, 즉 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트 (일반적으로 8kB)로 사용됩니다. 기본값은 &lt;code&gt;8MB&lt;/code&gt; 입니다 ( 8MB ).</target>
        </trans-unit>
        <trans-unit id="f505daff682e43751f274409c725e39b2063304a" translate="yes" xml:space="preserve">
          <source>Sets the minimum amount of time that a query snapshot can be used without risk of a &amp;ldquo;snapshot too old&amp;rdquo; error occurring when using the snapshot. Data that has been dead for longer than this threshold is allowed to be vacuumed away. This can help prevent bloat in the face of snapshots which remain in use for a long time. To prevent incorrect results due to cleanup of data which would otherwise be visible to the snapshot, an error is generated when the snapshot is older than this threshold and the snapshot is used to read a page which has been modified since the snapshot was built.</source>
          <target state="translated">스냅 샷을 사용할 때 &quot;스냅 샷이 너무 오래되었습니다&quot;오류가 발생하지 않고 쿼리 스냅 샷을 사용할 수있는 최소 시간을 설정합니다. 이 임계 값보다 오래 죽은 데이터는 진공 제거 할 수 있습니다. 이렇게하면 오랫동안 사용중인 스냅 샷이 부풀어 오르는 것을 방지 할 수 있습니다. 스냅 샷에 표시 될 수있는 데이터 정리로 인한 잘못된 결과를 방지하기 위해 스냅 샷이이 임계 값보다 오래된 경우 스냅 샷이 생성되고 스냅 샷은 스냅 샷이 작성된 이후 수정 된 페이지를 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bb19a4d9023d7705a87b231272d43c96a26a1699" translate="yes" xml:space="preserve">
          <source>Sets the netmask length for a &lt;code&gt;cidr&lt;/code&gt; value. Address bits to the right of the new netmask are set to zero.</source>
          <target state="translated">&lt;code&gt;cidr&lt;/code&gt; 값 의 넷 마스크 길이를 설정합니다 . 새 넷 마스크 오른쪽의 주소 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="68aa0959ab31ab1e40ccf017b07d5752565ef748" translate="yes" xml:space="preserve">
          <source>Sets the netmask length for an &lt;code&gt;inet&lt;/code&gt; value. The address part does not change.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 값 의 넷 마스크 길이를 설정합니다 . 주소 부분은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="639d71177255894af48e7cc59b6237adb1a67d10" translate="yes" xml:space="preserve">
          <source>Sets the number of concurrent disk I/O operations that PostgreSQL expects can be executed simultaneously. Raising this value will increase the number of I/O operations that any individual PostgreSQL session attempts to initiate in parallel. The allowed range is 1 to 1000, or zero to disable issuance of asynchronous I/O requests. Currently, this setting only affects bitmap heap scans.</source>
          <target state="translated">PostgreSQL이 동시에 실행할 수있을 것으로 예상되는 동시 디스크 I / O 작업 수를 설정합니다. 이 값을 올리면 개별 PostgreSQL 세션이 동시에 시작하려고하는 I / O 작업 수가 증가합니다. 허용되는 범위는 1-1000이거나 비동기 I / O 요청의 발행을 비활성화하려면 0입니다. 현재이 설정은 비트 맵 힙 스캔에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="a8a4b8635581c10272ed56e26835a20b76551d62" translate="yes" xml:space="preserve">
          <source>Sets the number of shared buffers for use by the server processes. The default value of this parameter is chosen automatically by initdb. Specifying this option is equivalent to setting the &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; configuration parameter.</source>
          <target state="translated">서버 프로세스에서 사용할 공유 버퍼 수를 설정합니다. 이 매개 변수의 기본값은 initdb에 의해 자동으로 선택됩니다. 이 옵션을 지정하는 것은 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 구성 매개 변수 를 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f522a397d47fccbd22581cdfc6bb6d4f77232d4d" translate="yes" xml:space="preserve">
          <source>Sets the output format for values of type &lt;code&gt;bytea&lt;/code&gt;. Valid values are &lt;code&gt;hex&lt;/code&gt; (the default) and &lt;code&gt;escape&lt;/code&gt; (the traditional PostgreSQL format). See &lt;a href=&quot;datatype-binary&quot;&gt;Section 8.4&lt;/a&gt; for more information. The &lt;code&gt;bytea&lt;/code&gt; type always accepts both formats on input, regardless of this setting.</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 유형의 값에 대한 출력 형식을 설정합니다 . 유효한 값은 &lt;code&gt;hex&lt;/code&gt; (기본값) 및 &lt;code&gt;escape&lt;/code&gt; (일반 PostgreSQL 형식)입니다. 자세한 정보는 &lt;a href=&quot;datatype-binary&quot;&gt;8.4 절&lt;/a&gt; 을 참조하십시오. &lt;code&gt;bytea&lt;/code&gt; 와의 종류에 관계없이 항상이 설정의 입력에 두 형식을 모두 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="49dd5aeef046daa87cfb1678f36acfad50707ec8" translate="yes" xml:space="preserve">
          <source>Sets the output format to one of &lt;code&gt;aligned&lt;/code&gt;, &lt;code&gt;asciidoc&lt;/code&gt;, &lt;code&gt;csv&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;latex&lt;/code&gt;, &lt;code&gt;latex-longtable&lt;/code&gt;, &lt;code&gt;troff-ms&lt;/code&gt;, &lt;code&gt;unaligned&lt;/code&gt;, or &lt;code&gt;wrapped&lt;/code&gt;. Unique abbreviations are allowed.</source>
          <target state="translated">출력 형식을 &lt;code&gt;aligned&lt;/code&gt; , &lt;code&gt;asciidoc&lt;/code&gt; , &lt;code&gt;csv&lt;/code&gt; , &lt;code&gt;html&lt;/code&gt; , &lt;code&gt;latex&lt;/code&gt; , &lt;code&gt;latex-longtable&lt;/code&gt; , &lt;code&gt;troff-ms&lt;/code&gt; , &lt;code&gt;unaligned&lt;/code&gt; 또는 &lt;code&gt;wrapped&lt;/code&gt; 중 하나로 설정합니다 . 고유 한 약어가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="678f9ce990e8b695092b47c67490b2121aa837bd" translate="yes" xml:space="preserve">
          <source>Sets the owning group of the Unix-domain socket(s). (The owning user of the sockets is always the user that starts the server.) In combination with the parameter &lt;code&gt;unix_socket_permissions&lt;/code&gt; this can be used as an additional access control mechanism for Unix-domain connections. By default this is the empty string, which uses the default group of the server user. This parameter can only be set at server start.</source>
          <target state="translated">유닉스 도메인 소켓의 소유 그룹을 설정합니다. 소켓의 소유 사용자는 항상 서버를 시작하는 사용자입니다. &lt;code&gt;unix_socket_permissions&lt;/code&gt; 매개 변수와 함께 이것은 Unix 도메인 연결을위한 추가 액세스 제어 메커니즘으로 사용될 수 있습니다. 기본적으로 이것은 빈 문자열이며 서버 사용자의 기본 그룹을 사용합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb48054c7e6e200ecafdfce7ec02b9c8cb3a455" translate="yes" xml:space="preserve">
          <source>Sets the parameter &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;new_value&lt;/code&gt;&lt;/em&gt;, and returns that value. If &lt;em&gt;&lt;code&gt;is_local&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;, the new value will only apply for the current transaction. If you want the new value to apply for the current session, use &lt;code&gt;false&lt;/code&gt; instead. This function corresponds to the SQL command &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">parameter &lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; &lt;/em&gt; 을 &lt;em&gt; &lt;code&gt;new_value&lt;/code&gt; 로&lt;/em&gt; 설정하고 해당 값을 반환합니다. 경우 &lt;em&gt; &lt;code&gt;is_local&lt;/code&gt; 가&lt;/em&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 새로운 값은 현재 트랜잭션에 대해 적용됩니다. 새 값을 현재 세션에 적용하려면 대신 &lt;code&gt;false&lt;/code&gt; 를 사용하십시오. 이 함수는 SQL 명령 &lt;code&gt;SET&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="eade538eea18ba5eb439351980c9800215ed5677" translate="yes" xml:space="preserve">
          <source>Sets the planner's assumption about the effective size of the disk cache that is available to a single query. This is factored into estimates of the cost of using an index; a higher value makes it more likely index scans will be used, a lower value makes it more likely sequential scans will be used. When setting this parameter you should consider both PostgreSQL's shared buffers and the portion of the kernel's disk cache that will be used for PostgreSQL data files, though some data might exist in both places. Also, take into account the expected number of concurrent queries on different tables, since they will have to share the available space. This parameter has no effect on the size of shared memory allocated by PostgreSQL, nor does it reserve kernel disk cache; it is used only for estimation purposes. The system also does not assume data remains in the disk cache between queries. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The default is 4 gigabytes (&lt;code&gt;4GB&lt;/code&gt;). (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default value scales proportionally to it.)</source>
          <target state="translated">단일 쿼리에 사용 가능한 디스크 캐시의 유효 크기에 대한 플래너의 가정을 설정합니다. 이는 지수 사용 비용의 추정치에 반영됩니다. 값이 클수록 인덱스 스캔이 사용될 가능성이 높아지고 값이 작을수록 순차적 스캔이 사용될 가능성이 높아집니다. 이 매개 변수를 설정할 때는 일부 데이터가 두 곳에 존재할 수 있지만 PostgreSQL의 공유 버퍼와 PostgreSQL 데이터 파일에 사용될 커널 디스크 캐시 부분을 모두 고려해야합니다. 또한 사용 가능한 공간을 공유해야하므로 서로 다른 테이블에서 예상되는 동시 쿼리 수를 고려하십시오. 이 매개 변수는 PostgreSQL에서 할당 한 공유 메모리의 크기에는 영향을 미치지 않으며 커널 디스크 캐시도 예약하지 않습니다. 추정 목적으로 만 사용됩니다.또한 시스템은 쿼리간에 디스크 캐시에 데이터가 남아 있다고 가정하지 않습니다. 이 값을 단위없이 지정하면 블록으로 간주됩니다. &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트 (일반적으로 8kB) 기본값은 &lt;code&gt;4GB&lt;/code&gt; 입니다. ( &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8kB가 아닌 경우 기본값 은 이에 비례하여 조정됩니다.)</target>
        </trans-unit>
        <trans-unit id="215bba23753ba431ea9d47a1344bfbb484f42418" translate="yes" xml:space="preserve">
          <source>Sets the planner's estimate of the cost of a disk page fetch that is part of a series of sequential fetches. The default is 1.0. This value can be overridden for tables and indexes in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="translated">일련의 순차적 페치의 일부인 디스크 페이지 페치 비용에 대한 플래너의 추정치를 설정합니다. 기본값은 1.0입니다. 동일한 이름의 테이블 스페이스 매개 변수를 설정하여 특정 테이블 스페이스의 테이블 및 인덱스에 대해이 값을 대체 할 수 있습니다 ( &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f06fe60b01aef7c49d720f83144298118281440b" translate="yes" xml:space="preserve">
          <source>Sets the planner's estimate of the cost of a non-sequentially-fetched disk page. The default is 4.0. This value can be overridden for tables and indexes in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="translated">순차적으로 페치되지 않은 디스크 페이지 비용의 플래너 추정값을 설정합니다. 기본값은 4.0입니다. 동일한 이름의 테이블 스페이스 매개 변수를 설정하여 특정 테이블 스페이스의 테이블 및 인덱스에 대해이 값을 대체 할 수 있습니다 ( &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1ff883f52213020414cafe7fe8a8e6096a2e5d5d" translate="yes" xml:space="preserve">
          <source>Sets the planner's estimate of the cost of launching parallel worker processes. The default is 1000.</source>
          <target state="translated">병렬 작업자 프로세스 시작 비용에 대한 플래너의 예상 비용을 설정합니다. 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="66e5badbac5fd1bbd7672e6dd40f7f2b48faf215" translate="yes" xml:space="preserve">
          <source>Sets the planner's estimate of the cost of processing each index entry during an index scan. The default is 0.005.</source>
          <target state="translated">인덱스 스캔 중에 각 인덱스 항목을 처리하는 비용에 대한 플래너의 추정치를 설정합니다. 기본값은 0.005입니다.</target>
        </trans-unit>
        <trans-unit id="01cc41364b70160c8f70e1cc9440a01907623c28" translate="yes" xml:space="preserve">
          <source>Sets the planner's estimate of the cost of processing each operator or function executed during a query. The default is 0.0025.</source>
          <target state="translated">쿼리 중에 실행 된 각 연산자 또는 함수 처리 비용의 플래너 추정값을 설정합니다. 기본값은 0.0025입니다.</target>
        </trans-unit>
        <trans-unit id="441825be2111d888c818bbe5ef23b877ca2dd83f" translate="yes" xml:space="preserve">
          <source>Sets the planner's estimate of the cost of processing each row during a query. The default is 0.01.</source>
          <target state="translated">쿼리 중에 각 행을 처리하는 비용에 대한 플래너의 추정치를 설정합니다. 기본값은 0.01입니다.</target>
        </trans-unit>
        <trans-unit id="430e7f5d6b274bc96b06ad9a3e320e52dfe7ab39" translate="yes" xml:space="preserve">
          <source>Sets the planner's estimate of the cost of transferring one tuple from a parallel worker process to another process. The default is 0.1.</source>
          <target state="translated">하나의 튜플을 병렬 작업자 프로세스에서 다른 프로세스로 전송하는 비용에 대한 플래너의 추정치를 설정합니다. 기본값은 0.1입니다.</target>
        </trans-unit>
        <trans-unit id="75e961f550770321a47a55eee42c87dc47d89649" translate="yes" xml:space="preserve">
          <source>Sets the planner's estimate of the fraction of a cursor's rows that will be retrieved. The default is 0.1. Smaller values of this setting bias the planner towards using &amp;ldquo;fast start&amp;rdquo; plans for cursors, which will retrieve the first few rows quickly while perhaps taking a long time to fetch all rows. Larger values put more emphasis on the total estimated time. At the maximum setting of 1.0, cursors are planned exactly like regular queries, considering only the total estimated time and not how soon the first rows might be delivered.</source>
          <target state="translated">검색 될 커서 행의 비율에 대한 플래너의 추정치를 설정합니다. 기본값은 0.1입니다. 이 설정 값이 작을수록 플래너는 커서에 대해 &quot;빠른 시작&quot;계획을 사용하도록 편향시킵니다. 커서는 처음 몇 행을 빠르게 검색하는 데 시간이 오래 걸리고 모든 행을 가져 오는 데 시간이 오래 걸립니다. 값이 클수록 총 예상 시간이 더 강조됩니다. 1.0의 최대 설정에서 커서는 총 예상 시간 만 고려하고 첫 번째 행이 얼마나 빨리 전달되는지를 고려하지 않고 일반 쿼리와 정확히 동일하게 계획됩니다.</target>
        </trans-unit>
        <trans-unit id="b74cc7eea094402f1d8f572b15430c9a3f23366e" translate="yes" xml:space="preserve">
          <source>Sets the psql variable &lt;code&gt;name&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, or if more than one value is given, to the concatenation of all of them. If only one argument is given, the variable is set to an empty-string value. To unset a variable, use the &lt;code&gt;\unset&lt;/code&gt; command.</source>
          <target state="translated">psql 변수 &lt;code&gt;name&lt;/code&gt; 을 &lt;code&gt;value&lt;/code&gt; 로 설정하거나 둘 이상의 값이 제공되면 모든 변수 를 연결합니다. 인수가 하나만 주어지면 변수는 빈 문자열 값으로 설정됩니다. 변수를 설정 해제하려면 &lt;code&gt;\unset&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3cc427ac8e9c4b356d6e649d2678371c55621cd" translate="yes" xml:space="preserve">
          <source>Sets the query cost above which JIT compilation applies expensive optimizations. Such optimization adds planning time, but can improve execution speed. It is not meaningful to set this to less than &lt;code&gt;jit_above_cost&lt;/code&gt;, and it is unlikely to be beneficial to set it to more than &lt;code&gt;jit_inline_above_cost&lt;/code&gt;. Setting this to &lt;code&gt;-1&lt;/code&gt; disables expensive optimizations. The default is &lt;code&gt;500000&lt;/code&gt;.</source>
          <target state="translated">JIT 컴파일이 비싼 최적화를 적용하는 것보다 높은 쿼리 비용을 설정합니다. 이러한 최적화는 계획 시간을 추가하지만 실행 속도를 향상시킬 수 있습니다. 이하로 설정하는 것이 의미가 없습니다 &lt;code&gt;jit_above_cost&lt;/code&gt; ,보다 더 많은을 설정하는 것이 도움이 될 가능성이있다 &lt;code&gt;jit_inline_above_cost&lt;/code&gt; . 이 값을 &lt;code&gt;-1&lt;/code&gt; 로 설정 하면 값 비싼 최적화가 비활성화됩니다. 기본값은 &lt;code&gt;500000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac2dd9f4841a542f63ff04be55fe948629592e5a" translate="yes" xml:space="preserve">
          <source>Sets the query cost above which JIT compilation attempts to inline functions and operators. Inlining adds planning time, but can improve execution speed. It is not meaningful to set this to less than &lt;code&gt;jit_above_cost&lt;/code&gt;. Setting this to &lt;code&gt;-1&lt;/code&gt; disables inlining. The default is &lt;code&gt;500000&lt;/code&gt;.</source>
          <target state="translated">JIT 컴파일이 함수 및 연산자를 인라인하려고 시도하는 쿼리 비용을 설정합니다. 인라인은 계획 시간을 추가하지만 실행 속도를 향상시킬 수 있습니다. 이것을 &lt;code&gt;jit_above_cost&lt;/code&gt; 보다 작게 설정하는 것은 의미가 없습니다 . 이것을 &lt;code&gt;-1&lt;/code&gt; 로 설정 하면 인라인 이 비활성화됩니다. 기본값은 &lt;code&gt;500000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="02063082bcb76821ede05005f821c8cf0e62cee9" translate="yes" xml:space="preserve">
          <source>Sets the query cost above which JIT compilation is activated, if enabled (see &lt;a href=&quot;https://www.postgresql.org/docs/12/jit.html&quot;&gt;Chapter 31&lt;/a&gt;). Performing JIT costs planning time but can accelerate query execution. Setting this to &lt;code&gt;-1&lt;/code&gt; disables JIT compilation. The default is &lt;code&gt;100000&lt;/code&gt;.</source>
          <target state="translated">활성화 된 경우 JIT 컴파일이 활성화되는 쿼리 비용을 설정합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/jit.html&quot;&gt;31 장&lt;/a&gt; 참조 ). JIT를 수행하면 계획 시간이 소요되지만 쿼리 실행을 가속화 할 수 있습니다. 이 값을 &lt;code&gt;-1&lt;/code&gt; 로 설정 하면 JIT 컴파일 이 비활성화됩니다. 기본값은 &lt;code&gt;100000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db649f38adafb2cfe08adb5ae46f8744c91ab7a2" translate="yes" xml:space="preserve">
          <source>Sets the query cost above which JIT compilation is activated, if enabled (see &lt;a href=&quot;https://www.postgresql.org/docs/13/jit.html&quot;&gt;Chapter 31&lt;/a&gt;). Performing JIT costs planning time but can accelerate query execution. Setting this to &lt;code&gt;-1&lt;/code&gt; disables JIT compilation. The default is &lt;code&gt;100000&lt;/code&gt;.</source>
          <target state="translated">활성화 된 경우 JIT 컴파일이 활성화되는 쿼리 비용을 설정합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/jit.html&quot;&gt;31 장&lt;/a&gt; 참조 ). JIT를 수행하면 계획 시간이 들지만 쿼리 실행을 가속화 할 수 있습니다. &lt;code&gt;-1&lt;/code&gt; 로 설정 하면 JIT 컴파일 이 비활성화됩니다. 기본값은 &lt;code&gt;100000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="02cb702a94c659f0e96017a2835d5c3582132b90" translate="yes" xml:space="preserve">
          <source>Sets the realm to match user principal names against. If this parameter is set, only users of that realm will be accepted. If it is not set, users of any realm can connect, subject to whatever user name mapping is done.</source>
          <target state="translated">사용자 프린시 펄 이름과 일치하도록 영역을 설정합니다. 이 매개 변수가 설정되면 해당 영역의 사용자 만 승인됩니다. 설정되지 않은 경우 사용자 이름 매핑이 수행 된 모든 영역의 사용자가 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1da8e17872d56e3b32b3439f187fa84edb464ed" translate="yes" xml:space="preserve">
          <source>Sets the record separator to use in unaligned output format to a zero byte.</source>
          <target state="translated">정렬되지 않은 출력 형식으로 사용할 레코드 구분 기호를 0 바이트로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5606d630619350ef9abeda5c764ac4222147ef4b" translate="yes" xml:space="preserve">
          <source>Sets the role's password. (A password is only of use for roles having the &lt;code&gt;LOGIN&lt;/code&gt; attribute, but you can nonetheless define one for roles without it.) If you do not plan to use password authentication you can omit this option. If no password is specified, the password will be set to null and password authentication will always fail for that user. A null password can optionally be written explicitly as &lt;code&gt;PASSWORD NULL&lt;/code&gt;.</source>
          <target state="translated">역할의 비밀번호를 설정합니다. 암호는 &lt;code&gt;LOGIN&lt;/code&gt; 속성 이있는 역할에만 사용 되지만 암호가없는 역할에 대해서는 암호를 정의 할 수 있습니다. 암호 인증을 사용하지 않으려는 경우이 옵션을 생략 할 수 있습니다. 암호를 지정하지 않으면 암호가 null로 설정되고 해당 사용자에 대한 암호 인증이 항상 실패합니다. 널 암호는 선택적으로 &lt;code&gt;PASSWORD NULL&lt;/code&gt; 로 명시 적으로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb5de31b6911067b1e365dd8c73320ae4512fb01" translate="yes" xml:space="preserve">
          <source>Sets the seed for subsequent &lt;code&gt;random()&lt;/code&gt; calls; argument must be between -1.0 and 1.0, inclusive</source>
          <target state="translated">후속 &lt;code&gt;random()&lt;/code&gt; 호출에 대한 시드를 설정 합니다. 인수는 -1.0과 1.0 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="609dde37cb2de8937be4c5a8ee98ac930d27385c" translate="yes" xml:space="preserve">
          <source>Sets the sequence object's current value, and optionally its &lt;code id=&quot;is_called&quot;&gt;is_called&lt;/code&gt; flag. The two-parameter form sets the sequence's &lt;code&gt;last_value&lt;/code&gt; field to the specified value and sets its &lt;code&gt;is_called&lt;/code&gt; field to &lt;code&gt;true&lt;/code&gt;, meaning that the next &lt;code&gt;nextval&lt;/code&gt; will advance the sequence before returning a value. The value that will be reported by &lt;code&gt;currval&lt;/code&gt; is also set to the specified value. In the three-parameter form, &lt;code&gt;is_called&lt;/code&gt; can be set to either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;true&lt;/code&gt; has the same effect as the two-parameter form. If it is set to &lt;code&gt;false&lt;/code&gt;, the next &lt;code&gt;nextval&lt;/code&gt; will return exactly the specified value, and sequence advancement commences with the following &lt;code&gt;nextval&lt;/code&gt;. Furthermore, the value reported by &lt;code&gt;currval&lt;/code&gt; is not changed in this case. For example,</source>
          <target state="translated">시퀀스 객체의 현재 값과 선택적으로 &lt;code id=&quot;is_called&quot;&gt;is_called&lt;/code&gt; 플래그를 설정합니다. 두 매개 변수 형식은 시퀀스의 &lt;code&gt;last_value&lt;/code&gt; 필드를 지정된 값으로 설정하고 &lt;code&gt;is_called&lt;/code&gt; 필드를 &lt;code&gt;true&lt;/code&gt; 로 설정 합니다 . 즉, 다음 &lt;code&gt;nextval&lt;/code&gt; 이 값을 반환하기 전에 시퀀스를 진행합니다. &lt;code&gt;currval&lt;/code&gt; 로보고 될 값 도 지정된 값으로 설정됩니다. 3 개 매개 변수 형식에서 &lt;code&gt;is_called&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 설정할 수 있습니다 . &lt;code&gt;true&lt;/code&gt; 는 두 매개 변수 형식과 동일한 효과를 갖습니다. &lt;code&gt;false&lt;/code&gt; 로 설정 되면 다음 &lt;code&gt;nextval&lt;/code&gt; 지정된 값을 정확하게 반환하고 시퀀스 진행은 다음 &lt;code&gt;nextval&lt;/code&gt; 로 시작됩니다 . 또한 이 경우 &lt;code&gt;currval&lt;/code&gt; 로보고되는 값 은 변경되지 않습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="d7024cf8010aece3606a76f8e37e44d42076b1f2" translate="yes" xml:space="preserve">
          <source>Sets the string to be printed in place of a null value. The default is to print nothing, which can easily be mistaken for an empty string. For example, one might prefer &lt;code&gt;\pset null '(null)'&lt;/code&gt;.</source>
          <target state="translated">널값 대신 인쇄 할 문자열을 설정합니다. 기본값은 아무것도 인쇄하지 않는 것으로 빈 문자열로 쉽게 착각 할 수 있습니다. 예를 들어, &lt;code&gt;\pset null '(null)'&lt;/code&gt; 선호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d0d5999942c3fce4dd3df1e49ffecfb914beb30" translate="yes" xml:space="preserve">
          <source>Sets the table title for any subsequently printed tables. This can be used to give your output descriptive tags. If no &lt;code&gt;value&lt;/code&gt; is given, the title is unset.</source>
          <target state="translated">이후에 인쇄되는 테이블의 테이블 제목을 설정합니다. 출력 설명 태그를 제공하는 데 사용할 수 있습니다. &lt;code&gt;value&lt;/code&gt; 을 지정 하지 않으면 제목이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63da690f2b470079bd60c4e8dfde0423f74026bf" translate="yes" xml:space="preserve">
          <source>Sets the target directory to write the output to. pg_basebackup will create this directory (and any missing parent directories) if it does not exist. If it already exists, it must be empty.</source>
          <target state="translated">출력을 쓸 대상 디렉토리를 설정합니다. pg_basebackup은 존재하지 않는 경우이 디렉토리 (및 누락 된 상위 디렉토리)를 생성합니다. 이미 존재하는 경우 비어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a9e1af3b2fb689d9e53f574ca3df72726aa01880" translate="yes" xml:space="preserve">
          <source>Sets the target width for the &lt;code&gt;wrapped&lt;/code&gt; format, and also the width limit for determining whether output is wide enough to require the pager or switch to the vertical display in expanded auto mode. Zero (the default) causes the target width to be controlled by the environment variable &lt;code&gt;COLUMNS&lt;/code&gt;, or the detected screen width if &lt;code&gt;COLUMNS&lt;/code&gt; is not set. In addition, if &lt;code&gt;columns&lt;/code&gt; is zero then the &lt;code&gt;wrapped&lt;/code&gt; format only affects screen output. If &lt;code&gt;columns&lt;/code&gt; is nonzero then file and pipe output is wrapped to that width as well.</source>
          <target state="translated">&lt;code&gt;wrapped&lt;/code&gt; 형식 의 대상 너비 와 확장 된 자동 모드에서 페이저를 요구하거나 수직 디스플레이로 전환하기에 충분한 출력 너비를 결정하기위한 너비 제한을 설정합니다. 0 (기본값)은 환경 변수 &lt;code&gt;COLUMNS&lt;/code&gt; 또는 &lt;code&gt;COLUMNS&lt;/code&gt; 가 설정되지 않은 경우 감지 된 화면 너비로 대상 너비를 제어합니다 . 또한 &lt;code&gt;columns&lt;/code&gt; 이 0이면 &lt;code&gt;wrapped&lt;/code&gt; 형식은 화면 출력에만 영향을줍니다. 경우 &lt;code&gt;columns&lt;/code&gt; 후 파일 파이프 출력 제로 이외 아니라 그 폭에 싸여있다.</target>
        </trans-unit>
        <trans-unit id="9418304bf83c8059c2c09a5f3ac4f6b29f3fb74e" translate="yes" xml:space="preserve">
          <source>Sets the time zone for displaying and interpreting time stamps. The built-in default is &lt;code&gt;GMT&lt;/code&gt;, but that is typically overridden in &lt;code&gt;postgresql.conf&lt;/code&gt;; initdb will install a setting there corresponding to its system environment. See &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt; for more information.</source>
          <target state="translated">타임 스탬프를 표시하고 해석하기위한 시간대를 설정합니다. 내장 된 기본값은 &lt;code&gt;GMT&lt;/code&gt; 이지만 일반적으로 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 재정의됩니다 . initdb는 시스템 환경에 해당하는 설정을 설치합니다. 자세한 정보는 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e16c7d7ee9ffcd6202a7613a26919ce859e9812" translate="yes" xml:space="preserve">
          <source>Sets the time zone used for timestamps written in the server log. Unlike &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;, this value is cluster-wide, so that all sessions will report timestamps consistently. The built-in default is &lt;code&gt;GMT&lt;/code&gt;, but that is typically overridden in &lt;code&gt;postgresql.conf&lt;/code&gt;; initdb will install a setting there corresponding to its system environment. See &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt; for more information. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">서버 로그에 기록 된 타임 스탬프에 사용되는 시간대를 설정합니다. &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 과 달리이 값은 클러스터 전체이므로 모든 세션이 일관되게 타임 스탬프를보고합니다. 내장 된 기본값은 &lt;code&gt;GMT&lt;/code&gt; 이지만 일반적으로 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 재정의됩니다 . initdb는 시스템 환경에 해당하는 설정을 설치합니다. 자세한 정보는 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3 절&lt;/a&gt; 을 참조하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1e9be4ad78776b39da3bb8c7ea45eba8f1ad12a" translate="yes" xml:space="preserve">
          <source>Sets the title of any tables being printed as the result of a query or unset any such title. This command is equivalent to &lt;code&gt;\pset title title&lt;/code&gt;. (The name of this command derives from &amp;ldquo;caption&amp;rdquo;, as it was previously only used to set the caption in an HTML table.)</source>
          <target state="translated">쿼리 결과로 인쇄되는 테이블의 제목을 설정하거나 제목을 설정 해제합니다. 이 명령은 &lt;code&gt;\pset title title&lt;/code&gt; 과 동일합니다 . 이 명령의 이름은 이전에 HTML 테이블에서 캡션을 설정하는 데만 사용 되었기 때문에&amp;ldquo;캡션&amp;rdquo;에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="13c4b9ea31ba093e5244fa2e73ddd78a559c5130" translate="yes" xml:space="preserve">
          <source>Sets the weak input mode (returns new setting)</source>
          <target state="translated">약한 입력 모드를 설정합니다 (새 설정으로 돌아갑니다).</target>
        </trans-unit>
        <trans-unit id="9f37111835d1c9f3006754469591f1e249e20cea" translate="yes" xml:space="preserve">
          <source>Sets the weak input mode, and returns new setting.</source>
          <target state="translated">약한 입력 모드를 설정하고 새로운 설정을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9309982f19ed9aa5641d0ca9828c67b16048770c" translate="yes" xml:space="preserve">
          <source>Sets up initial security labels for all objects within the current database. The argument may be &lt;code&gt;NULL&lt;/code&gt;, or the name of a specfile to be used as alternative of the system default.</source>
          <target state="translated">현재 데이터베이스 내의 모든 개체에 대한 초기 보안 레이블을 설정합니다. 인수는 &lt;code&gt;NULL&lt;/code&gt; 또는 시스템 기본값 대신 사용할 스펙 파일의 이름 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88768dee379947c4f7e08aaa204b29d2e74dfb86" translate="yes" xml:space="preserve">
          <source>Sets up initial security labels for all objects within the current database. The argument may be NULL, or the name of a specfile to be used as alternative of the system default.</source>
          <target state="translated">현재 데이터베이스 내의 모든 개체에 대한 초기 보안 레이블을 설정합니다. 인수는 NULL이거나 시스템 기본값의 대안으로 사용될 스펙 파일의 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab2b0c24fa44268a1bd5bc3db6cefa59a5e85b0" translate="yes" xml:space="preserve">
          <source>Sets variable &lt;code&gt;varname&lt;/code&gt; to a value calculated from &lt;code&gt;expression&lt;/code&gt;. The expression may contain the &lt;code&gt;NULL&lt;/code&gt; constant, Boolean constants &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt;, integer constants such as &lt;code&gt;5432&lt;/code&gt;, double constants such as &lt;code&gt;3.14159&lt;/code&gt;, references to variables &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;, &lt;a href=&quot;pgbench#PGBENCH-BUILTIN-OPERATORS&quot;&gt;operators&lt;/a&gt; with their usual SQL precedence and associativity, &lt;a href=&quot;pgbench#PGBENCH-BUILTIN-FUNCTIONS&quot;&gt;function calls&lt;/a&gt;, SQL &lt;a href=&quot;functions-conditional#FUNCTIONS-CASE&quot;&gt;&lt;code&gt;CASE&lt;/code&gt; generic conditional expressions&lt;/a&gt; and parentheses.</source>
          <target state="translated">변수 &lt;code&gt;varname&lt;/code&gt; 을 &lt;code&gt;expression&lt;/code&gt; 에서 계산 된 값으로 설정합니다 . 이 표현식에는 &lt;code&gt;NULL&lt;/code&gt; 상수, 부울 상수 &lt;code&gt;TRUE&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; , &lt;code&gt;5432&lt;/code&gt; 와 같은 정수 상수 , &lt;code&gt;3.14159&lt;/code&gt; 와 같은 이중 상수 , 변수에 대한 참조 &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; , 일반적인 SQL 우선 순위 및 연관성을 가진 &lt;a href=&quot;pgbench#PGBENCH-BUILTIN-OPERATORS&quot;&gt;연산자&lt;/a&gt; , &lt;a href=&quot;pgbench#PGBENCH-BUILTIN-FUNCTIONS&quot;&gt;함수 호출&lt;/a&gt; , SQL &lt;a href=&quot;functions-conditional#FUNCTIONS-CASE&quot;&gt; &lt;code&gt;CASE&lt;/code&gt; 일반 조건식&lt;/a&gt; 및 괄호.</target>
        </trans-unit>
        <trans-unit id="f924dad559be5e0c9b0095784ed5f3ccd6066315" translate="yes" xml:space="preserve">
          <source>Sets variable &lt;code&gt;varname&lt;/code&gt; to the result of the shell command &lt;code&gt;command&lt;/code&gt; with the given &lt;code&gt;argument&lt;/code&gt;(s). The command must return an integer value through its standard output.</source>
          <target state="translated">지정된 &lt;code&gt;argument&lt;/code&gt; 를 사용하여 변수 &lt;code&gt;varname&lt;/code&gt; 을 쉘 명령 &lt;code&gt;command&lt;/code&gt; 의 결과로 설정합니다 . 명령은 표준 출력을 통해 정수 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="06a831dd90f4fcce0caf06c98d85b86d9781c861" translate="yes" xml:space="preserve">
          <source>Sets whether &lt;code&gt;DOCUMENT&lt;/code&gt; or &lt;code&gt;CONTENT&lt;/code&gt; is implicit when converting between XML and character string values. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; for a description of this. Valid values are &lt;code&gt;DOCUMENT&lt;/code&gt; and &lt;code&gt;CONTENT&lt;/code&gt;. The default is &lt;code&gt;CONTENT&lt;/code&gt;.</source>
          <target state="translated">XML과 문자열 값 사이를 변환 할 때 &lt;code&gt;DOCUMENT&lt;/code&gt; 또는 &lt;code&gt;CONTENT&lt;/code&gt; 가 암시 적인지 여부를 설정합니다 . 이에 대한 설명은 &lt;a href=&quot;datatype-xml&quot;&gt;8.13 절을&lt;/a&gt; 참조하십시오 . 유효한 값은 &lt;code&gt;DOCUMENT&lt;/code&gt; 및 &lt;code&gt;CONTENT&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;CONTENT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="333c8849db9af052371db80618770b64f3dc1314" translate="yes" xml:space="preserve">
          <source>Sets whether GSSAPI user names should be treated case-insensitively. The default is &lt;code&gt;off&lt;/code&gt; (case sensitive). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">GSSAPI 사용자 이름을 대소 문자를 구분하여 처리해야하는지 여부를 설정합니다. 기본값은 &lt;code&gt;off&lt;/code&gt; (대소 문자 구분). 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47dc609161a8bb03371f6441c5ee3ee0b0a6fe41" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;commit_delay&lt;/code&gt; adds a time delay before a WAL flush is initiated. This can improve group commit throughput by allowing a larger number of transactions to commit via a single WAL flush, if system load is high enough that additional transactions become ready to commit within the given interval. However, it also increases latency by up to the &lt;code&gt;commit_delay&lt;/code&gt; for each WAL flush. Because the delay is just wasted if no other transactions become ready to commit, a delay is only performed if at least &lt;code&gt;commit_siblings&lt;/code&gt; other transactions are active when a flush is about to be initiated. Also, no delays are performed if &lt;code&gt;fsync&lt;/code&gt; is disabled. If this value is specified without units, it is taken as microseconds. The default &lt;code&gt;commit_delay&lt;/code&gt; is zero (no delay). Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;commit_delay&lt;/code&gt; 를 설정 하면 WAL 플러시가 시작되기 전에 시간 지연이 추가됩니다. 이는 시스템로드가 주어진 간격 내에 추가 트랜잭션을 커밋 할 수있을만큼 충분히 높은 경우 단일 WAL 플러시를 통해 더 많은 수의 트랜잭션이 커밋되도록하여 그룹 커밋 처리량을 향상시킬 수 있습니다. 그러나 각 WAL 플러시마다 최대 &lt;code&gt;commit_delay&lt;/code&gt; 까지 대기 시간이 증가 합니다. 커밋 할 준비가 된 다른 트랜잭션이 없으면 지연이 낭비되기 때문에 플러시가 시작될 때 다른 &lt;code&gt;commit_siblings&lt;/code&gt; 이상의 다른 트랜잭션이 활성화 된 경우에만 지연이 수행됩니다 . 또한 &lt;code&gt;fsync&lt;/code&gt; 가 비활성화 된 경우 지연이 수행 되지 않습니다. 이 값을 단위없이 지정하면 마이크로 초로 간주됩니다. 기본 &lt;code&gt;commit_delay&lt;/code&gt; 가 0입니다 (지연 없음). 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55f163c4026b369afdcf7bc41ff57f0a179c3fc4" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;lock_timeout&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; is not recommended because it would affect all sessions.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;code&gt;lock_timeout&lt;/code&gt; 을 설정하면 모든 세션에 영향을 미치므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5de84dde4ac09d0b73ef1551fcd1b6fb34265ef6" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;max_stack_depth&lt;/code&gt; higher than the actual kernel limit will mean that a runaway recursive function can crash an individual backend process. On platforms where PostgreSQL can determine the kernel limit, the server will not allow this variable to be set to an unsafe value. However, not all platforms provide the information, so caution is recommended in selecting a value.</source>
          <target state="translated">&lt;code&gt;max_stack_depth&lt;/code&gt; 를 실제 커널 한계보다 높게 설정 하면 런 어웨이 재귀 함수가 개별 백엔드 프로세스를 중단시킬 수 있습니다. PostgreSQL이 커널 제한을 결정할 수있는 플랫폼에서 서버는이 변수를 안전하지 않은 값으로 설정할 수 없습니다. 그러나 모든 플랫폼이 정보를 제공하는 것은 아니므로 값을 선택할 때주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="280c0f486c1375fc10412fec06e31ca1f194f910" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;statement_timeout&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; is not recommended because it would affect all sessions.</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;code&gt;statement_timeout&lt;/code&gt; 을 설정하면 모든 세션에 영향을 미치므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5cec1702484034fb224149bdce32ce0d06ff6eb" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;synchronous_commit&lt;/code&gt; to &lt;code&gt;remote_apply&lt;/code&gt; will cause each commit to wait until the current synchronous standbys report that they have replayed the transaction, making it visible to user queries. In simple cases, this allows for load balancing with causal consistency.</source>
          <target state="translated">&lt;code&gt;synchronous_commit&lt;/code&gt; 을 &lt;code&gt;remote_apply&lt;/code&gt; 로 설정 하면 현재 동기 대기가 트랜잭션을 재생했다고보고 할 때까지 각 커밋이 대기하여 사용자 쿼리에 표시됩니다. 간단한 경우, 이는 인과 적 일관성으로로드 밸런싱을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c638e32ab460b36192a8a3670d7ed6fc5ef48897" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;synchronous_commit&lt;/code&gt; to &lt;code&gt;remote_write&lt;/code&gt; will cause each commit to wait for confirmation that the standby has received the commit record and written it out to its own operating system, but not for the data to be flushed to disk on the standby. This setting provides a weaker guarantee of durability than &lt;code&gt;on&lt;/code&gt; does: the standby could lose the data in the event of an operating system crash, though not a PostgreSQL crash. However, it's a useful setting in practice because it can decrease the response time for the transaction. Data loss could only occur if both the primary and the standby crash and the database of the primary gets corrupted at the same time.</source>
          <target state="translated">&lt;code&gt;synchronous_commit&lt;/code&gt; 을 &lt;code&gt;remote_write&lt;/code&gt; 로 설정 하면 각 확약이 대기가 확약 레코드를 수신하여 자체 운영 체제에 기록했음을 확인하기 위해 대기하지만 데이터가 대기의 디스크로 플러시되지는 않습니다. 이 설정은 &lt;code&gt;on&lt;/code&gt; 보다 약한 내구성을 보장 합니다. PostgreSQL 충돌이 아닌 운영 체제 충돌시 대기에서 데이터가 손실 될 수 있습니다. 그러나 실제로는 트랜잭션의 응답 시간을 줄일 수 있으므로 유용한 설정입니다. 기본 및 대기 충돌과 기본 데이터베이스가 동시에 손상된 경우에만 데이터 손실이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58bb37c9c188c485a0fd527ed01ff2f5d42d9586" translate="yes" xml:space="preserve">
          <source>Setting Parameters</source>
          <target state="translated">파라미터 설정</target>
        </trans-unit>
        <trans-unit id="3deebc173c82b03c24ea5b544f3dfa1e2e6c2b6e" translate="yes" xml:space="preserve">
          <source>Setting a value for &lt;code&gt;parallel_workers&lt;/code&gt; via &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; directly controls how many parallel worker processes will be requested by a &lt;code&gt;CREATE INDEX&lt;/code&gt; against the table. This bypasses the cost model completely, and prevents &lt;code&gt;maintenance_work_mem&lt;/code&gt; from affecting how many parallel workers are requested. Setting &lt;code&gt;parallel_workers&lt;/code&gt; to 0 via &lt;code&gt;ALTER TABLE&lt;/code&gt; will disable parallel index builds on the table in all cases.</source>
          <target state="translated">&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE을&lt;/a&gt; 통해 &lt;code&gt;parallel_workers&lt;/code&gt; 의 값을 설정 하면 테이블에 대해 &lt;code&gt;CREATE INDEX&lt;/code&gt; 가 요청하는 병렬 작업자 프로세스 수를 직접 제어 합니다. 이는 비용 모델을 완전히 무시하고 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 이 요청 된 병렬 작업자 수에 영향을주지 않습니다. &lt;code&gt;ALTER TABLE&lt;/code&gt; 을 통해 &lt;code&gt;parallel_workers&lt;/code&gt; 를 0으로 설정하면 모든 경우에 테이블에서 병렬 인덱스 빌드가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="feb5c4ae5f778553cba809af284b054e9b9bf136" translate="yes" xml:space="preserve">
          <source>Setting file-system permissions only helps for Unix-socket connections. Local TCP/IP connections are not restricted by file-system permissions. Therefore, if you want to use file-system permissions for local security, remove the &lt;code&gt;host ... 127.0.0.1 ...&lt;/code&gt; line from &lt;code&gt;pg_hba.conf&lt;/code&gt;, or change it to a non-&lt;code&gt;trust&lt;/code&gt; authentication method.</source>
          <target state="translated">파일 시스템 권한을 설정하면 유닉스 소켓 연결에만 도움이됩니다. 로컬 TCP / IP 연결은 파일 시스템 권한에 의해 제한되지 않습니다. 따라서 로컬 보안에 파일 시스템 권한을 사용하려면 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에서 &lt;code&gt;host ... 127.0.0.1 ...&lt;/code&gt; 행을 제거 하거나 비 &lt;code&gt;trust&lt;/code&gt; 인증 방법으로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd50f0143fe2b357563572277fe9b73ebc378f80" translate="yes" xml:space="preserve">
          <source>Setting the &lt;code&gt;LEAKPROOF&lt;/code&gt; attribute on a function requires &lt;code&gt;install&lt;/code&gt; permission.</source>
          <target state="translated">함수 에서 &lt;code&gt;LEAKPROOF&lt;/code&gt; 속성을 설정 하려면 &lt;code&gt;install&lt;/code&gt; 권한이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="424109d8edff1803029472e86b9b860cdc86e197" translate="yes" xml:space="preserve">
          <source>Setting the seed explicitly allows to reproduce a &lt;code&gt;pgbench&lt;/code&gt; run exactly, as far as random numbers are concerned. As the random state is managed per thread, this means the exact same &lt;code&gt;pgbench&lt;/code&gt; run for an identical invocation if there is one client per thread and there are no external or data dependencies. From a statistical viewpoint reproducing runs exactly is a bad idea because it can hide the performance variability or improve performance unduly, e.g. by hitting the same pages as a previous run. However, it may also be of great help for debugging, for instance re-running a tricky case which leads to an error. Use wisely.</source>
          <target state="translated">시드를 명시 적으로 설정하면 난수가 관련되는 한 &lt;code&gt;pgbench&lt;/code&gt; 실행을 정확하게 재현 할 수 있습니다 . 임의의 상태는 스레드별로 관리 &lt;code&gt;pgbench&lt;/code&gt; 스레드 당 하나의 클라이언트가 있고 외부 또는 데이터 종속성이없는 경우 동일한 호출에 대해 동일한 pgbench가 실행 됨을 의미합니다 . 통계적 관점에서 런을 정확하게 재현하는 것은 성능 변동성을 숨기거나 예를 들어 이전 런과 같은 페이지를 쳐서 과도하게 성능을 향상시킬 수 있기 때문에 나쁜 생각입니다. 그러나 오류를 유발하는 까다로운 사례를 다시 실행하는 등 디버깅에 큰 도움이 될 수도 있습니다. 현명하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9d100cee685b46a504f6829cfcc7f9c692e6e707" translate="yes" xml:space="preserve">
          <source>Setting the seed explicitly allows to reproduce a &lt;code&gt;pgbench&lt;/code&gt; run exactly, as far as random numbers are concerned. As the random state is managed per thread, this means the exact same &lt;code&gt;pgbench&lt;/code&gt; run for an identical invocation if there is one client per thread and there are no external or data dependencies. From a statistical viewpoint reproducing runs exactly is a bad idea because it can hide the performance variability or improve performance unduly, e.g., by hitting the same pages as a previous run. However, it may also be of great help for debugging, for instance re-running a tricky case which leads to an error. Use wisely.</source>
          <target state="translated">시드를 명시 적으로 설정하면 난수에 관한 한 &lt;code&gt;pgbench&lt;/code&gt; 실행을 정확하게 재현 할 수 있습니다 . 임의의 상태는 스레드별로 관리 &lt;code&gt;pgbench&lt;/code&gt; 스레드 당 하나의 클라이언트가 있고 외부 또는 데이터 종속성이없는 경우 동일한 호출에 대해 정확히 동일한 pgbench가 실행됩니다. 통계적 관점에서 실행을 정확하게 재현하는 것은 성능 변동성을 숨기거나 예를 들어 이전 실행과 동일한 페이지를 치는 등 부당하게 성능을 향상시킬 수 있기 때문에 나쁜 생각입니다. 그러나 오류가 발생하는 까다로운 경우를 다시 실행하는 등 디버깅에도 큰 도움이 될 수 있습니다. 현명하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a140ae3d48aebdb9dbb636e5572c996be1028f9" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; or more may trigger use of the GEQO planner, resulting in non-optimal plans. See &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-GEQO&quot;&gt;Section 19.7.3&lt;/a&gt;.</source>
          <target state="translated">이 값을 &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; 이상으로 설정 하면 GEQO 플래너 사용이 트리거되어 계획이 최적화되지 않을 수 있습니다. &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-GEQO&quot;&gt;섹션 19.7.3&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="64eb45a8294e62b8b952a38285fef07ddf186ccf" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;regress&lt;/code&gt; has all of the same effects as setting it to &lt;code&gt;on&lt;/code&gt; plus some additional effects that are intended to facilitate automated regression testing. Normally, messages from a parallel worker include a context line indicating that, but a setting of &lt;code&gt;regress&lt;/code&gt; suppresses this line so that the output is the same as in non-parallel execution. Also, the &lt;code&gt;Gather&lt;/code&gt; nodes added to plans by this setting are hidden in &lt;code&gt;EXPLAIN&lt;/code&gt; output so that the output matches what would be obtained if this setting were turned &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">이 값을 설정 &lt;code&gt;regress&lt;/code&gt; 으로 설정하는 것과 동일한 효과를 모두 가지고 &lt;code&gt;on&lt;/code&gt; 자동화 된 회귀 테스트를 용이하게하기위한 것이다 플러스 몇 가지 추가 효과를. 일반적으로, 병렬 작업자의 메시지는 그 컨텍스트를 나타내는 라인을 포함하지만, 설정의 &lt;code&gt;regress&lt;/code&gt; 출력이 아닌 병렬 처리와 동일한되도록 줄을 억제한다. 또한 이 설정으로 계획에 추가 된 &lt;code&gt;Gather&lt;/code&gt; 노드는 &lt;code&gt;EXPLAIN&lt;/code&gt; 출력에 숨겨져 있으므로이 설정이 &lt;code&gt;off&lt;/code&gt; 경우의 결과와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="ef1c09963cd9d1024c50bc537034add064157e7f" translate="yes" xml:space="preserve">
          <source>Setting this variable does not disable all security checks related to large objects &amp;mdash; only those for which the default behavior has changed in PostgreSQL 9.0.</source>
          <target state="translated">이 변수를 설정해도 큰 객체와 관련된 모든 보안 검사가 비활성화되는 것은 아니며 PostgreSQL 9.0에서 기본 동작이 변경된 검사 만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7dfd406e86c501d612013ad1b39a50a94d711af9" translate="yes" xml:space="preserve">
          <source>Setting this variable to &lt;code&gt;on&lt;/code&gt; is equivalent to the command line option &lt;code&gt;-S&lt;/code&gt;.</source>
          <target state="translated">이 변수를 &lt;code&gt;on&lt;/code&gt; 으로 설정 하는 것은 명령 행 옵션 &lt;code&gt;-S&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="96e74f5c79f4b7010d067a371cf639f4b9a5b740" translate="yes" xml:space="preserve">
          <source>Setting this variable to &lt;code&gt;on&lt;/code&gt; is equivalent to the command line option &lt;code&gt;-q&lt;/code&gt;. It is probably not too useful in interactive mode.</source>
          <target state="translated">이 변수를 &lt;code&gt;on&lt;/code&gt; 으로 설정 하는 것은 명령 행 옵션 &lt;code&gt;-q&lt;/code&gt; 와 같습니다 . 대화식 모드에서는 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a7cab545f744602a3eb0eb4dc36411eb7e36891" translate="yes" xml:space="preserve">
          <source>Setting this variable to &lt;code&gt;on&lt;/code&gt; is equivalent to the command line option &lt;code&gt;-s&lt;/code&gt;.</source>
          <target state="translated">이 변수를 &lt;code&gt;on&lt;/code&gt; 으로 설정 하는 것은 명령 행 옵션 &lt;code&gt;-s&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="de0a1efb5fb420f0c59eac94e6307c2a1df1ff4c" translate="yes" xml:space="preserve">
          <source>Settings provided in this way override those set via &lt;code&gt;postgresql.conf&lt;/code&gt; or &lt;code&gt;ALTER SYSTEM&lt;/code&gt;, so they cannot be changed globally without restarting the server.</source>
          <target state="translated">이러한 방식으로 제공된 설정은 &lt;code&gt;postgresql.conf&lt;/code&gt; 또는 &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 을 통해 설정 한 설정을 무시 하므로 서버를 다시 시작하지 않고 전체적으로 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b43e085be04a5b5032482d683c20c310973739a" translate="yes" xml:space="preserve">
          <source>Settings: &lt;code&gt;SHOW&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, &lt;code&gt;RESET&lt;/code&gt;</source>
          <target state="translated">설정 : &lt;code&gt;SHOW&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; , &lt;code&gt;RESET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63a647a2c75794bd5989eb828ac51dd0f38b4c1e" translate="yes" xml:space="preserve">
          <source>Several of the Boolean flags in &lt;code&gt;pg_class&lt;/code&gt; are maintained lazily: they are guaranteed to be true if that's the correct state, but may not be reset to false immediately when the condition is no longer true. For example, &lt;code&gt;relhasindex&lt;/code&gt; is set by &lt;code&gt;CREATE INDEX&lt;/code&gt;, but it is never cleared by &lt;code&gt;DROP INDEX&lt;/code&gt;. Instead, &lt;code&gt;VACUUM&lt;/code&gt; clears &lt;code&gt;relhasindex&lt;/code&gt; if it finds the table has no indexes. This arrangement avoids race conditions and improves concurrency.</source>
          <target state="translated">&lt;code&gt;pg_class&lt;/code&gt; 의 Boolean 플래그 중 일부는 느리게 유지됩니다. 올바른 상태 인 경우 true가 보장되지만 조건이 더 이상 true가 아닌 경우 즉시 false로 재설정되지 않을 수 있습니다. 예를 들어, &lt;code&gt;relhasindex&lt;/code&gt; 는 &lt;code&gt;CREATE INDEX&lt;/code&gt; 에 의해 설정 되지만 &lt;code&gt;DROP INDEX&lt;/code&gt; 에 의해 지워지지는 않습니다 . 대신, 테이블에 인덱스가없는 경우 &lt;code&gt;VACUUM&lt;/code&gt; 은 &lt;code&gt;relhasindex&lt;/code&gt; 를 지 웁니다 . 이 배열은 경쟁 조건을 피하고 동시성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="4ec3656aee808a47715f95baabbfbe025c9785bc" translate="yes" xml:space="preserve">
          <source>Several other applications exist that can provide secure tunnels using a procedure similar in concept to the one just described.</source>
          <target state="translated">방금 설명한 것과 유사한 개념의 절차를 사용하여 보안 터널을 제공 할 수있는 몇 가지 다른 응용 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4042351a6d5c02c8dcd311ac414faef5a2d39735" translate="yes" xml:space="preserve">
          <source>Several predefined text search configurations are available, and you can create custom configurations easily. To facilitate management of text search objects, a set of SQL commands is available, and there are several psql commands that display information about text search objects (&lt;a href=&quot;textsearch-psql&quot;&gt;Section 12.10&lt;/a&gt;).</source>
          <target state="translated">사전 정의 된 여러 텍스트 검색 구성을 사용할 수 있으며 사용자 정의 구성을 쉽게 만들 수 있습니다. 텍스트 검색 객체를 쉽게 관리 할 수 ​​있도록 일련의 SQL 명령을 사용할 수 있으며 텍스트 검색 객체에 대한 정보를 표시하는 여러 psql 명령이 있습니다 ( &lt;a href=&quot;textsearch-psql&quot;&gt;12.10 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="186abc8b3c6e2e1142e7a19a169dad5743b8a629" translate="yes" xml:space="preserve">
          <source>Several predefined views, listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-DYNAMIC-VIEWS-TABLE&quot;&gt;Table 27.1&lt;/a&gt;, are available to show the current state of the system. There are also several other views, listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS-TABLE&quot;&gt;Table 27.2&lt;/a&gt;, available to show the results of statistics collection. Alternatively, one can build custom views using the underlying statistics functions, as discussed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCTIONS&quot;&gt;Section 27.2.20&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;monitoring-stats#MONITORING-STATS-DYNAMIC-VIEWS-TABLE&quot;&gt;표 27.1에&lt;/a&gt; 나열된 여러 사전 정의 된보기를 사용하여 시스템의 현재 상태를 표시 할 수 있습니다. 통계 수집 결과를 표시하는 데 사용할 수 있는 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS-TABLE&quot;&gt;표 27.2에&lt;/a&gt; 나열된 여러 다른보기도 있습니다. 또는 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCTIONS&quot;&gt;섹션 27.2.20에&lt;/a&gt; 설명 된대로 기본 통계 함수를 사용하여 사용자 정의보기를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="737630e42a62c460c14d1fdef742a1ea8aa4971b" translate="yes" xml:space="preserve">
          <source>Several predefined views, listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-DYNAMIC-VIEWS-TABLE&quot;&gt;Table 27.1&lt;/a&gt;, are available to show the current state of the system. There are also several other views, listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS-TABLE&quot;&gt;Table 27.2&lt;/a&gt;, available to show the results of statistics collection. Alternatively, one can build custom views using the underlying statistics functions, as discussed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCTIONS&quot;&gt;Section 27.2.3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;monitoring-stats#MONITORING-STATS-DYNAMIC-VIEWS-TABLE&quot;&gt;표 27.1에&lt;/a&gt; 나열된 여러 사전 정의 된보기를 사용하여 시스템의 현재 상태를 표시 할 수 있습니다. 통계 수집 결과를 표시하는 데 사용할 수 있는 몇 가지 다른보기가 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS-TABLE&quot;&gt;표 27.2에&lt;/a&gt; 나열되어 있습니다. 또는 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCTIONS&quot;&gt;27.2.3 절&lt;/a&gt; 에서 논의 된 것처럼 기본 통계 함수를 사용하여 사용자 정의보기를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c46dc52cb0fd044935ca07ffb1115c2c1707436" translate="yes" xml:space="preserve">
          <source>Several restrictions apply to the definition of generated columns and tables involving generated columns:</source>
          <target state="translated">생성 된 컬럼 및 생성 된 컬럼과 관련된 테이블의 정의에는 몇 가지 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea8dadc9bbe78dc1c6065234378727b1ccee99ab" translate="yes" xml:space="preserve">
          <source>Several settings are available for preloading shared libraries into the server, in order to load additional functionality or achieve performance benefits. For example, a setting of &lt;code&gt;'$libdir/mylib'&lt;/code&gt; would cause &lt;code&gt;mylib.so&lt;/code&gt; (or on some platforms, &lt;code&gt;mylib.sl&lt;/code&gt;) to be preloaded from the installation's standard library directory. The differences between the settings are when they take effect and what privileges are required to change them.</source>
          <target state="translated">추가 기능을로드하거나 성능 이점을 얻기 위해 공유 라이브러리를 서버에 사전로드하기위한 여러 설정을 사용할 수 있습니다. 예를 들어,의 설정은 &lt;code&gt;'$libdir/mylib'&lt;/code&gt; 원인이 &lt;code&gt;mylib.so&lt;/code&gt; (또는 플랫폼, &lt;code&gt;mylib.sl&lt;/code&gt; 가 ) 설치의 표준 라이브러리 디렉토리에서 미리로드 할 수 있습니다. 설정 간의 차이점은 적용 시점과 설정을 변경하는 데 필요한 권한입니다.</target>
        </trans-unit>
        <trans-unit id="de314fa0c9d9e359b633f2fdab4659c886fe5986" translate="yes" xml:space="preserve">
          <source>Severity</source>
          <target state="translated">Severity</target>
        </trans-unit>
        <trans-unit id="8382497862b5333e89d71eb83d6201f7edbc1ae1" translate="yes" xml:space="preserve">
          <source>Share/exclusive hash-bucket-level locks are used for read/write access. Locks are released after the whole bucket is processed. Bucket-level locks provide better concurrency than index-level ones, but deadlock is possible since the locks are held longer than one index operation.</source>
          <target state="translated">공유 / 독점 해시 버킷 수준 잠금은 읽기 / 쓰기 액세스에 사용됩니다. 전체 버킷이 처리 된 후 잠금이 해제됩니다. 버킷 수준 잠금은 인덱스 수준 잠금보다 나은 동시성을 제공하지만 잠금이 하나의 인덱스 작업보다 오래 유지되므로 교착 상태가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7041054debfd7e75ec463dde6ece66d8a86e909" translate="yes" xml:space="preserve">
          <source>Shared Disk</source>
          <target state="translated">공유 디스크</target>
        </trans-unit>
        <trans-unit id="327854df6cd5176c2c4c283a7be52111f5c9d91c" translate="yes" xml:space="preserve">
          <source>Shared Disk Failover</source>
          <target state="translated">공유 디스크 페일 오버</target>
        </trans-unit>
        <trans-unit id="81204b5b8aa655d624ef594ceffa8bff9a8dbdda" translate="yes" xml:space="preserve">
          <source>Shared disk failover avoids synchronization overhead by having only one copy of the database. It uses a single disk array that is shared by multiple servers. If the main database server fails, the standby server is able to mount and start the database as though it were recovering from a database crash. This allows rapid failover with no data loss.</source>
          <target state="translated">공유 디스크 장애 조치는 데이터베이스 사본이 하나만 있으면 동기화 오버 헤드를 방지합니다. 여러 서버가 공유하는 단일 디스크 배열을 사용합니다. 기본 데이터베이스 서버에 장애가 발생하면 대기 서버는 데이터베이스 충돌로부터 복구하는 것처럼 데이터베이스를 마운트하고 시작할 수 있습니다. 이를 통해 데이터 손실없이 빠른 장애 조치가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="be4677bc3167ff156c0f70748645ca17d9d6e0ac" translate="yes" xml:space="preserve">
          <source>Shared hardware functionality is common in network storage devices. Using a network file system is also possible, though care must be taken that the file system has full POSIX behavior (see &lt;a href=&quot;creating-cluster#CREATING-CLUSTER-NFS&quot;&gt;Section 18.2.2.1&lt;/a&gt;). One significant limitation of this method is that if the shared disk array fails or becomes corrupt, the primary and standby servers are both nonfunctional. Another issue is that the standby server should never access the shared storage while the primary server is running.</source>
          <target state="translated">공유 하드웨어 기능은 네트워크 저장 장치에서 일반적입니다. 파일 시스템이 전체 POSIX 동작을 갖도록주의를 기울여야하지만 네트워크 파일 시스템을 사용할 수도 있습니다 ( &lt;a href=&quot;creating-cluster#CREATING-CLUSTER-NFS&quot;&gt;섹션 18.2.2.1&lt;/a&gt; 참조 ). 이 방법의 한 가지 중요한 제한 사항은 공유 디스크 배열이 실패하거나 손상되면 주 서버와 대기 서버가 모두 작동하지 않는다는 것입니다. 또 다른 문제는 기본 서버가 실행 중일 때 대기 서버가 공유 스토리지에 절대 액세스하지 않아야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="122ae25e75a21ed0115c31580c3ed933ce192d09" translate="yes" xml:space="preserve">
          <source>Shared memory</source>
          <target state="translated">공유 메모리</target>
        </trans-unit>
        <trans-unit id="5faec398d75b30791d35577459b95beb89fc7cab" translate="yes" xml:space="preserve">
          <source>Shift JIS</source>
          <target state="translated">JIS 이동</target>
        </trans-unit>
        <trans-unit id="40ebc998343deb6927aa9c3448541680b6c8def8" translate="yes" xml:space="preserve">
          <source>Shift JIS, JIS X 0213</source>
          <target state="translated">시프트 JIS, JIS X 0213</target>
        </trans-unit>
        <trans-unit id="2ed964d488a18629e5189d1ef4f5ddc3e0e84362" translate="yes" xml:space="preserve">
          <source>Shigeru Hanada &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:shigeru.hanada@gmail.com&quot;&gt;shigeru.hanada@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">시게루 하나 다 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:shigeru.hanada@gmail.com&quot;&gt;shigeru.hanada@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d33a942717635731a46b5d50f82c6b059874f0c2" translate="yes" xml:space="preserve">
          <source>Short Option</source>
          <target state="translated">짧은 옵션</target>
        </trans-unit>
        <trans-unit id="a6bddca4094838cb2e61e94daf11b2b4cc784a24" translate="yes" xml:space="preserve">
          <source>Short Options</source>
          <target state="translated">짧은 옵션</target>
        </trans-unit>
        <trans-unit id="ef7e415769ea172bce2213c07734e8903372ed1e" translate="yes" xml:space="preserve">
          <source>Short form of &lt;code&gt;zulu&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;zulu&lt;/code&gt; 짧은 형태</target>
        </trans-unit>
        <trans-unit id="de3ce5331f63c72577518f7528978506dc16d741" translate="yes" xml:space="preserve">
          <source>Short-term share/exclusive page-level locks are used for read/write access. Locks are released immediately after each index row is fetched or inserted. But note that insertion of a GIN-indexed value usually produces several index key insertions per row, so GIN might do substantial work for a single value's insertion.</source>
          <target state="translated">단기 공유 / 독점 페이지 수준 잠금은 읽기 / 쓰기 액세스에 사용됩니다. 각 인덱스 행을 가져 오거나 삽입 한 직후에 잠금이 해제됩니다. 그러나 GIN 인덱싱 된 값을 삽입하면 일반적으로 행당 여러 개의 인덱스 키 삽입이 생성되므로 GIN은 단일 값 삽입에 상당한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c90e10c04766b36c2f74bf105975100a7e1dcf9" translate="yes" xml:space="preserve">
          <source>Short-term share/exclusive page-level locks are used for read/write access. Locks are released immediately after each index row is fetched or inserted. These index types provide the highest concurrency without deadlock conditions.</source>
          <target state="translated">단기 공유 / 독점 페이지 수준 잠금은 읽기 / 쓰기 액세스에 사용됩니다. 각 인덱스 행을 가져 오거나 삽입 한 직후에 잠금이 해제됩니다. 이러한 인덱스 유형은 교착 상태없이 최고의 동시성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3fd7f6da3aeb5f90c1d6f0a2df406e91992bb3cd" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;pg_relation_size(..., 'main')&lt;/code&gt;</source>
          <target state="translated">속기에 대한 &lt;code&gt;pg_relation_size(..., 'main')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c31c3c4c5cf335124cdfd61e93866afd5dad378" translate="yes" xml:space="preserve">
          <source>Show all settings:</source>
          <target state="translated">모든 설정 표시 :</target>
        </trans-unit>
        <trans-unit id="6a9084f3875ffc056911648550cc631358f302b2" translate="yes" xml:space="preserve">
          <source>Show help about clusterdb command line arguments, and exit.</source>
          <target state="translated">clusterdb 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="6d4dd3a0c50ed2654b818661c167f2a3bd6b9124" translate="yes" xml:space="preserve">
          <source>Show help about createdb command line arguments, and exit.</source>
          <target state="translated">createdb 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="3a5af20a7c6bf20f0aa15a095d7f9b0297426bcb" translate="yes" xml:space="preserve">
          <source>Show help about createuser command line arguments, and exit.</source>
          <target state="translated">createuser 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="b359d0e0d247bffc5abeb2eb2a1eed9cefe95d23" translate="yes" xml:space="preserve">
          <source>Show help about dropdb command line arguments, and exit.</source>
          <target state="translated">dropdb 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="85ad7006e83f3b7cdc3b9a444ee647c2693c3e62" translate="yes" xml:space="preserve">
          <source>Show help about dropuser command line arguments, and exit.</source>
          <target state="translated">dropuser 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="6ca705ddc437a08690f3b2633d651eeb6c7221e6" translate="yes" xml:space="preserve">
          <source>Show help about ecpg command line arguments, and exit.</source>
          <target state="translated">ecpg 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="73715df766764994de623a68abf14e48f23f7349" translate="yes" xml:space="preserve">
          <source>Show help about initdb command line arguments, and exit.</source>
          <target state="translated">initdb 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="b84593990bc08ba01da4988c0f7e73c741946a7d" translate="yes" xml:space="preserve">
          <source>Show help about pg_archivecleanup command line arguments, and exit.</source>
          <target state="translated">pg_archivecleanup 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="b4aceb4979d50ee44a118b0fce69d3be44ec4ba6" translate="yes" xml:space="preserve">
          <source>Show help about pg_basebackup command line arguments, and exit.</source>
          <target state="translated">pg_basebackup 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="3e3aa5c6fa25a6cadefaf4bde59df7c1d6b1d8f5" translate="yes" xml:space="preserve">
          <source>Show help about pg_checksums command line arguments, and exit.</source>
          <target state="translated">pg_checksums 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="ea3847703c10ba685b57506f2a33ef0fc22ccf08" translate="yes" xml:space="preserve">
          <source>Show help about pg_config command line arguments, and exit.</source>
          <target state="translated">pg_config 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="3bac1d489e9cf15b27f7a1475ea4553db014b689" translate="yes" xml:space="preserve">
          <source>Show help about pg_ctl command line arguments, and exit.</source>
          <target state="translated">pg_ctl 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="25344abf0da27426c6a81f8477775fd5857dacb6" translate="yes" xml:space="preserve">
          <source>Show help about pg_dump command line arguments, and exit.</source>
          <target state="translated">pg_dump 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="252f4c6458149db7367df4f024be1c1aa53d70c4" translate="yes" xml:space="preserve">
          <source>Show help about pg_dumpall command line arguments, and exit.</source>
          <target state="translated">pg_dumpall 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="a7bc13eb0622c3f124b5ba3911a6618b4f4f0f4c" translate="yes" xml:space="preserve">
          <source>Show help about pg_isready command line arguments, and exit.</source>
          <target state="translated">pg_isready 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="d102b7d8e69189b6d4db79b4aaf624da2a4f00b9" translate="yes" xml:space="preserve">
          <source>Show help about pg_receivewal command line arguments, and exit.</source>
          <target state="translated">pg_receivewal 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e510900385b0c15bce2d9ea628171cba6cfa7ee2" translate="yes" xml:space="preserve">
          <source>Show help about pg_recvlogical command line arguments, and exit.</source>
          <target state="translated">pg_recvlogical 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="7a78c16a92d9fcb81c65c7e94b3011da393d2eae" translate="yes" xml:space="preserve">
          <source>Show help about pg_restore command line arguments, and exit.</source>
          <target state="translated">pg_restore 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="cecd50c76204357040439f99b90a74d321e243c0" translate="yes" xml:space="preserve">
          <source>Show help about pg_test_fsync command line arguments, and exit.</source>
          <target state="translated">pg_test_fsync 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="9b05d99c0a7e9019926f42b70f6aae6818336643" translate="yes" xml:space="preserve">
          <source>Show help about pg_test_timing command line arguments, and exit.</source>
          <target state="translated">pg_test_timing 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="90fc449e038dd0721a4e2b2ca966300d2d459ad5" translate="yes" xml:space="preserve">
          <source>Show help about pg_verifybackup command line arguments, and exit.</source>
          <target state="translated">pg_verifybackup 명령 줄 인수에 대한 도움말을 표시하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="1e3719f3789034db8c05fbd718aacfde8b5aaeef" translate="yes" xml:space="preserve">
          <source>Show help about pg_waldump command line arguments, and exit.</source>
          <target state="translated">pg_waldump 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="42fd77de24cc2823d795b8d22114a540dcd7fe80" translate="yes" xml:space="preserve">
          <source>Show help about pgbench command line arguments, and exit.</source>
          <target state="translated">pgbench 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="0946fc1a8adf084a5eb44987caeef6ba091a830f" translate="yes" xml:space="preserve">
          <source>Show help about postgres command line arguments, and exit.</source>
          <target state="translated">postgres 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="eebcfe60f222ff4e3652f621ababf859ea73c31b" translate="yes" xml:space="preserve">
          <source>Show help about psql and exit. The optional &lt;code&gt;topic&lt;/code&gt; parameter (defaulting to &lt;code&gt;options&lt;/code&gt;) selects which part of psql is explained: &lt;code&gt;commands&lt;/code&gt; describes psql's backslash commands; &lt;code&gt;options&lt;/code&gt; describes the command-line options that can be passed to psql; and &lt;code&gt;variables&lt;/code&gt; shows help about psql configuration variables.</source>
          <target state="translated">psql에 대한 도움말을 표시하고 종료하십시오. 선택적 &lt;code&gt;topic&lt;/code&gt; 매개 변수 (기본값은 &lt;code&gt;options&lt;/code&gt; )는 psql의 어느 부분을 설명 할지 선택합니다. &lt;code&gt;commands&lt;/code&gt; 은 psql의 백 슬래시 명령을 설명합니다. &lt;code&gt;options&lt;/code&gt; 는 psql에 전달할 수있는 명령 줄 옵션을 설명합니다. 및 &lt;code&gt;variables&lt;/code&gt; psql의 구성 변수에 대한 쇼 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ba3d23f2597556381797d0c6c8bb3e512d3daa97" translate="yes" xml:space="preserve">
          <source>Show help about reindexdb command line arguments, and exit.</source>
          <target state="translated">reindexdb 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="7e19aa78e67104bf85a432189f2c47920bedbcc9" translate="yes" xml:space="preserve">
          <source>Show help about vacuumdb command line arguments, and exit.</source>
          <target state="translated">vacuumdb 명령 행 인수에 대한 도움말을 표시하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="afb15fc44cb6eec9c1fdc80debd70adfa40b4f5c" translate="yes" xml:space="preserve">
          <source>Show help, then exit.</source>
          <target state="translated">도움말을 표시 한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="853b3853482eccbc21580256609af5ca7ba32698" translate="yes" xml:space="preserve">
          <source>Show progress report every &lt;code&gt;sec&lt;/code&gt; seconds. The report includes the time since the beginning of the run, the TPS since the last report, and the transaction latency average and standard deviation since the last report. Under throttling (&lt;code&gt;-R&lt;/code&gt;), the latency is computed with respect to the transaction scheduled start time, not the actual transaction beginning time, thus it also includes the average schedule lag time.</source>
          <target state="translated">진행률 표시는 모든보고 &lt;code&gt;sec&lt;/code&gt; 초. 이 보고서에는 실행 시작 이후의 시간, 마지막 보고서 이후의 TPS 및 마지막 보고서 이후의 트랜잭션 대기 시간 평균 및 표준 편차가 포함됩니다. 제한 ( &lt;code&gt;-R&lt;/code&gt; )에서 대기 시간은 실제 트랜잭션 시작 시간이 아니라 트랜잭션 예약 시작 시간과 관련하여 계산되므로 평균 일정 지연 시간도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="83b30fb3302b0bc6889504472d07955588eb075d" translate="yes" xml:space="preserve">
          <source>Show the actual code of builtin script &lt;code&gt;scriptname&lt;/code&gt; on stderr, and exit immediately.</source>
          <target state="translated">stderr 에 내장 스크립트 &lt;code&gt;scriptname&lt;/code&gt; 의 실제 코드를 표시하고 즉시 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="ed713b56989add97be271f9656a275850020dfc7" translate="yes" xml:space="preserve">
          <source>Show the current setting of the parameter &lt;code&gt;DateStyle&lt;/code&gt;:</source>
          <target state="translated">매개 변수 &lt;code&gt;DateStyle&lt;/code&gt; 의 현재 설정을 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd59602fbf15ca57f257b03685c081bb8613fab2" translate="yes" xml:space="preserve">
          <source>Show the current setting of the parameter &lt;code&gt;geqo&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;geqo&lt;/code&gt; 매개 변수의 현재 설정을 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="266672d0cc93e22ed4bf63fe8c0f659334e863a2" translate="yes" xml:space="preserve">
          <source>Show the values of all configuration parameters, with descriptions.</source>
          <target state="translated">모든 구성 매개 변수의 값을 설명과 함께 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="49b5cec2f994c16948c97011500b3790384813f9" translate="yes" xml:space="preserve">
          <source>Showing the Server Status</source>
          <target state="translated">서버 상태 표시</target>
        </trans-unit>
        <trans-unit id="03e04d17e9625f007a5930f6dbef22dbb7475bb6" translate="yes" xml:space="preserve">
          <source>Shows a list of all PostgreSQL large objects currently stored in the database, along with any comments provided for them.</source>
          <target state="translated">데이터베이스에 현재 저장된 모든 PostgreSQL 대형 객체의 목록과 함께 제공된 주석이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a2bbeeef18c7760abbd737473fd2d13115130d8" translate="yes" xml:space="preserve">
          <source>Shows help about pg_basebackup command line arguments, and exits.</source>
          <target state="translated">pg_basebackup 명령 줄 인수에 대한 도움말을 표시하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="011ca580c53f19f685a47339e8e97c8581f4ac28" translate="yes" xml:space="preserve">
          <source>Shows help information. The optional &lt;code&gt;topic&lt;/code&gt; parameter (defaulting to &lt;code&gt;commands&lt;/code&gt;) selects which part of psql is explained: &lt;code&gt;commands&lt;/code&gt; describes psql's backslash commands; &lt;code&gt;options&lt;/code&gt; describes the command-line options that can be passed to psql; and &lt;code&gt;variables&lt;/code&gt; shows help about psql configuration variables.</source>
          <target state="translated">도움말 정보를 표시합니다. 선택적 &lt;code&gt;topic&lt;/code&gt; 매개 변수 (기본값은 &lt;code&gt;commands&lt;/code&gt; )는 psql의 어느 부분을 설명 할지 선택합니다. &lt;code&gt;commands&lt;/code&gt; 은 psql의 백 슬래시 명령을 설명합니다. &lt;code&gt;options&lt;/code&gt; 는 psql에 전달할 수있는 명령 줄 옵션을 설명합니다. 및 &lt;code&gt;variables&lt;/code&gt; psql의 구성 변수에 대한 쇼 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="45ec1a5a1006c75578b3139ef6d7ae2ac55d7cd0" translate="yes" xml:space="preserve">
          <source>Shows the copyright and distribution terms of PostgreSQL.</source>
          <target state="translated">PostgreSQL의 저작권 및 배포 조건을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6a47b6d887b45dd7212c15f40c6ff8a8aae869b5" translate="yes" xml:space="preserve">
          <source>Shows the database's locale setting for character classification. At present, this parameter can be shown but not set, because the setting is determined at database creation time.</source>
          <target state="translated">문자 분류에 대한 데이터베이스의 로케일 설정을 표시합니다. 현재이 설정은 데이터베이스 작성 시간에 결정되므로이 매개 변수를 표시 할 수는 있지만 설정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ac8c135c4c95d185f7579e7d5ccb0427fc13a39" translate="yes" xml:space="preserve">
          <source>Shows the database's locale setting for collation (text ordering). At present, this parameter can be shown but not set, because the setting is determined at database creation time.</source>
          <target state="translated">데이터 정렬 (텍스트 순서)에 대한 데이터베이스의 로캘 설정을 표시합니다. 현재이 설정은 데이터베이스 작성 시간에 결정되므로이 매개 변수를 표시 할 수는 있지만 설정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd25d10b3cec124bfdabf6a423610ed5000cc105" translate="yes" xml:space="preserve">
          <source>Shows the description (that is, the column names and data types) of the result of the current query buffer. The query is not actually executed; however, if it contains some type of syntax error, that error will be reported in the normal way.</source>
          <target state="translated">현재 쿼리 버퍼의 결과에 대한 설명 (즉, 열 이름 및 데이터 유형)을 표시합니다. 쿼리는 실제로 실행되지 않습니다. 그러나 일부 유형의 구문 오류가 포함 된 경우 해당 오류는 일반적인 방식으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="21b4282cfebef6d54a7e8c50989b472f07da30c2" translate="yes" xml:space="preserve">
          <source>Shows the descriptions of objects of type &lt;code&gt;constraint&lt;/code&gt;, &lt;code&gt;operator class&lt;/code&gt;, &lt;code&gt;operator family&lt;/code&gt;, &lt;code&gt;rule&lt;/code&gt;, and &lt;code&gt;trigger&lt;/code&gt;. All other comments may be viewed by the respective backslash commands for those object types.</source>
          <target state="translated">&lt;code&gt;constraint&lt;/code&gt; 유형 , &lt;code&gt;operator class&lt;/code&gt; , &lt;code&gt;operator family&lt;/code&gt; , &lt;code&gt;rule&lt;/code&gt; 및 &lt;code&gt;trigger&lt;/code&gt; 의 객체에 대한 설명을 표시합니다 . 다른 모든 주석은 해당 객체 유형에 대한 해당 백 슬래시 명령으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed26ff0945bae892464be83c6d55ff11dcdfa9c2" translate="yes" xml:space="preserve">
          <source>Shows the number of bytes used to store any individual data value. If applied directly to a table column value, this reflects any compression that was done.</source>
          <target state="translated">개별 데이터 값을 저장하는 데 사용되는 바이트 수를 표시합니다. 테이블 열 값에 직접 적용하면 수행 된 압축이 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="1032e9154653a6dd5bf55d7799b107ba3d8815bc" translate="yes" xml:space="preserve">
          <source>Shows the server's version number.</source>
          <target state="translated">서버의 버전 번호를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a8d534909c6977fe5e3f9d9d97b23b556650d2a4" translate="yes" xml:space="preserve">
          <source>Shows the server-side character set encoding. At present, this parameter can be shown but not set, because the encoding is determined at database creation time.</source>
          <target state="translated">서버 측 문자 세트 인코딩을 표시합니다. 현재 인코딩은 데이터베이스 작성시 결정되므로이 매개 변수는 표시 할 수 있지만 설정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="608848ac8eb224447f6517c28fd5b5db42577e53" translate="yes" xml:space="preserve">
          <source>Shut down the old server:</source>
          <target state="translated">이전 서버를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e17f9efd0805c8246331cb3ab6203ca24fa0a685" translate="yes" xml:space="preserve">
          <source>Shutting Down the Server</source>
          <target state="translated">서버 종료</target>
        </trans-unit>
        <trans-unit id="21bb0f35c155c2673dd310a09063d86ab45f2948" translate="yes" xml:space="preserve">
          <source>Sign of the argument (-1, 0, or +1)</source>
          <target state="translated">인수 부호 (-1, 0 또는 +1)</target>
        </trans-unit>
        <trans-unit id="8a65d66a4dc5e30365f03511181a1724147283b7" translate="yes" xml:space="preserve">
          <source>Signal another backend to cancel a query or terminate its session.</source>
          <target state="translated">쿼리를 취소하거나 세션을 종료하도록 다른 백엔드에 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b7c6185becfa7f658c2ed1686ee7ef751af777ca" translate="yes" xml:space="preserve">
          <source>Signals the log-file manager to switch to a new output file immediately. This works only when the built-in log collector is running, since otherwise there is no log-file manager subprocess.</source>
          <target state="translated">로그 파일 관리자에게 즉시 새 출력 파일로 전환하도록 알립니다. 내장 로그 콜렉터가 실행 중일 때만 작동합니다. 그렇지 않으면 로그 파일 관리자 서브 프로세스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f32be1dc74166373c988ec03b0bd86f0a576919" translate="yes" xml:space="preserve">
          <source>Signature</source>
          <target state="translated">Signature</target>
        </trans-unit>
        <trans-unit id="12bdee3f61d46761159d41e97b863d2f61d29c72" translate="yes" xml:space="preserve">
          <source>Signed integer</source>
          <target state="translated">부호있는 정수</target>
        </trans-unit>
        <trans-unit id="c98e235c841706a6cbee5f9d1606bb1993e58386" translate="yes" xml:space="preserve">
          <source>Significant revisions to the XML-related specifications in ISO/IEC 9075-14 (SQL/XML) were introduced with SQL:2006. PostgreSQL's implementation of the XML data type and related functions largely follows the earlier 2003 edition, with some borrowing from later editions. In particular:</source>
          <target state="translated">ISO / IEC 9075-14 (SQL / XML)의 XML 관련 사양에 대한 중요한 수정 사항이 SQL : 2006에 도입되었습니다. XML 데이터 형식 및 관련 기능에 대한 PostgreSQL의 구현은 대부분 2003 년 초판을 따르며 일부는 차 기판에서 빌려옵니다. 특히:</target>
        </trans-unit>
        <trans-unit id="c26865b7acf062340bd07b2839d9d6963defdb29" translate="yes" xml:space="preserve">
          <source>Similar considerations apply to generated columns. Stored generated columns are computed on insert or update on the local PostgreSQL server and handed to the foreign-data wrapper for writing out to the foreign data store, but it is not enforced that a query of the foreign table returns values for stored generated columns that are consistent with the generation expression. Again, this might result in incorrect query results.</source>
          <target state="translated">생성 된 열에도 비슷한 고려 사항이 적용됩니다. 저장된 생성 된 열은 로컬 PostgreSQL 서버에서 삽입 또는 업데이트시 계산되고 외부 데이터 저장소에 기록하기 위해 외부 데이터 래퍼로 전달되지만 외부 테이블의 쿼리가 저장된 생성 된 열의 값을 반환하도록 강제되지는 않습니다. 세대 표현과 일치합니다. 다시 이로 인해 잘못된 쿼리 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a8444e4e9c13437ed15e7447381867a17698dd8" translate="yes" xml:space="preserve">
          <source>Similar syntactic issues apply whenever you select a field from a composite value. For instance, to select just one field from the result of a function that returns a composite value, you'd need to write something like:</source>
          <target state="translated">복합 값에서 필드를 선택할 때마다 유사한 구문 문제가 적용됩니다. 예를 들어, 복합 값을 반환하는 함수의 결과에서 하나의 필드 만 선택하려면 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf7248108802a5f1079e62cb2f90417d0e6b9f3f" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;effective_io_concurrency&lt;/code&gt;, but used for maintenance work that is done on behalf of many client sessions.</source>
          <target state="translated">&lt;code&gt;effective_io_concurrency&lt;/code&gt; 와 유사 하지만 많은 클라이언트 세션을 대신하여 수행되는 유지 보수 작업에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82d360ed3bd0431e461a2955b0ee547f41f83c52" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;index_column_name&lt;/code&gt;, but used to infer expressions on &lt;code&gt;table_name&lt;/code&gt; columns appearing within index definitions (not simple columns). Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on any column appearing within &lt;code&gt;index_expression&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;index_column_name&lt;/code&gt; 과 유사 하지만 인덱스 정의 내에 나타나는 &lt;code&gt;table_name&lt;/code&gt; 열에 대한 표현식을 유추하는 데 사용됩니다 (간단한 열 아님). &lt;code&gt;CREATE INDEX&lt;/code&gt; 형식을 따릅니다 . &lt;code&gt;index_expression&lt;/code&gt; 내에 나타나는 열에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ea1336797aa51dc0636abf33f41b9a4a9fbb1870" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;pg_stat_all_tables&lt;/code&gt;, but counts actions taken so far within the current transaction (which are &lt;em&gt;not&lt;/em&gt; yet included in &lt;code&gt;pg_stat_all_tables&lt;/code&gt; and related views). The columns for numbers of live and dead rows and vacuum and analyze actions are not present in this view.</source>
          <target state="translated">&lt;code&gt;pg_stat_all_tables&lt;/code&gt; 와 유사 하지만 현재 트랜잭션 내에서 지금까지 수행 한 작업 ( &lt;code&gt;pg_stat_all_tables&lt;/code&gt; 및 관련보기 에는 아직 포함 &lt;em&gt;되지&lt;/em&gt; 않은 )을 계산합니다. 라이브 및 데드 행 수 및 진공 및 분석 조치에 대한 열은이보기에 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e70de572f476159a3244afa139c9185457204d2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;pg_stat_user_functions&lt;/code&gt;, but counts only calls during the current transaction (which are &lt;em&gt;not&lt;/em&gt; yet included in &lt;code&gt;pg_stat_user_functions&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;pg_stat_user_functions&lt;/code&gt; 와 유사 하지만 현재 트랜잭션 ( &lt;code&gt;pg_stat_user_functions&lt;/code&gt; 에 포함 &lt;em&gt;되지&lt;/em&gt; 않은) 동안의 호출 만 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e689a8890e7e6a1af5ab0e817474640d50617090" translate="yes" xml:space="preserve">
          <source>Similarly we can add a new partition to handle new data. We can create an empty partition in the partitioned table just as the original partitions were created above:</source>
          <target state="translated">마찬가지로 새 데이터를 처리하기 위해 새 파티션을 추가 할 수 있습니다. 원래 파티션이 위에서 생성 된 것처럼 파티션 된 테이블에 빈 파티션을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bda45196d8678e0790851fc9e9c1fa7f966b177" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY-FEEDBACK&quot;&gt;hot_standby_feedback&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; provide protection against relevant rows being removed by vacuum, but the former provides no protection during any time period when the standby is not connected, and the latter often needs to be set to a high value to provide adequate protection. Replication slots overcome these disadvantages.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY-FEEDBACK&quot;&gt;hot_standby_feedback&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; 는 진공에 의해 제거되는 관련 행에 대한 보호 기능을 제공하지만 전자는 대기가 연결되지 않은 모든 시간 동안 보호 기능을 제공하지 않으며 적절한 보호를 제공하기 위해 후자를 높은 값으로 설정해야하는 경우가 종종 있습니다. 복제 슬롯은 이러한 단점을 극복합니다.</target>
        </trans-unit>
        <trans-unit id="4798e0a3d47ed876bcabb4cbfef5e1505f1e94dd" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;pg_walfile_name&lt;/code&gt; extracts just the write-ahead log file name. When the given write-ahead log location is exactly at a write-ahead log file boundary, both these functions return the name of the preceding write-ahead log file. This is usually the desired behavior for managing write-ahead log archiving behavior, since the preceding file is the last one that currently needs to be archived.</source>
          <target state="translated">마찬가지로 &lt;code&gt;pg_walfile_name&lt;/code&gt; 은 미리 쓰기 로그 파일 이름 만 추출합니다. 지정된 미리 쓰기 로그 위치가 미리 쓰기 로그 파일 경계에 있으면이 두 함수는 이전 미리 쓰기 로그 파일의 이름을 반환합니다. 선행 파일이 현재 아카이브되어야하는 마지막 파일이므로 일반적으로 미리 쓰기 로그 아카이브 동작을 관리하기 위해 원하는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="aefb1fe7f7adc82a8dccb50c9b3ec4c8e66f41ea" translate="yes" xml:space="preserve">
          <source>Similarly, all of the following functions perform matching case-insensitively if their arguments are &lt;code&gt;citext&lt;/code&gt;:</source>
          <target state="translated">마찬가지로, 다음 함수는 모두 인수가 &lt;code&gt;citext&lt;/code&gt; 인 경우 대소 문자를 구분하지 않고 일치를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="ebb7dcd0160bb0e060c55b65d95fffb0cf4dedd0" translate="yes" xml:space="preserve">
          <source>Similarly, arrays with equal numbers of elements are compared in the order:</source>
          <target state="translated">마찬가지로, 요소 수가 같은 배열은 순서대로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="70d56d24501f3dfc0a8d03d95fcdf2a728bdbc63" translate="yes" xml:space="preserve">
          <source>Similarly, if a conflicting valid row has been deleted by an as-yet-uncommitted transaction, the would-be inserter must wait for that transaction to commit or abort, and then repeat the test.</source>
          <target state="translated">마찬가지로, 아직 커밋되지 않은 트랜잭션에 의해 충돌하는 유효한 행이 삭제 된 경우 해당 삽입 기는 해당 트랜잭션이 커밋 또는 중단 될 때까지 기다렸다가 테스트를 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="154c8c237f68225822b54cc980016061e8e3ab90" translate="yes" xml:space="preserve">
          <source>Similarly, if we were to specify that &lt;code&gt;cities&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt;&lt;code&gt;REFERENCES&lt;/code&gt; some other table, this constraint would not automatically propagate to &lt;code&gt;capitals&lt;/code&gt;. In this case you could work around it by manually adding the same &lt;code&gt;REFERENCES&lt;/code&gt; constraint to &lt;code&gt;capitals&lt;/code&gt;.</source>
          <target state="translated">마찬가지로, 우리가 그 &lt;code&gt;cities&lt;/code&gt; 를 지정한다면 . &lt;code&gt;name&lt;/code&gt; &lt;code&gt;REFERENCES&lt;/code&gt; 다른 테이블에서이 제한 조건은 자동으로 &lt;code&gt;capitals&lt;/code&gt; 전파되지 않습니다 . 이 경우 동일한 &lt;code&gt;REFERENCES&lt;/code&gt; 제약 조건을 &lt;code&gt;capitals&lt;/code&gt; 로 수동으로 추가하면이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42012dcf3f416bcc40ca1448b7704c866425ef87" translate="yes" xml:space="preserve">
          <source>Similarly, the elements of the &lt;code&gt;ORDER BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a statement-level &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/a&gt; clause, except that the expressions are always taken as simple expressions and never the name or number of an output column.</source>
          <target state="translated">마찬가지로, &lt;code&gt;ORDER BY&lt;/code&gt; 목록의 요소는 명령문 레벨 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/a&gt; 절의 요소와 거의 동일한 방식으로 해석됩니다 . 단, 표현식은 항상 단순 표현식으로 간주되며 출력 열의 이름이나 번호가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fe1287a923f84fb8e9e9c0365246beccb582f0a1" translate="yes" xml:space="preserve">
          <source>Similarly, the elements of the &lt;code&gt;ORDER BY&lt;/code&gt; list are interpreted in much the same fashion as elements of an &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;, except that the expressions are always taken as simple expressions and never the name or number of an output column.</source>
          <target state="translated">마찬가지로, &lt;code&gt;ORDER BY&lt;/code&gt; 목록의 요소 는 표현식이 항상 간단한 표현식으로 취해지고 출력 열의 이름이나 번호가 아닌 것을 제외하고 는 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 절의&lt;/a&gt; 요소와 거의 동일한 방식으로 해석 됩니다.</target>
        </trans-unit>
        <trans-unit id="7d3024f9a331118f7440ffabd1a19e023456c32f" translate="yes" xml:space="preserve">
          <source>Similarly, when attaching a new partition it may be scanned to verify that existing rows meet the partition constraint.</source>
          <target state="translated">마찬가지로, 새 파티션을 연결할 때 기존 행이 파티션 제한 조건을 충족하는지 확인하기 위해 스캔 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48cb40a4f0c379a4df44a747937ffa89e7d2973" translate="yes" xml:space="preserve">
          <source>Simon Tatham</source>
          <target state="translated">사이먼 테이텀</target>
        </trans-unit>
        <trans-unit id="589d8785493e5221497663234de1727f7cba786b" translate="yes" xml:space="preserve">
          <source>Simple example using &lt;code&gt;btree_gist&lt;/code&gt; instead of &lt;code&gt;btree&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;btree&lt;/code&gt; 대신 &lt;code&gt;btree_gist&lt;/code&gt; 를 사용하는 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="563523c7fb9aeb90cd3ca9914f9f94d5abfe8ef0" translate="yes" xml:space="preserve">
          <source>Simple example:</source>
          <target state="translated">간단한 예 :</target>
        </trans-unit>
        <trans-unit id="c415d561a9b9919ddec87d4fd9e66273eabb01ba" translate="yes" xml:space="preserve">
          <source>Simple views are automatically updatable: the system will allow &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements to be used on the view in the same way as on a regular table. A view is automatically updatable if it satisfies all of the following conditions:</source>
          <target state="translated">단순 뷰는 자동으로 갱신 가능합니다. 시스템은 일반 테이블과 동일한 방식으로 뷰에서 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 문을 사용할 수 있도록합니다. 다음 조건을 모두 만족하면보기를 자동으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e03f20a90b59b059ccb5f39b63fa73e127da8ce9" translate="yes" xml:space="preserve">
          <source>Simplified Chinese</source>
          <target state="translated">중국어 간체</target>
        </trans-unit>
        <trans-unit id="43411abb7d1c9c7f47655d69079a79307e822d3d" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;CRAAAA&lt;/code&gt; appears in the list of MCVs, the selectivity is merely the corresponding entry in the list of most common frequencies (MCFs):</source>
          <target state="translated">&lt;code&gt;CRAAAA&lt;/code&gt; 가 MCV 목록에 표시 되므로 선택성은 가장 일반적인 주파수 (MCF) 목록의 해당 항목 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="89f3cdc5948c45f8197dab43b045aed5e4d97049" translate="yes" xml:space="preserve">
          <source>Since LDAP often uses commas and spaces to separate the different parts of a DN, it is often necessary to use double-quoted parameter values when configuring LDAP options, as shown in the examples.</source>
          <target state="translated">LDAP는 종종 쉼표와 공백을 사용하여 DN의 다른 부분을 구분하므로 LDAP 옵션을 구성 할 때 예에 표시된 것처럼 큰 따옴표로 묶은 매개 변수 값을 사용해야하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bf1354d7ff8db3b8a4186015b13543b3510c3e8" translate="yes" xml:space="preserve">
          <source>Since PostgreSQL 8.1, the concepts of users and groups have been unified into a single kind of entity called a role. It is therefore no longer necessary to use the keyword &lt;code&gt;GROUP&lt;/code&gt; to identify whether a grantee is a user or a group. &lt;code&gt;GROUP&lt;/code&gt; is still allowed in the command, but it is a noise word.</source>
          <target state="translated">PostgreSQL 8.1 이후로, 사용자와 그룹의 개념은 역할이라고하는 단일 종류의 개체로 통합되었습니다. 따라서 더 이상 &lt;code&gt;GROUP&lt;/code&gt; 키워드를 사용하여 피부 여자가 사용자인지 그룹 인지 식별 ​​할 필요가 없습니다 . &lt;code&gt;GROUP&lt;/code&gt; 은 여전히 ​​명령에서 허용되지만 의미없는 단어입니다.</target>
        </trans-unit>
        <trans-unit id="8be3314cdf4b87d9c93a33ad52e0b7f880da0dc8" translate="yes" xml:space="preserve">
          <source>Since SQL:2008, the SQL standard includes a &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator that performs pattern matching according to the XQuery regular expression standard. PostgreSQL does not yet implement this operator, but you can get very similar behavior using the &lt;code&gt;regexp_match()&lt;/code&gt; function, since XQuery regular expressions are quite close to the ARE syntax described above.</source>
          <target state="translated">SQL : 2008 이후, SQL 표준에는 XQuery 정규식 표준에 따라 패턴 일치를 수행 하는 &lt;code&gt;LIKE_REGEX&lt;/code&gt; 연산자가 포함됩니다 . PostgreSQL은 아직이 연산자를 구현하지 않지만 XQuery 정규 표현식은 위에서 설명한 ARE 구문 과 매우 유사하기 때문에 &lt;code&gt;regexp_match()&lt;/code&gt; 함수를 사용하여 매우 유사한 동작을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8625b9ba3949c7fe8554cb85d09fc8b9c86c2c79" translate="yes" xml:space="preserve">
          <source>Since a longer document has a greater chance of containing a query term it is reasonable to take into account document size, e.g., a hundred-word document with five instances of a search word is probably more relevant than a thousand-word document with five instances. Both ranking functions take an integer &lt;code&gt;normalization&lt;/code&gt; option that specifies whether and how a document's length should impact its rank. The integer option controls several behaviors, so it is a bit mask: you can specify one or more behaviors using &lt;code&gt;|&lt;/code&gt; (for example, &lt;code&gt;2|4&lt;/code&gt;).</source>
          <target state="translated">문서가 길수록 쿼리 용어를 포함 할 가능성이 높아 지므로 문서 크기를 고려하는 것이 합리적입니다. 예를 들어 5 개의 검색어가있는 백 단어 문서는 5 개의 인스턴스가있는 천 단어 문서보다 더 관련이있을 수 있습니다. . 두 순위 함수 모두 문서 길이가 순위에 영향을 미치는지 여부와 방법을 지정 하는 정수 &lt;code&gt;normalization&lt;/code&gt; 옵션을 사용합니다. integer 옵션은 여러 가지 동작을 제어하므로 비트 마스크입니다. &lt;code&gt;|&lt;/code&gt; (예 : &lt;code&gt;2|4&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ba0221ecb447121dfa5d71859ea140f8e5182c9" translate="yes" xml:space="preserve">
          <source>Since a thesaurus dictionary has the capability to recognize phrases it must remember its state and interact with the parser. A thesaurus dictionary uses these assignments to check if it should handle the next word or stop accumulation. The thesaurus dictionary must be configured carefully. For example, if the thesaurus dictionary is assigned to handle only the &lt;code&gt;asciiword&lt;/code&gt; token, then a thesaurus dictionary definition like &lt;code&gt;one 7&lt;/code&gt; will not work since token type &lt;code&gt;uint&lt;/code&gt; is not assigned to the thesaurus dictionary.</source>
          <target state="translated">동의어 사전에는 구문을 인식하는 기능이 있으므로 상태를 기억하고 파서와 상호 작용해야합니다. 시소러스 사전은 이러한 할당을 사용하여 다음 단어를 처리해야하는지 또는 누적을 중지해야하는지 확인합니다. 동의어 사전은 신중하게 구성해야합니다. 예를 들어 동의어 사전이 &lt;code&gt;asciiword&lt;/code&gt; 토큰 만 처리하도록 할당 된 경우 토큰 유형 &lt;code&gt;uint&lt;/code&gt; 가 동의어 사전 사전에 지정 되지 않으므로 &lt;code&gt;one 7&lt;/code&gt; 과 같은 동의어 사전 사전 이 작동 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd3c08e9538692e7696ad1a2f973281df6784b75" translate="yes" xml:space="preserve">
          <source>Since all query results from a unionized &lt;code&gt;SELECT&lt;/code&gt; statement must appear in a single set of columns, the types of the results of each &lt;code&gt;SELECT&lt;/code&gt; clause must be matched up and converted to a uniform set. Similarly, the result expressions of a &lt;code&gt;CASE&lt;/code&gt; construct must be converted to a common type so that the &lt;code&gt;CASE&lt;/code&gt; expression as a whole has a known output type. Some other constructs, such as &lt;code&gt;ARRAY[]&lt;/code&gt; and the &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; functions, likewise require determination of a common type for several subexpressions.</source>
          <target state="translated">통합 된 &lt;code&gt;SELECT&lt;/code&gt; 문의 모든 쿼리 결과 는 단일 열 집합에 나타나야하므로 각 &lt;code&gt;SELECT&lt;/code&gt; 절의 결과 유형을 일치시키고 균일 한 집합으로 변환해야합니다. 마찬가지로 &lt;code&gt;CASE&lt;/code&gt; 구문 의 결과 식은 전체 &lt;code&gt;CASE&lt;/code&gt; 식이 알려진 출력 형식을 갖도록 일반 형식으로 변환되어야합니다 . &lt;code&gt;ARRAY[]&lt;/code&gt; 및 &lt;code&gt;GREATEST&lt;/code&gt; 및 &lt;code&gt;LEAST&lt;/code&gt; 함수 와 같은 일부 다른 구조 도 마찬가지로 여러 하위 표현식에 대한 공통 유형을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5101ea15275034ff0ce451417a60ca5633f481de" translate="yes" xml:space="preserve">
          <source>Since all query results from a unionized &lt;code&gt;SELECT&lt;/code&gt; statement must appear in a single set of columns, the types of the results of each &lt;code&gt;SELECT&lt;/code&gt; clause must be matched up and converted to a uniform set. Similarly, the result expressions of a &lt;code&gt;CASE&lt;/code&gt; construct must be converted to a common type so that the &lt;code&gt;CASE&lt;/code&gt; expression as a whole has a known output type. The same holds for &lt;code&gt;ARRAY&lt;/code&gt; constructs, and for the &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; functions.</source>
          <target state="translated">통합 된 &lt;code&gt;SELECT&lt;/code&gt; 문의 모든 쿼리 결과 는 단일 열 집합에 나타나야하므로 각 &lt;code&gt;SELECT&lt;/code&gt; 절의 결과 유형 이 일치하고 균일 한 집합으로 변환되어야합니다. 마찬가지로 &lt;code&gt;CASE&lt;/code&gt; 구문 의 결과 표현식은 &lt;code&gt;CASE&lt;/code&gt; 표현식 전체가 알려진 출력 유형을 갖도록 공통 유형으로 변환되어야합니다 . &lt;code&gt;ARRAY&lt;/code&gt; 구문과 &lt;code&gt;GREATEST&lt;/code&gt; 및 &lt;code&gt;LEAST&lt;/code&gt; 함수에 대해서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="cf4e7ab3e0efadc8c42881e4a0616971f4a3af83" translate="yes" xml:space="preserve">
          <source>Since both key extraction of indexed values and representation of the key in BRIN are flexible, they may depend on user-specified parameters.</source>
          <target state="translated">인덱싱 된 값의 키 추출과 BRIN의 키 표현은 모두 유연하기 때문에 사용자 지정 매개 변수에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a6afc48828dbe04a5a1b22ccc137f1654951b7d" translate="yes" xml:space="preserve">
          <source>Since both key extraction of indexed values and representation of the key in GIN are flexible, they may depend on user-specified parameters.</source>
          <target state="translated">인덱싱 된 값의 키 추출과 GIN의 키 표현은 모두 유연하기 때문에 사용자 지정 매개 변수에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95899699fee940ede501c76669447789d29d1ce1" translate="yes" xml:space="preserve">
          <source>Since buffer manager locks are not taken to copy the buffer state data that the view will display, accessing &lt;code&gt;pg_buffercache&lt;/code&gt; view has less impact on normal buffer activity but it doesn't provide a consistent set of results across all buffers. However, we ensure that the information of each buffer is self-consistent.</source>
          <target state="translated">뷰가 표시 할 버퍼 상태 데이터를 복사하는 데 버퍼 관리자 잠금을 사용하지 않기 때문에 &lt;code&gt;pg_buffercache&lt;/code&gt; 뷰에 액세스 하는 것은 정상적인 버퍼 활동에 미치는 영향이 적지 만 모든 버퍼에서 일관된 결과 집합을 제공하지는 않습니다. 그러나 우리는 각 버퍼의 정보가 일관성이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="546529f4e3657ccae2446f6d0ea0308f1634f110" translate="yes" xml:space="preserve">
          <source>Since collection of statistics adds some overhead to query execution, the system can be configured to collect or not collect information. This is controlled by configuration parameters that are normally set in &lt;code&gt;postgresql.conf&lt;/code&gt;. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details about setting configuration parameters.)</source>
          <target state="translated">통계 수집은 쿼리 실행에 약간의 오버 헤드를 추가하므로 시스템은 정보를 수집하거나 수집하지 않도록 구성 할 수 있습니다. 이것은 일반적으로 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정된 구성 매개 변수에 의해 제어됩니다 . 구성 매개 변수 설정에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67645c499d8137256f449024e811a0f4513577c3" translate="yes" xml:space="preserve">
          <source>Since collection of statistics adds some overhead to query execution, the system can be configured to collect or not collect information. This is controlled by configuration parameters that are normally set in &lt;code&gt;postgresql.conf&lt;/code&gt;. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details about setting configuration parameters.)</source>
          <target state="translated">통계 수집은 쿼리 실행에 약간의 오버 헤드를 추가하므로 시스템은 정보를 수집하거나 수집하지 않도록 구성 할 수 있습니다. 이는 일반적으로 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정된 구성 매개 변수에 의해 제어됩니다 . ( 구성 매개 변수 설정에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1106b832d115f6cb6282d0cbe20ff8c3da3e4cde" translate="yes" xml:space="preserve">
          <source>Since colons can legally appear in SQL commands, an apparent attempt at interpolation (that is, &lt;code&gt;:name&lt;/code&gt;, &lt;code&gt;:'name'&lt;/code&gt;, or &lt;code&gt;:&quot;name&quot;&lt;/code&gt;) is not replaced unless the named variable is currently set. In any case, you can escape a colon with a backslash to protect it from substitution.</source>
          <target state="translated">콜론은 합법적으로 SQL 명령에 나타날 수 있으므로 명명 된 변수가 현재 설정되어 있지 않으면 보간 시도 (즉, &lt;code&gt;:name&lt;/code&gt; , &lt;code&gt;:'name'&lt;/code&gt; 또는 &lt;code&gt;:&quot;name&quot;&lt;/code&gt; )가 대체되지 않습니다. 어쨌든 백 슬래시로 콜론을 이스케이프하여 대체되지 않도록 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="298653261d4e2da3a9897d5b9600b182775e828e" translate="yes" xml:space="preserve">
          <source>Since different kinds of statistics might be appropriate for different kinds of data, &lt;code&gt;pg_statistic&lt;/code&gt; is designed not to assume very much about what sort of statistics it stores. Only extremely general statistics (such as nullness) are given dedicated columns in &lt;code&gt;pg_statistic&lt;/code&gt;. Everything else is stored in &amp;ldquo;slots&amp;rdquo;, which are groups of associated columns whose content is identified by a code number in one of the slot's columns. For more information see &lt;code&gt;src/include/catalog/pg_statistic.h&lt;/code&gt;.</source>
          <target state="translated">다른 종류의 통계는 다른 종류의 데이터에 적합 할 수 있기 때문에 &lt;code&gt;pg_statistic&lt;/code&gt; 은 어떤 종류의 통계를 저장하는지에 대해 크게 가정하지 않도록 설계되었습니다. 매우 일반적인 통계 (예 : nullness) 만 &lt;code&gt;pg_statistic&lt;/code&gt; 의 전용 열에 제공됩니다 . 그 밖의 모든 내용은 슬롯의 열 중 하나에서 코드 번호로 내용이 식별되는 관련 열 그룹 인 &quot;슬롯&quot;에 저장됩니다. 자세한 정보는 &lt;code&gt;src/include/catalog/pg_statistic.h&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67415d92cc320226f230127e74cb20a035aa08f5" translate="yes" xml:space="preserve">
          <source>Since foreign keys are implemented as triggers, setting this parameter to &lt;code&gt;replica&lt;/code&gt; also disables all foreign key checks, which can leave data in an inconsistent state if improperly used.</source>
          <target state="translated">외래 키는 트리거로 구현되므로이 매개 변수를 &lt;code&gt;replica&lt;/code&gt; 설정 하면 모든 외래 키 검사가 비활성화되어 잘못 사용하면 데이터가 일관성이없는 상태로 남을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5638279ed10f4ed2bb5eeeabd98eb092d6ef65" translate="yes" xml:space="preserve">
          <source>Since hashes are unordered data structures, field order and line layout aren't semantically significant. However, to maintain a consistent appearance, we set a few rules that are applied by the formatting script &lt;code&gt;reformat_dat_file.pl&lt;/code&gt;:</source>
          <target state="translated">해시는 순서가없는 데이터 구조이므로 필드 순서와 라인 레이아웃은 의미가 중요하지 않습니다. 그러나 일관된 모양을 유지하기 위해 형식화 스크립트 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 에 의해 적용되는 몇 가지 규칙을 설정했습니다 .</target>
        </trans-unit>
        <trans-unit id="56947fc240edc3c959fec40008ed4b043f4a55b1" translate="yes" xml:space="preserve">
          <source>Since multidimensional arrays must be rectangular, inner constructors at the same level must produce sub-arrays of identical dimensions. Any cast applied to the outer &lt;code&gt;ARRAY&lt;/code&gt; constructor propagates automatically to all the inner constructors.</source>
          <target state="translated">다차원 배열은 직사각형이어야하므로 같은 수준의 내부 생성자는 같은 차원의 하위 배열을 생성해야합니다. 외부 &lt;code&gt;ARRAY&lt;/code&gt; 생성자에 적용된 캐스트 는 모든 내부 생성자에게 자동으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="6918a0b90b7088d29e58c799c230b8d7458180d4" translate="yes" xml:space="preserve">
          <source>Since no connection is made when this option is set to &lt;code&gt;false&lt;/code&gt;, the tables are not subscribed, and so after you enable the subscription nothing will be replicated. It is required to run &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; in order for tables to be subscribed.</source>
          <target state="translated">이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 연결이 설정 되지 않으므로 테이블이 구독되지 않으므로 구독을 활성화 한 후에는 복제되지 않습니다. 테이블을 구독하려면 &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; 을 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35520ec628c2741d8fd046f2b3cb96e56df400fa" translate="yes" xml:space="preserve">
          <source>Since numeric constants with decimal points are initially assigned the type &lt;code&gt;numeric&lt;/code&gt;, the following query will require no type conversion and therefore might be slightly more efficient:</source>
          <target state="translated">소수점이있는 숫자 상수에는 처음에 &lt;code&gt;numeric&lt;/code&gt; 유형이 지정 되므로 다음 쿼리는 유형 변환이 필요하지 않으므로 약간 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4bf82794f73c7ce541429d778bec739ee3ffb6f" translate="yes" xml:space="preserve">
          <source>Since pg_dumpall calls pg_dump internally, some diagnostic messages will refer to pg_dump.</source>
          <target state="translated">pg_dumpall은 내부적으로 pg_dump를 호출하기 때문에 일부 진단 메시지는 pg_dump를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="6fdb38a8aa429db79e46e5c1e427dcd369ad7ca6" translate="yes" xml:space="preserve">
          <source>Since pg_dumpall reads tables from all databases you will most likely have to connect as a database superuser in order to produce a complete dump. Also you will need superuser privileges to execute the saved script in order to be allowed to add roles and create databases.</source>
          <target state="translated">pg_dumpall은 모든 데이터베이스에서 테이블을 읽으므로 완전한 덤프를 생성하려면 데이터베이스 수퍼 유저로 연결해야 할 것입니다. 또한 역할을 추가하고 데이터베이스를 만들려면 저장된 스크립트를 실행하려면 수퍼 유저 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a6373a2bb40076c8e7f65d74d1f21b0d82a94e6e" translate="yes" xml:space="preserve">
          <source>Since policy expressions are added to the user's query directly, they will be run with the rights of the user running the overall query. Therefore, users who are using a given policy must be able to access any tables or functions referenced in the expression or they will simply receive a permission denied error when attempting to query the table that has row-level security enabled. This does not change how views work, however. As with normal queries and views, permission checks and policies for the tables which are referenced by a view will use the view owner's rights and any policies which apply to the view owner.</source>
          <target state="translated">정책 표현식은 사용자의 쿼리에 직접 추가되므로 전체 쿼리를 실행하는 사용자의 권한으로 실행됩니다. 따라서 지정된 정책을 사용하는 사용자는 표현식에서 참조 된 테이블 또는 함수에 액세스 할 수 있어야합니다. 그렇지 않으면 행 레벨 보안이 사용 가능한 테이블을 쿼리하려고 할 때 권한 거부 오류가 발생합니다. 그러나 뷰 작동 방식은 변경되지 않습니다. 일반 쿼리 및 뷰와 마찬가지로 뷰에서 참조하는 테이블에 대한 권한 검사 및 정책은 뷰 소유자의 권한과 뷰 소유자에게 적용되는 모든 정책을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a333e96b1b276814ee5afd42350289a1a05356ee" translate="yes" xml:space="preserve">
          <source>Since system table names begin with &lt;code&gt;pg_&lt;/code&gt;, it is best to avoid such names to ensure that you won't suffer a conflict if some future version defines a system table named the same as your table. (With the default search path, an unqualified reference to your table name would then be resolved as the system table instead.) System tables will continue to follow the convention of having names beginning with &lt;code&gt;pg_&lt;/code&gt;, so that they will not conflict with unqualified user-table names so long as users avoid the &lt;code&gt;pg_&lt;/code&gt; prefix.</source>
          <target state="translated">시스템 테이블 이름은 &lt;code&gt;pg_&lt;/code&gt; 로 시작하므로 이후 버전에서 테이블과 동일한 시스템 테이블을 정의 할 경우 충돌이 발생하지 않도록 이러한 이름을 피하는 것이 가장 좋습니다. (기본 검색 경로를 사용하면 테이블 이름에 대한 규정되지 않은 참조가 시스템 테이블로 대신 해석됩니다.) 시스템 테이블은 &lt;code&gt;pg_&lt;/code&gt; 로 시작하는 이름을 갖는 규칙을 계속 따르 므로 규정되지 않은 사용자와 충돌하지 않습니다. 사용자가 &lt;code&gt;pg_&lt;/code&gt; 접두사 를 사용하지 않는 한 테이블 이름 .</target>
        </trans-unit>
        <trans-unit id="b2a157ff6943b51f82e8abe52b286fec37765c98" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;pg_hba.conf&lt;/code&gt; records are examined sequentially for each connection attempt, the order of the records is significant. Typically, earlier records will have tight connection match parameters and weaker authentication methods, while later records will have looser match parameters and stronger authentication methods. For example, one might wish to use &lt;code&gt;trust&lt;/code&gt; authentication for local TCP/IP connections but require a password for remote TCP/IP connections. In this case a record specifying &lt;code&gt;trust&lt;/code&gt; authentication for connections from 127.0.0.1 would appear before a record specifying password authentication for a wider range of allowed client IP addresses.</source>
          <target state="translated">이후 &lt;code&gt;pg_hba.conf&lt;/code&gt; 기록은 각 연결 시도에 순차적으로 조사되어, 기록의 순서가 중요하다. 일반적으로 이전 레코드는 연결 일치 매개 변수가 엄격하고 인증 방법이 약한 반면 나중에 레코드는 일치 매개 변수가 느리고 인증 방법이 강합니다. 예를 들어, 로컬 TCP / IP 연결에는 &lt;code&gt;trust&lt;/code&gt; 인증 을 사용 하지만 원격 TCP / IP 연결에는 암호가 필요합니다. 이 경우 127.0.0.1에서 연결에 대한 &lt;code&gt;trust&lt;/code&gt; 인증을 지정하는 레코드가 더 넓은 범위의 허용 된 클라이언트 IP 주소에 대한 비밀번호 인증을 지정하는 레코드 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f958cad737d4e0d36812e54ad5367cb224ed80eb" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;queryid&lt;/code&gt; hash value is computed on the post-parse-analysis representation of the queries, the opposite is also possible: queries with identical texts might appear as separate entries, if they have different meanings as a result of factors such as different &lt;code&gt;search_path&lt;/code&gt; settings.</source>
          <target state="translated">때문에 &lt;code&gt;queryid&lt;/code&gt; 해시 값이 질의 후 파싱 분석 표현에 계산되고, 그 반대도 가능하다 : 그들은 요인들의 결과로서 다른 의미를 갖는 경우, 동일한 텍스트와 질의는 다른 것처럼, 별도의 항목으로 표시 될 수 &lt;code&gt;search_path&lt;/code&gt; 의의 설정 .</target>
        </trans-unit>
        <trans-unit id="13c61675eb3d1018af99b38293ca322654b1b9aa" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;words&lt;/code&gt; table has been generated as a separate, static table, it will need to be periodically regenerated so that it remains reasonably up-to-date with the document collection. Keeping it exactly current is usually unnecessary.</source>
          <target state="translated">때문에 &lt;code&gt;words&lt;/code&gt; 테이블을 별도의 정적 테이블로 생성 된, 주기적으로 합리적이 최대 최신 문서 컬렉션에 남아 있도록 재생해야합니다. 정확하게 최신 상태를 유지하는 것은 일반적으로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="199cdfbed8830469169fdf887fd0ad4eb308081c" translate="yes" xml:space="preserve">
          <source>Since the columns all had different names, the parser automatically found which table they belong to. If there were duplicate column names in the two tables you'd need to &lt;em&gt;qualify&lt;/em&gt; the column names to show which one you meant, as in:</source>
          <target state="translated">열의 이름이 모두 다르기 때문에 구문 분석기는 해당 테이블이 속하는 테이블을 자동으로 찾았습니다. 중복 된 열 이름이 두 테이블에이 있다면 당신은해야 할 것 &lt;em&gt;자격&lt;/em&gt; 이 같이 의미 하나의 쇼에 열 이름을 :</target>
        </trans-unit>
        <trans-unit id="c0d6de9fdd70693e1bfa76116e7b090830230099" translate="yes" xml:space="preserve">
          <source>Since the output of this data type is locale-sensitive, it might not work to load &lt;code&gt;money&lt;/code&gt; data into a database that has a different setting of &lt;code&gt;lc_monetary&lt;/code&gt;. To avoid problems, before restoring a dump into a new database make sure &lt;code&gt;lc_monetary&lt;/code&gt; has the same or equivalent value as in the database that was dumped.</source>
          <target state="translated">이 데이터 유형의 출력은 로케일에 민감하므로 &lt;code&gt;lc_monetary&lt;/code&gt; 설정이 다른 데이터베이스에 &lt;code&gt;money&lt;/code&gt; 데이터 를로드하지 못할 수 있습니다 . 문제점을 피하려면 덤프를 새 데이터베이스로 복원하기 전에 &lt;code&gt;lc_monetary&lt;/code&gt; 가 덤프 된 데이터베이스 와 동일한 값을 갖도록 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bce94f9d77091dc118411d2ffd0703ec455cc475" translate="yes" xml:space="preserve">
          <source>Since the predefined libc collations already include all collations defined in the operating system when the database instance is initialized, it is not often necessary to manually create new ones. Reasons might be if a different naming system is desired (in which case see also &lt;a href=&quot;collation#COLLATION-COPY&quot;&gt;Section 23.2.2.3.3&lt;/a&gt;) or if the operating system has been upgraded to provide new locale definitions (in which case see also &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt;&lt;code&gt;pg_import_system_collations()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">사전 정의 된 libc 데이터 정렬에는 데이터베이스 인스턴스가 초기화 될 때 운영 체제에 정의 된 모든 데이터 정렬이 이미 포함되어 있기 때문에 수동으로 새 데이터 정렬을 만들 필요는 없습니다. 다른 이름 지정 시스템이 필요한 경우 (이 경우 &lt;a href=&quot;collation#COLLATION-COPY&quot;&gt;섹션 23.2.2.3.3&lt;/a&gt; 참조 ) 운영 체제가 새 로케일 정의를 제공하도록 업그레이드 된 경우 (이 경우 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt; &lt;code&gt;pg_import_system_collations()&lt;/code&gt; &lt;/a&gt; 참조 ) 이유가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5c6e0d394e36fb0de36f2183a9b746b60816e5c" translate="yes" xml:space="preserve">
          <source>Since the purpose of &lt;code&gt;commit_delay&lt;/code&gt; is to allow the cost of each flush operation to be amortized across concurrently committing transactions (potentially at the expense of transaction latency), it is necessary to quantify that cost before the setting can be chosen intelligently. The higher that cost is, the more effective &lt;code&gt;commit_delay&lt;/code&gt; is expected to be in increasing transaction throughput, up to a point. The &lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync&lt;/a&gt; program can be used to measure the average time in microseconds that a single WAL flush operation takes. A value of half of the average time the program reports it takes to flush after a single 8kB write operation is often the most effective setting for &lt;code&gt;commit_delay&lt;/code&gt;, so this value is recommended as the starting point to use when optimizing for a particular workload. While tuning &lt;code&gt;commit_delay&lt;/code&gt; is particularly useful when the WAL log is stored on high-latency rotating disks, benefits can be significant even on storage media with very fast sync times, such as solid-state drives or RAID arrays with a battery-backed write cache; but this should definitely be tested against a representative workload. Higher values of &lt;code&gt;commit_siblings&lt;/code&gt; should be used in such cases, whereas smaller &lt;code&gt;commit_siblings&lt;/code&gt; values are often helpful on higher latency media. Note that it is quite possible that a setting of &lt;code&gt;commit_delay&lt;/code&gt; that is too high can increase transaction latency by so much that total transaction throughput suffers.</source>
          <target state="translated">&lt;code&gt;commit_delay&lt;/code&gt; 의 목적은 동시 커밋 트랜잭션 (잠재적으로 트랜잭션 대기 시간을 희생하여)에서 각 플러시 작업 비용을 상각 할 수 있도록하기 때문에 설정을 지능적으로 선택하기 전에 해당 비용을 수량화해야합니다. 비용이 높을수록 &lt;code&gt;commit_delay&lt;/code&gt; 가 트랜잭션 처리량을 증가시키는 데 더 효과적 일 것으로 예상됩니다. &lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync의&lt;/a&gt; 프로그램은 단일 WAL 플러시 동작이 마이크로 걸리는 평균 시간을 측정하는데 사용될 수있다. 단일 8kB 쓰기 작업 후 프로그램이 플러시하는 데 걸리는 평균 시간의 절반 값은 종종 &lt;code&gt;commit_delay&lt;/code&gt; 에 가장 효과적인 설정입니다 .따라서이 값은 특정 작업 부하를 최적화 할 때 사용할 시작점으로 권장됩니다. &lt;code&gt;commit_delay&lt;/code&gt; 조정 은 WAL 로그가 대기 시간이 긴 회전 디스크에 저장 될 때 특히 유용 하지만 솔리드 스테이트 드라이브 또는 배터리 백업 쓰기 캐시가있는 RAID 어레이와 같이 매우 빠른 동기화 시간을 가진 저장 매체에서도 이점이 중요 할 수 있습니다. 그러나 이것은 대표적인 워크로드에 대해 확실히 테스트되어야합니다. 이러한 경우 더 높은 &lt;code&gt;commit_siblings&lt;/code&gt; 값을 사용해야하지만, &lt;code&gt;commit_siblings&lt;/code&gt; 값이 작을 수록 대기 시간이 긴 매체에 도움이되는 경우가 많습니다. &lt;code&gt;commit_delay&lt;/code&gt; 의 설정이 가능할 수도 있습니다. 너무 높으면 트랜잭션 대기 시간이 너무 길어 총 트랜잭션 처리량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="cd2f21d2cdb1953c0c5b835269d782791a0ab4d7" translate="yes" xml:space="preserve">
          <source>Since the representation of the key in GiST is flexible, it may depend on user-specified parameters. For instance, the length of key signature may be specified. See &lt;code&gt;gtsvector_options()&lt;/code&gt; for example.</source>
          <target state="translated">GiST의 키 표현은 유연하기 때문에 사용자 지정 매개 변수에 따라 달라질 수 있습니다. 예를 들어, 키 서명의 길이를 지정할 수 있습니다. 예를 들어 &lt;code&gt;gtsvector_options()&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ab50c7085aeec75be4f64393b54c0c85eb31648" translate="yes" xml:space="preserve">
          <source>Since the representation of the key in SP-GiST is flexible, it may depend on user-specified parameters.</source>
          <target state="translated">SP-GiST의 키 표현은 유연하기 때문에 사용자 지정 매개 변수에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38404e4ae252c0fb6df726708c4db9566cc1f602" translate="yes" xml:space="preserve">
          <source>Since the result depends only on whether any rows are returned, and not on the contents of those rows, the output list of the subquery is normally unimportant. A common coding convention is to write all &lt;code&gt;EXISTS&lt;/code&gt; tests in the form &lt;code&gt;EXISTS(SELECT 1 WHERE ...)&lt;/code&gt;. There are exceptions to this rule however, such as subqueries that use &lt;code&gt;INTERSECT&lt;/code&gt;.</source>
          <target state="translated">결과는 행의 내용이 아닌 행이 리턴되는지 여부에만 의존하므로 부속 조회의 출력 목록은 일반적으로 중요하지 않습니다. 일반적인 코딩 규칙은 모든 &lt;code&gt;EXISTS&lt;/code&gt; 테스트를 &lt;code&gt;EXISTS(SELECT 1 WHERE ...)&lt;/code&gt; 형식으로 작성하는 것 입니다. 그러나이 규칙에는 &lt;code&gt;INTERSECT&lt;/code&gt; 를 사용하는 서브 쿼리와 같은 예외가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6915022737a4ee251e7aa12cc406103a469017ba" translate="yes" xml:space="preserve">
          <source>Since there are no comparison operators for the &lt;code&gt;xml&lt;/code&gt; data type, it is not possible to create an index directly on a column of this type. If speedy searches in XML data are desired, possible workarounds include casting the expression to a character string type and indexing that, or indexing an XPath expression. Of course, the actual query would have to be adjusted to search by the indexed expression.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 형식에 대한 비교 연산자가 없으므로이 형식의 열에 직접 인덱스를 만들 수 없습니다. XML 데이터에서 빠른 검색이 필요한 경우 가능한 해결 방법은 표현식을 문자열 유형으로 캐스트하고 색인화하거나 XPath 표현식을 색인화하는 것입니다. 물론 인덱스 된 식으로 검색하려면 실제 쿼리를 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3aba811d08ea8d6654643c46d530e502e8f4ddb8" translate="yes" xml:space="preserve">
          <source>Since these functions return the start time of the current transaction, their values do not change during the transaction. This is considered a feature: the intent is to allow a single transaction to have a consistent notion of the &amp;ldquo;current&amp;rdquo; time, so that multiple modifications within the same transaction bear the same time stamp.</source>
          <target state="translated">이러한 함수는 현재 트랜잭션의 시작 시간을 반환하므로 해당 값은 트랜잭션 중에 변경되지 않습니다. 이는 하나의 기능으로 간주됩니다. 의도는 단일 트랜잭션이 &quot;현재&quot;시간에 대해 일관된 개념을 갖도록하여 동일한 트랜잭션 내의 여러 수정이 동일한 타임 스탬프를 갖도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5081d2a8e80dce1e5372cc4efeef98be322bd7d6" translate="yes" xml:space="preserve">
          <source>Since this catalog contains passwords, it must not be publicly readable. &lt;a href=&quot;view-pg-roles&quot;&gt;&lt;code&gt;pg_roles&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_authid&lt;/code&gt; that blanks out the password field.</source>
          <target state="translated">이 카탈로그에는 비밀번호가 포함되어 있으므로 공개적으로 읽을 수 없습니다. &lt;a href=&quot;view-pg-roles&quot;&gt; &lt;code&gt;pg_roles&lt;/code&gt; &lt;/a&gt; 는 pg_authid 에서 공개적으로 읽을 수있는보기로 , 비밀번호 필드 를 비 &lt;code&gt;pg_authid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31a4560fac13b05921bb77646c88072cae1336d5" translate="yes" xml:space="preserve">
          <source>Since this query has no &lt;code&gt;WHERE&lt;/code&gt; clause, it must scan all the rows of the table, so the planner has chosen to use a simple sequential scan plan. The numbers that are quoted in parentheses are (left to right):</source>
          <target state="translated">이 쿼리에는 &lt;code&gt;WHERE&lt;/code&gt; 절이 없으므로 테이블의 모든 행을 스캔해야하므로 플래너는 간단한 순차 스캔 계획을 사용하도록 선택했습니다. 괄호 안에 인용 된 숫자는 (왼쪽에서 오른쪽으로)입니다 :</target>
        </trans-unit>
        <trans-unit id="6a9438bb8f01ddb0be97393ce893812f2800e878" translate="yes" xml:space="preserve">
          <source>Since timezone abbreviations are not well standardized, PostgreSQL provides a means to customize the set of abbreviations accepted by the server. The &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; run-time parameter determines the active set of abbreviations. While this parameter can be altered by any database user, the possible values for it are under the control of the database administrator &amp;mdash; they are in fact names of configuration files stored in &lt;code&gt;.../share/timezonesets/&lt;/code&gt; of the installation directory. By adding or altering files in that directory, the administrator can set local policy for timezone abbreviations.</source>
          <target state="translated">표준 시간대 약어가 제대로 표준화되지 않았기 때문에 PostgreSQL은 서버가 수용하는 약어 세트를 사용자 정의 할 수있는 수단을 제공합니다. &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations는이&lt;/a&gt; 런타임 약어들의 액티브 세트를 결정하는 파라미터. 이 매개 변수는 모든 데이터베이스 사용자가 변경할 수 있지만 가능한 값은 데이터베이스 관리자가 제어합니다. 실제로 는 설치 디렉토리의 &lt;code&gt;.../share/timezonesets/&lt;/code&gt; 에 저장된 구성 파일의 이름입니다 . 관리자는 해당 디렉토리에서 파일을 추가하거나 변경하여 시간대 약어에 대한 로컬 정책을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33079a20f3bb27296f94172a1ac1f04b23f52103" translate="yes" xml:space="preserve">
          <source>Since we can combine an indefinitely long sequence of WAL files for replay, continuous backup can be achieved simply by continuing to archive the WAL files. This is particularly valuable for large databases, where it might not be convenient to take a full backup frequently.</source>
          <target state="translated">재생을 위해 무한정 긴 WAL 파일 시퀀스를 결합 할 수 있으므로 WAL 파일을 계속 아카이브하면 연속 백업을 수행 할 수 있습니다. 이는 전체 백업을 자주 수행하는 것이 편리하지 않은 대규모 데이터베이스에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="af508a7006ceeb87b894c9ffcc385e2969ee8697" translate="yes" xml:space="preserve">
          <source>Since you are modifying copies of buffer pages, &lt;code&gt;GenericXLogStart()&lt;/code&gt; does not start a critical section. Thus, you can safely do memory allocation, error throwing, etc. between &lt;code&gt;GenericXLogStart()&lt;/code&gt; and &lt;code&gt;GenericXLogFinish()&lt;/code&gt;. The only actual critical section is present inside &lt;code&gt;GenericXLogFinish()&lt;/code&gt;. There is no need to worry about calling &lt;code&gt;GenericXLogAbort()&lt;/code&gt; during an error exit, either.</source>
          <target state="translated">버퍼 페이지의 사본을 수정 &lt;code&gt;GenericXLogStart()&lt;/code&gt; 는 중요한 섹션을 시작하지 않습니다. 따라서 &lt;code&gt;GenericXLogStart()&lt;/code&gt; 와 &lt;code&gt;GenericXLogFinish()&lt;/code&gt; 간에 메모리 할당, 오류 발생 등을 안전하게 수행 할 수 있습니다 . &lt;code&gt;GenericXLogFinish()&lt;/code&gt; 안에는 실제 중요한 섹션 만 있습니다. 오류 종료 중에 &lt;code&gt;GenericXLogAbort()&lt;/code&gt; 호출에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c98f077687b3caf297476f42f2cb0dd223e177f3" translate="yes" xml:space="preserve">
          <source>Since you have to keep around all the archived WAL files back to your last base backup, the interval between base backups should usually be chosen based on how much storage you want to expend on archived WAL files. You should also consider how long you are prepared to spend recovering, if recovery should be necessary &amp;mdash; the system will have to replay all those WAL segments, and that could take awhile if it has been a long time since the last base backup.</source>
          <target state="translated">보관 된 모든 WAL 파일을 마지막 기본 백업으로 다시 유지해야하므로 일반적으로 보관 된 WAL 파일에 소비 할 스토리지 용량에 따라 기본 백업 간격을 선택해야합니다. 또한 복구가 필요한 경우 복구에 소요되는 시간을 고려해야합니다. 시스템은 모든 WAL 세그먼트를 재생해야하며 마지막 기본 백업 이후 오랜 시간이 걸리면 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2331858b0c48cc7fd8cb1731819314a507f8abe" translate="yes" xml:space="preserve">
          <source>Since you need to be connected to the database server in order to execute the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command, the question remains how the &lt;em&gt;first&lt;/em&gt; database at any given site can be created. The first database is always created by the &lt;code&gt;initdb&lt;/code&gt; command when the data storage area is initialized. (See &lt;a href=&quot;creating-cluster&quot;&gt;Section 18.2&lt;/a&gt;.) This database is called &lt;code&gt;postgres&lt;/code&gt;. So to create the first &amp;ldquo;ordinary&amp;rdquo; database you can connect to &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE DATABASE&lt;/code&gt; 명령 을 실행하려면 데이터베이스 서버에 연결해야하므로 주어진 사이트에서 &lt;em&gt;첫 번째&lt;/em&gt; 데이터베이스를 작성 하는 방법에 대한 의문이 남아 있습니다. 첫 번째 데이터베이스는 데이터 저장 영역이 초기화 될 때 항상 &lt;code&gt;initdb&lt;/code&gt; 명령으로 작성됩니다 . ( &lt;a href=&quot;creating-cluster&quot;&gt;18.2 절&lt;/a&gt; 참조 )이 데이터베이스를 &lt;code&gt;postgres&lt;/code&gt; 라고 합니다. 따라서 첫 번째 &quot;일반&quot;데이터베이스를 만들려면 &lt;code&gt;postgres&lt;/code&gt; 에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57ec9a188c98ceb1070afcf704b5023d28a3aedd" translate="yes" xml:space="preserve">
          <source>Sine, argument in degrees</source>
          <target state="translated">사인,도 단위 인수</target>
        </trans-unit>
        <trans-unit id="2289ebbaa85adf250fc26a654dd1acc164b294f1" translate="yes" xml:space="preserve">
          <source>Sine, argument in radians</source>
          <target state="translated">사인, 라디안 인수</target>
        </trans-unit>
        <trans-unit id="d9186aaf22f650a773c9d0e96e50a0a1c0ab4ed4" translate="yes" xml:space="preserve">
          <source>Single value (zero-length interval)</source>
          <target state="translated">단일 값 (제로 길이 간격)</target>
        </trans-unit>
        <trans-unit id="53eb49dab80f523be1880417f8f5fed8236f5b2c" translate="yes" xml:space="preserve">
          <source>Single-User Mode</source>
          <target state="translated">단일 사용자 모드</target>
        </trans-unit>
        <trans-unit id="fbe740227f2ee74f6b3f6ca1703aa2041cde81bc" translate="yes" xml:space="preserve">
          <source>Single-column statistics store the number of distinct values in each column. Estimates of the number of distinct values when combining more than one column (for example, for &lt;code&gt;GROUP BY a, b&lt;/code&gt;) are frequently wrong when the planner only has single-column statistical data, causing it to select bad plans.</source>
          <target state="translated">단일 열 통계는 각 열의 고유 값 수를 저장합니다. 플래너에 단일 열 통계 데이터 만있는 경우 둘 이상의 열을 결합 할 때 (예 : &lt;code&gt;GROUP BY a, b&lt;/code&gt; ) 고유 값의 수를 잘못 추정 하여 잘못된 계획을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15bfc9805ef19562e995f84faa33a41c60eeeb4" translate="yes" xml:space="preserve">
          <source>Size of the JSON item (number of array elements, or 1 if not an array)</source>
          <target state="translated">JSON 항목의 크기 (배열 요소 수 또는 배열이 아닌 경우 1)</target>
        </trans-unit>
        <trans-unit id="68a7d07a9bea11c5a8b5df3b4fa351aa00a15d55" translate="yes" xml:space="preserve">
          <source>Size of the SQL/JSON item</source>
          <target state="translated">SQL / JSON 항목의 크기</target>
        </trans-unit>
        <trans-unit id="30a54315dd8dedf948529c769206b6f3bc742f65" translate="yes" xml:space="preserve">
          <source>Size of the allocation</source>
          <target state="translated">할당 크기</target>
        </trans-unit>
        <trans-unit id="679e705709a8f5865e92137e08b1e2abf4657717" translate="yes" xml:space="preserve">
          <source>Size of the allocation including padding. For anonymous allocations, no information about padding is available, so the &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;allocated_size&lt;/code&gt; columns will always be equal. Padding is not meaningful for free memory, so the columns will be equal in that case also.</source>
          <target state="translated">패딩을 포함한 할당 크기입니다. 익명 할당의 경우 패딩에 대한 정보를 사용할 수 없으므로 &lt;code&gt;size&lt;/code&gt; 및 &lt;code&gt;allocated_size&lt;/code&gt; 열은 항상 동일합니다. 패딩은 여유 메모리에 의미가 없으므로이 경우에도 열이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8a42ce7fa92f794da485e0f331ab739e28eab0ce" translate="yes" xml:space="preserve">
          <source>Size of the on-disk representation of this table in pages (of size &lt;code&gt;BLCKSZ&lt;/code&gt;). This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">이 테이블의 디스크 상 표현 크기 (페이지 크기 : &lt;code&gt;BLCKSZ&lt;/code&gt; ). 이것은 플래너가 사용한 추정치 일뿐입니다. &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 와 같은 몇 가지 DDL 명령 으로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ea0cfa4b145056f2c2d8358087cc5b370f627f6" translate="yes" xml:space="preserve">
          <source>Skip relations that cannot be immediately locked for processing.</source>
          <target state="translated">처리를 위해 즉시 잠글 수없는 관계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e96cc5c07585101e529cab02361cc17e2d162624" translate="yes" xml:space="preserve">
          <source>Slony-I is an example of this type of replication, with per-table granularity, and support for multiple standby servers. Because it updates the standby server asynchronously (in batches), there is possible data loss during fail over.</source>
          <target state="translated">Slony-I는 이러한 유형의 복제의 예이며, 테이블 단위로 세분화되고 여러 대기 서버를 지원합니다. 대기 서버를 비동기식으로 (일괄 적으로) 업데이트하므로 장애 조치 중에 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2375a5ecc3081b59c979ed2ad80655f50fe1b938" translate="yes" xml:space="preserve">
          <source>Slots can be created and dropped either via the streaming replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) or via SQL functions (see &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION&quot;&gt;Section 9.26.6&lt;/a&gt;).</source>
          <target state="translated">스트리밍 복제 프로토콜 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;섹션 52.4&lt;/a&gt; 참조 ) 또는 SQL 함수 ( &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION&quot;&gt;섹션 9.26.6&lt;/a&gt; 참조) 를 통해 슬롯을 생성하고 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef7ed8da0301da525243e45afb8f9f9ff2a026a7" translate="yes" xml:space="preserve">
          <source>Slots can be created and dropped either via the streaming replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) or via SQL functions (see &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION&quot;&gt;Section 9.27.6&lt;/a&gt;).</source>
          <target state="translated">슬롯은 스트리밍 복제 프로토콜 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;섹션 52.4&lt;/a&gt; 참조 ) 또는 SQL 함수 ( &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION&quot;&gt;섹션 9.27.6&lt;/a&gt; 참조) 를 통해 생성 및 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10d4f61f3c7009bc1274e568e420899a76d8b1b0" translate="yes" xml:space="preserve">
          <source>Smaller values of &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; and &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; reduce the extra I/O load caused by the background writer, but make it more likely that server processes will have to issue writes for themselves, delaying interactive queries.</source>
          <target state="translated">&lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; 및 &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; 값이 작을수록 백그라운드 작성기로 인한 추가 I / O로드가 줄어들지 만 서버 프로세스가 대화식 쿼리를 지연 시켜서 자체적으로 쓰기를 실행해야 할 가능성이 높아집니다.</target>
        </trans-unit>
        <trans-unit id="e3504b77b6faee648de025e7aa88cd59afa4e78e" translate="yes" xml:space="preserve">
          <source>Snapshots are exported with the &lt;code&gt;pg_export_snapshot&lt;/code&gt; function, shown in &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.87&lt;/a&gt;, and imported with the &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; command.</source>
          <target state="translated">스냅 샷은 &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;표 9.87에&lt;/a&gt; 표시된 &lt;code&gt;pg_export_snapshot&lt;/code&gt; 함수 로 내보내고 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 명령으로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="2154d750cc2cfb9132f577423b6b42dfaf0bb79d" translate="yes" xml:space="preserve">
          <source>Snapshots are exported with the &lt;code&gt;pg_export_snapshot&lt;/code&gt; function, shown in &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt;, and imported with the &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; command.</source>
          <target state="translated">스냅 샷은 &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;표 9.88에&lt;/a&gt; 표시된 &lt;code&gt;pg_export_snapshot&lt;/code&gt; 함수 로 내보내고 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 명령으로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8328cf8bf38a03a33deb3844df7fb01ce959fca2" translate="yes" xml:space="preserve">
          <source>So far we have explained how to add data to tables and how to change data. What remains is to discuss how to remove data that is no longer needed. Just as adding data is only possible in whole rows, you can only remove entire rows from a table. In the previous section we explained that SQL does not provide a way to directly address individual rows. Therefore, removing rows can only be done by specifying conditions that the rows to be removed have to match. If you have a primary key in the table then you can specify the exact row. But you can also remove groups of rows matching a condition, or you can remove all rows in the table at once.</source>
          <target state="translated">지금까지 테이블에 데이터를 추가하는 방법과 데이터를 변경하는 방법에 대해 설명했습니다. 더 이상 필요하지 않은 데이터를 제거하는 방법에 대해 논의하는 것이 남아 있습니다. 전체 행에서만 데이터를 추가 할 수있는 것처럼 테이블에서 전체 행만 제거 할 수 있습니다. 이전 섹션에서 SQL은 개별 행을 직접 처리하는 방법을 제공하지 않는다고 설명했습니다. 따라서 제거 할 행이 일치해야하는 조건을 지정해야만 행 제거를 수행 할 수 있습니다. 테이블에 기본 키가 있으면 정확한 행을 지정할 수 있습니다. 그러나 조건과 일치하는 행 그룹을 제거하거나 테이블의 모든 행을 한 번에 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="29ebc1a400c5a829663dbb6ebc2cefb5d5ce86a6" translate="yes" xml:space="preserve">
          <source>So if you index, say, an image collection with a PostgreSQL B-tree, you can only issue queries such as &amp;ldquo;is imagex equal to imagey&amp;rdquo;, &amp;ldquo;is imagex less than imagey&amp;rdquo; and &amp;ldquo;is imagex greater than imagey&amp;rdquo;. Depending on how you define &amp;ldquo;equals&amp;rdquo;, &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; in this context, this could be useful. However, by using a GiST based index, you could create ways to ask domain-specific questions, perhaps &amp;ldquo;find all images of horses&amp;rdquo; or &amp;ldquo;find all over-exposed images&amp;rdquo;.</source>
          <target state="translated">따라서 PostgreSQL B- 트리를 사용하여 이미지 모음을 색인화하는 경우 &quot;imagex는 imagey와 같음&quot;, &quot;imagex는 imagey보다 작음&quot;및 &quot;imagex가 imagey보다 큼&quot;과 같은 쿼리 만 실행할 수 있습니다. 이 문맥에서 &quot;같음&quot;, &quot;보다 작음&quot;및 &quot;보다 큼&quot;을 정의하는 방법에 따라 유용 할 수 있습니다. 그러나 GiST 기반 색인을 사용하여 &quot;말의 모든 이미지 찾기&quot;또는 &quot;과다 노출 된 모든 이미지 찾기&quot;와 같은 도메인 별 질문을하는 방법을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a0f355c69905f2f252426e49f864ef2a5b7861" translate="yes" xml:space="preserve">
          <source>So long as no deadlock situation is detected, a transaction seeking either a table-level or row-level lock will wait indefinitely for conflicting locks to be released. This means it is a bad idea for applications to hold transactions open for long periods of time (e.g., while waiting for user input).</source>
          <target state="translated">교착 상태 상황이 감지되지 않는 한, 테이블 레벨 또는 행 레벨 잠금을 찾는 트랜잭션은 충돌하는 잠금이 해제 될 때까지 무기한 대기합니다. 즉, 응용 프로그램이 트랜잭션을 장기간 (예 : 사용자 입력을 기다리는 동안) 열린 상태로 유지하는 것은 좋지 않은 생각입니다.</target>
        </trans-unit>
        <trans-unit id="802f301feb830e18927d63ec2e1513704a48826b" translate="yes" xml:space="preserve">
          <source>So long as the working table is not empty, repeat these steps:</source>
          <target state="translated">작업 테이블이 비어 있지 않으면 다음 단계를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="d7e7a2e939ab5bf22f9b4b74474d6d2680d09ed4" translate="yes" xml:space="preserve">
          <source>So the parser does a type conversion on the operand and the query is equivalent to:</source>
          <target state="translated">따라서 파서는 피연산자에서 유형 변환을 수행하며 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63fa8bc82dac59b478b1bb95af998c32c5f7979f" translate="yes" xml:space="preserve">
          <source>So the planner will usually select an index scan if possible. With a btree index, we get results like this:</source>
          <target state="translated">따라서 가능한 경우 플래너는 일반적으로 인덱스 스캔을 선택합니다. btree 인덱스를 사용하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b73efed3f68f4f478dfb510317bd6d6d0d980bd1" translate="yes" xml:space="preserve">
          <source>So to create a table in the new schema, use:</source>
          <target state="translated">새 스키마에서 테이블을 작성하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c2c8bfb31e799316901a0916e3e3f5dc632a7a93" translate="yes" xml:space="preserve">
          <source>So, 1700, 1800, 1900, 2100, and 2200 are not leap years. But 1600, 2000, and 2400 are leap years. By contrast, in the older Julian calendar all years divisible by 4 are leap years.</source>
          <target state="translated">따라서 1700, 1800, 1900, 2100 및 2200은 윤년이 아닙니다. 그러나 1600, 2000 및 2400은 윤년입니다. 대조적으로, 오래된 율리우스 력에서 4로 나눌 수있는 모든 연도는 윤년입니다.</target>
        </trans-unit>
        <trans-unit id="e3821383c968c02f69cf8fa47cf23c0a33104a8f" translate="yes" xml:space="preserve">
          <source>So, for example, these are equivalent:</source>
          <target state="translated">예를 들어 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3f3af4406f7f6601b6bf605bf9a16e75f82fc7a" translate="yes" xml:space="preserve">
          <source>So, if you run your own CA and allow only certificates from this CA to be accepted by the server, the serial number is the most reliable (albeit not very mnemonic) means to identify a user.</source>
          <target state="translated">따라서 고유 한 CA를 실행하고이 CA의 인증서 만 서버에서 승인하도록 허용하는 경우 일련 번호는 사용자를 식별하는 가장 신뢰할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1a2802bd2fde3f4714df8f02ed567c871086b01a" translate="yes" xml:space="preserve">
          <source>So, switching from primary to standby server can be fast but requires some time to re-prepare the failover cluster. Regular switching from primary to standby is useful, since it allows regular downtime on each system for maintenance. This also serves as a test of the failover mechanism to ensure that it will really work when you need it. Written administration procedures are advised.</source>
          <target state="translated">따라서 기본 서버에서 대기 서버로 빠르게 전환 할 수 있지만 장애 조치 클러스터를 다시 준비하는 데 약간의 시간이 필요합니다. 기본 시스템에서 대기 모드로 정기적으로 전환하면 유지 관리를 위해 각 시스템에서 정기적으로 다운 타임을 허용하므로 유용합니다. 또한 장애 조치 메커니즘의 테스트 역할을하여 필요할 때 실제로 작동하는지 확인합니다. 서면 관리 절차가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="041344b27b335d177c1a075d7d1e305e6cdfe865" translate="yes" xml:space="preserve">
          <source>So, to specify a named constraint, use the key word &lt;code&gt;CONSTRAINT&lt;/code&gt; followed by an identifier followed by the constraint definition. (If you don't specify a constraint name in this way, the system chooses a name for you.)</source>
          <target state="translated">따라서 명명 된 제약 조건을 지정하려면 키워드 &lt;code&gt;CONSTRAINT&lt;/code&gt; 와 식별자, 제약 조건 정의를 차례로 사용하십시오. (이러한 방식으로 제한 조건 이름을 지정하지 않으면 시스템이 이름을 선택합니다.)</target>
        </trans-unit>
        <trans-unit id="d1c700123479a2be7a31632c6a79166e2365e5fb" translate="yes" xml:space="preserve">
          <source>So, with the introduction of PGP encryption, usage of raw encryption functions is discouraged.</source>
          <target state="translated">따라서 PGP 암호화를 도입하면 원시 암호화 기능을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fb983e9ffaa4215db72398a2e5c05b59f1b19993" translate="yes" xml:space="preserve">
          <source>Soft upper limit of the size of the set returned by GIN index scans. For more information see &lt;a href=&quot;gin-tips&quot;&gt;Section 66.5&lt;/a&gt;.</source>
          <target state="translated">GIN 인덱스 스캔에 의해 리턴 된 세트 크기의 소프트 상한. 자세한 정보는 &lt;a href=&quot;gin-tips&quot;&gt;섹션 66.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48f43423db0562ef2e10fb3fce70a29d303c9a19" translate="yes" xml:space="preserve">
          <source>Solar Designer</source>
          <target state="translated">솔라 디자이너</target>
        </trans-unit>
        <trans-unit id="26e63dc273e3d7592946ac5e0a54673f05516860" translate="yes" xml:space="preserve">
          <source>Solaris 2.10 (Solaris 10) and laterOpenSolaris</source>
          <target state="translated">Solaris 2.10 (Solaris 10) 이상</target>
        </trans-unit>
        <trans-unit id="800a5d597c25aa9b354ed3f5a4ea3f53e2b17909" translate="yes" xml:space="preserve">
          <source>Solaris 2.6 to 2.9 (Solaris 6 to Solaris 9)</source>
          <target state="translated">Solaris 2.6 ~ 2.9 (Solaris 6 ~ Solaris 9)</target>
        </trans-unit>
        <trans-unit id="a812a86aecf127168fdd7bc939660cd07ba4f075" translate="yes" xml:space="preserve">
          <source>Solaris requires special handling. You must use &lt;code&gt;/usr/ucb/ps&lt;/code&gt;, rather than &lt;code&gt;/bin/ps&lt;/code&gt;. You also must use two &lt;code&gt;w&lt;/code&gt; flags, not just one. In addition, your original invocation of the &lt;code&gt;postgres&lt;/code&gt; command must have a shorter &lt;code&gt;ps&lt;/code&gt; status display than that provided by each server process. If you fail to do all three things, the &lt;code&gt;ps&lt;/code&gt; output for each server process will be the original &lt;code&gt;postgres&lt;/code&gt; command line.</source>
          <target state="translated">Solaris는 특별한 처리가 필요합니다. &lt;code&gt;/bin/ps&lt;/code&gt; 대신 &lt;code&gt;/usr/ucb/ps&lt;/code&gt; 를 사용해야합니다 . 또한 하나가 아닌 두 개의 &lt;code&gt;w&lt;/code&gt; 플래그를 사용해야합니다 . 또한 &lt;code&gt;postgres&lt;/code&gt; 명령 의 원래 호출은 각 서버 프로세스가 제공하는 것보다 짧은 &lt;code&gt;ps&lt;/code&gt; 상태 표시를 가져야합니다 . 세 가지 작업을 모두 수행하지 않으면 각 서버 프로세스 의 &lt;code&gt;ps&lt;/code&gt; 출력이 원래 &lt;code&gt;postgres&lt;/code&gt; 명령 줄이됩니다.</target>
        </trans-unit>
        <trans-unit id="68d253a9ab95a36c38dcaf213430a0c6c6a47cdd" translate="yes" xml:space="preserve">
          <source>Solarisillumos</source>
          <target state="translated">Solarisillumos</target>
        </trans-unit>
        <trans-unit id="e49cdd8b4661cbbc91446b849a1194e499a9884d" translate="yes" xml:space="preserve">
          <source>Some (less frequently used) encodings are not supported by ICU. When the database encoding is one of these, ICU collation entries in &lt;code&gt;pg_collation&lt;/code&gt; are ignored. Attempting to use one will draw an error along the lines of &amp;ldquo;collation &quot;de-x-icu&quot; for encoding &quot;WIN874&quot; does not exist&amp;rdquo;.</source>
          <target state="translated">ICU에서는 일부 (자주 사용하지 않는) 인코딩을 지원하지 않습니다. 데이터베이스 인코딩이 이들 중 하나 인 경우 &lt;code&gt;pg_collation&lt;/code&gt; 의 ICU 데이터 정렬 항목 은 무시됩니다. 하나를 사용하려고하면 &quot;WIN874&quot;가 존재하지 않기 때문에 &quot;collation&quot;de-x-icu &quot;행을 따라 오류가 발생합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="ee40f9b9734dbd4a91a7d92973258b40bb531dfd" translate="yes" xml:space="preserve">
          <source>Some DDL commands, currently only &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; and the table-rewriting forms of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, are not MVCC-safe. This means that after the truncation or rewrite commits, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the DDL command committed. This will only be an issue for a transaction that did not access the table in question before the DDL command started &amp;mdash; any transaction that has done so would hold at least an &lt;code&gt;ACCESS SHARE&lt;/code&gt; table lock, which would block the DDL command until that transaction completes. So these commands will not cause any apparent inconsistency in the table contents for successive queries on the target table, but they could cause visible inconsistency between the contents of the target table and other tables in the database.</source>
          <target state="translated">현재 &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; 및 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 의 테이블 재 작성 형식 인 일부 DDL 명령 은 MVCC 안전하지 않습니다. 이는 잘림 또는 다시 쓰기 커밋 후 DDL 명령이 커밋되기 전에 스냅 샷을 사용하는 경우 동시 트랜잭션에 대해 테이블이 비어있는 것으로 나타납니다. 이는 DDL 명령이 시작되기 전에 문제의 테이블에 액세스하지 않은 트랜잭션에만 해당됩니다. 그렇게 한 트랜잭션은 적어도 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 를 보유합니다.트랜잭션이 완료 될 때까지 DDL 명령을 차단하는 테이블 잠금. 따라서이 명령은 목표 테이블에 대한 연속 쿼리에 대해 테이블 ​​내용에 명백한 불일치가 발생하지 않지만 목표 테이블의 내용과 데이터베이스의 다른 테이블간에 눈에 불일치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f09ee2851258052d3c5f49a32727d2a1519806f" translate="yes" xml:space="preserve">
          <source>Some ISBN13 numbers can be displayed as ISBN.</source>
          <target state="translated">일부 ISBN13 숫자는 ISBN으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82b7dbf85db87bb9f84d8253cdea6c48e3402bf" translate="yes" xml:space="preserve">
          <source>Some ISMN13 numbers can be displayed as ISMN.</source>
          <target state="translated">일부 ISMN13 번호는 ISMN으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89bee48c2e802304b5519040cc804d32c04717b2" translate="yes" xml:space="preserve">
          <source>Some ISSN13 numbers can be displayed as ISSN.</source>
          <target state="translated">일부 ISSN13 번호는 ISSN으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4593e8caad52040d1bc379ad01ac76ec2b814f4" translate="yes" xml:space="preserve">
          <source>Some PostgreSQL data types and functions have special rules regarding transactional behavior. In particular, changes made to a sequence (and therefore the counter of a column declared using &lt;code&gt;serial&lt;/code&gt;) are immediately visible to all other transactions and are not rolled back if the transaction that made the changes aborts. See &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt; and &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;Section 8.1.4&lt;/a&gt;.</source>
          <target state="translated">일부 PostgreSQL 데이터 형식 및 함수에는 트랜잭션 동작과 관련된 특수 규칙이 있습니다. 특히 시퀀스에 대한 변경 사항 (따라서 &lt;code&gt;serial&lt;/code&gt; 을 사용하여 선언 된 열의 카운터 )은 다른 모든 트랜잭션에 즉시 표시되며 변경을 수행 한 트랜잭션이 중단 된 경우 롤백되지 않습니다. &lt;a href=&quot;functions-sequence&quot;&gt;섹션 9.16&lt;/a&gt; 및 &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;섹션 8.1.4를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c898a9bb75ed4c7011c7cba38b7f19b98cf58eca" translate="yes" xml:space="preserve">
          <source>Some PostgreSQL data types and functions have special rules regarding transactional behavior. In particular, changes made to a sequence (and therefore the counter of a column declared using &lt;code&gt;serial&lt;/code&gt;) are immediately visible to all other transactions and are not rolled back if the transaction that made the changes aborts. See &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt; and &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;Section 8.1.4&lt;/a&gt;.</source>
          <target state="translated">일부 PostgreSQL 데이터 유형 및 함수에는 트랜잭션 동작과 관련된 특별한 규칙이 있습니다. 특히 시퀀스에 대한 변경 사항 (따라서 &lt;code&gt;serial&lt;/code&gt; 을 사용하여 선언 된 열의 카운터 )은 다른 모든 트랜잭션에 즉시 표시되며 변경 한 트랜잭션이 중단되는 경우 롤백되지 않습니다. &lt;a href=&quot;functions-sequence&quot;&gt;섹션 9.17&lt;/a&gt; 및 &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;섹션 8.1.4를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8a3c2417878b41e5d1b86eff70225a555273e65" translate="yes" xml:space="preserve">
          <source>Some XML-related functions may not work at all on non-ASCII data when the server encoding is not UTF-8. This is known to be an issue for &lt;code&gt;xmltable()&lt;/code&gt; and &lt;code&gt;xpath()&lt;/code&gt; in particular.</source>
          <target state="translated">서버 인코딩이 UTF-8이 아닌 경우 비 ASCII 데이터에서 일부 XML 관련 함수가 전혀 작동하지 않을 수 있습니다. 이것은 특히 &lt;code&gt;xmltable()&lt;/code&gt; 및 &lt;code&gt;xpath()&lt;/code&gt; 의 문제로 알려져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87797d4e7cb9291108c3962a9881c1e9bcb03149" translate="yes" xml:space="preserve">
          <source>Some access methods return index entries in a well-defined order, others do not. There are actually two different ways that an access method can support sorted output:</source>
          <target state="translated">일부 액세스 방법은 잘 정의 된 순서로 색인 항목을 반환하지만 다른 방법은 그렇지 않습니다. 액세스 방법이 정렬 된 출력을 지원할 수있는 방법에는 실제로 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a655a45cf20ecf3645a89541b00f0a115c90a4a6" translate="yes" xml:space="preserve">
          <source>Some administrators prefer to schedule vacuuming themselves, for example doing all the work at night when load is low. The difficulty with doing vacuuming according to a fixed schedule is that if a table has an unexpected spike in update activity, it may get bloated to the point that &lt;code&gt;VACUUM FULL&lt;/code&gt; is really necessary to reclaim space. Using the autovacuum daemon alleviates this problem, since the daemon schedules vacuuming dynamically in response to update activity. It is unwise to disable the daemon completely unless you have an extremely predictable workload. One possible compromise is to set the daemon's parameters so that it will only react to unusually heavy update activity, thus keeping things from getting out of hand, while scheduled &lt;code&gt;VACUUM&lt;/code&gt;s are expected to do the bulk of the work when the load is typical.</source>
          <target state="translated">일부 관리자는 부하가 적을 때 야간에 모든 작업을 수행하는 것과 같이 스스로 청소를 예약하는 것을 선호합니다. 고정 된 일정에 따라 진공 청소기로 청소하기 어려운 점은 테이블에 업데이트 작업이 예기치 않게 급증하면 공간을 확보하는 데 실제로 &lt;code&gt;VACUUM FULL&lt;/code&gt; 이 필요한 수준까지 팽창 할 수 있다는 것 입니다. autovacuum 데몬을 사용하면 데몬이 업데이트 활동에 응답하여 동적으로 진공 청소를 예약하므로이 문제가 완화됩니다. 매우 예측 가능한 워크로드가없는 한 데몬을 완전히 비활성화하는 것은 현명하지 않습니다. 가능한 한 가지 타협은 데몬의 매개 변수를 설정하여 비정상적으로 과도한 업데이트 활동에만 반응하여 &lt;code&gt;VACUUM&lt;/code&gt; 을 예약하는 동안 문제가 발생하지 않도록하는 것입니다하중이 일반적 일 때 대부분의 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c20ac7f8d98b9c6d45f1cce6f0f6c935fedfd48" translate="yes" xml:space="preserve">
          <source>Some applications might expect that &lt;code&gt;expression = NULL&lt;/code&gt; returns true if &lt;code&gt;expression&lt;/code&gt; evaluates to the null value. It is highly recommended that these applications be modified to comply with the SQL standard. However, if that cannot be done the &lt;a href=&quot;runtime-config-compatible#GUC-TRANSFORM-NULL-EQUALS&quot;&gt;transform_null_equals&lt;/a&gt; configuration variable is available. If it is enabled, PostgreSQL will convert &lt;code&gt;x = NULL&lt;/code&gt; clauses to &lt;code&gt;x IS NULL&lt;/code&gt;.</source>
          <target state="translated">일부 응용 프로그램은 &lt;code&gt;expression&lt;/code&gt; 이 null 값으로 평가 되면 expression &lt;code&gt;expression = NULL&lt;/code&gt; 이 true를 반환 한다고 예상 할 수 있습니다 . 이러한 응용 프로그램은 SQL 표준을 준수하도록 수정하는 것이 좋습니다. 그러나이를 수행 할 수없는 경우 &lt;a href=&quot;runtime-config-compatible#GUC-TRANSFORM-NULL-EQUALS&quot;&gt;transform_null_equals&lt;/a&gt; 구성 변수를 사용할 수 있습니다. 활성화 된 경우 PostgreSQL은 &lt;code&gt;x = NULL&lt;/code&gt; 절을 &lt;code&gt;x IS NULL&lt;/code&gt; 로 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="632b4b8d0fdc54c7c1f407669799be4b0d2545df" translate="yes" xml:space="preserve">
          <source>Some approximation is allowed when determining the distance, so long as the result is never greater than the entry's actual distance. Thus, for example, distance to a bounding box is usually sufficient in geometric applications. For an internal tree node, the distance returned must not be greater than the distance to any of the child nodes. If the returned distance is not exact, the function must set &lt;code&gt;*recheck&lt;/code&gt; to true. (This is not necessary for internal tree nodes; for them, the calculation is always assumed to be inexact.) In this case the executor will calculate the accurate distance after fetching the tuple from the heap, and reorder the tuples if necessary.</source>
          <target state="translated">거리를 결정할 때 결과가 항목의 실제 거리보다 크지 않는 한 근사값이 허용됩니다. 따라서, 예를 들어 경계 상자까지의 거리는 일반적으로 기하학적 응용에서 충분합니다. 내부 트리 노드의 경우 반환 된 거리는 하위 노드까지의 거리보다 크지 않아야합니다. 리턴 된 거리가 정확하지 않으면 함수는 &lt;code&gt;*recheck&lt;/code&gt; 를 true로 설정해야 합니다. (이는 내부 트리 노드에는 필요하지 않으며 계산에 항상 정확하지 않은 것으로 가정합니다.)이 경우 실행 프로그램은 힙에서 튜플을 가져온 후 정확한 거리를 계산하고 필요한 경우 튜플을 다시 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="fc95418e24415c3b6866cd84571618bbdb7f3d8a" translate="yes" xml:space="preserve">
          <source>Some characters that are not alphanumeric have a special meaning that is different from being an operator. Details on the usage can be found at the location where the respective syntax element is described. This section only exists to advise the existence and summarize the purposes of these characters.</source>
          <target state="translated">영숫자가 아닌 일부 문자는 연산자와 다른 특별한 의미를 갖습니다. 사용법에 대한 세부 사항은 각 구문 요소가 설명 된 위치에서 찾을 수 있습니다. 이 섹션은 존재를 알리고 이러한 문자의 목적을 요약하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="3ca914c9f90c186cfb79184e4eadf75e2fbfec3f" translate="yes" xml:space="preserve">
          <source>Some client libraries issue &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; commands automatically, so that you might get the effect of transaction blocks without asking. Check the documentation for the interface you are using.</source>
          <target state="translated">일부 클라이언트 라이브러리는 &lt;code&gt;BEGIN&lt;/code&gt; 및 &lt;code&gt;COMMIT&lt;/code&gt; 명령을 자동으로 실행 하므로 묻지 않고 트랜잭션 블록의 효과를 얻을 수 있습니다. 사용중인 인터페이스에 대한 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cfb7d31c489ce387e3ca7981ab56df426c824263" translate="yes" xml:space="preserve">
          <source>Some client programs, like psql, attempt to connect twice while determining if a password is required, so duplicate &amp;ldquo;connection received&amp;rdquo; messages do not necessarily indicate a problem.</source>
          <target state="translated">psql과 같은 일부 클라이언트 프로그램은 암호가 필요한지 확인하면서 두 번 연결을 시도하므로 중복 된 &quot;연결 수신&quot;메시지가 반드시 문제를 나타내는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c43ec6be8964e23d2bba782762fe004df6ab23d3" translate="yes" xml:space="preserve">
          <source>Some commands take an SQL identifier (such as a table name) as argument. These arguments follow the syntax rules of SQL: Unquoted letters are forced to lowercase, while double quotes (&lt;code&gt;&quot;&lt;/code&gt;) protect letters from case conversion and allow incorporation of whitespace into the identifier. Within double quotes, paired double quotes reduce to a single double quote in the resulting name. For example, &lt;code&gt;FOO&quot;BAR&quot;BAZ&lt;/code&gt; is interpreted as &lt;code&gt;fooBARbaz&lt;/code&gt;, and &lt;code&gt;&quot;A weird&quot;&quot; name&quot;&lt;/code&gt; becomes &lt;code&gt;A weird&quot; name&lt;/code&gt;.</source>
          <target state="translated">일부 명령은 SQL 식별자 (예 : 테이블 이름)를 인수로 사용합니다. 인용 부호가없는 문자는 소문자로 입력해야하지만 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; )는 문자를 대 / 소문자 변환으로부터 보호하고 공백을 식별자에 통합 할 수 있도록합니다. 예를 들어, &lt;code&gt;FOO&quot;BAR&quot;BAZ&lt;/code&gt; 는 &lt;code&gt;fooBARbaz&lt;/code&gt; 로 해석 되고 &lt;code&gt;&quot;A weird&quot;&quot; name&quot;&lt;/code&gt; 은 &lt;code&gt;A weird&quot; name&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="186353a504f0c7029783349653466298212002b7" translate="yes" xml:space="preserve">
          <source>Some comparison-related functions are also available, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-FUNC-TABLE&quot;&gt;Table 9.3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-FUNC-TABLE&quot;&gt;표 9.3&lt;/a&gt; 과 같이 일부 비교 관련 기능도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2c4e01e43acca2c293b4331040f91820301e727" translate="yes" xml:space="preserve">
          <source>Some examples follow.</source>
          <target state="translated">다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="46355adbf6a9403e9485a04889f466fe8dde4386" translate="yes" xml:space="preserve">
          <source>Some examples of &lt;code&gt;pg_hba.conf&lt;/code&gt; entries are shown in &lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;Example 20.1&lt;/a&gt;. See the next section for details on the different authentication methods.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 항목 의 일부 예는 &lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;Example 20.1에&lt;/a&gt; 표시되어 있습니다. 다른 인증 방법에 대한 자세한 내용은 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9bc025c0a1aa36859c204fc8e90a56739f1738fd" translate="yes" xml:space="preserve">
          <source>Some examples of normalization:</source>
          <target state="translated">정규화의 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="7bcf7e4ca2fad466b748026159f5d8758d71fa4d" translate="yes" xml:space="preserve">
          <source>Some examples, with &lt;code&gt;#&quot;&lt;/code&gt; delimiting the return string:</source>
          <target state="translated">리턴 문자열 을 &lt;code&gt;#&quot;&lt;/code&gt; 로 구분하는 일부 예 :</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="8071a47a4b8f3fdc2d19f933ed730b4835dc2e6f" translate="yes" xml:space="preserve">
          <source>Some file system backup tools emit warnings or errors if the files they are trying to copy change while the copy proceeds. When taking a base backup of an active database, this situation is normal and not an error. However, you need to ensure that you can distinguish complaints of this sort from real errors. For example, some versions of rsync return a separate exit code for &amp;ldquo;vanished source files&amp;rdquo;, and you can write a driver script to accept this exit code as a non-error case. Also, some versions of GNU tar return an error code indistinguishable from a fatal error if a file was truncated while tar was copying it. Fortunately, GNU tar versions 1.16 and later exit with 1 if a file was changed during the backup, and 2 for other errors. With GNU tar version 1.23 and later, you can use the warning options &lt;code&gt;--warning=no-file-changed --warning=no-file-removed&lt;/code&gt; to hide the related warning messages.</source>
          <target state="translated">일부 파일 시스템 백업 도구는 복사가 진행되는 동안 복사하려는 파일이 변경되면 경고 또는 오류를 발생시킵니다. 활성 데이터베이스의 기본 백업을 수행 할 때이 상황은 정상이며 오류가 아닙니다. 그러나 이러한 종류의 불만을 실제 오류와 구분할 수 있는지 확인해야합니다. 예를 들어, 일부 버전의 rsync는&amp;ldquo;소실 된 소스 파일&amp;rdquo;에 대해 별도의 종료 코드를 반환하며이 종료 코드를 오류가 아닌 경우로 받아들이는 드라이버 스크립트를 작성할 수 있습니다. 또한 일부 버전의 GNU tar는 tar가 파일을 복사하는 동안 파일이 잘린 경우 치명적인 오류와 구분할 수없는 오류 코드를 반환합니다. 다행히도 GNU tar 버전 1.16 이상은 백업 중에 파일이 변경된 경우 1로 종료하고 다른 오류의 경우 2로 종료됩니다. GNU tar 버전 1.23 이상에서는 경고 옵션을 사용할 수 있습니다 &lt;code&gt;--warning=no-file-changed --warning=no-file-removed&lt;/code&gt; 관련 경고 메시지를 숨기려면 --warning = 파일이 변경되지 않음 --warning = 파일이 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="75ccb519e38c8da11cf9dcc5e1d2d49c10e8827f" translate="yes" xml:space="preserve">
          <source>Some file systems perform badly when they are almost full, so do not wait until the disk is completely full to take action.</source>
          <target state="translated">일부 파일 시스템은 거의 가득 차면 성능이 저하되므로 디스크가 완전히 가득 찰 때까지 기다리지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1b588df1a1ee894ccbd35f0a48265de63a1e85c5" translate="yes" xml:space="preserve">
          <source>Some frontends may create their own tables, and will not create the associated trigger(s). Also, users may not remember (or know) to create the triggers.</source>
          <target state="translated">일부 프런트 엔드는 자체 테이블을 생성 할 수 있으며 연관된 트리거를 생성하지 않습니다. 또한 사용자는 트리거를 생성하는 것을 기억하지 못하거나 알지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c44e7e09cdcce8cb244f1fd4b00de572bbde4d90" translate="yes" xml:space="preserve">
          <source>Some functionality not implemented for inheritance hierarchies is implemented for declarative partitioning. Considerable care is needed in deciding whether partitioning with legacy inheritance is useful for your application.</source>
          <target state="translated">상속 계층 구조로 구현되지 않은 일부 기능은 선언적 파티셔닝을 위해 구현됩니다. 레거시 상속을 통한 분할이 응용 프로그램에 유용한 지 여부를 결정하는 데 상당한주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4e987a6f096e52b72ae53225c55a8c600d7b531a" translate="yes" xml:space="preserve">
          <source>Some further operators also exist only for &lt;code&gt;jsonb&lt;/code&gt;, as shown in &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Table 9.45&lt;/a&gt;. Many of these operators can be indexed by &lt;code&gt;jsonb&lt;/code&gt; operator classes. For a full description of &lt;code&gt;jsonb&lt;/code&gt; containment and existence semantics, see &lt;a href=&quot;datatype-json#JSON-CONTAINMENT&quot;&gt;Section 8.14.3&lt;/a&gt;. &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt; describes how these operators can be used to effectively index &lt;code&gt;jsonb&lt;/code&gt; data.</source>
          <target state="translated">&lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;표 9.45에&lt;/a&gt; 표시된 것처럼 일부 추가 연산자는 &lt;code&gt;jsonb&lt;/code&gt; 에 대해서만 존재합니다 . 이러한 연산자 중 다수는 &lt;code&gt;jsonb&lt;/code&gt; 연산자 클래스 로 색인화 할 수 있습니다 . &lt;code&gt;jsonb&lt;/code&gt; 포함 및 존재 시맨틱에 대한 전체 설명은 &lt;a href=&quot;datatype-json#JSON-CONTAINMENT&quot;&gt;8.14.3 절을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;8.14.4 절&lt;/a&gt; 에서는 이러한 연산자를 사용하여 &lt;code&gt;jsonb&lt;/code&gt; 데이터 를 효과적으로 색인화하는 방법에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="f4febcc0c15855f8e8aef172c20c28e330de061a" translate="yes" xml:space="preserve">
          <source>Some further operators exist only for &lt;code&gt;jsonb&lt;/code&gt;, as shown in &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Table 9.45&lt;/a&gt;. &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt; describes how these operators can be used to effectively search indexed &lt;code&gt;jsonb&lt;/code&gt; data.</source>
          <target state="translated">&lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;표 9.45에&lt;/a&gt; 표시된 것처럼 일부 추가 연산자는 &lt;code&gt;jsonb&lt;/code&gt; 에 대해서만 존재합니다 . &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;8.14.4 절&lt;/a&gt; 에서는 이러한 연산자를 사용하여 색인화 된 &lt;code&gt;jsonb&lt;/code&gt; 데이터 를 효과적으로 검색하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="dc69f2a26ccfef272cb758bf4feb3f3174612774" translate="yes" xml:space="preserve">
          <source>Some ident servers have a nonstandard option that causes the returned user name to be encrypted, using a key that only the originating machine's administrator knows. This option &lt;em&gt;must not&lt;/em&gt; be used when using the ident server with PostgreSQL, since PostgreSQL does not have any way to decrypt the returned string to determine the actual user name.</source>
          <target state="translated">일부 ID 서버에는 비표준 옵션이 있는데, 이로 인해 원래 컴퓨터의 관리자 만 알고있는 키를 사용하여 반환 된 사용자 이름이 암호화됩니다. PostgreSQL에는 실제 사용자 이름을 결정하기 위해 반환 된 문자열을 해독 할 수있는 방법이 없으므로 PostgreSQL과 함께 ID 서버를 사용할 때이 옵션을 사용 &lt;em&gt;해서는 안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="39dfe399b8df469de93a797cf4642e80f5cda549" translate="yes" xml:space="preserve">
          <source>Some indexes might not index all tuples. If the tuple is not to be indexed, &lt;code&gt;aminsert&lt;/code&gt; should just return without doing anything.</source>
          <target state="translated">일부 인덱스는 모든 튜플을 인덱스하지 않을 수 있습니다. 튜플을 인덱싱하지 않으려면 아무 것도하지 않고 &lt;code&gt;aminsert&lt;/code&gt; 만 반환하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b9870923e23438cd2f121747a5de8c9682c94bbb" translate="yes" xml:space="preserve">
          <source>Some libraries need to perform certain operations that can only take place at postmaster start, such as allocating shared memory, reserving light-weight locks, or starting background workers. Those libraries must be loaded at server start through this parameter. See the documentation of each library for details.</source>
          <target state="translated">일부 라이브러리는 공유 메모리 할당, 경량 잠금 예약 또는 백그라운드 작업자 시작과 같이 포스트 마스터 시작시에만 발생할 수있는 특정 작업을 수행해야합니다. 이 라이브러리는 서버 시작시이 매개 변수를 통해로드해야합니다. 자세한 내용은 각 라이브러리의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fa3314a2a94ef400df62478e2256c9f4537efb3a" translate="yes" xml:space="preserve">
          <source>Some locale categories must have their values fixed when the database is created. You can use different settings for different databases, but once a database is created, you cannot change them for that database anymore. &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; are these categories. They affect the sort order of indexes, so they must be kept fixed, or indexes on text columns would become corrupt. (But you can alleviate this restriction using collations, as discussed in &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.) The default values for these categories are determined when &lt;code&gt;initdb&lt;/code&gt; is run, and those values are used when new databases are created, unless specified otherwise in the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command.</source>
          <target state="translated">데이터베이스를 만들 때 일부 로캘 범주의 값은 고정되어 있어야합니다. 데이터베이스마다 다른 설정을 사용할 수 있지만 데이터베이스를 만든 후에는 해당 데이터베이스에 대한 설정을 더 이상 변경할 수 없습니다. &lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; 이 이러한 범주입니다. 인덱스의 정렬 순서에 영향을 미치므로 고정 상태로 유지해야합니다. 그렇지 않으면 텍스트 열의 인덱스가 손상됩니다. (그러나 &lt;a href=&quot;collation&quot;&gt;섹션 23.2&lt;/a&gt; 에서 논의 된 것처럼 데이터 정렬을 사용하여이 제한을 완화 할 수 있습니다 .) 이러한 범주의 기본값은 &lt;code&gt;initdb&lt;/code&gt; 가 실행될 때 결정 되며 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 명령에 달리 지정되지 않는 한 새 데이터베이스가 작성 될 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0001d98ab2050cd6b99e7e04163bf1a711f72bfb" translate="yes" xml:space="preserve">
          <source>Some message localization libraries also look at the environment variable &lt;code&gt;LANGUAGE&lt;/code&gt; which overrides all other locale settings for the purpose of setting the language of messages. If in doubt, please refer to the documentation of your operating system, in particular the documentation about gettext.</source>
          <target state="translated">일부 메시지 로컬라이제이션 라이브러리는 또한 메시지 &lt;code&gt;LANGUAGE&lt;/code&gt; 를 설정하기 위해 다른 모든 로케일 설정을 대체 하는 환경 변수 LANGUAGE 를 확인합니다. 확실하지 않은 경우 운영 체제 문서, 특히 gettext에 대한 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="89da36cff77e35db916c73d1d15f2e05712a8864" translate="yes" xml:space="preserve">
          <source>Some more examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="2177d04e11d3387bec48af5385f473f12307f07a" translate="yes" xml:space="preserve">
          <source>Some notes:</source>
          <target state="translated">몇 가지 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="5a6644a3bf4293d6e3a922f24348c47425f47970" translate="yes" xml:space="preserve">
          <source>Some of the flag fields of &lt;code&gt;IndexAmRoutine&lt;/code&gt; have nonobvious implications. The requirements of &lt;code&gt;amcanunique&lt;/code&gt; are discussed in &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt;. The &lt;code&gt;amcanmulticol&lt;/code&gt; flag asserts that the access method supports multicolumn indexes, while &lt;code&gt;amoptionalkey&lt;/code&gt; asserts that it allows scans where no indexable restriction clause is given for the first index column. When &lt;code&gt;amcanmulticol&lt;/code&gt; is false, &lt;code&gt;amoptionalkey&lt;/code&gt; essentially says whether the access method supports full-index scans without any restriction clause. Access methods that support multiple index columns &lt;em&gt;must&lt;/em&gt; support scans that omit restrictions on any or all of the columns after the first; however they are permitted to require some restriction to appear for the first index column, and this is signaled by setting &lt;code&gt;amoptionalkey&lt;/code&gt; false. One reason that an index AM might set &lt;code&gt;amoptionalkey&lt;/code&gt; false is if it doesn't index null values. Since most indexable operators are strict and hence cannot return true for null inputs, it is at first sight attractive to not store index entries for null values: they could never be returned by an index scan anyway. However, this argument fails when an index scan has no restriction clause for a given index column. In practice this means that indexes that have &lt;code&gt;amoptionalkey&lt;/code&gt; true must index nulls, since the planner might decide to use such an index with no scan keys at all. A related restriction is that an index access method that supports multiple index columns &lt;em&gt;must&lt;/em&gt; support indexing null values in columns after the first, because the planner will assume the index can be used for queries that do not restrict these columns. For example, consider an index on (a,b) and a query with &lt;code&gt;WHERE a = 4&lt;/code&gt;. The system will assume the index can be used to scan for rows with &lt;code&gt;a = 4&lt;/code&gt;, which is wrong if the index omits rows where &lt;code&gt;b&lt;/code&gt; is null. It is, however, OK to omit rows where the first indexed column is null. An index access method that does index nulls may also set &lt;code&gt;amsearchnulls&lt;/code&gt;, indicating that it supports &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; clauses as search conditions.</source>
          <target state="translated">&lt;code&gt;IndexAmRoutine&lt;/code&gt; 의 플래그 필드 중 일부는 명백 하지 않은 의미를 갖습니다. &lt;code&gt;amcanunique&lt;/code&gt; 의 요구 사항은 &lt;a href=&quot;index-unique-checks&quot;&gt;61.5 절&lt;/a&gt; 에서 논의됩니다 . &lt;code&gt;amcanmulticol&lt;/code&gt; 의 상태 플래그는, 상기 액세스 방법을 지원하는 다중 열 인덱스 주장 &lt;code&gt;amoptionalkey&lt;/code&gt; 는 그것이 어떤 인덱싱 제한 절 제 인덱스 열에 대해 지정되지 않은 검색을 허용한다는 주장한다. 때 &lt;code&gt;amcanmulticol&lt;/code&gt; 은 거짓, &lt;code&gt;amoptionalkey&lt;/code&gt; 본질적 접근 방법은 어떤 제한 절없이 풀 인덱스 스캔을 지원하는지 여부를 말한다. 여러 인덱스 열을 지원하는 액세스 방법 &lt;em&gt;은&lt;/em&gt;첫 번째 이후의 열 또는 일부에 대한 제한을 생략하는 스캔을 지원합니다. 그러나 첫 번째 인덱스 열에 대해 약간의 제한이 필요할 수 있으며 &lt;code&gt;amoptionalkey&lt;/code&gt; 를 false 로 설정 하면 알 수 있습니다. 인덱스 AM이 &lt;code&gt;amoptionalkey&lt;/code&gt; 를 false로 설정할 수있는 한 가지 이유는 null 값을 인덱스하지 않는 경우입니다. 대부분의 인덱싱 가능 연산자는 엄격하고 널 입력에 대해 true를 리턴 할 수 없으므로 널 값에 대한 인덱스 항목을 저장하지 않는 것이 매력적입니다. 어쨌든 인덱스 스캔으로 리턴 될 수 없습니다. 그러나 인덱스 스캔에 지정된 인덱스 열에 대한 제한 절이 없으면이 인수가 실패합니다. 실제로 이것은 &lt;code&gt;amoptionalkey&lt;/code&gt; 가있는 인덱스를 의미합니다.플래너는 스캔 키가없는 인덱스를 사용하기로 결정할 수 있으므로 true는 널 인덱스를 작성해야합니다. 플래너는 이러한 열을 제한하지 않는 쿼리에 인덱스를 사용할 수 있다고 가정하기 때문에 여러 인덱스 열을 지원하는 인덱스 액세스 방법 은 첫 번째 열 이후의 열에서 null 값 인덱싱을 지원 &lt;em&gt;해야&lt;/em&gt; 한다는 제한이 있습니다. 예를 들어 (a, b)에 대한 인덱스와 &lt;code&gt;WHERE a = 4&lt;/code&gt; 쿼리를 고려하십시오 . 시스템은 인덱스가 &lt;code&gt;a = 4&lt;/code&gt; 인 행을 스캔하는 데 사용될 수 있다고 가정합니다. 인덱스 가 &lt;code&gt;b&lt;/code&gt; 가 null 인 행을 생략하면 잘못됩니다 . 그러나 첫 번째 색인화 된 열이 널인 행을 생략해도됩니다. 인덱스 널을 수행하는 인덱스 액세스 방법으로 &lt;code&gt;amsearchnulls&lt;/code&gt; 을 설정할 수도 있습니다.검색 조건으로 &lt;code&gt;IS NULL&lt;/code&gt; 및 &lt;code&gt;IS NOT NULL&lt;/code&gt; 절을 지원함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8aefae75cc3d2b3174dd432fe5b75ba252d75131" translate="yes" xml:space="preserve">
          <source>Some of the functions available for binary strings are also available for bit strings, as shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-TABLE&quot;&gt;Table 9.15&lt;/a&gt;.</source>
          <target state="translated">이진 문자열에 사용할 수있는 일부 함수는 &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-TABLE&quot;&gt;Table 9.15에&lt;/a&gt; 표시된 것처럼 비트 문자열에도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db07bfe2ef98cee0d48cd0b38f74fd0dc95ccde8" translate="yes" xml:space="preserve">
          <source>Some of the information available through this module can also be obtained using the built-in system view &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SSL-VIEW&quot;&gt;&lt;code&gt;pg_stat_ssl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈을 통해 사용 가능한 정보 중 일부는 내장 시스템 뷰 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SSL-VIEW&quot;&gt; &lt;code&gt;pg_stat_ssl&lt;/code&gt; 을&lt;/a&gt; 사용하여 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bcd8fba8efdd683e73f79a7ad2f9cec72567b2a" translate="yes" xml:space="preserve">
          <source>Some of the information available through this module can also be obtained using the built-in system view &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt;.</source>
          <target state="translated">이 모듈을 통해 사용 가능한 일부 정보는 내장 시스템 뷰 &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl을&lt;/a&gt; 사용하여 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="998eae93551979387ddf2052647b42a2befb241c" translate="yes" xml:space="preserve">
          <source>Some of the information here is derived from Purdue University's SP-GiST Indexing Project &lt;a href=&quot;https://www.cs.purdue.edu/spgist/&quot;&gt;web site&lt;/a&gt;. The SP-GiST implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov, and there is more information on their &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/spgist_dev&quot;&gt;web site&lt;/a&gt;.</source>
          <target state="translated">여기에 포함 된 일부 정보는 Purdue University의 SP-GiST Indexing Project &lt;a href=&quot;https://www.cs.purdue.edu/spgist/&quot;&gt;웹 사이트에서 제공&lt;/a&gt; 됩니다. PostgreSQL의 SP-GiST 구현은 주로 Teodor Sigaev와 Oleg Bartunov에 의해 유지 관리되며 &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/spgist_dev&quot;&gt;웹 사이트&lt;/a&gt; 에 자세한 정보가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71a8fb9853bb2acd7004a3923f01c2609b9c283b" translate="yes" xml:space="preserve">
          <source>Some of the information here is derived from the University of California at Berkeley's GiST Indexing Project &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;web site&lt;/a&gt; and Marcel Kornacker's thesis, &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz&quot;&gt;Access Methods for Next-Generation Database Systems&lt;/a&gt;. The GiST implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov, and there is more information on their &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;web site&lt;/a&gt;.</source>
          <target state="translated">여기에있는 정보 중 일부는 버클리의 GiST 인덱싱 프로젝트 &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;웹 사이트&lt;/a&gt; 의 캘리포니아 대학 과 Marcel Kornacker의 논문, &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz&quot;&gt;차세대 데이터베이스 시스템의 액세스 방법&lt;/a&gt; 에서 파생되었습니다 . PostgreSQL의 GiST 구현은 주로 Teodor Sigaev와 Oleg Bartunov에 의해 유지 관리되며 &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;웹 사이트&lt;/a&gt; 에 자세한 정보가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa3d45e20bc01b432c95fa31fdba9a4be4974533" translate="yes" xml:space="preserve">
          <source>Some of the information in the dynamic statistics views shown in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-DYNAMIC-VIEWS-TABLE&quot;&gt;Table 27.1&lt;/a&gt; is security restricted. Ordinary users can only see all the information about their own sessions (sessions belonging to a role that they are a member of). In rows about other sessions, many columns will be null. Note, however, that the existence of a session and its general properties such as its sessions user and database are visible to all users. Superusers and members of the built-in role &lt;code&gt;pg_read_all_stats&lt;/code&gt; (see also &lt;a href=&quot;default-roles&quot;&gt;Section 21.5&lt;/a&gt;) can see all the information about all sessions.</source>
          <target state="translated">&lt;a href=&quot;monitoring-stats#MONITORING-STATS-DYNAMIC-VIEWS-TABLE&quot;&gt;표 27.1에&lt;/a&gt; 표시된 동적 통계보기의 일부 정보 는 보안이 제한됩니다. 일반 사용자는 자신의 세션 (구성원이 속한 역할에 속하는 세션)에 대한 모든 정보 만 볼 수 있습니다. 다른 세션에 대한 행에서 많은 열이 널입니다. 그러나 세션의 존재와 세션 사용자 및 데이터베이스와 같은 일반 특성은 모든 사용자가 볼 수 있습니다. 수퍼 유저 및 기본 제공 역할 &lt;code&gt;pg_read_all_stats&lt;/code&gt; ( &lt;a href=&quot;default-roles&quot;&gt;섹션 21.5&lt;/a&gt; 참조)의 구성원 은 모든 세션에 대한 모든 정보를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7472b311f893951097bd89898df528a213754aa8" translate="yes" xml:space="preserve">
          <source>Some of them are adaptive &amp;mdash; that means when computers get faster, you can tune the algorithm to be slower, without introducing incompatibility with existing passwords.</source>
          <target state="translated">그들 중 일부는 적응 적입니다. 즉 컴퓨터가 빨라지면 기존 암호와 호환되지 않으면 서 알고리즘 속도를 늦출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8218d881f3b4892e13890c237f4e2b09729ea08" translate="yes" xml:space="preserve">
          <source>Some of these functions take an optional &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; parameter, which specifies the behavior when the file or directory does not exist. If &lt;code&gt;true&lt;/code&gt;, the function returns &lt;code&gt;NULL&lt;/code&gt; or an empty result set, as appropriate. If &lt;code&gt;false&lt;/code&gt;, an error is raised. The default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이러한 함수 중 일부는 파일 또는 디렉터리가 없을 때 동작을 지정 하는 선택적 &lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt; 매개 변수를 사용합니다. 만약 &lt;code&gt;true&lt;/code&gt; , 함수 반환 &lt;code&gt;NULL&lt;/code&gt; 또는 적절한 빈 결과 집합. 경우 &lt;code&gt;false&lt;/code&gt; 오류가 발생합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f0080393fa4110592ce37e73e22c8cc67eadbce9" translate="yes" xml:space="preserve">
          <source>Some of these functions take an optional &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; parameter, which specifies the behavior when the file or directory does not exist. If &lt;code&gt;true&lt;/code&gt;, the function returns NULL (except &lt;code&gt;pg_ls_dir&lt;/code&gt;, which returns an empty result set). If &lt;code&gt;false&lt;/code&gt;, an error is raised. The default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이러한 함수 중 일부는 파일 또는 디렉토리가 존재하지 않을 때의 동작을 지정하는 &lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt; 매개 변수를 선택적으로 사용 합니다. 만약 &lt;code&gt;true&lt;/code&gt; , (제외 함수를 반환 NULL &lt;code&gt;pg_ls_dir&lt;/code&gt; 빈 결과 집합을 반환). 경우 &lt;code&gt;false&lt;/code&gt; 오류가 발생합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc7268a9deb76728b8086f34b6d6d866d1225b18" translate="yes" xml:space="preserve">
          <source>Some operating systems have maximum file size limits that cause problems when creating large pg_dump output files. Fortunately, pg_dump can write to the standard output, so you can use standard Unix tools to work around this potential problem. There are several possible methods:</source>
          <target state="translated">일부 운영 체제에는 최대 pg_dump 출력 파일을 만들 때 문제를 일으키는 최대 파일 크기 제한이 있습니다. 다행히도 pg_dump는 표준 출력에 쓸 수 있으므로 표준 Unix 도구를 사용하여이 잠재적 인 문제를 해결할 수 있습니다. 몇 가지 가능한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e338575c366f43f8b2639ad336ca9a7a216b1b43" translate="yes" xml:space="preserve">
          <source>Some operations require a stronger lock when using declarative partitioning than when using table inheritance. For example, adding or removing a partition to or from a partitioned table requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table, whereas a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock is enough in the case of regular inheritance.</source>
          <target state="translated">일부 작업은 선언적 파티셔닝을 사용할 때 테이블 상속을 사용할 때보 다 더 강력한 잠금이 필요합니다. 예를 들어, 파티션을 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 테이블에서 파티션을 추가하거나 제거하려면 상위 테이블에서 ACCESS EXCLUSIVE 잠금을 수행해야하지만, 정기적 상속의 경우 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="fe6ddb12524ba962819fd107b5d5d21072949f0a" translate="yes" xml:space="preserve">
          <source>Some operations require a stronger lock when using declarative partitioning than when using table inheritance. For example, removing a partition from a partitioned table requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table, whereas a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock is enough in the case of regular inheritance.</source>
          <target state="translated">일부 작업에서는 테이블 상속을 사용할 때보 다 선언적 파티셔닝을 사용할 때 더 강력한 잠금이 필요합니다. 예를 들어 파티션을 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 테이블에서 파티션을 제거하려면 상위 테이블에 대한 ACCESS EXCLUSIVE 잠금을 가져와야 하는 반면, &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금은 일반 상속의 경우 충분합니다.</target>
        </trans-unit>
        <trans-unit id="61e3abe67f9e498dad7dd4b0b6225bdcb51ca759" translate="yes" xml:space="preserve">
          <source>Some or all of the partitions might use index scans instead of full-table sequential scans, but the point here is that there is no need to scan the older partitions at all to answer this query. When we enable partition pruning, we get a significantly cheaper plan that will deliver the same answer:</source>
          <target state="translated">일부 또는 모든 파티션은 전체 테이블 순차 스캔 대신 인덱스 스캔을 사용할 수 있지만 여기서 요점은이 쿼리에 응답하기 위해 이전 파티션을 전혀 스캔 할 필요가 없다는 것입니다. 파티션 정리를 사용하면 동일한 답변을 제공하는 훨씬 저렴한 요금제를 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9c09533175ee5238ece4403cd28aab4c3d6867" translate="yes" xml:space="preserve">
          <source>Some other SQL databases cannot do this except by introducing a dummy one-row table from which to do the &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 를 수행 할 더미 한 행 테이블을 도입하는 것 외에는 다른 SQL 데이터베이스가이를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8e48c3cfe05616b784c085aec228d1d30217192f" translate="yes" xml:space="preserve">
          <source>Some other database systems offer a &lt;code&gt;FROM&lt;/code&gt; option in which the target table is supposed to be listed again within &lt;code&gt;FROM&lt;/code&gt;. That is not how PostgreSQL interprets &lt;code&gt;FROM&lt;/code&gt;. Be careful when porting applications that use this extension.</source>
          <target state="translated">일부 다른 데이터베이스 시스템은 목표 테이블이 &lt;code&gt;FROM&lt;/code&gt; 내에 다시 나열되는 &lt;code&gt;FROM&lt;/code&gt; 옵션을 제공합니다 . 이것이 PostgreSQL이 &lt;code&gt;FROM&lt;/code&gt; 을 해석하는 방식이 아닙니다 . 이 확장을 사용하는 응용 프로그램을 이식 할 때는주의하십시오.</target>
        </trans-unit>
        <trans-unit id="3ccfca55f686ba0ba31202a9076e341570267be4" translate="yes" xml:space="preserve">
          <source>Some other software that supports authentication against LDAP uses the same URL format, so it will be easier to share the configuration.</source>
          <target state="translated">LDAP 인증을 지원하는 다른 소프트웨어는 동일한 URL 형식을 사용하므로 구성을보다 쉽게 ​​공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71b8d062276566612555a164f3dc7042f0fd7cf6" translate="yes" xml:space="preserve">
          <source>Some special-purpose foreign data wrappers might be the only access mechanism for the data they access, and in that case it might be appropriate for the foreign data wrapper itself to perform constraint enforcement. But you should not assume that a wrapper does that unless its documentation says so.</source>
          <target state="translated">일부 특수 목적 외부 데이터 랩퍼는 액세스하는 데이터에 대한 유일한 액세스 메커니즘 일 수 있으며,이 경우 외부 데이터 랩퍼 자체가 제한 조건 시행을 수행하는 것이 적절할 수 있습니다. 그러나 문서에서 명시하지 않는 한 래퍼가 그렇게한다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="af48bc9080b84e2b906f615214a2d37c6c059d88" translate="yes" xml:space="preserve">
          <source>Some tips for configuring continuous archiving are given here.</source>
          <target state="translated">연속 보관을 구성하기위한 몇 가지 팁이 여기에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f3310ff2b17f16a36c0a651c12a66749bec48ae3" translate="yes" xml:space="preserve">
          <source>Some tree algorithms require knowledge of level (or depth) of the current tuple, so the SP-GiST core provides the possibility for operator classes to manage level counting while descending the tree. There is also support for incrementally reconstructing the represented value when that is needed, and for passing down additional data (called &lt;em&gt;traverse values&lt;/em&gt;) during a tree descent.</source>
          <target state="translated">일부 트리 알고리즘에는 현재 튜플의 레벨 (또는 깊이)에 대한 지식이 필요하므로 SP-GiST 코어는 운영자 클래스가 트리를 내림차순으로 레벨 계산을 관리 할 수있는 가능성을 제공합니다. 필요한 경우 표현 된 값을 점진적으로 재구성하고 트리 하강 중 추가 데이터 ( &lt;em&gt;통과 값&lt;/em&gt; 이라고 함)를 전달하는 기능도 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="57d5318999724a7149ff42127fe2b4b95dffe0c9" translate="yes" xml:space="preserve">
          <source>Some tree algorithms use a fixed set of nodes for each inner tuple; for example, in a quad-tree there are always exactly four nodes corresponding to the four quadrants around the inner tuple's centroid point. In such a case the code typically works with the nodes by number, and there is no need for explicit node labels. To suppress node labels (and thereby save some space), the &lt;code&gt;picksplit&lt;/code&gt; function can return NULL for the &lt;code&gt;nodeLabels&lt;/code&gt; array, and likewise the &lt;code&gt;choose&lt;/code&gt; function can return NULL for the &lt;code&gt;prefixNodeLabels&lt;/code&gt; array during a &lt;code&gt;spgSplitTuple&lt;/code&gt; action. This will in turn result in &lt;code&gt;nodeLabels&lt;/code&gt; being NULL during subsequent calls to &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt;. In principle, node labels could be used for some inner tuples and omitted for others in the same index.</source>
          <target state="translated">일부 트리 알고리즘은 각 내부 튜플에 대해 고정 된 노드 세트를 사용합니다. 예를 들어, 쿼드 트리에는 항상 내부 튜플의 중심점 주위에있는 4 개의 사분면에 해당하는 정확히 4 개의 노드가 있습니다. 이 경우 코드는 일반적으로 숫자로 노드와 작동하며 명시적인 노드 레이블이 필요하지 않습니다. 억제 노드 라벨 (하여 일부 공간 절약)까지, &lt;code&gt;picksplit&lt;/code&gt; 의 기능은 대한 NULL을 반환 할 수 있습니다 &lt;code&gt;nodeLabels&lt;/code&gt; 의 배열과 마찬가지로이 &lt;code&gt;choose&lt;/code&gt; 기능은 대한 NULL을 반환 할 수 있습니다 &lt;code&gt;prefixNodeLabels&lt;/code&gt; 의 동안 배열 &lt;code&gt;spgSplitTuple&lt;/code&gt; 의 작업입니다. 그러면 후속 호출을 &lt;code&gt;choose&lt;/code&gt; 하는 동안 &lt;code&gt;nodeLabels&lt;/code&gt; 가 NULL이 되고 &lt;code&gt;inner_consistent&lt;/code&gt; . 원칙적으로 노드 레이블은 일부 내부 튜플에 사용될 수 있고 동일한 인덱스의 다른 튜플에는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fef57a82235a3bb40e3216a5544ae33c006ceef2" translate="yes" xml:space="preserve">
          <source>Some vendors' Linux 2.4 kernels are reported to have early versions of the 2.6 overcommit &lt;code&gt;sysctl&lt;/code&gt; parameter. However, setting &lt;code&gt;vm.overcommit_memory&lt;/code&gt; to 2 on a 2.4 kernel that does not have the relevant code will make things worse, not better. It is recommended that you inspect the actual kernel source code (see the function &lt;code&gt;vm_enough_memory&lt;/code&gt; in the file &lt;code&gt;mm/mmap.c&lt;/code&gt;) to verify what is supported in your kernel before you try this in a 2.4 installation. The presence of the &lt;code&gt;overcommit-accounting&lt;/code&gt; documentation file should &lt;em&gt;not&lt;/em&gt; be taken as evidence that the feature is there. If in any doubt, consult a kernel expert or your kernel vendor.</source>
          <target state="translated">일부 공급 업체의 Linux 2.4 커널에는 초기 버전의 2.6 초과 커밋 &lt;code&gt;sysctl&lt;/code&gt; 매개 변수 가있는 것으로보고되었습니다 . 그러나 관련 코드가없는 2.4 커널에서 &lt;code&gt;vm.overcommit_memory&lt;/code&gt; 를 2로 설정 하면 상황이 나빠질 수 있습니다. 2.4 설치에서 시도하기 전에 실제 커널 소스 코드 ( &lt;code&gt;mm/mmap.c&lt;/code&gt; 파일의 &lt;code&gt;vm_enough_memory&lt;/code&gt; 기능 참조)를 검사하여 커널 에서 지원되는 기능을 확인하는 것이 좋습니다. &lt;code&gt;overcommit-accounting&lt;/code&gt; 문서 파일 의 존재 가 해당 기능이 있다는 증거로 간주 되어서는 &lt;em&gt;안됩니다&lt;/em&gt; . 의심스러운 경우 커널 전문가 나 커널 공급 업체에 문의하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2fbe02864d9f547750ff0847fc3b17a6cd2c8e5" translate="yes" xml:space="preserve">
          <source>Something else?</source>
          <target state="translated">다른 것?</target>
        </trans-unit>
        <trans-unit id="cbd9802f29e343358a1bc38fbcf396bd5c9cf041" translate="yes" xml:space="preserve">
          <source>Sometimes it is necessary for usability or standards-compliance reasons to provide multiple implicit casts among a set of types, resulting in ambiguity that cannot be avoided as above. The parser has a fallback heuristic based on &lt;em&gt;type categories&lt;/em&gt; and &lt;em&gt;preferred types&lt;/em&gt; that can help to provide desired behavior in such cases. See &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more information.</source>
          <target state="translated">때로는 유용성 또는 표준 준수 이유로 인해 일련의 유형간에 여러 암시 적 캐스트를 제공해야하므로 위와 같이 피할 수없는 모호함이 발생합니다. 파서는 &lt;em&gt;형식 범주&lt;/em&gt; 및 이러한 경우에 원하는 동작을 제공하는 데 도움이 &lt;em&gt;되는 기본 형식&lt;/em&gt; 에 따라 대체 휴리스틱을 갖습니다 . 자세한 내용은 &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="35cba18046c49966ef87424c371d019270f65601" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to declare the final function as taking not just the state value, but extra parameters corresponding to the aggregate's input values. The main reason for doing this is if the final function is polymorphic and the state value's data type would be inadequate to pin down the result type. These extra parameters are always passed as NULL (and so the final function must not be strict when the &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; option is used), but nonetheless they are valid parameters. The final function could for example make use of &lt;code&gt;get_fn_expr_argtype&lt;/code&gt; to identify the actual argument type in the current call.</source>
          <target state="translated">때로는 최종 함수를 상태 값뿐만 아니라 집계의 입력 값에 해당하는 추가 매개 변수를 사용하는 것으로 선언하는 것이 유용합니다. 이를 수행하는 주된 이유는 최종 함수가 다형성이고 상태 값의 데이터 유형이 결과 유형을 고정하기에 부적합한 경우입니다. 이러한 추가 매개 변수는 항상 NULL로 전달되므로 ( &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; 옵션을 사용할 때 최종 기능이 엄격하지 않아야 함 ) 그럼에도 불구하고 유효한 매개 변수입니다. 최종 함수는 예를 들어 &lt;code&gt;get_fn_expr_argtype&lt;/code&gt; 을 사용하여 현재 호출에서 실제 인수 유형을 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="797cb254adf7a7230145f1a464341319be9dfa7d" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to obtain data from modified rows while they are being manipulated. The &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; commands all have an optional &lt;code&gt;RETURNING&lt;/code&gt; clause that supports this. Use of &lt;code&gt;RETURNING&lt;/code&gt; avoids performing an extra database query to collect the data, and is especially valuable when it would otherwise be difficult to identify the modified rows reliably.</source>
          <target state="translated">때때로 조작되는 동안 수정 된 행에서 데이터를 얻는 것이 유용합니다. &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 명령은 모든 옵션이 &lt;code&gt;RETURNING&lt;/code&gt; 절 그 지원이. &lt;code&gt;RETURNING&lt;/code&gt; 을 사용 하면 데이터를 수집하기 위해 추가 데이터베이스 쿼리를 수행하지 않아도되며 수정 된 행을 안정적으로 식별하기 어려운 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="589b5dd99d1a3bcbbe7f0626815306690d452011" translate="yes" xml:space="preserve">
          <source>Sometimes the kernel is not able to allocate the desired number of huge pages immediately, so it might be necessary to repeat the command or to reboot. (Immediately after a reboot, most of the machine's memory should be available to convert into huge pages.) To verify the huge page allocation situation, use:</source>
          <target state="translated">때로는 커널이 원하는 수의 방대한 페이지를 즉시 할당 할 수 없으므로 명령을 반복하거나 재부팅해야 할 수도 있습니다. (재부팅 직후, 대부분의 시스템 메모리는 대용량 페이지로 변환 할 수 있어야합니다.) 대용량 페이지 할당 상황을 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="edba2e2a0a78402812ec4490cdbcf19480e52041" translate="yes" xml:space="preserve">
          <source>Sometimes you want to create a database for someone else, and have them become the owner of the new database, so they can configure and manage it themselves. To achieve that, use one of the following commands:</source>
          <target state="translated">때로는 다른 사람을 위해 데이터베이스를 작성하여 새 데이터베이스의 소유자가되게하여 스스로 구성하고 관리 할 수 ​​있습니다. 이를 위해서는 다음 명령 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b8a37657dd02608d89aed0a0142f45c74773cf9" translate="yes" xml:space="preserve">
          <source>Sort Greek letters before Latin ones. (The default is Latin before Greek.)</source>
          <target state="translated">라틴 문자보다 먼저 그리스 문자를 정렬하십시오. (기본값은 그리스어 이전의 라틴어입니다.)</target>
        </trans-unit>
        <trans-unit id="b21aa58de7ef6694d18e29bfbe7222c1853916f5" translate="yes" xml:space="preserve">
          <source>Sort digits after Latin letters. (The default is digits before letters.)</source>
          <target state="translated">라틴 문자 뒤에 숫자를 정렬하십시오. (기본값은 문자 앞의 숫자입니다.)</target>
        </trans-unit>
        <trans-unit id="d1e6c665bc2866719a6d3e376a5ee652e02e92c0" translate="yes" xml:space="preserve">
          <source>Sort order in queries using &lt;code&gt;ORDER BY&lt;/code&gt; or the standard comparison operators on textual data</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 또는 텍스트 데이터에 대한 표준 비교 연산자를 사용하여 쿼리에서 정렬 순서</target>
        </trans-unit>
        <trans-unit id="3d8c08c57a1664c733943a411e2d1d6937a4cb14" translate="yes" xml:space="preserve">
          <source>Sort upper-case letters before lower-case letters. (The default is lower-case letters first.)</source>
          <target state="translated">소문자 앞에 대문자를 정렬하십시오. (기본값은 소문자입니다.)</target>
        </trans-unit>
        <trans-unit id="860fb4b3c0b6c3f118c575971c19f66391707a1d" translate="yes" xml:space="preserve">
          <source>Sorts in ascending order.</source>
          <target state="translated">오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="1cb177b2e41fa46c7748282571ecd94be959367d" translate="yes" xml:space="preserve">
          <source>Sorts in descending order.</source>
          <target state="translated">내림차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="59252796a1d65178d94efabcab7b0090c538ee29" translate="yes" xml:space="preserve">
          <source>Sorts the array in either ascending or descending order. &lt;em&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/em&gt; must be &lt;code&gt;asc&lt;/code&gt; or &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">오름차순 또는 내림차순으로 배열을 정렬합니다. &lt;em&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/em&gt; 은 &lt;code&gt;asc&lt;/code&gt; 또는 &lt;code&gt;desc&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d04be466d23e4bb4785321abf9f797dfcaa3ed41" translate="yes" xml:space="preserve">
          <source>Source Encoding</source>
          <target state="translated">소스 인코딩</target>
        </trans-unit>
        <trans-unit id="433880eb1f5e9a2d5f29e070c62168b0c64a11c8" translate="yes" xml:space="preserve">
          <source>Source encoding ID</source>
          <target state="translated">소스 인코딩 ID</target>
        </trans-unit>
        <trans-unit id="c1adb3913f4193c7ddc6a756d5779d712f2facaf" translate="yes" xml:space="preserve">
          <source>Source of the current parameter value</source>
          <target state="translated">현재 매개 변수 값의 소스</target>
        </trans-unit>
        <trans-unit id="2fe0fca9eb383c1b96dff89e4745ca807c376cbf" translate="yes" xml:space="preserve">
          <source>Source origin</source>
          <target state="translated">출처</target>
        </trans-unit>
        <trans-unit id="eb451b00bcf980ee35211d8edf035951afa327d2" translate="yes" xml:space="preserve">
          <source>South European</source>
          <target state="translated">남유럽</target>
        </trans-unit>
        <trans-unit id="842530dcfd763404d88c4b3546ef7a177843fa85" translate="yes" xml:space="preserve">
          <source>Space in data pages which does not contain current row versions, such as unused (free) space or outdated row versions.</source>
          <target state="translated">사용되지 않은 (사용 가능한) 공간 또는 오래된 행 버전과 같이 현재 행 버전을 포함하지 않는 데이터 페이지의 공간입니다.</target>
        </trans-unit>
        <trans-unit id="47438f611e9b4675f207aeccb246419a0fc0c2d3" translate="yes" xml:space="preserve">
          <source>Space symbols</source>
          <target state="translated">공간 기호</target>
        </trans-unit>
        <trans-unit id="4ee8867d129c7487cd99e817409452159e8107d2" translate="yes" xml:space="preserve">
          <source>Space-Partitioned Generalized Search Tree</source>
          <target state="translated">공간 분할 일반화 된 검색 트리</target>
        </trans-unit>
        <trans-unit id="b01bd8098830254d8d1b392aaf2bc493d078745c" translate="yes" xml:space="preserve">
          <source>Spaces within &lt;code&gt;extra-options&lt;/code&gt; are considered to separate arguments, unless escaped with a backslash (&lt;code&gt;\&lt;/code&gt;); write &lt;code&gt;\\&lt;/code&gt; to represent a literal backslash. Multiple arguments can also be specified via multiple uses of &lt;code&gt;-o&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;extra-options&lt;/code&gt; 내의 공백 은 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )로 이스케이프되지 않는 한 인수를 분리하는 것으로 간주됩니다 . 리터럴 백 슬래시를 나타내려면 &lt;code&gt;\\&lt;/code&gt; 를 쓰십시오 . &lt;code&gt;-o&lt;/code&gt; 를 여러 번 사용하여 여러 인수를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24923348b3b262d2936795f06c187845446e0aaf" translate="yes" xml:space="preserve">
          <source>Special space</source>
          <target state="translated">특별한 공간</target>
        </trans-unit>
        <trans-unit id="72380f82fd48833ecee5e3f80a7a2ddcde3793aa" translate="yes" xml:space="preserve">
          <source>Specific characteristics of the GEQO implementation in PostgreSQL are:</source>
          <target state="translated">PostgreSQL에서 GEQO 구현의 특정 특성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f4bcf9d24713a3110977a36b61a9419fe8cd063" translate="yes" xml:space="preserve">
          <source>Specific stop words recognized by the subdictionary cannot be specified; instead use &lt;code&gt;?&lt;/code&gt; to mark the location where any stop word can appear. For example, assuming that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;the&lt;/code&gt; are stop words according to the subdictionary:</source>
          <target state="translated">사전에서 인식 된 특정 중지 단어는 지정할 수 없습니다. 대신에 &lt;code&gt;?&lt;/code&gt; 중지 단어가 나타날 수있는 위치를 표시합니다. 예를 들어, &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;the&lt;/code&gt; 가 하위 사전에 따라 중지 단어 라고 가정하면</target>
        </trans-unit>
        <trans-unit id="256558cd909ae0b53e922f71288280e54ad5ed4b" translate="yes" xml:space="preserve">
          <source>Specific types of privileges, as defined in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ddl-priv&quot;&gt;섹션 5.7에&lt;/a&gt; 정의 된 특정 유형의 권한 .</target>
        </trans-unit>
        <trans-unit id="485f7bec8612e15316f0401415ceefa8d151c5ed" translate="yes" xml:space="preserve">
          <source>Specifies a comment to be associated with the newly created database.</source>
          <target state="translated">새로 작성된 데이터베이스와 연관시킬 주석을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c9ceefa0539c43a42c5a8a5bddc9ad741a927680" translate="yes" xml:space="preserve">
          <source>Specifies a connection string to be used for the standby server to connect with a sending server. This string is in the format described in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;. If any option is unspecified in this string, then the corresponding environment variable (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;) is checked. If the environment variable is not set either, then defaults are used.</source>
          <target state="translated">대기 서버가 송신 서버와 연결하는 데 사용할 연결 문자열을 지정합니다. 이 문자열은 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;33.1.1 절에&lt;/a&gt; 설명 된 형식으로되어 있습니다. 이 문자열에서 옵션을 지정하지 않으면 해당 환경 변수 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;섹션 33.14&lt;/a&gt; 참조 )가 검사됩니다. 환경 변수가 설정되지 않은 경우 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c5b01935c0c54303e901014bd929cd657e6ae52" translate="yes" xml:space="preserve">
          <source>Specifies a connection string to be used for the standby server to connect with a sending server. This string is in the format described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;. If any option is unspecified in this string, then the corresponding environment variable (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;) is checked. If the environment variable is not set either, then defaults are used.</source>
          <target state="translated">Specifies a connection string to be used for the standby server to connect with a sending server. This string is in the format described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;. If any option is unspecified in this string, then the corresponding environment variable (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;) is checked. If the environment variable is not set either, then defaults are used.</target>
        </trans-unit>
        <trans-unit id="b081623c0ed797e7348b5165771793e1f80eb1a2" translate="yes" xml:space="preserve">
          <source>Specifies a directory to search for log segment files or a directory with a &lt;code&gt;pg_wal&lt;/code&gt; subdirectory that contains such files. The default is to search in the current directory, the &lt;code&gt;pg_wal&lt;/code&gt; subdirectory of the current directory, and the &lt;code&gt;pg_wal&lt;/code&gt; subdirectory of &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">로그 세그먼트 파일을 검색 할 디렉토리 또는 해당 파일이 포함 된 &lt;code&gt;pg_wal&lt;/code&gt; 서브 디렉토리가있는 디렉토리를 지정 합니다. 기본값은 현재 디렉토리의에서 검색하는 것입니다 &lt;code&gt;pg_wal&lt;/code&gt; 현재 디렉토리의 하위 디렉토리 및 &lt;code&gt;pg_wal&lt;/code&gt; 의 하위 디렉토리 &lt;code&gt;PGDATA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2fa93c39bc71d53501aef52502b7ce5fa345b9f" translate="yes" xml:space="preserve">
          <source>Specifies a fraction of the table size to add to &lt;code&gt;autovacuum_analyze_threshold&lt;/code&gt; when deciding whether to trigger an &lt;code&gt;ANALYZE&lt;/code&gt;. The default is 0.1 (10% of table size). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 트리거 여부를 결정할 때 &lt;code&gt;autovacuum_analyze_threshold&lt;/code&gt; 에 추가 할 테이블 크기의 일부를 지정합니다 . 기본값은 0.1 (테이블 크기의 10 %)입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 그러나 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e04ea0da871d5ecbedeea42c99283c8eb0d137b" translate="yes" xml:space="preserve">
          <source>Specifies a fraction of the table size to add to &lt;code&gt;autovacuum_vacuum_insert_threshold&lt;/code&gt; when deciding whether to trigger a &lt;code&gt;VACUUM&lt;/code&gt;. The default is 0.2 (20% of table size). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">Specifies a fraction of the table size to add to &lt;code&gt;autovacuum_vacuum_insert_threshold&lt;/code&gt; when deciding whether to trigger a &lt;code&gt;VACUUM&lt;/code&gt; . The default is 0.2 (20% of table size). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</target>
        </trans-unit>
        <trans-unit id="86582b4f6a8af5a5577fc3a8aa32d5d7a70f31fc" translate="yes" xml:space="preserve">
          <source>Specifies a fraction of the table size to add to &lt;code&gt;autovacuum_vacuum_threshold&lt;/code&gt; when deciding whether to trigger a &lt;code&gt;VACUUM&lt;/code&gt;. The default is 0.2 (20% of table size). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 트리거 여부를 결정할 때 &lt;code&gt;autovacuum_vacuum_threshold&lt;/code&gt; 에 추가 할 테이블 크기의 일부를 지정합니다 . 기본값은 0.2 (테이블 크기의 20 %)입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 그러나 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cb86159ae43bca86d1259ed722d1b98469a1bc6" translate="yes" xml:space="preserve">
          <source>Specifies a libpq connection string to connect to the source PostgreSQL server to synchronize the target with. The connection must be a normal (non-replication) connection with a role having sufficient permissions to execute the functions used by pg_rewind on the source server (see Notes section for details) or a superuser role. This option requires the source server to be running and not in recovery mode.</source>
          <target state="translated">대상을 동기화하기 위해 소스 PostgreSQL 서버에 연결할 libpq 연결 문자열을 지정합니다. 연결은 소스 서버에서 pg_rewind가 사용하는 기능 (자세한 내용은 참고 섹션 참조)을 실행하기에 충분한 권한이있는 역할 또는 수퍼 유저 역할을 가진 일반 (복제되지 않은) 연결이어야합니다. 이 옵션을 사용하려면 소스 서버가 실행 중이어야하고 복구 모드가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="750f5a5345e3eb074813137e4b782fcea3d330db" translate="yes" xml:space="preserve">
          <source>Specifies a list of SSL cipher suites that are allowed to be used by SSL connections. See the ciphers manual page in the OpenSSL package for the syntax of this setting and a list of supported values. Only connections using TLS version 1.2 and lower are affected. There is currently no setting that controls the cipher choices used by TLS version 1.3 connections. The default value is &lt;code&gt;HIGH:MEDIUM:+3DES:!aNULL&lt;/code&gt;. The default is usually a reasonable choice unless you have specific security requirements.</source>
          <target state="translated">Specifies a list of SSL cipher suites that are allowed to be used by SSL connections. See the ciphers manual page in the OpenSSL package for the syntax of this setting and a list of supported values. Only connections using TLS version 1.2 and lower are affected. There is currently no setting that controls the cipher choices used by TLS version 1.3 connections. The default value is &lt;code&gt;HIGH:MEDIUM:+3DES:!aNULL&lt;/code&gt; . The default is usually a reasonable choice unless you have specific security requirements.</target>
        </trans-unit>
        <trans-unit id="303375caa9c73f3b153b6eae3adeab7d201930a6" translate="yes" xml:space="preserve">
          <source>Specifies a list of SSL cipher suites that are allowed to be used on secure connections. See the ciphers manual page in the OpenSSL package for the syntax of this setting and a list of supported values. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default value is &lt;code&gt;HIGH:MEDIUM:+3DES:!aNULL&lt;/code&gt;. The default is usually a reasonable choice unless you have specific security requirements.</source>
          <target state="translated">보안 연결에 사용할 수있는 SSL 암호 스위트 목록을 지정합니다. 이 설정의 구문과 지원되는 값 목록은 OpenSSL 패키지의 암호 매뉴얼 페이지를 참조하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;HIGH:MEDIUM:+3DES:!aNULL&lt;/code&gt; 입니다. 특정 보안 요구 사항이 없으면 일반적으로 기본값을 선택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d9a24cf657886ce881d2bbc497ab600c09cb7ad5" translate="yes" xml:space="preserve">
          <source>Specifies a list of standby servers that can support &lt;em&gt;synchronous replication&lt;/em&gt;, as described in &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;. There will be one or more active synchronous standbys; transactions waiting for commit will be allowed to proceed after these standby servers confirm receipt of their data. The synchronous standbys will be those whose names appear in this list, and that are both currently connected and streaming data in real-time (as shown by a state of &lt;code&gt;streaming&lt;/code&gt; in the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; view). Specifying more than one synchronous standby can allow for very high availability and protection against data loss.</source>
          <target state="translated">Specifies a list of standby servers that can support &lt;em&gt;synchronous replication&lt;/em&gt;, as described in &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;. There will be one or more active synchronous standbys; transactions waiting for commit will be allowed to proceed after these standby servers confirm receipt of their data. The synchronous standbys will be those whose names appear in this list, and that are both currently connected and streaming data in real-time (as shown by a state of &lt;code&gt;streaming&lt;/code&gt; in the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt; &lt;code&gt;pg_stat_replication&lt;/code&gt; &lt;/a&gt; view). Specifying more than one synchronous standby can allow for very high availability and protection against data loss.</target>
        </trans-unit>
        <trans-unit id="0c28a686e64fc852928cd8354ae41c3ef1e9d031" translate="yes" xml:space="preserve">
          <source>Specifies a list of standby servers that can support &lt;em&gt;synchronous replication&lt;/em&gt;, as described in &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;. There will be one or more active synchronous standbys; transactions waiting for commit will be allowed to proceed after these standby servers confirm receipt of their data. The synchronous standbys will be those whose names appear in this list, and that are both currently connected and streaming data in real-time (as shown by a state of &lt;code&gt;streaming&lt;/code&gt; in the &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; view). Specifying more than one synchronous standby can allow for very high availability and protection against data loss.</source>
          <target state="translated">&lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;26.2.8 절에&lt;/a&gt; 설명 된대로 &lt;em&gt;동기식 복제를&lt;/em&gt; 지원할 수있는 대기 서버 목록을 지정합니다 . 하나 이상의 활성 동기 대기가 있습니다. 커밋을 기다리는 트랜잭션은 이러한 대기 서버가 데이터 수신을 확인한 후에 진행될 수 있습니다. 동기 대기는 이름이이 목록에 표시되고 현재 연결되어 있고 실시간으로 데이터를 &lt;code&gt;streaming&lt;/code&gt; 하는 것입니다 ( &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt; &lt;code&gt;pg_stat_replication&lt;/code&gt; &lt;/a&gt; 보기 에서 스트리밍 상태로 표시됨 ). 둘 이상의 동기 대기를 지정하면 가용성을 높이고 데이터 손실을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81a9a1823be5c195bf476a0cf9f99a7a4d63bd93" translate="yes" xml:space="preserve">
          <source>Specifies a list of tables to add to the publication. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is added to the publication. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are added. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">게시에 추가 할 테이블 목록을 지정합니다. 테이블 이름 앞에 &lt;code&gt;ONLY&lt;/code&gt; 를 지정 하면 해당 테이블 만 게시에 추가됩니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은 테이블과 그 모든 자손 테이블 (있는 경우)에 추가됩니다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함되었음을 명시 적으로 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3dbfa9cf4ca255549603199e5beb25b6c6a3ffb" translate="yes" xml:space="preserve">
          <source>Specifies a list of tables to add to the publication. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is added to the publication. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are added. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included. This does not apply to a partitioned table, however. The partitions of a partitioned table are always implicitly considered part of the publication, so they are never explicitly added to the publication.</source>
          <target state="translated">Specifies a list of tables to add to the publication. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is added to the publication. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are added. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included. This does not apply to a partitioned table, however. The partitions of a partitioned table are always implicitly considered part of the publication, so they are never explicitly added to the publication.</target>
        </trans-unit>
        <trans-unit id="f7e000cf8931e185d3ccddfb7bb0ec8a54c6c6c0" translate="yes" xml:space="preserve">
          <source>Specifies a new handler function for the foreign-data wrapper.</source>
          <target state="translated">외부 데이터 랩퍼에 대한 새로운 핸들러 함수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4c9fb3f4fcac7cdc6ca5913424f3d4cd3d162f10" translate="yes" xml:space="preserve">
          <source>Specifies a new validator function for the foreign-data wrapper.</source>
          <target state="translated">외부 데이터 랩퍼에 대한 새 유효성 검증기 함수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="44314eaabdf717fe8af5fe9d854dbb059f9551ad" translate="yes" xml:space="preserve">
          <source>Specifies a non-negative integer value passed to the selected option.</source>
          <target state="translated">Specifies a non-negative integer value passed to the selected option.</target>
        </trans-unit>
        <trans-unit id="98a9da57955268cb4e2d34a66294a7568883c21e" translate="yes" xml:space="preserve">
          <source>Specifies a role name to be used to create the dump. This option causes pg_dump to issue a &lt;code&gt;SET ROLE&lt;/code&gt;&lt;code&gt;rolename&lt;/code&gt; command after connecting to the database. It is useful when the authenticated user (specified by &lt;code&gt;-U&lt;/code&gt;) lacks privileges needed by pg_dump, but can switch to a role with the required rights. Some installations have a policy against logging in directly as a superuser, and use of this option allows dumps to be made without violating the policy.</source>
          <target state="translated">덤프를 작성하는 데 사용할 역할 이름을 지정합니다. 이 옵션은 데이터베이스에 연결 한 후 pg_dump가 &lt;code&gt;SET ROLE&lt;/code&gt; &lt;code&gt;rolename&lt;/code&gt; 명령을 실행하게합니다. 인증 된 사용자 ( &lt;code&gt;-U&lt;/code&gt; 로 지정 )에 pg_dump에 필요한 권한이 없지만 필요한 권한이있는 역할로 전환 할 수있는 경우에 유용 합니다. 일부 설치에는 수퍼 유저로 직접 로그인하는 것에 대한 정책이 있으며이 옵션을 사용하면 정책을 위반하지 않고 덤프를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f6effd1fcf89ea81626f8bea4fa3151cc8bee9" translate="yes" xml:space="preserve">
          <source>Specifies a role name to be used to create the dump. This option causes pg_dumpall to issue a &lt;code&gt;SET ROLE&lt;/code&gt;&lt;code&gt;rolename&lt;/code&gt; command after connecting to the database. It is useful when the authenticated user (specified by &lt;code&gt;-U&lt;/code&gt;) lacks privileges needed by pg_dumpall, but can switch to a role with the required rights. Some installations have a policy against logging in directly as a superuser, and use of this option allows dumps to be made without violating the policy.</source>
          <target state="translated">덤프를 작성하는 데 사용할 역할 이름을 지정합니다. 이 옵션은 데이터베이스에 연결 한 후 pg_dumpall이 &lt;code&gt;SET ROLE&lt;/code&gt; &lt;code&gt;rolename&lt;/code&gt; 명령을 실행하게합니다. 인증 된 사용자 ( &lt;code&gt;-U&lt;/code&gt; 로 지정 )에 pg_dumpall에 필요한 권한이 없지만 필요한 권한이있는 역할로 전환 할 수있는 경우에 유용 합니다. 일부 설치에는 수퍼 유저로 직접 로그인하는 것에 대한 정책이 있으며이 옵션을 사용하면 정책을 위반하지 않고 덤프를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="165287e18c5310eacc9eb63af786b0dc40a50d69" translate="yes" xml:space="preserve">
          <source>Specifies a role name to be used to perform the restore. This option causes pg_restore to issue a &lt;code&gt;SET ROLE&lt;/code&gt;&lt;code&gt;rolename&lt;/code&gt; command after connecting to the database. It is useful when the authenticated user (specified by &lt;code&gt;-U&lt;/code&gt;) lacks privileges needed by pg_restore, but can switch to a role with the required rights. Some installations have a policy against logging in directly as a superuser, and use of this option allows restores to be performed without violating the policy.</source>
          <target state="translated">복원을 수행하는 데 사용할 역할 이름을 지정합니다. 이 옵션은 데이터베이스에 연결 한 후 pg_restore가 &lt;code&gt;SET ROLE&lt;/code&gt; &lt;code&gt;rolename&lt;/code&gt; 명령을 실행하게합니다. 인증 된 사용자 ( &lt;code&gt;-U&lt;/code&gt; 로 지정 )에 pg_restore에 필요한 권한이 없지만 필요한 권한이있는 역할로 전환 할 수있는 경우에 유용 합니다. 일부 설치에는 수퍼 유저로 직접 로그인하는 것에 대한 정책이 있으며이 옵션을 사용하면 정책을 위반하지 않고 복원을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e0009d58097fa4576b363e328e699964357ec44" translate="yes" xml:space="preserve">
          <source>Specifies a trigger file whose presence ends recovery in the standby. Even if this value is not set, you can still promote the standby using &lt;code&gt;pg_ctl promote&lt;/code&gt; or calling &lt;code&gt;pg_promote()&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Specifies a trigger file whose presence ends recovery in the standby. Even if this value is not set, you can still promote the standby using &lt;code&gt;pg_ctl promote&lt;/code&gt; or calling &lt;code&gt;pg_promote()&lt;/code&gt; . This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</target>
        </trans-unit>
        <trans-unit id="2bf3e260ba2bcb84939f82a7f5794cf7be8cbe77" translate="yes" xml:space="preserve">
          <source>Specifies a trigger file whose presence ends recovery in the standby. Even if this value is not set, you can still promote the standby using &lt;code&gt;pg_ctl promote&lt;/code&gt; or calling &lt;code&gt;pg_promote&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">대기 상태에서 존재가 복구를 종료하는 트리거 파일을 지정합니다. 이 값을 설정하지 않아도 &lt;code&gt;pg_ctl promote&lt;/code&gt; 를 사용 하거나 &lt;code&gt;pg_promote&lt;/code&gt; 를 호출 하여 대기를 승격시킬 수 있습니다 . 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b771f77e3208dfdb862ea17ec77c098ceb85b083" translate="yes" xml:space="preserve">
          <source>Specifies ascending sort order (which is the default).</source>
          <target state="translated">오름차순 정렬 순서를 지정합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="f45bd1e2f879c77bb7b53e35432df6d7316730e0" translate="yes" xml:space="preserve">
          <source>Specifies attributes to be placed within the &lt;code&gt;table&lt;/code&gt; tag in HTML output format. This command is equivalent to &lt;code&gt;\pset tableattr table_options&lt;/code&gt;.</source>
          <target state="translated">HTML 태그 형식으로 &lt;code&gt;table&lt;/code&gt; 태그 내에 배치 할 속성을 지정 합니다. 이 명령은 &lt;code&gt;\pset tableattr table_options&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3902fb3ce777aa35b3fac2a50efa7d3dabb9a8a2" translate="yes" xml:space="preserve">
          <source>Specifies descending sort order.</source>
          <target state="translated">내림차순 정렬을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2094bd447cab55c69a3258b59ddc2b44f1ae8abd" translate="yes" xml:space="preserve">
          <source>Specifies how long the standby server should wait when WAL data is not available from any sources (streaming replication, local &lt;code&gt;pg_wal&lt;/code&gt; or WAL archive) before trying again to retrieve WAL data. If this value is specified without units, it is taken as milliseconds. The default value is 5 seconds. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WAL 데이터를 다시 검색하기 전에 어떤 소스 (스트리밍 복제, 로컬 &lt;code&gt;pg_wal&lt;/code&gt; 또는 WAL 아카이브) 에서 WAL 데이터를 사용할 수 없을 때 대기 서버가 대기해야하는 시간을 지정합니다 . 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 5 초입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="324f3241e53fb654f2cf37e293c784beb4b68a4a" translate="yes" xml:space="preserve">
          <source>Specifies how much WAL processing must complete before the database server returns a &amp;ldquo;success&amp;rdquo; indication to the client. Valid values are &lt;code&gt;remote_apply&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt; (the default), &lt;code&gt;remote_write&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, and &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Specifies how much WAL processing must complete before the database server returns a &amp;ldquo;success&amp;rdquo; indication to the client. Valid values are &lt;code&gt;remote_apply&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; (the default), &lt;code&gt;remote_write&lt;/code&gt; , &lt;code&gt;local&lt;/code&gt; , and &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7110d892a84ed64ce28057aab49a0c4fe20a912" translate="yes" xml:space="preserve">
          <source>Specifies how often pg_recvlogical should issue &lt;code&gt;fsync()&lt;/code&gt; calls to ensure the output file is safely flushed to disk.</source>
          <target state="translated">출력 파일이 디스크로 안전하게 플러시되도록 pg_recvlogical이 &lt;code&gt;fsync()&lt;/code&gt; 호출을 발행하는 빈도를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="ee12e1c7639485eefc5a786fbb90cdbabeea8a25" translate="yes" xml:space="preserve">
          <source>Specifies how often the WAL writer flushes WAL, in time terms. After flushing WAL the writer sleeps for the length of time given by &lt;code&gt;wal_writer_delay&lt;/code&gt;, unless woken up sooner by an asynchronously committing transaction. If the last flush happened less than &lt;code&gt;wal_writer_delay&lt;/code&gt; ago and less than &lt;code&gt;wal_writer_flush_after&lt;/code&gt; worth of WAL has been produced since, then WAL is only written to the operating system, not flushed to disk. If this value is specified without units, it is taken as milliseconds. The default value is 200 milliseconds (&lt;code&gt;200ms&lt;/code&gt;). Note that on many systems, the effective resolution of sleep delays is 10 milliseconds; setting &lt;code&gt;wal_writer_delay&lt;/code&gt; to a value that is not a multiple of 10 might have the same results as setting it to the next higher multiple of 10. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WAL 기록기가 WAL을 플러시하는 빈도를 시간 단위로 지정합니다. WAL을 플러시 한 후 라이터 는 트랜잭션을 비동기 적으로 커밋하여 더 빨리 &lt;code&gt;wal_writer_delay&lt;/code&gt; 않으면 wal_writer_delay 에 의해 주어진 시간 동안 휴면 상태 가됩니다. 마지막 플러시가 &lt;code&gt;wal_writer_delay&lt;/code&gt; 이전 및 &lt;code&gt;wal_writer_flush_after&lt;/code&gt; 보다 적은 WAL이 생성 된 이후에 발생한 경우 WAL은 디스크로 플러시되지 않고 운영 체제에만 기록됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 200 밀리 초 ( &lt;code&gt;200ms&lt;/code&gt; )입니다. 많은 시스템에서 수면 지연의 유효 해상도는 10 밀리 초입니다. &lt;code&gt;wal_writer_delay&lt;/code&gt; 설정10의 배수가 아닌 값으로 설정하면 다음 10의 배수로 설정하는 것과 동일한 결과를 얻을 수 있습니다.이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 행 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fa378fb7ad959cf32cfce451c32fbd81700116c" translate="yes" xml:space="preserve">
          <source>Specifies how often the WAL writer flushes WAL, in volume terms. If the last flush happened less than &lt;code&gt;wal_writer_delay&lt;/code&gt; ago and less than &lt;code&gt;wal_writer_flush_after&lt;/code&gt; worth of WAL has been produced since, then WAL is only written to the operating system, not flushed to disk. If &lt;code&gt;wal_writer_flush_after&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt; then WAL data is always flushed immediately. If this value is specified without units, it is taken as WAL blocks, that is &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; bytes, typically 8kB. The default is &lt;code&gt;1MB&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WAL 작성기가 WAL을 플러시하는 빈도를 볼륨 단위로 지정합니다. 마지막 플러시가 &lt;code&gt;wal_writer_delay&lt;/code&gt; 이전 및 &lt;code&gt;wal_writer_flush_after&lt;/code&gt; 보다 적은 WAL이 생성 된 이후에 발생한 경우 WAL은 디스크로 플러시되지 않고 운영 체제에만 기록됩니다. &lt;code&gt;wal_writer_flush_after&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 WAL 데이터는 항상 즉시 플러시됩니다. 이 값을 단위없이 지정하면 WAL 블록, 즉 &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; 바이트 (일반적으로 8kB)로 사용됩니다. 기본값은 &lt;code&gt;1MB&lt;/code&gt; 입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="121d15310185ca050dd604bbb921da9d21c4961c" translate="yes" xml:space="preserve">
          <source>Specifies maximum number of logical replication workers. This includes both apply workers and table synchronization workers.</source>
          <target state="translated">최대 논리적 복제 작업자 수를 지정합니다. 여기에는 적용 작업자와 테이블 동기화 작업자가 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="da30a645950363aa58ae8666a48a1f3531ade39e" translate="yes" xml:space="preserve">
          <source>Specifies options to be passed directly to the &lt;code&gt;initdb&lt;/code&gt; command. &lt;code&gt;-o&lt;/code&gt; can be specified multiple times, with all the given options being passed through.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 명령으로 직접 전달할 옵션을 지정 합니다. &lt;code&gt;-o&lt;/code&gt; 는 지정된 모든 옵션을 통과하여 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a04e02ab7244c5c19d98dc2a1ff30c6e8b2cc1c4" translate="yes" xml:space="preserve">
          <source>Specifies options to be passed directly to the &lt;code&gt;postgres&lt;/code&gt; command. &lt;code&gt;-o&lt;/code&gt; can be specified multiple times, with all the given options being passed through.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 명령으로 직접 전달할 옵션을 지정 합니다. &lt;code&gt;-o&lt;/code&gt; 는 지정된 모든 옵션을 통과하여 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="581d7eb5d2c020c94b55a6bb5660a9fe5f91bfa5" translate="yes" xml:space="preserve">
          <source>Specifies options to be placed within the HTML &lt;code&gt;table&lt;/code&gt; tag. See &lt;code&gt;\pset tableattr&lt;/code&gt; for details.</source>
          <target state="translated">HTML &lt;code&gt;table&lt;/code&gt; 태그 내에 배치 할 옵션을 지정 합니다 . 자세한 내용은 &lt;code&gt;\pset tableattr&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="058044dd4e58b3336471e5049f9d048ba6ce5256" translate="yes" xml:space="preserve">
          <source>Specifies parameters used to connect to the server, as a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connction string&lt;/a&gt;; these will override any conflicting command line options.</source>
          <target state="translated">Specifies parameters used to connect to the server, as a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connction string&lt;/a&gt;; these will override any conflicting command line options.</target>
        </trans-unit>
        <trans-unit id="184ed54a0493df32b5d7bc8d569546c6dafe6a6d" translate="yes" xml:space="preserve">
          <source>Specifies parameters used to connect to the server, as a connection string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information.</source>
          <target state="translated">서버에 연결하는 데 사용되는 매개 변수를 연결 문자열로 지정합니다. 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;33.1.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc2394d8362dc1e23a30e4533949f9b7335d49c0" translate="yes" xml:space="preserve">
          <source>Specifies printing options, in the style of &lt;code&gt;\pset&lt;/code&gt;. Note that here you have to separate name and value with an equal sign instead of a space. For example, to set the output format to LaTeX, you could write &lt;code&gt;-P format=latex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; 스타일로 인쇄 옵션을 지정 합니다. 여기서 이름과 값을 공백 대신 등호로 구분해야합니다. 예를 들어, 출력 형식을 LaTeX로 설정하려면 &lt;code&gt;-P format=latex&lt;/code&gt; 를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bbd4a06fbdac40a5affd7a9f05d89015d842bbe" translate="yes" xml:space="preserve">
          <source>Specifies recovering into a particular timeline. The value can be a numeric timeline ID or a special value. The value &lt;code&gt;current&lt;/code&gt; recovers along the same timeline that was current when the base backup was taken. The value &lt;code&gt;latest&lt;/code&gt; recovers to the latest timeline found in the archive, which is useful in a standby server. &lt;code&gt;latest&lt;/code&gt; is the default.</source>
          <target state="translated">특정 타임 라인으로 복구하도록 지정합니다. 값은 숫자 타임 라인 ID 또는 특수 값일 수 있습니다. &lt;code&gt;current&lt;/code&gt; 값 은 기본 백업을 수행 할 당시와 동일한 타임 라인을 따라 복구됩니다. &lt;code&gt;latest&lt;/code&gt; 값 은 아카이브에서 찾은 최신 타임 라인으로 복구되며 대기 서버에서 유용합니다. &lt;code&gt;latest&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="8f1e665218083218130fead85a69aea0dd1b4cab" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;ANALYZE&lt;/code&gt; should not wait for any conflicting locks to be released when beginning work on a relation: if a relation cannot be locked immediately without waiting, the relation is skipped. Note that even with this option, &lt;code&gt;ANALYZE&lt;/code&gt; may still block when opening the relation's indexes or when acquiring sample rows from partitions, table inheritance children, and some types of foreign tables. Also, while &lt;code&gt;ANALYZE&lt;/code&gt; ordinarily processes all partitions of specified partitioned tables, this option will cause &lt;code&gt;ANALYZE&lt;/code&gt; to skip all partitions if there is a conflicting lock on the partitioned table.</source>
          <target state="translated">관계에 대한 작업을 시작할 때 충돌 잠금이 해제 될 때까지 &lt;code&gt;ANALYZE&lt;/code&gt; 가 대기하지 않도록 지정합니다 . 대기하지 않고 관계를 즉시 잠글 수없는 경우 관계를 건너 뜁니다. 이 옵션을 사용하더라도 관계 인덱스를 열거 나 파티션, 테이블 상속 자식 및 일부 외부 테이블에서 샘플 행을 가져올 때 &lt;code&gt;ANALYZE&lt;/code&gt; 가 여전히 차단 될 수 있습니다. 또한 &lt;code&gt;ANALYZE&lt;/code&gt; 는 일반적으로 지정된 파티션 된 테이블의 모든 파티션을 처리 하지만 이 옵션은 파티션 된 테이블에 충돌하는 잠금이있는 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 가 모든 파티션을 건너 뛰도록합니다.</target>
        </trans-unit>
        <trans-unit id="c474d1ecc2dc032b14a63f3354a144e0faab7390" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;LOCK TABLE&lt;/code&gt; should not wait for any conflicting locks to be released: if the specified lock(s) cannot be acquired immediately without waiting, the transaction is aborted.</source>
          <target state="translated">&lt;code&gt;LOCK TABLE&lt;/code&gt; 이 충돌하는 잠금이 해제 될 때까지 기다리지 않도록 지정합니다 . 지정된 잠금을 기다리지 않고 즉시 확보 할 수 없으면 트랜잭션이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="d5f1d53fa991b08f1e38cb6c6ba9fecdca72fb9f" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;VACUUM&lt;/code&gt; should attempt to remove index entries pointing to dead tuples. This is normally the desired behavior and is the default unless the &lt;code&gt;vacuum_index_cleanup&lt;/code&gt; option has been set to false for the table to be vacuumed. Setting this option to false may be useful when it is necessary to make vacuum run as quickly as possible, for example to avoid imminent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;). However, if index cleanup is not performed regularly, performance may suffer, because as the table is modified, indexes will accumulate dead tuples and the table itself will accumulate dead line pointers that cannot be removed until index cleanup is completed. This option has no effect for tables that do not have an index and is ignored if the &lt;code&gt;FULL&lt;/code&gt; option is used.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 사용 불능 튜플을 가리키는 인덱스 항목을 제거하도록 지정합니다 . 일반적으로 원하는 동작이며 테이블을 진공 청소기로 청소하기 위해 &lt;code&gt;vacuum_index_cleanup&lt;/code&gt; 옵션을 false로 설정 하지 않은 경우 기본값 입니다. 이 옵션을 false로 설정하면 임박한 트랜잭션 ID 랩 어라운드를 피하기 위해 진공을 최대한 빨리 실행해야 할 때 유용 할 수 있습니다 ( &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절 &lt;/a&gt; . 그러나 인덱스 정리가 정기적으로 수행되지 않으면 테이블이 수정 될 때 인덱스가 데드 튜플을 누적하고 인덱스 자체가 인덱스 정리가 완료 될 때까지 제거 할 수없는 데드 라인 포인터가 누적되므로 성능이 저하 될 수 있습니다. 이 옵션은 인덱스가없는 테이블에는 영향을 미치지 않으며 &lt;code&gt;FULL&lt;/code&gt; 옵션 참조) .</target>
        </trans-unit>
        <trans-unit id="0d429bcd2ea94b54e668c5354586e32e8f817f6f" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;VACUUM&lt;/code&gt; should attempt to truncate off any empty pages at the end of the table and allow the disk space for the truncated pages to be returned to the operating system. This is normally the desired behavior and is the default unless the &lt;code&gt;vacuum_truncate&lt;/code&gt; option has been set to false for the table to be vacuumed. Setting this option to false may be useful to avoid &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the table that the truncation requires. This option is ignored if the &lt;code&gt;FULL&lt;/code&gt; option is used.</source>
          <target state="translated">하도록 지정 &lt;code&gt;VACUUM&lt;/code&gt; 가 버림 페이지가 운영 체제에 반환하는 디스크 공간을 테이블의 끝에 빈 페이지를 잘라 허용을 시도한다. 일반적으로 원하는 동작이며 테이블을 진공 청소기로 청소하기 위해 &lt;code&gt;vacuum_truncate&lt;/code&gt; 옵션을 false로 설정 하지 않은 경우 기본값 입니다. 이 옵션을 false로 설정 하면 절단에 필요한 테이블에 대한 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금 을 피하는 데 유용 할 수 있습니다 . &lt;code&gt;FULL&lt;/code&gt; 옵션을 사용 하면이 옵션이 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="8acec09299fb8ba0ff540d797b166a76e15e9730" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;VACUUM&lt;/code&gt; should not wait for any conflicting locks to be released when beginning work on a relation: if a relation cannot be locked immediately without waiting, the relation is skipped. Note that even with this option, &lt;code&gt;VACUUM&lt;/code&gt; may still block when opening the relation's indexes. Additionally, &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; may still block when acquiring sample rows from partitions, table inheritance children, and some types of foreign tables. Also, while &lt;code&gt;VACUUM&lt;/code&gt; ordinarily processes all partitions of specified partitioned tables, this option will cause &lt;code&gt;VACUUM&lt;/code&gt; to skip all partitions if there is a conflicting lock on the partitioned table.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 관계에 대한 작업을 시작할 때 충돌하는 잠금이 해제 될 때까지 기다리지 않도록 지정합니다 . 대기하지 않고 관계를 즉시 잠글 수없는 경우 관계를 건너 뜁니다. 이 옵션을 사용하더라도 관계 인덱스를 열 때 &lt;code&gt;VACUUM&lt;/code&gt; 이 여전히 차단 될 수 있습니다. 또한 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 는 파티션, 테이블 상속 자식 및 일부 유형의 외부 테이블에서 샘플 행을 가져올 때 여전히 차단 될 수 있습니다. 또한 &lt;code&gt;VACUUM&lt;/code&gt; 은 일반적으로 지정된 파티션 된 테이블의 모든 파티션을 처리 하지만 이 옵션은 파티션 된 테이블에 충돌하는 잠금이있는 경우 &lt;code&gt;VACUUM&lt;/code&gt; 이 모든 파티션을 건너 뛰도록합니다.</target>
        </trans-unit>
        <trans-unit id="758034d1e69b26977b48b6f20e70d6677b8e004b" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;ecpg&lt;/code&gt; should write all its output to the given &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ecpg&lt;/code&gt; 가 모든 출력을 주어진 &lt;code&gt;filename&lt;/code&gt; 에 쓰 도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="74b631b820fc63f5d91fba7faebaeab4418c3bec" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;ecpg&lt;/code&gt; should write all its output to the given &lt;code&gt;filename&lt;/code&gt;. Write &lt;code&gt;-o -&lt;/code&gt; to send all output to standard output.</source>
          <target state="translated">Specifies that &lt;code&gt;ecpg&lt;/code&gt; should write all its output to the given &lt;code&gt;filename&lt;/code&gt; . Write &lt;code&gt;-o -&lt;/code&gt; to send all output to standard output.</target>
        </trans-unit>
        <trans-unit id="476673c72300067d2d8b801aea964f9b00c9cacb" translate="yes" xml:space="preserve">
          <source>Specifies that input comes from the client application.</source>
          <target state="translated">입력이 클라이언트 응용 프로그램에서 제공되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d33dfc40efb3f2b8c3b11c629c9ff5894ef179ee" translate="yes" xml:space="preserve">
          <source>Specifies that nulls sort after non-nulls. This is the default when &lt;code&gt;DESC&lt;/code&gt; is not specified.</source>
          <target state="translated">널이 아닌 널 이후에 널이 정렬되도록 지정합니다. &lt;code&gt;DESC&lt;/code&gt; 가 지정되지 않은 경우의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="daa8bfde45b331c533c9c174a243729b8f09ce7f" translate="yes" xml:space="preserve">
          <source>Specifies that nulls sort before non-nulls. This is the default when &lt;code&gt;DESC&lt;/code&gt; is specified.</source>
          <target state="translated">널이 널이 아닌 값보다 먼저 정렬되도록 지정합니다. &lt;code&gt;DESC&lt;/code&gt; 가 지정된 경우의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="1d04511fc8068e65b5ef87b24bac014646887848" translate="yes" xml:space="preserve">
          <source>Specifies that output goes to the client application.</source>
          <target state="translated">출력이 클라이언트 응용 프로그램으로 보내도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="daac76b603adeba1c174a4758e70d64d4861cda2" translate="yes" xml:space="preserve">
          <source>Specifies that psql is to execute the given command string, &lt;code&gt;command&lt;/code&gt;. This option can be repeated and combined in any order with the &lt;code&gt;-f&lt;/code&gt; option. When either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;-f&lt;/code&gt; is specified, psql does not read commands from standard input; instead it terminates after processing all the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; options in sequence.</source>
          <target state="translated">psql의가 있음을 지정, 주어진 명령 문자열을 실행 &lt;code&gt;command&lt;/code&gt; . 이 옵션은 &lt;code&gt;-f&lt;/code&gt; 옵션 과 함께 임의의 순서로 반복 및 결합 될 수 있습니다 . 때 중 하나 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;-f&lt;/code&gt; 이 , psql의 표준 입력에서 명령을 읽지 않습니다 지정; 대신 모든 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-f&lt;/code&gt; 옵션을 순서대로 처리 한 후 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="7ba58db87a5a3b8ba1951177b155f6ec5b6ddc9e" translate="yes" xml:space="preserve">
          <source>Specifies that psql should do its work quietly. By default, it prints welcome messages and various informational output. If this option is used, none of this happens. This is useful with the &lt;code&gt;-c&lt;/code&gt; option. This is equivalent to setting the variable &lt;code&gt;QUIET&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">psql이 자동으로 작업을 수행하도록 지정합니다. 기본적으로 환영 메시지와 다양한 정보 출력을 인쇄합니다. 이 옵션을 사용하면 아무 것도 발생하지 않습니다. 이것은 &lt;code&gt;-c&lt;/code&gt; 옵션 과 함께 유용합니다 . 변수 &lt;code&gt;QUIET&lt;/code&gt; 을 &lt;code&gt;on&lt;/code&gt; 으로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2674230f7e486c0e44905bbd6298fe8b2b2d1a82" translate="yes" xml:space="preserve">
          <source>Specifies that the command takes effect for only the current transaction. After &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;, the session-level setting takes effect again. Issuing this outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">명령이 현재 트랜잭션에만 적용되도록 지정합니다. &lt;code&gt;COMMIT&lt;/code&gt; 또는 &lt;code&gt;ROLLBACK&lt;/code&gt; 후에 세션 레벨 설정이 다시 적용됩니다. 이것을 트랜잭션 블록 외부에서 발행하면 경고가 발생하고 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bea83a0d108f3906897b3bf97f523a0c93c05d18" translate="yes" xml:space="preserve">
          <source>Specifies that the command takes effect for the current session. (This is the default if neither &lt;code&gt;SESSION&lt;/code&gt; nor &lt;code&gt;LOCAL&lt;/code&gt; appears.)</source>
          <target state="translated">명령이 현재 세션에 적용되도록 지정합니다. &lt;code&gt;SESSION&lt;/code&gt; 이나 &lt;code&gt;LOCAL&lt;/code&gt; 이 나타나지 않으면 이것이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="1dbd040f7f5d27f1c4151e077b939d7b51fddbf5" translate="yes" xml:space="preserve">
          <source>Specifies that the file contains a header line with the names of each column in the file. On output, the first line contains the column names from the table, and on input, the first line is ignored. This option is allowed only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">파일에 파일의 각 열 이름이있는 헤더 행이 포함되도록 지정합니다. 출력시 첫 번째 행에는 테이블의 열 이름이 포함되고 입력시 첫 번째 행은 무시됩니다. 이 옵션은 &lt;code&gt;CSV&lt;/code&gt; 형식을 사용할 때만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5dc311faf0410c6eef1ebd43c5c8ddbd66ce784a" translate="yes" xml:space="preserve">
          <source>Specifies that the file is encoded in the &lt;code&gt;encoding_name&lt;/code&gt;. If this option is omitted, the current client encoding is used. See the Notes below for more details.</source>
          <target state="translated">파일이 인코딩되어 지정 &lt;code&gt;encoding_name&lt;/code&gt; . 이 옵션을 생략하면 현재 클라이언트 인코딩이 사용됩니다. 자세한 내용은 아래 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1ae57a0f9d9b9535fad868885b858b893808d7a0" translate="yes" xml:space="preserve">
          <source>Specifies that the replication slot named by the &lt;code&gt;--slot&lt;/code&gt; option should be created before starting the backup. An error is raised if the slot already exists.</source>
          <target state="translated">Specifies that the replication slot named by the &lt;code&gt;--slot&lt;/code&gt; option should be created before starting the backup. An error is raised if the slot already exists.</target>
        </trans-unit>
        <trans-unit id="33c8179b9d6ed27cb816da9e750ff73781382b59" translate="yes" xml:space="preserve">
          <source>Specifies the &lt;em&gt;minimum&lt;/em&gt; number of characters to use to display the format specifier's output. The output is padded on the left or right (depending on the &lt;code&gt;-&lt;/code&gt; flag) with spaces as needed to fill the width. A too-small width does not cause truncation of the output, but is simply ignored. The width may be specified using any of the following: a positive integer; an asterisk (&lt;code&gt;*&lt;/code&gt;) to use the next function argument as the width; or a string of the form &lt;code&gt;*&lt;em&gt;n&lt;/em&gt;$&lt;/code&gt; to use the &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;th function argument as the width.</source>
          <target state="translated">Specifies the &lt;em&gt;minimum&lt;/em&gt; number of characters to use to display the format specifier's output. The output is padded on the left or right (depending on the &lt;code&gt;-&lt;/code&gt; flag) with spaces as needed to fill the width. A too-small width does not cause truncation of the output, but is simply ignored. The width may be specified using any of the following: a positive integer; an asterisk ( &lt;code&gt;*&lt;/code&gt; ) to use the next function argument as the width; or a string of the form &lt;code&gt;*&lt;em&gt;n&lt;/em&gt;$&lt;/code&gt; to use the &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt;th function argument as the width.</target>
        </trans-unit>
        <trans-unit id="4263bd49ddd4eeb4991d646e43be2a7f8a044727" translate="yes" xml:space="preserve">
          <source>Specifies the &lt;em&gt;minimum&lt;/em&gt; number of characters to use to display the format specifier's output. The output is padded on the left or right (depending on the &lt;code&gt;-&lt;/code&gt; flag) with spaces as needed to fill the width. A too-small width does not cause truncation of the output, but is simply ignored. The width may be specified using any of the following: a positive integer; an asterisk (&lt;code&gt;*&lt;/code&gt;) to use the next function argument as the width; or a string of the form &lt;code&gt;*n$&lt;/code&gt; to use the &lt;code&gt;n&lt;/code&gt;th function argument as the width.</source>
          <target state="translated">형식 지정자의 출력을 표시하는 데 사용할 &lt;em&gt;최소&lt;/em&gt; 문자 수를 지정합니다 . 출력은 너비를 채우는 데 필요한 공백으로 왼쪽 또는 오른쪽 ( &lt;code&gt;-&lt;/code&gt; 플래그 에 따라)에 채워집니다 . 너비가 너무 작 으면 출력이 잘리지 않지만 단순히 무시됩니다. 너비는 다음 중 하나를 사용하여 지정할 수 있습니다. 양의 정수; 다음 함수 인수를 너비로 사용 하는 별표 ( &lt;code&gt;*&lt;/code&gt; ); 또는 &lt;code&gt;n&lt;/code&gt; 번째 함수 인수를 너비로 사용하려면 &lt;code&gt;*n$&lt;/code&gt; 형식의 문자열 .</target>
        </trans-unit>
        <trans-unit id="dd2bb55445de516e2f15cc3a16e8b3167d160230" translate="yes" xml:space="preserve">
          <source>Specifies the Bonjour service name. The computer name is used if this parameter is set to the empty string &lt;code&gt;''&lt;/code&gt; (which is the default). This parameter is ignored if the server was not compiled with Bonjour support. This parameter can only be set at server start.</source>
          <target state="translated">Bonjour 서비스 이름을 지정합니다. 이 매개 변수가 빈 문자열 &lt;code&gt;''&lt;/code&gt; (기본값) 로 설정된 경우 컴퓨터 이름이 사용됩니다 . 서버가 Bonjour 지원으로 컴파일되지 않은 경우이 매개 변수는 무시됩니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60f372316e2c7a0c25e888864dcbe9c5947a1f98" translate="yes" xml:space="preserve">
          <source>Specifies the IP host name or address on which &lt;code&gt;postgres&lt;/code&gt; is to listen for TCP/IP connections from client applications. The value can also be a comma-separated list of addresses, or &lt;code&gt;*&lt;/code&gt; to specify listening on all available interfaces. An empty value specifies not listening on any IP addresses, in which case only Unix-domain sockets can be used to connect to the server. Defaults to listening only on localhost. Specifying this option is equivalent to setting the &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt; configuration parameter.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 가 클라이언트 애플리케이션에서 TCP / IP 연결을 청취 할 IP 호스트 이름 또는 주소를 지정합니다 . 값은 쉼표로 구분 된 주소 목록이거나 &lt;code&gt;*&lt;/code&gt; 사용 가능한 모든 인터페이스에서 수신 대기를 지정하기 위해 * 일 수도 있습니다. 빈 값은 IP 주소에서 수신 대기를 지정하지 않으며이 경우 서버에 연결하는 데 유닉스 도메인 소켓 만 사용할 수 있습니다. 로컬 호스트에서만 청취하도록 기본 설정됩니다. 이 옵션을 지정하는 것은 &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt; 구성 매개 변수 를 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6693c397b857918c8e1bf4322dde6ce56aa4e953" translate="yes" xml:space="preserve">
          <source>Specifies the LC_COLLATE setting to be used in this database.</source>
          <target state="translated">이 데이터베이스에서 사용할 LC_COLLATE 설정을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="87d16e3ed42fdb841c554674d4408e00bcbbe24c" translate="yes" xml:space="preserve">
          <source>Specifies the LC_CTYPE setting to be used in this database.</source>
          <target state="translated">이 데이터베이스에서 사용할 LC_CTYPE 설정을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="55aced566e201cfe60c72dc32ce5c91ff387e671" translate="yes" xml:space="preserve">
          <source>Specifies the TCP port or local Unix domain socket file extension on which the server is listening for connections.</source>
          <target state="translated">서버가 연결을 청취중인 TCP 포트 또는 로컬 Unix 도메인 소켓 파일 확장자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="931e876a68f198d3d0f31f6a09576aa928e1ef83" translate="yes" xml:space="preserve">
          <source>Specifies the TCP port or local Unix domain socket file extension on which the server is listening for connections. Defaults to the &lt;code&gt;PGPORT&lt;/code&gt; environment variable, if set, or a compiled-in default.</source>
          <target state="translated">서버가 연결을 청취중인 TCP 포트 또는 로컬 Unix 도메인 소켓 파일 확장자를 지정합니다. 받는 기본 &lt;code&gt;PGPORT&lt;/code&gt; 의 환경 변수 설정, 또는 컴파일 된 기본 경우.</target>
        </trans-unit>
        <trans-unit id="1245b6061a1bf12ce3fd139439709c120ed66a4b" translate="yes" xml:space="preserve">
          <source>Specifies the TCP port or the local Unix domain socket file extension on which the server is listening for connections.</source>
          <target state="translated">서버가 연결을 청취중인 TCP 포트 또는 로컬 Unix 도메인 소켓 파일 확장자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="507d190a685da40c64eecb6a283ca57e75a7447a" translate="yes" xml:space="preserve">
          <source>Specifies the TCP port or the local Unix-domain socket file extension on which the server is listening for connections. Defaults to the value of the &lt;code&gt;PGPORT&lt;/code&gt; environment variable or, if not set, to the port specified at compile time, usually 5432.</source>
          <target state="translated">서버가 연결을 청취하는 TCP 포트 또는 로컬 Unix 도메인 소켓 파일 확장자를 지정합니다. 기본값은 &lt;code&gt;PGPORT&lt;/code&gt; 환경 변수 의 값 또는 설정되지 않은 경우 컴파일시 지정된 포트 (일반적으로 5432)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3e3eab566b3a773eb12a7db97c4f1b334d29a443" translate="yes" xml:space="preserve">
          <source>Specifies the TCP/IP address(es) on which the server is to listen for connections from client applications. The value takes the form of a comma-separated list of host names and/or numeric IP addresses. The special entry &lt;code&gt;*&lt;/code&gt; corresponds to all available IP interfaces. The entry &lt;code&gt;0.0.0.0&lt;/code&gt; allows listening for all IPv4 addresses and &lt;code&gt;::&lt;/code&gt; allows listening for all IPv6 addresses. If the list is empty, the server does not listen on any IP interface at all, in which case only Unix-domain sockets can be used to connect to it. The default value is localhost, which allows only local TCP/IP &amp;ldquo;loopback&amp;rdquo; connections to be made. While client authentication (&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) allows fine-grained control over who can access the server, &lt;code&gt;listen_addresses&lt;/code&gt; controls which interfaces accept connection attempts, which can help prevent repeated malicious connection requests on insecure network interfaces. This parameter can only be set at server start.</source>
          <target state="translated">서버가 클라이언트 응용 프로그램의 연결을 청취 할 TCP / IP 주소를 지정합니다. 이 값은 쉼표로 구분 된 호스트 이름 및 / 또는 숫자 IP 주소 목록 형식입니다. 특수 항목 &lt;code&gt;*&lt;/code&gt; 는 사용 가능한 모든 IP 인터페이스에 해당합니다. &lt;code&gt;0.0.0.0&lt;/code&gt; 항목 은 모든 IPv4 주소를 수신 하고 &lt;code&gt;::&lt;/code&gt; 는 모든 IPv6 주소를 수신 할 수 있습니다. 목록이 비어 있으면 서버는 IP 인터페이스를 전혀 수신하지 않으며,이 경우 Unix 도메인 소켓 만 사용하여 연결할 수 있습니다. 기본값은 localhost이며 로컬 TCP / IP &quot;루프백&quot;연결 만 가능합니다. 클라이언트 인증 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; )을 통해 서버에 액세스 할 수있는 사람을 세밀하게 제어 할 수 있지만, &lt;code&gt;listen_addresses&lt;/code&gt; 는 연결 시도를 허용하는 인터페이스를 제어하여 안전하지 않은 네트워크 인터페이스에서 반복되는 악의적 인 연결 요청을 방지 할 수 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72d523a285d93d88501728182131dac85bfc7e2e" translate="yes" xml:space="preserve">
          <source>Specifies the TCP/IP address(es) on which the server is to listen for connections from client applications. The value takes the form of a comma-separated list of host names and/or numeric IP addresses. The special entry &lt;code&gt;*&lt;/code&gt; corresponds to all available IP interfaces. The entry &lt;code&gt;0.0.0.0&lt;/code&gt; allows listening for all IPv4 addresses and &lt;code&gt;::&lt;/code&gt; allows listening for all IPv6 addresses. If the list is empty, the server does not listen on any IP interface at all, in which case only Unix-domain sockets can be used to connect to it. The default value is localhost, which allows only local TCP/IP &amp;ldquo;loopback&amp;rdquo; connections to be made. While client authentication (&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) allows fine-grained control over who can access the server, &lt;code&gt;listen_addresses&lt;/code&gt; controls which interfaces accept connection attempts, which can help prevent repeated malicious connection requests on insecure network interfaces. This parameter can only be set at server start.</source>
          <target state="translated">Specifies the TCP/IP address(es) on which the server is to listen for connections from client applications. The value takes the form of a comma-separated list of host names and/or numeric IP addresses. The special entry &lt;code&gt;*&lt;/code&gt; corresponds to all available IP interfaces. The entry &lt;code&gt;0.0.0.0&lt;/code&gt; allows listening for all IPv4 addresses and &lt;code&gt;::&lt;/code&gt; allows listening for all IPv6 addresses. If the list is empty, the server does not listen on any IP interface at all, in which case only Unix-domain sockets can be used to connect to it. The default value is localhost, which allows only local TCP/IP &amp;ldquo;loopback&amp;rdquo; connections to be made. While client authentication (&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) allows fine-grained control over who can access the server, &lt;code&gt;listen_addresses&lt;/code&gt; controls which interfaces accept connection attempts, which can help prevent repeated malicious connection requests on insecure network interfaces. This parameter can only be set at server start.</target>
        </trans-unit>
        <trans-unit id="3537c254ac5f033d6d92a27bf13527e480601b18" translate="yes" xml:space="preserve">
          <source>Specifies the TCP/IP port or local Unix domain socket file extension on which &lt;code&gt;postgres&lt;/code&gt; is to listen for connections from client applications. Defaults to the value of the &lt;code&gt;PGPORT&lt;/code&gt; environment variable, or if &lt;code&gt;PGPORT&lt;/code&gt; is not set, then defaults to the value established during compilation (normally 5432). If you specify a port other than the default port, then all client applications must specify the same port using either command-line options or &lt;code&gt;PGPORT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 가 클라이언트 응용 프로그램의 연결을 청취 할 TCP / IP 포트 또는 로컬 Unix 도메인 소켓 파일 확장자를 지정 합니다. 기본값은 &lt;code&gt;PGPORT&lt;/code&gt; 환경 변수 의 값으로 설정 되거나 &lt;code&gt;PGPORT&lt;/code&gt; 가 설정되지 않은 경우 기본값은 컴파일 중에 설정된 값 (일반적으로 5432)으로 설정됩니다. 기본 포트 이외의 포트를 지정하면 모든 클라이언트 애플리케이션이 명령 행 옵션 또는 &lt;code&gt;PGPORT&lt;/code&gt; 를 사용하여 동일한 포트를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8ea867f4ac26c64d9cc1757cab1a7be546919f54" translate="yes" xml:space="preserve">
          <source>Specifies the amount of memory reserved to store the text of the currently executing command for each active session, for the &lt;code&gt;pg_stat_activity&lt;/code&gt;.&lt;code&gt;query&lt;/code&gt; field. If this value is specified without units, it is taken as bytes. The default value is 1024 bytes. This parameter can only be set at server start.</source>
          <target state="translated">&lt;code&gt;pg_stat_activity&lt;/code&gt; 에 대해 각 활성 세션에 대해 현재 실행중인 명령의 텍스트를 저장하기 위해 예약 된 메모리 양을 지정합니다 . &lt;code&gt;query&lt;/code&gt; 필드. 이 값을 단위없이 지정하면 바이트로 사용됩니다. 기본값은 1024 바이트입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc678a0bd453588d49abc80496b06117c941ca29" translate="yes" xml:space="preserve">
          <source>Specifies the amount of memory to be used by internal sorts and hashes before resorting to temporary disk files. See the description of the &lt;code&gt;work_mem&lt;/code&gt; configuration parameter in &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-MEMORY&quot;&gt;Section 19.4.1&lt;/a&gt;.</source>
          <target state="translated">임시 디스크 파일을 사용하기 전에 내부 정렬 및 해시에서 사용할 메모리 양을 지정합니다. 의 설명을 참조하십시오 &lt;code&gt;work_mem&lt;/code&gt; 의 에서 구성 매개 변수 &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-MEMORY&quot;&gt;섹션 19.4.1을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5252287a2ccbaeae869995aabcbb3347a332c8e" translate="yes" xml:space="preserve">
          <source>Specifies the amount of time after which a TCP keepalive message that has not been acknowledged by the client should be retransmitted. If this value is specified without units, it is taken as seconds. A value of 0 (the default) selects the operating system's default. This parameter is supported only on systems that support &lt;code&gt;TCP_KEEPINTVL&lt;/code&gt; or an equivalent socket option, and on Windows; on other systems, it must be zero. In sessions connected via a Unix-domain socket, this parameter is ignored and always reads as zero.</source>
          <target state="translated">클라이언트가 승인하지 않은 TCP keepalive 메시지를 재전송해야하는 시간을 지정합니다. 이 값을 단위없이 지정하면 초로 간주됩니다. 값 0 (기본값)은 운영 체제의 기본값을 선택합니다. 이 매개 변수는 &lt;code&gt;TCP_KEEPINTVL&lt;/code&gt; 또는 이와 동등한 소켓 옵션 을 지원하는 시스템 및 Windows 에서만 지원됩니다 . 다른 시스템에서는 0이어야합니다. Unix 도메인 소켓을 통해 연결된 세션에서이 매개 변수는 무시되며 항상 0으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="937e14bbced54fcb089087acebac570db1aea5e1" translate="yes" xml:space="preserve">
          <source>Specifies the amount of time that transmitted data may remain unacknowledged before the TCP connection is forcibly closed. If this value is specified without units, it is taken as milliseconds. A value of 0 (the default) selects the operating system's default. This parameter is supported only on systems that support &lt;code&gt;TCP_USER_TIMEOUT&lt;/code&gt;; on other systems, it must be zero. In sessions connected via a Unix-domain socket, this parameter is ignored and always reads as zero.</source>
          <target state="translated">TCP 연결이 강제로 닫히기 전에 전송 된 데이터가 승인되지 않은 상태로 유지 될 수있는 시간을 지정합니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 값 0 (기본값)은 운영 체제의 기본값을 선택합니다. 이 매개 변수는 &lt;code&gt;TCP_USER_TIMEOUT&lt;/code&gt; 을 지원하는 시스템에서만 지원 됩니다 . 다른 시스템에서는 0이어야합니다. Unix 도메인 소켓을 통해 연결된 세션에서이 매개 변수는 무시되며 항상 0으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="728efceb012fa4b8997461cbc11863da3a1b0bbc" translate="yes" xml:space="preserve">
          <source>Specifies the amount of time with no network activity after which the operating system should send a TCP keepalive message to the client. If this value is specified without units, it is taken as seconds. A value of 0 (the default) selects the operating system's default. This parameter is supported only on systems that support &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt; or an equivalent socket option, and on Windows; on other systems, it must be zero. In sessions connected via a Unix-domain socket, this parameter is ignored and always reads as zero.</source>
          <target state="translated">운영 체제가 클라이언트에 TCP keepalive 메시지를 보낸 후 네트워크 활동이없는 시간을 지정합니다. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 값 0 (기본값)은 운영 체제의 기본값을 선택합니다. 이 매개 변수는 &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt; 또는 이와 동등한 소켓 옵션 을 지원하는 시스템 및 Windows 에서만 지원됩니다 . 다른 시스템에서는 0이어야합니다. Unix 도메인 소켓을 통해 연결된 세션에서이 매개 변수는 무시되며 항상 0으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="3326b434e82205b64167175fe284cbe3cea32bb2" translate="yes" xml:space="preserve">
          <source>Specifies the authentication method to use when a connection matches this record. The possible choices are summarized here; details are in &lt;a href=&quot;auth-methods&quot;&gt;Section 20.3&lt;/a&gt;.</source>
          <target state="translated">연결이이 레코드와 일치 할 때 사용할 인증 방법을 지정합니다. 가능한 선택 사항이 여기에 요약되어 있습니다. 자세한 내용은 &lt;a href=&quot;auth-methods&quot;&gt;섹션 20.3에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e05d00026d5570d305872cd452173c1c629522" translate="yes" xml:space="preserve">
          <source>Specifies the base amount of memory to be used by sorts and hash tables before resorting to temporary disk files. See the description of the &lt;code&gt;work_mem&lt;/code&gt; configuration parameter in &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-MEMORY&quot;&gt;Section 19.4.1&lt;/a&gt;.</source>
          <target state="translated">Specifies the base amount of memory to be used by sorts and hash tables before resorting to temporary disk files. See the description of the &lt;code&gt;work_mem&lt;/code&gt; configuration parameter in &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-MEMORY&quot;&gt;Section 19.4.1&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7515aa26a943fa7c5306a8e3c5aa3e7ed65713f4" translate="yes" xml:space="preserve">
          <source>Specifies the character encoding scheme to be used in this database. The character sets supported by the PostgreSQL server are described in &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;Section 23.3.1&lt;/a&gt;.</source>
          <target state="translated">이 데이터베이스에서 사용될 문자 인코딩 체계를 지정합니다. PostgreSQL 서버가 지원하는 문자 세트는 &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;23.3.1 절에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f73b1a04ad633486d49bf7f4c459851a9fe540e" translate="yes" xml:space="preserve">
          <source>Specifies the character that separates columns within each row (line) of the file. The default is a tab character in text format, a comma in &lt;code&gt;CSV&lt;/code&gt; format. This must be a single one-byte character. This option is not allowed when using &lt;code&gt;binary&lt;/code&gt; format.</source>
          <target state="translated">파일의 각 행 (행) 내에서 열을 구분하는 문자를 지정합니다. 기본값은 텍스트 형식의 탭 문자, &lt;code&gt;CSV&lt;/code&gt; 형식 의 쉼표 입니다. 1 바이트 문자 여야합니다. &lt;code&gt;binary&lt;/code&gt; 형식을 사용할 때는이 옵션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5ee0f87c55facfe587a8287b5c66cf8a1f6f69aa" translate="yes" xml:space="preserve">
          <source>Specifies the character that should appear before a data character that matches the &lt;code&gt;QUOTE&lt;/code&gt; value. The default is the same as the &lt;code&gt;QUOTE&lt;/code&gt; value (so that the quoting character is doubled if it appears in the data). This must be a single one-byte character. This option is allowed only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">&lt;code&gt;QUOTE&lt;/code&gt; 값 과 일치하는 데이터 문자 앞에 표시 할 문자를 지정합니다 . 기본값은 &lt;code&gt;QUOTE&lt;/code&gt; 값 과 같습니다 (따라서 인용 문자가 데이터에 표시되면 두 배가됩니다). 1 바이트 문자 여야합니다. 이 옵션은 &lt;code&gt;CSV&lt;/code&gt; 형식을 사용할 때만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcb5c69e457d0676f8028272e4d08bdc17b24f6d" translate="yes" xml:space="preserve">
          <source>Specifies the checksum algorithm that should be applied to each file included in the backup manifest. Currently, the available algorithms are &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;CRC32C&lt;/code&gt;, &lt;code&gt;SHA224&lt;/code&gt;, &lt;code&gt;SHA256&lt;/code&gt;, &lt;code&gt;SHA384&lt;/code&gt;, and &lt;code&gt;SHA512&lt;/code&gt;. The default is &lt;code&gt;CRC32C&lt;/code&gt;.</source>
          <target state="translated">Specifies the checksum algorithm that should be applied to each file included in the backup manifest. Currently, the available algorithms are &lt;code&gt;NONE&lt;/code&gt; , &lt;code&gt;CRC32C&lt;/code&gt; , &lt;code&gt;SHA224&lt;/code&gt; , &lt;code&gt;SHA256&lt;/code&gt; , &lt;code&gt;SHA384&lt;/code&gt; , and &lt;code&gt;SHA512&lt;/code&gt; . The default is &lt;code&gt;CRC32C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb9b9f2a8b704112b18a3dd32cfe136e8a9d516a" translate="yes" xml:space="preserve">
          <source>Specifies the client machine address(es) that this record matches. This field can contain either a host name, an IP address range, or one of the special key words mentioned below.</source>
          <target state="translated">이 레코드가 일치하는 클라이언트 시스템 주소를 지정합니다. 이 필드에는 호스트 이름, IP 주소 범위 또는 아래 언급 된 특수 키워드 중 하나가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01ef1780e6cf02acd0c5f5ed01cc7fb8cfe694d8" translate="yes" xml:space="preserve">
          <source>Specifies the command to be executed. The standard output of this command will be read as though &lt;code&gt;COPY FROM PROGRAM&lt;/code&gt; were used. Either &lt;code&gt;program&lt;/code&gt; or &lt;code&gt;filename&lt;/code&gt; must be specified, but not both.</source>
          <target state="translated">실행할 명령을 지정합니다. &lt;code&gt;COPY FROM PROGRAM&lt;/code&gt; 을 사용한 것처럼이 명령의 표준 출력을 읽습니다 . 어느 &lt;code&gt;program&lt;/code&gt; 이나 &lt;code&gt;filename&lt;/code&gt; 지정하지만 둘 다해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cf2f84af8afbc3c22cdc032417bf2f88d7880df" translate="yes" xml:space="preserve">
          <source>Specifies the configuration file for host-based authentication (customarily called &lt;code&gt;pg_hba.conf&lt;/code&gt;). This parameter can only be set at server start.</source>
          <target state="translated">호스트 기반 인증을위한 구성 파일 (일반적으로 &lt;code&gt;pg_hba.conf&lt;/code&gt; )을 지정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b177fc10e511d9d1273b6e191c4a216322dbd90" translate="yes" xml:space="preserve">
          <source>Specifies the configuration file for user name mapping (customarily called &lt;code&gt;pg_ident.conf&lt;/code&gt;). This parameter can only be set at server start. See also &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;.</source>
          <target state="translated">사용자 이름 매핑을위한 구성 파일 (일반적으로 &lt;code&gt;pg_ident.conf&lt;/code&gt; )을 지정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. &lt;a href=&quot;auth-username-maps&quot;&gt;섹션 20.2&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="62531b8b18a1054d438f17f602dd10a4f893c363" translate="yes" xml:space="preserve">
          <source>Specifies the cost delay value that will be used in automatic &lt;code&gt;VACUUM&lt;/code&gt; operations. If -1 is specified, the regular &lt;a href=&quot;runtime-config-resource#GUC-VACUUM-COST-DELAY&quot;&gt;vacuum_cost_delay&lt;/a&gt; value will be used. If this value is specified without units, it is taken as milliseconds. The default value is 2 milliseconds. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">자동 &lt;code&gt;VACUUM&lt;/code&gt; 작업에 사용될 비용 지연 값을 지정합니다 . -1을 지정하면 일반 &lt;a href=&quot;runtime-config-resource#GUC-VACUUM-COST-DELAY&quot;&gt;vacuum_cost_delay&lt;/a&gt; 값이 사용됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 2 밀리 초입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 그러나 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bb18eeb02a5ec123a303d41b87b775a1befe02c" translate="yes" xml:space="preserve">
          <source>Specifies the cost limit value that will be used in automatic &lt;code&gt;VACUUM&lt;/code&gt; operations. If -1 is specified (which is the default), the regular &lt;a href=&quot;runtime-config-resource#GUC-VACUUM-COST-LIMIT&quot;&gt;vacuum_cost_limit&lt;/a&gt; value will be used. Note that the value is distributed proportionally among the running autovacuum workers, if there is more than one, so that the sum of the limits for each worker does not exceed the value of this variable. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">자동 &lt;code&gt;VACUUM&lt;/code&gt; 작업에 사용될 비용 제한 값을 지정합니다 . -1을 지정하면 (기본값) 일반 &lt;a href=&quot;runtime-config-resource#GUC-VACUUM-COST-LIMIT&quot;&gt;vacuum_cost_limit&lt;/a&gt; 값이 사용됩니다. 값이 둘 이상인 경우 실행중인 자동 진공 작업자간에 비례 적으로 분배되므로 각 작업자의 한계 합계가이 변수의 값을 초과하지 않습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 그러나 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="691012ae26d118f3562d9c59f3f7e4f27b51110b" translate="yes" xml:space="preserve">
          <source>Specifies the cutoff age (in multixacts) that &lt;code&gt;VACUUM&lt;/code&gt; should use to decide whether to replace multixact IDs with a newer transaction ID or multixact ID while scanning a table. The default is 5 million multixacts. Although users can set this value anywhere from zero to one billion, &lt;code&gt;VACUUM&lt;/code&gt; will silently limit the effective value to half the value of &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;, so that there is not an unreasonably short time between forced autovacuums. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 테이블을 스캔하는 동안 멀티 트랙트 ID를 새로운 트랜잭션 ID 또는 멀티 액트 ID로 바꿀지 여부를 결정하는 데 사용해야 하는 컷오프 연령 (멀티 액션)을 지정 합니다. 기본값은 5 백만 멀티 플렉스입니다. 사용자는이 값을 0에서 10 억 사이로 설정할 수 있지만 &lt;code&gt;VACUUM&lt;/code&gt; 은 유효 값을 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; 값의 절반으로 자동 제한 하므로 강제 자동 진공 시간이 부당하게 짧아지지 않습니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;24.1.5.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3129ffa0dcdb996d6987c871dd065e5f9257d92b" translate="yes" xml:space="preserve">
          <source>Specifies the cutoff age (in transactions) that &lt;code&gt;VACUUM&lt;/code&gt; should use to decide whether to freeze row versions while scanning a table. The default is 50 million transactions. Although users can set this value anywhere from zero to one billion, &lt;code&gt;VACUUM&lt;/code&gt; will silently limit the effective value to half the value of &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;, so that there is not an unreasonably short time between forced autovacuums. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 테이블을 스캔하는 동안 행 버전을 고정할지 결정하는 데 사용해야 하는 컷오프 연령 (트랜잭션 내)을 지정 합니다. 기본값은 5 천만 건입니다. 사용자는이 값을 0에서 10 억 사이로 설정할 수 있지만 &lt;code&gt;VACUUM&lt;/code&gt; 은 유효 값을 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; 값의 절반으로 자동 제한 하므로 강제 자동 진공 시간 사이에 부당한 시간이 발생하지 않습니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8715673ad98fb5dddf8f3f5ceb901ae593d793f9" translate="yes" xml:space="preserve">
          <source>Specifies the data delimiter character, the same as &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;DELIMITER&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;DELIMITER&lt;/code&gt; 옵션 과 동일한 데이터 분리 문자를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="2ea5589a2de1bbf6a38c52e2fee044d28c651545" translate="yes" xml:space="preserve">
          <source>Specifies the data encoding, the same as &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;ENCODING&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;ENCODING&lt;/code&gt; 옵션 과 동일한 데이터 인코딩을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="5af8a52127fbfc1a4cc525367a5a62ffaf272b08" translate="yes" xml:space="preserve">
          <source>Specifies the data escape character, the same as &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;ESCAPE&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;ESCAPE&lt;/code&gt; 옵션 과 동일한 데이터 이스케이프 문자를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="d6eaec56b9205c1e4f20e659077d8c6c791c6e5a" translate="yes" xml:space="preserve">
          <source>Specifies the data format, the same as &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORMAT&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;FORMAT&lt;/code&gt; 옵션 과 동일한 데이터 형식을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e27566dec065f120f231eb33fdff0c56084b43ec" translate="yes" xml:space="preserve">
          <source>Specifies the data null string, the same as &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;NULL&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;NULL&lt;/code&gt; 옵션 과 동일한 데이터 널 문자열을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1fb02119880c09f791ea56ac591737eec724251f" translate="yes" xml:space="preserve">
          <source>Specifies the data quote character, the same as &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;QUOTE&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;QUOTE&lt;/code&gt; 옵션 과 동일한 데이터 인용 문자를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="9305dacf023da04447c13894ccd6992cd30edebe" translate="yes" xml:space="preserve">
          <source>Specifies the database user who will own the new database. (This name is processed as a double-quoted identifier.)</source>
          <target state="translated">새 데이터베이스를 소유 할 데이터베이스 사용자를 지정합니다. (이 이름은 큰 따옴표로 식별됩니다.)</target>
        </trans-unit>
        <trans-unit id="e7915b5d5c43507845a24f072c5948f5c974a2bb" translate="yes" xml:space="preserve">
          <source>Specifies the default tablespace for the database. (This name is processed as a double-quoted identifier.)</source>
          <target state="translated">데이터베이스의 기본 테이블 스페이스를 지정합니다. (이 이름은 큰 따옴표로 식별됩니다.)</target>
        </trans-unit>
        <trans-unit id="85e58274db7fe8fbe7486990e2789e2add28ad36" translate="yes" xml:space="preserve">
          <source>Specifies the default time zone of the created database cluster. The value should be a full time zone name (see &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;).</source>
          <target state="translated">작성된 데이터베이스 클러스터의 기본 시간대를 지정합니다. 값은 전체 시간대 이름이어야합니다 ( &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b532386e1375b53e2307c6a49bffa84bafbabdcc" translate="yes" xml:space="preserve">
          <source>Specifies the delay between activity rounds for the background writer. In each round the writer issues writes for some number of dirty buffers (controllable by the following parameters). It then sleeps for the length of &lt;code&gt;bgwriter_delay&lt;/code&gt;, and repeats. When there are no dirty buffers in the buffer pool, though, it goes into a longer sleep regardless of &lt;code&gt;bgwriter_delay&lt;/code&gt;. If this value is specified without units, it is taken as milliseconds. The default value is 200 milliseconds (&lt;code&gt;200ms&lt;/code&gt;). Note that on many systems, the effective resolution of sleep delays is 10 milliseconds; setting &lt;code&gt;bgwriter_delay&lt;/code&gt; to a value that is not a multiple of 10 might have the same results as setting it to the next higher multiple of 10. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">백그라운드 작성기의 활동 라운드 간 지연을 지정합니다. 각 라운드에서 라이터는 몇 개의 더티 버퍼에 대한 쓰기를 실행합니다 (다음 매개 변수로 제어 가능). 그런 다음 &lt;code&gt;bgwriter_delay&lt;/code&gt; 길이 동안 휴면 상태를 유지합니다 . 버퍼 풀에 더티 버퍼가 없으면 &lt;code&gt;bgwriter_delay&lt;/code&gt; 에 관계없이 더 이상 휴면 상태가됩니다 . 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 200 밀리 초 ( &lt;code&gt;200ms&lt;/code&gt; )입니다. 많은 시스템에서 수면 지연의 유효 해상도는 10 밀리 초입니다. &lt;code&gt;bgwriter_delay&lt;/code&gt; 설정10의 배수가 아닌 값으로 설정하면 다음 10의 배수로 설정하는 것과 동일한 결과를 얻을 수 있습니다.이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 행 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65891b99ebd84a5b4b8f9137b7b2548818a03e44" translate="yes" xml:space="preserve">
          <source>Specifies the directory of the Unix-domain socket on which &lt;code&gt;postgres&lt;/code&gt; is to listen for connections from client applications. The value can also be a comma-separated list of directories. An empty value specifies not listening on any Unix-domain sockets, in which case only TCP/IP sockets can be used to connect to the server. The default value is normally &lt;code&gt;/tmp&lt;/code&gt;, but that can be changed at build time. Specifying this option is equivalent to setting the &lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt; configuration parameter.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 가 클라이언트 애플리케이션으로부터의 연결을 청취 할 Unix 도메인 소켓의 디렉토리를 지정합니다 . 이 값은 쉼표로 구분 된 디렉토리 목록 일 수도 있습니다. 빈 값은 Unix 도메인 소켓에서 수신 대기를 지정하지 않으며,이 경우 TCP / IP 소켓 만 사용하여 서버에 연결할 수 있습니다. 기본값은 일반적으로 &lt;code&gt;/tmp&lt;/code&gt; 이지만 빌드시 변경할 수 있습니다. 이 옵션을 지정하는 것은 &lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt; 구성 매개 변수 를 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9f92701675ccc7e5c65cd587df83a3e9fd36185c" translate="yes" xml:space="preserve">
          <source>Specifies the directory of the Unix-domain socket(s) on which the server is to listen for connections from client applications. Multiple sockets can be created by listing multiple directories separated by commas. Whitespace between entries is ignored; surround a directory name with double quotes if you need to include whitespace or commas in the name. An empty value specifies not listening on any Unix-domain sockets, in which case only TCP/IP sockets can be used to connect to the server. The default value is normally &lt;code&gt;/tmp&lt;/code&gt;, but that can be changed at build time. On Windows, the default is empty, which means no Unix-domain socket is created by default. This parameter can only be set at server start.</source>
          <target state="translated">Specifies the directory of the Unix-domain socket(s) on which the server is to listen for connections from client applications. Multiple sockets can be created by listing multiple directories separated by commas. Whitespace between entries is ignored; surround a directory name with double quotes if you need to include whitespace or commas in the name. An empty value specifies not listening on any Unix-domain sockets, in which case only TCP/IP sockets can be used to connect to the server. The default value is normally &lt;code&gt;/tmp&lt;/code&gt; , but that can be changed at build time. On Windows, the default is empty, which means no Unix-domain socket is created by default. This parameter can only be set at server start.</target>
        </trans-unit>
        <trans-unit id="2ece6c2b137836024542c892b5cbde6d4260efa0" translate="yes" xml:space="preserve">
          <source>Specifies the directory of the Unix-domain socket(s) on which the server is to listen for connections from client applications. Multiple sockets can be created by listing multiple directories separated by commas. Whitespace between entries is ignored; surround a directory name with double quotes if you need to include whitespace or commas in the name. An empty value specifies not listening on any Unix-domain sockets, in which case only TCP/IP sockets can be used to connect to the server. The default value is normally &lt;code&gt;/tmp&lt;/code&gt;, but that can be changed at build time. This parameter can only be set at server start.</source>
          <target state="translated">서버가 클라이언트 응용 프로그램의 연결을 청취 할 Unix 도메인 소켓의 디렉토리를 지정합니다. 쉼표로 구분 된 여러 디렉토리를 나열하여 여러 소켓을 작성할 수 있습니다. 항목 사이의 공백은 무시됩니다. 이름에 공백이나 쉼표를 포함해야하는 경우 디렉토리 이름을 큰 따옴표로 묶으십시오. 빈 값은 Unix 도메인 소켓에서 수신 대기를 지정하지 않으며,이 경우 TCP / IP 소켓 만 사용하여 서버에 연결할 수 있습니다. 기본값은 일반적으로 &lt;code&gt;/tmp&lt;/code&gt; 이지만 빌드시 변경할 수 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb29cb5eeb7f7be52b758840367e33a588690dab" translate="yes" xml:space="preserve">
          <source>Specifies the directory to use for data storage. This parameter can only be set at server start.</source>
          <target state="translated">데이터 스토리지에 사용할 디렉토리를 지정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11db5df96b49399726662fcbc893e27a9805ff11" translate="yes" xml:space="preserve">
          <source>Specifies the directory where the database cluster is stored.</source>
          <target state="translated">데이터베이스 클러스터가 저장된 디렉토리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c0c2552ed1cff5eeeb9b6a5931f697e4a6460190" translate="yes" xml:space="preserve">
          <source>Specifies the directory where the database cluster is stored; can be overridden using the &lt;code&gt;-D&lt;/code&gt; option.</source>
          <target state="translated">데이터베이스 클러스터가 저장된 디렉토리를 지정합니다. &lt;code&gt;-D&lt;/code&gt; 옵션을 사용하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="faf02825df46734a3a4d7329750e798986daa627" translate="yes" xml:space="preserve">
          <source>Specifies the directory where the database cluster is to be stored; can be overridden using the &lt;code&gt;-D&lt;/code&gt; option.</source>
          <target state="translated">데이터베이스 클러스터가 저장 될 디렉토리를 지정합니다. &lt;code&gt;-D&lt;/code&gt; 옵션을 사용하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6dea9fa06e699d296db947040f8b73a9cca2562" translate="yes" xml:space="preserve">
          <source>Specifies the dynamic shared memory implementation that the server should use. Possible values are &lt;code&gt;posix&lt;/code&gt; (for POSIX shared memory allocated using &lt;code&gt;shm_open&lt;/code&gt;), &lt;code&gt;sysv&lt;/code&gt; (for System V shared memory allocated via &lt;code&gt;shmget&lt;/code&gt;), &lt;code&gt;windows&lt;/code&gt; (for Windows shared memory), and &lt;code&gt;mmap&lt;/code&gt; (to simulate shared memory using memory-mapped files stored in the data directory). Not all values are supported on all platforms; the first supported option is the default for that platform. The use of the &lt;code&gt;mmap&lt;/code&gt; option, which is not the default on any platform, is generally discouraged because the operating system may write modified pages back to disk repeatedly, increasing system I/O load; however, it may be useful for debugging, when the &lt;code&gt;pg_dynshmem&lt;/code&gt; directory is stored on a RAM disk, or when other shared memory facilities are not available.</source>
          <target state="translated">서버가 사용해야하는 동적 공유 메모리 구현을 지정합니다. 가능한 값은 &lt;code&gt;posix&lt;/code&gt; ( &lt;code&gt;shm_open&lt;/code&gt; 을 사용하여 할당 된 POSIX 공유 메모리의 경우 ), &lt;code&gt;sysv&lt;/code&gt; ( &lt;code&gt;shmget&lt;/code&gt; 을 통해 할당 된 System V 공유 메모리의 경우 ), &lt;code&gt;windows&lt;/code&gt; (Windows 공유 메모리의 경우) 및 &lt;code&gt;mmap&lt;/code&gt; (데이터에 저장된 메모리 매핑 된 파일을 사용하여 공유 메모리를 시뮬레이트하는 것)입니다. 예배 규칙서). 모든 플랫폼에서 모든 값이 지원되는 것은 아닙니다. 지원되는 첫 번째 옵션은 해당 플랫폼의 기본값입니다. 의 사용 &lt;code&gt;mmap&lt;/code&gt; 운영 체제가 수정 된 페이지를 디스크에 반복해서 다시 기록하여 시스템 I / O로드를 증가시킬 수 있으므로 모든 플랫폼에서 기본값이 아닌 옵션은 일반적으로 사용하지 않는 것이 좋습니다. 그러나 &lt;code&gt;pg_dynshmem&lt;/code&gt; 디렉토리가 RAM 디스크에 저장되어 있거나 다른 공유 메모리 기능을 사용할 수없는 경우 디버깅에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="760955cf97ee3290fb4508d4d49cce72805b4c4e" translate="yes" xml:space="preserve">
          <source>Specifies the field separator to be used in CSV output format. If the separator character appears in a field's value, that field is output within double quotes, following standard CSV rules. The default is a comma.</source>
          <target state="translated">CSV 출력 형식으로 사용할 필드 구분 기호를 지정합니다. 구분 기호 문자가 필드 값에 나타나면 해당 필드는 표준 CSV 규칙에 따라 큰 따옴표 안에 출력됩니다. 기본값은 쉼표입니다.</target>
        </trans-unit>
        <trans-unit id="2e917d1d433d917f6043796b032bcd2ffaee9907" translate="yes" xml:space="preserve">
          <source>Specifies the field separator to be used in unaligned output format. That way one can create, for example, tab-separated output, which other programs might prefer. To set a tab as field separator, type &lt;code&gt;\pset fieldsep '\t'&lt;/code&gt;. The default field separator is &lt;code&gt;'|'&lt;/code&gt; (a vertical bar).</source>
          <target state="translated">정렬되지 않은 출력 형식으로 사용할 필드 구분 기호를 지정합니다. 이렇게하면 예를 들어 다른 프로그램이 선호하는 탭으로 구분 된 출력을 만들 수 있습니다. 탭을 필드 구분자로 설정하려면 &lt;code&gt;\pset fieldsep '\t'&lt;/code&gt; . 기본 필드 구분 기호는 &lt;code&gt;'|'&lt;/code&gt; (세로 막대).</target>
        </trans-unit>
        <trans-unit id="04cee49efc62ebe789d21e0e47ab887d247c1561" translate="yes" xml:space="preserve">
          <source>Specifies the file name to write test data in. This file should be in the same file system that the &lt;code&gt;pg_wal&lt;/code&gt; directory is or will be placed in. (&lt;code&gt;pg_wal&lt;/code&gt; contains the WAL files.) The default is &lt;code&gt;pg_test_fsync.out&lt;/code&gt; in the current directory.</source>
          <target state="translated">테스트 데이터를 쓸 파일 이름을 지정합니다.이 파일은 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리 와 같 거나 배치 될 파일 시스템에 있어야합니다 . ( &lt;code&gt;pg_wal&lt;/code&gt; 은 WAL 파일을 포함합니다.) 기본값은 현재 디렉토리에서 &lt;code&gt;pg_test_fsync.out&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fced01e8658afcc18d03f94c05c35dca865c777" translate="yes" xml:space="preserve">
          <source>Specifies the file system location of the database configuration files. If this option is omitted, the environment variable &lt;code&gt;PGDATA&lt;/code&gt; is used.</source>
          <target state="translated">데이터베이스 구성 파일의 파일 시스템 위치를 지정합니다. 이 옵션을 생략하면 환경 변수 &lt;code&gt;PGDATA&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fce11e308f8b788248456ee55963a12916efd84e" translate="yes" xml:space="preserve">
          <source>Specifies the file system location of the database configuration files. See &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt; for details.</source>
          <target state="translated">데이터베이스 구성 파일의 파일 시스템 위치를 지정합니다. 자세한 내용 &lt;a href=&quot;runtime-config-file-locations&quot;&gt;은 19.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6bdce9b9a73682cb387605b56e2bec119f17da6" translate="yes" xml:space="preserve">
          <source>Specifies the file system path to the data directory of the source server to synchronize the target with. This option requires the source server to be cleanly shut down.</source>
          <target state="translated">대상과 동기화 할 소스 서버의 데이터 디렉토리에 대한 파일 시스템 경로를 지정합니다. 이 옵션을 사용하려면 소스 서버를 완전히 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="411e213240e08ca41390292b5e38f6b03746b594" translate="yes" xml:space="preserve">
          <source>Specifies the file to be read. Must be an absolute path name. Either &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;program&lt;/code&gt; must be specified, but not both.</source>
          <target state="translated">읽을 파일을 지정합니다. 절대 경로 이름이어야합니다. 어느 &lt;code&gt;filename&lt;/code&gt; 또는 &lt;code&gt;program&lt;/code&gt; 지정된 있지만 두해야합니다.</target>
        </trans-unit>
        <trans-unit id="08934caea4c1eeffe19f4d899c8f9bb92e1f1430" translate="yes" xml:space="preserve">
          <source>Specifies the file to be read. Relative paths are relative to the data directory. Either &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;program&lt;/code&gt; must be specified, but not both.</source>
          <target state="translated">Specifies the file to be read. Relative paths are relative to the data directory. Either &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;program&lt;/code&gt; must be specified, but not both.</target>
        </trans-unit>
        <trans-unit id="08877521850620f394bb17ee11ca3feb476df03a" translate="yes" xml:space="preserve">
          <source>Specifies the fraction of the total number of heap tuples counted in the previous statistics collection that can be inserted without incurring an index scan at the &lt;code&gt;VACUUM&lt;/code&gt; cleanup stage. This setting currently applies to B-tree indexes only.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 정리 단계 에서 인덱스 스캔을 수행하지 않고 삽입 할 수있는 이전 통계 콜렉션에서 계산 된 총 힙 튜플의 비율을 지정합니다 . 이 설정은 현재 B- 트리 인덱스에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b9ed7d21ee29b1d7465127ec160457147915070" translate="yes" xml:space="preserve">
          <source>Specifies the host name of the machine on which the database server is running. If the value begins with a slash, it is used as the directory for the Unix domain socket. The default is taken from the &lt;code&gt;PGHOST&lt;/code&gt; environment variable, if set, else a Unix domain socket connection is attempted.</source>
          <target state="translated">데이터베이스 서버가 실행중인 시스템의 호스트 이름을 지정합니다. 값이 슬래시로 시작하면 Unix 도메인 소켓의 디렉토리로 사용됩니다. 기본값은 &lt;code&gt;PGHOST&lt;/code&gt; 환경 변수 에서 가져옵니다 ( 설정된 경우). 그렇지 않으면 Unix 도메인 소켓 연결이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="7b33215b75a3b8e77a3311c8e8a50d808b349e56" translate="yes" xml:space="preserve">
          <source>Specifies the host name of the machine on which the server is running. If the value begins with a slash, it is used as the directory for a Unix domain socket. The default is taken from the &lt;code&gt;PGHOST&lt;/code&gt; environment variable, if set, else a Unix domain socket connection is attempted.</source>
          <target state="translated">Specifies the host name of the machine on which the server is running. If the value begins with a slash, it is used as the directory for a Unix domain socket. The default is taken from the &lt;code&gt;PGHOST&lt;/code&gt; environment variable, if set, else a Unix domain socket connection is attempted.</target>
        </trans-unit>
        <trans-unit id="378299773e2dcbbba21e7bfe4902078b6a68428f" translate="yes" xml:space="preserve">
          <source>Specifies the host name of the machine on which the server is running. If the value begins with a slash, it is used as the directory for the Unix domain socket.</source>
          <target state="translated">서버가 실행중인 시스템의 호스트 이름을 지정합니다. 값이 슬래시로 시작하면 Unix 도메인 소켓의 디렉토리로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1104adbc4a77ea04906311b0d429b5af7cf8b538" translate="yes" xml:space="preserve">
          <source>Specifies the host name of the machine on which the server is running. If the value begins with a slash, it is used as the directory for the Unix domain socket. The default is taken from the &lt;code&gt;PGHOST&lt;/code&gt; environment variable, if set, else a Unix domain socket connection is attempted.</source>
          <target state="translated">서버가 실행중인 시스템의 호스트 이름을 지정합니다. 값이 슬래시로 시작하면 Unix 도메인 소켓의 디렉토리로 사용됩니다. 기본값은 &lt;code&gt;PGHOST&lt;/code&gt; 환경 변수 에서 가져옵니다 ( 설정된 경우). 그렇지 않으면 Unix 도메인 소켓 연결이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="b77d791d0d8685e5a29d9b871f2bdf6c521c05de" translate="yes" xml:space="preserve">
          <source>Specifies the host name of the machine on which the server is running. If the value begins with a slash, it is used as the directory for the Unix-domain socket.</source>
          <target state="translated">서버가 실행중인 시스템의 호스트 이름을 지정합니다. 값이 슬래시로 시작하면 Unix 도메인 소켓의 디렉토리로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb03ba8300bc7d9b1acc3da46e5cafc97ca9080d" translate="yes" xml:space="preserve">
          <source>Specifies the locale to be used in this database. This is equivalent to specifying both &lt;code&gt;--lc-collate&lt;/code&gt; and &lt;code&gt;--lc-ctype&lt;/code&gt;.</source>
          <target state="translated">이 데이터베이스에서 사용될 로케일을 지정합니다. &lt;code&gt;--lc-collate&lt;/code&gt; 및 &lt;code&gt;--lc-ctype&lt;/code&gt; 을 모두 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="32d3c2328c525bf7ec362c874803f45f18836f7d" translate="yes" xml:space="preserve">
          <source>Specifies the location for the write-ahead log directory. &lt;code&gt;waldir&lt;/code&gt; must be an absolute path. The write-ahead log directory can only be specified when the backup is in plain mode.</source>
          <target state="translated">미리 쓰기 로그 디렉토리의 위치를 ​​지정합니다. &lt;code&gt;waldir&lt;/code&gt; 는 절대 경로 여야합니다. 미리 쓰기 로그 디렉토리는 백업이 일반 모드 인 경우에만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="146ce026eb97b19b6590e742fbbe8b13613d13d2" translate="yes" xml:space="preserve">
          <source>Specifies the location of the &lt;code&gt;postgres&lt;/code&gt; executable. By default the &lt;code&gt;postgres&lt;/code&gt; executable is taken from the same directory as &lt;code&gt;pg_ctl&lt;/code&gt;, or failing that, the hard-wired installation directory. It is not necessary to use this option unless you are doing something unusual and get errors that the &lt;code&gt;postgres&lt;/code&gt; executable was not found.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 실행 파일 의 위치를 ​​지정합니다 . 기본적으로 &lt;code&gt;postgres&lt;/code&gt; 실행 파일은 &lt;code&gt;pg_ctl&lt;/code&gt; 과 동일한 디렉토리 또는 하드 배선 된 설치 디렉토리에서 실패합니다. 비정상적인 작업을 수행하고 &lt;code&gt;postgres&lt;/code&gt; 실행 파일을 찾을 수없는 오류가 발생하지 않으면이 옵션을 사용할 필요 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="67cf41f8a4f60dc2e9858ff9535fd94e3e6a81dd" translate="yes" xml:space="preserve">
          <source>Specifies the location of the archive file (or directory, for a directory-format archive) to be restored. If not specified, the standard input is used.</source>
          <target state="translated">복원 할 아카이브 파일 (또는 디렉토리 형식 아카이브의 디렉토리)의 위치를 ​​지정합니다. 지정하지 않으면 표준 입력이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="78c275e7478de780e0c0ae20a65504117c5eb802" translate="yes" xml:space="preserve">
          <source>Specifies the main server configuration file (customarily called &lt;code&gt;postgresql.conf&lt;/code&gt;). This parameter can only be set on the &lt;code&gt;postgres&lt;/code&gt; command line.</source>
          <target state="translated">기본 서버 구성 파일 (사용자 정의 &lt;code&gt;postgresql.conf&lt;/code&gt; )을 지정합니다 . 이 매개 변수는 &lt;code&gt;postgres&lt;/code&gt; 명령 행 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e97ccf4a8e23f9d384eed434906574cc2271c74" translate="yes" xml:space="preserve">
          <source>Specifies the maximum age (in multixacts) that a table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; field can attain before a &lt;code&gt;VACUUM&lt;/code&gt; operation is forced to prevent multixact ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled.</source>
          <target state="translated">테이블의 &lt;code&gt;pg_class&lt;/code&gt; 최대 수명 (멀티 액스)을 지정합니다 . &lt;code&gt;relminmxid&lt;/code&gt; 필드는 &lt;code&gt;VACUUM&lt;/code&gt; 작업이 테이블 내에서 multixact ID 랩 어라운드를 방지 하기 전에 수행 될 수 있습니다 . 시스템은 autovacuum이 비활성화되어 있어도 랩 어라운드를 방지하기 위해 autovacuum 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5affde86c2fe5784f06a063b364dacc33bbb535a" translate="yes" xml:space="preserve">
          <source>Specifies the maximum age (in transactions) that a table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfrozenxid&lt;/code&gt; field can attain before a &lt;code&gt;VACUUM&lt;/code&gt; operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled.</source>
          <target state="translated">테이블의 &lt;code&gt;pg_class&lt;/code&gt; 인 최대 기간 (트랜잭션 내)을 지정합니다 . &lt;code&gt;relfrozenxid&lt;/code&gt; 필드는 &lt;code&gt;VACUUM&lt;/code&gt; 작업이 테이블 내에서 트랜잭션 ID 랩 어라운드를 방지 하기 전에 수행 될 수 있습니다 . 시스템은 autovacuum이 비활성화되어 있어도 랩 어라운드를 방지하기 위해 autovacuum 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3f010b7fcdde599793afec4e96d15a5fb2abe975" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of disk space that a process can use for temporary files, such as sort and hash temporary files, or the storage file for a held cursor. A transaction attempting to exceed this limit will be canceled. If this value is specified without units, it is taken as kilobytes. &lt;code&gt;-1&lt;/code&gt; (the default) means no limit. Only superusers can change this setting.</source>
          <target state="translated">프로세스가 정렬 및 해시 임시 파일과 같은 임시 파일 또는 보류 된 커서의 스토리지 파일에 사용할 수있는 최대 디스크 공간을 지정합니다. 이 한도를 초과하려는 거래는 취소됩니다. 이 값을 단위없이 지정하면 킬로바이트로 간주됩니다. &lt;code&gt;-1&lt;/code&gt; (기본값)은 제한이 없음을 의미합니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0573c5c6cbdc223f1b969e9b0f0a345c30b39d5" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of memory to be used by each autovacuum worker process. If this value is specified without units, it is taken as kilobytes. It defaults to -1, indicating that the value of &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; should be used instead. The setting has no effect on the behavior of &lt;code&gt;VACUUM&lt;/code&gt; when run in other contexts.</source>
          <target state="translated">각 자동 진공 작업자 프로세스에서 사용할 최대 메모리 양을 지정합니다. 이 값을 단위없이 지정하면 킬로바이트로 간주됩니다. 기본값은 -1이며 &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 값을 대신 사용해야 함을 나타냅니다 . 설정은 다른 컨텍스트에서 실행될 때 &lt;code&gt;VACUUM&lt;/code&gt; 의 동작에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f20ba25be2ae4f074daf969e02c820a003ce7d14" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of memory to be used by logical decoding, before some of the decoded changes are written to local disk. This limits the amount of memory used by logical streaming replication connections. It defaults to 64 megabytes (&lt;code&gt;64MB&lt;/code&gt;). Since each replication connection only uses a single buffer of this size, and an installation normally doesn't have many such connections concurrently (as limited by &lt;code&gt;max_wal_senders&lt;/code&gt;), it's safe to set this value significantly higher than &lt;code&gt;work_mem&lt;/code&gt;, reducing the amount of decoded changes written to disk.</source>
          <target state="translated">Specifies the maximum amount of memory to be used by logical decoding, before some of the decoded changes are written to local disk. This limits the amount of memory used by logical streaming replication connections. It defaults to 64 megabytes ( &lt;code&gt;64MB&lt;/code&gt; ). Since each replication connection only uses a single buffer of this size, and an installation normally doesn't have many such connections concurrently (as limited by &lt;code&gt;max_wal_senders&lt;/code&gt; ), it's safe to set this value significantly higher than &lt;code&gt;work_mem&lt;/code&gt; , reducing the amount of decoded changes written to disk.</target>
        </trans-unit>
        <trans-unit id="126d64716f55e0082a6fcec7e843ff39dfb3930f" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of memory to be used by maintenance operations, such as &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, and &lt;code&gt;ALTER TABLE ADD FOREIGN KEY&lt;/code&gt;. If this value is specified without units, it is taken as kilobytes. It defaults to 64 megabytes (&lt;code&gt;64MB&lt;/code&gt;). Since only one of these operations can be executed at a time by a database session, and an installation normally doesn't have many of them running concurrently, it's safe to set this value significantly larger than &lt;code&gt;work_mem&lt;/code&gt;. Larger settings might improve performance for vacuuming and for restoring database dumps.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; 및 &lt;code&gt;ALTER TABLE ADD FOREIGN KEY&lt;/code&gt; 와 같은 유지 보수 조작에서 사용할 최대 메모리 양을 지정합니다 . 이 값을 단위없이 지정하면 킬로바이트로 간주됩니다. 기본값은 &lt;code&gt;64MB&lt;/code&gt; ( 64MB )입니다. 이러한 작업 중 하나만 데이터베이스 세션에 의해 한 번에 실행될 수 있으며 설치시 일반적으로 많은 작업이 동시에 실행되지 &lt;code&gt;work_mem&lt;/code&gt; 값을 work_mem 보다 크게 크게 설정하는 것이 안전합니다 . 설정이 클수록 데이터베이스 덤프를 정리하고 복원하기위한 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd32d6b12ec5aaa1b931d66d0b7044757f368123" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.</source>
          <target state="translated">한 번에 실행될 수있는 최대 자동 진공 프로세스 수 (자동 진공 실행기 제외)를 지정합니다. 기본값은 3입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b383405f7162dd50d5848f42073bbeb113500832" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of concurrent connections from standby servers or streaming base backup clients (i.e., the maximum number of simultaneously running WAL sender processes). The default is &lt;code&gt;10&lt;/code&gt;. The value &lt;code&gt;0&lt;/code&gt; means replication is disabled. Abrupt disconnection of a streaming client might leave an orphaned connection slot behind until a timeout is reached, so this parameter should be set slightly higher than the maximum number of expected clients so disconnected clients can immediately reconnect. This parameter can only be set at server start. Also, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;replica&lt;/code&gt; or higher to allow connections from standby servers.</source>
          <target state="translated">Specifies the maximum number of concurrent connections from standby servers or streaming base backup clients (i.e., the maximum number of simultaneously running WAL sender processes). The default is &lt;code&gt;10&lt;/code&gt; . The value &lt;code&gt;0&lt;/code&gt; means replication is disabled. Abrupt disconnection of a streaming client might leave an orphaned connection slot behind until a timeout is reached, so this parameter should be set slightly higher than the maximum number of expected clients so disconnected clients can immediately reconnect. This parameter can only be set at server start. Also, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;replica&lt;/code&gt; or higher to allow connections from standby servers.</target>
        </trans-unit>
        <trans-unit id="d86d4a61156c2127910d22c104af16bc1a25e54c" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of concurrent connections from standby servers or streaming base backup clients (i.e., the maximum number of simultaneously running WAL sender processes). The default is &lt;code&gt;10&lt;/code&gt;. The value &lt;code&gt;0&lt;/code&gt; means replication is disabled. Abrupt streaming client disconnection might leave an orphaned connection slot behind until a timeout is reached, so this parameter should be set slightly higher than the maximum number of expected clients so disconnected clients can immediately reconnect. This parameter can only be set at server start. Also, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;replica&lt;/code&gt; or higher to allow connections from standby servers.</source>
          <target state="translated">대기 서버 또는 스트리밍 기본 백업 클라이언트로부터의 최대 동시 연결 수를 지정합니다 (즉, 동시에 실행되는 최대 WAL 송신자 프로세스 수). 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다. 값이 &lt;code&gt;0&lt;/code&gt; 이면 복제가 비활성화 된 것입니다. 스트리밍 클라이언트 연결이 갑자기 끊어지면 시간 초과에 도달 할 때까지 고아 연결 슬롯이 남겨질 수 있으므로이 매개 변수는 최대 예상 클라이언트 수보다 약간 높게 설정되어 연결이 끊긴 클라이언트가 즉시 다시 연결할 수 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 또한 대기 서버로부터의 연결을 허용 하려면 &lt;code&gt;wal_level&lt;/code&gt; 을 &lt;code&gt;replica&lt;/code&gt; 이상 으로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0e16d0fca721e93f769eda585ab46fe9f10953cb" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of replication slots (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;) that the server can support. The default is 10. This parameter can only be set at server start. Setting it to a lower value than the number of currently existing replication slots will prevent the server from starting. Also, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;replica&lt;/code&gt; or higher to allow replication slots to be used.</source>
          <target state="translated">서버가 지원할 수 있는 최대 복제 슬롯 수 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;섹션 26.2.6&lt;/a&gt; 참조 )를 지정합니다. 기본값은 10입니다.이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 현재 존재하는 복제 슬롯 수보다 낮은 값으로 설정하면 서버가 시작되지 않습니다. 또한 복제 슬롯을 사용 하려면 &lt;code&gt;wal_level&lt;/code&gt; 을 &lt;code&gt;replica&lt;/code&gt; 이상 으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a990b44b3d9cccdd64f1d53821fc66bf704b75f8" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of seconds to wait when waiting for an operation to complete (see option &lt;code&gt;-w&lt;/code&gt;). Defaults to the value of the &lt;code&gt;PGCTLTIMEOUT&lt;/code&gt; environment variable or, if not set, to 60 seconds.</source>
          <target state="translated">작업 완료를 기다릴 때 대기 할 최대 시간 (초)을 지정합니다 ( &lt;code&gt;-w&lt;/code&gt; 옵션 참조 ). 기본값은 &lt;code&gt;PGCTLTIMEOUT&lt;/code&gt; 환경 변수 의 값 또는 설정되지 않은 경우 60 초로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f2eb91704d62701e391e184a733cf4465a18531f" translate="yes" xml:space="preserve">
          <source>Specifies the maximum safe depth of the server's execution stack. The ideal setting for this parameter is the actual stack size limit enforced by the kernel (as set by &lt;code&gt;ulimit -s&lt;/code&gt; or local equivalent), less a safety margin of a megabyte or so. The safety margin is needed because the stack depth is not checked in every routine in the server, but only in key potentially-recursive routines. If this value is specified without units, it is taken as kilobytes. The default setting is two megabytes (&lt;code&gt;2MB&lt;/code&gt;), which is conservatively small and unlikely to risk crashes. However, it might be too small to allow execution of complex functions. Only superusers can change this setting.</source>
          <target state="translated">서버 실행 스택의 최대 안전 깊이를 지정합니다. 이 매개 변수의 이상적인 설정은 커널에 의해 강제 된 실제 스택 크기 제한 ( &lt;code&gt;ulimit -s&lt;/code&gt; 또는 로컬 등가 로 설정 됨 )이며, 안전 마진 (MB) 정도는 적습니다. 서버의 모든 루틴에서 스택 깊이를 검사하는 것이 아니라 잠재적으로 재귀 가능한 주요 루틴에서만 스택 깊이를 검사하므로 안전 여유가 필요합니다. 이 값을 단위없이 지정하면 킬로바이트로 간주됩니다. 기본 설정은 &lt;code&gt;2MB&lt;/code&gt; ( 2MB )이며 이는 보수적으로 작으며 충돌의 위험이 없습니다. 그러나 복잡한 기능을 실행하기에는 너무 작을 수 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7234d0051dd21c559d43eed9daa7ea589a63a0cd" translate="yes" xml:space="preserve">
          <source>Specifies the minimum delay between autovacuum runs on any given database. In each round the daemon examines the database and issues &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; commands as needed for tables in that database. If this value is specified without units, it is taken as seconds. The default is one minute (&lt;code&gt;1min&lt;/code&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">지정된 데이터베이스에서 자동 진공 실행 사이의 최소 지연을 지정합니다. 각 라운드에서 데몬은 데이터베이스를 검사하고 해당 데이터베이스의 테이블에 필요한 &lt;code&gt;VACUUM&lt;/code&gt; 및 &lt;code&gt;ANALYZE&lt;/code&gt; 명령을 실행합니다. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 기본값은 1 분 ( &lt;code&gt;1min&lt;/code&gt; )입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="267c64f5c00b0e74b3708b0fce086b4c4b979899" translate="yes" xml:space="preserve">
          <source>Specifies the minimum frequency for the WAL receiver process on the standby to send information about replication progress to the primary or upstream standby, where it can be seen using the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; view. The standby will report the last write-ahead log location it has written, the last position it has flushed to disk, and the last position it has applied. This parameter's value is the maximum amount of time between reports. Updates are sent each time the write or flush positions change, or at least as often as specified by this parameter. Thus, the apply position may lag slightly behind the true position. If this value is specified without units, it is taken as seconds. The default value is 10 seconds. Setting this parameter to zero disables status updates completely. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Specifies the minimum frequency for the WAL receiver process on the standby to send information about replication progress to the primary or upstream standby, where it can be seen using the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt; &lt;code&gt;pg_stat_replication&lt;/code&gt; &lt;/a&gt; view. The standby will report the last write-ahead log location it has written, the last position it has flushed to disk, and the last position it has applied. This parameter's value is the maximum amount of time between reports. Updates are sent each time the write or flush positions change, or at least as often as specified by this parameter. Thus, the apply position may lag slightly behind the true position. If this value is specified without units, it is taken as seconds. The default value is 10 seconds. Setting this parameter to zero disables status updates completely. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</target>
        </trans-unit>
        <trans-unit id="b2ea8e4056ad15333c7e77677985f461f0b80f0a" translate="yes" xml:space="preserve">
          <source>Specifies the minimum frequency for the WAL receiver process on the standby to send information about replication progress to the primary or upstream standby, where it can be seen using the &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; view. The standby will report the last write-ahead log location it has written, the last position it has flushed to disk, and the last position it has applied. This parameter's value is the maximum amount of time between reports. Updates are sent each time the write or flush positions change, or at least as often as specified by this parameter. Thus, the apply position may lag slightly behind the true position. If this value is specified without units, it is taken as seconds. The default value is 10 seconds. Setting this parameter to zero disables status updates completely. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt; &lt;code&gt;pg_stat_replication&lt;/code&gt; 을&lt;/a&gt; 사용하여 볼 수있는 기본 또는 업스트림 대기로 복제 진행에 대한 정보를 보내기 위해 대기에서 WAL 수신자 프로세스의 최소 빈도를 지정합니다.전망. 대기는 마지막으로 기록한 미리 기록 로그 위치, 디스크로 플러시 된 마지막 위치 및 마지막으로 적용된 위치를보고합니다. 이 매개 변수의 값은 보고서 간 최대 시간입니다. 쓰기 또는 플러시 위치가 변경 될 때마다 또는 최소한이 매개 변수로 지정된 횟수만큼 업데이트가 전송됩니다. 따라서 적용 위치가 실제 위치보다 약간 뒤처 질 수 있습니다. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 기본값은 10 초입니다. 이 매개 변수를 0으로 설정하면 상태 업데이트가 완전히 비활성화됩니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce0ab7b202d3d8692703c1ba1fdf9aca06bfd456" translate="yes" xml:space="preserve">
          <source>Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an &lt;code&gt;ANALYZE&lt;/code&gt; in any one table. The default is 50 tuples. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">하나의 테이블에서 &lt;code&gt;ANALYZE&lt;/code&gt; 를 트리거하는 데 필요한 삽입, 업데이트 또는 삭제 된 튜플의 최소 수를 지정 합니다. 기본값은 50 튜플입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 그러나 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0403968d38181f241e6089a57de9236a1691e263" translate="yes" xml:space="preserve">
          <source>Specifies the minimum number of past log file segments kept in the &lt;code&gt;pg_wal&lt;/code&gt; directory, in case a standby server needs to fetch them for streaming replication. Each segment is normally 16 megabytes. If a standby server connected to the sending server falls behind by more than &lt;code&gt;wal_keep_segments&lt;/code&gt; segments, the sending server might remove a WAL segment still needed by the standby, in which case the replication connection will be terminated. Downstream connections will also eventually fail as a result. (However, the standby server can recover by fetching the segment from archive, if WAL archiving is in use.)</source>
          <target state="translated">대기 서버가 스트리밍 복제를 위해이를 가져와야 할 경우를 대비 하여 &lt;code&gt;pg_wal&lt;/code&gt; 디렉토리에 보관 된 최소 과거 로그 파일 세그먼트 수를 지정 합니다. 각 세그먼트는 일반적으로 16MB입니다. 송신 서버에 연결된 대기 서버가 &lt;code&gt;wal_keep_segments&lt;/code&gt; 세그먼트 보다 많이 뒤쳐 질 경우, 송신 서버는 대기에서 여전히 필요한 WAL 세그먼트를 제거 할 수 있으며이 경우 복제 연결이 종료됩니다. 결과적으로 다운 스트림 연결도 실패합니다. 그러나 WAL 아카이브가 사용중인 경우 대기 서버는 아카이브에서 세그먼트를 페치하여 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c286f041e9491afc48842651c34e1386fc2a3ac4" translate="yes" xml:space="preserve">
          <source>Specifies the minimum number of updated or deleted tuples needed to trigger a &lt;code&gt;VACUUM&lt;/code&gt; in any one table. The default is 50 tuples. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">하나의 테이블에서 &lt;code&gt;VACUUM&lt;/code&gt; 을 트리거하는 데 필요한 업데이트 또는 삭제 된 튜플의 최소 수를 지정 합니다. 기본값은 50 튜플입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 그러나 테이블 스토리지 매개 변수를 변경하여 개별 테이블에 대한 설정을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8cb967b3bebd14ab88f1ef26f4bffddb2565c5a" translate="yes" xml:space="preserve">
          <source>Specifies the minimum size of past log file segments kept in the &lt;code&gt;pg_wal&lt;/code&gt; directory, in case a standby server needs to fetch them for streaming replication. If a standby server connected to the sending server falls behind by more than &lt;code&gt;wal_keep_size&lt;/code&gt; megabytes, the sending server might remove a WAL segment still needed by the standby, in which case the replication connection will be terminated. Downstream connections will also eventually fail as a result. (However, the standby server can recover by fetching the segment from archive, if WAL archiving is in use.)</source>
          <target state="translated">Specifies the minimum size of past log file segments kept in the &lt;code&gt;pg_wal&lt;/code&gt; directory, in case a standby server needs to fetch them for streaming replication. If a standby server connected to the sending server falls behind by more than &lt;code&gt;wal_keep_size&lt;/code&gt; megabytes, the sending server might remove a WAL segment still needed by the standby, in which case the replication connection will be terminated. Downstream connections will also eventually fail as a result. (However, the standby server can recover by fetching the segment from archive, if WAL archiving is in use.)</target>
        </trans-unit>
        <trans-unit id="ec4d011fd180e526dc6d261474f8f2aa1994581b" translate="yes" xml:space="preserve">
          <source>Specifies the name of an additional process-ID (PID) file that the server should create for use by server administration programs. This parameter can only be set at server start.</source>
          <target state="translated">서버가 서버 관리 프로그램에서 사용하기 위해 작성해야하는 추가 프로세스 ID (PID) 파일의 이름을 지정합니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba64ee81036e5a43ac1d284414488964610d00df" translate="yes" xml:space="preserve">
          <source>Specifies the name of the PostgreSQL user to be created. This name must be different from all existing roles in this PostgreSQL installation.</source>
          <target state="translated">작성할 PostgreSQL 사용자의 이름을 지정합니다. 이 이름은이 PostgreSQL 설치에서 기존의 모든 역할과 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="f596235638c2dd0556fe4d70a6782045baaa7b44" translate="yes" xml:space="preserve">
          <source>Specifies the name of the PostgreSQL user to be removed. You will be prompted for a name if none is specified on the command line and the &lt;code&gt;-i&lt;/code&gt;/&lt;code&gt;--interactive&lt;/code&gt; option is used.</source>
          <target state="translated">제거 할 PostgreSQL 사용자의 이름을 지정합니다. 명령 행에 이름이 지정되지 않고 &lt;code&gt;-i&lt;/code&gt; / &lt;code&gt;--interactive&lt;/code&gt; 옵션이 사용 된 경우 이름을 묻는 프롬프트가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="b27c166f7a4f9ca906105a7248615c5eb38e2f3d" translate="yes" xml:space="preserve">
          <source>Specifies the name of the curve to use in ECDH key exchange. It needs to be supported by all clients that connect. It does not need to be the same curve used by the server's Elliptic Curve key. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;prime256v1&lt;/code&gt;.</source>
          <target state="translated">ECDH 키 교환에 사용할 곡선 이름을 지정합니다. 연결하는 모든 클라이언트에서 지원해야합니다. 서버의 타원 곡선 키와 동일한 곡선 일 필요는 없습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;prime256v1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c2f5dba57b0deebf9f28589d386420f0d436f37a" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be accessed. This must be the last argument on the command line. If it is omitted it defaults to the user name.</source>
          <target state="translated">액세스 할 데이터베이스 이름을 지정합니다. 명령 행에서 마지막 인수 여야합니다. 생략하면 기본값은 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9a6d89fc9e77ee3f0191e150ee2fd3ab59290f96" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be cleaned or analyzed, when &lt;code&gt;-a&lt;/code&gt;/&lt;code&gt;--all&lt;/code&gt; is not used. If this is not specified, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt;. If that is not set, the user name specified for the connection is used. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</source>
          <target state="translated">Specifies the name of the database to be cleaned or analyzed, when &lt;code&gt;-a&lt;/code&gt; / &lt;code&gt;--all&lt;/code&gt; is not used. If this is not specified, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt; . If that is not set, the user name specified for the connection is used. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</target>
        </trans-unit>
        <trans-unit id="42c9a31bc526009932a298eaed835ab7845dba65" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be cleaned or analyzed. If this is not specified and &lt;code&gt;-a&lt;/code&gt; (or &lt;code&gt;--all&lt;/code&gt;) is not used, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt;. If that is not set, the user name specified for the connection is used.</source>
          <target state="translated">정리 또는 분석 할 데이터베이스 이름을 지정합니다. 이를 지정하지 않고 &lt;code&gt;-a&lt;/code&gt; (또는 &lt;code&gt;--all&lt;/code&gt; )를 사용하지 않으면 환경 변수 &lt;code&gt;PGDATABASE&lt;/code&gt; 에서 데이터베이스 이름을 읽습니다 . 설정되어 있지 않으면 연결에 지정된 사용자 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1edac6244d0c219a03f7816821420057c8003489" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be clustered, when &lt;code&gt;-a&lt;/code&gt;/&lt;code&gt;--all&lt;/code&gt; is not used. If this is not specified, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt;. If that is not set, the user name specified for the connection is used. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</source>
          <target state="translated">Specifies the name of the database to be clustered, when &lt;code&gt;-a&lt;/code&gt; / &lt;code&gt;--all&lt;/code&gt; is not used. If this is not specified, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt; . If that is not set, the user name specified for the connection is used. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</target>
        </trans-unit>
        <trans-unit id="77286e601c0d7ad6f34cc2441c556793d427eaa0" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be clustered. If this is not specified and &lt;code&gt;-a&lt;/code&gt; (or &lt;code&gt;--all&lt;/code&gt;) is not used, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt;. If that is not set, the user name specified for the connection is used.</source>
          <target state="translated">클러스터 할 데이터베이스의 이름을 지정합니다. 이를 지정하지 않고 &lt;code&gt;-a&lt;/code&gt; (또는 &lt;code&gt;--all&lt;/code&gt; )를 사용하지 않으면 환경 변수 &lt;code&gt;PGDATABASE&lt;/code&gt; 에서 데이터베이스 이름을 읽습니다 . 설정되어 있지 않으면 연결에 지정된 사용자 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bb149ecf0a8a96bd4dcff90624b2044507c63ad7" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be created. The name must be unique among all PostgreSQL databases in this cluster. The default is to create a database with the same name as the current system user.</source>
          <target state="translated">작성할 데이터베이스 이름을 지정합니다. 이 클러스터의 모든 PostgreSQL 데이터베이스에서 이름이 고유해야합니다. 디폴트는 현재 시스템 사용자와 이름이 같은 데이터베이스를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6320121c5ada2cddc268aadc8fa8b77204bd02e" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be dumped. If this is not specified, the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt; is used. If that is not set, the user name specified for the connection is used.</source>
          <target state="translated">덤프 할 데이터베이스의 이름을 지정합니다. 이를 지정하지 않으면 환경 변수 &lt;code&gt;PGDATABASE&lt;/code&gt; 가 사용됩니다. 설정되어 있지 않으면 연결에 지정된 사용자 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="145b4c9a58867d82070d4155f41e9d8101d52309" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be reindexed, when &lt;code&gt;-a&lt;/code&gt;/&lt;code&gt;--all&lt;/code&gt; is not used. If this is not specified, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt;. If that is not set, the user name specified for the connection is used. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</source>
          <target state="translated">Specifies the name of the database to be reindexed, when &lt;code&gt;-a&lt;/code&gt; / &lt;code&gt;--all&lt;/code&gt; is not used. If this is not specified, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt; . If that is not set, the user name specified for the connection is used. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</target>
        </trans-unit>
        <trans-unit id="8aa308a2d58dcda20cc1cc4796d09597d760bab9" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be reindexed. If this is not specified and &lt;code&gt;-a&lt;/code&gt; (or &lt;code&gt;--all&lt;/code&gt;) is not used, the database name is read from the environment variable &lt;code&gt;PGDATABASE&lt;/code&gt;. If that is not set, the user name specified for the connection is used.</source>
          <target state="translated">재색 인화 할 데이터베이스 이름을 지정합니다. 이를 지정하지 않고 &lt;code&gt;-a&lt;/code&gt; (또는 &lt;code&gt;--all&lt;/code&gt; )를 사용하지 않으면 환경 변수 &lt;code&gt;PGDATABASE&lt;/code&gt; 에서 데이터베이스 이름을 읽습니다 . 설정되어 있지 않으면 연결에 지정된 사용자 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="93430faca7110a2ed34b1de2612c19dd5d158e9d" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to be removed.</source>
          <target state="translated">제거 할 데이터베이스 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cbfd83da278393a2bb650f62c07e3bc33867c7a3" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to discover what other databases should be clustered. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, and if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used.</source>
          <target state="translated">클러스터 할 다른 데이터베이스를 발견하기 위해 연결할 데이터베이스 이름을 지정합니다. 지정하지 않으면 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 사용되고 존재하지 않으면 &lt;code&gt;template1&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9960b3884e3ff63577481ba2b475c59038d6128e" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to discover what other databases should be reindexed. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, and if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used.</source>
          <target state="translated">다시 색인화해야 할 다른 데이터베이스를 발견하기 위해 연결할 데이터베이스 이름을 지정합니다. 지정하지 않으면 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 사용되고 존재하지 않으면 &lt;code&gt;template1&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c814583b820381beeb16360a570cd3a52292d9ad" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to discover what other databases should be vacuumed. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, and if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used.</source>
          <target state="translated">정리할 다른 데이터베이스를 발견하기 위해 연결할 데이터베이스 이름을 지정합니다. 지정하지 않으면 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 사용되고 존재하지 않으면 &lt;code&gt;template1&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c495a5df0e2553002c0820b7e223f15ae2a7a682" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to for dumping global objects and discovering what other databases should be dumped. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, and if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used.</source>
          <target state="translated">글로벌 오브젝트를 덤프하고 덤프 할 다른 데이터베이스를 발견하기 위해 연결할 데이터베이스 이름을 지정합니다. 지정하지 않으면 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 사용되고 존재하지 않으면 &lt;code&gt;template1&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="638ef2cbfc482d4ed63ef40a2ba5e0cd385f8f1b" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to in order to drop the target database. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used; if that does not exist (or is the database being dropped), &lt;code&gt;template1&lt;/code&gt; will be used.</source>
          <target state="translated">대상 데이터베이스를 삭제하기 위해 연결할 데이터베이스 이름을 지정합니다. 지정하지 않으면 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 사용됩니다. 존재하지 않거나 데이터베이스가 삭제되는 경우 &lt;code&gt;template1&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9a678049ae0222b783efb8e489371d0743621d1" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to in order to drop the target database. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used; if that does not exist (or is the database being dropped), &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</source>
          <target state="translated">Specifies the name of the database to connect to in order to drop the target database. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used; if that does not exist (or is the database being dropped), &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</target>
        </trans-unit>
        <trans-unit id="0c15af992e34a3a0fa305182ed832a37e16d661a" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to to discover which databases should be clustered, when &lt;code&gt;-a&lt;/code&gt;/&lt;code&gt;--all&lt;/code&gt; is used. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, or if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Also, connection string parameters other than the database name itself will be re-used when connecting to other databases.</source>
          <target state="translated">Specifies the name of the database to connect to to discover which databases should be clustered, when &lt;code&gt;-a&lt;/code&gt; / &lt;code&gt;--all&lt;/code&gt; is used. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, or if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Also, connection string parameters other than the database name itself will be re-used when connecting to other databases.</target>
        </trans-unit>
        <trans-unit id="b66b6659ac6159120b09fa3cd91c4177446d9ec7" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to to discover which databases should be reindexed, when &lt;code&gt;-a&lt;/code&gt;/&lt;code&gt;--all&lt;/code&gt; is used. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, or if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Also, connection string parameters other than the database name itself will be re-used when connecting to other databases.</source>
          <target state="translated">Specifies the name of the database to connect to to discover which databases should be reindexed, when &lt;code&gt;-a&lt;/code&gt; / &lt;code&gt;--all&lt;/code&gt; is used. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, or if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Also, connection string parameters other than the database name itself will be re-used when connecting to other databases.</target>
        </trans-unit>
        <trans-unit id="6c8c12b71804afa9f376c769eff2d36959fb3fed" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to to discover which databases should be vacuumed, when &lt;code&gt;-a&lt;/code&gt;/&lt;code&gt;--all&lt;/code&gt; is used. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, or if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Also, connection string parameters other than the database name itself will be re-used when connecting to other databases.</source>
          <target state="translated">Specifies the name of the database to connect to to discover which databases should be vacuumed, when &lt;code&gt;-a&lt;/code&gt; / &lt;code&gt;--all&lt;/code&gt; is used. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used, or if that does not exist, &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Also, connection string parameters other than the database name itself will be re-used when connecting to other databases.</target>
        </trans-unit>
        <trans-unit id="05aa5906b6d8b93f39c0fb91da9ec9b7045073d5" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to when creating the new database. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used; if that does not exist (or if it is the name of the new database being created), &lt;code&gt;template1&lt;/code&gt; will be used.</source>
          <target state="translated">새 데이터베이스를 작성할 때 연결할 데이터베이스 이름을 지정합니다. 지정하지 않으면 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스가 사용됩니다. 존재하지 않거나 작성중인 새 데이터베이스의 이름 인 경우 &lt;code&gt;template1&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a0c92361f119154286401b1272a455f5208170f" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to when creating the new database. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used; if that does not exist (or if it is the name of the new database being created), &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</source>
          <target state="translated">Specifies the name of the database to connect to when creating the new database. If not specified, the &lt;code&gt;postgres&lt;/code&gt; database will be used; if that does not exist (or if it is the name of the new database being created), &lt;code&gt;template1&lt;/code&gt; will be used. This can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</target>
        </trans-unit>
        <trans-unit id="3b5a050e221e712b6aea81d13bdc8e468c753c77" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to.</source>
          <target state="translated">연결할 데이터베이스 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3a5df3f6366eaac622b92f1e33b1e906b227c4eb" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</source>
          <target state="translated">Specifies the name of the database to connect to. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</target>
        </trans-unit>
        <trans-unit id="83558a13daf04bcf549756b2e27ad9996b0aeef3" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to. This is equivalent to specifying &lt;code&gt;dbname&lt;/code&gt; as the first non-option argument on the command line.</source>
          <target state="translated">연결할 데이터베이스 이름을 지정합니다. 이는 명령 행에서 &lt;code&gt;dbname&lt;/code&gt; 을 옵션이 아닌 첫 번째 인수로 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7045823979a5c9e30b1abf2715a423613f7a37a7" translate="yes" xml:space="preserve">
          <source>Specifies the name of the database to connect to. This is equivalent to specifying &lt;code&gt;dbname&lt;/code&gt; as the first non-option argument on the command line. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</source>
          <target state="translated">Specifies the name of the database to connect to. This is equivalent to specifying &lt;code&gt;dbname&lt;/code&gt; as the first non-option argument on the command line. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options.</target>
        </trans-unit>
        <trans-unit id="3a1908731503b055b19666826b9e04bd057ebf5e" translate="yes" xml:space="preserve">
          <source>Specifies the name of the file containing Diffie-Hellman parameters used for so-called ephemeral DH family of SSL ciphers. The default is empty, in which case compiled-in default DH parameters used. Using custom DH parameters reduces the exposure if an attacker manages to crack the well-known compiled-in DH parameters. You can create your own DH parameters file with the command &lt;code&gt;openssl dhparam -out dhparams.pem 2048&lt;/code&gt;.</source>
          <target state="translated">소위 임시 DH SSL 암호 군에 사용되는 Diffie-Hellman 매개 변수를 포함하는 파일 이름을 지정합니다. 기본값은 비어 있으며,이 경우 컴파일 된 기본 DH 매개 변수가 사용됩니다. 공격자가 잘 알려진 컴파일 된 DH 매개 변수를 해독 할 경우 사용자 지정 DH 매개 변수를 사용하면 노출이 줄어 듭니다. &lt;code&gt;openssl dhparam -out dhparams.pem 2048&lt;/code&gt; 명령을 사용하여 고유 한 DH 매개 변수 파일을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0622470097200762d7d443d008e250439121381d" translate="yes" xml:space="preserve">
          <source>Specifies the name of the file containing the SSL server certificate authority (CA). Relative paths are relative to the data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is empty, meaning no CA file is loaded, and client certificate verification is not performed.</source>
          <target state="translated">SSL 서버 인증 기관 (CA)을 포함하는 파일 이름을 지정합니다. 상대 경로는 데이터 디렉토리를 기준으로합니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 비어 있습니다. 즉, CA 파일이로드되지 않고 클라이언트 인증서 확인이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bae1e7846a9c5450eae51f0ce1248e54dad12868" translate="yes" xml:space="preserve">
          <source>Specifies the name of the file containing the SSL server certificate revocation list (CRL). Relative paths are relative to the data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is empty, meaning no CRL file is loaded.</source>
          <target state="translated">SSL 서버 CRL (Certificate Revocation List)을 포함하는 파일 이름을 지정합니다. 상대 경로는 데이터 디렉토리를 기준으로합니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 비어 있습니다. 즉, CRL 파일이로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38cd4f3dc9813010e6034efda9c09573477cd23b" translate="yes" xml:space="preserve">
          <source>Specifies the name of the file containing the SSL server certificate. Relative paths are relative to the data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;server.crt&lt;/code&gt;.</source>
          <target state="translated">SSL 서버 인증서가 포함 된 파일 이름을 지정합니다. 상대 경로는 데이터 디렉토리를 기준으로합니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;server.crt&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a80365214556c2a2be3de847fc3e074bf0846c6" translate="yes" xml:space="preserve">
          <source>Specifies the name of the file containing the SSL server private key. Relative paths are relative to the data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;server.key&lt;/code&gt;.</source>
          <target state="translated">SSL 서버 개인 키를 포함하는 파일 이름을 지정합니다. 상대 경로는 데이터 디렉토리를 기준으로합니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;server.key&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4607c81653142efa771ba2f3019c56810db492d5" translate="yes" xml:space="preserve">
          <source>Specifies the number of TCP keepalive messages that can be lost before the server's connection to the client is considered dead. A value of 0 (the default) selects the operating system's default. This parameter is supported only on systems that support &lt;code&gt;TCP_KEEPCNT&lt;/code&gt; or an equivalent socket option; on other systems, it must be zero. In sessions connected via a Unix-domain socket, this parameter is ignored and always reads as zero.</source>
          <target state="translated">서버와 클라이언트의 연결이 끊어지기 전에 손실 될 수있는 TCP keepalive 메시지 수를 지정합니다. 값 0 (기본값)은 운영 체제의 기본값을 선택합니다. 이 매개 변수는 &lt;code&gt;TCP_KEEPCNT&lt;/code&gt; 또는 동등한 소켓 옵션 을 지원하는 시스템에서만 지원됩니다 . 다른 시스템에서는 0이어야합니다. Unix 도메인 소켓을 통해 연결된 세션에서이 매개 변수는 무시되며 항상 0으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="35e764d72ec6f00b0216fb1052be858d95250160" translate="yes" xml:space="preserve">
          <source>Specifies the number of inserted tuples needed to trigger a &lt;code&gt;VACUUM&lt;/code&gt; in any one table. The default is 1000 tuples. If -1 is specified, autovacuum will not trigger a &lt;code&gt;VACUUM&lt;/code&gt; operation on any tables based on the number of inserts. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">Specifies the number of inserted tuples needed to trigger a &lt;code&gt;VACUUM&lt;/code&gt; in any one table. The default is 1000 tuples. If -1 is specified, autovacuum will not trigger a &lt;code&gt;VACUUM&lt;/code&gt; operation on any tables based on the number of inserts. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</target>
        </trans-unit>
        <trans-unit id="48d5c63bb87e1c3bac4f154cb64fa004acf6a6db" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds between status packets sent back to the server. This allows for easier monitoring of the progress from server. A value of zero disables the periodic status updates completely, although an update will still be sent when requested by the server, to avoid timeout disconnect. The default value is 10 seconds.</source>
          <target state="translated">서버로 다시 전송되는 상태 패킷 사이의 시간 (초)을 지정합니다. 이를 통해 서버에서 진행 상황을 쉽게 모니터링 할 수 있습니다. 값이 0이면 시간 초과 연결 끊기를 피하기 위해 서버에서 요청시 업데이트가 계속 전송되지만 주기적 상태 업데이트가 완전히 비활성화됩니다. 기본값은 10 초입니다.</target>
        </trans-unit>
        <trans-unit id="27ee570194a712eb03b2f49c37e350c298990d63" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds between status packets sent back to the source server. Smaller values allow more accurate monitoring of backup progress from the server. A value of zero disables periodic status updates completely, although an update will still be sent when requested by the server, to avoid timeout-based disconnects. The default value is 10 seconds.</source>
          <target state="translated">Specifies the number of seconds between status packets sent back to the source server. Smaller values allow more accurate monitoring of backup progress from the server. A value of zero disables periodic status updates completely, although an update will still be sent when requested by the server, to avoid timeout-based disconnects. The default value is 10 seconds.</target>
        </trans-unit>
        <trans-unit id="ea542b3506a4692ae26cd5feb16ab14526275d28" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds for each test. The more time per test, the greater the test's accuracy, but the longer it takes to run. The default is 5 seconds, which allows the program to complete in under 2 minutes.</source>
          <target state="translated">각 테스트의 초 수를 지정합니다. 테스트 당 시간이 많을수록 테스트의 정확도는 높아지지만 실행 시간이 길어집니다. 기본값은 5 초이며 2 분 안에 프로그램을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cc03900b1929bc4bc3435d34770495f2f12cc60" translate="yes" xml:space="preserve">
          <source>Specifies the number of transactions by which &lt;code&gt;VACUUM&lt;/code&gt; and HOT updates will defer cleanup of dead row versions. The default is zero transactions, meaning that dead row versions can be removed as soon as possible, that is, as soon as they are no longer visible to any open transaction. You may wish to set this to a non-zero value on a primary server that is supporting hot standby servers, as described in &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;. This allows more time for queries on the standby to complete without incurring conflicts due to early cleanup of rows. However, since the value is measured in terms of number of write transactions occurring on the primary server, it is difficult to predict just how much additional grace time will be made available to standby queries. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 및 HOT 업데이트가 데드 행 버전 정리를 지연 시키는 트랜잭션 수를 지정합니다 . 기본값은 0 트랜잭션입니다. 즉, 사용 가능한 행 버전이 더 이상 열려있는 트랜잭션에 더 이상 표시되지 않는 한 가능한 빨리 죽은 행 버전을 제거 할 수 있습니다. &lt;a href=&quot;hot-standby&quot;&gt;26.5 절에&lt;/a&gt; 설명 된대로 상시 대기 서버를 지원하는 기본 서버에서이 값을 0이 아닌 값으로 설정할 수 있습니다 . 이를 통해 초기 행 정리로 인해 충돌이 발생하지 않고 대기에서 쿼리를 완료하는 데 더 많은 시간이 소요됩니다. 그러나이 값은 주 서버에서 발생하는 쓰기 트랜잭션 수로 측정되기 때문에 대기 쿼리에 사용할 수있는 추가 유예 시간을 예측하는 것은 어렵습니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a66859b61b3f3229e8a580cf2576546743106ff" translate="yes" xml:space="preserve">
          <source>Specifies the provider to use for locale services associated with this collation. Possible values are: &lt;code&gt;icu&lt;/code&gt;, &lt;code&gt;libc&lt;/code&gt;. &lt;code&gt;libc&lt;/code&gt; is the default. The available choices depend on the operating system and build options.</source>
          <target state="translated">이 데이터 정렬과 관련된 로캘 서비스에 사용할 공급자를 지정합니다. 가능한 값은 &lt;code&gt;icu&lt;/code&gt; , &lt;code&gt;libc&lt;/code&gt; 입니다. &lt;code&gt;libc&lt;/code&gt; 가 기본값입니다. 사용 가능한 선택 사항은 운영 체제 및 빌드 옵션에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="499c4377a213acbe2f50878dd26f848ea71f62d5" translate="yes" xml:space="preserve">
          <source>Specifies the quoting character to be used when a data value is quoted. The default is double-quote. This must be a single one-byte character. This option is allowed only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">데이터 값이 인용 될 때 사용될 인용 문자를 지정합니다. 기본값은 큰 따옴표입니다. 1 바이트 문자 여야합니다. 이 옵션은 &lt;code&gt;CSV&lt;/code&gt; 형식을 사용할 때만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb624ed7e1e60e95c350918cd5415ed8b5d2c9de" translate="yes" xml:space="preserve">
          <source>Specifies the record (line) separator to use in unaligned output format. The default is a newline character.</source>
          <target state="translated">정렬되지 않은 출력 형식으로 사용할 레코드 (행) 구분 기호를 지정합니다. 디폴트는 개행 문자입니다.</target>
        </trans-unit>
        <trans-unit id="2558e1aa0584d2c9b59b33c889639d3c2a8793ce" translate="yes" xml:space="preserve">
          <source>Specifies the shared memory implementation that the server should use for the main shared memory region that holds PostgreSQL's shared buffers and other shared data. Possible values are &lt;code&gt;mmap&lt;/code&gt; (for anonymous shared memory allocated using &lt;code&gt;mmap&lt;/code&gt;), &lt;code&gt;sysv&lt;/code&gt; (for System V shared memory allocated via &lt;code&gt;shmget&lt;/code&gt;) and &lt;code&gt;windows&lt;/code&gt; (for Windows shared memory). Not all values are supported on all platforms; the first supported option is the default for that platform. The use of the &lt;code&gt;sysv&lt;/code&gt; option, which is not the default on any platform, is generally discouraged because it typically requires non-default kernel settings to allow for large allocations (see &lt;a href=&quot;kernel-resources#SYSVIPC&quot;&gt;Section 18.4.1&lt;/a&gt;).</source>
          <target state="translated">서버가 PostgreSQL의 공유 버퍼 및 기타 공유 데이터를 보유하는 기본 공유 메모리 영역에 사용해야하는 공유 메모리 구현을 지정합니다. 가능한 값은 다음 &lt;code&gt;mmap&lt;/code&gt; (익명을 사용하여 할당 된 메모리 공유에 대한 &lt;code&gt;mmap&lt;/code&gt; ) &lt;code&gt;sysv&lt;/code&gt; (시스템 V를 통해 할당 된 메모리 공유를 위해 &lt;code&gt;shmget&lt;/code&gt; 과) &lt;code&gt;windows&lt;/code&gt; (Windows가 공유 메모리에 대한). 모든 플랫폼에서 모든 값이 지원되는 것은 아닙니다. 지원되는 첫 번째 옵션은 해당 플랫폼의 기본값입니다. 플랫폼에서 기본값이 아닌 &lt;code&gt;sysv&lt;/code&gt; 옵션 의 사용 은 일반적으로 큰 할당을 허용하기 위해 기본이 아닌 커널 설정이 필요하므로 권장하지 않습니다 ( &lt;a href=&quot;kernel-resources#SYSVIPC&quot;&gt;18.4.1 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ccd9f460ce8d5cb66ffec64aa427c1853d1b8854" translate="yes" xml:space="preserve">
          <source>Specifies the shutdown mode. &lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;smart&lt;/code&gt;, &lt;code&gt;fast&lt;/code&gt;, or &lt;code&gt;immediate&lt;/code&gt;, or the first letter of one of these three. If this option is omitted, &lt;code&gt;fast&lt;/code&gt; is the default.</source>
          <target state="translated">종료 모드를 지정합니다. &lt;code&gt;mode&lt;/code&gt; 할 수 있습니다 &lt;code&gt;smart&lt;/code&gt; , &lt;code&gt;fast&lt;/code&gt; , 또는 &lt;code&gt;immediate&lt;/code&gt; , 또는이 세 가지 중 하나의 첫 글자. 이 옵션을 생략하면 &lt;code&gt;fast&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="fab1a9b05630ddb8e82054863572cf573012df3a" translate="yes" xml:space="preserve">
          <source>Specifies the string that represents a null value. The default is &lt;code&gt;\N&lt;/code&gt; (backslash-N) in text format, and an unquoted empty string in &lt;code&gt;CSV&lt;/code&gt; format. You might prefer an empty string even in text format for cases where you don't want to distinguish nulls from empty strings. This option is not allowed when using &lt;code&gt;binary&lt;/code&gt; format.</source>
          <target state="translated">널값을 나타내는 문자열을 지정합니다. 텍스트 형식 의 기본값은 &lt;code&gt;\N&lt;/code&gt; (백 슬래시 -N)이며 따옴표없는 빈 문자열은 &lt;code&gt;CSV&lt;/code&gt; 형식입니다. 빈 문자열과 null을 구분하지 않으려는 경우 텍스트 형식에서도 빈 문자열을 선호 할 수 있습니다. &lt;code&gt;binary&lt;/code&gt; 형식을 사용할 때는이 옵션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="befe3a3ac118d97b0cd868cce1352d119ad055f4" translate="yes" xml:space="preserve">
          <source>Specifies the target of checkpoint completion, as a fraction of total time between checkpoints. The default is 0.5. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">검사 점 완료 대상을 검사 점 사이의 총 시간의 일부로 지정합니다. 기본값은 0.5입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71c8d5b87a0e5a99f8d4571a644763394fd77006" translate="yes" xml:space="preserve">
          <source>Specifies the template database from which to build this database. (This name is processed as a double-quoted identifier.)</source>
          <target state="translated">이 데이터베이스를 구축 할 템플릿 데이터베이스를 지정합니다. (이 이름은 큰 따옴표로 식별됩니다.)</target>
        </trans-unit>
        <trans-unit id="85ecc3d1311105aaeb7eeb12a6761d2e6623ba45" translate="yes" xml:space="preserve">
          <source>Specifies the test duration, in seconds. Longer durations give slightly better accuracy, and are more likely to discover problems with the system clock moving backwards. The default test duration is 3 seconds.</source>
          <target state="translated">테스트 기간을 초 단위로 지정합니다. 지속 시간이 길수록 정확도가 약간 향상되고 시스템 시계가 뒤로 이동하는 문제를 발견 할 가능성이 높습니다. 기본 테스트 기간은 3 초입니다.</target>
        </trans-unit>
        <trans-unit id="654ce7fd440b9ced99f16585e2dca9d032264a5c" translate="yes" xml:space="preserve">
          <source>Specifies the user name to connect as.</source>
          <target state="translated">Specifies the user name to connect as.</target>
        </trans-unit>
        <trans-unit id="d34c628f85bceb534d90fd071ae6e05e316684fb" translate="yes" xml:space="preserve">
          <source>Specifies the version number of the frontend/backend protocol to be used for a particular session. This option is for internal use only.</source>
          <target state="translated">특정 세션에 사용될 프론트 엔드 / 백엔드 프로토콜의 버전 번호를 지정합니다. 이 옵션은 내부 전용입니다.</target>
        </trans-unit>
        <trans-unit id="7aa5a4652a46d1f3c27eaba7af4bd3633fed02d9" translate="yes" xml:space="preserve">
          <source>Specifies the version string to store with the collation. Normally, this should be omitted, which will cause the version to be computed from the actual version of the collation as provided by the operating system. This option is intended to be used by &lt;code&gt;pg_upgrade&lt;/code&gt; for copying the version from an existing installation.</source>
          <target state="translated">데이터 정렬과 함께 저장할 버전 문자열을 지정합니다. 일반적으로 운영 체제에서 제공 한 데이터 정렬의 실제 버전에서 버전이 계산되도록하는 경우 생략해야합니다. 이 옵션은 &lt;code&gt;pg_upgrade&lt;/code&gt; 가 기존 설치에서 버전을 복사하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddaa8dc2a7d08117a4f2b4c3d78cac04e661f41d" translate="yes" xml:space="preserve">
          <source>Specifies verbose mode.</source>
          <target state="translated">상세 모드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c46d2e1a51a71406401ec9ff38daaf6fd4a82a32" translate="yes" xml:space="preserve">
          <source>Specifies verbose mode. This will cause pg_dump to output detailed object comments and start/stop times to the dump file, and progress messages to standard error.</source>
          <target state="translated">상세 모드를 지정합니다. 이로 인해 pg_dump는 자세한 객체 주석과 시작 / 중지 시간을 덤프 파일로 출력하고 메시지를 표준 오류로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="ebd9c3e91abd466e5cb76c7e539eb720eb8bab79" translate="yes" xml:space="preserve">
          <source>Specifies verbose mode. This will cause pg_dumpall to output start/stop times to the dump file, and progress messages to standard error. It will also enable verbose output in pg_dump.</source>
          <target state="translated">상세 모드를 지정합니다. 이로 인해 pg_dumpall이 시작 / 중지 시간을 덤프 파일로 출력하고 메시지를 표준 오류로 진행합니다. 또한 pg_dump에서 상세 출력을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2e1b16c0cfb347ed5e5085abe8f7b40f00f3b213" translate="yes" xml:space="preserve">
          <source>Specifies what action the server should take once the recovery target is reached. The default is &lt;code&gt;pause&lt;/code&gt;, which means recovery will be paused. &lt;code&gt;promote&lt;/code&gt; means the recovery process will finish and the server will start to accept connections. Finally &lt;code&gt;shutdown&lt;/code&gt; will stop the server after reaching the recovery target.</source>
          <target state="translated">복구 대상에 도달하면 서버가 수행 할 작업을 지정합니다. 기본값은 &lt;code&gt;pause&lt;/code&gt; 입니다. 즉, 복구가 일시 중지됩니다. &lt;code&gt;promote&lt;/code&gt; 은 복구 프로세스가 완료되고 서버가 연결을 수락하기 시작 함을 의미합니다. 마지막으로 &lt;code&gt;shutdown&lt;/code&gt; 하면 복구 대상에 도달 한 후 서버가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="a78ff10e6c3eb26498d1ae314b645439f6179efb" translate="yes" xml:space="preserve">
          <source>Specifies where &lt;code&gt;initdb&lt;/code&gt; should find its input files to initialize the database cluster. This is normally not necessary. You will be told if you need to specify their location explicitly.</source>
          <target state="translated">데이터베이스 클러스터를 초기화하기 위해 &lt;code&gt;initdb&lt;/code&gt; 가 입력 파일을 찾아야하는 위치를 지정 합니다. 이것은 일반적으로 필요하지 않습니다. 위치를 명시 적으로 지정해야하는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="55702d9d058993c167739847fc03d714335ae9bd" translate="yes" xml:space="preserve">
          <source>Specifies whether or not a hot standby will send feedback to the primary or upstream standby about queries currently executing on the standby. This parameter can be used to eliminate query cancels caused by cleanup records, but can cause database bloat on the primary for some workloads. Feedback messages will not be sent more frequently than once per &lt;code&gt;wal_receiver_status_interval&lt;/code&gt;. The default value is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">핫 대기가 현재 대기에서 실행중인 쿼리에 대한 피드백을 기본 또는 업스트림 대기로 보낼지 여부를 지정합니다. 이 매개 변수는 정리 레코드로 인한 쿼리 취소를 제거하는 데 사용할 수 있지만 일부 워크로드의 경우 기본 데이터베이스에서 데이터베이스 팽창이 발생할 수 있습니다. 피드백 메시지는 &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; 당 두 번 이상 전송되지 않습니다 . 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf42dfb5427d85a48aa7ca14c68254a8aa74d01e" translate="yes" xml:space="preserve">
          <source>Specifies whether or not you can connect and run queries during recovery, as described in &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;. The default value is &lt;code&gt;on&lt;/code&gt;. This parameter can only be set at server start. It only has effect during archive recovery or in standby mode.</source>
          <target state="translated">&lt;a href=&quot;hot-standby&quot;&gt;26.5 절에&lt;/a&gt; 설명 된대로 복구 중에 쿼리를 연결하고 실행할 수 있는지 여부를 지정합니다 . 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. 아카이브 복구 중 또는 대기 모드에서만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c8c1d8143602dc11e9fa60d73a3ca68243f890ed" translate="yes" xml:space="preserve">
          <source>Specifies whether the &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; should connect to the publisher at all. Setting this to &lt;code&gt;false&lt;/code&gt; will change default values of &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;create_slot&lt;/code&gt; and &lt;code&gt;copy_data&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 을 게시자에게 전혀 연결 해야하는지 여부를 지정합니다 . 이 설정 &lt;code&gt;false&lt;/code&gt; 디폴트 값으로 변경됩니다 &lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;create_slot&lt;/code&gt; 및 &lt;code&gt;copy_data&lt;/code&gt; 을 에 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84687778000177e86e0cfae2870b7c397621b704" translate="yes" xml:space="preserve">
          <source>Specifies whether the WAL receiver process should create a temporary replication slot on the remote instance when no permanent replication slot to use has been configured (using &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt;). The default is off. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. If this parameter is changed while the WAL receiver process is running, that process is signaled to shut down and expected to restart with the new setting.</source>
          <target state="translated">Specifies whether the WAL receiver process should create a temporary replication slot on the remote instance when no permanent replication slot to use has been configured (using &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt;). The default is off. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. If this parameter is changed while the WAL receiver process is running, that process is signaled to shut down and expected to restart with the new setting.</target>
        </trans-unit>
        <trans-unit id="3f3fe61335a36998cd2b4e2be2d49820174726c7" translate="yes" xml:space="preserve">
          <source>Specifies whether the collation should use deterministic comparisons. The default is true. A deterministic comparison considers strings that are not byte-wise equal to be unequal even if they are considered logically equal by the comparison. PostgreSQL breaks ties using a byte-wise comparison. Comparison that is not deterministic can make the collation be, say, case- or accent-insensitive. For that, you need to choose an appropriate &lt;code&gt;LC_COLLATE&lt;/code&gt; setting &lt;em&gt;and&lt;/em&gt; set the collation to not deterministic here.</source>
          <target state="translated">데이터 정렬이 결정적 비교를 사용해야하는지 여부를 지정합니다. 기본값은 true입니다. 결정 론적 비교에서는 비교에 의해 논리적으로 동일한 것으로 간주 되더라도 바이트 단위가 아닌 문자열이 동일하지 않은 것으로 간주합니다. PostgreSQL은 바이트 단위 비교를 사용하여 연결을 끊습니다. 결정적이지 않은 비교는 데이터 정렬을 대 / 소문자를 구분하지 않도록 할 수 있습니다. 이를 위해, 당신은 적절한 선택해야 &lt;code&gt;LC_COLLATE&lt;/code&gt; 의 설정을 &lt;em&gt;하고&lt;/em&gt; 여기에 결정적하지 않도록 데이터 정렬을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="08409a9f4fcfade75db2fbc62c996ba7ea8ee98a" translate="yes" xml:space="preserve">
          <source>Specifies whether the command should create the replication slot on the publisher. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">명령이 게시자에서 복제 슬롯을 작성해야하는지 여부를 지정합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="561cf57ae696bf0926965afe12bdcd1ab43f09ee" translate="yes" xml:space="preserve">
          <source>Specifies whether the data has a header line, the same as &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;HEADER&lt;/code&gt; option.</source>
          <target state="translated">지정 데이터는 헤더 행과 동일한이 있는지 여부를 &lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;HEADER&lt;/code&gt; 의 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6d89f58ceb7dd86d8f940fbdda605d4fc3829701" translate="yes" xml:space="preserve">
          <source>Specifies whether the existing data in the publications that are being subscribed to should be copied once the replication starts. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">구독중인 게시의 기존 데이터를 복제가 시작되면 복사해야하는지 여부를 지정합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01671c86b8712d3c0948e12ba2326166698483be" translate="yes" xml:space="preserve">
          <source>Specifies whether the existing data in the publications that are being subscribed to should be copied once the replication starts. The default is &lt;code&gt;true&lt;/code&gt;. (Previously subscribed tables are not copied.)</source>
          <target state="translated">Specifies whether the existing data in the publications that are being subscribed to should be copied once the replication starts. The default is &lt;code&gt;true&lt;/code&gt; . (Previously subscribed tables are not copied.)</target>
        </trans-unit>
        <trans-unit id="81c51bc60a5635b9d7f0ed683614af3991e0177b" translate="yes" xml:space="preserve">
          <source>Specifies whether the selected option should be turned on or off. You can write &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;ON&lt;/code&gt;, or &lt;code&gt;1&lt;/code&gt; to enable the option, and &lt;code&gt;FALSE&lt;/code&gt;, &lt;code&gt;OFF&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; to disable it. The &lt;code&gt;boolean&lt;/code&gt; value can also be omitted, in which case &lt;code&gt;TRUE&lt;/code&gt; is assumed.</source>
          <target state="translated">선택한 옵션을 켜거나 끌지 여부를 지정합니다. 옵션을 활성화하려면 &lt;code&gt;TRUE&lt;/code&gt; , &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 을 , 비활성화하려면 &lt;code&gt;FALSE&lt;/code&gt; , &lt;code&gt;OFF&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 을 쓸 수 있습니다 . &lt;code&gt;boolean&lt;/code&gt; 값은 생략 될 수 있는데, &lt;code&gt;TRUE&lt;/code&gt; 는 것으로한다.</target>
        </trans-unit>
        <trans-unit id="6568125e106aa49b2591a59804669013e3cf6ee5" translate="yes" xml:space="preserve">
          <source>Specifies whether the subscription should be actively replicating, or whether it should be just setup but not started yet. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">구독을 적극적으로 복제해야하는지 또는 아직 설정했지만 아직 시작하지 않아야하는지 여부를 지정합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0bfd7f0006bcdef7ba712843d62f6cc1add8b74d" translate="yes" xml:space="preserve">
          <source>Specifies whether to stop just after the specified recovery target (&lt;code&gt;on&lt;/code&gt;), or just before the recovery target (&lt;code&gt;off&lt;/code&gt;). Applies when &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-LSN&quot;&gt;recovery_target_lsn&lt;/a&gt;, &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIME&quot;&gt;recovery_target_time&lt;/a&gt;, or &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-XID&quot;&gt;recovery_target_xid&lt;/a&gt; is specified. This setting controls whether transactions having exactly the target WAL location (LSN), commit time, or transaction ID, respectively, will be included in the recovery. Default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">지정된 복구 대상 직후 ( &lt;code&gt;on&lt;/code&gt; ) 또는 복구 대상 바로 앞 ( &lt;code&gt;off&lt;/code&gt; ) 을 중지할지 여부를 지정합니다 . &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-LSN&quot;&gt;recovery_target_lsn&lt;/a&gt; , &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIME&quot;&gt;recovery_target_time&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-XID&quot;&gt;recovery_target_xid&lt;/a&gt; 가 지정된 경우에 적용됩니다 . 이 설정은 정확히 목표 WAL 위치 (LSN), 커밋 시간 또는 트랜잭션 ID가 각각있는 트랜잭션이 복구에 포함되는지 여부를 제어합니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20226283d4365e33dc730c0bd2fac837b89e9d64" translate="yes" xml:space="preserve">
          <source>Specifies whether to use color in diagnostic messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">Specifies whether to use color in diagnostic messages. Possible values are &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f40b062fb2ef6e6073ff265399161c58d4f3561" translate="yes" xml:space="preserve">
          <source>Specifies whether to use color in diagnostics messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">진단 메시지에 색상을 사용할지 여부를 지정합니다. 가능한 값은 없습니다 &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaf40d41e0c4e647942e03bce313b74c79cba167" translate="yes" xml:space="preserve">
          <source>Specifies whether to use the server's SSL cipher preferences, rather than the client's. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 아닌 서버의 SSL 암호 환경 설정을 사용할지 여부를 지정합니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf5277a15623718394738fd9c86087faaccdd4d4" translate="yes" xml:space="preserve">
          <source>Specifies whether transaction commit will wait for WAL records to be written to disk before the command returns a &amp;ldquo;success&amp;rdquo; indication to the client. Valid values are &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;remote_apply&lt;/code&gt;, &lt;code&gt;remote_write&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, and &lt;code&gt;off&lt;/code&gt;. The default, and safe, setting is &lt;code&gt;on&lt;/code&gt;. When &lt;code&gt;off&lt;/code&gt;, there can be a delay between when success is reported to the client and when the transaction is really guaranteed to be safe against a server crash. (The maximum delay is three times &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt;.) Unlike &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt;, setting this parameter to &lt;code&gt;off&lt;/code&gt; does not create any risk of database inconsistency: an operating system or database crash might result in some recent allegedly-committed transactions being lost, but the database state will be just the same as if those transactions had been aborted cleanly. So, turning &lt;code&gt;synchronous_commit&lt;/code&gt; off can be a useful alternative when performance is more important than exact certainty about the durability of a transaction. For more discussion see &lt;a href=&quot;wal-async-commit&quot;&gt;Section 29.3&lt;/a&gt;.</source>
          <target state="translated">명령이 클라이언트에 &quot;성공&quot;표시를 반환하기 전에 트랜잭션 커밋이 WAL 레코드가 디스크에 기록 될 때까지 대기할지 여부를 지정합니다. 유효한 값은 &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;remote_apply&lt;/code&gt; , &lt;code&gt;remote_write&lt;/code&gt; , &lt;code&gt;local&lt;/code&gt; 및 &lt;code&gt;off&lt;/code&gt; 입니다. 기본적이고 안전한 설정은 &lt;code&gt;on&lt;/code&gt; 입니다. 때 &lt;code&gt;off&lt;/code&gt; , 성공은 클라이언트에보고 될 때 트랜잭션이 정말 서버 충돌에 대한 안전이 보장 될 때 사이에 지연이있을 수 있습니다. 최대 지연 시간은 &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay의&lt;/a&gt; 3 배 입니다 . &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; 와 달리이 매개 변수를 &lt;code&gt;off&lt;/code&gt; 로 설정하십시오.데이터베이스 불일치의 위험이 없습니다. 운영 체제 또는 데이터베이스 충돌로 인해 최근에 커밋 된 것으로 추정되는 일부 트랜잭션이 손실 될 수 있지만 데이터베이스 상태는 해당 트랜잭션이 완전히 중단 된 것과 같습니다. 따라서 &lt;code&gt;synchronous_commit&lt;/code&gt; 을 끄는 것이 트랜잭션의 내구성에 대한 정확한 확실성보다 성능이 더 중요한 경우 유용한 대안이 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;wal-async-commit&quot;&gt;섹션 29.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="116f31279a5160606e40129e9839a559648d4433" translate="yes" xml:space="preserve">
          <source>Specifies which conflicts &lt;code&gt;ON CONFLICT&lt;/code&gt; takes the alternative action on by choosing &lt;em&gt;arbiter indexes&lt;/em&gt;. Either performs &lt;em&gt;unique index inference&lt;/em&gt;, or names a constraint explicitly. For &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt;, it is optional to specify a &lt;em&gt;&lt;code&gt;conflict_target&lt;/code&gt;&lt;/em&gt;; when omitted, conflicts with all usable constraints (and unique indexes) are handled. For &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;, a &lt;em&gt;&lt;code&gt;conflict_target&lt;/code&gt;&lt;/em&gt;&lt;em&gt;must&lt;/em&gt; be provided.</source>
          <target state="translated">&lt;em&gt;중재자&lt;/em&gt; 충돌 을 선택하여 &lt;code&gt;ON CONFLICT&lt;/code&gt; 가 충돌을 대체 할 조치를 지정 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt;고유 인덱스 추론을&lt;/em&gt; 수행 하거나 제약 조건의 이름을 명시 적으로 지정합니다. 들어 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; , 지정하는 옵션입니다 &lt;em&gt; &lt;code&gt;conflict_target&lt;/code&gt; 을&lt;/em&gt; ; 생략하면 사용 가능한 모든 제한 조건 (및 고유 색인)과의 충돌이 처리됩니다. 들어 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 하는 &lt;em&gt; &lt;code&gt;conflict_target&lt;/code&gt; 이&lt;/em&gt;&lt;em&gt; 있어야&lt;/em&gt; 제공 할 수.</target>
        </trans-unit>
        <trans-unit id="04fd7a99f103a7674fd3650283ad5df86a38c1d7" translate="yes" xml:space="preserve">
          <source>Specifies which database name(s) this record matches. The value &lt;code&gt;all&lt;/code&gt; specifies that it matches all databases. The value &lt;code&gt;sameuser&lt;/code&gt; specifies that the record matches if the requested database has the same name as the requested user. The value &lt;code&gt;samerole&lt;/code&gt; specifies that the requested user must be a member of the role with the same name as the requested database. (&lt;code&gt;samegroup&lt;/code&gt; is an obsolete but still accepted spelling of &lt;code&gt;samerole&lt;/code&gt;.) Superusers are not considered to be members of a role for the purposes of &lt;code&gt;samerole&lt;/code&gt; unless they are explicitly members of the role, directly or indirectly, and not just by virtue of being a superuser. The value &lt;code&gt;replication&lt;/code&gt; specifies that the record matches if a physical replication connection is requested (note that replication connections do not specify any particular database). Otherwise, this is the name of a specific PostgreSQL database. Multiple database names can be supplied by separating them with commas. A separate file containing database names can be specified by preceding the file name with &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">이 레코드와 일치하는 데이터베이스 이름을 지정합니다. &lt;code&gt;all&lt;/code&gt; 값 은 모든 데이터베이스와 일치하도록 지정합니다. &lt;code&gt;sameuser&lt;/code&gt; 값 은 요청 된 데이터베이스의 이름이 요청 된 사용자와 동일한 경우 레코드가 일치하도록 지정합니다. &lt;code&gt;samerole&lt;/code&gt; 값 은 요청 된 사용자가 요청 된 데이터베이스와 이름이 같은 역할의 구성원이어야 함을 지정합니다. ( &lt;code&gt;samegroup&lt;/code&gt; 은 의 오래된하지만 여전히 가능 철자 &lt;code&gt;samerole&lt;/code&gt; .) 수퍼 유저는 목적에 대한 역할의 구성원으로 간주되지 않습니다 &lt;code&gt;samerole&lt;/code&gt; 단지 수퍼 유저 인 덕분에 그들이 직접 또는 간접적으로 명시 적 역할의 멤버가 아니라면, 그리고 . 가치 &lt;code&gt;replication&lt;/code&gt; 실제 복제 연결이 요청 된 경우 레코드가 일치하도록 지정합니다 (복제 연결은 특정 데이터베이스를 지정하지 않음에 유의하십시오). 그렇지 않으면 특정 PostgreSQL 데이터베이스의 이름입니다. 쉼표로 구분하여 여러 데이터베이스 이름을 제공 할 수 있습니다. 파일 이름 앞에 &lt;code&gt;@&lt;/code&gt; 를 붙여 데이터베이스 이름이 포함 된 별도의 파일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d636bc68af3f129d834c4f7c23a7d5cb374e4f3e" translate="yes" xml:space="preserve">
          <source>Specifies which database user name(s) this record matches. The value &lt;code&gt;all&lt;/code&gt; specifies that it matches all users. Otherwise, this is either the name of a specific database user, or a group name preceded by &lt;code&gt;+&lt;/code&gt;. (Recall that there is no real distinction between users and groups in PostgreSQL; a &lt;code&gt;+&lt;/code&gt; mark really means &amp;ldquo;match any of the roles that are directly or indirectly members of this role&amp;rdquo;, while a name without a &lt;code&gt;+&lt;/code&gt; mark matches only that specific role.) For this purpose, a superuser is only considered to be a member of a role if they are explicitly a member of the role, directly or indirectly, and not just by virtue of being a superuser. Multiple user names can be supplied by separating them with commas. A separate file containing user names can be specified by preceding the file name with &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">이 레코드가 일치하는 데이터베이스 사용자 이름을 지정합니다. &lt;code&gt;all&lt;/code&gt; 값 은 모든 사용자와 일치하도록 지정합니다. 그렇지 않으면, 이것은 특정 데이터베이스 사용자의 이름이거나 &lt;code&gt;+&lt;/code&gt; 가 앞에 오는 그룹 이름 입니다. (PostgreSQL에서 사용자와 그룹 간에는 실질적인 차이가 없습니다. &lt;code&gt;+&lt;/code&gt; 표시는 실제로 &quot;직접 또는 간접적으로이 역할의 구성원 인 역할과 일치 함&quot;을 의미하며 &lt;code&gt;+&lt;/code&gt; 가 없는 이름은마크는 해당 특정 역할과 만 일치합니다.)이 목적을 위해 수퍼 유저는 단순히 수퍼 유저가 아니라 직간접 적으로 역할의 구성원 인 경우에만 역할의 구성원으로 간주됩니다. 쉼표로 구분하여 여러 사용자 이름을 제공 할 수 있습니다. 파일 이름 앞에 &lt;code&gt;@&lt;/code&gt; 를 붙여서 사용자 이름이 포함 된 별도의 파일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5e088932112a3aa70b2edd9c7b6f330cee6a988" translate="yes" xml:space="preserve">
          <source>Specify an additional include path, used to find files included via &lt;code&gt;EXEC SQL INCLUDE&lt;/code&gt;. Defaults are &lt;code&gt;.&lt;/code&gt; (current directory), &lt;code&gt;/usr/local/include&lt;/code&gt;, the PostgreSQL include directory which is defined at compile time (default: &lt;code&gt;/usr/local/pgsql/include&lt;/code&gt;), and &lt;code&gt;/usr/include&lt;/code&gt;, in that order.</source>
          <target state="translated">&lt;code&gt;EXEC SQL INCLUDE&lt;/code&gt; 를 통해 포함 된 파일을 찾는 데 사용되는 추가 포함 경로를 지정하십시오 . 기본값은 &lt;code&gt;.&lt;/code&gt; (현재 디렉토리), &lt;code&gt;/usr/local/include&lt;/code&gt; , PostgreSQL 포함 디렉토리는 컴파일 타임에 정의 된 디렉토리 (기본값 : &lt;code&gt;/usr/local/pgsql/include&lt;/code&gt; ) 및 &lt;code&gt;/usr/include&lt;/code&gt; 순서로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2297c287dd5dcea97a177d8a770b0b08d36ebcce" translate="yes" xml:space="preserve">
          <source>Specify format of the archive. It is not necessary to specify the format, since pg_restore will determine the format automatically. If specified, it can be one of the following:</source>
          <target state="translated">아카이브 형식을 지정하십시오. pg_restore가 형식을 자동으로 결정하므로 형식을 지정할 필요가 없습니다. 지정된 경우 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fef48f59b1bd0e9cd6b0f9f8b9881d4863e9299a" translate="yes" xml:space="preserve">
          <source>Specify output file for generated script, or for the listing when used with &lt;code&gt;-l&lt;/code&gt;. Use &lt;code&gt;-&lt;/code&gt; for stdout.</source>
          <target state="translated">생성 된 스크립트 또는 &lt;code&gt;-l&lt;/code&gt; 과 함께 사용할 경우 목록에 대한 출력 파일을 지정하십시오 . stdout에 &lt;code&gt;-&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c162041167cbfc0a656da0c5232a46cbe070711b" translate="yes" xml:space="preserve">
          <source>Specify that the policy is to be created as a permissive policy. All permissive policies which are applicable to a given query will be combined together using the Boolean &amp;ldquo;OR&amp;rdquo; operator. By creating permissive policies, administrators can add to the set of records which can be accessed. Policies are permissive by default.</source>
          <target state="translated">정책이 허용 정책으로 작성되도록 지정하십시오. 주어진 쿼리에 적용 가능한 모든 허용 정책은 부울 &quot;OR&quot;연산자를 사용하여 함께 결합됩니다. 허용 정책을 작성하여 관리자는 액세스 할 수있는 레코드 세트에 추가 할 수 있습니다. 정책은 기본적으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bce8ed255627219b10fa9d298b0f43fea955f861" translate="yes" xml:space="preserve">
          <source>Specify that the policy is to be created as a restrictive policy. All restrictive policies which are applicable to a given query will be combined together using the Boolean &amp;ldquo;AND&amp;rdquo; operator. By creating restrictive policies, administrators can reduce the set of records which can be accessed as all restrictive policies must be passed for each record.</source>
          <target state="translated">정책이 제한 정책으로 작성되도록 지정하십시오. 주어진 쿼리에 적용 가능한 모든 제한 정책은 부울&amp;ldquo;AND&amp;rdquo;연산자를 사용하여 함께 결합됩니다. 관리자는 제한 정책을 작성하여 모든 레코드에 대해 모든 제한 정책을 전달해야하므로 액세스 할 수있는 레코드 세트를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddffed63bf5206c3c523be1c15def02715e9a8dc" translate="yes" xml:space="preserve">
          <source>Specify the compression level to use. Zero means no compression. For the custom archive format, this specifies compression of individual table-data segments, and the default is to compress at a moderate level. For plain text output, setting a nonzero compression level causes the entire output file to be compressed, as though it had been fed through gzip; but the default is not to compress. The tar archive format currently does not support compression at all.</source>
          <target state="translated">사용할 압축 수준을 지정하십시오. 0은 압축이 없음을 의미합니다. 사용자 정의 아카이브 형식의 경우 개별 테이블 데이터 세그먼트의 압축을 지정하며 기본값은 보통 수준으로 압축하는 것입니다. 일반 텍스트 출력의 경우 0이 아닌 압축 수준을 설정하면 전체 출력 파일이 gzip을 통해 공급 된 것처럼 압축됩니다. 그러나 기본값은 압축하지 않는 것입니다. tar 아카이브 형식은 현재 압축을 전혀 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="675e9bf1dd133c46baed26e08336e77714552600" translate="yes" xml:space="preserve">
          <source>Specify the maximum size of WAL files that &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;replication slots&lt;/a&gt; are allowed to retain in the &lt;code&gt;pg_wal&lt;/code&gt; directory at checkpoint time. If &lt;code&gt;max_slot_wal_keep_size&lt;/code&gt; is -1 (the default), replication slots may retain an unlimited amount of WAL files. Otherwise, if restart_lsn of a replication slot falls behind the current LSN by more than the given size, the standby using the slot may no longer be able to continue replication due to removal of required WAL files. You can see the WAL availability of replication slots in &lt;a href=&quot;view-pg-replication-slots&quot;&gt;pg_replication_slots&lt;/a&gt;.</source>
          <target state="translated">Specify the maximum size of WAL files that &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;replication slots&lt;/a&gt; are allowed to retain in the &lt;code&gt;pg_wal&lt;/code&gt; directory at checkpoint time. If &lt;code&gt;max_slot_wal_keep_size&lt;/code&gt; is -1 (the default), replication slots may retain an unlimited amount of WAL files. Otherwise, if restart_lsn of a replication slot falls behind the current LSN by more than the given size, the standby using the slot may no longer be able to continue replication due to removal of required WAL files. You can see the WAL availability of replication slots in &lt;a href=&quot;view-pg-replication-slots&quot;&gt;pg_replication_slots&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d08aa11ed8e2e056c96c29df6ee8f99b3f6c16b9" translate="yes" xml:space="preserve">
          <source>Specify the output format, which can be TEXT, XML, JSON, or YAML. Non-text output contains the same information as the text output format, but is easier for programs to parse. This parameter defaults to &lt;code&gt;TEXT&lt;/code&gt;.</source>
          <target state="translated">TEXT, XML, JSON 또는 YAML 일 수있는 출력 형식을 지정하십시오. 비 텍스트 출력에는 텍스트 출력 형식과 동일한 정보가 포함되지만 프로그램의 구문 분석이 더 쉽습니다. 이 매개 변수의 기본값은 &lt;code&gt;TEXT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbc854630b8965e66a39868a3ff997521d2f1933" translate="yes" xml:space="preserve">
          <source>Specify the parallel degree of &lt;em&gt;parallel vacuum&lt;/em&gt;. This allows the vacuum to leverage multiple CPUs to process indexes. See &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">Specify the parallel degree of &lt;em&gt;parallel vacuum&lt;/em&gt;. This allows the vacuum to leverage multiple CPUs to process indexes. See &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="97d5c6c81e2f5df1a05fc06ba5ebbc33efa9aae4" translate="yes" xml:space="preserve">
          <source>Specify the superuser user name to use when disabling triggers. This is relevant only if &lt;code&gt;--disable-triggers&lt;/code&gt; is used.</source>
          <target state="translated">트리거를 비활성화 할 때 사용할 수퍼 유저 사용자 이름을 지정하십시오. &lt;code&gt;--disable-triggers&lt;/code&gt; 를 사용하는 경우에만 해당 됩니다.</target>
        </trans-unit>
        <trans-unit id="5d99186f621c6855e4371f4922a42dcd48ef5a91" translate="yes" xml:space="preserve">
          <source>Specify the superuser user name to use when disabling triggers. This is relevant only if &lt;code&gt;--disable-triggers&lt;/code&gt; is used. (Usually, it's better to leave this out, and instead start the resulting script as superuser.)</source>
          <target state="translated">트리거를 비활성화 할 때 사용할 수퍼 유저 사용자 이름을 지정하십시오. &lt;code&gt;--disable-triggers&lt;/code&gt; 를 사용하는 경우에만 해당 됩니다. (보통 이것을 제외하고 결과 스크립트를 수퍼 유저로 시작하는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="d0a53c7974b664105ca5bb7d1f6f0d025135a5db" translate="yes" xml:space="preserve">
          <source>Specifying a savepoint name that has not been established is an error.</source>
          <target state="translated">설정되지 않은 저장 점 이름을 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8496f8219d6a05c0f6e67ab945bd25553a6cda0c" translate="yes" xml:space="preserve">
          <source>Specifying a savepoint name that was not previously defined is an error.</source>
          <target state="translated">이전에 정의되지 않은 저장 점 이름을 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7b583239edeab0e82a701a61e318795f92d51e7" translate="yes" xml:space="preserve">
          <source>Specifying an empty string will also set the password to null, but that was not the case before PostgreSQL version 10. In earlier versions, an empty string could be used, or not, depending on the authentication method and the exact version, and libpq would refuse to use it in any case. To avoid the ambiguity, specifying an empty string should be avoided.</source>
          <target state="translated">빈 문자열을 지정하면 암호도 null로 설정되지만 PostgreSQL 버전 10 이전에는 그렇지 않았습니다. 이전 버전에서는 인증 방법과 정확한 버전에 따라 빈 문자열을 사용하거나 사용하지 않을 수 있으며 libpq는 어떤 경우에도 사용을 거부하십시오. 모호성을 피하려면 빈 문자열을 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="502446c7f283be604cd89d269395d5b824c09988" translate="yes" xml:space="preserve">
          <source>Specifying an interval of &lt;code&gt;0&lt;/code&gt; disables issuing &lt;code&gt;fsync()&lt;/code&gt; calls altogether, while still reporting progress to the server. In this case, data could be lost in the event of a crash.</source>
          <target state="translated">간격을 &lt;code&gt;0&lt;/code&gt; 으로 지정하면 서버에 진행 상황을 계속보고하면서 &lt;code&gt;fsync()&lt;/code&gt; 호출을 모두 비활성화 할 수 있습니다. 이 경우 충돌시 데이터가 유실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ee68781384189181db8f50fcee9523287e35dd" translate="yes" xml:space="preserve">
          <source>Specifying any of &lt;code&gt;dbname&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter.</source>
          <target state="translated">Specifying any of &lt;code&gt;dbname&lt;/code&gt; , &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter.</target>
        </trans-unit>
        <trans-unit id="072eeb2988a12e4edda0f5a01b575fcf14b7ad05" translate="yes" xml:space="preserve">
          <source>Specifying that another table's column &lt;code&gt;REFERENCES cities(name)&lt;/code&gt; would allow the other table to contain city names, but not capital names. There is no good workaround for this case.</source>
          <target state="translated">다른 테이블의 열 &lt;code&gt;REFERENCES cities(name)&lt;/code&gt; 지정하면 다른 테이블에 도시 이름은 포함되지만 대문자 이름은 포함 할 수 없습니다. 이 경우에는 좋은 해결 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e83a7b4429453b711ef8109e95073284035eeaf8" translate="yes" xml:space="preserve">
          <source>Split &lt;em&gt;&lt;code&gt;qualified_identifier&lt;/code&gt;&lt;/em&gt; into an array of identifiers, removing any quoting of individual identifiers. By default, extra characters after the last identifier are considered an error; but if the second parameter is &lt;code&gt;false&lt;/code&gt;, then such extra characters are ignored. (This behavior is useful for parsing names for objects like functions.) Note that this function does not truncate over-length identifiers. If you want truncation you can cast the result to &lt;code&gt;name[]&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;qualified_identifier&lt;/code&gt; &lt;/em&gt; 를 식별자 배열로 분할 하여 개별 식별자 인용을 제거하십시오. 기본적으로 마지막 식별자 다음에 나오는 추가 문자는 오류로 간주됩니다. 그러나 두 번째 매개 변수가 &lt;code&gt;false&lt;/code&gt; 인 경우 이러한 추가 문자는 무시됩니다. 이 동작은 함수와 같은 객체의 이름을 구문 분석하는 데 유용합니다.이 함수는 길이가 긴 식별자를 자르지 않습니다. 자르기를 원하면 결과를 &lt;code&gt;name[]&lt;/code&gt; 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="452c0eaa4396b1682c70507bbb500c41cee09798" translate="yes" xml:space="preserve">
          <source>Split &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; on &lt;em&gt;&lt;code&gt;delimiter&lt;/code&gt;&lt;/em&gt; and return the given field (counting from one)</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;delimiter&lt;/code&gt; &lt;/em&gt;&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 을 분할 하고 주어진 필드를 반환합니다 (하나부터 계산).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fba8c7efc2fc29805f0ed0262e77872ab249cfd" translate="yes" xml:space="preserve">
          <source>Split &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; using a POSIX regular expression as the delimiter. See &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt; for more information.</source>
          <target state="translated">POSIX 정규식을 구분 기호로 사용하여 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 을 분할 하십시오. 자세한 정보는 &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="872e271b7798fa220ef122e358d8e6aa4e6b7817" translate="yes" xml:space="preserve">
          <source>Splits &lt;em&gt;&lt;code&gt;qualified_identifier&lt;/code&gt;&lt;/em&gt; into an array of identifiers, removing any quoting of individual identifiers. By default, extra characters after the last identifier are considered an error; but if the second parameter is &lt;code&gt;false&lt;/code&gt;, then such extra characters are ignored. (This behavior is useful for parsing names for objects like functions.) Note that this function does not truncate over-length identifiers. If you want truncation you can cast the result to &lt;code&gt;name[]&lt;/code&gt;.</source>
          <target state="translated">Splits &lt;em&gt; &lt;code&gt;qualified_identifier&lt;/code&gt; &lt;/em&gt; into an array of identifiers, removing any quoting of individual identifiers. By default, extra characters after the last identifier are considered an error; but if the second parameter is &lt;code&gt;false&lt;/code&gt; , then such extra characters are ignored. (This behavior is useful for parsing names for objects like functions.) Note that this function does not truncate over-length identifiers. If you want truncation you can cast the result to &lt;code&gt;name[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a821ba60ce0a62f2e4462f30b9d2569bb51770bb" translate="yes" xml:space="preserve">
          <source>Splits &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; at occurrences of &lt;em&gt;&lt;code&gt;delimiter&lt;/code&gt;&lt;/em&gt; and returns the &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;'th field (counting from one).</source>
          <target state="translated">Splits &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; at occurrences of &lt;em&gt; &lt;code&gt;delimiter&lt;/code&gt; &lt;/em&gt; and returns the &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt;'th field (counting from one).</target>
        </trans-unit>
        <trans-unit id="f46c43c436e7a2286908d6c4af5eaaca471d33b1" translate="yes" xml:space="preserve">
          <source>Splits &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; using a POSIX regular expression as the delimiter; see &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;.</source>
          <target state="translated">Splits &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; using a POSIX regular expression as the delimiter; see &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1d04717d2186b8faec3f593183713d22dd3a23a7" translate="yes" xml:space="preserve">
          <source>Splits the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; at occurrences of &lt;em&gt;&lt;code&gt;delimiter&lt;/code&gt;&lt;/em&gt; and forms the remaining data into a &lt;code&gt;text&lt;/code&gt; array. If &lt;em&gt;&lt;code&gt;delimiter&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, each character in the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; will become a separate element in the array. If &lt;em&gt;&lt;code&gt;delimiter&lt;/code&gt;&lt;/em&gt; is an empty string, then the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; is treated as a single field. If &lt;em&gt;&lt;code&gt;null_string&lt;/code&gt;&lt;/em&gt; is supplied and is not &lt;code&gt;NULL&lt;/code&gt;, fields matching that string are converted to &lt;code&gt;NULL&lt;/code&gt; entries.</source>
          <target state="translated">Splits the &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; at occurrences of &lt;em&gt; &lt;code&gt;delimiter&lt;/code&gt; &lt;/em&gt; and forms the remaining data into a &lt;code&gt;text&lt;/code&gt; array. If &lt;em&gt; &lt;code&gt;delimiter&lt;/code&gt; &lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt; , each character in the &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; will become a separate element in the array. If &lt;em&gt; &lt;code&gt;delimiter&lt;/code&gt; &lt;/em&gt; is an empty string, then the &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; is treated as a single field. If &lt;em&gt; &lt;code&gt;null_string&lt;/code&gt; &lt;/em&gt; is supplied and is not &lt;code&gt;NULL&lt;/code&gt; , fields matching that string are converted to &lt;code&gt;NULL&lt;/code&gt; entries.</target>
        </trans-unit>
        <trans-unit id="a41ad5dd4e3055c054e1b8131090a49096de1b65" translate="yes" xml:space="preserve">
          <source>Square brackets (&lt;code&gt;[]&lt;/code&gt;) are used for array access.</source>
          <target state="translated">대괄호 ( &lt;code&gt;[]&lt;/code&gt; )는 배열 액세스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47a3278f023594b94c900b5d792366be2e8b3d39" translate="yes" xml:space="preserve">
          <source>Square root</source>
          <target state="translated">제곱근</target>
        </trans-unit>
        <trans-unit id="9b2338cc740ef3f8a991d0cf2d9f70c9cdd0b9eb" translate="yes" xml:space="preserve">
          <source>Standard Generalized Markup Language</source>
          <target state="translated">표준 일반 마크 업 언어</target>
        </trans-unit>
        <trans-unit id="eea619235b15d5c21293d7a81c24547355124b6b" translate="yes" xml:space="preserve">
          <source>Standard Unix Tools</source>
          <target state="translated">표준 유닉스 도구</target>
        </trans-unit>
        <trans-unit id="de2b6e929cd7367d09ce95f38c08be723ba36508" translate="yes" xml:space="preserve">
          <source>Standard Usage:</source>
          <target state="translated">표준 사용법 :</target>
        </trans-unit>
        <trans-unit id="0331a857cd4069f8f946115fc758e05691b6e5d9" translate="yes" xml:space="preserve">
          <source>Standby (server)</source>
          <target state="translated">Standby (server)</target>
        </trans-unit>
        <trans-unit id="9ad1496103ebe737cb4cfc02baea1e5fc4b6bebd" translate="yes" xml:space="preserve">
          <source>Standby mode is exited and the server switches to normal operation when &lt;code&gt;pg_ctl promote&lt;/code&gt; is run or a trigger file is found (&lt;code&gt;promote_trigger_file&lt;/code&gt;). Before failover, any WAL immediately available in the archive or in &lt;code&gt;pg_wal&lt;/code&gt; will be restored, but no attempt is made to connect to the master.</source>
          <target state="translated">&lt;code&gt;pg_ctl promote&lt;/code&gt; 가 실행되거나 트리거 파일이 발견 &lt;code&gt;promote_trigger_file&lt;/code&gt; ( promote_trigger_file ) 대기 모드가 종료되고 서버가 정상 작동으로 전환됩니다 . 장애 조치 전에 아카이브 또는 &lt;code&gt;pg_wal&lt;/code&gt; 에서 즉시 사용 가능한 WAL 이 복원되지만 마스터에 연결하려는 시도는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4abfa5fe8d34903a682ac3a907a3aa371e9fedf4" translate="yes" xml:space="preserve">
          <source>Standby mode is exited and the server switches to normal operation when &lt;code&gt;pg_ctl promote&lt;/code&gt; is run, &lt;code&gt;pg_promote()&lt;/code&gt; is called, or a trigger file is found (&lt;code&gt;promote_trigger_file&lt;/code&gt;). Before failover, any WAL immediately available in the archive or in &lt;code&gt;pg_wal&lt;/code&gt; will be restored, but no attempt is made to connect to the master.</source>
          <target state="translated">Standby mode is exited and the server switches to normal operation when &lt;code&gt;pg_ctl promote&lt;/code&gt; is run, &lt;code&gt;pg_promote()&lt;/code&gt; is called, or a trigger file is found ( &lt;code&gt;promote_trigger_file&lt;/code&gt; ). Before failover, any WAL immediately available in the archive or in &lt;code&gt;pg_wal&lt;/code&gt; will be restored, but no attempt is made to connect to the master.</target>
        </trans-unit>
        <trans-unit id="4e863244c82b2b389bea57f2367f9cb4ec762ff3" translate="yes" xml:space="preserve">
          <source>Star symbols can also be quantified to restrict how many labels they can match:</source>
          <target state="translated">별표를 수량화하여 일치시킬 수있는 레이블 수를 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f2216d23a9c349059c6dc07393909d7f3482743" translate="yes" xml:space="preserve">
          <source>Start or restart an index scan, possibly with new scan keys. (To restart using previously-passed keys, NULL is passed for &lt;code&gt;keys&lt;/code&gt; and/or &lt;code&gt;orderbys&lt;/code&gt;.) Note that it is not allowed for the number of keys or order-by operators to be larger than what was passed to &lt;code&gt;ambeginscan&lt;/code&gt;. In practice the restart feature is used when a new outer tuple is selected by a nested-loop join and so a new key comparison value is needed, but the scan key structure remains the same.</source>
          <target state="translated">가능하면 새 스캔 키를 사용하여 인덱스 스캔을 시작하거나 다시 시작하십시오. (이전에 전달 된 키를 사용하여 다시 시작하려면 &lt;code&gt;keys&lt;/code&gt; 및 / 또는 &lt;code&gt;orderbys&lt;/code&gt; 에 대해 NULL이 전달됩니다 .) 키 또는 order-by 연산자의 수가 &lt;code&gt;ambeginscan&lt;/code&gt; 에 전달 된 것보다 클 수는 없습니다 . 실제로 다시 시작 기능은 중첩 루프 조인으로 새 외부 튜플을 선택할 때 사용되므로 새 키 비교 값이 필요하지만 스캔 키 구조는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4b412902d910099d2ab6874b5f6691914e603e66" translate="yes" xml:space="preserve">
          <source>Start reading at the specified log segment file. This implicitly determines the path in which files will be searched for, and the timeline to use.</source>
          <target state="translated">지정된 로그 세그먼트 파일에서 읽기를 시작하십시오. 이는 파일을 검색 할 경로와 사용할 타임 라인을 암시 적으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b84a6f7e80fffa2ae6a8127e864e6100a90ad408" translate="yes" xml:space="preserve">
          <source>Start the database server, again using the special database user account:</source>
          <target state="translated">특수 데이터베이스 사용자 계정을 사용하여 데이터베이스 서버를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="36f704b789e75035581f19c0aa3c1d618bb75944" translate="yes" xml:space="preserve">
          <source>Start the server. The server will go into recovery mode and proceed to read through the archived WAL files it needs. Should the recovery be terminated because of an external error, the server can simply be restarted and it will continue recovery. Upon completion of the recovery process, the server will remove &lt;code&gt;recovery.signal&lt;/code&gt; (to prevent accidentally re-entering recovery mode later) and then commence normal database operations.</source>
          <target state="translated">서버를 시작하십시오. 서버는 복구 모드로 전환되고 필요한 보관 된 WAL 파일을 읽습니다. 외부 오류로 인해 복구가 종료되면 서버를 다시 시작하면 복구가 계속됩니다. 복구 프로세스가 완료되면 서버는 &lt;code&gt;recovery.signal&lt;/code&gt; 을 제거하고 (나중에 실수로 복구 모드로 다시 들어가는 것을 방지하기 위해) 정상적인 데이터베이스 작업을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fe398d868821034ad151a10a0aa3ab7f0418c47d" translate="yes" xml:space="preserve">
          <source>Start type of the system service. &lt;code&gt;start-type&lt;/code&gt; can be &lt;code&gt;auto&lt;/code&gt;, or &lt;code&gt;demand&lt;/code&gt;, or the first letter of one of these two. If this option is omitted, &lt;code&gt;auto&lt;/code&gt; is the default.</source>
          <target state="translated">시스템 서비스의 시작 유형 &lt;code&gt;start-type&lt;/code&gt; 은 &lt;code&gt;auto&lt;/code&gt; 또는 &lt;code&gt;demand&lt;/code&gt; 또는이 두 문자 중 첫 번째 문자 일 수 있습니다 . 이 옵션을 생략하면 &lt;code&gt;auto&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d8ad6e42a920b41dab86607fc2b641bad383a626" translate="yes" xml:space="preserve">
          <source>Start value of the sequence</source>
          <target state="translated">시퀀스의 시작 값</target>
        </trans-unit>
        <trans-unit id="d3d5f43ee9321076081248871d53d2f4d5c235d8" translate="yes" xml:space="preserve">
          <source>Starting the Database Server</source>
          <target state="translated">데이터베이스 서버 시작</target>
        </trans-unit>
        <trans-unit id="194f6075b816df9810c74136441d89fc4b3d92ae" translate="yes" xml:space="preserve">
          <source>Starting the Database Server: Client Connection Problems</source>
          <target state="translated">데이터베이스 서버 시작 : 클라이언트 연결 문제</target>
        </trans-unit>
        <trans-unit id="27ca8ea5e2e544cb9af4440f44c1cfd080713eac" translate="yes" xml:space="preserve">
          <source>Starting the Database Server: Server Start-up Failures</source>
          <target state="translated">데이터베이스 서버 시작 : 서버 시작 실패</target>
        </trans-unit>
        <trans-unit id="b638ffb3274d9bb64101256b64c8469c46ae5986" translate="yes" xml:space="preserve">
          <source>Starting the Server</source>
          <target state="translated">서버 시작</target>
        </trans-unit>
        <trans-unit id="38d6823e381e2b97ec437a489b16c7cd4f8aaf46" translate="yes" xml:space="preserve">
          <source>Starting with PostgreSQL version 9.0, you can use streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) to achieve the same benefits with less effort.</source>
          <target state="translated">PostgreSQL 버전 9.0부터는 스트리밍 복제 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;26.2.5&lt;/a&gt; 참조 )를 사용하여 적은 노력으로 동일한 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08be92f5bd8036d0ab648816f990adfcf0029379" translate="yes" xml:space="preserve">
          <source>State code: &lt;code&gt;i&lt;/code&gt; = initialize, &lt;code&gt;d&lt;/code&gt; = data is being copied, &lt;code&gt;s&lt;/code&gt; = synchronized, &lt;code&gt;r&lt;/code&gt; = ready (normal replication)</source>
          <target state="translated">상태 코드 : &lt;code&gt;i&lt;/code&gt; = 초기화, &lt;code&gt;d&lt;/code&gt; = 데이터 복사 중, &lt;code&gt;s&lt;/code&gt; = 동기화, &lt;code&gt;r&lt;/code&gt; = 준비 (정상 복제)</target>
        </trans-unit>
        <trans-unit id="57052c5f4957ab3d7367c2a5fa0946985e3f70bb" translate="yes" xml:space="preserve">
          <source>Statement-Based Replication Middleware</source>
          <target state="translated">명령문 기반 복제 미들웨어</target>
        </trans-unit>
        <trans-unit id="cbd3743fe5a3ab54a079de4fa5d18e2e88a8088e" translate="yes" xml:space="preserve">
          <source>Statement-level</source>
          <target state="translated">Statement-level</target>
        </trans-unit>
        <trans-unit id="40b6852707bbd31d9501afffde5f792ccd2c9d03" translate="yes" xml:space="preserve">
          <source>Statement-level triggers on a view are fired only if the action on the view is handled by a row-level &lt;code&gt;INSTEAD OF&lt;/code&gt; trigger. If the action is handled by an &lt;code&gt;INSTEAD&lt;/code&gt; rule, then whatever statements are emitted by the rule are executed in place of the original statement naming the view, so that the triggers that will be fired are those on tables named in the replacement statements. Similarly, if the view is automatically updatable, then the action is handled by automatically rewriting the statement into an action on the view's base table, so that the base table's statement-level triggers are the ones that are fired.</source>
          <target state="translated">뷰의 명령문 레벨 트리거는 뷰의 조치가 행 레벨 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거에 의해 처리되는 경우에만 시작됩니다 . 조치가 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙에 의해 처리되는 경우, 규칙에 의해 생성 된 명령문은 뷰를 명명하는 원래 명령문 대신 실행되므로 트리거 될 트리거는 대체 명령문에 이름이 지정된 테이블의 트리거입니다. 마찬가지로보기를 자동으로 업데이트 할 수있는 경우, 명령문을보기의 기본 테이블에있는 조치에 자동으로 다시 작성하여 조치가 처리되므로 기본 테이블의 명령문 레벨 트리거가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c010f9e77089d9833294cc3aae17d400c2624d2a" translate="yes" xml:space="preserve">
          <source>Statements are executed more quickly in a transaction block, because transaction start/commit requires significant CPU and disk activity. Execution of multiple statements inside a transaction is also useful to ensure consistency when making several related changes: other sessions will be unable to see the intermediate states wherein not all the related updates have been done.</source>
          <target state="translated">트랜잭션 시작 / 커밋에는 상당한 CPU 및 디스크 작업이 필요하기 때문에 트랜잭션 블록에서 명령문이 더 빨리 실행됩니다. 트랜잭션 내에서 여러 명령문을 실행하면 여러 관련 변경을 수행 할 때 일관성을 유지하는 데 유용합니다. 다른 세션에서는 모든 관련 업데이트가 완료되지 않은 중간 상태를 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="acf9521494dc54c620b135e07871cb53c42cd3c9" translate="yes" xml:space="preserve">
          <source>Statements that contain simple syntax errors are not logged even by the &lt;code&gt;log_statement&lt;/code&gt; = &lt;code&gt;all&lt;/code&gt; setting, because the log message is emitted only after basic parsing has been done to determine the statement type. In the case of extended query protocol, this setting likewise does not log statements that fail before the Execute phase (i.e., during parse analysis or planning). Set &lt;code&gt;log_min_error_statement&lt;/code&gt; to &lt;code&gt;ERROR&lt;/code&gt; (or lower) to log such statements.</source>
          <target state="translated">간단한 구문 오류가 포함 된 명령문은 &lt;code&gt;log_statement&lt;/code&gt; = &lt;code&gt;all&lt;/code&gt; 설정으로 도 로그되지 않습니다 . 명령문 유형을 판별하기 위해 기본 구문 분석이 수행 된 후에 만 ​​로그 메시지가 생성되기 때문입니다. 확장 쿼리 프로토콜의 경우이 설정은 마찬가지로 실행 단계 이전 (예 : 구문 분석 또는 계획 중)에 실패한 명령문을 기록하지 않습니다. 이러한 명령문을 로그 &lt;code&gt;log_min_error_statement&lt;/code&gt; 를 &lt;code&gt;ERROR&lt;/code&gt; (또는 그 이하)로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="db5c70d83baa4567c859336546ef85d7d8623622" translate="yes" xml:space="preserve">
          <source>Statistical correlation between physical row ordering and logical ordering of the column values. This ranges from -1 to +1. When the value is near -1 or +1, an index scan on the column will be estimated to be cheaper than when it is near zero, due to reduction of random access to the disk. (This column is null if the column data type does not have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.)</source>
          <target state="translated">물리적 행 순서와 열 값의 논리적 순서 사이의 통계적 상관. 범위는 -1에서 +1입니다. 값이 -1 또는 +1에 가까우면 디스크에 대한 임의 액세스의 감소로 인해 열의 인덱스 스캔이 0에 가까울 때보 다 싼 것으로 추정됩니다. (이 열은 열 데이터 유형에 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가없는 경우 널 입니다.)</target>
        </trans-unit>
        <trans-unit id="9a9fc749b7c132ac6bf1a07d9e96218dfabb80eb" translate="yes" xml:space="preserve">
          <source>Statistics Collector</source>
          <target state="translated">통계 수집기</target>
        </trans-unit>
        <trans-unit id="74d86a1f6a07f8a77fd04b79cb2e622d4d5fd952" translate="yes" xml:space="preserve">
          <source>Statistics Information Functions</source>
          <target state="translated">통계 정보 기능</target>
        </trans-unit>
        <trans-unit id="d2cf3148c43e96fbd5a61538babff0c2d5760c79" translate="yes" xml:space="preserve">
          <source>Statistics Used by the Planner</source>
          <target state="translated">플래너가 사용하는 통계</target>
        </trans-unit>
        <trans-unit id="99a201b3fed6df6ed5ed37511712f338e1d9904c" translate="yes" xml:space="preserve">
          <source>Statistics objects are created using the &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt; command. Creation of such an object merely creates a catalog entry expressing interest in the statistics. Actual data collection is performed by &lt;code&gt;ANALYZE&lt;/code&gt; (either a manual command, or background auto-analyze). The collected values can be examined in the &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="translated">통계 오브젝트는 &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt; 명령을 사용하여 작성됩니다 . 이러한 개체를 생성하면 통계에 대한 관심을 나타내는 카탈로그 항목 만 작성됩니다. 실제 데이터 수집은 &lt;code&gt;ANALYZE&lt;/code&gt; (수동 명령 또는 백그라운드 자동 분석)에 의해 수행됩니다 . 수집 된 값은 &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt; &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; &lt;/a&gt; 카탈로그 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc9a0112f865d1a29cf01568926792ace553a622" translate="yes" xml:space="preserve">
          <source>Stats collector (process)</source>
          <target state="translated">Stats collector (process)</target>
        </trans-unit>
        <trans-unit id="e30827cb8bbecbd6e93cd3c3c6950e2f9d87beb9" translate="yes" xml:space="preserve">
          <source>Still, with appropriate use of expression indexes, the above query can use an index. If querying for particular items within the &lt;code&gt;&quot;tags&quot;&lt;/code&gt; key is common, defining an index like this may be worthwhile:</source>
          <target state="translated">여전히 식 인덱스를 적절히 사용하면 위 쿼리에서 인덱스를 사용할 수 있습니다. &lt;code&gt;&quot;tags&quot;&lt;/code&gt; 키 내의 특정 항목에 대한 쿼리 가 일반적인 경우 다음과 같이 인덱스를 정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fb2285467ee95a339f6cd83a0568d854f57fff09" translate="yes" xml:space="preserve">
          <source>Stop after reading the specified log segment file.</source>
          <target state="translated">지정된 로그 세그먼트 파일을 읽은 후 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="6a8bd9224939c0468435f95c435e66ecf2de52e3" translate="yes" xml:space="preserve">
          <source>Stop reading at the specified WAL location, instead of reading to the end of the log stream.</source>
          <target state="translated">로그 스트림 끝을 읽는 대신 지정된 WAL 위치에서 읽기를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="2d0c4f05ef6713bdd56aeb38584e87c3d2dda84e" translate="yes" xml:space="preserve">
          <source>Stop the server, if it's running.</source>
          <target state="translated">서버가 실행 중이면 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="3eade2d2bb2293afd3eb3db96fb6157c176e52dc" translate="yes" xml:space="preserve">
          <source>Stop words are words that are very common, appear in almost every document, and have no discrimination value. Therefore, they can be ignored in the context of full text searching. For example, every English text contains words like &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;the&lt;/code&gt;, so it is useless to store them in an index. However, stop words do affect the positions in &lt;code&gt;tsvector&lt;/code&gt;, which in turn affect ranking:</source>
          <target state="translated">중지 단어는 매우 일반적이며 거의 모든 문서에 나타나며 차별 가치가없는 단어입니다. 따라서 전체 텍스트 검색의 맥락에서 무시할 수 있습니다. 예를 들어, 모든 영어 텍스트가 같은 단어가 포함되어 및 &lt;code&gt;the&lt;/code&gt; , 그래서 인덱스에 저장하는 쓸모없는 것입니다. 그러나 중지 단어는 &lt;code&gt;tsvector&lt;/code&gt; 의 위치에 영향을 미치며 순위에 영향을줍니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48dc2b75f0b88a18a8353ee85f551384e635e76b" translate="yes" xml:space="preserve">
          <source>Stopping the Server</source>
          <target state="translated">서버 중지</target>
        </trans-unit>
        <trans-unit id="aae769a0618c2688570a2e6949d9055f0b9c630d" translate="yes" xml:space="preserve">
          <source>Storage Parameters</source>
          <target state="translated">저장 매개 변수</target>
        </trans-unit>
        <trans-unit id="ff8fec38d95756f7b58cefb020df790b99ee6421" translate="yes" xml:space="preserve">
          <source>Storage Size</source>
          <target state="translated">보관 크기</target>
        </trans-unit>
        <trans-unit id="f7b4842540682ea4bf73edee465143969b41b03d" translate="yes" xml:space="preserve">
          <source>Storage encryption can be performed at the file system level or the block level. Linux file system encryption options include eCryptfs and EncFS, while FreeBSD uses PEFS. Block level or full disk encryption options include dm-crypt + LUKS on Linux and GEOM modules geli and gbde on FreeBSD. Many other operating systems support this functionality, including Windows.</source>
          <target state="translated">스토리지 암호화는 파일 시스템 수준 또는 블록 수준에서 수행 할 수 있습니다. Linux 파일 시스템 암호화 옵션에는 eCryptfs 및 EncFS가 포함되며 FreeBSD는 PEFS를 사용합니다. 블록 레벨 또는 전체 디스크 암호화 옵션에는 Linux의 dm-crypt + LUKS 및 FreeBSD의 GEOM 모듈 geli 및 gbde가 포함됩니다. Windows를 포함한 많은 다른 운영 체제가이 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="72beac58316ea4ff26f0e4dc445d95c8cf736d21" translate="yes" xml:space="preserve">
          <source>Stores the file into a PostgreSQL large object. Optionally, it associates the given comment with the object. Example:</source>
          <target state="translated">파일을 PostgreSQL 대형 객체에 저장합니다. 선택적으로 주어진 주석을 오브젝트와 연관시킵니다. 예:</target>
        </trans-unit>
        <trans-unit id="98849831501a6ebc0da0afac13e611052814f47a" translate="yes" xml:space="preserve">
          <source>Stream the write-ahead log while the backup is created. This will open a second connection to the server and start streaming the write-ahead log in parallel while running the backup. Therefore, it will use up two connections configured by the &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; parameter. As long as the client can keep up with write-ahead log received, using this mode requires no extra write-ahead logs to be saved on the master.</source>
          <target state="translated">백업이 작성되는 동안 미리 쓰기 로그를 스트리밍하십시오. 그러면 서버에 대한 두 번째 연결이 열리고 백업을 실행하는 동안 미리 쓰기 로그를 동시에 스트리밍하기 시작합니다. 따라서 &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; 매개 변수로 구성된 두 개의 연결을 사용합니다 . 클라이언트가 미리 쓰기 로그를 수신 할 수있는 한이 모드를 사용하면 마스터에 추가 미리 쓰기 로그를 저장할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="300f71c619b12bfb4534f512f41e27141b5eb057" translate="yes" xml:space="preserve">
          <source>Stream write-ahead log data while the backup is being taken. This method will open a second connection to the server and start streaming the write-ahead log in parallel while running the backup. Therefore, it will require two replication connections not just one. As long as the client can keep up with the write-ahead log data, using this method requires no extra write-ahead logs to be saved on the source server.</source>
          <target state="translated">Stream write-ahead log data while the backup is being taken. This method will open a second connection to the server and start streaming the write-ahead log in parallel while running the backup. Therefore, it will require two replication connections not just one. As long as the client can keep up with the write-ahead log data, using this method requires no extra write-ahead logs to be saved on the source server.</target>
        </trans-unit>
        <trans-unit id="097088ad5c088ba6bc904a64eea0095316a57177" translate="yes" xml:space="preserve">
          <source>Streaming replication allows a standby server to stay more up-to-date than is possible with file-based log shipping. The standby connects to the primary, which streams WAL records to the standby as they're generated, without waiting for the WAL file to be filled.</source>
          <target state="translated">스트리밍 복제를 사용하면 대기 서버가 파일 기반 로그 전달에서 가능한 것보다 최신 상태를 유지할 수 있습니다. 대기는 기본에 연결되며 WAL 레코드가 생성 될 때까지 기다리지 않고 생성 된 WAL 레코드를 대기에 스트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="a1a6c03c88f7251c1fbee700421246ba6f838a61" translate="yes" xml:space="preserve">
          <source>Streaming replication and log-shipping standby servers can remain running until a later step.</source>
          <target state="translated">스트리밍 복제 및 로그 전달 대기 서버는 이후 단계까지 계속 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="510bec85b3982a82cd98f9026b6d44348c927578" translate="yes" xml:space="preserve">
          <source>Streaming replication is asynchronous by default (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;), in which case there is a small delay between committing a transaction in the primary and the changes becoming visible in the standby. This delay is however much smaller than with file-based log shipping, typically under one second assuming the standby is powerful enough to keep up with the load. With streaming replication, &lt;code&gt;archive_timeout&lt;/code&gt; is not required to reduce the data loss window.</source>
          <target state="translated">스트리밍 복제는 기본적으로 비동기 적입니다 ( &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;섹션 26.2.8&lt;/a&gt; 참조 ).이 경우 기본 트랜잭션을 커밋하는 것과 대기에서 변경 사항이 표시되는 것 사이에 약간의 지연이 있습니다. 그러나이 지연은 파일 기반 로그 전달보다 훨씬 작습니다. 일반적으로 대기가로드를 견딜 수있을 정도로 강력하다고 가정하면 1 초 미만입니다. 스트리밍 복제의 경우 데이터 손실 창을 줄이기 위해 &lt;code&gt;archive_timeout&lt;/code&gt; 이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59734c88a6da60d417cc049feadd59d856020ec2" translate="yes" xml:space="preserve">
          <source>Strictly speaking, this process is iteration not recursion, but &lt;code&gt;RECURSIVE&lt;/code&gt; is the terminology chosen by the SQL standards committee.</source>
          <target state="translated">엄밀히 말하면,이 프로세스는 반복이 아닌 반복이지만 &lt;code&gt;RECURSIVE&lt;/code&gt; 는 SQL 표준위원회에서 선택한 용어입니다.</target>
        </trans-unit>
        <trans-unit id="0449bdd319938ccde49136f6f586857687fc872f" translate="yes" xml:space="preserve">
          <source>String Functions and Operators</source>
          <target state="translated">문자열 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="c4cf243380995c59cd0d14287fbbada913c64d63" translate="yes" xml:space="preserve">
          <source>String concatenation</source>
          <target state="translated">문자열 연결</target>
        </trans-unit>
        <trans-unit id="32f77e7a8d21e9702c07e36bf15eaad35d0a97ff" translate="yes" xml:space="preserve">
          <source>String concatenation with one non-string input</source>
          <target state="translated">문자열이 아닌 하나의 입력으로 문자열 연결</target>
        </trans-unit>
        <trans-unit id="41ef585079d5f482c881aa9ff8b8142d7dc3d92e" translate="yes" xml:space="preserve">
          <source>String does not match regular expression, case insensitively</source>
          <target state="translated">String does not match regular expression, case insensitively</target>
        </trans-unit>
        <trans-unit id="d1498f8c412cb6fe18453053129495cd593d8907" translate="yes" xml:space="preserve">
          <source>String does not match regular expression, case sensitively</source>
          <target state="translated">String does not match regular expression, case sensitively</target>
        </trans-unit>
        <trans-unit id="eecc324e7b74589dbb5b2379d9d7d1c95b96c95d" translate="yes" xml:space="preserve">
          <source>String matches regular expression, case insensitively</source>
          <target state="translated">String matches regular expression, case insensitively</target>
        </trans-unit>
        <trans-unit id="13ce7f439f352d96909a1d3acade62ccac820fd7" translate="yes" xml:space="preserve">
          <source>String matches regular expression, case sensitively</source>
          <target state="translated">String matches regular expression, case sensitively</target>
        </trans-unit>
        <trans-unit id="b45b16e6a34eec5581884d72320e0a2987555685" translate="yes" xml:space="preserve">
          <source>String sort order</source>
          <target state="translated">문자열 정렬 순서</target>
        </trans-unit>
        <trans-unit id="8ce9849d1cc5dda7156d4d9867d5362993f6a11c" translate="yes" xml:space="preserve">
          <source>String to append to the user name when forming the DN to bind as, when doing simple bind authentication.</source>
          <target state="translated">바인드 인증을 수행 할 때 바인드 할 DN을 구성 할 때 사용자 이름에 추가 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1c6eef04ae18bf39d0276b928e30ca70903fe5c2" translate="yes" xml:space="preserve">
          <source>String to prepend to the user name when forming the DN to bind as, when doing simple bind authentication.</source>
          <target state="translated">간단한 바인드 인증을 수행 할 때 바인딩 할 DN을 구성 할 때 사용자 이름 앞에 추가 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="332d895a8178354e855f4b4b01b8b37ea06ec60c" translate="yes" xml:space="preserve">
          <source>String to separate keys with in branch output (optional)</source>
          <target state="translated">분기 출력에서 ​​키를 구분하는 문자열 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="71f074fee588f6374a9072f9342ac58ca9eb5442" translate="yes" xml:space="preserve">
          <source>String types</source>
          <target state="translated">문자열 타입</target>
        </trans-unit>
        <trans-unit id="50e84681568a65ae1f9159b6074361760a41fe5f" translate="yes" xml:space="preserve">
          <source>String: ascii</source>
          <target state="translated">문자열 : 아스키</target>
        </trans-unit>
        <trans-unit id="1b44c134e7e055c2b1a9c9e82da0983e2f92762b" translate="yes" xml:space="preserve">
          <source>String: bit_length</source>
          <target state="translated">문자열 : bit_length</target>
        </trans-unit>
        <trans-unit id="ddc8a0f4aa2bebf9f87fa9e3e13a4f7c426d613d" translate="yes" xml:space="preserve">
          <source>String: btrim</source>
          <target state="translated">문자열 : 브림</target>
        </trans-unit>
        <trans-unit id="34f0beb228d201bcbfd514224e3741ccffa94bab" translate="yes" xml:space="preserve">
          <source>String: char_length</source>
          <target state="translated">문자열 : char_length</target>
        </trans-unit>
        <trans-unit id="a2e71bdf0d12af18f2ad32f8352df2b6527fdfdf" translate="yes" xml:space="preserve">
          <source>String: character_length</source>
          <target state="translated">문자열 : character_length</target>
        </trans-unit>
        <trans-unit id="071c1bd918b7aaf0050b846384abfcf76dc51e8d" translate="yes" xml:space="preserve">
          <source>String: chr</source>
          <target state="translated">끈 : chr</target>
        </trans-unit>
        <trans-unit id="25cc2d86bc862b5a7d2d3b605fd1f5576e99761e" translate="yes" xml:space="preserve">
          <source>String: concat</source>
          <target state="translated">문자열 : concat</target>
        </trans-unit>
        <trans-unit id="4d550960ed8279e8d9f70ad320821d381afdce25" translate="yes" xml:space="preserve">
          <source>String: concat_ws</source>
          <target state="translated">문자열 : concat_ws</target>
        </trans-unit>
        <trans-unit id="50a5596aa4b63d6d635e458633f05b0fc068a82d" translate="yes" xml:space="preserve">
          <source>String: convert</source>
          <target state="translated">문자열 : 변환</target>
        </trans-unit>
        <trans-unit id="84bb90d91d40a617b967c6d13b48451aeeab81c2" translate="yes" xml:space="preserve">
          <source>String: convert_from</source>
          <target state="translated">문자열 : convert_from</target>
        </trans-unit>
        <trans-unit id="683b9d59b4171ae3bb9d62a9900a7a3672ac29f0" translate="yes" xml:space="preserve">
          <source>String: convert_to</source>
          <target state="translated">문자열 : convert_to</target>
        </trans-unit>
        <trans-unit id="6d247ef21a962c4e7cec93666726d82bfeff47bf" translate="yes" xml:space="preserve">
          <source>String: decode</source>
          <target state="translated">문자열 : 디코드</target>
        </trans-unit>
        <trans-unit id="68c98a013d33f5af63b106ead9e611cf3d8f45be" translate="yes" xml:space="preserve">
          <source>String: encode</source>
          <target state="translated">문자열 : 인코딩</target>
        </trans-unit>
        <trans-unit id="27228e33dff3b13ecae209427ad6962ef3966fa8" translate="yes" xml:space="preserve">
          <source>String: format</source>
          <target state="translated">문자열 : 형식</target>
        </trans-unit>
        <trans-unit id="e6e4f69c1c9b82022165be0cb0f2d95412856d58" translate="yes" xml:space="preserve">
          <source>String: initcap</source>
          <target state="translated">문자열 : initcap</target>
        </trans-unit>
        <trans-unit id="1732ca58ada5251a6d93b45fbdb71271ad3a4e75" translate="yes" xml:space="preserve">
          <source>String: left</source>
          <target state="translated">문자열 : 왼쪽</target>
        </trans-unit>
        <trans-unit id="201cee3f29b0d41dfb56d0f48c4d8365cc2fb59f" translate="yes" xml:space="preserve">
          <source>String: length</source>
          <target state="translated">끈 : 길이</target>
        </trans-unit>
        <trans-unit id="0b3e55babd8460f758255794a292444719791dea" translate="yes" xml:space="preserve">
          <source>String: lower</source>
          <target state="translated">끈 : 낮게</target>
        </trans-unit>
        <trans-unit id="d39106cd1f64291ff1da6a77498eaa8c2e3293ae" translate="yes" xml:space="preserve">
          <source>String: lpad</source>
          <target state="translated">끈 : lpad</target>
        </trans-unit>
        <trans-unit id="04e1e6b1d4c6b8da9e39f7384cfd51dc79cac796" translate="yes" xml:space="preserve">
          <source>String: ltrim</source>
          <target state="translated">끈 : ltrim</target>
        </trans-unit>
        <trans-unit id="1c54812b4ae3b4ceea772deefde4e95a1fce94cb" translate="yes" xml:space="preserve">
          <source>String: md5</source>
          <target state="translated">문자열 : md5</target>
        </trans-unit>
        <trans-unit id="ac043f807b05335f82e237d3941504bdb0741297" translate="yes" xml:space="preserve">
          <source>String: octet_length</source>
          <target state="translated">문자열 : octet_length</target>
        </trans-unit>
        <trans-unit id="2b5f0ff4acad59980841e75c58f66ea894ec779a" translate="yes" xml:space="preserve">
          <source>String: overlay</source>
          <target state="translated">문자열 : 오버레이</target>
        </trans-unit>
        <trans-unit id="12a140fcd54fe34e62668e7158016378e14b4a4a" translate="yes" xml:space="preserve">
          <source>String: parse_ident</source>
          <target state="translated">문자열 : parse_ident</target>
        </trans-unit>
        <trans-unit id="c0e5427dfe2e2623ca27f4bcbd5ae38d3aa3211a" translate="yes" xml:space="preserve">
          <source>String: pg_client_encoding</source>
          <target state="translated">문자열 : pg_client_encoding</target>
        </trans-unit>
        <trans-unit id="6bdc622884e2cfa70cfee1b14f125c58dc52f642" translate="yes" xml:space="preserve">
          <source>String: position</source>
          <target state="translated">문자열 : 위치</target>
        </trans-unit>
        <trans-unit id="09ee7bc1d6b77853f8938e9db2c194923150013c" translate="yes" xml:space="preserve">
          <source>String: quote_ident</source>
          <target state="translated">문자열 : quote_ident</target>
        </trans-unit>
        <trans-unit id="37301b96991b0536647c684f63e98566d59ad56b" translate="yes" xml:space="preserve">
          <source>String: quote_literal</source>
          <target state="translated">문자열 : quote_literal</target>
        </trans-unit>
        <trans-unit id="a6884d950c0e89c0943c0a17a2a147a30b74cb07" translate="yes" xml:space="preserve">
          <source>String: quote_nullable</source>
          <target state="translated">문자열 : quote_nullable</target>
        </trans-unit>
        <trans-unit id="c3525ebfc19b886689211c7bb446feeda0760a11" translate="yes" xml:space="preserve">
          <source>String: regexp_match</source>
          <target state="translated">문자열 : regexp_match</target>
        </trans-unit>
        <trans-unit id="71ccb92cef718b1dde93f4781b7c87d77853748c" translate="yes" xml:space="preserve">
          <source>String: regexp_matches</source>
          <target state="translated">문자열 : regexp_matches</target>
        </trans-unit>
        <trans-unit id="e16516f1760883bd23e95ba181dbbdfff87c488d" translate="yes" xml:space="preserve">
          <source>String: regexp_replace</source>
          <target state="translated">문자열 : regexp_replace</target>
        </trans-unit>
        <trans-unit id="ecf083034d626d730499dd69aeeb56fe53843eec" translate="yes" xml:space="preserve">
          <source>String: regexp_split_to_array</source>
          <target state="translated">문자열 : regexp_split_to_array</target>
        </trans-unit>
        <trans-unit id="a366e7d33d49c6dc497208dd2d0a0e04aad83496" translate="yes" xml:space="preserve">
          <source>String: regexp_split_to_table</source>
          <target state="translated">문자열 : regexp_split_to_table</target>
        </trans-unit>
        <trans-unit id="4079a4633e969547899b47f9fdbbe547b69224ab" translate="yes" xml:space="preserve">
          <source>String: repeat</source>
          <target state="translated">문자열 : 반복</target>
        </trans-unit>
        <trans-unit id="b99a9148f52bdbad8507100aced79b9d00b89614" translate="yes" xml:space="preserve">
          <source>String: replace</source>
          <target state="translated">문자열 : 바꾸기</target>
        </trans-unit>
        <trans-unit id="70f4c4f222d7d4078f4b015519b5b5bf873ef628" translate="yes" xml:space="preserve">
          <source>String: reverse</source>
          <target state="translated">문자열 : 역</target>
        </trans-unit>
        <trans-unit id="dcfb8358a846bb0173455db045f2873350896817" translate="yes" xml:space="preserve">
          <source>String: right</source>
          <target state="translated">문자열 : 오른쪽</target>
        </trans-unit>
        <trans-unit id="7b1a53af3e9b298ddb5cfaee37e5523139422856" translate="yes" xml:space="preserve">
          <source>String: rpad</source>
          <target state="translated">문자열 : rpad</target>
        </trans-unit>
        <trans-unit id="d0865b985039b41de33b713d16499610a793160a" translate="yes" xml:space="preserve">
          <source>String: rtrim</source>
          <target state="translated">문자열 : rtrim</target>
        </trans-unit>
        <trans-unit id="605faffa530c4582cf2014ad6cab92435bf13002" translate="yes" xml:space="preserve">
          <source>String: split_part</source>
          <target state="translated">문자열 : split_part</target>
        </trans-unit>
        <trans-unit id="d059542544155ed4e92228221e477c0a54b77476" translate="yes" xml:space="preserve">
          <source>String: starts_with</source>
          <target state="translated">문자열 : starts_with</target>
        </trans-unit>
        <trans-unit id="48c26c504046b590b6dfc4ca4c86d27ebd68d44f" translate="yes" xml:space="preserve">
          <source>String: strpos</source>
          <target state="translated">끈 : strpos</target>
        </trans-unit>
        <trans-unit id="7f30fed6f2ad4b5936528a3a7206e6492a735162" translate="yes" xml:space="preserve">
          <source>String: substr</source>
          <target state="translated">문자열 : substr</target>
        </trans-unit>
        <trans-unit id="39c1145cb68cb9da97aa5828a0d839f607409e69" translate="yes" xml:space="preserve">
          <source>String: substring</source>
          <target state="translated">문자열 : 부분 문자열</target>
        </trans-unit>
        <trans-unit id="17551030013441f835f88d00a012ac6d9f9d5c6c" translate="yes" xml:space="preserve">
          <source>String: to_ascii</source>
          <target state="translated">문자열 : to_ascii</target>
        </trans-unit>
        <trans-unit id="965bac44ff9db247a629dafcf978fa4f86429971" translate="yes" xml:space="preserve">
          <source>String: to_hex</source>
          <target state="translated">문자열 : to_hex</target>
        </trans-unit>
        <trans-unit id="678ac09e759d449e376773e208cf0d772fff02d2" translate="yes" xml:space="preserve">
          <source>String: translate</source>
          <target state="translated">문자열 : 번역</target>
        </trans-unit>
        <trans-unit id="fc0ea0a16f33c79417e6740c743891066ecd2125" translate="yes" xml:space="preserve">
          <source>String: trim</source>
          <target state="translated">끈 : 트림</target>
        </trans-unit>
        <trans-unit id="c6fe2c39e5216163633d7a13c08fe59c40823e45" translate="yes" xml:space="preserve">
          <source>String: upper</source>
          <target state="translated">끈 : 위</target>
        </trans-unit>
        <trans-unit id="1f29d0b44ae3aefe3d6a4f9865d7524375588a7a" translate="yes" xml:space="preserve">
          <source>String: ||</source>
          <target state="translated">문자열 : ||</target>
        </trans-unit>
        <trans-unit id="6c952e04c823117fee9d2e85f24258d74196894e" translate="yes" xml:space="preserve">
          <source>Structural inconsistencies between indexes and the heap relations that are indexed (when &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed).</source>
          <target state="translated">(경우 인덱싱 인덱스 및 힙 구조 간의 불일치 관계 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 검증이 수행된다).</target>
        </trans-unit>
        <trans-unit id="39b44f9e9122e1dc4480c2f21d87778437e7ad97" translate="yes" xml:space="preserve">
          <source>Structural inconsistencies caused by incorrect operator class implementations.</source>
          <target state="translated">잘못된 연산자 클래스 구현으로 인한 구조적 불일치</target>
        </trans-unit>
        <trans-unit id="8fc1b89c9f574004732a0426adb44900a9e367c4" translate="yes" xml:space="preserve">
          <source>Structured Query Language</source>
          <target state="translated">구조적 쿼리 언어</target>
        </trans-unit>
        <trans-unit id="8cda1d2285a519c283a395b803fa1e6588057b92" translate="yes" xml:space="preserve">
          <source>Stunnel or SSH can also be used to encrypt transmissions.</source>
          <target state="translated">Stunnel 또는 SSH를 사용하여 전송을 암호화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9630656149e803852b35719d8b68437043db824d" translate="yes" xml:space="preserve">
          <source>Style Specification</source>
          <target state="translated">스타일 사양</target>
        </trans-unit>
        <trans-unit id="e18032b285246f370b0a08592cb139e9556efdce" translate="yes" xml:space="preserve">
          <source>Sub-partitioning can be useful to further divide partitions that are expected to become larger than other partitions, although excessive sub-partitioning can easily lead to large numbers of partitions and can cause the same problems mentioned in the preceding paragraph.</source>
          <target state="translated">하위 분할은 다른 분할 영역보다 커질 것으로 예상되는 분할 영역을 추가로 분할하는 데 유용 할 수 있지만 과도한 분할 분할은 많은 수의 분할 영역을 쉽게 만들 수 있으며 이전 단락에서 언급 한 것과 동일한 문제를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7bf35af23ac99da91f912cb4a0354686b23fa33" translate="yes" xml:space="preserve">
          <source>Subdirectory containing LISTEN/NOTIFY status data</source>
          <target state="translated">LISTEN / NOTIFY 상태 데이터를 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="bc7b8a01e46392163777df616f989929c911a5d0" translate="yes" xml:space="preserve">
          <source>Subdirectory containing WAL (Write Ahead Log) files</source>
          <target state="translated">WAL (Write Ahead Log) 파일을 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="d94445bf01eed4c131a288398d30ba337f48ce02" translate="yes" xml:space="preserve">
          <source>Subdirectory containing cluster-wide tables, such as &lt;code&gt;pg_database&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_database&lt;/code&gt; 와 같은 클러스터 전체 테이블을 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="8f4120d23c9394dd1a9233dffdee25ecbef63458" translate="yes" xml:space="preserve">
          <source>Subdirectory containing exported snapshots</source>
          <target state="translated">내 보낸 스냅 샷을 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="8bdfd44b37f080168bf3c2a5ca216902fe87759b" translate="yes" xml:space="preserve">
          <source>Subdirectory containing files used by the dynamic shared memory subsystem</source>
          <target state="translated">동적 공유 메모리 서브 시스템이 사용하는 파일을 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="615426fd5dcf651fe31db934a317b3b733da2830" translate="yes" xml:space="preserve">
          <source>Subdirectory containing information about committed serializable transactions</source>
          <target state="translated">커미트 된 직렬화 가능 트랜잭션에 대한 정보를 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="a0095b6078ce59f34b1f3a6e759fee029b884ff4" translate="yes" xml:space="preserve">
          <source>Subdirectory containing multitransaction status data (used for shared row locks)</source>
          <target state="translated">다중 트랜잭션 상태 데이터를 포함하는 서브 디렉토리 (공유 행 잠금에 사용됨)</target>
        </trans-unit>
        <trans-unit id="41b7ca7920179bef8a936cd99c4381823fa4d70a" translate="yes" xml:space="preserve">
          <source>Subdirectory containing per-database subdirectories</source>
          <target state="translated">데이터베이스 별 서브 디렉토리를 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="07685c92aee0d33ccc687f0b3d628e6648475d00" translate="yes" xml:space="preserve">
          <source>Subdirectory containing permanent files for the statistics subsystem</source>
          <target state="translated">통계 서브 시스템에 대한 영구 파일을 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="f617420f37be4b29fbeee049c893d0753374f30e" translate="yes" xml:space="preserve">
          <source>Subdirectory containing replication slot data</source>
          <target state="translated">복제 슬롯 데이터를 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="a8f078f4d0a0ac23a7514126c75d3c9414a3bbb1" translate="yes" xml:space="preserve">
          <source>Subdirectory containing state files for prepared transactions</source>
          <target state="translated">준비된 트랜잭션에 대한 상태 파일을 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="3148ceec771e620567efc7945f22e12038e27aa2" translate="yes" xml:space="preserve">
          <source>Subdirectory containing status data for logical decoding</source>
          <target state="translated">논리적 디코딩을위한 상태 데이터가 포함 된 하위 디렉토리</target>
        </trans-unit>
        <trans-unit id="7ab90255f23bae0ba807576875e7dc4d82bb9429" translate="yes" xml:space="preserve">
          <source>Subdirectory containing subtransaction status data</source>
          <target state="translated">서브 트랜잭션 상태 데이터를 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="6d4dfa7c8bc498c10fef2eb0f92eb7aad8d619f8" translate="yes" xml:space="preserve">
          <source>Subdirectory containing symbolic links to tablespaces</source>
          <target state="translated">테이블 스페이스에 대한 기호 링크가 포함 된 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="e0827a9bd56a24bb726396eefa93e0826891b832" translate="yes" xml:space="preserve">
          <source>Subdirectory containing temporary files for the statistics subsystem</source>
          <target state="translated">통계 서브 시스템에 대한 임시 파일을 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="87aea01fb35180706b21f3a679b7c11688dfd769" translate="yes" xml:space="preserve">
          <source>Subdirectory containing transaction commit status data</source>
          <target state="translated">트랜잭션 커밋 상태 데이터를 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="5c78f4628d828278bdda9c2ef98b257aef112c34" translate="yes" xml:space="preserve">
          <source>Subdirectory containing transaction commit timestamp data</source>
          <target state="translated">트랜잭션 커밋 타임 스탬프 데이터를 포함하는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="68c8981332b80b6d3a0c198d919193dc81d563d9" translate="yes" xml:space="preserve">
          <source>Subqueries appearing in &lt;code&gt;FROM&lt;/code&gt; can be preceded by the key word &lt;code&gt;LATERAL&lt;/code&gt;. This allows them to reference columns provided by preceding &lt;code&gt;FROM&lt;/code&gt; items. (Without &lt;code&gt;LATERAL&lt;/code&gt;, each subquery is evaluated independently and so cannot cross-reference any other &lt;code&gt;FROM&lt;/code&gt; item.)</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 에 나타나는 서브 쿼리 앞에는 키워드 &lt;code&gt;LATERAL&lt;/code&gt; 이 올 수 있습니다. 이를 통해 이전 &lt;code&gt;FROM&lt;/code&gt; 항목 에서 제공 한 열을 참조 할 수 있습니다 . &lt;code&gt;LATERAL&lt;/code&gt; 이 없으면 각 하위 쿼리가 독립적으로 평가되므로 다른 &lt;code&gt;FROM&lt;/code&gt; 항목을 상호 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7db234704226a9776beb0bf3cb66e720657a4e43" translate="yes" xml:space="preserve">
          <source>Subqueries specifying a derived table must be enclosed in parentheses and &lt;em&gt;must&lt;/em&gt; be assigned a table alias name (as in &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;). For example:</source>
          <target state="translated">파생 테이블을 지정하는 서브 쿼리는 괄호로 묶어야 하며 테이블 별명 ( &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;7.2.1.2 절 참조&lt;/a&gt; )을 지정 &lt;em&gt;해야합니다&lt;/em&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79095639cf2544d3073712b3f47816fbf8b20418" translate="yes" xml:space="preserve">
          <source>Subquery Expressions</source>
          <target state="translated">하위 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="865463737c8f48f3aa72b7ead5718dd92da8c241" translate="yes" xml:space="preserve">
          <source>Subquery Expressions: ALL</source>
          <target state="translated">하위 쿼리 표현식 : ALL</target>
        </trans-unit>
        <trans-unit id="15cf22f4ca2cbad1f0895430a1a93780f8359cb3" translate="yes" xml:space="preserve">
          <source>Subquery Expressions: ANY/SOME</source>
          <target state="translated">하위 쿼리 표현식 : ANY / SOME</target>
        </trans-unit>
        <trans-unit id="c017020b157f38ba5f0e4c7163f775e551ef827a" translate="yes" xml:space="preserve">
          <source>Subquery Expressions: EXISTS</source>
          <target state="translated">하위 쿼리 표현식 : EXISTS</target>
        </trans-unit>
        <trans-unit id="c5d20d3534f81573891e1bb1440033e16b160a70" translate="yes" xml:space="preserve">
          <source>Subquery Expressions: IN</source>
          <target state="translated">하위 쿼리 표현식 : IN</target>
        </trans-unit>
        <trans-unit id="fc3da9daaefdef4d7d55570f631f82eddc3c8167" translate="yes" xml:space="preserve">
          <source>Subquery Expressions: NOT IN</source>
          <target state="translated">하위 쿼리 표현식 : NOT IN</target>
        </trans-unit>
        <trans-unit id="58383774b869790a897e575b16df98f07aba9c48" translate="yes" xml:space="preserve">
          <source>Subscripted assignment allows creation of arrays that do not use one-based subscripts. For example one might assign to &lt;code&gt;myarray[-2:7]&lt;/code&gt; to create an array with subscript values from -2 to 7.</source>
          <target state="translated">첨자 할당을 통해 1 기반 첨자를 사용하지 않는 배열을 만들 수 있습니다. 예를 들어 &lt;code&gt;myarray[-2:7]&lt;/code&gt; 에 할당하여 첨자 값이 -2에서 7 사이 인 배열을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fde48f31aff21f9652066ed6732f7e7dbae712e" translate="yes" xml:space="preserve">
          <source>Subscription</source>
          <target state="translated">Subscription</target>
        </trans-unit>
        <trans-unit id="6bd8bbcdd16d7fa73a1576bac730dc40d904ca8c" translate="yes" xml:space="preserve">
          <source>Subscription: Replication Slot Management</source>
          <target state="translated">구독 : 복제 슬롯 관리</target>
        </trans-unit>
        <trans-unit id="da9aa9c218887f9328a3617679a0129e7cbb5be2" translate="yes" xml:space="preserve">
          <source>Subscriptions are dumped by &lt;code&gt;pg_dump&lt;/code&gt; if the current user is a superuser. Otherwise a warning is written and subscriptions are skipped, because non-superusers cannot read all subscription information from the &lt;code&gt;pg_subscription&lt;/code&gt; catalog.</source>
          <target state="translated">현재 사용자가 수퍼 유저 인 경우 &lt;code&gt;pg_dump&lt;/code&gt; 가 구독을 덤프합니다 . 그렇지 않으면 수퍼 유저가 아닌 사용자가 &lt;code&gt;pg_subscription&lt;/code&gt; 카탈로그 에서 모든 구독 정보를 읽을 수 없으므로 경고가 작성되고 구독이 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="890d07dfb730a94c948bf494aa3c454b09068aea" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from a date</source>
          <target state="translated">Subtract a number of days from a date</target>
        </trans-unit>
        <trans-unit id="b79da3e7d531f1a5c659f5d86dd1fa7614c19e8c" translate="yes" xml:space="preserve">
          <source>Subtract an interval from a date</source>
          <target state="translated">Subtract an interval from a date</target>
        </trans-unit>
        <trans-unit id="ee247c59fd00eb6e88694b48e90b69f248bb3d69" translate="yes" xml:space="preserve">
          <source>Subtract an interval from a time</source>
          <target state="translated">Subtract an interval from a time</target>
        </trans-unit>
        <trans-unit id="492ab4dfc3f7dd0a6ea5351217bf1d3c1417da17" translate="yes" xml:space="preserve">
          <source>Subtract an interval from a timestamp</source>
          <target state="translated">Subtract an interval from a timestamp</target>
        </trans-unit>
        <trans-unit id="d28fc5630d7cdabec8ea351d50deb0f34ca2e89f" translate="yes" xml:space="preserve">
          <source>Subtract argument from &lt;code id=&quot;current_date&quot;&gt;current_date&lt;/code&gt; (at midnight)</source>
          <target state="translated">Subtract argument from &lt;code id=&quot;current_date&quot;&gt;current_date&lt;/code&gt; (at midnight)</target>
        </trans-unit>
        <trans-unit id="3e46e65b130ddf6c45bb58587fb22e20b60add00" translate="yes" xml:space="preserve">
          <source>Subtract arguments, producing a &amp;ldquo;symbolic&amp;rdquo; result that uses years and months, rather than just days</source>
          <target state="translated">인수를 빼고 며칠이 아닌 몇 년과 몇 달을 사용하는 &quot;기호&quot;결과를 생성</target>
        </trans-unit>
        <trans-unit id="6e12870b99286e1127827cc558899707b25f3271" translate="yes" xml:space="preserve">
          <source>Subtract dates, producing the number of days elapsed</source>
          <target state="translated">Subtract dates, producing the number of days elapsed</target>
        </trans-unit>
        <trans-unit id="c58db93176082206cc39b7b8d58fe9dcbb23b005" translate="yes" xml:space="preserve">
          <source>Subtract from &lt;code&gt;current_date&lt;/code&gt; (at midnight)</source>
          <target state="translated">&lt;code&gt;current_date&lt;/code&gt; 에서 빼기 (자정)</target>
        </trans-unit>
        <trans-unit id="4b426e7ec352450879798ecf5daf6f55fc661fca" translate="yes" xml:space="preserve">
          <source>Subtract intervals</source>
          <target state="translated">Subtract intervals</target>
        </trans-unit>
        <trans-unit id="9490dcbcc89cb0e6ae51baf890cc7d196be7cf64" translate="yes" xml:space="preserve">
          <source>Subtract times</source>
          <target state="translated">Subtract times</target>
        </trans-unit>
        <trans-unit id="205722f3601c28fa9b9e01598123f312ee869388" translate="yes" xml:space="preserve">
          <source>Subtract timestamps (converting 24-hour intervals into days, similarly to &lt;code id=&quot;justify_hours&quot;&gt;justify_hours()&lt;/code&gt;)</source>
          <target state="translated">Subtract timestamps (converting 24-hour intervals into days, similarly to &lt;code id=&quot;justify_hours&quot;&gt;justify_hours()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a5b58ce4dec6fe8562096a10da3109ac06c55815" translate="yes" xml:space="preserve">
          <source>Subtraction</source>
          <target state="translated">Subtraction</target>
        </trans-unit>
        <trans-unit id="261d18c0b4b2750e4f05fa67d0ffcf4b1d96ec6c" translate="yes" xml:space="preserve">
          <source>Subtraction of dates and timestamps can also be complex. One conceptually simple way to perform subtraction is to convert each value to a number of seconds using &lt;code&gt;EXTRACT(EPOCH FROM ...)&lt;/code&gt;, then subtract the results; this produces the number of &lt;em&gt;seconds&lt;/em&gt; between the two values. This will adjust for the number of days in each month, timezone changes, and daylight saving time adjustments. Subtraction of date or timestamp values with the &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; operator returns the number of days (24-hours) and hours/minutes/seconds between the values, making the same adjustments. The &lt;code&gt;age&lt;/code&gt; function returns years, months, days, and hours/minutes/seconds, performing field-by-field subtraction and then adjusting for negative field values. The following queries illustrate the differences in these approaches. The sample results were produced with &lt;code&gt;timezone = 'US/Eastern'&lt;/code&gt;; there is a daylight saving time change between the two dates used:</source>
          <target state="translated">날짜와 타임 스탬프를 빼는 것도 복잡 할 수 있습니다. 빼기를 수행하는 개념적으로 간단한 방법 중 하나는 &lt;code&gt;EXTRACT(EPOCH FROM ...)&lt;/code&gt; 사용하여 각 값을 초 단위로 변환 한 다음 결과를 빼는 것입니다. 두 값 사이 의 &lt;em&gt;시간 (초)을&lt;/em&gt; 생성 합니다. 매월 일수, 시간대 변경 및 일광 절약 시간제 조정에 따라 조정됩니다. &quot; &lt;code&gt;-&lt;/code&gt; &quot;연산자를 사용하여 날짜 또는 타임 스탬프 값을 빼면 값 사이 의 일 수 (24 시간) 및시 / 분 / 초를 반환하여 동일한 조정을 수행합니다. &lt;code&gt;age&lt;/code&gt; 이 함수는 년, 월, 일 및시 / 분 / 초를 반환하여 필드 별 빼기를 수행 한 다음 음의 필드 값을 조정합니다. 다음 쿼리는 이러한 접근 방식의 차이점을 보여줍니다. 샘플 결과는 &lt;code&gt;timezone = 'US/Eastern'&lt;/code&gt; ; 사용 된 두 날짜 사이에 일광 절약 시간 제가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="673c6f4156d27c4c89ab51b23b1b7623e9d51ba4" translate="yes" xml:space="preserve">
          <source>Subtracts an offset from an address.</source>
          <target state="translated">Subtracts an offset from an address.</target>
        </trans-unit>
        <trans-unit id="6c18ba2488b7e7610ab1075bb6b6808cda0db8b1" translate="yes" xml:space="preserve">
          <source>Subtracts the coordinates of the second &lt;code&gt;point&lt;/code&gt; from those of each point of the first argument, thus performing translation. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">Subtracts the coordinates of the second &lt;code&gt;point&lt;/code&gt; from those of each point of the first argument, thus performing translation. Available for &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cd3bf3468e45ca6cf9ed3820e774557f6bab5f2" translate="yes" xml:space="preserve">
          <source>Such a lexeme will match any word in a &lt;code&gt;tsvector&lt;/code&gt; that begins with the given string.</source>
          <target state="translated">이러한 &lt;code&gt;tsvector&lt;/code&gt; 은 주어진 문자열로 시작 하는 tsvector의 모든 단어와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="1a6935cbd548c7cb1356258dec56c7d7c9c9daed" translate="yes" xml:space="preserve">
          <source>Summarizes the page range covering the given block, if not already summarized. This is like &lt;code&gt;brin_summarize_new_values&lt;/code&gt; except that it only processes the page range that covers the given table block number.</source>
          <target state="translated">Summarizes the page range covering the given block, if not already summarized. This is like &lt;code&gt;brin_summarize_new_values&lt;/code&gt; except that it only processes the page range that covers the given table block number.</target>
        </trans-unit>
        <trans-unit id="1043eba8f9ff7610fb3b54c0e6654ab5f20a1891" translate="yes" xml:space="preserve">
          <source>Summing all the MCFs also tells us that the total fraction of the population represented by MCVs is 0.03033333, and therefore the fraction represented by the histogram is 0.96966667 (again, there are no nulls, else we'd have to exclude them here). We can see that the value &lt;code&gt;IAAAAA&lt;/code&gt; falls nearly at the end of the third histogram bucket. Using some rather cheesy assumptions about the frequency of different characters, the planner arrives at the estimate 0.298387 for the portion of the histogram population that is less than &lt;code&gt;IAAAAA&lt;/code&gt;. We then combine the estimates for the MCV and non-MCV populations:</source>
          <target state="translated">모든 MCF를 합하면 MCV로 표시되는 모집단의 총 분수는 0.03033333이므로 히스토그램으로 표시되는 분수는 0.96966667입니다 (다시 null이 없으므로 여기에서 제외해야 함). 우리는 &lt;code&gt;IAAAAA&lt;/code&gt; 의 가치 가 세 번째 막대 그래프 버킷의 끝에 거의 도달 함을 알 수 있습니다 . 다른 문자의 빈도에 대한 다소 건전한 가정을 사용하여 플래너는 &lt;code&gt;IAAAAA&lt;/code&gt; 미만의 히스토그램 모집단 부분에 대한 추정치 0.298387에 도달합니다 . 그런 다음 MCV 및 비 MCV 인구에 대한 추정치를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="48c98cab7866e606328c99289ed24e339393b5ab" translate="yes" xml:space="preserve">
          <source>Sun</source>
          <target state="translated">Sun</target>
        </trans-unit>
        <trans-unit id="bc5dd045b8623ddfc4bd0bce98ca5fda42accf88" translate="yes" xml:space="preserve">
          <source>Sunday</source>
          <target state="translated">Sunday</target>
        </trans-unit>
        <trans-unit id="3ad9b8785bd7100cb2f2075a0f7f1d0ef3e93c82" translate="yes" xml:space="preserve">
          <source>Superusers and roles with the &lt;code&gt;BYPASSRLS&lt;/code&gt; attribute always bypass the row security system when accessing a table. Table owners normally bypass row security as well, though a table owner can choose to be subject to row security with &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... FORCE ROW LEVEL SECURITY&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;BYPASSRLS&lt;/code&gt; 속성을 가진 수퍼 유저 및 역할 은 테이블에 액세스 할 때 항상 행 보안 시스템을 무시합니다. 테이블 소유자는 일반적으로 행 보안도 무시하지만 테이블 소유자는 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... FORCE ROW LEVEL SECURITY를 사용&lt;/a&gt; 하여 행 보안에 종속되도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6deb2217407c0e1d3336da76af2dc83750a3a56b" translate="yes" xml:space="preserve">
          <source>Superusers can always do this; ordinary roles can only do it if they are both the current owner of the object (or a member of the owning role) and a member of the new owning role.</source>
          <target state="translated">수퍼 유저는 항상이 작업을 수행 할 수 있습니다. 일반 역할은 개체의 현재 소유자 (또는 소유 역할의 구성원)와 새로운 소유 역할의 구성원 인 경우에만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0411114a21b2adee414a179957a9d8346298b4ae" translate="yes" xml:space="preserve">
          <source>Superusers can change anyone's session defaults. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change defaults for non-superuser roles. Ordinary roles can only set defaults for themselves. Certain configuration variables cannot be set this way, or can only be set if a superuser issues the command. Only superusers can change a setting for all roles in all databases.</source>
          <target state="translated">수퍼 유저는 모든 사람의 세션 기본값을 변경할 수 있습니다. &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이있는 역할 은 비 수퍼 유저 역할의 기본값을 변경할 수 있습니다. 일반 역할은 자체 기본값 만 설정할 수 있습니다. 특정 구성 변수는이 방법으로 설정할 수 없거나 수퍼 유저가 명령을 실행하는 경우에만 설정할 수 있습니다. 수퍼 유저 만 모든 데이터베이스의 모든 역할에 대한 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="907d5da367c5a63245a4ae868a4e7fce2c1b083e" translate="yes" xml:space="preserve">
          <source>Support Function 1</source>
          <target state="translated">지원 기능 1</target>
        </trans-unit>
        <trans-unit id="c09a79dec1db562eebf88cf47ed5a50fffedd9e4" translate="yes" xml:space="preserve">
          <source>Support Function 11</source>
          <target state="translated">지원 기능 11</target>
        </trans-unit>
        <trans-unit id="e289451a2ca3c0a7d252b9c2f70b294939ca7fdf" translate="yes" xml:space="preserve">
          <source>Support Function 12</source>
          <target state="translated">지원 기능 12</target>
        </trans-unit>
        <trans-unit id="6e499bf4c9c754bc1732d472a2aa6eff27a07bfb" translate="yes" xml:space="preserve">
          <source>Support Function 13</source>
          <target state="translated">지원 기능 13</target>
        </trans-unit>
        <trans-unit id="6dd1a8a6ee876d24035ef10ce2bfecdddd7f7a41" translate="yes" xml:space="preserve">
          <source>Support Function 14</source>
          <target state="translated">지원 기능 14</target>
        </trans-unit>
        <trans-unit id="9b3de44d2e9117e957e8ac0601aa782ff399a546" translate="yes" xml:space="preserve">
          <source>Support Function 2</source>
          <target state="translated">지원 기능 2</target>
        </trans-unit>
        <trans-unit id="ffa11ff7190ca0ad79e4d11f9554144f18dc96d8" translate="yes" xml:space="preserve">
          <source>Support Function 3</source>
          <target state="translated">지원 기능 3</target>
        </trans-unit>
        <trans-unit id="0502f4f0b227a6c4f29087521fc1969d1920005d" translate="yes" xml:space="preserve">
          <source>Support Function 4</source>
          <target state="translated">지원 기능 4</target>
        </trans-unit>
        <trans-unit id="3dcaacf100fc2260b3c94d206bc162395874e56e" translate="yes" xml:space="preserve">
          <source>Support for the Serializable transaction isolation level has not yet been added to Hot Standby replication targets (described in &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;). The strictest isolation level currently supported in hot standby mode is Repeatable Read. While performing all permanent database writes within Serializable transactions on the master will ensure that all standbys will eventually reach a consistent state, a Repeatable Read transaction run on the standby can sometimes see a transient state that is inconsistent with any serial execution of the transactions on the master.</source>
          <target state="translated">직렬화 가능 트랜잭션 분리 레벨에 대한 지원이 아직 핫 스탠바이 복제 대상에 추가되지 않았습니다 ( &lt;a href=&quot;hot-standby&quot;&gt;26.5 절 참조&lt;/a&gt; ). 핫 대기 모드에서 현재 지원되는 가장 엄격한 격리 수준은 반복 읽기입니다. 마스터의 직렬화 가능 트랜잭션 내에서 모든 영구 데이터베이스 쓰기를 수행하면 모든 대기가 결국 일관된 상태에 도달 할 수 있지만 대기에서 반복 가능한 읽기 트랜잭션은 때때로 트랜잭션의 직렬 실행과 일치하지 않는 일시적인 상태를 볼 수 있습니다. 석사.</target>
        </trans-unit>
        <trans-unit id="5a34c45df15d10c301e2f85c149cf52752fba00f" translate="yes" xml:space="preserve">
          <source>Support function number</source>
          <target state="translated">지원 기능 번호</target>
        </trans-unit>
        <trans-unit id="9a9e38e1eb6e54775a61ad2f54c8b43392351a84" translate="yes" xml:space="preserve">
          <source>Support function numbers 1 through 10 are reserved for the BRIN internal functions, so the SQL level functions start with number 11. Support function number 11 is the main function required to build the index. It should accept two arguments with the same data type as the operator class, and return the union of them. The inclusion operator class can store union values with different data types if it is defined with the &lt;code&gt;STORAGE&lt;/code&gt; parameter. The return value of the union function should match the &lt;code&gt;STORAGE&lt;/code&gt; data type.</source>
          <target state="translated">Support function numbers 1 through 10 are reserved for the BRIN internal functions, so the SQL level functions start with number 11. Support function number 11 is the main function required to build the index. It should accept two arguments with the same data type as the operator class, and return the union of them. The inclusion operator class can store union values with different data types if it is defined with the &lt;code&gt;STORAGE&lt;/code&gt; parameter. The return value of the union function should match the &lt;code&gt;STORAGE&lt;/code&gt; data type.</target>
        </trans-unit>
        <trans-unit id="c71068037e94d8332b7ce5c2f143ba8f4ab078f9" translate="yes" xml:space="preserve">
          <source>Support function numbers 1-10 are reserved for the BRIN internal functions, so the SQL level functions start with number 11. Support function number 11 is the main function required to build the index. It should accept two arguments with the same data type as the operator class, and return the union of them. The inclusion operator class can store union values with different data types if it is defined with the &lt;code&gt;STORAGE&lt;/code&gt; parameter. The return value of the union function should match the &lt;code&gt;STORAGE&lt;/code&gt; data type.</source>
          <target state="translated">지원 기능 번호 1-10은 BRIN 내부 기능 용으로 예약되어 있으므로 SQL 레벨 기능은 번호 11로 시작합니다. 지원 기능 번호 11은 색인을 빌드하는 데 필요한 주요 기능입니다. 연산자 클래스와 동일한 데이터 유형을 가진 두 개의 인수를 허용하고 이들의 합집합을 리턴해야합니다. 포함 연산자 클래스는 &lt;code&gt;STORAGE&lt;/code&gt; 매개 변수로 정의 된 경우 다른 데이터 유형의 통합 값을 저장할 수 있습니다 . 공용체 함수의 반환 값은 &lt;code&gt;STORAGE&lt;/code&gt; 데이터 형식 과 일치해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d45258be3e9e702ac9f50d65ef6c8b5aed0bc52f" translate="yes" xml:space="preserve">
          <source>Support function numbers 12 and 14 are provided to support irregularities of built-in data types. Function number 12 is used to support network addresses from different families which are not mergeable. Function number 14 is used to support empty ranges. Function number 13 is an optional but recommended one, which allows the new value to be checked before it is passed to the union function. As the BRIN framework can shortcut some operations when the union is not changed, using this function can improve index performance.</source>
          <target state="translated">내장 기능 유형의 불규칙성을 지원하기 위해 지원 기능 번호 12 및 14가 제공됩니다. 기능 번호 12는 병합 할 수없는 다른 제품군의 네트워크 주소를 지원하는 데 사용됩니다. 기능 번호 14는 빈 범위를 지원하는 데 사용됩니다. 기능 번호 13은 선택적이지만 권장되는 기능으로, 결합 함수에 전달되기 전에 새 값을 확인할 수 있습니다. 결합이 변경되지 않은 경우 BRIN 프레임 워크가 일부 조작을 단축 할 수 있으므로이 기능을 사용하면 색인 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2911475300ce27b8f1eb080e67fbdccac2de1ab" translate="yes" xml:space="preserve">
          <source>Suppose that serializable transaction A computes:</source>
          <target state="translated">직렬화 가능 트랜잭션 A가 다음을 계산한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1d3ef7f8d989a7e48b2c7f32f9ea47b48c699018" translate="yes" xml:space="preserve">
          <source>Suppose that we have a table describing test outcomes. We wish to ensure that there is only one &amp;ldquo;successful&amp;rdquo; entry for a given subject and target combination, but there might be any number of &amp;ldquo;unsuccessful&amp;rdquo; entries. Here is one way to do it:</source>
          <target state="translated">테스트 결과를 설명하는 테이블이 있다고 가정하십시오. 특정 주제와 대상 조합에 대해 &quot;성공적인&quot;항목이 하나만 있는지 확인하고 싶지만 &quot;성공하지 않은&quot;항목이있을 수 있습니다. 이를 수행하는 한 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="743788628689e4987318bbca2c91f416661423f7" translate="yes" xml:space="preserve">
          <source>Suppose we are constructing a database for a large ice cream company. The company measures peak temperatures every day as well as ice cream sales in each region. Conceptually, we want a table like:</source>
          <target state="translated">대형 아이스크림 회사를위한 데이터베이스를 구축한다고 가정합니다. 이 회사는 매일 최고 기온과 각 지역의 아이스크림 판매량을 측정합니다. 개념적으로 우리는 다음과 같은 테이블을 원합니다.</target>
        </trans-unit>
        <trans-unit id="9c17bab107c29b94c45b210bc2f14582c7b152c8" translate="yes" xml:space="preserve">
          <source>Suppose we have a table similar to this:</source>
          <target state="translated">다음과 비슷한 테이블이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="16819758c26018bf3c1d17e9c0b3ce89d560555f" translate="yes" xml:space="preserve">
          <source>Suppose you are storing web server access logs in a database. Most accesses originate from the IP address range of your organization but some are from elsewhere (say, employees on dial-up connections). If your searches by IP are primarily for outside accesses, you probably do not need to index the IP range that corresponds to your organization's subnet.</source>
          <target state="translated">웹 서버 액세스 로그를 데이터베이스에 저장한다고 가정하십시오. 대부분의 액세스는 조직의 IP 주소 범위에서 시작되지만 일부는 다른 곳 (예 : 전화 접속 연결 직원)에서 비롯됩니다. IP로 검색하는 것이 주로 외부 액세스 용인 경우 조직의 서브넷에 해당하는 IP 범위를 색인화하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="24d33aa7e53f5a8d8f6233a97b9c7afcbc1aa556" translate="yes" xml:space="preserve">
          <source>Suppose you would like to retrieve all heart rate values higher than 130. You can achieve this using the following expression:</source>
          <target state="translated">130보다 높은 모든 심박수 값을 검색하려고한다고 가정합니다. 다음 표현식을 사용하여이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3719258182047c4866cd7f147c47d8ce35d7566" translate="yes" xml:space="preserve">
          <source>Switch logging to quiet mode, producing only one progress message per 5 seconds. The default logging prints one message each 100,000 rows, which often outputs many lines per second (especially on good hardware).</source>
          <target state="translated">Switch logging to quiet mode, producing only one progress message per 5 seconds. The default logging prints one message each 100,000 rows, which often outputs many lines per second (especially on good hardware).</target>
        </trans-unit>
        <trans-unit id="f6445090a76897a243b8e1150cca3fa90d4b4ea2" translate="yes" xml:space="preserve">
          <source>Switch logging to quiet mode, producing only one progress message per 5 seconds. The default logging prints one message each 100000 rows, which often outputs many lines per second (especially on good hardware).</source>
          <target state="translated">로깅을 자동 모드로 전환하여 5 초마다 하나의 진행 메시지 만 생성합니다. 기본 로깅은 100000 행마다 하나의 메시지를 인쇄하며, 종종 초당 많은 행을 출력합니다 (특히 좋은 하드웨어에서).</target>
        </trans-unit>
        <trans-unit id="c8ea092a85e78ead8510d85f0c0625a34098858d" translate="yes" xml:space="preserve">
          <source>Switches the client domain of the current session to the new domain, if allowed by the security policy. It also accepts &lt;code&gt;NULL&lt;/code&gt; input as a request to transition to the client's original domain.</source>
          <target state="translated">보안 정책에서 허용하는 경우 현재 세션의 클라이언트 도메인을 새 도메인으로 전환합니다. 또한 클라이언트의 원래 도메인으로의 전환 요청으로 &lt;code&gt;NULL&lt;/code&gt; 입력을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="0e134a3fef6d0efac5eb5fe4519866d39ea80626" translate="yes" xml:space="preserve">
          <source>Switches to CSV (Comma-Separated Values) output mode. This is equivalent to &lt;code&gt;\pset format csv&lt;/code&gt;.</source>
          <target state="translated">CSV (쉼표로 구분 된 값) 출력 모드로 전환합니다. 이것은 &lt;code&gt;\pset format csv&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8943c0c7bb99f3a140162be87988c24e474f51aa" translate="yes" xml:space="preserve">
          <source>Switches to HTML output mode. This is equivalent to &lt;code&gt;\pset format html&lt;/code&gt; or the &lt;code&gt;\H&lt;/code&gt; command.</source>
          <target state="translated">HTML 출력 모드로 전환합니다. 이것은 &lt;code&gt;\pset format html&lt;/code&gt; 또는 &lt;code&gt;\H&lt;/code&gt; 명령과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c3f20d915a881ae7826ce8ed053822eb7ce2474" translate="yes" xml:space="preserve">
          <source>Switches to unaligned output mode. (The default output mode is &lt;code&gt;aligned&lt;/code&gt;.) This is equivalent to &lt;code&gt;\pset format unaligned&lt;/code&gt;.</source>
          <target state="translated">정렬되지 않은 출력 모드로 전환합니다. (기본 출력 모드는 &lt;code&gt;aligned&lt;/code&gt; 됩니다.) 이것은 &lt;code&gt;\pset format unaligned&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b71d31ce4c760fe3d3b78e7888afa57cf5a0e790" translate="yes" xml:space="preserve">
          <source>Sync. MM Repl.</source>
          <target state="translated">Sync. MM Repl.</target>
        </trans-unit>
        <trans-unit id="ea7fb8a955cd05cbb91ab54291b192105baf0c5c" translate="yes" xml:space="preserve">
          <source>Synchronous Multimaster Replication</source>
          <target state="translated">동기식 멀티 마스터 복제</target>
        </trans-unit>
        <trans-unit id="f06e00390114030665dc1af3c2f2549eb2105197" translate="yes" xml:space="preserve">
          <source>Synchronous Replication Support for Logical Decoding</source>
          <target state="translated">논리적 디코딩을위한 동기식 복제 지원</target>
        </trans-unit>
        <trans-unit id="5150a9ed3cf5b7082e49cf1ed0e9473251eb5db8" translate="yes" xml:space="preserve">
          <source>Synchronous replication is affected by this setting when &lt;code&gt;synchronous_commit&lt;/code&gt; is set to &lt;code&gt;remote_apply&lt;/code&gt;; every &lt;code&gt;COMMIT&lt;/code&gt; will need to wait to be applied.</source>
          <target state="translated">&lt;code&gt;synchronous_commit&lt;/code&gt; 이 &lt;code&gt;remote_apply&lt;/code&gt; 로 설정된 경우 동기 복제는이 설정의 영향을받습니다 . 모든 &lt;code&gt;COMMIT&lt;/code&gt; 는 적용되기를 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="c97d5846effd0db2b8ba98590d3d030f3979ef66" translate="yes" xml:space="preserve">
          <source>Synchronous replication offers the ability to confirm that all changes made by a transaction have been transferred to one or more synchronous standby servers. This extends that standard level of durability offered by a transaction commit. This level of protection is referred to as 2-safe replication in computer science theory, and group-1-safe (group-safe and 1-safe) when &lt;code&gt;synchronous_commit&lt;/code&gt; is set to &lt;code&gt;remote_write&lt;/code&gt;.</source>
          <target state="translated">동기 복제는 트랜잭션에 의해 작성된 모든 변경 사항이 하나 이상의 동기 대기 서버로 전송되었음을 확인할 수있는 기능을 제공합니다. 이는 트랜잭션 커밋이 제공하는 표준 수준의 내구성을 확장합니다. 이 수준의 보호는 컴퓨터 과학 이론에서는 2 안전 복제, &lt;code&gt;synchronous_commit&lt;/code&gt; 가 &lt;code&gt;remote_write&lt;/code&gt; 로 설정된 경우 그룹 1 안전 (그룹 안전 및 1 안전) 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="66bca2f074a9298c6898a989342ad7914302532a" translate="yes" xml:space="preserve">
          <source>Synchronous replication supports one or more synchronous standby servers; transactions will wait until all the standby servers which are considered as synchronous confirm receipt of their data. The number of synchronous standbys that transactions must wait for replies from is specified in &lt;code&gt;synchronous_standby_names&lt;/code&gt;. This parameter also specifies a list of standby names and the method (&lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;ANY&lt;/code&gt;) to choose synchronous standbys from the listed ones.</source>
          <target state="translated">동기 복제는 하나 이상의 동기 대기 서버를 지원합니다. 트랜잭션은 동 기적으로 간주되는 모든 대기 서버가 데이터 수신을 확인할 때까지 대기합니다. 에 지정된 트랜잭션에서 응답을 기다려야 동기 대기 상태의 개수 &lt;code&gt;synchronous_standby_names&lt;/code&gt; . 이 매개 변수는 또한 대기 이름 목록과 메소드 ( &lt;code&gt;FIRST&lt;/code&gt; 및 &lt;code&gt;ANY&lt;/code&gt; )를 지정하여 나열된 대기 이름 중에서 동기 대기를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="1c522640864b910b21792b5bc2eb805600d4806b" translate="yes" xml:space="preserve">
          <source>Synchronous replication usually requires carefully planned and placed standby servers to ensure applications perform acceptably. Waiting doesn't utilize system resources, but transaction locks continue to be held until the transfer is confirmed. As a result, incautious use of synchronous replication will reduce performance for database applications because of increased response times and higher contention.</source>
          <target state="translated">동기식 복제에는 일반적으로 응용 프로그램이 제대로 작동하도록 신중하게 계획되고 배치 된 대기 서버가 필요합니다. 대기는 시스템 자원을 사용하지 않지만 전송이 확인 될 때까지 트랜잭션 잠금은 계속 유지됩니다. 결과적으로 동기식 복제를 신중하게 사용하면 응답 시간이 증가하고 경합이 높아 데이터베이스 응용 프로그램의 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="2478cf7ee16609d7975a8d9bd93f15e8f50d4ce2" translate="yes" xml:space="preserve">
          <source>Synchronous state of this standby server. Possible values are:</source>
          <target state="translated">이 대기 서버의 동기 상태입니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="8640af9a3dc13761ab85b5c7ca2e486a1bff3272" translate="yes" xml:space="preserve">
          <source>Syntactically, &lt;code&gt;VALUES&lt;/code&gt; followed by expression lists is treated as equivalent to:</source>
          <target state="translated">구문 적으로 &lt;code&gt;VALUES&lt;/code&gt; 와 표현식 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="7c0634da4e6af4287a5127e71efae066153473f8" translate="yes" xml:space="preserve">
          <source>Syslog produces its own time stamp and process ID information, so you probably do not want to include those escapes if you are logging to syslog.</source>
          <target state="translated">Syslog는 자체 타임 스탬프 및 프로세스 ID 정보를 생성하므로 syslog에 로깅하는 경우 해당 이스케이프를 포함하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3742a8ec467fb193f2ee267e5e63d3eff097899e" translate="yes" xml:space="preserve">
          <source>System Administration: brin_desummarize_range</source>
          <target state="translated">시스템 관리 : brin_desummarize_range</target>
        </trans-unit>
        <trans-unit id="8609026a801e5fb2121d1aec716dd82a16cbd2d0" translate="yes" xml:space="preserve">
          <source>System Administration: brin_summarize_new_values</source>
          <target state="translated">시스템 관리 : brin_summarize_new_values</target>
        </trans-unit>
        <trans-unit id="21507d85b46e69df7f2079ce7def51a1bdc6f1e4" translate="yes" xml:space="preserve">
          <source>System Administration: brin_summarize_range</source>
          <target state="translated">시스템 관리 : brin_summarize_range</target>
        </trans-unit>
        <trans-unit id="a0b5919b3586799e5bbe81dd56097fbd44d21700" translate="yes" xml:space="preserve">
          <source>System Administration: current_setting</source>
          <target state="translated">시스템 관리 : current_setting</target>
        </trans-unit>
        <trans-unit id="7d03ac06264d73c68d118eb864079985f90e236d" translate="yes" xml:space="preserve">
          <source>System Administration: gin_clean_pending_list</source>
          <target state="translated">시스템 관리 : gin_clean_pending_list</target>
        </trans-unit>
        <trans-unit id="2739cbcb48390647ec624ec982fb2288e6baf74b" translate="yes" xml:space="preserve">
          <source>System Administration: pg_advisory_lock</source>
          <target state="translated">시스템 관리 : pg_advisory_lock</target>
        </trans-unit>
        <trans-unit id="0bc9483742169da97eb30dcdfeac8a14ab9110fd" translate="yes" xml:space="preserve">
          <source>System Administration: pg_advisory_lock_shared</source>
          <target state="translated">시스템 관리 : pg_advisory_lock_shared</target>
        </trans-unit>
        <trans-unit id="5f75d3c108623cf5378b3df50e782f8a4334ae70" translate="yes" xml:space="preserve">
          <source>System Administration: pg_advisory_unlock</source>
          <target state="translated">시스템 관리 : pg_advisory_unlock</target>
        </trans-unit>
        <trans-unit id="cabd7c0b5ec00e80c0561bff572d8734082b2f00" translate="yes" xml:space="preserve">
          <source>System Administration: pg_advisory_unlock_all</source>
          <target state="translated">시스템 관리 : pg_advisory_unlock_all</target>
        </trans-unit>
        <trans-unit id="dc53d4aea3e0cfdd3f1083de38dc090fc5cd7afd" translate="yes" xml:space="preserve">
          <source>System Administration: pg_advisory_unlock_shared</source>
          <target state="translated">시스템 관리 : pg_advisory_unlock_shared</target>
        </trans-unit>
        <trans-unit id="322aca3ed836d89ef1b76f7d209ebf83fffd4819" translate="yes" xml:space="preserve">
          <source>System Administration: pg_advisory_xact_lock</source>
          <target state="translated">시스템 관리 : pg_advisory_xact_lock</target>
        </trans-unit>
        <trans-unit id="a28ba37e4bc36f5d13923165e168cf868882a572" translate="yes" xml:space="preserve">
          <source>System Administration: pg_advisory_xact_lock_shared</source>
          <target state="translated">시스템 관리 : pg_advisory_xact_lock_shared</target>
        </trans-unit>
        <trans-unit id="804ce31f5f308f107defd28906838bd25c93a0cf" translate="yes" xml:space="preserve">
          <source>System Administration: pg_backup_start_time</source>
          <target state="translated">시스템 관리 : pg_backup_start_time</target>
        </trans-unit>
        <trans-unit id="4193c54c93e4febcca92e2353273e506660ca05b" translate="yes" xml:space="preserve">
          <source>System Administration: pg_cancel_backend</source>
          <target state="translated">시스템 관리 : pg_cancel_backend</target>
        </trans-unit>
        <trans-unit id="1327b28b502addd6ef41a8f71b2affd51f08c0d5" translate="yes" xml:space="preserve">
          <source>System Administration: pg_collation_actual_version</source>
          <target state="translated">시스템 관리 : pg_collation_actual_version</target>
        </trans-unit>
        <trans-unit id="2fd71627b5e14eb04ed034b8e279c05c0560a894" translate="yes" xml:space="preserve">
          <source>System Administration: pg_column_size</source>
          <target state="translated">시스템 관리 : pg_column_size</target>
        </trans-unit>
        <trans-unit id="f857a2541b412446e744e27c114cd45c8ec060a6" translate="yes" xml:space="preserve">
          <source>System Administration: pg_copy_logical_replication_slot</source>
          <target state="translated">시스템 관리 : pg_copy_logical_replication_slot</target>
        </trans-unit>
        <trans-unit id="0de0bf071518c2d9437fc2e810f4fa5c7152c73b" translate="yes" xml:space="preserve">
          <source>System Administration: pg_copy_physical_replication_slot</source>
          <target state="translated">시스템 관리 : pg_copy_physical_replication_slot</target>
        </trans-unit>
        <trans-unit id="ae9db85f3e5fdd8309a3acd0d3adea188faf2fc9" translate="yes" xml:space="preserve">
          <source>System Administration: pg_create_logical_replication_slot</source>
          <target state="translated">시스템 관리 : pg_create_logical_replication_slot</target>
        </trans-unit>
        <trans-unit id="c6e50a7392f862c302436243554d442f4f9fed28" translate="yes" xml:space="preserve">
          <source>System Administration: pg_create_physical_replication_slot</source>
          <target state="translated">시스템 관리 : pg_create_physical_replication_slot</target>
        </trans-unit>
        <trans-unit id="f7b608cbef53b149cf94b734d38705b91a5170e4" translate="yes" xml:space="preserve">
          <source>System Administration: pg_create_restore_point</source>
          <target state="translated">시스템 관리 : pg_create_restore_point</target>
        </trans-unit>
        <trans-unit id="ce7cc4fac3e26d1263f2baf1cc6d8da0b2e18819" translate="yes" xml:space="preserve">
          <source>System Administration: pg_current_wal_flush_lsn</source>
          <target state="translated">시스템 관리 : pg_current_wal_flush_lsn</target>
        </trans-unit>
        <trans-unit id="aa96f02417fbde2e1b263e762114beacd50839c1" translate="yes" xml:space="preserve">
          <source>System Administration: pg_current_wal_insert_lsn</source>
          <target state="translated">시스템 관리 : pg_current_wal_insert_lsn</target>
        </trans-unit>
        <trans-unit id="9b0bb86728fe6d96a7b83678c537d9274c86d30b" translate="yes" xml:space="preserve">
          <source>System Administration: pg_current_wal_lsn</source>
          <target state="translated">시스템 관리 : pg_current_wal_lsn</target>
        </trans-unit>
        <trans-unit id="02fa9a0c1fe28f912418e655c6245c7efd236d96" translate="yes" xml:space="preserve">
          <source>System Administration: pg_database_size</source>
          <target state="translated">시스템 관리 : pg_database_size</target>
        </trans-unit>
        <trans-unit id="51bc4cd7ad092a71be8a5612cd956b9d490a06b3" translate="yes" xml:space="preserve">
          <source>System Administration: pg_drop_replication_slot</source>
          <target state="translated">시스템 관리 : pg_drop_replication_slot</target>
        </trans-unit>
        <trans-unit id="9fd436a85573a7fbdb18104b12a6d9d73558bf32" translate="yes" xml:space="preserve">
          <source>System Administration: pg_export_snapshot</source>
          <target state="translated">시스템 관리 : pg_export_snapshot</target>
        </trans-unit>
        <trans-unit id="199c0e3932b71ac995be98b6f347644a3f291f10" translate="yes" xml:space="preserve">
          <source>System Administration: pg_filenode_relation</source>
          <target state="translated">시스템 관리 : pg_filenode_relation</target>
        </trans-unit>
        <trans-unit id="93b580ca294ae4123d3685c644a6eedbdeb040cc" translate="yes" xml:space="preserve">
          <source>System Administration: pg_import_system_collations</source>
          <target state="translated">시스템 관리 : pg_import_system_collations</target>
        </trans-unit>
        <trans-unit id="d7ccf31921dc4f7467eb31fcb5d9a785ca99b698" translate="yes" xml:space="preserve">
          <source>System Administration: pg_indexes_size</source>
          <target state="translated">시스템 관리 : pg_indexes_size</target>
        </trans-unit>
        <trans-unit id="380d728cdb809faf1d0b5120affe03cc353e8dfc" translate="yes" xml:space="preserve">
          <source>System Administration: pg_is_in_backup</source>
          <target state="translated">시스템 관리 : pg_is_in_backup</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
