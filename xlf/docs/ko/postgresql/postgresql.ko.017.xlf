<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="e1a2d424d05fad0ce8a503aad44ed8e2890ec86d" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt;pg_stat_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 테이블에 대해 하나의 행으로, 해당 특정 테이블에 대한 액세스에 대한 통계가 표시됩니다. 보다&lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt; pg_stat_all_tables&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abc0444614ec30e98f25afeab84f356db8f57c5c" translate="yes" xml:space="preserve">
          <source>One row for each tracked function, showing statistics about executions of that function. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;&lt;code&gt;pg_stat_user_functions&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">추적 된 각 함수에 대한 하나의 행으로 해당 함수 실행에 대한 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt; &lt;code&gt;pg_stat_user_functions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e4f1c454b46b07db5b5caff74a33b9a88d14f14" translate="yes" xml:space="preserve">
          <source>One row for each tracked function, showing statistics about executions of that function. See &lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;pg_stat_user_functions&lt;/a&gt; for details.</source>
          <target state="translated">추적 된 각 기능에 대해 한 행씩 해당 기능의 실행에 대한 통계를 표시합니다. &lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;pg_stat_user_functions를&lt;/a&gt; 참조하십시오 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9f68f712788d8659f6dc744778895e8637cccb9" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the WAL archiver process's activity. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ARCHIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_archiver&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">한 행만 표시되며 WAL 아카이버 프로세스의 활동에 대한 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ARCHIVER-VIEW&quot;&gt; &lt;code&gt;pg_stat_archiver&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a27e9764cf42abc447770a40b26ae4110256df1" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the WAL archiver process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt; for details.</source>
          <target state="translated">WAL 아카이버 프로세스의 활동에 대한 통계를 보여주는 한 행만. &lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7159edec345b30dd16d1cfb1cd64291c8e94cf0f" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the background writer process's activity. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-BGWRITER-VIEW&quot;&gt;&lt;code&gt;pg_stat_bgwriter&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">백그라운드 작성기 프로세스의 활동에 대한 통계를 표시하는 한 행만 있습니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-BGWRITER-VIEW&quot;&gt; &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08ff69da529511355514d8fad09917a768f3dfee" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the background writer process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt; for details.</source>
          <target state="translated">백그라운드 작성기 프로세스의 활동에 대한 통계를 보여주는 한 행만. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="60bbed9973e1e54e8a987346455e2156c0d06574" translate="yes" xml:space="preserve">
          <source>One row per SLRU, showing statistics of operations. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SLRU-VIEW&quot;&gt;&lt;code&gt;pg_stat_slru&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">SLRU 당 하나의 행으로 작업 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SLRU-VIEW&quot;&gt; &lt;code&gt;pg_stat_slru&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="246692679d62f964e577891f2766cf44cbec4578" translate="yes" xml:space="preserve">
          <source>One row per WAL sender process, showing statistics about replication to that sender's connected standby server. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">WAL 발신자 프로세스 당 하나의 행으로 해당 발신자의 연결된 대기 서버로의 복제에 대한 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt; &lt;code&gt;pg_stat_replication&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="41761c4e3d769b5a97047d2af3c904ca9b99e019" translate="yes" xml:space="preserve">
          <source>One row per WAL sender process, showing statistics about replication to that sender's connected standby server. See &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; for details.</source>
          <target state="translated">WAL 발신자 프로세스 당 하나의 행으로, 발신자의 연결된 대기 서버로의 복제에 대한 통계가 표시됩니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e405939a7164c82deba654b8915f184314fd703" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about GSSAPI authentication and encryption used on this connection. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-GSSAPI-VIEW&quot;&gt;&lt;code&gt;pg_stat_gssapi&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">연결 당 한 행 (일반 및 복제),이 연결에 사용 된 GSSAPI 인증 및 암호화에 대한 정보를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-GSSAPI-VIEW&quot;&gt; &lt;code&gt;pg_stat_gssapi&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="04eefccf9acdca920d874c55aed10830947f2ad0" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about GSSAPI authentication and encryption used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt; for details.</source>
          <target state="translated">연결 당 하나의 행 (정규 및 복제)으로이 연결에 사용 된 GSSAPI 인증 및 암호화에 대한 정보가 표시됩니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0c6ee7f9f33f1b8de0af5ed4f012017f5739968" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about SSL used on this connection. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SSL-VIEW&quot;&gt;&lt;code&gt;pg_stat_ssl&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">연결 당 하나의 행 (일반 및 복제),이 연결에 사용 된 SSL에 대한 정보를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SSL-VIEW&quot;&gt; &lt;code&gt;pg_stat_ssl&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff2500623059c396127b50986a7192b6dece4045" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about SSL used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt; for details.</source>
          <target state="translated">연결 당 하나의 행 (정규 및 복제)으로이 연결에 사용 된 SSL에 대한 정보가 표시됩니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01cc5c68a8fa3b32b1a1b5f70dba90054b794d9e" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics about query cancels due to conflict with recovery on standby servers. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">데이터베이스 당 하나의 행으로 대기 서버에서 복구와의 충돌로 인한 쿼리 취소에 대한 데이터베이스 전체 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt; &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e2bdd85f6f61ca9f60bf24ae4eb4fe127af69af" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics about query cancels due to conflict with recovery on standby servers. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.</source>
          <target state="translated">데이터베이스 당 하나의 행으로, 대기 서버 복구와의 충돌로 인한 쿼리 취소에 대한 데이터베이스 전체 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28e4559145d57da7a6239ef820ede5cd25bacf3c" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt;&lt;code&gt;pg_stat_database&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">데이터베이스 전체 통계를 표시하는 데이터베이스 당 하나의 행. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt; &lt;code&gt;pg_stat_database&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28ca9a3ad9c0527d7bf8067a93b52b4e199755b8" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; for details.</source>
          <target state="translated">데이터베이스 전체에 대한 통계를 보여주는 데이터베이스 당 하나의 행. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e295d72faf33e0deeaaee1f07b6d5d6544081e45" translate="yes" xml:space="preserve">
          <source>One row per server process, showing information related to the current activity of that process, such as state and current query. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">상태 및 현재 쿼리와 같은 해당 프로세스의 현재 활동과 관련된 정보를 표시하는 서버 프로세스 당 하나의 행입니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt; &lt;code&gt;pg_stat_activity&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="02ad092a9644445754a24d9ccf37920da6663d5c" translate="yes" xml:space="preserve">
          <source>One row per server process, showing information related to the current activity of that process, such as state and current query. See &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;pg_stat_activity&lt;/a&gt; for details.</source>
          <target state="translated">서버 프로세스 당 하나의 행으로 상태 및 현재 쿼리와 같은 해당 프로세스의 현재 활동과 관련된 정보를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;pg_stat_activity&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cd0d7184c558c048e1447f27b2e4a45d43e212a8" translate="yes" xml:space="preserve">
          <source>One semantically-insignificant detail worth noting is that in &lt;code&gt;jsonb&lt;/code&gt;, numbers will be printed according to the behavior of the underlying &lt;code&gt;numeric&lt;/code&gt; type. In practice this means that numbers entered with &lt;code&gt;E&lt;/code&gt; notation will be printed without it, for example:</source>
          <target state="translated">의미가 중요하지 않은 하나의 세부 사항은 &lt;code&gt;jsonb&lt;/code&gt; 에서 숫자가 기본 &lt;code&gt;numeric&lt;/code&gt; 유형 의 동작에 따라 인쇄된다는 것 입니다. 실제로 이것은 &lt;code&gt;E&lt;/code&gt; 표기법으로 입력 한 숫자가 이를 포함하지 않고 인쇄 됨을 의미합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a6e275ed16c86e3b4c5fd635846a9ed4c51adbd" translate="yes" xml:space="preserve">
          <source>One server process blocks another if it either holds a lock that conflicts with the blocked process's lock request (hard block), or is waiting for a lock that would conflict with the blocked process's lock request and is ahead of it in the wait queue (soft block). When using parallel queries the result always lists client-visible process IDs (that is, &lt;code&gt;pg_backend_pid&lt;/code&gt; results) even if the actual lock is held or awaited by a child worker process. As a result of that, there may be duplicated PIDs in the result. Also note that when a prepared transaction holds a conflicting lock, it will be represented by a zero process ID.</source>
          <target state="translated">한 서버 프로세스가 차단 된 프로세스의 잠금 요청 (하드 블록)과 충돌하는 잠금을 보유하거나 차단 된 프로세스의 잠금 요청과 충돌하고 대기 대기열에서 앞서있는 잠금을 기다리는 경우 (소프트 블록). 병렬 쿼리를 사용할 때 결과는 하위 작업자 프로세스가 실제 잠금을 유지하거나 &lt;code&gt;pg_backend_pid&lt;/code&gt; 하더라도 항상 클라이언트가 볼 수있는 프로세스 ID (즉, pg_backend_pid 결과)를 나열 합니다. 그 결과 결과에 중복 된 PID가있을 수 있습니다. 또한 준비된 트랜잭션이 충돌하는 잠금을 보유하는 경우 프로세스 ID가 0으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eee0b1a9ad748e96945cdf21735c3cba379b36e1" translate="yes" xml:space="preserve">
          <source>One should be wary of statements of the form</source>
          <target state="translated">하나는 형식의 진술에주의해야합니다</target>
        </trans-unit>
        <trans-unit id="46a23970289c263b3e0e6e71fbc6ba26b97f5282" translate="yes" xml:space="preserve">
          <source>One should be wary that it is easy to misspell a POSIX-style time zone specification, since there is no check on the reasonableness of the zone abbreviation(s). For example, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; will work, leaving the system effectively using a rather peculiar abbreviation for UTC.</source>
          <target state="translated">영역 약어의 합리성에 대한 검사가 없기 때문에 POSIX 스타일 시간대 사양의 철자가 틀리기 쉽다는 점에주의해야합니다. 예를 들어 &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; 이 작동하여 시스템이 UTC에 대해 다소 특이한 약어를 효과적으로 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="0503270d022d51df4a5d1385ddb363763c100a21" translate="yes" xml:space="preserve">
          <source>One should be wary that the POSIX-style time zone feature can lead to silently accepting bogus input, since there is no check on the reasonableness of the zone abbreviations. For example, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; will work, leaving the system effectively using a rather peculiar abbreviation for UTC. Another issue to keep in mind is that in POSIX time zone names, positive offsets are used for locations &lt;em&gt;west&lt;/em&gt; of Greenwich. Everywhere else, PostgreSQL follows the ISO-8601 convention that positive timezone offsets are &lt;em&gt;east&lt;/em&gt; of Greenwich.</source>
          <target state="translated">POSIX 스타일 시간대 기능은 구역 약어의 합리성에 대한 점검이 없기 때문에 가짜 입력을 자동으로 수락 할 수 있다는 점에주의해야합니다. 예를 들어 &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; 은 작동하며 UTC에 대해 다소 독특한 약어를 사용하여 시스템을 효과적으로 유지합니다. 명심해야 할 또 다른 문제는 POSIX 시간대 이름에서 양수 오프셋이 그리니치 &lt;em&gt;서쪽&lt;/em&gt; 지역에 사용된다는 것 입니다. 다른 곳에서 PostgreSQL은 ISO-8601 규칙에 따라 양의 시간대 오프셋이 &lt;em&gt;동쪽입니다&lt;/em&gt; 그리니치 에 .</target>
        </trans-unit>
        <trans-unit id="07761093680f0435d07de4dfbf3133e5f6e33451" translate="yes" xml:space="preserve">
          <source>One upgrade method is to dump data from one major version of PostgreSQL and reload it in another &amp;mdash; to do this, you must use a &lt;em&gt;logical&lt;/em&gt; backup tool like pg_dumpall; file system level backup methods will not work. (There are checks in place that prevent you from using a data directory with an incompatible version of PostgreSQL, so no great harm can be done by trying to start the wrong server version on a data directory.)</source>
          <target state="translated">한 가지 업그레이드 방법은 하나의 주요 버전의 PostgreSQL에서 데이터를 덤프하고 다른 버전으로 다시로드하는 것입니다.이를 위해서는 &lt;em&gt;논리&lt;/em&gt; 를 사용해야합니다&lt;em&gt;&lt;/em&gt; pg_dumpall과 같은 백업 도구 . 파일 시스템 수준 백업 방법이 작동하지 않습니다. 호환되지 않는 PostgreSQL 버전의 데이터 디렉토리를 사용하지 못하게하는 검사가 있으므로 데이터 디렉토리에서 잘못된 서버 버전을 시작하면 큰 피해를 입을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c2ef0cb6e16fe638517e00044d9fddafd2f1f0e" translate="yes" xml:space="preserve">
          <source>One way to avoid this problem is to run PostgreSQL on a machine where you can be sure that other processes will not run the machine out of memory. If memory is tight, increasing the swap space of the operating system can help avoid the problem, because the out-of-memory (OOM) killer is invoked only when physical memory and swap space are exhausted.</source>
          <target state="translated">이 문제를 피하는 한 가지 방법은 다른 프로세스가 컴퓨터의 메모리 부족 상태로 실행되지 않도록 시스템에서 PostgreSQL을 실행하는 것입니다. 메모리가 부족하면 실제 메모리 및 스왑 공간이 소진 된 경우에만 메모리 부족 (OOM) 킬러가 호출되므로 운영 체제의 스왑 공간을 늘리면 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb720ead71b0312fba38d640c63f7a5801cc13dc" translate="yes" xml:space="preserve">
          <source>One way to do this is to shut down the server and start a single-user PostgreSQL server with the &lt;code&gt;-P&lt;/code&gt; option included on its command line. Then, &lt;code&gt;REINDEX DATABASE&lt;/code&gt;, &lt;code&gt;REINDEX SYSTEM&lt;/code&gt;, &lt;code&gt;REINDEX TABLE&lt;/code&gt;, or &lt;code&gt;REINDEX INDEX&lt;/code&gt; can be issued, depending on how much you want to reconstruct. If in doubt, use &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; to select reconstruction of all system indexes in the database. Then quit the single-user server session and restart the regular server. See the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page for more information about how to interact with the single-user server interface.</source>
          <target state="translated">이를 수행하는 한 가지 방법은 서버를 종료 하고 명령 행에 &lt;code&gt;-P&lt;/code&gt; 옵션이 포함 된 단일 사용자 PostgreSQL 서버를 시작하는 것 입니다. 그런 다음 재구성하려는 양에 따라 &lt;code&gt;REINDEX DATABASE&lt;/code&gt; , &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; , &lt;code&gt;REINDEX TABLE&lt;/code&gt; 또는 &lt;code&gt;REINDEX INDEX&lt;/code&gt; 를 발행 할 수 있습니다. &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; 경우 REINDEX SYSTEM 을 사용 하여 데이터베이스에있는 모든 시스템 인덱스의 재구성을 선택하십시오. 그런 다음 단일 사용자 서버 세션을 종료하고 일반 서버를 다시 시작하십시오. 참고 항목 &lt;a href=&quot;app-postgres&quot;&gt;포스트 그레스&lt;/a&gt; 단일 사용자 서버 인터페이스와 상호 작용하는 방법에 대한 자세한 내용은 참조 페이지를.</target>
        </trans-unit>
        <trans-unit id="76a318a5204a34131edd8add7164960e6a6851df" translate="yes" xml:space="preserve">
          <source>One way to look at variant plans is to force the planner to disregard whatever strategy it thought was the cheapest, using the enable/disable flags described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;. (This is a crude tool, but useful. See also &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.) For example, if we're unconvinced that sequential-scan-and-sort is the best way to deal with table &lt;code&gt;onek&lt;/code&gt; in the previous example, we could try</source>
          <target state="translated">변형 계획을 보는 한 가지 방법 &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;은 19.7.1 절에&lt;/a&gt; 설명 된 활성화 / 비활성화 플래그를 사용하여 계획자가 가장 저렴한 전략을 무시하도록하는 것 입니다. (이것은 조잡한 도구이지만 유용합니다. &lt;a href=&quot;explicit-joins&quot;&gt;14.3 절도&lt;/a&gt; 참조하십시오 .) 예를 들어, 순차 스캔 및 정렬이 이전 예제에서 테이블 &lt;code&gt;onek&lt;/code&gt; 를 처리하는 가장 좋은 방법 인지 확신 할 수없는 경우 시도해 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0391e7fdb45313d9e4e2f5f1634bb9ecb7a05ff9" translate="yes" xml:space="preserve">
          <source>One way to prevent spoofing of &lt;code&gt;local&lt;/code&gt; connections is to use a Unix domain socket directory (&lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt;) that has write permission only for a trusted local user. This prevents a malicious user from creating their own socket file in that directory. If you are concerned that some applications might still reference &lt;code&gt;/tmp&lt;/code&gt; for the socket file and hence be vulnerable to spoofing, during operating system startup create a symbolic link &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; that points to the relocated socket file. You also might need to modify your &lt;code&gt;/tmp&lt;/code&gt; cleanup script to prevent removal of the symbolic link.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 연결 스푸핑을 방지하는 한 가지 방법 은 신뢰할 수있는 로컬 사용자에게만 쓰기 권한이 있는 Unix 도메인 소켓 디렉토리 ( &lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt; )를 사용하는 것입니다. 이로 인해 악의적 인 사용자가 해당 디렉토리에 자체 소켓 파일을 만들 수 없습니다. 일부 응용 프로그램이 여전히 소켓 파일에 대해 &lt;code&gt;/tmp&lt;/code&gt; 를 참조 하여 스푸핑에 취약한 것이 우려되는 경우 운영 체제 시작 중에 재배치 된 소켓 파일을 가리키는 심볼릭 링크 &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; 를 만듭니다 . &lt;code&gt;/tmp&lt;/code&gt; 를 수정해야 할 수도 있습니다.기호 링크가 제거되지 않도록 정리 스크립트 .</target>
        </trans-unit>
        <trans-unit id="839eb373f7e57c0c527b6ab4498f37574f9b1b5d" translate="yes" xml:space="preserve">
          <source>Online Analytical Processing</source>
          <target state="translated">온라인 분석 처리</target>
        </trans-unit>
        <trans-unit id="9bc8e24fa431e83abb8ee45cbd92647ad8e714f7" translate="yes" xml:space="preserve">
          <source>Online Transaction Processing</source>
          <target state="translated">온라인 거래 처리</target>
        </trans-unit>
        <trans-unit id="0b59497ee41bee58e3cf2969b674c4903d4bc6b0" translate="yes" xml:space="preserve">
          <source>Online statistics:</source>
          <target state="translated">온라인 통계 :</target>
        </trans-unit>
        <trans-unit id="95683a3aebf06f5e3b349d234f74e1173b887f29" translate="yes" xml:space="preserve">
          <source>Only an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock blocks a &lt;code&gt;SELECT&lt;/code&gt; (without &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt;) statement.</source>
          <target state="translated">&lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금 만 &lt;code&gt;SELECT&lt;/code&gt; ( 차단 &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; 없음)를 차단합니다 ) 명령문을 .</target>
        </trans-unit>
        <trans-unit id="6428d0603b66d67294f1af1eb460cffe5ea43327" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum), like &lt;code&gt;--analyze-only&lt;/code&gt;. Run several (currently three) stages of analyze with different configuration settings, to produce usable statistics faster.</source>
          <target state="translated">&lt;code&gt;--analyze-only&lt;/code&gt; 와 같은 옵티 마이저 (진공 없음)가 사용할 통계 만 계산 . 사용 가능한 통계를 더 빨리 생성하기 위해 다른 구성 설정으로 여러 단계 (현재 3 개)의 분석 단계를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e4af2b2a347593a2587cd89d5c7edc042fe1b2ae" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum).</source>
          <target state="translated">최적화 프로그램에서 사용할 통계 만 계산하십시오 (진공 없음).</target>
        </trans-unit>
        <trans-unit id="1ff76f6d5463fac41b779622c32a96a9ae59972a" translate="yes" xml:space="preserve">
          <source>Only certain data types support TOAST &amp;mdash; there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST, a data type must have a variable-length (&lt;em&gt;varlena&lt;/em&gt;) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). TOAST does not constrain the rest of the data type's representation. The special representations collectively called &lt;em&gt;TOASTed values&lt;/em&gt; work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a TOAST-able data type must be careful about how they handle potentially TOASTed input values: an input might not actually consist of a four-byte length word and contents until after it's been &lt;em&gt;detoasted&lt;/em&gt;. (This is normally done by invoking &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; before doing anything with an input value, but in some cases more efficient approaches are possible. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt; for more detail.)</source>
          <target state="translated">특정 데이터 유형 만 TOAST를 지원합니다. 큰 필드 값을 생성 할 수없는 데이터 유형에 오버 헤드를 부과 할 필요가 없습니다. TOAST를 지원하려면 데이터 유형에 가변 길이 ( &lt;em&gt;varlena&lt;/em&gt; ) 표현 이 있어야합니다 . 일반적으로 저장된 값의 첫 번째 4 바이트 단어에는 값의 전체 길이 (바이트 포함)가 포함됩니다 (자체 포함). TOAST는 나머지 데이터 유형 표현을 제한하지 않습니다. 특수 표현은 집합 적으로 라고&lt;em&gt; TOAST 값으로&lt;/em&gt; 이 초기 길이 단어를 수정하거나 해석하여 작동합니다. 따라서 TOAST 가능 데이터 유형을 지원하는 C 레벨 함수는 잠재적으로 TOAST 가능한 입력 값을 처리하는 방법에주의해야합니다. 입력은 실제로 4 바이트 길이의 단어와 내용으로 구성되지 않을 수 있습니다.&lt;em&gt;해체&lt;/em&gt; . (이것은 일반적으로 입력 값으로 무언가를하기 전에 &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; 을 호출함으로써 이루어 지지만, 어떤 경우에는보다 효율적인 접근이 가능합니다. 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;은 37.13.1 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6ed75bf01a8cac9ceb181bdbf71cfb0dfa8f9324" translate="yes" xml:space="preserve">
          <source>Only certain data types support TOAST &amp;mdash; there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST, a data type must have a variable-length (&lt;em&gt;varlena&lt;/em&gt;) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). TOAST does not constrain the rest of the data type's representation. The special representations collectively called &lt;em&gt;TOASTed values&lt;/em&gt; work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a TOAST-able data type must be careful about how they handle potentially TOASTed input values: an input might not actually consist of a four-byte length word and contents until after it's been &lt;em&gt;detoasted&lt;/em&gt;. (This is normally done by invoking &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; before doing anything with an input value, but in some cases more efficient approaches are possible. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt; for more detail.)</source>
          <target state="translated">특정 데이터 유형 만 TOAST를 지원합니다. 큰 필드 값을 생성 할 수없는 데이터 유형에 오버 헤드를 부과 할 필요가 없습니다. TOAST를 지원하려면 데이터 유형에 가변 길이 ( &lt;em&gt;varlena&lt;/em&gt; ) 표현 이 있어야합니다 . 일반적으로 저장된 값의 처음 4 바이트 단어에는 값의 총 길이 (자체 포함)가 포함됩니다. TOAST는 나머지 데이터 유형 표현을 제한하지 않습니다. 집합 적으로 &lt;em&gt;TOASTed 값&lt;/em&gt; 이라고하는 특수 표현은 이 초기 길이 단어를 수정하거나 재 해석하여 작동합니다. 따라서 TOAST 가능 데이터 유형을 지원하는 C 레벨 함수는 잠재적으로 TOAST 입력 값을 처리하는 방법에 대해주의해야합니다. 입력은 실제로 4 바이트 길이의 단어와 내용으로 구성되지 않을 수 있습니다.&lt;em&gt;detoasted&lt;/em&gt; . (이것은 일반적으로 입력 값을 사용하기 전에 &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; 을 호출 하여 수행되지만 경우에 따라 더 효율적인 접근 방식이 가능합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;섹션 37.13.1&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="27a5875a715917165876854e17c248ccf4f95f13" translate="yes" xml:space="preserve">
          <source>Only display records generated by the specified resource manager. If &lt;code&gt;list&lt;/code&gt; is passed as name, print a list of valid resource manager names, and exit.</source>
          <target state="translated">지정된 자원 관리자가 생성 한 레코드 만 표시하십시오. &lt;code&gt;list&lt;/code&gt; 가 name으로 전달 되면 유효한 자원 관리자 이름 목록을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="1eec6acc7fed503402488b3ba82909c46aae0483" translate="yes" xml:space="preserve">
          <source>Only display records marked with the given transaction ID.</source>
          <target state="translated">주어진 거래 ID로 표시된 레코드 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="df686aa57f8a0399728798091a1185e8914758e9" translate="yes" xml:space="preserve">
          <source>Only dump the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to dump all sections.</source>
          <target state="translated">명명 된 섹션 만 덤프하십시오. 섹션 이름은 &lt;code&gt;pre-data&lt;/code&gt; , &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;post-data&lt;/code&gt; 일 수 있습니다. 이 옵션은 여러 섹션을 선택하기 위해 두 번 이상 지정할 수 있습니다. 기본값은 모든 섹션을 덤프하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8c62a53b547108de76ccc1531107eb8cfedb9cfb" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a multixact ID age of at least &lt;code&gt;mxid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent multixact ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;).</source>
          <target state="translated">만 진공을 실행하거나 최소한의 multixact ID 연령 테이블에서 명령을 분석 &lt;code&gt;mxid_age&lt;/code&gt; . 이 설정은 다중 처리 ID 랩 어라운드를 방지하기 위해 처리 할 테이블의 우선 순위를 지정하는 데 유용합니다 ( &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;24.1.5.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="22cc7a345e3b6c6eac0bd069839bf36f1185ab25" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a transaction ID age of at least &lt;code&gt;xid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;).</source>
          <target state="translated">트랜잭션 ID &lt;code&gt;xid_age&lt;/code&gt; 이상인 테이블에 대해서만 vacuum 또는 분석 명령을 실행하십시오 . 이 설정은 트랜잭션 ID 랩 어라운드를 방지하기 위해 처리 할 테이블의 우선 순위를 지정하는 데 유용합니다 ( &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="30caad55acba8eaee72cd0eb2b22ca9a6e1cfcaa" translate="yes" xml:space="preserve">
          <source>Only has effect if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled.</source>
          <target state="translated">&lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;데이터 체크섬&lt;/a&gt; 이 활성화 된 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4930a6bbf0f1c4de7f538ff4072a1668f8d281a2" translate="yes" xml:space="preserve">
          <source>Only lowercase &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; spellings are accepted</source>
          <target state="translated">소문자 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 철자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d755b459eeaa6b733e81509898e0f04066e3489" translate="yes" xml:space="preserve">
          <source>Only one comment string is stored for each object, so to modify a comment, issue a new &lt;code&gt;COMMENT&lt;/code&gt; command for the same object. To remove a comment, write &lt;code&gt;NULL&lt;/code&gt; in place of the text string. Comments are automatically dropped when their object is dropped.</source>
          <target state="translated">각 오브젝트마다 하나의 주석 문자열 만 저장되므로 주석을 수정 하려면 동일한 오브젝트에 대해 새 &lt;code&gt;COMMENT&lt;/code&gt; 명령을 실행하십시오. 주석을 제거하려면 텍스트 문자열 대신 &lt;code&gt;NULL&lt;/code&gt; 을 작성 하십시오. 객체를 놓으면 주석이 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6b3d566bcef3dc1ca42fe3bd8ea05bbe930d19d6" translate="yes" xml:space="preserve">
          <source>Only one parameter may be supplied to the function in a &lt;code&gt;CREATE TRIGGER&lt;/code&gt; statement, and that is optional. If supplied it will be used for the channel name for the notifications. If omitted &lt;code&gt;tcn&lt;/code&gt; will be used for the channel name.</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; 문 에서 함수에 하나의 매개 변수 만 제공 될 수 있으며 이는 선택적입니다. 제공되는 경우 알림의 채널 이름으로 사용됩니다. 생략 하면 채널 이름에 &lt;code&gt;tcn&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6026da30f943934674a5eb09f1e0f0526ceb2de" translate="yes" xml:space="preserve">
          <source>Only one row, showing statistics about the WAL receiver from that receiver's connected server. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">해당 수신자의 연결된 서버에서 WAL 수신자에 대한 통계를 표시하는 단 하나의 행입니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt; &lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="52d2c18b8c742c722526abc3884826a2891d9cd5" translate="yes" xml:space="preserve">
          <source>Only one row, showing statistics about the WAL receiver from that receiver's connected server. See &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; for details.</source>
          <target state="translated">해당 수신자의 연결된 서버에서 WAL 수신자에 대한 통계를 표시하는 단 하나의 행. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e141ed896712b895fe333210a9bdff25138d7ab" translate="yes" xml:space="preserve">
          <source>Only operator classes for &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; are included with the module.</source>
          <target state="translated">&lt;code&gt;int4&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 에 대한 연산자 클래스 만 모듈에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="109540637ae1151a05d5ef17fc0235346d4ed7ef" translate="yes" xml:space="preserve">
          <source>Only persistent base tables and partitioned tables can be part of a publication. Temporary tables, unlogged tables, foreign tables, materialized views, and regular views cannot be part of a publication.</source>
          <target state="translated">영구 기본 테이블과 분할 된 테이블 만 게시의 일부가 될 수 있습니다. 임시 테이블, 로그되지 않은 테이블, 외부 테이블, 구체화 된 뷰 및 일반 뷰는 게시의 일부가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="36554985b3656b4dddfbe30677cd178826516027" translate="yes" xml:space="preserve">
          <source>Only persistent base tables can be part of a publication. Temporary tables, unlogged tables, foreign tables, materialized views, regular views, and partitioned tables cannot be part of a publication. To replicate a partitioned table, add the individual partitions to the publication.</source>
          <target state="translated">영구 기본 테이블 만 공개의 일부가 될 수 있습니다. 임시 테이블, 로그되지 않은 테이블, 외부 테이블, 구체화 된 뷰, 일반 뷰 및 파티션 된 테이블은 게시의 일부일 수 없습니다. 분할 된 테이블을 복제하려면 개별 파티션을 게시에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b0f9131e0157ccbc9f71702565357129b8273efc" translate="yes" xml:space="preserve">
          <source>Only restore the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to restore all sections.</source>
          <target state="translated">명명 된 섹션 만 복원하십시오. 섹션 이름은 &lt;code&gt;pre-data&lt;/code&gt; , &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;post-data&lt;/code&gt; 일 수 있습니다. 이 옵션은 여러 섹션을 선택하기 위해 두 번 이상 지정할 수 있습니다. 기본값은 모든 섹션을 복원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d94341e83b6e3cc09be7f96d9ae2bbdbd997a3f" translate="yes" xml:space="preserve">
          <source>Only roles that have the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be used as the initial role name for a database connection. A role with the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be considered the same as a &amp;ldquo;database user&amp;rdquo;. To create a role with login privilege, use either:</source>
          <target state="translated">&lt;code&gt;LOGIN&lt;/code&gt; 속성 이있는 역할 만 데이터베이스 연결의 초기 역할 이름으로 사용할 수 있습니다. &lt;code&gt;LOGIN&lt;/code&gt; 속성 을 가진 역할 은&amp;ldquo;데이터베이스 사용자&amp;rdquo;와 동일한 것으로 간주 될 수 있습니다. 로그인 권한이있는 역할을 만들려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d85fc142dd33473e697f51542b02c504f67a9b35" translate="yes" xml:space="preserve">
          <source>Only shared libraries specifically intended to be used with PostgreSQL can be loaded this way. Every PostgreSQL-supported library has a &amp;ldquo;magic block&amp;rdquo; that is checked to guarantee compatibility. For this reason, non-PostgreSQL libraries cannot be loaded in this way. You might be able to use operating-system facilities such as &lt;code&gt;LD_PRELOAD&lt;/code&gt; for that.</source>
          <target state="translated">PostgreSQL과 함께 사용하도록 특별히 설계된 공유 라이브러리 만이 방법으로로드 할 수 있습니다. 모든 PostgreSQL 지원 라이브러리에는 호환성을 보장하기 위해 &quot;매직 블록&quot;이 있습니다. 이러한 이유로 PostgreSQL 이외의 라이브러리는 이런 방식으로로드 할 수 없습니다. 이를 위해 &lt;code&gt;LD_PRELOAD&lt;/code&gt; 와 같은 운영 체제 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bf905053544478968750f95521ca3e30e70375f" translate="yes" xml:space="preserve">
          <source>Only superusers can alter foreign-data wrappers. Additionally, only superusers can own foreign-data wrappers.</source>
          <target state="translated">수퍼 유저 만 외부 데이터 래퍼를 변경할 수 있습니다. 또한 수퍼 유저 만 외부 데이터 래퍼를 소유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9d1a65de15d43acfd7df441e250838c198f3037" translate="yes" xml:space="preserve">
          <source>Only superusers can call &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">수퍼 유저 만 &lt;code&gt;CHECKPOINT&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b3d5ff53d3f29afdf3319b912d99cf3260a4f77" translate="yes" xml:space="preserve">
          <source>Only superusers can change this setting, because it affects the messages sent to the server log as well as to the client, and an improper value might obscure the readability of the server logs.</source>
          <target state="translated">수퍼 유저 만이 설정을 변경할 수 있습니다.이 설정은 서버 로그 및 클라이언트로 전송 된 메시지에 영향을 미치며, 잘못된 값은 서버 로그의 가독성을 가릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2be6ed45f348313973635f2ddfd082cf6f9717d" translate="yes" xml:space="preserve">
          <source>Only superusers can create event triggers.</source>
          <target state="translated">슈퍼 유저 만 이벤트 트리거를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ae5bc67902361297a54dbc3f2c9fc4cdf0facde" translate="yes" xml:space="preserve">
          <source>Only superusers can create foreign-data wrappers.</source>
          <target state="translated">수퍼 유저 만 외부 데이터 래퍼를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0a550e0a836899716e0fe5ebdbfaa0d54059384" translate="yes" xml:space="preserve">
          <source>Only superusers can define new access methods.</source>
          <target state="translated">수퍼 유저 만 새로운 액세스 방법을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d11423b98472dc3dca65de17ed52b8e73990fa3d" translate="yes" xml:space="preserve">
          <source>Only superusers can use &lt;code&gt;ALTER SYSTEM&lt;/code&gt;. Also, since this command acts directly on the file system and cannot be rolled back, it is not allowed inside a transaction block or function.</source>
          <target state="translated">수퍼 유저 만 &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 을 사용할 수 있습니다 . 또한이 명령은 파일 시스템에서 직접 작동하며 롤백 할 수 없으므로 트랜잭션 블록 또는 함수 내에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0b0ed2869d7ce3fc0379f4c0080abfebb839775" translate="yes" xml:space="preserve">
          <source>Only superusers may connect to foreign servers without password authentication, so always specify the &lt;code&gt;password&lt;/code&gt; option for user mappings belonging to non-superusers.</source>
          <target state="translated">수퍼 유저 만 암호 인증없이 외부 서버에 연결할 수 있으므로 항상 수퍼 유저가 아닌 사용자 매핑에 &lt;code&gt;password&lt;/code&gt; 옵션을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9674d9c7cf6a8e522bf949d4719f88f50cf734f7" translate="yes" xml:space="preserve">
          <source>Only superusers may create or modify user mappings with the &lt;code&gt;sslcert&lt;/code&gt; or &lt;code&gt;sslkey&lt;/code&gt; settings.</source>
          <target state="translated">수퍼 유저 만 &lt;code&gt;sslcert&lt;/code&gt; 또는 &lt;code&gt;sslkey&lt;/code&gt; 설정을 사용하여 사용자 매핑을 만들거나 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="add5aed352ded84ef9a29f07c8afce866831ef29" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;=&lt;/code&gt; operator is supported for search. But it is possible to add support for arrays with union and intersection operations in the future.</source>
          <target state="translated">검색 에는 &lt;code&gt;=&lt;/code&gt; 연산자 만 지원됩니다. 그러나 향후 통합 및 교차 작업이있는 어레이에 대한 지원을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c2cf173b45b1ac1a32e3ec0d5fe77ba32623c7" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VERBOSE&lt;/code&gt; options can be specified, and only in that order, without surrounding the option list in parentheses. Prior to PostgreSQL 9.0, the unparenthesized syntax was the only one supported. It is expected that all new options will be supported only in the parenthesized syntax.</source>
          <target state="translated">옵션 목록을 괄호로 &lt;code&gt;VERBOSE&lt;/code&gt; 않고 &lt;code&gt;ANALYZE&lt;/code&gt; 및 VERBOSE 옵션 만 순서대로 지정할 수 있습니다. PostgreSQL 9.0 이전에는 괄호로 묶지 않은 구문 만 지원되었습니다. 모든 새로운 옵션은 괄호 안에있는 구문에서만 지원 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="60a1039af88ab14d5161dbfac50ade9fe96eaa30" translate="yes" xml:space="preserve">
          <source>Only the custom and directory archive formats are supported with this option. The input must be a regular file or directory (not, for example, a pipe or standard input). Also, multiple jobs cannot be used together with the option &lt;code&gt;--single-transaction&lt;/code&gt;.</source>
          <target state="translated">이 옵션에서는 사용자 정의 및 디렉토리 아카이브 형식 만 지원됩니다. 입력은 일반 파일 또는 디렉토리 여야합니다 (예 : 파이프 또는 표준 입력이 아님). 또한 여러 작업을 &lt;code&gt;--single-transaction&lt;/code&gt; 옵션과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5022f8e7bdd77bf8c02d9d1490318561a8027b6a" translate="yes" xml:space="preserve">
          <source>Only the custom and directory archive formats are supported with this option. The input must be a regular file or directory (not, for example, a pipe). This option is ignored when emitting a script rather than connecting directly to a database server. Also, multiple jobs cannot be used together with the option &lt;code&gt;--single-transaction&lt;/code&gt;.</source>
          <target state="translated">이 옵션에서는 사용자 정의 및 디렉토리 아카이브 형식 만 지원됩니다. 입력은 일반 파일 또는 디렉토리 여야합니다 (예 : 파이프 아님). 이 옵션은 데이터베이스 서버에 직접 연결하지 않고 스크립트를 생성 할 때 무시됩니다. 또한 여러 작업을 &lt;code&gt;--single-transaction&lt;/code&gt; 옵션과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5e47b4720ff6f0582001899cb68bf4bdb2a0ac11" translate="yes" xml:space="preserve">
          <source>Only the owner of the database, or a superuser, can drop a database. Dropping a database removes all objects that were contained within the database. The destruction of a database cannot be undone.</source>
          <target state="translated">데이터베이스 소유자 또는 수퍼 유저 만 데이터베이스를 삭제할 수 있습니다. 데이터베이스를 삭제하면 데이터베이스에 포함 된 모든 개체가 제거됩니다. 데이터베이스 삭제는 취소 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="992702029b9e3a50c611dc6825669adb061c4f3f" translate="yes" xml:space="preserve">
          <source>Only the specified timeline is displayed (or the default, if none is specified). Records in other timelines are ignored.</source>
          <target state="translated">지정된 타임 라인 만 표시됩니다 (또는 지정되지 않은 경우 기본값). 다른 타임 라인의 레코드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0e8a66b6f0be3b6d7c6a27438485bc034b86bede" translate="yes" xml:space="preserve">
          <source>Only validate checksums in the relation with filenode &lt;code&gt;filenode&lt;/code&gt;.</source>
          <target state="translated">filenode &lt;code&gt;filenode&lt;/code&gt; 와 관련하여 체크섬 만 유효성 검증하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0b885bbfd4f3bfc263123d67cbabd608309adfe" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity</source>
          <target state="translated">개방형 데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="904b1a9c4f30cf27ea883ca5fa7d3ff036c36eb9" translate="yes" xml:space="preserve">
          <source>Open interval with lower bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">하한 &lt;code&gt;x&lt;/code&gt; 의 열린 간격</target>
        </trans-unit>
        <trans-unit id="5a8b4a983dd22778ee9f002679eacd86bf69191d" translate="yes" xml:space="preserve">
          <source>Open interval with upper bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">상한 &lt;code&gt;x&lt;/code&gt; 를 가진 열린 간격</target>
        </trans-unit>
        <trans-unit id="45de3417dc1987111074bc170202fbf751c567d8" translate="yes" xml:space="preserve">
          <source>Open path</source>
          <target state="translated">열린 길</target>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="50ef244d7dd70cb29f22ada32d04825a64fc9036" translate="yes" xml:space="preserve">
          <source>OpenBSD sys/crypto</source>
          <target state="translated">OpenBSD sys / crypto</target>
        </trans-unit>
        <trans-unit id="e301ca795081a87c0033bddb2e90503f9f7929d2" translate="yes" xml:space="preserve">
          <source>OpenPGP message format.</source>
          <target state="translated">OpenPGP 메시지 형식.</target>
        </trans-unit>
        <trans-unit id="2188261ca504497d39a1689d5dff920fe8b50f79" translate="yes" xml:space="preserve">
          <source>OpenSSL names for the most common curves are: &lt;code&gt;prime256v1&lt;/code&gt; (NIST P-256), &lt;code&gt;secp384r1&lt;/code&gt; (NIST P-384), &lt;code&gt;secp521r1&lt;/code&gt; (NIST P-521). The full list of available curves can be shown with the command &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt;. Not all of them are usable in TLS though.</source>
          <target state="translated">가장 일반적인 곡선의 OpenSSL 이름은 &lt;code&gt;prime256v1&lt;/code&gt; (NIST P-256), &lt;code&gt;secp384r1&lt;/code&gt; (NIST P-384), &lt;code&gt;secp521r1&lt;/code&gt; (NIST P-521)입니다. 사용 가능한 커브의 전체 목록은 &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt; 명령으로 표시 할 수 있습니다 . TLS에서 모두 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5c972fdff495c397d3150e0515793a7f4559382c" translate="yes" xml:space="preserve">
          <source>OpenSSL supports a wide range of ciphers and authentication algorithms, of varying strength. While a list of ciphers can be specified in the OpenSSL configuration file, you can specify ciphers specifically for use by the database server by modifying &lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;ssl_ciphers&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">OpenSSL은 다양한 강도의 광범위한 암호 및 인증 알고리즘을 지원합니다. OpenSSL 구성 파일에서 암호 목록을 지정할 수 있지만 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;ssl_ciphers&lt;/a&gt; 를 수정하여 데이터베이스 서버에서 사용할 암호를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3b0974ebaa95408edcf74b52711fc4f50a804a3" translate="yes" xml:space="preserve">
          <source>Operations such as TRUNCATE which normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition. Note that dropping a partition with &lt;code&gt;DROP TABLE&lt;/code&gt; requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="translated">TRUNCATE와 같은 작업은 일반적으로 테이블과 모든 상속 자식에 영향을 미치며 모든 파티션에 캐스케이드되지만 개별 파티션에서도 수행 될 수 있습니다. &lt;code&gt;DROP TABLE&lt;/code&gt; 을 사용 하여 파티션을 삭제 하려면 상위 테이블에서 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="b07cfafa5cefef04cd848e7642b8acf9013a81e6" translate="yes" xml:space="preserve">
          <source>Operator Classes and Operator Families</source>
          <target state="translated">운영자 클래스 및 운영자 가족</target>
        </trans-unit>
        <trans-unit id="b398f34e06d00a1a82db7c5bd5884749c340c3d5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 1</source>
          <target state="translated">운영자 전략 1</target>
        </trans-unit>
        <trans-unit id="244ef231d648a8011796f75d8ba0c200ff67c490" translate="yes" xml:space="preserve">
          <source>Operator Strategy 10</source>
          <target state="translated">사업자 전략 10</target>
        </trans-unit>
        <trans-unit id="aa5d9755365c2952ee3e6f612eacdbdd1a1d7624" translate="yes" xml:space="preserve">
          <source>Operator Strategy 11</source>
          <target state="translated">사업자 전략 11</target>
        </trans-unit>
        <trans-unit id="d4a97822fa5fff84d7420e13e887c2193e9890f0" translate="yes" xml:space="preserve">
          <source>Operator Strategy 12</source>
          <target state="translated">사업자 전략 12</target>
        </trans-unit>
        <trans-unit id="84afbc51b4cffb9fe60bc11408d20fc3c75207ff" translate="yes" xml:space="preserve">
          <source>Operator Strategy 2</source>
          <target state="translated">사업자 전략 2</target>
        </trans-unit>
        <trans-unit id="32970bd5b0dc670174fa5e603b715a1879812041" translate="yes" xml:space="preserve">
          <source>Operator Strategy 20</source>
          <target state="translated">사업자 전략 20</target>
        </trans-unit>
        <trans-unit id="151eb78f3e104abebf3876024563a961e2605d2c" translate="yes" xml:space="preserve">
          <source>Operator Strategy 21</source>
          <target state="translated">사업자 전략 21</target>
        </trans-unit>
        <trans-unit id="8684f3d138a78992a0b771dfbb423682326c65f8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 22</source>
          <target state="translated">사업자 전략 22</target>
        </trans-unit>
        <trans-unit id="71205740f8d9e86efeb0bd151835d85c0a6b3446" translate="yes" xml:space="preserve">
          <source>Operator Strategy 23</source>
          <target state="translated">사업자 전략 23</target>
        </trans-unit>
        <trans-unit id="e0c4fa7b818964dd91a014987dc2cbf9d0f35f95" translate="yes" xml:space="preserve">
          <source>Operator Strategy 3</source>
          <target state="translated">사업자 전략 3</target>
        </trans-unit>
        <trans-unit id="c0698fd0a94af9d76a35b8038b94b51dc5055fa5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 4</source>
          <target state="translated">사업자 전략 4</target>
        </trans-unit>
        <trans-unit id="7f6f8898348de22423f28b86e1d340d71a2b39e6" translate="yes" xml:space="preserve">
          <source>Operator Strategy 5</source>
          <target state="translated">사업자 전략 5</target>
        </trans-unit>
        <trans-unit id="3b8f252bde4d01adf4e5020737ab0f39249112c8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 6, 18</source>
          <target state="translated">사업자 전략 6, 18</target>
        </trans-unit>
        <trans-unit id="63882822a5b9fac73c626ceb2fedd6c07953d3d2" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7</source>
          <target state="translated">사업자 전략 7</target>
        </trans-unit>
        <trans-unit id="614f640543a97c56dc41fc006e5e6df302593992" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7, 13, 16, 24, 25</source>
          <target state="translated">사업자 전략 7, 13, 16, 24, 25</target>
        </trans-unit>
        <trans-unit id="f5666e86d614f20d9c6c6d654b73870444a0a7b8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 8, 14, 26, 27</source>
          <target state="translated">사업자 전략 8, 14, 26, 27</target>
        </trans-unit>
        <trans-unit id="6bd466b077248c905be85a30157069ea7d392f05" translate="yes" xml:space="preserve">
          <source>Operator Strategy 9</source>
          <target state="translated">사업자 전략 9</target>
        </trans-unit>
        <trans-unit id="23a5e32675db7a6dae8947caf6f8b77d2fb419f2" translate="yes" xml:space="preserve">
          <source>Operator class member</source>
          <target state="translated">연산자 클래스 멤버</target>
        </trans-unit>
        <trans-unit id="a154991f482d1ef020b50f829693f6a3e7645883" translate="yes" xml:space="preserve">
          <source>Operator classes are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">연산자 클래스는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;섹션 37.16&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63c649d8246e4687f509dd0b4cd3e53d324b319" translate="yes" xml:space="preserve">
          <source>Operator classes are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">연산자 클래스는 &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;섹션 37.16&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="58080c4fb9795121bf1294991f50a6dd258005c4" translate="yes" xml:space="preserve">
          <source>Operator classes that implement completely different semantics are also possible, provided implementations of the four main support functions described above are written. Note that backwards compatibility across major releases is not guaranteed: for example, additional support functions might be required in later releases.</source>
          <target state="translated">위에서 설명한 네 가지 주요 지원 기능의 구현이 작성된 경우 완전히 다른 의미를 구현하는 연산자 클래스도 가능합니다. 주요 릴리스 간의 하위 호환성은 보장되지 않습니다. 예를 들어, 이후 릴리스에서는 추가 지원 기능이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb753b5f274e2276c93849eb8d4d017ef67b8b0d" translate="yes" xml:space="preserve">
          <source>Operator families are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">운영자 제품군은 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;섹션 37.16&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e043feb1fde1f2ad0490d4b9f478c590c6ae0a" translate="yes" xml:space="preserve">
          <source>Operator families are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">오퍼레이터 제품군은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;섹션 37.16&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="089453e64460e24c4860d90b978d73331899e626" translate="yes" xml:space="preserve">
          <source>Operator family containing the operator class</source>
          <target state="translated">연산자 클래스를 포함하는 연산자 제품군</target>
        </trans-unit>
        <trans-unit id="d001f433bb040727266e2e45232ebf1b96c87507" translate="yes" xml:space="preserve">
          <source>Operator purpose, either &lt;code&gt;s&lt;/code&gt; for search or &lt;code&gt;o&lt;/code&gt; for ordering</source>
          <target state="translated">운영자의 목적, 하나 &lt;code&gt;s&lt;/code&gt; 검색이나에 대한 &lt;code&gt;o&lt;/code&gt; 주문에 대한</target>
        </trans-unit>
        <trans-unit id="912efd8e18516ea9637e59e441f7f7a9add7dc7b" translate="yes" xml:space="preserve">
          <source>Operator strategy number</source>
          <target state="translated">운영자 전략 번호</target>
        </trans-unit>
        <trans-unit id="2e8cb1b3b6dd7d5c36991fdde1327aa3fa525b70" translate="yes" xml:space="preserve">
          <source>Operator/Element</source>
          <target state="translated">Operator/Element</target>
        </trans-unit>
        <trans-unit id="2d08499adb61cbc2e5aa0edb02bd1f8b9de48e7f" translate="yes" xml:space="preserve">
          <source>Operator/Method</source>
          <target state="translated">Operator/Method</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="245cf7f12c2bf5a2fc5aaf31f347829fe389252a" translate="yes" xml:space="preserve">
          <source>Operators are represented by &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt;, writing the type names exactly as they appear in the &lt;code&gt;pg_operator.dat&lt;/code&gt; entry's &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields. (Write &lt;code&gt;0&lt;/code&gt; for the omitted operand of a unary operator.)</source>
          <target state="translated">연산자는 &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt; 으로 표시되며 &lt;code&gt;pg_operator.dat&lt;/code&gt; 항목의 &lt;code&gt;oprleft&lt;/code&gt; 및 &lt;code&gt;oprright&lt;/code&gt; 필드에 나타나는 것과 동일한 형식 이름 을 씁니다 . 단항 연산자의 생략 된 피연산자에 대해서는 &lt;code&gt;0&lt;/code&gt; 을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="1f5c0ba13f00010cbbfefca8a52453ff0cb4b539" translate="yes" xml:space="preserve">
          <source>Optimality of the query plan</source>
          <target state="translated">쿼리 계획의 최적화</target>
        </trans-unit>
        <trans-unit id="5b15e9cc0d575ead9ee77f9021833cc95443ec95" translate="yes" xml:space="preserve">
          <source>Optimizer</source>
          <target state="translated">Optimizer</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="30ea09691f79f4f3b53ede4678ab841460419294" translate="yes" xml:space="preserve">
          <source>Optional data-manipulation: compression, conversion to UTF-8, and/or conversion of line-endings.</source>
          <target state="translated">선택적 데이터 조작 : 압축, UTF-8로 변환 및 / 또는 줄 끝 변환</target>
        </trans-unit>
        <trans-unit id="dda0500e72a6b8d9415eee2d2bd9c2b4bddc1e78" translate="yes" xml:space="preserve">
          <source>Optional key words. They have no effect.</source>
          <target state="translated">선택적 키워드. 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="be700c602b6a0f91e2d0a7efd9323b26ffbdc0e3" translate="yes" xml:space="preserve">
          <source>Optional parameters can be written in any order, not only the order illustrated above.</source>
          <target state="translated">선택적 매개 변수는 위에서 설명한 순서뿐만 아니라 임의의 순서로 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ddbf1be07fc433b776138e1087ccfcfc7bb295" translate="yes" xml:space="preserve">
          <source>Optional planner support function for this function (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt;)</source>
          <target state="translated">이 기능에 대한 선택적 플래너 지원 기능 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;섹션 37.11&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a2e97703c74b74734bc3d703b229e2fffbfe125d" translate="yes" xml:space="preserve">
          <source>Optional planner support function for this function (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt;)</source>
          <target state="translated">이 기능에 대한 플래너 지원 기능 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;섹션 37.11&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="2fd16c799a777633af7110bcb3365acd2d2f9b6f" translate="yes" xml:space="preserve">
          <source>Optional server type, potentially useful to foreign-data wrappers.</source>
          <target state="translated">선택적 서버 유형으로, 외부 데이터 랩퍼에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="23e65fc5f0e4b9be1c8551d9648425aede4fa734" translate="yes" xml:space="preserve">
          <source>Optional server version, potentially useful to foreign-data wrappers.</source>
          <target state="translated">선택적 서버 버전으로, 외부 데이터 랩퍼에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8080182e2b9ea49c9096dd85079cd9c704e16363" translate="yes" xml:space="preserve">
          <source>Optionally one can add the key word &lt;code&gt;ASC&lt;/code&gt; (ascending) or &lt;code&gt;DESC&lt;/code&gt; (descending) after any expression in the &lt;code&gt;ORDER BY&lt;/code&gt; clause. If not specified, &lt;code&gt;ASC&lt;/code&gt; is assumed by default. Alternatively, a specific ordering operator name can be specified in the &lt;code&gt;USING&lt;/code&gt; clause. An ordering operator must be a less-than or greater-than member of some B-tree operator family. &lt;code&gt;ASC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;lt;&lt;/code&gt; and &lt;code&gt;DESC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;gt;&lt;/code&gt;. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)</source>
          <target state="translated">선택적 으로 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서 표현식 후 키워드 &lt;code&gt;ASC&lt;/code&gt; (오름차순) 또는 &lt;code&gt;DESC&lt;/code&gt; (내림차순)를 추가 할 수 있습니다 . 지정하지 않으면 &lt;code&gt;ASC&lt;/code&gt; 가 기본적으로 가정됩니다. 또는 특정 순서 연산자 이름을 &lt;code&gt;USING&lt;/code&gt; 절에 지정할 수 있습니다 . 주문 연산자는 일부 B- 트리 연산자 제품군의 멤버보다 작거나 커야합니다. &lt;code&gt;ASC&lt;/code&gt; 는 일반적으로 &lt;code&gt;USING &amp;lt;&lt;/code&gt; 과 같고 &lt;code&gt;DESC&lt;/code&gt; 는 일반적으로 &lt;code&gt;USING &amp;gt;&lt;/code&gt; 과 같습니다 . 그러나 사용자 정의 데이터 유형의 작성자는 기본 정렬 순서를 정확히 정의 할 수 있으며 다른 이름을 가진 연산자에 해당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a8ce77c093de9028c29694dad75d1d0b46f922" translate="yes" xml:space="preserve">
          <source>Optionally specifies an existing replication slot to be used when connecting to the sending server via streaming replication to control resource removal on the upstream node (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). This parameter can only be set at server start. This setting has no effect if &lt;code&gt;primary_conninfo&lt;/code&gt; is not set.</source>
          <target state="translated">선택적으로 업스트림 노드에서 자원 제거를 제어하기 위해 스트리밍 복제를 통해 전송 서버에 연결할 때 사용할 기존 복제 슬롯을 지정합니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;26.2.6 절&lt;/a&gt; 참조 ). 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. &lt;code&gt;primary_conninfo&lt;/code&gt; 가 설정되지 않은 경우이 설정은 적용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96c92ada09a34799bdf814b9347c979dbca22b37" translate="yes" xml:space="preserve">
          <source>Optionally specifies an existing replication slot to be used when connecting to the sending server via streaming replication to control resource removal on the upstream node (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. If this parameter is changed while the WAL receiver process is running, that process is signaled to shut down and expected to restart with the new setting. This setting has no effect if &lt;code&gt;primary_conninfo&lt;/code&gt; is not set or the server is not in standby mode.</source>
          <target state="translated">업스트림 노드에서 리소스 제거를 제어하기 위해 스트리밍 복제를 통해 송신 서버에 연결할 때 사용할 기존 복제 슬롯을 선택적으로 지정합니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;섹션 26.2.6&lt;/a&gt; 참조 ). 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . WAL 수신기 프로세스가 실행되는 동안이 매개 변수가 변경되면 해당 프로세스는 종료 신호를 받고 새 설정으로 다시 시작할 것으로 예상됩니다. &lt;code&gt;primary_conninfo&lt;/code&gt; 가 설정되지 않았거나 서버가 대기 모드가 아닌 경우이 설정은 적용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9e1a54cb19d7f45ef6c62130cbc0ebd54aaaeaa" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can include subcommands to create objects within the new schema. The subcommands are treated essentially the same as separate commands issued after creating the schema, except that if the &lt;code&gt;AUTHORIZATION&lt;/code&gt; clause is used, all the created objects will be owned by that user.</source>
          <target state="translated">선택적으로 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 에는 새 스키마 내에 오브젝트를 작성하는 부속 명령이 포함될 수 있습니다. 부속 명령은 &lt;code&gt;AUTHORIZATION&lt;/code&gt; 절을 사용하는 경우 작성된 ​​모든 오브젝트가 해당 사용자가 소유 한다는 점을 제외하고는 스키마 작성 후 발행 된 개별 명령과 본질적으로 동일하게 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="f83f2be43194c5b280c1fd15656c0623344c2afd" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt; can be written before &lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;. This presently makes no difference in PostgreSQL and is deprecated; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Compatibility&lt;/a&gt; below.</source>
          <target state="translated">선택적으로 &lt;code&gt;GLOBAL&lt;/code&gt; 또는 &lt;code&gt;LOCAL&lt;/code&gt; 은 &lt;code&gt;TEMPORARY&lt;/code&gt; 또는 &lt;code&gt;TEMP&lt;/code&gt; 앞에 쓸 수 있습니다 . 이것은 현재 PostgreSQL에서 차이가 없으며 더 이상 사용되지 않습니다. 아래의 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;호환성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb213cf60cad5118b118598f7c3788d5e4cf965c" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt; can be written before &lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;. This presently makes no difference in PostgreSQL and is deprecated; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Compatibility&lt;/a&gt;.</source>
          <target state="translated">선택적으로, &lt;code&gt;GLOBAL&lt;/code&gt; 또는 &lt;code&gt;LOCAL&lt;/code&gt; 은 &lt;code&gt;TEMPORARY&lt;/code&gt; 또는 &lt;code&gt;TEMP&lt;/code&gt; 전에 쓸 수 있습니다 . 이것은 현재 PostgreSQL에서 차이가 없으며 더 이상 사용되지 않습니다. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;호환성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a86b4b1bbae5190193648607744f965bba9ad7dc" translate="yes" xml:space="preserve">
          <source>Optionally, a B-tree operator family may provide &lt;code&gt;options&lt;/code&gt; (&amp;ldquo;operator class specific options&amp;rdquo;) support functions, registered under support function number 5. These functions define a set of user-visible parameters that control operator class behavior.</source>
          <target state="translated">선택적으로, B- 트리 운영자 제품군은 지원 기능 번호 5에 등록 된 &lt;code&gt;options&lt;/code&gt; ( &quot;운영자 클래스 특정 옵션&quot;) 지원 기능을 제공 할 수 있습니다. 이러한 기능은 운영자 클래스 동작을 제어하는 ​​사용자가 볼 수있는 매개 변수 세트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8bbcd7d9ec5c4025e28ab09de1e1dc49ba23c52a" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;code&gt;equalimage&lt;/code&gt; (&amp;ldquo;equality implies image equality&amp;rdquo;) support functions, registered under support function number 4. These functions allow the core code to determine when it is safe to apply the btree deduplication optimization. Currently, &lt;code&gt;equalimage&lt;/code&gt; functions are only called when building or rebuilding an index.</source>
          <target state="translated">선택적으로 btree 운영자 제품군은 지원 기능 번호 4에 등록 된 &lt;code&gt;equalimage&lt;/code&gt; ( &quot;equality는 이미지 같음을 의미 함&quot;) 지원 기능을 제공 할 수 있습니다. 이러한 기능을 사용하면 핵심 코드가 btree 중복 제거 최적화를 적용하는 것이 안전한시기를 결정할 수 있습니다. 현재 &lt;code&gt;equalimage&lt;/code&gt; 함수는 인덱스를 빌드하거나 다시 빌드 할 때만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="38ce22db7991e92cf37c1757c548b3362a7ca1aa" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;in_range&lt;/em&gt; support function(s), registered under support function number 3. These are not used during btree index operations; rather, they extend the semantics of the operator family so that it can support window clauses containing the &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame bound types (see &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;). Fundamentally, the extra information provided is how to add or subtract an &lt;code&gt;offset&lt;/code&gt; value in a way that is compatible with the family's data ordering.</source>
          <target state="translated">선택적으로, 운영자 BTREE 가족 제공 &lt;em&gt;in_range의&lt;/em&gt; 지원 기능 번호 3. 이러한 BTREE 인덱스 작업 중에 사용되지 따라 등록 지원 함수 (들); 그것을 포함하는 윈도우 절 지원할 수 있도록 오히려 운영자 가족의 의미를 확장 &lt;code&gt;RANGE&lt;/code&gt; 를 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; 을 및 &lt;code&gt;RANGE&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; 프레임 유형 결합 (참조 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;섹션 4.2.8&lt;/a&gt; ). 기본적으로 제공되는 추가 정보 는 제품군의 데이터 순서와 호환되는 방식으로 &lt;code&gt;offset&lt;/code&gt; 값을 더하거나 빼는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="478c790850d122e707e8f7883dedaa4fc2abbd82" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;sort support&lt;/em&gt; function(s), registered under support function number 2. These functions allow implementing comparisons for sorting purposes in a more efficient way than naively calling the comparison support function. The APIs involved in this are defined in &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt;.</source>
          <target state="translated">선택적으로, btree 운영자 제품군은 지원 기능 번호 2로 등록 된 &lt;em&gt;정렬 지원&lt;/em&gt; 기능을 제공 할 수 있습니다.이 기능을 사용하면 비교 지원 기능을 순진하게 호출하는 것보다 더 효율적인 방식으로 정렬 목적으로 비교를 구현할 수 있습니다. 이와 관련된 API는 &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d0b1d8f44651eff9c08018d57dc26658e0d79ec" translate="yes" xml:space="preserve">
          <source>Optionally, an operator class for GIN can supply the following method:</source>
          <target state="translated">선택적으로 GIN의 연산자 클래스는 다음 방법을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="555fcafecaac1b7a79da77571a044c4fcd960ef4" translate="yes" xml:space="preserve">
          <source>Optionally, integer &lt;em&gt;positions&lt;/em&gt; can be attached to lexemes:</source>
          <target state="translated">선택적으로 정수 &lt;em&gt;위치&lt;/em&gt; 는 렉 세스에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba2c90dde0ab03dd101be9fe39552cd35bcc19fc" translate="yes" xml:space="preserve">
          <source>Optionally, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with one or more weight letters, which restricts them to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes with one of those weights:</source>
          <target state="translated">선택적으로, &lt;code&gt;tsquery&lt;/code&gt; 의 lexemes 는 하나 이상의 가중치 문자로 레이블을 지정할 수 있습니다. 이는 &lt;code&gt;tsvector&lt;/code&gt; lexemes 만 해당 가중치 중 하나와 일치하도록 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="bfb2e74b331377cdefa56e8103510af4757e8e75" translate="yes" xml:space="preserve">
          <source>Options are named to be similar to GnuPG. An option's value should be given after an equal sign; separate options from each other with commas. For example:</source>
          <target state="translated">옵션은 GnuPG와 유사하게 이름이 지정됩니다. 옵션의 값은 등호 뒤에 제공해야합니다. 옵션을 쉼표로 구분하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01c5d645df020042965df6656c79fbcb52302c6d" translate="yes" xml:space="preserve">
          <source>Options for Single-User Mode</source>
          <target state="translated">단일 사용자 모드 옵션</target>
        </trans-unit>
        <trans-unit id="2cc6e913a91a4d81d0ee2eacb713152c147c5122" translate="yes" xml:space="preserve">
          <source>Options for Windows</source>
          <target state="translated">Windows 옵션</target>
        </trans-unit>
        <trans-unit id="0807432116c5005f30d6e9cc2d8f5760b3400db2" translate="yes" xml:space="preserve">
          <source>Options specified for authentication method, if any</source>
          <target state="translated">인증 방법에 지정된 옵션 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="2ba952bec3ffacb85d251e04c62c8891e8cc4022" translate="yes" xml:space="preserve">
          <source>Options to be associated with the new foreign table or one of its columns. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Duplicate option names are not allowed (although it's OK for a table option and a column option to have the same name).</source>
          <target state="translated">새 외부 테이블 또는 해당 컬럼 중 하나와 연관 될 옵션. 허용되는 옵션 이름 및 값은 각 외부 데이터 랩퍼에 고유하며 외부 데이터 랩퍼의 유효성 검증기 기능을 사용하여 유효성이 검증됩니다. 중복 옵션 이름은 허용되지 않습니다 (테이블 옵션과 열 옵션이 동일한 이름을 갖는 것은 괜찮지 만).</target>
        </trans-unit>
        <trans-unit id="ea0cc8f54bce88ccfd10bba527220a016a032c30" translate="yes" xml:space="preserve">
          <source>Options to be used during the import. The allowed option names and values are specific to each foreign data wrapper.</source>
          <target state="translated">가져 오는 동안 사용할 옵션. 허용되는 옵션 이름과 값은 각 외부 데이터 래퍼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9a0c5ecf28319808109742741597da1a162506e4" translate="yes" xml:space="preserve">
          <source>Or, if no array size is to be specified:</source>
          <target state="translated">또는 배열 크기를 지정하지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="57f20b026b33a5f996b1722a8963058f7f139ed9" translate="yes" xml:space="preserve">
          <source>Order in which the entries are processed (1..&lt;code&gt;n&lt;/code&gt;)</source>
          <target state="translated">입력이 처리되는 순서 (1 .. &lt;code&gt;n&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6b71865e60556421edb3dc5a27a33115f8d23b2c" translate="yes" xml:space="preserve">
          <source>Order in which to consult this entry (lower &lt;code&gt;mapseqno&lt;/code&gt;s first)</source>
          <target state="translated">이 항목을 참조하는 순서 ( 먼저 &lt;code&gt;mapseqno&lt;/code&gt; s)</target>
        </trans-unit>
        <trans-unit id="9032c5927654c6b139387affcba7ab64e16f3699" translate="yes" xml:space="preserve">
          <source>Ordering Operators</source>
          <target state="translated">주문 연산자</target>
        </trans-unit>
        <trans-unit id="bb496dd08aebe7c50e13b0f636e3490f9e72e352" translate="yes" xml:space="preserve">
          <source>Ordinarily a cast must have different source and target data types. However, it is allowed to declare a cast with identical source and target types if it has a cast implementation function with more than one argument. This is used to represent type-specific length coercion functions in the system catalogs. The named function is used to coerce a value of the type to the type modifier value given by its second argument.</source>
          <target state="translated">일반적으로 캐스트는 다른 소스 및 대상 데이터 유형을 가져야합니다. 그러나 둘 이상의 인수가있는 캐스트 구현 함수가있는 경우 동일한 소스 및 대상 유형으로 캐스트를 선언 할 수 있습니다. 시스템 카탈로그에서 유형별 길이 강제 함수를 나타내는 데 사용됩니다. 명명 된 함수는 유형의 값을 두 번째 인수가 제공하는 유형 수정 자 값으로 강제 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="23ae1f89c4cafddef64330187ff525b64ad51110" translate="yes" xml:space="preserve">
          <source>Ordinarily, PostgreSQL functions are expected to be true functions that do not modify their input values. However, an aggregate transition function, &lt;em&gt;when used in the context of an aggregate&lt;/em&gt;, is allowed to cheat and modify its transition-state argument in place. This can provide substantial performance benefits compared to making a fresh copy of the transition state each time.</source>
          <target state="translated">일반적으로 PostgreSQL 함수는 입력 값을 수정하지 않는 실제 함수일 것으로 예상됩니다. 그러나 집계 &lt;em&gt;컨텍스트에서 사용되는&lt;/em&gt; 집계 전이 함수 는 해당 전이 상태 인수를 속이고 수정하는 것이 허용됩니다. 이것은 매번 전환 상태의 새로운 사본을 만드는 것과 비교하여 상당한 성능 이점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0095250f58080cd4f7b0263a9f790d13029e21" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a date/time string is syntactically valid but contains out-of-range field values, an error will be thrown. For example, input specifying the 31st of February will be rejected.</source>
          <target state="translated">일반적으로 날짜 / 시간 문자열이 구문 상 유효하지만 범위를 벗어난 필드 값을 포함하는 경우 오류가 발생합니다. 예를 들어, 2 월 31 일을 지정하는 입력은 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="d469c00e9517d285e5591f4a6f0cfdb929fc4475" translate="yes" xml:space="preserve">
          <source>Ordinarily, only the object's owner (or a superuser) can grant or revoke privileges on an object. However, it is possible to grant a privilege &amp;ldquo;with grant option&amp;rdquo;, which gives the recipient the right to grant it in turn to others. If the grant option is subsequently revoked then all who received the privilege from that recipient (directly or through a chain of grants) will lose the privilege. For details see the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; reference pages.</source>
          <target state="translated">일반적으로 개체 소유자 (또는 수퍼 유저) 만 개체에 대한 권한을 부여하거나 취소 할 수 있습니다. 그러나 &quot;권한 부여 옵션으로&quot;권한을 부여하면 수신자에게 다른 사람에게 권한을 부여 할 수있는 권한이 부여됩니다. 그랜트 옵션이 그 후에 취소되면, 그 수신자로부터 (직접 또는 보조금 체인을 통해) 권한을받은 모든 사람은 그 권한을 잃게됩니다. 자세한 내용은 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 및 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; 참조 페이지 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1198b431d5751f4a8f2d46d9894c80568e5c546c" translate="yes" xml:space="preserve">
          <source>Ordinarily, the input rows are fed to the aggregate function in an unspecified order. In many cases this does not matter; for example, &lt;code&gt;min&lt;/code&gt; produces the same result no matter what order it receives the inputs in. However, some aggregate functions (such as &lt;code&gt;array_agg&lt;/code&gt; and &lt;code&gt;string_agg&lt;/code&gt;) produce results that depend on the ordering of the input rows. When using such an aggregate, the optional &lt;code&gt;order_by_clause&lt;/code&gt; can be used to specify the desired ordering. The &lt;code&gt;order_by_clause&lt;/code&gt; has the same syntax as for a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, as described in &lt;a href=&quot;queries-order&quot;&gt;Section 7.5&lt;/a&gt;, except that its expressions are always just expressions and cannot be output-column names or numbers. For example:</source>
          <target state="translated">일반적으로 입력 행은 지정되지 않은 순서로 집계 함수에 제공됩니다. 많은 경우에 이것은 중요하지 않습니다. 예를 들어 &lt;code&gt;min&lt;/code&gt; 은 입력을받는 순서에 상관없이 동일한 결과를 생성합니다. 그러나 &lt;code&gt;array_agg&lt;/code&gt; 및 &lt;code&gt;string_agg&lt;/code&gt; 와 같은 일부 집계 함수 는 입력 행의 순서에 따라 결과를 생성합니다. 이러한 집계를 사용할 때 선택적 &lt;code&gt;order_by_clause&lt;/code&gt; 를 사용하여 원하는 순서를 지정할 수 있습니다. &lt;code&gt;order_by_clause&lt;/code&gt; 는 쿼리 수준과 동일한 구문은 &lt;code&gt;ORDER BY&lt;/code&gt; 에 설명 된대로 절을 &lt;a href=&quot;queries-order&quot;&gt;7.5 절&lt;/a&gt;의 표현식은 항상 표현식 일 뿐이며 출력 열 이름 또는 숫자 일 수는 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a1751155e24c2b7f81369ad2aa106588546c4f5" translate="yes" xml:space="preserve">
          <source>Ordinarily, the user must have the PostgreSQL superuser privilege to register a new language. However, the owner of a database can register a new language within that database if the language is listed in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog and is marked as allowed to be created by database owners (&lt;code&gt;tmpldbacreate&lt;/code&gt; is true). The default is that trusted languages can be created by database owners, but this can be adjusted by superusers by modifying the contents of &lt;code&gt;pg_pltemplate&lt;/code&gt;. The creator of a language becomes its owner and can later drop it, rename it, or assign it to a new owner.</source>
          <target state="translated">일반적으로 새 언어를 등록하려면 사용자에게 PostgreSQL 수퍼 유저 권한이 있어야합니다. 그러나 언어가 &lt;code&gt;pg_pltemplate&lt;/code&gt; 카탈로그에 나열되어 있고 데이터베이스 소유자가 작성할 수있는 것으로 표시되어 있으면 ( &lt;code&gt;tmpldbacreate&lt;/code&gt; 가 true) 데이터베이스 소유자 가 해당 데이터베이스 내에서 새 언어를 등록 할 수 있습니다 . 디폴트는 데이터베이스 소유자가 신뢰할 수있는 언어를 작성할 수 있지만 &lt;code&gt;pg_pltemplate&lt;/code&gt; 의 내용을 수정하여 수퍼 유저가 조정할 수있는 것 입니다. 언어 작성자는 소유자가되어 나중에 언어를 삭제하거나 이름을 바꾸거나 새 소유자에게 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d31ebd6359b908a6b08b46621a9edc9ed8848a84" translate="yes" xml:space="preserve">
          <source>Ordinarily, there will be only a single WAL range. However, if a backup is taken from a standby which switches timelines during the backup due to an upstream promotion, it is possible for multiple ranges to be present, each with a different timeline. There will never be multiple WAL ranges present for the same timeline.</source>
          <target state="translated">일반적으로 WAL 범위는 하나만 있습니다. 그러나 업스트림 프로모션으로 인해 백업 중에 타임 라인을 전환하는 대기에서 백업을 가져 오는 경우 각각 다른 타임 라인을 가진 여러 범위가 존재할 수 있습니다. 동일한 타임 라인에 대해 여러 WAL 범위가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49558321bc55879a8f79a252d13bd83f15cac2ec" translate="yes" xml:space="preserve">
          <source>Ordinary comparison operators yield null (signifying &amp;ldquo;unknown&amp;rdquo;), not true or false, when either input is null. For example, &lt;code&gt;7 = NULL&lt;/code&gt; yields null, as does &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt;. When this behavior is not suitable, use the &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; predicates:</source>
          <target state="translated">일반적인 비교 연산자는 입력 중 하나가 null 인 경우 true 또는 false가 아닌 null ( &quot;알 수 없음&quot;을 나타냄)을 생성합니다. 예를 들어 &lt;code&gt;7 = NULL&lt;/code&gt; 은 &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt; 과 같이 null이 됩니다 . 이 동작이 적합하지 않은 경우 &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; 술어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1f51e9682012527e72ed015353424811e9ad8a4d" translate="yes" xml:space="preserve">
          <source>Ordinary text is allowed in &lt;code&gt;to_char&lt;/code&gt; templates and will be output literally. You can put a substring in double quotes to force it to be interpreted as literal text even if it contains template patterns. For example, in &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; will be replaced by the year data, but the single &lt;code&gt;Y&lt;/code&gt; in &lt;code&gt;Year&lt;/code&gt; will not be. In &lt;code&gt;to_date&lt;/code&gt;, &lt;code&gt;to_number&lt;/code&gt;, and &lt;code&gt;to_timestamp&lt;/code&gt;, literal text and double-quoted strings result in skipping the number of characters contained in the string; for example &lt;code&gt;&quot;XX&quot;&lt;/code&gt; skips two input characters (whether or not they are &lt;code&gt;XX&lt;/code&gt;).</source>
          <target state="translated">일반 텍스트는 &lt;code&gt;to_char&lt;/code&gt; 템플릿 에서 허용되며 문자 그대로 출력됩니다. 템플릿 패턴이 포함 된 경우에도 하위 문자열을 큰 따옴표로 묶어 리터럴 텍스트로 해석 할 수 있습니다. 예를 들어,에서 &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt; 는 &lt;code&gt;YYYY&lt;/code&gt; 는 연도 데이터로 대체되지만, 단일 &lt;code&gt;Y&lt;/code&gt; 에서 &lt;code&gt;Year&lt;/code&gt; 되지 않습니다. 에서 &lt;code&gt;to_date&lt;/code&gt; , &lt;code&gt;to_number&lt;/code&gt; 및 &lt;code&gt;to_timestamp&lt;/code&gt; , 문자 텍스트를 두 번 인용 문자열은 문자열에 포함 된 문자 수를 건너 뛰는 결과; 예를 들어 &lt;code&gt;&quot;XX&quot;&lt;/code&gt; 는 두 개의 입력 문자를 (가 있는지 여부를 건너 뜁니다 &lt;code&gt;XX&lt;/code&gt; 를 ).</target>
        </trans-unit>
        <trans-unit id="47deb2333130b0b71a558b913d84907ec715a39c" translate="yes" xml:space="preserve">
          <source>Original UNIX crypt</source>
          <target state="translated">원래 UNIX 크립</target>
        </trans-unit>
        <trans-unit id="728421f1a8e764e582012583a50320fee679ab3e" translate="yes" xml:space="preserve">
          <source>Original author: Gene Selkov, Jr. &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt;, Mathematics and Computer Science Division, Argonne National Laboratory.</source>
          <target state="translated">원저자 : Gene Selkov, Jr. &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt; , Argonne National Laboratory의 수학 및 컴퓨터 과학과.</target>
        </trans-unit>
        <trans-unit id="15c3cbc7d90ec04ca02171128016ae7aa1d06c07" translate="yes" xml:space="preserve">
          <source>Original version by Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;. Rewritten in version 8.4 to suit new FSM implementation by Heikki Linnakangas &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Mark Kirkwood의 원본 버전 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt; . Heikki Linnakangas &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt; &amp;gt;의 새로운 FSM 구현에 맞게 버전 8.4로 다시 작성</target>
        </trans-unit>
        <trans-unit id="6c3f5ca5b9a803aee38134c4fbdc2dd67fcb8f9e" translate="yes" xml:space="preserve">
          <source>Other clients and libraries might provide their own mechanisms, via the shell or otherwise, that allow the user to alter session settings without direct use of SQL commands.</source>
          <target state="translated">다른 클라이언트 및 라이브러리는 쉘을 통해 또는 사용자가 SQL 명령을 직접 사용하지 않고도 세션 설정을 변경할 수있는 자체 메커니즘을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b025a6555e41ac8947f0005aa2f96a2fbcedc20" translate="yes" xml:space="preserve">
          <source>Other database systems might advance these values more frequently.</source>
          <target state="translated">다른 데이터베이스 시스템은이 값을 더 자주 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16dab4fb6d3b76123e52d90af3ba7c8bf6cdec38" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future.</source>
          <target state="translated">앞으로 다른 의존성 향료가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d54e9e4d1cedbb61d73910e1c0331a6b34276e3c" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future. Note in particular that the current definition only supports roles as referenced objects.</source>
          <target state="translated">앞으로 다른 의존성 향료가 필요할 수 있습니다. 특히 현재 정의는 참조 된 개체로서의 역할 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b090b2cc862f6eb58c39020ceea8daeedfe6f7b3" translate="yes" xml:space="preserve">
          <source>Other digest algorithms</source>
          <target state="translated">다른 다이제스트 알고리즘</target>
        </trans-unit>
        <trans-unit id="dd97a9c89af824879fb23956d987ca3355ff4cc8" translate="yes" xml:space="preserve">
          <source>Other libraries can also be preloaded. By preloading a shared library, the library startup time is avoided when the library is first used. However, the time to start each new server process might increase slightly, even if that process never uses the library. So this parameter is recommended only for libraries that will be used in most sessions. Also, changing this parameter requires a server restart, so this is not the right setting to use for short-term debugging tasks, say. Use &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; for that instead.</source>
          <target state="translated">다른 라이브러리도 미리로드 할 수 있습니다. 공유 라이브러리를 사전로드하면 라이브러리를 처음 사용할 때 라이브러리 시작 시간을 피할 수 있습니다. 그러나 해당 프로세스가 라이브러리를 사용하지 않더라도 각각의 새 서버 프로세스를 시작하는 시간이 약간 증가 할 수 있습니다. 따라서이 매개 변수는 대부분의 세션에서 사용될 라이브러리에만 권장됩니다. 또한이 매개 변수를 변경하면 서버를 다시 시작해야하므로 단기 디버깅 작업에 적합한 설정이 아닙니다. 대신 &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c67ab500e2007fcfd325e1fcf258d410b75fddd" translate="yes" xml:space="preserve">
          <source>Other notes for &lt;code&gt;log_min_duration_statement&lt;/code&gt; apply also to this setting.</source>
          <target state="translated">&lt;code&gt;log_min_duration_statement&lt;/code&gt; 에 대한 다른 참고 사항 도이 설정에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b92deff69f1b0201e91466736d1490cd0ff7c6" translate="yes" xml:space="preserve">
          <source>Other object types, such as &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;roles&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;tablespaces&lt;/a&gt;, replication origins, subscriptions for logical replication, and databases themselves are not local SQL objects since they exist entirely outside of any specific database; they are called &lt;em&gt;global objects&lt;/em&gt;. The names of such objects are enforced to be unique within the whole database cluster.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;역할&lt;/a&gt; , &lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;테이블 스페이스&lt;/a&gt; , 복제 오리진, 논리적 복제를위한 구독 및 데이터베이스 자체와 같은 다른 개체 유형 은 특정 데이터베이스 외부에 완전히 존재하므로 로컬 SQL 개체가 아닙니다. 이를 &lt;em&gt;전역 개체&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 이러한 개체의 이름은 전체 데이터베이스 클러스터 내에서 고유하도록 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6d149d1176a026cafb96a0f82667c8ba54a10c" translate="yes" xml:space="preserve">
          <source>Other options are also available:</source>
          <target state="translated">다른 옵션도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="translated">다른 옵션:</target>
        </trans-unit>
        <trans-unit id="c97d8649180973af39b8407abdf8e46bf80d94a0" translate="yes" xml:space="preserve">
          <source>Other punctuation is ignored. So like &lt;code&gt;plainto_tsquery&lt;/code&gt; and &lt;code&gt;phraseto_tsquery&lt;/code&gt;, the &lt;code&gt;websearch_to_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input.</source>
          <target state="translated">다른 구두점은 무시됩니다. 따라서 &lt;code&gt;plainto_tsquery&lt;/code&gt; 및 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 와 마찬가지로 &lt;code&gt;websearch_to_tsquery&lt;/code&gt; 함수는 입력에서 &lt;code&gt;tsquery&lt;/code&gt; 연산자, 가중치 레이블 또는 접두사 일치 레이블을 인식하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="da25b0d9d5dc45c67ed8cb3f27503780b4aa4443" translate="yes" xml:space="preserve">
          <source>Other recommended kernel setting changes for database servers which will have a large number of connections are:</source>
          <target state="translated">연결 수가 많은 데이터베이스 서버에 대한 다른 권장 커널 설정 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3903dba9afe98748981ae8bb62ee1e14b5b5b0bf" translate="yes" xml:space="preserve">
          <source>Other scan types, such as scans of non-btree indexes, may support parallel scans in the future.</source>
          <target state="translated">Btree가 아닌 인덱스의 스캔과 같은 다른 스캔 유형은 향후 병렬 스캔을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c88c65d71407192da2177c969f1b4c3e1b24c5ec" translate="yes" xml:space="preserve">
          <source>Other systems may only allow setting the time source on boot. On older Linux systems the &quot;clock&quot; kernel setting is the only way to make this sort of change. And even on some more recent ones, the only option you'll see for a clock source is &quot;jiffies&quot;. Jiffies are the older Linux software clock implementation, which can have good resolution when it's backed by fast enough timing hardware, as in this example:</source>
          <target state="translated">다른 시스템은 부팅시 시간 소스 설정 만 허용 할 수 있습니다. 구형 Linux 시스템에서는 &quot;시계&quot;커널 설정이 이러한 종류의 변경을 수행 할 수있는 유일한 방법입니다. 그리고 더 최근의 것에서도 클럭 소스에 대해 볼 수있는 유일한 옵션은 &quot;지피&quot;입니다. Jiffies는 이전 Linux 소프트웨어 시계 구현으로,이 예에서와 같이 빠른 타이밍 하드웨어로 백업 할 때 좋은 해상도를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a2d21cbb1de6f88a1dcf3d541f364a9e95c1127" translate="yes" xml:space="preserve">
          <source>Other than configuration of the negotiation behavior, GSSAPI encryption requires no setup beyond that which is necessary for GSSAPI authentication. (For more information on configuring that, see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt;.)</source>
          <target state="translated">협상 동작 구성 외에 GSSAPI 암호화는 GSSAPI 인증에 필요한 것 이상의 설정이 필요하지 않습니다. (구성에 대한 자세한 내용 &lt;a href=&quot;gssapi-auth&quot;&gt;은 20.6 단원을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d21779594b1e9934ec89f12215df7e04fc45898b" translate="yes" xml:space="preserve">
          <source>Other ways of looking at the statistics can be set up by writing queries that use the same underlying statistics access functions used by the standard views shown above. For details such as the functions' names, consult the definitions of the standard views. (For example, in psql you could issue &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt;.) The access functions for per-database statistics take a database OID as an argument to identify which database to report on. The per-table and per-index functions take a table or index OID. The functions for per-function statistics take a function OID. Note that only tables, indexes, and functions in the current database can be seen with these functions.</source>
          <target state="translated">통계를 보는 다른 방법은 위에 표시된 표준보기에서 사용하는 것과 동일한 기본 통계 액세스 기능을 사용하는 쿼리를 작성하여 설정할 수 있습니다. 함수 이름과 같은 세부 사항은 표준보기의 정의를 참조하십시오. (예를 들어, psql에서 &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt; 발행 할 수 있습니다.) 데이터베이스 별 통계에 대한 액세스 함수는보고 할 데이터베이스를 식별하기 위해 데이터베이스 OID를 인수로 사용합니다. 테이블 별 및 인덱스 별 함수는 테이블 또는 인덱스 OID를 사용합니다. 기능별 통계 기능은 기능 OID를 사용합니다. 현재 데이터베이스의 테이블, 인덱스 및 함수 만 이러한 함수로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5209293ce5b675774d27db322f4e25b9f78fde50" translate="yes" xml:space="preserve">
          <source>Other, less commonly used, options are also available:</source>
          <target state="translated">덜 일반적으로 사용되는 다른 옵션도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f791018da698782167efe67330f3a311425f18" translate="yes" xml:space="preserve">
          <source>Otherwise the date field ordering is assumed to follow the &lt;code&gt;DateStyle&lt;/code&gt; setting: mm-dd-yy, dd-mm-yy, or yy-mm-dd. Throw an error if a month or day field is found to be out of range.</source>
          <target state="translated">그렇지 않으면 날짜 필드 순서는 &lt;code&gt;DateStyle&lt;/code&gt; 설정 (mm-dd-yy, dd-mm-yy 또는 yy-mm-dd) 을 따르는 것으로 가정합니다 . 월 또는 일 필드가 범위를 벗어난 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="456174149b4fb59cccb0b858ebfab00191262c8b" translate="yes" xml:space="preserve">
          <source>Otherwise, all input expressions must have the same implicit collation derivation or the default collation. If any non-default collation is present, that is the result of the collation combination. Otherwise, the result is the default collation.</source>
          <target state="translated">그렇지 않으면 모든 입력 표현식에 동일한 암시 적 데이터 정렬 파생 또는 기본 데이터 정렬이 있어야합니다. 기본이 아닌 데이터 정렬이 있으면 데이터 정렬 조합의 결과입니다. 그렇지 않으면 결과가 기본 데이터 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="d7ebacc516a1689e9342c3f059955ce6038791c1" translate="yes" xml:space="preserve">
          <source>Otherwise, choose the last non-unknown input type that allows all the preceding non-unknown inputs to be implicitly converted to it. (There always is such a type, since at least the first type in the list must satisfy this condition.)</source>
          <target state="translated">그렇지 않으면, 모든 이전의 알려지지 않은 입력이 암시 적으로 변환 될 수 있도록 알려지지 않은 마지막 입력 유형을 선택하십시오. (목록의 첫 번째 유형이이 조건을 충족해야하므로 항상 이러한 유형이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="c834d57b171be985e3943329b0a6b22664e27dab" translate="yes" xml:space="preserve">
          <source>Otherwise, color is not used.</source>
          <target state="translated">그렇지 않으면 색상이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9c2a604b8999f698fdb4a51e3a4309645319d17" translate="yes" xml:space="preserve">
          <source>Otherwise, if the JSON value is a string literal, the contents of the string are fed to the input conversion function for the column's data type.</source>
          <target state="translated">그렇지 않으면 JSON 값이 문자열 리터럴 인 경우 문자열의 컨텐츠는 열의 데이터 유형에 대한 입력 변환 함수에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8a7f14af2eabfd7eaf13755e5438dd8fa6b532ed" translate="yes" xml:space="preserve">
          <source>Otherwise, if the JSON value is a string, the contents of the string are fed to the input conversion function for the column's data type.</source>
          <target state="translated">그렇지 않고 JSON 값이 문자열이면 문자열의 내용이 열의 데이터 유형에 대한 입력 변환 함수에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7bead17837ca29580c9cb15e38f0a813be5d9242" translate="yes" xml:space="preserve">
          <source>Otherwise, the ordinary text representation of the JSON value is fed to the input conversion function for the column's data type.</source>
          <target state="translated">그렇지 않으면 JSON 값의 일반 텍스트 표현이 열의 데이터 유형에 대한 입력 변환 함수에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c91502e459c401481e3ca0162bbcb613cfb57d2b" translate="yes" xml:space="preserve">
          <source>Otherwise, try to convert the expression to the target type. This is possible if an &lt;em&gt;assignment cast&lt;/em&gt; between the two types is registered in the &lt;code&gt;pg_cast&lt;/code&gt; catalog (see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;). Alternatively, if the expression is an unknown-type literal, the contents of the literal string will be fed to the input conversion routine for the target type.</source>
          <target state="translated">그렇지 않으면 표현식을 대상 유형으로 변환하십시오. 두 유형 간의 &lt;em&gt;할당 캐스트&lt;/em&gt; 가 &lt;code&gt;pg_cast&lt;/code&gt; 카탈로그에 등록 된 경우 가능합니다 ( &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; 참조 ). 또는 표현식이 알 수없는 유형 리터럴 인 경우 리터럴 문자열의 컨텐츠는 대상 유형에 대한 입력 변환 루틴으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="43c3af901aa493d7824a6ced3329413231661c11" translate="yes" xml:space="preserve">
          <source>Out-of-line values are divided (after compression if used) into chunks of at most &lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; bytes (by default this value is chosen so that four chunk rows will fit on a page, making it about 2000 bytes). Each chunk is stored as a separate row in the TOAST table belonging to the owning table. Every TOAST table has the columns &lt;code&gt;chunk_id&lt;/code&gt; (an OID identifying the particular TOASTed value), &lt;code&gt;chunk_seq&lt;/code&gt; (a sequence number for the chunk within its value), and &lt;code&gt;chunk_data&lt;/code&gt; (the actual data of the chunk). A unique index on &lt;code&gt;chunk_id&lt;/code&gt; and &lt;code&gt;chunk_seq&lt;/code&gt; provides fast retrieval of the values. A pointer datum representing an out-of-line on-disk TOASTed value therefore needs to store the OID of the TOAST table in which to look and the OID of the specific value (its &lt;code&gt;chunk_id&lt;/code&gt;). For convenience, pointer datums also store the logical datum size (original uncompressed data length) and physical stored size (different if compression was applied). Allowing for the varlena header bytes, the total size of an on-disk TOAST pointer datum is therefore 18 bytes regardless of the actual size of the represented value.</source>
          <target state="translated">라인 외부 값은 사용 된 경우 압축 후 최대 &lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; 바이트의 청크로 나뉩니다 ( 기본적으로이 값은 4 개의 청크 행이 페이지에 맞도록 선택되어 약 2000 바이트가됩니다). 각 청크는 소유 테이블에 속하는 TOAST 테이블에 별도의 행으로 저장됩니다. 모든 TOAST 테이블에는 &lt;code&gt;chunk_id&lt;/code&gt; (특정 TOAST 값을 식별하는 OID), &lt;code&gt;chunk_seq&lt;/code&gt; (값 내 청크의 시퀀스 번호) 및 &lt;code&gt;chunk_data&lt;/code&gt; (청크의 실제 데이터) 열이 있습니다. &lt;code&gt;chunk_id&lt;/code&gt; 및 &lt;code&gt;chunk_seq&lt;/code&gt; 의 고유 인덱스값을 빠르게 검색합니다. 따라서 디스크 외부의 디스크 TOAST 값을 나타내는 포인터 데이텀은 찾아야 할 TOAST 테이블의 OID와 특정 값의 OID ( &lt;code&gt;chunk_id&lt;/code&gt; )를 저장해야합니다. 편의상 포인터 데이텀은 논리 데이텀 크기 (원래의 비 압축 데이터 길이)와 실제 저장된 크기 (압축이 적용된 경우에 따라 다름)도 저장합니다. varlena 헤더 바이트를 허용하면 디스크상의 TOAST 포인터 데이텀의 총 크기는 표시된 값의 실제 크기에 관계없이 18 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="97c53cd2b521753c0d717a86dd39f58035793149" translate="yes" xml:space="preserve">
          <source>Output Length</source>
          <target state="translated">출력 길이</target>
        </trans-unit>
        <trans-unit id="afe32b815eb6ac2d448375f1b337e892bc780a8c" translate="yes" xml:space="preserve">
          <source>Output Result</source>
          <target state="translated">출력 결과</target>
        </trans-unit>
        <trans-unit id="a19289a8a65e3eaa1c70019f70d69f0ccdc7e3cc" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="translated">&lt;code&gt;ALTER OWNER&lt;/code&gt; 명령 대신 SQL 표준 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 명령을 출력 하여 오브젝트 소유권을 판별하십시오. 이로 인해 덤프 표준이 호환되지만 덤프의 오브젝트 히스토리에 따라 올바르게 복원되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d49ccd8d61f0c2e0d773215d12c820e621fe051" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="translated">&lt;code&gt;ALTER OWNER&lt;/code&gt; 명령 대신 SQL 표준 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 명령을 출력 하여 오브젝트 소유권을 판별하십시오. 이렇게하면 덤프가 표준과 호환되지만 덤프의 오브젝트 히스토리에 따라 제대로 복원되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4625db4629522bcdf0c7c483ff44db087396b6a5" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly. Also, a dump using &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; will certainly require superuser privileges to restore correctly, whereas &lt;code&gt;ALTER OWNER&lt;/code&gt; requires lesser privileges.</source>
          <target state="translated">&lt;code&gt;ALTER OWNER&lt;/code&gt; 명령 대신 SQL 표준 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 명령을 출력 하여 오브젝트 소유권을 판별하십시오. 이로 인해 덤프가 표준과 호환되지만 덤프의 오브젝트 히스토리에 따라 올바르게 복원되지 않을 수 있습니다. 또한 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 을 사용하는 덤프 는 올바르게 복원하려면 수퍼 유저 권한이 필요 하지만 &lt;code&gt;ALTER OWNER&lt;/code&gt; 는 더 적은 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2005b7d907d65c19aff7a047dfc1b1dcc52ef1ca" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;tar&lt;/code&gt;-format archive suitable for input into pg_restore. The tar format is compatible with the directory format: extracting a tar-format archive produces a valid directory-format archive. However, the tar format does not support compression. Also, when using tar format the relative order of table data items cannot be changed during restore.</source>
          <target state="translated">pg_restore에 입력하기에 적합한 &lt;code&gt;tar&lt;/code&gt; 형식의 아카이브를 출력합니다 . tar 형식은 디렉토리 형식과 호환됩니다. tar 형식 아카이브를 추출하면 유효한 디렉토리 형식 아카이브가 생성됩니다. 그러나 tar 형식은 압축을 지원하지 않습니다. 또한 tar 형식을 사용하는 경우 복원 중에 테이블 데이터 항목의 상대 순서를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2eb830dc0187c951bb3c38e2fc9ae11b3f83d2a4" translate="yes" xml:space="preserve">
          <source>Output a custom-format archive suitable for input into pg_restore. Together with the directory output format, this is the most flexible output format in that it allows manual selection and reordering of archived items during restore. This format is also compressed by default.</source>
          <target state="translated">pg_restore에 입력하기에 적합한 사용자 정의 형식 아카이브를 출력하십시오. 디렉토리 출력 형식과 함께, 복원 중에 아카이브 된 항목을 수동으로 선택하고 순서를 변경할 수있는 가장 유연한 출력 형식입니다. 이 형식은 기본적으로 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="314bcb0a58dea88f5b77ecfb141e26b87d6cd0bf" translate="yes" xml:space="preserve">
          <source>Output a directory-format archive suitable for input into pg_restore. This will create a directory with one file for each table and blob being dumped, plus a so-called Table of Contents file describing the dumped objects in a machine-readable format that pg_restore can read. A directory format archive can be manipulated with standard Unix tools; for example, files in an uncompressed archive can be compressed with the gzip tool. This format is compressed by default and also supports parallel dumps.</source>
          <target state="translated">pg_restore에 입력하기에 적합한 디렉토리 형식 아카이브를 출력하십시오. 그러면 pg_restore가 읽을 수있는 기계가 읽을 수있는 형식으로 덤프 된 오브젝트를 설명하는 소위 목차 파일과 각 테이블 및 블로 브에 대해 하나의 파일이있는 디렉토리가 작성됩니다. 디렉토리 형식 아카이브는 표준 Unix 도구를 사용하여 조작 할 수 있습니다. 예를 들어, 압축되지 않은 아카이브의 파일은 gzip 도구를 사용하여 압축 할 수 있습니다. 이 형식은 기본적으로 압축되며 병렬 덤프도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9af173b4747fa54411d828576f57ede6b623e6c6" translate="yes" xml:space="preserve">
          <source>Output a plain-text SQL script file (the default).</source>
          <target state="translated">일반 텍스트 SQL 스크립트 파일을 출력합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="8bdf0890d1e63cc1cfc92f91594ac95c633ba722" translate="yes" xml:space="preserve">
          <source>Output commands to clean (drop) database objects prior to outputting the commands for creating them. (Unless &lt;code&gt;--if-exists&lt;/code&gt; is also specified, restore might generate some harmless error messages, if any objects were not present in the destination database.)</source>
          <target state="translated">데이터베이스 오브젝트를 작성하기위한 명령을 출력하기 전에 데이터베이스 오브젝트를 정리 (삭제)하는 출력 명령. ( &lt;code&gt;--if-exists&lt;/code&gt; 하는 것도 지정하지 않으면 대상 데이터베이스에 개체가없는 경우 복원시 무해한 오류 메시지가 생성 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="48cd5d324665dcd708893b4a104e4fb4fecb1e8f" translate="yes" xml:space="preserve">
          <source>Output conversion function (binary format), or 0 if none</source>
          <target state="translated">출력 변환 함수 (이진 형식) 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="3bc8730df1e12ab656e0ea8398920726728cdbcd" translate="yes" xml:space="preserve">
          <source>Output conversion function (text format)</source>
          <target state="translated">출력 변환 기능 (텍스트 형식)</target>
        </trans-unit>
        <trans-unit id="2d850ce6c63d0f20826daa05520cced6f2083334" translate="yes" xml:space="preserve">
          <source>Output detailed information about backup blocks.</source>
          <target state="translated">백업 블록에 대한 자세한 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="babad7640e9f136cd19423d495f4b1ee0fee89a9" translate="yes" xml:space="preserve">
          <source>Output is always in the standard form.</source>
          <target state="translated">출력은 항상 표준 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7835db447bc76230b5b0d736b2d78c671d7100a1" translate="yes" xml:space="preserve">
          <source>Outputs</source>
          <target state="translated">Outputs</target>
        </trans-unit>
        <trans-unit id="cdfe59de620bc8ec7ec39dbaf869451006fe122e" translate="yes" xml:space="preserve">
          <source>Outputs information about the current database connection.</source>
          <target state="translated">현재 데이터베이스 연결에 대한 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="a3ae7cd3ba4b5d3440099a3b3e44c0885cc411f2" translate="yes" xml:space="preserve">
          <source>Overlaps or is left of &amp;mdash; This might be better read as &amp;ldquo;does not extend to right of&amp;rdquo;. It is true when b &amp;lt;= d.</source>
          <target state="translated">겹치거나 남음 &amp;mdash;&amp;ldquo;오른쪽으로 확장되지 않음&amp;rdquo;으로 읽는 것이 좋습니다. b &amp;lt;= d 인 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="e3d201e01172e474738c7662f57e70ca764bc088" translate="yes" xml:space="preserve">
          <source>Overlaps or is right of &amp;mdash; This might be better read as &amp;ldquo;does not extend to left of&amp;rdquo;. It is true when a &amp;gt;= c.</source>
          <target state="translated">겹치거나 오른쪽에 있음-&amp;ldquo;왼쪽으로 확장되지 않음&amp;rdquo;으로 더 잘 읽을 수 있습니다. a&amp;gt; = c 인 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="7af34d74e482413c9143a47da7e672969aed843a" translate="yes" xml:space="preserve">
          <source>Overlaps? (One point in common makes this true.)</source>
          <target state="translated">중복? (한 점이 공통적으로 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="cb2f163ccc20cb7388203cf1edbc6860b44ea0f0" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Overloading</target>
        </trans-unit>
        <trans-unit id="a2fd113f354ec9ec1edb291682b81f94fe430ddc" translate="yes" xml:space="preserve">
          <source>Owner of the collation</source>
          <target state="translated">데이터 정렬의 소유자</target>
        </trans-unit>
        <trans-unit id="b7eb54933c030e119dce1086dc82e09c41077f94" translate="yes" xml:space="preserve">
          <source>Owner of the configuration</source>
          <target state="translated">구성 소유자</target>
        </trans-unit>
        <trans-unit id="a47511340c90f2c223a36694793ee22b0651e345" translate="yes" xml:space="preserve">
          <source>Owner of the conversion</source>
          <target state="translated">전환 소유자</target>
        </trans-unit>
        <trans-unit id="9adb637b26bc7a0111112afdc905c0fa9b433b1f" translate="yes" xml:space="preserve">
          <source>Owner of the database, usually the user who created it</source>
          <target state="translated">데이터베이스 소유자, 일반적으로 데이터베이스를 작성한 사용자</target>
        </trans-unit>
        <trans-unit id="1e1395f6076a153ad4fcc55b23348741788d9a0e" translate="yes" xml:space="preserve">
          <source>Owner of the dictionary</source>
          <target state="translated">사전의 소유자</target>
        </trans-unit>
        <trans-unit id="873852f61944660a0d123bafc40c1182f58cd2a5" translate="yes" xml:space="preserve">
          <source>Owner of the event trigger</source>
          <target state="translated">이벤트 트리거의 소유자</target>
        </trans-unit>
        <trans-unit id="e618675166fd8eccc064277b88953a8fdc0951cf" translate="yes" xml:space="preserve">
          <source>Owner of the extended statistics</source>
          <target state="translated">확장 된 통계의 소유자</target>
        </trans-unit>
        <trans-unit id="0e0062122acfc3428eb36e8494aa91cdda1bb823" translate="yes" xml:space="preserve">
          <source>Owner of the extension</source>
          <target state="translated">확장의 소유자</target>
        </trans-unit>
        <trans-unit id="1b3fd58bbcd1cbede99d727eb332a616ef746459" translate="yes" xml:space="preserve">
          <source>Owner of the foreign server</source>
          <target state="translated">외부 서버의 소유자</target>
        </trans-unit>
        <trans-unit id="4abeec384f4e4e4fd2630496e361931c03792e90" translate="yes" xml:space="preserve">
          <source>Owner of the foreign-data wrapper</source>
          <target state="translated">외부 데이터 랩퍼의 소유자</target>
        </trans-unit>
        <trans-unit id="045ebe36026cc33372375251adb04267dd08a6f9" translate="yes" xml:space="preserve">
          <source>Owner of the function</source>
          <target state="translated">기능의 소유자</target>
        </trans-unit>
        <trans-unit id="3de3b296802701c83666e4a9e6c77ad8e092b09c" translate="yes" xml:space="preserve">
          <source>Owner of the language</source>
          <target state="translated">언어의 소유자</target>
        </trans-unit>
        <trans-unit id="5f358242f17294414495cbc231ac35ed8a7ef36f" translate="yes" xml:space="preserve">
          <source>Owner of the large object</source>
          <target state="translated">큰 물체의 소유자</target>
        </trans-unit>
        <trans-unit id="08c133834660a3f3265245c9248f60f1979449d5" translate="yes" xml:space="preserve">
          <source>Owner of the namespace</source>
          <target state="translated">네임 스페이스의 소유자</target>
        </trans-unit>
        <trans-unit id="f3d409145414a207ad5ab1a06298cf4de3e3d79d" translate="yes" xml:space="preserve">
          <source>Owner of the operator</source>
          <target state="translated">운영자의 소유자</target>
        </trans-unit>
        <trans-unit id="4fe1d02890b80f29d14de9cf7c7d720b98ec4436" translate="yes" xml:space="preserve">
          <source>Owner of the operator class</source>
          <target state="translated">연산자 클래스의 소유자</target>
        </trans-unit>
        <trans-unit id="34a092b8bf19aa76f83af3f5f7f00fd4abe9f1da" translate="yes" xml:space="preserve">
          <source>Owner of the operator family</source>
          <target state="translated">운영자 가족의 소유자</target>
        </trans-unit>
        <trans-unit id="530840c2bedf8afbc58ec145a817bd5855b5da2c" translate="yes" xml:space="preserve">
          <source>Owner of the publication</source>
          <target state="translated">간행물의 소유자</target>
        </trans-unit>
        <trans-unit id="f104f465825a18941861fe36eee16972af35d0fd" translate="yes" xml:space="preserve">
          <source>Owner of the relation</source>
          <target state="translated">관계의 소유자</target>
        </trans-unit>
        <trans-unit id="d2d338d2c9f46fc9058acd6bf8b505d62cfd7125" translate="yes" xml:space="preserve">
          <source>Owner of the statistics object</source>
          <target state="translated">통계 개체의 소유자</target>
        </trans-unit>
        <trans-unit id="27aa59e6a53863d7fc75c728e631589d9ef875ce" translate="yes" xml:space="preserve">
          <source>Owner of the subscription</source>
          <target state="translated">구독 소유자</target>
        </trans-unit>
        <trans-unit id="3ca261d2ecfb68a9f64ba043ec469131179f4f2d" translate="yes" xml:space="preserve">
          <source>Owner of the tablespace, usually the user who created it</source>
          <target state="translated">테이블 스페이스의 소유자, 일반적으로 테이블 스페이스를 작성한 사용자</target>
        </trans-unit>
        <trans-unit id="451938c2f2732dd84e3e87dd05cdd4be024d9498" translate="yes" xml:space="preserve">
          <source>Owner of the type</source>
          <target state="translated">유형의 소유자</target>
        </trans-unit>
        <trans-unit id="7a88ac00bf4b0ee2c311712a067ae74712fb2321" translate="yes" xml:space="preserve">
          <source>Ownership of objects can be transferred one at a time using &lt;code&gt;ALTER&lt;/code&gt; commands, for example:</source>
          <target state="translated">&lt;code&gt;ALTER&lt;/code&gt; 명령을 사용하여 한 번에 하나씩 객체의 소유권을 전송할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="880684f9ec2b7a622ac555da2f5f06938c962c51" translate="yes" xml:space="preserve">
          <source>P''(t)</source>
          <target state="translated">P''(t)</target>
        </trans-unit>
        <trans-unit id="6c4b4caa40b248d284230f88cbcd7f13476b2cac" translate="yes" xml:space="preserve">
          <source>P(t)</source>
          <target state="translated">P(t)</target>
        </trans-unit>
        <trans-unit id="f8475eae73fea7de999190d28ead30c11cd46b3b" translate="yes" xml:space="preserve">
          <source>P-1Y-2M3DT-4H-5M-6S</source>
          <target state="translated">P-1Y-2M3DT-4H-5M-6S</target>
        </trans-unit>
        <trans-unit id="637e5ac0a44e83d198f6482aad52a4ee2c33076a" translate="yes" xml:space="preserve">
          <source>P-1Y-2M3D​T-4H-5M-6S</source>
          <target state="translated">P-1Y-2M3D​T-4H-5M-6S</target>
        </trans-unit>
        <trans-unit id="c066b74bc2c03f3472bba6e63d39e90c2e2d20c7" translate="yes" xml:space="preserve">
          <source>P0001-02-03T04:05:06</source>
          <target state="translated">P0001-02-03T04:05:06</target>
        </trans-unit>
        <trans-unit id="579e8ed8bf53a5860299c4787471ee73ec431b5e" translate="yes" xml:space="preserve">
          <source>P1Y2M</source>
          <target state="translated">P1Y2M</target>
        </trans-unit>
        <trans-unit id="bd1aaf321a587301c665f6a19e72881af023a930" translate="yes" xml:space="preserve">
          <source>P1Y2M3DT4H5M6S</source>
          <target state="translated">P1Y2M3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="9ba0b6685e5baca573f3acd95f81a092797985f3" translate="yes" xml:space="preserve">
          <source>P3DT4H5M6S</source>
          <target state="translated">P3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="1dc752ba52c4ea05107706b7e03df6ab354e39ff" translate="yes" xml:space="preserve">
          <source>PAM</source>
          <target state="translated">PAM</target>
        </trans-unit>
        <trans-unit id="388c2af7f59c6eee722356ebc329cec67a8389d7" translate="yes" xml:space="preserve">
          <source>PAM Authentication</source>
          <target state="translated">PAM 인증</target>
        </trans-unit>
        <trans-unit id="9e8eaf2f87853067037437397fcd30a4aa337b20" translate="yes" xml:space="preserve">
          <source>PAM service name.</source>
          <target state="translated">PAM 서비스 이름</target>
        </trans-unit>
        <trans-unit id="0bfd8f66160aa4b77dcdec5d43e4805495e07e18" translate="yes" xml:space="preserve">
          <source>PGP Public-Key encryption</source>
          <target state="translated">PGP 공개 키 암호화</target>
        </trans-unit>
        <trans-unit id="76646f05da6bf5eb4fecf712e1a4c9bffc428604" translate="yes" xml:space="preserve">
          <source>PGP Symmetric encryption</source>
          <target state="translated">PGP 대칭 암호화</target>
        </trans-unit>
        <trans-unit id="4e09cf6b34360609cb4cdd2c5b437e8b7854a05d" translate="yes" xml:space="preserve">
          <source>PGSQL</source>
          <target state="translated">PGSQL</target>
        </trans-unit>
        <trans-unit id="3ba27c9c3666ed10b53aa3320fe270149336d75a" translate="yes" xml:space="preserve">
          <source>PGXS</source>
          <target state="translated">PGXS</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="feee1d9b13144a255359aea6e303897e613b068c" translate="yes" xml:space="preserve">
          <source>PITR</source>
          <target state="translated">PITR</target>
        </trans-unit>
        <trans-unit id="3238a2c23ec52b54d1a9d62034bcdec3628b7db6" translate="yes" xml:space="preserve">
          <source>PL</source>
          <target state="translated">PL</target>
        </trans-unit>
        <trans-unit id="beec5d503ed58c40992ce7fab4af575b48a55538" translate="yes" xml:space="preserve">
          <source>PL/pgSQL handles output parameters in &lt;code&gt;CALL&lt;/code&gt; commands differently; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Section 42.6.3&lt;/a&gt;.</source>
          <target state="translated">PL / pgSQL은 &lt;code&gt;CALL&lt;/code&gt; 명령의 출력 매개 변수를 다르게 처리합니다 . &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;섹션 42.6.3&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="17b76a5d14c8b2c49a6ac06895875148d89695c0" translate="yes" xml:space="preserve">
          <source>PL/pgSQL handles output parameters in &lt;code&gt;CALL&lt;/code&gt; commands differently; see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Section 42.6.3&lt;/a&gt;.</source>
          <target state="translated">PL / pgSQL은 &lt;code&gt;CALL&lt;/code&gt; 명령의 출력 매개 변수를 다르게 처리합니다 . &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;42.6.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="4e03c943de4a471ff8d7eb0aea61351231577229" translate="yes" xml:space="preserve">
          <source>POSIX Time Zone Specifications</source>
          <target state="translated">POSIX 시간대 사양</target>
        </trans-unit>
        <trans-unit id="f586c4a0642bd8530bd206b6d1e6d9b7d935f68f" translate="yes" xml:space="preserve">
          <source>POSIX interprets character classes such as &lt;code&gt;\w&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;) according to the prevailing locale (which you can control by attaching a &lt;code&gt;COLLATE&lt;/code&gt; clause to the operator or function). XQuery specifies these classes by reference to Unicode character properties, so equivalent behavior is obtained only with a locale that follows the Unicode rules.</source>
          <target state="translated">POSIX는 기본 로케일 ( &lt;code&gt;COLLATE&lt;/code&gt; 절을 연산자 또는 함수 에 첨부하여 제어 할 수 있음)에 따라 &lt;code&gt;\w&lt;/code&gt; ( &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;표 9.20&lt;/a&gt; 참조) 와 같은 문자 클래스를 해석합니다 . XQuery는 유니 코드 문자 속성을 참조하여 이러한 클래스를 지정하므로 유니 코드 규칙을 따르는 로캘로만 동등한 동작을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63465644013ae752eee8a21083fea8ac69dc57b1" translate="yes" xml:space="preserve">
          <source>POSIX interprets character classes such as &lt;code&gt;\w&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;) according to the prevailing locale (which you can control by attaching a &lt;code&gt;COLLATE&lt;/code&gt; clause to the operator or function). XQuery specifies these classes by reference to Unicode character properties, so equivalent behavior is obtained only with a locale that follows the Unicode rules.</source>
          <target state="translated">POSIX 는 일반적인 로케일 ( 연산자 또는 함수에 &lt;code&gt;COLLATE&lt;/code&gt; 절을 연결하여 제어 할 수 있음)에 따라 &lt;code&gt;\w&lt;/code&gt; ( &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;표 9.21&lt;/a&gt; 참조) 와 같은 문자 클래스를 해석합니다 . XQuery는 유니 코드 문자 속성을 참조하여 이러한 클래스를 지정하므로 유니 코드 규칙을 따르는 로캘에서만 동등한 동작을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e102feaa5742be5a0f3d3fc50f40fceae7d340a6" translate="yes" xml:space="preserve">
          <source>POSIX regular expressions provide a more powerful means for pattern matching than the &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;SIMILAR TO&lt;/code&gt; operators. Many Unix tools such as &lt;code&gt;egrep&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt;, or &lt;code&gt;awk&lt;/code&gt; use a pattern matching language that is similar to the one described here.</source>
          <target state="translated">POSIX 정규식은 &lt;code&gt;LIKE&lt;/code&gt; 및 &lt;code&gt;SIMILAR TO&lt;/code&gt; 연산자 보다 패턴 일치를위한보다 강력한 수단을 제공합니다 . &lt;code&gt;egrep&lt;/code&gt; , &lt;code&gt;sed&lt;/code&gt; 또는 &lt;code&gt;awk&lt;/code&gt; 와 같은 많은 Unix 도구 는 여기에 설명 된 것과 유사한 패턴 일치 언어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="46e0e2f3d2a15c3b14b95e0c1c7504bef70da246" translate="yes" xml:space="preserve">
          <source>POSIX-style time zone specification</source>
          <target state="translated">POSIX 스타일 시간대 사양</target>
        </trans-unit>
        <trans-unit id="66e2f96d2e144c19219f34885e8aed66af8ec26f" translate="yes" xml:space="preserve">
          <source>PREPARE</source>
          <target state="translated">PREPARE</target>
        </trans-unit>
        <trans-unit id="497f657a7bd6c59491c1afe2f14778a0325e0aeb" translate="yes" xml:space="preserve">
          <source>PREPARE &amp;mdash; prepare a statement for execution</source>
          <target state="translated">PREPARE &amp;mdash; 실행을위한 명령문 준비</target>
        </trans-unit>
        <trans-unit id="37fb488fc1130c92529c23ebb00239237637a743" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION</source>
          <target state="translated">거래 준비</target>
        </trans-unit>
        <trans-unit id="a6c4ba5ff6212b5c43bdc5722e0f091244559eda" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION &amp;mdash; prepare the current transaction for two-phase commit</source>
          <target state="translated">PREPARE TRANSACTION &amp;mdash; 2 단계 커밋을위한 현재 트랜잭션 준비</target>
        </trans-unit>
        <trans-unit id="5ddcb3afaebc491f73714dc172d37266e6be3bda" translate="yes" xml:space="preserve">
          <source>Packaging and deployment scripts should be careful to create the &lt;code&gt;postgres&lt;/code&gt; user as a system user by using &lt;code&gt;useradd -r&lt;/code&gt;, &lt;code&gt;adduser --system&lt;/code&gt;, or equivalent.</source>
          <target state="translated">패키징 및 배포 스크립트는 &lt;code&gt;useradd -r&lt;/code&gt; , &lt;code&gt;adduser --system&lt;/code&gt; 또는 이와 동등한 기능 을 사용하여 &lt;code&gt;postgres&lt;/code&gt; 사용자를 시스템 사용자로 생성 할 때주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a10c2d221e8eba42e9b331576d9daca086bdfe95" translate="yes" xml:space="preserve">
          <source>Packet containing a session key &amp;mdash; either symmetric-key or public-key encrypted.</source>
          <target state="translated">세션 키를 포함하는 패킷 &amp;mdash; 대칭 키 또는 공개 키 암호화</target>
        </trans-unit>
        <trans-unit id="fe9ad910809dee7861d17df7e5f096ed938e0ab2" translate="yes" xml:space="preserve">
          <source>Packet containing data encrypted with the session key.</source>
          <target state="translated">세션 키로 암호화 된 데이터가 포함 된 패킷.</target>
        </trans-unit>
        <trans-unit id="5dd9f751429eb18847bb4ae66caf8a2fda2b0c20" translate="yes" xml:space="preserve">
          <source>Page checksum</source>
          <target state="translated">페이지 체크섬</target>
        </trans-unit>
        <trans-unit id="10d741089ed07914a82a77ba0b90a6a76cd492d4" translate="yes" xml:space="preserve">
          <source>Page number of this page within its large object (counting from zero)</source>
          <target state="translated">큰 개체 내에서이 페이지의 페이지 번호 (0부터 계산)</target>
        </trans-unit>
        <trans-unit id="fc5666da83404ee33adbe94f98f1c6ba4503d3c8" translate="yes" xml:space="preserve">
          <source>Page number targeted by the lock within the relation, or null if the target is not a relation page or tuple</source>
          <target state="translated">관계 내에서 잠금이 대상으로하는 페이지 번호 또는 대상이 관계 페이지 또는 튜플이 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="05fe9679957eb1665689044c2d47f231b7b99aa3" translate="yes" xml:space="preserve">
          <source>Page number within the relation</source>
          <target state="translated">관계 내의 페이지 번호</target>
        </trans-unit>
        <trans-unit id="2b355a7b15353314735e75b8e122c5ae1fcd5a22" translate="yes" xml:space="preserve">
          <source>Page size and layout version number information</source>
          <target state="translated">페이지 크기 및 레이아웃 버전 번호 정보</target>
        </trans-unit>
        <trans-unit id="a03c41b78d25bf18f06cd333e2c95e267c66a660" translate="yes" xml:space="preserve">
          <source>PageHeaderData</source>
          <target state="translated">PageHeaderData</target>
        </trans-unit>
        <trans-unit id="2750093ba2a279af4331fd53d0a8cee7be245d4f" translate="yes" xml:space="preserve">
          <source>PageXLogRecPtr</source>
          <target state="translated">PageXLogRecPtr</target>
        </trans-unit>
        <trans-unit id="d90de0896be6c5efa3c782fa286f1c3cdb9a7b50" translate="yes" xml:space="preserve">
          <source>Parallel Plans</source>
          <target state="translated">병렬 계획</target>
        </trans-unit>
        <trans-unit id="686414fccc150dceb0e9f56ace196fdc729a14bb" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Aggregation</source>
          <target state="translated">병렬 계획 : 병렬 집계</target>
        </trans-unit>
        <trans-unit id="b75e7cdb23627ee4086ddf3246e9c894f0ce11d0" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Append</source>
          <target state="translated">병렬 계획 : 병렬 추가</target>
        </trans-unit>
        <trans-unit id="976b16b543b8304722b64b1a24c59b4c0b79488f" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Joins</source>
          <target state="translated">병렬 계획 : 병렬 조인</target>
        </trans-unit>
        <trans-unit id="9010e7d56024ae4a3d31f2d2290191dd0b36e537" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Plan Tips</source>
          <target state="translated">병렬 계획 : 병렬 계획 팁</target>
        </trans-unit>
        <trans-unit id="039109d587d0e62745986a2cf6f26a04992e1351" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Scans</source>
          <target state="translated">병렬 계획 : 병렬 스캔</target>
        </trans-unit>
        <trans-unit id="cfafb44924e6a5f388ef259a64814a132f966833" translate="yes" xml:space="preserve">
          <source>Parallel Query</source>
          <target state="translated">병렬 쿼리</target>
        </trans-unit>
        <trans-unit id="82124baa3b5560bbd5720a4765dc2466961bc53a" translate="yes" xml:space="preserve">
          <source>Parallel Safety</source>
          <target state="translated">병렬 안전</target>
        </trans-unit>
        <trans-unit id="0fe56d7979154496310d56ea233bf1c11643ddc4" translate="yes" xml:space="preserve">
          <source>Parallel Safety: Parallel Labeling for Functions and Aggregates</source>
          <target state="translated">병렬 안전 : 기능 및 집계에 대한 병렬 레이블링</target>
        </trans-unit>
        <trans-unit id="5ab3e8fa2d7856e75083b2a36c41793361958622" translate="yes" xml:space="preserve">
          <source>Parallel aggregation is not supported in all situations. Each aggregate must be &lt;a href=&quot;parallel-safety&quot;&gt;safe&lt;/a&gt; for parallelism and must have a combine function. If the aggregate has a transition state of type &lt;code&gt;internal&lt;/code&gt;, it must have serialization and deserialization functions. See &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; for more details. Parallel aggregation is not supported if any aggregate function call contains &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clause and is also not supported for ordered set aggregates or when the query involves &lt;code&gt;GROUPING SETS&lt;/code&gt;. It can only be used when all joins involved in the query are also part of the parallel portion of the plan.</source>
          <target state="translated">모든 상황에서 병렬 집계가 지원되는 것은 아닙니다. 각 집계는 병렬 처리에 &lt;a href=&quot;parallel-safety&quot;&gt;안전&lt;/a&gt; 해야하며 결합 기능이 있어야합니다. 집계에 &lt;code&gt;internal&lt;/code&gt; 유형의 전환 상태가있는 경우 직렬화 및 역 직렬화 기능이 있어야합니다. 자세한 내용은 &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; 를 참조하십시오. 집계 함수 호출에 &lt;code&gt;DISTINCT&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 절이 포함 된 경우 병렬 집계는 지원 되지 않으며 정렬 된 세트 집계 또는 쿼리에 &lt;code&gt;GROUPING SETS&lt;/code&gt; 가 포함 된 경우에도 지원되지 않습니다 . 조회와 관련된 모든 조인이 계획의 병렬 부분의 일부인 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04d6d9331b5a5aaad9590228fe97b2a4cfe26295" translate="yes" xml:space="preserve">
          <source>Parallel index builds may benefit from increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt; where an equivalent serial index build will see little or no benefit. Note that &lt;code&gt;maintenance_work_mem&lt;/code&gt; may influence the number of worker processes requested, since parallel workers must have at least a &lt;code&gt;32MB&lt;/code&gt; share of the total &lt;code&gt;maintenance_work_mem&lt;/code&gt; budget. There must also be a remaining &lt;code&gt;32MB&lt;/code&gt; share for the leader process. Increasing &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; may allow more workers to be used, which will reduce the time needed for index creation, so long as the index build is not already I/O bound. Of course, there should also be sufficient CPU capacity that would otherwise lie idle.</source>
          <target state="translated">병렬 색인 빌드는 동등한 직렬 색인 빌드가 이점을 거의 또는 전혀 보지 못하는 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 을 증가시키는 이점이 있습니다. 참고 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 로는 병렬 근로자는 적어도이 있어야하기 때문에, 요청 작업자 프로세스의 수에 영향을 미칠 수있는 &lt;code&gt;32MB&lt;/code&gt; 의 총의 주 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 로의 예산을. 리더 프로세스에 대한 나머지 &lt;code&gt;32MB&lt;/code&gt; 공유 도 있어야합니다 . &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers를&lt;/a&gt; 늘리면 더 많은 작업자를 사용할 수 있으므로 인덱스 빌드가 아직 I / O 바인딩되지 않은 경우 인덱스 작성에 필요한 시간이 줄어 듭니다. 물론, 유휴 상태 일 수있는 충분한 CPU 용량도 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8d1ebc235cfc864b875140b5812bbbb72ec9bf92" translate="yes" xml:space="preserve">
          <source>Parallel query</source>
          <target state="translated">병렬 쿼리</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="09be2449f5c7874ea156950916c870b9f0c9269d" translate="yes" xml:space="preserve">
          <source>Parameter type (&lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">매개 변수 유형 ( &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;real&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="044b6f8bb6500f64950a5a00b3fc891db56006e8" translate="yes" xml:space="preserve">
          <source>Parameter value assumed at server startup if the parameter is not otherwise set</source>
          <target state="translated">매개 변수가 다르게 설정되지 않은 경우 서버 시작시 가정 된 매개 변수 값</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="2f389ed6f97b68ab045fe7feae01a113660deba4" translate="yes" xml:space="preserve">
          <source>Parameters - &lt;code&gt;SHOW&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, &lt;code&gt;RESET&lt;/code&gt;</source>
          <target state="translated">파라미터 &lt;code&gt;SHOW&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; , &lt;code&gt;RESET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d605d3acb20f72158d3fdf0384d4816df27da77" translate="yes" xml:space="preserve">
          <source>Parameters set in this way provide default values for the cluster. The settings seen by active sessions will be these values unless they are overridden. The following sections describe ways in which the administrator or user can override these defaults.</source>
          <target state="translated">이러한 방식으로 설정된 매개 변수는 클러스터의 기본값을 제공합니다. 활성 세션에 표시되는 설정은 무시하지 않는 한이 값이됩니다. 다음 섹션에서는 관리자 나 사용자가 이러한 기본값을 무시할 수있는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b9f24c90be4904850b86a1b21d3ff1448827c68d" translate="yes" xml:space="preserve">
          <source>Parent trigger that this trigger is cloned from, zero if not a clone; this happens when partitions are created or attached to a partitioned table.</source>
          <target state="translated">이 트리거가 복제 된 상위 트리거, 복제가 아닌 경우 0입니다. 이것은 파티션이 생성되거나 파티션 된 테이블에 연결될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9c46bf34fcbc732066fd8d85a736b2f71975d85" translate="yes" xml:space="preserve">
          <source>Parentheses (&lt;code&gt;()&lt;/code&gt;) have their usual meaning to group expressions and enforce precedence. In some cases parentheses are required as part of the fixed syntax of a particular SQL command.</source>
          <target state="translated">괄호 ( &lt;code&gt;()&lt;/code&gt; )는 표현식을 그룹화하고 우선 순위를 적용한다는 일반적인 의미를 갖습니다. 경우에 따라 특정 SQL 명령의 고정 구문의 일부로 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="98e95b8350c1e439f335fb041362e108a0725712" translate="yes" xml:space="preserve">
          <source>Parentheses &lt;code&gt;()&lt;/code&gt; can be used to group items into a single logical item.</source>
          <target state="translated">괄호 &lt;code&gt;()&lt;/code&gt; 를 사용하여 항목을 단일 논리 항목으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd6d9306fafc7f371b0f3c8451bd6a999eda172" translate="yes" xml:space="preserve">
          <source>Parentheses are used to resolve ambiguities. In the following example, the first statement assigns the alias &lt;code&gt;b&lt;/code&gt; to the second instance of &lt;code&gt;my_table&lt;/code&gt;, but the second statement assigns the alias to the result of the join:</source>
          <target state="translated">괄호는 모호성을 해결하는 데 사용됩니다. 다음 예제에서 첫 번째 명령문은 별명 &lt;code&gt;b&lt;/code&gt; 를 &lt;code&gt;my_table&lt;/code&gt; 의 두 번째 인스턴스에 지정하지만 두 번째 명령문은 별명을 조인 결과에 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8a18942798320d682a81a99742ced66e1f7dcd4f" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to control nesting of the &lt;code&gt;tsquery&lt;/code&gt; operators. Without parentheses, &lt;code&gt;|&lt;/code&gt; binds least tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt;, then &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt; most tightly.</source>
          <target state="translated">괄호를 사용하여 &lt;code&gt;tsquery&lt;/code&gt; 연산자의 중첩을 제어 할 수 있습니다 . 괄호없이 &lt;code&gt;|&lt;/code&gt; 가장 밀접하게 바인딩 된 다음 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 및 &lt;code&gt;!&lt;/code&gt; 가장 단단히.</target>
        </trans-unit>
        <trans-unit id="0de9a8d461cec2b96e138a5742063451fce829dd" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to enforce grouping of these operators. In the absence of parentheses, &lt;code&gt;!&lt;/code&gt; (NOT) binds most tightly, &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) next most tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), with &lt;code&gt;|&lt;/code&gt; (OR) binding the least tightly.</source>
          <target state="translated">괄호를 사용하여 이러한 연산자를 그룹화 할 수 있습니다. 괄호가 없으면 &lt;code&gt;!&lt;/code&gt; (NOT)는 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) 다음으로 가장 밀접하게 바인딩 된 다음 &lt;code&gt;&amp;amp;&lt;/code&gt; (AND)와 &lt;code&gt;|&lt;/code&gt; (또는) 가장 단단히 묶습니다.</target>
        </trans-unit>
        <trans-unit id="1050a7f51685a531fe35b29d9845b1171bb5126c" translate="yes" xml:space="preserve">
          <source>Parentheses, which can be used to provide filter expressions or define the order of path evaluation.</source>
          <target state="translated">필터 표현식을 제공하거나 경로 평가 순서를 정의하는 데 사용할 수있는 괄호.</target>
        </trans-unit>
        <trans-unit id="dde89c96be949ecdb36498952ab75fb083c95513" translate="yes" xml:space="preserve">
          <source>Parse and validate the reloptions array for an index. This is called only when a non-null reloptions array exists for the index. &lt;em&gt;&lt;code&gt;reloptions&lt;/code&gt;&lt;/em&gt; is a &lt;code&gt;text&lt;/code&gt; array containing entries of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt;. The function should construct a &lt;code&gt;bytea&lt;/code&gt; value, which will be copied into the &lt;code&gt;rd_options&lt;/code&gt; field of the index's relcache entry. The data contents of the &lt;code&gt;bytea&lt;/code&gt; value are open for the access method to define; most of the standard access methods use struct &lt;code&gt;StdRdOptions&lt;/code&gt;. When &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is true, the function should report a suitable error message if any of the options are unrecognized or have invalid values; when &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false, invalid entries should be silently ignored. (&lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false when loading options already stored in &lt;code&gt;pg_catalog&lt;/code&gt;; an invalid entry could only be found if the access method has changed its rules for options, and in that case ignoring obsolete entries is appropriate.) It is OK to return NULL if default behavior is wanted.</source>
          <target state="translated">인덱스에 대한 reloptions 배열을 구문 분석하고 유효성을 검증하십시오. 널이 아닌 reloptions 배열이 색인에 존재하는 경우에만 호출됩니다. &lt;em&gt; &lt;code&gt;reloptions&lt;/code&gt; &lt;/em&gt; 는 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 형식의 항목을 포함 하는 &lt;code&gt;text&lt;/code&gt; 배열 입니다. 이 함수는 &lt;code&gt;bytea&lt;/code&gt; 값을 구성해야 하며 이는 인덱스 relcache 항목의 &lt;code&gt;rd_options&lt;/code&gt; 필드에 복사됩니다 . &lt;code&gt;bytea&lt;/code&gt; 값 의 데이터 내용은 액세스 방법이 정의 할 수 있도록 열려 있습니다. 대부분의 표준 액세스 방법은 struct &lt;code&gt;StdRdOptions&lt;/code&gt; 를 사용 합니다 . 때 &lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt; 사실 어떠한 옵션이 인식되지 또는 잘못된 값이있는 경우, 함수는 적절한 오류 메시지를보고한다 언제&lt;em&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt; 가 false이면 유효하지 않은 항목을 자동으로 무시해야합니다. ( &lt;code&gt;pg_catalog&lt;/code&gt; 에 이미 저장된 옵션을로드 할 때&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt; 가유효합니다. 액세스 방법이 옵션에 대한 규칙을 변경 한 경우에만 유효하지 않은 항목을 찾을 수 있으며,이 경우 사용되지 않는 항목을 무시하는 것이 적절합니다.) 기본 동작 인 경우 NULL을 반환해도됩니다. 원합니다.</target>
        </trans-unit>
        <trans-unit id="e963287c4fec77476e5d1bf8476b1e7cc102ae88" translate="yes" xml:space="preserve">
          <source>Parse system include files as well.</source>
          <target state="translated">시스템 포함 파일도 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="0c8772d05d1a8b9d8d78cf0c1c4a6eb499eca0c8" translate="yes" xml:space="preserve">
          <source>Parser Stage</source>
          <target state="translated">파서 스테이지</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="284615f8b9e452b1f47ea07fb3256c3c1e7eaa1e" translate="yes" xml:space="preserve">
          <source>Parses the given document and returns true if the document is well-formed XML. (Note: this is an alias for the standard PostgreSQL function &lt;code&gt;xml_is_well_formed()&lt;/code&gt;. The name &lt;code&gt;xml_valid()&lt;/code&gt; is technically incorrect since validity and well-formedness have different meanings in XML.)</source>
          <target state="translated">주어진 문서를 구문 분석하고 문서가 올바른 형식의 XML이면 true를 반환합니다. (참고 : 이것은 표준 PostgreSQL 함수 &lt;code&gt;xml_is_well_formed()&lt;/code&gt; 의 별칭입니다 . &lt;code&gt;xml_valid()&lt;/code&gt; 이름 은 XML에서 유효성과 올바른 형식이 다른 의미를 갖기 때문에 기술적으로 올바르지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="b58d58ace5fa0761b582d29360f9eac7d42ba9f0" translate="yes" xml:space="preserve">
          <source>Parsing for arguments stops at the end of the line, or when another unquoted backslash is found. An unquoted backslash is taken as the beginning of a new meta-command. The special sequence &lt;code&gt;\\&lt;/code&gt; (two backslashes) marks the end of arguments and continues parsing SQL commands, if any. That way SQL and psql commands can be freely mixed on a line. But in any case, the arguments of a meta-command cannot continue beyond the end of the line.</source>
          <target state="translated">인수의 구문 분석은 줄 끝에서 또는 인용되지 않은 다른 백 슬래시가 발견 될 때 중지됩니다. 인용되지 않은 백 슬래시는 새로운 메타 명령의 시작으로 간주됩니다. 특수 시퀀스 &lt;code&gt;\\&lt;/code&gt; (두 개의 백 슬래시)는 인수의 끝을 표시하고 SQL 명령이있는 경우 계속 구문 분석합니다. 이렇게하면 SQL과 psql 명령을 한 줄에 자유롭게 혼합 할 수 있습니다. 그러나 어쨌든 메타 명령의 주장은 줄 끝을 넘어 계속 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="07c159051320590e27d53f2ca68bc5552c059bb0" translate="yes" xml:space="preserve">
          <source>Part II. The SQL Language</source>
          <target state="translated">파트 II. SQL 언어</target>
        </trans-unit>
        <trans-unit id="ed99b73ba1d17331570cbb8c11cb9612833219a4" translate="yes" xml:space="preserve">
          <source>Part III. Server Administration</source>
          <target state="translated">파트 III. 서버 관리</target>
        </trans-unit>
        <trans-unit id="233b8f2c1ff53528b0a2395bfd96a5533e5bf211" translate="yes" xml:space="preserve">
          <source>Part VII. Internals</source>
          <target state="translated">파트 VII. 내부</target>
        </trans-unit>
        <trans-unit id="1c0b1424932f39a83140c4ab14b4b9ddde6b4f52" translate="yes" xml:space="preserve">
          <source>Part VIII. Appendixes</source>
          <target state="translated">파트 VIII. 부록</target>
        </trans-unit>
        <trans-unit id="53657ace24d508d9d61d6689474a05a11f116ca4" translate="yes" xml:space="preserve">
          <source>Partial (including parallel) aggregation is currently not supported for ordered-set aggregates. Also, it will never be used for aggregate calls that include &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clauses, since those semantics cannot be supported during partial aggregation.</source>
          <target state="translated">순서 집합 집계에 대해서는 부분 (병렬 포함) 집계가 현재 지원되지 않습니다. 또한 &lt;code&gt;DISTINCT&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 절 을 포함하는 집계 호출에는 사용 되지 않습니다. 이러한 의미는 부분 집계 중에 지원할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">부분 인덱스</target>
        </trans-unit>
        <trans-unit id="21eb60b5918acacccb4909c31bcd93a4758e3020" translate="yes" xml:space="preserve">
          <source>Partial Mode</source>
          <target state="translated">부분 모드</target>
        </trans-unit>
        <trans-unit id="f7fabd14af4eb6ccfa3f503f4e268b2ad2693497" translate="yes" xml:space="preserve">
          <source>Partial indexes also have interesting interactions with index-only scans. Consider the partial index shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;:</source>
          <target state="translated">부분 인덱스는 인덱스 전용 스캔과도 흥미로운 상호 작용을합니다. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3에&lt;/a&gt; 표시된 부분 인덱스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="943df06a52fbfe34ca375a62898de53e7d01f42f" translate="yes" xml:space="preserve">
          <source>Partition</source>
          <target state="translated">Partition</target>
        </trans-unit>
        <trans-unit id="7a5ba09370f100d4b05c522688c9cba42e037f6a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be disabled using the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; 설정을 사용하여 파티션 정리를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2325b1acc0d3782c122e1bc1c9eed9984fc2f19a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be performed not only during the planning of a given query, but also during its execution. This is useful as it can allow more partitions to be pruned when clauses contain expressions whose values are not known at query planning time, for example, parameters defined in a &lt;code&gt;PREPARE&lt;/code&gt; statement, using a value obtained from a subquery, or using a parameterized value on the inner side of a nested loop join. Partition pruning during execution can be performed at any of the following times:</source>
          <target state="translated">주어진 쿼리를 계획하는 동안뿐만 아니라 실행하는 동안 파티션 제거를 수행 할 수 있습니다. 이는 절에 쿼리 계획시 값을 알 수없는 표현식 (예 : &lt;code&gt;PREPARE&lt;/code&gt; 문에 정의 된 매개 변수 , 서브 쿼리에서 얻은 값 사용 또는 중첩 루프 조인의 내부 실행 중 파티션 정리는 다음 중 언제라도 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a934d5fd56ebc9886a2336d4cf199c8f485ebd" translate="yes" xml:space="preserve">
          <source>Partitioned table (relation)</source>
          <target state="translated">파티션을 나눈 테이블 (관계)</target>
        </trans-unit>
        <trans-unit id="25be32546f15fa3443a67e839c875e6c98ffb53d" translate="yes" xml:space="preserve">
          <source>Partitioned tables do not support &lt;code&gt;EXCLUDE&lt;/code&gt; constraints; however, you can define these constraints on individual partitions.</source>
          <target state="translated">파티션 된 테이블은 &lt;code&gt;EXCLUDE&lt;/code&gt; 제한 조건을 지원하지 않습니다 . 그러나 개별 파티션에서 이러한 제한 조건을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd1ab913d96a23c99606f41fe3792bb2b1fe894" translate="yes" xml:space="preserve">
          <source>Partitioning of big collections and the proper use of GIN and GiST indexes allows the implementation of very fast searches with online update. Partitioning can be done at the database level using table inheritance, or by distributing documents over servers and collecting external search results, e.g. via &lt;a href=&quot;ddl-foreign-data&quot;&gt;Foreign Data&lt;/a&gt; access. The latter is possible because ranking functions use only local information.</source>
          <target state="translated">큰 컬렉션을 분할하고 GIN 및 GiST 인덱스를 올바르게 사용하면 온라인 업데이트로 매우 빠른 검색을 구현할 수 있습니다. 테이블 상속을 사용하거나 서버를 통해 문서를 배포하고 외부 &lt;a href=&quot;ddl-foreign-data&quot;&gt;데이터&lt;/a&gt; 액세스 등을 통해 외부 검색 결과를 수집하여 데이터베이스 수준에서 분할을 수행 할 수 있습니다 . 순위 기능은 로컬 정보 만 사용하므로 후자가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a24ec4cff1b6c6f9a0a6c355299a351c0f004fce" translate="yes" xml:space="preserve">
          <source>Partitioning of big collections and the proper use of GIN and GiST indexes allows the implementation of very fast searches with online update. Partitioning can be done at the database level using table inheritance, or by distributing documents over servers and collecting external search results, e.g., via &lt;a href=&quot;ddl-foreign-data&quot;&gt;Foreign Data&lt;/a&gt; access. The latter is possible because ranking functions use only local information.</source>
          <target state="translated">큰 컬렉션을 분할하고 GIN 및 GiST 인덱스를 적절하게 사용하면 온라인 업데이트로 매우 빠른 검색을 구현할 수 있습니다. 분할은 테이블 상속을 사용하여 데이터베이스 수준에서 수행하거나 서버에 문서를 배포하고 외부 &lt;a href=&quot;ddl-foreign-data&quot;&gt;데이터&lt;/a&gt; 액세스 를 통해 외부 검색 결과를 수집하여 수행 할 수 있습니다 . 후자는 순위 기능이 지역 정보 만 사용하기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="de0bffd921d00f01c704a415da77618af1ad1157" translate="yes" xml:space="preserve">
          <source>Partitioning refers to splitting what is logically one large table into smaller physical pieces. Partitioning can provide several benefits:</source>
          <target state="translated">파티셔닝이란 논리적으로 하나의 큰 테이블을 작은 물리적 조각으로 나누는 것을 말합니다. 파티셔닝은 몇 가지 이점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c73b5aa4d6c05a53fb97d25c9d92f2517cfd521" translate="yes" xml:space="preserve">
          <source>Partitioning strategy; &lt;code&gt;h&lt;/code&gt; = hash partitioned table, &lt;code&gt;l&lt;/code&gt; = list partitioned table, &lt;code&gt;r&lt;/code&gt; = range partitioned table</source>
          <target state="translated">분할 전략; &lt;code&gt;h&lt;/code&gt; = 해시 파티션 된 테이블, &lt;code&gt;l&lt;/code&gt; = 파티션 된 테이블 나열, &lt;code&gt;r&lt;/code&gt; = 범위 파티션 된 테이블</target>
        </trans-unit>
        <trans-unit id="ac39e0014a08ee6c92f0e5cdb5959d966b4de171" translate="yes" xml:space="preserve">
          <source>Partitions can also be foreign tables, although they have some limitations that normal tables do not; see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">파티션은 외부 테이블 일 수도 있지만 일반 테이블에는없는 일부 제한 사항이 있습니다. 참조 &lt;a href=&quot;sql-createforeigntable&quot;&gt;FOREIGN 테이블 만들기&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="742a14b2e0099a02fc2828373fdc246b43a7d658" translate="yes" xml:space="preserve">
          <source>Partitions cannot have columns that are not present in the parent. It is not possible to specify columns when creating partitions with &lt;code&gt;CREATE TABLE&lt;/code&gt;, nor is it possible to add columns to partitions after-the-fact using &lt;code&gt;ALTER TABLE&lt;/code&gt;. Tables may be added as a partition with &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; only if their columns exactly match the parent.</source>
          <target state="translated">파티션은 부모에없는 열을 가질 수 없습니다. &lt;code&gt;CREATE TABLE&lt;/code&gt; 을 사용하여 파티션을 만들 때 열을 지정할 수 없으며 &lt;code&gt;ALTER TABLE&lt;/code&gt; 을 사용하여 사실상 파티션에 열을 추가 할 수도 없습니다 . 열이 부모와 정확히 일치하는 경우에만 &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; 을 사용하여 테이블을 파티션으로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90542a9f44eb209be50c576524ab51cf75180838" translate="yes" xml:space="preserve">
          <source>Partitions may themselves be defined as partitioned tables, using what is called &lt;em&gt;sub-partitioning&lt;/em&gt;. Partitions may have their own indexes, constraints and default values, distinct from those of other partitions. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on creating partitioned tables and partitions.</source>
          <target state="translated">파티션 자체는 &lt;em&gt;서브 파티션&lt;/em&gt; 이라고하는 것을 사용하여 파티션 된 테이블로 정의 될 수 있습니다 . 파티션은 다른 파티션과는 다른 고유 인덱스, 제약 조건 및 기본값을 가질 수 있습니다. 파티션 된 테이블 및 파티션 작성에 대한 자세한 내용 은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0fe4b4dd2ad3e0c4391acf69fe76d976b85276f5" translate="yes" xml:space="preserve">
          <source>Partitions thus created are in every way normal PostgreSQL tables (or, possibly, foreign tables). It is possible to specify a tablespace and storage parameters for each partition separately.</source>
          <target state="translated">이렇게 생성 된 파티션은 모든 방법으로 일반적인 PostgreSQL 테이블 (또는 외부 테이블)입니다. 각 파티션에 대한 테이블 스페이스 및 스토리지 매개 변수를 개별적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88b62432a05ee62c1b6215e5aa74e2720815cc44" translate="yes" xml:space="preserve">
          <source>Parts of the GEQO module are adapted from D. Whitley's Genitor algorithm.</source>
          <target state="translated">GEQO 모듈의 일부는 D. Whitley의 Genitor 알고리즘에서 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="f1c5d9114d4f8eeeec0857bd19317d948e267875" translate="yes" xml:space="preserve">
          <source>Pass the option &lt;code&gt;name&lt;/code&gt; to the output plugin with, if specified, the option value &lt;code&gt;value&lt;/code&gt;. Which options exist and their effects depends on the used output plugin.</source>
          <target state="translated">지정된 경우 옵션 값 &lt;code&gt;value&lt;/code&gt; 를 사용 하여 옵션 &lt;code&gt;name&lt;/code&gt; 을 출력 플러그인에 전달하십시오 . 어떤 옵션이 존재하며 그 효과는 사용 된 출력 플러그인에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="adee4d3938c90062826aa15c6cd38c8f321a8960" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. See &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; for details of how encrypted passwords are stored.</source>
          <target state="translated">비밀번호 (암호화 가능) 없으면 null입니다. 암호화 된 비밀번호 저장 방법에 대한 자세한 내용은 &lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99366622edd98624e0f268beb5dfad9b43284c50" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. The format depends on the form of encryption used.</source>
          <target state="translated">비밀번호 (암호화 가능) 없으면 null입니다. 형식은 사용 된 암호화 형식에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e6148812de885ba8e1911ccd743a2dc2463667a7" translate="yes" xml:space="preserve">
          <source>Password Authentication</source>
          <target state="translated">비밀번호 인증</target>
        </trans-unit>
        <trans-unit id="e8e30ae74424dc989ae9149964d67afb93a52bdb" translate="yes" xml:space="preserve">
          <source>Password Encryption</source>
          <target state="translated">비밀번호 암호화</target>
        </trans-unit>
        <trans-unit id="36eca0e0aafbe2102ac86aee3d25cb85966cbaa6" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication)</source>
          <target state="translated">비밀번호 만료 시간 (비밀번호 인증에만 사용)</target>
        </trans-unit>
        <trans-unit id="de5ff361027e5b08609865471d6dc5846a389286" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication); null if no expiration</source>
          <target state="translated">비밀번호 만료 시간 (비밀번호 인증에만 사용됨); 만료가 없으면 null</target>
        </trans-unit>
        <trans-unit id="238db8fa438548c1928f9502d7d8e1e30eb6d531" translate="yes" xml:space="preserve">
          <source>Password for the user to run the service as.</source>
          <target state="translated">사용자가 서비스를 실행하기위한 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="3fa38ad80d289fe4c73a95809bdea71d6cbf450b" translate="yes" xml:space="preserve">
          <source>Password for user to bind to the directory with to perform the search when doing search+bind authentication.</source>
          <target state="translated">검색 + 바인드 인증을 수행 할 때 사용자가 디렉토리에 바인드하여 검색을 수행하기위한 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="d33984b00815ba0da90a3eeaeb545efb634cbde4" translate="yes" xml:space="preserve">
          <source>Path construction using functions:</source>
          <target state="translated">기능을 사용한 경로 구성 :</target>
        </trans-unit>
        <trans-unit id="463f854670c23f477bbd78e96423f8e31931e339" translate="yes" xml:space="preserve">
          <source>Path literals of JSON primitive types: Unicode text, numeric, true, false, or null.</source>
          <target state="translated">JSON 기본 유형의 경로 리터럴 : 유니 코드 텍스트, 숫자, true, false 또는 널입니다.</target>
        </trans-unit>
        <trans-unit id="7b6339b7ad3d2b4abc5be8c19dc30583042c4165" translate="yes" xml:space="preserve">
          <source>Path of a Query</source>
          <target state="translated">쿼리 경로</target>
        </trans-unit>
        <trans-unit id="266a8e23c8475feda63519f1c3d2f320f2aaac65" translate="yes" xml:space="preserve">
          <source>Path of shared library that implements language</source>
          <target state="translated">언어를 구현하는 공유 라이브러리의 경로</target>
        </trans-unit>
        <trans-unit id="6a3675336ca9e8caece923ce6c69021ab35c9b34" translate="yes" xml:space="preserve">
          <source>Path variables listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;Table 8.24&lt;/a&gt;.</source>
          <target state="translated">에 나열된 경로 변수 &lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;표 8.24&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55707d92267c5187de428b55c28d908802787d98" translate="yes" xml:space="preserve">
          <source>Paths are output using the first or second syntax, as appropriate.</source>
          <target state="translated">경로는 적절하게 첫 번째 또는 두 번째 구문을 사용하여 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="d21eb60eb90443c1e0fde7a365afe587f415ae66" translate="yes" xml:space="preserve">
          <source>Paths are represented by lists of connected points. Paths can be &lt;em&gt;open&lt;/em&gt;, where the first and last points in the list are considered not connected, or &lt;em&gt;closed&lt;/em&gt;, where the first and last points are considered connected.</source>
          <target state="translated">경로는 연결된 점 목록으로 표시됩니다. 경로 일 수 &lt;em&gt;열기&lt;/em&gt; 목록의 처음과 마지막 지점이 고려되지 연결되거나, 어디 &lt;em&gt;폐쇄&lt;/em&gt; 처음과 마지막 지점 접속 간주되는 곳.</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="535ab3a1c5459ace2d0b0bcb8fc022e58a4100d9" translate="yes" xml:space="preserve">
          <source>Pattern Matching</source>
          <target state="translated">패턴 매칭</target>
        </trans-unit>
        <trans-unit id="1a43195d59d6b988e5bc825ea91ee5fa2ee54455" translate="yes" xml:space="preserve">
          <source>Pattern Matching: LIKE</source>
          <target state="translated">패턴 매칭 : LIKE</target>
        </trans-unit>
        <trans-unit id="577a01dd1c0e8f649068e70f9cf054970915cb36" translate="yes" xml:space="preserve">
          <source>Pattern Matching: POSIX Regular Expressions</source>
          <target state="translated">패턴 일치 : POSIX 정규식</target>
        </trans-unit>
        <trans-unit id="1aca0dbf2888e4f1bc7d10adb1a49bb94a808a60" translate="yes" xml:space="preserve">
          <source>Pattern Matching: SIMILAR TO Regular Expressions</source>
          <target state="translated">패턴 일치 : 정규 표현식과 유사</target>
        </trans-unit>
        <trans-unit id="2cca6a6a36d34faa5c5f178fbe489846badc8fb5" translate="yes" xml:space="preserve">
          <source>Pattern matching operators (&lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt;, and POSIX-style regular expressions); locales affect both case insensitive matching and the classification of characters by character-class regular expressions</source>
          <target state="translated">패턴 일치 연산자 ( &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;SIMILAR TO&lt;/code&gt; 및 POSIX 스타일 정규식); 로케일은 대소 문자를 구분하지 않는 일치와 문자 클래스 정규 표현식으로 문자 분류에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="ca382c16294c214dbe3191677fc4669d70c86654" translate="yes" xml:space="preserve">
          <source>Pauses recovery immediately (restricted to superusers by default, but other users can be granted EXECUTE to run the function).</source>
          <target state="translated">복구를 즉시 일시 중지합니다 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음).</target>
        </trans-unit>
        <trans-unit id="9d18ff4f9325c1d261553975b88e0f79d832a0bc" translate="yes" xml:space="preserve">
          <source>Pauses recovery. While recovery is paused, no further database changes are applied. If hot standby is active, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="translated">복구를 일시 중지합니다. 복구가 일시 중지 된 동안에는 더 이상 데이터베이스 변경 사항이 적용되지 않습니다. 상시 대기가 활성화 된 경우 모든 새 쿼리는 데이터베이스의 동일한 일관된 스냅 샷을 보게되며 복구가 재개 될 때까지 더 이상 쿼리 충돌이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12a0f150ca4476ed5b576c007ac1865d1fb8bb74" translate="yes" xml:space="preserve">
          <source>Peer Authentication</source>
          <target state="translated">피어 인증</target>
        </trans-unit>
        <trans-unit id="7140c44c7da9185cfa0b73cd8cc49f9de3bc1489" translate="yes" xml:space="preserve">
          <source>Peer authentication is only available on operating systems providing the &lt;code&gt;getpeereid()&lt;/code&gt; function, the &lt;code&gt;SO_PEERCRED&lt;/code&gt; socket parameter, or similar mechanisms. Currently that includes Linux, most flavors of BSD including macOS, and Solaris.</source>
          <target state="translated">피어 인증은 &lt;code&gt;getpeereid()&lt;/code&gt; 함수, &lt;code&gt;SO_PEERCRED&lt;/code&gt; 소켓 매개 변수 또는 유사한 메커니즘을 제공하는 운영 체제에서만 사용 가능합니다 . 현재 여기에는 Linux, macOS 및 Solaris를 포함한 대부분의 BSD 버전이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a4e88cdf6f01c061fef4d5d033c1f84e81c460db" translate="yes" xml:space="preserve">
          <source>Peer authentication is usually recommendable for local connections, though trust authentication might be sufficient in some circumstances. Password authentication is the easiest choice for remote connections. All the other options require some kind of external security infrastructure (usually an authentication server or a certificate authority for issuing SSL certificates), or are platform-specific.</source>
          <target state="translated">피어 인증은 일반적으로 로컬 연결에 권장되지만 일부 상황에서는 신뢰 인증으로 충분할 수 있습니다. 암호 인증은 원격 연결을위한 가장 쉬운 선택입니다. 다른 모든 옵션에는 일종의 외부 보안 인프라 (일반적으로 SSL 인증서 발급을위한 인증 서버 또는 인증 기관)가 필요하거나 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9cdd79a05b9da966c26a1f6a5e99a7a9fb8d64a3" translate="yes" xml:space="preserve">
          <source>Per-Command Policies</source>
          <target state="translated">명령 별 정책</target>
        </trans-unit>
        <trans-unit id="ed1d3a75054b9592b198ba465dda151b09c333ea" translate="yes" xml:space="preserve">
          <source>Per-Statement Latencies</source>
          <target state="translated">문당 대기 시간</target>
        </trans-unit>
        <trans-unit id="db0ae07882c18b5649ee33de907e97a3481ed614" translate="yes" xml:space="preserve">
          <source>Per-Transaction Logging</source>
          <target state="translated">트랜잭션 별 로깅</target>
        </trans-unit>
        <trans-unit id="f973c235a702ba0b4882340692bc401f9c1e7c7c" translate="yes" xml:space="preserve">
          <source>Per-index value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;vacuum_cleanup_index_scale_factor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;vacuum_cleanup_index_scale_factor의&lt;/a&gt; 인덱스 당 값입니다 .</target>
        </trans-unit>
        <trans-unit id="6aee541129a013df791c695dddfe4b66f3b0804a" translate="yes" xml:space="preserve">
          <source>Per-table granularity</source>
          <target state="translated">테이블 단위 세분성</target>
        </trans-unit>
        <trans-unit id="df6300430e05243fb8623c3dacf21a834f4ec9db" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;autovacuum_analyze_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;autovacuum_analyze_scale_factor&lt;/a&gt; 매개 변수의 테이블 당 값입니다 .</target>
        </trans-unit>
        <trans-unit id="13bcc410c7f9ecd5027e7aabb4054809e94a5637" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;autovacuum_analyze_threshold&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;autovacuum_analyze_threshold&lt;/a&gt; 매개 변수의 테이블 당 값 .</target>
        </trans-unit>
        <trans-unit id="b4cc49570c37ddaf0ad982835227bdfeb5fb34fc" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; 매개 변수의 테이블 당 값 . autovacuum은 시스템 전체 설정보다 큰 테이블 당 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 매개 변수를 무시 합니다 (작게 만 설정할 수 있음).</target>
        </trans-unit>
        <trans-unit id="adc3bbc6bde46e7a977a3d025522a0b130c2221c" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; 매개 변수의 테이블 당 값 . autovacuum은 시스템 전체 설정보다 큰 테이블 당 &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; 매개 변수를 무시 합니다 (작게 만 설정할 수 있음).</target>
        </trans-unit>
        <trans-unit id="52ee90bf83a221126d345af63a697f023bf7aaf2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;autovacuum_vacuum_cost_delay&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;autovacuum_vacuum_cost_delay&lt;/a&gt; 매개 변수의 테이블 당 값 .</target>
        </trans-unit>
        <trans-unit id="b8f18627239c76784b53c354db6754ba7815a1a8" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;autovacuum_vacuum_cost_limit&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;autovacuum_vacuum_cost_limit&lt;/a&gt; 매개 변수의 테이블 당 값 .</target>
        </trans-unit>
        <trans-unit id="4d12e56fad0fc8cfde31ec88733d4a8a4914d22d" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt; 매개 변수의 테이블 당 값입니다 .</target>
        </trans-unit>
        <trans-unit id="d66effb5fc4a6d26e983439f8ea5df04cb08e89f" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt; parameter. The special value of -1 may be used to disable insert vacuums on the table.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt; 매개 변수의 테이블 당 값입니다 . 특수 값 -1을 사용하여 테이블에서 진공 삽입을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dd4eed61fa80fd43095c3741dd5dd959fac77e2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; 매개 변수의 테이블 당 값입니다 .</target>
        </trans-unit>
        <trans-unit id="4413713442ca0dbea5e7f8130793f8e4a24e0cef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; 매개 변수의 테이블 당 값입니다 .</target>
        </trans-unit>
        <trans-unit id="3d2800f8c07e42c6c33e28d11f8d0822c4287722" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt; 매개 변수의 테이블 당 값입니다 .</target>
        </trans-unit>
        <trans-unit id="223ad5e2d00a73119ddde400e71e2b1ba9280ccb" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt; 매개 변수의 테이블 당 값입니다 . autovacuum은 시스템 전체 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; 설정의 절반보다 큰 테이블 별 &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; 매개 변수를 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="68a4d3118ea45821db0cebd7519f0ea146995887" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; 매개 변수의 테이블 당 값입니다 .</target>
        </trans-unit>
        <trans-unit id="aed713d91e51cd08cd23d16d2810e44fceb208ef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; 매개 변수의 테이블 당 값입니다 . autovacuum은 시스템 전체 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; 설정의 절반보다 큰 테이블 별 &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; 매개 변수를 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="3d6a639607b9fecb0af2c41612e5b2768fa56a2e" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt; 매개 변수의 테이블 당 값입니다 .</target>
        </trans-unit>
        <trans-unit id="e975b3d41bbeabc6eb00c97d7e30fbafd1d2457e" translate="yes" xml:space="preserve">
          <source>Percentage of dead tuples</source>
          <target state="translated">죽은 튜플의 백분율</target>
        </trans-unit>
        <trans-unit id="b0cd75c0030dceadd02cefb1f4f8cdfe1c43c19b" translate="yes" xml:space="preserve">
          <source>Percentage of free space</source>
          <target state="translated">여유 공간의 백분율</target>
        </trans-unit>
        <trans-unit id="026e26a6ed3d13c32e91d16667b4fce6169c8f91" translate="yes" xml:space="preserve">
          <source>Percentage of live tuples</source>
          <target state="translated">라이브 튜플의 백분율</target>
        </trans-unit>
        <trans-unit id="20574a809cad3d22e4de78bb07a64ea3c84d8769" translate="yes" xml:space="preserve">
          <source>Percentage of table scanned</source>
          <target state="translated">스캔 한 테이블의 백분율</target>
        </trans-unit>
        <trans-unit id="cecafd6247612c74017c4324067017c519c963f3" translate="yes" xml:space="preserve">
          <source>Perform &amp;ldquo;full&amp;rdquo; vacuuming.</source>
          <target state="translated">&quot;전체&quot;진공 청소를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="feca8a5ed5223a5437966dd095f2b42b084450e7" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">SCRAM-SHA-256 인증을 수행하여 사용자 비밀번호를 확인하십시오. 자세한 내용 &lt;a href=&quot;auth-password&quot;&gt;은 20.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cee9d96cd6bf238088136c000e640e78e06aa374" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 or MD5 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">SCRAM-SHA-256 또는 MD5 인증을 수행하여 사용자 비밀번호를 확인하십시오. 자세한 내용 &lt;a href=&quot;auth-password&quot;&gt;은 20.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e17faacf8a7556f475f5c4f9f96ab42fd904d29" translate="yes" xml:space="preserve">
          <source>Perform a variable assignment, like the &lt;code&gt;\set&lt;/code&gt; meta-command. Note that you must separate name and value, if any, by an equal sign on the command line. To unset a variable, leave off the equal sign. To set a variable with an empty value, use the equal sign but leave off the value. These assignments are done during command line processing, so variables that reflect connection state will get overwritten later.</source>
          <target state="translated">&lt;code&gt;\set&lt;/code&gt; meta-command 와 같은 변수 할당을 수행하십시오 . 명령 줄에서 이름과 값이 있으면 등호로 구분해야합니다. 변수를 설정 해제하려면 등호를 생략하십시오. 빈 값으로 변수를 설정하려면 등호를 사용하되 값은 생략하십시오. 이러한 할당은 명령 행 처리 중에 수행되므로 연결 상태를 반영하는 변수는 나중에 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="fb9e20f68ce84ca1bc08bc43d32bfdf37750e58d" translate="yes" xml:space="preserve">
          <source>Perform index vacuum and index cleanup phases of &lt;code&gt;VACUUM&lt;/code&gt; in parallel using &lt;code&gt;integer&lt;/code&gt; background workers (for the details of each vacuum phase, please refer to &lt;a href=&quot;progress-reporting#VACUUM-PHASES&quot;&gt;Table 27.37&lt;/a&gt;). The number of workers used to perform the operation is equal to the number of indexes on the relation that support parallel vacuum which is limited by the number of workers specified with &lt;code&gt;PARALLEL&lt;/code&gt; option if any which is further limited by &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;. An index can participate in parallel vacuum if and only if the size of the index is more than &lt;a href=&quot;runtime-config-query#GUC-MIN-PARALLEL-INDEX-SCAN-SIZE&quot;&gt;min_parallel_index_scan_size&lt;/a&gt;. Please note that it is not guaranteed that the number of parallel workers specified in &lt;code&gt;integer&lt;/code&gt; will be used during execution. It is possible for a vacuum to run with fewer workers than specified, or even with no workers at all. Only one worker can be used per index. So parallel workers are launched only when there are at least &lt;code&gt;2&lt;/code&gt; indexes in the table. Workers for vacuum are launched before the start of each phase and exit at the end of the phase. These behaviors might change in a future release. This option can't be used with the &lt;code&gt;FULL&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 백그라운드 워커를 사용하여 &lt;code&gt;VACUUM&lt;/code&gt; 의 인덱스 진공 및 인덱스 정리 단계를 병렬로 수행 합니다 (각 진공 단계에 대한 자세한 내용은 &lt;a href=&quot;progress-reporting#VACUUM-PHASES&quot;&gt;표 27.37&lt;/a&gt; 참조 ). 작업을 수행하는 데 사용되는 작업자 수는 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers에&lt;/a&gt; 의해 추가로 제한되는 &lt;code&gt;PARALLEL&lt;/code&gt; 옵션으로 지정된 작업자 수로 제한되는 병렬 진공을 지원하는 관계의 인덱스 수와 같습니다 . 인덱스 크기가 &lt;a href=&quot;runtime-config-query#GUC-MIN-PARALLEL-INDEX-SCAN-SIZE&quot;&gt;min_parallel_index_scan_size&lt;/a&gt; 보다 큰 경우에만 인덱스가 병렬 진공에 참여할 수 있습니다 . &lt;code&gt;integer&lt;/code&gt; 지정된 병렬 작업자의 수가 보장되지는 않습니다.실행 중에 사용됩니다. 지정된 것보다 적은 수의 작업자를 사용하거나 작업자가 전혀없는 경우에도 vacuum을 실행할 수 있습니다. 인덱스 당 하나의 작업자 만 사용할 수 있습니다. 따라서 병렬 워커는 테이블에 인덱스가 &lt;code&gt;2&lt;/code&gt; 개 이상있을 때만 시작됩니다 . 진공 작업자는 각 단계가 시작되기 전에 시작되고 단계가 끝날 때 종료됩니다. 이러한 동작은 향후 릴리스에서 변경 될 수 있습니다. 이 옵션은 &lt;code&gt;FULL&lt;/code&gt; 옵션 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b34d3d05facf882ae3a691abd30e8b6cd4a6e677" translate="yes" xml:space="preserve">
          <source>Perform just a selected set of the normal initialization steps. &lt;code&gt;init_steps&lt;/code&gt; specifies the initialization steps to be performed, using one character per step. Each step is invoked in the specified order. The default is &lt;code&gt;dtgvp&lt;/code&gt;. The available steps are:</source>
          <target state="translated">선택한 일련의 일반 초기화 단계 만 수행하십시오. &lt;code&gt;init_steps&lt;/code&gt; 는 단계 당 하나의 문자를 사용하여 수행 할 초기화 단계를 지정합니다. 각 단계는 지정된 순서대로 호출됩니다. 기본값은 &lt;code&gt;dtgvp&lt;/code&gt; 입니다. 사용 가능한 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f6bc160364e3493898bf7d6bb17edbe09454bda" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming before running the test. This option is &lt;em&gt;necessary&lt;/em&gt; if you are running a custom test scenario that does not include the standard tables &lt;code&gt;pgbench_accounts&lt;/code&gt;, &lt;code&gt;pgbench_branches&lt;/code&gt;, &lt;code&gt;pgbench_history&lt;/code&gt;, and &lt;code&gt;pgbench_tellers&lt;/code&gt;.</source>
          <target state="translated">테스트를 실행하기 전에 진공 청소기로 청소하지 마십시오. 이 옵션은 표준 테이블 &lt;code&gt;pgbench_accounts&lt;/code&gt; , &lt;code&gt;pgbench_branches&lt;/code&gt; , &lt;code&gt;pgbench_history&lt;/code&gt; 및 &lt;code&gt;pgbench_tellers&lt;/code&gt; 를 포함하지 않는 사용자 정의 테스트 시나리오를 실행하는 경우 &lt;em&gt;필요&lt;/em&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a366494657843694e57b5bad59c50324f01a651" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming during initialization. (This option suppresses the &lt;code&gt;v&lt;/code&gt; initialization step, even if it was specified in &lt;code&gt;-I&lt;/code&gt;.)</source>
          <target state="translated">초기화 중에 진공 청소를 수행하지 마십시오. (이 옵션 은 &lt;code&gt;-I&lt;/code&gt; 에 지정된 경우에도 &lt;code&gt;v&lt;/code&gt; 초기화 단계를 억제합니다 .)</target>
        </trans-unit>
        <trans-unit id="ae7a93c9cfd5aa5e2e72b1ed16236cb5de67de61" translate="yes" xml:space="preserve">
          <source>Perform the backup, using any convenient file-system-backup tool such as tar or cpio (not pg_dump or pg_dumpall). It is neither necessary nor desirable to stop normal operation of the database while you do this. See &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;Section 25.3.3.3&lt;/a&gt; for things to consider during this backup.</source>
          <target state="translated">tar 또는 cpio (pg_dump 또는 pg_dumpall 아님)와 같은 편리한 파일 시스템 백업 도구를 사용하여 백업을 수행하십시오. 이렇게하는 동안 데이터베이스의 정상적인 작동을 중지 할 필요도없고 바람직하지도 않습니다. 이 백업 중에 고려해야 할 사항 &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;은 25.3.3.3 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0828d0154023185a4f3f08252e7050a26fc998a" translate="yes" xml:space="preserve">
          <source>Perform the same operation and return the updated entries:</source>
          <target state="translated">동일한 작업을 수행하고 업데이트 된 항목을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="ca80079033f0036f2ec138c62dcdab998ede3b1d" translate="yes" xml:space="preserve">
          <source>Perform the same operation, using a sub-select in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절 에서 부속 선택을 사용하여 동일한 조작을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4af32e4acc11996347bfaec82c71604728dd29" translate="yes" xml:space="preserve">
          <source>Performance Tips</source>
          <target state="translated">성능 팁</target>
        </trans-unit>
        <trans-unit id="fc8d14b954dfe439eb5ef6988b32004ef49622c0" translate="yes" xml:space="preserve">
          <source>Performs a frontend (client) copy. This is an operation that runs an SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command, but instead of the server reading or writing the specified file, psql reads or writes the file and routes the data between the server and the local file system. This means that file accessibility and privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">프론트 엔드 (클라이언트) 복사를 수행합니다. 이는 SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; 명령 을 실행하는 조작 이지만, 서버가 지정된 파일을 읽거나 쓰는 대신 psql이 파일을 읽거나 쓰며 서버와 로컬 파일 시스템간에 데이터를 라우트합니다. 이는 파일 액세스 가능성 및 권한이 서버가 아닌 로컬 사용자의 권한이며 SQL 수퍼 유저 권한이 필요하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6c344e1248da1978bc3644d43b9d891fff2e39be" translate="yes" xml:space="preserve">
          <source>Peter Eisentraut &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">피터 아이젠 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt; &amp;lt; peter_e@gmx.net &amp;gt;</target>
        </trans-unit>
        <trans-unit id="da078a3d051b083b829b48a189bf09b75dac6cd7" translate="yes" xml:space="preserve">
          <source>Peter Mount &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">피터 마운트 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac972e7b24283f21a917e63d12ab81c028b6b619" translate="yes" xml:space="preserve">
          <source>Phantom Read</source>
          <target state="translated">팬텀 읽기</target>
        </trans-unit>
        <trans-unit id="f6371a4980dacd0f821ddeb75bac77ae4886ba72" translate="yes" xml:space="preserve">
          <source>Phase</source>
          <target state="translated">Phase</target>
        </trans-unit>
        <trans-unit id="042205072874b99f497a9509acb6db1b05f17fb3" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database File Layout</source>
          <target state="translated">물리적 스토리지 : 데이터베이스 파일 레이아웃</target>
        </trans-unit>
        <trans-unit id="3fc82c3858fa9eb0fe848a4e73244b155ecf922b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database Page Layout</source>
          <target state="translated">물리적 스토리지 : 데이터베이스 페이지 레이아웃</target>
        </trans-unit>
        <trans-unit id="bb5882e77d3988624189c0ed4e594bfe45615e1a" translate="yes" xml:space="preserve">
          <source>Physical Storage: Free Space Map</source>
          <target state="translated">물리적 스토리지 : 여유 공간 맵</target>
        </trans-unit>
        <trans-unit id="1aa3f80bb2e1afaf99e1bd935f3605582854ea4b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Initialization Fork</source>
          <target state="translated">물리적 스토리지 : 초기화 포크</target>
        </trans-unit>
        <trans-unit id="365026e65b63752c65e5cd29c199d84c6b17ab3e" translate="yes" xml:space="preserve">
          <source>Physical Storage: TOAST</source>
          <target state="translated">물리적 스토리지 : TOAST</target>
        </trans-unit>
        <trans-unit id="2b725586447f2023155afd853eb7071d04362c03" translate="yes" xml:space="preserve">
          <source>Physical Storage: Visibility Map</source>
          <target state="translated">물리적 스토리지 : 가시성 맵</target>
        </trans-unit>
        <trans-unit id="27e67533896359d51a605428384ec08a0b4ccbfe" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes</source>
          <target state="translated">바이트 단위의 물리적 관계 길이</target>
        </trans-unit>
        <trans-unit id="53d91fab1719e32b08f04ca110073dde614b240a" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes (exact)</source>
          <target state="translated">바이트 단위의 물리적 관계 길이 (정확한)</target>
        </trans-unit>
        <trans-unit id="2d0ec6f0ef721a8a8cb1c82f207caf7adfca229f" translate="yes" xml:space="preserve">
          <source>Place the database cluster's data directory in a memory-backed file system (i.e. RAM disk). This eliminates all database disk I/O, but limits data storage to the amount of available memory (and perhaps swap).</source>
          <target state="translated">데이터베이스 클러스터의 데이터 디렉토리를 메모리 지원 파일 시스템 (예 : RAM 디스크)에 저장하십시오. 이렇게하면 모든 데이터베이스 디스크 I / O가 제거되지만 데이터 스토리지는 사용 가능한 메모리 (및 스왑)의 양으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="763b9aa0654971e3e19fdea85c60c9a6639631aa" translate="yes" xml:space="preserve">
          <source>Place the database cluster's data directory in a memory-backed file system (i.e., RAM disk). This eliminates all database disk I/O, but limits data storage to the amount of available memory (and perhaps swap).</source>
          <target state="translated">데이터베이스 클러스터의 데이터 디렉토리를 메모리 지원 파일 시스템 (예 : RAM 디스크)에 배치합니다. 이렇게하면 모든 데이터베이스 디스크 I / O가 제거되지만 데이터 저장소는 사용 가능한 메모리 양 (및 스왑)으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="eeb237570f0f7f892d4ed491876f26dd479a782a" translate="yes" xml:space="preserve">
          <source>Placing &lt;code&gt;ORDER BY&lt;/code&gt; within the aggregate's regular argument list, as described so far, is used when ordering the input rows for general-purpose and statistical aggregates, for which ordering is optional. There is a subclass of aggregate functions called &lt;em&gt;ordered-set aggregates&lt;/em&gt; for which an &lt;code&gt;order_by_clause&lt;/code&gt; is &lt;em&gt;required&lt;/em&gt;, usually because the aggregate's computation is only sensible in terms of a specific ordering of its input rows. Typical examples of ordered-set aggregates include rank and percentile calculations. For an ordered-set aggregate, the &lt;code&gt;order_by_clause&lt;/code&gt; is written inside &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt;, as shown in the final syntax alternative above. The expressions in the &lt;code&gt;order_by_clause&lt;/code&gt; are evaluated once per input row just like regular aggregate arguments, sorted as per the &lt;code&gt;order_by_clause&lt;/code&gt;'s requirements, and fed to the aggregate function as input arguments. (This is unlike the case for a non-&lt;code&gt;WITHIN GROUP&lt;/code&gt;&lt;code&gt;order_by_clause&lt;/code&gt;, which is not treated as argument(s) to the aggregate function.) The argument expressions preceding &lt;code&gt;WITHIN GROUP&lt;/code&gt;, if any, are called &lt;em&gt;direct arguments&lt;/em&gt; to distinguish them from the &lt;em&gt;aggregated arguments&lt;/em&gt; listed in the &lt;code&gt;order_by_clause&lt;/code&gt;. Unlike regular aggregate arguments, direct arguments are evaluated only once per aggregate call, not once per input row. This means that they can contain variables only if those variables are grouped by &lt;code&gt;GROUP BY&lt;/code&gt;; this restriction is the same as if the direct arguments were not inside an aggregate expression at all. Direct arguments are typically used for things like percentile fractions, which only make sense as a single value per aggregation calculation. The direct argument list can be empty; in this case, write just &lt;code&gt;()&lt;/code&gt; not &lt;code&gt;(*)&lt;/code&gt;. (PostgreSQL will actually accept either spelling, but only the first way conforms to the SQL standard.)</source>
          <target state="translated">지금까지 설명한대로 집계의 일반 인수 목록 에 &lt;code&gt;ORDER BY&lt;/code&gt; 를 배치 하면 순서 지정이 선택적인 범용 및 통계 집계에 대해 입력 행을 정렬 할 때 사용됩니다. 라는 집계 함수의 서브 클래스가 &lt;em&gt;주문한 세트 집계&lt;/em&gt; 하는 &lt;code&gt;order_by_clause&lt;/code&gt; 이 되는 &lt;em&gt;요구&lt;/em&gt; 집계의 계산은 입력 행의 특정 순서의 관점에서만 현명한입니다 때문에 일반적으로는,. 순서 집합 집계의 일반적인 예에는 순위 및 백분위 수 계산이 포함됩니다. 순서 집합 집계의 경우 &lt;code&gt;order_by_clause&lt;/code&gt; 는 위의 마지막 구문 대안에 표시된 것처럼 &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt; 안에 작성됩니다 . 의 표현 &lt;code&gt;order_by_clause&lt;/code&gt; 는 일반 집계 인수와 마찬가지로 입력 행당 한 번씩 평가되며 &lt;code&gt;order_by_clause&lt;/code&gt; 의 요구 사항에 따라 정렬 되어 입력 인수로 집계 함수에 제공됩니다. (이는 &lt;code&gt;WITHIN GROUP&lt;/code&gt; 이 아닌 &lt;code&gt;order_by_clause&lt;/code&gt; 의 경우와 달리 집계 함수의 인수로 처리되지 않습니다.) &lt;code&gt;WITHIN GROUP&lt;/code&gt; 앞에있는 인수 표현식이있는 경우 &lt;em&gt;집계 된 인수&lt;/em&gt; 와 구별하기 위해 &lt;em&gt;직접 인수&lt;/em&gt; 라고 합니다. &lt;code&gt;order_by_clause&lt;/code&gt; 에 나열 됨&lt;em&gt;&lt;/em&gt;. 일반 집계 인수와 달리 직접 인수는 입력 행당 한 번이 아니라 집계 호출 당 한 번만 평가됩니다. 이는 변수가 &lt;code&gt;GROUP BY&lt;/code&gt; 로 그룹화 된 경우에만 변수를 포함 할 수 있음을 의미합니다 . 이 제한은 직접 인수가 집계 표현식 안에 전혀없는 것과 같습니다. 직접 인수는 일반적으로 백분위 수 분수와 같은 항목에 사용되며 집계 계산마다 단일 값으로 만 의미가 있습니다. 직접 인수 목록은 비어있을 수 있습니다. 이 경우 &lt;code&gt;(*)&lt;/code&gt; 가 아닌 ( &lt;code&gt;()&lt;/code&gt; 만 쓰십시오 . (PostgreSQL은 실제로 철자를 허용하지만 첫 번째 방법 만이 SQL 표준을 준수합니다.)</target>
        </trans-unit>
        <trans-unit id="050a736fd59911f8226167a2c6f31c24c2830d29" translate="yes" xml:space="preserve">
          <source>Placing the function in a &lt;code&gt;LATERAL&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item keeps it from being invoked more than once per row. &lt;code&gt;m.*&lt;/code&gt; is still expanded into &lt;code&gt;m.a, m.b, m.c&lt;/code&gt;, but now those variables are just references to the output of the &lt;code&gt;FROM&lt;/code&gt; item. (The &lt;code&gt;LATERAL&lt;/code&gt; keyword is optional here, but we show it to clarify that the function is getting &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;some_table&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; &lt;code&gt;FROM&lt;/code&gt; 항목에 함수를 배치하면 행당 두 번 이상 호출되지 않습니다. &lt;code&gt;m.*&lt;/code&gt; 는 여전히 &lt;code&gt;m.a, m.b, m.c&lt;/code&gt; 로 확장 되었지만 이제는 이러한 변수가 &lt;code&gt;FROM&lt;/code&gt; 항목 의 출력에 대한 참조 일뿐 입니다. ( &lt;code&gt;LATERAL&lt;/code&gt; 키워드는 여기서 선택 사항이지만 함수가 &lt;code&gt;some_table&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt; 를 받고 있음을 분명히 보여줍니다 .)</target>
        </trans-unit>
        <trans-unit id="b4a1219ff91be25a0770f7df590b928d12b8a2c5" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. &lt;code&gt;VACUUM FULL&lt;/code&gt; rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires an exclusive lock on each table while it is being processed.</source>
          <target state="translated">일반 &lt;code&gt;VACUUM&lt;/code&gt; ( &lt;code&gt;FULL&lt;/code&gt; 제외)은 단순히 공간을 회수하여 재사용 할 수있게합니다. 이 형식의 명령은 배타적 잠금을 얻지 못하므로 테이블을 정상적으로 읽고 쓰는 것과 동시에 작동 할 수 있습니다. 그러나 추가 공간은 운영 체제로 반환되지 않습니다 (대부분의 경우). 동일한 테이블 내에서 재사용 할 수 있습니다. &lt;code&gt;VACUUM FULL&lt;/code&gt; 은 테이블의 전체 내용을 추가 공간없이 새 디스크 파일로 다시 작성하므로 사용되지 않은 공간을 운영 체제로 반환 할 수 있습니다. 이 양식은 훨씬 느리며 처리되는 동안 각 테이블에 독점 잠금이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cdc70d31ed5da3eee47809b4dd230782b8f8497b" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. It also allows us to leverage multiple CPUs in order to process indexes. This feature is known as &lt;em&gt;parallel vacuum&lt;/em&gt;. To disable this feature, one can use &lt;code&gt;PARALLEL&lt;/code&gt; option and specify parallel workers as zero. &lt;code&gt;VACUUM FULL&lt;/code&gt; rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires an exclusive lock on each table while it is being processed.</source>
          <target state="translated">Plain &lt;code&gt;VACUUM&lt;/code&gt; ( &lt;code&gt;FULL&lt;/code&gt; 없음 )은 단순히 공간을 확보하고 재사용 할 수 있도록합니다. 이 명령 형식은 배타적 잠금을 얻지 못하기 때문에 테이블의 정상적인 읽기 및 쓰기와 병렬로 작동 할 수 있습니다. 그러나 추가 공간은 운영 체제로 반환되지 않습니다 (대부분의 경우). 동일한 테이블 내에서 재사용 할 수 있도록 유지됩니다. 또한 인덱스를 처리하기 위해 여러 CPU를 활용할 수 있습니다. 이 기능을 &lt;em&gt;병렬 진공이라고&lt;/em&gt; 합니다. 이 기능을 비활성화하려면 &lt;code&gt;PARALLEL&lt;/code&gt; 옵션을 사용하고 병렬 작업자를 0으로 지정할 수 있습니다 . &lt;code&gt;VACUUM FULL&lt;/code&gt; 테이블의 전체 내용을 추가 공간없이 새 디스크 파일에 다시 작성하여 사용하지 않는 공간을 운영 체제로 반환 할 수 있습니다. 이 형식은 훨씬 느리고 처리되는 동안 각 테이블에 대한 배타적 잠금이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8499132893d83a3f2ae11d9668e227a0e6596484" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; may not be satisfactory when a table contains large numbers of dead row versions as a result of massive update or delete activity. If you have such a table and you need to reclaim the excess disk space it occupies, you will need to use &lt;code&gt;VACUUM FULL&lt;/code&gt;, or alternatively &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the table-rewriting variants of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. These commands rewrite an entire new copy of the table and build new indexes for it. All these options require exclusive lock. Note that they also temporarily use extra disk space approximately equal to the size of the table, since the old copies of the table and indexes can't be released until the new ones are complete.</source>
          <target state="translated">테이블에 대량의 업데이트 또는 삭제 활동으로 인해 많은 수의 데드 로우 버전이 포함 된 경우 일반 &lt;code&gt;VACUUM&lt;/code&gt; 이 만족스럽지 않을 수 있습니다. 이러한 테이블이 있고 사용중인 디스크 공간을 재 확보해야하는 경우 &lt;code&gt;VACUUM FULL&lt;/code&gt; 또는 &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 또는 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 의 테이블 재 작성 변형 중 하나 를 사용해야 합니다 . 이 명령은 테이블의 전체 새 사본을 다시 작성하고 새 인덱스를 빌드합니다. 이러한 모든 옵션에는 독점 잠금이 필요합니다. 새 테이블이 완료 될 때까지 테이블과 인덱스의 이전 복사본을 해제 할 수 없으므로 테이블 크기와 거의 동일한 추가 디스크 공간을 일시적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9dba597737e71648392c996cea122250f0bead7" translate="yes" xml:space="preserve">
          <source>Plan nodes to which an &lt;code&gt;InitPlan&lt;/code&gt; is attached.</source>
          <target state="translated">&lt;code&gt;InitPlan&lt;/code&gt; 이 연결된 노드를 계획하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bae7f24c9eebd1039795f1be6ffdf3da89d373b" translate="yes" xml:space="preserve">
          <source>Plan nodes which reference a correlated &lt;code&gt;SubPlan&lt;/code&gt;.</source>
          <target state="translated">상관 된 &lt;code&gt;SubPlan&lt;/code&gt; 을 참조하는 노드를 계획 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd8eca8ef866c5503502580ce3a00558f59a9928" translate="yes" xml:space="preserve">
          <source>Plannable queries (that is, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;) are combined into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry whenever they have identical query structures according to an internal hash calculation. Typically, two queries will be considered the same for this purpose if they are semantically equivalent except for the values of literal constants appearing in the query. Utility commands (that is, all other commands) are compared strictly on the basis of their textual query strings, however.</source>
          <target state="translated">계획 가능한 쿼리 (즉, &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; )는 내부 해시 계산에 따라 동일한 쿼리 구조를 가질 때마다 단일 &lt;code&gt;pg_stat_statements&lt;/code&gt; 항목 으로 결합됩니다 . 일반적으로 두 쿼리는 쿼리에 나타나는 리터럴 상수 값을 제외하고 의미 적으로 동일한 경우 이러한 목적으로 동일한 것으로 간주됩니다. 그러나 유틸리티 명령 (즉, 다른 모든 명령)은 텍스트 쿼리 문자열을 기준으로 엄격하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="1c065dbb4470e9d21b7a921d317fd42a4a204fc8" translate="yes" xml:space="preserve">
          <source>Planner Statistics and Security</source>
          <target state="translated">플래너 통계 및 보안</target>
        </trans-unit>
        <trans-unit id="20ef8925a22326d996284c55f97493dce8cb35b8" translate="yes" xml:space="preserve">
          <source>Planner/Optimizer</source>
          <target state="translated">Planner/Optimizer</target>
        </trans-unit>
        <trans-unit id="88b7699abe5df4b9c91f2b6e5ea1aabcde7ea7fc" translate="yes" xml:space="preserve">
          <source>Plans and resources - &lt;code&gt;PREPARE&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DEALLOCATE&lt;/code&gt;, &lt;code&gt;DISCARD&lt;/code&gt;</source>
          <target state="translated">계획 및 리소스- &lt;code&gt;PREPARE&lt;/code&gt; , &lt;code&gt;EXECUTE&lt;/code&gt; , &lt;code&gt;DEALLOCATE&lt;/code&gt; , &lt;code&gt;DISCARD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e7c7717c711ec0c456d95556daba5b3b636c0d1" translate="yes" xml:space="preserve">
          <source>Plans and resources: &lt;code&gt;PREPARE&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DEALLOCATE&lt;/code&gt;, &lt;code&gt;DISCARD&lt;/code&gt;</source>
          <target state="translated">계획 및 리소스 : &lt;code&gt;PREPARE&lt;/code&gt; , &lt;code&gt;EXECUTE&lt;/code&gt; , &lt;code&gt;DEALLOCATE&lt;/code&gt; , &lt;code&gt;DISCARD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60e74c5b37f496e9f5820d20828439504e47ddb6" translate="yes" xml:space="preserve">
          <source>Please enter all the commands shown above so you have some data to work with in the following sections.</source>
          <target state="translated">다음 섹션에서 작업 할 데이터가 있도록 위에 표시된 모든 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="a932052bd8c1c2c9d99c8557aa55ac6cb1e71319" translate="yes" xml:space="preserve">
          <source>Please note that you may see some or all of the following notifications depending on the particular versions you have of libselinux and selinux-policy:</source>
          <target state="translated">libselinux 및 selinux-policy의 특정 버전에 따라 다음 알림 중 일부 또는 전부가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0db2f66cabcb72c7d5c5552d7794e37b6384e5d6" translate="yes" xml:space="preserve">
          <source>Please note the following points when using the generic WAL record facility:</source>
          <target state="translated">일반 WAL 레코드 기능을 사용할 때 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="86f9d988d7b8b2829ff9e18a117a22f3c6c12cda" translate="yes" xml:space="preserve">
          <source>Pluggable Authentication Modules</source>
          <target state="translated">플러그 가능 인증 모듈</target>
        </trans-unit>
        <trans-unit id="3dfb3c336b3693041700e2e10c00427b27b0180f" translate="yes" xml:space="preserve">
          <source>Plugins and extensions - &lt;code&gt;LOAD&lt;/code&gt;</source>
          <target state="translated">플러그인 및 확장 &lt;code&gt;LOAD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfc627985ddf6332a8ae76b6d6e7fac5e923c727" translate="yes" xml:space="preserve">
          <source>Plugins and extensions: &lt;code&gt;LOAD&lt;/code&gt;</source>
          <target state="translated">플러그인 및 확장 : &lt;code&gt;LOAD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efefb1be830f67be53a399ad23055160dfbce160" translate="yes" xml:space="preserve">
          <source>Plus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">SQL / JSON 시퀀스를 반복하는 플러스 연산자</target>
        </trans-unit>
        <trans-unit id="65afde293357ae741287178244c36bbcce3cc736" translate="yes" xml:space="preserve">
          <source>Point on a plane</source>
          <target state="translated">비행기를 가리킨다</target>
        </trans-unit>
        <trans-unit id="609adbe0655f07f14c79208d551f8d9718fabd23" translate="yes" xml:space="preserve">
          <source>Point or box of intersection</source>
          <target state="translated">교차점 또는 상자</target>
        </trans-unit>
        <trans-unit id="09812b4d0aeaa487df4bde731b3996675a249aaa" translate="yes" xml:space="preserve">
          <source>Points are output using the first syntax.</source>
          <target state="translated">첫 번째 구문을 사용하여 점이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="44c9844a5c8235f295a2612b30b79553235db5c0" translate="yes" xml:space="preserve">
          <source>Points are the fundamental two-dimensional building block for geometric types. Values of type &lt;code&gt;point&lt;/code&gt; are specified using either of the following syntaxes:</source>
          <target state="translated">점은 기하학적 유형의 기본 2 차원 빌딩 블록입니다. &lt;code&gt;point&lt;/code&gt; 유형의 값은 다음 구문 중 하나를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="7f6158e808f6832883a61fff6f7473e7ffa8d937" translate="yes" xml:space="preserve">
          <source>Points to note:</source>
          <target state="translated">참고 사항 :</target>
        </trans-unit>
        <trans-unit id="da968837807c4a4627a6c38281eebcac2e2aa0b7" translate="yes" xml:space="preserve">
          <source>Policies are created using the &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; command, altered using the &lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt; command, and dropped using the &lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt; command. To enable and disable row security for a given table, use the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; 명령을 사용하여 정책을 작성 하고 &lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt; 명령을 사용하여 변경 한 후 &lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt; 명령을 사용하여 삭제합니다 . 주어진 테이블에 대해 행 보안을 사용하거나 사용하지 않으려면 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1624c281a60434d712e179fdb6ff898796130b43" translate="yes" xml:space="preserve">
          <source>Policies can be applied for specific commands or for specific roles. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified. Multiple policies may apply to a single command; see below for more details. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;Table 256&lt;/a&gt; summarizes how the different types of policy apply to specific commands.</source>
          <target state="translated">특정 명령이나 특정 역할에 정책을 적용 할 수 있습니다. 새로 작성된 정책의 기본값은 달리 지정하지 않는 한 모든 명령 및 역할에 적용되는 것입니다. 단일 명령에 여러 정책이 적용될 수 있습니다. 자세한 내용은 아래를 참조하십시오. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;표 256&lt;/a&gt; 에는 다양한 유형의 정책이 특정 명령에 적용되는 방법이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea4ac1b26dd811200c863a2d28d42117a994a64e" translate="yes" xml:space="preserve">
          <source>Policies can be applied for specific commands or for specific roles. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified. Multiple policies may apply to a single command; see below for more details. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;Table 272&lt;/a&gt; summarizes how the different types of policy apply to specific commands.</source>
          <target state="translated">특정 명령 또는 특정 역할에 대해 정책을 적용 할 수 있습니다. 새로 생성 된 정책의 기본값은 별도로 지정하지 않는 한 모든 명령과 역할에 적용된다는 것입니다. 단일 명령에 여러 정책이 적용될 수 있습니다. 자세한 내용은 아래를 참조하십시오. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;표 272&lt;/a&gt; 는 여러 유형의 정책이 특정 명령에 적용되는 방식을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="9218496f73981d3e04361890ce5e81c103eeff2b" translate="yes" xml:space="preserve">
          <source>Policies stored in &lt;code&gt;pg_policy&lt;/code&gt; are applied only when &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relrowsecurity&lt;/code&gt; is set for their table.</source>
          <target state="translated">&lt;code&gt;pg_policy&lt;/code&gt; 에 저장된 정책 은 &lt;code&gt;pg_class&lt;/code&gt; 경우에만 적용됩니다 . &lt;code&gt;relrowsecurity&lt;/code&gt; 는 해당 테이블에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64fe90225d9ffc87de024a67667003d6e6192eb8" translate="yes" xml:space="preserve">
          <source>Policy names are per-table. Therefore, one policy name can be used for many different tables and have a definition for each table which is appropriate to that table.</source>
          <target state="translated">정책 이름은 테이블 당입니다. 따라서 하나의 정책 이름을 여러 다른 테이블에 사용할 수 있으며 해당 테이블에 적합한 각 테이블에 대한 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a028a9272b54da3da6db504ed096a2910de4d948" translate="yes" xml:space="preserve">
          <source>Polygon (similar to closed path)</source>
          <target state="translated">다각형 (닫힌 경로와 유사)</target>
        </trans-unit>
        <trans-unit id="358c4e4d5755c21f01067425fdfdaf1bfdcb7099" translate="yes" xml:space="preserve">
          <source>Polygons are output using the first syntax.</source>
          <target state="translated">다각형은 첫 번째 구문을 사용하여 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="7fb66bc5a7ec5dcfcc725c19a5a1e5c03cd32e7e" translate="yes" xml:space="preserve">
          <source>Polygons are represented by lists of points (the vertexes of the polygon). Polygons are very similar to closed paths, but are stored differently and have their own set of support routines.</source>
          <target state="translated">다각형은 점 목록 (다각형의 꼭지점)으로 표시됩니다. 다각형은 닫힌 패스와 매우 유사하지만 다르게 저장되며 자체 지원 루틴 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="931d8d1ab098337b34a524e4f5275bb68856723d" translate="yes" xml:space="preserve">
          <source>Popular examples</source>
          <target state="translated">Popular examples</target>
        </trans-unit>
        <trans-unit id="274e42ad6449f3252ec5038abe402083876dea88" translate="yes" xml:space="preserve">
          <source>Populating a Database</source>
          <target state="translated">데이터베이스 채우기</target>
        </trans-unit>
        <trans-unit id="367461ddb82787c5535ecce370eaabdc51b55d46" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent executing the statement, in milliseconds</source>
          <target state="translated">Population standard deviation of time spent executing the statement, in milliseconds</target>
        </trans-unit>
        <trans-unit id="7fbc9b4eb9f4bb4e95de4acb2d6d7f0b43e20913" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent in the statement, in milliseconds</source>
          <target state="translated">명령문에 소요 된 시간의 인구 표준 편차 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="75494ee8f234525fd82a1234cd1d741493f67113" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">Population standard deviation of time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</target>
        </trans-unit>
        <trans-unit id="384cecb2d7b1b2012eaea272977d2cf0c551884e" translate="yes" xml:space="preserve">
          <source>Port number of the PostgreSQL instance this WAL receiver is connected to.</source>
          <target state="translated">이 WAL 수신자가 연결된 PostgreSQL 인스턴스의 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="008e62801aaa400319958b2b2b06cc2182c60162" translate="yes" xml:space="preserve">
          <source>Port number on LDAP server to connect to. If no port is specified, the LDAP library's default port setting will be used.</source>
          <target state="translated">연결할 LDAP 서버의 포트 번호입니다. 포트를 지정하지 않으면 LDAP 라이브러리의 기본 포트 설정이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c75704d05c6e22d0fdf67c00eb401f9b1c6b139b" translate="yes" xml:space="preserve">
          <source>Portable Operating System Interface</source>
          <target state="translated">휴대용 운영 체제 인터페이스</target>
        </trans-unit>
        <trans-unit id="e7c56d55f410fd275aaccf8ba063a18761b3e5c0" translate="yes" xml:space="preserve">
          <source>Position values in &lt;code&gt;tsvector&lt;/code&gt; must be greater than 0 and no more than 16,383</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 의 위치 값은 0보다 크고 16,383보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="bbb340fe5bf8594afaa03b969bb8e8f82eef71df" translate="yes" xml:space="preserve">
          <source>Positional notation is the traditional mechanism for passing arguments to functions in PostgreSQL. An example is:</source>
          <target state="translated">위치 표기법은 PostgreSQL의 함수에 인수를 전달하는 일반적인 메커니즘입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd8bd0b5027f70c1cefa9f905da80fd30083ef2a" translate="yes" xml:space="preserve">
          <source>Possible</source>
          <target state="translated">Possible</target>
        </trans-unit>
        <trans-unit id="6db8a7e83593975ece623b8f9b3fe94d53e8a1b1" translate="yes" xml:space="preserve">
          <source>Possible limitations of the &lt;code&gt;query&lt;/code&gt; clause are documented under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; 절의 가능한 제한 사항은 &lt;a href=&quot;sql-select&quot;&gt;SELECT에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e46bf54baa1011e163ced28f70574e61876f70d3" translate="yes" xml:space="preserve">
          <source>Possible variants of the above queries are:</source>
          <target state="translated">위 쿼리의 가능한 변형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92818ef9b703eafdfca9b984fb83c6ed173e8358" translate="yes" xml:space="preserve">
          <source>Possibly, your site administrator has already created a database for your use. In that case you can omit this step and skip ahead to the next section.</source>
          <target state="translated">사이트 관리자가 이미 사용하기 위해 데이터베이스를 작성했을 수 있습니다. 이 경우이 단계를 생략하고 다음 섹션으로 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="d31a3cecdd68dfe451de7f17fd71f41b5ec2d2b2" translate="yes" xml:space="preserve">
          <source>PostgreSQL B-Tree indexes are multi-level tree structures, where each level of the tree can be used as a doubly-linked list of pages. A single metapage is stored in a fixed position at the start of the first segment file of the index. All other pages are either leaf pages or internal pages. Leaf pages are the pages on the lowest level of the tree. All other levels consist of internal pages. Each leaf page contains tuples that point to table rows. Each internal page contains tuples that point to the next level down in the tree. Typically, over 99% of all pages are leaf pages. Both internal pages and leaf pages use the standard page format described in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL B-Tree indexes are multi-level tree structures, where each level of the tree can be used as a doubly-linked list of pages. A single metapage is stored in a fixed position at the start of the first segment file of the index. All other pages are either leaf pages or internal pages. Leaf pages are the pages on the lowest level of the tree. All other levels consist of internal pages. Each leaf page contains tuples that point to table rows. Each internal page contains tuples that point to the next level down in the tree. Typically, over 99% of all pages are leaf pages. Both internal pages and leaf pages use the standard page format described in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0c5bb15ce4cd87c929efa330565ff6d28cd04381" translate="yes" xml:space="preserve">
          <source>PostgreSQL Client Applications</source>
          <target state="translated">PostgreSQL 클라이언트 애플리케이션</target>
        </trans-unit>
        <trans-unit id="c24f12993bca195ad8365e3a9f46bba7d548c46e" translate="yes" xml:space="preserve">
          <source>PostgreSQL Error Codes</source>
          <target state="translated">PostgreSQL 오류 코드</target>
        </trans-unit>
        <trans-unit id="179caa7e2f2ae5bcccafd6de1029390b28df93ea" translate="yes" xml:space="preserve">
          <source>PostgreSQL Extension System</source>
          <target state="translated">PostgreSQL 확장 시스템</target>
        </trans-unit>
        <trans-unit id="bde4caa4f627d1ed1cd6258230a52653ae368364" translate="yes" xml:space="preserve">
          <source>PostgreSQL Limits</source>
          <target state="translated">PostgreSQL 제한</target>
        </trans-unit>
        <trans-unit id="831c73ba52cb3a865742b364e490e3d33fd67271" translate="yes" xml:space="preserve">
          <source>PostgreSQL Log Sequence Number</source>
          <target state="translated">PostgreSQL 로그 시퀀스 번호</target>
        </trans-unit>
        <trans-unit id="d6e7156cbc0b3b93da375064bee0966e60cdb8ac" translate="yes" xml:space="preserve">
          <source>PostgreSQL Rule System</source>
          <target state="translated">PostgreSQL 규칙 시스템</target>
        </trans-unit>
        <trans-unit id="452e61af45168fd75ac971dbf646f72b427da732" translate="yes" xml:space="preserve">
          <source>PostgreSQL Server Applications</source>
          <target state="translated">PostgreSQL 서버 애플리케이션</target>
        </trans-unit>
        <trans-unit id="67fae22a18c43950aa1922954f1d91e59073538b" translate="yes" xml:space="preserve">
          <source>PostgreSQL User Account</source>
          <target state="translated">PostgreSQL 사용자 계정</target>
        </trans-unit>
        <trans-unit id="2764cd9d3bf007f792e3e2fc4a68faeb55344442" translate="yes" xml:space="preserve">
          <source>PostgreSQL accesses certain on-disk information via &lt;em&gt;SLRU&lt;/em&gt; (simple least-recently-used) caches. The &lt;code&gt;pg_stat_slru&lt;/code&gt; view will contain one row for each tracked SLRU cache, showing statistics about access to cached pages.</source>
          <target state="translated">PostgreSQL accesses certain on-disk information via &lt;em&gt;SLRU&lt;/em&gt; (simple least-recently-used) caches. The &lt;code&gt;pg_stat_slru&lt;/code&gt; view will contain one row for each tracked SLRU cache, showing statistics about access to cached pages.</target>
        </trans-unit>
        <trans-unit id="c5ec2d5a5859a9a3bd680edc1c2f24695d8620d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL actually treats every SQL statement as being executed within a transaction. If you do not issue a &lt;code&gt;BEGIN&lt;/code&gt; command, then each individual statement has an implicit &lt;code&gt;BEGIN&lt;/code&gt; and (if successful) &lt;code&gt;COMMIT&lt;/code&gt; wrapped around it. A group of statements surrounded by &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; is sometimes called a &lt;em&gt;transaction block&lt;/em&gt;.</source>
          <target state="translated">PostgreSQL은 실제로 모든 SQL 문을 트랜잭션 내에서 실행되는 것으로 취급합니다. &lt;code&gt;BEGIN&lt;/code&gt; 명령을 발행하지 않으면 , 각 개별 명령문에는 내재 된 &lt;code&gt;BEGIN&lt;/code&gt; 이 있고 (성공하는 경우) &lt;code&gt;COMMIT&lt;/code&gt; 가 랩핑됩니다. &lt;code&gt;BEGIN&lt;/code&gt; 및 &lt;code&gt;COMMIT&lt;/code&gt; 로 둘러싸인 명령문 그룹을 &lt;em&gt;트랜잭션 블록&lt;/em&gt; 이라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="a08fed9d9b5168502be31cd2bf857824ed3fb1b6" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; to be used as &lt;code&gt;WITH&lt;/code&gt; queries. This is not found in the SQL standard.</source>
          <target state="translated">PostgreSQL을 사용하면 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 를 &lt;code&gt;WITH&lt;/code&gt; 쿼리 로 사용할 수 있습니다. 이것은 SQL 표준에서 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ae0ed23837a44ee80fff5d2d48a225d0adbd095" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a function call to be written directly as a member of the &lt;code&gt;FROM&lt;/code&gt; list. In the SQL standard it would be necessary to wrap such a function call in a sub-&lt;code&gt;SELECT&lt;/code&gt;; that is, the syntax &lt;code&gt;FROM func(...) alias&lt;/code&gt; is approximately equivalent to &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt;. Note that &lt;code&gt;LATERAL&lt;/code&gt; is considered to be implicit; this is because the standard requires &lt;code&gt;LATERAL&lt;/code&gt; semantics for an &lt;code&gt;UNNEST()&lt;/code&gt; item in &lt;code&gt;FROM&lt;/code&gt;. PostgreSQL treats &lt;code&gt;UNNEST()&lt;/code&gt; the same as other set-returning functions.</source>
          <target state="translated">PostgreSQL을 사용하면 함수 호출을 &lt;code&gt;FROM&lt;/code&gt; 목록 의 멤버로 직접 작성할 수 있습니다 . SQL 표준에서는 이러한 함수 호출을 하위 &lt;code&gt;SELECT&lt;/code&gt; 에 래핑해야합니다 . 즉, &lt;code&gt;FROM func(...) alias&lt;/code&gt; 구문 은 &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt; 와 거의 같습니다 . 참고 &lt;code&gt;LATERAL&lt;/code&gt; 암시로 간주됩니다; 이는 표준 에 &lt;code&gt;FROM&lt;/code&gt; 의 &lt;code&gt;UNNEST()&lt;/code&gt; 항목에 대한 &lt;code&gt;LATERAL&lt;/code&gt; 시맨틱이 필요하기 때문 입니다. PostgreSQL은 &lt;code&gt;UNNEST()&lt;/code&gt; 를 다른 set-returning 함수와 동일하게 취급 합니다.</target>
        </trans-unit>
        <trans-unit id="1fec2c228fe0347b7815e3014f29d97d5a87acca" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table of no columns to be created (for example, &lt;code&gt;CREATE TABLE foo();&lt;/code&gt;). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases for &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt;, so it seems cleaner to ignore this spec restriction.</source>
          <target state="translated">PostgreSQL을 사용하면 열이없는 테이블을 만들 수 있습니다 (예 : &lt;code&gt;CREATE TABLE foo();&lt;/code&gt; ). 이것은 열이 0 인 테이블을 허용하지 않는 SQL 표준의 확장입니다. 제로 열 테이블은 그다지 유용하지 않지만이를 허용하지 않으면 &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt; 에 대해 이상한 특수한 경우가 발생 하므로이 사양 제한을 ​​무시하는 것이 더 깔끔해 보입니다.</target>
        </trans-unit>
        <trans-unit id="5a502e4f8d9c2660f0a8eba2540286883c5cd8c9" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table to have more than one identity column. The standard specifies that a table can have at most one identity column. This is relaxed mainly to give more flexibility for doing schema changes or migrations. Note that the &lt;code&gt;INSERT&lt;/code&gt; command supports only one override clause that applies to the entire statement, so having multiple identity columns with different behaviors is not well supported.</source>
          <target state="translated">PostgreSQL을 사용하면 테이블에 둘 이상의 ID 열이있을 수 있습니다. 표준은 테이블이 최대 하나의 ID 열을 가질 수 있도록 지정합니다. 이는 주로 스키마 변경 또는 마이그레이션을위한 유연성을 높이기 위해 완화되었습니다. 점을 유의 &lt;code&gt;INSERT&lt;/code&gt; 그래서 다른 동작으로 여러 ID 열을 갖는 모든 문에 적용 명령을 지원하는 하나의 재정의 절은 잘 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3ae4855b2a3e72640693b7d20d3ad5d9fb47042" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a trailing &lt;code&gt;*&lt;/code&gt; to be written to explicitly specify the non-&lt;code&gt;ONLY&lt;/code&gt; behavior of including child tables. The standard does not allow this.</source>
          <target state="translated">PostgreSQL을 사용하면 후행 &lt;code&gt;*&lt;/code&gt; 을 작성 하여 자식 테이블을 포함 하는 비 &lt;code&gt;ONLY&lt;/code&gt; 동작 을 명시 적으로 지정할 수 있습니다. 표준은 이것을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0222c8fe2334be83692d30a209d5aa08ec24134f" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows an object owner to revoke their own ordinary privileges: for example, a table owner can make the table read-only to themselves by revoking their own &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt; privileges. This is not possible according to the SQL standard. The reason is that PostgreSQL treats the owner's privileges as having been granted by the owner to themselves; therefore they can revoke them too. In the SQL standard, the owner's privileges are granted by an assumed entity &amp;ldquo;_SYSTEM&amp;rdquo;. Not being &amp;ldquo;_SYSTEM&amp;rdquo;, the owner cannot revoke these rights.</source>
          <target state="translated">PostgreSQL을 사용하면 객체 소유자가 자신의 일반 권한을 취소 할 수 있습니다. 예를 들어, 테이블 소유자는 자신의 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 및 &lt;code&gt;TRUNCATE&lt;/code&gt; 권한 을 취소하여 테이블을 읽기 전용으로 만들 수 있습니다 . 이것은 SQL 표준에 따라 불가능합니다. 그 이유는 PostgreSQL이 소유자의 권한을 소유자가 자신에게 부여한 것으로 취급하기 때문입니다. 그러므로 그들도 취소 할 수 있습니다. SQL 표준에서 소유자의 권한은 가정 된 엔터티&amp;ldquo;_SYSTEM&amp;rdquo;에 의해 부여됩니다. &amp;ldquo;_SYSTEM&amp;rdquo;이 아닌 소유자는 이러한 권한을 취소 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d75f3d8cbebcea3de67f82faaf69d14b5b967380" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows columns of a table to be defined as variable-length multidimensional arrays. Arrays of any built-in or user-defined base type, enum type, composite type, range type, or domain can be created.</source>
          <target state="translated">PostgreSQL에서는 테이블의 열을 가변 길이 다차원 배열로 정의 할 수 있습니다. 내장 또는 사용자 정의 기본 유형, 열거 형 유형, 복합 유형, 범위 유형 또는 도메인의 배열을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06987dbdd7bcd6dca55a6bfbcab96569673d7620" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows conversion between any two character sets for which a conversion function is listed in the &lt;a href=&quot;catalog-pg-conversion&quot;&gt;&lt;code&gt;pg_conversion&lt;/code&gt;&lt;/a&gt; system catalog. PostgreSQL comes with some predefined conversions, as summarized in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt; and shown in more detail in &lt;a href=&quot;multibyte#BUILTIN-CONVERSIONS-TABLE&quot;&gt;Table 23.3&lt;/a&gt;. You can create a new conversion using the SQL command &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt;. (To be used for automatic client/server conversions, a conversion must be marked as &amp;ldquo;default&amp;rdquo; for its character set pair.)</source>
          <target state="translated">PostgreSQL allows conversion between any two character sets for which a conversion function is listed in the &lt;a href=&quot;catalog-pg-conversion&quot;&gt; &lt;code&gt;pg_conversion&lt;/code&gt; &lt;/a&gt; system catalog. PostgreSQL comes with some predefined conversions, as summarized in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt; and shown in more detail in &lt;a href=&quot;multibyte#BUILTIN-CONVERSIONS-TABLE&quot;&gt;Table 23.3&lt;/a&gt;. You can create a new conversion using the SQL command &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt;. (To be used for automatic client/server conversions, a conversion must be marked as &amp;ldquo;default&amp;rdquo; for its character set pair.)</target>
        </trans-unit>
        <trans-unit id="bbbdf4cafaaa4dcf65d19eea36b6d2663f13d7b7" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows database sessions to synchronize their snapshots. A &lt;em&gt;snapshot&lt;/em&gt; determines which data is visible to the transaction that is using the snapshot. Synchronized snapshots are necessary when two or more sessions need to see identical content in the database. If two sessions just start their transactions independently, there is always a possibility that some third transaction commits between the executions of the two &lt;code&gt;START TRANSACTION&lt;/code&gt; commands, so that one session sees the effects of that transaction and the other does not.</source>
          <target state="translated">PostgreSQL을 사용하면 데이터베이스 세션이 스냅 샷을 동기화 할 수 있습니다. &lt;em&gt;스냅 숏&lt;/em&gt; 데이터의 스냅 샷을 사용하는 트랜잭션에 보이는 결정. 둘 이상의 세션이 데이터베이스에서 동일한 컨텐츠를 볼 필요가있는 경우 동기화 된 스냅 샷이 필요합니다. 두 개의 세션이 트랜잭션을 독립적으로 시작하는 경우 항상 두 개의 &lt;code&gt;START TRANSACTION&lt;/code&gt; 명령 실행 사이에 일부 세 번째 트랜잭션이 커미트 될 수 있으므로 한 세션은 해당 트랜잭션의 영향을보고 다른 세션은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f376988cf3adab23de6270e27f2d8af7b43d3dc" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows expressions with prefix and postfix unary (one-argument) operators, as well as binary (two-argument) operators. Like functions, operators can be overloaded, so the same problem of selecting the right operator exists.</source>
          <target state="translated">PostgreSQL을 사용하면 이진수 (2 인수) 연산자뿐만 아니라 접두사 및 접미사 단항 (1 인수) 연산자를 사용할 수 있습니다. 함수와 마찬가지로 연산자가 오버로드 될 수 있으므로 올바른 연산자를 선택하는 것과 동일한 문제가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="38e06aff61270fa25d3a83fecc14dbc49c17fa73" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows function &lt;em&gt;overloading&lt;/em&gt;; that is, the same name can be used for several different functions so long as they have distinct input argument types. Whether or not you use it, this capability entails security precautions when calling functions in databases where some users mistrust other users; see &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL은 함수 &lt;em&gt;오버로딩을&lt;/em&gt; 허용합니다 . 즉, 고유 한 입력 인수 유형이있는 한 여러 다른 함수에 동일한 이름을 사용할 수 있습니다. 사용 여부에 관계없이이 기능은 일부 사용자가 다른 사용자를 불신하는 데이터베이스에서 함수를 호출 할 때 보안 예방 조치를 수반합니다. &lt;a href=&quot;typeconv-func&quot;&gt;섹션 10.3&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="885786b4f5cdfbf8b703cb2cdbcec19a632c472d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows functions that have named parameters to be called using either &lt;em&gt;positional&lt;/em&gt; or &lt;em&gt;named&lt;/em&gt; notation. Named notation is especially useful for functions that have a large number of parameters, since it makes the associations between parameters and actual arguments more explicit and reliable. In positional notation, a function call is written with its argument values in the same order as they are defined in the function declaration. In named notation, the arguments are matched to the function parameters by name and can be written in any order. For each notation, also consider the effect of function argument types, documented in &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL에서는 이름이 지정된 매개 변수가있는 함수를 &lt;em&gt;위치&lt;/em&gt; 또는 &lt;em&gt;이름&lt;/em&gt; 표기법을 사용하여 호출 할 수 있습니다 . 명명 된 표기법은 매개 변수와 실제 인수 사이의 연관성을보다 명확하고 안정적으로 만들기 때문에 많은 수의 매개 변수가있는 함수에 특히 유용합니다. 위치 표기법에서 함수 호출은 함수 선언에 정의 된 순서대로 인수 값으로 작성됩니다. 명명 된 표기법에서 인수는 이름별로 함수 매개 변수와 일치하며 순서에 관계없이 작성할 수 있습니다. 각 표기법에 대해 &lt;a href=&quot;typeconv-func&quot;&gt;10.3 절에&lt;/a&gt; 설명 된 함수 인수 유형의 영향도 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccedf68ac95013795d6781ac353bb002bbdac9bd" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows identifier syntax (&lt;code&gt;&quot;rolename&quot;&lt;/code&gt;), while the SQL standard requires the role name to be written as a string literal. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">PostgreSQL은 식별자 구문 ( &lt;code&gt;&quot;rolename&quot;&lt;/code&gt; )을 허용하지만 SQL 표준에서는 역할 이름을 문자열 리터럴로 작성해야합니다. SQL은 트랜잭션 중에이 명령을 허용하지 않습니다. 이유가 없기 때문에 PostgreSQL은 이러한 제한을 두지 않습니다. &lt;code&gt;SESSION&lt;/code&gt; 및 &lt;code&gt;LOCAL&lt;/code&gt; 개질제로하고, PostgreSQL의 확장이다 &lt;code&gt;RESET&lt;/code&gt; 의 구문.</target>
        </trans-unit>
        <trans-unit id="aee304bddb0add35cce98f16acc2e91d76460499" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows one to omit the &lt;code&gt;FROM&lt;/code&gt; clause. It has a straightforward use to compute the results of simple expressions:</source>
          <target state="translated">PostgreSQL을 사용하면 &lt;code&gt;FROM&lt;/code&gt; 절 을 생략 할 수 있습니다 . 간단한 표현식의 결과를 계산하는 데 간단하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0eb6de17c126effc5a1502158efa04db9cdf59d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows only one character set encoding per database. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</source>
          <target state="translated">PostgreSQL은 데이터베이스 당 하나의 문자 세트 인코딩 만 허용합니다. 따라서 데이터베이스 인코딩이 UTF8이 아닌 한 JSON 유형이 JSON 스펙을 엄격하게 준수하는 것은 불가능합니다. 데이터베이스 인코딩에 표시 할 수없는 문자를 직접 포함 시키려고하면 실패합니다. 반대로 데이터베이스 인코딩으로 표현할 수 있지만 UTF8로는 표현할 수없는 문자는 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4d7c19f392d3d32e2ae22627f8334829c75a1e" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows the application developer to specify the durability level required via replication. This can be specified for the system overall, though it can also be specified for specific users or connections, or even individual transactions.</source>
          <target state="translated">PostgreSQL을 통해 애플리케이션 개발자는 복제를 통해 필요한 내구성 수준을 지정할 수 있습니다. 특정 사용자 나 연결 또는 개별 트랜잭션에 대해서도 지정할 수 있지만 시스템 전체에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67e964073140451a310c8055af1d484d7e584b05" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows you to specify time zones in three different forms:</source>
          <target state="translated">PostgreSQL을 사용하면 시간대를 세 가지 다른 형식으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2091ac924b203b9490fe163a62e56fac7f983c3f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts &amp;ldquo;escape&amp;rdquo; string constants, which are an extension to the SQL standard. An escape string constant is specified by writing the letter &lt;code&gt;E&lt;/code&gt; (upper or lower case) just before the opening single quote, e.g., &lt;code&gt;E'foo'&lt;/code&gt;. (When continuing an escape string constant across lines, write &lt;code&gt;E&lt;/code&gt; only before the first opening quote.) Within an escape string, a backslash character (&lt;code&gt;\&lt;/code&gt;) begins a C-like &lt;em&gt;backslash escape&lt;/em&gt; sequence, in which the combination of backslash and following character(s) represent a special byte value, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;Table 4.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL은 SQL 표준의 확장 인 &quot;이스케이프&quot;문자열 상수도 허용합니다. 이스케이프 문자열 상수는 여는 작은 따옴표 바로 앞에 문자 &lt;code&gt;E&lt;/code&gt; (대문자 또는 소문자) 를 쓰면 지정됩니다 (예 : &lt;code&gt;E'foo'&lt;/code&gt; . (선에서 탈출 문자열 상수, 쓰기 계속 &lt;code&gt;E&lt;/code&gt; 이스케이프 문자열 내에서 첫 번째 오프닝 견적 전에를.), 백 슬래시 문자는 (은 &lt;code&gt;\&lt;/code&gt; )는 C와 같은 시작 &lt;em&gt;백 슬래시 이스케이프&lt;/em&gt; 시퀀스에서 백 슬래시의 조합 다음 문자 ( s)는 &lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;표 4.1에&lt;/a&gt; 표시된 것처럼 특수 바이트 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b8e26c666446bf180bc1b3bdb6835476bef38f80" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts the following alternative forms for input: use of upper-case digits, the standard format surrounded by braces, omitting some or all hyphens, adding a hyphen after any group of four digits. Examples are:</source>
          <target state="translated">PostgreSQL은 다음과 같은 대체 입력 형식도 허용합니다. 대문자 숫자 사용, 중괄호로 묶은 표준 형식, 일부 또는 모든 하이픈을 생략하고 4 자리 그룹 뒤에 하이픈을 추가합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d551afc59236ea284f4ca849fa7d2277a7469049" translate="yes" xml:space="preserve">
          <source>PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL은 또한 보안 강화를 위해 GSSAPI를 사용하여 클라이언트 / 서버 통신을 암호화 할 수 있도록 기본 지원합니다. 지원을 위해서는 클라이언트 및 서버 시스템 모두에 GSSAPI 구현 (예 : MIT krb5)이 설치되어 있고 빌드시 PostgreSQL에서 지원이 활성화되어 있어야합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;16 장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="dd43f6c5eff3afed0ef2482d92caa74dc0ae8b00" translate="yes" xml:space="preserve">
          <source>PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="7d7d486aaa9f91eb610db7317aa89991dcace483" translate="yes" xml:space="preserve">
          <source>PostgreSQL also protects against some kinds of data corruption on storage devices that may occur because of hardware errors or media failure over time, such as reading/writing garbage data.</source>
          <target state="translated">PostgreSQL은 또한 가비지 데이터 읽기 / 쓰기와 같이 시간이 지남에 따라 하드웨어 오류 또는 미디어 오류로 인해 발생할 수있는 스토리지 장치의 일부 데이터 손상을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="bc4957185fda95801e3489431ec80f6cc95ed9d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL also provides functions that return the start time of the current statement, as well as the actual current time at the instant the function is called. The complete list of non-SQL-standard time functions is:</source>
          <target state="translated">PostgreSQL은 또한 현재 명령문의 시작 시간과 함수가 호출되는 순간의 실제 현재 시간을 리턴하는 함수를 제공합니다. 비 SQL 표준 시간 함수의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd1b1c906496b16c3b9719d59a4575ea64702a53" translate="yes" xml:space="preserve">
          <source>PostgreSQL also provides the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; for UUIDs.</source>
          <target state="translated">PostgreSQL also provides the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; for UUIDs.</target>
        </trans-unit>
        <trans-unit id="73c105cc11eec562c7842e40a45124c8ca33cfca" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports &lt;em&gt;mixed&lt;/em&gt; notation, which combines positional and named notation. In this case, positional parameters are written first and named parameters appear after them.</source>
          <target state="translated">PostgreSQL 은 위치 표기법과 이름 표기법을 결합한 &lt;em&gt;혼합&lt;/em&gt; 표기법 도 지원합니다 . 이 경우 위치 매개 변수가 먼저 작성되고 이름 지정된 매개 변수가 그 뒤에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ca59eb947715e169590d0f69e1f5c9da2f5d3e56" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports a parameter to strip the realm from the principal. This method is supported for backwards compatibility and is strongly discouraged as it is then impossible to distinguish different users with the same user name but coming from different realms. To enable this, set &lt;code&gt;include_realm&lt;/code&gt; to 0. For simple single-realm installations, doing that combined with setting the &lt;code&gt;krb_realm&lt;/code&gt; parameter (which checks that the principal's realm matches exactly what is in the &lt;code&gt;krb_realm&lt;/code&gt; parameter) is still secure; but this is a less capable approach compared to specifying an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL은 또한 프린시 펄에서 영역을 제거하는 매개 변수를 지원합니다. 이 방법은 이전 버전과의 호환성을 위해 지원되며 동일한 사용자 이름을 가지고 있지만 다른 영역에서 온 다른 사용자를 구별하는 것이 불가능하므로 권장하지 않습니다. 이를 가능하게하려면 &lt;code&gt;include_realm&lt;/code&gt; 을 0으로 설정하십시오. 간단한 단일 영역 설치의 경우 &lt;code&gt;krb_realm&lt;/code&gt; 매개 변수 설정 (주체 영역이 &lt;code&gt;krb_realm&lt;/code&gt; 매개 변수의 내용과 정확히 일치하는지 확인) 설정과 결합하여 수행하는 것이 여전히 안전합니다. 그러나 이것은 &lt;code&gt;pg_ident.conf&lt;/code&gt; 에 명시 적 매핑을 지정하는 것과 비교할 때 능력이 떨어지는 접근법 입니다.</target>
        </trans-unit>
        <trans-unit id="0b477944494e7d8e126d3d69b3ea2e26c69eb1df" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports another type of escape syntax for strings that allows specifying arbitrary Unicode characters by code point. A Unicode escape string constant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case letter U followed by ampersand) immediately before the opening quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the string &lt;code&gt;'data'&lt;/code&gt; could be written as</source>
          <target state="translated">PostgreSQL은 코드 포인트별로 임의의 유니 코드 문자를 지정할 수있는 문자열에 대한 다른 유형의 이스케이프 구문도 지원합니다. 유니 코드 이스케이프 문자열 상수 는 여는 따옴표 바로 앞에 &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt; 같은 공백없이 &lt;code&gt;U&amp;amp;&lt;/code&gt; (대문자 U와 소문자 앰퍼샌드)로 시작합니다 . (주이 운영자와의 모호성 만드는 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 . 사용 공간을 운영자 주위에이 문제를 방지 할 수 있습니다.) 따옴표 내부 유니 코드 문자는 4 자리의 16 진수 코드 포인트 번호 또는 뒤에 백 슬래시를 작성하여 탈출 형태로 지정 될 수 있습니다 또는 백 슬래시와 더하기 부호, 6 자리 16 진수 코드 포인트 번호가 뒤 따릅니다. 예를 들어 문자열 &lt;code&gt;'data'&lt;/code&gt; 로 쓸 수있다</target>
        </trans-unit>
        <trans-unit id="8b4d1cfe50623e59a66d0a1accf91a989fc0e27f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports reporting dynamic information about exactly what is going on in the system right now, such as the exact command currently being executed by other server processes, and which other connections exist in the system. This facility is independent of the collector process.</source>
          <target state="translated">PostgreSQL은 다른 서버 프로세스에서 현재 실행중인 정확한 명령 및 시스템에 존재하는 다른 연결과 같이 시스템에서 현재 진행중인 작업에 대한 동적 정보보고도 지원합니다. 이 기능은 콜렉터 프로세스와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="478c7623d400e727e3280b1e79d887e002061f8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports the SQL-standard notations &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;float(p)&lt;/code&gt; for specifying inexact numeric types. Here, &lt;code&gt;p&lt;/code&gt; specifies the minimum acceptable precision in &lt;em&gt;binary&lt;/em&gt; digits. PostgreSQL accepts &lt;code&gt;float(1)&lt;/code&gt; to &lt;code&gt;float(24)&lt;/code&gt; as selecting the &lt;code&gt;real&lt;/code&gt; type, while &lt;code&gt;float(25)&lt;/code&gt; to &lt;code&gt;float(53)&lt;/code&gt; select &lt;code&gt;double precision&lt;/code&gt;. Values of &lt;code&gt;p&lt;/code&gt; outside the allowed range draw an error. &lt;code&gt;float&lt;/code&gt; with no precision specified is taken to mean &lt;code&gt;double precision&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL은 부정확 한 숫자 유형을 지정하기 위해 SQL 표준 표기법 인 &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;float(p)&lt;/code&gt; 도 지원합니다 . 여기서 &lt;code&gt;p&lt;/code&gt; 는 허용 가능한 최소 정밀도를 &lt;em&gt;이진수&lt;/em&gt; 로 지정합니다 . PostgreSQL은 &lt;code&gt;float(1)&lt;/code&gt; ~ &lt;code&gt;float(24)&lt;/code&gt; 를 &lt;code&gt;real&lt;/code&gt; 유형 으로 선택하고 &lt;code&gt;float(25)&lt;/code&gt; ~ &lt;code&gt;float(53)&lt;/code&gt; &lt;code&gt;double precision&lt;/code&gt; 을 선택 합니다. 허용 범위를 벗어난 &lt;code&gt;p&lt;/code&gt; 값은 오류를 발생시킵니다. &lt;code&gt;float&lt;/code&gt; 의미로 이동합니다 지정되지 정밀 &lt;code&gt;double precision&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de648c643b7990a2f17212f7c4a34e709bba19e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL always initially presumes that a regular expression follows the ARE rules. However, the more limited ERE or BRE rules can be chosen by prepending an &lt;em&gt;embedded option&lt;/em&gt; to the RE pattern, as described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt;. This can be useful for compatibility with applications that expect exactly the POSIX 1003.2 rules.</source>
          <target state="translated">PostgreSQL은 항상 정규 표현식이 ARE 규칙을 따르는 것으로 가정합니다. 그러나 &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;섹션 9.7.3.4에&lt;/a&gt; 설명 된 것처럼 &lt;em&gt;포함 된 옵션&lt;/em&gt; 을 RE 패턴 앞에 추가하여보다 제한된 ERE 또는 BRE 규칙을 선택할 수 있습니다 . POSIX 1003.2 규칙을 정확히 예상하는 응용 프로그램과의 호환성에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54903aca24fd73df3d0ecfd618b2abc92e61f984" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input row. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when rows are inserted or updated, and not at other times. (The warning above about not referencing other table data is really a special case of this restriction.)</source>
          <target state="translated">PostgreSQL은 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건의 조건이 변경 불가능 하다고 가정합니다. 즉 , 동일한 입력 행에 대해 항상 동일한 결과를 제공합니다. 이 가정은 행이 삽입되거나 업데이트 될 때만 다른 시점이 아닌 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건 검사를 정당화하는 것 입니다. (다른 테이블 데이터를 참조하지 않는 것에 대한 위의 경고는 실제로이 제한의 특별한 경우입니다.)</target>
        </trans-unit>
        <trans-unit id="ff088d9be54485de195a863d4cf5285816323947" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input value. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when a value is first converted to be of a domain type, and not at other times. (This is essentially the same as the treatment of table &lt;code&gt;CHECK&lt;/code&gt; constraints, as described in &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;Section 5.4.1&lt;/a&gt;.)</source>
          <target state="translated">PostgreSQL은 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건이 변경 불가능 하다고 가정합니다. 즉 , 동일한 입력 값에 대해 항상 동일한 결과를 제공합니다. 이 가정은 값이 다른 시간이 아닌 도메인 유형으로 처음 변환 될 때만 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건 검사를 정당화하는 것입니다. (이는 &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;5.4.1 절&lt;/a&gt; 에서 설명한 테이블 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 의 처리와 본질적으로 동일합니다 .)</target>
        </trans-unit>
        <trans-unit id="a2bff8b5a2ca5d91db2860fea9c0dad6138d0027" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates a unique index when a unique constraint or primary key is defined for a table. The index covers the columns that make up the primary key or unique constraint (a multicolumn index, if appropriate), and is the mechanism that enforces the constraint.</source>
          <target state="translated">테이블에 대해 고유 제한 조건 또는 기본 키가 정의되면 PostgreSQL은 자동으로 고유 인덱스를 생성합니다. 인덱스는 기본 키 또는 고유 제한 조건 (적절한 경우 다중 열 인덱스)을 구성하는 열을 다루며 제한 조건을 적용하는 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="f26b59affbadfc237829843f54d3c4584d266882" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for more information.)</source>
          <target state="translated">PostgreSQL은 고유성을 유지하기 위해 각 고유 제약 조건 및 기본 키 제약 조건에 대한 인덱스를 자동으로 생성합니다. 따라서 기본 키 열에 대해 명시 적으로 색인을 작성할 필요가 없습니다. (자세한 내용은 &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="0b81b71597df376d9c14681a44f3238d9b5f3ccb" translate="yes" xml:space="preserve">
          <source>PostgreSQL can accept time zone specifications that are written according to the POSIX standard's rules for the &lt;code&gt;TZ&lt;/code&gt; environment variable. POSIX time zone specifications are inadequate to deal with the complexity of real-world time zone history, but there are sometimes reasons to use them.</source>
          <target state="translated">PostgreSQL can accept time zone specifications that are written according to the POSIX standard's rules for the &lt;code&gt;TZ&lt;/code&gt; environment variable. POSIX time zone specifications are inadequate to deal with the complexity of real-world time zone history, but there are sometimes reasons to use them.</target>
        </trans-unit>
        <trans-unit id="71faf5408aef54cef3ab5e08ed45e5e43ecd20a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL can build indexes while leveraging multiple CPUs in order to process the table rows faster. This feature is known as &lt;em&gt;parallel index build&lt;/em&gt;. For index methods that support building indexes in parallel (currently, only B-tree), &lt;code&gt;maintenance_work_mem&lt;/code&gt; specifies the maximum amount of memory that can be used by each index build operation as a whole, regardless of how many worker processes were started. Generally, a cost model automatically determines how many worker processes should be requested, if any.</source>
          <target state="translated">PostgreSQL은 테이블 행을 더 빠르게 처리하기 위해 여러 CPU를 활용하면서 인덱스를 작성할 수 있습니다. 이 기능을 &lt;em&gt;병렬 인덱스 빌드라고&lt;/em&gt; 합니다. 병렬로 색인 작성 (현재 B- 트리 만)을 지원하는 색인 ​​메소드의 경우 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 은 시작된 작업자 프로세스 수에 관계없이 각 색인 빌드 조작에서 전체적으로 사용할 수있는 최대 메모리 양을 지정합니다. 일반적으로 비용 모델은 요청해야하는 작업자 프로세스 수를 자동으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b61a24efb840bbdfd7121333fc936cd259d1497d" translate="yes" xml:space="preserve">
          <source>PostgreSQL can sometimes exhaust various operating system resource limits, especially when multiple copies of the server are running on the same system, or in very large installations. This section explains the kernel resources used by PostgreSQL and the steps you can take to resolve problems related to kernel resource consumption.</source>
          <target state="translated">PostgreSQL은 여러 운영 체제 리소스 제한을 고갈시킬 수 있습니다. 특히 서버의 여러 복사본이 동일한 시스템에서 또는 대규모 설치에서 실행되는 경우. 이 섹션에서는 PostgreSQL에서 사용하는 커널 리소스와 커널 리소스 소비와 관련된 문제를 해결하기 위해 수행 할 수있는 단계에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b2e725f00d6a809e37502a0cf8c2fc8a68d3f58c" translate="yes" xml:space="preserve">
          <source>PostgreSQL comes with the following built-in range types:</source>
          <target state="translated">PostgreSQL에는 다음과 같은 내장 범위 유형이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cb387a6689d06faa79aaca21b4c8e065a066ab23" translate="yes" xml:space="preserve">
          <source>PostgreSQL considers distinct collation objects to be incompatible even when they have identical properties. Thus for example,</source>
          <target state="translated">PostgreSQL은 고유 한 데이터 정렬 객체가 동일한 속성을 가지고 있어도 호환되지 않는 것으로 간주합니다. 따라서 예를 들어</target>
        </trans-unit>
        <trans-unit id="390d5417e842d1a1814896813c380671ee3b4fd0" translate="yes" xml:space="preserve">
          <source>PostgreSQL creates a temporary variable of data type &lt;code&gt;stype&lt;/code&gt; to hold the current internal state of the aggregate. At each input row, the aggregate argument value(s) are calculated and the state transition function is invoked with the current state value and the new argument value(s) to calculate a new internal state value. After all the rows have been processed, the final function is invoked once to calculate the aggregate's return value. If there is no final function then the ending state value is returned as-is.</source>
          <target state="translated">PostgreSQL은 데이터 유형 &lt;code&gt;stype&lt;/code&gt; 의 임시 변수를 생성 하여 집계의 현재 내부 상태를 유지합니다. 각 입력 행에서 집계 인수 값을 계산하고 현재 상태 값 및 새 인수 값으로 상태 전이 함수를 호출하여 새 내부 상태 값을 계산합니다. 모든 행이 처리 된 후 최종 함수가 한 번 호출되어 집계의 리턴 값을 계산합니다. 최종 함수가 없으면 종료 상태 값이 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="14a71a515034c71c679dfb591fbd291cd9591d60" translate="yes" xml:space="preserve">
          <source>PostgreSQL currently does not support multi-character collating elements. This information describes possible future behavior.</source>
          <target state="translated">PostgreSQL은 현재 다중 문자 조합 요소를 지원하지 않습니다. 이 정보는 가능한 미래 행동에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7e2fde7f5f9c9a2ecbda1c45fded6817737c8d70" translate="yes" xml:space="preserve">
          <source>PostgreSQL database passwords are separate from operating system user passwords. The password for each database user is stored in the &lt;code&gt;pg_authid&lt;/code&gt; system catalog. Passwords can be managed with the SQL commands &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, e.g., &lt;strong&gt;&lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt;&lt;/strong&gt;, or the psql command &lt;code&gt;\password&lt;/code&gt;. If no password has been set up for a user, the stored password is null and password authentication will always fail for that user.</source>
          <target state="translated">PostgreSQL 데이터베이스 비밀번호는 운영 체제 사용자 비밀번호와 다릅니다. 각 데이터베이스 사용자의 비밀번호는 &lt;code&gt;pg_authid&lt;/code&gt; 시스템 카탈로그에 저장됩니다 . 비밀번호는 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 및 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; SQL 명령 ( 예 : &lt;strong&gt; &lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt; &lt;/strong&gt; ) 또는 psql 명령 &lt;code&gt;\password&lt;/code&gt; 사용하여 관리 할 수 ​​있습니다 . 사용자에 대한 비밀번호가 설정되지 않은 경우 저장된 비밀번호가 널이며 해당 사용자에 대한 비밀번호 인증이 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae07be10ad05f8eb77e791ce859f3046663e8d9e" translate="yes" xml:space="preserve">
          <source>PostgreSQL databases require periodic maintenance known as &lt;em&gt;vacuuming&lt;/em&gt;. For many installations, it is sufficient to let vacuuming be performed by the &lt;em&gt;autovacuum daemon&lt;/em&gt;, which is described in &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;. You might need to adjust the autovacuuming parameters described there to obtain best results for your situation. Some database administrators will want to supplement or replace the daemon's activities with manually-managed &lt;code&gt;VACUUM&lt;/code&gt; commands, which typically are executed according to a schedule by cron or Task Scheduler scripts. To set up manually-managed vacuuming properly, it is essential to understand the issues discussed in the next few subsections. Administrators who rely on autovacuuming may still wish to skim this material to help them understand and adjust autovacuuming.</source>
          <target state="translated">PostgreSQL 데이터베이스에는 &lt;em&gt;진공 청소기로&lt;/em&gt; 알려진 정기 유지 관리가 필요합니다 . 많은 설치의 경우 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;24.1.6 절에&lt;/a&gt; 설명 된 &lt;em&gt;autovacuum 데몬으로&lt;/em&gt; 진공 청소를 수행하기에 충분합니다 . 상황에 가장 적합한 결과를 얻으려면 여기에 설명 된 자동 진공 파라미터를 조정해야 할 수도 있습니다. 일부 데이터베이스 관리자는 데몬의 활동을 수동으로 관리되는 &lt;code&gt;VACUUM&lt;/code&gt; 으로 보완하거나 교체하려고합니다.명령은 일반적으로 cron 또는 작업 스케줄러 스크립트에 의해 스케줄에 따라 실행됩니다. 수동으로 관리되는 진공 청소기를 올바르게 설정하려면 다음 몇 가지 하위 섹션에서 설명하는 문제를 이해해야합니다. 자동 진공 청소기를 사용하는 관리자는 자동 진공 청소기를 이해하고 조정하는 데 도움이되도록이 자료를 훑어 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b15ec468b17952447cfdd51a679958ed70d2e48" translate="yes" xml:space="preserve">
          <source>PostgreSQL devises a &lt;em&gt;query plan&lt;/em&gt; for each query it receives. Choosing the right plan to match the query structure and the properties of the data is absolutely critical for good performance, so the system includes a complex &lt;em&gt;planner&lt;/em&gt; that tries to choose good plans. You can use the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command to see what query plan the planner creates for any query. Plan-reading is an art that requires some experience to master, but this section attempts to cover the basics.</source>
          <target state="translated">PostgreSQL 은 수신하는 각 쿼리마다 &lt;em&gt;쿼리 계획&lt;/em&gt; 을 고안합니다 . 쿼리 구조와 데이터 속성에 맞는 올바른 계획을 선택하는 것은 좋은 성능을 위해 절대적으로 중요하므로 시스템에는 좋은 계획을 선택 하는 복잡한 &lt;em&gt;계획자가&lt;/em&gt; 포함됩니다 . &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 명령을 사용하여 플래너가 쿼리에 대해 작성하는 쿼리 계획을 볼 수 있습니다. 계획 읽기는 약간의 경험을 필요로하는 기술이지만이 섹션에서는 기본 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c6bdc7ca1f027f4e423efc6001869a2aac8718c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not have an explicit &lt;code&gt;OPEN&lt;/code&gt; cursor statement; a cursor is considered open when it is declared. Use the &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; statement to declare a cursor.</source>
          <target state="translated">PostgreSQL에는 명시적인 &lt;code&gt;OPEN&lt;/code&gt; 커서 문 이 없습니다 . 커서는 선언 될 때 열린 것으로 간주됩니다. &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; 문을 사용하여 커서를 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="0dfef93504eab39387d43751a55a477c2955176f" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not offer this type of replication, though PostgreSQL two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;) can be used to implement this in application code or middleware.</source>
          <target state="translated">PostgreSQL은 이러한 유형의 복제를 제공하지 않지만 PostgreSQL 2 단계 커밋 ( &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; 및 &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; )을 사용하여 애플리케이션 코드 또는 미들웨어에서이를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb2a401b7b0ac69a360f9b7c695ed89ed9ebff0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection.</source>
          <target state="translated">PostgreSQL은 수정 가능한 메모리 오류로부터 보호하지 않으며 업계 표준 ECC (Error Correcting Code) 또는 더 나은 보호를 사용하는 RAM을 사용하여 작동한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="13d3dc2372c98003c5a49c2b15eff6ff46f18e90" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection. However, ECC memory is typically only immune to single-bit errors, and should not be assumed to provide &lt;em&gt;absolute&lt;/em&gt; protection against failures that result in memory corruption.</source>
          <target state="translated">PostgreSQL은 수정 가능한 메모리 오류로부터 보호하지 않으며 업계 표준 ECC (Error Correcting Code) 또는 더 나은 보호를 사용하는 RAM을 사용하여 작동한다고 가정합니다. 그러나 ECC 메모리는 일반적으로 단일 비트 오류에만 영향을받지 않으므로&lt;em&gt; 절대&lt;/em&gt; 메모리 손상 될 장애에 대한 보호.</target>
        </trans-unit>
        <trans-unit id="1217e1656a3a27412f47a2f27ca6ddad0011cb8d" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not provide the system software required to identify a failure on the primary and notify the standby database server. Many such tools exist and are well integrated with the operating system facilities required for successful failover, such as IP address migration.</source>
          <target state="translated">PostgreSQL은 기본에서 장애를 식별하고 대기 데이터베이스 서버에 알리는 데 필요한 시스템 소프트웨어를 제공하지 않습니다. 이러한 많은 도구가 존재하며 IP 주소 마이그레이션과 같은 성공적인 장애 조치에 필요한 운영 체제 기능과 잘 통합되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d796e67fd8db9494e77a87bae072c969985dce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not support &lt;code&gt;CHECK&lt;/code&gt; constraints that reference table data other than the new or updated row being checked. While a &lt;code&gt;CHECK&lt;/code&gt; constraint that violates this rule may appear to work in simple tests, it cannot guarantee that the database will not reach a state in which the constraint condition is false (due to subsequent changes of the other row(s) involved). This would cause a database dump and reload to fail. The reload could fail even when the complete database state is consistent with the constraint, due to rows not being loaded in an order that will satisfy the constraint. If possible, use &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, or &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints to express cross-row and cross-table restrictions.</source>
          <target state="translated">PostgreSQL은 &lt;code&gt;CHECK&lt;/code&gt; 중인 새 행이나 업데이트 된 행 이외의 테이블 데이터를 참조 하는 CHECK 제약 조건을 지원하지 않습니다 . 이 규칙을 위반 하는 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 간단한 테스트에서 작동하는 것처럼 보일 수 있지만 데이터베이스가 제약 조건이 잘못된 상태 (관련된 다른 행의 후속 변경으로 인해)에 도달하지 않는다고 보장 할 수는 없습니다. 이로 인해 데이터베이스 덤프 및 재로드가 실패합니다. 전체 데이터베이스 상태가 제한 조건을 만족시키는 순서로로드되지 않아서 전체 데이터베이스 상태가 제한 조건과 일치하는 경우에도 재로드가 실패 할 수 있습니다. 가능하면 &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;EXCLUDE&lt;/code&gt; 또는 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 제약 조건을 사용하여 행 간 및 테이블 간 제한을 표현하십시오.</target>
        </trans-unit>
        <trans-unit id="cef8ed11bde695868953cc0c745e366d96215f8a" translate="yes" xml:space="preserve">
          <source>PostgreSQL doesn't remember any information about modified rows in memory, so there is no limit on the number of rows locked at one time. However, locking a row might cause a disk write, e.g., &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; modifies selected rows to mark them locked, and so will result in disk writes.</source>
          <target state="translated">PostgreSQL은 메모리의 수정 된 행에 대한 정보를 기억하지 않으므로 한 번에 잠긴 행 수에는 제한이 없습니다. 그러나 행을 잠그면 디스크 쓰기가 발생할 수 있습니다. 예를 들어, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 는 선택된 행을 수정하여 잠긴 것으로 표시하므로 디스크 쓰기가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="63ab1d6406e057a762f3f310fecdc3a3bbd6104e" translate="yes" xml:space="preserve">
          <source>PostgreSQL endeavors to be compatible with the SQL standard definitions for typical usage. However, the SQL standard has an odd mix of date and time types and capabilities. Two obvious problems are:</source>
          <target state="translated">PostgreSQL은 일반적인 사용법에 대한 SQL 표준 정의와 호환되도록 노력합니다. 그러나 SQL 표준에는 날짜 및 시간 유형과 기능이 혼합되어 있습니다. 두 가지 명백한 문제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66d120b7abdf73ead6dc3fd9f48bfc40f4f89b99" translate="yes" xml:space="preserve">
          <source>PostgreSQL enforces SQL uniqueness constraints using &lt;em&gt;unique indexes&lt;/em&gt;, which are indexes that disallow multiple entries with identical keys. An access method that supports this feature sets &lt;code&gt;amcanunique&lt;/code&gt; true. (At present, only b-tree supports it.) Columns listed in the &lt;code&gt;INCLUDE&lt;/code&gt; clause are not considered when enforcing uniqueness.</source>
          <target state="translated">PostgreSQL 은 동일한 키를 가진 여러 항목을 허용하지 않는 &lt;em&gt;인덱스&lt;/em&gt; 인 &lt;em&gt;unique indexes를&lt;/em&gt; 사용하여 SQL 고유성 제약 조건을 시행 합니다. 이 기능을 지원하는 액세스 방법은 &lt;code&gt;amcanunique&lt;/code&gt; 를 true로 설정 합니다. (현재는 b-tree 만 지원합니다.) &lt;code&gt;INCLUDE&lt;/code&gt; 절에 나열된 열 은 고유성을 적용 할 때 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46cf5e94b98f5acb847fc69a661150beb395793b" translate="yes" xml:space="preserve">
          <source>PostgreSQL grants privileges on some types of objects to &lt;code&gt;PUBLIC&lt;/code&gt; by default when the objects are created. No privileges are granted to &lt;code&gt;PUBLIC&lt;/code&gt; by default on tables, table columns, sequences, foreign data wrappers, foreign servers, large objects, schemas, or tablespaces. For other types of objects, the default privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt; are as follows: &lt;code&gt;CONNECT&lt;/code&gt; and &lt;code&gt;TEMPORARY&lt;/code&gt; (create temporary tables) privileges for databases; &lt;code&gt;EXECUTE&lt;/code&gt; privilege for functions and procedures; and &lt;code&gt;USAGE&lt;/code&gt; privilege for languages and data types (including domains). The object owner can, of course, &lt;code&gt;REVOKE&lt;/code&gt; both default and expressly granted privileges. (For maximum security, issue the &lt;code&gt;REVOKE&lt;/code&gt; in the same transaction that creates the object; then there is no window in which another user can use the object.) Also, these default privilege settings can be overridden using the &lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt; command.</source>
          <target state="translated">PostgreSQL 은 객체가 생성 될 때 기본적 으로 일부 객체 유형에 대한 권한을 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 합니다. 테이블, 테이블 컬럼, 시퀀스, 외부 데이터 랩퍼, 외부 서버, 대형 오브젝트, 스키마 또는 테이블 공간에서 기본적으로 &lt;code&gt;PUBLIC&lt;/code&gt; 에 특권이 부여되지 않습니다 . 다른 유형의 오브젝트의 경우 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 된 기본 권한 은 다음과 같습니다. 데이터베이스에 대한 &lt;code&gt;CONNECT&lt;/code&gt; 및 &lt;code&gt;TEMPORARY&lt;/code&gt; (임시 테이블 작성) 권한; 기능과 절차에 대한 &lt;code&gt;EXECUTE&lt;/code&gt; 특권; 및 &lt;code&gt;USAGE&lt;/code&gt; 언어와 (도메인 포함) 데이터 유형에 대한 권한. 물론 객체 소유자는 &lt;code&gt;REVOKE&lt;/code&gt; 를 수행기본 및 명시 적으로 부여 된 권한. (보안을 최대화 하려면 오브젝트를 작성하는 동일한 트랜잭션에서 &lt;code&gt;REVOKE&lt;/code&gt; 를 발행하십시오 . 그러면 다른 사용자가 오브젝트를 사용할 수있는 창이 없습니다.) 또한 이러한 기본 권한 설정은 &lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt; 명령을 사용하여 겹쳐 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a3b4b281714f98b0b025baa01ab2e4079267b58" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles column expansion by actually transforming the first form into the second. So, in this example, &lt;code&gt;myfunc()&lt;/code&gt; would get invoked three times per row with either syntax. If it's an expensive function you may wish to avoid that, which you can do with a query like:</source>
          <target state="translated">PostgreSQL은 실제로 첫 번째 양식을 두 번째 양식으로 변환하여 열 확장을 처리합니다. 따라서이 예제에서 &lt;code&gt;myfunc()&lt;/code&gt; 는 두 구문 중 하나를 사용하여 행당 세 번 호출됩니다. 비싼 기능이라면 피하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df3dd7b1a171b6d6a80edc47008e7fbb158239c5" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles temporary tables in a way rather different from the standard; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">PostgreSQL은 표준과는 다른 방식으로 임시 테이블을 처리합니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d2f14dc9f7becae572a0674a0a8f299b6b7b7aa" translate="yes" xml:space="preserve">
          <source>PostgreSQL has a rich set of native data types available to users. Users can add new types to PostgreSQL using the &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; command.</source>
          <target state="translated">PostgreSQL에는 사용자가 사용할 수있는 다양한 기본 데이터 유형이 있습니다. &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 명령을 사용하여 PostgreSQL에 새 유형을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78dda5739ec01795bd873fabe7ba9d163840acc7" translate="yes" xml:space="preserve">
          <source>PostgreSQL has an optional but highly recommended feature called &lt;em&gt;autovacuum&lt;/em&gt;, whose purpose is to automate the execution of &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; commands. When enabled, autovacuum checks for tables that have had a large number of inserted, updated or deleted tuples. These checks use the statistics collection facility; therefore, autovacuum cannot be used unless &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; is set to &lt;code&gt;true&lt;/code&gt;. In the default configuration, autovacuuming is enabled and the related configuration parameters are appropriately set.</source>
          <target state="translated">PostgreSQL에는 &lt;code&gt;VACUUM&lt;/code&gt; 및 &lt;code&gt;ANALYZE&lt;/code&gt; 명령 의 실행을 자동화하는 &lt;em&gt;autovacuum&lt;/em&gt; 이라는 선택적이지만 권장되는 기능 이 있습니다. 활성화되면 autovacuum은 많은 수의 삽입, 업데이트 또는 삭제 된 튜플이있는 테이블을 확인합니다. 이러한 검사는 통계 수집 기능을 사용합니다. 따라서 &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있지 않으면 autovacuum을 사용할 수 없습니다 . 기본 구성에서는 자동 진공 청소기가 활성화되고 관련 구성 매개 변수가 적절하게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="745a9a5fff0d46d735897a2bfe230fa0dcd833f5" translate="yes" xml:space="preserve">
          <source>PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt;&lt;code&gt;--with-llvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL은 PostgreSQL이 &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt; &lt;code&gt;--with-llvm&lt;/code&gt; 으로&lt;/a&gt; 빌드 될 때 &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM을&lt;/a&gt; 사용하여 JIT 컴파일을 수행 할 수 있도록 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f7ea341e1bda684ee6450441ed6006b9a4d3fe3f" translate="yes" xml:space="preserve">
          <source>PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt;&lt;code&gt;--with-llvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt; &lt;code&gt;--with-llvm&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1f59e9103489b1a27d73e875b095c1816ff90ee6" translate="yes" xml:space="preserve">
          <source>PostgreSQL has many features not touched upon in this tutorial introduction, which has been oriented toward newer users of SQL. These features are discussed in more detail in the remainder of this book.</source>
          <target state="translated">PostgreSQL에는이 자습서 소개에서 다루지 않은 많은 기능이 있으며, 이는 새로운 SQL 사용자를 대상으로합니다. 이 기능은이 책의 나머지 부분에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="34f532154e5db2109f00a916c27e879723393e79" translate="yes" xml:space="preserve">
          <source>PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL은 보안 강화를 위해 SSL 연결을 사용하여 클라이언트 / 서버 통신을 암호화 할 수 있도록 기본 지원합니다. 이를 위해서는 OpenSSL이 클라이언트 및 서버 시스템 모두에 설치되어 있고 빌드시 PostgreSQL에서 지원이 활성화되어 있어야합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;16 장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="640330cf66c03ad2dde6227a20793bf15623446d" translate="yes" xml:space="preserve">
          <source>PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="ac22150741f7b1e7ae0c9084c74a767cc69f4028" translate="yes" xml:space="preserve">
          <source>PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html#PROTOCOL-REPLICATION-BASE-BACKUP&quot;&gt;BASE_BACKUP&lt;/a&gt; (i.e., replication command that &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; issues to take a base backup). This may be expanded in the future.</source>
          <target state="translated">PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; , and &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html#PROTOCOL-REPLICATION-BASE-BACKUP&quot;&gt;BASE_BACKUP&lt;/a&gt; (i.e., replication command that &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; issues to take a base backup). This may be expanded in the future.</target>
        </trans-unit>
        <trans-unit id="2cee738042d576fe56c5cf2614b5d2a89ef2ed35" translate="yes" xml:space="preserve">
          <source>PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt;. This may be expanded in the future.</source>
          <target state="translated">PostgreSQL은 명령 실행 중 특정 명령의 진행 상황을보고 할 수 있습니다. 현재 진행률보고를 지원하는 유일한 명령은 &lt;code&gt;CREATE INDEX&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; 및 &lt;code&gt;CLUSTER&lt;/code&gt; 입니다. 향후 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a153bd140b6eee429afa97ad0154361013ce149c" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements portions of the SQL/MED specification, allowing you to access data that resides outside PostgreSQL using regular SQL queries. Such data is referred to as &lt;em&gt;foreign data&lt;/em&gt;. (Note that this usage is not to be confused with foreign keys, which are a type of constraint within the database.)</source>
          <target state="translated">PostgreSQL은 SQL / MED 사양의 일부를 구현하여 일반 SQL 쿼리를 사용하여 PostgreSQL 외부에있는 데이터에 액세스 할 수 있습니다. 이러한 데이터를 &lt;em&gt;외부 데이터&lt;/em&gt; 라고합니다 . (이 사용법은 데이터베이스 내의 제약 유형 인 외래 키와 혼동해서는 안됩니다.)</target>
        </trans-unit>
        <trans-unit id="45ba54515ef38ae8443e32276665e58fc7c44f3d" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements table inheritance, which can be a useful tool for database designers. (SQL:1999 and later define a type inheritance feature, which differs in many respects from the features described here.)</source>
          <target state="translated">PostgreSQL은 데이터베이스 상속자에게 유용한 도구가 될 수있는 테이블 상속을 구현합니다. (SQL : 1999 이상은 형식 상속 기능을 정의합니다.이 기능은 여러면에서 여기에 설명 된 기능과 다릅니다.)</target>
        </trans-unit>
        <trans-unit id="9a4293b24f0d18f72db2fd6c1c67a47c9fab41ed" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; that has the same functionality as &lt;code&gt;CREATE ROLE&lt;/code&gt; (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="translated">PostgreSQL에는 &lt;code&gt;CREATE ROLE&lt;/code&gt; 과 동일한 기능 (실제로이 명령을 호출 함)을 가지고 있지만 명령 셸에서 실행할 수 있는 프로그램 &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; 가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84114ad3110b572f55729ff61c07b1a5d40daec3" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; that has the same functionality as this command (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="translated">PostgreSQL에는 이 명령과 동일한 기능 (실제로이 명령을 호출 함)을 가진 프로그램 &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; 가 포함되어 있지만 명령 쉘에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="682b0969ef85f21e73efd9cc0f1d64eca421eb6a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics, so we defer a detailed explanation to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;. Some of the frequently used data types are &lt;code&gt;integer&lt;/code&gt; for whole numbers, &lt;code&gt;numeric&lt;/code&gt; for possibly fractional numbers, &lt;code&gt;text&lt;/code&gt; for character strings, &lt;code&gt;date&lt;/code&gt; for dates, &lt;code&gt;time&lt;/code&gt; for time-of-day values, and &lt;code&gt;timestamp&lt;/code&gt; for values containing both date and time.</source>
          <target state="translated">PostgreSQL에는 많은 응용 프로그램에 적합한 다양한 내장 데이터 유형이 포함되어 있습니다. 사용자는 자신의 데이터 유형을 정의 할 수도 있습니다. 대부분의 내장 데이터 유형에는 명확한 이름과 의미가 있으므로 &lt;a href=&quot;datatype&quot;&gt;8 장에&lt;/a&gt; 대한 자세한 설명을 연기합니다 . 자주 사용되는 데이터 유형 중 일부는 &lt;code&gt;integer&lt;/code&gt; 전체 숫자, &lt;code&gt;numeric&lt;/code&gt; 가능 분수를 들어, &lt;code&gt;text&lt;/code&gt; 문자열에 대한, &lt;code&gt;date&lt;/code&gt; 날짜, &lt;code&gt;time&lt;/code&gt; 시간의 일 값 및 &lt;code&gt;timestamp&lt;/code&gt; 날짜와 시간 모두를 포함하는 값.</target>
        </trans-unit>
        <trans-unit id="735559b54f06b3f3f206e8111b18e4ea8d9566e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an &amp;ldquo;autovacuum&amp;rdquo; facility which can automate routine vacuum maintenance. For more information about automatic and manual vacuuming, see &lt;a href=&quot;routine-vacuuming&quot;&gt;Section 24.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL에는 일상적인 진공 유지 관리를 자동화 할 수있는 &quot;autovacuum&quot;기능이 포함되어 있습니다. 자동 및 수동 진공 청소기에 대한 자세한 내용은 &lt;a href=&quot;routine-vacuuming&quot;&gt;24.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffa60848047cd6b07df3ba1987237f159ca48b0a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an implementation of the standard btree (multi-way balanced tree) index data structure. Any data type that can be sorted into a well-defined linear order can be indexed by a btree index. The only limitation is that an index entry cannot exceed approximately one-third of a page (after TOAST compression, if applicable).</source>
          <target state="translated">PostgreSQL에는 표준 btree (multi-way balance tree) 인덱스 데이터 구조의 구현이 포함됩니다. 잘 정의 된 선형 순서로 정렬 할 수있는 모든 데이터 유형은 btree 색인으로 색인화 할 수 있습니다. 유일한 제한 사항은 색인 항목이 페이지의 약 1/3을 초과 할 수 없다는 것입니다 (해당되는 경우 TOAST 압축 후).</target>
        </trans-unit>
        <trans-unit id="d6a78d8c03890ed632c11d38bfbd22f9d27d3999" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes one function to generate a UUID:</source>
          <target state="translated">PostgreSQL includes one function to generate a UUID:</target>
        </trans-unit>
        <trans-unit id="821fe06f71c1808348a7b91e09179799740b9a95" translate="yes" xml:space="preserve">
          <source>PostgreSQL is a &lt;em&gt;relational database management system&lt;/em&gt; (RDBMS). That means it is a system for managing data stored in &lt;em&gt;relations&lt;/em&gt;. Relation is essentially a mathematical term for &lt;em&gt;table&lt;/em&gt;. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.</source>
          <target state="translated">PostgreSQL은 &lt;em&gt;관계형 데이터베이스 관리 시스템&lt;/em&gt; (RDBMS)입니다. 이는 &lt;em&gt;관계에&lt;/em&gt; 저장된 데이터를 관리하기위한 시스템임을 의미합니다 . 관계는 본질적으로 &lt;em&gt;테이블에&lt;/em&gt; 대한 수학적 용어입니다 . 테이블에 데이터를 저장한다는 개념은 오늘날 매우 흔하게 나타날 수 있지만 본질적으로 데이터베이스를 구성하는 여러 가지 다른 방법이 있습니다. 유닉스 계열 운영 체제의 파일 및 디렉토리는 계층 데이터베이스의 예를 구성합니다. 보다 현대적인 개발은 객체 지향 데이터베이스입니다.</target>
        </trans-unit>
        <trans-unit id="9cfd426182152d61be1e2778a072f15bc552fcab" translate="yes" xml:space="preserve">
          <source>PostgreSQL is implemented using a simple &amp;ldquo;process per user&amp;rdquo; client/server model. In this model there is one &lt;em&gt;client process&lt;/em&gt; connected to exactly one &lt;em&gt;server process&lt;/em&gt;. As we do not know ahead of time how many connections will be made, we have to use a &lt;em&gt;master process&lt;/em&gt; that spawns a new server process every time a connection is requested. This master process is called &lt;code&gt;postgres&lt;/code&gt; and listens at a specified TCP/IP port for incoming connections. Whenever a request for a connection is detected the &lt;code&gt;postgres&lt;/code&gt; process spawns a new server process. The server tasks communicate with each other using &lt;em&gt;semaphores&lt;/em&gt; and &lt;em&gt;shared memory&lt;/em&gt; to ensure data integrity throughout concurrent data access.</source>
          <target state="translated">PostgreSQL은 간단한 &quot;사용자 당 프로세스&quot;클라이언트 / 서버 모델을 사용하여 구현됩니다. 이 모델에는 정확히 하나의 &lt;em&gt;서버 프로세스에&lt;/em&gt; 연결된 하나의 &lt;em&gt;클라이언트 프로세스가 &lt;/em&gt;&lt;em&gt;있습니다&lt;/em&gt; . 연결 수를 미리 알지 못 하므로 연결을 요청할 때마다 새 서버 프로세스를 생성하는 &lt;em&gt;마스터 프로세스&lt;/em&gt; 를 사용해야 합니다. 이 마스터 프로세스를 &lt;code&gt;postgres&lt;/code&gt; 라고 하며 지정된 TCP / IP 포트에서 수신 연결을 수신합니다. 연결 요청이 감지 될 때마다 &lt;code&gt;postgres&lt;/code&gt; 프로세스는 새 서버 프로세스를 생성합니다. 서버 작업을 사용하여 서로 통신 &lt;em&gt;세마포어&lt;/em&gt; 와 &lt;em&gt; 공유 메모리를 합니다.&lt;/em&gt;동시 데이터 액세스에 걸쳐 데이터 무결성을 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b0c6c6215c78ea032d3a013c7f4ae434fd6519" translate="yes" xml:space="preserve">
          <source>PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</source>
          <target state="translated">PostgreSQL은 SQL 표준이 요구하는 것보다 날짜 / 시간 입력을보다 유연하게 처리합니다. 날짜 / 시간 입력의 정확한 구문 분석 규칙과 월, 요일 및 시간대를 포함하여 인식 된 텍스트 필드에 대해서는 &lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;부록 B&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e736d3c1e26ee5e1fae5c95f8dd1c63e5c415e11" translate="yes" xml:space="preserve">
          <source>PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/13/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</source>
          <target state="translated">PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/13/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</target>
        </trans-unit>
        <trans-unit id="c828eb4cf5a62919aaf9e56822812dfeb42eacd5" translate="yes" xml:space="preserve">
          <source>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</source>
          <target state="translated">PostgreSQL은 확장 성이 뛰어나 새로운 데이터 유형, 함수, 연산자 및 기타 데이터베이스 객체를 정의 할 수 있습니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;37 장을&lt;/a&gt; 참조하십시오 . 실제로 내장 객체는 거의 동일한 메커니즘을 사용하여 구현됩니다. 이 확장 성은 함수 호출로 인한 오버 헤드를 의미합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;37.3 절&lt;/a&gt; 참조 ). 이러한 오버 헤드를 줄이기 위해 JIT 컴파일은 작은 함수의 본문을 사용하여 표현식에 인라인 할 수 있습니다. 이를 통해 오버 헤드의 상당 부분을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b06ee715ba9fc1a2cac6f18f375e3b7a31953a1c" translate="yes" xml:space="preserve">
          <source>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</source>
          <target state="translated">PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</target>
        </trans-unit>
        <trans-unit id="66bf58dffda176b2af709bb0e9bb018d0b319b34" translate="yes" xml:space="preserve">
          <source>PostgreSQL lets you reference columns of other tables in the &lt;code&gt;WHERE&lt;/code&gt; condition by specifying the other tables in the &lt;code&gt;USING&lt;/code&gt; clause. For example, to delete all films produced by a given producer, one can do:</source>
          <target state="translated">PostgreSQL을 사용하면 &lt;code&gt;USING&lt;/code&gt; 절 에 다른 테이블을 지정하여 &lt;code&gt;WHERE&lt;/code&gt; 조건 에서 다른 테이블의 열을 참조 할 수 있습니다 . 예를 들어, 특정 제작자가 제작 한 모든 영화를 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="575317fbf767c3750ee89eec8e188302800f4189" translate="yes" xml:space="preserve">
          <source>PostgreSQL makes use of symbolic links to simplify the implementation of tablespaces. This means that tablespaces can be used &lt;em&gt;only&lt;/em&gt; on systems that support symbolic links.</source>
          <target state="translated">PostgreSQL은 심볼릭 링크를 사용하여 테이블 스페이스 구현을 단순화합니다. 이는 테이블 스페이스는 기호 링크를 지원하는 시스템 &lt;em&gt;에서만&lt;/em&gt; 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c0ca6dd2831d7be94912fd0050870a1cb327936d" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers a way to specify how to divide a table into pieces called partitions. The table that is divided is referred to as a &lt;em&gt;partitioned table&lt;/em&gt;. The specification consists of the &lt;em&gt;partitioning method&lt;/em&gt; and a list of columns or expressions to be used as the &lt;em&gt;partition key&lt;/em&gt;.</source>
          <target state="translated">PostgreSQL은 테이블을 파티션이라는 조각으로 나누는 방법을 지정하는 방법을 제공합니다. &lt;em&gt;분할 된 테이블을 분할 된 테이블&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 사양은 &lt;em&gt;파티션 방법&lt;/em&gt; 과 &lt;em&gt;파티션 키로&lt;/em&gt; 사용할 열 또는 표현식 목록으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="891f5d2a022ddd1dd671a070027ea1cff8f75e34" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers built-in support for the following forms of partitioning:</source>
          <target state="translated">PostgreSQL은 다음 형식의 파티셔닝을 기본적으로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5662adc70468d34652ede9f811304c570cee30e3" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers data types to store IPv4, IPv6, and MAC addresses, as shown in &lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;Table 8.21&lt;/a&gt;. It is better to use these types instead of plain text types to store network addresses, because these types offer input error checking and specialized operators and functions (see &lt;a href=&quot;functions-net&quot;&gt;Section 9.12&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL은 &lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;표 8.21&lt;/a&gt; 과 같이 IPv4, IPv6 및 MAC 주소를 저장하기위한 데이터 유형을 제공합니다 . 네트워크 주소를 저장하기 위해 일반 텍스트 유형 대신 이러한 유형을 사용하는 것이 좋습니다. 이러한 유형은 입력 오류 검사 및 특수 연산자 및 기능을 제공하기 때문입니다 ( &lt;a href=&quot;functions-net&quot;&gt;9.12 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="84c215e752220c438a12a8423b6fe5998d9faf4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers encryption at several levels, and provides flexibility in protecting data from disclosure due to database server theft, unscrupulous administrators, and insecure networks. Encryption might also be required to secure sensitive data such as medical records or financial transactions.</source>
          <target state="translated">PostgreSQL은 여러 수준의 암호화를 제공하며 데이터베이스 서버 도난, 부도덕 한 관리자 및 안전하지 않은 네트워크로 인한 데이터 공개를 유연하게 보호합니다. 의료 기록이나 금융 거래와 같은 민감한 데이터를 보호하기 위해 암호화가 필요할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f5fb450ee35fca9053db0e9cf0fee2e325d788" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers two types for storing JSON data: &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt;. To implement efficient query mechanisms for these data types, PostgreSQL also provides the &lt;code&gt;jsonpath&lt;/code&gt; data type described in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL은 JSON 데이터 저장을 위해 &lt;code&gt;json&lt;/code&gt; 과 &lt;code&gt;jsonb&lt;/code&gt; 의 두 가지 유형을 제공합니다 . 이러한 데이터 유형에 대한 효율적인 쿼리 메커니즘을 구현하기 위해 PostgreSQL은 &lt;code&gt;jsonpath&lt;/code&gt; &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;섹션에&lt;/a&gt; 설명 된 jsonpath 데이터 유형 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="926dbd334c49f127c9efe79cdb0a9983f9b87b3a" translate="yes" xml:space="preserve">
          <source>PostgreSQL only allows the execution of a user-defined function for the triggered action. The standard allows the execution of a number of other SQL commands, such as &lt;code&gt;CREATE TABLE&lt;/code&gt;, as the triggered action. This limitation is not hard to work around by creating a user-defined function that executes the desired commands.</source>
          <target state="translated">PostgreSQL은 트리거 된 동작에 대한 사용자 정의 함수의 실행 만 허용합니다. 이 표준을 사용하면 &lt;code&gt;CREATE TABLE&lt;/code&gt; 과 같은 여러 가지 다른 SQL 명령을 트리거 된 조치로 실행할 수 있습니다. 이 제한 사항은 원하는 명령을 실행하는 사용자 정의 함수를 작성하여 해결하기 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43083b6336b02575039a2d9d8f76b5988935b20e" translate="yes" xml:space="preserve">
          <source>PostgreSQL procedural language libraries can be preloaded in this way, typically by using the syntax &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; where &lt;code&gt;XXX&lt;/code&gt; is &lt;code&gt;pgsql&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt;, &lt;code&gt;tcl&lt;/code&gt;, or &lt;code&gt;python&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 절차 언어 라이브러리는 일반적으로 &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; 구문을 사용하여 사전로드 할 수 있습니다. 여기서 &lt;code&gt;XXX&lt;/code&gt; 는 &lt;code&gt;pgsql&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;tcl&lt;/code&gt; 또는 &lt;code&gt;python&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f59dd80e652539f7d5e5bc6cc2d156491128c008" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a JIT implementation based on LLVM. The interface to the JIT provider is pluggable and the provider can be changed without recompiling (although currently, the build process only provides inlining support data for LLVM). The active provider is chosen via the setting &lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL은 LLVM을 기반으로 JIT 구현을 제공합니다. JIT 제공자에 대한 인터페이스는 플러그 가능하며 다시 컴파일하지 않고 제공자를 변경할 수 있습니다 (현재는 빌드 프로세스가 LLVM에 대한 인라인 지원 데이터 만 제공함). 활성 제공자는 &lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt; 설정을 통해 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe91789313046ec6475705a372e78ba71b0024c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a function to inspect complex statistics defined using the &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command.</source>
          <target state="translated">PostgreSQL은 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 명령을 사용하여 정의 된 복잡한 통계를 검사하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="46fdddf06cc7902f32855be5f7713801b1905af6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a means for creating locks that have application-defined meanings. These are called &lt;em&gt;advisory locks&lt;/em&gt;, because the system does not enforce their use &amp;mdash; it is up to the application to use them correctly. Advisory locks can be useful for locking strategies that are an awkward fit for the MVCC model. For example, a common use of advisory locks is to emulate pessimistic locking strategies typical of so-called &amp;ldquo;flat file&amp;rdquo; data management systems. While a flag stored in a table could be used for the same purpose, advisory locks are faster, avoid table bloat, and are automatically cleaned up by the server at the end of the session.</source>
          <target state="translated">PostgreSQL은 애플리케이션 정의 의미를 갖는 잠금을 생성하는 수단을 제공합니다. 시스템은 사용을 강제하지 않기 때문에 &lt;em&gt;권고 잠금&lt;/em&gt; 이라고하며 이를 올바르게 사용하는 것은 응용 프로그램의 책임입니다. 권고 잠금은 MVCC 모델에 적합하지 않은 잠금 전략에 유용 할 수 있습니다. 예를 들어, 권고 잠금의 일반적인 사용은 소위 &quot;플랫 파일&quot;데이터 관리 시스템의 전형적인 비관적 잠금 전략을 모방하는 것입니다. 테이블에 저장된 플래그는 동일한 목적으로 사용될 수 있지만 권고 잠금은 더 빠르며 테이블 팽창을 피하며 세션이 끝날 때 서버에 의해 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="0cfb1fbdc7aff0cefa972216042683bcba69e5d6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a number of functions that return values related to the current date and time. These SQL-standard functions all return values based on the start time of the current transaction:</source>
          <target state="translated">PostgreSQL은 현재 날짜 및 시간과 관련된 값을 반환하는 많은 함수를 제공합니다. 이 SQL 표준 함수는 모두 현재 트랜잭션의 시작 시간을 기준으로 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b4d4d96a6016bf1a3419a8adde28df6d7f17d284" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a rich set of tools for developers to manage concurrent access to data. Internally, data consistency is maintained by using a multiversion model (Multiversion Concurrency Control, MVCC). This means that each SQL statement sees a snapshot of data (a &lt;em&gt;database version&lt;/em&gt;) as it was some time ago, regardless of the current state of the underlying data. This prevents statements from viewing inconsistent data produced by concurrent transactions performing updates on the same data rows, providing &lt;em&gt;transaction isolation&lt;/em&gt; for each database session. MVCC, by eschewing the locking methodologies of traditional database systems, minimizes lock contention in order to allow for reasonable performance in multiuser environments.</source>
          <target state="translated">PostgreSQL은 개발자가 데이터에 대한 동시 액세스를 관리 할 수있는 다양한 도구를 제공합니다. 내부적으로 다중 버전 모델 (Multiversion Concurrency Control, MVCC)을 사용하여 데이터 일관성을 유지합니다. 이는 각 SQL 문이 기본 데이터의 현재 상태에 관계없이 얼마 전과 같이 데이터의 스냅 샷 ( &lt;em&gt;데이터베이스 버전&lt;/em&gt; )을 보는 것을 의미합니다 . 이는 명령문이 동일한 데이터 행에서 갱신을 수행하는 동시 트랜잭션으로 인해 일관되지 않은 데이터를 보지 못하게 하여 각 데이터베이스 세션에 대해 &lt;em&gt;트랜잭션 분리&lt;/em&gt; 를 제공 &lt;em&gt;합니다&lt;/em&gt; . MVCC는 기존 데이터베이스 시스템의 잠금 방법론을 피함으로써 다중 사용자 환경에서 합리적인 성능을 발휘할 수 있도록 잠금 경합을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="1ecdd68232ab41018a2aebf2b36bf6bfee6f90a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a set of default roles which provide access to certain, commonly needed, privileged capabilities and information. Administrators can GRANT these roles to users and/or other roles in their environment, providing those users with access to the specified capabilities and information.</source>
          <target state="translated">PostgreSQL은 일반적으로 필요한 특권 기능 및 정보에 대한 액세스를 제공하는 기본 역할 세트를 제공합니다. 관리자는 이러한 역할을 사용자 및 / 또는 환경의 다른 역할에 부여하여 해당 사용자에게 지정된 기능 및 정보에 대한 액세스 권한을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12a7e7c8c66bad39574adedb86e60a5508ed2a12" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides facilities to support dynamic tracing of the database server. This allows an external utility to be called at specific points in the code and thereby trace execution.</source>
          <target state="translated">PostgreSQL은 데이터베이스 서버의 동적 추적을 지원하는 기능을 제공합니다. 이를 통해 코드의 특정 지점에서 외부 유틸리티를 호출하여 실행을 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93788cdb40903d97aaf58bdd1f296a2d0af57e6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides predefined dictionaries for many languages. There are also several predefined templates that can be used to create new dictionaries with custom parameters. Each predefined dictionary template is described below. If no existing template is suitable, it is possible to create new ones; see the &lt;code&gt;contrib/&lt;/code&gt; area of the PostgreSQL distribution for examples.</source>
          <target state="translated">PostgreSQL은 여러 언어에 대해 사전 정의 된 사전을 제공합니다. 사용자 정의 매개 변수를 사용하여 새 사전을 작성하는 데 사용할 수있는 몇 가지 사전 정의 된 템플리트도 있습니다. 사전 정의 된 각 사전 템플릿이 아래에 설명되어 있습니다. 기존 템플릿이 적합하지 않은 경우 새 템플릿을 만들 수 있습니다. 예제는 PostgreSQL 배포판 의 &lt;code&gt;contrib/&lt;/code&gt; 영역을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abe4b5b2c2d17d1440228c909b7105d20d3d03a0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several features for breaking down complex &lt;code&gt;postgresql.conf&lt;/code&gt; files into sub-files. These features are especially useful when managing multiple servers with related, but not identical, configurations.</source>
          <target state="translated">PostgreSQL은 복잡한 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일을 하위 파일로 분류 하기위한 몇 가지 기능을 제공 합니다. 이러한 기능은 특히 동일하지는 않지만 관련된 구성으로 여러 서버를 관리 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="12ddc3899973df221c8322e34a526586b23ebfaa" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several index types: B-tree, Hash, GiST, SP-GiST, GIN and BRIN. Each index type uses a different algorithm that is best suited to different types of queries. By default, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command creates B-tree indexes, which fit the most common situations.</source>
          <target state="translated">PostgreSQL은 B-tree, Hash, GiST, SP-GiST, GIN 및 BRIN과 같은 몇 가지 인덱스 유형을 제공합니다. 각 인덱스 유형은 다른 유형의 쿼리에 가장 적합한 다른 알고리즘을 사용합니다. 기본적으로 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령은 가장 일반적인 상황에 맞는 B- 트리 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4d643a989351582bdcc707ed3905be058a733c4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides storage and comparison functions for UUIDs, but the core database does not include any function for generating UUIDs, because no single algorithm is well suited for every application. The &lt;a href=&quot;uuid-ossp&quot;&gt;uuid-ossp&lt;/a&gt; module provides functions that implement several standard algorithms. The &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module also provides a generation function for random UUIDs. Alternatively, UUIDs could be generated by client applications or other libraries invoked through a server-side function.</source>
          <target state="translated">PostgreSQL은 UUID에 대한 저장 및 비교 기능을 제공하지만 모든 응용 프로그램에 적합한 단일 알고리즘이 없기 때문에 핵심 데이터베이스에는 UUID 생성 기능이 포함되어 있지 않습니다. &lt;a href=&quot;uuid-ossp&quot;&gt;UUID - OSSP의&lt;/a&gt; 모듈은 여러 표준 알고리즘을 구현하는 기능을 제공합니다. &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto의&lt;/a&gt; 모듈은 임의의 UUID를 생성하는 기능을 제공한다. 또는 UUID는 서버 측 기능을 통해 호출 된 클라이언트 응용 프로그램 또는 기타 라이브러리에 의해 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8055d8a3fe512bf9a836cadb5eae9c2e8b86c5c" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the function &lt;code&gt;to_tsvector&lt;/code&gt; for converting a document to the &lt;code&gt;tsvector&lt;/code&gt; data type.</source>
          <target state="translated">PostgreSQL은 문서를 &lt;code&gt;tsvector&lt;/code&gt; 데이터 형식으로 변환하기 위해 &lt;code&gt;to_tsvector&lt;/code&gt; 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="987c367c1a1efc0cb03cfb3dd34409cf91adaf69" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, &lt;code&gt;phraseto_tsquery&lt;/code&gt; and &lt;code&gt;websearch_to_tsquery&lt;/code&gt; for converting a query to the &lt;code&gt;tsquery&lt;/code&gt; data type. &lt;code&gt;to_tsquery&lt;/code&gt; offers access to more features than either &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;phraseto_tsquery&lt;/code&gt;, but it is less forgiving about its input. &lt;code&gt;websearch_to_tsquery&lt;/code&gt; is a simplified version of &lt;code&gt;to_tsquery&lt;/code&gt; with an alternative syntax, similar to the one used by web search engines.</source>
          <target state="translated">PostgreSQL은 쿼리를 &lt;code&gt;tsquery&lt;/code&gt; 데이터 형식으로 변환하기 위해 &lt;code&gt;to_tsquery&lt;/code&gt; , &lt;code&gt;plainto_tsquery&lt;/code&gt; , &lt;code&gt;phraseto_tsquery&lt;/code&gt; 및 &lt;code&gt;websearch_to_tsquery&lt;/code&gt; 함수를 제공합니다 . &lt;code&gt;to_tsquery&lt;/code&gt; 는 &lt;code&gt;plainto_tsquery&lt;/code&gt; 또는 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 보다 많은 기능에 대한 액세스를 제공 하지만 입력에 대해서는 덜 관대합니다. &lt;code&gt;websearch_to_tsquery&lt;/code&gt; 는 웹 검색 엔진에서 사용하는 것과 유사한 대체 구문을 사용하는 단순화 된 &lt;code&gt;to_tsquery&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="d433b9e1cb0cc5f1366352a11ce9410f17e6d0fd" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the index methods B-tree, hash, GiST, SP-GiST, GIN, and BRIN. Users can also define their own index methods, but that is fairly complicated.</source>
          <target state="translated">PostgreSQL은 B- 트리, 해시, GiST, SP-GiST, GIN 및 BRIN과 같은 인덱스 방법을 제공합니다. 사용자는 자신의 색인 방법을 정의 할 수도 있지만 상당히 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="bed8f31d13fc879249d79e50cd113d8dd0d3c306" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the standard SQL type &lt;code&gt;boolean&lt;/code&gt;; see &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;Table 8.19&lt;/a&gt;. The &lt;code&gt;boolean&lt;/code&gt; type can have several states: &amp;ldquo;true&amp;rdquo;, &amp;ldquo;false&amp;rdquo;, and a third state, &amp;ldquo;unknown&amp;rdquo;, which is represented by the SQL null value.</source>
          <target state="translated">PostgreSQL은 표준 SQL 유형 &lt;code&gt;boolean&lt;/code&gt; 제공합니다 . &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;표 8.19&lt;/a&gt; 참조 . &lt;code&gt;boolean&lt;/code&gt; 은 SQL 널 (null) 값으로 표현된다, &quot;true&quot;를 &quot;false&quot;로하고, 제 3 국, &quot;알 수없는&quot;, : 유형은 여러 가지 상태를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="112d712cbd3f4abfdabfc159cdc6a3584db95c15" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides three SQL commands to establish configuration defaults. The already-mentioned &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command provides a SQL-accessible means of changing global defaults; it is functionally equivalent to editing &lt;code&gt;postgresql.conf&lt;/code&gt;. In addition, there are two commands that allow setting of defaults on a per-database or per-role basis:</source>
          <target state="translated">PostgreSQL은 구성 기본값을 설정하기 위해 세 가지 SQL 명령을 제공합니다. 이미 언급 된 &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; 명령은 전역 기본값을 변경하는 SQL 액세스 가능 수단을 제공합니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 편집 기능과 동일합니다 . 또한 데이터베이스별로 또는 역할별로 기본값을 설정할 수있는 두 가지 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d071c1667c54c5d765a697ea20deb60db45601b3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</source>
          <target state="translated">PostgreSQL은 전체 텍스트 검색을 지원하도록 설계된 두 가지 데이터 유형을 제공합니다. 이는 자연어 모음을 통한 검색 활동입니다. &lt;em&gt; 문서&lt;/em&gt; 검색하여 &lt;em&gt;쿼리&lt;/em&gt; 와 가장 일치하는 것을 찾습니다 . &lt;code&gt;tsvector&lt;/code&gt; 의 유형은 텍스트 검색에 최적화 된 형태의 문서를 나타냅니다; &lt;code&gt;tsquery&lt;/code&gt; 의 유형은 유사하게 텍스트 쿼리를 나타냅니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장&lt;/a&gt; 에서는이 기능에 대한 자세한 설명을 제공하고 &lt;a href=&quot;functions-textsearch&quot;&gt;9.13 절&lt;/a&gt; 에는 관련 기능과 연산자가 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc076effaac188434f505c3be6fa39f626918c7e" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</source>
          <target state="translated">PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</target>
        </trans-unit>
        <trans-unit id="8d5de0e98d735e8c10c90f072b5e772ac6f8ca44" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two functions introduced in SQL:2006, but in variants that use the XPath 1.0 language, rather than XML Query as specified for them in the standard.</source>
          <target state="translated">PostgreSQL은 SQL : 2006에 도입 된 두 가지 기능을 제공하지만 표준에 지정된 XML 쿼리가 아닌 XPath 1.0 언어를 사용하는 변형으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6e29f8f292e01eb034e6335e7938f34ec555db8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides various lock modes to control concurrent access to data in tables. These modes can be used for application-controlled locking in situations where MVCC does not give the desired behavior. Also, most PostgreSQL commands automatically acquire locks of appropriate modes to ensure that referenced tables are not dropped or modified in incompatible ways while the command executes. (For example, &lt;code&gt;TRUNCATE&lt;/code&gt; cannot safely be executed concurrently with other operations on the same table, so it obtains an exclusive lock on the table to enforce that.)</source>
          <target state="translated">PostgreSQL은 다양한 잠금 모드를 제공하여 테이블의 데이터에 대한 동시 액세스를 제어합니다. 이 모드는 MVCC가 원하는 동작을 제공하지 않는 상황에서 응용 프로그램 제어 잠금에 사용될 수 있습니다. 또한 대부분의 PostgreSQL 명령은 자동으로 적절한 모드의 잠금을 획득하여 명령이 실행되는 동안 참조 된 테이블이 호환되지 않는 방식으로 삭제되거나 수정되지 않도록합니다. (예를 들어, &lt;code&gt;TRUNCATE&lt;/code&gt; 는 동일한 테이블에서 다른 작업과 동시에 안전하게 실행될 수 없으므로 테이블에 대한 독점 잠금을 획득하여이를 시행합니다.)</target>
        </trans-unit>
        <trans-unit id="a2a834b0e992b83325c457a9496be0432049ea8a" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides various methods for authenticating users:</source>
          <target state="translated">PostgreSQL provides various methods for authenticating users:</target>
        </trans-unit>
        <trans-unit id="aca67cd10f6b55fba07fefeab32464592e84bd50" translate="yes" xml:space="preserve">
          <source>PostgreSQL reads the system-wide OpenSSL configuration file. By default, this file is named &lt;code&gt;openssl.cnf&lt;/code&gt; and is located in the directory reported by &lt;code&gt;openssl version -d&lt;/code&gt;. This default can be overridden by setting environment variable &lt;code&gt;OPENSSL_CONF&lt;/code&gt; to the name of the desired configuration file.</source>
          <target state="translated">PostgreSQL은 시스템 전체 OpenSSL 구성 파일을 읽습니다. 기본적으로이 파일의 이름은 &lt;code&gt;openssl.cnf&lt;/code&gt; 이며 &lt;code&gt;openssl version -d&lt;/code&gt; 에 의해보고 된 디렉토리에 있습니다 . 환경 변수 &lt;code&gt;OPENSSL_CONF&lt;/code&gt; 를 원하는 구성 파일 이름 으로 설정 하여이 기본값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e141c534293f75601bff1fea667fc64a4f6c7d7" translate="yes" xml:space="preserve">
          <source>PostgreSQL recognizes functional dependency (allowing columns to be omitted from &lt;code&gt;GROUP BY&lt;/code&gt;) only when a table's primary key is included in the &lt;code&gt;GROUP BY&lt;/code&gt; list. The SQL standard specifies additional conditions that should be recognized.</source>
          <target state="translated">PostgreSQL 은 테이블의 기본 키가 &lt;code&gt;GROUP BY&lt;/code&gt; 목록에 포함 된 경우에만 기능 종속성 ( &lt;code&gt;GROUP BY&lt;/code&gt; 에서 열을 생략 할 수 있음)을 인식 합니다. SQL 표준은 인식해야 할 추가 조건을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d151da8167491478df86aef81ab6d8ffea35f9fb" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases before 7.4 used a different binary file format.</source>
          <target state="translated">7.4 이전의 PostgreSQL 릴리스는 다른 이진 파일 형식을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="b128f368f0a60d65746b559a252c4dc977c1b44f" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases prior to 8.1 would accept queries of this form, and add an implicit entry to the query's &lt;code&gt;FROM&lt;/code&gt; clause for each table referenced by the query. This is no longer allowed.</source>
          <target state="translated">8.1 이전의 PostgreSQL 릴리스는이 형식의 쿼리를 허용하고 쿼리에서 참조하는 각 테이블에 대한 쿼리의 &lt;code&gt;FROM&lt;/code&gt; 절에 암시 적 항목을 추가 합니다. 더 이상 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63fb6169ba8a1a0f974f4aea96b8b4aa6c3f1759" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires a few bytes of System V shared memory (typically 48 bytes, on 64-bit platforms) for each copy of the server. On most modern operating systems, this amount can easily be allocated. However, if you are running many copies of the server or you explicitly configure the server to use large amounts of System V shared memory (see &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_type&lt;/a&gt;), it may be necessary to increase &lt;code&gt;SHMALL&lt;/code&gt;, which is the total amount of System V shared memory system-wide. Note that &lt;code&gt;SHMALL&lt;/code&gt; is measured in pages rather than bytes on many systems.</source>
          <target state="translated">PostgreSQL에는 서버의 각 사본마다 몇 바이트의 System V 공유 메모리 (일반적으로 64 비트 플랫폼에서 48 바이트)가 필요합니다. 대부분의 최신 운영 체제에서이 양을 쉽게 할당 할 수 있습니다. 그러나 많은 서버 사본을 실행 중이거나 대량의 System V 공유 메모리를 사용하도록 서버를 명시 적으로 구성한 경우 ( &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_type&lt;/a&gt; 참조 ) &lt;code&gt;SHMALL&lt;/code&gt; 을 늘려야합니다. . 이는 총 System V 공유 량입니다. 시스템 전체 메모리. 참고 &lt;code&gt;SHMALL&lt;/code&gt; 가 많은 시스템의 페이지가 아닌 바이트 단위로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="c2c20c79653dcae8f8fc047710211c040521d5bc" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires the operating system to provide inter-process communication (IPC) features, specifically shared memory and semaphores. Unix-derived systems typically provide &amp;ldquo;System V&amp;rdquo; IPC, &amp;ldquo;POSIX&amp;rdquo; IPC, or both. Windows has its own implementation of these features and is not discussed here.</source>
          <target state="translated">PostgreSQL을 사용하려면 운영 체제에서 프로세스 간 통신 (IPC) 기능, 특히 공유 메모리 및 세마포어를 제공해야합니다. 유닉스 파생 시스템은 일반적으로 &quot;System V&quot;IPC, &quot;POSIX&quot;IPC 또는 둘 다를 제공합니다. Windows는 이러한 기능을 자체적으로 구현하므로 여기에서는 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36d337a94d7ba7a46b07377e19460ac78dd155d2" translate="yes" xml:space="preserve">
          <source>PostgreSQL streaming replication is asynchronous by default. If the primary server crashes then some transactions that were committed may not have been replicated to the standby server, causing data loss. The amount of data loss is proportional to the replication delay at the time of failover.</source>
          <target state="translated">PostgreSQL 스트리밍 복제는 기본적으로 비동기식입니다. 기본 서버가 충돌하면 커밋 된 일부 트랜잭션이 대기 서버로 복제되지 않아 데이터가 손실 될 수 있습니다. 데이터 손실량은 장애 조치시 복제 지연에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="7c42d1cce1b2b6028e2490c0570386d5f856bca2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports a powerful &lt;em&gt;rule system&lt;/em&gt; for the specification of &lt;em&gt;views&lt;/em&gt; and ambiguous &lt;em&gt;view updates&lt;/em&gt;. Originally the PostgreSQL rule system consisted of two implementations:</source>
          <target state="translated">PostgreSQL은 &lt;em&gt;뷰 지정&lt;/em&gt; 및 모호한 &lt;em&gt;뷰 업데이트를&lt;/em&gt; 위한 강력한 &lt;em&gt;규칙 시스템&lt;/em&gt; 을 지원 &lt;em&gt;합니다&lt;/em&gt; . 원래 PostgreSQL 규칙 시스템은 두 가지 구현으로 구성되었습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2241743d9fa8eb9bf19ded10e2bc6c68ceaf9df2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports automatic character set conversion between server and client for certain character set combinations. The conversion information is stored in the &lt;code&gt;pg_conversion&lt;/code&gt; system catalog. PostgreSQL comes with some predefined conversions, as shown in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt;. You can create a new conversion using the SQL command &lt;code&gt;CREATE CONVERSION&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL은 특정 문자 세트 조합에 대해 서버와 클라이언트 간의 자동 문자 세트 변환을 지원합니다. 변환 정보는 &lt;code&gt;pg_conversion&lt;/code&gt; 시스템 카탈로그에 저장됩니다 . PostgreSQL에는 &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;표 23.2&lt;/a&gt; 와 같이 미리 정의 된 변환이 포함되어 있습니다. SQL 명령 &lt;code&gt;CREATE CONVERSION&lt;/code&gt; 을 사용하여 새 변환을 작성할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="debb294ce8d55fb3d9baa6257891a19adad25190" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports automatic character set conversion between server and client for many combinations of character sets (&lt;a href=&quot;multibyte#MULTIBYTE-CONVERSIONS-SUPPORTED&quot;&gt;Section 23.3.4&lt;/a&gt; shows which ones).</source>
          <target state="translated">PostgreSQL supports automatic character set conversion between server and client for many combinations of character sets (&lt;a href=&quot;multibyte#MULTIBYTE-CONVERSIONS-SUPPORTED&quot;&gt;Section 23.3.4&lt;/a&gt; shows which ones).</target>
        </trans-unit>
        <trans-unit id="a7c3b9018391e76aa16042a998f014061b76d5bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports basic table partitioning. This section describes why and how to implement partitioning as part of your database design.</source>
          <target state="translated">PostgreSQL은 기본 테이블 파티셔닝을 지원합니다. 이 섹션에서는 데이터베이스 디자인의 일부로 파티셔닝을 구현하는 이유와 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1e97f638eb1274873aa3e4e622cb72d93b7b7f24" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports building indexes without locking out writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;CREATE INDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.</source>
          <target state="translated">PostgreSQL은 쓰기를 잠그지 않고 인덱스 작성을 지원합니다. 이 메소드는 &lt;code&gt;CREATE INDEX&lt;/code&gt; 의 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션을 지정하여 호출됩니다. . 이 옵션을 사용하면 PostgreSQL은 두 번의 테이블 스캔을 수행해야하며, 잠재적으로 인덱스를 수정하거나 사용하여 종료 할 수있는 모든 기존 트랜잭션을 대기해야합니다. 따라서이 방법은 표준 인덱스 빌드보다 더 많은 총 작업이 필요하며 완료하는 데 시간이 훨씬 오래 걸립니다. 그러나 인덱스가 작성되는 동안 정상적인 조작을 계속할 수 있으므로이 방법은 프로덕션 환경에서 새 인덱스를 추가하는 데 유용합니다. 물론, 인덱스 생성으로 인한 추가 CPU 및 I / O로드로 인해 다른 작업이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf603007c3689d71b489ed77c1b75a8fa44bed1c" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports parallel aggregation by aggregating in two stages. First, each process participating in the parallel portion of the query performs an aggregation step, producing a partial result for each group of which that process is aware. This is reflected in the plan as a &lt;code&gt;Partial Aggregate&lt;/code&gt; node. Second, the partial results are transferred to the leader via &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt;. Finally, the leader re-aggregates the results across all workers in order to produce the final result. This is reflected in the plan as a &lt;code&gt;Finalize Aggregate&lt;/code&gt; node.</source>
          <target state="translated">PostgreSQL은 두 단계로 집계하여 병렬 집계를 지원합니다. 먼저, 쿼리의 병렬 부분에 참여하는 각 프로세스는 집계 단계를 수행하여 해당 프로세스가 인식하는 각 그룹에 대한 부분 결과를 생성합니다. 이는 계획에 &lt;code&gt;Partial Aggregate&lt;/code&gt; 노드 로 반영됩니다 . 둘째, 부분 결과는 &lt;code&gt;Gather&lt;/code&gt; 또는 &lt;code&gt;Gather Merge&lt;/code&gt; 를 통해 리더로 전송됩니다 . 마지막으로, 리더는 최종 결과를 산출하기 위해 모든 작업자에 대해 결과를 다시 집계합니다. 이것은 &lt;code&gt;Finalize Aggregate&lt;/code&gt; 로 계획에 반영됩니다 노드 .</target>
        </trans-unit>
        <trans-unit id="98c96f2dead7b89b38c3c2461ff7cd5a4376ae6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports rebuilding indexes with minimum locking of writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;REINDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table for each index that needs to be rebuilt and wait for termination of all existing transactions that could potentially use the index. This method requires more total work than a standard index rebuild and takes significantly longer to complete as it needs to wait for unfinished transactions that might modify the index. However, since it allows normal operations to continue while the index is being rebuilt, this method is useful for rebuilding indexes in a production environment. Of course, the extra CPU, memory and I/O load imposed by the index rebuild may slow down other operations.</source>
          <target state="translated">PostgreSQL은 최소 쓰기 잠금으로 인덱스 재 구축을 지원합니다. 이 메소드는 &lt;code&gt;REINDEX&lt;/code&gt; 의 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 옵션을 지정하여 호출됩니다.. 이 옵션을 사용하면 PostgreSQL은 재 빌드해야하는 각 인덱스에 대해 테이블을 두 번 스캔하고 인덱스를 사용할 수있는 모든 기존 트랜잭션이 종료 될 때까지 기다려야합니다. 이 방법은 표준 인덱스 재 구축보다 더 많은 총 작업이 필요하며 인덱스를 수정할 수있는 완료되지 않은 트랜잭션을 기다려야하므로 완료하는 데 훨씬 오래 걸립니다. 그러나 인덱스를 다시 작성하는 동안 정상적인 작업을 계속할 수 있으므로이 방법은 프로덕션 환경에서 인덱스를 다시 작성하는 데 유용합니다. 물론 인덱스 재 구축으로 부과 된 추가 CPU, 메모리 및 I / O로드로 인해 다른 작업이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b659630282ce6fbd7aba80155fab2795874d42d4" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports row-level access, but &lt;code&gt;sepgsql&lt;/code&gt; does not.</source>
          <target state="translated">PostgreSQL은 행 수준 액세스를 지원하지만 &lt;code&gt;sepgsql&lt;/code&gt; 은 지원 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef19df889c26aff47b13a779090fcd37550d60bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several methods for logging server messages, including stderr, csvlog and syslog. On Windows, eventlog is also supported. Set this parameter to a list of desired log destinations separated by commas. The default is to log to stderr only. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">PostgreSQL은 stderr, csvlog 및 syslog를 포함하여 서버 메시지 로깅을위한 몇 가지 방법을 지원합니다. Windows에서는 eventlog도 지원됩니다. 이 매개 변수를 쉼표로 구분하여 원하는 로그 대상 목록으로 설정하십시오. 디폴트는 stderr에만 로그하는 것입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51899fa8eebb3b3aa74bb4a137479eee2fd66147" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several special date/time input values for convenience, as shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;Table 8.13&lt;/a&gt;. The values &lt;code&gt;infinity&lt;/code&gt; and &lt;code&gt;-infinity&lt;/code&gt; are specially represented inside the system and will be displayed unchanged; but the others are simply notational shorthands that will be converted to ordinary date/time values when read. (In particular, &lt;code&gt;now&lt;/code&gt; and related strings are converted to a specific time value as soon as they are read.) All of these values need to be enclosed in single quotes when used as constants in SQL commands.</source>
          <target state="translated">PostgreSQL은 편의상 몇 가지 특수 날짜 / 시간 입력 값을 지원합니다 ( &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;표 8.13 참조)&lt;/a&gt; . &lt;code&gt;infinity&lt;/code&gt; 와 &lt;code&gt;-infinity&lt;/code&gt; 무한대 값 은 시스템 내부에 특별히 표시되며 변경되지 않은 상태로 표시됩니다. 그러나 다른 것은 읽을 때 일반적인 날짜 / 시간 값으로 변환되는 표기법의 속기입니다. (특히, &lt;code&gt;now&lt;/code&gt; 및 관련 문자열은 읽 자마자 특정 시간 값으로 변환됩니다.) 이러한 모든 값은 SQL 명령에서 상수로 사용될 때 작은 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6c41dd3d36631eef9a60ad49bfd703137d3f4d8" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.5&lt;/a&gt; for more information).</source>
          <target state="translated">PostgreSQL은 &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;표 8.9에&lt;/a&gt; 나와있는 전체 SQL 날짜 및 시간 유형을 지원합니다 . 이러한 데이터 유형에서 사용 가능한 작업은 &lt;a href=&quot;functions-datetime&quot;&gt;섹션 9.9에&lt;/a&gt; 설명되어 있습니다. 날짜는 달력이 소개되기 몇 년 전에도 그레고리력에 따라 계산됩니다 (자세한 내용 &lt;a href=&quot;datetime-units-history&quot;&gt;은 B.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="20349ba6e468e9df9a098ab6e794e103ce905a08" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.6&lt;/a&gt; for more information).</source>
          <target state="translated">PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.6&lt;/a&gt; for more information).</target>
        </trans-unit>
        <trans-unit id="f14a3d6cb75702f32d5dc071e65c1dc41ad01772" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the standard SQL types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;char(N)&lt;/code&gt;, &lt;code&gt;varchar(N)&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt;, as well as other types of general utility and a rich set of geometric types. PostgreSQL can be customized with an arbitrary number of user-defined data types. Consequently, type names are not key words in the syntax, except where required to support special cases in the SQL standard.</source>
          <target state="translated">PostgreSQL은 표준 SQL 유형 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;real&lt;/code&gt; , &lt;code&gt;double precision&lt;/code&gt; , &lt;code&gt;char(N)&lt;/code&gt; , &lt;code&gt;varchar(N)&lt;/code&gt; , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt; 및 &lt;code&gt;interval&lt;/code&gt; 뿐만 아니라 다른 유형의 일반 유틸리티와 다양한 기하학적 유형을 지원합니다. PostgreSQL은 임의의 수의 사용자 정의 데이터 형식으로 사용자 정의 할 수 있습니다. 결과적으로 SQL 표준에서 특수한 경우를 지원하는 데 필요한 경우를 제외하고 형식 이름은 구문의 키워드가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0d51b565fec4c2b0e44f5a1d45ac9c129a9f5580" translate="yes" xml:space="preserve">
          <source>PostgreSQL treats the settings &lt;code&gt;origin&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; the same internally. Third-party replication systems may use these two values for their internal purposes, for example using &lt;code&gt;local&lt;/code&gt; to designate a session whose changes should not be replicated.</source>
          <target state="translated">PostgreSQL은 설정 &lt;code&gt;origin&lt;/code&gt; 과 &lt;code&gt;local&lt;/code&gt; 내부적으로 동일하게 취급합니다 . 타사 복제 시스템은 이러한 두 값을 내부 목적으로 사용할 수 있습니다 (예 : &lt;code&gt;local&lt;/code&gt; 을 사용하여 변경 사항을 복제하지 않아야하는 세션을 지정).</target>
        </trans-unit>
        <trans-unit id="749a4f6a11ea83f98676b6594e8c9efc963bc390" translate="yes" xml:space="preserve">
          <source>PostgreSQL type</source>
          <target state="translated">PostgreSQL 유형</target>
        </trans-unit>
        <trans-unit id="47a27d79e52ae2c7462f626790ad2829a449a676" translate="yes" xml:space="preserve">
          <source>PostgreSQL uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as TOAST (or &amp;ldquo;the best thing since sliced bread&amp;rdquo;). The TOAST infrastructure is also used to improve handling of large data values in-memory.</source>
          <target state="translated">PostgreSQL은 고정 페이지 크기 (일반적으로 8kB)를 사용하며 튜플이 여러 페이지에 걸쳐있는 것을 허용하지 않습니다. 따라서 매우 큰 필드 값을 직접 저장할 수 없습니다. 이 한계를 극복하기 위해, 큰 필드 값은 압축 및 / 또는 여러 개의 물리적 행으로 나뉩니다. 이것은 대부분의 백엔드 코드에 거의 영향을 미치지 않으면 서 사용자에게 투명하게 발생합니다. 이 기술은 TOAST (또는&amp;ldquo;얇게 썬 빵 이후 가장 좋은 것&amp;rdquo;)로 잘 알려져 있습니다. TOAST 인프라는 또한 메모리 내에서 큰 데이터 값 처리를 향상시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1529abe3421ea489100f9759672bf8f68aa03a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL version information. See also &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt; for a machine-readable version.</source>
          <target state="translated">PostgreSQL 버전 정보. 기계가 읽을 수있는 버전 은 &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79b79e94e250861d3a37b2b81991c08edde567f2" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.5 used slightly different operator precedence rules. In particular, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; used to be treated as generic operators; &lt;code&gt;IS&lt;/code&gt; tests used to have higher priority; and &lt;code&gt;NOT BETWEEN&lt;/code&gt; and related constructs acted inconsistently, being taken in some cases as having the precedence of &lt;code&gt;NOT&lt;/code&gt; rather than &lt;code&gt;BETWEEN&lt;/code&gt;. These rules were changed for better compliance with the SQL standard and to reduce confusion from inconsistent treatment of logically equivalent constructs. In most cases, these changes will result in no behavioral change, or perhaps in &amp;ldquo;no such operator&amp;rdquo; failures which can be resolved by adding parentheses. However there are corner cases in which a query might change behavior without any parsing error being reported. If you are concerned about whether these changes have silently broken something, you can test your application with the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warning&lt;/a&gt; turned on to see if any warnings are logged.</source>
          <target state="translated">9.5 이전의 PostgreSQL 버전은 약간 다른 연산자 우선 순위 규칙을 사용했습니다. 특히, &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; 과 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 일반 연산자로 처리하기 위해 사용; &lt;code&gt;IS&lt;/code&gt; 테스트는 우선 순위가 높았습니다. 및 &lt;code&gt;NOT BETWEEN&lt;/code&gt; 및 관련 구조는의 우선 순위 것으로 경우에 따라 취해지고, 일관성 행동 &lt;code&gt;NOT&lt;/code&gt; 보다는 &lt;code&gt;BETWEEN&lt;/code&gt; . 이러한 규칙은 SQL 표준을보다 잘 준수하고 논리적으로 동등한 구문의 일관성없는 처리로 인한 혼동을 줄이기 위해 변경되었습니다. 대부분의 경우 이러한 변경으로 인해 동작이 변경되지 않거나 괄호를 추가하여 해결할 수있는 &quot;이런 연산자 없음&quot;오류가 발생할 수 있습니다. 그러나 구문 분석 오류가보고되지 않고 쿼리가 동작을 변경할 수있는 경우가 있습니다. 이러한 변경 사항이 자동으로 손상되었는지 여부에 대해 우려되는 경우 구성 매개 변수 &lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warning을&lt;/a&gt; 설정하여 애플리케이션을 테스트하여 경고가 기록되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b12aba1a6149cc1a1cc6de75b2d9db3d7327f976" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan.</source>
          <target state="translated">9.6 이전의 PostgreSQL 버전은 정렬 및 제한에 대한 출력 표현식의 평가 타이밍에 대한 보증을 제공하지 않았습니다. 선택한 쿼리 계획의 형식에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a330d6e333f0e705b7dbdae815c080baf029fd11" translate="yes" xml:space="preserve">
          <source>PostgreSQL will accept &lt;code&gt;BY VALUE&lt;/code&gt; or &lt;code&gt;BY REF&lt;/code&gt; in an &lt;code&gt;XMLEXISTS&lt;/code&gt; or &lt;code&gt;XMLTABLE&lt;/code&gt; construct, but it ignores them. The &lt;code&gt;xml&lt;/code&gt; data type holds a character-string serialized representation, so there is no node identity to preserve, and passing is always effectively &lt;code&gt;BY VALUE&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL은 &lt;code&gt;XMLEXISTS&lt;/code&gt; 또는 &lt;code&gt;XMLTABLE&lt;/code&gt; 구문 에서 &lt;code&gt;BY VALUE&lt;/code&gt; 또는 &lt;code&gt;BY REF&lt;/code&gt; 를 허용 하지만 무시합니다. &lt;code&gt;xml&lt;/code&gt; 데이터 형식 때문에 보존 할 노드 ID가 없습니다, 및 전달은 항상 효율적이다, 문자 문자열 직렬화 표현을 보유하고 &lt;code&gt;BY VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46668d602303093fd5436b07b8510921686fe19b" translate="yes" xml:space="preserve">
          <source>PostgreSQL will allow superusers to create databases with &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding even when &lt;code&gt;LC_CTYPE&lt;/code&gt; is not &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt;. As noted above, &lt;code&gt;SQL_ASCII&lt;/code&gt; does not enforce that the data stored in the database has any particular encoding, and so this choice poses risks of locale-dependent misbehavior. Using this combination of settings is deprecated and may someday be forbidden altogether.</source>
          <target state="translated">PostgreSQL을 사용 하면 &lt;code&gt;LC_CTYPE&lt;/code&gt; 이 &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;POSIX&lt;/code&gt; 가 아닌 경우에도 수퍼 유저가 &lt;code&gt;SQL_ASCII&lt;/code&gt; 인코딩으로 데이터베이스를 작성할 수 있습니다 . 위에서 언급했듯이 &lt;code&gt;SQL_ASCII&lt;/code&gt; 는 데이터베이스에 저장된 데이터에 특정 인코딩이 적용되도록 강요하지 않으므로이 선택은 로케일 종속 오작동의 위험이 있습니다. 이 설정 조합 사용은 더 이상 사용되지 않으며 언젠가는 모두 금지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c3b94e027418ea1293e7cfc1afc35261ba39ee" translate="yes" xml:space="preserve">
          <source>PostgreSQL will apply this expansion behavior to any composite-valued expression, although as shown &lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;above&lt;/a&gt;, you need to write parentheses around the value that &lt;code&gt;.*&lt;/code&gt; is applied to whenever it's not a simple table name. For example, if &lt;code&gt;myfunc()&lt;/code&gt; is a function returning a composite type with columns &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then these two queries have the same result:</source>
          <target state="translated">PostgreSQL은이 확장 동작을 모든 복합 값 식에 적용하지만, &lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;위에&lt;/a&gt; 표시된 것처럼 간단한 테이블 이름이 아닐 때마다 &lt;code&gt;.*&lt;/code&gt; 가 적용되는 값을 괄호로 묶어야 합니다. 예를 들어, &lt;code&gt;myfunc()&lt;/code&gt; 가 열 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 가 있는 복합 유형을 반환하는 함수 인 경우이 두 쿼리의 결과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c89f6a3f1560a7bd4653723f3e72dbf1311168a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL will attempt to convert the column's default value (if any) to the new type, as well as any constraints that involve the column. But these conversions might fail, or might produce surprising results. It's often best to drop any constraints on the column before altering its type, and then add back suitably modified constraints afterwards.</source>
          <target state="translated">PostgreSQL은 열의 기본값 (있는 경우)을 새 유형으로 변환하고 열과 관련된 제약 조건을 시도합니다. 그러나 이러한 변환은 실패하거나 놀라운 결과를 생성 할 수 있습니다. 유형을 변경하기 전에 열에서 제한 조건을 삭제 한 다음 적절하게 수정 된 제한 조건을 나중에 다시 추가하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="23adfa969a97323ee3ec177a7dcb8f6884bb3a0c" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt; transaction semantics depend on being able to compare transaction ID (XID) numbers: a row version with an insertion XID greater than the current transaction's XID is &amp;ldquo;in the future&amp;rdquo; and should not be visible to the current transaction. But since transaction IDs have limited size (32 bits) a cluster that runs for a long time (more than 4 billion transactions) would suffer &lt;em&gt;transaction ID wraparound&lt;/em&gt;: the XID counter wraps around to zero, and all of a sudden transactions that were in the past appear to be in the future &amp;mdash; which means their output become invisible. In short, catastrophic data loss. (Actually the data is still there, but that's cold comfort if you cannot get at it.) To avoid this, it is necessary to vacuum every table in every database at least once every two billion transactions.</source>
          <target state="translated">PostgreSQL의 &lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt; 트랜잭션 시맨틱은 트랜잭션 ID (XID) 번호를 비교할 수 있는지에 달려 있습니다. 현재 트랜잭션의 XID보다 큰 삽입 XID를 가진 행 버전은&amp;ldquo;미래에 있으며&amp;rdquo;현재 트랜잭션에 표시되지 않아야합니다. 그러나 트랜잭션 ID의 크기 (32 비트)가 제한되어 있기 때문에 오랫동안 실행되는 클러스터 (40 억 건 이상의 트랜잭션)에서 &lt;em&gt;트랜잭션 ID가 줄어 듭니다.&lt;/em&gt;: XID 카운터가 0으로 줄 바꿈되고 과거에 있었던 모든 갑작스런 트랜잭션이 미래에있는 것처럼 보이므로 출력이 보이지 않습니다. 요컨대, 치명적인 데이터 손실. (실제로 데이터는 여전히 존재하지만 데이터를 얻을 수없는 경우 냉담합니다.)이를 피하려면 적어도 20 억 건의 트랜잭션마다 모든 데이터베이스의 모든 테이블을 진공 청소기로 청소해야합니다.</target>
        </trans-unit>
        <trans-unit id="d01ad7a96af1c4c37b0765a65b29de55d59ec177" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; command has to process each table on a regular basis for several reasons:</source>
          <target state="translated">PostgreSQL의 &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령은 몇 가지 이유로 각 테이블을 정기적으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d397eedb2e425cb61e6640819576e2ece268547" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;em&gt;statistics collector&lt;/em&gt; is a subsystem that supports collection and reporting of information about server activity. Presently, the collector can count accesses to tables and indexes in both disk-block and individual-row terms. It also tracks the total number of rows in each table, and information about vacuum and analyze actions for each table. It can also count calls to user-defined functions and the total time spent in each one.</source>
          <target state="translated">PostgreSQL의 &lt;em&gt;통계 수집기&lt;/em&gt; 는 서버 활동에 대한 정보 수집 및보고를 지원하는 하위 시스템입니다. 현재 콜렉터는 디스크 블록 및 개별 행 용어로 테이블 및 인덱스에 대한 액세스를 계산할 수 있습니다. 또한 각 테이블의 총 행 수와 각 테이블의 진공 및 분석 조치에 대한 정보도 추적합니다. 또한 사용자 정의 함수에 대한 호출 및 각 함수에 소요 된 총 시간을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa34938a4c0bdb7ddaed6ea9437aad3e7e7c20a7" translate="yes" xml:space="preserve">
          <source>PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt;, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</source>
          <target state="translated">PostgreSQL의 JIT 구현은 &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;internal&lt;/code&gt; 유형의 함수 본문 과 이러한 함수를 기반으로하는 연산자를 인라인 할 수 있습니다 . 확장 기능에 대해 그렇게하려면 해당 기능의 정의를 사용할 수 있어야합니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; 를 사용하여 LLVM JIT 지원으로 컴파일 된 서버에 대한 확장을 빌드하면 관련 파일이 자동으로 빌드되고 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="cbfface12059fe15d4ea1c0663b32afd132d460b" translate="yes" xml:space="preserve">
          <source>PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt;, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</source>
          <target state="translated">PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt; , as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</target>
        </trans-unit>
        <trans-unit id="b2ce9be22eb538937b290524f1a893fff9a3a342" translate="yes" xml:space="preserve">
          <source>PostgreSQL's foreign-data functionality is still under active development. Optimization of queries is primitive (and mostly left to the wrapper, too). Thus, there is considerable room for future performance improvements.</source>
          <target state="translated">PostgreSQL의 외부 데이터 기능은 아직 개발 중입니다. 쿼리 최적화는 기본적입니다 (대부분 래퍼에도 맡김). 따라서 향후 성능 향상을위한 상당한 여지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="045ba636eac8c350bd9d92d07f5b544b6d689ef6" translate="yes" xml:space="preserve">
          <source>PostgreSQL's implementation of SQL/JSON path language has the following deviations from the SQL/JSON standard:</source>
          <target state="translated">PostgreSQL의 SQL / JSON 경로 언어 구현은 SQL / JSON 표준과 다음과 같은 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="49d790f2e543677fa7af238d2ad2b0bee3041d87" translate="yes" xml:space="preserve">
          <source>PostgreSQL's implementation of the SQL/JSON path language has the following deviations from the SQL/JSON standard:</source>
          <target state="translated">PostgreSQL's implementation of the SQL/JSON path language has the following deviations from the SQL/JSON standard:</target>
        </trans-unit>
        <trans-unit id="b6512655ce0206ad2e55af59128437c19a85eef8" translate="yes" xml:space="preserve">
          <source>PostgreSQL's regular expressions are implemented using a software package written by Henry Spencer. Much of the description of regular expressions below is copied verbatim from his manual.</source>
          <target state="translated">PostgreSQL의 정규식은 Henry Spencer가 작성한 소프트웨어 패키지를 사용하여 구현됩니다. 아래 정규식에 대한 대부분의 설명은 그의 매뉴얼에서 그대로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="8b89dce84ea21263b16697e60b4c1b4c85d27493" translate="yes" xml:space="preserve">
          <source>PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL의 텍스트 검색 기능은 &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장&lt;/a&gt; 에서 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="e1d7207a8f75323c89ab9632a9dcc5793d725c97" translate="yes" xml:space="preserve">
          <source>PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="39f6a42a4fb0039de8b2fce0531aa5cf8bf17009" translate="yes" xml:space="preserve">
          <source>PostgreSQL-style typecast</source>
          <target state="translated">PostgreSQL 스타일의 캐스트</target>
        </trans-unit>
        <trans-unit id="ee3a796a1951d3ab475d28807f6598608b0104af" translate="yes" xml:space="preserve">
          <source>Postmaster (process)</source>
          <target state="translated">Postmaster (process)</target>
        </trans-unit>
        <trans-unit id="19b427c5cf5eb995bfcd7725e3fbf7217d1adcbd" translate="yes" xml:space="preserve">
          <source>Poul-Henning Kamp</source>
          <target state="translated">폴 헤닝 캄프</target>
        </trans-unit>
        <trans-unit id="17ae45bd355f880cc7401f24ea563dca0df2e7d4" translate="yes" xml:space="preserve">
          <source>Pre-loaded catalog rows must have preassigned OIDs if there are OID references to them in other pre-loaded rows. A preassigned OID is also needed if the row's OID must be referenced from C code. If neither case applies, the &lt;code&gt;oid&lt;/code&gt; metadata field can be omitted, in which case the bootstrap code assigns an OID automatically. In practice we usually preassign OIDs for all or none of the pre-loaded rows in a given catalog, even if only some of them are actually cross-referenced.</source>
          <target state="translated">사전로드 된 다른 행에 OID 참조가 있으면 사전로드 된 카탈로그 행에 사전 지정된 OID가 있어야합니다. C 코드에서 행의 OID를 참조해야하는 경우 사전 할당 된 OID도 필요합니다. 두 경우 모두 적용되지 않으면 &lt;code&gt;oid&lt;/code&gt; 메타 데이터 필드를 생략 할 수 있습니다.이 경우 부트 스트랩 코드는 OID를 자동으로 할당합니다. 실제로 우리는 일반적으로 주어진 카탈로그에 사전로드 된 행의 일부 또는 전부에 대해 OID를 사전에 할당합니다. 일부는 실제로 상호 참조 된 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3509ce167d8714af0e6b496635d49ac549f353e8" translate="yes" xml:space="preserve">
          <source>Pre-packaged versions of PostgreSQL will typically create a suitable user account automatically during package installation.</source>
          <target state="translated">Pre-packaged versions of PostgreSQL will typically create a suitable user account automatically during package installation.</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="24fe09a1cf90d17df4307cd57797792c845342fc" translate="yes" xml:space="preserve">
          <source>Predicate locks in PostgreSQL, like in most other database systems, are based on data actually accessed by a transaction. These will show up in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view with a &lt;code&gt;mode&lt;/code&gt; of &lt;code&gt;SIReadLock&lt;/code&gt;. The particular locks acquired during execution of a query will depend on the plan used by the query, and multiple finer-grained locks (e.g., tuple locks) may be combined into fewer coarser-grained locks (e.g., page locks) during the course of the transaction to prevent exhaustion of the memory used to track the locks. A &lt;code&gt;READ ONLY&lt;/code&gt; transaction may be able to release its SIRead locks before completion, if it detects that no conflicts can still occur which could lead to a serialization anomaly. In fact, &lt;code&gt;READ ONLY&lt;/code&gt; transactions will often be able to establish that fact at startup and avoid taking any predicate locks. If you explicitly request a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction, it will block until it can establish this fact. (This is the &lt;em&gt;only&lt;/em&gt; case where Serializable transactions block but Repeatable Read transactions don't.) On the other hand, SIRead locks often need to be kept past transaction commit, until overlapping read write transactions complete.</source>
          <target state="translated">대부분의 다른 데이터베이스 시스템과 마찬가지로 PostgreSQL의 술어 잠금은 트랜잭션이 실제로 액세스하는 데이터를 기반으로합니다. 이것들은 &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; &lt;code&gt;mode&lt;/code&gt; 로 &lt;code&gt;SIReadLock&lt;/code&gt; 시스템 뷰 에 나타납니다 . 쿼리를 실행하는 동안 획득 한 특정 잠금은 쿼리에서 사용하는 계획에 따라 달라지며 여러 미세한 잠금 (예 : 튜플 잠금)은 더 적은 세밀한 잠금 (예 : 페이지 잠금)으로 결합 될 수 있습니다. 잠금을 추적하는 데 사용되는 메모리가 소진되지 않도록하는 트랜잭션. &lt;code&gt;READ ONLY&lt;/code&gt; 트랜잭션이 충돌은 여전히 이상 직렬화로 이어질 수있는 발생하지 않도록 감지 한 경우, 완료 전에 SIRead 잠금을 해제 할 수 있습니다. 실제로, &lt;code&gt;READ ONLY&lt;/code&gt; 트랜잭션은 종종 시작시 해당 사실을 확립하고 술어 잠금을 피할 수 있습니다. &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; 트랜잭션 을 명시 적으로 요청하면 이 사실을 설정할 수있을 때까지 차단됩니다. (이것은 직렬화 가능한 트랜잭션은 차단하지만 반복 가능한 읽기 트랜잭션은 그렇지 않은 &lt;em&gt;유일한&lt;/em&gt; 경우입니다.) 반면에 읽기 쓰기 트랜잭션이 겹칠 때까지 SIRead 잠금은 트랜잭션 커밋 이후에 유지되어야하는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="8515d3fdb655d3e82744bca30feb482862c14535" translate="yes" xml:space="preserve">
          <source>Predicate/Value</source>
          <target state="translated">Predicate/Value</target>
        </trans-unit>
        <trans-unit id="7a2a4f6fed53f092f075c647902092f49dff565c" translate="yes" xml:space="preserve">
          <source>Prepare all statements before using them. Libecpg will keep a cache of prepared statements and reuse a statement if it gets executed again. If the cache runs full, libecpg will free the least used statement.</source>
          <target state="translated">사용하기 전에 모든 진술을 준비하십시오. Libecpg는 준비된 명령문의 캐시를 유지하고 명령문이 다시 실행될 경우 재사용합니다. 캐시가 가득 차면 libecpg는 가장 적게 사용 된 명령문을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="805b0426cd8c493c6395add1e59cb6d57cc782f6" translate="yes" xml:space="preserve">
          <source>Prepare for an index scan. The &lt;code&gt;nkeys&lt;/code&gt; and &lt;code&gt;norderbys&lt;/code&gt; parameters indicate the number of quals and ordering operators that will be used in the scan; these may be useful for space allocation purposes. Note that the actual values of the scan keys aren't provided yet. The result must be a palloc'd struct. For implementation reasons the index access method &lt;em&gt;must&lt;/em&gt; create this struct by calling &lt;code&gt;RelationGetIndexScan()&lt;/code&gt;. In most cases &lt;code&gt;ambeginscan&lt;/code&gt; does little beyond making that call and perhaps acquiring locks; the interesting parts of index-scan startup are in &lt;code&gt;amrescan&lt;/code&gt;.</source>
          <target state="translated">인덱스 스캔을 준비하십시오. &lt;code&gt;nkeys&lt;/code&gt; 및 &lt;code&gt;norderbys&lt;/code&gt; 매개 변수 quals 스캔에 사용되는 순서 사업자의 수를 나타냅니다; 이들은 공간 할당 목적에 유용 할 수 있습니다. 스캔 키의 실제 값은 아직 제공되지 않았습니다. 결과는 palloc'd 구조체 여야합니다. 구현상의 이유로 인덱스 액세스 메소드 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;RelationGetIndexScan()&lt;/code&gt; 을 호출하여이 구조체를 작성 &lt;em&gt;해야합니다&lt;/em&gt; . 대부분의 경우 &lt;code&gt;ambeginscan&lt;/code&gt; 은 전화를 걸거나 잠금을 획득하는 것 이상을 수행하지 않습니다. 인덱스 스캔 시작의 흥미로운 부분은 &lt;code&gt;amrescan&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1badb6123149d2dd80187b1001e17317e0376a45" translate="yes" xml:space="preserve">
          <source>Prepare for performing on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">온라인 백업 수행 준비 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음)</target>
        </trans-unit>
        <trans-unit id="ea6420d9e6ea0b317eaaff702554d4ab07b95961" translate="yes" xml:space="preserve">
          <source>Prepare the current transaction for two-phase commit, using &lt;code&gt;foobar&lt;/code&gt; as the transaction identifier:</source>
          <target state="translated">&lt;code&gt;foobar&lt;/code&gt; 를 트랜잭션 식별자로 사용하여 2 단계 커밋에 대한 현재 트랜잭션을 준비하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eccdbb667192934bc79ff3dadac066bfd3213f5" translate="yes" xml:space="preserve">
          <source>Prepared statements (either explicitly prepared or implicitly generated, for example by PL/pgSQL) can be executed using custom or generic plans. Custom plans are made afresh for each execution using its specific set of parameter values, while generic plans do not rely on the parameter values and can be re-used across executions. Thus, use of a generic plan saves planning time, but if the ideal plan depends strongly on the parameter values then a generic plan may be inefficient. The choice between these options is normally made automatically, but it can be overridden with &lt;code&gt;plan_cache_mode&lt;/code&gt;. The allowed values are &lt;code&gt;auto&lt;/code&gt; (the default), &lt;code&gt;force_custom_plan&lt;/code&gt; and &lt;code&gt;force_generic_plan&lt;/code&gt;. This setting is considered when a cached plan is to be executed, not when it is prepared. For more information see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">준비된 명령문 (예 : PL / pgSQL에 의해 명시 적으로 준비되거나 내재적으로 생성 된)은 사용자 정의 또는 일반 계획을 사용하여 실행할 수 있습니다. 일반 계획은 매개 변수 값에 의존하지 않고 여러 실행에서 재사용 할 수있는 반면, 사용자 정의 계획은 특정 매개 변수 값 세트를 사용하여 각 실행에 대해 새로 작성됩니다. 따라서 일반 계획을 사용하면 계획 시간이 절약되지만 이상적인 계획이 매개 변수 값에 크게 의존하는 경우 일반 계획이 비효율적 일 수 있습니다. 이러한 옵션 중에서 선택하는 것은 일반적으로 자동으로 이루어 &lt;code&gt;plan_cache_mode&lt;/code&gt; 로 대체 할 수 있습니다 . 허용되는 값은 &lt;code&gt;auto&lt;/code&gt; (기본값), &lt;code&gt;force_custom_plan&lt;/code&gt; 및 &lt;code&gt;force_generic_plan&lt;/code&gt; 입니다.. 이 설정은 캐시 된 계획이 준비 될 때가 아니라 실행될 때 고려됩니다. 자세한 정보는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d2d9ca4ec55b877233447dcb48943c2ef02e7aa" translate="yes" xml:space="preserve">
          <source>Prepared statements can take parameters: values that are substituted into the statement when it is executed. When creating the prepared statement, refer to parameters by position, using &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. A corresponding list of parameter data types can optionally be specified. When a parameter's data type is not specified or is declared as &lt;code&gt;unknown&lt;/code&gt;, the type is inferred from the context in which the parameter is first referenced (if possible). When executing the statement, specify the actual values for these parameters in the &lt;code&gt;EXECUTE&lt;/code&gt; statement. Refer to &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; for more information about that.</source>
          <target state="translated">준비된 명령문은 매개 변수 : 명령문이 실행될 때 명령문으로 대체되는 값을 취할 수 있습니다. 준비된 명령문을 작성할 때 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등을 사용하여 위치별로 매개 변수를 참조하십시오 . 해당 매개 변수 데이터 유형 목록을 선택적으로 지정할 수 있습니다. 매개 변수의 데이터 유형이 지정되지 않았거나 &lt;code&gt;unknown&lt;/code&gt; 으로 선언 된 경우, 유형이 매개 변수가 처음 참조되는 컨텍스트 (가능한 경우)에서 유추됩니다. 명령문을 실행할 때 &lt;code&gt;EXECUTE&lt;/code&gt; 문 에서 이러한 매개 변수의 실제 값을 지정하십시오 . 이에 대한 자세한 정보는 &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23037ec79dcb923a75cebd6186549d643c581e91" translate="yes" xml:space="preserve">
          <source>Prepared statements only last for the duration of the current database session. When the session ends, the prepared statement is forgotten, so it must be recreated before being used again. This also means that a single prepared statement cannot be used by multiple simultaneous database clients; however, each client can create their own prepared statement to use. Prepared statements can be manually cleaned up using the &lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt; command.</source>
          <target state="translated">준비된 명령문은 현재 데이터베이스 세션 기간 동안 만 지속됩니다. 세션이 종료되면 준비된 명령문을 잊어 버리므로 다시 사용하기 전에 다시 작성해야합니다. 이는 또한 여러 개의 동시 데이터베이스 클라이언트가 단일 준비 명령문을 사용할 수 없음을 의미합니다. 그러나 각 클라이언트는 사용할 준비된 명령문을 작성할 수 있습니다. 준비된 명령문은 &lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt; 명령을 사용하여 수동으로 정리할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a483a03c91ae871a21f8ef97015a97d796c2feb5" translate="yes" xml:space="preserve">
          <source>Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g. if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</source>
          <target state="translated">준비된 명령문은 단일 세션을 사용하여 많은 수의 유사한 명령문을 실행할 때 잠재적으로 가장 큰 성능 이점을 갖습니다. 쿼리가 많은 테이블을 조인하거나 여러 규칙을 적용해야하는 경우와 같이 문을 계획하거나 다시 작성하기가 복잡한 경우 성능 차이가 특히 중요합니다. 명령문이 계획 및 재 작성이 상대적으로 단순하지만 실행 비용이 비교적 높은 경우 준비된 명령문의 성능 이점은 눈에 띄지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a94a7cd86cc26d07584643894920d2ea393b742" translate="yes" xml:space="preserve">
          <source>Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g., if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</source>
          <target state="translated">Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g., if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</target>
        </trans-unit>
        <trans-unit id="753ab9dddcfb8d57e3e410ee3c11bd1e55a46a27" translate="yes" xml:space="preserve">
          <source>Prepares the server to begin an on-line backup. The only required parameter is an arbitrary user-defined label for the backup. (Typically this would be the name under which the backup dump file will be stored.) If the optional second parameter is given as &lt;code&gt;true&lt;/code&gt;, it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries. The optional third parameter specifies whether to perform an exclusive or non-exclusive backup (default is exclusive).</source>
          <target state="translated">Prepares the server to begin an on-line backup. The only required parameter is an arbitrary user-defined label for the backup. (Typically this would be the name under which the backup dump file will be stored.) If the optional second parameter is given as &lt;code&gt;true&lt;/code&gt; , it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries. The optional third parameter specifies whether to perform an exclusive or non-exclusive backup (default is exclusive).</target>
        </trans-unit>
        <trans-unit id="09d9df46eddb7f24ca7fe8fbfe8e2dbda8bfc576" translate="yes" xml:space="preserve">
          <source>Prepends an element to the beginning of an array (same as the &lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt; operator).</source>
          <target state="translated">Prepends an element to the beginning of an array (same as the &lt;code&gt;anyelement&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;anyarray&lt;/code&gt; operator).</target>
        </trans-unit>
        <trans-unit id="16e489d5458780c56ecec5255859ffa473005ad5" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;COPY TO&lt;/code&gt; will never emit an octal or hex-digits backslash sequence, but it does use the other sequences listed above for those control characters.</source>
          <target state="translated">현재 &lt;code&gt;COPY TO&lt;/code&gt; 는 8 진수 또는 16 진수 백 슬래시 시퀀스를 방출하지 않지만 해당 제어 문자에 대해 위에 나열된 다른 시퀀스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aa75b2cb1f42b5b78ef47e3bac6d7cbc20568a8c" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;ON SELECT&lt;/code&gt; rules must be unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules and must have actions that consist of a single &lt;code&gt;SELECT&lt;/code&gt; command. Thus, an &lt;code&gt;ON SELECT&lt;/code&gt; rule effectively turns the table into a view, whose visible contents are the rows returned by the rule's &lt;code&gt;SELECT&lt;/code&gt; command rather than whatever had been stored in the table (if anything). It is considered better style to write a &lt;code&gt;CREATE VIEW&lt;/code&gt; command than to create a real table and define an &lt;code&gt;ON SELECT&lt;/code&gt; rule for it.</source>
          <target state="translated">현재 &lt;code&gt;ON SELECT&lt;/code&gt; 규칙은 무조건 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙이어야하며 단일 &lt;code&gt;SELECT&lt;/code&gt; 명령으로 구성된 작업이 있어야합니다 . 따라서 &lt;code&gt;ON SELECT&lt;/code&gt; 규칙은 효과적으로 테이블을 뷰로 변환합니다.이 뷰의 내용은 테이블에 저장된 것이 아니라 규칙의 &lt;code&gt;SELECT&lt;/code&gt; 명령에 의해 반환되는 행 입니다. 실제 테이블을 작성하고 &lt;code&gt;ON SELECT&lt;/code&gt; 규칙을 정의하는 것보다 &lt;code&gt;CREATE VIEW&lt;/code&gt; 명령 을 작성하는 것이 더 좋은 스타일로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="52172a45fa35ea47ee37481a7598605f94332941" translate="yes" xml:space="preserve">
          <source>Presently, all data values in a binary-format file are assumed to be in binary format (format code one). It is anticipated that a future extension might add a header field that allows per-column format codes to be specified.</source>
          <target state="translated">현재, 이진 형식 파일의 모든 데이터 값은 이진 형식 (포맷 코드 1) 인 것으로 가정합니다. 향후 확장 프로그램에서는 열별 형식 코드를 지정할 수있는 헤더 필드를 추가 할 수있을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="07a55fa2dfc20be04c1afe40194156f4b790bc71" translate="yes" xml:space="preserve">
          <source>Presently, if a rule action contains a &lt;code&gt;NOTIFY&lt;/code&gt; command, the &lt;code&gt;NOTIFY&lt;/code&gt; command will be executed unconditionally, that is, the &lt;code&gt;NOTIFY&lt;/code&gt; will be issued even if there are not any rows that the rule should apply to. For example, in:</source>
          <target state="translated">현재 규칙 조치에 &lt;code&gt;NOTIFY&lt;/code&gt; 명령이 포함되어 있으면 &lt;code&gt;NOTIFY&lt;/code&gt; 명령이 무조건 실행 됩니다. 즉, 규칙에 적용해야하는 행이 없어도 &lt;code&gt;NOTIFY&lt;/code&gt; 가 발행됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70f8a5644dc2d0fd28dd5618b027e4363107a89a" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt; or, preferably, run pg_restore as a PostgreSQL superuser.</source>
          <target state="translated">현재 &lt;code&gt;--disable-triggers&lt;/code&gt; 에 대해 생성 된 명령 은 수퍼 유저로 수행해야합니다. 따라서 &lt;code&gt;-S&lt;/code&gt; 를 사용하여 수퍼 유저 이름을 지정 하거나 PostgreSQL 수퍼 유저로 pg_restore를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="48866779c6574ae0eb32e070be6be5c56e3ca440" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So, you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt;, or preferably be careful to start the resulting script as a superuser.</source>
          <target state="translated">현재 &lt;code&gt;--disable-triggers&lt;/code&gt; 에 대해 생성 된 명령 은 수퍼 유저로 수행해야합니다. 따라서 &lt;code&gt;-S&lt;/code&gt; 로 수퍼 유저 이름을 지정 하거나 결과 스크립트를 수퍼 유저로 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="334d01d9c8e3bbf43f71d7eda4f0774b3bc44f64" translate="yes" xml:space="preserve">
          <source>Preset Options</source>
          <target state="translated">사전 설정 옵션</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="ee7bdb0dff39839c1fd827f5826a7bfd60c2d7e2" translate="yes" xml:space="preserve">
          <source>Prevent dumping of access privileges (grant/revoke commands).</source>
          <target state="translated">액세스 권한 덤프 방지 (grant / revoke 명령)</target>
        </trans-unit>
        <trans-unit id="a0771736ef9369c38d7919dcb8f69f80ef4855cc" translate="yes" xml:space="preserve">
          <source>Prevent restoration of access privileges (grant/revoke commands).</source>
          <target state="translated">액세스 권한의 복원을 방지합니다 (grant / revoke 명령).</target>
        </trans-unit>
        <trans-unit id="233b752a1d979d1b03bfc00189d385eb81deac5c" translate="yes" xml:space="preserve">
          <source>Preventing Server Spoofing</source>
          <target state="translated">서버 스푸핑 방지</target>
        </trans-unit>
        <trans-unit id="1a94269e22003d091ed6391f5e761e1543872045" translate="yes" xml:space="preserve">
          <source>Prevents issuing a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">Prevents issuing a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</target>
        </trans-unit>
        <trans-unit id="e8bdc61ee10f118e8dbdacdf82251ed8db7cccd4" translate="yes" xml:space="preserve">
          <source>Prevents the creation of a temporary replication slot for the backup.</source>
          <target state="translated">Prevents the creation of a temporary replication slot for the backup.</target>
        </trans-unit>
        <trans-unit id="2b615ec81ab4e47bd0f90f57d3f7154275428abd" translate="yes" xml:space="preserve">
          <source>Prevents the server from estimating the total amount of backup data that will be streamed, resulting in the &lt;code&gt;backup_total&lt;/code&gt; column in the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view always being &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Prevents the server from estimating the total amount of backup data that will be streamed, resulting in the &lt;code&gt;backup_total&lt;/code&gt; column in the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view always being &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b97befde20e55eaecab9bab9cc63c02e247c4a9f" translate="yes" xml:space="preserve">
          <source>Previous releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:</source>
          <target state="translated">이전 릴리스에서는 이후 저장 점으로 업그레이드 된 잠금을 유지하지 못했습니다. 예를 들어이 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ed4a0fe2451468df117ba30c37470ca22149ca7" translate="yes" xml:space="preserve">
          <source>Primary (server)</source>
          <target state="translated">Primary (server)</target>
        </trans-unit>
        <trans-unit id="f4bbf8103efddb82c7e4b9fff8c530d57422a504" translate="yes" xml:space="preserve">
          <source>Primary key</source>
          <target state="translated">Primary key</target>
        </trans-unit>
        <trans-unit id="5e203068f90ee842092a40f00034de5e2bf0c940" translate="yes" xml:space="preserve">
          <source>Primary keys are useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.</source>
          <target state="translated">기본 키는 설명서 및 클라이언트 응용 프로그램 모두에 유용합니다. 예를 들어 행 값을 수정할 수있는 GUI 응용 프로그램은 행을 고유하게 식별 할 수 있도록 테이블의 기본 키를 알아야합니다. 데이터베이스 시스템이 기본 키가 선언 된 경우 기본 키를 사용하는 다양한 방법도 있습니다. 예를 들어 기본 키는 해당 테이블을 참조하는 외래 키의 기본 대상 열을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="302096a883e851361a7c65e770ac4a2f93b77640" translate="yes" xml:space="preserve">
          <source>Primary keys can span more than one column; the syntax is similar to unique constraints:</source>
          <target state="translated">기본 키는 둘 이상의 열에 걸쳐있을 수 있습니다. 구문은 고유 제한 조건과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="54c622f5b5e8c75c7d4757c68339aa2e8b25f7fc" translate="yes" xml:space="preserve">
          <source>Primary log file name, or log in the requested format, currently in use by the logging collector</source>
          <target state="translated">기본적으로 로그 수집기에서 사용중인 기본 로그 파일 이름 또는 요청 된 형식으로 로그인</target>
        </trans-unit>
        <trans-unit id="4a03aad5c247b986acad6d97b6927c2a6ffb1095" translate="yes" xml:space="preserve">
          <source>Primitive JSON values are compared using the same comparison rules as for the underlying PostgreSQL data type. Strings are compared using the default database collation.</source>
          <target state="translated">기본 JSON 값은 기본 PostgreSQL 데이터 유형과 동일한 비교 규칙을 사용하여 비교됩니다. 문자열은 기본 데이터베이스 데이터 정렬을 사용하여 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="9f9dd23572b66164559cf3545fb93e79c89e5d8a" translate="yes" xml:space="preserve">
          <source>Principal used to authenticate this connection, or NULL if GSSAPI was not used to authenticate this connection. This field is truncated if the principal is longer than &lt;code&gt;NAMEDATALEN&lt;/code&gt; (64 characters in a standard build).</source>
          <target state="translated">Principal은이 연결을 인증하는 데 사용되거나 GSSAPI가이 연결을 인증하는 데 사용되지 않은 경우 NULL입니다. 주체가 &lt;code&gt;NAMEDATALEN&lt;/code&gt; (표준 빌드에서 64 자) 보다 길면 이 필드가 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="a7e7318f55e0c844d9e1050c000b470ae6a8596e" translate="yes" xml:space="preserve">
          <source>Print additional information including the version and the &quot;include&quot; path.</source>
          <target state="translated">버전 및 &quot;포함&quot;경로를 포함한 추가 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="e8de0f5082ac6065288eac684400de412407c144" translate="yes" xml:space="preserve">
          <source>Print all nonempty input lines to standard output as they are read. (This does not apply to lines read interactively.) This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">비어 있지 않은 모든 입력 라인을 읽을 때 표준 출력으로 인쇄하십시오. (대화식으로 읽은 행에는 적용되지 않습니다.) 변수 &lt;code&gt;ECHO&lt;/code&gt; 를 &lt;code&gt;all&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ebb9a1e5bbdb1243d5e4a31dff31eebe9fc06f03" translate="yes" xml:space="preserve">
          <source>Print debugging output from the bootstrap backend and a few other messages of lesser interest for the general public. The bootstrap backend is the program &lt;code&gt;initdb&lt;/code&gt; uses to create the catalog tables. This option generates a tremendous amount of extremely boring output.</source>
          <target state="translated">부트 스트랩 백엔드에서 디버깅 출력을 인쇄하고 일반 대중에게는 관심이 적은 몇 가지 다른 메시지를 인쇄하십시오. 부트 스트랩 백엔드는 &lt;code&gt;initdb&lt;/code&gt; 가 카탈로그 테이블을 작성하는 데 사용 하는 프로그램 입니다. 이 옵션은 엄청난 양의 지루한 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a7c370355f00f0bd758a9808623b790c218141fd" translate="yes" xml:space="preserve">
          <source>Print debugging output.</source>
          <target state="translated">디버깅 출력을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f0d63d35347e807b3cd5630fcccfcb97aefdff03" translate="yes" xml:space="preserve">
          <source>Print detailed information during processing.</source>
          <target state="translated">처리하는 동안 자세한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c073dbd6b543c579fb650eb5ea8d11e57c402573" translate="yes" xml:space="preserve">
          <source>Print failed SQL commands to standard error output. This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;errors&lt;/code&gt;.</source>
          <target state="translated">실패한 SQL 명령을 표준 오류 출력으로 인쇄하십시오. 이는 &lt;code&gt;ECHO&lt;/code&gt; 변수 를 &lt;code&gt;errors&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="597bb464eafa276a5ad0cc91e76eaf6190c85748" translate="yes" xml:space="preserve">
          <source>Print lots of debug logging output on &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; 에 많은 디버그 로깅 출력을 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="a75f64b677ea04810bae39f5467bba0bd440ec28" translate="yes" xml:space="preserve">
          <source>Print only errors, no informational messages.</source>
          <target state="translated">정보 메시지가없는 오류 만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="4f01f9df20b27d4321c4eb47d64e1ce581df8c21" translate="yes" xml:space="preserve">
          <source>Print psql's command line history to &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is omitted, the history is written to the standard output (using the pager if appropriate). This command is not available if psql was built without Readline support.</source>
          <target state="translated">psql의 명령 행 히스토리를 &lt;code&gt;filename&lt;/code&gt; 으로 인쇄하십시오 . 경우 &lt;code&gt;filename&lt;/code&gt; 생략되면, 이력 (호출기 적절한 경우 사용) 표준 출력에 기록된다. psql이 Readline 지원없이 빌드 된 경우이 명령을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="827ff74717cfd2b965ff32b6c6548085dff68335" translate="yes" xml:space="preserve">
          <source>Print the clusterdb version and exit.</source>
          <target state="translated">clusterdb 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f6d64dc0309d9d3b50923addc35c2349b3a13866" translate="yes" xml:space="preserve">
          <source>Print the createdb version and exit.</source>
          <target state="translated">createdb 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f9c1069309fb6fad15e176f641cc5f92410a215f" translate="yes" xml:space="preserve">
          <source>Print the createuser version and exit.</source>
          <target state="translated">createuser 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="6ca986b09253f90ac05485c4d1b53fd88df68efc" translate="yes" xml:space="preserve">
          <source>Print the current query buffer to the standard output. If the current query buffer is empty, the most recently executed query is printed instead.</source>
          <target state="translated">현재 쿼리 버퍼를 표준 출력으로 인쇄하십시오. 현재 쿼리 버퍼가 비어 있으면 가장 최근에 실행 된 쿼리가 대신 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1947bab167f53773caffcdb3abd24d61e23f4340" translate="yes" xml:space="preserve">
          <source>Print the dropdb version and exit.</source>
          <target state="translated">dropdb 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="c27b83ad0e23795e57b1563b077c538c9ab60bb3" translate="yes" xml:space="preserve">
          <source>Print the dropuser version and exit.</source>
          <target state="translated">드롭 유저 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e9eeca2b3e3f27d8960033787d850e4053105026" translate="yes" xml:space="preserve">
          <source>Print the ecpg version and exit.</source>
          <target state="translated">ecpg 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="657af6d675a70187bdfd892abd1e767e65979526" translate="yes" xml:space="preserve">
          <source>Print the initdb version and exit.</source>
          <target state="translated">initdb 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="a31c7045982c28354a2311d649532f2714d0cd52" translate="yes" xml:space="preserve">
          <source>Print the location of C header files for server programming.</source>
          <target state="translated">서버 프로그래밍을 위해 C 헤더 파일의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c7399f9aea54b81806345b5fe9d88c09f2b217c4" translate="yes" xml:space="preserve">
          <source>Print the location of C header files of the client interfaces.</source>
          <target state="translated">클라이언트 인터페이스의 C 헤더 파일 위치를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="595d5d7d00e3b9031bcf9b394461136007040d8b" translate="yes" xml:space="preserve">
          <source>Print the location of HTML documentation files.</source>
          <target state="translated">HTML 문서 파일의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="2c45a54aeef843a3b47abadef8be23a9c8c5faa3" translate="yes" xml:space="preserve">
          <source>Print the location of architecture-independent support files.</source>
          <target state="translated">아키텍처 독립적 지원 파일의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="6938b263f35a6474ff201cc4e757d0f937313671" translate="yes" xml:space="preserve">
          <source>Print the location of documentation files.</source>
          <target state="translated">문서 파일의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="38bf4c616b7c56d3f58464d10d1a64af7f6e8779" translate="yes" xml:space="preserve">
          <source>Print the location of dynamically loadable modules, or where the server would search for them. (Other architecture-dependent data files might also be installed in this directory.)</source>
          <target state="translated">동적으로로드 가능한 모듈의 위치 또는 서버가 검색 할 위치를 인쇄하십시오. 다른 아키텍처 종속 데이터 파일도이 디렉토리에 설치 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53148cc85f0f5372b92b4adab97d78f0cf599385" translate="yes" xml:space="preserve">
          <source>Print the location of extension makefiles.</source>
          <target state="translated">확장자 makefile의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="4dee3cc7ede35752aad16661b510c6ddc2cb5087" translate="yes" xml:space="preserve">
          <source>Print the location of locale support files. (This will be an empty string if locale support was not configured when PostgreSQL was built.)</source>
          <target state="translated">로케일 지원 파일의 위치를 ​​인쇄하십시오. (PostgreSQL을 빌드 할 때 로케일 지원이 구성되지 않은 경우 빈 문자열이됩니다.)</target>
        </trans-unit>
        <trans-unit id="8935ed932264eb12d05dc3d54390bc5894e6a109" translate="yes" xml:space="preserve">
          <source>Print the location of manual pages.</source>
          <target state="translated">매뉴얼 페이지의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="5c6b2cdac40039c6a4b46eed898e35031563c475" translate="yes" xml:space="preserve">
          <source>Print the location of object code libraries.</source>
          <target state="translated">오브젝트 코드 라이브러리의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="cc4be32137a130cb7e8939f72a35980a1297a7e0" translate="yes" xml:space="preserve">
          <source>Print the location of other C header files.</source>
          <target state="translated">다른 C 헤더 파일의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="348ec650580d85aaddcb30661d2eb9345e76019a" translate="yes" xml:space="preserve">
          <source>Print the location of system-wide configuration files.</source>
          <target state="translated">시스템 전체 구성 파일의 위치를 ​​인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="4773e766d5cc8cfc3ce755cd29aeb486a0dd05ae" translate="yes" xml:space="preserve">
          <source>Print the location of user executables. Use this, for example, to find the &lt;code&gt;psql&lt;/code&gt; program. This is normally also the location where the &lt;code&gt;pg_config&lt;/code&gt; program resides.</source>
          <target state="translated">사용자 실행 파일의 위치를 ​​인쇄하십시오. 예를 들어 &lt;code&gt;psql&lt;/code&gt; 프로그램 을 찾으려면 이것을 사용하십시오 . 이것은 일반적으로 &lt;code&gt;pg_config&lt;/code&gt; 프로그램이 있는 위치이기도 합니다.</target>
        </trans-unit>
        <trans-unit id="53049ab5ef89f22bb5a6370fb0f7681de3a90603" translate="yes" xml:space="preserve">
          <source>Print the names of the files that would have been removed on &lt;code&gt;stdout&lt;/code&gt; (performs a dry run).</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 에서 제거되었을 파일의 이름을 인쇄하십시오 (건조 실행).</target>
        </trans-unit>
        <trans-unit id="9c56e3a83e3c5d8c7d0ed82cb15ca361eb64f1dd" translate="yes" xml:space="preserve">
          <source>Print the options that were given to the &lt;code&gt;configure&lt;/code&gt; script when PostgreSQL was configured for building. This can be used to reproduce the identical configuration, or to find out with what options a binary package was built. (Note however that binary packages often contain vendor-specific custom patches.) See also the examples below.</source>
          <target state="translated">PostgreSQL을 빌드하도록 구성 할 때 &lt;code&gt;configure&lt;/code&gt; 스크립트에 제공된 옵션을 인쇄하십시오 . 동일한 구성을 재현하거나 바이너리 패키지가 구축 된 옵션을 찾는 데 사용할 수 있습니다. 그러나 이진 패키지에는 종종 공급 업체별 사용자 지정 패치가 포함되어 있습니다. 아래 예도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b85724f77cfb0e7f274dc964acb424d6648ba3f5" translate="yes" xml:space="preserve">
          <source>Print the pg_archivecleanup version and exit.</source>
          <target state="translated">pg_archivecleanup 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="74b744744ac1bd9386b12893ce62c91739371ca7" translate="yes" xml:space="preserve">
          <source>Print the pg_basebackup version and exit.</source>
          <target state="translated">pg_basebackup 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="1fca2718d1cfc02986e8abfd6906319ca68c5805" translate="yes" xml:space="preserve">
          <source>Print the pg_checksums version and exit.</source>
          <target state="translated">pg_checksums 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="bff35bc331305f42d0adc605e5c4b58b8bea0e9f" translate="yes" xml:space="preserve">
          <source>Print the pg_ctl version and exit.</source>
          <target state="translated">pg_ctl 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="2f2c8e42d192d577eaeaaebcc2a4ef29dbe17a60" translate="yes" xml:space="preserve">
          <source>Print the pg_dump version and exit.</source>
          <target state="translated">pg_dump 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="711f70c380c99649a9e35f12c5de7cf7f0629905" translate="yes" xml:space="preserve">
          <source>Print the pg_dumpall version and exit.</source>
          <target state="translated">pg_dumpall 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="8234e166090222ac3be3d5f09ddf8625331bebb7" translate="yes" xml:space="preserve">
          <source>Print the pg_isready version and exit.</source>
          <target state="translated">pg_isready 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="521a97d4453901044173e646cb65a707141a7eb2" translate="yes" xml:space="preserve">
          <source>Print the pg_receivewal version and exit.</source>
          <target state="translated">pg_receivewal 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="8fea9240f920d019a51b3b8ffd1d91229e6f0d5d" translate="yes" xml:space="preserve">
          <source>Print the pg_recvlogical version and exit.</source>
          <target state="translated">pg_recvlogical 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="70b6553fafd53c48b770a9da4d3ec37d70a8b1bd" translate="yes" xml:space="preserve">
          <source>Print the pg_restore version and exit.</source>
          <target state="translated">pg_restore 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="6c61b85690c18a6b2ca1bca9177c45ff31b5bf02" translate="yes" xml:space="preserve">
          <source>Print the pg_test_fsync version and exit.</source>
          <target state="translated">pg_test_fsync 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="b30cd37e82aef2f652a2277ade9f7c97f25f875b" translate="yes" xml:space="preserve">
          <source>Print the pg_test_timing version and exit.</source>
          <target state="translated">pg_test_timing 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e08a7072f490e6a4e9bfb50e943fdf0655a61477" translate="yes" xml:space="preserve">
          <source>Print the pg_verifybackup version and exit.</source>
          <target state="translated">Print the pg_verifybackup version and exit.</target>
        </trans-unit>
        <trans-unit id="a75796fa54df85333380d1e7052d5f64abec4dce" translate="yes" xml:space="preserve">
          <source>Print the pg_waldump version and exit.</source>
          <target state="translated">pg_waldump 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="835f88fb67301afbc19bedf23ff78555f1978387" translate="yes" xml:space="preserve">
          <source>Print the pgbench version and exit.</source>
          <target state="translated">pgbench 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f24e000355bdd04337ccc4fe4d288fbdae421623" translate="yes" xml:space="preserve">
          <source>Print the postgres version and exit.</source>
          <target state="translated">postgres 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="a240d07648994ecf31009ecc7c34fcbc6cd8c620" translate="yes" xml:space="preserve">
          <source>Print the psql version and exit.</source>
          <target state="translated">psql 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="9739b8f99cc181f488382f72fe14dfc0f6cbc479" translate="yes" xml:space="preserve">
          <source>Print the reindexdb version and exit.</source>
          <target state="translated">reindexdb 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="ecaad77a21e5cec5eaf16f12e5d3692f68b6cf4f" translate="yes" xml:space="preserve">
          <source>Print the vacuumdb version and exit.</source>
          <target state="translated">vacuumdb 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="860a0a17430dffac960ad73d395384c352d45cdd" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CC&lt;/code&gt; variable that was used for building PostgreSQL. This shows the C compiler used.</source>
          <target state="translated">PostgreSQL 빌드에 사용 된 &lt;code&gt;CC&lt;/code&gt; 변수 의 값을 인쇄하십시오 . 사용 된 C 컴파일러를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7872c242661cddddfe9f42b05b47dc0212422396" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches.</source>
          <target state="translated">PostgreSQL 빌드에 사용 된 &lt;code&gt;CFLAGS&lt;/code&gt; 변수 의 값을 인쇄하십시오 . 이것은 C 컴파일러 스위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="04b3c2f0676508a38269ff7567031f4ef2b568d8" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows extra C compiler switches used for building shared libraries.</source>
          <target state="translated">PostgreSQL 빌드에 사용 된 &lt;code&gt;CFLAGS_SL&lt;/code&gt; 변수 의 값을 인쇄하십시오 . 공유 라이브러리를 빌드하는 데 사용되는 추가 C 컴파일러 스위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7c0bdef9295fb7af405415912b5de766b9d4853d" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CPPFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches needed at preprocessing time (typically, &lt;code&gt;-I&lt;/code&gt; switches).</source>
          <target state="translated">PostgreSQL 빌드에 사용 된 &lt;code&gt;CPPFLAGS&lt;/code&gt; 변수 의 값을 인쇄하십시오 . 이것은 전처리 시간에 필요한 C 컴파일러 스위치 (일반적으로 &lt;code&gt;-I&lt;/code&gt; 스위치)를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0696181ec9c948b2b028ffaf665cb6bea3b893d7" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches.</source>
          <target state="translated">PostgreSQL 빌드에 사용 된 &lt;code&gt;LDFLAGS&lt;/code&gt; 변수 의 값을 인쇄하십시오 . 링커 스위치가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6bb0fe5ffeea6cad2f014a2a3a3b8da60923296c" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_EX&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building executables only.</source>
          <target state="translated">PostgreSQL 빌드에 사용 된 &lt;code&gt;LDFLAGS_EX&lt;/code&gt; 변수 의 값을 인쇄하십시오 . 실행 파일 빌드에만 사용되는 링커 스위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="afbd4079f245521defb38cf6819d6a459fcf80ee" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building shared libraries only.</source>
          <target state="translated">PostgreSQL 빌드에 사용 된 &lt;code&gt;LDFLAGS_SL&lt;/code&gt; 변수 의 값을 인쇄하십시오 . 공유 라이브러리 빌드에만 사용되는 링커 스위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6ca57dae88c29583c5d57897894867bc83f03e6b" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LIBS&lt;/code&gt; variable that was used for building PostgreSQL. This normally contains &lt;code&gt;-l&lt;/code&gt; switches for external libraries linked into PostgreSQL.</source>
          <target state="translated">PostgreSQL 빌드에 사용 된 &lt;code&gt;LIBS&lt;/code&gt; 변수 의 값을 인쇄하십시오 . 여기에는 일반적 으로 PostgreSQL에 연결된 외부 라이브러리에 대한 &lt;code&gt;-l&lt;/code&gt; 스위치 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="8570b6b8795434406c72b8b33b0f9520fcd7b330" translate="yes" xml:space="preserve">
          <source>Print the version of PostgreSQL.</source>
          <target state="translated">PostgreSQL 버전을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c7df780f62e4b06755a28e7503d78d06b7b6aac8" translate="yes" xml:space="preserve">
          <source>Print time information and other statistics at the end of each command. This is useful for benchmarking or for use in tuning the number of buffers.</source>
          <target state="translated">각 명령 끝에 시간 정보 및 기타 통계를 인쇄하십시오. 이는 벤치마킹 또는 버퍼 수 조정에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7df4a5fb243017c5e16941bc4e0dfea430b29b29" translate="yes" xml:space="preserve">
          <source>Print timing statistics for each query relating to each of the major system modules. This option cannot be used together with the &lt;code&gt;-s&lt;/code&gt; option.</source>
          <target state="translated">각 주요 시스템 모듈과 관련된 각 쿼리에 대한 타이밍 통계를 인쇄합니다. 이 옵션은 &lt;code&gt;-s&lt;/code&gt; 옵션 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="85a0746f8a9b8ded581582b11332c0023bccc928" translate="yes" xml:space="preserve">
          <source>Print verbose debugging output that is mostly useful for developers debugging pg_rewind.</source>
          <target state="translated">pg_rewind를 디버깅하는 개발자에게 주로 유용한 상세 디버깅 출력을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="97b0c0a03f737e5ff32021d5ed70701853641a62" translate="yes" xml:space="preserve">
          <source>Prints a detailed vacuum activity report for each table.</source>
          <target state="translated">각 테이블에 대한 자세한 진공 활동 보고서를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="fdb87a5e1b1bdc10bff754f8e203de6fe5cda103" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each index is reindexed.</source>
          <target state="translated">각 색인이 다시 색인 작성 될 때 진행 보고서를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="aa656d5b9337debc039cad558013cd97db922af4" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each table is clustered.</source>
          <target state="translated">각 테이블이 클러스터링 될 때 진행 보고서를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="dd907f7d58905d750186d058c3a6deb80e3a4b4f" translate="yes" xml:space="preserve">
          <source>Prints the argument to stderr, and returns the argument.</source>
          <target state="translated">Prints the argument to stderr, and returns the argument.</target>
        </trans-unit>
        <trans-unit id="b8b2b40104cd92cd0c519f2553360402afa05710" translate="yes" xml:space="preserve">
          <source>Prints the arguments to the standard output, separated by one space and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</source>
          <target state="translated">인수를 표준 출력에 한 칸씩 분리 한 다음 줄 바꾸기로 인쇄합니다. 이것은 스크립트 출력에 정보를 산재하는 데 유용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54169614c32fc13e7741fdc14ac2684c64e4dad5" translate="yes" xml:space="preserve">
          <source>Prints the evaluated arguments to standard output, separated by spaces and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</source>
          <target state="translated">Prints the evaluated arguments to standard output, separated by spaces and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</target>
        </trans-unit>
        <trans-unit id="0f1bb5606479758154dc8298304bb8f734e9529b" translate="yes" xml:space="preserve">
          <source>Prints the pg_basebackup version and exits.</source>
          <target state="translated">Prints the pg_basebackup version and exits.</target>
        </trans-unit>
        <trans-unit id="f89aa4d95dc992bd35115af766260f55953c5bc3" translate="yes" xml:space="preserve">
          <source>Prints the value of the named run-time parameter, and exits. (See the &lt;code&gt;-c&lt;/code&gt; option above for details.) This can be used on a running server, and returns values from &lt;code&gt;postgresql.conf&lt;/code&gt;, modified by any parameters supplied in this invocation. It does not reflect parameters supplied when the cluster was started.</source>
          <target state="translated">명명 된 런타임 매개 변수의 값을 인쇄하고 종료합니다. (자세한 내용은 위 의 &lt;code&gt;-c&lt;/code&gt; 옵션을 참조하십시오.) 실행중인 서버에서 사용할 수 &lt;code&gt;postgresql.conf&lt;/code&gt; 호출에서 제공된 매개 변수로 수정 ​​된 postgresql.conf 에서 값을 리턴합니다 . 클러스터가 시작될 때 제공된 매개 변수를 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4dcba485023d207a9206ea5fc3e3c00fb561414e" translate="yes" xml:space="preserve">
          <source>Prior releases of PostgreSQL also had an R-tree index method. This method has been removed because it had no significant advantages over the GiST method. If &lt;code&gt;USING rtree&lt;/code&gt; is specified, &lt;code&gt;CREATE INDEX&lt;/code&gt; will interpret it as &lt;code&gt;USING gist&lt;/code&gt;, to simplify conversion of old databases to GiST.</source>
          <target state="translated">PostgreSQL의 이전 릴리스에는 R- 트리 인덱스 방법도있었습니다. 이 방법은 GiST 방법에 비해 큰 이점이 없기 때문에 제거되었습니다. 경우 &lt;code&gt;USING rtree&lt;/code&gt; 지정되어, &lt;code&gt;CREATE INDEX&lt;/code&gt; 로 해석됩니다 &lt;code&gt;USING gist&lt;/code&gt; GIST에 기존 데이터베이스의 전환을 단순화하기 위해,.</target>
        </trans-unit>
        <trans-unit id="3bafe92248149caf71bc79d94b8990987f12cfb7" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 10, this rule did not exist, and unspecified-type literals in a &lt;code&gt;SELECT&lt;/code&gt; output list were left as type &lt;code&gt;unknown&lt;/code&gt;. That had assorted bad consequences, so it's been changed.</source>
          <target state="translated">PostgreSQL 10 이전에는이 ​​규칙이 존재하지 않았으며 &lt;code&gt;SELECT&lt;/code&gt; 출력 목록의 지정되지 않은 유형 리터럴은 &lt;code&gt;unknown&lt;/code&gt; 형식으로 남아있었습니다 . 그 결과 나쁜 결과가 나왔으므로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="35b1eb24223c97f90cf161ff4a23f9a4840e576e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 12, it was possible to skip arbitrary text in the input string using non-letter or non-digit characters. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; used to work. Now you can only use letter characters for this purpose. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; skip &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 12 이전에는 문자가 아닌 문자 나 숫자가 아닌 문자를 사용하여 입력 문자열에서 임의의 텍스트를 건너 뛸 수있었습니다. 예를 들어 &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; 가 작동했습니다. 이제이 목적으로 만 문자를 사용할 수 있습니다. 예를 들어, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; 및 &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; 를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="857acef4a685e40620b468c416dd0a4e24020172" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; cases were not handled per SQL specification. A comparison like &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; was implemented as &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; whereas the correct behavior is equivalent to &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 8.2 이전에는 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 사례가 SQL 사양별로 처리되지 않았습니다. &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; 와 같은 비교 &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; 로 구현 되었지만 올바른 동작은 &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ebe12687d87000c523fc24a0eeeef23def50ea6" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were called &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, respectively. These names are still available, but are deprecated and will eventually be removed. Notice that the old names are reversed from the convention formerly followed by the core geometric data types!</source>
          <target state="translated">PostgreSQL 8.2 이전에는 포함 연산자 &lt;code&gt;@&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;@&lt;/code&gt; 을 각각 &lt;code&gt;@&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 이라고 했습니다. 이 이름은 여전히 ​​사용 가능하지만 더 이상 사용되지 않으며 결국 제거됩니다. 이전 이름은 이전에 핵심 지오메트리 데이터 유형이 뒤 따르는 규칙과 반대입니다.</target>
        </trans-unit>
        <trans-unit id="5348a6ba1728be7d24665ecab38998e34ce72cc3" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.0, there was no permission structure associated with large objects. As a result, &lt;code&gt;pg_largeobject&lt;/code&gt; was publicly readable and could be used to obtain the OIDs (and contents) of all large objects in the system. This is no longer the case; use &lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt;&lt;code&gt;pg_largeobject_metadata&lt;/code&gt;&lt;/a&gt; to obtain a list of large object OIDs.</source>
          <target state="translated">PostgreSQL 9.0 이전에는 큰 객체와 관련된 권한 구조가 없었습니다. 결과적으로, &lt;code&gt;pg_largeobject&lt;/code&gt; 는 공개적으로 읽을 수 있었고 시스템에있는 모든 대형 오브젝트의 OID (및 내용)를 얻는 데 사용될 수 있습니다. 더 이상 그렇지 않습니다. 사용 &lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt; &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; 을&lt;/a&gt; 대형 오브젝트 된 OID의 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b601cf233ea62fc96a74bc628fe24fcc3e36d22e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.3, only System V shared memory was used, so the amount of System V shared memory required to start the server was much larger. If you are running an older version of the server, please consult the documentation for your server version.</source>
          <target state="translated">PostgreSQL 9.3 이전에는 System V 공유 메모리 만 사용되었으므로 서버를 시작하는 데 필요한 System V 공유 메모리의 양은 훨씬 더 큽니다. 이전 버전의 서버를 실행중인 경우 서버 버전에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa951ebcd4fe7e0105a5593fae4e308d45c56780" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL version 9.1, a request for the Serializable transaction isolation level provided exactly the same behavior described here. To retain the legacy Serializable behavior, Repeatable Read should now be requested.</source>
          <target state="translated">PostgreSQL 버전 9.1 이전에는 Serializable 트랜잭션 격리 수준에 대한 요청이 여기에 설명 된 것과 동일한 동작을 제공했습니다. 레거시 직렬화 가능 동작을 유지하려면 이제 반복 가능 읽기를 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="284364f281ed56be49bcacf7f01665e2a0a6fd04" translate="yes" xml:space="preserve">
          <source>Priority of this standby server for being chosen as the synchronous standby in a priority-based synchronous replication. This has no effect in a quorum-based synchronous replication.</source>
          <target state="translated">우선 순위 기반 동기 복제에서 동기 대기로 선택되는이 대기 서버의 우선 순위. 쿼럼 기반 동기 복제에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="515ede092cef3c82a110d9534d9f8d3d6afc3135" translate="yes" xml:space="preserve">
          <source>Privilege</source>
          <target state="translated">Privilege</target>
        </trans-unit>
        <trans-unit id="f10ec7ea8e1d8b3a37e319a1b22811778ff9078d" translate="yes" xml:space="preserve">
          <source>Privilege and Ownership - &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;REASSIGN&lt;/code&gt;</source>
          <target state="translated">권한 및 소유권 - &lt;code&gt;GRANT&lt;/code&gt; , &lt;code&gt;REVOKE&lt;/code&gt; , &lt;code&gt;REASSIGN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9010c080ebbc337d2462d6350ec168e7027ffdcc" translate="yes" xml:space="preserve">
          <source>Privilege and Ownership: &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;REASSIGN&lt;/code&gt;</source>
          <target state="translated">Privilege and Ownership: &lt;code&gt;GRANT&lt;/code&gt; , &lt;code&gt;REVOKE&lt;/code&gt; , &lt;code&gt;REASSIGN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de3a5e762db24187db518d22a3b23c1896a649d9" translate="yes" xml:space="preserve">
          <source>Privileges</source>
          <target state="translated">Privileges</target>
        </trans-unit>
        <trans-unit id="2a58093a093ab7a9a99a1645efb525934d0d372c" translate="yes" xml:space="preserve">
          <source>Privileges are only checked once at the start of a replication connection. They are not re-checked as each change record is read from the publisher, nor are they re-checked for each change when applied.</source>
          <target state="translated">권한은 복제 연결 시작시 한 번만 확인됩니다. 각 변경 레코드를 게시자로부터 읽을 때 다시 확인되지 않으며 적용 할 때마다 각 변경에 대해 다시 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1787c604579783f25be8d303f900f7717e89e48f" translate="yes" xml:space="preserve">
          <source>Privileges on databases, tablespaces, schemas, and languages are PostgreSQL extensions.</source>
          <target state="translated">데이터베이스, 테이블 스페이스, 스키마 및 언어에 대한 권한은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="46289836967711686edf2dff70a298178c49970e" translate="yes" xml:space="preserve">
          <source>Probe that fires after dirty buffers have been written to the kernel, and before starting to issue fsync requests.</source>
          <target state="translated">더티 버퍼가 커널에 기록 된 후 및 fsync 요청을 시작하기 전에 발생하는 프로브.</target>
        </trans-unit>
        <trans-unit id="53ee2024c54dc2129f5d4dce9249284ce7d962e4" translate="yes" xml:space="preserve">
          <source>Probe that fires after each buffer is written during checkpoint. arg0 is the ID number of the buffer.</source>
          <target state="translated">검사 점 동안 각 버퍼가 작성된 후 발생하는 프로브. arg0은 버퍼의 ID 번호입니다.</target>
        </trans-unit>
        <trans-unit id="3c4f6900a8f3d94a47b827dad74ca58a7f090a3e" translate="yes" xml:space="preserve">
          <source>Probe that fires anytime the server process updates its &lt;code&gt;pg_stat_activity&lt;/code&gt;.&lt;code&gt;status&lt;/code&gt;. arg0 is the new status string.</source>
          <target state="translated">서버 프로세스가 &lt;code&gt;pg_stat_activity&lt;/code&gt; 를 업데이트 할 때마다 발생하는 프로브 . &lt;code&gt;status&lt;/code&gt; . arg0은 새로운 상태 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="453f8db7eb85902c8d7efba2100824b715baeb8d" translate="yes" xml:space="preserve">
          <source>Probe that fires at the start of a new transaction. arg0 is the transaction ID.</source>
          <target state="translated">새로운 거래가 시작될 때 발생하는 프로브. arg0은 트랜잭션 ID입니다.</target>
        </trans-unit>
        <trans-unit id="3a3aefacb2b30c73490e38f66077f014ccc50ebf" translate="yes" xml:space="preserve">
          <source>Probe that fires before issuing any write request for a shared buffer. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="translated">공유 버퍼에 대한 쓰기 요청을 발행하기 전에 발생하는 프로브. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="33d263a06d1f645788a7d9cc687ecf761651c94e" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL record is inserted. arg0 is the resource manager (rmid) for the record. arg1 contains the info flags.</source>
          <target state="translated">WAL 레코드가 삽입 될 때 발생하는 프로브. arg0은 레코드의 자원 관리자 (rmid)입니다. arg1은 정보 플래그를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9f1168c24751c9cc0c2a8a2c6b3927e1a19c2275" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL segment switch is requested.</source>
          <target state="translated">WAL 세그먼트 스위치가 요청 될 때 발생하는 프로브.</target>
        </trans-unit>
        <trans-unit id="8e4d476400e68096572772c60276c43e69c8a62b" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block read is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually read, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="translated">블록 읽기가 완료되면 발생하는 프로브. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼에 대한 임시 관계를 만든 백엔드의 ID이거나 공유 버퍼에 대한 &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1)입니다. arg6은 실제로 읽은 바이트 수이고, arg7은 요청 된 수입니다 (다르면 문제가 있음을 나타냄).</target>
        </trans-unit>
        <trans-unit id="bec87f01b3c4ae7574229debd84c5fd432c77b1a" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block write is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually written, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="translated">블록 쓰기가 완료되면 발생하는 프로브. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼에 대한 임시 관계를 만든 백엔드의 ID이거나 공유 버퍼에 대한 &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1)입니다. arg6은 실제로 쓴 바이트 수이며, arg7은 요청 된 수입니다 (다르면 문제가 있음을 나타냄).</target>
        </trans-unit>
        <trans-unit id="46f91b3dd629f638c1e5b0918321dc6a1503deb9" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is complete. arg0 and arg1 contain the fork and block numbers of the page (if this is a relation extension request, arg1 now contains the block number of the newly added block). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read. arg7 is true if the buffer was found in the pool, false if not.</source>
          <target state="translated">버퍼 읽기가 완료되면 발생하는 프로브. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다 (관계 확장 요청 인 경우 arg1에는 새로 추가 된 블록의 블록 번호가 포함됨). arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼에 대한 임시 관계를 만든 백엔드의 ID이거나 공유 버퍼에 대한 &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1)입니다. arg6은 관계 확장 요청의 경우 true이고 일반 읽기의 경우 false입니다. 버퍼가 풀에서 발견되면 arg7은 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="58ba85ae8dc3ff12abd986e1bbe24ce88cd6ffee" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is started. arg0 and arg1 contain the fork and block numbers of the page (but arg1 will be -1 if this is a relation extension request). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read.</source>
          <target state="translated">버퍼 읽기가 시작될 때 발생하는 프로브. arg0 및 arg1은 페이지의 포크 및 블록 번호를 포함합니다 (하지만 관계 확장 요청 인 경우 arg1은 -1 임). arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼에 대한 임시 관계를 만든 백엔드의 ID이거나 공유 버퍼에 대한 &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1)입니다. arg6은 관계 확장 요청의 경우 true이고 일반 읽기의 경우 false입니다.</target>
        </trans-unit>
        <trans-unit id="0fbe84f59555154d75e50194b6717675ebf83d0f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is complete. (The probes listed next fire in sequence during checkpoint processing.) arg0 is the number of buffers written. arg1 is the total number of buffers. arg2, arg3 and arg4 contain the number of WAL files added, removed and recycled respectively.</source>
          <target state="translated">검사 점이 완료되면 발생하는 프로브. (체크 포인트 처리 중에 다음에 나열된 프로브가 순서대로 실행됩니다.) arg0은 쓴 버퍼 수입니다. arg1은 총 버퍼 수입니다. arg2, arg3 및 arg4에는 각각 추가, 제거 및 재활용 된 WAL 파일 수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="23fe54bf3cce9571085cc7cf6504d3feaa949415" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="translated">체크 포인트가 시작될 때 발생하는 프로브. arg0은 종료, 즉시 또는 강제 같은 다른 검사 점 유형을 구별하는 데 사용되는 비트 단위 플래그를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="93bbd1ca880ff804d869958124aceb46cced58c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when a deadlock is found by the deadlock detector.</source>
          <target state="translated">교착 상태 탐지기에 의해 교착 상태가 발견되면 발생하는 프로브.</target>
        </trans-unit>
        <trans-unit id="cd2095b8769349eb00b3e4c4c59eb7c9f09aa65d" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty WAL buffer write is complete.</source>
          <target state="translated">더티 WAL 버퍼 쓰기가 완료되면 발생하는 프로브.</target>
        </trans-unit>
        <trans-unit id="e06e64448ac61e5f30e9d0aae09a59b087a40467" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty-buffer write is complete. The arguments are the same as for &lt;code&gt;buffer-write-dirty-start&lt;/code&gt;.</source>
          <target state="translated">더티 버퍼 쓰기가 완료되면 발생하는 프로브. 인수는 &lt;code&gt;buffer-write-dirty-start&lt;/code&gt; 와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="bc7ff5d60d95edecd39d25ce953e04898f2adf03" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has begun to wait because the lock is not available. arg0 through arg3 are the tag fields identifying the object being locked. arg4 indicates the type of object being locked. arg5 indicates the lock type being requested.</source>
          <target state="translated">잠금을 사용할 수 없어 헤비급 잠금 (lmgr 잠금) 요청이 대기하기 시작했을 때 발생하는 프로브. arg0 ~ arg3은 잠긴 오브젝트를 식별하는 태그 필드입니다. arg4는 잠기고있는 객체의 유형을 나타냅니다. arg5는 요청중인 잠금 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4162528ebd10f947261c421936db3a10071c6bda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has finished waiting (i.e., has acquired the lock). The arguments are the same as for &lt;code&gt;lock-wait-start&lt;/code&gt;.</source>
          <target state="translated">헤비급 잠금 (lmgr 잠금) 요청이 대기를 마치면 (즉, 잠금을 획득 한 경우) 발생하는 프로브. 인수는 &lt;code&gt;lock-wait-start&lt;/code&gt; 와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="c611257e152cea80f6cfc845709b8d0de904351c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty WAL buffer because no more WAL buffer space is available. (If this happens often, it implies that &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; is too small.)</source>
          <target state="translated">더 이상 사용할 수있는 WAL 버퍼 공간이 없기 때문에 서버 프로세스가 더티 WAL 버퍼 쓰기를 시작할 때 발생하는 프로브. (이것이 자주 발생하면 &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; 가 너무 작다는 것을 의미합니다 .)</target>
        </trans-unit>
        <trans-unit id="f78264e8172fbf9d18964b5de63c4b5c50a37b93" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty buffer. (If this happens often, it implies that &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; is too small or the background writer control parameters need adjustment.) arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="translated">서버 프로세스가 더티 버퍼 쓰기를 시작할 때 발생하는 프로브. 이 문제가 자주 발생하면 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 가 너무 작거나 백그라운드 작성기 제어 매개 변수를 조정해야 함을 의미합니다 . arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ab6028b90f757cbb259294d12f57f8c712860524" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process has been released from its wait for an LWLock (it does not actually have the lock yet). arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">서버 프로세스가 LWLock 대기에서 해제 될 때 발생하는 프로브입니다 (실제로는 아직 잠금이 없습니다). arg0은 LWLock의 트랜치입니다. arg1은 요청 된 잠금 모드 (독점 또는 공유)입니다.</target>
        </trans-unit>
        <trans-unit id="327d56ed2b9d3f4cc36bd9b948fbb4da61129ae8" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort is complete. arg0 is true for external sort, false for internal sort. arg1 is the number of disk blocks used for an external sort, or kilobytes of memory used for an internal sort.</source>
          <target state="translated">정렬이 완료되면 발생하는 프로브. arg0은 외부 정렬의 경우 true이고 내부 정렬의 경우 false입니다. arg1은 외부 정렬에 사용되는 디스크 블록 수 또는 내부 정렬에 사용되는 킬로바이트 메모리입니다.</target>
        </trans-unit>
        <trans-unit id="4a9847b929f87d2af0af81f9222c2554ede52eda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort operation is started. arg0 indicates heap, index or datum sort. arg1 is true for unique-value enforcement. arg2 is the number of key columns. arg3 is the number of kilobytes of work memory allowed. arg4 is true if random access to the sort result is required. arg5 indicates serial when &lt;code&gt;0&lt;/code&gt;, parallel worker when &lt;code&gt;1&lt;/code&gt;, or parallel leader when &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">정렬 작업이 시작될 때 발생하는 프로브. arg0은 힙, 인덱스 또는 데이텀 정렬을 나타냅니다. arg1은 고유 값 적용에 해당됩니다. arg2는 키 열의 수입니다. arg3은 허용 된 작업 메모리의 킬로바이트 수입니다. 정렬 결과에 무작위로 액세스해야하는 경우 arg4는 true입니다. arg5는 &lt;code&gt;0&lt;/code&gt; 이면 직렬 , &lt;code&gt;1&lt;/code&gt; 이면 병렬 작업자 , &lt;code&gt;2&lt;/code&gt; 이면 병렬 리더를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9a6c578cf9ebf6dafcb797b30e10c8c0ea10449f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes successfully. arg0 is the transaction ID.</source>
          <target state="translated">트랜잭션이 성공적으로 완료되면 발생하는 프로브입니다. arg0은 트랜잭션 ID입니다.</target>
        </trans-unit>
        <trans-unit id="4a8dcaad5632a5c029ca8a4cd70eeafe1ca847b1" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes unsuccessfully. arg0 is the transaction ID.</source>
          <target state="translated">트랜잭션이 성공적으로 완료되지 않으면 발생하는 프로브입니다. arg0은 트랜잭션 ID입니다.</target>
        </trans-unit>
        <trans-unit id="17050254a1180d83c2f09021018121a20c9a108c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a write request is complete. (Note that this just reflects the time to pass the data to the kernel; it's typically not actually been written to disk yet.) The arguments are the same as for &lt;code&gt;buffer-flush-start&lt;/code&gt;.</source>
          <target state="translated">쓰기 요청이 완료되면 발생하는 프로브입니다. (이것은 단지 데이터를 커널에 전달하는 시간만을 반영한다는 점에 유의하십시오. 일반적으로 실제로 디스크에 기록되지 않았습니다.) 인수는 &lt;code&gt;buffer-flush-start&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8e023e6af3bb6f75b33af22efff6aa6afa3fd941" translate="yes" xml:space="preserve">
          <source>Probe that fires when all dirty buffers have been written. arg0 is the total number of buffers. arg1 is the number of buffers actually written by the checkpoint process. arg2 is the number that were expected to be written (arg1 of &lt;code&gt;buffer-sync-start&lt;/code&gt;); any difference reflects other processes flushing buffers during the checkpoint.</source>
          <target state="translated">더티 버퍼가 모두 쓰여졌을 때 발생하는 프로브. arg0은 총 버퍼 수입니다. arg1은 실제로 검사 점 프로세스에 의해 작성된 버퍼 수입니다. arg2는 쓰여질 것으로 예상 된 숫자입니다 ( &lt;code&gt;buffer-sync-start&lt;/code&gt; 의 arg1 ). 차이는 체크 포인트 동안 다른 프로세스 플러시 버퍼를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="466cfd0176351b56d635f32f0410727040245d40" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been acquired. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">LWLock을 획득했을 때 발생하는 프로브. arg0은 LWLock의 트랜치입니다. arg1은 요청 된 잠금 모드 (독점 또는 공유)입니다.</target>
        </trans-unit>
        <trans-unit id="6121be81d01b11fd11854f3cc9d63c7a9a5f1cbf" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been released (but note that any released waiters have not yet been awakened). arg0 is the LWLock's tranche.</source>
          <target state="translated">LWLock이 해제되었을 때 발생하는 프로브입니다 (그러나 릴리스 된 웨이터가 아직 깨어나지 않았다는 점에 유의하십시오). arg0은 LWLock의 트랜치입니다.</target>
        </trans-unit>
        <trans-unit id="eee4a231a6a278d84a4bf21d96cfbf0b033695e4" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not immediately available and a server process has begun to wait for the lock to become available. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">LWLock을 즉시 사용할 수없고 서버 프로세스가 잠금을 사용할 수있을 때까지 대기하기 시작했을 때 발생하는 프로브. arg0은 LWLock의 트랜치입니다. arg1은 요청 된 잠금 모드 (독점 또는 공유)입니다.</target>
        </trans-unit>
        <trans-unit id="32b5dee951d8d8bbcc4c527b18fd9921e80f05ea" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">발신자가 대기를 지정하지 않았을 때 LWLock이 성공적으로 획득되지 않았을 때 발생하는 프로브. arg0은 LWLock의 트랜치입니다. arg1은 요청 된 잠금 모드 (독점 또는 공유)입니다.</target>
        </trans-unit>
        <trans-unit id="29ccd443bca3bd38a197795375408911c2de33c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">발신자가 대기를 지정하지 않았을 때 LWLock을 성공적으로 획득했을 때 발생하는 프로브. arg0은 LWLock의 트랜치입니다. arg1은 요청 된 잠금 모드 (독점 또는 공유)입니다.</target>
        </trans-unit>
        <trans-unit id="9fe33e9001aca2852cd9dca52b36bdbecb7c1f32" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to read a block from a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="translated">관계에서 블록을 읽기 시작할 때 발생하는 프로브. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼에 대한 임시 관계를 만든 백엔드의 ID이거나 공유 버퍼에 대한 &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1)입니다.</target>
        </trans-unit>
        <trans-unit id="d3f7e8aeab722a5eb71c03e5e72e466f6f7d683f" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to write a block to a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="translated">관계에 블록을 쓰기 시작할 때 발생하는 프로브. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼에 대한 임시 관계를 만든 백엔드의 ID이거나 공유 버퍼에 대한 &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1)입니다.</target>
        </trans-unit>
        <trans-unit id="9cef86798a06a87b1e53005af8b7cffd9544c2ff" translate="yes" xml:space="preserve">
          <source>Probe that fires when syncing of buffers to disk is complete.</source>
          <target state="translated">버퍼와 디스크의 동기화가 완료되면 발생하는 프로브.</target>
        </trans-unit>
        <trans-unit id="7e4496f8bfaa3cf215e7723d1b3f6a6a44062ac3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;clog-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">검사 점의 CLOG 부분이 완료되면 시작되는 프로브입니다. arg0은 &lt;code&gt;clog-checkpoint-start&lt;/code&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="1ce40580bfe3cc60932d40bba9c3a62201a4d419" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">검사 점의 CLOG 부분이 시작될 때 발생하는 프로브. arg0은 일반 검사 점의 경우 true이고 종료 검사 점의 경우 false입니다.</target>
        </trans-unit>
        <trans-unit id="f127e8e58e69f04b50616b0e221c7c59b7f1f3d1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;multixact-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">검사 점의 MultiXact 부분이 완료되면 발생하는 프로브. arg0은 &lt;code&gt;multixact-checkpoint-start&lt;/code&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7db7d3684151dd5b3ccf2213972ecca8de60eb5e" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">검사 점의 MultiXact 부분이 시작될 때 발생하는 프로브. arg0은 일반 검사 점의 경우 true이고 종료 검사 점의 경우 false입니다.</target>
        </trans-unit>
        <trans-unit id="19d184e6d4448ad19f4409d088d396f7df8c32d3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">검사 점의 SUBTRANS 부분이 완료되면 발생하는 프로브. arg0은 &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="406309c24a9ce7d667e2ff79d8bf7268a9ff9831" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">검사 점의 SUBTRANS 부분이 시작될 때 발생하는 프로브. arg0은 일반 검사 점의 경우 true이고 종료 검사 점의 경우 false입니다.</target>
        </trans-unit>
        <trans-unit id="2d124d93cd049bd0371700c2959bdf0770b013e0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the buffer-writing portion of a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="translated">검사 점의 버퍼 쓰기 부분이 시작될 때 발생하는 프로브. arg0은 종료, 즉시 또는 강제 같은 다른 검사 점 유형을 구별하는 데 사용되는 비트 단위 플래그를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="931b1ed777e93c094dcd52151780b666556374f1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is complete.</source>
          <target state="translated">쿼리 실행이 완료되면 시작되는 프로브입니다.</target>
        </trans-unit>
        <trans-unit id="6643c1646d73651ecf6358eff359f77c5055c16d" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is started.</source>
          <target state="translated">쿼리 실행이 시작될 때 발생하는 프로브입니다.</target>
        </trans-unit>
        <trans-unit id="0944a082320c7bc732281e77e7ca49f36f32c834" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is complete. arg0 is the query string.</source>
          <target state="translated">쿼리 구문 분석이 완료되면 시작되는 프로브입니다. arg0은 쿼리 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d96fa9e5daed0c63d0c0481d8ca8ebbe0a261583" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is started. arg0 is the query string.</source>
          <target state="translated">쿼리 구문 분석이 시작될 때 발생하는 프로브입니다. arg0은 쿼리 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9452ef2f9dd8e46c1c62afe77724fc190b423661" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is complete.</source>
          <target state="translated">쿼리 계획이 완료되면 시작되는 프로브입니다.</target>
        </trans-unit>
        <trans-unit id="a1d4370c7121e9a518ec9800f508633ae2640459" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is started.</source>
          <target state="translated">쿼리 계획이 시작될 때 발생하는 프로브입니다.</target>
        </trans-unit>
        <trans-unit id="96a4a695589b1af8e96af229876a85b1ac6a6721" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is complete. arg0 is the query string.</source>
          <target state="translated">쿼리 처리가 완료되면 시작되는 프로브입니다. arg0은 쿼리 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="17d08bdfb5f9889597cd8fad97751d8760642495" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is started. arg0 is the query string.</source>
          <target state="translated">쿼리 처리가 시작될 때 발생하는 프로브입니다. arg0은 쿼리 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="eab217356aa735f20b49ab127f241495b6ade066" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is complete. arg0 is the query string.</source>
          <target state="translated">쿼리 재 작성이 완료되면 시작되는 프로브입니다. arg0은 쿼리 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a428364242cf9691158e2fd27eee09f0cdf33ee9" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is started. arg0 is the query string.</source>
          <target state="translated">쿼리 다시 쓰기가 시작될 때 발생하는 프로브입니다. arg0은 쿼리 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="21185778a7abdae335897b758940d7f751d2a6f0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is complete.</source>
          <target state="translated">체크 포인트의 2 단계 부분이 완료되면 발생하는 프로브.</target>
        </trans-unit>
        <trans-unit id="0b37c215587e2b196fc6e3605c0952c5abaaeaa4" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is started.</source>
          <target state="translated">체크 포인트의 2 단계 부분이 시작될 때 발생하는 프로브.</target>
        </trans-unit>
        <trans-unit id="64dbe1e4375ac3d8c100dcc3b4624e32ba635dcb" translate="yes" xml:space="preserve">
          <source>Probe that fires when we begin to write dirty buffers during checkpoint (after identifying which buffers must be written). arg0 is the total number of buffers. arg1 is the number that are currently dirty and need to be written.</source>
          <target state="translated">검사 점에서 더티 버퍼를 쓰기 시작할 때 (어떤 버퍼를 작성해야하는지 식별 한 후) 발생하는 프로브. arg0은 총 버퍼 수입니다. arg1은 현재 더럽고 기록해야하는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="0e17699a3879dd39ab092b19091e781ba0c3179a" translate="yes" xml:space="preserve">
          <source>Procedural Languages (server-side)</source>
          <target state="translated">절차 적 언어 (서버 측)</target>
        </trans-unit>
        <trans-unit id="d23b357b75ad2622370788956db89d9cceb43ba0" translate="yes" xml:space="preserve">
          <source>Procedural languages are local to individual databases. However, a language can be installed into the &lt;code&gt;template1&lt;/code&gt; database, which will cause it to be available automatically in all subsequently-created databases.</source>
          <target state="translated">절차 적 언어는 개별 데이터베이스에 로컬입니다. 그러나 &lt;code&gt;template1&lt;/code&gt; 데이터베이스에 언어를 설치할 수 있으므로 이후에 작성된 모든 데이터베이스에서 언어를 자동으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc9339747734b918985c0542808ea173cf36ca7c" translate="yes" xml:space="preserve">
          <source>Procedure (routine)</source>
          <target state="translated">Procedure (routine)</target>
        </trans-unit>
        <trans-unit id="c80cc4229f5a9d3da6a7c3b6c8547ced65049640" translate="yes" xml:space="preserve">
          <source>Process ID</source>
          <target state="translated">프로세스 ID</target>
        </trans-unit>
        <trans-unit id="be2c2eb824ea5b51d9b5bce07c9b40cd34577acf" translate="yes" xml:space="preserve">
          <source>Process ID of a WAL sender process</source>
          <target state="translated">WAL 발신자 프로세스의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="41767044d1edbdb5cf9f2dae1fdd49d59e940ebf" translate="yes" xml:space="preserve">
          <source>Process ID of a WAL sender process.</source>
          <target state="translated">Process ID of a WAL sender process.</target>
        </trans-unit>
        <trans-unit id="af10df8d6082fa39f1e4f58ff138720439c3d068" translate="yes" xml:space="preserve">
          <source>Process ID of a backend</source>
          <target state="translated">백엔드의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="373864156198cbd9c04a34d7ab3e6735c02719d2" translate="yes" xml:space="preserve">
          <source>Process ID of a backend or WAL sender process</source>
          <target state="translated">백엔드 또는 WAL 발신자 프로세스의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="c5da887d9f68351aff22198bf3916a2bd05dd9d7" translate="yes" xml:space="preserve">
          <source>Process ID of backend.</source>
          <target state="translated">백엔드의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="1aca36c0622a2538e27d8bf063d83ca00390c145" translate="yes" xml:space="preserve">
          <source>Process ID of the WAL receiver process</source>
          <target state="translated">WAL 수신자 프로세스의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="5d7d2e19d28ca6186fcc59c93b80889377f993f2" translate="yes" xml:space="preserve">
          <source>Process ID of the locker currently being waited for.</source>
          <target state="translated">현재 대기중인 로커의 프로세스 ID.</target>
        </trans-unit>
        <trans-unit id="f0648fb422c9ce57f595e096435bf789668b2752" translate="yes" xml:space="preserve">
          <source>Process ID of the parallel group leader, if this process is a parallel query worker. &lt;code&gt;NULL&lt;/code&gt; if this process is a parallel group leader or does not participate in parallel query.</source>
          <target state="translated">Process ID of the parallel group leader, if this process is a parallel query worker. &lt;code&gt;NULL&lt;/code&gt; if this process is a parallel group leader or does not participate in parallel query.</target>
        </trans-unit>
        <trans-unit id="01681ffc812bd9e058f3a6c5baf1409c4f0ba3bc" translate="yes" xml:space="preserve">
          <source>Process ID of the server process attached to the current session</source>
          <target state="translated">현재 세션에 연결된 서버 프로세스의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="af8e0118b6d9e8d86d67cf0400739aba8210dd2b" translate="yes" xml:space="preserve">
          <source>Process ID of the server process handling the current session</source>
          <target state="translated">현재 세션을 처리하는 서버 프로세스의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="03fbcc6f1367738e610a0cace02a8fd6438fb048" translate="yes" xml:space="preserve">
          <source>Process ID of the server process holding or awaiting this lock, or null if the lock is held by a prepared transaction</source>
          <target state="translated">이 잠금을 보유 또는 대기중인 서버 프로세스의 프로세스 ID 또는 잠금이 준비된 트랜잭션에 의해 보류 된 경우 널</target>
        </trans-unit>
        <trans-unit id="999d9e41cb5cf7f111cc6e19904f6e291da38b6e" translate="yes" xml:space="preserve">
          <source>Process ID of the subscription worker process</source>
          <target state="translated">서브 스크립 션 작업자 프로세스의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="e1f52d5447d8eaecbf7bddfce74b35d1ffb039b9" translate="yes" xml:space="preserve">
          <source>Process ID of this backend</source>
          <target state="translated">이 백엔드의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="d15b210cc1e134700f907b8b25d7b1043aa0ca7b" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a lock</source>
          <target state="translated">지정된 서버 프로세스 ID가 잠금을 획득하지 못하도록 차단하는 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="6f132a3ada7bb531c167b75bc5eeea4c4aebfc18" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a safe snapshot</source>
          <target state="translated">지정된 서버 프로세스 ID가 안전한 스냅 샷을 얻지 못하도록 차단하는 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="f9b1d2668cc983dbc740512036c3c2a0339f13e5" translate="yes" xml:space="preserve">
          <source>Process IDs of locking backends (more than one if multitransaction)</source>
          <target state="translated">백엔드 잠금 프로세스 ID (다중 트랜잭션 인 경우 둘 이상)</target>
        </trans-unit>
        <trans-unit id="f966bc3f73e4a99fa5d7b7c8751d4573456fa586" translate="yes" xml:space="preserve">
          <source>Process Identifier</source>
          <target state="translated">프로세스 식별자</target>
        </trans-unit>
        <trans-unit id="23fe74f2755c9dfea4c7fb3bc31b2e29d2cbcd59" translate="yes" xml:space="preserve">
          <source>Process header files. When this option is specified, the output file extension becomes &lt;code&gt;.h&lt;/code&gt; not &lt;code&gt;.c&lt;/code&gt;, and the default input file extension is &lt;code&gt;.pgh&lt;/code&gt; not &lt;code&gt;.pgc&lt;/code&gt;. Also, the &lt;code&gt;-c&lt;/code&gt; option is forced on.</source>
          <target state="translated">Process header files. When this option is specified, the output file extension becomes &lt;code&gt;.h&lt;/code&gt; not &lt;code&gt;.c&lt;/code&gt; , and the default input file extension is &lt;code&gt;.pgh&lt;/code&gt; not &lt;code&gt;.pgc&lt;/code&gt; . Also, the &lt;code&gt;-c&lt;/code&gt; option is forced on.</target>
        </trans-unit>
        <trans-unit id="d4a6aac2feb7c0acbdd36ece9c6b8ffa6edac4ab" translate="yes" xml:space="preserve">
          <source>Process of an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; which acts on behalf of a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;client session&lt;/a&gt; and handles its requests.</source>
          <target state="translated">Process of an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; which acts on behalf of a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;client session&lt;/a&gt; and handles its requests.</target>
        </trans-unit>
        <trans-unit id="9404f1b149e0fa2944f7fe7f5a9758a8f27d7f2a" translate="yes" xml:space="preserve">
          <source>Process start time stamp</source>
          <target state="translated">프로세스 시작 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="2fc3c183e1dc7c192411203ba9cdff758c852d48" translate="yes" xml:space="preserve">
          <source>Process within an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;, which runs system- or user-supplied code. Serves as infrastructure for several features in PostgreSQL, such as &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;logical replication&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-PARALLEL-QUERY&quot;&gt;parallel queries&lt;/a&gt;. In addition, &lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;Extensions&lt;/a&gt; can add custom background worker processes.</source>
          <target state="translated">Process within an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;, which runs system- or user-supplied code. Serves as infrastructure for several features in PostgreSQL, such as &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;logical replication&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-PARALLEL-QUERY&quot;&gt;parallel queries&lt;/a&gt;. In addition, &lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;Extensions&lt;/a&gt; can add custom background worker processes.</target>
        </trans-unit>
        <trans-unit id="9b87f820c5635b5c920ad2cf5059d2207d8f59e5" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action.</source>
          <target state="translated">삭제 또는 업데이트로 인해 외래 키 제약 조건 위반이 발생했음을 나타내는 오류가 발생합니다. 제한 조건이 지연되면 참조 행이 여전히 존재하면 제한 조건 점검시이 오류가 발생합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="19db911f45836f08f67324db7d1d1b7713f59b5d" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same as &lt;code&gt;NO ACTION&lt;/code&gt; except that the check is not deferrable.</source>
          <target state="translated">삭제 또는 업데이트로 인해 외래 키 제약 조건 위반이 발생했음을 나타내는 오류가 발생합니다. 이것은 점검이 연기 될 수 없다는 점을 제외하고 &lt;code&gt;NO ACTION&lt;/code&gt; 동일합니다.</target>
        </trans-unit>
        <trans-unit id="595741604d266c8ba7ee063d34ab349a2aac4f77" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query</source>
          <target state="translated">행 이름과 &lt;code&gt;N&lt;/code&gt; 값 열을 포함하는 &quot;피벗 테이블&quot;을 생성합니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 호출 쿼리에 지정된 행 유형에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d19d956161f313325e8c8fa1383c1d5dc4285689" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query.</source>
          <target state="translated">Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query.</target>
        </trans-unit>
        <trans-unit id="3b7d934bad462d22e3d780a0512ef5f70c8fefe7" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below</source>
          <target state="translated">행 이름과 &lt;code&gt;N&lt;/code&gt; 값 열을 포함하는 &quot;피벗 테이블&quot;을 생성합니다 . &lt;code&gt;crosstab2&lt;/code&gt; , &lt;code&gt;crosstab3&lt;/code&gt; 및 &lt;code&gt;crosstab4&lt;/code&gt; 가 사전 정의되어 있지만 아래 설명 된대로 추가 &lt;code&gt;crosstabN&lt;/code&gt; 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6827b61996dcfecd3a6bdd8ecd7849189131e707" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below.</source>
          <target state="translated">Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt; , &lt;code&gt;crosstab3&lt;/code&gt; , and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below.</target>
        </trans-unit>
        <trans-unit id="953361f0fb07cbbdc30a8c3d39ada8d75e41aa1b" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query</source>
          <target state="translated">두 번째 쿼리로 지정된 값 열을 사용하여 &quot;피벗 테이블&quot;을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2796ff43fdf0371172e3aca0613ef5e330539f10" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query.</source>
          <target state="translated">Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query.</target>
        </trans-unit>
        <trans-unit id="eeb96fffad25790b78f8b2fd976762cd22e0262e" translate="yes" xml:space="preserve">
          <source>Produces a representation of a hierarchical tree structure</source>
          <target state="translated">계층 적 트리 구조의 표현을 생성합니다</target>
        </trans-unit>
        <trans-unit id="6073947dcba4d43cc98e457a1a526968941edbfc" translate="yes" xml:space="preserve">
          <source>Produces a representation of a hierarchical tree structure.</source>
          <target state="translated">Produces a representation of a hierarchical tree structure.</target>
        </trans-unit>
        <trans-unit id="f1f50ebfc9183ee48a90532a8dbfb3653ac19c72" translate="yes" xml:space="preserve">
          <source>Produces a representation of the indexable portion of a &lt;code&gt;tsquery&lt;/code&gt;. A result that is empty or just &lt;code id=&quot;t&quot;&gt;T&lt;/code&gt; indicates a non-indexable query.</source>
          <target state="translated">Produces a representation of the indexable portion of a &lt;code&gt;tsquery&lt;/code&gt; . A result that is empty or just &lt;code id=&quot;t&quot;&gt;T&lt;/code&gt; indicates a non-indexable query.</target>
        </trans-unit>
        <trans-unit id="d2cf09a7cb7a5d996def491486e555116c8e56fe" translate="yes" xml:space="preserve">
          <source>Produces a set of normally distributed random values</source>
          <target state="translated">정규 분포 랜덤 값 세트를 생성합니다</target>
        </trans-unit>
        <trans-unit id="315b9480dccd3ac225db648897293892f773f54e" translate="yes" xml:space="preserve">
          <source>Produces a set of normally distributed random values.</source>
          <target state="translated">Produces a set of normally distributed random values.</target>
        </trans-unit>
        <trans-unit id="9b3d37859bb87e00841bf5b68801363110571121" translate="yes" xml:space="preserve">
          <source>Produces no output, but tells non-session processes to stop at this point in the string; ignored by session processes</source>
          <target state="translated">출력을 생성하지 않지만 세션의 비 프로세스가 문자열의이 시점에서 중지하도록 지시합니다. 세션 프로세스에서 무시</target>
        </trans-unit>
        <trans-unit id="c4cc122a953a1ad9e9d147019c31d589653986fa" translate="yes" xml:space="preserve">
          <source>Produces the intersection of two cubes.</source>
          <target state="translated">두 큐브의 교집합을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bc2b03c140585a107e123dbad9c7907236c487ae" translate="yes" xml:space="preserve">
          <source>Produces the union of two cubes.</source>
          <target state="translated">두 큐브의 결합을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3a873ea551f5b656a037c9a2775158084055a3fb" translate="yes" xml:space="preserve">
          <source>Programs using C code with embedded SQL have to be linked against the &lt;code&gt;libecpg&lt;/code&gt; library, for example using the linker options &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt;.</source>
          <target state="translated">임베드 된 SQL과 함께 C 코드를 사용하는 프로그램 은 링커 옵션 &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt; 를 사용하여 &lt;code&gt;libecpg&lt;/code&gt; 라이브러리에 링크 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="62babe4510e8d8a8ee8afda900ec73acd0a5dab6" translate="yes" xml:space="preserve">
          <source>Progress Reporting</source>
          <target state="translated">진행보고</target>
        </trans-unit>
        <trans-unit id="3d02226c16e2d7d25eeaba8bd347cdb833f33050" translate="yes" xml:space="preserve">
          <source>Promotes a physical standby server. With &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt;&lt;code&gt;wait_seconds&lt;/code&gt;&lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt;, the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending &lt;code&gt;SIGUSR1&lt;/code&gt; to the postmaster to trigger the promotion. This function is restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">실제 대기 서버를 승격시킵니다. 함께 &lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt; 로 설정 &lt;code&gt;true&lt;/code&gt; (기본), 함수 대기가 추진 완료 또는 때까지 &lt;em&gt; &lt;code&gt;wait_seconds&lt;/code&gt; &lt;/em&gt; 초 통과, 반환 &lt;code&gt;true&lt;/code&gt; 홍보가 성공하는 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지. 경우 &lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt; 설정되어 &lt;code&gt;false&lt;/code&gt; , 함수는 반환 &lt;code&gt;true&lt;/code&gt; 을 즉시 전송 한 후 &lt;code&gt;SIGUSR1&lt;/code&gt; 을 촉진를 트리거 포스트 마스터에게. 이 기능은 기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377afe4fc3a70d640cc41e476917292a950a7519" translate="yes" xml:space="preserve">
          <source>Promotes a standby server to primary status. With &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt;&lt;code&gt;wait_seconds&lt;/code&gt;&lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt;, the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending a &lt;code&gt;SIGUSR1&lt;/code&gt; signal to the postmaster to trigger promotion.</source>
          <target state="translated">Promotes a standby server to primary status. With &lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt; &lt;code&gt;wait_seconds&lt;/code&gt; &lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt; , the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending a &lt;code&gt;SIGUSR1&lt;/code&gt; signal to the postmaster to trigger promotion.</target>
        </trans-unit>
        <trans-unit id="310745705e4b51911f7ad05e685132e85803b43c" translate="yes" xml:space="preserve">
          <source>Prompt for confirmation before actually removing the user, and prompt for the user name if none is specified on the command line.</source>
          <target state="translated">실제로 사용자를 제거하기 전에 확인을 요청하고 명령 행에 사용자 이름이 지정되지 않은 경우 사용자 이름을 입력하도록 프롬프트하십시오.</target>
        </trans-unit>
        <trans-unit id="a4139dbdd33b4ca75eb092bf7d5f911f9e520f3e" translate="yes" xml:space="preserve">
          <source>Prompt for the user name if none is specified on the command line, and also prompt for whichever of the options &lt;code&gt;-d&lt;/code&gt;/&lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;/&lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;/&lt;code&gt;-S&lt;/code&gt; is not specified on the command line. (This was the default behavior up to PostgreSQL 9.1.)</source>
          <target state="translated">명령 행에 사용자 이름이 지정되지 않은 경우 사용자 이름을 묻고 명령 행에 &lt;code&gt;-d&lt;/code&gt; / &lt;code&gt;-D&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; / &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; / &lt;code&gt;-S&lt;/code&gt; 옵션이 지정되지 않은 경우에도 프롬프트합니다 . (이것은 PostgreSQL 9.1까지의 기본 동작이었습니다.)</target>
        </trans-unit>
        <trans-unit id="4d970e24b22fc0f6e277e6e1b9c10241b2293ff1" translate="yes" xml:space="preserve">
          <source>Prompting</source>
          <target state="translated">Prompting</target>
        </trans-unit>
        <trans-unit id="7b9401a5b590107a8b6c6f9423644051eff19629" translate="yes" xml:space="preserve">
          <source>Prompts can contain terminal control characters which, for example, change the color, background, or style of the prompt text, or change the title of the terminal window. In order for the line editing features of Readline to work properly, these non-printing control characters must be designated as invisible by surrounding them with &lt;code&gt;%[&lt;/code&gt; and &lt;code&gt;%]&lt;/code&gt;. Multiple pairs of these can occur within the prompt. For example:</source>
          <target state="translated">프롬프트에는 예를 들어 프롬프트 텍스트의 색상, 배경 또는 스타일을 변경하거나 터미널 창의 제목을 변경하는 터미널 제어 문자가 포함될 수 있습니다. Readline의 행 편집 기능이 올바르게 작동하려면 이러한 비 인쇄 제어 문자를 &lt;code&gt;%[&lt;/code&gt; 및 &lt;code&gt;%]&lt;/code&gt; 로 묶어서 보이지 않는 것으로 지정해야합니다 . 프롬프트에서 여러 쌍이 발생할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="068e4f6fa6576b1f7eb180c4d966c9c332e88e9a" translate="yes" xml:space="preserve">
          <source>Prompts the user to supply text, which is assigned to the variable &lt;code&gt;name&lt;/code&gt;. An optional prompt string, &lt;code&gt;text&lt;/code&gt;, can be specified. (For multiword prompts, surround the text with single quotes.)</source>
          <target state="translated">변수 &lt;code&gt;name&lt;/code&gt; 지정된 텍스트를 제공하도록 사용자에게 프롬프트합니다 . 선택적 프롬프트 문자열 인 &lt;code&gt;text&lt;/code&gt; 를 지정할 수 있습니다. 여러 단어 프롬프트의 경우 작은 따옴표로 텍스트를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="25a719c409be1921beafe5e788d439d93b07f5ff" translate="yes" xml:space="preserve">
          <source>Protocol head</source>
          <target state="translated">프로토콜 헤드</target>
        </trans-unit>
        <trans-unit id="1a9320a6ee345a64538cc41c73838b336f61862b" translate="yes" xml:space="preserve">
          <source>Protocol to use for submitting queries to the server:</source>
          <target state="translated">서버에 쿼리를 제출하는 데 사용할 프로토콜 :</target>
        </trans-unit>
        <trans-unit id="c1ac8c14d0bafdecefeefa05418d3e4bf8d46ea4" translate="yes" xml:space="preserve">
          <source>Provide an extension that will be stripped from all file names before deciding if they should be deleted. This is typically useful for cleaning up archives that have been compressed during storage, and therefore have had an extension added by the compression program. For example: &lt;code&gt;-x .gz&lt;/code&gt;.</source>
          <target state="translated">삭제 여부를 결정하기 전에 모든 파일 이름에서 제거 할 확장명을 제공하십시오. 이는 일반적으로 저장 중에 압축되어 압축 프로그램에 의해 확장명이 추가 된 아카이브를 정리하는 데 유용합니다. 예를 들어 &lt;code&gt;-x .gz&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5c7f8ac0c8dc8b2a3526acf0eb6df53ded419c3" translate="yes" xml:space="preserve">
          <source>Provide information about extensions of client certificate: extension name, extension value, and if it is a critical extension.</source>
          <target state="translated">클라이언트 인증서의 확장명에 대한 정보를 제공하십시오 : 확장명, 확장 값 및 중요한 확장명.</target>
        </trans-unit>
        <trans-unit id="7bc2350bc3b2039d9e0afed6b3606b6e8d63eb56" translate="yes" xml:space="preserve">
          <source>Provide the correct path to the database directory with &lt;code&gt;-D&lt;/code&gt;, or make sure that the environment variable &lt;code&gt;PGDATA&lt;/code&gt; is set. Also specify the name of the particular database you want to work in.</source>
          <target state="translated">&lt;code&gt;-D&lt;/code&gt; 를 사용하여 데이터베이스 디렉토리의 올바른 경로를 제공 하거나 환경 변수 &lt;code&gt;PGDATA&lt;/code&gt; 가 설정되어 있는지 확인하십시오 . 작업하려는 특정 데이터베이스의 이름도 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7fba2085619c6e697d55f8299ef0ca805ea435a8" translate="yes" xml:space="preserve">
          <source>Provider of the collation: &lt;code&gt;d&lt;/code&gt; = database default, &lt;code&gt;c&lt;/code&gt; = libc, &lt;code&gt;i&lt;/code&gt; = icu</source>
          <target state="translated">데이터 정렬 제공자 : &lt;code&gt;d&lt;/code&gt; = 데이터베이스 기본값, &lt;code&gt;c&lt;/code&gt; = libc, &lt;code&gt;i&lt;/code&gt; = icu</target>
        </trans-unit>
        <trans-unit id="b0a624c98e3417bfbf37f095267adcc37f1bdf46" translate="yes" xml:space="preserve">
          <source>Provider-specific version of the collation. This is recorded when the collation is created and then checked when it is used, to detect changes in the collation definition that could lead to data corruption.</source>
          <target state="translated">데이터 정렬의 공급자 별 버전입니다. 데이터 정렬이 생성 될 때 기록 된 다음 데이터가 손상 될 수있는 데이터 정렬 정의의 변경을 감지하기 위해 데이터 정렬이 사용될 때 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="813380993db87b7b78063d3b522dabe042e0e038" translate="yes" xml:space="preserve">
          <source>Provides information implicitly requested by the user, e.g., output from &lt;code&gt;VACUUM VERBOSE&lt;/code&gt;.</source>
          <target state="translated">사용자가 암시 적으로 요청한 정보 (예 : &lt;code&gt;VACUUM VERBOSE&lt;/code&gt; 출력)를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="de28296ee358cb5c7a7c1493346ff358cf83bc56" translate="yes" xml:space="preserve">
          <source>Provides information that might be helpful to users, e.g., notice of truncation of long identifiers.</source>
          <target state="translated">긴 식별자의 잘림과 같은 사용자에게 도움이 될 수있는 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b544ef7e317c450388c8e22bbca337ffb169c783" translate="yes" xml:space="preserve">
          <source>Provides successively-more-detailed information for use by developers.</source>
          <target state="translated">개발자가 사용할 수 있도록보다 상세하고 연속적인 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4085a3488b9b927970106c990aa79f6421cbdb9c" translate="yes" xml:space="preserve">
          <source>Provides warnings of likely problems, e.g., &lt;code&gt;COMMIT&lt;/code&gt; outside a transaction block.</source>
          <target state="translated">트랜잭션 블록 외부의 &lt;code&gt;COMMIT&lt;/code&gt; 와 같은 가능한 문제에 대한 경고를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ff659eeee4de0858f88b33fd3f4e7746d59a5ad2" translate="yes" xml:space="preserve">
          <source>Pseudo-Types</source>
          <target state="translated">Pseudo-Types</target>
        </trans-unit>
        <trans-unit id="4ece916bc1c6f84ddff998832df4ef0ea2024f0a" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: any</source>
          <target state="translated">의사 유형 : 모두</target>
        </trans-unit>
        <trans-unit id="b47d9ee644ffb538aa98ee437eec99c988a8d15d" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyarray</source>
          <target state="translated">의사 유형 : anyarray</target>
        </trans-unit>
        <trans-unit id="54a7e454a263cbffc9189e0007bfd9b7424c0230" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatible</source>
          <target state="translated">Pseudo-Types: anycompatible</target>
        </trans-unit>
        <trans-unit id="e1fcd8d0a37fb97a6ae1915b033c556308cf2f68" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblearray</source>
          <target state="translated">Pseudo-Types: anycompatiblearray</target>
        </trans-unit>
        <trans-unit id="8e05bbac8a7e912d1c04921f6f4547ac37465d26" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblenonarray</source>
          <target state="translated">Pseudo-Types: anycompatiblenonarray</target>
        </trans-unit>
        <trans-unit id="934be7c6aaed34ba9e8da8c91bad2e35901f6935" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblerange</source>
          <target state="translated">Pseudo-Types: anycompatiblerange</target>
        </trans-unit>
        <trans-unit id="22e5a6f841dae2418964bcaa84aa6a0a7f245549" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyelement</source>
          <target state="translated">의사 유형 : anyelement</target>
        </trans-unit>
        <trans-unit id="7a3f6d920428a6c8e5967a26fb4e46758728f6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyenum</source>
          <target state="translated">의사 유형 : anyenum</target>
        </trans-unit>
        <trans-unit id="84a873dc734548a1fe95e38fb333bb6d8bee10ef" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anynonarray</source>
          <target state="translated">의사 유형 : anynonarray</target>
        </trans-unit>
        <trans-unit id="3f53e360e11fbb973d5b222308c28fd5706c50dd" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyrange</source>
          <target state="translated">의사 유형 : anyrange</target>
        </trans-unit>
        <trans-unit id="df7657db40732623a8894c06b0028cc7640273e5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: cstring</source>
          <target state="translated">의사 유형 : cstring</target>
        </trans-unit>
        <trans-unit id="facd216b2d58500521e9c80e073f3f02e67f467b" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: event_trigger</source>
          <target state="translated">의사 유형 : event_trigger</target>
        </trans-unit>
        <trans-unit id="0c5c3ab69652fb55ae765ca8240e7c3bf40db9ce" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: fdw_handler</source>
          <target state="translated">의사 유형 : fdw_handler</target>
        </trans-unit>
        <trans-unit id="8d96c1feed021f0bd14872d446a70c55ec2a02e1" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: index_am_handler</source>
          <target state="translated">의사 유형 : index_am_handler</target>
        </trans-unit>
        <trans-unit id="8be67788a823313be97039f4a4b82ee6108f4b0f" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: internal</source>
          <target state="translated">의사 유형 : 내부</target>
        </trans-unit>
        <trans-unit id="c054109c5cb702aee10dbb32b0def25f56488525" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: language_handler</source>
          <target state="translated">의사 유형 : language_handler</target>
        </trans-unit>
        <trans-unit id="20a35bc47475d7650010ce766369afc8aabfb683" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: opaque</source>
          <target state="translated">의사 유형 : 불투명</target>
        </trans-unit>
        <trans-unit id="3674c8f90a9e09b98f639dae572ceb4253fed389" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: pg_ddl_command</source>
          <target state="translated">의사 유형 : pg_ddl_command</target>
        </trans-unit>
        <trans-unit id="c0325a47d21e05370cdf2a42ac118a73e10a48da" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: record</source>
          <target state="translated">의사 유형 : 레코드</target>
        </trans-unit>
        <trans-unit id="5724b565e2f347bb8125e3c1275c349af6b7742b" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: table_am_handler</source>
          <target state="translated">Pseudo-Types: table_am_handler</target>
        </trans-unit>
        <trans-unit id="d51593e94e15db79bb52c20320be4240d42cc899" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: trigger</source>
          <target state="translated">의사 유형 : 트리거</target>
        </trans-unit>
        <trans-unit id="4e60d0c02309d5445a01602a98db4ff91365738e" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: tsm_handler</source>
          <target state="translated">의사 유형 : tsm_handler</target>
        </trans-unit>
        <trans-unit id="17a7daa819e8dc7b6c6317f25efa7b50fffc1bab" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: unknown</source>
          <target state="translated">의사 유형 : 알 수 없음</target>
        </trans-unit>
        <trans-unit id="ad3dfebd9fb48eb5727ce6fe6f50844a86efc6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: void</source>
          <target state="translated">의사 유형 : void</target>
        </trans-unit>
        <trans-unit id="6c4dc2e4c074e37178229f858d4eb2dfaf30038f" translate="yes" xml:space="preserve">
          <source>Pseudo-types</source>
          <target state="translated">Pseudo-types</target>
        </trans-unit>
        <trans-unit id="cfb71764f58cd5ce25681b038025973a34e3322a" translate="yes" xml:space="preserve">
          <source>Pseudocode for a suitable &lt;code&gt;restore_command&lt;/code&gt; is:</source>
          <target state="translated">적합한 &lt;code&gt;restore_command&lt;/code&gt; 의 의사 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88d402501992d3fecf47cb438f8e35c65835d25d" translate="yes" xml:space="preserve">
          <source>PuTTY</source>
          <target state="translated">PuTTY</target>
        </trans-unit>
        <trans-unit id="e00441c49bf6cb62a4a537860a47c6b85de694f6" translate="yes" xml:space="preserve">
          <source>Publication</source>
          <target state="translated">Publication</target>
        </trans-unit>
        <trans-unit id="1c3179d96f0fdc556230a1396cdf463d5208ef82" translate="yes" xml:space="preserve">
          <source>Publications are different from schemas and do not affect how the table is accessed. Each table can be added to multiple publications if needed. Publications may currently only contain tables. Objects must be added explicitly, except when a publication is created for &lt;code&gt;ALL TABLES&lt;/code&gt;.</source>
          <target state="translated">게시는 스키마와 다르며 테이블에 액세스하는 방법에 영향을 미치지 않습니다. 필요한 경우 각 테이블을 여러 게시에 추가 할 수 있습니다. 발행물에는 현재 테이블 만 포함될 수 있습니다. &lt;code&gt;ALL TABLES&lt;/code&gt; 에 대한 공개가 작성되는 경우를 제외하고 오브젝트를 명시 적으로 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="58589c3756a9812c4f0f3e4873d1e342581ef4c0" translate="yes" xml:space="preserve">
          <source>Publications can choose to limit the changes they produce to any combination of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt;, similar to how triggers are fired by particular event types. By default, all operation types are replicated.</source>
          <target state="translated">발행물은 특정 이벤트 유형에 의해 트리거가 실행되는 방식과 유사하게 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 및 &lt;code&gt;TRUNCATE&lt;/code&gt; 의 조합으로 변경 사항을 제한하도록 선택할 수 있습니다 . 기본적으로 모든 작업 유형이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="18900d3584ded79ec60330adb7d33689eb4bab06" translate="yes" xml:space="preserve">
          <source>Put all query output into file &lt;code&gt;filename&lt;/code&gt;. This is equivalent to the command &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">모든 쿼리 출력을 파일 &lt;code&gt;filename&lt;/code&gt; 에 넣습니다 . 이것은 &lt;code&gt;\o&lt;/code&gt; 명령과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="877e59f50b56dd32ce7ae2762957d53396b6d9d9" translate="yes" xml:space="preserve">
          <source>Qualified joins</source>
          <target state="translated">자격을 갖춘 조인</target>
        </trans-unit>
        <trans-unit id="3eb467853e78723a75783ad177cb3b81ed614c2e" translate="yes" xml:space="preserve">
          <source>Qualified names are tedious to write, and it's often best not to wire a particular schema name into applications anyway. Therefore tables are often referred to by &lt;em&gt;unqualified names&lt;/em&gt;, which consist of just the table name. The system determines which table is meant by following a &lt;em&gt;search path&lt;/em&gt;, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.</source>
          <target state="translated">정규화 된 이름은 작성하기가 지루하므로 특정 스키마 이름을 응용 프로그램에 연결하지 않는 것이 가장 좋습니다. 따라서 테이블은 종종 테이블 이름으로 구성된 &lt;em&gt;규정되지 않은 이름으로&lt;/em&gt; 참조됩니다 . 시스템은 &lt;em&gt;검색 할 경로를&lt;/em&gt; 따라 어떤 테이블을 의미하는지 판별합니다.이 &lt;em&gt;경로&lt;/em&gt; 는 찾아 볼 스키마 목록입니다. 검색 경로에서 첫 번째로 일치하는 테이블이 원하는 테이블로 간주됩니다. 검색 경로에 일치하는 것이 없으면 데이터베이스의 다른 스키마에 일치하는 테이블 이름이 있어도 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="29bac22a5e177f5c85c1a4ee3241bc0678be6667" translate="yes" xml:space="preserve">
          <source>Quantifier</source>
          <target state="translated">Quantifier</target>
        </trans-unit>
        <trans-unit id="5370954c958801abba850882cd6534802d171dbc" translate="yes" xml:space="preserve">
          <source>Quantities of days, hours, minutes, and seconds can be specified without explicit unit markings. For example, &lt;code&gt;'1 12:59:10'&lt;/code&gt; is read the same as &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt;. Also, a combination of years and months can be specified with a dash; for example &lt;code&gt;'200-10'&lt;/code&gt; is read the same as &lt;code&gt;'200 years 10 months'&lt;/code&gt;. (These shorter forms are in fact the only ones allowed by the SQL standard, and are used for output when &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt;.)</source>
          <target state="translated">일, 시간, 분 및 초의 수량은 명시적인 단위 표시없이 지정할 수 있습니다. 예를 들어, &lt;code&gt;'1 12:59:10'&lt;/code&gt; 은 &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt; 와 동일하게 읽습니다 . 또한 연도와 월의 조합을 대시로 지정할 수 있습니다. 예를 들어 &lt;code&gt;'200-10'&lt;/code&gt; 은 &lt;code&gt;'200 years 10 months'&lt;/code&gt; 와 동일하게 읽습니다 . (이 짧은 형식은 실제로 SQL 표준에서 허용되는 유일한 형식이며 &lt;code&gt;IntervalStyle&lt;/code&gt; 이 &lt;code&gt;sql_standard&lt;/code&gt; 로 설정된 경우 출력에 사용됩니다 .)</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="a618b4be8d3ac72545f3085fe616d342b7139fba" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="translated">Query</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">쿼리 계획</target>
        </trans-unit>
        <trans-unit id="b65f94596db8e112e4f92d4f1acdc4bb922a6268" translate="yes" xml:space="preserve">
          <source>Query access - &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;COPY TO&lt;/code&gt;</source>
          <target state="translated">쿼리 액세스 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;COPY TO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b64c3246eb985e6edb480b51e216c4c9b501e9cb" translate="yes" xml:space="preserve">
          <source>Query access: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;COPY TO&lt;/code&gt;</source>
          <target state="translated">Query access: &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;COPY TO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb0b645346d8b6276dfe9ec30dfc16f0625329b2" translate="yes" xml:space="preserve">
          <source>Query performance can be improved dramatically in certain situations, particularly when most of the heavily accessed rows of the table are in a single partition or a small number of partitions. The partitioning substitutes for leading columns of indexes, reducing index size and making it more likely that the heavily-used parts of the indexes fit in memory.</source>
          <target state="translated">특정 상황에서, 특히 테이블에서 많이 액세스하는 행이 단일 파티션 또는 소수의 파티션에있는 경우 쿼리 성능이 크게 향상 될 수 있습니다. 파티셔닝은 인덱스의 선행 컬럼을 대체하여 인덱스 크기를 줄이고 인덱스의 사용량이 많은 부분이 메모리에 적합 할 가능성을 높입니다.</target>
        </trans-unit>
        <trans-unit id="1478c128e274ba1bf11d8cef131aa61f63dfccc5" translate="yes" xml:space="preserve">
          <source>Query planner</source>
          <target state="translated">Query planner</target>
        </trans-unit>
        <trans-unit id="198d3f9fde17e740d63372e1985f338979a36a67" translate="yes" xml:space="preserve">
          <source>Query tree (in the form of a &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the rule's action</source>
          <target state="translated">규칙의 조치에 대한 조회 트리 ( &lt;code&gt;nodeToString()&lt;/code&gt; 표현 양식 )</target>
        </trans-unit>
        <trans-unit id="a6002c5c363574bc4fe16e6079b6e23f671de172" translate="yes" xml:space="preserve">
          <source>Querying this view is similar to using &lt;code&gt;SHOW ALL&lt;/code&gt; but provides more detail. It is also more flexible, since it's possible to specify filter conditions or join against other relations.</source>
          <target state="translated">이 뷰를 쿼리하는 것은 &lt;code&gt;SHOW ALL&lt;/code&gt; 을 사용하는 것과 유사 하지만 자세한 내용을 제공합니다. 필터 조건을 지정하거나 다른 관계에 대해 결합 할 수 있기 때문에 더 유연합니다.</target>
        </trans-unit>
        <trans-unit id="33208d59d48811565117bf5ce172585c48018ea8" translate="yes" xml:space="preserve">
          <source>Quick Setup</source>
          <target state="translated">빠른 설치</target>
        </trans-unit>
        <trans-unit id="d17b23cd28367fcd27d5f878512b5e25587ec17b" translate="yes" xml:space="preserve">
          <source>Quits the psql program. In a script file, only execution of that script is terminated.</source>
          <target state="translated">psql 프로그램을 종료합니다. 스크립트 파일에서는 해당 스크립트의 실행 만 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="472cc72a1798e7f5b5bbceeb0bca7885d9d12809" translate="yes" xml:space="preserve">
          <source>Quoted identifiers can contain any character, except the character with code zero. (To include a double quote, write two double quotes.) This allows constructing table or column names that would otherwise not be possible, such as ones containing spaces or ampersands. The length limitation still applies.</source>
          <target state="translated">인용 부호는 코드가 0 인 문자를 제외한 모든 문자를 포함 할 수 있습니다. 큰 따옴표를 포함 시키려면 큰 따옴표 두 개를 쓰십시오. 이렇게하면 공백이나 앰퍼샌드를 포함하는 것과 같이 불가능한 테이블 또는 열 이름을 만들 수 있습니다. 길이 제한은 여전히 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a777f2b79b97851a7b855a9429a5ebde18f036d" translate="yes" xml:space="preserve">
          <source>Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers &lt;code&gt;FOO&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt;, and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; are considered the same by PostgreSQL, but &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; are different from these three and each other. (The folding of unquoted names to lower case in PostgreSQL is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, &lt;code&gt;foo&lt;/code&gt; should be equivalent to &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; not &lt;code&gt;&quot;foo&quot;&lt;/code&gt; according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)</source>
          <target state="translated">인용 부호를 인용하면 대소 문자를 구분하지만 인용되지 않은 이름은 항상 소문자로 접 힙니다. 예를 들어 식별자 &lt;code&gt;FOO&lt;/code&gt; , &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 는 PostgreSQL에서 동일한 것으로 간주되지만 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 는이 세 가지와 다릅니다. (PostgreSQL에서 인용되지 않은 이름을 소문자로 접는 것은 SQL 표준과 호환되지 않으므로 인용되지 않은 이름은 대문자로 &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 하므로 &lt;code&gt;foo&lt;/code&gt; 는 표준에 따라 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 가 아니라 &quot; FOO&quot; 와 동일해야합니다 . 휴대용 응용 프로그램을 작성하려면 항상 특정 이름을 인용하거나 인용하지 않는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="115088ecccb3000708edba51535672720b3a9ec6" translate="yes" xml:space="preserve">
          <source>Quoting rules for lexemes are the same as described previously for lexemes in &lt;code&gt;tsvector&lt;/code&gt;; and, as with &lt;code&gt;tsvector&lt;/code&gt;, any required normalization of words must be done before converting to the &lt;code&gt;tsquery&lt;/code&gt; type. The &lt;code&gt;to_tsquery&lt;/code&gt; function is convenient for performing such normalization:</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 에 대한 인용 규칙은 tsvector의 lexemes에 대해 이전에 설명한 것과 동일합니다 . &lt;code&gt;tsvector&lt;/code&gt; 와 마찬가지로 &lt;code&gt;tsquery&lt;/code&gt; 유형으로 변환하기 전에 필요한 단어 정규화를 수행해야합니다 . &lt;code&gt;to_tsquery&lt;/code&gt; 의 기능은 정상화를 수행하기에 편리합니다 :</target>
        </trans-unit>
        <trans-unit id="b79583615e1227273c81a5db2662b19ad81511a9" translate="yes" xml:space="preserve">
          <source>RADIUS Authentication</source>
          <target state="translated">RADIUS 인증</target>
        </trans-unit>
        <trans-unit id="a954f117477515ead533688d7e4ca8e606782c1a" translate="yes" xml:space="preserve">
          <source>RAM which is used by the processes common to an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;. It mirrors parts of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; files, provides a transient area for &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt;, and stores additional common information. Note that shared memory belongs to the complete instance, not to a single database.</source>
          <target state="translated">RAM which is used by the processes common to an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;. It mirrors parts of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; files, provides a transient area for &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt;, and stores additional common information. Note that shared memory belongs to the complete instance, not to a single database.</target>
        </trans-unit>
        <trans-unit id="7edcf4d8bc4d16588d07b8848c85c166b827fdc9" translate="yes" xml:space="preserve">
          <source>RD-Tree for one-dimensional array of int4 values</source>
          <target state="translated">int4 값의 1 차원 배열을위한 RD-Tree</target>
        </trans-unit>
        <trans-unit id="ff426c74c79867f7bf13e61c4f68d776339590f2" translate="yes" xml:space="preserve">
          <source>RDBMS</source>
          <target state="translated">RDBMS</target>
        </trans-unit>
        <trans-unit id="633fabe87d723214b65f1db2d624431f04c32334" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED</source>
          <target state="translated">재 지정 소유</target>
        </trans-unit>
        <trans-unit id="7b6e0d55ca8c5d1c174cbdd39c8e88014cc1d924" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED &amp;mdash; change the ownership of database objects owned by a database role</source>
          <target state="translated">REASSIGN OWNED &amp;mdash; 데이터베이스 역할이 소유 한 데이터베이스 객체의 소유권을 변경합니다</target>
        </trans-unit>
        <trans-unit id="d9cbb3a44e5994b48186107b069ebdee3f1ded8c" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW</source>
          <target state="translated">신선한 머티리얼 라이즈 뷰</target>
        </trans-unit>
        <trans-unit id="044770dd01baff51d49560ba1c3262f9b7a5e296" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW &amp;mdash; replace the contents of a materialized view</source>
          <target state="translated">REFRESH MATERIALIZED VIEW &amp;mdash; 구체화 된 뷰의 내용을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="d68887fcf8498472cf8183721de3d160d3d8a3bb" translate="yes" xml:space="preserve">
          <source>REINDEX &amp;mdash; rebuild indexes</source>
          <target state="translated">REINDEX &amp;mdash; 인덱스 재 구축</target>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="translated">릴리즈 포인트</target>
        </trans-unit>
        <trans-unit id="d33a2b2590d58d2a81b75053789ac9fe4aed380a" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT &amp;mdash; destroy a previously defined savepoint</source>
          <target state="translated">SAVEPOINT 릴리스 &amp;mdash; 이전에 정의 된 세이브 포인트를 폐기합니다</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="c157890fb1f2fab533caebe2d7bbafd037ee3504" translate="yes" xml:space="preserve">
          <source>RESET &amp;mdash; restore the value of a run-time parameter to the default value</source>
          <target state="translated">RESET &amp;mdash; 런타임 매개 변수 값을 기본값으로 복원</target>
        </trans-unit>
        <trans-unit id="d173eb30e8b9fe61478a02d722cdc111a632ca90" translate="yes" xml:space="preserve">
          <source>REVOKE</source>
          <target state="translated">REVOKE</target>
        </trans-unit>
        <trans-unit id="6d5e97f2b0b3bc9eba1622d19f4c033f547d2f10" translate="yes" xml:space="preserve">
          <source>REVOKE &amp;mdash; remove access privileges</source>
          <target state="translated">REVOKE &amp;mdash; 액세스 권한 제거</target>
        </trans-unit>
        <trans-unit id="285e88316b0d14455ae0c18a656f7e4c2153f4a5" translate="yes" xml:space="preserve">
          <source>RFC</source>
          <target state="translated">RFC</target>
        </trans-unit>
        <trans-unit id="709f9208ad6c95b7efb1b7aea432fe35dfaffef8" translate="yes" xml:space="preserve">
          <source>RFC 3629</source>
          <target state="translated">RFC 3629</target>
        </trans-unit>
        <trans-unit id="bf1bf54df970aa71d56934027fc34edd568d7730" translate="yes" xml:space="preserve">
          <source>RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt;. In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt;). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for characters that cannot be represented in the database encoding. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent single character for storage; this includes folding surrogate pairs into a single character.</source>
          <target state="translated">RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt; . In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt; ). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for characters that cannot be represented in the database encoding. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent single character for storage; this includes folding surrogate pairs into a single character.</target>
        </trans-unit>
        <trans-unit id="2e9a9191aa9d2f384e00599efbf540e0c6906e72" translate="yes" xml:space="preserve">
          <source>RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt;. In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt;). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for non-ASCII characters (those above &lt;code&gt;U+007F&lt;/code&gt;) unless the database encoding is UTF8. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent ASCII or UTF8 character for storage; this includes folding surrogate pairs into a single character.</source>
          <target state="translated">RFC 7159는 JSON 문자열이 &lt;code&gt;\uXXXX&lt;/code&gt; 로 표시된 유니 코드 이스케이프 시퀀스를 포함 할 수 있도록합니다 . &lt;code&gt;json&lt;/code&gt; 유형 의 입력 함수 에서 데이터베이스 인코딩에 관계없이 유니 코드 이스케이프가 허용되며 구문 정확성 (즉, 4 개의 16 진수가 &lt;code&gt;\u&lt;/code&gt; 뒤에 오는지 ) 에 대해서만 점검됩니다 . 그러나 &lt;code&gt;jsonb&lt;/code&gt; 의 입력 기능 은 더 엄격합니다. 데이터베이스 인코딩이 UTF8이 아닌 경우 비 ASCII 문자 ( &lt;code&gt;U+007F&lt;/code&gt; 이상)에 대한 유니 코드 이스케이프를 허용하지 않습니다 . &lt;code&gt;jsonb&lt;/code&gt; 의 유형은 거부 &lt;code&gt;\u0000&lt;/code&gt; 그 PostgreSQL의의 표현 될 수 없기 때문에 ( &lt;code&gt;text&lt;/code&gt; 유니 코드 기본 다국어 평면 외부의 문자를 지정하기 위해 유니 코드 대리 쌍을 사용하는 것이 정확해야합니다. 유효한 유니 코드 이스케이프는 저장을 위해 동등한 ASCII 또는 UTF8 문자로 변환됩니다. 여기에는 서로 게이트 쌍을 단일 문자로 접는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f7efe490a5991ad892dcbf815cf18cb496f3a528" translate="yes" xml:space="preserve">
          <source>RFC 7159 specifies that JSON strings should be encoded in UTF8. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</source>
          <target state="translated">RFC 7159 specifies that JSON strings should be encoded in UTF8. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</target>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="59a24d752da80d40b19238fcc5ec55b82fdc443e" translate="yes" xml:space="preserve">
          <source>ROLLBACK &amp;mdash; abort the current transaction</source>
          <target state="translated">ROLLBACK &amp;mdash; 현재 거래를 중단합니다</target>
        </trans-unit>
        <trans-unit id="e90e1449c7ef5b8820b08718a11f2da71c8d13be" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED</source>
          <target state="translated">롤백 준비</target>
        </trans-unit>
        <trans-unit id="48a2a83386a59b9b2fdad5e2cd3606242846748b" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED &amp;mdash; cancel a transaction that was earlier prepared for two-phase commit</source>
          <target state="translated">ROLLBACK PREPARED &amp;mdash; 이전에 2 단계 커밋을 위해 준비된 트랜잭션을 취소합니다</target>
        </trans-unit>
        <trans-unit id="61b9b7603e40508bc503ee4691737e409606fd90" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT</source>
          <target state="translated">저장 점으로 롤백</target>
        </trans-unit>
        <trans-unit id="d35ebfad8fd6f928fec74d3875a90f0020c24317" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT &amp;mdash; roll back to a savepoint</source>
          <target state="translated">저장 점으로 롤백 &amp;mdash; 저장 점으로 롤백</target>
        </trans-unit>
        <trans-unit id="5a8f649047eb74a2e378d2089854762723ab49ef" translate="yes" xml:space="preserve">
          <source>ROW EXCLUSIVE</source>
          <target state="translated">ROW 독점</target>
        </trans-unit>
        <trans-unit id="14cb7a6b49bc39b1cc0a49d9f930265fc065d308" translate="yes" xml:space="preserve">
          <source>ROW SHARE</source>
          <target state="translated">행 공유</target>
        </trans-unit>
        <trans-unit id="498fa9be2d32c469ac4cde84af98396f043472d9" translate="yes" xml:space="preserve">
          <source>Random access to mechanical disk storage is normally much more expensive than four times sequential access. However, a lower default is used (4.0) because the majority of random accesses to disk, such as indexed reads, are assumed to be in cache. The default value can be thought of as modeling random access as 40 times slower than sequential, while expecting 90% of random reads to be cached.</source>
          <target state="translated">기계 디스크 스토리지에 대한 임의 액세스는 일반적으로 순차 액세스의 4 배보다 훨씬 비쌉니다. 그러나 인덱싱 된 읽기와 같은 디스크에 대한 대부분의 임의 액세스는 캐시에있는 것으로 가정하기 때문에 더 낮은 기본값 (4.0)이 사용됩니다. 기본값은 임의 읽기의 90 %가 캐시 될 것으로 예상하면서 순차보다 40 배 느리게 임의 액세스를 모델링하는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="a12932077f1a02e9d49ac217bf48adda8287e429" translate="yes" xml:space="preserve">
          <source>Range Partitioning</source>
          <target state="translated">범위 파티셔닝</target>
        </trans-unit>
        <trans-unit id="150371fe63779db9b501fedeeefe579700f1d7d0" translate="yes" xml:space="preserve">
          <source>Range Types</source>
          <target state="translated">범위 유형</target>
        </trans-unit>
        <trans-unit id="53d929e1fb8ce766a0948419773ae86cbb9a3971" translate="yes" xml:space="preserve">
          <source>Range Types: daterange</source>
          <target state="translated">범위 유형 : 날짜 범위</target>
        </trans-unit>
        <trans-unit id="a3693b9f49e1d1bce857f56deb98c373c7aef619" translate="yes" xml:space="preserve">
          <source>Range Types: int4range</source>
          <target state="translated">범위 유형 : int4range</target>
        </trans-unit>
        <trans-unit id="8a82ac3da25ee609b2aeb0f2103e7ae7eeded8ea" translate="yes" xml:space="preserve">
          <source>Range Types: int8range</source>
          <target state="translated">범위 유형 : int8range</target>
        </trans-unit>
        <trans-unit id="744cc477872918910432194727cf36fb5632f253" translate="yes" xml:space="preserve">
          <source>Range Types: numrange</source>
          <target state="translated">범위 유형 : numrange</target>
        </trans-unit>
        <trans-unit id="f03184b38e676b9e59d518680c29ef81d475b159" translate="yes" xml:space="preserve">
          <source>Range Types: tsrange</source>
          <target state="translated">범위 유형 : tsrange</target>
        </trans-unit>
        <trans-unit id="010e27d6ddc0ef1f60c30945a5ab60be84e20b61" translate="yes" xml:space="preserve">
          <source>Range Types: tstzrange</source>
          <target state="translated">범위 유형 : tstzrange</target>
        </trans-unit>
        <trans-unit id="19eccf536154da069167603ea475b5f422e59b33" translate="yes" xml:space="preserve">
          <source>Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</source>
          <target state="translated">범위 및 목록 분할에는 btree 연산자 클래스가 필요하지만 해시 분할에는 해시 연산자 클래스가 필요합니다. 운영자 클래스를 명시 적으로 지정하지 않으면 적절한 유형의 기본 운영자 클래스가 사용됩니다. 기본 연산자 클래스가 없으면 오류가 발생합니다. 해시 파티셔닝을 사용하는 경우 사용되는 연산자 클래스는 지원 기능 2를 구현해야합니다 (자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;은 37.16.3 절&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="8895dad393fa948899c08b946bd0ebf4934f19ea" translate="yes" xml:space="preserve">
          <source>Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</source>
          <target state="translated">Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</target>
        </trans-unit>
        <trans-unit id="48652fff66c0aa4370d5c8fba0d573037de8ea3f" translate="yes" xml:space="preserve">
          <source>Range types</source>
          <target state="translated">범위 유형</target>
        </trans-unit>
        <trans-unit id="152d9f920b5a18dd2e34c468823a545e1a1c8d0c" translate="yes" xml:space="preserve">
          <source>Range types are data types representing a range of values of some element type (called the range's &lt;em&gt;subtype&lt;/em&gt;). For instance, ranges of &lt;code&gt;timestamp&lt;/code&gt; might be used to represent the ranges of time that a meeting room is reserved. In this case the data type is &lt;code&gt;tsrange&lt;/code&gt; (short for &amp;ldquo;timestamp range&amp;rdquo;), and &lt;code&gt;timestamp&lt;/code&gt; is the subtype. The subtype must have a total order so that it is well-defined whether element values are within, before, or after a range of values.</source>
          <target state="translated">범위 유형은 일부 요소 유형의 값 범위를 나타내는 데이터 유형입니다 (범위의 &lt;em&gt;하위 유형&lt;/em&gt; 이라고 함 ). 예를 들어, &lt;code&gt;timestamp&lt;/code&gt; 범위는 미팅 룸이 예약 된 시간 범위를 나타내는 데 사용될 수 있습니다. 이 경우 데이터 유형은 &lt;code&gt;tsrange&lt;/code&gt; ( &quot;타임 스탬프 범위&quot;의 약자)이고 &lt;code&gt;timestamp&lt;/code&gt; 는 하위 유형입니다. 하위 유형은 요소 순서가 값 범위 내, 이전 또는 이후에 잘 정의되도록 총 순서를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="10501cb18e09508ff10076b64f0cc428df172882" translate="yes" xml:space="preserve">
          <source>Range types are useful because they represent many element values in a single range value, and because concepts such as overlapping ranges can be expressed clearly. The use of time and date ranges for scheduling purposes is the clearest example; but price ranges, measurement ranges from an instrument, and so forth can also be useful.</source>
          <target state="translated">범위 유형은 단일 범위 값으로 많은 요소 값을 나타내며 범위가 겹치는 등의 개념을 명확하게 표현할 수 있기 때문에 유용합니다. 스케줄링 목적으로 시간 및 날짜 범위를 사용하는 것이 가장 명확한 예입니다. 그러나 가격 범위, 기기의 측정 범위 등도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e16fe42dfe025a7c0b1d71163b5e1f4ac592f248" translate="yes" xml:space="preserve">
          <source>Range: &amp;#x27;[2011-01-01,2011-03-01)&amp;#x27;::tsrange @&amp;gt; &amp;#x27;2011-01-10&amp;#x27;::timestamp</source>
          <target state="translated">Range: '[2011-01-01,2011-03-01)'::tsrange @&amp;gt; '2011-01-10'::timestamp</target>
        </trans-unit>
        <trans-unit id="a9a5ac13ea7278862eadf429fec1a6d53e07ac45" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;amp;</source>
          <target state="translated">범위 : &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="5138aeeb99cbf6ebff075b87fadb3ac93d6e5193" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;gt;</source>
          <target state="translated">범위 : &amp;amp;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d72ae278ac597396584e8c02a1741c100edfca80" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;lt;</source>
          <target state="translated">범위 : &amp;amp; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e3887b799dded8092c6301d5be1aefa3d0dd6d3a" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;</source>
          <target state="translated">사거리 :&amp;gt;</target>
        </trans-unit>
        <trans-unit id="798e0e9e88e4e32e73dc02d11defb73693566666" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;&amp;gt;</source>
          <target state="translated">범위 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e6946ee5453b7aafe3852ad6a413e04bbe70b3f" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;=</source>
          <target state="translated">범위 :&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="50827e59e82c8b9b94902deba9c0cd7d740e2584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;</source>
          <target state="translated">범위 : &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f6f037363a29496f0699d11afa7d6227f3803584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;gt;</source>
          <target state="translated">사거리 : &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f6f0031a9d4355c819448b50757c3487642b742" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;lt;</source>
          <target state="translated">범위 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="278020aa13725565b03e23b783ab30ead6a5d971" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;=</source>
          <target state="translated">범위 : &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="8fd029989c2ed32bcffaf5576523df4934fcb6aa" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;@</source>
          <target state="translated">범위 : &amp;lt;@</target>
        </trans-unit>
        <trans-unit id="519ae404f51d7cdda5157d728a679f6ac34e633b" translate="yes" xml:space="preserve">
          <source>Range: *</source>
          <target state="translated">범위 : *</target>
        </trans-unit>
        <trans-unit id="2eb640bcc9834e28157d86493366688f7c5d38a2" translate="yes" xml:space="preserve">
          <source>Range: +</source>
          <target state="translated">사거리 : +</target>
        </trans-unit>
        <trans-unit id="c8e5cef097bd3910fe5e0190257f34cad206f4c2" translate="yes" xml:space="preserve">
          <source>Range: -</source>
          <target state="translated">사거리 :-</target>
        </trans-unit>
        <trans-unit id="b30626f6a47ecd0abac84acd28b5ffc7444c5618" translate="yes" xml:space="preserve">
          <source>Range: -|-</source>
          <target state="translated">범위 :-|-</target>
        </trans-unit>
        <trans-unit id="1c3066fd7e6819e63ddca17dcd69c108489cf890" translate="yes" xml:space="preserve">
          <source>Range: 42 &amp;lt;@ int4range</source>
          <target state="translated">Range: 42 &amp;lt;@ int4range</target>
        </trans-unit>
        <trans-unit id="d7943ac61251b0e439e59453d3c9bd4d92cbe7db" translate="yes" xml:space="preserve">
          <source>Range: =</source>
          <target state="translated">범위 : =</target>
        </trans-unit>
        <trans-unit id="5c9fd1a7ffb6cd6aed893574001127ea193ec53e" translate="yes" xml:space="preserve">
          <source>Range: @&amp;gt;</source>
          <target state="translated">범위 : @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5345a847755c33035bc2591758bc060d8da94779" translate="yes" xml:space="preserve">
          <source>Range: NULL</source>
          <target state="translated">Range: NULL</target>
        </trans-unit>
        <trans-unit id="83729c8bd9a31e069f9cad56b7e2bfe6d4220671" translate="yes" xml:space="preserve">
          <source>Range: int4range &amp;lt;@ int4range</source>
          <target state="translated">Range: int4range &amp;lt;@ int4range</target>
        </trans-unit>
        <trans-unit id="b6abcc684ac42f015a5d77cb6bf7ae1803faa802" translate="yes" xml:space="preserve">
          <source>Range: int4range @&amp;gt; int4range</source>
          <target state="translated">Range: int4range @&amp;gt; int4range</target>
        </trans-unit>
        <trans-unit id="7cbb9c6dd7fa8194a072796ecd9b741b996bd7a3" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;amp; int8range</source>
          <target state="translated">Range: int8range &amp;amp;&amp;amp; int8range</target>
        </trans-unit>
        <trans-unit id="4b0bb91169217b4e29cfb76dc5581d25ed6b251b" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;gt; int8range</source>
          <target state="translated">Range: int8range &amp;amp;&amp;gt; int8range</target>
        </trans-unit>
        <trans-unit id="ff9df88e5abad3c50f6d014794683bf550b4afb2" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;lt; int8range</source>
          <target state="translated">Range: int8range &amp;amp;&amp;lt; int8range</target>
        </trans-unit>
        <trans-unit id="e00a7aa8e9c2301c9240fdd0b4875fa5651174d5" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;gt;&amp;gt; int8range</source>
          <target state="translated">Range: int8range &amp;gt;&amp;gt; int8range</target>
        </trans-unit>
        <trans-unit id="3040a7f95f19ee36e36e4e5ae3a596d709298aa3" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;lt;&amp;lt; int8range</source>
          <target state="translated">Range: int8range &amp;lt;&amp;lt; int8range</target>
        </trans-unit>
        <trans-unit id="6d06790af02020de10dd09609a797d037f242e11" translate="yes" xml:space="preserve">
          <source>Range: int8range * int8range</source>
          <target state="translated">Range: int8range * int8range</target>
        </trans-unit>
        <trans-unit id="79c4e2dbf1d6156da3d7eac97068e72a3e022465" translate="yes" xml:space="preserve">
          <source>Range: int8range - int8range</source>
          <target state="translated">Range: int8range - int8range</target>
        </trans-unit>
        <trans-unit id="5df42bdba4fe9375d8ecde65d144985e2fa123da" translate="yes" xml:space="preserve">
          <source>Range: isempty</source>
          <target state="translated">범위 : 빈</target>
        </trans-unit>
        <trans-unit id="9447a77bf49896166cdfa5ac004b88e4656caa30" translate="yes" xml:space="preserve">
          <source>Range: isempty)</source>
          <target state="translated">Range: isempty)</target>
        </trans-unit>
        <trans-unit id="7cf1b8f7817c42e33a217bf084388d7956ddb800" translate="yes" xml:space="preserve">
          <source>Range: lower</source>
          <target state="translated">범위 : 낮게</target>
        </trans-unit>
        <trans-unit id="3534ccb32cb9b587caf3133de3f56d8a17947373" translate="yes" xml:space="preserve">
          <source>Range: lower)</source>
          <target state="translated">Range: lower)</target>
        </trans-unit>
        <trans-unit id="41561998090e13cce0a01b7784c0b3af97242f0c" translate="yes" xml:space="preserve">
          <source>Range: lower_inc</source>
          <target state="translated">범위 : lower_inc</target>
        </trans-unit>
        <trans-unit id="49ede64eaa7a5da6409899cef575840c6dedca3b" translate="yes" xml:space="preserve">
          <source>Range: lower_inc)</source>
          <target state="translated">Range: lower_inc)</target>
        </trans-unit>
        <trans-unit id="2cc53727481a0808617729c756b990601f85da64" translate="yes" xml:space="preserve">
          <source>Range: lower_inf</source>
          <target state="translated">범위 : lower_inf</target>
        </trans-unit>
        <trans-unit id="2a99c9126b3c8019058e523ae759bf66bab6b3d8" translate="yes" xml:space="preserve">
          <source>Range: lower_inf&amp;#x27;::daterange)</source>
          <target state="translated">Range: lower_inf'::daterange)</target>
        </trans-unit>
        <trans-unit id="34730d102b3ffad4351ea1715389e7a70c0cc7ec" translate="yes" xml:space="preserve">
          <source>Range: numrange + numrange</source>
          <target state="translated">Range: numrange + numrange</target>
        </trans-unit>
        <trans-unit id="2a1e61e3344f0ee0e36aee5f2d966cf254ba621b" translate="yes" xml:space="preserve">
          <source>Range: numrange -|- numrange</source>
          <target state="translated">Range: numrange -|- numrange</target>
        </trans-unit>
        <trans-unit id="4ace460c813343c7a659f92c463b48f8e9497c10" translate="yes" xml:space="preserve">
          <source>Range: range_merge</source>
          <target state="translated">범위 : range_merge</target>
        </trans-unit>
        <trans-unit id="25aa728cd66f80690db18e571734403309e220fa" translate="yes" xml:space="preserve">
          <source>Range: range_merge&amp;#x27;::int4range, &amp;#x27;[3,4)&amp;#x27;::int4range)</source>
          <target state="translated">Range: range_merge'::int4range, '[3,4)'::int4range)</target>
        </trans-unit>
        <trans-unit id="1f28a3c6d0b4768f8b324bd884ab8839d0315ae6" translate="yes" xml:space="preserve">
          <source>Range: upper</source>
          <target state="translated">범위 : 상단</target>
        </trans-unit>
        <trans-unit id="04161af92454051c0f045081c7825aa3a8e93a1f" translate="yes" xml:space="preserve">
          <source>Range: upper)</source>
          <target state="translated">Range: upper)</target>
        </trans-unit>
        <trans-unit id="254cd3d46f3b050314f0a32b8ccaf21bfef8428c" translate="yes" xml:space="preserve">
          <source>Range: upper_inc</source>
          <target state="translated">범위 : upper_inc</target>
        </trans-unit>
        <trans-unit id="96dc0693990a3ee24e3cb9591cf140f45bea8755" translate="yes" xml:space="preserve">
          <source>Range: upper_inc)</source>
          <target state="translated">Range: upper_inc)</target>
        </trans-unit>
        <trans-unit id="15a1bf88678aec9c8e638569577cf68508681fb4" translate="yes" xml:space="preserve">
          <source>Range: upper_inf</source>
          <target state="translated">범위 : upper_inf</target>
        </trans-unit>
        <trans-unit id="97b0a2bf6f728a07761880c6d6ff4cec56f9089c" translate="yes" xml:space="preserve">
          <source>Range: upper_inf&amp;#x27;::daterange)</source>
          <target state="translated">Range: upper_inf'::daterange)</target>
        </trans-unit>
        <trans-unit id="16773cb5b6a39b09024cc881604849b2ada6e7b5" translate="yes" xml:space="preserve">
          <source>Ranking attempts to measure how relevant documents are to a particular query, so that when there are many matches the most relevant ones can be shown first. PostgreSQL provides two predefined ranking functions, which take into account lexical, proximity, and structural information; that is, they consider how often the query terms appear in the document, how close together the terms are in the document, and how important is the part of the document where they occur. However, the concept of relevancy is vague and very application-specific. Different applications might require additional information for ranking, e.g., document modification time. The built-in ranking functions are only examples. You can write your own ranking functions and/or combine their results with additional factors to fit your specific needs.</source>
          <target state="translated">순위는 특정 쿼리와 관련이있는 문서를 측정하려고 시도하므로 일치하는 항목이 많을 때 가장 관련성이 높은 문서를 먼저 표시 할 수 있습니다. PostgreSQL은 사전, 순위 및 구조 정보를 고려한 사전 정의 된 두 가지 순위 기능을 제공합니다. 즉, 쿼리 용어가 문서에 표시되는 빈도, 용어가 문서에 얼마나 가깝게 존재하는지, 그리고 문서에서 발생하는 부분이 얼마나 중요한지를 고려합니다. 그러나 관련성의 개념은 모호하고 매우 응용 프로그램에 따라 다릅니다. 다른 응용 프로그램은 문서 수정 시간과 같은 순위 지정을위한 추가 정보가 필요할 수 있습니다. 내장 순위 기능은 예제 일뿐입니다. 자신의 순위 기능을 작성하거나 결과를 특정 요소에 맞게 추가 요소와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d643b0d7aa4393d4d9da3687d8322d0a81e0cab" translate="yes" xml:space="preserve">
          <source>Ranking can be expensive since it requires consulting the &lt;code&gt;tsvector&lt;/code&gt; of each matching document, which can be I/O bound and therefore slow. Unfortunately, it is almost impossible to avoid since practical queries often result in large numbers of matches.</source>
          <target state="translated">일치하는 각 문서 의 &lt;code&gt;tsvector&lt;/code&gt; 를 참조해야하므로 순위가 비쌀 수 있으며 , 이는 I / O 바인딩이 가능하고 느릴 수 있습니다. 불행히도 실제 쿼리는 종종 많은 수의 일치를 유발하므로 피하는 것이 거의 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="19afdfa41a0ed827f969267ae295f3b913f28c70" translate="yes" xml:space="preserve">
          <source>Ranks vectors based on the frequency of their matching lexemes.</source>
          <target state="translated">일치하는 exemes의 빈도를 기준으로 벡터의 순위를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="236c736d2b53bb667d136c499a0d1ba402fdd25d" translate="yes" xml:space="preserve">
          <source>Rather than look at &lt;code&gt;pg_statistic&lt;/code&gt; directly, it's better to look at its view &lt;a href=&quot;view-pg-stats&quot;&gt;&lt;code&gt;pg_stats&lt;/code&gt;&lt;/a&gt; when examining the statistics manually. &lt;code&gt;pg_stats&lt;/code&gt; is designed to be more easily readable. Furthermore, &lt;code&gt;pg_stats&lt;/code&gt; is readable by all, whereas &lt;code&gt;pg_statistic&lt;/code&gt; is only readable by a superuser. (This prevents unprivileged users from learning something about the contents of other people's tables from the statistics. The &lt;code&gt;pg_stats&lt;/code&gt; view is restricted to show only rows about tables that the current user can read.) For example, we might do:</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 을 직접 보는 것보다는 통계를 수동으로 검사 할 때 &lt;a href=&quot;view-pg-stats&quot;&gt; &lt;code&gt;pg_stats&lt;/code&gt; &lt;/a&gt; 의보기를 보는 것이 좋습니다 . &lt;code&gt;pg_stats&lt;/code&gt; 는보다 쉽게 ​​읽을 수 있도록 설계되었습니다. 또한 &lt;code&gt;pg_stats&lt;/code&gt; 는 모두 읽을 수있는 반면 &lt;code&gt;pg_statistic&lt;/code&gt; 은 수퍼 유저 만 읽을 수 있습니다. (이것은 권한이없는 사용자가 통계에서 다른 사람의 테이블 내용에 대해 무언가를 배우지 못하게합니다. &lt;code&gt;pg_stats&lt;/code&gt; 보기는 현재 사용자가 읽을 수있는 테이블에 대한 행만 표시하도록 제한됩니다.) 예를 들어, 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2bec5c61f15a407e756ab05a685ad23bb7e5511" translate="yes" xml:space="preserve">
          <source>Raw encryption</source>
          <target state="translated">원시 암호화</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
