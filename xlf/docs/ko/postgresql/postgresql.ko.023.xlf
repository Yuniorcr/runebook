<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="b6017b9e9e841e1ed3391e353ec7b6f77818cd5d" translate="yes" xml:space="preserve">
          <source>The slice syntaxes with omitted &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; can be used too, but only when updating an array value that is not NULL or zero-dimensional (otherwise, there is no existing subscript limit to substitute).</source>
          <target state="translated">&lt;code&gt;lower-bound&lt;/code&gt; 및 / 또는 &lt;code&gt;upper-bound&lt;/code&gt; 을 생략 한 슬라이스 구문 도 사용할 수 있지만 NULL 또는 0 차원이 아닌 배열 값을 업데이트하는 경우에만 사용할 수 있습니다 (그렇지 않으면 대체 할 기존 첨자 제한이 없습니다).</target>
        </trans-unit>
        <trans-unit id="b0a06932e4c9d25d4fab3d4aa77750dbf6cafc0f" translate="yes" xml:space="preserve">
          <source>The slot type - &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</source>
          <target state="translated">슬롯 유형- &lt;code&gt;physical&lt;/code&gt; 또는 &lt;code&gt;logical&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2a58ef414f79a96eef654d0cb5a2b339ceb599" translate="yes" xml:space="preserve">
          <source>The slot type: &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</source>
          <target state="translated">The slot type: &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4042361f65f02965ea45d409682bd67eb2ab934d" translate="yes" xml:space="preserve">
          <source>The sole disadvantage of increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; (and &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; along with it) is that the &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; subdirectories of the database cluster will take more space, because it must store the commit status and (if &lt;code&gt;track_commit_timestamp&lt;/code&gt; is enabled) timestamp of all transactions back to the &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; horizon. The commit status uses two bits per transaction, so if &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; is set to its maximum allowed value of two billion, &lt;code&gt;pg_xact&lt;/code&gt; can be expected to grow to about half a gigabyte and &lt;code&gt;pg_commit_ts&lt;/code&gt; to about 20GB. If this is trivial compared to your total database size, setting &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; to its maximum allowed value is recommended. Otherwise, set it depending on what you are willing to allow for &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; storage. (The default, 200 million transactions, translates to about 50MB of &lt;code&gt;pg_xact&lt;/code&gt; storage and about 2GB of &lt;code&gt;pg_commit_ts&lt;/code&gt; storage.)</source>
          <target state="translated">&lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; (및 &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 와 함께) 를 증가시키는 유일한 단점은 데이터베이스 클러스터 의 &lt;code&gt;pg_xact&lt;/code&gt; 및 &lt;code&gt;pg_commit_ts&lt;/code&gt; 서브 디렉토리가 커밋 상태를 저장해야하고 ( &lt;code&gt;track_commit_timestamp&lt;/code&gt; 가 활성화 된 경우) 모든 트랜잭션의 타임 스탬프를 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 지평선. 커밋 상태는 트랜잭션 당 2 비트를 사용하므로 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 가 최대 허용 값인 20 억으로 &lt;code&gt;pg_xact&lt;/code&gt; 경우 pg_xact 는 약 기가 바이트 및 &lt;code&gt;pg_commit_ts&lt;/code&gt; 로 증가 할 수 있습니다.약 20GB까지 이것이 전체 데이터베이스 크기와 비교하여 사소한 경우 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 를 최대 허용 값으로 설정하는 것이 좋습니다. 그렇지 않으면, &lt;code&gt;pg_xact&lt;/code&gt; 및 &lt;code&gt;pg_commit_ts&lt;/code&gt; 스토리지 에 허용하려는 대상에 따라 설정하십시오 . 기본적으로 2 억 건의 트랜잭션은 약 50MB의 &lt;code&gt;pg_xact&lt;/code&gt; 스토리지와 약 2GB의 &lt;code&gt;pg_commit_ts&lt;/code&gt; 스토리지 로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="420d354e00f2d98f43f69fb5c85b3c9d2f0a5c6c" translate="yes" xml:space="preserve">
          <source>The sort expression(s) can be any expression that would be valid in the query's select list. An example is:</source>
          <target state="translated">정렬 식은 쿼리의 선택 목록에서 유효한 식일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af64fa9d73d05dafcf40b04a10bc43a2c675e4b9" translate="yes" xml:space="preserve">
          <source>The sort position of this enum value within its enum type</source>
          <target state="translated">열거 형 내에서이 열거 형 값의 정렬 위치</target>
        </trans-unit>
        <trans-unit id="267381ff52d7207cad90e1b1efb3d2ae56d6e149" translate="yes" xml:space="preserve">
          <source>The source directory &lt;code&gt;contrib/intarray/bench&lt;/code&gt; contains a benchmark test suite, which can be run against an installed PostgreSQL server. (It also requires &lt;code&gt;DBD::Pg&lt;/code&gt; to be installed.) To run:</source>
          <target state="translated">소스 디렉토리 &lt;code&gt;contrib/intarray/bench&lt;/code&gt; 에는 설치된 PostgreSQL 서버에 대해 실행할 수있는 벤치 마크 테스트 스위트가 포함되어 있습니다. ( &lt;code&gt;DBD::Pg&lt;/code&gt; 도 설치해야합니다.) 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f4b684dc4cf3d0e7f8017a75669ef677ed19f660" translate="yes" xml:space="preserve">
          <source>The source encoding name.</source>
          <target state="translated">소스 인코딩 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5b4632e063d85e50c766912ad7e51e33ef8bf318" translate="yes" xml:space="preserve">
          <source>The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PUBLIC&lt;/code&gt; 이라는 특수한 &quot;역할&quot;이름을 사용하여 시스템의 모든 역할에 권한을 부여 할 수 있습니다. 또한 데이터베이스 사용자가 많은 경우 권한을 관리 할 수 ​​있도록&amp;ldquo;그룹&amp;rdquo;역할을 설정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;21 장&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0711f789242d7822af841eb7515278a8210c6c3f" translate="yes" xml:space="preserve">
          <source>The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</source>
          <target state="translated">The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d534e247b3040487a992ce1f01908ab3c5c62964" translate="yes" xml:space="preserve">
          <source>The special entry &lt;code&gt;*&lt;/code&gt; matches any standby name.</source>
          <target state="translated">특수 항목 &lt;code&gt;*&lt;/code&gt; 는 모든 대기 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="31bc549a6a2aaa2d8b0391bf2c83e80b6eb59358" translate="yes" xml:space="preserve">
          <source>The special field name &lt;code&gt;*&lt;/code&gt; means &amp;ldquo;all fields&amp;rdquo;, as further explained in &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="translated">특수 필드 이름 &lt;code&gt;*&lt;/code&gt; 은 &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;8.16.5 절&lt;/a&gt; 에서 더 설명 된대로&amp;ldquo;모든 필드&amp;rdquo;를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="758ed933ac597fbff2a112b5d5781d2521256906" translate="yes" xml:space="preserve">
          <source>The special privileges of the object owner (i.e., the right to do &lt;code&gt;DROP&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, etc.) are always implicit in being the owner, and cannot be granted or revoked. But the object owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others.</source>
          <target state="translated">객체 소유자의 특수 권한 (즉, &lt;code&gt;DROP&lt;/code&gt; , &lt;code&gt;GRANT&lt;/code&gt; , &lt;code&gt;REVOKE&lt;/code&gt; 등 을 수행 할 수있는 권한 )은 항상 소유자임을 암시하며 부여하거나 취소 할 수 없습니다. 그러나 객체 소유자는 자신과 다른 사람을 위해 테이블을 읽기 전용으로 만드는 등의 일반적인 권한을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c644ef37e4f8fad5de2f6806820052ad171113ce" translate="yes" xml:space="preserve">
          <source>The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</source>
          <target state="translated">특수 테이블 함수 &lt;code&gt;UNNEST&lt;/code&gt; 는 임의의 수의 배열 매개 변수로 호출 될 수 있으며, 각 매개 변수에 대해 &lt;code&gt;UNNEST&lt;/code&gt; ( &lt;a href=&quot;functions-array&quot;&gt;섹션 9.18&lt;/a&gt; )가 개별적으로 호출되고 &lt;code&gt;ROWS FROM&lt;/code&gt; 구문을 사용하여 결합 된 것처럼 해당하는 수의 열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="394c1d359ef1d3b89124b30daad8e16a978cd018" translate="yes" xml:space="preserve">
          <source>The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.19&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</source>
          <target state="translated">The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.19&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</target>
        </trans-unit>
        <trans-unit id="e3760930d6be21baabcd516fd8aaa6bbd0e31deb" translate="yes" xml:space="preserve">
          <source>The special values &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt; may be used when creating a range partition to indicate that there is no lower or upper bound on the column's value. For example, a partition defined using &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; allows any values less than 10, and a partition defined using &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; allows any values greater than or equal to 10.</source>
          <target state="translated">범위 파티션을 작성할 때 특수 값 &lt;code&gt;MINVALUE&lt;/code&gt; 및 &lt;code&gt;MAXVALUE&lt;/code&gt; 를 사용하여 열 값에 하한 또는 상한이 없음을 표시 할 수 있습니다. 예를 들어, &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; 사용하여 정의 된 파티션은 10보다 작은 값을 허용하고 &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; 사용하여 정의 된 파티션은 10 보다 크거나 같은 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7e90fbaeae1d1655b1bb6f95cb13335bf4d3a214" translate="yes" xml:space="preserve">
          <source>The specially treated variables are:</source>
          <target state="translated">특별히 처리 된 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b586ed754bd73f7164a8d06b3ccf052091b7071" translate="yes" xml:space="preserve">
          <source>The specific data that a BRIN index will store, as well as the specific queries that the index will be able to satisfy, depend on the operator class selected for each column of the index. Data types having a linear sort order can have operator classes that store the minimum and maximum value within each block range, for instance; geometrical types might store the bounding box for all the objects in the block range.</source>
          <target state="translated">BRIN 인덱스가 저장할 특정 데이터와 인덱스가 만족할 수있는 특정 쿼리는 인덱스의 각 열에 대해 선택된 연산자 클래스에 따라 다릅니다. 선형 정렬 순서를 갖는 데이터 유형은 예를 들어 각 블록 범위 내에서 최소값과 최대 값을 저장하는 연산자 클래스를 가질 수 있습니다. 기하학적 유형은 블록 범위의 모든 객체에 대한 경계 상자를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c67370c9102fee266def76d5516bcf8df8f39414" translate="yes" xml:space="preserve">
          <source>The specific function that is referenced by a function call is determined using the following procedure.</source>
          <target state="translated">함수 호출이 참조하는 특정 함수는 다음 절차를 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d4491b1318b4f57536f43e332d74ca6d054454c5" translate="yes" xml:space="preserve">
          <source>The specific operator that is referenced by an operator expression is determined using the following procedure. Note that this procedure is indirectly affected by the precedence of the operators involved, since that will determine which sub-expressions are taken to be the inputs of which operators. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">연산자식이 참조하는 특정 연산자는 다음 절차에 따라 결정됩니다. 이 프로시 저는 관련된 연산자의 우선 순위에 의해 간접적으로 영향을받습니다. 이는 어떤 하위 표현식이 어떤 연산자의 입력으로 간주되는지 결정하기 때문입니다. 자세한 정보는 &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;4.1.6 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="56960e04e804eb4178adc815aab5ca82c4358153" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Index zero corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</source>
          <target state="translated">The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Index zero corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</target>
        </trans-unit>
        <trans-unit id="bf52c4d6cf2c8133df1aca73cde50bf658361fd0" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Zero index corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</source>
          <target state="translated">지정된 &lt;code&gt;index&lt;/code&gt; 은 정수일 수 있으며 단일 숫자 값을 리턴하는 표현식 일 수 있으며 자동으로 정수로 캐스트됩니다. 인덱스 0은 첫 번째 배열 요소에 해당합니다. &lt;code&gt;last&lt;/code&gt; 키워드를 사용하여 마지막 배열 요소를 나타낼 수도 있습니다. 이는 길이를 알 수없는 배열을 처리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8859206cebb9c86d9bc85a5c793d72f97cbfcda7" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;role_name&lt;/code&gt; must be a role that the current session user is a member of. (If the session user is a superuser, any role can be selected.)</source>
          <target state="translated">지정된 &lt;code&gt;role_name&lt;/code&gt; 은 현재 세션 사용자가 속한 역할이어야합니다. 세션 사용자가 수퍼 유저 인 경우 모든 역할을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afd818a1af1c31122dbe5ccb86326656bebfdabf" translate="yes" xml:space="preserve">
          <source>The specified locale and encoding settings must match, or an error will be reported.</source>
          <target state="translated">지정된 로케일 및 인코딩 설정이 일치해야합니다. 그렇지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="0c30502cb792c5bd66e555818ae0268a7466dc40" translate="yes" xml:space="preserve">
          <source>The specified null string is sent by &lt;code&gt;COPY TO&lt;/code&gt; without adding any backslashes; conversely, &lt;code&gt;COPY FROM&lt;/code&gt; matches the input against the null string before removing backslashes. Therefore, a null string such as &lt;code&gt;\N&lt;/code&gt; cannot be confused with the actual data value &lt;code&gt;\N&lt;/code&gt; (which would be represented as &lt;code&gt;\\N&lt;/code&gt;).</source>
          <target state="translated">지정된 널 문자열은 백 슬래시를 추가하지 않고 &lt;code&gt;COPY TO&lt;/code&gt; 에 의해 전송됩니다 . 반대로, &lt;code&gt;COPY FROM&lt;/code&gt; 은 백 슬래시를 제거하기 전에 널 문자열과 입력을 일치시킵니다. 따라서 &lt;code&gt;\N&lt;/code&gt; 과 같은 널 문자열 은 실제 데이터 값 &lt;code&gt;\N&lt;/code&gt; ( &lt;code&gt;\\N&lt;/code&gt; 표시됨) 과 혼동 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4d4785fdbe411a867de5dc30c6f6e2cd3e8ad8aa" translate="yes" xml:space="preserve">
          <source>The specified replication slot has to exist unless the option &lt;code&gt;-C&lt;/code&gt; is also used.</source>
          <target state="translated">&lt;code&gt;-C&lt;/code&gt; 옵션 도 사용 하지 않으면 지정된 복제 슬롯이 존재해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fe37bdbcd81870812798f7398d4fa3769b9383b0" translate="yes" xml:space="preserve">
          <source>The speed of the archiving command is unimportant as long as it can keep up with the average rate at which your server generates WAL data. Normal operation continues even if the archiving process falls a little behind. If archiving falls significantly behind, this will increase the amount of data that would be lost in the event of a disaster. It will also mean that the &lt;code&gt;pg_wal/&lt;/code&gt; directory will contain large numbers of not-yet-archived segment files, which could eventually exceed available disk space. You are advised to monitor the archiving process to ensure that it is working as you intend.</source>
          <target state="translated">보관 명령의 속도는 서버가 WAL 데이터를 생성하는 평균 속도를 따라갈 수있는 한 중요하지 않습니다. 아카이빙 프로세스가 약간 뒤쳐져도 정상적인 작동이 계속됩니다. 보관이 크게 뒤처지면 재해시 손실되는 데이터 양이 늘어납니다. 또한 &lt;code&gt;pg_wal/&lt;/code&gt; 디렉토리에는 아직 아카이브되지 않은 많은 세그먼트 파일이 포함되어 결국 사용 가능한 디스크 공간을 초과 할 수 있습니다. 보관 프로세스가 의도 한대로 작동하는지 확인하기 위해 보관 프로세스를 모니터링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95c448049b38c97f5a095366eb9a582e60005694" translate="yes" xml:space="preserve">
          <source>The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</source>
          <target state="translated">spi 모듈은 SPI ( &lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; ) 및 트리거 사용에 대한 몇 가지 실행 가능한 예제를 제공 합니다. 이러한 기능은 그 자체로는 가치가 있지만 자신의 목적에 맞게 수정하는 예제로 더 유용합니다. 이 함수는 모든 테이블에서 사용할 수있을 정도로 일반적이지만 트리거를 생성하는 동안 테이블 및 필드 이름 (아래 설명 참조)을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cab15a6018a42e58d3535f603f3afdd60d9e9dde" translate="yes" xml:space="preserve">
          <source>The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/13/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</source>
          <target state="translated">The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/13/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</target>
        </trans-unit>
        <trans-unit id="51d51509dfcf1b638bd0142f5ba7e99e05ff8361" translate="yes" xml:space="preserve">
          <source>The standard B-tree operators are also provided, for example</source>
          <target state="translated">표준 B- 트리 연산자도 제공됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="540592c3e626f7c31f8adb5673f9493bff1cdcb6" translate="yes" xml:space="preserve">
          <source>The standard PostgreSQL distribution does not include any Ispell configuration files. Dictionaries for a large number of languages are available from &lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt;. Also, some more modern dictionary file formats are supported &amp;mdash; &lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;MySpell&lt;/a&gt; (OO &amp;lt; 2.0.1) and &lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt; (OO &amp;gt;= 2.0.2). A large list of dictionaries is available on the &lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki&lt;/a&gt;.</source>
          <target state="translated">표준 PostgreSQL 배포에는 Ispell 구성 파일이 포함되어 있지 않습니다. 많은 언어에 대한 사전은 &lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt; 에서 구할 수 있습니다 . 또한 &lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;MySpell&lt;/a&gt; (OO &amp;lt;2.0.1) 및 &lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt; (OO&amp;gt; = 2.0.2) 과 같은 최신 사전 파일 형식이 지원됩니다 . 많은 사전 목록이 &lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki에서 제공&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="c31d1f8f49b866b6c41ce1d3be305d54cfca10f1" translate="yes" xml:space="preserve">
          <source>The standard allows transition tables to be used with column-specific &lt;code&gt;UPDATE&lt;/code&gt; triggers, but then the set of rows that should be visible in the transition tables depends on the trigger's column list. This is not currently implemented by PostgreSQL.</source>
          <target state="translated">표준을 사용하면 전이 테이블을 열별 &lt;code&gt;UPDATE&lt;/code&gt; 트리거 와 함께 사용할 수 있지만 전이 테이블에 표시되어야하는 행 세트는 트리거의 열 목록에 따라 다릅니다. 이것은 현재 PostgreSQL에 의해 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7abbb06bd2ac89072eb3b19d752092cab8a2a05f" translate="yes" xml:space="preserve">
          <source>The standard and predefined collations are in the schema &lt;code&gt;pg_catalog&lt;/code&gt;, like all predefined objects. User-defined collations should be created in user schemas. This also ensures that they are saved by &lt;code&gt;pg_dump&lt;/code&gt;.</source>
          <target state="translated">표준 및 사전 정의 된 데이터 정렬은 모든 사전 정의 된 오브젝트와 같이 스키마 &lt;code&gt;pg_catalog&lt;/code&gt; 에 있습니다. 사용자 정의 데이터 정렬은 사용자 스키마에서 생성해야합니다. 이것은 또한 &lt;code&gt;pg_dump&lt;/code&gt; 에 의해 저장되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="7c4d54e7271038b160fc912ff3e59738441ec42e" translate="yes" xml:space="preserve">
          <source>The standard approach to doing case-insensitive matches in PostgreSQL has been to use the &lt;code&gt;lower&lt;/code&gt; function when comparing values, for example</source>
          <target state="translated">PostgreSQL에서 대소 문자를 구분하지 않는 일치를 수행하는 표준 접근 방식은 값을 비교할 때 &lt;code&gt;lower&lt;/code&gt; 기능 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="66a45d5bab8320954db0c2f93584f58e956d983a" translate="yes" xml:space="preserve">
          <source>The standard comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for &lt;code&gt;jsonb&lt;/code&gt;, but not for &lt;code&gt;json&lt;/code&gt;. They follow the ordering rules for B-tree operations outlined at &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;표 9.1에&lt;/a&gt; 표시된 표준 비교 연산자 는 &lt;code&gt;jsonb&lt;/code&gt; 에는 사용할 수 있지만 &lt;code&gt;json&lt;/code&gt; 에는 사용할 수 없습니다 . 이들은 &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;8.14.4 절에&lt;/a&gt; 요약 된 B- 트리 작업에 대한 순서 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="aecb6846cb8fa061d2893b8cbe3329208b79f989" translate="yes" xml:space="preserve">
          <source>The standard form of &lt;code&gt;VACUUM&lt;/code&gt; removes dead row versions in tables and indexes and marks the space available for future reuse. However, it will not return the space to the operating system, except in the special case where one or more pages at the end of a table become entirely free and an exclusive table lock can be easily obtained. In contrast, &lt;code&gt;VACUUM FULL&lt;/code&gt; actively compacts tables by writing a complete new version of the table file with no dead space. This minimizes the size of the table, but can take a long time. It also requires extra disk space for the new copy of the table, until the operation completes.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 의 표준 형식은 테이블과 인덱스에서 데드 행 버전을 제거하고 향후 재사용에 사용할 수있는 공간을 표시합니다. 그러나 테이블 끝에있는 하나 이상의 페이지가 완전히 사용 가능하고 독점 테이블 잠금을 쉽게 얻을 수있는 특수한 경우를 제외하고는 운영 체제로 공간을 리턴하지 않습니다. 반대로, &lt;code&gt;VACUUM FULL&lt;/code&gt; 은 데드 스페이스없이 완전히 새로운 버전의 테이블 파일을 작성하여 테이블을 능동적으로 압축합니다. 이렇게하면 테이블 크기가 최소화되지만 시간이 오래 걸릴 수 있습니다. 또한 작업이 완료 될 때까지 테이블의 새 사본을위한 추가 디스크 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="64a9df6af803f6fb88db88a2c8492bf422359cc7" translate="yes" xml:space="preserve">
          <source>The standard only allows one function to be dropped per command.</source>
          <target state="translated">표준은 명령 당 하나의 기능 만 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5dc058e6d69517b035378cc0545a3ff6bbf59c9" translate="yes" xml:space="preserve">
          <source>The standard only allows one procedure to be dropped per command.</source>
          <target state="translated">표준은 명령 당 하나의 절차 만 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d079640bb3afa14420ec7729af4881846a5851ac" translate="yes" xml:space="preserve">
          <source>The standard only allows one routine to be dropped per command.</source>
          <target state="translated">표준은 명령 당 하나의 루틴 만 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f30578370e30868e083b5faa5f9ddb49a2e7ea" translate="yes" xml:space="preserve">
          <source>The standard requires parentheses around the subquery clause; in PostgreSQL, these parentheses are optional.</source>
          <target state="translated">표준에는 하위 쿼리 절 주위에 괄호가 필요합니다. PostgreSQL에서 이러한 괄호는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="037c9f0273cfeaa62d235fa64430e2ec604be3e9" translate="yes" xml:space="preserve">
          <source>The standard's definition of the behavior of temporary tables is widely ignored. PostgreSQL's behavior on this point is similar to that of several other SQL databases.</source>
          <target state="translated">임시 테이블의 동작에 대한 표준의 정의는 널리 무시됩니다. 이 시점에서 PostgreSQL의 동작은 다른 여러 SQL 데이터베이스의 동작과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d958124d33ada3ecaa4ecf5cd2414a7d80adeee5" translate="yes" xml:space="preserve">
          <source>The statement subforms and actions available for &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; are a subset of those available for &lt;code&gt;ALTER TABLE&lt;/code&gt;, and have the same meaning when used for materialized views. See the descriptions for &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; 에 사용 가능한 명령문 서브 폼 및 조치 는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 에 사용 가능한 명령문 서브 세트 및 조치 이며 구체화 된보기에 사용될 때 동일한 의미를 갖습니다. 자세한 내용은 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE에&lt;/a&gt; 대한 설명을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="adf6cc4f8a6109f575b7d3519d3e9c33574716b7" translate="yes" xml:space="preserve">
          <source>The statistic-gathering target for this statistics object for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the maximum of the statistics target of the referenced columns, if set, or the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">The statistic-gathering target for this statistics object for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the maximum of the statistics target of the referenced columns, if set, or the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6a85ce8c175ffd31b8c2d56822ffccc6660fc62f" translate="yes" xml:space="preserve">
          <source>The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 에 의해 수집 된 통계 에는 일반적으로 각 열에서 가장 일반적인 값 목록과 각 열의 대략적인 데이터 분포를 보여주는 막대 그래프가 포함됩니다. &lt;code&gt;ANALYZE&lt;/code&gt; 가 고유하지 않은 것으로 간주하거나 (예 : 고유 키 열에 공통 값이 없음) 열 데이터 유형이 적절한 연산자를 지원하지 않는 경우 이들 중 하나 또는 둘 다를 생략 할 수 있습니다 . &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;24 장의&lt;/a&gt; 통계에 대한 자세한 정보가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adfbbd6d85375712da67e76aabf75e7f5395de5a" translate="yes" xml:space="preserve">
          <source>The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/13/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</source>
          <target state="translated">The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/13/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="238068c46fb76fc5b6da5477e8f4ec22c3889848" translate="yes" xml:space="preserve">
          <source>The statistics collector is active during recovery. All scans, reads, blocks, index usage, etc., will be recorded normally on the standby. Replayed actions will not duplicate their effects on primary, so replaying an insert will not increment the Inserts column of pg_stat_user_tables. The stats file is deleted at the start of recovery, so stats from primary and standby will differ; this is considered a feature, not a bug.</source>
          <target state="translated">통계 콜렉터는 복구 중에 활성화됩니다. 모든 스캔, 읽기, 차단, 인덱스 사용량 등은 대기 모드에서 정상적으로 기록됩니다. 재생 된 조치는 기본에 대한 영향을 복제하지 않으므로 삽입을 재생해도 pg_stat_user_tables의 삽입 열이 증가하지 않습니다. 통계 파일은 복구 시작시 삭제되므로 기본 및 대기의 통계는 다릅니다. 이것은 버그가 아닌 기능으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="965711f627243ac89dbb9d9e575eab2acab52658" translate="yes" xml:space="preserve">
          <source>The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g. after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</source>
          <target state="translated">통계 수집기는 수집 된 정보를 임시 파일을 통해 다른 PostgreSQL 프로세스로 전송합니다. 이 파일은 &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; 매개 변수로 이름이 지정된 디렉토리 , 기본적으로 &lt;code&gt;pg_stat_tmp&lt;/code&gt; 에 저장 됩니다. 성능 향상을 위해 &lt;code&gt;stats_temp_directory&lt;/code&gt; 를 RAM 기반 파일 시스템으로 지정하여 물리적 I / O 요구 사항을 줄입니다. 서버가 완전히 종료되면 통계 데이터의 영구 사본이 &lt;code&gt;pg_stat&lt;/code&gt; 서브 디렉토리에 저장 되므로 서버를 재시작해도 통계를 유지할 수 있습니다. 서버 시작시 복구가 수행되면 (예 : 즉시 종료, 서버 충돌 및 특정 시점 복구) 모든 통계 카운터가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed6f0b5b68c60cb649e8a7cdfda530aaa032eb80" translate="yes" xml:space="preserve">
          <source>The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g., after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</source>
          <target state="translated">The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g., after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</target>
        </trans-unit>
        <trans-unit id="3d31102b772c217f86df5c917a56d333df998b96" translate="yes" xml:space="preserve">
          <source>The statistics gathered by the module are made available via a view named &lt;code&gt;pg_stat_statements&lt;/code&gt;. This view contains one row for each distinct database ID, user ID and query ID (up to the maximum number of distinct statements that the module can track). The columns of the view are shown in &lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;Table F.21&lt;/a&gt;.</source>
          <target state="translated">모듈이 수집 한 통계는 &lt;code&gt;pg_stat_statements&lt;/code&gt; 라는보기를 통해 사용 가능합니다 . 이보기에는 각 고유 한 데이터베이스 ID, 사용자 ID 및 조회 ID (모듈이 추적 할 수있는 최대 고유 명령문 수)에 대한 하나의 행이 있습니다. 보기의 열은 &lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;표 F.21에&lt;/a&gt; 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d129f0558b07e424e594be75be7478f28f34b280" translate="yes" xml:space="preserve">
          <source>The stop point must be after the ending time of the base backup, i.e., the end time of &lt;code&gt;pg_stop_backup&lt;/code&gt;. You cannot use a base backup to recover to a time when that backup was in progress. (To recover to such a time, you must go back to your previous base backup and roll forward from there.)</source>
          <target state="translated">중지 지점은 기본 백업의 종료 시간, 즉 &lt;code&gt;pg_stop_backup&lt;/code&gt; 의 종료 시간 이후 여야합니다 . 기본 백업을 사용하여 백업이 진행중인 시간으로 복구 할 수 없습니다. (이러한 시간으로 복구하려면 이전 기본 백업으로 돌아가서 롤 포워드해야합니다.)</target>
        </trans-unit>
        <trans-unit id="991a8e15374d6e812a4e43376053e637a59638d9" translate="yes" xml:space="preserve">
          <source>The stopword file format is the same as already explained.</source>
          <target state="translated">스톱 워드 파일 형식은 이미 설명한 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a67abf97180ecab3e7785607a17892200ca122a" translate="yes" xml:space="preserve">
          <source>The storage alignment requirement of the data type. If specified, it must be &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, or &lt;code&gt;double&lt;/code&gt;; the default is &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">데이터 유형의 스토리지 정렬 요구 사항 지정된 경우 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;int2&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 이어야합니다 . 디폴트는 &lt;code&gt;int4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4fb27d9289cba59d0dbea8d9a256bcf54f4d8f1d" translate="yes" xml:space="preserve">
          <source>The storage requirement for a short string (up to 126 bytes) is 1 byte plus the actual string, which includes the space padding in the case of &lt;code&gt;character&lt;/code&gt;. Longer strings have 4 bytes of overhead instead of 1. Long strings are compressed by the system automatically, so the physical requirement on disk might be less. Very long values are also stored in background tables so that they do not interfere with rapid access to shorter column values. In any case, the longest possible character string that can be stored is about 1 GB. (The maximum value that will be allowed for &lt;code&gt;n&lt;/code&gt; in the data type declaration is less than that. It wouldn't be useful to change this because with multibyte character encodings the number of characters and bytes can be quite different. If you desire to store long strings with no specific upper limit, use &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; without a length specifier, rather than making up an arbitrary length limit.)</source>
          <target state="translated">짧은 문자열 (최대 126 바이트)의 스토리지 요구 사항은 1 바이트 + 실제 문자열이며 여기에는 &lt;code&gt;character&lt;/code&gt; 의 경우 공백이 포함됩니다 . 긴 문자열은 1 대신 4 바이트의 오버 헤드를 갖습니다. 긴 문자열은 시스템에 의해 자동으로 압축되므로 디스크의 물리적 요구 사항은 더 적을 수 있습니다. 매우 긴 값은 백그라운드 테이블에 저장되므로 더 짧은 열 값에 빠르게 액세스하는 데 방해가되지 않습니다. 어쨌든 저장할 수있는 가장 긴 문자열은 약 1GB입니다. ( &lt;code&gt;n&lt;/code&gt; 에 허용되는 최대 값데이터 유형 선언에서 그보다 작습니다. 멀티 바이트 문자 인코딩을 사용하면 문자 수와 바이트 수가 상당히 다를 수 있으므로이를 변경하면 유용하지 않습니다. 특정 상한없이 긴 문자열을 저장 하려면 임의의 길이 제한을 구성하는 대신 길이 지정자가없는 &lt;code&gt;text&lt;/code&gt; 또는 &lt;code&gt;character varying&lt;/code&gt; 사용 하십시오 .)</target>
        </trans-unit>
        <trans-unit id="80d6814e5ec0e1d06f3de3ede9d15794bac11987" translate="yes" xml:space="preserve">
          <source>The storage strategy for the data type. If specified, must be &lt;code&gt;plain&lt;/code&gt;, &lt;code&gt;external&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, or &lt;code&gt;main&lt;/code&gt;; the default is &lt;code&gt;plain&lt;/code&gt;.</source>
          <target state="translated">데이터 유형에 대한 스토리지 전략. 지정된 경우 &lt;code&gt;plain&lt;/code&gt; , &lt;code&gt;external&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; 또는 &lt;code&gt;main&lt;/code&gt; 이어야합니다 . 기본값은 &lt;code&gt;plain&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b76e63a79625e26440cca8d9a00f3887da24e61" translate="yes" xml:space="preserve">
          <source>The stream format is determined by the output plugin specified when the slot was created.</source>
          <target state="translated">스트림 형식은 슬롯을 만들 때 지정된 출력 플러그인에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="19380cfa586d87fdf911b110ff6bf4d13369bdea" translate="yes" xml:space="preserve">
          <source>The string constant can be written using either regular SQL notation or dollar-quoting.</source>
          <target state="translated">문자열 상수는 일반 SQL 표기법 또는 달러 인용을 사용하여 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84091e9e070956556635627e5454034e5e1ceadb" translate="yes" xml:space="preserve">
          <source>The string constant's text is passed to the input conversion routine for the type called &lt;code&gt;type&lt;/code&gt;. The result is a constant of the indicated type. The explicit type cast can be omitted if there is no ambiguity as to the type the constant must be (for example, when it is assigned directly to a table column), in which case it is automatically coerced.</source>
          <target state="translated">문자열 상수의 텍스트는 type이라는 &lt;code&gt;type&lt;/code&gt; 의 입력 변환 루틴으로 전달됩니다 . 결과는 표시된 유형의 상수입니다. 상수에 대한 모호성이없는 경우 명시 적 유형 캐스트를 생략 할 수 있습니다 (예 : 테이블 열에 직접 지정된 경우).이 경우 자동으로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c916cd87a0dd50984ecec5d10546dad9c3284d3a" translate="yes" xml:space="preserve">
          <source>The string must start with a &lt;code&gt;P&lt;/code&gt;, and may include a &lt;code&gt;T&lt;/code&gt; that introduces the time-of-day units. The available unit abbreviations are given in &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;Table 8.16&lt;/a&gt;. Units may be omitted, and may be specified in any order, but units smaller than a day must appear after &lt;code&gt;T&lt;/code&gt;. In particular, the meaning of &lt;code&gt;M&lt;/code&gt; depends on whether it is before or after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">문자열은 &lt;code&gt;P&lt;/code&gt; 로 시작해야 하며 시간 단위를 소개 하는 &lt;code&gt;T&lt;/code&gt; 를 포함 할 수 있습니다 . 사용 가능한 단위 약어가 &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;표 8.16&lt;/a&gt; 에 나와 있습니다. 단위는 생략 할 수 있으며 순서에 관계없이 지정할 수 있지만 하루보다 작은 단위는 &lt;code&gt;T&lt;/code&gt; 뒤에 표시되어야합니다 . 특히 &lt;code&gt;M&lt;/code&gt; 의 의미는 그것이 &lt;code&gt;T&lt;/code&gt; 이전인지 이후인지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5ac1d279bca8c92d106e249d73c9450bd51985a" translate="yes" xml:space="preserve">
          <source>The string used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used as a second parameter identifying for example which database user the user is attempting to authenticate as, which can be used for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</source>
          <target state="translated">RADIUS 요청에서 &lt;code&gt;NAS Identifier&lt;/code&gt; 로 사용되는 문자열 입니다. 이 매개 변수는 예를 들어 사용자가 인증하려는 데이터베이스 사용자를 식별하는 두 번째 매개 변수로 사용될 수 있으며 RADIUS 서버의 정책 일치에 사용될 수 있습니다. 식별자를 지정하지 않으면 기본 &lt;code&gt;postgresql&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3ee7b9f09ddbdb9488305b75db66d9c52bca23d" translate="yes" xml:space="preserve">
          <source>The string value of an XML element is the concatenation, in document order, of all text nodes contained in that element and its descendants. The string value of an element with no descendant text nodes is an empty string (not &lt;code&gt;NULL&lt;/code&gt;). Any &lt;code&gt;xsi:nil&lt;/code&gt; attributes are ignored. Note that the whitespace-only &lt;code&gt;text()&lt;/code&gt; node between two non-text elements is preserved, and that leading whitespace on a &lt;code&gt;text()&lt;/code&gt; node is not flattened. The XPath 1.0 &lt;code&gt;string&lt;/code&gt; function may be consulted for the rules defining the string value of other XML node types and non-XML values.</source>
          <target state="translated">XML 요소의 문자열 값은 해당 요소에 포함 된 모든 텍스트 노드와 해당 하위 항목의 연결 (문서 순서)입니다. 하위 텍스트 노드가없는 요소의 문자열 값은 빈 문자열입니다 ( &lt;code&gt;NULL&lt;/code&gt; 아님). 모든 &lt;code&gt;xsi:nil&lt;/code&gt; 속성은 무시됩니다. 두 개의 비 텍스트 요소 사이 의 공백 전용 &lt;code&gt;text()&lt;/code&gt; 노드는 유지되며 &lt;code&gt;text()&lt;/code&gt; 노드의 선행 공백 은 평평하지 않습니다. 다른 XML 노드 유형의 문자열 값과 비 XML 값을 정의하는 규칙에 대해서는 XPath 1.0 &lt;code&gt;string&lt;/code&gt; 함수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fec81f56bf595f634fb57f3910c670ede118c7c" translate="yes" xml:space="preserve">
          <source>The string-literal processor removes one level of backslashes, so that what arrives at the composite-value parser looks like &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt;. In turn, the string fed to the &lt;code&gt;text&lt;/code&gt; data type's input routine becomes &lt;code&gt;&quot;\&lt;/code&gt;. (If we were working with a data type whose input routine also treated backslashes specially, &lt;code&gt;bytea&lt;/code&gt; for example, we might need as many as eight backslashes in the command to get one backslash into the stored composite field.) Dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) can be used to avoid the need to double backslashes.</source>
          <target state="translated">문자열 리터럴 프로세서는 한 수준의 백 슬래시를 제거하여 복합 값 구문 분석기에 도달하는 항목이 &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt; 와 같이 나타나고 &lt;code&gt;text&lt;/code&gt; 데이터 유형의 입력 루틴에 공급 된 문자열 이 &lt;code&gt;&quot;\&lt;/code&gt; 가 됩니다. (우리가 누구의 입력 루틴도 특별히 백 슬래시 처리, 데이터 유형과 작업하는 경우 &lt;code&gt;bytea&lt;/code&gt; 와 예를 들어 명령에 8 개의 백 슬래시가 저장된 복합 필드에 하나의 백 슬래시를 얻기 위해, 우리는해야 할 수도 있습니다.) 달러 표시 (인용 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;4.1 절. 2.4&lt;/a&gt; )를 사용하여 백 슬래시를 이중으로 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6422f96b00c11494b4fcf618b39050902cb1b6e9" translate="yes" xml:space="preserve">
          <source>The strings to be used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used, for example, to identify which database cluster the user is attempting to connect to, which can be useful for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</source>
          <target state="translated">The strings to be used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used, for example, to identify which database cluster the user is attempting to connect to, which can be useful for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</target>
        </trans-unit>
        <trans-unit id="8b9c21921311be92ddd5f85cbd74e19f06bfbb6a" translate="yes" xml:space="preserve">
          <source>The structure &lt;code&gt;IndexAmRoutine&lt;/code&gt; is defined thus:</source>
          <target state="translated">&lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1b7ec1adb20c9f7f9468502c9f11469bc8e03f67" translate="yes" xml:space="preserve">
          <source>The structure of a query plan is a tree of &lt;em&gt;plan nodes&lt;/em&gt;. Nodes at the bottom level of the tree are scan nodes: they return raw rows from a table. There are different types of scan nodes for different table access methods: sequential scans, index scans, and bitmap index scans. There are also non-table row sources, such as &lt;code&gt;VALUES&lt;/code&gt; clauses and set-returning functions in &lt;code&gt;FROM&lt;/code&gt;, which have their own scan node types. If the query requires joining, aggregation, sorting, or other operations on the raw rows, then there will be additional nodes above the scan nodes to perform these operations. Again, there is usually more than one possible way to do these operations, so different node types can appear here too. The output of &lt;code&gt;EXPLAIN&lt;/code&gt; has one line for each node in the plan tree, showing the basic node type plus the cost estimates that the planner made for the execution of that plan node. Additional lines might appear, indented from the node's summary line, to show additional properties of the node. The very first line (the summary line for the topmost node) has the estimated total execution cost for the plan; it is this number that the planner seeks to minimize.</source>
          <target state="translated">쿼리 계획의 구조는 &lt;em&gt;계획 노드&lt;/em&gt; 의 트리입니다 . 트리의 맨 아래 레벨에있는 노드는 스캔 노드입니다. 테이블에서 원시 행을 리턴합니다. 테이블 액세스 방법마다 순차적 스캔, 인덱스 스캔 및 비트 맵 인덱스 스캔과 같은 여러 유형의 스캔 노드가 있습니다. &lt;code&gt;FROM&lt;/code&gt; 에 &lt;code&gt;VALUES&lt;/code&gt; 절 및 set-returning 함수와 같은 테이블이 아닌 행 소스 도 있으며 자체 스캔 노드 유형이 있습니다. 쿼리에서 원시 행에 대한 조인, 집계, 정렬 또는 기타 작업이 필요한 경우 스캔 노드 위에 이러한 작업을 수행 할 추가 노드가 있습니다. 다시 말하지만 일반적으로 이러한 작업을 수행하는 방법은 여러 가지가 있으므로 여기에 다른 노드 유형도 나타날 수 있습니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 의 출력계획 트리의 각 노드에 대해 하나의 라인이 있으며 기본 노드 유형과 계획자가 해당 계획 노드를 실행하기 위해 수행 한 비용 추정치가 표시됩니다. 노드의 추가 특성을 표시하기 위해 노드 요약 행에서 들여 쓰기 된 추가 행이 나타날 수 있습니다. 첫 번째 라인 (최상위 노드의 요약 라인)에는 계획에 대한 예상 총 실행 비용이 있습니다. 플래너가 최소화하려고하는 것은이 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="845e7bd65e68101aeef835121687192ee5165c8e" translate="yes" xml:space="preserve">
          <source>The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt;, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 하위 명령문은 서로 동시에 기본 쿼리와 함께 실행됩니다. 따라서 &lt;code&gt;WITH&lt;/code&gt; 에서 데이터 수정 문 을 사용할 때 지정된 업데이트가 실제로 발생하는 순서는 예측할 수 없습니다. 모든 명령문은 동일한 &lt;em&gt;스냅 샷&lt;/em&gt; 으로 실행 되므로 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장&lt;/a&gt; 참조 ) 대상 테이블에 대한 서로의 영향을 &quot;볼&quot;수 없습니다. 이는 실제 행 갱신 순서의 예측 불가능의 영향을 완화 시키며, &lt;code&gt;RETURNING&lt;/code&gt; 데이터가 다른 &lt;code&gt;WITH&lt;/code&gt; 부속 명령문과 기본 조회 사이의 변경 사항을 전달하는 유일한 방법 임을 의미 합니다. 이것의 예는</target>
        </trans-unit>
        <trans-unit id="12dd874db96a4d69f19603b298f230a8d71acc37" translate="yes" xml:space="preserve">
          <source>The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt;, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</source>
          <target state="translated">The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt; , the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</target>
        </trans-unit>
        <trans-unit id="b11dad81d612edf5fd0a4215e04a5d2694b81901" translate="yes" xml:space="preserve">
          <source>The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery.</source>
          <target state="translated">하위 쿼리는 주변 쿼리의 변수를 참조 할 수 있으며 하위 쿼리를 평가하는 동안 상수 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="9047f1ac499137a7641446b4435a2058e7165f8c" translate="yes" xml:space="preserve">
          <source>The subquery must return a single column. If the subquery's output column is of a non-array type, the resulting one-dimensional array will have an element for each row in the subquery result, with an element type matching that of the subquery's output column. If the subquery's output column is of an array type, the result will be an array of the same type but one higher dimension; in this case all the subquery rows must yield arrays of identical dimensionality, else the result would not be rectangular.</source>
          <target state="translated">하위 쿼리는 단일 열을 반환해야합니다. 하위 쿼리의 출력 열이 배열이 아닌 유형 인 경우 결과 1 차원 배열은 하위 쿼리 결과의 각 행에 대한 요소를 가지며 하위 요소의 출력 열과 일치하는 요소 유형을 갖습니다. 하위 쿼리의 출력 열이 배열 유형 인 경우 결과는 동일한 유형이지만 하나의 차원이 더 큰 배열이됩니다. 이 경우 모든 하위 쿼리 행은 동일한 차원의 배열을 생성해야합니다. 그렇지 않으면 결과가 직사각형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ad9a65e976a88e8f391a32410934cda1367df45d" translate="yes" xml:space="preserve">
          <source>The subquery will generally only be executed long enough to determine whether at least one row is returned, not all the way to completion. It is unwise to write a subquery that has side effects (such as calling sequence functions); whether the side effects occur might be unpredictable.</source>
          <target state="translated">부속 조회는 일반적으로 완료 될 때까지가 아니라 하나 이상의 행이 리턴되는지 여부를 판별 할만큼 충분히 오래 실행됩니다. 부작용 (예 : 시퀀스 함수 호출)이있는 서브 쿼리를 작성하는 것은 현명하지 않습니다. 부작용 발생 여부는 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="68c9d90ab99dc33425ce7d63877e33bcb6f1a254" translate="yes" xml:space="preserve">
          <source>The subscriber also requires the &lt;code&gt;max_replication_slots&lt;/code&gt; to be set. In this case it should be set to at least the number of subscriptions that will be added to the subscriber. &lt;code&gt;max_logical_replication_workers&lt;/code&gt; must be set to at least the number of subscriptions, again plus some reserve for the table synchronization. Additionally the &lt;code&gt;max_worker_processes&lt;/code&gt; may need to be adjusted to accommodate for replication workers, at least (&lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt;). Note that some extensions and parallel queries also take worker slots from &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">가입자는 또한 &lt;code&gt;max_replication_slots&lt;/code&gt; 를 설정 해야합니다 . 이 경우 구독자에 추가 될 구독 수 이상으로 설정해야합니다. &lt;code&gt;max_logical_replication_workers&lt;/code&gt; 는 최소한 구독 수와 테이블 동기화를위한 예비 예약 수로 설정해야합니다. 또한 &lt;code&gt;max_worker_processes&lt;/code&gt; 는 최소한 ( &lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt; ) 복제 작업자를 수용하도록 조정해야 할 수도 있습니다 . 일부 확장 및 병렬 쿼리는 &lt;code&gt;max_worker_processes&lt;/code&gt; 에서 작업자 슬롯을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5061f785b5ca16b03e284f2d1ce17b7eeda1d830" translate="yes" xml:space="preserve">
          <source>The subscriber database behaves in the same way as any other PostgreSQL instance and can be used as a publisher for other databases by defining its own publications.</source>
          <target state="translated">구독자 데이터베이스는 다른 PostgreSQL 인스턴스와 같은 방식으로 작동하며 자체 게시를 정의하여 다른 데이터베이스의 게시자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e109de41793b3722661641499539600ee95867" translate="yes" xml:space="preserve">
          <source>The subscription apply process will run in the local database with the privileges of a superuser.</source>
          <target state="translated">구독 적용 프로세스는 수퍼 유저의 권한으로 로컬 데이터베이스에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4cb7abebeb2fd700c8b2ec617037c9667107f4c0" translate="yes" xml:space="preserve">
          <source>The subscription is added using &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; and can be stopped/resumed at any time using the &lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt; command and removed using &lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION을&lt;/a&gt; 사용하여 구독을 추가 하고 &lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt; 명령을 사용하여 언제든지 중지 / 다시 시작하고 &lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION을&lt;/a&gt; 사용하여 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="121044a7fb76fda9e0fbc21177fe11d696a1b02d" translate="yes" xml:space="preserve">
          <source>The subscription represents a replication connection to the publisher. As such this command does not only add definitions in the local catalogs but also creates a replication slot on the publisher.</source>
          <target state="translated">구독은 게시자에 대한 복제 연결을 나타냅니다. 따라서이 명령은 로컬 카탈로그에 정의를 추가 할뿐만 아니라 게시자에 복제 슬롯을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48011fd4928d8a9744bee30b18454a7d53e6f680" translate="yes" xml:space="preserve">
          <source>The subscripts of an array value built with &lt;code&gt;ARRAY&lt;/code&gt; always begin with one. For more information about arrays, see &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ARRAY&lt;/code&gt; 로 작성된 배열 값의 첨자는 항상 1로 시작합니다. 배열에 대한 자세한 내용은 &lt;a href=&quot;arrays&quot;&gt;8.15 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2334c3c5a694ddeb266347a848900f44f0cab917" translate="yes" xml:space="preserve">
          <source>The summarizing structure is bound in size by &lt;code&gt;maintenance_work_mem&lt;/code&gt;. In order to ensure that there is no more than a 2% probability of failure to detect an inconsistency for each heap tuple that should be represented in the index, approximately 2 bytes of memory are needed per tuple. As less memory is made available per tuple, the probability of missing an inconsistency slowly increases. This approach limits the overhead of verification significantly, while only slightly reducing the probability of detecting a problem, especially for installations where verification is treated as a routine maintenance task. Any single absent or malformed tuple has a new opportunity to be detected with each new verification attempt.</source>
          <target state="translated">요약 구조는 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 에 의해 크기가 제한됩니다 . 인덱스에 표시되어야하는 각 힙 튜플에 대해 불일치를 감지하지 못할 확률이 2 %를 넘지 않도록하려면 튜플 당 약 2 바이트의 메모리가 필요합니다. 튜플 당 사용 가능한 메모리가 줄어들면 불일치가 사라질 확률이 천천히 증가합니다. 이 접근 방식은 검증 오버 헤드를 크게 제한하는 반면, 특히 검증이 일상적인 유지 관리 작업으로 처리되는 설치의 경우 문제를 발견 할 가능성을 약간만 줄입니다. 결석 또는 기형의 단일 튜플은 각각의 새로운 검증 시도로 탐지 될 새로운 기회를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="aa2efac8a5cca33663d7c228751b90df82bafbc8" translate="yes" xml:space="preserve">
          <source>The switch file &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; is created first, enabling archiving of completed WAL files to occur. After the backup the switch file is removed. Archived WAL files are then added to the backup so that both base backup and all required WAL files are part of the same tar file. Please remember to add error handling to your backup scripts.</source>
          <target state="translated">스위치 파일 &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; 가 먼저 생성되어 완료된 WAL 파일을 보관할 수 있습니다. 백업 후 스위치 파일이 제거됩니다. 그런 다음 아카이브 된 WAL 파일이 백업에 추가되어 기본 백업과 필요한 모든 WAL 파일이 모두 동일한 tar 파일의 일부가됩니다. 백업 스크립트에 오류 처리 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="87700f6e1446d98115cf77b5305bf6c280312a5f" translate="yes" xml:space="preserve">
          <source>The symbol shown in the column &amp;ldquo;Condition Name&amp;rdquo; is the condition name to use in PL/pgSQL. Condition names can be written in either upper or lower case. (Note that PL/pgSQL does not recognize warning, as opposed to error, condition names; those are classes 00, 01, and 02.)</source>
          <target state="translated">&amp;ldquo;조건 이름&amp;rdquo;열에 표시된 기호는 PL / pgSQL에서 사용할 조건 이름입니다. 조건 이름은 대문자 또는 소문자로 쓸 수 있습니다. PL / pgSQL은 오류, 조건 이름이 아니라 경고를 인식하지 못합니다 (클래스 00, 01 및 02).</target>
        </trans-unit>
        <trans-unit id="af2af0e19179d988e1c5bb09182f6b8329bf33d2" translate="yes" xml:space="preserve">
          <source>The synchronization workers are taken from the pool defined by &lt;code&gt;max_logical_replication_workers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max_logical_replication_workers&lt;/code&gt; 에 의해 정의 된 풀에서 동기화 워커를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9ff2f915045408cc48aad6178d8c49b4353ee6d4" translate="yes" xml:space="preserve">
          <source>The synchronous states of standby servers can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">대기 서버의 동기 상태는 &lt;code&gt;pg_stat_replication&lt;/code&gt; 보기를 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">문법</target>
        </trans-unit>
        <trans-unit id="8f181461d9c844d09a197734c97365af11fec6c2" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;CREATE TABLE&lt;/code&gt; allows the exact size of arrays to be specified, for example:</source>
          <target state="translated">&lt;code&gt;CREATE TABLE&lt;/code&gt; 의 구문을 사용하면 정확한 크기의 배열을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="966dbee44492fe4c1ad689fb4503c9e542bc2d3e" translate="yes" xml:space="preserve">
          <source>The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:</source>
          <target state="translated">함수 호출 구문은 함수 이름 (스키마 이름으로 정규화 될 수 있음)과 그 뒤에 인수 목록이 괄호로 묶여 있습니다.</target>
        </trans-unit>
        <trans-unit id="9827946ae401eb6c51ab3afdb1c21f5055ada0b5" translate="yes" xml:space="preserve">
          <source>The syntax for ordered-set aggregates allows &lt;code&gt;VARIADIC&lt;/code&gt; to be specified for both the last direct parameter and the last aggregated (&lt;code&gt;WITHIN GROUP&lt;/code&gt;) parameter. However, the current implementation restricts use of &lt;code&gt;VARIADIC&lt;/code&gt; in two ways. First, ordered-set aggregates can only use &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, not other variadic array types. Second, if the last direct parameter is &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, then there can be only one aggregated parameter and it must also be &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;. (In the representation used in the system catalogs, these two parameters are merged into a single &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; item, since &lt;code&gt;pg_proc&lt;/code&gt; cannot represent functions with more than one &lt;code&gt;VARIADIC&lt;/code&gt; parameter.) If the aggregate is a hypothetical-set aggregate, the direct arguments that match the &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameter are the hypothetical ones; any preceding parameters represent additional direct arguments that are not constrained to match the aggregated arguments.</source>
          <target state="translated">순서 집합 집계 구문을 사용하면 &lt;code&gt;VARIADIC&lt;/code&gt; 를 마지막 직접 매개 변수와 마지막 집계 ( &lt;code&gt;WITHIN GROUP&lt;/code&gt; ) 매개 변수 모두에 지정할 수 있습니다 . 그러나 현재 구현 에서는 두 가지 방식 으로 &lt;code&gt;VARIADIC&lt;/code&gt; 사용을 제한합니다 . 첫째, 순서 집합 집계는 다른 가변 배열 유형이 아닌 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 만 사용할 수 있습니다. 두 번째로, 마지막 직접 매개 변수가 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 인 경우 하나의 집계 매개 변수 만있을 수 있으며 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 여야합니다 . (시스템 카탈로그에 사용 된 표현에서이 두 매개 변수는 &lt;code&gt;pg_proc&lt;/code&gt; 이후 단일 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 항목 으로 병합됩니다. &lt;code&gt;VARIADIC&lt;/code&gt; 매개 변수 가 둘 이상인 함수를 표시 할 수 없습니다 .) 집계가 가상 집합 집계 인 경우 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 매개 변수 와 일치하는 직접 인수 는 가상입니다. 이전의 모든 매개 변수는 집계 된 인수와 일치하도록 제한되지 않은 추가 직접 인수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d86a8075f285a9e5f082a7c58f078a97fe87d56b" translate="yes" xml:space="preserve">
          <source>The syntax is comparable to &lt;code&gt;CREATE TABLE&lt;/code&gt;, except that only field names and types can be specified; no constraints (such as &lt;code&gt;NOT NULL&lt;/code&gt;) can presently be included. Note that the &lt;code&gt;AS&lt;/code&gt; keyword is essential; without it, the system will think a different kind of &lt;code&gt;CREATE TYPE&lt;/code&gt; command is meant, and you will get odd syntax errors.</source>
          <target state="translated">필드 이름과 유형 만 지정할 수 있다는 점을 제외하고 구문은 &lt;code&gt;CREATE TABLE&lt;/code&gt; 과 비슷 합니다. 현재 &lt;code&gt;NOT NULL&lt;/code&gt; 과 같은 제약 조건 은 포함 할 수 없습니다 . 있습니다 &lt;code&gt;AS&lt;/code&gt; 의 키워드가 필수적이다; 그것 없이는 시스템은 다른 종류의 &lt;code&gt;CREATE TYPE&lt;/code&gt; 명령을 의미 한다고 생각할 것이고 이상한 구문 에러를 보게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="42c058b9d6546225c3baf16e3e4b8ff07bce7ea0" translate="yes" xml:space="preserve">
          <source>The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</source>
          <target state="translated">숫자 형 상수의 구문은 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;4.1.2 절&lt;/a&gt; 에서 설명 합니다. 숫자 유형에는 해당하는 산술 연산자와 함수의 전체 세트가 있습니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장&lt;/a&gt; 을 참조하십시오. 다음 섹션에서는 유형을 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="066ef2160f0ee25b4e61a233c1f3a6f5f1cba268" translate="yes" xml:space="preserve">
          <source>The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</source>
          <target state="translated">The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</target>
        </trans-unit>
        <trans-unit id="3602bbafe5a0054bbc62eb9c26f3d0a2eca852d1" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; is</source>
          <target state="translated">구문의 &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; 의 항은&lt;/a&gt; 인</target>
        </trans-unit>
        <trans-unit id="256ca2bba9fef3ff251261724a6f5b0ce7b90218" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt;&lt;/a&gt; clause is</source>
          <target state="translated">The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; &lt;/a&gt; clause is</target>
        </trans-unit>
        <trans-unit id="8203a94af84f4e0e580fcba3501f0b24c27a5840" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;CREATE INDEX&lt;/code&gt; command normally requires writing parentheses around index expressions, as shown in the second example. The parentheses can be omitted when the expression is just a function call, as in the first example.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; 명령 의 구문에는 일반적으로 두 번째 예와 같이 인덱스 표현식 주위에 괄호를 써야합니다. 첫 번째 예에서와 같이 표현식이 함수 호출 일 경우 괄호를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c241abd813b7161dcc7e86ad91e10959de152091" translate="yes" xml:space="preserve">
          <source>The syntax of this command is similar to that of the SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. All options other than the data source/destination are as specified for &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;. Because of this, special parsing rules apply to the &lt;code&gt;\copy&lt;/code&gt; meta-command. Unlike most other meta-commands, the entire remainder of the line is always taken to be the arguments of &lt;code&gt;\copy&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">이 명령의 구문은 SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; 명령 의 구문과 유사합니다 . 데이터 소스 / 대상 이외의 모든 옵션은 &lt;a href=&quot;sql-copy&quot;&gt;COPY에&lt;/a&gt; 지정된대로입니다 . 이 때문에 특수한 구문 분석 규칙이 &lt;code&gt;\copy&lt;/code&gt; 메타 명령에 적용됩니다 . 대부분의 다른 메타 명령과 달리 나머지 줄 전체는 항상 &lt;code&gt;\copy&lt;/code&gt; 인수로 간주되며 인수에서 변수 보간이나 역 따옴표 확장이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd8d680d5b62b13099c9e19bc923e563b07e6d19" translate="yes" xml:space="preserve">
          <source>The syntax used so far requires you to remember the order of the columns. An alternative syntax allows you to list the columns explicitly:</source>
          <target state="translated">지금까지 사용한 구문은 열 순서를 기억해야합니다. 대체 구문을 사용하면 열을 명시 적으로 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="033030a62bda22a5de4a5aeea859f2505dc5e730" translate="yes" xml:space="preserve">
          <source>The syntax with &lt;code&gt;ORDER BY&lt;/code&gt; in the parameter list creates a special type of aggregate called an &lt;em&gt;ordered-set aggregate&lt;/em&gt;; or if &lt;code&gt;HYPOTHETICAL&lt;/code&gt; is specified, then a &lt;em&gt;hypothetical-set aggregate&lt;/em&gt; is created. These aggregates operate over groups of sorted values in order-dependent ways, so that specification of an input sort order is an essential part of a call. Also, they can have &lt;em&gt;direct&lt;/em&gt; arguments, which are arguments that are evaluated only once per aggregation rather than once per input row. Hypothetical-set aggregates are a subclass of ordered-set aggregates in which some of the direct arguments are required to match, in number and data types, the aggregated argument columns. This allows the values of those direct arguments to be added to the collection of aggregate-input rows as an additional &amp;ldquo;hypothetical&amp;rdquo; row.</source>
          <target state="translated">와 구문 &lt;code&gt;ORDER BY&lt;/code&gt; 매개 변수 목록은 전화 집계 특수한 유형의 생성 &lt;em&gt;순서 설정된 집계를&lt;/em&gt; ; 또는 &lt;code&gt;HYPOTHETICAL&lt;/code&gt; 을 지정하면 &lt;em&gt;가상 집합 집계&lt;/em&gt; 가 작성됩니다. 이러한 집계는 순서에 따라 정렬 된 값 그룹을 처리하므로 입력 정렬 순서 지정이 호출의 필수 부분입니다. 또한, 그들은 &lt;em&gt;직접&lt;/em&gt; 할 수 있습니다&lt;em&gt;&lt;/em&gt;인수 : 입력 행당 한 번이 아니라 집계마다 한 번만 평가되는 인수입니다. 가설 집합 집계는 순서 인수 집합의 하위 클래스로, 일부 직접 인수는 집계 된 인수 열과 숫자 및 데이터 형식으로 일치해야합니다. 이를 통해 이러한 직접 인수의 값을 집계 입력 행 모음에 추가 &quot;가설 적&quot;행으로 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3670cc6e37bfe2baa6c265184cfb9070b0da0ca9" translate="yes" xml:space="preserve">
          <source>The syntaxes using &lt;code&gt;*&lt;/code&gt; are used for calling parameter-less aggregate functions as window functions, for example &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt;. The asterisk (&lt;code&gt;*&lt;/code&gt;) is customarily not used for window-specific functions. Window-specific functions do not allow &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; to be used within the function argument list.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 를 사용 하는 구문 은 &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt; 와 같이 매개 변수없는 집계 함수를 창 함수로 호출하는 데 사용됩니다 . 별표 ( &lt;code&gt;*&lt;/code&gt; )는 일반적으로 창 특정 기능에 사용되지 않습니다. 창 특정 함수는 &lt;code&gt;DISTINCT&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 를 함수 인수 목록 내에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5413e5588ef7474b4153013c25aed37daf2b6ac4" translate="yes" xml:space="preserve">
          <source>The system catalog &lt;code&gt;pg_language&lt;/code&gt; (see &lt;a href=&quot;catalog-pg-language&quot;&gt;Section 51.29&lt;/a&gt;) records information about the currently installed languages. Also, the psql command &lt;code&gt;\dL&lt;/code&gt; lists the installed languages.</source>
          <target state="translated">시스템 카탈로그 &lt;code&gt;pg_language&lt;/code&gt; ( &lt;a href=&quot;catalog-pg-language&quot;&gt;섹션 51.29&lt;/a&gt; 참조 )는 현재 설치된 언어에 대한 정보를 기록합니다. 또한 psql 명령 &lt;code&gt;\dL&lt;/code&gt; 은 설치된 언어를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="2583bf948cb2199416aaa963439f3392af0c4543" translate="yes" xml:space="preserve">
          <source>The system catalog cache code (and most catalog-munging code in general) assumes that the fixed-length portions of all system catalog tuples are in fact present, because it maps this C struct declaration onto them. Thus, all variable-length fields and nullable fields must be placed at the end, and they cannot be accessed as struct fields. For example, if you tried to set &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typrelid&lt;/code&gt; to be NULL, it would fail when some piece of code tried to reference &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; (or worse, &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt;, because that follows &lt;code&gt;typrelid&lt;/code&gt;). This would result in random errors or even segmentation violations.</source>
          <target state="translated">시스템 카탈로그 캐시 코드 (및 대부분의 카탈로그 검색 코드)는이 C 구조체 선언을 매핑하기 때문에 모든 시스템 카탈로그 튜플의 고정 길이 부분이 실제로 존재한다고 가정합니다. 따라서 모든 가변 길이 필드와 널 입력 가능 필드는 끝에 배치해야하며 구조체 필드로 액세스 할 수 없습니다. 예를 들어, &lt;code&gt;pg_type&lt;/code&gt; 을 설정하려고 시도한 경우 . &lt;code&gt;typrelid&lt;/code&gt; 이 코드의 일부 조각이 참조를 시도 할 때 실패, NULL로 &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; (또는 더 나쁜, &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt; , 그 다음 때문에 &lt;code&gt;typrelid&lt;/code&gt; ). 이로 인해 임의 오류가 발생하거나 세그먼테이션 위반이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb485f21372d37054b0b92886fc6889e8d0f2f48" translate="yes" xml:space="preserve">
          <source>The system catalog schema, &lt;code&gt;pg_catalog&lt;/code&gt;, is always searched, whether it is mentioned in the path or not. If it is mentioned in the path then it will be searched in the specified order. If &lt;code&gt;pg_catalog&lt;/code&gt; is not in the path then it will be searched &lt;em&gt;before&lt;/em&gt; searching any of the path items.</source>
          <target state="translated">시스템 카탈로그 스키마 &lt;code&gt;pg_catalog&lt;/code&gt; 는 경로에 언급되었는지 여부에 관계없이 항상 검색됩니다. 경로에 언급 된 경우 지정된 순서대로 검색됩니다. 경우 &lt;code&gt;pg_catalog&lt;/code&gt; 가 경로에없는 다음이 검색됩니다 &lt;em&gt;전에&lt;/em&gt; 경로 항목 중 하나를 검색.</target>
        </trans-unit>
        <trans-unit id="dffb9af79cadde8378337d566688f00f092c9630" translate="yes" xml:space="preserve">
          <source>The system catalogs store information about which conversions, or &lt;em&gt;casts&lt;/em&gt;, exist between which data types, and how to perform those conversions. Additional casts can be added by the user with the &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; command. (This is usually done in conjunction with defining new data types. The set of casts between built-in types has been carefully crafted and is best not altered.)</source>
          <target state="translated">시스템 카탈로그 는 어떤 데이터 유형간에 존재 하는 변환 또는 &lt;em&gt;캐스트&lt;/em&gt; 및 해당 변환 수행 방법에 대한 정보를 저장합니다 . &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; 명령으로 사용자가 추가 캐스트를 추가 할 수 있습니다 . (이는 일반적으로 새 데이터 유형을 정의하는 것과 관련하여 수행됩니다. 내장 유형 사이의 캐스트 세트는 신중하게 작성되었으며 변경되지 않는 것이 가장 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="94541a873b2d451108de2b46c0592e4902bdbb36" translate="yes" xml:space="preserve">
          <source>The system uses no more than &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, &lt;code&gt;NAMEDATALEN&lt;/code&gt; is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the &lt;code&gt;NAMEDATALEN&lt;/code&gt; constant in &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt;.</source>
          <target state="translated">시스템은 &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1 바이트 이하의 식별자를 사용합니다. 더 긴 이름은 명령으로 쓸 수 있지만 잘립니다. 기본적으로 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 은 64이므로 최대 식별자 길이는 63 바이트입니다. 이 한계에 문제가 있으면 &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt; 에서 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 상수를 변경하여 증가시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18aee9967e71bb22ca6c7ef97d956490785417e5" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-file-settings&quot;&gt;&lt;code&gt;pg_file_settings&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the configuration files, or for diagnosing problems if a SIGHUP signal did not have the desired effects.</source>
          <target state="translated">시스템보기 &lt;a href=&quot;view-pg-file-settings&quot;&gt; &lt;code&gt;pg_file_settings&lt;/code&gt; &lt;/a&gt; 는 구성 파일의 변경 사항을 사전 테스트하거나 SIGHUP 신호에 원하는 효과가없는 경우 문제를 진단하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51af27f0b42d0a59cf04312463422fdaffc06293" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-hba-file-rules&quot;&gt;&lt;code&gt;pg_hba_file_rules&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the &lt;code&gt;pg_hba.conf&lt;/code&gt; file, or for diagnosing problems if loading of the file did not have the desired effects. Rows in the view with non-null &lt;code&gt;error&lt;/code&gt; fields indicate problems in the corresponding lines of the file.</source>
          <target state="translated">시스템 뷰 &lt;a href=&quot;view-pg-hba-file-rules&quot;&gt; &lt;code&gt;pg_hba_file_rules&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일의 변경 사항을 사전 테스트 하거나 파일로드에 원하는 효과가없는 경우 문제를 진단 하는 데 도움이 될 수 있습니다 . 널이 아닌 &lt;code&gt;error&lt;/code&gt; 필드 가있는보기의 행 은 파일의 해당 행에 문제점이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0d1a0c3c602b5e69816adbc6a5f72656d7deb220" translate="yes" xml:space="preserve">
          <source>The system-wide startup file is named &lt;code&gt;psqlrc&lt;/code&gt; and is sought in the installation's &amp;ldquo;system configuration&amp;rdquo; directory, which is most reliably identified by running &lt;code&gt;pg_config --sysconfdir&lt;/code&gt;. By default this directory will be &lt;code&gt;../etc/&lt;/code&gt; relative to the directory containing the PostgreSQL executables. The name of this directory can be set explicitly via the &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">시스템 전체의 시작 파일 이름은 &lt;code&gt;psqlrc&lt;/code&gt; 이며 설치의 &quot;시스템 구성&quot;디렉토리에서 찾을 수 있습니다.이 디렉토리는 &lt;code&gt;pg_config --sysconfdir&lt;/code&gt; 을 실행하여 가장 안정적으로 식별됩니다 . 기본적으로이 디렉토리는 PostgreSQL 실행 파일을 포함하는 디렉토리와 관련하여 &lt;code&gt;../etc/&lt;/code&gt; 입니다. 이 디렉토리의 이름은 &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; 환경 변수 를 통해 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9987d6e81d602450ad224137a711661462f4308" translate="yes" xml:space="preserve">
          <source>The table also shows that PostgreSQL's Repeatable Read implementation does not allow phantom reads. Stricter behavior is permitted by the SQL standard: the four isolation levels only define which phenomena must not happen, not which phenomena &lt;em&gt;must&lt;/em&gt; happen. The behavior of the available isolation levels is detailed in the following subsections.</source>
          <target state="translated">이 표는 또한 PostgreSQL의 반복 가능한 읽기 구현이 팬텀 읽기를 허용하지 않음을 보여줍니다. SQL 표준에서는보다 엄격한 동작이 허용됩니다. 4 가지 격리 수준은 어떤 현상이 발생하지 않아야하는지, 어떤 현상 &lt;em&gt;이&lt;/em&gt; 발생 하지 않아야하는지 만 정의 &lt;em&gt;합니다&lt;/em&gt; . 사용 가능한 격리 수준의 동작은 다음 하위 섹션에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="142b69e02a67de00ba841f641f5ef3fa34a277d2" translate="yes" xml:space="preserve">
          <source>The table definition above includes a primary key specification. This is useful to protect against accidentally importing the same information twice. The &lt;code&gt;COPY&lt;/code&gt; command commits all of the data it imports at one time, so any error will cause the entire import to fail. If you import a partial log file and later import the file again when it is complete, the primary key violation will cause the import to fail. Wait until the log is complete and closed before importing. This procedure will also protect against accidentally importing a partial line that hasn't been completely written, which would also cause &lt;code&gt;COPY&lt;/code&gt; to fail.</source>
          <target state="translated">위의 테이블 정의에는 기본 키 사양이 포함되어 있습니다. 이는 동일한 정보를 실수로 두 번 가져 오는 것을 방지하는 데 유용합니다. &lt;code&gt;COPY&lt;/code&gt; 오류가 전체 가져 오기가 실패 할 수 있도록 명령, 그것은 한 번에 가져 오는 모든 데이터를 커밋합니다. 부분 로그 파일을 가져오고 나중에 파일이 완료 될 때 파일을 다시 가져 오면 기본 키 위반으로 가져 오기가 실패합니다. 가져 오기 전에 로그가 완료되고 닫힐 때까지 기다리십시오. 이 절차는 또한 완전히 작성되지 않은 부분 라인을 실수로 가져 오는 것을 방지하여 &lt;code&gt;COPY&lt;/code&gt; 가 실패하는 원인이 됩니다.</target>
        </trans-unit>
        <trans-unit id="990156ac1571d648e7c5aa23d608c8979b58753e" translate="yes" xml:space="preserve">
          <source>The table is also vacuumed if the number of tuples inserted since the last vacuum has exceeded the defined insert threshold, which is defined as:</source>
          <target state="translated">The table is also vacuumed if the number of tuples inserted since the last vacuum has exceeded the defined insert threshold, which is defined as:</target>
        </trans-unit>
        <trans-unit id="8b15dacbb7afc519b6433f93ec4919614f65b399" translate="yes" xml:space="preserve">
          <source>The table is partitioned by explicitly listing which key values appear in each partition.</source>
          <target state="translated">각 파티션에 표시되는 키 값을 명시 적으로 나열하여 테이블이 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="b51488835cbb40ee5da1ee3d9a8f7864d4b57976" translate="yes" xml:space="preserve">
          <source>The table is partitioned by specifying a modulus and a remainder for each partition. Each partition will hold the rows for which the hash value of the partition key divided by the specified modulus will produce the specified remainder.</source>
          <target state="translated">테이블은 각 파티션에 대한 계수와 나머지를 지정하여 파티션됩니다. 각 파티션은 파티션 키의 해시 값을 지정된 계수로 나눈 행을 보유하며 지정된 나머지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7c5e839b9bae27b38d6af54b60ca56e0b347f0f2" translate="yes" xml:space="preserve">
          <source>The table is partitioned into &amp;ldquo;ranges&amp;rdquo; defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, one might partition by date ranges, or by ranges of identifiers for particular business objects.</source>
          <target state="translated">테이블은 키 열 또는 열 집합에 의해 정의 된 &quot;범위&quot;로 분할되며 다른 파티션에 할당 된 값 범위간에 겹치지 않습니다. 예를 들어, 날짜 범위 또는 특정 비즈니스 오브젝트의 식별자 범위별로 파티션을 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="292e8b677c187c4d68b1ebe250d22a32e9af8561" translate="yes" xml:space="preserve">
          <source>The table or index that the described column belongs to</source>
          <target state="translated">설명 된 컬럼이 속하는 테이블 또는 인덱스</target>
        </trans-unit>
        <trans-unit id="d142b3cf8f5a90793004bbdd69de61322293bd63" translate="yes" xml:space="preserve">
          <source>The table referenced by a referential integrity constraint</source>
          <target state="translated">참조 무결성 제약 조건으로 참조되는 테이블</target>
        </trans-unit>
        <trans-unit id="2a8191ca3a1df3ed6d1e85b59a92238d8c6f7d14" translate="yes" xml:space="preserve">
          <source>The table this column belongs to</source>
          <target state="translated">이 열이 속한 테이블</target>
        </trans-unit>
        <trans-unit id="75cfe910e753a5d9a7438e22a49cad2342942a50" translate="yes" xml:space="preserve">
          <source>The table this constraint is on; 0 if not a table constraint</source>
          <target state="translated">이 제약 조건이있는 테이블입니다. 테이블 제약 조건이 아닌 경우 0</target>
        </trans-unit>
        <trans-unit id="2f088db11eed75527c26721e5e66e62e0678aeb6" translate="yes" xml:space="preserve">
          <source>The table this rule is for</source>
          <target state="translated">이 규칙이 적용되는 테이블</target>
        </trans-unit>
        <trans-unit id="ac24dc8d3f1364ef3223d38811cd0f1cdfc7bc70" translate="yes" xml:space="preserve">
          <source>The table this trigger is on</source>
          <target state="translated">이 트리거가있는 테이블</target>
        </trans-unit>
        <trans-unit id="d2d2364aa6d119df4f431f30d6909fa91ae4a412" translate="yes" xml:space="preserve">
          <source>The table to which the policy applies</source>
          <target state="translated">정책이 적용되는 테이블</target>
        </trans-unit>
        <trans-unit id="539b9dae513896d5721c3d82785ae25ab4799ccf" translate="yes" xml:space="preserve">
          <source>The tables added to a publication that publishes &lt;code&gt;UPDATE&lt;/code&gt; and/or &lt;code&gt;DELETE&lt;/code&gt; operations must have &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; defined. Otherwise those operations will be disallowed on those tables.</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; 및 / 또는 &lt;code&gt;DELETE&lt;/code&gt; 조작 을 공개하는 발행물에 추가 된 테이블 에는 &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; 가 정의되어 있어야합니다 . 그렇지 않으면 해당 테이블에서 해당 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="367460ef7d1ca64d14464409850a0a51a7ab7dc7" translate="yes" xml:space="preserve">
          <source>The tables are matched between the publisher and the subscriber using the fully qualified table name. Replication to differently-named tables on the subscriber is not supported.</source>
          <target state="translated">정규화 된 테이블 이름을 사용하여 게시자와 구독자간에 테이블이 일치합니다. 구독자에서 다른 이름의 테이블에 대한 복제는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3c0314798fd15f5ed903ef71976f9e615a0bb52" translate="yes" xml:space="preserve">
          <source>The tablespace associated with a database is used to store the system catalogs of that database. Furthermore, it is the default tablespace used for tables, indexes, and temporary files created within the database, if no &lt;code&gt;TABLESPACE&lt;/code&gt; clause is given and no other selection is specified by &lt;code&gt;default_tablespace&lt;/code&gt; or &lt;code&gt;temp_tablespaces&lt;/code&gt; (as appropriate). If a database is created without specifying a tablespace for it, it uses the same tablespace as the template database it is copied from.</source>
          <target state="translated">데이터베이스와 연관된 테이블 스페이스는 해당 데이터베이스의 시스템 카탈로그를 저장하는 데 사용됩니다. 또한 &lt;code&gt;TABLESPACE&lt;/code&gt; 절이 제공되지 않고 &lt;code&gt;default_tablespace&lt;/code&gt; 또는 &lt;code&gt;temp_tablespaces&lt;/code&gt; 에 의해 다른 선택 사항이 지정되지 않은 경우 데이터베이스 내에서 작성된 테이블, 인덱스 및 임시 파일에 사용되는 기본 테이블 스페이스 입니다. 데이터베이스가 테이블 스페이스를 지정하지 않고 작성되면 데이터베이스에서 복사 된 템플리트 데이터베이스와 동일한 테이블 스페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cd0a83e9744372d73f37f6c31fa32edd33e0f557" translate="yes" xml:space="preserve">
          <source>The tablespace in which this relation is stored. If zero, the database's default tablespace is implied. (Not meaningful if the relation has no on-disk file.)</source>
          <target state="translated">이 관계가 저장되는 테이블 스페이스입니다. 0이면 데이터베이스의 기본 테이블 스페이스가 암시됩니다. (관계에 디스크 파일이없는 경우에는 의미가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="91ace69fa784c06e03e2d35b1b8ec1909d7a7501" translate="yes" xml:space="preserve">
          <source>The tablespace in which to create the index. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; for indexes on temporary tables.</source>
          <target state="translated">인덱스를 작성할 테이블 스페이스입니다. 지정하지 않으면 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 가 참조되거나 임시 테이블의 인덱스에 대한 &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; 가 참조 됩니다.</target>
        </trans-unit>
        <trans-unit id="6945a89a0355036aac3b6ff63ff9fc68b1cb28a4" translate="yes" xml:space="preserve">
          <source>The tablespace to which the index will be moved.</source>
          <target state="translated">인덱스가 이동 될 테이블 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="2fdf7a817dfba5e9f0aef01d7a04fe1bad9896f5" translate="yes" xml:space="preserve">
          <source>The tag, if any, of a dollar-quoted string follows the same rules as an unquoted identifier, except that it cannot contain a dollar sign. Tags are case sensitive, so &lt;code&gt;$tag$String content$tag$&lt;/code&gt; is correct, but &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; is not.</source>
          <target state="translated">달러 인용 문자열의 태그 (있는 경우)는 인용 부호를 포함 할 수 없다는 점을 제외하고는 인용되지 않은 식별자와 동일한 규칙을 따릅니다. 태그는 대소 문자를 구분하므로 &lt;code&gt;$tag$String content$tag$&lt;/code&gt; 는 정확하지만 &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; 는 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bef8aba7a1bcf650d04e76e3a3595346989e8039" translate="yes" xml:space="preserve">
          <source>The target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order; or the first &lt;code&gt;N&lt;/code&gt; column names, if there are only &lt;code&gt;N&lt;/code&gt; columns supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt;. The values supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt; are associated with the explicit or implicit column list left-to-right.</source>
          <target state="translated">대상 열 이름은 임의의 순서로 나열 될 수 있습니다. 열 이름 목록이 전혀 제공되지 않으면 기본값은 선언 된 순서대로 테이블의 모든 열입니다. 또는 상기 제 &lt;code&gt;N&lt;/code&gt; 의 열 이름 만이 있다면 &lt;code&gt;N&lt;/code&gt; 에 의해 공급 된 열 &lt;code&gt;VALUES&lt;/code&gt; 의 절 또는 &lt;code&gt;query&lt;/code&gt; . &lt;code&gt;VALUES&lt;/code&gt; 절 또는 &lt;code&gt;query&lt;/code&gt; 에서 제공 한 값 은 왼쪽에서 오른쪽으로 명시 적 또는 암시 적 열 목록과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a52fa4d647d2a0e534fa04140c4a0531834e1437" translate="yes" xml:space="preserve">
          <source>The target function can be specified by name alone, or by name and arguments, for example &lt;code&gt;foo(integer, text)&lt;/code&gt;. The argument types must be given if there is more than one function of the same name.</source>
          <target state="translated">대상 함수는 이름만으로 지정하거나 이름 및 인수로 지정할 수 있습니다 &lt;code&gt;foo(integer, text)&lt;/code&gt; 예 : foo (integer, text)) . 동일한 이름의 함수가 둘 이상인 경우 인수 유형을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a83f3ee2747bb5a0ebf49f8f4cc7233f65fe3b6" translate="yes" xml:space="preserve">
          <source>The task of the &lt;em&gt;planner/optimizer&lt;/em&gt; is to create an optimal execution plan. A given SQL query (and hence, a query tree) can be actually executed in a wide variety of different ways, each of which will produce the same set of results. If it is computationally feasible, the query optimizer will examine each of these possible execution plans, ultimately selecting the execution plan that is expected to run the fastest.</source>
          <target state="translated">&lt;em&gt;플래너 / 최적화 기&lt;/em&gt; 의 작업은 최적의 실행 계획을 만드는 것입니다. 주어진 SQL 쿼리 (따라서 쿼리 트리)는 실제로 다양한 방식으로 실행될 수 있으며, 각 방법은 동일한 결과 집합을 생성합니다. 계산이 가능한 경우 쿼리 최적화 프로그램은 이러한 가능한 각 실행 계획을 검사하여 궁극적으로 가장 빠른 실행 계획을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d0cfcd2522974bd11b7e720b66ddba5e0dc99d8f" translate="yes" xml:space="preserve">
          <source>The technical difference between a &lt;code&gt;jsonb_ops&lt;/code&gt; and a &lt;code&gt;jsonb_path_ops&lt;/code&gt; GIN index is that the former creates independent index items for each key and value in the data, while the latter creates index items only for each value in the data. &lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt; Basically, each &lt;code&gt;jsonb_path_ops&lt;/code&gt; index item is a hash of the value and the key(s) leading to it; for example to index &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt;, a single index item would be created incorporating all three of &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; into the hash value. Thus a containment query looking for this structure would result in an extremely specific index search; but there is no way at all to find out whether &lt;code&gt;foo&lt;/code&gt; appears as a key. On the other hand, a &lt;code&gt;jsonb_ops&lt;/code&gt; index would create three index items representing &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; separately; then to do the containment query, it would look for rows containing all three of these items. While GIN indexes can perform such an AND search fairly efficiently, it will still be less specific and slower than the equivalent &lt;code&gt;jsonb_path_ops&lt;/code&gt; search, especially if there are a very large number of rows containing any single one of the three index items.</source>
          <target state="translated">&lt;code&gt;jsonb_ops&lt;/code&gt; 와 &lt;code&gt;jsonb_path_ops&lt;/code&gt; GIN 인덱스 의 기술적 차이점 은 전자가 데이터의 각 키와 값에 대해 독립적 인 인덱스 항목을 작성하고 후자는 데이터의 각 값에 대해서만 색인 항목을 작성한다는 것입니다. &lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt; 기본적으로 각 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 인덱스 항목은 값의 해시 이며이 값으로 이어지는 키입니다. 예를 들어 &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt; 인덱싱하기 위해 &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 세 개를 모두 해시 값으로 통합하는 단일 인덱스 항목이 작성 됩니다. 따라서이 구조를 찾는 격리 쿼리는 매우 특정한 인덱스 검색을 초래합니다. 그러나 여부를 알 수있는 방법은 전혀 없습니다 &lt;code&gt;foo&lt;/code&gt; 가 키로 나타납니다. 반면에 &lt;code&gt;jsonb_ops&lt;/code&gt; 인덱스는 &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 를 별도로 나타내는 세 개의 인덱스 항목을 만듭니다 . 그런 다음 포함 쿼리를 수행하기 위해 이러한 세 가지 항목이 모두 포함 된 행을 찾습니다. GIN 인덱스는 이러한 AND 검색을 상당히 효율적으로 수행 할 수 있지만 , 특히 세 개의 인덱스 항목 중 하나를 포함하는 행이 매우 많은 경우 동등한 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 검색 보다 덜 구체적이고 느립니다 .</target>
        </trans-unit>
        <trans-unit id="1c8f7bc59665b224be12f558ca16a9e07627bb77" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block.</source>
          <target state="translated">임시 테이블은 현재 트랜잭션 블록의 끝에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="2e88ee252852e295414cf3850a24be66c227bee2" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block. When used on a partitioned table, this action drops its partitions and when used on tables with inheritance children, it drops the dependent children.</source>
          <target state="translated">임시 테이블은 현재 트랜잭션 블록의 끝에서 삭제됩니다. 파티션 된 테이블에서 사용될 때이 조치는 파티션을 삭제하고 상속 하위가있는 테이블에서 사용되는 경우 종속 하위를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="544789fd88fe85a89dc95a84868e683fa382498a" translate="yes" xml:space="preserve">
          <source>The term attribute is equivalent to column and is used for historical reasons.</source>
          <target state="translated">속성이라는 용어는 열과 동일하며 역사적 이유로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a7c2d2771e24236d6f1bdd6761fd668754e8bc" translate="yes" xml:space="preserve">
          <source>The text representation of an &lt;code&gt;hstore&lt;/code&gt;, used for input and output, includes zero or more &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs separated by commas. Some examples:</source>
          <target state="translated">입력 및 출력에 사용되는 &lt;code&gt;hstore&lt;/code&gt; 의 텍스트 표현 에는 쉼표로 구분 된 0 개 이상의 &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 쌍이 포함됩니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="98a0a387ebcc73eb1a002f76f9873cf6168a1347" translate="yes" xml:space="preserve">
          <source>The text-search functionality in PostgreSQL can also be used to speed up full-document searches of XML data. The necessary preprocessing support is, however, not yet available in the PostgreSQL distribution.</source>
          <target state="translated">PostgreSQL의 텍스트 검색 기능을 사용하여 XML 데이터의 전체 문서 검색 속도를 높일 수도 있습니다. 그러나 필요한 전처리 지원은 아직 PostgreSQL 배포판에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9535cead63cebae1ff29d54da604a76ade0e73e1" translate="yes" xml:space="preserve">
          <source>The textual label for this enum value</source>
          <target state="translated">이 열거 치의 텍스트 라벨</target>
        </trans-unit>
        <trans-unit id="5d79225bbaf1bc36cb45016180fd38042b31a872" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary &lt;code&gt;thesaurus_astro&lt;/code&gt; does know the phrase &lt;code&gt;supernovae stars&lt;/code&gt;, but &lt;code&gt;ts_lexize&lt;/code&gt; fails since it does not parse the input text but treats it as a single token. Use &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;to_tsvector&lt;/code&gt; to test thesaurus dictionaries, for example:</source>
          <target state="translated">동의어 사전 사전 &lt;code&gt;thesaurus_astro&lt;/code&gt; 는 &lt;code&gt;supernovae stars&lt;/code&gt; 라는 문구를 알고 있지만 입력 텍스트를 구문 분석하지 않고 단일 토큰으로 취급하므로 &lt;code&gt;ts_lexize&lt;/code&gt; 가 실패합니다. 다음과 같이 &lt;code&gt;plainto_tsquery&lt;/code&gt; 또는 &lt;code&gt;to_tsvector&lt;/code&gt; 를 사용 하여 시소러스 사전을 테스트 하십시오 .</target>
        </trans-unit>
        <trans-unit id="497ebaef7c7bb30921967269b6dd4bfd06472628" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary chooses the longest match if there are multiple phrases matching the input, and ties are broken by using the last definition.</source>
          <target state="translated">동의어 사전은 입력과 일치하는 여러 구가 있고 마지막 정의를 사용하여 연결이 끊어지면 가장 긴 일치 항목을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6384b1615ea61227de680b163bce3c7f613d4849" translate="yes" xml:space="preserve">
          <source>The third form changes the owner of the database. To alter the owner, you must own the database and also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. (Note that superusers have all these privileges automatically.)</source>
          <target state="translated">세 번째 양식은 데이터베이스 소유자를 변경합니다. 소유자를 변경하려면 데이터베이스를 소유하고 새 소유 역할의 직접 또는 간접 구성원이어야하며 &lt;code&gt;CREATEDB&lt;/code&gt; 권한 이 있어야합니다 . (수퍼 유저에게는 이러한 모든 권한이 자동으로 부여됩니다.)</target>
        </trans-unit>
        <trans-unit id="fb3a4f1cf7c17f675b6c88c65b759e2c18503d10" translate="yes" xml:space="preserve">
          <source>The third form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new range type, as described in &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; 의 세 번째 형식은 &lt;a href=&quot;rangetypes&quot;&gt;8.17 절&lt;/a&gt; 에서 설명한대로 새 범위 유형을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="46e5d7ec29a414875ddb7427a1366569e134347d" translate="yes" xml:space="preserve">
          <source>The third parameter being &lt;code&gt;false&lt;/code&gt; tells &lt;code&gt;pg_start_backup&lt;/code&gt; to initiate a non-exclusive base backup.</source>
          <target state="translated">세 번째 매개 변수가 &lt;code&gt;false&lt;/code&gt; &lt;code&gt;pg_start_backup&lt;/code&gt; 이 비 독점적 기본 백업을 시작하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="43c4f141a3275bbc30bab46035e573f420cd4242" translate="yes" xml:space="preserve">
          <source>The third syntax was used before PostgreSQL version 9.6 and is still supported. It's the same as the first syntax with &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;num_sync&lt;/code&gt; equal to 1. For example, &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; and &lt;code&gt;s1, s2&lt;/code&gt; have the same meaning: either &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; is chosen as a synchronous standby.</source>
          <target state="translated">세 번째 구문은 PostgreSQL 버전 9.6 이전에 사용되었으며 여전히 지원됩니다. &lt;code&gt;FIRST&lt;/code&gt; 및 &lt;code&gt;num_sync&lt;/code&gt; 가 1 인 첫 번째 구문과 동일합니다. 예를 들어, &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; 및 &lt;code&gt;s1, s2&lt;/code&gt; 는 동일한 의미를 갖습니다. &lt;code&gt;s1&lt;/code&gt; 또는 &lt;code&gt;s2&lt;/code&gt; 는 동기 대기로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="bce8828bcc021e862db732b17b8f2b754b34f3cc" translate="yes" xml:space="preserve">
          <source>The third variant changes the name of the group. This is exactly equivalent to renaming the role with &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;.</source>
          <target state="translated">세 번째 변형은 그룹의 이름을 변경합니다. 이것은 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE로&lt;/a&gt; 역할 이름을 바꾸는 것과 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e2d943d4346301a5cf1de51eecfb3a352a414893" translate="yes" xml:space="preserve">
          <source>The time at which the cursor was declared</source>
          <target state="translated">커서가 선언 된 시간</target>
        </trans-unit>
        <trans-unit id="ec4185f356c4ef6086071a2e178362bf4f8c1b5e" translate="yes" xml:space="preserve">
          <source>The time at which the prepared statement was created</source>
          <target state="translated">준비된 명세서가 작성된 시간</target>
        </trans-unit>
        <trans-unit id="ffd5bbf754455019459a28dd71a5db592d1e512d" translate="yes" xml:space="preserve">
          <source>The time fields in a transition rule have the same format as the offset fields described previously, except that they cannot contain signs. They define the current local time at which the change to the other time occurs. If omitted, they default to &lt;code&gt;02:00:00&lt;/code&gt;.</source>
          <target state="translated">The time fields in a transition rule have the same format as the offset fields described previously, except that they cannot contain signs. They define the current local time at which the change to the other time occurs. If omitted, they default to &lt;code&gt;02:00:00&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e8bb2f344559ea1d916061668ce3e9aa5b7836" translate="yes" xml:space="preserve">
          <source>The time zone 7 hours west from UTC (equivalent to PDT). Positive values are east from UTC.</source>
          <target state="translated">표준 시간대는 UTC에서 서쪽으로 7 시간입니다 (PDT와 동일). 양수 값은 UTC에서 동쪽입니다.</target>
        </trans-unit>
        <trans-unit id="ee80f641d8eab20953a3190cfb6422152c737dea" translate="yes" xml:space="preserve">
          <source>The time zone 8 hours west from UTC (equivalent to PST).</source>
          <target state="translated">표준 시간대는 UTC에서 서쪽으로 8 시간입니다 (PST와 동일).</target>
        </trans-unit>
        <trans-unit id="3d03995667dbda87e63122260f5c6f6cb9fe649a" translate="yes" xml:space="preserve">
          <source>The time zone for Berkeley, California.</source>
          <target state="translated">캘리포니아 버클리의 시간대.</target>
        </trans-unit>
        <trans-unit id="668f3cdec134bede84a934a9af41142895f7b007" translate="yes" xml:space="preserve">
          <source>The time zone for Italy.</source>
          <target state="translated">이탈리아의 시간대.</target>
        </trans-unit>
        <trans-unit id="c7ed4ff2c6ce4f9a9cd61b96f6374cf02812e246" translate="yes" xml:space="preserve">
          <source>The time zone offset from UTC, measured in seconds. Positive values correspond to time zones east of UTC, negative values to zones west of UTC. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.)</source>
          <target state="translated">UTC와의 시간대 오프셋 (초)입니다. 양수 값은 UTC 동부 표준 시간대에 해당하고 음수 값은 UTC 서쪽 표준 시간대에 해당합니다. 기술적으로 PostgreSQL은 윤초를 처리하지 않기 때문에 UTC를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ca5243d8e51420e24c77cdd1c3e577fee34053c" translate="yes" xml:space="preserve">
          <source>The time-of-day types are &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; and &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt;. &lt;code&gt;time&lt;/code&gt; alone is equivalent to &lt;code&gt;time without time zone&lt;/code&gt;.</source>
          <target state="translated">시간대 유형은 &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; 가없는 시간 [(p)] 및 시간대 가있는 &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt; . &lt;code&gt;time&lt;/code&gt; 만은 &lt;code&gt;time without time zone&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="404ebb0f442feebec6561a16038577c2da51bc2d" translate="yes" xml:space="preserve">
          <source>The timeline for this range of WAL records, as an integer.</source>
          <target state="translated">The timeline for this range of WAL records, as an integer.</target>
        </trans-unit>
        <trans-unit id="14e09ea608f1f50e50cadf98aabc877a7444e25e" translate="yes" xml:space="preserve">
          <source>The timeout is measured from the time a command arrives at the server until it is completed by the server. If multiple SQL statements appear in a single simple-Query message, the timeout is applied to each statement separately. (PostgreSQL versions before 13 usually treated the timeout as applying to the whole query string.) In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is canceled by completion of an Execute or Sync message.</source>
          <target state="translated">The timeout is measured from the time a command arrives at the server until it is completed by the server. If multiple SQL statements appear in a single simple-Query message, the timeout is applied to each statement separately. (PostgreSQL versions before 13 usually treated the timeout as applying to the whole query string.) In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is canceled by completion of an Execute or Sync message.</target>
        </trans-unit>
        <trans-unit id="41de03730261b036dd783f63ba08317d9d3e641d" translate="yes" xml:space="preserve">
          <source>The timeout is measured from the time a command arrives at the server until it is completed by the server. In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is cancelled by completion of an Execute or Sync message.</source>
          <target state="translated">제한 시간은 명령이 서버에 도달 한 시간부터 서버에 의해 완료 될 때까지 측정됩니다. 확장 쿼리 프로토콜에서 쿼리 관련 메시지 (Parse, Bind, Execute, Describe)가 도착하면 시간 초과가 실행되기 시작하고 Execute 또는 Sync 메시지가 완료되면 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="1f30fb914124c09d41ba75a819d8afdbb3ea8c79" translate="yes" xml:space="preserve">
          <source>The toast_tuple_target specifies the minimum tuple length required before we try to compress and/or move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This affects columns marked as External (for move), Main (for compression), or Extended (for both) and applies only to new tuples. There is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default block size will be 2040 bytes. Valid values are between 128 bytes and the (block size - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">The toast_tuple_target specifies the minimum tuple length required before we try to compress and/or move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This affects columns marked as External (for move), Main (for compression), or Extended (for both) and applies only to new tuples. There is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default block size will be 2040 bytes. Valid values are between 128 bytes and the (block size - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</target>
        </trans-unit>
        <trans-unit id="d98b14f1fa1ca6a1d2cfd5fbd83b532ce899e731" translate="yes" xml:space="preserve">
          <source>The toast_tuple_target specifies the minimum tuple length required before we try to move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This only affects columns marked as either External or Extended and applies only to new tuples - there is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default blocksize will be 2040 bytes. Valid values are between 128 bytes and the (blocksize - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">toast_tuple_target은 긴 열 값을 TOAST 테이블로 이동하기 전에 필요한 최소 튜플 길이를 지정하며, 토스트가 시작되면 길이를 아래로 줄이려고하는 대상 길이이기도합니다. 이것은 외부 또는 확장으로 표시된 열에 만 영향을 미치며 새 튜플에만 적용되며 기존 행에는 영향을 미치지 않습니다. 기본적으로이 매개 변수는 블록 당 최소 4 개의 튜플을 허용하도록 설정되며 기본 블록 크기는 2040 바이트입니다. 유효한 값은 기본적으로 8160 바이트 인 128 바이트와 (blocksize-헤더) 사이입니다. 이 값을 변경하면 매우 짧거나 긴 행에는 유용하지 않을 수 있습니다. 기본 설정은 종종 최적에 가까우며이 매개 변수를 설정하면 경우에 따라 부정적인 영향을 줄 수 있습니다. TOAST 테이블에는이 매개 변수를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="621d22a0cd204d89633ad09943ee84f1181db01e" translate="yes" xml:space="preserve">
          <source>The total number of columns in the index (duplicates &lt;code&gt;pg_class.relnatts&lt;/code&gt;); this number includes both key and included attributes</source>
          <target state="translated">인덱스의 총 열 수 ( &lt;code&gt;pg_class.relnatts&lt;/code&gt; 중복 ) 이 숫자에는 키 및 포함 된 속성이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f560f36dfc9d943beeddde2257c0e1b305d7ee85" translate="yes" xml:space="preserve">
          <source>The transaction ID epoch is not actually stored anywhere in the database except in the field that is set by &lt;code&gt;pg_resetwal&lt;/code&gt;, so any value will work so far as the database itself is concerned. You might need to adjust this value to ensure that replication systems such as Slony-I and Skytools work correctly &amp;mdash; if so, an appropriate value should be obtainable from the state of the downstream replicated database.</source>
          <target state="translated">트랜잭션 ID 에포크는 실제로 &lt;code&gt;pg_resetwal&lt;/code&gt; 에 의해 설정된 필드를 제외하고 데이터베이스의 어느 곳에도 저장되지 않으므로 데이터베이스 자체에 관한 한 모든 값이 작동합니다. Slony-I 및 Skytools와 같은 복제 시스템이 올바르게 작동하도록이 값을 조정해야 할 경우 다운 스트림 복제 된 데이터베이스의 상태에서 적절한 값을 얻을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c3634c8a4a4ce9f542309bb5a4cc86011569d07" translate="yes" xml:space="preserve">
          <source>The transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed: &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;COPY FROM&lt;/code&gt; if the table they would write to is not a temporary table; all &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;ALTER&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; commands; &lt;code&gt;COMMENT&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;; and &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; and &lt;code&gt;EXECUTE&lt;/code&gt; if the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk.</source>
          <target state="translated">트랜잭션 액세스 모드는 트랜잭션이 읽기 / 쓰기인지 읽기 전용인지를 결정합니다. 읽기 / 쓰기가 기본값입니다. 트랜잭션이 읽기 전용 인 경우 다음 SQL 명령은 허용되지 않습니다. &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 및 &lt;code&gt;COPY FROM&lt;/code&gt; 은 쓰기 테이블이 임시 테이블이 아닌 경우입니다. 모든 &lt;code&gt;CREATE&lt;/code&gt; , &lt;code&gt;ALTER&lt;/code&gt; 및 &lt;code&gt;DROP&lt;/code&gt; 명령; &lt;code&gt;COMMENT&lt;/code&gt; , &lt;code&gt;GRANT&lt;/code&gt; , &lt;code&gt;REVOKE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; ; 및 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 및 &lt;code&gt;EXECUTE&lt;/code&gt; 그들이 실행할 명령이 나열된 명령 중 하나입니다. 이것은 디스크에 대한 모든 쓰기를 막지 않는 읽기 전용의 고급 개념입니다.</target>
        </trans-unit>
        <trans-unit id="75f4c782782aa478238329da73889aa36680137b" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be committed.</source>
          <target state="translated">커밋 할 트랜잭션의 트랜잭션 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="cf987258f7d6ba8e2728a7ab480e418085360e38" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be rolled back.</source>
          <target state="translated">롤백 할 트랜잭션의 트랜잭션 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="9eeef0c349968aef779233f9f813d33249bc7a83" translate="yes" xml:space="preserve">
          <source>The transaction isolation level cannot be changed after the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">트랜잭션의 첫 번째 쿼리 또는 데이터 수정 명령문 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; 또는 &lt;code&gt;COPY&lt;/code&gt; )이 실행 된 후에는 트랜잭션 분리 레벨을 변경할 수 없습니다 . 트랜잭션 격리 및 동시성 제어에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fe24188c8709c03cdec891a49204bbf4cf162d4" translate="yes" xml:space="preserve">
          <source>The transaction isolation level cannot be changed after the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">The transaction isolation level cannot be changed after the first query or data-modification statement ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; , or &lt;code&gt;COPY&lt;/code&gt; ) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</target>
        </trans-unit>
        <trans-unit id="ed3fff67b302c5509e4a3c68f6d878b34bcf063e" translate="yes" xml:space="preserve">
          <source>The transactional behavior of &lt;code&gt;RESET&lt;/code&gt; is the same as &lt;code&gt;SET&lt;/code&gt;: its effects will be undone by transaction rollback.</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 의 트랜잭션 동작은 &lt;code&gt;SET&lt;/code&gt; 과 동일 합니다. 트랜잭션 롤백에 의해 그 효과가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="bd74e2a12fdda047e415ded6637d08f54eb6f6c6" translate="yes" xml:space="preserve">
          <source>The translation of login credentials in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; to credentials in a remote data system defined by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;.</source>
          <target state="translated">The translation of login credentials in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; to credentials in a remote data system defined by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="75001c08db137e17c60a1922c998f38549cfd962" translate="yes" xml:space="preserve">
          <source>The translations from internal enum values to textual labels are kept in the system catalog &lt;a href=&quot;catalog-pg-enum&quot;&gt;&lt;code&gt;pg_enum&lt;/code&gt;&lt;/a&gt;. Querying this catalog directly can be useful.</source>
          <target state="translated">내부 열거 형 값에서 텍스트 레이블로의 변환은 시스템 카탈로그 &lt;a href=&quot;catalog-pg-enum&quot;&gt; &lt;code&gt;pg_enum&lt;/code&gt; 에&lt;/a&gt; 보관됩니다 . 이 카탈로그를 직접 쿼리하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d50a1ac1c4a79cbe553bfb51786402f941c2b3ba" translate="yes" xml:space="preserve">
          <source>The trigger can be specified to fire before the operation is attempted on a row (before constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; is attempted); or after the operation has completed (after constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; has completed); or instead of the operation (in the case of inserts, updates or deletes on a view). If the trigger fires before or instead of the event, the trigger can skip the operation for the current row, or change the row being inserted (for &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; operations only). If the trigger fires after the event, all changes, including the effects of other triggers, are &amp;ldquo;visible&amp;rdquo; to the trigger.</source>
          <target state="translated">조작이 행에서 시도되기 전에 (제약 조건이 점검되고 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 가 시도 되기 전에) 트리거가 트리거되도록 지정할 수 있습니다 . 또는 작업이 완료된 후 (제약 조건을 확인하고 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 가 완료된 후); 또는 작업 대신 (보기에서 삽입, 업데이트 또는 삭제의 경우). 이벤트 전후에 트리거가 발생하면 트리거는 현재 행에 대한 작업을 건너 뛰거나 삽입중인 행을 변경할 수 있습니다 ( &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 의 경우)작업 만 해당). 이벤트 후에 트리거가 발생하면 다른 트리거의 영향을 포함한 모든 변경 사항이 트리거에 &quot;표시&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="360ddad9a8de88b17738a1bfb31175dc0ad50509" translate="yes" xml:space="preserve">
          <source>The trigger definition is the same as before. Note that each &lt;code&gt;IF&lt;/code&gt; test must exactly match the &lt;code&gt;CHECK&lt;/code&gt; constraint for its child table.</source>
          <target state="translated">트리거 정의는 이전과 동일합니다. 각 &lt;code&gt;IF&lt;/code&gt; 테스트는 해당 자식 테이블 의 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 과 정확히 일치해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a810fcfc0902003d265053e230960c8ff8fc873c" translate="yes" xml:space="preserve">
          <source>The trigger firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;. Simply enabled triggers (the default) will fire when the replication role is &amp;ldquo;origin&amp;rdquo; (the default) or &amp;ldquo;local&amp;rdquo;. Triggers configured as &lt;code&gt;ENABLE REPLICA&lt;/code&gt; will only fire if the session is in &amp;ldquo;replica&amp;rdquo; mode, and triggers configured as &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; will fire regardless of the current replication role.</source>
          <target state="translated">트리거 발생 메커니즘은 구성 변수 &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role의&lt;/a&gt; 영향을받습니다 . 복제 역할이 &quot;origin&quot;(기본값) 또는 &quot;local&quot;이면 간단하게 활성화 된 트리거 (기본값)가 실행됩니다. &lt;code&gt;ENABLE REPLICA&lt;/code&gt; 로 구성된 트리거 는 세션이 &quot;복제본&quot;모드 인 경우에만 실행되며 &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; 로 구성된 트리거 는 현재 복제 역할에 관계없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4f53bb9473c53f31ec2630d134ac2ab3b419880a" translate="yes" xml:space="preserve">
          <source>The trigger will only fire if at least one of the listed columns is mentioned as a target of the &lt;code&gt;UPDATE&lt;/code&gt; command or if one of the listed columns is a generated column that depends on a column that is the target of the &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">트리거 만 나열된 열 중 적어도 하나의 목표로 한 경우 발광하는 &lt;code&gt;UPDATE&lt;/code&gt; 명령 또는 나열된 열 중 하나의 타겟 인 항목에 따라 생성 된 컬럼 경우 &lt;code&gt;UPDATE&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f9812ac32136a445e04fcdb0d1e4cacff3be7be9" translate="yes" xml:space="preserve">
          <source>The two arguments must be of comparable types. To be specific, they are compared exactly as if you had written &lt;code&gt;value1 = value2&lt;/code&gt;, so there must be a suitable &lt;code&gt;=&lt;/code&gt; operator available.</source>
          <target state="translated">The two arguments must be of comparable types. To be specific, they are compared exactly as if you had written &lt;code&gt;value1 = value2&lt;/code&gt; , so there must be a suitable &lt;code&gt;=&lt;/code&gt; operator available.</target>
        </trans-unit>
        <trans-unit id="33dc8fc66a104f662e1e1ef39564cf253e0b3d0e" translate="yes" xml:space="preserve">
          <source>The two characters must be separated by whitespace, and any leading or trailing whitespace on a line is ignored.</source>
          <target state="translated">두 문자는 공백으로 구분해야하며 행의 선행 또는 후행 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="76e9af5cad39e06c0aff7fc7950d58905fea1d7b" translate="yes" xml:space="preserve">
          <source>The two common uses of the &lt;code&gt;COLLATE&lt;/code&gt; clause are overriding the sort order in an &lt;code&gt;ORDER BY&lt;/code&gt; clause, for example:</source>
          <target state="translated">&lt;code&gt;COLLATE&lt;/code&gt; 절의 두 가지 일반적인 용도 는 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에서 정렬 순서를 대체하는 것 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35a38d5de3cd4f9280a434f729b41435ab278e27" translate="yes" xml:space="preserve">
          <source>The two ranking functions currently available are:</source>
          <target state="translated">현재 사용 가능한 두 가지 순위 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce8dc1c8a536536645752666f7fffe721ce60a13" translate="yes" xml:space="preserve">
          <source>The two-parameter form of &lt;code&gt;obj_description&lt;/code&gt; returns the comment for a database object specified by its OID and the name of the containing system catalog. For example, &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; would retrieve the comment for the table with OID 123456. The one-parameter form of &lt;code&gt;obj_description&lt;/code&gt; requires only the object OID. It is deprecated since there is no guarantee that OIDs are unique across different system catalogs; therefore, the wrong comment might be returned.</source>
          <target state="translated">&lt;code&gt;obj_description&lt;/code&gt; 의 두 매개 변수 형식은 해당 OID 및 포함 된 시스템 카탈로그의 이름으로 지정된 데이터베이스 오브젝트에 대한 주석을 리턴합니다. 예를 들어, &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; 는 OID가 123456 인 테이블에 대한 주석을 검색합니다. &lt;code&gt;obj_description&lt;/code&gt; 의 한 매개 변수 형식은 오브젝트 OID 만 필요합니다. OID가 다른 시스템 카탈로그에서 고유하다는 보장이 없으므로 사용되지 않습니다. 따라서 잘못된 주석이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4f339ae3cabb76936eb748863a60863a4f4f72e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;integer&lt;/code&gt; is the common choice, as it offers the best balance between range, storage size, and performance. The &lt;code&gt;smallint&lt;/code&gt; type is generally only used if disk space is at a premium. The &lt;code&gt;bigint&lt;/code&gt; type is designed to be used when the range of the &lt;code&gt;integer&lt;/code&gt; type is insufficient.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형 은 범위, 스토리지 크기 및 성능간에 최상의 균형을 제공하므로 일반적으로 선택됩니다. &lt;code&gt;smallint&lt;/code&gt; 디스크 공간이 프리미엄에있는 경우 유형은 일반적에만 사용됩니다. &lt;code&gt;bigint&lt;/code&gt; 유형은 범위 때 사용하도록 설계 &lt;code&gt;integer&lt;/code&gt; 타입은 불충분하다.</target>
        </trans-unit>
        <trans-unit id="73f1593ff9d450e1b3a9d9ecf07b14639511ab2d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g. addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 유형 은 매우 큰 자릿수를 가진 숫자 를 저장할 수 있습니다. 정확성이 요구되는 금액 및 기타 수량을 저장하는 데 특히 권장됩니다. &lt;code&gt;numeric&lt;/code&gt; 값을 사용한 계산은 가능한 경우 더하기, 빼기, 곱하기와 같은 정확한 결과를 산출합니다. 그러나 &lt;code&gt;numeric&lt;/code&gt; 값 에 대한 계산 은 정수 유형 또는 다음 섹션에서 설명하는 부동 소수점 유형에 비해 매우 느립니다.</target>
        </trans-unit>
        <trans-unit id="d8ef95808394eeedcc4e8f80e7ae1d4796c0832d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g., addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</source>
          <target state="translated">The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g., addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</target>
        </trans-unit>
        <trans-unit id="793233ae84eec2944804278e0981414a3f21b17d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;time with time zone&lt;/code&gt; is defined by the SQL standard, but the definition exhibits properties which lead to questionable usefulness. In most cases, a combination of &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, and &lt;code&gt;timestamp with time zone&lt;/code&gt; should provide a complete range of date/time functionality required by any application.</source>
          <target state="translated">표준 &lt;code&gt;time with time zone&lt;/code&gt; 가 포함 된 유형 시간 은 SQL 표준에 의해 정의되지만이 정의에는 의심의 여지가있는 속성이 표시됩니다. 대부분의 경우, &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamp without time zone&lt;/code&gt; &lt;code&gt;timestamp with time zone&lt;/code&gt; 및 시간대 와 타임 스탬프 의 조합은 모든 응용 프로그램에 필요한 완전한 날짜 / 시간 기능을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7b02ae1d94b05c4445fedeab1d5ea2204949c69" translate="yes" xml:space="preserve">
          <source>The type being created is an array; this specifies the type of the array elements.</source>
          <target state="translated">작성되는 유형은 배열입니다. 배열 요소의 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="dec7ae5dcf41bac97c38ef83c552012b75a666d1" translate="yes" xml:space="preserve">
          <source>The type names &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;serial4&lt;/code&gt; are equivalent: both create &lt;code&gt;integer&lt;/code&gt; columns. The type names &lt;code&gt;bigserial&lt;/code&gt; and &lt;code&gt;serial8&lt;/code&gt; work the same way, except that they create a &lt;code&gt;bigint&lt;/code&gt; column. &lt;code&gt;bigserial&lt;/code&gt; should be used if you anticipate the use of more than 2&lt;sup&gt;31&lt;/sup&gt; identifiers over the lifetime of the table. The type names &lt;code&gt;smallserial&lt;/code&gt; and &lt;code&gt;serial2&lt;/code&gt; also work the same way, except that they create a &lt;code&gt;smallint&lt;/code&gt; column.</source>
          <target state="translated">&lt;code&gt;serial&lt;/code&gt; 및 &lt;code&gt;serial4&lt;/code&gt; 유형 이름 은 동일합니다. 둘 다 &lt;code&gt;integer&lt;/code&gt; 열을 만듭니다 . &lt;code&gt;bigserial&lt;/code&gt; 및 &lt;code&gt;serial8&lt;/code&gt; 유형 이름 은 &lt;code&gt;bigint&lt;/code&gt; 열 을 생성한다는 점을 제외하고 동일한 방식으로 작동합니다 . 테이블 수명 동안 2 &lt;sup&gt;31&lt;/sup&gt; 개 이상의 식별자를 사용할 것으로 예상되는 경우 &lt;code&gt;bigserial&lt;/code&gt; 을 사용해야 합니다. 유형 이름 &lt;code&gt;smallserial&lt;/code&gt; 및 &lt;code&gt;serial2&lt;/code&gt; 또한 그들이 만들 것을 제외하고, 같은 방식으로 작동 &lt;code&gt;smallint&lt;/code&gt; 열을.&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fe751081daba63125cfc111c4d7f7c5219b07dce" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;.</source>
          <target state="translated">열 유형은 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; 을 작성하여 참조됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0ea7f76717a65c02b1bddcb00950b7e9f4876d9" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a function independent of changes to the definition of a table.</source>
          <target state="translated">열 유형은 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; 을 작성하여 참조됩니다 . 이 기능을 사용하면 테이블 정의의 변경과 독립적으로 기능을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1ec982d03e7790491fadba1642490dfd8fdc55a" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a procedure independent of changes to the definition of a table.</source>
          <target state="translated">열 유형은 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; 을 작성하여 참조됩니다 . 이 기능을 사용하면 테이블 정의의 변경과 무관하게 프로 시저를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e103307ad05526fdabd013a4e01ed05bfdbdb7" translate="yes" xml:space="preserve">
          <source>The type of event for which the backend is waiting, if any; otherwise NULL. Possible values are:</source>
          <target state="translated">백엔드가 대기중인 이벤트 유형입니다 (있는 경우). 그렇지 않으면 NULL입니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8d405d6c92bbb1fd074ac96c8d3effed9604172" translate="yes" xml:space="preserve">
          <source>The type of event for which the backend is waiting, if any; otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt;.</source>
          <target state="translated">The type of event for which the backend is waiting, if any; otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9f9f096a38b6430fd5ddb4a740ecb24f54b601d1" translate="yes" xml:space="preserve">
          <source>The type of format conversion to use to produce the format specifier's output. The following types are supported:</source>
          <target state="translated">형식 지정자의 출력을 생성하는 데 사용되는 형식 변환 유형입니다. 다음 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1ddd9e551f2a05479f6513f5110e44168eae5ec3" translate="yes" xml:space="preserve">
          <source>The type of object to which this label applies, as text.</source>
          <target state="translated">이 레이블이 적용되는 객체의 유형 (텍스트)입니다.</target>
        </trans-unit>
        <trans-unit id="e0efbb84b508511a8c55e93462baf31f477709c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;decimal&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; are equivalent. Both types are part of the SQL standard.</source>
          <target state="translated">&lt;code&gt;decimal&lt;/code&gt; 및 &lt;code&gt;numeric&lt;/code&gt; 유형 은 동일합니다. 두 유형 모두 SQL 표준의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="929117e51025410290ad9a3ec11af66ca11a1c9b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; store whole numbers, that is, numbers without fractional components, of various ranges. Attempts to store values outside of the allowed range will result in an error.</source>
          <target state="translated">&lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; 및 &lt;code&gt;bigint&lt;/code&gt; 유형 은 정수 , 즉 소수 성분이없는 숫자를 다양한 범위로 저장합니다. 허용 된 범위를 벗어난 값을 저장하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f88d1600c2fa8cf210ddde6767edf800fcc4b8ae" translate="yes" xml:space="preserve">
          <source>The unallocated space. New item identifiers are allocated from the start of this area, new items from the end.</source>
          <target state="translated">할당되지 않은 공간. 새 항목 식별자는이 영역의 시작부터 끝부터 새 항목이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ac986319e3f5efca56837ce99d1572cef0217f" translate="yes" xml:space="preserve">
          <source>The underlying data type of the domain. This can include array specifiers.</source>
          <target state="translated">도메인의 기본 데이터 유형입니다. 여기에는 배열 지정자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1d964b1947580871a9afde80dd70168c2a16dc4" translate="yes" xml:space="preserve">
          <source>The union and difference operators will fail if the resulting range would need to contain two disjoint sub-ranges, as such a range cannot be represented.</source>
          <target state="translated">결과 범위가 두 개의 분리 된 하위 범위를 포함해야하는 경우 합집합 및 차이 연산자가 실패합니다. 이러한 범위는 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="50b30c7a19cffa1de56e373435e89e8ef50ced95" translate="yes" xml:space="preserve">
          <source>The units kB, MB, GB and TB used by the functions &lt;code&gt;pg_size_pretty&lt;/code&gt; and &lt;code&gt;pg_size_bytes&lt;/code&gt; are defined using powers of 2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is 1024&lt;sup&gt;2&lt;/sup&gt; = 1048576 bytes, and so on.</source>
          <target state="translated">&lt;code&gt;pg_size_pretty&lt;/code&gt; 및 &lt;code&gt;pg_size_bytes&lt;/code&gt; 함수가 사용하는 kB, MB, GB 및 TB 단위 는 10의 제곱이 아닌 2의 제곱을 사용하여 정의되므로 1kB는 1024 바이트, 1MB는 ​​1024 &lt;sup&gt;2&lt;/sup&gt; = 1048576 바이트 등입니다.</target>
        </trans-unit>
        <trans-unit id="e4ae2c5b2eeaa2e69e79b5cb262b5458e41e3c91" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; as an operator name is deprecated. It may be disallowed altogether in a future release.</source>
          <target state="translated">사용 &lt;code&gt;=&amp;gt;&lt;/code&gt; 오퍼레이터 이름이 중단된다. 향후 릴리스에서는 완전히 허용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5abb8578ec77c7960afe6e04fbf989b69b52b5fe" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;AND&lt;/code&gt; in the &lt;code&gt;BETWEEN&lt;/code&gt; syntax creates an ambiguity with the use of &lt;code&gt;AND&lt;/code&gt; as a logical operator. To resolve this, only a limited set of expression types are allowed as the second argument of a &lt;code&gt;BETWEEN&lt;/code&gt; clause. If you need to write a more complex sub-expression in &lt;code&gt;BETWEEN&lt;/code&gt;, write parentheses around the sub-expression.</source>
          <target state="translated">The use of &lt;code&gt;AND&lt;/code&gt; in the &lt;code&gt;BETWEEN&lt;/code&gt; syntax creates an ambiguity with the use of &lt;code&gt;AND&lt;/code&gt; as a logical operator. To resolve this, only a limited set of expression types are allowed as the second argument of a &lt;code&gt;BETWEEN&lt;/code&gt; clause. If you need to write a more complex sub-expression in &lt;code&gt;BETWEEN&lt;/code&gt; , write parentheses around the sub-expression.</target>
        </trans-unit>
        <trans-unit id="93c091c993d1f380ee067cec46b15b6ee688b73b" translate="yes" xml:space="preserve">
          <source>The use of explicit locking can increase the likelihood of &lt;em&gt;deadlocks&lt;/em&gt;, wherein two (or more) transactions each hold locks that the other wants. For example, if transaction 1 acquires an exclusive lock on table A and then tries to acquire an exclusive lock on table B, while transaction 2 has already exclusive-locked table B and now wants an exclusive lock on table A, then neither one can proceed. PostgreSQL automatically detects deadlock situations and resolves them by aborting one of the transactions involved, allowing the other(s) to complete. (Exactly which transaction will be aborted is difficult to predict and should not be relied upon.)</source>
          <target state="translated">명시 적 잠금을 사용하면 &lt;em&gt;교착 상태&lt;/em&gt; 가 발생할 가능성이 높아질 수 있습니다 . 여기서 두 개 이상의 트랜잭션은 각각 다른 트랜잭션이 원하는 잠금을 보유합니다. 예를 들어, 트랜잭션 1이 테이블 A에서 독점 잠금을 획득 한 다음 테이블 B에서 독점 잠금을 획득하려고 시도하는 반면 트랜잭션 2가 이미 독점 잠금 테이블 B를 가지고 있고 이제 테이블 A에서 독점 잠금을 원하는 경우 어느 쪽도 진행할 수 없습니다. . PostgreSQL은 교착 상태 상황을 자동으로 감지하고 관련된 트랜잭션 중 하나를 중단하여 다른 상황을 완료함으로써이를 해결합니다. (정확하게 중단 될 트랜잭션은 예측하기 어렵고 의존해서는 안됩니다.)</target>
        </trans-unit>
        <trans-unit id="8f0b3f4b5acb7da25097931a18b8f5ac621923d3" translate="yes" xml:space="preserve">
          <source>The use of huge pages results in smaller page tables and less CPU time spent on memory management, increasing performance. For more details about using huge pages on Linux, see &lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;Section 18.4.5&lt;/a&gt;.</source>
          <target state="translated">큰 페이지를 사용하면 페이지 테이블이 줄어들고 메모리 관리에 소요되는 CPU 시간이 줄어들어 성능이 향상됩니다. Linux에서 거대한 페이지를 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;섹션 18.4.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ce63f397bb5d8284bad24ef82b2459f7b090249" translate="yes" xml:space="preserve">
          <source>The use of this option is obsolete; all command-line options for server processes can be specified directly on the &lt;code&gt;postgres&lt;/code&gt; command line.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다. 서버 프로세스에 대한 모든 명령 행 옵션은 &lt;code&gt;postgres&lt;/code&gt; 명령 행 에서 직접 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09cf7166a8b226caae95159176b66ea236b91cf0" translate="yes" xml:space="preserve">
          <source>The user can select the commit mode of each transaction, so that it is possible to have both synchronous and asynchronous commit transactions running concurrently. This allows flexible trade-offs between performance and certainty of transaction durability. The commit mode is controlled by the user-settable parameter &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;, which can be changed in any of the ways that a configuration parameter can be set. The mode used for any one transaction depends on the value of &lt;code&gt;synchronous_commit&lt;/code&gt; when transaction commit begins.</source>
          <target state="translated">사용자는 각 트랜잭션의 커밋 모드를 선택할 수 있으므로 동기식 및 비동기식 커밋 트랜잭션을 동시에 실행할 수 있습니다. 이를 통해 성능과 트랜잭션 내구성의 확실성간에 유연한 균형을 유지할 수 있습니다. 커미트 모드는 사용자가 설정 가능한 매개 변수 &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit에&lt;/a&gt; 의해 제어되며 구성 매개 변수를 설정할 수있는 모든 방법으로 변경할 수 있습니다. 하나의 트랜잭션에 사용되는 모드는 트랜잭션 커밋이 시작될 때 &lt;code&gt;synchronous_commit&lt;/code&gt; 의 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="58fdb850f0b7e6f4f12d81d3a2ab809c8e564bba" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the procedure in order to be allowed to invoke it.</source>
          <target state="translated">호출 할 수 있으려면 사용자에게 프로 시저에 &lt;code&gt;EXECUTE&lt;/code&gt; 특권이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c74ba756422b33951733fa9726163bde6e9f1367" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;USAGE&lt;/code&gt; privilege for the procedural language, or must be a superuser if the language is untrusted. This is the same privilege requirement as for creating a function in the language.</source>
          <target state="translated">사용자는이 있어야 &lt;code&gt;USAGE&lt;/code&gt; 절차 언어에 대한 권한을, 또는 언어가 신뢰할 수없는 경우 수퍼 유저 여야합니다. 이것은 언어로 함수를 작성하는 것과 동일한 특권 요구 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7355b734bfbb693399b1f5be80a21fc683a4208f" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the domain.</source>
          <target state="translated">도메인의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5b67af9ba18fb81e51e55c777748aa943b2fa8e5" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the event trigger.</source>
          <target state="translated">이벤트 트리거의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="aba5a7708c66551701c5165cf7ba963ffe31406d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign server.</source>
          <target state="translated">외부 서버의 새 소유자의 사용자 이름</target>
        </trans-unit>
        <trans-unit id="e794753392792d29db630aab48374584b0d3cb46" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign-data wrapper.</source>
          <target state="translated">외부 데이터 랩퍼의 새 소유자의 사용자 이름</target>
        </trans-unit>
        <trans-unit id="9764aeef0fe4bb5d4f2272e77d6962230b353685" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the materialized view.</source>
          <target state="translated">구체화 된보기의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2b0e8f2639c9d0e1c0e8fa04963b62d2820b7705" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the publication.</source>
          <target state="translated">발행물의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2288b9ac65364d46e00039d4c94aae751493c3c0" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the sequence.</source>
          <target state="translated">시퀀스의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d54654fb52ccc22d099e9d7662a28009ae6c974d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the statistics object.</source>
          <target state="translated">통계 오브젝트의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c69e3a3d77712ec7eadabb2257570bc879c31fe4" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the subscription.</source>
          <target state="translated">구독의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6566e54be9aa4e4a755e403ba928be2a78bd2f0e" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the table.</source>
          <target state="translated">테이블의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5465925abc46b022486e34924312d36ae3fb4555" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the type.</source>
          <target state="translated">유형의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a6eb245257eeab851862782e2a923bbc7e47c8d6" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the view.</source>
          <target state="translated">뷰의 새 소유자의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ead32115822b14f6c36ec30a49fc2050b45d7ff6" translate="yes" xml:space="preserve">
          <source>The user name to connect as</source>
          <target state="translated">연결할 사용자 이름</target>
        </trans-unit>
        <trans-unit id="e907b500844d993a9893eddde6a23ad8e157309f" translate="yes" xml:space="preserve">
          <source>The user performing the lock on the view must have the corresponding privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the lock does not need any permissions on the underlying base relations.</source>
          <target state="translated">뷰에서 잠금을 수행하는 사용자는 뷰에 대한 해당 권한이 있어야합니다. 또한 뷰의 소유자는 기본 관계에 대한 관련 권한을 가져야하지만 잠금을 수행하는 사용자는 기본 관계에 대한 권한이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bfd48e694dd153c1235989f4fbd645fdacfec80" translate="yes" xml:space="preserve">
          <source>The user that creates the function becomes the owner of the function.</source>
          <target state="translated">함수를 생성 한 사용자는 함수의 소유자가됩니다.</target>
        </trans-unit>
        <trans-unit id="96430e1e5477d00f6c76c64e1c8233d8001617e1" translate="yes" xml:space="preserve">
          <source>The user that creates the procedure becomes the owner of the procedure.</source>
          <target state="translated">프로 시저를 작성하는 사용자가 프로 시저의 소유자가됩니다.</target>
        </trans-unit>
        <trans-unit id="fa24870d0f9c850e93790c8855a7b4579bd41481" translate="yes" xml:space="preserve">
          <source>The user who defines a text search configuration becomes its owner.</source>
          <target state="translated">텍스트 검색 구성을 정의한 사용자가 소유자가됩니다.</target>
        </trans-unit>
        <trans-unit id="f6d4088ee84ecfa3f7d22aab37f998c942ea2998" translate="yes" xml:space="preserve">
          <source>The user who defines a text search dictionary becomes its owner.</source>
          <target state="translated">텍스트 검색 사전을 정의하는 사용자가 소유자가됩니다.</target>
        </trans-unit>
        <trans-unit id="ba174285d0ec0c6de6eab2554bacc234f431f1f5" translate="yes" xml:space="preserve">
          <source>The user who defines an operator class becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator class definition could confuse or even crash the server.)</source>
          <target state="translated">연산자 클래스를 정의하는 사용자가 소유자가됩니다. 현재 생성 사용자는 수퍼 유저 여야합니다. (이 제한은 잘못된 연산자 클래스 정의로 인해 서버가 혼동되거나 심지어 충돌 할 수 있기 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="fbdfed285f07a1cecc02c081ebab06c65c95b2f7" translate="yes" xml:space="preserve">
          <source>The user who defines an operator family becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="translated">운영자 제품군을 정의하는 사용자가 소유자가됩니다. 현재 생성 사용자는 수퍼 유저 여야합니다. (이 제한은 잘못된 운영자 패밀리 정의가 서버를 혼란 시키거나 충돌시킬 수 있기 때문에 작성됩니다.)</target>
        </trans-unit>
        <trans-unit id="a72f845d3a0a4dd8ce3bae5ed1b2a783fa9c859b" translate="yes" xml:space="preserve">
          <source>The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, and normally also becomes the owner of any objects created by the extension's script.</source>
          <target state="translated">The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, and normally also becomes the owner of any objects created by the extension's script.</target>
        </trans-unit>
        <trans-unit id="a49e64af112af0fce66c24196c6a87dd37d8a41a" translate="yes" xml:space="preserve">
          <source>The user's client (frontend) application that wants to perform database operations. Client applications can be very diverse in nature: a client could be a text-oriented tool, a graphical application, a web server that accesses the database to display web pages, or a specialized database maintenance tool. Some client applications are supplied with the PostgreSQL distribution; most are developed by users.</source>
          <target state="translated">데이터베이스 작업을 수행하려는 사용자의 클라이언트 (프런트 엔드) 응용 프로그램 클라이언트 응용 프로그램은 본질적으로 매우 다양 할 수 있습니다. 클라이언트는 텍스트 지향 도구, 그래픽 응용 프로그램, 웹 페이지를 표시하기 위해 데이터베이스에 액세스하는 웹 서버 또는 특수한 데이터베이스 유지 관리 도구 일 수 있습니다. 일부 클라이언트 응용 프로그램에는 PostgreSQL 배포판이 제공됩니다. 대부분의 사용자에 의해 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b80e8348cd40d70e9a3578f00476d222916ac1c" translate="yes" xml:space="preserve">
          <source>The user's personal startup file is named &lt;code&gt;.psqlrc&lt;/code&gt; and is sought in the invoking user's home directory. On Windows, which lacks such a concept, the personal startup file is named &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt;. The location of the user's startup file can be set explicitly via the &lt;code&gt;PSQLRC&lt;/code&gt; environment variable.</source>
          <target state="translated">사용자의 개인 시작 파일 이름은 &lt;code&gt;.psqlrc&lt;/code&gt; 이며 호출하는 사용자의 홈 디렉토리에서 찾습니다 . 이러한 개념이없는 Windows에서는 개인 시작 파일의 이름이 &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt; 입니다. 사용자 시작 파일의 위치는 &lt;code&gt;PSQLRC&lt;/code&gt; 환경 변수 를 통해 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3920cf489a63459b72dde1b92f7b717a8e6b52fd" translate="yes" xml:space="preserve">
          <source>The user, database, and (client) host items remain the same for the life of the client connection, but the activity indicator changes. The activity can be &lt;code&gt;idle&lt;/code&gt; (i.e., waiting for a client command), &lt;code&gt;idle in transaction&lt;/code&gt; (waiting for client inside a &lt;code&gt;BEGIN&lt;/code&gt; block), or a command type name such as &lt;code&gt;SELECT&lt;/code&gt;. Also, &lt;code&gt;waiting&lt;/code&gt; is appended if the server process is presently waiting on a lock held by another session. In the above example we can infer that process 15606 is waiting for process 15610 to complete its transaction and thereby release some lock. (Process 15610 must be the blocker, because there is no other active session. In more complicated cases it would be necessary to look into the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view to determine who is blocking whom.)</source>
          <target state="translated">사용자, 데이터베이스 및 (클라이언트) 호스트 항목은 클라이언트 연결 수명 동안 동일하게 유지되지만 활동 표시기는 변경됩니다. 활동은 &lt;code&gt;idle&lt;/code&gt; (즉, 클라이언트 명령 &lt;code&gt;idle in transaction&lt;/code&gt; ), 트랜잭션 유휴 상태 ( &lt;code&gt;BEGIN&lt;/code&gt; 블록 내 클라이언트 대기 중 ) 또는 &lt;code&gt;SELECT&lt;/code&gt; 와 같은 명령 유형 이름 일 수 있습니다. 또한 서버 프로세스가 현재 다른 세션에서 보유한 잠금을 대기중인 경우 &lt;code&gt;waiting&lt;/code&gt; 가 추가됩니다. 위의 예에서 프로세스 15606이 프로세스 15610이 트랜잭션을 완료하고 일부 잠금을 해제하기를 기다리고 있음을 유추 할 수 있습니다. (15610 프로세스는 다른 활성 세션이 없으므로 차단해야합니다. 더 복잡한 경우에는 &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; 를 조사해야합니다 . 누가 누구를 차단하고 있는지 확인하기위한 시스템보기)</target>
        </trans-unit>
        <trans-unit id="13392321669f2c3fc39fecf0f89fb41cca2076a4" translate="yes" xml:space="preserve">
          <source>The usual comparison operators are available, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;표 9.1에&lt;/a&gt; 나와있는 것처럼 일반적인 비교 연산자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06a88b4eddcbb8d26f5f678e56a78a9bd14190d1" translate="yes" xml:space="preserve">
          <source>The usual goal of routine vacuuming is to do standard &lt;code&gt;VACUUM&lt;/code&gt;s often enough to avoid needing &lt;code&gt;VACUUM FULL&lt;/code&gt;. The autovacuum daemon attempts to work this way, and in fact will never issue &lt;code&gt;VACUUM FULL&lt;/code&gt;. In this approach, the idea is not to keep tables at their minimum size, but to maintain steady-state usage of disk space: each table occupies space equivalent to its minimum size plus however much space gets used up between vacuumings. Although &lt;code&gt;VACUUM FULL&lt;/code&gt; can be used to shrink a table back to its minimum size and return the disk space to the operating system, there is not much point in this if the table will just grow again in the future. Thus, moderately-frequent standard &lt;code&gt;VACUUM&lt;/code&gt; runs are a better approach than infrequent &lt;code&gt;VACUUM FULL&lt;/code&gt; runs for maintaining heavily-updated tables.</source>
          <target state="translated">일상적인 진공 청소기의 일반적인 목표는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 이 필요하지 않도록 표준 &lt;code&gt;VACUUM&lt;/code&gt; 을 수행하는 것 입니다. autovacuum 데몬은 이러한 방식으로 작동하려고 시도하며 실제로 &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 발행하지 않습니다 . 이 방법에서는 테이블을 최소 크기로 유지하는 것이 아니라 디스크 공간의 안정적인 상태 사용을 유지하는 것이 좋습니다. 각 테이블은 최소 크기에 해당하는 공간을 차지하지만 진공 청소기 사이에 많은 공간이 사용됩니다. 하지만 &lt;code&gt;VACUUM FULL&lt;/code&gt; 는 최소 크기 테이블 등을 축소하고 운영 시스템에 디스크 공간을 반환하는 데 사용할 수있는 테이블 그냥 나중에 다시 성장할 경우이 훨씬 점은 없다. 따라서, 적당한 빈도의 표준 &lt;code&gt;VACUUM&lt;/code&gt; 심하게 업데이트 된 테이블을 유지 관리하기 위해 &lt;code&gt;VACUUM FULL&lt;/code&gt; 실행 보다 실행이 더 나은 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="8705eeb4c73510ec550152d0313d6eeffdb4ff7a" translate="yes" xml:space="preserve">
          <source>The usual interpretation of the &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; fields is that they identify the left and right input types of the operator(s) that a particular support function supports. For some access methods these match the input data type(s) of the support function itself, for others not. There is a notion of &amp;ldquo;default&amp;rdquo; support functions for an index, which are those with &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; both equal to the index operator class's &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;amproclefttype&lt;/code&gt; 및 &lt;code&gt;amprocrighttype&lt;/code&gt; 필드 의 일반적인 해석은 특정 지원 기능이 지원하는 연산자의 왼쪽 및 오른쪽 입력 유형을 식별한다는 것입니다. 일부 액세스 방법의 경우 지원 기능 자체의 입력 데이터 유형과 일치하지만 다른 경우에는 그렇지 않습니다. 인덱스에 대한 &quot;기본&quot;지원 함수 개념이 있는데, 이는 &lt;code&gt;amproclefttype&lt;/code&gt; 및 &lt;code&gt;amprocrighttype&lt;/code&gt; 이 모두 인덱스 연산자 클래스의 &lt;code&gt;opcintype&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="675415fe7638319c8a05abc3d9aab113c5086abb" translate="yes" xml:space="preserve">
          <source>The usual logical operators are available:</source>
          <target state="translated">일반적인 논리 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410b768bdab1d606d84345d16fb594b86774dec4" translate="yes" xml:space="preserve">
          <source>The utility command &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; can be used to start and shut down the &lt;code&gt;postgres&lt;/code&gt; server safely and comfortably.</source>
          <target state="translated">유틸리티 명령 &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; 을 사용하여 &lt;code&gt;postgres&lt;/code&gt; 서버를 안전하고 편안하게 시작하고 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="914a00521ee94634aa555f79070e426ade88941f" translate="yes" xml:space="preserve">
          <source>The value can range from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;10000000000&lt;/code&gt;. When &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, index scans are never skipped during &lt;code&gt;VACUUM&lt;/code&gt; cleanup. The default value is &lt;code&gt;0.1&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 &lt;code&gt;0&lt;/code&gt; ~ &lt;code&gt;10000000000&lt;/code&gt; 입니다. &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 &lt;code&gt;VACUUM&lt;/code&gt; 정리 중에 인덱스 스캔을 건너 뛰지 않습니다 . 기본값은 &lt;code&gt;0.1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="82bae1585ba067ff6aabd9ec822fffc256ffef0f" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;dynamic_library_path&lt;/code&gt; must be a list of absolute directory paths separated by colons (or semi-colons on Windows). If a list element starts with the special string &lt;code&gt;$libdir&lt;/code&gt;, the compiled-in PostgreSQL package library directory is substituted for &lt;code&gt;$libdir&lt;/code&gt;; this is where the modules provided by the standard PostgreSQL distribution are installed. (Use &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; to find out the name of this directory.) For example:</source>
          <target state="translated">&lt;code&gt;dynamic_library_path&lt;/code&gt; 의 값은 콜론 (또는 Windows의 경우 세미콜론)으로 구분 된 절대 디렉토리 경로 목록이어야합니다. list 요소가 특수 문자열 &lt;code&gt;$libdir&lt;/code&gt; 시작 하면 컴파일 된 PostgreSQL 패키지 라이브러리 디렉토리가 &lt;code&gt;$libdir&lt;/code&gt; 로 대체됩니다 . 여기에는 표준 PostgreSQL 배포에서 제공하는 모듈이 설치됩니다. ( &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; 을 사용 하여이 디렉토리의 이름을 찾으십시오.) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2ece96ce583cb594781fa18e96e90c23a241cb2" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;search_path&lt;/code&gt; must be a comma-separated list of schema names. Any name that is not an existing schema, or is a schema for which the user does not have &lt;code&gt;USAGE&lt;/code&gt; permission, is silently ignored.</source>
          <target state="translated">&lt;code&gt;search_path&lt;/code&gt; 의 값 은 쉼표로 구분 된 스키마 이름 목록이어야합니다. 기존 스키마가 아니거나 사용자에게 &lt;code&gt;USAGE&lt;/code&gt; 권한 이없는 스키마 인 이름은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1885fd3acbde2dfc55224cb44032743ea0749cf2" translate="yes" xml:space="preserve">
          <source>The value is a list of names of tablespaces. When there is more than one name in the list, PostgreSQL chooses a random member of the list each time a temporary object is to be created; except that within a transaction, successively created temporary objects are placed in successive tablespaces from the list. If the selected element of the list is an empty string, PostgreSQL will automatically use the default tablespace of the current database instead.</source>
          <target state="translated">값은 테이블 스페이스 이름 목록입니다. 목록에 둘 이상의 이름이있는 경우 PostgreSQL은 임시 객체를 생성 할 때마다 목록의 임의 구성원을 선택합니다. 트랜잭션 내에서 연속적으로 작성된 임시 오브젝트는 목록의 연속 테이블 스페이스에 배치됩니다. 목록에서 선택한 요소가 빈 문자열이면 PostgreSQL은 자동으로 현재 데이터베이스의 기본 테이블 스페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99c82c62699420580e0ce37ee3df7912c1dd98bf" translate="yes" xml:space="preserve">
          <source>The value is either the name of a tablespace, or an empty string to specify using the default tablespace of the current database. If the value does not match the name of any existing tablespace, PostgreSQL will automatically use the default tablespace of the current database. If a nondefault tablespace is specified, the user must have &lt;code&gt;CREATE&lt;/code&gt; privilege for it, or creation attempts will fail.</source>
          <target state="translated">값은 테이블 스페이스의 이름이거나 현재 데이터베이스의 기본 테이블 스페이스를 사용하여 지정할 빈 문자열입니다. 값이 기존 테이블 스페이스의 이름과 일치하지 않으면 PostgreSQL은 자동으로 현재 데이터베이스의 기본 테이블 스페이스를 사용합니다. 기본이 아닌 테이블 스페이스가 지정되면 사용자에게 &lt;code&gt;CREATE&lt;/code&gt; 권한이 있어야합니다 . 그렇지 않으면 작성 시도가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="35739a3ab0eff8d38722337e2254ec6c774352ae" translate="yes" xml:space="preserve">
          <source>The value might be quoted and schema-qualified. If no collation is derived for the argument expression, then a null value is returned. If the argument is not of a collatable data type, then an error is raised.</source>
          <target state="translated">값이 인용되고 스키마로 한정 될 수 있습니다. 인수 표현식에 대해 데이터 정렬이 파생되지 않으면 널값이 리턴됩니다. 인수가 배열 가능한 데이터 유형이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39c36934ef87435e122aa28a1e5f5b7fbbf50ca7" translate="yes" xml:space="preserve">
          <source>The value of either of these directories that is appropriate for the installation can be found out using &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt;.</source>
          <target state="translated">설치에 적합한 이들 디렉토리 중 하나의 값은 &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; 를 사용하여 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48b58f404c5ab41a010c449c8600d4f12fc88c78" translate="yes" xml:space="preserve">
          <source>The value of the last affected OID, as returned from an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;\lo_import&lt;/code&gt; command. This variable is only guaranteed to be valid until after the result of the next SQL command has been displayed. PostgreSQL servers since version 12 do not support OID system columns anymore, thus LASTOID will always be 0 following &lt;code&gt;INSERT&lt;/code&gt; when targeting such servers.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;\lo_import&lt;/code&gt; 명령 에서 리턴 된 마지막 영향을받는 OID의 값 . 이 변수는 다음 SQL 명령의 결과가 표시 될 때까지만 유효합니다. 버전 12 이후의 PostgreSQL 서버는 더 이상 OID 시스템 열을 지원하지 않으므로 이러한 서버를 대상으로 할 때 &lt;code&gt;INSERT&lt;/code&gt; 다음에 LASTOID가 항상 0 입니다.</target>
        </trans-unit>
        <trans-unit id="5b8285b6717f13b01f6793b29c8c9dedce0baef8" translate="yes" xml:space="preserve">
          <source>The value of the psql variable &lt;code&gt;name&lt;/code&gt;. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, above, for details.</source>
          <target state="translated">The value of the psql variable &lt;code&gt;name&lt;/code&gt; . See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, above, for details.</target>
        </trans-unit>
        <trans-unit id="c651921fd6703938e12fa970227922443e260428" translate="yes" xml:space="preserve">
          <source>The value of the psql variable &lt;code&gt;name&lt;/code&gt;. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; for details.</source>
          <target state="translated">psql 변수 &lt;code&gt;name&lt;/code&gt; 의 값입니다 . 자세한 내용은 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7cad357760c4befedd7f8fdaa593e68c359c8118" translate="yes" xml:space="preserve">
          <source>The value of the selected prompt variable is printed literally, except where a percent sign (&lt;code&gt;%&lt;/code&gt;) is encountered. Depending on the next character, certain other text is substituted instead. Defined substitutions are:</source>
          <target state="translated">백분율 기호 ( &lt;code&gt;%&lt;/code&gt; )가 있는 경우를 제외하고 선택한 프롬프트 변수의 값이 문자 그대로 인쇄 됩니다. 다음 문자에 따라 다른 특정 텍스트가 대신 사용됩니다. 정의 된 대체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="039fa537d91bfcd8e0c10a9f71f9137554b1d793" translate="yes" xml:space="preserve">
          <source>The value of this parameter is a time stamp in the same format accepted by the &lt;code&gt;timestamp with time zone&lt;/code&gt; data type, except that you cannot use a time zone abbreviation (unless the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; variable has been set earlier in the configuration file). Preferred style is to use a numeric offset from UTC, or you can write a full time zone name, e.g., &lt;code&gt;Europe/Helsinki&lt;/code&gt; not &lt;code&gt;EEST&lt;/code&gt;.</source>
          <target state="translated">The value of this parameter is a time stamp in the same format accepted by the &lt;code&gt;timestamp with time zone&lt;/code&gt; data type, except that you cannot use a time zone abbreviation (unless the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; variable has been set earlier in the configuration file). Preferred style is to use a numeric offset from UTC, or you can write a full time zone name, e.g., &lt;code&gt;Europe/Helsinki&lt;/code&gt; not &lt;code&gt;EEST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c0a0ed9f32ba0a19ec5847f3fbe4958f014ea1" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; setting. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수의 값은 &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; 설정을 대체합니다 . 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a4243c2cf710a88b014f758bc5617eddee2438a" translate="yes" xml:space="preserve">
          <source>The value to use for &lt;code&gt;old_version&lt;/code&gt; is determined by the extension's author, and might vary if there is more than one version of the old-style module that can be upgraded into an extension. For the standard additional modules supplied with pre-9.1 PostgreSQL, use &lt;code&gt;unpackaged&lt;/code&gt; for &lt;code&gt;old_version&lt;/code&gt; when updating a module to extension style.</source>
          <target state="translated">&lt;code&gt;old_version&lt;/code&gt; 에 사용할 값 은 확장 프로그램의 작성자에 의해 결정되며 확장으로 업그레이드 할 수있는 이전 스타일 모듈 버전이 둘 이상있는 경우 달라질 수 있습니다. 9.1 이전 PostgreSQL과 함께 제공되는 표준 추가 모듈의 경우 모듈을 확장 스타일로 업데이트 할 때 &lt;code&gt;old_version&lt;/code&gt; 에 대해 패키지화 &lt;code&gt;unpackaged&lt;/code&gt; 로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="29a25a9c8e901cbf1e213381b2fe324bdafd7520" translate="yes" xml:space="preserve">
          <source>The value to use for a template-specific option. If the value is not a simple identifier or number, it must be quoted (but you can always quote it, if you wish).</source>
          <target state="translated">템플릿 별 옵션에 사용할 값입니다. 값이 단순한 식별자 나 숫자가 아닌 경우 따옴표로 묶어야합니다 (원하는 경우 언제든지 따옴표로 묶을 수 있음).</target>
        </trans-unit>
        <trans-unit id="97aba03e4cf10e442611ec122abb257717947453" translate="yes" xml:space="preserve">
          <source>The values in each record are separated by the &lt;code&gt;DELIMITER&lt;/code&gt; character. If the value contains the delimiter character, the &lt;code&gt;QUOTE&lt;/code&gt; character, the &lt;code&gt;NULL&lt;/code&gt; string, a carriage return, or line feed character, then the whole value is prefixed and suffixed by the &lt;code&gt;QUOTE&lt;/code&gt; character, and any occurrence within the value of a &lt;code&gt;QUOTE&lt;/code&gt; character or the &lt;code&gt;ESCAPE&lt;/code&gt; character is preceded by the escape character. You can also use &lt;code&gt;FORCE_QUOTE&lt;/code&gt; to force quotes when outputting non-&lt;code&gt;NULL&lt;/code&gt; values in specific columns.</source>
          <target state="translated">각 레코드의 값은 &lt;code&gt;DELIMITER&lt;/code&gt; 문자 로 구분됩니다 . 값에 구분 기호 문자, &lt;code&gt;QUOTE&lt;/code&gt; 문자, &lt;code&gt;NULL&lt;/code&gt; 문자열, 캐리지 리턴 또는 줄 바꿈 문자가 포함 된 경우 전체 값 앞에 &lt;code&gt;QUOTE&lt;/code&gt; 문자 가 붙고 접미사가 붙으며 &lt;code&gt;QUOTE&lt;/code&gt; 문자 또는 &lt;code&gt;ESCAPE&lt;/code&gt; 문자 앞에는 이스케이프 문자가 있습니다. &lt;code&gt;FORCE_QUOTE&lt;/code&gt; 를 사용 하여 특정 열에서 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 값을 출력 할 때 따옴표를 강제 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08d03d5b23111b07a76c7aeb9df7ffb0e8eb87a7" translate="yes" xml:space="preserve">
          <source>The values stored in the free space map are not exact. They're rounded to precision of 1/256th of &lt;code&gt;BLCKSZ&lt;/code&gt; (32 bytes with default &lt;code&gt;BLCKSZ&lt;/code&gt;), and they're not kept fully up-to-date as tuples are inserted and updated.</source>
          <target state="translated">여유 공간 맵에 저장된 값이 정확하지 않습니다. 그것들은 1 / 256th의 &lt;code&gt;BLCKSZ&lt;/code&gt; (기본 &lt;code&gt;BLCKSZ&lt;/code&gt; 의 경우 32 바이트) 의 정밀도로 반올림 되며 튜플이 삽입되고 업데이트 될 때 완전히 최신 상태로 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6c08b4507fc75b276335a79d4dd41a78fcf9ac5" translate="yes" xml:space="preserve">
          <source>The variants to add and drop attributes are part of the SQL standard; the other variants are PostgreSQL extensions.</source>
          <target state="translated">속성을 추가 및 삭제하는 변형은 SQL 표준의 일부입니다. 다른 변형은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="90629b5d606371db9e2f9a38b9c003515b5bf970" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;\d&lt;/code&gt; commands accept a &lt;code&gt;pattern&lt;/code&gt; parameter to specify the object name(s) to be displayed. In the simplest case, a pattern is just the exact name of the object. The characters within a pattern are normally folded to lower case, just as in SQL names; for example, &lt;code&gt;\dt FOO&lt;/code&gt; will display the table named &lt;code&gt;foo&lt;/code&gt;. As in SQL names, placing double quotes around a pattern stops folding to lower case. Should you need to include an actual double quote character in a pattern, write it as a pair of double quotes within a double-quote sequence; again this is in accord with the rules for SQL quoted identifiers. For example, &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; will display the table named &lt;code&gt;FOO&quot;BAR&lt;/code&gt; (not &lt;code&gt;foo&quot;bar&lt;/code&gt;). Unlike the normal rules for SQL names, you can put double quotes around just part of a pattern, for instance &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; will display the table named &lt;code&gt;fooFOObar&lt;/code&gt;.</source>
          <target state="translated">다양한 &lt;code&gt;\d&lt;/code&gt; 명령은 &lt;code&gt;pattern&lt;/code&gt; 매개 변수를 허용하여 표시 할 오브젝트 이름을 지정합니다. 가장 간단한 경우 패턴은 객체의 정확한 이름입니다. 패턴 내의 문자는 일반적으로 SQL 이름에서와 같이 소문자로 접 힙니다. 예를 들어, &lt;code&gt;\dt FOO&lt;/code&gt; 는 &lt;code&gt;foo&lt;/code&gt; 라는 테이블을 표시합니다 . SQL 이름에서와 같이 패턴 주위에 큰 따옴표를 넣으면 소문자로 접히지 않습니다. 패턴에 실제 큰 따옴표를 포함해야하는 경우 큰 따옴표 순서 안에 큰 따옴표 쌍으로 쓰십시오. 이 역시 SQL 인용 식별자에 대한 규칙과 일치합니다. 예를 들어, &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; 은 &lt;code&gt;FOO&quot;BAR&lt;/code&gt; 이라는 테이블을 표시합니다 ( &lt;code&gt;foo&quot;bar&lt;/code&gt; ). SQL 이름에 대한 일반 규칙과는 달리, 당신은 예를 들어, 주변 패턴의 한 부분을 따옴표를 넣을 수 있습니다 &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; 라는 테이블이 표시됩니다 &lt;code&gt;fooFOObar&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7768758b3213c172e932c01f8e8da70daa4ada7f" translate="yes" xml:space="preserve">
          <source>The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">다양한 모든 포함 및 존재 연산자와 다른 모든 JSON 연산자 및 함수는 &lt;a href=&quot;functions-json&quot;&gt;9.15 섹션에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f313c60885e972dab9c59de4db6a32bb9909c11" translate="yes" xml:space="preserve">
          <source>The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="81c7ea1665d58af0cc391c652b85b77be99d97f9" translate="yes" xml:space="preserve">
          <source>The various variants of &lt;code&gt;BETWEEN&lt;/code&gt; are implemented in terms of the ordinary comparison operators, and therefore will work for any data type(s) that can be compared.</source>
          <target state="translated">The various variants of &lt;code&gt;BETWEEN&lt;/code&gt; are implemented in terms of the ordinary comparison operators, and therefore will work for any data type(s) that can be compared.</target>
        </trans-unit>
        <trans-unit id="4e179b7076409c4b105a612d7c9bb99b67e607cd" translate="yes" xml:space="preserve">
          <source>The verbatim query string submitted to declare this cursor</source>
          <target state="translated">이 커서를 선언하기 위해 제출 된 완전 쿼리 문자열</target>
        </trans-unit>
        <trans-unit id="91cb72e2fa3dca24da98249febe148f7555e66ba" translate="yes" xml:space="preserve">
          <source>The version of the extension to install. This can be written as either an identifier or a string literal. The default version is whatever is specified in the extension's control file.</source>
          <target state="translated">설치할 확장 버전입니다. 이것은 식별자 또는 문자열 리터럴로 작성 될 수 있습니다. 기본 버전은 확장 프로그램의 제어 파일에 지정된 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f466ef09b06001ef2dbe51d7e047e29feba87d5" translate="yes" xml:space="preserve">
          <source>The vertical header, displayed as the leftmost column, contains the values found in column &lt;code&gt;colV&lt;/code&gt;, in the same order as in the query results, but with duplicates removed.</source>
          <target state="translated">가장 왼쪽 열로 표시되는 세로 머리글에는 쿼리 결과와 동일한 순서로 열 &lt;code&gt;colV&lt;/code&gt; 에있는 값이 포함 되지만 중복은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ea52093b90b84d5b4fcb30b73c3186c808f82ec0" translate="yes" xml:space="preserve">
          <source>The very first process of an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;. It starts and manages the other auxiliary processes and creates &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend processes&lt;/a&gt; on demand.</source>
          <target state="translated">The very first process of an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;. It starts and manages the other auxiliary processes and creates &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend processes&lt;/a&gt; on demand.</target>
        </trans-unit>
        <trans-unit id="0adcabe9624ff122085bfba5e28081fdc88cd247" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_config&lt;/code&gt; describes the compile-time configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries. It provides the same basic information as the &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQL client application.</source>
          <target state="translated">&lt;code&gt;pg_config&lt;/code&gt; 뷰 는 현재 설치된 PostgreSQL 버전의 컴파일 타임 구성 매개 변수를 설명합니다. 예를 들어, 필요한 헤더 파일 및 라이브러리를 쉽게 찾을 수 있도록 PostgreSQL에 인터페이스하려는 소프트웨어 패키지에서 사용됩니다. &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQL 클라이언트 응용 프로그램 과 동일한 기본 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="08ea6b2cfb240aa2a36ba0270a0c6bfcfe867503" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_file_settings&lt;/code&gt; provides a summary of the contents of the server's configuration file(s). A row appears in this view for each &amp;ldquo;name = value&amp;rdquo; entry appearing in the files, with annotations indicating whether the value could be applied successfully. Additional row(s) may appear for problems not linked to a &amp;ldquo;name = value&amp;rdquo; entry, such as syntax errors in the files.</source>
          <target state="translated">&lt;code&gt;pg_file_settings&lt;/code&gt; 뷰 는 서버 구성 파일의 내용을 요약 한 것입니다. 파일에 나타나는 각&amp;ldquo;name = value&amp;rdquo;항목에 대한 행이이보기에 나타나고 값을 성공적으로 적용 할 수 있는지를 나타내는 주석이 있습니다. 파일의 구문 오류와 같이 &quot;name = value&quot;항목에 연결되지 않은 문제에 대해 추가 행이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d33a4b341777d328dc2c1f214857e8874dc6d9" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_group&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows the names and members of all roles that are marked as not &lt;code&gt;rolcanlogin&lt;/code&gt;, which is an approximation to the set of roles that are being used as groups.</source>
          <target state="translated">&lt;code&gt;pg_group&lt;/code&gt; 뷰 는 이전 버전과의 호환성을 위해 존재합니다. 8.1 이전 버전의 PostgreSQL에 존재했던 카탈로그를 에뮬레이트합니다. &lt;code&gt;rolcanlogin&lt;/code&gt; 이 아닌 것으로 표시된 모든 역할의 이름과 구성원을 표시 합니다. 이는 그룹으로 사용중인 역할 세트에 대한 근사값입니다.</target>
        </trans-unit>
        <trans-unit id="6dadc8f5b62fc6f506c2d65eb8b07e558e7c8b3f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_hba_file_rules&lt;/code&gt; provides a summary of the contents of the client authentication configuration file, &lt;code&gt;pg_hba.conf&lt;/code&gt;. A row appears in this view for each non-empty, non-comment line in the file, with annotations indicating whether the rule could be applied successfully.</source>
          <target state="translated">&lt;code&gt;pg_hba_file_rules&lt;/code&gt; 보기 는 클라이언트 인증 구성 파일 &lt;code&gt;pg_hba.conf&lt;/code&gt; 의 내용을 요약하여 제공합니다 . 이보기에는 파일의 비어 있지 않은 주석이 아닌 행마다 규칙이 적용되는지 여부를 나타내는 주석이있는 행이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="aac1873f6d2161781d725af8550ac62cddd3ae8a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_indexes&lt;/code&gt; provides access to useful information about each index in the database.</source>
          <target state="translated">&lt;code&gt;pg_indexes&lt;/code&gt; 뷰 는 데이터베이스의 각 인덱스에 대한 유용한 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c4a5f88ab67e15b0fb81ed88eb1f6933ddc8f95f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; 뷰 는 데이터베이스 서버 내의 활성 프로세스가 보유한 잠금에 대한 정보에 대한 액세스를 제공합니다. 잠금에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;13 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f25d4dc4f833f46aa9ec8087405622ced3b66529" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</source>
          <target state="translated">The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</target>
        </trans-unit>
        <trans-unit id="042974f73615dd15fc09c5129e6b33aeeef53099" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_matviews&lt;/code&gt; provides access to useful information about each materialized view in the database.</source>
          <target state="translated">뷰 &lt;code&gt;pg_matviews&lt;/code&gt; 는 데이터베이스의 각 구체화 된 뷰에 대한 유용한 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f35ab0d9ea2df46d55f4f8845455de38e126b0e5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_policies&lt;/code&gt; provides access to useful information about each row-level security policy in the database.</source>
          <target state="translated">&lt;code&gt;pg_policies&lt;/code&gt; 뷰 는 데이터베이스의 각 행 수준 보안 정책에 대한 유용한 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="43d0e1b7a1af60f6a8bef0840cbf55e0cd1189ae" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_prepared_xacts&lt;/code&gt; displays information about transactions that are currently prepared for two-phase commit (see &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; for details).</source>
          <target state="translated">&lt;code&gt;pg_prepared_xacts&lt;/code&gt; 뷰 에는 현재 2 단계 커밋을 위해 준비된 트랜잭션에 대한 정보가 표시됩니다 (자세한 내용은 &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="5890e8d1e9f41b0cd60cd417fec506b423153a1c" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_publication_tables&lt;/code&gt; provides information about the mapping between publications and the tables they contain. Unlike the underlying catalog &lt;code&gt;pg_publication_rel&lt;/code&gt;, this view expands publications defined as &lt;code&gt;FOR ALL TABLES&lt;/code&gt;, so for such publications there will be a row for each eligible table.</source>
          <target state="translated">&lt;code&gt;pg_publication_tables&lt;/code&gt; 뷰 는 발행물과 포함 된 테이블 간의 맵핑에 대한 정보를 제공합니다. 기본 카탈로그 &lt;code&gt;pg_publication_rel&lt;/code&gt; 과 달리이 보기는 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 로 정의 된 발행물을 확장 하므로 해당 발행물의 경우 적합한 각 테이블에 대한 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6f8a891f9c67ef2b6de308cc7563907a8fbe06b" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_roles&lt;/code&gt; provides access to information about database roles. This is simply a publicly readable view of &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="translated">&lt;code&gt;pg_roles&lt;/code&gt; 뷰 는 데이터베이스 역할에 대한 정보에 대한 액세스를 제공합니다. 이것은 비밀번호 필드 를 &lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt; 공개적으로 읽을 수있는 pg_authid 보기입니다 .</target>
        </trans-unit>
        <trans-unit id="be02d2530abee0307e3d8c75ed7462d6006d37d5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_rules&lt;/code&gt; provides access to useful information about query rewrite rules.</source>
          <target state="translated">&lt;code&gt;pg_rules&lt;/code&gt; 뷰 는 쿼리 재 작성 규칙에 대한 유용한 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8abbf138d7583623930f0cc0e4290da9934bc84a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_seclabels&lt;/code&gt; provides information about security labels. It as an easier-to-query version of the &lt;a href=&quot;catalog-pg-seclabel&quot;&gt;&lt;code&gt;pg_seclabel&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="translated">&lt;code&gt;pg_seclabels&lt;/code&gt; 뷰 는 보안 레이블에 대한 정보를 제공합니다. &lt;a href=&quot;catalog-pg-seclabel&quot;&gt; &lt;code&gt;pg_seclabel&lt;/code&gt; &lt;/a&gt; 카탈로그 의 쿼리하기 쉬운 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="9de8f57dd43c6ec5ae63346c8a1f92176c16d0d1" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_sequences&lt;/code&gt; provides access to useful information about each sequence in the database.</source>
          <target state="translated">&lt;code&gt;pg_sequences&lt;/code&gt; 뷰 는 데이터베이스의 각 시퀀스에 대한 유용한 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="25e4f3261aeb43d1f5668204f1fb62fa4677a0bd" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_settings&lt;/code&gt; provides access to run-time parameters of the server. It is essentially an alternative interface to the &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; and &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; commands. It also provides access to some facts about each parameter that are not directly available from &lt;code&gt;SHOW&lt;/code&gt;, such as minimum and maximum values.</source>
          <target state="translated">&lt;code&gt;pg_settings&lt;/code&gt; 뷰 는 서버의 런타임 매개 변수에 대한 액세스를 제공합니다. 기본적으로 &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; 및 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 명령에 대한 대체 인터페이스 입니다. 또한 &lt;code&gt;SHOW&lt;/code&gt; 에서 직접 사용할 수없는 각 매개 변수 ( 최소 및 최대 값)에 대한 일부 정보에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7729b5ec7977be5f90c3408f6cef81a593faa4de" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_shadow&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows properties of all roles that are marked as &lt;code&gt;rolcanlogin&lt;/code&gt; in &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_shadow&lt;/code&gt; 뷰 는 이전 버전과의 호환성을 위해 존재합니다. 8.1 이전 버전의 PostgreSQL에 있던 카탈로그를 에뮬레이트합니다. &lt;code&gt;rolcanlogin&lt;/code&gt; 에서 &lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt; 표시된 모든 역할의 속성을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d15bc53a297402a714a0bba8855047689e420c4a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; catalog. This view allows access only to rows of &lt;code&gt;pg_statistic&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="translated">&lt;code&gt;pg_stats&lt;/code&gt; 뷰 는 &lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt; 카탈로그에 저장된 정보에 대한 액세스를 제공합니다 . 이보기는 사용자에게 읽기 권한이있는 테이블에 해당하는 &lt;code&gt;pg_statistic&lt;/code&gt; 행에만 액세스 할 수 있으므로이 보기에 대한 공개 읽기 액세스를 허용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8b10f73e0ee9172a27b8a2e39f5e546984d02189" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats_ext&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt;&lt;code&gt;pg_statistic_ext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalogs. This view allows access only to rows of &lt;code&gt;pg_statistic_ext&lt;/code&gt; and &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="translated">&lt;code&gt;pg_stats_ext&lt;/code&gt; 뷰 는 &lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt; &lt;code&gt;pg_statistic_ext&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt; &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; &lt;/a&gt; 카탈로그에 저장된 정보에 대한 액세스를 제공합니다 . 이보기는 사용자에게 읽기 권한이있는 테이블에 해당하는 &lt;code&gt;pg_statistic_ext&lt;/code&gt; 및 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 행에만 액세스 할 수 있으므로이 보기에 대한 공개 읽기 액세스를 허용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f40e73d682038b4cca53135af313b3e16f3f20f0" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_tables&lt;/code&gt; provides access to useful information about each table in the database.</source>
          <target state="translated">&lt;code&gt;pg_tables&lt;/code&gt; 뷰 는 데이터베이스의 각 테이블에 대한 유용한 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6619a281d707d2c59aad726e79eb743d37565afc" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; provides a list of time zone abbreviations that are currently recognized by the datetime input routines. The contents of this view change when the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; run-time parameter is modified.</source>
          <target state="translated">&lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; 보기 는 현재 datetime 입력 루틴이 인식하는 시간대 약어 목록을 제공합니다. &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; 런타임 매개 변수가 수정 되면이보기의 내용이 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="779554f59d2b5af071b41b6375ef03ef95013941" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_names&lt;/code&gt; provides a list of time zone names that are recognized by &lt;code&gt;SET TIMEZONE&lt;/code&gt;, along with their associated abbreviations, UTC offsets, and daylight-savings status. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.) Unlike the abbreviations shown in &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;&lt;code&gt;pg_timezone_abbrevs&lt;/code&gt;&lt;/a&gt;, many of these names imply a set of daylight-savings transition date rules. Therefore, the associated information changes across local DST boundaries. The displayed information is computed based on the current value of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_timezone_names&lt;/code&gt; 뷰 는 &lt;code&gt;SET TIMEZONE&lt;/code&gt; 에 의해 인식되는 시간대 이름 목록 과 관련 약어, UTC 오프셋 및 일광 절약 상태를 제공합니다. 기술적으로 PostgreSQL은 윤초를 처리하지 않기 때문에 UTC를 사용하지 않습니다. &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt; &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; 에&lt;/a&gt; 표시된 약어와 달리 이러한 이름 중 상당수는 일광 절약 전환 날짜 규칙 세트를 의미합니다. 따라서 관련 정보가 로컬 DST 경계에서 변경됩니다. 표시된 정보는 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 의 현재 값을 기반으로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="0accb8d532196eb116802aaa4d92096a1d624fec" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user&lt;/code&gt; provides access to information about database users. This is simply a publicly readable view of &lt;a href=&quot;view-pg-shadow&quot;&gt;&lt;code&gt;pg_shadow&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="translated">&lt;code&gt;pg_user&lt;/code&gt; 뷰 는 데이터베이스 사용자에 대한 정보에 대한 액세스를 제공합니다. 이것은 비밀번호 필드 를 &lt;a href=&quot;view-pg-shadow&quot;&gt; &lt;code&gt;pg_shadow&lt;/code&gt; &lt;/a&gt; 공개적으로 읽을 수있는 pg_shadow 뷰입니다 .</target>
        </trans-unit>
        <trans-unit id="9af556d749b255c75a83063bd94ae2fbcc5e7542" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user_mappings&lt;/code&gt; provides access to information about user mappings. This is essentially a publicly readable view of &lt;a href=&quot;catalog-pg-user-mapping&quot;&gt;&lt;code&gt;pg_user_mapping&lt;/code&gt;&lt;/a&gt; that leaves out the options field if the user has no rights to use it.</source>
          <target state="translated">&lt;code&gt;pg_user_mappings&lt;/code&gt; 뷰 는 사용자 매핑에 대한 정보에 대한 액세스를 제공합니다. 이것은 &lt;a href=&quot;catalog-pg-user-mapping&quot;&gt; &lt;code&gt;pg_user_mapping&lt;/code&gt; &lt;/a&gt; 의 공개적으로 읽을 수있는보기로 , 사용자에게 옵션을 사용할 권한이없는 경우 옵션 필드를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="ebac217e3082208e364c831d2d7b567e319b9c3e" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_views&lt;/code&gt; provides access to useful information about each view in the database.</source>
          <target state="translated">뷰 &lt;code&gt;pg_views&lt;/code&gt; 는 데이터베이스의 각보기에 대한 유용한 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4817256584c648c50b28a16cee721735c1a52c24" translate="yes" xml:space="preserve">
          <source>The view definition must not contain &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, or &lt;code&gt;OFFSET&lt;/code&gt; clauses at the top level.</source>
          <target state="translated">뷰 정의에는 최상위 레벨에서 &lt;code&gt;WITH&lt;/code&gt; , &lt;code&gt;DISTINCT&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; , &lt;code&gt;HAVING&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; 또는 &lt;code&gt;OFFSET&lt;/code&gt; 절이 포함되지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac73f4040a9b923ccad030c67910098b61fec109" translate="yes" xml:space="preserve">
          <source>The view definition must not contain set operations (&lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) at the top level.</source>
          <target state="translated">뷰 정의는 최상위 레벨에서 세트 조작 ( &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; 또는 &lt;code&gt;EXCEPT&lt;/code&gt; )을 포함해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5066d83f9232becf3a59274519313c89ede3a33" translate="yes" xml:space="preserve">
          <source>The view must have exactly one entry in its &lt;code&gt;FROM&lt;/code&gt; list, which must be a table or another updatable view.</source>
          <target state="translated">뷰는 &lt;code&gt;FROM&lt;/code&gt; 목록 에 정확히 하나의 항목 을 가져야하며 이는 테이블 또는 다른 업데이트 가능한 뷰 여야합니다.</target>
        </trans-unit>
        <trans-unit id="baf2ef9470f50663334ce73cc7c64a2829052725" translate="yes" xml:space="preserve">
          <source>The view's select list must not contain any aggregates, window functions or set-returning functions.</source>
          <target state="translated">뷰의 선택 목록에는 집계, 창 함수 또는 집합 반환 함수가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="130532d5707af5b172a46c66162c216e956933cf" translate="yes" xml:space="preserve">
          <source>The visibility map stores two bits per heap page. The first bit, if set, indicates that the page is all-visible, or in other words that the page does not contain any tuples that need to be vacuumed. This information can also be used by &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;index-only scans&lt;/em&gt;&lt;/a&gt; to answer queries using only the index tuple. The second bit, if set, means that all tuples on the page have been frozen. That means that even an anti-wraparound vacuum need not revisit the page.</source>
          <target state="translated">가시성 맵은 힙 페이지 당 2 비트를 저장합니다. 첫 번째 비트 (설정된 경우)는 페이지가 모두 표시됨을 나타내거나 다시 말해 청소해야 할 튜플이 페이지에 없음을 나타냅니다. 이 정보는 인덱스 튜플 만 사용하여 쿼리에 응답하기 위해 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;인덱스 전용 스캔&lt;/em&gt;&lt;/a&gt; 에서도 사용할 수 있습니다 . 두 번째 비트 (설정된 경우)는 페이지의 모든 튜플이 고정되었음을 의미합니다. 이는 랩 어라운드 방지 진공조차도 페이지를 다시 방문 할 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="07214e8c015e87c0486ca72cfe80d8e537680c27" translate="yes" xml:space="preserve">
          <source>The web site of the Unicode Consortium.</source>
          <target state="translated">유니 코드 컨소시엄의 웹 사이트.</target>
        </trans-unit>
        <trans-unit id="ac0772ef278780058ef7ad6f8b7ba38fa2811ad4" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;The&lt;/code&gt; was recognized by the &lt;code&gt;english_ispell&lt;/code&gt; dictionary as a stop word (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;) and will not be indexed. The spaces are discarded too, since the configuration provides no dictionaries at all for them.</source>
          <target state="translated">단어 &lt;code&gt;The&lt;/code&gt; 에 의해 인식되었다 &lt;code&gt;english_ispell&lt;/code&gt; 의 정지 단어 (같은 사전 &lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;섹션 12.6.1&lt;/a&gt; ) 및 인덱싱되지 않습니다. 구성은 사전을 전혀 제공하지 않으므로 공백도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="59b558b7e67cfe3d7e609850ba39630cdfabc234" translate="yes" xml:space="preserve">
          <source>The words &lt;code&gt;INNER&lt;/code&gt; and &lt;code&gt;OUTER&lt;/code&gt; are optional in all forms. &lt;code&gt;INNER&lt;/code&gt; is the default; &lt;code&gt;LEFT&lt;/code&gt;, &lt;code&gt;RIGHT&lt;/code&gt;, and &lt;code&gt;FULL&lt;/code&gt; imply an outer join.</source>
          <target state="translated">&lt;code&gt;INNER&lt;/code&gt; 및 &lt;code&gt;OUTER&lt;/code&gt; 라는 단어 는 모든 형태에서 선택 사항입니다. &lt;code&gt;INNER&lt;/code&gt; 가 기본값입니다. &lt;code&gt;LEFT&lt;/code&gt; , &lt;code&gt;RIGHT&lt;/code&gt; 및 &lt;code&gt;FULL&lt;/code&gt; 은 외부 조인을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0b4d99c273391963b8b35583f768d35f9926b320" translate="yes" xml:space="preserve">
          <source>The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; parameter to be set high enough that the log is not removed before the end of the backup. If the log has been rotated when it's time to transfer it, the backup will fail and be unusable.</source>
          <target state="translated">미리 쓰기 로그 파일은 백업이 끝날 때 수집됩니다. 따라서 백업이 끝나기 전에 로그가 제거되지 않을 정도로 &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; 매개 변수를 높게 설정해야합니다. 로그를 전송할 때 로그가 회전 된 경우 백업이 실패하고 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="bb82d1de22fb923c487c6dd4a9b8f7c1ca501443" translate="yes" xml:space="preserve">
          <source>The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the source server's &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; parameter to be set high enough that the required log data is not removed before the end of the backup. If the required log data has been recycled before it's time to transfer it, the backup will fail and be unusable.</source>
          <target state="translated">The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the source server's &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; parameter to be set high enough that the required log data is not removed before the end of the backup. If the required log data has been recycled before it's time to transfer it, the backup will fail and be unusable.</target>
        </trans-unit>
        <trans-unit id="ba7564fc67dee171caeeb2fce7f2a0e6bd4739d4" translate="yes" xml:space="preserve">
          <source>The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</source>
          <target state="translated">미리 쓰기 로그는 일반 PostgreSQL 연결을 통해 스트리밍되며 복제 프로토콜을 사용합니다. 수퍼 유저 또는 &lt;code&gt;REPLICATION&lt;/code&gt; 권한이 있는 사용자 ( &lt;a href=&quot;role-attributes&quot;&gt;21.2 절&lt;/a&gt; 참조 ) 를 사용하여 연결해야 하며 &lt;code&gt;pg_hba.conf&lt;/code&gt; 는 복제 연결을 허용해야합니다. 또한 스트림에 사용 가능한 세션을 하나 이상 남겨 둘 수 있도록 &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; 를 높게 설정 하여 서버를 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="98bdbb8059522e13ab67d4f644a83a409dec157e" translate="yes" xml:space="preserve">
          <source>The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;) or a superuser, and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</source>
          <target state="translated">The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;) or a superuser, and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</target>
        </trans-unit>
        <trans-unit id="432cd562d6efcb95d5dc25b8cd51ce86806b3431" translate="yes" xml:space="preserve">
          <source>The year field divided by 10</source>
          <target state="translated">연도 필드를 10으로 나눈 값</target>
        </trans-unit>
        <trans-unit id="e98cba09cda3a8f0612018162bdf75b308d8a647" translate="yes" xml:space="preserve">
          <source>The year field. Keep in mind there is no &lt;code&gt;0 AD&lt;/code&gt;, so subtracting &lt;code&gt;BC&lt;/code&gt; years from &lt;code&gt;AD&lt;/code&gt; years should be done with care.</source>
          <target state="translated">연도 필드. 더 없다 명심 &lt;code&gt;0 AD&lt;/code&gt; 가 너무 빼서, &lt;code&gt;BC&lt;/code&gt; 주 에서 세 &lt;code&gt;AD&lt;/code&gt; 신중하게해야 년.</target>
        </trans-unit>
        <trans-unit id="3552e22363d1468b0aacd8c69df60173fa97d631" translate="yes" xml:space="preserve">
          <source>Then a second pass is performed to add tuples that were added while the first pass was running. This step is also done in a separate transaction for each index.</source>
          <target state="translated">그런 다음 첫 번째 패스가 실행되는 동안 추가 된 튜플을 추가하기 위해 두 번째 패스가 수행됩니다. 이 단계는 각 인덱스마다 별도의 트랜잭션으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="de263736bca031472680a6589ed91b77cebda41e" translate="yes" xml:space="preserve">
          <source>Then create a foreign server using &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;. In this example we wish to connect to a PostgreSQL server on host &lt;code&gt;192.83.123.89&lt;/code&gt; listening on port &lt;code&gt;5432&lt;/code&gt;. The database to which the connection is made is named &lt;code&gt;foreign_db&lt;/code&gt; on the remote server:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER를&lt;/a&gt; 사용하여 외부 서버를 작성하십시오 . 이 예에서는 포트 &lt;code&gt;5432&lt;/code&gt; 에서 수신 대기하는 호스트 &lt;code&gt;192.83.123.89&lt;/code&gt; 의 PostgreSQL 서버에 연결하려고합니다 . 연결되는 데이터베이스의 이름 은 원격 서버에서 &lt;code&gt;foreign_db&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a9fba163e98528da53932bde9ceaf387982416c" translate="yes" xml:space="preserve">
          <source>Then create a foreign server:</source>
          <target state="translated">그런 다음 외부 서버를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e43083876c3094d12a2389b25dd099144327f495" translate="yes" xml:space="preserve">
          <source>Then create the necessary functions:</source>
          <target state="translated">그런 다음 필요한 기능을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2dddb885a6a2b1519c7054126c37d9c20d84517e" translate="yes" xml:space="preserve">
          <source>Then do:</source>
          <target state="translated">그런 다음 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4426056bca332e6c166eaec6ccb98cd595443c37" translate="yes" xml:space="preserve">
          <source>Then give the snapshot identifier in a &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command at the beginning of the newly opened transaction:</source>
          <target state="translated">그런 다음 새로 열린 트랜잭션 시작시 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 명령에 스냅 샷 ID를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="099f3b7a79e1e05797463b8b9b3322c6caaa4e61" translate="yes" xml:space="preserve">
          <source>Then in</source>
          <target state="translated">그런 다음</target>
        </trans-unit>
        <trans-unit id="ccb8ef6dada9fbef1512f58ed41d1e67ec739a68" translate="yes" xml:space="preserve">
          <source>Then issue the tablespace creation command inside PostgreSQL:</source>
          <target state="translated">그런 다음 PostgreSQL 내에서 테이블 스페이스 작성 명령을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="a0f76343f97548fdfb798c00512768e705a5ee06" translate="yes" xml:space="preserve">
          <source>Then on the publisher database:</source>
          <target state="translated">그런 다음 게시자 데이터베이스에서 :</target>
        </trans-unit>
        <trans-unit id="1d6e3db28b5d51e7392c9e84a5178977bac26570" translate="yes" xml:space="preserve">
          <source>Then psql's &lt;code&gt;\dp&lt;/code&gt; command would show:</source>
          <target state="translated">그런 다음 psql의 &lt;code&gt;\dp&lt;/code&gt; 명령은 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e40d95af0c8bcea8599638c011ae6dba5195ebe1" translate="yes" xml:space="preserve">
          <source>Then value &lt;code&gt;i&lt;/code&gt; between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; inclusive is drawn with probability: &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 값 사이의 값 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt; 확률로 그려집니다 .</target>
        </trans-unit>
        <trans-unit id="509703ffcaaed84d033fc9e94ce5a7937bf0da94" translate="yes" xml:space="preserve">
          <source>Then we create a GIN index to speed up the search:</source>
          <target state="translated">그런 다음 검색 속도를 높이기 위해 GIN 색인을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c623faac8eaf06e9450b38faf671811be2f6e1f9" translate="yes" xml:space="preserve">
          <source>Then we no longer have access to the public schema without explicit qualification. There is nothing special about the public schema except that it exists by default. It can be dropped, too.</source>
          <target state="translated">그런 다음 명시적인 자격 없이는 더 이상 공개 스키마에 액세스 할 수 없습니다. 퍼블릭 스키마는 기본적으로 존재한다는 점을 제외하고는 특별한 것이 없습니다. 떨어 뜨릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d0e01998d1caf45906467ce09eb6d9f85a24392" translate="yes" xml:space="preserve">
          <source>Then we will get these results:</source>
          <target state="translated">그러면 다음과 같은 결과가 나옵니다.</target>
        </trans-unit>
        <trans-unit id="30348812ea695911ccd6ce73f8cff665d67bd9ad" translate="yes" xml:space="preserve">
          <source>Then you can use it in a &lt;code&gt;SELECT&lt;/code&gt; command, for instance:</source>
          <target state="translated">그런 다음 &lt;code&gt;SELECT&lt;/code&gt; 명령 에서 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c956d2a4c1c867a4aa753ae841035f68a38bb7b" translate="yes" xml:space="preserve">
          <source>Then you could name the files in the &lt;code&gt;conf.d&lt;/code&gt; directory like this:</source>
          <target state="translated">그런 다음 &lt;code&gt;conf.d&lt;/code&gt; 디렉토리 의 파일 이름을 다음과 같이 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4c7647dc71f8f47d91ed549387e0af6d05b17ea" translate="yes" xml:space="preserve">
          <source>Then, create a symbolic link to it in &lt;code&gt;/etc/rc3.d&lt;/code&gt; as &lt;code&gt;S99postgresql&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;/etc/rc3.d&lt;/code&gt; 에 &lt;code&gt;S99postgresql&lt;/code&gt; 로 심볼릭 링크를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e196180497775135006d17c14fe064e7b2203578" translate="yes" xml:space="preserve">
          <source>Then, sign the request with the key to create a root certificate authority (using the default OpenSSL configuration file location on Linux):</source>
          <target state="translated">그런 다음 키로 요청에 서명하여 루트 인증 기관을 작성하십시오 (Linux의 기본 OpenSSL 구성 파일 위치 사용).</target>
        </trans-unit>
        <trans-unit id="50d0f1107bc900bc4a9d5405919a76e23f028a3e" translate="yes" xml:space="preserve">
          <source>There also exist local objects that do not belong to schemas; some examples are &lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;extensions&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-CAST&quot;&gt;data type casts&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrappers&lt;/a&gt;. The names of such objects of the same type are enforced to be unique within the database.</source>
          <target state="translated">There also exist local objects that do not belong to schemas; some examples are &lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;extensions&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-CAST&quot;&gt;data type casts&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrappers&lt;/a&gt;. The names of such objects of the same type are enforced to be unique within the database.</target>
        </trans-unit>
        <trans-unit id="5100635bf226727d046c206be142bf5ea8b71db2" translate="yes" xml:space="preserve">
          <source>There are a few built-in trigger functions that can be used to solve common problems without having to write your own trigger code; see &lt;a href=&quot;https://www.postgresql.org/docs/13/functions-trigger.html&quot;&gt;Section 9.28&lt;/a&gt;.</source>
          <target state="translated">There are a few built-in trigger functions that can be used to solve common problems without having to write your own trigger code; see &lt;a href=&quot;https://www.postgresql.org/docs/13/functions-trigger.html&quot;&gt;Section 9.28&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6e6f711b66bbac69a2f23c2445e625c076269156" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on operator names, however:</source>
          <target state="translated">그러나 운영자 이름에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06308b22446d8ff8a3bec464184e0db33a1b8e3" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on your choice of name:</source>
          <target state="translated">선택하는 데 몇 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e38ec4f8f8d1c9acce491ad6d51f28d3688ffbf6" translate="yes" xml:space="preserve">
          <source>There are a few solutions that do not fit into the above categories:</source>
          <target state="translated">위의 범주에 맞지 않는 몇 가지 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2d4b5a4acbfddfda3fa8af2f47936fbae4e67b7" translate="yes" xml:space="preserve">
          <source>There are a few things to be careful about when adding trace macros to the C code:</source>
          <target state="translated">C 코드에 추적 매크로를 추가 할 때주의해야 할 사항이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="30225d755151e996e06d97ca5afb06ce57185f7a" translate="yes" xml:space="preserve">
          <source>There are a few things you need to do to simplify importing CSV log files:</source>
          <target state="translated">CSV 로그 파일 가져 오기를 단순화하기 위해 수행해야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f7d5ba0c83b5c117ed409216f966f9d7eef72d" translate="yes" xml:space="preserve">
          <source>There are also additional types of conflict that can occur with Hot Standby. These conflicts are &lt;em&gt;hard conflicts&lt;/em&gt; in the sense that queries might need to be canceled and, in some cases, sessions disconnected to resolve them. The user is provided with several ways to handle these conflicts. Conflict cases include:</source>
          <target state="translated">핫 스탠바이에서 발생할 수있는 추가 유형의 충돌도 있습니다. 이러한 충돌은 &lt;em&gt;하드 충돌&lt;/em&gt; 쿼리를 취소 할 수 있으며, 경우에 세션을 해결하기 위해 분리한다는 점이다. 사용자에게는 이러한 충돌을 처리 할 수있는 몇 가지 방법이 제공됩니다. 충돌 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="080fe8c96ab19e790a2ea0bd30b8130c9a87b676" translate="yes" xml:space="preserve">
          <source>There are also some built-in operator classes besides the default ones:</source>
          <target state="translated">기본 클래스 외에 내장 연산자 클래스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8bbd8454471c92fa3e16174c667ec63b3cc9c3f" translate="yes" xml:space="preserve">
          <source>There are also some comparison predicates, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;Table 9.2&lt;/a&gt;. These behave much like operators, but have special syntax mandated by the SQL standard.</source>
          <target state="translated">&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;표 9.2에&lt;/a&gt; 표시된 것처럼 일부 비교 술어도 있습니다 . 이들은 연산자와 매우 유사하게 작동하지만 SQL 표준에서 요구하는 특수 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f3ba822c528ebdfeb9746d393a7742a7d6e349" translate="yes" xml:space="preserve">
          <source>There are cases in which the actual and estimated values won't match up well, but nothing is really wrong. One such case occurs when plan node execution is stopped short by a &lt;code&gt;LIMIT&lt;/code&gt; or similar effect. For example, in the &lt;code&gt;LIMIT&lt;/code&gt; query we used before,</source>
          <target state="translated">실제 값과 추정 값이 일치하지 않는 경우가 있지만 실제로 잘못된 것은 없습니다. &lt;code&gt;LIMIT&lt;/code&gt; 또는 이와 유사한 영향으로 계획 노드 실행이 짧게 중지 될 때 이러한 경우가 발생합니다 . 예를 들어, 이전에 사용한 &lt;code&gt;LIMIT&lt;/code&gt; 쿼리에서</target>
        </trans-unit>
        <trans-unit id="626c9a7674dab9b044bc50641f2a4b064da217a4" translate="yes" xml:space="preserve">
          <source>There are certain operations that hold critical locks and should therefore complete as quickly as possible. Cost-based vacuum delays do not occur during such operations. Therefore it is possible that the cost accumulates far higher than the specified limit. To avoid uselessly long delays in such cases, the actual delay is calculated as &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; / &lt;code&gt;vacuum_cost_limit&lt;/code&gt; with a maximum of &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4.</source>
          <target state="translated">중요한 잠금을 유지하는 작업이 있으므로 최대한 빨리 완료해야합니다. 이러한 작업 중에는 비용 기반 진공 지연이 발생하지 않습니다. 따라서 비용이 지정된 한도보다 훨씬 더 많이 누적 될 수 있습니다. 이러한 경우에 쓸데없이 긴 지연을 피하기 위해 실제 지연은 최대 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4 인 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; _ &lt;code&gt;vacuum_cost_limit&lt;/code&gt; / vacuum_cost_limit 로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="49623fffc3b27e386ddb0902bf870bdd64aa14c1" translate="yes" xml:space="preserve">
          <source>There are different kinds of privileges: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REFERENCES&lt;/code&gt;, &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;TEMPORARY&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, and &lt;code&gt;USAGE&lt;/code&gt;. The privileges applicable to a particular object vary depending on the object's type (table, function, etc). More detail about the meanings of these privileges appears below. The following sections and chapters will also show you how these privileges are used.</source>
          <target state="translated">: 권한의 다른 종류가있다 &lt;code&gt;SELECT&lt;/code&gt; 가 , &lt;code&gt;INSERT&lt;/code&gt; 가 , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REFERENCES&lt;/code&gt; , &lt;code&gt;TRIGGER&lt;/code&gt; , &lt;code&gt;CREATE&lt;/code&gt; , &lt;code&gt;CONNECT&lt;/code&gt; 는 , &lt;code&gt;TEMPORARY&lt;/code&gt; , &lt;code&gt;EXECUTE&lt;/code&gt; 및 &lt;code&gt;USAGE&lt;/code&gt; . 특정 객체에 적용 할 수있는 권한은 객체 유형 (테이블, 기능 등)에 따라 다릅니다. 이러한 권한의 의미에 대한 자세한 내용은 아래에 나와 있습니다. 다음 섹션과 장에서는 이러한 권한이 어떻게 사용되는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2f4c8f7302f72ae7897c7273dc4e0796366f4575" translate="yes" xml:space="preserve">
          <source>There are examples in &lt;code&gt;refint.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refint.example&lt;/code&gt; 에 예제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e74d4a0a2f4513529b90fbecc5989b2ddcb617e4" translate="yes" xml:space="preserve">
          <source>There are five forms of &lt;code&gt;CREATE TYPE&lt;/code&gt;, as shown in the syntax synopsis above. They respectively create a &lt;em&gt;composite type&lt;/em&gt;, an &lt;em&gt;enum type&lt;/em&gt;, a &lt;em&gt;range type&lt;/em&gt;, a &lt;em&gt;base type&lt;/em&gt;, or a &lt;em&gt;shell type&lt;/em&gt;. The first four of these are discussed in turn below. A shell type is simply a placeholder for a type to be defined later; it is created by issuing &lt;code&gt;CREATE TYPE&lt;/code&gt; with no parameters except for the type name. Shell types are needed as forward references when creating range types and base types, as discussed in those sections.</source>
          <target state="translated">위의 구문 개요에서 볼 수 있듯이 &lt;code&gt;CREATE TYPE&lt;/code&gt; 의 다섯 가지 형식이 있습니다 . 이들은 각각 &lt;em&gt;복합 형&lt;/em&gt; , &lt;em&gt;열거 형&lt;/em&gt; , &lt;em&gt;범위 형&lt;/em&gt; , &lt;em&gt;기본형&lt;/em&gt; 또는 &lt;em&gt;쉘형을 작성합니다&lt;/em&gt; . 이들 중 처음 네 개는 아래에서 차례로 설명합니다. 쉘 유형은 유형이 나중에 정의 될 자리 표시 자일뿐입니다. 유형 이름 이외의 매개 변수없이 &lt;code&gt;CREATE TYPE&lt;/code&gt; 을 발행하여 작성됩니다 . 셸 유형은 해당 섹션에서 설명한대로 범위 유형 및 기본 유형을 만들 때 정방향 참조로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6b159eaf60b6b4119e8b7cbd7a662966676f50a3" translate="yes" xml:space="preserve">
          <source>There are five methods that an index operator class for GiST must provide, and five that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt;, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt;, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted. The optional tenth method &lt;code&gt;options&lt;/code&gt; is needed if the operator class provides the user-specified parameters.</source>
          <target state="translated">There are five methods that an index operator class for GiST must provide, and five that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt; , &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt; , which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt; , which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted. The optional tenth method &lt;code&gt;options&lt;/code&gt; is needed if the operator class provides the user-specified parameters.</target>
        </trans-unit>
        <trans-unit id="c1c0e123011cea9ffa5e9167dd8e734710858d21" translate="yes" xml:space="preserve">
          <source>There are five methods that an index operator class for GiST must provide, and four that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt;, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt;, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted.</source>
          <target state="translated">GiST에 대한 인덱스 연산자 클래스가 제공해야하는 5 가지 메소드가 있으며 선택적으로 4 가지가 있습니다. 인덱스의 정확성이 적절히 구현 확보 &lt;code&gt;same&lt;/code&gt; , &lt;code&gt;consistent&lt;/code&gt; 과 &lt;code&gt;union&lt;/code&gt; 인덱스의 효율 (크기 및 속도)가에 달려 있지만, 방법 &lt;code&gt;penalty&lt;/code&gt; 및 &lt;code&gt;picksplit&lt;/code&gt; 방법. 두 가지 선택적인 방법은 &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;decompress&lt;/code&gt; 입니다 . 인덱스는 인덱스하는 데이터와 다른 유형의 내부 트리 데이터를 가질 수 있습니다. 잎은 다른 트리 노드가 어떤 C 구조체 될 수 있습니다 (하지만 당신은 여전히 여기 PostgreSQL의 데이터 형식 규칙을 따라야하지만, 인덱스 데이터 형식의 것이어야한다 정보를 참조하십시오 &lt;code&gt;varlena&lt;/code&gt; 가변 크기 데이터의 경우). 트리의 내부 데이터 유형이 SQL 레벨에 존재 하면 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 명령 의 &lt;code&gt;STORAGE&lt;/code&gt; 옵션을 사용할 수 있습니다. 선택적인 여덟 번째 방법은 &lt;code&gt;distance&lt;/code&gt; 로 , 연산자 클래스가 정렬 된 스캔 (가까운 이웃 검색)을 지원하려는 경우에 필요합니다. &lt;code&gt;compress&lt;/code&gt; 클래스 가 생략 된 경우를 제외하고 연산자 클래스가 인덱스 전용 스캔을 지원하려는 경우 선택적 아홉 번째 메소드 &lt;code&gt;fetch&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="29e9f9add6de4117c3f41e8f16d45114f4cd168c" translate="yes" xml:space="preserve">
          <source>There are five user-defined methods that an index operator class for SP-GiST must provide, and one is optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt;, since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; additionally returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts datum to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple.</source>
          <target state="translated">SP-GiST 용 인덱스 연산자 클래스가 제공해야하는 5 가지 사용자 정의 메소드가 있으며 하나는 선택 사항입니다. 다섯 가지 필수 메소드는 모두 두 개의 &lt;code&gt;internal&lt;/code&gt; 인수 를 허용하는 규칙을 따릅니다. 첫 번째 인수는 지원 메소드의 입력 값을 포함하는 C 구조체에 대한 포인터이고 두 번째 인수는 출력 값을 배치해야하는 C 구조체에 대한 포인터입니다. 모든 필수 결과가 출력 구조체에 나타나기 때문에 필수 메서드 중 4 개는 &lt;code&gt;void&lt;/code&gt; 를 반환합니다 . 그러나 &lt;code&gt;leaf_consistent&lt;/code&gt; 는 &lt;code&gt;boolean&lt;/code&gt; 결과를 추가로 리턴합니다 . 메소드는 입력 구조체의 필드를 수정해서는 안됩니다. 모든 경우에 출력 구조체는 사용자 정의 메소드를 호출하기 전에 0으로 초기화됩니다. 선택적인 여섯 번째 방법 &lt;code&gt;compress&lt;/code&gt; 는 데이텀이 유일한 인수로 색인화되도록 허용하고 리프 튜플의 물리적 저장에 적합한 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="666f4f8fef47bb1c6205d9fa4aaa2bdc7c54c92a" translate="yes" xml:space="preserve">
          <source>There are five user-defined methods that an index operator class for SP-GiST must provide, and two are optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt;, since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts a &lt;code&gt;datum&lt;/code&gt; to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple. The optional seventh method &lt;code&gt;options&lt;/code&gt; accepts an &lt;code&gt;internal&lt;/code&gt; pointer to a C struct, where opclass-specific parameters should be placed, and returns &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">There are five user-defined methods that an index operator class for SP-GiST must provide, and two are optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt; , since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts a &lt;code&gt;datum&lt;/code&gt; to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple. The optional seventh method &lt;code&gt;options&lt;/code&gt; accepts an &lt;code&gt;internal&lt;/code&gt; pointer to a C struct, where opclass-specific parameters should be placed, and returns &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa03941817da7215f34f7c4059988c3830f85876" translate="yes" xml:space="preserve">
          <source>There are four fundamental SQL constructs requiring distinct type conversion rules in the PostgreSQL parser:</source>
          <target state="translated">PostgreSQL 파서에는 고유 한 유형 변환 규칙이 필요한 네 가지 기본 SQL 구성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af078d5f8f920b3bd3ff699db4f54f596acf2a85" translate="yes" xml:space="preserve">
          <source>There are four methods that an operator class for BRIN must provide:</source>
          <target state="translated">BRIN의 연산자 클래스가 제공해야하는 네 가지 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc37bd22ec5c580834570b2476e6fe4f24b8403a" translate="yes" xml:space="preserve">
          <source>There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.15.2.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;like_regex&lt;/code&gt; &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;절&lt;/a&gt; 에서 설명한 것처럼 like_regex 필터에 사용 된 정규식 패턴의 해석에는 약간의 차이가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d77bf2fc4587de107eca9fd91e0707c3fe21d0a" translate="yes" xml:space="preserve">
          <source>There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.16.2.3&lt;/a&gt;.</source>
          <target state="translated">There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.16.2.3&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e2d1e6b157368edb7a34c08bf06a60ee5f8744e9" translate="yes" xml:space="preserve">
          <source>There are not currently any commands that manipulate procedural language templates; to change the built-in information, a superuser must modify the table using ordinary &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;UPDATE&lt;/code&gt; commands.</source>
          <target state="translated">현재 절차 언어 템플릿을 조작하는 명령은 없습니다. 내장 정보를 변경하려면 수퍼 유저가 일반 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 명령을 사용하여 테이블을 수정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="18b7b9a654dddbbbf44432092fdfff639afd65c3" translate="yes" xml:space="preserve">
          <source>There are parallel variants of these operators for both the &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types. The field/element/path extraction operators return the same type as their left-hand input (either &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;), except for those specified as returning &lt;code&gt;text&lt;/code&gt;, which coerce the value to text. The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such element exists. The field/element/path extraction operators that accept integer JSON array subscripts all support negative subscripting from the end of arrays.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;jsonb&lt;/code&gt; 유형 모두에 대해 이러한 연산자의 병렬 변형이 있습니다. 필드 / 요소 / 경로 추출 연산자는 좌측 입력 (하나와 동일한 유형을 리턴 &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt; 복귀로 지정된 것을 제외한) &lt;code&gt;text&lt;/code&gt; , 텍스트로 강제 변환 된 값. JSON 입력에 요청과 일치하는 올바른 구조가없는 경우 필드 / 요소 / 경로 추출 연산자는 실패하지 않고 NULL을 반환합니다. 예를 들어 그러한 요소가 존재하지 않는 경우. 정수 JSON 배열 첨자를 허용하는 필드 / 요소 / 경로 추출 연산자는 모두 배열 끝에서 음의 첨자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f87d9a17505cfd4cb8b88d986ea842eb4469f8b6" translate="yes" xml:space="preserve">
          <source>There are several &lt;code&gt;substr&lt;/code&gt; functions, one of which takes types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;. If called with a string constant of unspecified type, the system chooses the candidate function that accepts an argument of the preferred category &lt;code&gt;string&lt;/code&gt; (namely of type &lt;code&gt;text&lt;/code&gt;).</source>
          <target state="translated">여러 개의 &lt;code&gt;substr&lt;/code&gt; 함수가 있으며 그중 하나는 &lt;code&gt;text&lt;/code&gt; 및 &lt;code&gt;integer&lt;/code&gt; 유형을 취 합니다 . 지정되지 않은 유형의 문자열 상수로 호출 된 경우 시스템은 선호 범주 &lt;code&gt;string&lt;/code&gt; (즉, &lt;code&gt;text&lt;/code&gt; 유형 ) 의 인수를 허용하는 후보 함수를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="4a86c45854efa996c6173d14634a86acbb0fae9b" translate="yes" xml:space="preserve">
          <source>There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</source>
          <target state="translated">데이터베이스 성능에 영향을주는 몇 가지 WAL 관련 구성 매개 변수가 있습니다. 이 섹션에서는 사용법에 대해 설명합니다. 서버 구성 매개 변수 설정에 대한 일반 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b72e63e0c980adc25f0dbe77097459ea5e3e677a" translate="yes" xml:space="preserve">
          <source>There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</source>
          <target state="translated">There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</target>
        </trans-unit>
        <trans-unit id="90a47baf0edabbb7ab4de9adfe99efaea9932730" translate="yes" xml:space="preserve">
          <source>There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot.</source>
          <target state="translated">이 옵션을 사용할 때주의해야 할 몇 가지주의 사항이 있습니다. 하나의 색인 이름 만 지정할 수 있으며 &lt;code&gt;CASCADE&lt;/code&gt; 옵션은 지원되지 않습니다. 따라서 &lt;code&gt;UNIQUE&lt;/code&gt; 또는 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건 을 지원하는 인덱스 는이 방법으로 삭제할 수 없습니다. 또한 트랜잭션 블록 내 에서 일반 &lt;code&gt;DROP INDEX&lt;/code&gt; 명령을 수행 할 수 있지만 &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; 는 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce288b97182be46ed306ba70355423aaea68f94a" translate="yes" xml:space="preserve">
          <source>There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot. Lastly, indexes on partitioned tables cannot be dropped using this option.</source>
          <target state="translated">There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot. Lastly, indexes on partitioned tables cannot be dropped using this option.</target>
        </trans-unit>
        <trans-unit id="91dcaac9ead3b10f651956a96badf0ae2f79aa1a" translate="yes" xml:space="preserve">
          <source>There are several common reasons the server might fail to start. Check the server's log file, or start it by hand (without redirecting standard output or standard error) and see what error messages appear. Below we explain some of the most common error messages in more detail.</source>
          <target state="translated">서버가 시작되지 않는 몇 가지 일반적인 이유가 있습니다. 서버의 로그 파일을 확인하거나 표준 출력 또는 표준 오류를 리디렉션하지 않고 직접 시작하여 어떤 오류 메시지가 나타나는지 확인하십시오. 아래에서 가장 일반적인 오류 메시지에 대해보다 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9adbaa62a8322d6f35b205f33d65aadeb73701d5" translate="yes" xml:space="preserve">
          <source>There are several configuration parameters that control the behavior of &lt;code&gt;auto_explain&lt;/code&gt;. Note that the default behavior is to do nothing, so you must set at least &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; if you want any results.</source>
          <target state="translated">&lt;code&gt;auto_explain&lt;/code&gt; 의 동작을 제어하는 ​​몇 가지 구성 매개 변수가 있습니다. 기본 동작은 아무 것도하지 않는 것이므로 결과를 원하면 최소한 &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; 을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d56877000af0d37b6fb862a08aad3882b83fec73" translate="yes" xml:space="preserve">
          <source>There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt;). Also, the right to extend a relation is represented as a separate lockable object, as is the right to update &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datfrozenxid&lt;/code&gt;. Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</source>
          <target state="translated">There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt; ). Also, the right to extend a relation is represented as a separate lockable object, as is the right to update &lt;code&gt;pg_database&lt;/code&gt; . &lt;code&gt;datfrozenxid&lt;/code&gt; . Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</target>
        </trans-unit>
        <trans-unit id="8f07db15d474ec8167b00bf77d56e7101e3f26c7" translate="yes" xml:space="preserve">
          <source>There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt;). Also, the right to extend a relation is represented as a separate lockable object. Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</source>
          <target state="translated">잠금 가능한 개체에는 몇 가지 다른 유형의 잠금 개체가 있습니다. 전체 관계 (예 : 테이블), 개별 관계 페이지, 개별 관계 튜플, 트랜잭션 ID (가상 및 영구 ID) 및 일반 데이터베이스 개체 (클래스 OID 및 개체 OID로 식별), &lt;code&gt;pg_description&lt;/code&gt; 또는 &lt;code&gt;pg_depend&lt;/code&gt; 와 같은 방식으로 ). 또한 관계를 확장 할 수있는 권한은 별도의 잠금 가능한 개체로 표시됩니다. 또한 사용자 정의 의미가있는 숫자에 대해서는 &quot;권고&quot;잠금을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="114cb14410efa6f2de15cd3a5be68d31fc1e555a" translate="yes" xml:space="preserve">
          <source>There are several limitations of Hot Standby. These can and probably will be fixed in future releases:</source>
          <target state="translated">핫 스탠바이에는 몇 가지 제한 사항이 있습니다. 이들은 다음 릴리스에서 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faced4b79c9138d3cc4676d1e4253b24407642f4" translate="yes" xml:space="preserve">
          <source>There are several modifiers that can be put at the end of a non-star &lt;code&gt;lquery&lt;/code&gt; item to make it match more than just the exact match:</source>
          <target state="translated">There are several modifiers that can be put at the end of a non-star &lt;code&gt;lquery&lt;/code&gt; item to make it match more than just the exact match:</target>
        </trans-unit>
        <trans-unit id="9e6c3965c75b70506035e1130db0d24734cc5245" translate="yes" xml:space="preserve">
          <source>There are several modifiers that can be put at the end of a non-star label in &lt;code&gt;lquery&lt;/code&gt; to make it match more than just the exact match:</source>
          <target state="translated">&lt;code&gt;lquery&lt;/code&gt; 에서 별표가 아닌 레이블의 끝에 배치 하여 정확히 일치하는 것 이상을 일치 시킬 수있는 몇 가지 수정자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c65cdf0a50b535370cafd7a5d8814b1949feb7fa" translate="yes" xml:space="preserve">
          <source>There are several password-based authentication methods. These methods operate similarly but differ in how the users' passwords are stored on the server and how the password provided by a client is sent across the connection.</source>
          <target state="translated">몇 가지 비밀번호 기반 인증 방법이 있습니다. 이러한 방법은 비슷하게 작동하지만 사용자 암호가 서버에 저장되는 방식과 클라이언트가 제공 한 암호가 연결을 통해 전송되는 방식이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="82697895b0fc3864eed5346e0a502ff9ce90f8b6" translate="yes" xml:space="preserve">
          <source>There are several possible values of &lt;code&gt;context&lt;/code&gt;. In order of decreasing difficulty of changing the setting, they are:</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; 의 몇 가지 가능한 값이 있습니다. 설정 변경의 어려움을 줄이려면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="412101ab8ec853191b9bda2fa3098ca1192d7103" translate="yes" xml:space="preserve">
          <source>There are several reasons why one might want to use schemas:</source>
          <target state="translated">스키마를 사용하려는 몇 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="47ec670ad87a5a65f5d73f50b758515c8d78f032" translate="yes" xml:space="preserve">
          <source>There are several settings which can cause the query planner not to generate a parallel query plan under any circumstances. In order for any parallel query plans whatsoever to be generated, the following settings must be configured as indicated.</source>
          <target state="translated">쿼리 플래너가 어떤 상황에서도 병렬 쿼리 계획을 생성하지 못하게하는 몇 가지 설정이 있습니다. 병렬 쿼리 계획을 생성하기 위해 다음 설정을 표시된대로 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a490c0d4b72a8988d006fa28baad623b333c2c3" translate="yes" xml:space="preserve">
          <source>There are several ways around this problem. One simple answer is to use &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; in sub-&lt;code&gt;SELECT&lt;/code&gt;s in row security policies. However, that requires granting &lt;code&gt;UPDATE&lt;/code&gt; privilege on the referenced table (here &lt;code&gt;users&lt;/code&gt;) to the affected users, which might be undesirable. (But another row security policy could be applied to prevent them from actually exercising that privilege; or the sub-&lt;code&gt;SELECT&lt;/code&gt; could be embedded into a security definer function.) Also, heavy concurrent use of row share locks on the referenced table could pose a performance problem, especially if updates of it are frequent. Another solution, practical if updates of the referenced table are infrequent, is to take an exclusive lock on the referenced table when updating it, so that no concurrent transactions could be examining old row values. Or one could just wait for all concurrent transactions to end after committing an update of the referenced table and before making changes that rely on the new security situation.</source>
          <target state="translated">이 문제를 해결하는 데는 몇 가지 방법이 있습니다. 한 가지 간단한 대답은 행 보안 정책의 하위 &lt;code&gt;SELECT&lt;/code&gt; 에서 &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; 를 사용하는 것입니다 . 그러나 영향을받는 사용자 &lt;code&gt;users&lt;/code&gt; 참조 된 테이블 (여기서는 users ) 에 대한 &lt;code&gt;UPDATE&lt;/code&gt; 권한을 부여해야 하므로 바람직하지 않습니다. 그러나 다른 행 보안 정책을 적용하여 실제로 해당 권한을 행사하지 못하도록하거나 하위 &lt;code&gt;SELECT&lt;/code&gt; 참조 된 테이블에서 행 공유 잠금을 많이 동시에 사용하면 특히 업데이트가 자주 발생하는 경우 성능 문제가 발생할 수 있습니다. 참조 된 테이블의 업데이트가 드문 경우에 실용적인 또 다른 솔루션은 업데이트 할 때 참조 된 테이블에 대해 독점 잠금을 수행하여 동시 트랜잭션이 이전 행 값을 검사 할 수 없도록하는 것입니다. 또는 참조 된 테이블의 업데이트를 커밋 한 후 새로운 보안 상황에 따라 변경을 수행하기 전에 모든 동시 트랜잭션이 종료 될 때까지 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78c41a8baf3f45e2e246f13ef8df748fedf21ff4" translate="yes" xml:space="preserve">
          <source>There are several ways to shut down the database server. Under the hood, they all reduce to sending a signal to the supervisor &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">There are several ways to shut down the database server. Under the hood, they all reduce to sending a signal to the supervisor &lt;code&gt;postgres&lt;/code&gt; process.</target>
        </trans-unit>
        <trans-unit id="0a65d46642b8ea0d625c08a9a29af3d8886f49e2" translate="yes" xml:space="preserve">
          <source>There are several ways to shut down the database server. You control the type of shutdown by sending different signals to the master &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">데이터베이스 서버를 종료하는 방법에는 여러 가지가 있습니다. 마스터 &lt;code&gt;postgres&lt;/code&gt; 프로세스에 다른 신호를 보내 종료 유형을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="f2aaff5fcb38efacb1d58514b7509e951bb1187c" translate="yes" xml:space="preserve">
          <source>There are some basic assumptions that a btree operator family must satisfy:</source>
          <target state="translated">btree 운영자 제품군이 충족해야하는 몇 가지 기본 가정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b521cdf532a9a953ad42c30cbfbc097cf6b1b08" translate="yes" xml:space="preserve">
          <source>There are three available prewarming methods. &lt;code&gt;prefetch&lt;/code&gt; issues asynchronous prefetch requests to the operating system, if this is supported, or throws an error otherwise. &lt;code&gt;read&lt;/code&gt; reads the requested range of blocks; unlike &lt;code&gt;prefetch&lt;/code&gt;, this is synchronous and supported on all platforms and builds, but may be slower. &lt;code&gt;buffer&lt;/code&gt; reads the requested range of blocks into the database buffer cache.</source>
          <target state="translated">사전 예열 방법에는 세 가지가 있습니다. &lt;code&gt;prefetch&lt;/code&gt; 는 지원되는 경우 운영 체제에 비동기 프리 페치 요청을 발행하거나 그렇지 않으면 오류를 발생시킵니다. &lt;code&gt;read&lt;/code&gt; 는 요청 된 블록 범위를 읽습니다. &lt;code&gt;prefetch&lt;/code&gt; 와 달리 , 이것은 모든 플랫폼 및 빌드에서 동기식이며 지원되지만 느려질 수 있습니다. &lt;code&gt;buffer&lt;/code&gt; 는 요청 된 블록 범위를 데이터베이스 버퍼 캐시로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cb805126a31ff8c55ee475c5fbc01109be8dd511" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;em&gt;implicitly-typed constants&lt;/em&gt; in PostgreSQL: strings, bit strings, and numbers. Constants can also be specified with explicit types, which can enable more accurate representation and more efficient handling by the system. These alternatives are discussed in the following subsections.</source>
          <target state="translated">PostgreSQL 에는 3 가지 종류의 &lt;em&gt;암시 적 유형 상수&lt;/em&gt; 가 있습니다 : 문자열, 비트 문자열 및 숫자. 상수는 명시 적 유형으로도 지정할 수 있으므로 시스템에서보다 정확한 표현과보다 효율적인 처리가 가능합니다. 이러한 대안은 다음 하위 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="30766d90eb25e2981c2e600b788f88cc0665cda4" translate="yes" xml:space="preserve">
          <source>There are three possible syntaxes for an operator invocation:</source>
          <target state="translated">연산자 호출에 대한 세 가지 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac1c9045fce554fb04868e602b7a9908c87947d" translate="yes" xml:space="preserve">
          <source>There are three separate approaches to pattern matching provided by PostgreSQL: the traditional SQL &lt;code&gt;LIKE&lt;/code&gt; operator, the more recent &lt;code&gt;SIMILAR TO&lt;/code&gt; operator (added in SQL:1999), and POSIX-style regular expressions. Aside from the basic &amp;ldquo;does this string match this pattern?&amp;rdquo; operators, functions are available to extract or replace matching substrings and to split a string at matching locations.</source>
          <target state="translated">PostgreSQL에서 제공하는 패턴 일치에 대한 세 가지 별도의 접근 방식이 있습니다 : 전통적인 SQL &lt;code&gt;LIKE&lt;/code&gt; 연산자, 최신 &lt;code&gt;SIMILAR TO&lt;/code&gt; 연산자 (SQL : 1999에 추가됨) 및 POSIX 스타일 정규식입니다. 기본 &quot;이 문자열이이 패턴과 일치합니까?&quot; 연산자, 함수는 일치하는 부분 문자열을 추출 또는 교체하고 일치하는 위치에서 문자열을 분할하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c74bdd55156d3b2783c8a6fd237fe0bceb9cfeef" translate="yes" xml:space="preserve">
          <source>There are two approaches to enforce that users provide a certificate during login.</source>
          <target state="translated">사용자가 로그인 중에 인증서를 제공하도록하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="03a8c876ced91bb81f55235d3d3af76552bcc675" translate="yes" xml:space="preserve">
          <source>There are two categories of limitation to keep in mind: the restriction from XQuery to XPath for the functions specified in the SQL standard, and the restriction of XPath to version 1.0 for both the standard and the PostgreSQL-specific functions.</source>
          <target state="translated">명심해야 할 제한 범주는 SQL 표준에 지정된 함수에 대한 XQuery에서 XPath 로의 제한과 표준 및 PostgreSQL 관련 함수 모두에 대해 XPath를 버전 1.0으로 제한하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="45979291689bf78b7c41886076f2033f33bb0dc2" translate="yes" xml:space="preserve">
          <source>There are two columns containing the city name. This is correct because the lists of columns from the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables are concatenated. In practice this is undesirable, though, so you will probably want to list the output columns explicitly rather than using &lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">도시 이름을 포함하는 두 개의 열이 있습니다. &lt;code&gt;weather&lt;/code&gt; 및 &lt;code&gt;cities&lt;/code&gt; 테이블 의 열 목록 이 연결 되어 있기 때문에 올바른 것 입니다. 실제로 이것은 바람직하지 않으므로 &lt;code&gt;*&lt;/code&gt; : 대신 출력 열을 명시 적으로 나열하고 싶을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="65ab8b09fb62c8b1237a292bc36db36c5b33b77b" translate="yes" xml:space="preserve">
          <source>There are two commonly used internal WAL functions: &lt;code&gt;XLogInsertRecord&lt;/code&gt; and &lt;code&gt;XLogFlush&lt;/code&gt;. &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used to place a new record into the WAL buffers in shared memory. If there is no space for the new record, &lt;code&gt;XLogInsertRecord&lt;/code&gt; will have to write (move to kernel cache) a few filled WAL buffers. This is undesirable because &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used on every database low level modification (for example, row insertion) at a time when an exclusive lock is held on affected data pages, so the operation needs to be as fast as possible. What is worse, writing WAL buffers might also force the creation of a new log segment, which takes even more time. Normally, WAL buffers should be written and flushed by an &lt;code&gt;XLogFlush&lt;/code&gt; request, which is made, for the most part, at transaction commit time to ensure that transaction records are flushed to permanent storage. On systems with high log output, &lt;code&gt;XLogFlush&lt;/code&gt; requests might not occur often enough to prevent &lt;code&gt;XLogInsertRecord&lt;/code&gt; from having to do writes. On such systems one should increase the number of WAL buffers by modifying the &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; parameter. When &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is set and the system is very busy, setting &lt;code&gt;wal_buffers&lt;/code&gt; higher will help smooth response times during the period immediately following each checkpoint.</source>
          <target state="translated">일반적으로 사용되는 내부 WAL 함수에는 &lt;code&gt;XLogInsertRecord&lt;/code&gt; 및 &lt;code&gt;XLogFlush&lt;/code&gt; 가 있습니다. &lt;code&gt;XLogInsertRecord&lt;/code&gt; 는 공유 메모리의 WAL 버퍼에 새 레코드를 배치하는 데 사용됩니다. 새 레코드를위한 공간이 없으면 &lt;code&gt;XLogInsertRecord&lt;/code&gt; 는 채워진 WAL 버퍼 몇 개를 작성 (커널 캐시로 이동)해야합니다. &lt;code&gt;XLogInsertRecord&lt;/code&gt; 는 영향을받는 데이터 페이지에서 독점 잠금이 유지되는 시간에 모든 데이터베이스 하위 레벨 수정 (예 : 행 삽입)에 사용 되므로 작업 이 최대한 빨라야 하므로 바람직하지 않습니다 . 더 나쁜 것은 WAL 버퍼를 작성하면 새 로그 세그먼트를 작성해야하는데 훨씬 더 많은 시간이 걸립니다. 일반적으로 WAL 버퍼는 &lt;code&gt;XLogFlush&lt;/code&gt; 요청은 대부분 트랜잭션 커밋 시간에 이루어지며 트랜잭션 레코드가 영구 저장소로 플러시되도록합니다. 로그 출력이 높은 시스템에서 &lt;code&gt;XLogFlush&lt;/code&gt; 요청이 자주 발생하지 &lt;code&gt;XLogInsertRecord&lt;/code&gt; 가 쓰기를 수행하지 못할 수 있습니다 . 이러한 시스템에서는 &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; 매개 변수 를 수정하여 WAL 버퍼 수를 늘려야합니다 . 때 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes이&lt;/a&gt; 설정 시스템 설정, 매우 바쁜입니다 &lt;code&gt;wal_buffers&lt;/code&gt; 을 즉시 각 체크 포인트 다음 기간 동안 부드러운 응답 시간을 도움이 될 것입니다 높은.</target>
        </trans-unit>
        <trans-unit id="1612227459001e258e7447e0effe46078acfe3e4" translate="yes" xml:space="preserve">
          <source>There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than &lt;code&gt;NULL&lt;/code&gt; when the input string is of zero length. Second, if the delimiter string is &lt;code&gt;NULL&lt;/code&gt;, the function splits the input into individual characters, rather than returning &lt;code&gt;NULL&lt;/code&gt; as before.</source>
          <target state="translated">There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than &lt;code&gt;NULL&lt;/code&gt; when the input string is of zero length. Second, if the delimiter string is &lt;code&gt;NULL&lt;/code&gt; , the function splits the input into individual characters, rather than returning &lt;code&gt;NULL&lt;/code&gt; as before.</target>
        </trans-unit>
        <trans-unit id="e556036ec4c364c079311c21d04103cf4c7118b6" translate="yes" xml:space="preserve">
          <source>There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than NULL when the input string is of zero length. Second, if the delimiter string is NULL, the function splits the input into individual characters, rather than returning NULL as before.</source>
          <target state="translated">9.1 이전 버전의 PostgreSQL 과 &lt;code&gt;string_to_array&lt;/code&gt; 의 동작에는 두 가지 차이점이 있습니다 . 먼저 입력 문자열의 길이가 0 인 경우 NULL이 아닌 빈 (0 요소) 배열을 반환합니다. 둘째, 분리 문자열이 NULL 인 경우 함수는 이전과 같이 NULL을 리턴하지 않고 입력을 개별 문자로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="9a38ac647b826e47337bf978dbd260eda2d37e47" translate="yes" xml:space="preserve">
          <source>There are two forms of the &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command. In the first form, the user supplies just the name of the desired language, and the PostgreSQL server consults the &lt;a href=&quot;catalog-pg-pltemplate&quot;&gt;&lt;code&gt;pg_pltemplate&lt;/code&gt;&lt;/a&gt; system catalog to determine the correct parameters. In the second form, the user supplies the language parameters along with the language name. The second form can be used to create a language that is not defined in &lt;code&gt;pg_pltemplate&lt;/code&gt;, but this approach is considered obsolescent.</source>
          <target state="translated">&lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 명령 에는 두 가지 형식이 있습니다 . 첫 번째 형식에서 사용자는 원하는 언어의 이름 만 제공하고 PostgreSQL 서버는 &lt;a href=&quot;catalog-pg-pltemplate&quot;&gt; &lt;code&gt;pg_pltemplate&lt;/code&gt; &lt;/a&gt; 시스템 카탈로그를 참조하여 올바른 매개 변수를 결정합니다. 두 번째 형태에서, 사용자는 언어 이름과 함께 언어 매개 변수를 제공합니다. 두 번째 형식은 &lt;code&gt;pg_pltemplate&lt;/code&gt; 에 정의되지 않은 언어를 만드는 데 사용할 수 있지만이 방법은 사용 되지 않는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f9cc8590527e484357685c3a4d915bc501e931e5" translate="yes" xml:space="preserve">
          <source>There are two kinds of indexes that can be used to speed up full text searches. Note that indexes are not mandatory for full text searching, but in cases where a column is searched on a regular basis, an index is usually desirable.</source>
          <target state="translated">전체 텍스트 검색 속도를 높이는 데 사용할 수있는 두 가지 종류의 색인이 있습니다. 전체 텍스트 검색에는 인덱스가 필수는 아니지만 열을 정기적으로 검색하는 경우에는 인덱스가 일반적으로 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="0b78b765f97cf8944029e53f4ab00dc6de355959" translate="yes" xml:space="preserve">
          <source>There are two methods that an operator class for GIN must provide:</source>
          <target state="translated">GIN의 연산자 클래스가 제공해야하는 두 가지 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ebcfbeecc8c9e28432149890e115326d408ee9d" translate="yes" xml:space="preserve">
          <source>There are two other fixed-length character types in PostgreSQL, shown in &lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;Table 8.5&lt;/a&gt;. The &lt;code&gt;name&lt;/code&gt; type exists &lt;em&gt;only&lt;/em&gt; for the storage of identifiers in the internal system catalogs and is not intended for use by the general user. Its length is currently defined as 64 bytes (63 usable characters plus terminator) but should be referenced using the constant &lt;code&gt;NAMEDATALEN&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; source code. The length is set at compile time (and is therefore adjustable for special uses); the default maximum length might change in a future release. The type &lt;code&gt;&quot;char&quot;&lt;/code&gt; (note the quotes) is different from &lt;code&gt;char(1)&lt;/code&gt; in that it only uses one byte of storage. It is internally used in the system catalogs as a simplistic enumeration type.</source>
          <target state="translated">PostgreSQL에는 다른 고정 길이 문자 유형이 두 가지 있습니다 ( &lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;표 8.5 참조)&lt;/a&gt; . &lt;code&gt;name&lt;/code&gt; 종류 존재 &lt;em&gt;만&lt;/em&gt; 내부 시스템 카탈로그의 식별자를 저장하기 위해 일반 유저가 사용할 수 없습니다. 길이는 현재 64 바이트 (63 개의 사용 가능한 문자와 종결 자)로 정의되어 있지만 &lt;code&gt;C&lt;/code&gt; 소스 코드 에서 상수 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 을 사용하여 참조해야합니다 . 길이는 컴파일 타임에 설정되므로 특수 용도로 조정할 수 있습니다. 기본 최대 길이는 다음 릴리스에서 변경 될 수 있습니다. &lt;code&gt;&quot;char&quot;&lt;/code&gt; 유형 (따옴표 인용)은 &lt;code&gt;char(1)&lt;/code&gt; 과 다릅니다.스토리지는 1 바이트 만 사용한다는 점에서 내부적으로 시스템 카탈로그에서 단순한 열거 유형으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a65ab8661e9c6e6250372b71f3e4d52aadd8690" translate="yes" xml:space="preserve">
          <source>There are two restrictions, however, which make this method impractical, or at least inferior to the pg_dump method:</source>
          <target state="translated">그러나이 방법이 실용적이지 않거나 pg_dump 방법보다 열등한 두 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb559c725c45849ac1890ba81d8ba70c6affbb84" translate="yes" xml:space="preserve">
          <source>There are two significant ways in which run times measured by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can deviate from normal execution of the same query. First, since no output rows are delivered to the client, network transmission costs and I/O conversion costs are not included. Second, the measurement overhead added by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can be significant, especially on machines with slow &lt;code&gt;gettimeofday()&lt;/code&gt; operating-system calls. You can use the &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; tool to measure the overhead of timing on your system.</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 로 측정 한 런타임 이 동일한 쿼리의 정상적인 실행에서 벗어날 수 있는 두 가지 중요한 방법이 있습니다. 첫째, 출력 행이 클라이언트에 전달되지 않기 때문에 네트워크 전송 비용과 I / O 변환 비용이 포함되지 않습니다. 둘째, &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 에 의해 추가 된 측정 오버 헤드는 특히 &lt;code&gt;gettimeofday()&lt;/code&gt; 운영 체제 호출 이 느린 시스템에서 중요 할 수 있습니다 . &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; 도구를 사용 하여 시스템의 타이밍 오버 헤드를 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4b4937b46d88bd048aae10c82ed3779adc47d2b" translate="yes" xml:space="preserve">
          <source>There are two special cases of bracket expressions: the bracket expressions &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an &lt;code&gt;alnum&lt;/code&gt; character (as defined by the POSIX character class described above) or an underscore. This is an extension, compatible with but not specified by POSIX 1003.2, and should be used with caution in software intended to be portable to other systems. The constraint escapes described below are usually preferable; they are no more standard, but are easier to type.</source>
          <target state="translated">대괄호 식에는 두 가지 특수한 경우가 있습니다. 대괄호 식 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; 및 &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; 은 각각 단어의 시작과 끝에 빈 문자열과 일치하는 제약 조건입니다. 단어는 단어 문자가 앞에 오지 않고 뒤에 오는 일련의 단어 문자로 정의됩니다. 단어 문자는 &lt;code&gt;alnum&lt;/code&gt; 문자 (위에서 설명한 POSIX 문자 클래스에 정의 된대로) 또는 밑줄입니다. 이것은 POSIX 1003.2와 호환되지만 지정되지 않은 확장이며 다른 시스템에 이식 할 수있는 소프트웨어에서주의해서 사용해야합니다. 아래 설명 된 제한 이스케이프가 일반적으로 바람직합니다. 더 이상 표준은 아니지만 입력하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="33967632431b8aaf7d1ba8660310b5c4fbf05d2a" translate="yes" xml:space="preserve">
          <source>There are two variants of &lt;code&gt;VACUUM&lt;/code&gt;: standard &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;VACUUM FULL&lt;/code&gt;. &lt;code&gt;VACUUM FULL&lt;/code&gt; can reclaim more disk space but runs much more slowly. Also, the standard form of &lt;code&gt;VACUUM&lt;/code&gt; can run in parallel with production database operations. (Commands such as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; will continue to function normally, though you will not be able to modify the definition of a table with commands such as &lt;code&gt;ALTER TABLE&lt;/code&gt; while it is being vacuumed.) &lt;code&gt;VACUUM FULL&lt;/code&gt; requires exclusive lock on the table it is working on, and therefore cannot be done in parallel with other use of the table. Generally, therefore, administrators should strive to use standard &lt;code&gt;VACUUM&lt;/code&gt; and avoid &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 에는 표준 &lt;code&gt;VACUUM&lt;/code&gt; 과 &lt;code&gt;VACUUM FULL&lt;/code&gt; 의 두 가지 변형이 있습니다 . &lt;code&gt;VACUUM FULL&lt;/code&gt; 은 더 많은 디스크 공간을 회수 할 수 있지만 훨씬 느리게 실행됩니다. 또한 표준 형식의 &lt;code&gt;VACUUM&lt;/code&gt; 은 프로덕션 데이터베이스 작업과 동시에 실행될 수 있습니다. ( 진공되는 동안 &lt;code&gt;ALTER TABLE&lt;/code&gt; 과 같은 명령으로 테이블 정의를 수정할 수는 없지만 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 와 같은 명령 은 계속 정상적으로 작동합니다 .) &lt;code&gt;VACUUM FULL&lt;/code&gt; 작업중인 테이블에 독점 잠금이 필요하므로 다른 테이블 사용과 동시에 수행 할 수 없습니다. 따라서 일반적으로 관리자는 표준 &lt;code&gt;VACUUM&lt;/code&gt; 을 사용 하고 &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 피하기 위해 노력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="082cbad2612b1a539364141256cd8c079fbdd04c" translate="yes" xml:space="preserve">
          <source>There are two ways to acquire an advisory lock in PostgreSQL: at session level or at transaction level. Once acquired at session level, an advisory lock is held until explicitly released or the session ends. Unlike standard lock requests, session-level advisory lock requests do not honor transaction semantics: a lock acquired during a transaction that is later rolled back will still be held following the rollback, and likewise an unlock is effective even if the calling transaction fails later. A lock can be acquired multiple times by its owning process; for each completed lock request there must be a corresponding unlock request before the lock is actually released. Transaction-level lock requests, on the other hand, behave more like regular lock requests: they are automatically released at the end of the transaction, and there is no explicit unlock operation. This behavior is often more convenient than the session-level behavior for short-term usage of an advisory lock. Session-level and transaction-level lock requests for the same advisory lock identifier will block each other in the expected way. If a session already holds a given advisory lock, additional requests by it will always succeed, even if other sessions are awaiting the lock; this statement is true regardless of whether the existing lock hold and new request are at session level or transaction level.</source>
          <target state="translated">PostgreSQL에서 자문 잠금을 얻는 방법에는 세션 수준 또는 트랜잭션 수준의 두 가지가 있습니다. 세션 수준에서 획득 한 후에는 명시 적으로 해제되거나 세션이 종료 될 때까지 권고 잠금이 유지됩니다. 표준 잠금 요청과 달리 세션 수준 권고 잠금 요청은 트랜잭션 시맨틱을 존중하지 않습니다. 나중에 롤백 된 트랜잭션 중에 획득 한 잠금은 롤백 후에도 유지되며 나중에 호출 트랜잭션이 실패하더라도 잠금 해제가 적용됩니다. 잠금은 소유 프로세스에 의해 여러 번 획득 할 수 있습니다. 완료된 각 잠금 요청에 대해 잠금이 실제로 해제되기 전에 해당 잠금 해제 요청이 있어야합니다. 반면에 거래 수준 잠금 요청은 일반 잠금 요청과 비슷하게 작동합니다. 트랜잭션이 끝나면 자동으로 해제됩니다.명시적인 잠금 해제 작업이 없습니다. 이 동작은 종종 자문 잠금을 단기적으로 사용하기 위해 세션 수준 동작보다 더 편리합니다. 동일한 권고 잠금 ID에 대한 세션 레벨 및 트랜잭션 레벨 잠금 요청은 예상 된 방식으로 서로를 차단합니다. 세션에 지정된 권고 잠금이 이미 있으면 다른 세션이 잠금을 기다리고 있더라도 추가 요청이 항상 성공합니다. 기존 잠금 보류 및 새 요청이 세션 레벨인지 트랜잭션 레벨인지에 관계없이이 명령문은 적용됩니다.세션에 지정된 권고 잠금이 이미 있으면 다른 세션이 잠금을 기다리고 있더라도 추가 요청이 항상 성공합니다. 기존 잠금 보류 및 새 요청이 세션 레벨인지 트랜잭션 레벨인지에 관계없이이 명령문은 적용됩니다.세션에 지정된 권고 잠금이 이미 있으면 다른 세션이 잠금을 기다리고 있더라도 추가 요청이 항상 성공합니다. 기존 잠금 보류 및 새 요청이 세션 레벨인지 트랜잭션 레벨인지에 관계없이이 명령문은 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d918b8ea922c6c6ee662eb9ab4cebb7da36eb443" translate="yes" xml:space="preserve">
          <source>There are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.</source>
          <target state="translated">제약 조건을 정의하는 방법에는 테이블 제약 조건과 열 제약 조건이 있습니다. 열 제약 조건은 열 정의의 일부로 정의됩니다. 테이블 제약 조건 정의는 특정 열에 연결되지 않으며 둘 이상의 열을 포함 할 수 있습니다. 모든 열 제약 조건은 테이블 제약 조건으로 작성할 수도 있습니다. 열 제약 조건은 제약 조건이 하나의 열에 만 영향을 줄 때 사용하기에 편리한 표기법입니다.</target>
        </trans-unit>
        <trans-unit id="3100ad6baa7faf64044c5fff315dddab6008581f" translate="yes" xml:space="preserve">
          <source>There are two ways to delete rows in a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;USING&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="translated">데이터베이스의 다른 테이블에 포함 된 정보를 사용하여 테이블에서 행을 삭제하는 방법은 두 가지가 있습니다. 하위 선택 사용 또는 &lt;code&gt;USING&lt;/code&gt; 절 에서 추가 테이블 지정 . 어떤 기술이 더 적합한 지 특정 상황에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9d2cb602ac946da832fb98a751bc210a74312a33" translate="yes" xml:space="preserve">
          <source>There are two ways to modify a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;FROM&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="translated">데이터베이스의 다른 테이블에 포함 된 정보를 사용하여 테이블을 수정하는 방법에는 두 가지가 있습니다. 하위 선택 사용 또는 &lt;code&gt;FROM&lt;/code&gt; 절 에 추가 테이블 지정 . 어떤 기술이 더 적합한 지 특정 상황에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="aa2e4ae09129d50722332a9a349176e58b93478a" translate="yes" xml:space="preserve">
          <source>There are various shortcut commands for &lt;code&gt;\pset&lt;/code&gt;. See &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\T&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; 대한 다양한 바로 가기 명령이 있습니다 . 참조 &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\C&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , &lt;code&gt;\T&lt;/code&gt; , 및 &lt;code&gt;\x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36d44242f8d38cae700147e3f10ad23b2c1671f8" translate="yes" xml:space="preserve">
          <source>There are various special syntax rules and behaviors associated with composite types in queries. These rules provide useful shortcuts, but can be confusing if you don't know the logic behind them.</source>
          <target state="translated">쿼리의 복합 유형과 관련된 다양한 특수 구문 규칙 및 동작이 있습니다. 이러한 규칙은 유용한 지름길을 제공하지만 그 뒤에있는 논리를 모르면 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adeaa568e81b8c22d184926d9648a6a85b174068" translate="yes" xml:space="preserve">
          <source>There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt;s running at the same time, but it is better from a performance point of view to take only one backup, and copy the result.</source>
          <target state="translated">동시에 여러 개의 &lt;code&gt;pg_basebackup&lt;/code&gt; 이 실행될 수 있지만 성능 관점에서 하나의 백업 만 수행하고 결과를 복사하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="20d4685d4d3e4d67053c5be3bcdf1498541d87e6" translate="yes" xml:space="preserve">
          <source>There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt;s running at the same time, but it is usually better from a performance point of view to take only one backup, and copy the result.</source>
          <target state="translated">There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt; s running at the same time, but it is usually better from a performance point of view to take only one backup, and copy the result.</target>
        </trans-unit>
        <trans-unit id="241118165bea21fbe830bef68a27cbb0152bef40" translate="yes" xml:space="preserve">
          <source>There is a &amp;ldquo;simple&amp;rdquo; form of &lt;code&gt;CASE&lt;/code&gt; expression that is a variant of the general form above:</source>
          <target state="translated">위의 일반적인 형태의 변형 인 &amp;ldquo;간단한&amp;rdquo;형태의 &lt;code&gt;CASE&lt;/code&gt; 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a329b25f5c93a21ac5ea836673c784c6afc768a" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;CREATE COLLATION&lt;/code&gt; statement in the SQL standard, but it is limited to copying an existing collation. The syntax to create a new collation is a PostgreSQL extension.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE COLLATION&lt;/code&gt; 문이 있지만 기존 데이터 정렬 복사로 제한됩니다. 새로운 데이터 정렬을 생성하는 구문은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="74c08b98f45942b4395776e7da22b84f7266e5c2" translate="yes" xml:space="preserve">
          <source>There is a catch if you try to use conditional rules for complex view updates: there &lt;em&gt;must&lt;/em&gt; be an unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rule for each action you wish to allow on the view. If the rule is conditional, or is not &lt;code&gt;INSTEAD&lt;/code&gt;, then the system will still reject attempts to perform the update action, because it thinks it might end up trying to perform the action on the dummy table of the view in some cases. If you want to handle all the useful cases in conditional rules, add an unconditional &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; rule to ensure that the system understands it will never be called on to update the dummy table. Then make the conditional rules non-&lt;code&gt;INSTEAD&lt;/code&gt;; in the cases where they are applied, they add to the default &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; action. (This method does not currently work to support &lt;code&gt;RETURNING&lt;/code&gt; queries, however.)</source>
          <target state="translated">복잡한 뷰 업데이트에 조건부 규칙을 사용하려고하면 캐치 가 있습니다. 뷰에서 허용하려는 각 작업마다 무조건 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙 이 &lt;em&gt;있어야합니다&lt;/em&gt; . 규칙이 조건부이거나 &lt;code&gt;INSTEAD&lt;/code&gt; 가 아닌 경우 시스템은 일부 경우보기의 더미 테이블에서 조치를 수행하려고 시도 할 수 있다고 생각하기 때문에 업데이트 조치를 수행하려는 시도를 여전히 거부합니다. 조건부 규칙에서 모든 유용한 사례를 처리하려면 무조건 &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; 규칙을 추가 하여 시스템이 더미 테이블을 업데이트하기 위해 호출되지 않음을 이해하도록하십시오. 그런 다음 조건부 규칙을 &lt;code&gt;INSTEAD&lt;/code&gt; 가 아닌 것으로 만드십시오 . 적용되는 경우 기본값에 추가됩니다. &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; 행동. 그러나이 방법은 현재 &lt;code&gt;RETURNING&lt;/code&gt; 쿼리 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c21f127ac29ffa6b6d6cad86ad16cb8ebd82f4c7" translate="yes" xml:space="preserve">
          <source>There is a limit on how many columns a table can contain. Depending on the column types, it is between 250 and 1600. However, defining a table with anywhere near this many columns is highly unusual and often a questionable design.</source>
          <target state="translated">테이블에 포함 할 수있는 열 수에는 제한이 있습니다. 열 유형에 따라 250에서 1600 사이입니다. 그러나이 많은 열 근처에 테이블을 정의하는 것은 매우 이례적이며 종종 의심스러운 디자인입니다.</target>
        </trans-unit>
        <trans-unit id="60f67c0e3cf6c026c3a97cec11f99b88526b93a6" translate="yes" xml:space="preserve">
          <source>There is a more general version of the FOLLOWED BY operator having the form &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer standing for the difference between the positions of the matching lexemes. &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; is the same as &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, while &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; allows exactly one other lexeme to appear between the matches, and so on. The &lt;code&gt;phraseto_tsquery&lt;/code&gt; function makes use of this operator to construct a &lt;code&gt;tsquery&lt;/code&gt; that can match a multi-word phrase when some of the words are stop words. For example:</source>
          <target state="translated">&lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 형식의보다 일반적인 버전의 FOLLOWED BY 연산자가 있습니다. 여기서 &lt;code&gt;N&lt;/code&gt; 은 일치하는 렉서스의 위치 간 차이를 나타내는 정수입니다. &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 와 동일 하지만 &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; 는 일치하는 사이에 정확히 하나의 다른 lexeme이 나타나는 것을 허용합니다. &lt;code&gt;phraseto_tsquery&lt;/code&gt; 의 기능 차종은 구성이 연산자의 사용 &lt;code&gt;tsquery&lt;/code&gt; 단어의 일부가 정지 단어 때 여러 단어 구문을 일치시킬 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98845715e9aff2aab5a7e45eba23b610067562bc" translate="yes" xml:space="preserve">
          <source>There is a possibility that a concurrent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; on the row being moved will get a serialization failure error. Suppose session 1 is performing an &lt;code&gt;UPDATE&lt;/code&gt; on a partition key, and meanwhile a concurrent session 2 for which this row is visible performs an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operation on this row. In such case, session 2's &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; will detect the row movement and raise a serialization failure error (which always returns with an SQLSTATE code '40001'). Applications may wish to retry the transaction if this occurs. In the usual case where the table is not partitioned, or where there is no row movement, session 2 would have identified the newly updated row and carried out the &lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt; on this new row version.</source>
          <target state="translated">이동중인 행에서 동시 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 가 직렬화 실패 오류를 발생시킬 수 있습니다. 가정하자 세션 1은 수행 &lt;code&gt;UPDATE&lt;/code&gt; 를 분할 키, 및 그 사이에 동시 세션 2는이 행은 표시 행하는 것이다 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 이 행의 동작. 이 경우 세션 2의 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 행 이동을 감지하고 직렬화 실패 오류를 발생시킵니다 (항상 SQLSTATE 코드 '40001'과 함께 리턴 됨). 이 경우 응용 프로그램은 트랜잭션을 재 시도 할 수 있습니다. 테이블이 분할되지 않았거나 행 이동이없는 일반적인 경우 세션 2는 새로 업데이트 된 행을 식별 하고이 새 행 버전 에서 &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; 를 수행했을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e2fb3023d52c67871f97870f963ae3e2511e1afd" translate="yes" xml:space="preserve">
          <source>There is a queue that holds notifications that have been sent but not yet processed by all listening sessions. If this queue becomes full, transactions calling &lt;code&gt;NOTIFY&lt;/code&gt; will fail at commit. The queue is quite large (8GB in a standard installation) and should be sufficiently sized for almost every use case. However, no cleanup can take place if a session executes &lt;code&gt;LISTEN&lt;/code&gt; and then enters a transaction for a very long time. Once the queue is half full you will see warnings in the log file pointing you to the session that is preventing cleanup. In this case you should make sure that this session ends its current transaction so that cleanup can proceed.</source>
          <target state="translated">전송되었지만 아직 모든 청취 세션에서 처리하지 않은 알림을 보유하는 큐가 있습니다. 이 큐가 가득 차면 &lt;code&gt;NOTIFY&lt;/code&gt; 를 호출하는 트랜잭션 은 커밋시 실패합니다. 대기열은 상당히 크며 (표준 설치에서는 8GB) 거의 모든 사용 사례에 적합한 크기 여야합니다. 그러나 세션이 &lt;code&gt;LISTEN&lt;/code&gt; 을 실행 한 다음 매우 오랫동안 트랜잭션을 입력 하면 정리를 수행 할 수 없습니다 . 큐가 반만 가득 차면 로그 파일에 정리를 방해하는 세션을 가리키는 경고가 표시됩니다. 이 경우 정리가 진행될 수 있도록이 세션이 현재 트랜잭션을 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6acd66eed300880ccbb1a71d22c7409bc533b1e" translate="yes" xml:space="preserve">
          <source>There is a race condition when first setting up a listening session: if concurrently-committing transactions are sending notify events, exactly which of those will the newly listening session receive? The answer is that the session will receive all events committed after an instant during the transaction's commit step. But that is slightly later than any database state that the transaction could have observed in queries. This leads to the following rule for using &lt;code&gt;LISTEN&lt;/code&gt;: first execute (and commit!) that command, then in a new transaction inspect the database state as needed by the application logic, then rely on notifications to find out about subsequent changes to the database state. The first few received notifications might refer to updates already observed in the initial database inspection, but this is usually harmless.</source>
          <target state="translated">There is a race condition when first setting up a listening session: if concurrently-committing transactions are sending notify events, exactly which of those will the newly listening session receive? The answer is that the session will receive all events committed after an instant during the transaction's commit step. But that is slightly later than any database state that the transaction could have observed in queries. This leads to the following rule for using &lt;code&gt;LISTEN&lt;/code&gt; : first execute (and commit!) that command, then in a new transaction inspect the database state as needed by the application logic, then rely on notifications to find out about subsequent changes to the database state. The first few received notifications might refer to updates already observed in the initial database inspection, but this is usually harmless.</target>
        </trans-unit>
        <trans-unit id="7f864b552f926f474ffeb07a0a68232c7a34815b" translate="yes" xml:space="preserve">
          <source>There is a second kind of identifier: the &lt;em&gt;delimited identifier&lt;/em&gt; or &lt;em&gt;quoted identifier&lt;/em&gt;. It is formed by enclosing an arbitrary sequence of characters in double-quotes (&lt;code&gt;&quot;&lt;/code&gt;). A delimited identifier is always an identifier, never a key word. So &lt;code&gt;&quot;select&quot;&lt;/code&gt; could be used to refer to a column or table named &amp;ldquo;select&amp;rdquo;, whereas an unquoted &lt;code&gt;select&lt;/code&gt; would be taken as a key word and would therefore provoke a parse error when used where a table or column name is expected. The example can be written with quoted identifiers like this:</source>
          <target state="translated">두 번째 종류의 식별자 인 &lt;em&gt;구분 식별자&lt;/em&gt; 또는 &lt;em&gt;인용 식별자가&lt;/em&gt; 있습니다. 임의의 문자 시퀀스를 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 로 묶어 구성합니다 . 구분 식별자는 항상 식별자이며 키워드는 아니므로 &lt;code&gt;&quot;select&quot;&lt;/code&gt; 는&quot;select &quot;라는 열 또는 테이블을 나타내는 데 사용할 수 있습니다. 인용되지 않은 &lt;code&gt;select&lt;/code&gt; 은 키워드로 간주되므로 테이블 또는 열 이름이 예상되는 경우 구문 분석 오류가 발생합니다. 예를 들어 다음과 같이 따옴표 붙은 식별자로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad93af24a4ac7faa267b7d3536c1e6d83e1bf68" translate="yes" xml:space="preserve">
          <source>There is a second standard system database named &lt;code&gt;template0&lt;/code&gt;. This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt;, that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt;, you can create a &amp;ldquo;pristine&amp;rdquo; user database (one where no user-defined objects exist and where the system objects have not been altered) that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt;. This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a pristine database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</source>
          <target state="translated">There is a second standard system database named &lt;code&gt;template0&lt;/code&gt; . This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt; , that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt; , you can create a &amp;ldquo;pristine&amp;rdquo; user database (one where no user-defined objects exist and where the system objects have not been altered) that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt; . This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a pristine database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</target>
        </trans-unit>
        <trans-unit id="99e2749bbb2f806b8f89c17d420b1dde22c11b68" translate="yes" xml:space="preserve">
          <source>There is a second standard system database named &lt;code&gt;template0&lt;/code&gt;. This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt;, that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt;, you can create a &amp;ldquo;virgin&amp;rdquo; user database that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt;. This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a virgin database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</source>
          <target state="translated">&lt;code&gt;template0&lt;/code&gt; 이라는 두 번째 표준 시스템 데이터베이스가 있습니다. 이 데이터베이스에는 &lt;code&gt;template1&lt;/code&gt; 의 초기 내용과 동일한 데이터 , 즉 PostgreSQL 버전으로 사전 정의 된 표준 객체 만 포함됩니다. 데이터베이스 클러스터가 초기화 된 후에는 &lt;code&gt;template0&lt;/code&gt; 을 변경해서는 안됩니다. 지시에 의해 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 복사 &lt;code&gt;template0&lt;/code&gt; 대신 &lt;code&gt;template1&lt;/code&gt; 를을 , 당신의 사이트 로컬 추가 하나도 포함하지 않는 &quot;처녀&quot;사용자 데이터베이스 생성 할 수 있습니다 &lt;code&gt;template1&lt;/code&gt; 를을 . 이것은 &lt;code&gt;pg_dump&lt;/code&gt; 를 복원 할 때 특히 편리합니다덤프 : 덤프 스크립트는 버진 데이터베이스에서 복원하여 나중에 &lt;code&gt;template1&lt;/code&gt; 에 추가되었을 수있는 오브젝트와 충돌하지 않고 덤프 된 데이터베이스의 올바른 컨텐츠를 다시 작성하도록해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c4adb0689e8eca60cac4109882f9fd73f05b7582" translate="yes" xml:space="preserve">
          <source>There is a separate server process called the &lt;em&gt;background writer&lt;/em&gt;, whose function is to issue writes of &amp;ldquo;dirty&amp;rdquo; (new or modified) shared buffers. It writes shared buffers so server processes handling user queries seldom or never need to wait for a write to occur. However, the background writer does cause a net overall increase in I/O load, because while a repeatedly-dirtied page might otherwise be written only once per checkpoint interval, the background writer might write it several times as it is dirtied in the same interval. The parameters discussed in this subsection can be used to tune the behavior for local needs.</source>
          <target state="translated">&lt;em&gt;background writer&lt;/em&gt; 라는 별도의 서버 프로세스가 있으며 ,이 기능은 &quot;더러운&quot;(새로운 또는 수정 된) 공유 버퍼 쓰기를 발행하는 기능입니다. 공유 버퍼를 작성하므로 사용자 쿼리를 처리하는 서버 프로세스가 거의 없거나 쓰기가 발생할 때까지 기다릴 필요가 없습니다. 그러나 백그라운드 작성기는 체크 포인트 간격 당 한 번만 반복적으로 삭제 된 페이지가 작성 될 수 있지만 동일한 간격으로 더러워 져서 여러 번 작성 될 수 있기 때문에 I / O로드가 전체적으로 순증가합니다. . 이 하위 섹션에서 논의 된 매개 변수는 로컬 요구에 대한 동작을 조정하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90974f119b06bcf646bf0eec46102bc09a0eac90" translate="yes" xml:space="preserve">
          <source>There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 257&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;. When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</source>
          <target state="translated">스크립트 파일을위한 간단한 변수 대체 기능이 있습니다. 변수 이름은 문자 (비 라틴 문자 포함), 숫자 및 밑줄로 구성되어야합니다. 변수는 위에서 설명한 command-line &lt;code&gt;-D&lt;/code&gt; 옵션 또는 아래에서 설명하는 메타 명령 으로 설정할 수 있습니다 . &lt;code&gt;-D&lt;/code&gt; 명령 행 옵션으로 사전 설정 한 변수 외에도 &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;표 257에&lt;/a&gt; 나열된 자동으로 사전 설정되는 몇 가지 변수가 있습니다 . &lt;code&gt;-D&lt;/code&gt; 를 사용하여 이러한 변수에 지정된 값 이 자동 사전 설정보다 우선합니다. 일단 설정되면, 변수의 값을 작성하여 SQL 명령에 삽입 할 수 있습니다 &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; . 둘 이상의 클라이언트 세션을 실행할 때 각 세션에는 고유 한 변수 세트가 있습니다. pgbench는 하나의 명령문에서 최대 255 개의 변수 사용을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f9e27e33d86d73062aeb666fac5a6e70627179d3" translate="yes" xml:space="preserve">
          <source>There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 273&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;. When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</source>
          <target state="translated">There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 273&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; . When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</target>
        </trans-unit>
        <trans-unit id="84b40deac5f431c882b47bcec560aceab88cb2ea" translate="yes" xml:space="preserve">
          <source>There is a strong connection between the XQuery language and XPath versions 2.0 and later: any expression that is syntactically valid and executes successfully in both produces the same result (with a minor exception for expressions containing numeric character references or predefined entity references, which XQuery replaces with the corresponding character while XPath leaves them alone). But there is no such connection between these languages and XPath 1.0; it was an earlier language and differs in many respects.</source>
          <target state="translated">XQuery 언어와 XPath 버전 2.0 이상 사이에는 밀접한 관련이 있습니다. 구문 상 유효하고 둘 다에서 성공적으로 실행되는 표현식은 동일한 결과를 생성합니다 (숫자 참조 또는 사전 정의 된 엔티티 참조를 포함하는 표현식은 XQuery가 대체 함) XPath는 해당 문자를 그대로 둡니다). 그러나 이러한 언어와 XPath 1.0 사이에는 그러한 연결이 없습니다. 초기 언어 였고 여러면에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c56c39bf47cf0690546e1095f601459a05ce75db" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; parameter, which determines the placement of temporary tables and indexes, as well as temporary files that are used for purposes such as sorting large data sets. This can be a list of tablespace names, rather than only one, so that the load associated with temporary objects can be spread over multiple tablespaces. A random member of the list is picked each time a temporary object is to be created.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; 매개 변수 도 있습니다.이 매개 변수는 임시 테이블 및 인덱스의 배치와 대용량 데이터 세트 정렬과 같은 목적으로 사용되는 임시 파일의 위치를 ​​결정합니다. 이는 임시 오브젝트와 연관된로드가 여러 테이블 스페이스에 분산 될 수 있도록 하나가 아니라 테이블 스페이스 이름의 목록 일 수 있습니다. 임시 개체를 만들 때마다 목록의 임의 구성원이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="58b9a64bc7c6fc9848f60613899f8c2ff0dc12dc" translate="yes" xml:space="preserve">
          <source>There is also a non-default GIN operator class &lt;code&gt;gin__int_ops&lt;/code&gt; supporting the same operators.</source>
          <target state="translated">동일한 연산자를 지원하는 기본이 아닌 GIN 연산자 클래스 &lt;code&gt;gin__int_ops&lt;/code&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d6db9a7a400632bced3a61ed8d0f591628a4c78" translate="yes" xml:space="preserve">
          <source>There is also a single-argument &lt;code&gt;to_timestamp&lt;/code&gt; function; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;Table 9.31&lt;/a&gt;.</source>
          <target state="translated">단일 인수 &lt;code&gt;to_timestamp&lt;/code&gt; 함수도 있습니다. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;표 9.31&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="41669b255a0d94f06b45d60440ba0720ed574d46" translate="yes" xml:space="preserve">
          <source>There is also a two-parameter version of &lt;code&gt;xslt_process&lt;/code&gt; which does not pass any parameters to the transformation.</source>
          <target state="translated">매개 변수를 변환에 전달하지 않는 &lt;code&gt;xslt_process&lt;/code&gt; 의 두 매개 변수 버전도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad78e13b5545fbac4993cd2573ccb0145f0260a" translate="yes" xml:space="preserve">
          <source>There is also an &lt;code&gt;include_if_exists&lt;/code&gt; directive, which acts the same as the &lt;code&gt;include&lt;/code&gt; directive, except when the referenced file does not exist or cannot be read. A regular &lt;code&gt;include&lt;/code&gt; will consider this an error condition, but &lt;code&gt;include_if_exists&lt;/code&gt; merely logs a message and continues processing the referencing configuration file.</source>
          <target state="translated">&lt;code&gt;include_if_exists&lt;/code&gt; 지시문 도 있습니다.이 지시문 은 참조 된 파일이 없거나 읽을 수없는 경우를 제외하고 는 &lt;code&gt;include&lt;/code&gt; 지시문 과 동일하게 작동합니다 . 일반 &lt;code&gt;include&lt;/code&gt; 은이 조건을 오류 조건으로 간주하지만 &lt;code&gt;include_if_exists&lt;/code&gt; 는 단순히 메시지를 기록하고 참조 구성 파일 처리를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="87e6a166488f605dc208dade3f60cf2f1017cef3" translate="yes" xml:space="preserve">
          <source>There is also an exception to the exception: I/O conversion casts from composite types to string types cannot be invoked using functional syntax, but must be written in explicit cast syntax (either &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; notation). This exception was added because after the introduction of automatically-provided I/O conversion casts, it was found too easy to accidentally invoke such a cast when a function or column reference was intended.</source>
          <target state="translated">예외에 대한 예외도 있습니다. 복합 유형에서 문자열 유형으로의 I / O 변환 캐스트는 기능적 구문을 사용하여 호출 할 수 없지만 명시 적 캐스트 구문 ( &lt;code&gt;CAST&lt;/code&gt; 또는 &lt;code&gt;::&lt;/code&gt; 표기법) 으로 작성해야합니다 . 이 예외는 자동으로 제공되는 I / O 변환 캐스트를 도입 한 후 함수 또는 열 참조가 의도되었을 때 이러한 캐스트를 실수로 호출하기가 너무 쉽기 때문에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="10e49e8f0395261cca6c9bddfde366e5b44bc0fa" translate="yes" xml:space="preserve">
          <source>There is also an option to grant privileges on all objects of the same type within one or more schemas. This functionality is currently supported only for tables, sequences, functions, and procedures. &lt;code&gt;ALL TABLES&lt;/code&gt; also affects views and foreign tables, just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; also affects aggregate and window functions, but not procedures, again just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. Use &lt;code&gt;ALL ROUTINES&lt;/code&gt; to include procedures.</source>
          <target state="translated">하나 이상의 스키마 내에서 동일한 유형의 모든 개체에 대한 권한을 부여하는 옵션도 있습니다. 이 기능은 현재 테이블, 시퀀스, 함수 및 프로 시저에 대해서만 지원됩니다. &lt;code&gt;ALL TABLES&lt;/code&gt; 는 특정 오브젝트 &lt;code&gt;GRANT&lt;/code&gt; 명령 과 마찬가지로 뷰 및 외부 테이블에도 영향을줍니다 . &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; 은 집계 및 창 기능에도 영향을 미치지 만 특정 객체 &lt;code&gt;GRANT&lt;/code&gt; 명령 과 마찬가지로 절차에는 영향을 미치지 않습니다 . &lt;code&gt;ALL ROUTINES&lt;/code&gt; 을 사용 하여 절차를 포함 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a702bafff3c7f4c616d64a2b71bb4d856736202" translate="yes" xml:space="preserve">
          <source>There is also the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function which covers cases when only searching by beginning of the string is needed.</source>
          <target state="translated">접두사 연산자 &lt;code&gt;^@&lt;/code&gt; 와 문자열의 시작으로 만 검색해야하는 경우를 다루는 해당 &lt;code&gt;starts_with&lt;/code&gt; 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="012b88356356711e33f301f2bb1596f7e0f835cc" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;autoinc.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;autoinc.example&lt;/code&gt; 에 예제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93425455a73285f0e21d7315c96b601935f70ba0" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;insert_username.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insert_username.example&lt;/code&gt; 에 예제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b24fdd30442f553bc5891f105491e9f92bd108" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;moddatetime.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;moddatetime.example&lt;/code&gt; 에 예제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2b9c61965fcc66e74624ddfce72996d337e8786" translate="yes" xml:space="preserve">
          <source>There is an inherent ambiguity between octal character-entry escapes and back references, which is resolved by the following heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e., the number is in the legal range for a back reference), and otherwise is taken as octal.</source>
          <target state="translated">8 진 문자 입력 이스케이프와 역 참조 사이에는 고유 한 모호성이 있으며, 위에서 언급 한대로 다음 휴리스틱으로 해결됩니다. 선행 0은 항상 8 진 이스케이프를 나타냅니다. 0이 아닌 단일 숫자 다음에 다른 숫자가 오는 것은 항상 역 참조로 간주됩니다. 0으로 시작하지 않는 여러 자리 시퀀스는 적절한 하위 표현식 뒤에 오는 경우 (즉, 숫자가 역 참조의 유효한 범위에있는 경우) 역 참조로 취해지고 그렇지 않으면 8 진수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2d4f42c096704e40b12586b5cb5d82cbdaf1b311" translate="yes" xml:space="preserve">
          <source>There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형의 선택적 두 번째 매개 변수가 있습니다. &lt;code&gt;true&lt;/code&gt; 인 경우 가능한 빨리 &lt;code&gt;pg_start_backup&lt;/code&gt; 을 실행하도록 지정 합니다. 이로 인해 즉시 체크 포인트가 발생하여 I / O 작업이 급증하여 동시에 실행되는 쿼리가 느려집니다.</target>
        </trans-unit>
        <trans-unit id="ea377213a3bab4fda44e6ee45837c28d5e6303c2" translate="yes" xml:space="preserve">
          <source>There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the function will return immediately after the backup is completed, without waiting for WAL to be archived. This behavior is only useful with backup software that independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. By default or when this parameter is true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled. (On a standby, this means that it will wait only when &lt;code&gt;archive_mode&lt;/code&gt; = &lt;code&gt;always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.)</source>
          <target state="translated">There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt; . If false, the function will return immediately after the backup is completed, without waiting for WAL to be archived. This behavior is only useful with backup software that independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. By default or when this parameter is true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled. (On a standby, this means that it will wait only when &lt;code&gt;archive_mode&lt;/code&gt; = &lt;code&gt;always&lt;/code&gt; . If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.)</target>
        </trans-unit>
        <trans-unit id="39681348944621b0cbdb87c4dd79d5e8a6ab1c87" translate="yes" xml:space="preserve">
          <source>There is another important concept associated with window functions: for each row, there is a set of rows within its partition called its &lt;em&gt;window frame&lt;/em&gt;. Some window functions act only on the rows of the window frame, rather than of the whole partition. By default, if &lt;code&gt;ORDER BY&lt;/code&gt; is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause. When &lt;code&gt;ORDER BY&lt;/code&gt; is omitted the default frame consists of all rows in the partition. &lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]&lt;/sup&gt;&lt;/a&gt; Here is an example using &lt;code&gt;sum&lt;/code&gt;:</source>
          <target state="translated">창 함수와 관련된 또 다른 중요한 개념이 있습니다. 각 행마다 파티션 내에 &lt;em&gt;창 프레임&lt;/em&gt; 이라는 행 세트가 있습니다 . 일부 창 기능은 전체 파티션이 아닌 창 프레임의 행에서만 작동합니다. 기본적으로 &lt;code&gt;ORDER BY&lt;/code&gt; 가 제공되면 프레임은 파티션 시작부터 현재 행까지의 모든 행과 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에 따라 현재 행과 동일한 다음 행으로 구성됩니다 . 때 &lt;code&gt;ORDER BY&lt;/code&gt; 가 생략되는 기본 프레임은 파티션의 모든 행으로 구성되어 있습니다. &lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]&lt;/sup&gt;&lt;/a&gt; 다음은 &lt;code&gt;sum&lt;/code&gt; 을 사용한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="64034dc768225bc4dcced9797dcc3830def63396" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f28370d7fe3178c0f150cc0dec3299397ce3c2af" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER COLLATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER COLLATION&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7babd298f2e4c509f069c94f5602aeb995a6b57c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER CONVERSION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER CONVERSION&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="928fd572e35641041e67b18e6e748efce3723a8c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="991bfb585377a575377a77fe428cfaf85a73d860" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9d77ec038759f5fffa10b0b08001ebb09342372d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER GROUP&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bb57388d9f735799eb7b9b89ff35e3d5ef151e31" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1637168216f474c65041857a21d81b0e4a440e97" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="345d872d60a75b2e0f9d89245157411db046f3d0" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8fcc86f4b1945452fb4d2e3306232b8ba831ba49" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cc28991fbce6444e2838b4c5b330fc7e8b89d499" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER OPERATOR&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2506d4e215504a7cdfcb1194c2679242cc54a59e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER SCHEMA&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER SCHEMA&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2964377f745afad2429ec74b207708196b68d312" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER STATISTICS&lt;/code&gt; 명령 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9c3931d89739bf4a90fd967b4f0a43fada449313" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e24f943c01b48797aaba76a9060c58b771452dd4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eee71505e9ca52479c60dc800cccb5a32c56fe24" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d50e75d0db9753a5bb17ed4059457e195c3fbe78" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f2e5183222d4bb5c821f92f235643d98359507e9" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e08ef635bc500a8ffe34e71b4cb60735a3f59c83" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ANALYZE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;ANALYZE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2ab267186c8c406bf12491cd64160dcb07b24078" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CLUSTER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CLUSTER&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b29db8edfc564e2f37aa124a9094dedfa5dc75ca" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COMMENT&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;COMMENT&lt;/code&gt; 명령 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="51ffc421257a5e488b200464e2482e6c0cb494cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COPY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;COPY&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d1ea525f2af46d628097a5d99e04b04f3dea2225" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE DATABASE&lt;/code&gt; statement in the SQL standard. Databases are equivalent to catalogs, whose creation is implementation-defined.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 문 이 없습니다 . 데이터베이스는 작성이 구현 정의 된 카탈로그와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1892a6f6e1f58d3b4418aa1f7caf04e29a8df179" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5bd71c5d0a01b45b44b80fcee88ed4660e223ea1" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE GROUP&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e39953cfa3881edf0f677e0b9a6a85f9dce8605d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 명령 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="502eb254142165b2715d9eff63db5d89a608e2d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="609c741f2314d56bf655daef547dcb2a0644be82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="41df83262dc2c3b270bf89a5b823f9c05295e631" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ec4376bb5fb0542843f635e97909a4ca5d798c55" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="adb922403a157a64a60a934905fa24aa07814119" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DO&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DO&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="453ae3f4ad66d52b89a14781b63b1f82ed5a0eba" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP AGGREGATE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fec0e29fd940c929987502b958108c6376839288" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP CONVERSION&lt;/code&gt; statement in the SQL standard, but a &lt;code&gt;DROP TRANSLATION&lt;/code&gt; statement that goes along with the &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; statement that is similar to the &lt;code&gt;CREATE CONVERSION&lt;/code&gt; statement in PostgreSQL.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP CONVERSION&lt;/code&gt; 문 이 없지만 PostgreSQL 의 &lt;code&gt;CREATE CONVERSION&lt;/code&gt; 문과 유사한 &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; 문과 함께 제공 되는 &lt;code&gt;DROP TRANSLATION&lt;/code&gt; 문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb09b1464adf925f06c0292814700fb9b8091f6c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP DATABASE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP DATABASE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a3c4c010988712d96dd1e79f98080f9432271062" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="75623002e2b624abb982d948db215c1dd60a52cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP GROUP&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="27a5387a3bec15b9e950f163994562d5efac89f3" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP LANGUAGE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e3d30fcc924219aba17a45fb588c01476a1e9ff6" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4a4d8ad142bdd21f8d4bd8875a49f33849bf5d39" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="20b4d42336169eb36dbc8e0af63669368391995e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP OPERATOR&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="22ab45de26ec7860503bcd3c1a242a1a6a072838" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP STATISTICS&lt;/code&gt; 명령 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="33a3a716e771311567ab1607e35bf61106da647f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3ff33e4bc1ee2eee7f638d4f9ffce00160a3d8ec" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="22f0a322ac87aa6f316366f64468b6a33b449141" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="caba21772330bd3e8d6bc5c0114bed4813577256" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4c6a0d8e969d6d60c24413dee9ec35d4707051d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;EXPLAIN&lt;/code&gt; statement defined in the SQL standard.</source>
          <target state="translated">SQL 표준에 정의 된 &lt;code&gt;EXPLAIN&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3188600a38497d7445251ce699c39dbe875e80ee" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LISTEN&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;LISTEN&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="89782cda07082f5c8f4d6514f108dab71bcfa4d2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LOCK TABLE&lt;/code&gt; in the SQL standard, which instead uses &lt;code&gt;SET TRANSACTION&lt;/code&gt; to specify concurrency levels on transactions. PostgreSQL supports that too; see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; for details.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;LOCK TABLE&lt;/code&gt; 이 없으며 대신 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 을 사용하여 트랜잭션의 동시성 레벨을 지정하십시오. PostgreSQL도이를 지원합니다. 자세한 내용은 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f784f25d51430ade6f35b2e081075babec2e0fe" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;MOVE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;MOVE&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4a168bea72d9806503f40f80aa12982ca9fd8601" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;NOTIFY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;NOTIFY&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6e1257ab0b3946084dffdd621f7db244f79c25f5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;REINDEX&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;REINDEX&lt;/code&gt; 명령 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e9129bb3a754d8cf06ba21c59dfcd6069ee5971c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;SECURITY LABEL&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;SECURITY LABEL&lt;/code&gt; 명령 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c2c399b535d16a105f07135d4035417088b1dcc4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;UNLISTEN&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;UNLISTEN&lt;/code&gt; 명령 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6a373be7f6f352e566798cf5a1903b201f8406b2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;VACUUM&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL 표준 에는 &lt;code&gt;VACUUM&lt;/code&gt; 문 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eaadde692acdf895866b856cf669a3d745361c1a" translate="yes" xml:space="preserve">
          <source>There is no alignment padding or any other extra data between fields.</source>
          <target state="translated">필드 사이에 정렬 패딩이나 다른 추가 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d9b8c9e107ad42ee0fad08dd8f24c67ee8d865a" translate="yes" xml:space="preserve">
          <source>There is no automatic way to verify that all of the &lt;code&gt;CHECK&lt;/code&gt; constraints are mutually exclusive. It is safer to create code that generates child tables and creates and/or modifies associated objects than to write each by hand.</source>
          <target state="translated">모든 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건이 상호 배타적 임을 확인하는 자동 방법은 없습니다 . 자식 테이블을 생성하고 관련 개체를 직접 작성하거나 수정하는 것보다 자식 테이블을 생성 및 / 또는 수정하는 코드를 만드는 것이 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6a9b18acfad0da6c23024f7c2509d5457d17977e" translate="yes" xml:space="preserve">
          <source>There is no comparably easy way to determine a next OID that's beyond the largest one in the database, but fortunately it is not critical to get the next-OID setting right.</source>
          <target state="translated">데이터베이스에서 가장 큰 다음 OID를 결정하는 비교적 쉬운 방법은 없지만, 다음 OID 설정을 올바르게 수행하는 것은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4db36b67fac0c975746b2d641f8b3943a36d8046" translate="yes" xml:space="preserve">
          <source>There is no cross-checking of indexes against their heap relation during normal operation. Symptoms of heap corruption can be subtle.</source>
          <target state="translated">정상 작동 중에 힙 관계에 대한 인덱스의 교차 점검은 없습니다. 힙 손상의 증상은 미묘 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e96dd49b9a313a343547338d49ed17c06a38c1a6" translate="yes" xml:space="preserve">
          <source>There is no dependent object; this type of entry is a signal that the system itself depends on the referenced object, and so that object must never be deleted. Entries of this type are created only by &lt;code&gt;initdb&lt;/code&gt;. The columns for the dependent object contain zeroes.</source>
          <target state="translated">종속 개체가 없습니다. 이 유형의 항목은 시스템 자체가 참조 된 객체에 의존한다는 신호이므로 객체를 절대로 삭제해서는 안됩니다. 이 유형의 항목은 &lt;code&gt;initdb&lt;/code&gt; 에 의해서만 작성 됩니다 . 종속 개체의 열에는 0이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="70fc6506fe197311ab91bc28b3e88218eb7eab49" translate="yes" xml:space="preserve">
          <source>There is no general method of repairing problems that &lt;code&gt;amcheck&lt;/code&gt; detects. An explanation for the root cause of an invariant violation should be sought. &lt;a href=&quot;pageinspect&quot;&gt;pageinspect&lt;/a&gt; may play a useful role in diagnosing corruption that &lt;code&gt;amcheck&lt;/code&gt; detects. A &lt;code&gt;REINDEX&lt;/code&gt; may not be effective in repairing corruption.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; 가 감지 하는 일반적인 문제 복구 방법은 없습니다 . 변하지 않는 위반의 근본 원인에 대한 설명을 찾아야합니다. &lt;a href=&quot;pageinspect&quot;&gt;pagecheck&lt;/a&gt; 는 &lt;code&gt;amcheck&lt;/code&gt; 가 탐지 한 손상을 진단하는 데 유용한 역할을 할 수 있습니다 . &lt;code&gt;REINDEX&lt;/code&gt; 는 손상을 수리 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f84235bff819237a1da91e8e95c005f22d0298e2" translate="yes" xml:space="preserve">
          <source>There is no length limit on the input strings.</source>
          <target state="translated">입력 문자열에는 길이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4dbeb068f00ac522f4db315c80e9ac31689bfd87" translate="yes" xml:space="preserve">
          <source>There is no linguistic support, even for English. Regular expressions are not sufficient because they cannot easily handle derived words, e.g., &lt;code&gt;satisfies&lt;/code&gt; and &lt;code&gt;satisfy&lt;/code&gt;. You might miss documents that contain &lt;code&gt;satisfies&lt;/code&gt;, although you probably would like to find them when searching for &lt;code&gt;satisfy&lt;/code&gt;. It is possible to use &lt;code&gt;OR&lt;/code&gt; to search for multiple derived forms, but this is tedious and error-prone (some words can have several thousand derivatives).</source>
          <target state="translated">영어에 대해서도 언어 지원이 없습니다. 정규 표현식은 파생 된 단어를 쉽게 처리 할 수 ​​없기 때문에 충분하지 않습니다 (예 : &lt;code&gt;satisfies&lt;/code&gt; 및 &lt;code&gt;satisfy&lt;/code&gt; . 당신은 포함 된 문서 놓칠 수 &lt;code&gt;satisfies&lt;/code&gt; 당신은 아마 검색 할 때 그들을 찾을 싶습니다 있지만, &lt;code&gt;satisfy&lt;/code&gt; . &lt;code&gt;OR&lt;/code&gt; 을 사용 하여 여러 파생 된 양식을 검색 할 수는 있지만 지루하고 오류가 발생하기 쉽습니다 (일부 단어에는 수천 개의 파생어가있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="56e118a7d0adfb0e635c9d07f655d84a8ad88c12" translate="yes" xml:space="preserve">
          <source>There is no mechanism to enforce uniqueness of standby names. In case of duplicates one of the matching standbys will be considered as higher priority, though exactly which one is indeterminate.</source>
          <target state="translated">대기 이름의 고유성을 강제하는 메커니즘은 없습니다. 중복의 경우 일치하는 대기 중 하나가 정확하게 결정되지 않은 우선 순위로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ee6e31417005e5059c60745bca02997125074c26" translate="yes" xml:space="preserve">
          <source>There is no need to grant privileges to the owner of an object (usually the user that created it), as the owner has all privileges by default. (The owner could, however, choose to revoke some of their own privileges for safety.)</source>
          <target state="translated">소유자는 기본적으로 모든 권한을 가지므로 개체 소유자 (일반적으로 개체를 만든 사용자)에게 권한을 부여 할 필요가 없습니다. 그러나 소유자는 안전에 대한 일부 권한을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ae1505daac493ace3132ae554c6ea20c2ba190" translate="yes" xml:space="preserve">
          <source>There is no performance difference among these three types, apart from increased storage space when using the blank-padded type, and a few extra CPU cycles to check the length when storing into a length-constrained column. While &lt;code&gt;character(n)&lt;/code&gt; has performance advantages in some other database systems, there is no such advantage in PostgreSQL; in fact &lt;code&gt;character(n)&lt;/code&gt; is usually the slowest of the three because of its additional storage costs. In most situations &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; should be used instead.</source>
          <target state="translated">공백으로 채워진 유형을 사용할 때 스토리지 공간이 증가하고 길이가 제한된 컬럼에 저장할 때 길이를 확인하는 몇 가지 추가 CPU주기 외에는이 세 가지 유형간에 성능 차이가 없습니다. 하지만 &lt;code&gt;character(n)&lt;/code&gt; 다른 데이터베이스 시스템의 성능 장점을 가지고, PostgreSQL을에 그런 장점이 없다; 실제로 &lt;code&gt;character(n)&lt;/code&gt; 은 추가 스토리지 비용으로 인해 일반적으로 3 개 중 가장 느립니다. 대부분의 상황에서 &lt;code&gt;text&lt;/code&gt; 나 &lt;code&gt;character varying&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8afc4737cc902a7afc20e4910e033de6ddabdb93" translate="yes" xml:space="preserve">
          <source>There is no restriction regarding how many database users a given operating system user can correspond to, nor vice versa. Thus, entries in a map should be thought of as meaning &amp;ldquo;this operating system user is allowed to connect as this database user&amp;rdquo;, rather than implying that they are equivalent. The connection will be allowed if there is any map entry that pairs the user name obtained from the external authentication system with the database user name that the user has requested to connect as.</source>
          <target state="translated">주어진 운영 체제 사용자가 대응할 수있는 데이터베이스 사용자 수에 대한 제한은 없으며 그 반대도 마찬가지입니다. 따라서 맵의 항목은 &quot;이 운영 체제 사용자는이 데이터베이스 사용자로 연결할 수 있습니다&quot;라는 의미로 간주되어야합니다. 외부 인증 시스템에서 얻은 사용자 이름과 사용자가 연결을 요청한 데이터베이스 사용자 이름을 쌍으로하는 맵 항목이 있으면 연결이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d6a72d9fa9097f88cd465d659b996359e6595c" translate="yes" xml:space="preserve">
          <source>There is no result row for the city of Hayward. This is because there is no matching entry in the &lt;code&gt;cities&lt;/code&gt; table for Hayward, so the join ignores the unmatched rows in the &lt;code&gt;weather&lt;/code&gt; table. We will see shortly how this can be fixed.</source>
          <target state="translated">Hayward시에 대한 결과 행이 없습니다. 이는 Hayward 에 대한 &lt;code&gt;cities&lt;/code&gt; 테이블에 일치하는 항목이 없기 때문에 조인은 &lt;code&gt;weather&lt;/code&gt; 테이블 에서 일치하지 않는 행을 무시 합니다. 우리는 이것이 어떻게 고칠 수 있는지 곧 보게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb859432422d8124605fd6fa0a5ba7fbb347c338" translate="yes" xml:space="preserve">
          <source>There is no way to create an exclusion constraint spanning all partitions; it is only possible to constrain each leaf partition individually.</source>
          <target state="translated">모든 파티션에 걸쳐 제외 제약 조건을 만들 수있는 방법은 없습니다. 각 리프 파티션을 개별적으로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0394a27a4ae985b5c69a41210e1f40ba8b0d8944" translate="yes" xml:space="preserve">
          <source>There is one further implementation-level restriction that applies regardless of the operator class or collation used:</source>
          <target state="translated">There is one further implementation-level restriction that applies regardless of the operator class or collation used:</target>
        </trans-unit>
        <trans-unit id="18b7fd66a2cb5b710dc5cc84ddcb5325f9ab68cf" translate="yes" xml:space="preserve">
          <source>There is one further implementation-level restriction that may be lifted in a future version of PostgreSQL:</source>
          <target state="translated">There is one further implementation-level restriction that may be lifted in a future version of PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="1b5bd62ec3737bfec14cadfb61679b8166c57b55" translate="yes" xml:space="preserve">
          <source>There is one row for each buffer in the shared cache. Unused buffers are shown with all fields null except &lt;code&gt;bufferid&lt;/code&gt;. Shared system catalogs are shown as belonging to database zero.</source>
          <target state="translated">공유 캐시에는 각 버퍼마다 하나의 행이 있습니다. 사용되지 않은 버퍼는 &lt;code&gt;bufferid&lt;/code&gt; 를 제외한 모든 필드가 null로 표시됩니다 . 공유 시스템 카탈로그는 데이터베이스 0에 속하는 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f45963e6e5833c88c83b3b4b867ec971de5358c8" translate="yes" xml:space="preserve">
          <source>There is only one &lt;code&gt;round&lt;/code&gt; function that takes two arguments; it takes a first argument of type &lt;code&gt;numeric&lt;/code&gt; and a second argument of type &lt;code&gt;integer&lt;/code&gt;. So the following query automatically converts the first argument of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt;:</source>
          <target state="translated">두 개의 인수를 취하는 하나의 &lt;code&gt;round&lt;/code&gt; 함수가 있습니다. &lt;code&gt;numeric&lt;/code&gt; 유형의 첫 번째 인수 와 &lt;code&gt;integer&lt;/code&gt; 유형의 두 번째 인수가 필요합니다 . 따라서 다음 쿼리는 &lt;code&gt;integer&lt;/code&gt; 유형의 첫 번째 인수 를 &lt;code&gt;numeric&lt;/code&gt; 로 자동 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="b9159e4fda642d08346e94fb2d3ac2dbc99a478a" translate="yes" xml:space="preserve">
          <source>There is only one factorial operator (postfix &lt;code&gt;!&lt;/code&gt;) defined in the standard catalog, and it takes an argument of type &lt;code&gt;bigint&lt;/code&gt;. The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</source>
          <target state="translated">표준 카탈로그에는 하나의 계승 연산자 (postfix &lt;code&gt;!&lt;/code&gt; ) 만 정의되어 있으며 &lt;code&gt;bigint&lt;/code&gt; 유형의 인수를 사용합니다 . 스캐너 는이 쿼리 표현식에서 인수에 초기 유형의 &lt;code&gt;integer&lt;/code&gt; 를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="dd1f87be0e4d3b116fb1cbdcb6dc8732c5edc78d" translate="yes" xml:space="preserve">
          <source>There is only one square root operator (prefix &lt;code&gt;|/&lt;/code&gt;) defined in the standard catalog, and it takes an argument of type &lt;code&gt;double precision&lt;/code&gt;. The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</source>
          <target state="translated">There is only one square root operator (prefix &lt;code&gt;|/&lt;/code&gt; ) defined in the standard catalog, and it takes an argument of type &lt;code&gt;double precision&lt;/code&gt; . The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</target>
        </trans-unit>
        <trans-unit id="ca0c7153374d6f701aba32a67304ea000734d416" translate="yes" xml:space="preserve">
          <source>There is presently no security mechanism for viewing comments: any user connected to a database can see all the comments for objects in that database. For shared objects such as databases, roles, and tablespaces, comments are stored globally so any user connected to any database in the cluster can see all the comments for shared objects. Therefore, don't put security-critical information in comments.</source>
          <target state="translated">주석을보기위한 보안 메커니즘은 현재 없습니다. 데이터베이스에 연결된 모든 사용자는 해당 데이터베이스의 오브젝트에 대한 모든 주석을 볼 수 있습니다. 데이터베이스, 역할 및 테이블 스페이스와 같은 공유 객체의 경우 주석이 전체적으로 저장되므로 클러스터의 모든 데이터베이스에 연결된 모든 사용자가 공유 객체에 대한 모든 주석을 볼 수 있습니다. 따라서 주석에 보안에 중요한 정보를 넣지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e848fe2ab9f9a42478fab56269c47dd1ce42078d" translate="yes" xml:space="preserve">
          <source>There is usually not much point in making more than one tablespace per logical file system, since you cannot control the location of individual files within a logical file system. However, PostgreSQL does not enforce any such limitation, and indeed it is not directly aware of the file system boundaries on your system. It just stores files in the directories you tell it to use.</source>
          <target state="translated">논리 파일 시스템 내에서 개별 파일의 위치를 ​​제어 할 수 없기 때문에 논리 파일 시스템 당 둘 이상의 테이블 스페이스를 작성하는 데 일반적으로 큰 의미가 없습니다. 그러나 PostgreSQL은 이러한 제한을 적용하지 않으며 실제로 시스템의 파일 시스템 경계를 직접 인식하지 못합니다. 사용하도록 지시 한 디렉토리에 파일을 저장하기 만합니다.</target>
        </trans-unit>
        <trans-unit id="d953cfaaf0252b15b02b8c9a112ebe99c8fa7d20" translate="yes" xml:space="preserve">
          <source>There must also be matching child-table constraints for all &lt;code&gt;CHECK&lt;/code&gt; constraints of the parent, except those marked non-inheritable (that is, created with &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt;) in the parent, which are ignored; all child-table constraints matched must not be marked non-inheritable. Currently &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered, but this might change in the future.</source>
          <target state="translated">상속 할 수없는 것으로 표시된 (즉, &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt; 생성 된) 부모를 제외하고 부모의 모든 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건에 대해 일치하는 자식 테이블 제약 조건이 있어야합니다 . 일치하는 모든 자식 테이블 제약 조건을 상속 불가능으로 표시해서는 안됩니다. 현재 &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; 및 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 제약 조건은 고려되지 않지만 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d0ef1c54ee5da6f3a9bc0faf2941d2e26078541" translate="yes" xml:space="preserve">
          <source>There should be no extra overhead in the parser or executor if a query does not need implicit type conversion. That is, if a query is well-formed and the types already match, then the query should execute without spending extra time in the parser and without introducing unnecessary implicit conversion calls in the query.</source>
          <target state="translated">쿼리에 암시 적 유형 변환이 필요하지 않은 경우 파서 또는 실행기에 추가 오버 헤드가 없어야합니다. 즉, 쿼리가 올바르게 구성되어 있고 형식이 이미 일치하는 경우 구문 분석기에서 추가 시간을 소비하지 않고 쿼리에 불필요한 암시 적 변환 호출을 도입하지 않고 쿼리를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="934618c1781f2f0a9f6bb79bbcc267c826504412" translate="yes" xml:space="preserve">
          <source>There was formerly an &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; variant, but this is now ignored (with a warning). An index cannot have an owner different from its table's owner. Changing the table's owner automatically changes the index as well.</source>
          <target state="translated">이전에 &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; 변형이 있었지만 이제는 경고와 함께 무시됩니다. 인덱스는 테이블 소유자와 다른 소유자를 가질 수 없습니다. 테이블 소유자를 변경하면 인덱스도 자동으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="eb82410dec70b2b3321bff0d1e9388c3bd8dfd33" translate="yes" xml:space="preserve">
          <source>There's no need to manually create indexes on unique columns; doing so would just duplicate the automatically-created index.</source>
          <target state="translated">고유 한 열에 인덱스를 수동으로 만들 필요는 없습니다. 그렇게하면 자동 생성 된 인덱스가 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="dd1c3102c4930b5f2a44ebfcda5a098872c67837" translate="yes" xml:space="preserve">
          <source>Thesauruses are used during indexing so any change in the thesaurus dictionary's parameters &lt;em&gt;requires&lt;/em&gt; reindexing. For most other dictionary types, small changes such as adding or removing stopwords does not force reindexing.</source>
          <target state="translated">동의어 사전은 인덱싱 중에 사용되므로 동의어 사전 사전의 매개 변수를 변경 &lt;em&gt;하려면&lt;/em&gt; 색인이 . 대부분의 다른 사전 유형의 경우, 중지 어 추가 또는 제거와 같은 작은 변경으로 인해 재색 인화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f1ad8c9ce64bcda09c594082de2a500ef5cce09" translate="yes" xml:space="preserve">
          <source>These are actually just special cases of the general casting notations discussed next.</source>
          <target state="translated">이것들은 실제로 다음에 논의되는 일반적인 캐스팅 표기법의 특별한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="1ede3bb37d9693ab9536c9fcd48ebe3c46555fd8" translate="yes" xml:space="preserve">
          <source>These are good sources to start learning about various kinds of encoding systems.</source>
          <target state="translated">이것들은 다양한 종류의 인코딩 시스템에 대한 학습을 ​​시작하기에 좋은 소스입니다.</target>
        </trans-unit>
        <trans-unit id="8a4a0666760118b211b5b7d0b41910720c832114" translate="yes" xml:space="preserve">
          <source>These are less likely to be problematic than &lt;code&gt;search_path&lt;/code&gt;, but can be handled with function &lt;code&gt;SET&lt;/code&gt; options if the need arises.</source>
          <target state="translated">이것들은 &lt;code&gt;search_path&lt;/code&gt; 보다 문제가 되지 않지만 필요한 경우 함수 &lt;code&gt;SET&lt;/code&gt; 옵션 으로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="e09b98f630a14c95107bbc1d571768385072e6a7" translate="yes" xml:space="preserve">
          <source>These are some examples of valid numeric constants:</source>
          <target state="translated">다음은 유효한 숫자 상수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="2d394fc649569a5eeeb4c5600c0f12014850ba1f" translate="yes" xml:space="preserve">
          <source>These are the steps to perform an upgrade with pg_upgrade:</source>
          <target state="translated">pg_upgrade로 업그레이드를 수행하는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f72a6870691351c5c2b87041a8d81f8e78b27456" translate="yes" xml:space="preserve">
          <source>These attributes inform the query optimizer about the behavior of the function. At most one choice can be specified. If none of these appear, &lt;code&gt;VOLATILE&lt;/code&gt; is the default assumption.</source>
          <target state="translated">이러한 속성은 함수의 작동에 대해 쿼리 최적화 프로그램에 알려줍니다. 최대 하나의 선택을 지정할 수 있습니다. 이 중 아무 것도 나타나지 않으면 &lt;code&gt;VOLATILE&lt;/code&gt; 이 기본 가정입니다.</target>
        </trans-unit>
        <trans-unit id="f85846f94f84f78007c888a90fb32598de3ea04f" translate="yes" xml:space="preserve">
          <source>These caches can typically be disabled; however, the method for doing this varies by operating system and drive type:</source>
          <target state="translated">이러한 캐시는 일반적으로 비활성화 할 수 있습니다. 그러나이를 수행하는 방법은 운영 체제 및 드라이브 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="484e4f03dd4a3ca589988330c2b61dd6c51084dd" translate="yes" xml:space="preserve">
          <source>These clauses alter attributes originally set by &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. For more information, see the &lt;code&gt;CREATE ROLE&lt;/code&gt; reference page.</source>
          <target state="translated">이 절은 원래 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE에&lt;/a&gt; 의해 설정된 속성을 변경합니다 . 자세한 정보는 &lt;code&gt;CREATE ROLE&lt;/code&gt; 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae13d4d630a34fa139e9046de2cb8f6bc13b3a42" translate="yes" xml:space="preserve">
          <source>These clauses define a role's ability to create databases. If &lt;code&gt;CREATEDB&lt;/code&gt; is specified, the role being defined will be allowed to create new databases. Specifying &lt;code&gt;NOCREATEDB&lt;/code&gt; will deny a role the ability to create databases. If not specified, &lt;code&gt;NOCREATEDB&lt;/code&gt; is the default.</source>
          <target state="translated">이 절은 데이터베이스를 생성하는 역할의 기능을 정의합니다. 경우 &lt;code&gt;CREATEDB&lt;/code&gt; 가 지정되어 정의되는 역할은 새 데이터베이스를 만들 허용됩니다. &lt;code&gt;NOCREATEDB&lt;/code&gt; 를 지정 하면 데이터베이스 작성 기능이 거부됩니다. 지정하지 않으면 &lt;code&gt;NOCREATEDB&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="236a4db02b1fa5b8bc065150c9e1f92cd0c2db65" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role &amp;ldquo;inherits&amp;rdquo; the privileges of roles it is a member of. A role with the &lt;code&gt;INHERIT&lt;/code&gt; attribute can automatically use whatever database privileges have been granted to all roles it is directly or indirectly a member of. Without &lt;code&gt;INHERIT&lt;/code&gt;, membership in another role only grants the ability to &lt;code&gt;SET ROLE&lt;/code&gt; to that other role; the privileges of the other role are only available after having done so. If not specified, &lt;code&gt;INHERIT&lt;/code&gt; is the default.</source>
          <target state="translated">이 절은 역할이 구성원의 역할 권한을 &quot;상속&quot;하는지 여부를 결정합니다. 와 역할 &lt;code&gt;INHERIT&lt;/code&gt; 의 속성은 자동으로 직접 또는 간접적으로의 구성원 인 모든 역할에 부여 된 어떤 데이터베이스 권한을 사용할 수 있습니다. &lt;code&gt;INHERIT&lt;/code&gt; 이 없으면 다른 역할의 멤버 자격만으로 다른 역할에 &lt;code&gt;SET ROLE&lt;/code&gt; 을 설정할 수 있습니다. 다른 역할의 권한은 그렇게 한 후에 만 ​​사용할 수 있습니다. 지정하지 않으면 &lt;code&gt;INHERIT&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a8f7e3712b4368e28fc6b45f7eab106b1e33840d" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. The superuser and owner of the table being dumped always bypass RLS.</source>
          <target state="translated">이 절은 역할이 모든 RLS (Row-Level Security) 정책을 무시하는지 여부를 결정합니다. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; 가 기본값입니다. pg_dump는 &lt;code&gt;row_security&lt;/code&gt; 를 &lt;code&gt;OFF&lt;/code&gt; 로 설정 합니다. 테이블의 모든 내용이 덤프되도록하기 위해 기본적으로 로 설정합니다. pg_dump를 실행하는 사용자에게 적절한 권한이 없으면 오류가 반환됩니다. 덤프되는 테이블의 수퍼 유저와 소유자는 항상 RLS를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1c4c9abff0ed7aed3c18b9b9a05141b1d9e0e976" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. You must be a superuser to create a new role having the &lt;code&gt;BYPASSRLS&lt;/code&gt; attribute.</source>
          <target state="translated">These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. You must be a superuser to create a new role having the &lt;code&gt;BYPASSRLS&lt;/code&gt; attribute.</target>
        </trans-unit>
        <trans-unit id="cdfb1f660e91b5c6f6fdf7bb5b01ee2031a6647b" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default.</source>
          <target state="translated">이 절은 역할이 복제 역할인지 여부를 결정합니다. 복제 모드 (물리적 또는 논리적 복제)에서 서버에 연결하고 복제 슬롯을 만들거나 삭제하려면 역할에이 특성 (또는 수퍼 유저)이 있어야합니다. 갖는 역할 &lt;code&gt;REPLICATION&lt;/code&gt; 속성은 매우 높은 권한의 역할이며, 실제로 복제에 사용 역할을 사용해야합니다. 지정하지 않으면 &lt;code&gt;NOREPLICATION&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9f08ec67a75e039b1e1d579f9d114eb5649ed79b" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default. You must be a superuser to create a new role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute.</source>
          <target state="translated">These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default. You must be a superuser to create a new role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute.</target>
        </trans-unit>
        <trans-unit id="93cac2364d542f963f918606f10bb473c25cf54c" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is allowed to log in; that is, whether the role can be given as the initial session authorization name during client connection. A role having the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be thought of as a user. Roles without this attribute are useful for managing database privileges, but are not users in the usual sense of the word. If not specified, &lt;code&gt;NOLOGIN&lt;/code&gt; is the default, except when &lt;code&gt;CREATE ROLE&lt;/code&gt; is invoked through its alternative spelling &lt;a href=&quot;sql-createuser&quot;&gt;CREATE USER&lt;/a&gt;.</source>
          <target state="translated">이 절은 역할의 로그인 허용 여부를 결정합니다. 즉, 클라이언트 연결 중에 역할을 초기 세션 권한 부여 이름으로 제공 할 수 있는지 여부입니다. &lt;code&gt;LOGIN&lt;/code&gt; 속성 을 가진 역할 은 사용자로 생각할 수 있습니다. 이 속성이없는 역할은 데이터베이스 권한을 관리하는 데 유용하지만 일반적인 의미의 사용자는 아닙니다. 지정하지 않으면 대체 철자 &lt;a href=&quot;sql-createuser&quot;&gt;CREATE USER를&lt;/a&gt; 통해 &lt;code&gt;CREATE ROLE&lt;/code&gt; 이 호출되는 경우를 제외하고 &lt;code&gt;NOLOGIN&lt;/code&gt; 이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="181b83412fd4eddb3ac3029828e16b7a9b6b98ef" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role will be permitted to create new roles (that is, execute &lt;code&gt;CREATE ROLE&lt;/code&gt;). A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can also alter and drop other roles. If not specified, &lt;code&gt;NOCREATEROLE&lt;/code&gt; is the default.</source>
          <target state="translated">이 절은 역할이 새 역할을 만들 수 있는지 (즉, &lt;code&gt;CREATE ROLE&lt;/code&gt; 실행 ) 여부를 결정합니다 . &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이 있는 역할은 다른 역할을 변경하거나 삭제할 수 있습니다. 지정하지 않으면 &lt;code&gt;NOCREATEROLE&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2e0e211b5e3eb630f6887dce4107cdd808855949" translate="yes" xml:space="preserve">
          <source>These clauses determine whether the new role is a &amp;ldquo;superuser&amp;rdquo;, who can override all access restrictions within the database. Superuser status is dangerous and should be used only when really needed. You must yourself be a superuser to create a new superuser. If not specified, &lt;code&gt;NOSUPERUSER&lt;/code&gt; is the default.</source>
          <target state="translated">이 절은 새 역할이 &quot;수퍼 유저&quot;인지 여부를 결정하며,이 역할은 데이터베이스 내의 모든 액세스 제한을 무시할 수 있습니다. 수퍼 유저 상태는 위험하므로 실제로 필요한 경우에만 사용해야합니다. 새 수퍼 유저를 만들려면 자신이 수퍼 유저 여야합니다. 지정하지 않으면 &lt;code&gt;NOSUPERUSER&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b6a59cdbb5e799d0fed1a4aa2596214d1849fd5f" translate="yes" xml:space="preserve">
          <source>These clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If the &lt;code&gt;refcolumn&lt;/code&gt; list is omitted, the primary key of the &lt;code&gt;reftable&lt;/code&gt; is used. The referenced columns must be the columns of a non-deferrable unique or primary key constraint in the referenced table. The user must have &lt;code&gt;REFERENCES&lt;/code&gt; permission on the referenced table (either the whole table, or the specific referenced columns). The addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table. Note that foreign key constraints cannot be defined between temporary tables and permanent tables.</source>
          <target state="translated">이 절은 외래 키 제약 조건을 지정합니다. 새 테이블의 하나 이상의 열 그룹에는 참조 된 테이블의 일부 행에 대한 참조 된 열의 값과 일치하는 값만 포함되어야합니다. 는 IF &lt;code&gt;refcolumn&lt;/code&gt; 의 목록이 생략의 기본 키 &lt;code&gt;reftable&lt;/code&gt; 이 사용됩니다. 참조 된 컬럼은 참조 된 테이블에서 지연 불가능한 고유 또는 기본 키 제한 조건의 컬럼이어야합니다. 사용자는 참조 된 테이블 (전체 테이블 또는 특정 참조 열)에 대한 &lt;code&gt;REFERENCES&lt;/code&gt; 권한이 있어야합니다 . 외래 키 제약 조건을 추가하려면 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 가참조 테이블에 대한 잠금이 필요 합니다. 임시 테이블과 영구 테이블간에 외래 키 제약 조건을 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="857c0ae8d220b45b3955f09362ef789a9a3402e5" translate="yes" xml:space="preserve">
          <source>These commands are defined in the SQL standard, except for the &lt;code&gt;DEFERRABLE&lt;/code&gt; transaction mode and the &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; form, which are PostgreSQL extensions.</source>
          <target state="translated">이러한 명령은 &lt;code&gt;DEFERRABLE&lt;/code&gt; 트랜잭션 모드와 PostgreSQL 확장 인 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 양식을 제외하고 SQL 표준에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ad3dc4d8a64e61d33f79320b9d9d378ce755f14" translate="yes" xml:space="preserve">
          <source>These commands may be used to end SQL queries, taking the place of the terminating semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="translated">These commands may be used to end SQL queries, taking the place of the terminating semicolon ( &lt;code&gt;;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f08278f74b1bbe88f6fdde4ee30a3df428b62a8f" translate="yes" xml:space="preserve">
          <source>These comparison operators are available for all built-in data types that have a natural ordering, including numeric, string, and date/time types. In addition, arrays, composite types, and ranges can be compared if their component data types are comparable.</source>
          <target state="translated">These comparison operators are available for all built-in data types that have a natural ordering, including numeric, string, and date/time types. In addition, arrays, composite types, and ranges can be compared if their component data types are comparable.</target>
        </trans-unit>
        <trans-unit id="c9a3af7e0da0acbd34de05752f110be6e0e62942" translate="yes" xml:space="preserve">
          <source>These configuration parameters provide a crude method of influencing the query plans chosen by the query optimizer. If the default plan chosen by the optimizer for a particular query is not optimal, a &lt;em&gt;temporary&lt;/em&gt; solution is to use one of these configuration parameters to force the optimizer to choose a different plan. Better ways to improve the quality of the plans chosen by the optimizer include adjusting the planner cost constants (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;), running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; manually, increasing the value of the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter, and increasing the amount of statistics collected for specific columns using &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;.</source>
          <target state="translated">이러한 구성 매개 변수는 쿼리 최적화 프로그램이 선택한 쿼리 계획에 영향을 미치는 조잡한 방법을 제공합니다. 특정 쿼리에 대해 옵티마이 저가 선택한 기본 계획이 최적이 아닌 경우 &lt;em&gt;임시&lt;/em&gt; 솔루션은 이러한 구성 매개 변수 중 하나를 사용하여 옵티마이 저가 다른 계획을 선택하도록합니다. 옵티마이 저가 선택한 계획의 품질을 개선하는 더 좋은 방법은 플래너 비용 상수 조정 ( &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;섹션 19.7.2&lt;/a&gt; 참조 ), 수동으로 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 실행 , &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; 구성 매개 변수 의 값 증가 및 특정 컬럼에 대해 수집 된 통계량 증가를 포함합니다. 사용 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="97b05ff9bc8f45601af490580b1cf57f630e4008" translate="yes" xml:space="preserve">
          <source>These cost-based decisions will be made at plan time, not execution time. This means that when prepared statements are in use, and a generic plan is used (see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;), the values of the configuration parameters in effect at prepare time control the decisions, not the settings at execution time.</source>
          <target state="translated">이러한 비용 기반 결정은 실행 시간이 아니라 계획 시간에 이루어집니다. 이는 준비된 명령문이 사용 &lt;a href=&quot;sql-prepare&quot;&gt;중이고&lt;/a&gt; 일반 계획이 사용되는 경우 ( PREPARE 참조 ) 준비 시간에 유효한 구성 매개 변수 값이 실행시 설정이 아니라 결정을 제어 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bd102e49cf8b96793cacdde24d32614ffb078540" translate="yes" xml:space="preserve">
          <source>These counts can be particularly valuable for filter conditions applied at join nodes. The &amp;ldquo;Rows Removed&amp;rdquo; line only appears when at least one scanned row, or potential join pair in the case of a join node, is rejected by the filter condition.</source>
          <target state="translated">이 수는 결합 노드에 적용된 필터 조건에 특히 유용 할 수 있습니다. &quot;행 제거됨&quot;행은 하나 이상의 스캔 된 행 또는 조인 노드의 경우 잠재적 조인 쌍이 필터 조건에 의해 거부 된 경우에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9525af1114ee853e1be2e829b6746f11684a7213" translate="yes" xml:space="preserve">
          <source>These examples all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown.</source>
          <target state="translated">These examples all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; . Output is always in the first of the forms shown.</target>
        </trans-unit>
        <trans-unit id="d2ee06a454af3afd2603bd1ff07db9463f13f34e" translate="yes" xml:space="preserve">
          <source>These examples show use of &lt;code&gt;position&lt;/code&gt; fields:</source>
          <target state="translated">이 예는 &lt;code&gt;position&lt;/code&gt; 필드 사용을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f944ac8005ce9ea42b0263baeef3f32035cd55b8" translate="yes" xml:space="preserve">
          <source>These examples show use of &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; fields:</source>
          <target state="translated">These examples show use of &lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt; fields:</target>
        </trans-unit>
        <trans-unit id="e22989ebfc8062e1b7b80c3eb7a3f32777c7de5c" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown.</source>
          <target state="translated">이 예제는 모두 같은 주소를 지정합니다. 대문자 a 및 소문자는 숫자 &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; 에 허용됩니다 . 출력은 항상 표시된 양식 중 첫 번째 양식입니다.</target>
        </trans-unit>
        <trans-unit id="ef90197c0c87bcadf3fd64cda40bcfb6928639b3" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown. The last six input formats that are mentioned above are not part of any standard. To convert a traditional 48 bit MAC address in EUI-48 format to modified EUI-64 format to be included as the host portion of an IPv6 address, use &lt;code&gt;macaddr8_set7bit&lt;/code&gt; as shown:</source>
          <target state="translated">이 예제는 모두 같은 주소를 지정합니다. 대문자 a 및 소문자는 숫자 &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; 에 허용됩니다 . 출력은 항상 표시된 양식 중 첫 번째 양식입니다. 위에서 언급 한 마지막 6 개의 입력 형식은 표준의 일부가 아닙니다. IPv6 주소의 호스트 부분으로 포함되도록 EUI-48 형식의 기존 48 비트 MAC 주소를 수정 된 EUI-64 형식으로 변환하려면 &lt;code&gt;macaddr8_set7bit&lt;/code&gt; 과 같이 macaddr8_set7bit 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="31279325b3351a8e4e53dffc8199d39f6d4f7fef" translate="yes" xml:space="preserve">
          <source>These fields do not apply to &lt;code&gt;local&lt;/code&gt; records.</source>
          <target state="translated">These fields do not apply to &lt;code&gt;local&lt;/code&gt; records.</target>
        </trans-unit>
        <trans-unit id="754aea8d14b67db99a02b25bbf6a65624166cf06" translate="yes" xml:space="preserve">
          <source>These fields only apply to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="translated">이 필드는 &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;hostssl&lt;/code&gt; 및 &lt;code&gt;hostnossl&lt;/code&gt; 레코드 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="72eddf11f12dc6025be9e6bc42deb5078bd81869" translate="yes" xml:space="preserve">
          <source>These forms alter the sequence that underlies an existing identity column. &lt;code&gt;sequence_option&lt;/code&gt; is an option supported by &lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCE&lt;/a&gt; such as &lt;code&gt;INCREMENT BY&lt;/code&gt;.</source>
          <target state="translated">이러한 형식은 기존 ID 열의 기본 순서를 변경합니다. &lt;code&gt;sequence_option&lt;/code&gt; 은 &lt;code&gt;INCREMENT BY&lt;/code&gt; 와 같은 &lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCE에서&lt;/a&gt; 지원하는 옵션 입니다.</target>
        </trans-unit>
        <trans-unit id="94eb82c63d8a50cb48f48fc67bdfcbfef03ff87e" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">이러한 양식은 열이 ID 열인지 또는 기존 ID 열의 생성 속성을 변경합니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1bc8e996c262c353a8a23c5058e8d5716c2b27c6" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details. Like &lt;code&gt;SET DEFAULT&lt;/code&gt;, these forms only affect the behavior of subsequent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands; they do not cause rows already in the table to change.</source>
          <target state="translated">이러한 양식은 열이 ID 열인지 여부를 변경하거나 기존 ID 열의 생성 속성을 변경합니다. 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오. &lt;code&gt;SET DEFAULT&lt;/code&gt; 와 마찬가지로 이러한 형식은 후속 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 명령 의 동작에만 영향을줍니다 . 테이블에 이미있는 행이 변경되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e41d9a5a685b55548689fcb598e8403262b9b305" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is marked to allow null values or to reject null values.</source>
          <target state="translated">이러한 형식은 열이 널값을 허용하는지 또는 널값을 거부하도록 표시되는지 여부를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="93ec998a277e66396552c3ff5dd5565fd0687627" translate="yes" xml:space="preserve">
          <source>These forms change whether a domain is marked to allow NULL values or to reject NULL values. You can only &lt;code&gt;SET NOT NULL&lt;/code&gt; when the columns using the domain contain no null values.</source>
          <target state="translated">이러한 형식은 도메인이 NULL 값을 허용하거나 NULL 값을 거부하도록 표시되는지 여부를 변경합니다. 도메인을 사용하는 열에 null 값이없는 경우 에만 &lt;code&gt;SET NOT NULL&lt;/code&gt; 을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6fb1f760d0b7848e70cd0fa414aa5c5a55c2d88" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of event triggers. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. See also &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;.</source>
          <target state="translated">이 양식은 이벤트 트리거 발생을 구성합니다. 비활성화 된 트리거는 여전히 시스템에 알려져 있지만 트리거링 이벤트가 발생할 때 실행되지 않습니다. &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed16a2682c252a84ef2e6b9d1135068b069708b2" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of rewrite rules belonging to the table. A disabled rule is still known to the system, but is not applied during query rewriting. The semantics are as for disabled/enabled triggers. This configuration is ignored for &lt;code&gt;ON SELECT&lt;/code&gt; rules, which are always applied in order to keep views working even if the current session is in a non-default replication role.</source>
          <target state="translated">이 양식은 테이블에 속하는 다시 쓰기 규칙의 실행을 구성합니다. 비활성화 된 규칙은 여전히 ​​시스템에 알려져 있지만 쿼리 재 작성 중에는 적용되지 않습니다. 의미는 비활성화 / 활성화 된 트리거와 같습니다. &lt;code&gt;ON SELECT&lt;/code&gt; 규칙에 대해서는이 구성이 무시됩니다.이 규칙은 현재 세션이 기본 복제 역할이 아닌 경우에도보기가 작동하도록하기 위해 항상 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="78d1881ed192b61ccc8ca5381f7ecf2d5ccbebb4" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the foreign table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">이 형식은 외부 테이블에 속하는 트리거의 발생을 구성합니다. 자세한 내용은 유사한 형식의 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="537c2d5f6bf4afe4d0ece015a719f2c170c94088" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed. One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints). Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed.</source>
          <target state="translated">이 형식은 테이블에 속하는 트리거의 발생을 구성합니다. 비활성화 된 트리거는 여전히 시스템에 알려져 있지만 트리거 이벤트가 발생할 때 실행되지 않습니다. 지연된 트리거의 경우, 트리거 기능이 실제로 실행될 때가 아니라 이벤트가 발생할 때 활성화 상태가 점검됩니다. 이름으로 지정된 단일 트리거 또는 테이블의 모든 트리거 또는 사용자 트리거 만 비활성화하거나 활성화 할 수 있습니다 (이 옵션은 외래 키 제약 조건 또는 지연 가능한 고유성 및 제외 제약 조건을 구현하는 데 사용되는 것과 같은 내부적으로 생성 된 제약 조건 트리거를 제외합니다). 내부적으로 생성 된 제약 조건 트리거를 비활성화하거나 활성화하려면 수퍼 유저 권한이 필요합니다. 물론 트리거가 실행되지 않으면 제약 조건의 무결성을 보장 할 수 없으므로주의해서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e52e37f61e3318ab7cf1d7a034b06767466f19cd" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table when the user is the table owner. If enabled, row level security policies will be applied when the user is the table owner. If disabled (the default) then row level security will not be applied when the user is the table owner. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">이 양식은 사용자가 테이블 소유자 인 경우 테이블에 속하는 행 보안 정책의 적용을 제어합니다. 사용 가능한 경우 사용자가 테이블 소유자 인 경우 행 레벨 보안 정책이 적용됩니다. 비활성화 된 경우 (기본값) 사용자가 테이블 소유자 인 경우 행 수준 보안이 적용되지 않습니다. &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8b1a193cdfbb05ae9fcb8caf7ab280345bebc71" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row level security is disabled - in this case, the policies will NOT be applied and the policies will be ignored. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">이 양식은 테이블에 속하는 행 보안 정책의 적용을 제어합니다. 테이블에 대한 정책이 활성화되어 있지 않으면 기본 거부 정책이 적용됩니다. 행 레벨 보안이 사용 불가능한 경우에도 테이블에 대한 정책이 존재할 수 있습니다.이 경우 정책이 적용되지 않고 정책이 무시됩니다. &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb00f1090b2d9838bfed692cafa4246a07d423cf" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row level security is disabled. In this case, the policies will &lt;em&gt;not&lt;/em&gt; be applied and the policies will be ignored. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">이러한 양식은 테이블에 속하는 행 보안 정책의 적용을 제어합니다. 활성화되고 테이블에 대한 정책이없는 경우 기본 거부 정책이 적용됩니다. 행 수준 보안이 비활성화 된 경우에도 테이블에 대한 정책이 존재할 수 있습니다. 이 경우 정책이 적용 &lt;em&gt;되지 않고&lt;/em&gt; 정책이 무시됩니다. &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6de2d316d42b6299041b7b9b1fe769e5eb9fc501" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column (where removal is equivalent to setting the default value to NULL). The new default value will only apply in subsequent &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands; it does not cause rows already in the table to change.</source>
          <target state="translated">이러한 양식은 열의 기본값을 설정하거나 제거합니다 (제거는 기본값을 NULL로 설정하는 것과 동일 함). 새 기본값은 후속 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 명령 에만 적용됩니다 . 테이블에 이미있는 행이 변경되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9ad545d11775ef6194d67bbd91b31263b043327" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. A view column's default value is substituted into any &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command whose target is the view, before applying any rules or triggers for the view. The view's default will therefore take precedence over any default values from underlying relations.</source>
          <target state="translated">이 양식은 열의 기본값을 설정하거나 제거합니다. 보기 열의 기본값 은보기에 대한 규칙이나 트리거를 적용하기 전에 대상이보기 인 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 명령 으로 대체됩니다 . 따라서 뷰의 기본값은 기본 관계의 기본값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a2f96c4d1ee03fc069f57f93ee22ce31fb12871d" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. Default values only apply in subsequent &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands; they do not cause rows already in the table to change.</source>
          <target state="translated">이 양식은 열의 기본값을 설정하거나 제거합니다. 기본값은 후속 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 명령 에만 적용됩니다 . 이미 테이블에있는 행이 변경되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9f74070b70e1b37c8a8a55a2765bed5bb39ae4b" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a domain. Note that defaults only apply to subsequent &lt;code&gt;INSERT&lt;/code&gt; commands; they do not affect rows already in a table using the domain.</source>
          <target state="translated">이 양식은 도메인의 기본값을 설정하거나 제거합니다. 기본값은 후속 &lt;code&gt;INSERT&lt;/code&gt; 명령 에만 적용됩니다 . 도메인을 사용하는 테이블에 이미있는 행에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c517087178e89eb8504bd404d1b9002cc9225010" translate="yes" xml:space="preserve">
          <source>These functions act like their counterparts described above without the &lt;code&gt;_tz&lt;/code&gt; suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value &lt;code&gt;2015-08-02&lt;/code&gt; as a timestamp with time zone, so the result depends on the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.</source>
          <target state="translated">이러한 함수 는 시간대 인식 변환이 필요한 날짜 / 시간 값의 비교를 지원한다는 점을 제외하고 는 &lt;code&gt;_tz&lt;/code&gt; 접미사 없이 위에서 설명한 해당 함수처럼 작동 합니다. 아래 예에서는 날짜 전용 값 &lt;code&gt;2015-08-02&lt;/code&gt; 를 시간대가있는 타임 스탬프로 해석해야 하므로 결과는 현재 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 설정 에 따라 달라집니다 . 이러한 종속성으로 인해 이러한 함수는 안정적인 것으로 표시되며 이는 이러한 함수를 인덱스에서 사용할 수 없음을 의미합니다. 이들의 대응 항목은 변경 불가능하므로 인덱스에 사용할 수 있습니다. 그러나 그러한 비교를 요청하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1609442aa33410461ce94595a5363c37f09493d1" translate="yes" xml:space="preserve">
          <source>These functions are provided mostly for illustration purposes. You can create your own return types and functions based on the underlying &lt;code&gt;crosstab()&lt;/code&gt; function. There are two ways to do it:</source>
          <target state="translated">이러한 기능은 주로 설명을 위해 제공됩니다. 기본 &lt;code&gt;crosstab()&lt;/code&gt; 함수를 기반으로 고유 한 리턴 유형 및 함수를 작성할 수 있습니다 . 이를 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71ab786c550ccb22b4bc0a42b2b14940119395f" translate="yes" xml:space="preserve">
          <source>These functions check whether a &lt;code&gt;text&lt;/code&gt; string is well-formed XML, returning a Boolean result. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; checks for a well-formed document, while &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; checks for well-formed content. &lt;code&gt;xml_is_well_formed&lt;/code&gt; does the former if the &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; configuration parameter is set to &lt;code&gt;DOCUMENT&lt;/code&gt;, or the latter if it is set to &lt;code&gt;CONTENT&lt;/code&gt;. This means that &lt;code&gt;xml_is_well_formed&lt;/code&gt; is useful for seeing whether a simple cast to type &lt;code&gt;xml&lt;/code&gt; will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of &lt;code&gt;XMLPARSE&lt;/code&gt; will succeed.</source>
          <target state="translated">이 함수는 &lt;code&gt;text&lt;/code&gt; 문자열이 올바른 형식의 XML 인지 확인 하여 부울 결과를 반환합니다. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; 는 올바른 형식의 문서를 확인 하고 &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; 는 올바른 형식의 콘텐츠를 확인합니다. &lt;code&gt;xml_is_well_formed&lt;/code&gt; 이 경우 생성 전을 수행 &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption의&lt;/a&gt; 설정 파라미터가 설정되어 &lt;code&gt;DOCUMENT&lt;/code&gt; 가 설정되어 있으면, 후자 &lt;code&gt;CONTENT&lt;/code&gt; . 이는 &lt;code&gt;xml_is_well_formed&lt;/code&gt; 가 &lt;code&gt;xml&lt;/code&gt; 유형으로의 간단한 캐스트 성공 여부를 확인하는 데 유용하고 다른 두 함수는 해당 &lt;code&gt;XMLPARSE&lt;/code&gt; 변형 이 성공 하는지 여부를 확인하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="1992890b76b79219185f1f21ec736953dc79e0bb" translate="yes" xml:space="preserve">
          <source>These functions check whether a &lt;code&gt;text&lt;/code&gt; string represents well-formed XML, returning a Boolean result. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; checks for a well-formed document, while &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; checks for well-formed content. &lt;code&gt;xml_is_well_formed&lt;/code&gt; does the former if the &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; configuration parameter is set to &lt;code&gt;DOCUMENT&lt;/code&gt;, or the latter if it is set to &lt;code&gt;CONTENT&lt;/code&gt;. This means that &lt;code&gt;xml_is_well_formed&lt;/code&gt; is useful for seeing whether a simple cast to type &lt;code&gt;xml&lt;/code&gt; will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of &lt;code&gt;XMLPARSE&lt;/code&gt; will succeed.</source>
          <target state="translated">이러한 함수는 &lt;code&gt;text&lt;/code&gt; 문자열이 올바른 형식의 XML을 나타내는 지 확인 하여 부울 결과를 반환합니다. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; 는 올바른 형식의 문서를 확인 하고 &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; 는 올바른 형식의 콘텐츠를 확인합니다. &lt;code&gt;xml_is_well_formed&lt;/code&gt; 는 &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; 구성 매개 변수가 &lt;code&gt;DOCUMENT&lt;/code&gt; 로 설정된 경우 전자를 수행하고 &lt;code&gt;CONTENT&lt;/code&gt; 로 설정된 경우 후자를 수행합니다 . 즉, &lt;code&gt;xml_is_well_formed&lt;/code&gt; 는 &lt;code&gt;xml&lt;/code&gt; 유형으로의 단순 캐스트 가 성공할지 여부를 확인하는 데 유용하지만 다른 두 함수는 &lt;code&gt;XMLPARSE&lt;/code&gt; 의 해당 변형 이 성공 할지 여부를 확인하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="c60a18e52593260f76cbca36e7fdad5953d14de4" translate="yes" xml:space="preserve">
          <source>These functions evaluate the XPath query on the supplied document, and cast the result to the specified type.</source>
          <target state="translated">이 함수는 제공된 문서에서 XPath 조회를 평가하고 결과를 지정된 유형으로 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="b4542e502e3568b9c387481842c5701029f5b7b1" translate="yes" xml:space="preserve">
          <source>These functions ignore tables that are not readable by the current user. The database-wide functions additionally ignore schemas that the current user does not have &lt;code&gt;USAGE&lt;/code&gt; (lookup) privilege for.</source>
          <target state="translated">이러한 함수는 현재 사용자가 읽을 수없는 테이블을 무시합니다. 데이터베이스 전체 함수는 현재 사용자에게 &lt;code&gt;USAGE&lt;/code&gt; (조회) 권한 이없는 스키마를 추가로 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="f4a3b49c368c625ddd8e1b267d172c4c23e85fb8" translate="yes" xml:space="preserve">
          <source>These functions only run a cipher over data; they don't have any advanced features of PGP encryption. Therefore they have some major problems:</source>
          <target state="translated">이 함수는 데이터에 대해서만 암호를 실행합니다. PGP 암호화의 고급 기능이 없습니다. 따라서 몇 가지 중요한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e87e18038a41ce286dc1540ea6ddc6645f709cb" translate="yes" xml:space="preserve">
          <source>These functions wrap/unwrap binary data into PGP ASCII-armor format, which is basically Base64 with CRC and additional formatting.</source>
          <target state="translated">이 함수는 바이너리 데이터를 PGP ASCII-armor 형식으로 랩 / 랩핑 해제합니다. 기본적으로 CRC 및 추가 형식이있는 Base64입니다.</target>
        </trans-unit>
        <trans-unit id="a69e2cf20fe43ca97cfd2d3152291de2a47cffbd" translate="yes" xml:space="preserve">
          <source>These instructions assume that your existing installation is under the &lt;code&gt;/usr/local/pgsql&lt;/code&gt; directory, and that the data area is in &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;. Substitute your paths appropriately.</source>
          <target state="translated">이 지시 사항은 기존 설치가 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; 디렉토리에 있고 데이터 영역이 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 에 있다고 가정합니다 . 당신의 경로를 적절하게 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="4c32652f01e68dc2b9e4e1795da20ec44b710efa" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on casts.</source>
          <target state="translated">캐스트에 대한 종속성이 없으므로이 키워드는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bea3c1233d30126b2b7a88c0987f5eda6383c5d4" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on conversions.</source>
          <target state="translated">이러한 키워드는 전환에 대한 종속성이 없으므로 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fd011ed971053a775e55c8199ea3272eca8d26f" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on policies.</source>
          <target state="translated">이 키워드는 정책에 대한 종속성이 없으므로 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6e707f7bc3e009a0e21e941c667a8cfc394f561" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on publications.</source>
          <target state="translated">이 키워드는 출판물에 의존하지 않기 때문에 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32c4da55bd25afdbc9c41ed6381881695d3bb025" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on subscriptions.</source>
          <target state="translated">구독에 대한 종속성이 없기 때문에 이러한 키워드는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c7609a430b2441baa8c916ed20ac5c190ce5d75" translate="yes" xml:space="preserve">
          <source>These messages are harmless and should be ignored.</source>
          <target state="translated">이 메시지는 무해하며 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c905ac1adcf65ee4d503774195629e18e03ce45" translate="yes" xml:space="preserve">
          <source>These numbers are current as of the last &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; on the table. The planner then fetches the actual current number of pages in the table (this is a cheap operation, not requiring a table scan). If that is different from &lt;code&gt;relpages&lt;/code&gt; then &lt;code&gt;reltuples&lt;/code&gt; is scaled accordingly to arrive at a current number-of-rows estimate. In the example above, the value of &lt;code&gt;relpages&lt;/code&gt; is up-to-date so the rows estimate is the same as &lt;code&gt;reltuples&lt;/code&gt;.</source>
          <target state="translated">이 숫자는 테이블 의 마지막 &lt;code&gt;VACUUM&lt;/code&gt; 또는 &lt;code&gt;ANALYZE&lt;/code&gt; 기준 으로 최신 입니다. 그런 다음 플래너는 테이블에서 실제 현재 페이지 수를 페치합니다 (테이블 스캔이 필요없는 저렴한 조작입니다). 즉, 다른 경우 &lt;code&gt;relpages&lt;/code&gt; 다음 &lt;code&gt;reltuples&lt;/code&gt; 전류 번호 오브 행 추정치에 도달하도록 적절히 스케일링된다. 위의 예에서 &lt;code&gt;relpages&lt;/code&gt; 값은 최신이므로 행 추정값은 &lt;code&gt;reltuples&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e10d3fa9498e1464949f282d6e93d894677beaed" translate="yes" xml:space="preserve">
          <source>These numbers are derived very straightforwardly. If you do:</source>
          <target state="translated">이 숫자는 매우 간단합니다. 당신이 할 경우 :</target>
        </trans-unit>
        <trans-unit id="3ceb62071b97b9d98e29565b51240d61862b6aa6" translate="yes" xml:space="preserve">
          <source>These operations are also possible using &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. &lt;code&gt;ALTER INDEX&lt;/code&gt; is in fact just an alias for the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that apply to indexes.</source>
          <target state="translated">이러한 작업은 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE을&lt;/a&gt; 사용하여 가능합니다 . &lt;code&gt;ALTER INDEX&lt;/code&gt; 는 실제로 인덱스에 적용되는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="545a0c8a716c900f9e4c80a9d1bee182bedf1b50" translate="yes" xml:space="preserve">
          <source>These operations are not as efficient as the SQL &lt;code&gt;COPY&lt;/code&gt; command with a file or program data source or destination, because all data must pass through the client/server connection. For large amounts of data the SQL command might be preferable.</source>
          <target state="translated">모든 데이터가 클라이언트 / 서버 연결을 통과해야하기 때문에 파일이나 프로그램 데이터 소스 또는 대상이 있는 SQL &lt;code&gt;COPY&lt;/code&gt; 명령 만큼 효율적이지 않습니다 . 많은 양의 데이터의 경우 SQL 명령이 선호 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="127d5c1d5ec611dd1c5cea591e059868fdcde0f9" translate="yes" xml:space="preserve">
          <source>These operators do not make a lot of sense for any practical purpose but sorting. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="translated">이 연산자는 실용적인 목적이 아니라 정렬에 많은 의미가 있습니다. 이 연산자는 먼저 (a)와 (c)를 비교하고, 같으면 (b)와 (d)를 비교하십시오. 따라서 대부분의 경우 합리적으로 정렬이 좋으며 ORDER BY를이 유형과 함께 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0263a47917171f02351f77d8e8b63fd3b27641de" translate="yes" xml:space="preserve">
          <source>These option names are recognized case-insensitively. Any unspecified options receive these defaults:</source>
          <target state="translated">이 옵션 이름은 대소 문자를 구분하지 않습니다. 지정되지 않은 옵션은 다음 기본값을받습니다.</target>
        </trans-unit>
        <trans-unit id="97b00e5b641f2fbb1f110712d8ca4d9e2d1eb19a" translate="yes" xml:space="preserve">
          <source>These option names are recognized case-insensitively. You must double-quote string values if they contain spaces or commas.</source>
          <target state="translated">이러한 옵션 이름은 대소 문자를 구분하지 않습니다. 공백이나 쉼표가 포함 된 경우 문자열 값을 큰 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="aae23616e05cfe7a713aa38934f0f1dc39a127ad" translate="yes" xml:space="preserve">
          <source>These options can be used to control the names used in SQL statements sent to the remote PostgreSQL server. These options are needed when a foreign table is created with names different from the underlying remote table's names.</source>
          <target state="translated">이 옵션은 원격 PostgreSQL 서버로 전송되는 SQL 문에 사용되는 이름을 제어하는 ​​데 사용할 수 있습니다. 이 옵션은 기본 원격 테이블 이름과 다른 이름으로 외부 테이블을 만들 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d77fba085883250197e1d576feb3bfa1670ceb86" translate="yes" xml:space="preserve">
          <source>These options can only be specified for a foreign table or its columns, not in the options of the &lt;code&gt;file_fdw&lt;/code&gt; foreign-data wrapper, nor in the options of a server or user mapping using the wrapper.</source>
          <target state="translated">이러한 옵션은 &lt;code&gt;file_fdw&lt;/code&gt; 외부 데이터 랩퍼 옵션이나 랩퍼를 사용하는 서버 또는 사용자 맵핑 옵션이 아닌 외부 테이블 또는 해당 컬럼에 대해서만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00c89bc3ee002172b7e73344d78285229be1f391" translate="yes" xml:space="preserve">
          <source>These parameters (except the XPath strings) are just substituted into a plain SQL SELECT statement, so you have some flexibility &amp;mdash; the statement is</source>
          <target state="translated">이러한 매개 변수 (XPath 문자열 제외)는 일반 SQL SELECT 문으로 대체되므로 유연성이 있습니다. 명령문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2aabd8f5a3412d7716945926dce543c9d86d614" translate="yes" xml:space="preserve">
          <source>These parameters can be set on any server that is to send replication data to one or more standby servers. The master is always a sending server, so these parameters must always be set on the master. The role and meaning of these parameters does not change after a standby becomes the master.</source>
          <target state="translated">이 매개 변수는 하나 이상의 대기 서버로 복제 데이터를 보내는 서버에서 설정할 수 있습니다. 마스터는 항상 보내는 서버이므로 이러한 매개 변수는 항상 마스터에서 설정해야합니다. 이러한 매개 변수의 역할과 의미는 대기가 마스터가 된 후에 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c34294a4db205be8e19649f7f900fbda851ca14" translate="yes" xml:space="preserve">
          <source>These parameters can be set on the master/primary server that is to send replication data to one or more standby servers. Note that in addition to these parameters, &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; must be set appropriately on the master server, and optionally WAL archiving can be enabled as well (see &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;Section 19.5.3&lt;/a&gt;). The values of these parameters on standby servers are irrelevant, although you may wish to set them there in preparation for the possibility of a standby becoming the master.</source>
          <target state="translated">이 매개 변수는 하나 이상의 대기 서버로 복제 데이터를 보내는 마스터 / 기본 서버에서 설정할 수 있습니다. 이 매개 변수 외에도 &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level을&lt;/a&gt; 마스터 서버에서 적절하게 설정 해야하며 선택적으로 WAL 아카이브도 사용할 수 있습니다 ( &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;섹션 19.5.3&lt;/a&gt; 참조 ). 대기 서버에서 이러한 매개 변수의 값은 관련이 없지만 대기가 마스터가 될 가능성을 준비하기 위해이를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d75398d82f486d5c040810e5532c3a355a6c99c" translate="yes" xml:space="preserve">
          <source>These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the &lt;code&gt;pg_stat&lt;/code&gt; and &lt;code&gt;pg_statio&lt;/code&gt; family of system views. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt; for more information.</source>
          <target state="translated">이 매개 변수는 서버 전체 통계 수집 기능을 제어합니다. 통계 수집이 활성화되면 생성 된 데이터는 &lt;code&gt;pg_stat&lt;/code&gt; 및 &lt;code&gt;pg_statio&lt;/code&gt; 시스템 뷰 제품군을 통해 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;27 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d575b835ad7e47410bdf9d6f66f26ab665d0047" translate="yes" xml:space="preserve">
          <source>These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the &lt;code&gt;pg_stat&lt;/code&gt; and &lt;code&gt;pg_statio&lt;/code&gt; family of system views. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt; for more information.</source>
          <target state="translated">이러한 매개 변수는 서버 전체의 통계 수집 기능을 제어합니다. 통계 수집이 활성화되면 생성 된 데이터 는 시스템 뷰 의 &lt;code&gt;pg_stat&lt;/code&gt; 및 &lt;code&gt;pg_statio&lt;/code&gt; 제품군을 통해 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/monitoring.html&quot;&gt;27 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7058fa11283b8e308dc5c38fd60ebf25607e531" translate="yes" xml:space="preserve">
          <source>These parameters enable various debugging output to be emitted. When set, they print the resulting parse tree, the query rewriter output, or the execution plan for each executed query. These messages are emitted at &lt;code&gt;LOG&lt;/code&gt; message level, so by default they will appear in the server log but will not be sent to the client. You can change that by adjusting &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; and/or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;. These parameters are off by default.</source>
          <target state="translated">이 파라미터는 다양한 디버깅 출력을 내 보냅니다. 설정되면 결과 구문 분석 트리, 쿼리 재 작성기 출력 또는 실행 된 각 쿼리에 대한 실행 계획을 인쇄합니다. 이러한 메시지는 &lt;code&gt;LOG&lt;/code&gt; 메시지 레벨에서 생성되므로 기본적으로 서버 로그에 표시되지만 클라이언트로 전송되지는 않습니다. &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; 및 / 또는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages를&lt;/a&gt; 조정하여이를 변경할 수 있습니다 . 이 매개 변수는 기본적으로 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1defee4ea46ba6aaadce70e43d5781b50b0c40a2" translate="yes" xml:space="preserve">
          <source>These parameters must be set in &lt;code&gt;postgresql.conf&lt;/code&gt;. Typical usage might be:</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정해야합니다 . 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51c50b20efcdf41bd58d1a6d4948e28cfd164232" translate="yes" xml:space="preserve">
          <source>These popular data structures were originally developed for in-memory usage. In main memory, they are usually designed as a set of dynamically allocated nodes linked by pointers. This is not suitable for direct storing on disk, since these chains of pointers can be rather long which would require too many disk accesses. In contrast, disk-based data structures should have a high fanout to minimize I/O. The challenge addressed by SP-GiST is to map search tree nodes to disk pages in such a way that a search need access only a few disk pages, even if it traverses many nodes.</source>
          <target state="translated">이러한 대중적인 데이터 구조는 원래 메모리 내 사용을 위해 개발되었습니다. 기본 메모리에서 이들은 일반적으로 포인터로 연결된 동적 할당 노드 세트로 설계됩니다. 이러한 포인터 체인은 너무 길어 디스크 액세스가 너무 많이 필요할 수 있으므로 디스크에 직접 저장하는 데 적합하지 않습니다. 반대로 디스크 기반 데이터 구조는 I / O를 최소화하기 위해 팬 아웃이 높아야합니다. SP-GiST가 해결해야 할 과제는 검색 트리 노드가 디스크 페이지에 매핑되어 검색이 많은 노드를 통과하더라도 몇 개의 디스크 페이지에만 액세스 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="929fc5ec9668da12721d514b3f6bf4c331845b00" translate="yes" xml:space="preserve">
          <source>These represent the IEEE 754 special values &amp;ldquo;infinity&amp;rdquo;, &amp;ldquo;negative infinity&amp;rdquo;, and &amp;ldquo;not-a-number&amp;rdquo;, respectively. When writing these values as constants in an SQL command, you must put quotes around them, for example &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt;. On input, these strings are recognized in a case-insensitive manner.</source>
          <target state="translated">이들은 각각 IEEE 754 특수 값&amp;ldquo;무한대&amp;rdquo;,&amp;ldquo;음의 무한대&amp;rdquo;및&amp;ldquo;숫자가 아님&amp;rdquo;을 나타냅니다. SQL 명령에서 이러한 값을 상수로 쓸 때는 &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt; 와 같이 따옴표를 묶어야합니다 . 입력시 이러한 문자열은 대소 문자를 구분하지 않고 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="f1107e48978793d7f588abce7216f17e213bc711" translate="yes" xml:space="preserve">
          <source>These rules are very similar to those for writing field values in composite-type literals. See &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;Section 8.16.6&lt;/a&gt; for additional commentary.</source>
          <target state="translated">이 규칙은 복합 유형 리터럴로 필드 값을 쓰는 규칙과 매우 유사합니다. 추가 설명 &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;은 8.16.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f4ab75f18b56a1736b944ffdb026f1b2a9cc643" translate="yes" xml:space="preserve">
          <source>These semaphore-related settings are read-only as far as &lt;code&gt;sysctl&lt;/code&gt; is concerned, but can be set in &lt;code&gt;/boot/loader.conf&lt;/code&gt;:</source>
          <target state="translated">이 세마포어 관련 설정은 &lt;code&gt;sysctl&lt;/code&gt; 에 관한 한 읽기 전용 이지만 &lt;code&gt;/boot/loader.conf&lt;/code&gt; 에서 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0eb1c6b354c2721dc2500c187dae9d22e4b37ec" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command. Any user is allowed to change their session-local value. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">이러한 설정은 &lt;code&gt;postgresql.conf&lt;/code&gt; 또는 &lt;code&gt;SET&lt;/code&gt; 명령을 통해 세션 내 에서 설정할 수 있습니다 . 모든 사용자는 세션 로컬 값을 변경할 수 있습니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 의 변경 사항은 &lt;code&gt;SET&lt;/code&gt; 로 세션 로컬 값이 설정되지 않은 경우에만 기존 세션에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="0adef7245cebc3b52bd4dfc1694701eadaec06f1" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command; but only superusers can change them via &lt;code&gt;SET&lt;/code&gt;. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">이 설정은 &lt;code&gt;postgresql.conf&lt;/code&gt; 또는 &lt;code&gt;SET&lt;/code&gt; 명령을 통해 세션 내 에서 설정할 수 있습니다 . 그러나 수퍼 유저 만 &lt;code&gt;SET&lt;/code&gt; 을 통해 변경할 수 있습니다 . &lt;code&gt;postgresql.conf&lt;/code&gt; 의 변경 사항은 &lt;code&gt;SET&lt;/code&gt; 로 세션 로컬 값이 설정되지 않은 경우에만 기존 세션에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="7a83e5497c48f3fadb734c9a42de145288252b14" translate="yes" xml:space="preserve">
          <source>These settings can only be applied when the server starts, so any change requires restarting the server. Values for these settings are typically stored in the &lt;code&gt;postgresql.conf&lt;/code&gt; file, or passed on the command line when starting the server. Of course, settings with any of the lower &lt;code&gt;context&lt;/code&gt; types can also be set at server start time.</source>
          <target state="translated">이 설정은 서버가 시작될 때만 적용 할 수 있으므로 변경하면 서버를 다시 시작해야합니다. 이러한 설정 값은 일반적으로 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일에 저장 되거나 서버를 시작할 때 명령 줄에 전달됩니다. 물론 낮은 &lt;code&gt;context&lt;/code&gt; 유형을 가진 설정은 서버 시작시 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02aa5756831dee127ec65944b5fa10a7b3de8a8e" translate="yes" xml:space="preserve">
          <source>These settings cannot be changed directly; they reflect internally determined values. Some of them may be adjustable by rebuilding the server with different configuration options, or by changing options supplied to &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">이 설정은 직접 변경할 수 없습니다. 내부적으로 결정된 값을 반영합니다. 이들 중 일부는 다른 구성 옵션으로 서버를 재 구축하거나 &lt;code&gt;initdb&lt;/code&gt; 에 제공된 옵션을 변경하여 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="317e80ee1851e3545ba5ed374350ee15698895fc" translate="yes" xml:space="preserve">
          <source>These settings control how process titles of server processes are modified. Process titles are typically viewed using programs like ps or, on Windows, Process Explorer. See &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details.</source>
          <target state="translated">이 설정은 서버 프로세스의 프로세스 제목을 수정하는 방법을 제어합니다. 프로세스 제목은 일반적으로 ps와 같은 프로그램이나 Windows의 프로세스 탐색기를 사용하여 볼 수 있습니다. 자세한 내용 &lt;a href=&quot;monitoring-ps&quot;&gt;은 27.1 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c21f5b22d74359b34a233de933da88c1556b1754" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a logical replication subscriber. Their values on the publisher are irrelevant.</source>
          <target state="translated">이 설정은 논리적 복제 가입자의 동작을 제어합니다. 출판사에 대한 그들의 가치는 무관합니다.</target>
        </trans-unit>
        <trans-unit id="51ac309dd49de1c6d6c04c1c54a256fdaeb98b75" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a standby server that is to receive replication data. Their values on the master server are irrelevant.</source>
          <target state="translated">이 설정은 복제 데이터를 수신 할 대기 서버의 동작을 제어합니다. 마스터 서버의 값은 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d40b8d037fb02f22e279e00bffd1ef98f7d8c44d" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the &lt;em&gt;autovacuum&lt;/em&gt; feature. Refer to &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. Note that many of these settings can be overridden on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt;.</source>
          <target state="translated">이 설정은 자동 &lt;em&gt;진공&lt;/em&gt; 기능 의 동작을 제어합니다 . 자세한 정보는 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;24.1.6 절&lt;/a&gt; 을 참조하십시오. 이러한 설정 중 다수는 테이블별로 재정의 될 수 있습니다. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;스토리지 매개 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c9c05e7e68e0c9931d3c483fab276d6098720bf" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the built-in &lt;em&gt;streaming replication&lt;/em&gt; feature (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). Servers will be either a master or a standby server. Masters can send data, while standbys are always receivers of replicated data. When cascading replication (see &lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;Section 26.2.7&lt;/a&gt;) is used, standby servers can also be senders, as well as receivers. Parameters are mainly for sending and standby servers, though some parameters have meaning only on the master server. Settings may vary across the cluster without problems if that is required.</source>
          <target state="translated">이 설정은 내장 &lt;em&gt;스트리밍 복제&lt;/em&gt; 기능 의 동작을 제어합니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;26.2.5 절&lt;/a&gt; 참조 ). 서버는 마스터 또는 대기 서버입니다. 마스터는 데이터를 전송할 수 있지만 대기는 항상 복제 된 데이터의 수신자입니다. 계단식 복제 ( &lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;26.2.7&lt;/a&gt; 참조 )를 사용하는 경우 대기 서버는 수신자는 물론 발신자 일 수도 있습니다. 매개 변수는 주로 송신 및 대기 서버용이지만 일부 매개 변수는 마스터 서버에서만 의미가 있습니다. 필요한 경우 클러스터에 따라 설정이 문제없이 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="631081e51e8d0c56dfb2edd79daea765216e4764" translate="yes" xml:space="preserve">
          <source>These settings will cause postmaster child processes to run with the normal OOM score adjustment of zero, so that the OOM killer can still target them at need. You could use some other value for &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; if you want the child processes to run with some other OOM score adjustment. (&lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; can also be omitted, in which case it defaults to zero.) If you do not set &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt;, the child processes will run with the same OOM score adjustment as the postmaster, which is unwise since the whole point is to ensure that the postmaster has a preferential setting.</source>
          <target state="translated">이러한 설정은 포스트 마스터 하위 프로세스가 정상적인 OOM 점수 조정 0으로 실행되도록하여 OOM 킬러가 필요할 때이를 대상으로 할 수 있도록합니다. 하위 프로세스를 다른 OOM 점수 조정으로 실행하려면 &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; 에 다른 값을 사용할 수 있습니다 . ( &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; 는 생략 할 수 있으며,이 경우 기본값은 0입니다.) &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt; 을 설정하지 않으면 하위 프로세스는 포스트 마스터와 동일한 OOM 점수 조정으로 실행됩니다. 포스트 마스터는 우선적으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8ab15e9b47def86730e35b3c5c50e0dfe3f834aa" translate="yes" xml:space="preserve">
          <source>These specify what the prompts psql issues should look like. See &lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;Prompting&lt;/a&gt; below.</source>
          <target state="translated">이것들은 psql 이슈가 어떤 프롬프트를 보여줄지를 지정합니다. 아래의 &lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;프롬프트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6086ed3e7f06eab1a2070198d662f5b66b1e6406" translate="yes" xml:space="preserve">
          <source>These trigger functions automatically compute a &lt;code&gt;tsvector&lt;/code&gt; column from one or more textual columns, under the control of parameters specified in the &lt;code&gt;CREATE TRIGGER&lt;/code&gt; command. An example of their use is:</source>
          <target state="translated">이 트리거 함수 는 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 명령에 지정된 매개 변수의 제어하에 하나 이상의 텍스트 열에서 &lt;code&gt;tsvector&lt;/code&gt; 열을 자동으로 계산합니다 . 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26b286f322440c12ea3e3c031f3d293b77ba6582" translate="yes" xml:space="preserve">
          <source>These two fields can be used as an alternative to the &lt;code&gt;IP-address&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;mask-length&lt;/code&gt; notation. Instead of specifying the mask length, the actual mask is specified in a separate column. For example, &lt;code&gt;255.0.0.0&lt;/code&gt; represents an IPv4 CIDR mask length of 8, and &lt;code&gt;255.255.255.255&lt;/code&gt; represents a CIDR mask length of 32.</source>
          <target state="translated">이 두 필드는 &lt;code&gt;IP-address&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;mask-length&lt;/code&gt; 표기법 의 대안으로 사용될 수 있습니다 . 마스크 길이를 지정하는 대신 실제 마스크는 별도의 열에 지정됩니다. 예를 들어, &lt;code&gt;255.0.0.0&lt;/code&gt; 은 IPv4 CIDR 마스크 길이 8을 나타내고 &lt;code&gt;255.255.255.255&lt;/code&gt; 는 CIDR 마스크 길이 32를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b912ce7211a3c9dfe25f2009d32879c2b4a7718a" translate="yes" xml:space="preserve">
          <source>These variables are set at program start-up to reflect psql's version, respectively as a verbose string, a short string (e.g., &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt;, or &lt;code&gt;11beta1&lt;/code&gt;), and a number (e.g., &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;). They can be changed or unset.</source>
          <target state="translated">이러한 변수는 프로그램 시작시 psql 버전을 각각 상세 문자열, 짧은 문자열 (예 : &lt;code&gt;9.6.2&lt;/code&gt; , &lt;code&gt;10.1&lt;/code&gt; 또는 &lt;code&gt;11beta1&lt;/code&gt; ) 및 숫자 (예 : &lt;code&gt;90602&lt;/code&gt; 또는 &lt;code&gt;100001&lt;/code&gt; )로 반영하도록 설정됩니다. 변경하거나 설정을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1888af9231d7dc7892d920d2796a7d30d3c432b" translate="yes" xml:space="preserve">
          <source>These will always return true or false, never a null value, even when the operand is null. A null input is treated as the logical value &amp;ldquo;unknown&amp;rdquo;. Notice that &lt;code&gt;IS UNKNOWN&lt;/code&gt; and &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; are effectively the same as &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt;, respectively, except that the input expression must be of Boolean type.</source>
          <target state="translated">피연산자가 null 인 경우에도 항상 true 또는 false를 반환하며 null 값은 반환하지 않습니다. 널 입력은 논리 값&amp;ldquo;알 수 없음&amp;rdquo;으로 취급됩니다. 알 &lt;code&gt;IS UNKNOWN&lt;/code&gt; 및 &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; 이 효과적으로 동일하다 &lt;code&gt;IS NULL&lt;/code&gt; 과 &lt;code&gt;IS NOT NULL&lt;/code&gt; 입력 식 부울 타입이어야하는 것을 제외하고, 각각.</target>
        </trans-unit>
        <trans-unit id="eb77a6f9b66e9a05805238727dad27ac972c149a" translate="yes" xml:space="preserve">
          <source>They are slow. As the amount of data is so small, this is the only way to make brute-forcing passwords hard.</source>
          <target state="translated">그들은 느리다. 데이터 양이 너무 적기 때문에 이것이 무차별 암호를 단단하게 만드는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="bf2c8c3d26564b271cd3b0f3cc01f4bc594ad56e" translate="yes" xml:space="preserve">
          <source>They don't handle text.</source>
          <target state="translated">그들은 텍스트를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89bd6007244204d4a23986add99e11b8144bb68e" translate="yes" xml:space="preserve">
          <source>They don't provide any integrity checking, to see if the encrypted data was modified.</source>
          <target state="translated">암호화 된 데이터가 수정되었는지 확인하기 위해 무결성 검사를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="108af784f0fd778d605e66d5a415819131da0024" translate="yes" xml:space="preserve">
          <source>They expect that users manage all encryption parameters themselves, even IV.</source>
          <target state="translated">그들은 사용자가 IV를 포함한 모든 암호화 매개 변수를 스스로 관리 할 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="0c2039617625e55d628a5303153737be520c2636" translate="yes" xml:space="preserve">
          <source>They include the algorithm type in the result, so passwords hashed with different algorithms can co-exist.</source>
          <target state="translated">결과에 알고리즘 유형이 포함되므로 다른 알고리즘으로 해시 된 비밀번호가 공존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e7dceb3b44e3013034907236242ebd62f58f0d" translate="yes" xml:space="preserve">
          <source>They provide no ordering (ranking) of search results, which makes them ineffective when thousands of matching documents are found.</source>
          <target state="translated">검색 결과의 순서 (순위)를 제공하지 않으므로 수천 개의 일치하는 문서를 찾을 때 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c267279c3829425820b5af53bc51b1aea00680d" translate="yes" xml:space="preserve">
          <source>They tend to be slow because there is no index support, so they must process all documents for every search.</source>
          <target state="translated">색인 지원이 없기 때문에 속도가 느리므로 모든 검색에 대해 모든 문서를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc6b695f1b5d50d9c60b39def6c93072e73b0c7c" translate="yes" xml:space="preserve">
          <source>They use a random value, called the &lt;em&gt;salt&lt;/em&gt;, so that users having the same password will have different encrypted passwords. This is also an additional defense against reversing the algorithm.</source>
          <target state="translated">그들은 &lt;em&gt;salt&lt;/em&gt; 라는 임의의 값을 사용 하므로 동일한 비밀번호를 가진 사용자는 다른 암호화 된 비밀번호를 갖습니다. 이것은 또한 알고리즘 반전에 대한 추가 방어입니다.</target>
        </trans-unit>
        <trans-unit id="e85a3bee9adadb9e25e77dec1600e19104320bfe" translate="yes" xml:space="preserve">
          <source>They use user key directly as cipher key.</source>
          <target state="translated">사용자 키를 암호 키로 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8dbebd5ef75455c0a62f167f8fa030487ae4ceab" translate="yes" xml:space="preserve">
          <source>Things are more difficult if you need to recover from corruption of an index on a system table. In this case it's important for the system to not have used any of the suspect indexes itself. (Indeed, in this sort of scenario you might find that server processes are crashing immediately at start-up, due to reliance on the corrupted indexes.) To recover safely, the server must be started with the &lt;code&gt;-P&lt;/code&gt; option, which prevents it from using indexes for system catalog lookups.</source>
          <target state="translated">시스템 테이블의 인덱스 손상으로부터 복구해야하는 경우 상황이 더 어려워집니다. 이 경우 시스템이 의심스러운 인덱스 자체를 사용하지 않는 것이 중요합니다. 실제로 이러한 종류의 시나리오에서는 손상된 인덱스에 의존하여 시작시 서버 프로세스가 즉시 중단 될 수 있습니다. 안전하게 복구하려면 서버를 &lt;code&gt;-P&lt;/code&gt; 옵션 으로 시작해야합니다. 시스템 카탈로그 조회에 색인 사용</target>
        </trans-unit>
        <trans-unit id="96f7dee4533ea61962d64e3ad5a7fcf16ccab0dd" translate="yes" xml:space="preserve">
          <source>Third, turn on &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt;. For security reasons, the rules in &lt;code&gt;sepgsql-regtest&lt;/code&gt; are not enabled by default; the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter enables the rules needed to launch the regression tests. It can be turned on using the &lt;code&gt;setsebool&lt;/code&gt; command:</source>
          <target state="translated">세 번째로 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; 를 켜 십시오 . 보안상의 이유로 &lt;code&gt;sepgsql-regtest&lt;/code&gt; 의 규칙은 기본적으로 활성화되어 있지 않습니다. &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; 의 매개 변수는 회귀 테스트를 실행하는 데 필요한 규칙을 할 수 있습니다. &lt;code&gt;setsebool&lt;/code&gt; 명령 을 사용하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8a4d63f55e2492f2cd42b3a9fb86caa1ca5e84c" translate="yes" xml:space="preserve">
          <source>Third-party applications can be put into separate schemas so they do not collide with the names of other objects.</source>
          <target state="translated">타사 응용 프로그램은 별도의 스키마에 넣어 다른 개체의 이름과 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04297a9823a3a2086d546b9d671ec1f8ab29f655" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;WITH&lt;/code&gt; query will be folded, producing the same execution plan as</source>
          <target state="translated">이 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 접혀서 동일한 실행 계획을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="14ca478547dc2e8fab1f8f6bfce576b001fe2285" translate="yes" xml:space="preserve">
          <source>This access control mechanism is independent of the one described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;.</source>
          <target state="translated">이 액세스 제어 메커니즘은 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 에서 설명 된 것과 독립적입니다 .</target>
        </trans-unit>
        <trans-unit id="b5d11934ea2252677e8bf50febe72c8f70679b90" translate="yes" xml:space="preserve">
          <source>This access control mechanism is independent of the one described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;.</source>
          <target state="translated">이 액세스 제어 메커니즘은 &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;20 장에&lt;/a&gt; 설명 된 메커니즘과 독립적입니다 .</target>
        </trans-unit>
        <trans-unit id="4c7fa7bd259660d0cb8e1608dc878af198c41a3a" translate="yes" xml:space="preserve">
          <source>This acquires a row-level lock on the row with the specified account number. Then, the second transaction executes:</source>
          <target state="translated">지정된 계정 번호로 행의 행 레벨 잠금을 얻습니다. 그런 다음 두 번째 트랜잭션이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5cf940ef6c18dd4ff1a92a3955dc9c9d23c16666" translate="yes" xml:space="preserve">
          <source>This allows further operations to be performed on the data before it is dropped. For example, this is often a useful time to back up the data using &lt;code&gt;COPY&lt;/code&gt;, pg_dump, or similar tools. It might also be a useful time to aggregate data into smaller formats, perform other data manipulations, or run reports.</source>
          <target state="translated">이를 통해 데이터를 삭제하기 전에 추가 작업을 수행 할 수 있습니다. 예를 들어, 이것은 종종 &lt;code&gt;COPY&lt;/code&gt; , pg_dump 또는 이와 유사한 도구를 사용하여 데이터를 백업하는 데 유용한 시간 입니다. 또한 데이터를 더 작은 형식으로 집계하거나 다른 데이터 조작을 수행하거나 보고서를 실행하는 데 유용한 시간 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fb6b13498a74131eab9c57b3090da36c9ec9b3f" translate="yes" xml:space="preserve">
          <source>This allows sequential scans of large tables to synchronize with each other, so that concurrent scans read the same block at about the same time and hence share the I/O workload. When this is enabled, a scan might start in the middle of the table and then &amp;ldquo;wrap around&amp;rdquo; the end to cover all rows, so as to synchronize with the activity of scans already in progress. This can result in unpredictable changes in the row ordering returned by queries that have no &lt;code&gt;ORDER BY&lt;/code&gt; clause. Setting this parameter to &lt;code&gt;off&lt;/code&gt; ensures the pre-8.3 behavior in which a sequential scan always starts from the beginning of the table. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">이를 통해 큰 테이블의 순차적 스캔이 서로 동기화 될 수 있으므로 동시 스캔이 거의 동시에 동일한 블록을 읽고 I / O 워크로드를 공유 할 수 있습니다. 이 기능을 사용하면 테이블 중간에서 스캔이 시작된 다음 끝을&amp;ldquo;랩핑&amp;rdquo;하여 모든 행을 커버하여 이미 진행중인 스캔 활동과 동기화 할 수 있습니다. &lt;code&gt;ORDER BY&lt;/code&gt; 절이 없는 쿼리에서 반환 된 행 순서가 예기치 않게 변경 될 수 있습니다 . 이 매개 변수를 &lt;code&gt;off&lt;/code&gt; 로 설정하면 순차적 스캔이 항상 테이블의 시작 부분에서 시작되는 8.3 이전의 동작이 보장됩니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="253b2ab3ed8967081995487ba9ee5b4826393d61" translate="yes" xml:space="preserve">
          <source>This and other array operators are further described in &lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;. It can be accelerated by an appropriate index, as described in &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt;.</source>
          <target state="translated">이 배열 연산자와 다른 배열 연산자는 &lt;a href=&quot;functions-array&quot;&gt;9.18 절&lt;/a&gt; 에서 자세히 설명 합니다. &lt;a href=&quot;indexes-types&quot;&gt;11.2 절에&lt;/a&gt; 설명 된대로 적절한 색인으로 가속화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a81f0db3b04480fe75e2e180f22423d163b36314" translate="yes" xml:space="preserve">
          <source>This and other array operators are further described in &lt;a href=&quot;functions-array&quot;&gt;Section 9.19&lt;/a&gt;. It can be accelerated by an appropriate index, as described in &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt;.</source>
          <target state="translated">이것과 다른 배열 연산자는 &lt;a href=&quot;functions-array&quot;&gt;섹션 9.19&lt;/a&gt; 에서 자세히 설명 합니다. &lt;a href=&quot;indexes-types&quot;&gt;섹션 11.2에&lt;/a&gt; 설명 된대로 적절한 인덱스로 가속화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22f7125f90456e96d69dc4420ff05c41c76b48ac" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses BSD Authentication to verify the password. BSD Authentication is used only to validate user name/password pairs. Therefore the user's role must already exist in the database before BSD Authentication can be used for authentication. The BSD Authentication framework is currently only available on OpenBSD.</source>
          <target state="translated">이 인증 방법은 BSD 인증을 사용하여 비밀번호를 확인한다는 점을 제외하고는 &lt;code&gt;password&lt;/code&gt; 와 유사하게 작동 합니다. BSD 인증은 사용자 이름 / 암호 쌍의 유효성을 검사하는 데만 사용됩니다. 따라서 BSD 인증을 인증에 사용하려면 사용자 역할이 데이터베이스에 이미 존재해야합니다. BSD 인증 프레임 워크는 현재 OpenBSD에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b4a95a1004ec8979c4ed272cc869cffc8b380262" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses LDAP as the password verification method. LDAP is used only to validate the user name/password pairs. Therefore the user must already exist in the database before LDAP can be used for authentication.</source>
          <target state="translated">이 인증 방법은 비밀번호 확인 방법으로 LDAP를 사용한다는 점을 제외하고는 &lt;code&gt;password&lt;/code&gt; 와 유사하게 작동합니다 . LDAP는 사용자 이름 / 암호 쌍의 유효성을 검사하는 데만 사용됩니다. 따라서 인증에 LDAP를 사용하려면 사용자가 데이터베이스에 이미 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="14894f744e61a4d997e0bd55d2f4134698e24251" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses PAM (Pluggable Authentication Modules) as the authentication mechanism. The default PAM service name is &lt;code&gt;postgresql&lt;/code&gt;. PAM is used only to validate user name/password pairs and optionally the connected remote host name or IP address. Therefore the user must already exist in the database before PAM can be used for authentication. For more information about PAM, please read the &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;Linux-PAM Page&lt;/a&gt;.</source>
          <target state="translated">이 인증 방법은 PAM (Pluggable Authentication Modules)을 인증 메커니즘으로 사용한다는 점을 제외하고는 &lt;code&gt;password&lt;/code&gt; 와 유사하게 작동합니다 . 기본 PAM 서비스 이름은 &lt;code&gt;postgresql&lt;/code&gt; 입니다. PAM은 사용자 이름 / 암호 쌍 및 선택적으로 연결된 원격 호스트 이름 또는 IP 주소의 유효성을 검사하는 데만 사용됩니다. 따라서 PAM을 인증에 사용하려면 사용자가 데이터베이스에 이미 존재해야합니다. PAM에 대한 자세한 내용은 &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;Linux-PAM 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd397f0c1d27e7e6f24266e4663491230029a1f" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses RADIUS as the password verification method. RADIUS is used only to validate the user name/password pairs. Therefore the user must already exist in the database before RADIUS can be used for authentication.</source>
          <target state="translated">이 인증 방법은 비밀번호 확인 방법으로 RADIUS를 사용한다는 점을 제외하고는 &lt;code&gt;password&lt;/code&gt; 와 유사하게 작동합니다 . RADIUS는 사용자 이름 / 암호 쌍의 유효성을 검사하는 데만 사용됩니다. 따라서 RADIUS를 인증에 사용하려면 사용자가 데이터베이스에 이미 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="699ba79710348057cae6bc38a6f4967f7fef3d56" translate="yes" xml:space="preserve">
          <source>This authentication method uses SSL client certificates to perform authentication. It is therefore only available for SSL connections. When using this authentication method, the server will require that the client provide a valid, trusted certificate. No password prompt will be sent to the client. The &lt;code&gt;cn&lt;/code&gt; (Common Name) attribute of the certificate will be compared to the requested database user name, and if they match the login will be allowed. User name mapping can be used to allow &lt;code&gt;cn&lt;/code&gt; to be different from the database user name.</source>
          <target state="translated">이 인증 방법은 SSL 클라이언트 인증서를 사용하여 인증을 수행합니다. 따라서 SSL 연결에만 사용할 수 있습니다. 이 인증 방법을 사용할 때 서버는 클라이언트가 유효한 신뢰할 수있는 인증서를 제공해야합니다. 비밀번호 프롬프트가 클라이언트로 전송되지 않습니다. 인증서 의 &lt;code&gt;cn&lt;/code&gt; (공통 이름) 속성은 요청 된 데이터베이스 사용자 이름과 비교되며 일치하는 경우 로그인이 허용됩니다. &lt;code&gt;cn&lt;/code&gt; 이 데이터베이스 사용자 이름과 다를 수 있도록 사용자 이름 맵핑을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ac6c0054ced8ebe81d0f1a02772b68633401dc6" translate="yes" xml:space="preserve">
          <source>This behavior is desirable since it allows searches to work for both the whole compound word and for components. Here is another instructive example:</source>
          <target state="translated">이 동작은 전체 복합 단어와 구성 요소 모두에 대해 검색이 가능하기 때문에 바람직합니다. 다음은 또 다른 유익한 예입니다.</target>
        </trans-unit>
        <trans-unit id="286f6e80e06ffd51f385da7d2a7694b40cc44231" translate="yes" xml:space="preserve">
          <source>This can be convenient to be able to use operating-system-independent collation names in applications.</source>
          <target state="translated">응용 프로그램에서 운영 체제 독립적 인 데이터 정렬 이름을 사용하는 것이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2cb2c31cd20a3afc74e461bc50ba20daffd3b134" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes.</source>
          <target state="translated">이것은 GiST 인덱스가 아닌 GiST 인덱스에 의해 매우 효율적으로 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30c9965536e9eb1807b9625445e1dc9ee486d49c" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes. It will usually beat the first formulation when only a small number of the closest matches is wanted.</source>
          <target state="translated">이것은 GiST 인덱스가 아닌 GiST 인덱스에 의해 매우 효율적으로 구현 될 수 있습니다. 가장 적은 수의 가장 근접한 매치 만 원할 때 일반적으로 첫 번째 공식을 이깁니다.</target>
        </trans-unit>
        <trans-unit id="b19d203036cf7d45dfab0c4ad82ce10183e0940c" translate="yes" xml:space="preserve">
          <source>This can very quickly delete millions of records because it doesn't have to individually delete every record. Note however that the above command requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="translated">모든 레코드를 개별적으로 삭제할 필요가 없기 때문에 수백만 개의 레코드를 매우 빠르게 삭제할 수 있습니다. 그러나 위 명령을 수행하려면 상위 테이블에서 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3706a06d88bffe054b5b4e9ba07c3a2f69517db" translate="yes" xml:space="preserve">
          <source>This catalog only contains tables known to the subscription after running either &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; or &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt;.</source>
          <target state="translated">이 카탈로그에는 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 또는 &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; 을 실행 한 후 구독에 알려진 테이블 만 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="c00511a06e3429d3e3c63e91ce19e3a4e9397cad" translate="yes" xml:space="preserve">
          <source>This chapter explains the interface between the core PostgreSQL system and &lt;em&gt;table access methods&lt;/em&gt;, which manage the storage for tables. The core system knows little about these access methods beyond what is specified here, so it is possible to develop entirely new access method types by writing add-on code.</source>
          <target state="translated">이 장에서는 &lt;em&gt;테이블&lt;/em&gt; 스토리지를 관리하는 핵심 PostgreSQL 시스템과 &lt;em&gt;테이블 액세스 방법&lt;/em&gt; 간의 인터페이스에 대해 설명합니다 . 핵심 시스템은 여기에 지정된 것 이상으로 이러한 액세스 방법에 대해 거의 알지 못하므로 애드온 코드를 작성하여 완전히 새로운 액세스 방법 유형을 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bbb8116ccc75f5eb2a80776b0a4003df51db1c5" translate="yes" xml:space="preserve">
          <source>This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;. You should be aware that some PostgreSQL language features are extensions to the standard.</source>
          <target state="translated">이 장에서는 SQL을 사용하여 간단한 작업을 수행하는 방법에 대한 개요를 제공합니다. 이 학습서는 단지 소개를 목적으로하며 SQL에 대한 완전한 학습서는 아닙니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]을&lt;/a&gt; 포함하여 수많은 책이 SQL로 작성되었습니다 . 일부 PostgreSQL 언어 기능은 표준의 확장 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8dae2bfb234e1cafffdc1445672c01cdceebec98" translate="yes" xml:space="preserve">
          <source>This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;. You should be aware that some PostgreSQL language features are extensions to the standard.</source>
          <target state="translated">이 장에서는 SQL을 사용하여 간단한 작업을 수행하는 방법에 대한 개요를 제공합니다. 이 튜토리얼은 여러분에게 소개를 제공하기위한 것이며 SQL에 대한 완전한 튜토리얼이 아닙니다. &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#DATE97&quot;&gt;[date97]을&lt;/a&gt; 포함하여 수많은 책이 SQL에 대해 작성되었습니다 . 일부 PostgreSQL 언어 기능은 표준에 대한 확장입니다.</target>
        </trans-unit>
        <trans-unit id="d4bef49f81ca7b2b6c1d960ddeae062fa5602386" translate="yes" xml:space="preserve">
          <source>This chapter will on occasion refer to examples found in &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt; to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in &lt;code&gt;advanced.sql&lt;/code&gt; in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt; for how to use the file.)</source>
          <target state="translated">이 장은 때때로 &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;2 장&lt;/a&gt; 에서 찾은 예를 참조하여 변경하거나 개선하므로 해당 장을 읽으면 도움이 될 것입니다. 이 장의 일부 예 는 tutorial. 디렉토리의 &lt;code&gt;advanced.sql&lt;/code&gt; 에서도 찾을 수 있습니다 . 이 파일에는로드 할 샘플 데이터도 포함되어 있으며 여기에서는 반복되지 않습니다. ( 파일 사용법은 &lt;a href=&quot;tutorial-sql-intro&quot;&gt;2.1 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="dabed7c214422d3752d4d13e0c2a45b4ba36ecbe" translate="yes" xml:space="preserve">
          <source>This chapter will on occasion refer to examples found in &lt;a href=&quot;https://www.postgresql.org/docs/13/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt; to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in &lt;code&gt;advanced.sql&lt;/code&gt; in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt; for how to use the file.)</source>
          <target state="translated">이 장은 때때로 &lt;a href=&quot;https://www.postgresql.org/docs/13/tutorial-sql.html&quot;&gt;2 장&lt;/a&gt; 에있는 예제를 참조하여 변경하거나 개선하므로 해당 장을 읽어 보는 것이 유용 할 것입니다. 이 장의 일부 예제 는 튜토리얼 디렉토리의 &lt;code&gt;advanced.sql&lt;/code&gt; 에서도 찾을 수 있습니다 . 이 파일에는로드 할 일부 샘플 데이터도 포함되어 있으며 여기에서는 반복하지 않습니다. ( 파일 사용법은 &lt;a href=&quot;tutorial-sql-intro&quot;&gt;2.1 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b05316eb335b74f7f1d96b694767ed937c7a73d2" translate="yes" xml:space="preserve">
          <source>This clause allows selection of the tablespace in which the index associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint will be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="translated">이 절에서는 &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;EXCLUDE&lt;/code&gt; 제약 조건 과 관련된 인덱스가 생성 될 테이블 스페이스를 선택할 수 있습니다. 지정하지 않으면 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 를 참조하거나 테이블이 임시 인 경우 &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="9a22b296ec30545018cebf2ee6b84bbc440b4d2a" translate="yes" xml:space="preserve">
          <source>This clause alters parameters originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information. The allowed options are &lt;code&gt;slot_name&lt;/code&gt; and &lt;code&gt;synchronous_commit&lt;/code&gt;</source>
          <target state="translated">이 절은 원래 &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION에&lt;/a&gt; 의해 설정된 매개 변수를 변경 합니다. 자세한 내용은 거기를 참조하십시오. 허용되는 옵션은 &lt;code&gt;slot_name&lt;/code&gt; 및 &lt;code&gt;synchronous_commit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9dde9dc06154fb93b57360e4813d2af30753235f" translate="yes" xml:space="preserve">
          <source>This clause alters publication parameters originally set by &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. See there for more information.</source>
          <target state="translated">이 절은 원래 &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION에&lt;/a&gt; 의해 설정된 공개 매개 변수를 변경 합니다. 자세한 내용은 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a47a54fa61280e2ffdfce9d2640b5d9bb858deb" translate="yes" xml:space="preserve">
          <source>This clause alters the connection property originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information.</source>
          <target state="translated">이 절은 &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION에&lt;/a&gt; 의해 원래 설정된 연결 속성을 변경합니다 . 자세한 내용은 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d2fcb8e278e1a72c6a053d69e9530239790d3c7" translate="yes" xml:space="preserve">
          <source>This clause creates the column as a &lt;em&gt;generated column&lt;/em&gt;. The column cannot be written to, and when read the result of the specified expression will be returned.</source>
          <target state="translated">이 절은 열을 &lt;em&gt;생성 된 열로&lt;/em&gt; 만듭니다 . 열을 쓸 수 없으며 읽을 때 지정된 표현식의 결과가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cd8eb7a6eec884310b19db2fe89fcdaa447cc6e8" translate="yes" xml:space="preserve">
          <source>This clause creates the column as an &lt;em&gt;identity column&lt;/em&gt;. It will have an implicit sequence attached to it and the column in new rows will automatically have values from the sequence assigned to it.</source>
          <target state="translated">이 절은 열을 &lt;em&gt;ID 열로&lt;/em&gt; 만듭니다 . 여기에는 암시 적 시퀀스가 ​​첨부되며 새 행의 열에는 자동으로 지정된 시퀀스의 값이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="da05955831bd605d103f99ab7132a00a6b982439" translate="yes" xml:space="preserve">
          <source>This clause indicates whether the following relation name is for the before-image transition relation or the after-image transition relation.</source>
          <target state="translated">이 절은 다음 관계 이름이 이미지 이전 전이 관계인지 또는 이미지 이후 전이 관계인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="deddf49266216fee17210941a2dbf2f328be5ca2" translate="yes" xml:space="preserve">
          <source>This clause is only intended for compatibility with nonstandard SQL databases. Its use is discouraged in new applications.</source>
          <target state="translated">이 절은 비표준 SQL 데이터베이스와의 호환성을 위해서만 사용됩니다. 새로운 응용 프로그램에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41393a74e45a6c0a80ff1bb273dd882f889e0a0f" translate="yes" xml:space="preserve">
          <source>This clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications.</source>
          <target state="translated">이 절은 비표준 SQL 데이터베이스와의 호환성을 위해서만 제공됩니다. 새로운 응용 프로그램에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="22cd0887432e6ccdc3a45b9fc77bdb8214571dbc" translate="yes" xml:space="preserve">
          <source>This clause is useful for example when copying values between tables. Writing &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; will copy from &lt;code&gt;tbl1&lt;/code&gt; all columns that are not identity columns in &lt;code&gt;tbl2&lt;/code&gt; while values for the identity columns in &lt;code&gt;tbl2&lt;/code&gt; will be generated by the sequences associated with &lt;code&gt;tbl2&lt;/code&gt;.</source>
          <target state="translated">이 절은 예를 들어 테이블간에 값을 복사 할 때 유용합니다. 쓰기 &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; 복사한다 &lt;code&gt;tbl1&lt;/code&gt; 하지의 ID 열 모든 컬럼 &lt;code&gt;tbl2&lt;/code&gt; 의 ID 열 값하면서 &lt;code&gt;tbl2&lt;/code&gt; 와 연관된 시퀀스에 의해 생성된다 &lt;code&gt;tbl2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4ccb1be36e739cedb50d44f85c522aa002c906" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a publication. The following parameters are supported:</source>
          <target state="translated">이 절은 게시에 대한 선택적 매개 변수를 지정합니다. 다음과 같은 매개 변수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab7a0e0c831da17344263c723c33e3ad9e5583a" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a subscription. The following parameters are supported:</source>
          <target state="translated">이 절은 구독에 대한 선택적 매개 변수를 지정합니다. 다음과 같은 매개 변수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="501055417d1a99c1021f58bb4344fd42a1fc3dfa" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a view; the following parameters are supported:</source>
          <target state="translated">이 절은보기에 대한 선택적 매개 변수를 지정합니다. 다음과 같은 매개 변수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="959992a100adc135a448ff56a939c7cb03335c38" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for a table or index; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; below for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should not contain OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">이 절은 테이블 또는 인덱스에 대한 선택적 스토리지 매개 변수를 지정합니다. 참조 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;저장 영역 매개 변수&lt;/a&gt; 자세한 내용은 아래를. 이전 버전과의 호환성 을 위해 테이블 의 &lt;code&gt;WITH&lt;/code&gt; 절에는 &lt;code&gt;OIDS=FALSE&lt;/code&gt; 를 포함 하여 새 테이블의 행에 OID (개체 식별자)가 포함되지 않도록 지정할 수 있습니다. &lt;code&gt;OIDS=TRUE&lt;/code&gt; 는 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53e5726eff7272a0b43b9a8622a25a1a4b88715e" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for a table or index; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should not contain OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">이 절은 테이블 또는 인덱스에 대한 선택적 스토리지 매개 변수를 지정합니다. 자세한 내용은 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;스토리지 매개 변수&lt;/a&gt; 를 참조하십시오. 이전 버전과의 호환성 을 위해 테이블 의 &lt;code&gt;WITH&lt;/code&gt; 절에 &lt;code&gt;OIDS=FALSE&lt;/code&gt; 를 포함 하여 새 테이블의 행에 OID (객체 식별자)가 포함되지 않도록 지정할 수 있으며 &lt;code&gt;OIDS=TRUE&lt;/code&gt; 는 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e37f3a174a386383c959a305d30ae15361d5fa2" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new materialized view; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. All parameters supported for &lt;code&gt;CREATE TABLE&lt;/code&gt; are also supported for &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt;. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">이 절은 새로운 구체화 된보기에 대한 선택적 저장 매개 변수를 지정합니다. 자세한 내용은 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;스토리지 매개 변수&lt;/a&gt; 를 참조하십시오. &lt;code&gt;CREATE TABLE&lt;/code&gt; 에 대해 지원되는 모든 매개 변수 는 &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; 에 대해서도 지원됩니다 . 자세한 정보는 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="207b4757c66805d303f77232d29f374adc4dd287" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new materialized view; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for more information. All parameters supported for &lt;code&gt;CREATE TABLE&lt;/code&gt; are also supported for &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt;. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">이 절은 새로운 구체화 된 뷰에 대한 선택적 저장 매개 변수를 지정합니다. 참조 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;저장 영역 매개 변수&lt;/a&gt; 에서 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE에&lt;/a&gt; 대한 자세한 내용은 문서를. &lt;code&gt;CREATE TABLE&lt;/code&gt; 에 지원되는 모든 매개 변수 는 &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; 에도 지원됩니다 . 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="afd2349edcbad3293d90a1b82afea4e43718f802" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new table; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should contain no OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">이 절은 새 테이블에 대한 선택적 스토리지 매개 변수를 지정합니다. 자세한 내용은 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;스토리지 매개 변수&lt;/a&gt; 를 참조하십시오. 이전 버전과의 호환성 을 위해 테이블 의 &lt;code&gt;WITH&lt;/code&gt; 절에 &lt;code&gt;OIDS=FALSE&lt;/code&gt; 를 포함하여 새 테이블의 행에 OID (객체 식별자)가 포함되지 않도록 지정할 수 있으며 &lt;code&gt;OIDS=TRUE&lt;/code&gt; 는 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e578543445bd0cc923dce66a8dfdd41602ac897b" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new table; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should contain no OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">이 절은 새 테이블에 대한 선택적 스토리지 매개 변수를 지정합니다. 참조 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;저장 영역 매개 변수&lt;/a&gt; 에서 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE에&lt;/a&gt; 대한 자세한 내용은 문서를. 이전 버전과의 호환성 을 위해 테이블 의 &lt;code&gt;WITH&lt;/code&gt; 절에는 &lt;code&gt;OIDS=FALSE&lt;/code&gt; 를 포함하여 새 테이블의 행에 OID (개체 식별자)가 포함되지 않도록 지정할 수 있습니다. &lt;code&gt;OIDS=TRUE&lt;/code&gt; 는 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b9cf336be30ceb53b3db8168b3e8c1bdee3f553" translate="yes" xml:space="preserve">
          <source>This clause specifies options for the new foreign-data wrapper. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Option names must be unique.</source>
          <target state="translated">이 절은 새로운 외부 데이터 랩퍼에 대한 옵션을 지정합니다. 허용되는 옵션 이름 및 값은 각 외부 데이터 랩퍼에 고유하며 외부 데이터 랩퍼의 유효성 검증기 기능을 사용하여 유효성이 검증됩니다. 옵션 이름은 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f504297f50fca952ddee9289f583252aaad16be" translate="yes" xml:space="preserve">
          <source>This clause specifies the options for the server. The options typically define the connection details of the server, but the actual names and values are dependent on the server's foreign-data wrapper.</source>
          <target state="translated">이 절은 서버의 옵션을 지정합니다. 옵션은 일반적으로 서버의 연결 세부 사항을 정의하지만 실제 이름 및 값은 서버의 외부 데이터 랩퍼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="553dd348cb64862c6f6c7f8e200b08ad63014f0b" translate="yes" xml:space="preserve">
          <source>This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.</source>
          <target state="translated">이 절은 사용자 매핑 옵션을 지정합니다. 옵션은 일반적으로 매핑의 실제 사용자 이름과 비밀번호를 정의합니다. 옵션 이름은 고유해야합니다. 허용되는 옵션 이름과 값은 서버의 외부 데이터 래퍼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="36dc1042b746c18fc663603f39f06075d4e8bad1" translate="yes" xml:space="preserve">
          <source>This clause specifies the type of access method to define. Only &lt;code&gt;TABLE&lt;/code&gt; and &lt;code&gt;INDEX&lt;/code&gt; are supported at present.</source>
          <target state="translated">이 절은 정의 할 액세스 방법의 유형을 지정합니다. 만 &lt;code&gt;TABLE&lt;/code&gt; 와 &lt;code&gt;INDEX&lt;/code&gt; 는 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c9f34db6e75577cfa3e83dbdc6bf919fff89f9" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the data produced by the query should be copied into the new table. If not, only the table structure is copied. The default is to copy the data.</source>
          <target state="translated">이 절은 쿼리에서 생성 된 데이터를 새 테이블에 복사해야하는지 여부를 지정합니다. 그렇지 않은 경우 테이블 구조 만 복사됩니다. 기본값은 데이터를 복사하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d31ed888cfee0dc08f120a78ae32fb1759c0983" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the materialized view should be populated at creation time. If not, the materialized view will be flagged as unscannable and cannot be queried until &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; is used.</source>
          <target state="translated">이 절은 작성시 구체화 된보기를 채워야하는지 여부를 지정합니다. 그렇지 않으면 구체화 된 뷰는 스캔 할 수없는 것으로 플래그가 지정되며 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; 를 사용할 때까지 쿼리 할 수 ​​없습니다 .</target>
        </trans-unit>
        <trans-unit id="d4795183bcf13c08ef4cb630d8902e21d5cf34ce" translate="yes" xml:space="preserve">
          <source>This color specification format is also used by other software packages such as GCC, GNU coreutils, and GNU grep.</source>
          <target state="translated">이 색상 사양 형식은 GCC, GNU coreutils 및 GNU grep과 같은 다른 소프트웨어 패키지에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc6ac474993dbe5358c6881853df7fd2d4d9cd6" translate="yes" xml:space="preserve">
          <source>This column has a default expression or generation expression, in which case there will be a corresponding entry in the &lt;code&gt;pg_attrdef&lt;/code&gt; catalog that actually defines the expression. (Check &lt;code&gt;attgenerated&lt;/code&gt; to determine whether this is a default or a generation expression.)</source>
          <target state="translated">이 열에는 기본 표현식 또는 생성 표현식이 있으며,이 경우 실제로 &lt;code&gt;pg_attrdef&lt;/code&gt; 카탈로그에 해당 표현식을 정의 하는 해당 항목이 있습니다 . ( &lt;code&gt;attgenerated&lt;/code&gt; 를 확인 하여 이것이 기본 표현식인지 또는 생성 표현식인지 판별 하십시오 .)</target>
        </trans-unit>
        <trans-unit id="c2b7e0b12551b63f994a3beb30fdb6c9912fa294" translate="yes" xml:space="preserve">
          <source>This column has a one element array containing the value used when the column is entirely missing from the row, as happens when the column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The value is only used when &lt;code&gt;atthasmissing&lt;/code&gt; is true. If there is no value the column is null.</source>
          <target state="translated">이 열에는 행을 만든 후 열이 비 휘발성 &lt;code&gt;DEFAULT&lt;/code&gt; 값으로 추가 될 때처럼 행에서 열이 완전히 누락 된 경우 사용되는 값을 포함하는 하나의 요소 배열이 있습니다 . &lt;code&gt;atthasmissing&lt;/code&gt; 이 true 인 경우에만 값이 사용됩니다 . 값이 없으면 열이 null입니다.</target>
        </trans-unit>
        <trans-unit id="35ff62cc51341f34bf3df6fe15f16224e9f0ba2a" translate="yes" xml:space="preserve">
          <source>This column has a value which is used where the column is entirely missing from the row, as happens when a column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The actual value used is stored in the &lt;code&gt;attmissingval&lt;/code&gt; column.</source>
          <target state="translated">이 컬럼은 행이 작성된 후 컬럼이 비 휘발성 &lt;code&gt;DEFAULT&lt;/code&gt; 값으로 추가 될 때 발생하는 것처럼 행에서 컬럼이 완전히 누락 된 위치에서 사용되는 값을 갖 습니다. 사용 된 실제 값은 &lt;code&gt;attmissingval&lt;/code&gt; 열에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="111e19fea7f4514da864aef92d2fd3831ac7425b" translate="yes" xml:space="preserve">
          <source>This column has been dropped and is no longer valid. A dropped column is still physically present in the table, but is ignored by the parser and so cannot be accessed via SQL.</source>
          <target state="translated">이 열은 삭제되었으며 더 이상 유효하지 않습니다. 삭제 된 열은 여전히 ​​테이블에 실제로 존재하지만 구문 분석기는 무시하므로 SQL을 통해 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b598ea81d21dfda8a3cd60afd34a658bae3f5740" translate="yes" xml:space="preserve">
          <source>This column is defined locally in the relation. Note that a column can be locally defined and inherited simultaneously.</source>
          <target state="translated">이 열은 관계에서 로컬로 정의됩니다. 열을 로컬로 정의하고 동시에 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="699529a66bde15ad8ad9a32706a761c81f8ea245" translate="yes" xml:space="preserve">
          <source>This command acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">이 명령은 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="ace2f59fb68bc1a8e1f61640a30167ef3925c24d" translate="yes" xml:space="preserve">
          <source>This command adds the &lt;code&gt;user.postgres&lt;/code&gt; project and sets the shared memory maximum for the &lt;code&gt;postgres&lt;/code&gt; user to 8GB, and takes effect the next time that user logs in, or when you restart PostgreSQL (not reload). The above assumes that PostgreSQL is run by the &lt;code&gt;postgres&lt;/code&gt; user in the &lt;code&gt;postgres&lt;/code&gt; group. No server reboot is required.</source>
          <target state="translated">이 명령은 &lt;code&gt;user.postgres&lt;/code&gt; 프로젝트를 추가하고 &lt;code&gt;postgres&lt;/code&gt; 사용자 의 공유 메모리 최대 값 을 8GB로 설정하고 다음에 사용자가 로그인하거나 PostgreSQL을 다시 시작할 때 (다시로드하지 않음) 적용됩니다. 위의 내용은 PostgreSQL이 &lt;code&gt;postgres&lt;/code&gt; 그룹 의 &lt;code&gt;postgres&lt;/code&gt; 사용자에 의해 실행된다고 가정합니다 . 서버를 다시 부팅 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d0a3c8a461143dd6e79fdea4b574da1733f08aa" translate="yes" xml:space="preserve">
          <source>This command begins a new transaction block. If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed. This is the same as the &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">이 명령은 새로운 트랜잭션 블록을 시작합니다. 분리 레벨, 읽기 / 쓰기 모드 또는 지연 가능 모드가 지정되면 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 이 실행 된 것처럼 새 트랜잭션에 이러한 특성 이 있습니다. 이것은 &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; 명령 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="62d4740f8d77efc3fe73e95e0f13203063c98ef5" translate="yes" xml:space="preserve">
          <source>This command can't be used to set &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;, nor parameters that are not allowed in &lt;code&gt;postgresql.conf&lt;/code&gt; (e.g., &lt;a href=&quot;runtime-config-preset&quot;&gt;preset options&lt;/a&gt;).</source>
          <target state="translated">이 명령은 &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt; 를 설정 하거나 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 허용되지 않는 매개 변수 (예 : &lt;a href=&quot;runtime-config-preset&quot;&gt;프리셋 옵션&lt;/a&gt; ) 를 설정하는 데 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4e40f32b710aa4b5a2f3104aef12c4365c871f09" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is committed immediately.</source>
          <target state="translated">이 명령은 트랜잭션 블록 내에서 실행할 수 없습니다. 준비된 트랜잭션은 즉시 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="20b731d4b786265bb5e3ab49dc8d1a8760feab6b" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is rolled back immediately.</source>
          <target state="translated">이 명령은 트랜잭션 블록 내에서 실행할 수 없습니다. 준비된 트랜잭션은 즉시 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="3a29d09c1029fd474b45e76bcdb5bbdf65bd3023" translate="yes" xml:space="preserve">
          <source>This command cannot be executed while connected to the target database. Thus, it might be more convenient to use the program &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; instead, which is a wrapper around this command.</source>
          <target state="translated">대상 데이터베이스에 연결되어있는 동안이 명령을 실행할 수 없습니다. 따라서 대신 &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; 프로그램을 사용하는 것이 더 편리 할 수 ​​있습니다 . 이는이 명령의 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="2e5d7b0191945449cf1438d09ec7519757af4913" translate="yes" xml:space="preserve">
          <source>This command complies with the behavior defined in the SQL standard, except for the limitation that, in PostgreSQL, it does not apply to &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints. Also, PostgreSQL checks non-deferrable uniqueness constraints immediately, not at end of statement as the standard would suggest.</source>
          <target state="translated">이 명령은 PostgreSQL에서 &lt;code&gt;NOT NULL&lt;/code&gt; 및 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건에 적용되지 않는 제한 사항을 제외하고 SQL 표준에 정의 된 동작을 따릅니다 . 또한 PostgreSQL은 표준에서 제안한대로 명령문 끝이 아닌 지연 불가능한 고유성 제약 조건을 즉시 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d38352e381f4c256e7b517b01e9b0ccd61de188e" translate="yes" xml:space="preserve">
          <source>This command conforms to ISO/IEC 9075-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">이 명령은 ISO / IEC 9075-9 (SQL / MED)를 준수합니다. 단, 표준에서는 PostgreSQL 확장 인 &lt;code&gt;IF EXISTS&lt;/code&gt; 옵션 과는 별도로 명령 당 하나의 외부 테이블 만 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b34603e56b93d743e26d620fe567201bf5d5d62" translate="yes" xml:space="preserve">
          <source>This command conforms to the ISO/IEC 9075-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">이 명령은 ISO / IEC 9075-9 (SQL / MED)를 따릅니다. 단, 표준에서는 PostgreSQL 확장 인 &lt;code&gt;IF EXISTS&lt;/code&gt; 옵션을 제외하고 명령 당 하나의 외부 테이블 만 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f1f85c735f1b71966f80b17247cbce182c5909a" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except for the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">이 명령 은 PostgreSQL 확장 인 &lt;code&gt;IF EXISTS&lt;/code&gt; 옵션을 제외하고 SQL 표준을 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="468590b4d092b563617998d73f97b2171f1d8742" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 및 &lt;code&gt;RETURNING&lt;/code&gt; 절이 PostgreSQL 확장 인 &lt;code&gt;WITH&lt;/code&gt; &lt;code&gt;UPDATE&lt;/code&gt; 와 함께 사용하는 기능을 제외 하고이 명령은 SQL 표준을 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="bf1546d77c97dbe67b0ddd8982d22b8e55974688" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;DELETE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 과 함께 &lt;code&gt;DELETE&lt;/code&gt; 를 사용할 수있는 기능 과 마찬가지로 &lt;code&gt;USING&lt;/code&gt; 및 &lt;code&gt;RETURNING&lt;/code&gt; 절이 PostgreSQL 확장 이라는 점을 제외 하고이 명령은 SQL 표준을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="681caf8270b9ecf7b205e0a60ad45b051b0e81dd" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">이 명령은 표준 이 PostgreSQL 확장 인 &lt;code&gt;IF EXISTS&lt;/code&gt; 옵션을 제외하고 명령 당 하나의 테이블 만 삭제할 수 있다는 점을 제외하고는 SQL 표준을 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="93af22491b168f8df3ca39363ea91881304542c1" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one view to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">이 명령은 표준 이 PostgreSQL 확장 인 &lt;code&gt;IF EXISTS&lt;/code&gt; 옵션을 제외하고 명령 당 하나의보기 만 삭제할 수 있다는 점을 제외하고는 SQL 표준을 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="4b31cc3350023fe9b74a561a1da0159f92b17624" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, with these PostgreSQL extensions:</source>
          <target state="translated">이 명령은 다음 PostgreSQL 확장을 사용하여 SQL 표준을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="dabcb37ca2e8b2f56629a8b0fd30a7a18fcbfc70" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard. The standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL allows it to be omitted.</source>
          <target state="translated">이 명령은 SQL 표준을 준수합니다. 표준은 키워드 &lt;code&gt;SAVEPOINT&lt;/code&gt; 가 필수 임을 지정 하지만 PostgreSQL에서는이를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1c4c1beba4d7959f48fbfa14fde82110587427a" translate="yes" xml:space="preserve">
          <source>This command displays the execution plan that the PostgreSQL planner generates for the supplied statement. The execution plan shows how the table(s) referenced by the statement will be scanned &amp;mdash; by plain sequential scan, index scan, etc. &amp;mdash; and if multiple tables are referenced, what join algorithms will be used to bring together the required rows from each input table.</source>
          <target state="translated">이 명령은 PostgreSQL 플래너가 제공된 명령문에 대해 생성 한 실행 계획을 표시합니다. 실행 계획은 명령문이 참조하는 테이블을 일반 순차 스캔, 인덱스 스캔 등으로 스캔하는 방법을 보여줍니다. 여러 테이블이 참조되는 경우 각 테이블에서 필요한 행을 결합하는 데 어떤 조인 알고리즘이 사용됩니까? 입력 테이블.</target>
        </trans-unit>
        <trans-unit id="4333b1355b5818f99bd58b5b127214feda5e5493" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command is executed immediately if you added a semicolon to it. Otherwise it is redisplayed; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">이 명령은 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 또는 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 명령 의 양식으로 명명 된 함수 또는 프로 시저의 정의를 페치하고 편집합니다 . 편집은 &lt;code&gt;\edit&lt;/code&gt; 과 같은 방식으로 수행됩니다 . 편집기가 종료 된 후 세미콜론을 추가하면 업데이트 된 명령이 즉시 실행됩니다. 그렇지 않으면 다시 표시됩니다. 세미콜론 또는 &lt;code&gt;\g&lt;/code&gt; 를 입력 하여 보내거나 &lt;code&gt;\r&lt;/code&gt; 을 입력하여 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="8488cb1889e76b5a66add5218ab2ee79544199b3" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">이 명령은 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 또는 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 명령 의 형식으로 명명 된 함수 또는 프로 시저의 정의를 페치하고 편집합니다 . 편집은 &lt;code&gt;\edit&lt;/code&gt; 과 같은 방식으로 수행됩니다 . 편집기가 종료되면 업데이트 된 명령이 쿼리 버퍼에서 대기합니다. 세미콜론 또는 &lt;code&gt;\g&lt;/code&gt; 를 입력 하여 보내거나 &lt;code&gt;\r&lt;/code&gt; 을 입력하여 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="f922604d6411c18a78b17a2c612a5b15141b9a3b" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command is executed immediately if you added a semicolon to it. Otherwise it is redisplayed; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">이 명령은 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 명령 의 형태로 명명 된 뷰의 정의를 가져오고 편집합니다 . 편집은 &lt;code&gt;\edit&lt;/code&gt; 과 같은 방식으로 수행됩니다 . 편집기가 종료 된 후 세미콜론을 추가하면 업데이트 된 명령이 즉시 실행됩니다. 그렇지 않으면 다시 표시됩니다. 세미콜론 또는 &lt;code&gt;\g&lt;/code&gt; 를 입력 하여 보내거나 &lt;code&gt;\r&lt;/code&gt; 을 입력하여 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="bf69a2b293c399676b07c902a79f2f6947b772dc" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">이 명령은 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 명령 의 형식으로 명명 된 뷰의 정의를 가져오고 편집합니다 . 편집은 &lt;code&gt;\edit&lt;/code&gt; 과 같은 방식으로 수행됩니다 . 편집기가 종료되면 업데이트 된 명령이 쿼리 버퍼에서 대기합니다. 세미콜론 또는 &lt;code&gt;\g&lt;/code&gt; 를 입력 하여 보내거나 &lt;code&gt;\r&lt;/code&gt; 을 입력하여 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="de8b3b98128e1d7cfa1ced8632fee4a04f5b0692" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 또는 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 명령 의 형식으로 명명 된 함수 또는 프로 시저의 정의를 페치하고 표시합니다 . 정의는 &lt;code&gt;\o&lt;/code&gt; 로 설정 한대로 현재 쿼리 출력 채널에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c81c5ecf842f5babd90a21465ed15920d3fbf2d" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 명령 형식으로 명명 된 뷰의 정의를 가져 와서 표시합니다 . 정의는 &lt;code&gt;\o&lt;/code&gt; 로 설정 한대로 현재 쿼리 출력 채널에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd85d7e6ea3b73ffb02cb31a536b30a7bacab224" translate="yes" xml:space="preserve">
          <source>This command is a PostgreSQL extension present for historical reasons. &lt;code&gt;ROLLBACK&lt;/code&gt; is the equivalent standard SQL command.</source>
          <target state="translated">이 명령은 역사적 이유로 존재하는 PostgreSQL 확장입니다. &lt;code&gt;ROLLBACK&lt;/code&gt; 은 동등한 표준 SQL 명령입니다.</target>
        </trans-unit>
        <trans-unit id="2845ceac7504cffef12e499b57f5339a71e8d823" translate="yes" xml:space="preserve">
          <source>This command is functionally similar to &lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt;, but it is preferred since it is less likely to be confused with other uses of the &lt;code&gt;SELECT INTO&lt;/code&gt; syntax. Furthermore, &lt;code&gt;CREATE TABLE AS&lt;/code&gt; offers a superset of the functionality offered by &lt;code&gt;SELECT INTO&lt;/code&gt;.</source>
          <target state="translated">이 명령은 기능적으로 &lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt; 와 유사 하지만 다른 &lt;code&gt;SELECT INTO&lt;/code&gt; 구문 사용과 혼동 될 가능성이 적으므로 선호 됩니다. 또한 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 는 &lt;code&gt;SELECT INTO&lt;/code&gt; 가 제공하는 기능의 상위 집합을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4f51d7c5a1147247ad39d7dd8578e7109e7bd269" translate="yes" xml:space="preserve">
          <source>This command is identical to &lt;code&gt;\echo&lt;/code&gt; except that the output will be written to psql's standard error channel, rather than standard output.</source>
          <target state="translated">이 명령은 출력이 표준 출력이 아닌 psql의 표준 오류 채널에 기록된다는 점을 제외하면 &lt;code&gt;\echo&lt;/code&gt; 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1eebc2c2dfbb338f54847defda6bbbbd05da85aa" translate="yes" xml:space="preserve">
          <source>This command is identical to &lt;code&gt;\echo&lt;/code&gt; except that the output will be written to the query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;\o&lt;/code&gt; 의해 설정된 출력이 쿼리 출력 채널에 기록된다는 점을 제외하고 &lt;code&gt;\echo&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c6b1eb8df7cef0a6e41f20fd61cbd76e26932fed" translate="yes" xml:space="preserve">
          <source>This command is similar to the corresponding command in the SQL standard, apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension. But note that much of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command and the data type extension mechanisms in PostgreSQL differ from the SQL standard.</source>
          <target state="translated">이 명령은 PostgreSQL 확장 인 &lt;code&gt;IF EXISTS&lt;/code&gt; 옵션을 제외하고 SQL 표준의 해당 명령과 유사합니다 . 그러나 PostgreSQL의 많은 &lt;code&gt;CREATE TYPE&lt;/code&gt; 명령 및 데이터 유형 확장 메커니즘은 SQL 표준과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="74399205e4f06569f7b7a41f319f8abd6da5004d" translate="yes" xml:space="preserve">
          <source>This command is unrelated to the SQL command &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;.</source>
          <target state="translated">이 명령은 SQL 명령 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 과 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="017757db6d9507e6b7436f7a9ae4e2248893c3e8" translate="yes" xml:space="preserve">
          <source>This command loads a shared library file into the PostgreSQL server's address space. If the file has been loaded already, the command does nothing. Shared library files that contain C functions are automatically loaded whenever one of their functions is called. Therefore, an explicit &lt;code&gt;LOAD&lt;/code&gt; is usually only needed to load a library that modifies the server's behavior through &amp;ldquo;hooks&amp;rdquo; rather than providing a set of functions.</source>
          <target state="translated">이 명령은 공유 라이브러리 파일을 PostgreSQL 서버의 주소 공간으로로드합니다. 파일이 이미로드 된 경우 명령은 아무 작업도 수행하지 않습니다. C 함수가 포함 된 공유 라이브러리 파일은 해당 함수 중 하나가 호출 될 때마다 자동으로로드됩니다. 따라서 명시 적 &lt;code&gt;LOAD&lt;/code&gt; 는 일반적으로 함수 집합을 제공하지 않고 &quot;후크&quot;를 통해 서버의 동작을 수정하는 라이브러리를로드하는 데만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="58fcb6c8246e8a6d76583723b04afe1b09a7d9c3" translate="yes" xml:space="preserve">
          <source>This command may be used to end SQL queries, taking the place of the terminating semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="translated">이 명령은 종료 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )을 대신하여 SQL 쿼리를 종료하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="677d2975d49fcc1351e4405fb4dd24f72ba0639a" translate="yes" xml:space="preserve">
          <source>This command must be used inside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; to start one.</source>
          <target state="translated">이 명령은 트랜잭션 블록 내에서 사용해야합니다. &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; 을 사용 하여 시작 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b6b0df46bdea049004d95ff3514fc627c0bf758" translate="yes" xml:space="preserve">
          <source>This command must not be used when the server is running. &lt;code&gt;pg_resetwal&lt;/code&gt; will refuse to start up if it finds a server lock file in the data directory. If the server crashed then a lock file might have been left behind; in that case you can remove the lock file to allow &lt;code&gt;pg_resetwal&lt;/code&gt; to run. But before you do so, make doubly certain that there is no server process still alive.</source>
          <target state="translated">서버가 실행 중일 때는이 명령을 사용해서는 안됩니다. &lt;code&gt;pg_resetwal&lt;/code&gt; 은 데이터 디렉토리에서 서버 잠금 파일을 찾으면 시작을 거부합니다. 서버가 충돌 한 경우 잠금 파일이 남아있을 수 있습니다. 이 경우 잠금 파일을 제거하여 &lt;code&gt;pg_resetwal&lt;/code&gt; 을 실행할 수 있습니다. 그러나 그렇게하기 전에 서버 프로세스가 아직 남아 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="71df21dcefbc6a0e13c7dad07c76dab173b26ca8" translate="yes" xml:space="preserve">
          <source>This command only alters the behavior of constraints within the current transaction. Issuing this outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">이 명령은 현재 트랜잭션 내에서 제약 조건의 동작 만 변경합니다. 이것을 트랜잭션 블록 외부에서 발행하면 경고가 발생하고 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd16c39418a0167a8c3018978b081238b82407a5" translate="yes" xml:space="preserve">
          <source>This command removes the procedural language &lt;code&gt;plsample&lt;/code&gt;:</source>
          <target state="translated">이 명령은 절차 언어 &lt;code&gt;plsample&lt;/code&gt; 을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="13a5e5db6761174aa48d67b3836a7c44b067d9bd" translate="yes" xml:space="preserve">
          <source>This command removes the square root function:</source>
          <target state="translated">이 명령은 제곱근 함수를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c8da0e72c154580e68779b6eda81a32e4cdad2c2" translate="yes" xml:space="preserve">
          <source>This command sets options affecting the output of query result tables. &lt;code&gt;option&lt;/code&gt; indicates which option is to be set. The semantics of &lt;code&gt;value&lt;/code&gt; vary depending on the selected option. For some options, omitting &lt;code&gt;value&lt;/code&gt; causes the option to be toggled or unset, as described under the particular option. If no such behavior is mentioned, then omitting &lt;code&gt;value&lt;/code&gt; just results in the current setting being displayed.</source>
          <target state="translated">이 명령은 쿼리 결과 테이블의 출력에 영향을주는 옵션을 설정합니다. &lt;code&gt;option&lt;/code&gt; 은 설정할 옵션을 나타냅니다. &lt;code&gt;value&lt;/code&gt; 의 의미 는 선택한 옵션에 따라 다릅니다. 일부 옵션의 경우 &lt;code&gt;value&lt;/code&gt; 생략 하면 특정 옵션에 설명 된대로 옵션이 토글되거나 설정 해제됩니다. 이러한 동작을 언급하지 않으면 &lt;code&gt;value&lt;/code&gt; 을 생략 하면 현재 설정 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="55b80b7eaaaf7b41602e63f2f9f3e4efa523bee3" translate="yes" xml:space="preserve">
          <source>This command sets the current user identifier of the current SQL session to be &lt;code&gt;role_name&lt;/code&gt;. The role name can be written as either an identifier or a string literal. After &lt;code&gt;SET ROLE&lt;/code&gt;, permissions checking for SQL commands is carried out as though the named role were the one that had logged in originally.</source>
          <target state="translated">이 명령은 현재 SQL 세션의 현재 사용자 식별자를 &lt;code&gt;role_name&lt;/code&gt; 으로 설정 합니다. 역할 이름은 식별자 또는 문자열 리터럴로 쓸 수 있습니다. &lt;code&gt;SET ROLE&lt;/code&gt; 후 , 명명 된 역할이 원래 로그인 한 것처럼 SQL 명령에 대한 권한 점검이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f7712990490e001a7ee650bc9d46804ef39e8a64" translate="yes" xml:space="preserve">
          <source>This command sets the session user identifier and the current user identifier of the current SQL session to be &lt;code&gt;user_name&lt;/code&gt;. The user name can be written as either an identifier or a string literal. Using this command, it is possible, for example, to temporarily become an unprivileged user and later switch back to being a superuser.</source>
          <target state="translated">이 명령은 세션 사용자 식별자 및 현재 SQL 세션의 현재 사용자 식별자를 &lt;code&gt;user_name&lt;/code&gt; 으로 설정 합니다. 사용자 이름은 식별자 또는 문자열 리터럴로 쓸 수 있습니다. 예를 들어이 명령을 사용하면 일시적으로 권한이없는 사용자가되어 나중에 수퍼 유저로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c9ce1414108a89726b8871ae0b54d84b052aa18" translate="yes" xml:space="preserve">
          <source>This command will fail if any of &lt;code&gt;hstore&lt;/code&gt;'s objects are in use in the database, for example if any tables have columns of the &lt;code&gt;hstore&lt;/code&gt; type. Add the &lt;code&gt;CASCADE&lt;/code&gt; option to forcibly remove those dependent objects as well.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 오브젝트 중 하나가 데이터베이스에서 사용중인 경우 (예 : &lt;code&gt;hstore&lt;/code&gt; 유형의 컬럼이있는 테이블이있는 경우) 이 명령은 실패합니다 . &lt;code&gt;CASCADE&lt;/code&gt; 옵션을 추가하여 해당 종속 개체를 강제로 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6b862ff106f276a9375de8c6aab656803f7a4efb" translate="yes" xml:space="preserve">
          <source>This command will free storage associated with the materialized view &lt;code&gt;annual_statistics_basis&lt;/code&gt; and leave it in an unscannable state:</source>
          <target state="translated">이 명령은 materialized view &lt;code&gt;annual_statistics_basis&lt;/code&gt; 와 연관된 스토리지를 비우고 스캔 할 수없는 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="6c9c73632173fe8b7637783ced8159d79d16ea65" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that reference the configuration in &lt;code&gt;to_tsvector&lt;/code&gt; calls. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the text search configuration.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; 호출 에서 구성을 참조하는 기존 색인이 있으면이 명령이 성공하지 않습니다 . &lt;code&gt;CASCADE&lt;/code&gt; 를 추가 하여 텍스트 검색 구성과 함께 이러한 색인을 삭제 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b7e8e631e47d7a2498f014c562d775f4aa922d4" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use operator classes within the family. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator family.</source>
          <target state="translated">패밀리 내에서 연산자 클래스를 사용하는 기존 색인이 있으면이 명령이 실패합니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 추가 하여 운영자 패밀리와 함께 이러한 색인을 삭제 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e344bd47bfc7344c009cae8df60f4f2d04ad7fee" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use the operator class. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator class.</source>
          <target state="translated">연산자 클래스를 사용하는 기존 색인이 있으면이 명령이 실패합니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 추가 하여 연산자 클래스와 함께 이러한 인덱스를 삭제 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a073ad25e0df8057b772f9939bb92486f83b429" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the dictionary. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the dictionary.</source>
          <target state="translated">사전을 사용하는 기존 텍스트 검색 구성이 있으면이 명령이 성공하지 않습니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 추가 하여 사전과 함께 이러한 구성을 삭제 하십시오 .</target>
        </trans-unit>
        <trans-unit id="98b8a535bcfac2a0dbcd407ddbfe551b50e04749" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the parser. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the parser.</source>
          <target state="translated">구문 분석기를 사용하는 기존 텍스트 검색 구성이 있으면이 명령이 성공하지 않습니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 추가 하여 파서와 함께 이러한 구성을 삭제 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9140e2324a0907c1e9782d65b5e3ea71a6d9655e" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search dictionaries that use the template. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such dictionaries along with the template.</source>
          <target state="translated">템플릿을 사용하는 기존 텍스트 검색 사전이 있으면이 명령이 성공하지 못합니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 추가 하여 템플릿과 함께 이러한 사전을 삭제 하십시오 .</target>
        </trans-unit>
        <trans-unit id="17f6112c2268ba0c9663f367e376afa3756d596b" translate="yes" xml:space="preserve">
          <source>This command will perform archiving when &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; exists, and otherwise silently return zero exit status (allowing PostgreSQL to recycle the unwanted WAL file).</source>
          <target state="translated">이 명령은 &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; 가 존재할 때 아카이빙을 수행 하고 그렇지 않으면 PostgreSQL이 원하지 않는 WAL 파일을 재활용 할 수 있도록 종료 상태 0을 자동으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08ffbb1ab36d371eef7c290033c779142e12ec33" translate="yes" xml:space="preserve">
          <source>This command will remove the index &lt;code&gt;title_idx&lt;/code&gt;:</source>
          <target state="translated">이 명령은 &lt;code&gt;title_idx&lt;/code&gt; 인덱스를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="2078fd2a1ddd7b0f72d80b8a3d0cc32c019e717f" translate="yes" xml:space="preserve">
          <source>This command will remove the materialized view called &lt;code&gt;order_summary&lt;/code&gt;:</source>
          <target state="translated">이 명령은 &lt;code&gt;order_summary&lt;/code&gt; 라는 구체화 된 뷰를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="a242c77a8ccd56ddace9304e1ec3ea12442c9d59" translate="yes" xml:space="preserve">
          <source>This command will remove the view called &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">이 명령은 &lt;code&gt;kinds&lt;/code&gt; 뷰를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="0d7ac7005486ff5a82c81e39d2a6985dcac07fb2" translate="yes" xml:space="preserve">
          <source>This command will replace the contents of the materialized view called &lt;code&gt;order_summary&lt;/code&gt; using the query from the materialized view's definition, and leave it in a scannable state:</source>
          <target state="translated">이 명령은 구체화 된 뷰 정의의 쿼리를 사용하여 &lt;code&gt;order_summary&lt;/code&gt; 라는 구체화 된 뷰의 내용을 대체하고 스캔 가능한 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="21fb41393a4eea96218c35f555df78b95eb06e38" translate="yes" xml:space="preserve">
          <source>This command will return a sample of 100 rows from the table &lt;code&gt;my_table&lt;/code&gt; (unless the table does not have 100 visible rows, in which case all its rows are returned).</source>
          <target state="translated">이 명령은 &lt;code&gt;my_table&lt;/code&gt; 테이블에서 100 개의 행 샘플을 리턴합니다 (테이블에 100 개의 가시 행이 없으면 모든 행이 리턴됩니다).</target>
        </trans-unit>
        <trans-unit id="01ae94e8662537ac6716b276145364c5f4fb1046" translate="yes" xml:space="preserve">
          <source>This command will return as large a sample of &lt;code&gt;my_table&lt;/code&gt; as it can read in 1 second (1000 milliseconds). Of course, if the whole table can be read in under 1 second, all its rows will be returned.</source>
          <target state="translated">이 명령은 1 초 (1000 밀리 초)에 읽을 수 있는 최대 &lt;code&gt;my_table&lt;/code&gt; 샘플을 반환 합니다. 물론 전체 테이블을 1 초 이내에 읽을 수 있으면 모든 행이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8973f1428f19cf5f51d43ae902ba0ec839e24687" translate="yes" xml:space="preserve">
          <source>This command will work independent of whether &lt;code&gt;foo&lt;/code&gt; is an aggregate, function, or procedure.</source>
          <target state="translated">이 명령은 &lt;code&gt;foo&lt;/code&gt; 가 집계, 함수 또는 프로 시저 인지에 관계없이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="8ac0fa233aac6a123e11329c2972c3833b6e69d2" translate="yes" xml:space="preserve">
          <source>This confirms there are 100 distinct combinations in the two columns, and all of them are about equally likely (1% frequency for each one). The base frequency is the frequency computed from per-column statistics, as if there were no multi-column statistics. Had there been any null values in either of the columns, this would be identified in the &lt;code&gt;nulls&lt;/code&gt; column.</source>
          <target state="translated">이는 두 열에 100 개의 별개의 조합이 있음을 확인하며, 모두 동일하게 (각각에 대해 1 % 빈도) 가능성이 높습니다. 기본 빈도는 다중 열 통계가없는 것처럼 열별 통계에서 계산 된 빈도입니다. 열 중 하나에에 null 값이 있었다면, 이것은에서 확인 될 &lt;code&gt;nulls&lt;/code&gt; 열입니다.</target>
        </trans-unit>
        <trans-unit id="a75759d2d2d52e1dc2865efa8cf2fb6090b3f128" translate="yes" xml:space="preserve">
          <source>This constant is a two-dimensional, 3-by-3 array consisting of three subarrays of integers.</source>
          <target state="translated">이 상수는 3 개의 하위 배열로 구성된 2 차원 3x3 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a1d39be831b881f732286b6571d19294d43d84bf" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. It is a non-inheritable constraint.</source>
          <target state="translated">이 제한 조건은 관계에 대해 로컬로 정의됩니다. 상속 할 수없는 제약 조건입니다.</target>
        </trans-unit>
        <trans-unit id="ee0fafaed69e2c50c035d4176a4d38521e63e5d6" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. Note that a constraint can be locally defined and inherited simultaneously.</source>
          <target state="translated">이 제한 조건은 관계에 대해 로컬로 정의됩니다. 제약 조건은 로컬에서 정의하고 동시에 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="677137c6fdb574fcaee9a2f495faececc7604ba8" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will either be true or false, never null.</source>
          <target state="translated">이 구성은 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 행 비교 와 유사 하지만 널 입력에 대해서는 널을 생성하지 않습니다. 대신, 널 (null) 값은 널 (null)이 아닌 값과 같지 않은 것으로 간주되며, 두 개의 널 (null)은 동일한 것으로 간주됩니다 (고유하지 않음). 따라서 결과는 true 또는 false이며 절대 null이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1020bde7bf73c7df63ce8acf0bfdb90bb93b7fcb" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;=&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will always be either true or false, never null.</source>
          <target state="translated">이 구문은 &lt;code&gt;=&lt;/code&gt; 행 비교 와 비슷 하지만 null 입력에 대해서는 null을 생성하지 않습니다. 대신, 널 (null) 값은 널 (null)이 아닌 값과 같지 않은 것으로 간주되며, 두 개의 널 (null)은 동일한 것으로 간주됩니다 (고유하지 않음). 따라서 결과는 항상 true 또는 false이며 절대 null이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="33a306bcfd5b03d8e762816f623417a83fd23a93" translate="yes" xml:space="preserve">
          <source>This controls how many pages or tuples of a single relation can be predicate-locked before the lock is promoted to covering the whole relation. Values greater than or equal to zero mean an absolute limit, while negative values mean &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt; divided by the absolute value of this setting. The default is -2, which keeps the behavior from previous versions of PostgreSQL. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">이는 잠금이 전체 관계를 포함하도록 승격되기 전에 단일 관계의 페이지 또는 튜플이 얼마나 많은 술어를 잠글 수 있는지 제어합니다. 0보다 크거나 같은 값은 절대 제한을 의미하고 음수 값은 &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction을이&lt;/a&gt; 설정의 절대 값으로 나눈 값을 의미 합니다. 기본값은 -2이며 이전 버전의 PostgreSQL에서 동작을 유지합니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37486631dcaede39c55161d228505d69d73e3e22" translate="yes" xml:space="preserve">
          <source>This controls how many rows on a single page can be predicate-locked before the lock is promoted to covering the whole page. The default is 2. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">잠금이 전체 페이지를 덮기 전에 단일 페이지에서 얼마나 많은 행이 술어 잠금 될 수 있는지 제어합니다. 기본값은 2입니다.이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8a7a6bb04de3147a65fe3e69e114d351a95bdd3" translate="yes" xml:space="preserve">
          <source>This controls whether a quote mark can be represented by &lt;code&gt;\'&lt;/code&gt; in a string literal. The preferred, SQL-standard way to represent a quote mark is by doubling it (&lt;code&gt;''&lt;/code&gt;) but PostgreSQL has historically also accepted &lt;code&gt;\'&lt;/code&gt;. However, use of &lt;code&gt;\'&lt;/code&gt; creates security risks because in some client character set encodings, there are multibyte characters in which the last byte is numerically equivalent to ASCII &lt;code&gt;\&lt;/code&gt;. If client-side code does escaping incorrectly then a SQL-injection attack is possible. This risk can be prevented by making the server reject queries in which a quote mark appears to be escaped by a backslash. The allowed values of &lt;code&gt;backslash_quote&lt;/code&gt; are &lt;code&gt;on&lt;/code&gt; (allow &lt;code&gt;\'&lt;/code&gt; always), &lt;code&gt;off&lt;/code&gt; (reject always), and &lt;code&gt;safe_encoding&lt;/code&gt; (allow only if client encoding does not allow ASCII &lt;code&gt;\&lt;/code&gt; within a multibyte character). &lt;code&gt;safe_encoding&lt;/code&gt; is the default setting.</source>
          <target state="translated">따옴표를 문자열 리터럴에서 &lt;code&gt;\'&lt;/code&gt; 로 표시 할 수 있는지 여부를 제어합니다 . 따옴표를 나타내는 기본 SQL 표준 방법은 &lt;code&gt;''&lt;/code&gt; 을 두 배로 늘리는 ( '' ) 것이지만 PostgreSQL은 역사적으로 &lt;code&gt;\'&lt;/code&gt; 받아 들였습니다 . 그러나 &lt;code&gt;\'&lt;/code&gt; 하면 일부 클라이언트 문자 세트 인코딩에서 마지막 바이트가 숫자 적으로 ASCII &lt;code&gt;\&lt;/code&gt; 와 동일한 멀티 바이트 문자가 있기 때문에 보안 위험이 발생합니다 . 클라이언트 측 코드가 잘못 이스케이프하면 SQL 주입 공격이 가능합니다. 이 위험은 서버가 백 슬래시로 따옴표가 이스케이프 된 쿼리를 거부하도록함으로써 방지 할 수 있습니다. &lt;code&gt;backslash_quote&lt;/code&gt; 의 허용 된 값 이 &lt;code&gt;on&lt;/code&gt; ( 허용됨) &lt;code&gt;\'&lt;/code&gt; 항상), &lt;code&gt;off&lt;/code&gt; ()는 항상 거부하고 &lt;code&gt;safe_encoding&lt;/code&gt; 클라이언트 인코딩이 ASCII를 허용하지 않는 경우에만 (수 &lt;code&gt;\&lt;/code&gt; 멀티 바이트 문자 내에서). &lt;code&gt;safe_encoding&lt;/code&gt; 이 기본 설정입니다.</target>
        </trans-unit>
        <trans-unit id="90ccb11174fcbc5e0dcaecf5ce4057bc44c37e08" translate="yes" xml:space="preserve">
          <source>This controls whether ordinary string literals (&lt;code&gt;'...'&lt;/code&gt;) treat backslashes literally, as specified in the SQL standard. Beginning in PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt; (prior releases defaulted to &lt;code&gt;off&lt;/code&gt;). Applications can check this parameter to determine how string literals will be processed. The presence of this parameter can also be taken as an indication that the escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;) is supported. Escape string syntax (&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;) should be used if an application desires backslashes to be treated as escape characters.</source>
          <target state="translated">이는 일반 문자열 리터럴 ( &lt;code&gt;'...'&lt;/code&gt; )이 SQL 표준에 지정된대로 백 슬래시를 문자 적으로 처리 하는지 여부를 제어합니다 . PostgreSQL 9.1부터는 기본값이 &lt;code&gt;on&lt;/code&gt; (사전 릴리스는 기본적으로 &lt;code&gt;off&lt;/code&gt; ). 애플리케이션은이 매개 변수를 확인하여 문자열 리터럴이 처리되는 방식을 결정할 수 있습니다. 이 매개 변수의 존재는 이스케이프 문자열 구문 ( &lt;code&gt;E'...'&lt;/code&gt; )이 지원됨을 나타내는 것으로 간주 될 수도 있습니다 . 응용 프로그램에서 백 슬래시를 이스케이프 문자로 처리하려면 이스케이프 문자열 구문 ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;4.1.2.2 절&lt;/a&gt; )을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="04ce8a3710d0e73d6eb9a44e5b7e7596e3b6ada8" translate="yes" xml:space="preserve">
          <source>This controls whether the array input parser recognizes unquoted &lt;code&gt;NULL&lt;/code&gt; as specifying a null array element. By default, this is &lt;code&gt;on&lt;/code&gt;, allowing array values containing null values to be entered. However, PostgreSQL versions before 8.2 did not support null values in arrays, and therefore would treat &lt;code&gt;NULL&lt;/code&gt; as specifying a normal array element with the string value &amp;ldquo;NULL&amp;rdquo;. For backward compatibility with applications that require the old behavior, this variable can be turned &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">배열 입력 구문 분석기가 따옴표없는 &lt;code&gt;NULL&lt;/code&gt; 을 널 배열 요소를 지정하는 것으로 인식하는지 여부를 제어합니다 . 기본적으로 이것은 &lt;code&gt;on&lt;/code&gt; 이므로 null 값을 포함하는 배열 값을 입력 할 수 있습니다. 그러나 8.2 이전의 PostgreSQL 버전은 배열에서 null 값을 지원하지 않으므로 문자열 값이 &quot;NULL&quot;인 일반 배열 요소를 지정하는 것으로 &lt;code&gt;NULL&lt;/code&gt; 을 처리 합니다 . 이전 동작이 필요한 응용 프로그램과의 호환성을 위해이 변수를 &lt;code&gt;off&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a334bdaf5d7adfdeb7bdd6cc764b677eb1d1fc0d" translate="yes" xml:space="preserve">
          <source>This controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable can be postponed until the end of the transaction (using the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command). &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; is the default. Currently, only &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, and &lt;code&gt;REFERENCES&lt;/code&gt; (foreign key) constraints accept this clause. &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints are not deferrable. Note that deferrable constraints cannot be used as conflict arbitrators in an &lt;code&gt;INSERT&lt;/code&gt; statement that includes an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause.</source>
          <target state="translated">제약 조건을 연기 할 수 있는지 여부를 제어합니다. 연기 할 수없는 구속 조건은 모든 명령 직후에 점검됩니다. &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; 명령을 사용하여 트랜잭션이 끝날 때까지 연기 할 수있는 제한 조건 검사를 연기 할 수 있습니다 . &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; 이 기본값입니다. 현재 &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; , &lt;code&gt;EXCLUDE&lt;/code&gt; 및 &lt;code&gt;REFERENCES&lt;/code&gt; (외부 키) 제약 조건 만이 절을 허용합니다. &lt;code&gt;NOT NULL&lt;/code&gt; 및 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 연기 할 수 없습니다. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 를 포함하는 &lt;code&gt;INSERT&lt;/code&gt; 문 에서 지연 가능한 제한 조건을 충돌 중재자로 사용할 수 없습니다. 절.</target>
        </trans-unit>
        <trans-unit id="1918927d29af63f959f031de4a1383381d5530a7" translate="yes" xml:space="preserve">
          <source>This creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;, a variadic function found in a schema that permits untrusted users to create objects. A malicious user can take control and execute arbitrary SQL functions as though you executed them. Substitute a call bearing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, which bypasses this hazard. Calls populating &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameters often have no equivalent formulation containing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword. To issue those calls safely, the function's schema must permit only trusted users to create objects.</source>
          <target state="translated">이것은 정규화 된 이름 &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt; 을 통해 신뢰할 수없는 사용자가 객체를 생성 할 수있는 스키마에있는 가변 함수 를 호출 할 때 보안 위험을 초래 합니다. 악의적 인 사용자는 마치 실행하는 것처럼 임의의 SQL 함수를 제어하고 실행할 수 있습니다. 이 위험을 우회 하는 &lt;code&gt;VARIADIC&lt;/code&gt; 키워드가 있는 통화를 대체하십시오 . &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 매개 변수를 채우는 호출 에는 종종 &lt;code&gt;VARIADIC&lt;/code&gt; 키워드를 포함하는 동등한 공식이 없습니다 . 이러한 호출을 안전하게 발행하려면 함수의 스키마에서 신뢰할 수있는 사용자 만 객체를 만들 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0046336b7276ca25c455594eb1a8ba81761391eb" translate="yes" xml:space="preserve">
          <source>This creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[9]&lt;/sup&gt;&lt;/a&gt;, a variadic function found in a schema that permits untrusted users to create objects. A malicious user can take control and execute arbitrary SQL functions as though you executed them. Substitute a call bearing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, which bypasses this hazard. Calls populating &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameters often have no equivalent formulation containing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword. To issue those calls safely, the function's schema must permit only trusted users to create objects.</source>
          <target state="translated">이것은 신뢰할 수없는 사용자가 객체를 생성 할 수 있도록 허용하는 스키마에서 발견되는 가변 함수 를 정규화 된 이름 &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[9]을&lt;/sup&gt;&lt;/a&gt; 통해 호출 할 때 보안 위험 을 만듭니다. 악의적 인 사용자는 마치 실행 한 것처럼 임의의 SQL 함수를 제어하고 실행할 수 있습니다. 이 위험을 우회 하는 &lt;code&gt;VARIADIC&lt;/code&gt; 키워드가 있는 호출을 대체하십시오 . &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 매개 변수를 채우는 호출 에는 종종 &lt;code&gt;VARIADIC&lt;/code&gt; 키워드를 포함하는 동등한 공식이 없습니다 . 이러한 호출을 안전하게 실행하려면 함수의 스키마가 신뢰할 수있는 사용자 만 개체를 ​​만들 수 있도록 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d12540189cdbd640895d38788f65f9fbba1d76fa" translate="yes" xml:space="preserve">
          <source>This creates a table named &lt;code&gt;my_first_table&lt;/code&gt; with two columns. The first column is named &lt;code&gt;first_column&lt;/code&gt; and has a data type of &lt;code&gt;text&lt;/code&gt;; the second column has the name &lt;code&gt;second_column&lt;/code&gt; and the type &lt;code&gt;integer&lt;/code&gt;. The table and column names follow the identifier syntax explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;Section 4.1.1&lt;/a&gt;. The type names are usually also identifiers, but there are some exceptions. Note that the column list is comma-separated and surrounded by parentheses.</source>
          <target state="translated">그러면 두 개의 열이있는 &lt;code&gt;my_first_table&lt;/code&gt; 이라는 테이블이 생성 됩니다. 첫 번째 열의 이름은 &lt;code&gt;first_column&lt;/code&gt; 이며 데이터 유형은 &lt;code&gt;text&lt;/code&gt; 입니다 . 두 번째 열의 이름은 &lt;code&gt;second_column&lt;/code&gt; 이고 &lt;code&gt;integer&lt;/code&gt; 유형 입니다 . 테이블 및 열 이름 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;은 4.1.1 절&lt;/a&gt; 에서 설명한 식별자 구문을 따릅니다 . 유형 이름도 일반적으로 식별자이지만 일부 예외가 있습니다. 열 목록은 쉼표로 구분되고 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="2df112a8a7b40124ef90c403fdef2c5ff1577746" translate="yes" xml:space="preserve">
          <source>This creates an availability hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;, any function found in a schema that permits untrusted users to create objects. A malicious user can create a function with the name of an existing function, replicating that function's parameters and appending novel parameters having default values. This precludes new calls to the original function. To forestall this hazard, place functions in schemas that permit only trusted users to create objects.</source>
          <target state="translated">이로 인해 정규화 된 이름 &lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt; 을 통해 신뢰할 수없는 사용자가 객체를 만들 수있는 스키마에서 발견 된 함수 를 호출 할 때 가용성에 위험이 생깁니다 . 악의적 인 사용자는 기존 함수의 이름으로 함수를 생성하여 해당 함수의 매개 변수를 복제하고 기본값을 가진 새로운 매개 변수를 추가 할 수 있습니다. 이것은 원래 함수에 대한 새로운 호출을 배제합니다. 이 위험을 막으려면 신뢰할 수있는 사용자 만 개체를 ​​만들 수 있도록 함수를 스키마에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="a732ec34a93086b562c56c901a996da67bed793b" translate="yes" xml:space="preserve">
          <source>This creates an availability hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/a&gt;, any function found in a schema that permits untrusted users to create objects. A malicious user can create a function with the name of an existing function, replicating that function's parameters and appending novel parameters having default values. This precludes new calls to the original function. To forestall this hazard, place functions in schemas that permit only trusted users to create objects.</source>
          <target state="translated">신뢰할 수없는 사용자가 객체를 생성 할 수 있도록 허용하는 스키마에서 발견 된 모든 함수 를 정규화 된 이름 &lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[9]을&lt;/sup&gt;&lt;/a&gt; 통해 호출 할 때 가용성 위험이 발생 합니다. 악의적 인 사용자는 기존 함수의 이름으로 함수를 생성하여 해당 함수의 매개 변수를 복제하고 기본값이있는 새로운 매개 변수를 추가 할 수 있습니다. 이것은 원래 함수에 대한 새로운 호출을 배제합니다. 이러한 위험을 방지하려면 신뢰할 수있는 사용자 만 개체를 ​​만들 수 있도록 허용하는 스키마에 함수를 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="5fd08e31876bb0659f97fc74e6e81b5de962b395" translate="yes" xml:space="preserve">
          <source>This creates registry entries used by the event viewer, under the default event source named &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;PostgreSQL&lt;/code&gt; 이라는 기본 이벤트 소스 아래에 이벤트 뷰어가 사용하는 레지스트리 항목이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2f685ce47d5796c5b17ed2dc2e9f2a95a1be4cb" translate="yes" xml:space="preserve">
          <source>This creates the scripts and compiles the C files containing user-defined functions and types. Then, to start the tutorial, do the following:</source>
          <target state="translated">스크립트를 작성하고 사용자 정의 함수 및 유형을 포함하는 C 파일을 컴파일합니다. 그런 다음 학습서를 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d9b31e3f2055cca38cc6b689ae9fad52cab29160" translate="yes" xml:space="preserve">
          <source>This design allows for both backwards-compatible header additions (add header extension chunks, or set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal such changes, and add supporting data to the extension area if needed).</source>
          <target state="translated">이 디자인은 이전 버전과 호환되는 헤더 추가 (헤더 확장 청크 추가 또는 하위 플래그 비트 설정)와 이전 버전과 호환되지 않는 변경 (고차 플래그 비트를 설정하여 이러한 변경을 알리고 지원 데이터를 확장에 추가 할 수 있음) 필요한 경우 면적).</target>
        </trans-unit>
        <trans-unit id="d1507a2d26ed6cd13d8f06661be29be45050cd21" translate="yes" xml:space="preserve">
          <source>This dictionary template is used to create dictionaries that replace a word with a synonym. Phrases are not supported (use the thesaurus template (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;) for that). A synonym dictionary can be used to overcome linguistic problems, for example, to prevent an English stemmer dictionary from reducing the word &amp;ldquo;Paris&amp;rdquo; to &amp;ldquo;pari&amp;rdquo;. It is enough to have a &lt;code&gt;Paris paris&lt;/code&gt; line in the synonym dictionary and put it before the &lt;code&gt;english_stem&lt;/code&gt; dictionary. For example:</source>
          <target state="translated">이 사전 템플릿은 단어를 동의어로 대체하는 사전을 작성하는 데 사용됩니다. 문구는 지원되지 않습니다 (동의어 사전 템플릿 ( &lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;12.6.4 절&lt;/a&gt; ) 사용). 동의어 사전은 예를 들어 영어 형태소 사전이 단어 &quot;Paris&quot;를 &quot;pari&quot;로 줄이는 것을 방지하기 위해 언어 문제를 극복하는 데 사용될 수 있습니다. 동의어 사전에 &lt;code&gt;Paris paris&lt;/code&gt; 라인이 &lt;code&gt;english_stem&lt;/code&gt; 사전 앞에 놓는 것으로 충분합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dfab7a227af58e60167bfee0ac87d5907b3ad3ee" translate="yes" xml:space="preserve">
          <source>This document answers frequently asked questions about SELinux. It focuses primarily on Fedora, but is not limited to Fedora.</source>
          <target state="translated">이 문서는 SELinux에 대한 질문과 대답을 제공합니다. 주로 Fedora에 중점을 두지 만 Fedora에만 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="64f99dd7f4a8868a1752a291c897889c1028116d" translate="yes" xml:space="preserve">
          <source>This document provides a wide spectrum of knowledge to administer SELinux on your systems. It focuses primarily on Red Hat operating systems, but is not limited to them.</source>
          <target state="translated">이 문서는 시스템에서 SELinux를 관리하기위한 광범위한 지식을 제공합니다. 주로 Red Hat 운영 체제에 중점을 두지 만 이에 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d69a24fba08d14e58aa301ec18364f049dd9f435" translate="yes" xml:space="preserve">
          <source>This does not prevent cleanup of dead rows which have reached the age specified by &lt;code&gt;old_snapshot_threshold&lt;/code&gt;.</source>
          <target state="translated">이로 인해 &lt;code&gt;old_snapshot_threshold&lt;/code&gt; 에 의해 지정된 유효 기간에 도달 한 데드 행이 정리되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="34a33c8e067844a10adc4d1ec87dc8f9bed7f940" translate="yes" xml:space="preserve">
          <source>This does not work because &lt;code&gt;integer&lt;/code&gt; does not have an implicit cast to &lt;code&gt;text&lt;/code&gt;. An explicit cast will work, however:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 에는 암시 적 캐스트 &lt;code&gt;text&lt;/code&gt; 가 없기 때문에 작동 하지 않습니다 . 그러나 명시 적 캐스트는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f8a11325d581fd69da8d48499eb1dc3e0e55ab89" translate="yes" xml:space="preserve">
          <source>This equivalence between functional notation and field notation makes it possible to use functions on composite types to implement &amp;ldquo;computed fields&amp;rdquo;.   An application using the last query above wouldn't need to be directly aware that &lt;code&gt;somefunc&lt;/code&gt; isn't a real column of the table.</source>
          <target state="translated">기능 표기법과 필드 표기법의이 동등성으로 인해 복합 유형의 함수를 사용하여 &quot;계산 된 필드&quot;를 구현할 수 있습니다. 위의 마지막 쿼리를 사용하는 응용 프로그램은 &lt;code&gt;somefunc&lt;/code&gt; 가 테이블의 실제 열이 아니라는 것을 직접 인식하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="cf34fbb91a15c4b2d08b406f2026ab198cd22a33" translate="yes" xml:space="preserve">
          <source>This evaluates query on document and wraps the result in XML tags. If the result is multivalued, the output will look like:</source>
          <target state="translated">문서에 대한 쿼리를 평가하고 결과를 XML 태그로 래핑합니다. 결과가 다중 값 인 경우 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15ced5262cfea0d7c224d2d14022b915ded0c9bb" translate="yes" xml:space="preserve">
          <source>This example creates a composite type and uses it in a function definition:</source>
          <target state="translated">이 예제는 복합 유형을 작성하고이를 함수 정의에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fd20b024051cecf699f47d6601ef377cbbceb783" translate="yes" xml:space="preserve">
          <source>This example creates a large object type and uses it in a table definition:</source>
          <target state="translated">이 예제는 큰 객체 유형을 만들어 테이블 정의에 사용합니다.</target>
        </trans-unit>
        <trans-unit id="81988155ae08cfd1bb03bda3f7e767cd1d1e7982" translate="yes" xml:space="preserve">
          <source>This example creates a range type:</source>
          <target state="translated">이 예는 범위 유형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="29a86563a51e3572dd14a9d9255eda3ebb2201cc" translate="yes" xml:space="preserve">
          <source>This example creates an enumerated type and uses it in a table definition:</source>
          <target state="translated">이 예제는 열거 유형을 작성하고이를 테이블 정의에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e15c416b1eb4a6e0ac422253fe9d7c571e4e1d98" translate="yes" xml:space="preserve">
          <source>This example creates the &lt;code&gt;us_postal_code&lt;/code&gt; data type and then uses the type in a table definition. A regular expression test is used to verify that the value looks like a valid US postal code:</source>
          <target state="translated">이 예제는 &lt;code&gt;us_postal_code&lt;/code&gt; 데이터 유형을 작성한 후 테이블 정의에서 유형을 사용합니다. 정규식 테스트를 사용하여 값이 유효한 미국 우편 번호처럼 보이는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="824e6c2d218cfa4fc262bbf54ecefd33c7e0d65c" translate="yes" xml:space="preserve">
          <source>This example creates the base data type &lt;code&gt;box&lt;/code&gt; and then uses the type in a table definition:</source>
          <target state="translated">이 예에서는 기본 데이터 형식 &lt;code&gt;box&lt;/code&gt; 를 만든 다음 테이블 정의에서 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="434cf5265b6621f51d3d3b20b1a695bea28ca57d" translate="yes" xml:space="preserve">
          <source>This example for Unix systems sets the locale to Swedish (&lt;code&gt;sv&lt;/code&gt;) as spoken in Sweden (&lt;code&gt;SE&lt;/code&gt;). Other possibilities might include &lt;code&gt;en_US&lt;/code&gt; (U.S. English) and &lt;code&gt;fr_CA&lt;/code&gt; (French Canadian). If more than one character set can be used for a locale then the specifications can take the form &lt;code&gt;language_territory.codeset&lt;/code&gt;. For example, &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; represents the French language (fr) as spoken in Belgium (BE), with a UTF-8 character set encoding.</source>
          <target state="translated">Unix 시스템의이 예는 스웨덴어 ( &lt;code&gt;SE&lt;/code&gt; ) 에서 사용 되는 로케일을 스웨덴어 ( &lt;code&gt;sv&lt;/code&gt; )로 설정합니다 . 다른 가능성으로는 &lt;code&gt;en_US&lt;/code&gt; (미국 영어) 및 &lt;code&gt;fr_CA&lt;/code&gt; (프랑스어 캐나다)가 있습니다. 로케일에 둘 이상의 문자 세트를 사용할 수있는 경우 스펙은 &lt;code&gt;language_territory.codeset&lt;/code&gt; 양식을 사용할 수 있습니다 . 예를 들어 &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; 은 벨기에 (BE)에서 사용되는 프랑스어 (fr)를 UTF-8 문자 세트 인코딩으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b2c48d8838d3c1575e17a1f1c1bf4b1c54be443" translate="yes" xml:space="preserve">
          <source>This example inserts into array columns:</source>
          <target state="translated">이 예제는 배열 열에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="42fa4c592cce0c22be8f54fb9056c02e69ce0496" translate="yes" xml:space="preserve">
          <source>This example inserts some rows into table &lt;code&gt;films&lt;/code&gt; from a table &lt;code&gt;tmp_films&lt;/code&gt; with the same column layout as &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">이 예에 나타난 일부 행 삽입 &lt;code&gt;films&lt;/code&gt; 테이블로부터 &lt;code&gt;tmp_films&lt;/code&gt; 같은 열 레이아웃 &lt;code&gt;films&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a463d9dae9db43b670ea9503d31a0e368fa4ee70" translate="yes" xml:space="preserve">
          <source>This example is equivalent to &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt;. More interesting cases, which cannot be reduced to a plain join, arise when the subquery involves grouping or aggregation.</source>
          <target state="translated">이 예는 &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt; 과 같습니다 . 하위 쿼리가 그룹화 또는 집계와 관련 될 때 일반 조인으로 줄일 수없는보다 흥미로운 경우가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="be1a5f2f3b699d99e46d29b68340b721327b27dd" translate="yes" xml:space="preserve">
          <source>This example is, of course, oversimplified, but there's a lot of control possible in a transaction block through the use of savepoints. Moreover, &lt;code&gt;ROLLBACK TO&lt;/code&gt; is the only way to regain control of a transaction block that was put in aborted state by the system due to an error, short of rolling it back completely and starting again.</source>
          <target state="translated">물론이 예제는 지나치게 단순화되었지만 저장 점을 사용하여 트랜잭션 블록에서 많은 제어가 가능합니다. 또한 &lt;code&gt;ROLLBACK TO&lt;/code&gt; 는 오류로 인해 시스템에 의해 중단 된 상태의 트랜잭션 블록에 대한 제어를 다시 얻는 유일한 방법으로, 완전히 롤백하고 다시 시작하는 데 부족합니다.</target>
        </trans-unit>
        <trans-unit id="a7b74712a2cd7143b58e55978ebc0a1e029aad05" translate="yes" xml:space="preserve">
          <source>This example produces a set something like:</source>
          <target state="translated">이 예제는 다음과 같은 세트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bd0849ce5d2cb6e49bc1884469c044510632ded5" translate="yes" xml:space="preserve">
          <source>This example shows a session that performs verification of the 10 largest catalog indexes in the database &amp;ldquo;test&amp;rdquo;. Verification of the presence of heap tuples as index tuples is requested for the subset that are unique indexes. Since no error is raised, all indexes tested appear to be logically consistent. Naturally, this query could easily be changed to call &lt;code&gt;bt_index_check&lt;/code&gt; for every index in the database where verification is supported.</source>
          <target state="translated">이 예는 데이터베이스 &quot;test&quot;에서 10 개의 가장 큰 카탈로그 색인을 확인하는 세션을 보여줍니다. 고유 인덱스 인 서브 세트에 대해 인덱스 튜플로서 힙 튜플이 있는지 검증해야합니다. 오류가 발생하지 않으므로 테스트 된 모든 인덱스가 논리적으로 일관된 것으로 보입니다. 당연히이 쿼리는 검증이 지원되는 데이터베이스의 모든 인덱스에 대해 &lt;code&gt;bt_index_check&lt;/code&gt; 를 호출하도록 쉽게 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52eaa3c393eb8836501cf0b71b2390cbd556c111" translate="yes" xml:space="preserve">
          <source>This example shows how to use a function in the &lt;code&gt;FROM&lt;/code&gt; clause, both with and without a column definition list:</source>
          <target state="translated">이 예는 열 정의 목록 유무에 관계없이 &lt;code&gt;FROM&lt;/code&gt; 절 에서 함수를 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="faf001583d1938e7eac65338b42d5145eeba9d29" translate="yes" xml:space="preserve">
          <source>This example shows how to use a simple &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="translated">이 예는 간단한 &lt;code&gt;WITH&lt;/code&gt; 절 을 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="dd1b1ae7add544b9cdd447e36bf84ceb80a1e127" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;LATERAL&lt;/code&gt; to apply a set-returning function &lt;code&gt;get_product_names()&lt;/code&gt; for each row of the &lt;code&gt;manufacturers&lt;/code&gt; table:</source>
          <target state="translated">이 예제는 &lt;code&gt;LATERAL&lt;/code&gt; 을 사용 하여 &lt;code&gt;manufacturers&lt;/code&gt; 테이블 의 각 행에 대해 반환 함수 &lt;code&gt;get_product_names()&lt;/code&gt; 를 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="36985cd8d425adbc4e1df7381c866befdc14c9f1" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;ROWS FROM&lt;/code&gt;:</source>
          <target state="translated">이 예에서는 &lt;code&gt;ROWS FROM&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0eba8d9892663515b6cc219ad20715d37c9c5396" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;WITH RECURSIVE&lt;/code&gt; to find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:</source>
          <target state="translated">이 예에서는 &lt;code&gt;WITH RECURSIVE&lt;/code&gt; 를 사용 하여 직속 하위 만 표시하는 테이블에서 직원 Mary의 모든 하위 직원 (직접 또는 간접)과 간접 수준을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="625799a6daa4d3a32ad43aba61a387f19b4df04e" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;DEFAULT&lt;/code&gt; clause for the date columns rather than specifying a value:</source>
          <target state="translated">이 예에서는 값을 지정하지 않고 날짜 열에 &lt;code&gt;DEFAULT&lt;/code&gt; 절을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="33b1cc724cf1f567bbb040ff9e9078c758235297" translate="yes" xml:space="preserve">
          <source>This example uses the following data (also available in file &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; in the source distribution):</source>
          <target state="translated">이 예제는 다음 데이터를 사용합니다 ( 소스 배포의 &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; 파일에서도 사용 가능 ).</target>
        </trans-unit>
        <trans-unit id="4a2eb1d66444608a417cb7a2c5c2fded452498b8" translate="yes" xml:space="preserve">
          <source>This example would remove all rows from tables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. The number of affected rows reported to the client would only include rows removed from &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">이 예제는 테이블 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 에서 모든 행을 제거합니다 . 클라이언트에보고 된 영향을받는 행 수에는 &lt;code&gt;bar&lt;/code&gt; 에서 제거 된 행만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="759fd9b05670f2874eee702f3df4de125c19d274" translate="yes" xml:space="preserve">
          <source>This example would use the standard Unicode collation in a nondeterministic way. In particular, this would allow strings in different normal forms to be compared correctly. More interesting examples make use of the ICU customization facilities explained above. For example:</source>
          <target state="translated">이 예제는 비 결정적 방식으로 표준 유니 코드 데이터 정렬을 사용합니다. 특히, 이렇게하면 다른 일반 형식의 문자열을 올바르게 비교할 수 있습니다. 더 흥미로운 예는 위에서 설명한 ICU 사용자 정의 기능을 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a370e5d62e07be8745753fc6bbcb3e1a1d2437da" translate="yes" xml:space="preserve">
          <source>This expanded version of the previous query shows the operator family each operator class belongs to:</source>
          <target state="translated">이전 쿼리의이 확장 된 버전은 각 연산자 클래스가 속하는 연산자 제품군을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d891c30f21d694bab5f748d5f0b9dd9f8f629f4a" translate="yes" xml:space="preserve">
          <source>This expression returns the size of the track if it contains any segments with high heart rate values, or an empty sequence otherwise.</source>
          <target state="translated">이 표현식은 높은 심박수 값을 가진 세그먼트가 포함 된 경우 트랙의 크기를 반환하거나 그렇지 않으면 빈 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0d9bda9d80ab3b41fb483157cc1a94532dbac7fb" translate="yes" xml:space="preserve">
          <source>This expression yields true when two time periods (defined by their endpoints) overlap, false when they do not overlap. The endpoints can be specified as pairs of dates, times, or time stamps; or as a date, time, or time stamp followed by an interval. When a pair of values is provided, either the start or the end can be written first; &lt;code&gt;OVERLAPS&lt;/code&gt; automatically takes the earlier value of the pair as the start. Each time period is considered to represent the half-open interval &lt;code&gt;start&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;time&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;end&lt;/code&gt;, unless &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are equal in which case it represents that single time instant. This means for instance that two time periods with only an endpoint in common do not overlap.</source>
          <target state="translated">이 표현식은 두 개의 기간 (끝점으로 정의 됨)이 겹치면 true를, 겹치지 않으면 false를 생성합니다. 끝점은 날짜, 시간 또는 타임 스탬프 쌍으로 지정할 수 있습니다. 또는 날짜, 시간 또는 타임 스탬프와 간격이 있습니다. 한 쌍의 값이 제공되면 시작 또는 끝을 먼저 쓸 수 있습니다. &lt;code&gt;OVERLAPS&lt;/code&gt; 는 자동으로 쌍의 이전 값을 시작으로 사용합니다. &lt;code&gt;start&lt;/code&gt; 와 &lt;code&gt;end&lt;/code&gt; 가 동일 하지 않으면 각 시간은 반 개방 간격 &lt;code&gt;start&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;time&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;end&lt;/code&gt; 를 나타내는 것으로 간주됩니다 . 이는 예를 들어 공통 엔드 포인트 만있는 두 기간이 겹치지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c11b883111f39a35c0f589a7362884a445b2f9be" translate="yes" xml:space="preserve">
          <source>This extensibility should not be confused with the extensibility of the other standard search trees in terms of the data they can handle. For example, PostgreSQL supports extensible B-trees and hash indexes. That means that you can use PostgreSQL to build a B-tree or hash over any data type you want. But B-trees only support range predicates (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;), and hash indexes only support equality queries.</source>
          <target state="translated">이 확장 성은 다른 표준 검색 트리의 확장 성과 처리 할 수있는 데이터 측면에서 혼동되어서는 안됩니다. 예를 들어 PostgreSQL은 확장 가능한 B- 트리 및 해시 인덱스를 지원합니다. 즉, PostgreSQL을 사용하여 원하는 모든 데이터 유형에 대해 B- 트리 또는 해시를 구축 할 수 있습니다. 그러나 B- 트리는 범위 술어 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; ) 만 지원하고 해시 인덱스는 동등 쿼리 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="25249be2bc655571c6b319a5e05ab9bf57e7f0ce" translate="yes" xml:space="preserve">
          <source>This extension won't build at all unless the installation was configured with &lt;code&gt;--with-openssl&lt;/code&gt;.</source>
          <target state="translated">설치가 &lt;code&gt;--with-openssl&lt;/code&gt; 로 구성되어 있지 않으면이 확장은 전혀 빌드되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="985d874d57f888d6b7d33a42c3b39fe6c5d40324" translate="yes" xml:space="preserve">
          <source>This failure occurs because PostgreSQL treats multiple &lt;code&gt;UNION&lt;/code&gt;s as a nest of pairwise operations; that is, this input is the same as</source>
          <target state="translated">이 실패는 PostgreSQL이 여러 &lt;code&gt;UNION&lt;/code&gt; 을 쌍별 작업의 중첩으로 취급하기 때문에 발생합니다 . 즉,이 입력은</target>
        </trans-unit>
        <trans-unit id="9dea5b639461b36e0d899f8204fb2b765c1a0fb6" translate="yes" xml:space="preserve">
          <source>This feature is disabled by default for manually issued &lt;code&gt;VACUUM&lt;/code&gt; commands. To enable it, set the &lt;code&gt;vacuum_cost_delay&lt;/code&gt; variable to a nonzero value.</source>
          <target state="translated">이 기능은 수동으로 발행 된 &lt;code&gt;VACUUM&lt;/code&gt; 명령에 대해 기본적으로 비활성화되어 있습니다 . 이를 사용하려면 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 변수를 0이 아닌 값으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7554d4b1db763d2db35742e4df9b2b6a631440fa" translate="yes" xml:space="preserve">
          <source>This feature is intended as a temporary measure until a complete solution is found. At that time, this option will be removed.</source>
          <target state="translated">이 기능은 완전한 솔루션을 찾을 때까지 임시 조치로 사용됩니다. 이때이 옵션은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="37d4c1ac5e0b12c58cdf26713648d8dd1dfac571" translate="yes" xml:space="preserve">
          <source>This feature was designed to allow parameters not normally known to PostgreSQL to be added by add-on modules (such as procedural languages). This allows extension modules to be configured in the standard ways.</source>
          <target state="translated">이 기능은 PostgreSQL에 일반적으로 알려지지 않은 매개 변수를 추가 모듈 (예 : 절차 언어)로 추가 할 수 있도록 설계되었습니다. 이를 통해 확장 모듈을 표준 방식으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6d9b959196517fcbab35a6da62247fb2b91ad04" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from Bash.</source>
          <target state="translated">이 기능은 Bash에서 뻔뻔스럽게 표절되었습니다.</target>
        </trans-unit>
        <trans-unit id="9dd0c7f9cb881f24c299dc7cd6acc6e93722283f" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from tcsh.</source>
          <target state="translated">이 기능은 tcsh에서 뻔뻔스럽게 표절되었습니다.</target>
        </trans-unit>
        <trans-unit id="195725685743f0dba93fa9e927faaeac64a5e891" translate="yes" xml:space="preserve">
          <source>This field is not available in PostgreSQL releases prior to 8.3.</source>
          <target state="translated">8.3 이전의 PostgreSQL 릴리스에서는이 필드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6136f38c2e93a8910734e7b6cf3ef3cea4cdbf88" translate="yes" xml:space="preserve">
          <source>This field only applies to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="translated">이 필드는 &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;hostssl&lt;/code&gt; 및 &lt;code&gt;hostnossl&lt;/code&gt; 레코드 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bb02774d9e01b5ecb4a1f9ea9a8d0284469c4dd" translate="yes" xml:space="preserve">
          <source>This flag does not behave identically to the &lt;code&gt;-t&lt;/code&gt; flag of pg_dump. There is not currently any provision for wild-card matching in pg_restore, nor can you include a schema name within its &lt;code&gt;-t&lt;/code&gt;. And, while pg_dump's &lt;code&gt;-t&lt;/code&gt; flag will also dump subsidiary objects (such as indexes) of the selected table(s), pg_restore's &lt;code&gt;-t&lt;/code&gt; flag does not include such subsidiary objects.</source>
          <target state="translated">이 플래그는 pg_dump 의 &lt;code&gt;-t&lt;/code&gt; 플래그 와 동일하게 작동하지 않습니다 . 현재 pg_restore에는 와일드 카드 일치에 대한 규정이 없으며 &lt;code&gt;-t&lt;/code&gt; 내에 스키마 이름을 포함시킬 수도 없습니다 . 또한 pg_dump의 &lt;code&gt;-t&lt;/code&gt; 플래그는 선택된 테이블의 보조 객체 (예 : 인덱스)도 덤프하지만 pg_restore의 &lt;code&gt;-t&lt;/code&gt; 플래그는 그러한 보조 객체를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="238947e6bf1928a48d022f51eceab630f9f9ea68" translate="yes" xml:space="preserve">
          <source>This forces the checkpoint to be done as quickly as possible.</source>
          <target state="translated">이렇게하면 검사 점이 가능한 빨리 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="69aa54921685a649b05a319351142e3198d02907" translate="yes" xml:space="preserve">
          <source>This form adds a new &lt;code&gt;PRIMARY KEY&lt;/code&gt; or &lt;code&gt;UNIQUE&lt;/code&gt; constraint to a table based on an existing unique index. All the columns of the index will be included in the constraint.</source>
          <target state="translated">이 형식 은 기존 고유 인덱스를 기반으로 테이블에 새 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;UNIQUE&lt;/code&gt; 제약 조건을 추가합니다 . 인덱스의 모든 열이 제약 조건에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3ba31c86d5c7be29caf3e323f522bf84c40b7fcf" translate="yes" xml:space="preserve">
          <source>This form adds a new attribute to a composite type, using the same syntax as &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;.</source>
          <target state="translated">이 양식은 &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 과 동일한 구문을 사용하여 복합 유형에 새 속성을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a0322ba886bea1157dcae5f05c22210a2d27f5b1" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Unlike the case when adding a column to a regular table, nothing happens to the underlying storage: this action simply declares that some new column is now accessible through the foreign table.</source>
          <target state="translated">이 양식은 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 과 동일한 구문을 사용하여 외부 테이블에 새 열을 추가합니다 . 일반 테이블에 열을 추가하는 경우와 달리 기본 스토리지에는 아무 변화가 없습니다.이 조치는 이제 외부 테이블을 통해 일부 새 열에 액세스 할 수 있음을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="95c0b10fe4a25bd3c814ee981b4c421d53eaf37a" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the table, using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified and a column already exists with this name, no error is thrown.</source>
          <target state="translated">이 양식은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 과 동일한 구문을 사용하여 테이블에 새 열을 추가합니다 . 경우 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 지정되고 열이 이미이 이름을 가진, 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8ee63428230bf79c5e0942a3cc936820a6d5d6f" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a domain using the same syntax as &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. When a new constraint is added to a domain, all columns using that domain will be checked against the newly added constraint. These checks can be suppressed by adding the new constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option; the constraint can later be made valid using &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt;. Newly inserted or updated rows are always checked against all constraints, even those marked &lt;code&gt;NOT VALID&lt;/code&gt;. &lt;code&gt;NOT VALID&lt;/code&gt; is only accepted for &lt;code&gt;CHECK&lt;/code&gt; constraints.</source>
          <target state="translated">이 양식은 &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt; 과 동일한 구문을 사용하여 도메인에 새로운 제한 조건을 추가합니다 . 새 제약 조건이 도메인에 추가되면 해당 도메인을 사용하는 모든 열이 새로 추가 된 제약 조건과 비교하여 검사됩니다. &lt;code&gt;NOT VALID&lt;/code&gt; 옵션을 사용하여 새 제한 조건을 추가하여 이러한 점검을 억제 할 수 있습니다 . &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt; 사용하여 제약 조건을 나중에 유효하게 만들 수 있습니다 . 새로 삽입되거나 업데이트 된 행은 항상 &lt;code&gt;NOT VALID&lt;/code&gt; 로 표시된 모든 제한 조건에 대해 검사 됩니다. &lt;code&gt;NOT VALID&lt;/code&gt; 는 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f1ef6b759daf52986e80a140fc1e8e6996a0c1e" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Currently only &lt;code&gt;CHECK&lt;/code&gt; constraints are supported.</source>
          <target state="translated">이 형식은 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 과 동일한 구문을 사용하여 외래 테이블에 새로운 제약 조건을 추가합니다 . 현재 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="99cace79007308dc0d8e7331f85a19c72d625225" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a table using the same constraint syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, plus the option &lt;code&gt;NOT VALID&lt;/code&gt;, which is currently only allowed for foreign key and CHECK constraints.</source>
          <target state="translated">이 형식은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 과 동일한 제약 구문과 &lt;code&gt;NOT VALID&lt;/code&gt; 옵션을 사용하여 테이블에 새로운 제약 조건을 추가합니다. 이 옵션 은 현재 외래 키 및 CHECK 제약 조건에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="60c743b0f8a6b250501ac85a73828ca722af7185" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a table using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, plus the option &lt;code&gt;NOT VALID&lt;/code&gt;, which is currently only allowed for foreign key and CHECK constraints.</source>
          <target state="translated">이 형식은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 과 동일한 구문과 &lt;code&gt;NOT VALID&lt;/code&gt; 옵션을 사용하여 테이블에 새 제약 조건을 추가합니다. 이 옵션 에는 현재 외래 키 및 CHECK 제약 조건에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ce19ef3782b6ce0c5b9df7476cc0daa1dd41c54" translate="yes" xml:space="preserve">
          <source>This form adds a new value to an enum type. The new value's place in the enum's ordering can be specified as being &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; one of the existing values. Otherwise, the new item is added at the end of the list of values.</source>
          <target state="translated">이 형식은 열거 형에 새로운 값을 추가합니다. 열거의 순서에 새 값의 장소로서 지정 될 수 있습니다 &lt;code&gt;BEFORE&lt;/code&gt; 또는 &lt;code&gt;AFTER&lt;/code&gt; 기존 값 중 하나를. 그렇지 않으면 값 목록 끝에 새 항목이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f6cf59f2735afa1f2d995a149ad05a9eb1b35eb7" translate="yes" xml:space="preserve">
          <source>This form adds an existing object to the extension. This is mainly useful in extension update scripts. The object will subsequently be treated as a member of the extension; notably, it can only be dropped by dropping the extension.</source>
          <target state="translated">이 양식은 기존 개체를 확장에 추가합니다. 이것은 주로 확장 업데이트 스크립트에서 유용합니다. 이후에 객체는 확장의 멤버로 취급됩니다. 특히 확장을 삭제해야만 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="595f54e5f3b774c232dc30ed51e46c90273688d9" translate="yes" xml:space="preserve">
          <source>This form adds the target foreign table as a new child of the specified parent table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">이 양식은 대상 외부 테이블을 지정된 상위 테이블의 새 하위로 추가합니다. 자세한 내용은 유사한 형식의 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="927ec7cd6b47cc568c9f6a02695b9db39fd050a7" translate="yes" xml:space="preserve">
          <source>This form adds the target table as a new child of the specified parent table. Subsequently, queries against the parent will include records of the target table. To be added as a child, the target table must already contain all the same columns as the parent (it could have additional columns, too). The columns must have matching data types, and if they have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the parent then they must also have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the child.</source>
          <target state="translated">이 양식은 대상 테이블을 지정된 상위 테이블의 새 하위로 추가합니다. 결과적으로 부모에 대한 쿼리에는 대상 테이블의 레코드가 포함됩니다. 하위로 추가하려면 대상 테이블에 상위와 동일한 열이 모두 포함되어 있어야합니다 (추가 열도있을 수 있음). 열은 일치하는 데이터 유형을해야하며, 그들이 가지고있는 경우 &lt;code&gt;NOT NULL&lt;/code&gt; 의 부모에 제약을 그들은 또한이 있어야합니다 &lt;code&gt;NOT NULL&lt;/code&gt; 의 아이의 제약을.</target>
        </trans-unit>
        <trans-unit id="d346519cab151e59ba4d85ab858ae6233fa9d98e" translate="yes" xml:space="preserve">
          <source>This form alters the attributes of a constraint that was previously created. Currently only foreign key constraints may be altered.</source>
          <target state="translated">이 양식은 이전에 작성된 구속 조건의 속성을 변경합니다. 현재 외래 키 제약 조건 만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c3d28a97b5f73f4ab63b75ff86f6835976075b5" translate="yes" xml:space="preserve">
          <source>This form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using &lt;code&gt;FOR VALUES&lt;/code&gt; or as a default partition by using &lt;code&gt;DEFAULT&lt;/code&gt;. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the target table. (See also &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.)</source>
          <target state="translated">이 양식은 기존 테이블 (파티션 될 수도 있음)을 대상 테이블의 파티션으로 첨부합니다. 테이블은 &lt;code&gt;FOR VALUES&lt;/code&gt; 를 사용하여 특정 값에 대한 파티션 으로, 또는 &lt;code&gt;DEFAULT&lt;/code&gt; 를 사용하여 기본 파티션 으로 첨부 할 수 있습니다 . 대상 테이블의 각 인덱스에 대해 해당 테이블이 첨부 테이블에 작성됩니다. 또는 동등한 인덱스가 이미 존재하는 경우 &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; 이 실행 된 것처럼 목표 테이블의 인덱스에 첨부됩니다 . 기존 테이블이 외부 테이블 인 경우 목표 테이블에 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스가있는 경우 현재 테이블을 목표 테이블의 파티션으로 첨부 할 수 없습니다 . ( &lt;a href=&quot;sql-createforeigntable&quot;&gt;외부 테이블 작성&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1869ca7747dbe933e84af2c5cba71787701542d6" translate="yes" xml:space="preserve">
          <source>This form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using &lt;code&gt;FOR VALUES&lt;/code&gt; or as a default partition by using &lt;code&gt;DEFAULT&lt;/code&gt;. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the target table. (See also &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.) For each user-defined row-level trigger that exists in the target table, a corresponding one is created in the attached table.</source>
          <target state="translated">이 양식은 기존 테이블 (자체가 분할 될 수 있음)을 대상 테이블의 파티션으로 첨부합니다. 테이블은 &lt;code&gt;FOR VALUES&lt;/code&gt; 를 사용하여 특정 값에 대한 파티션으로 연결 하거나 &lt;code&gt;DEFAULT&lt;/code&gt; 를 사용하여 기본 파티션으로 연결할 수 있습니다 . 대상 테이블의 각 인덱스에 대해 첨부 된 테이블에 해당 인덱스가 생성됩니다. 또는 동등한 인덱스가 이미 존재하는 경우 &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; 이 실행 된 것처럼 대상 테이블의 인덱스에 첨부됩니다 . 기존 테이블이 외부 테이블 인 경우 대상 테이블에 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스 가 있으면 현재 테이블을 대상 테이블의 파티션으로 첨부 할 수 없습니다 . ( &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 참조.) 대상 테이블에 존재하는 각 사용자 정의 행 수준 트리거에 대해 해당 트리거가 첨부 된 테이블에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bc3fb037ad7936c80f6f29d8637098894917452d" translate="yes" xml:space="preserve">
          <source>This form can be used to create the foreign table as partition of the given parent table with specified partition bound values. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details. Note that it is currently not allowed to create the foreign table as a partition of the parent table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the parent table. (See also &lt;a href=&quot;sql-altertable&quot;&gt;&lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">이 형식을 사용하면 지정된 파티션 바운드 값으로 지정된 부모 테이블의 파티션으로 외부 테이블을 만들 수 있습니다. 자세한 내용은 비슷한 형식의 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오. 상위 테이블에 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스가있는 경우 현재 외부 테이블을 상위 테이블의 파티션으로 작성할 수 없습니다 . &lt;a href=&quot;sql-altertable&quot;&gt; &lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17c7c9cbd670ca1e7d92be433f5a08452d27c094" translate="yes" xml:space="preserve">
          <source>This form changes one or more index-method-specific storage parameters for the index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details on the available parameters. Note that the index contents will not be modified immediately by this command; depending on the parameter you might need to rebuild the index with &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; to get the desired effects.</source>
          <target state="translated">이 형식은 인덱스에 대한 하나 이상의 인덱스 방법 별 스토리지 매개 변수를 변경합니다. 사용 가능한 매개 변수에 대한 자세한 내용 은 &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 를 참조하십시오 . 색인 내용은이 명령으로 즉시 수정되지 않습니다. 매개 변수에 따라 원하는 효과를 얻기 위해 &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; 를 사용 하여 색인을 재 빌드해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85e33ac3b4ee94fcc601870b607686da66a411c8" translate="yes" xml:space="preserve">
          <source>This form changes one or more storage parameters for the table. See &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done with &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.</source>
          <target state="translated">이 양식은 테이블에 대한 하나 이상의 스토리지 매개 변수를 변경합니다. 사용 가능한 매개 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;변수에&lt;/a&gt; 대한 자세한 내용 은 스토리지 매개 변수 를 참조하십시오 . 이 명령으로 테이블 내용이 즉시 수정되지는 않습니다. 매개 변수에 따라 원하는 효과를 얻기 위해 테이블을 다시 작성해야 할 수도 있습니다. 즉 수행 할 수 있습니다 &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt; , &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 또는의 형태 중 하나 &lt;code&gt;ALTER TABLE&lt;/code&gt; 세력 테이블 재 작성이. 플래너 관련 매개 변수의 경우, 다음에 테이블이 잠길 때 변경 사항이 적용되므로 현재 실행중인 쿼리는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a90914d894dbf343cb6837e8578f6573c8aee615" translate="yes" xml:space="preserve">
          <source>This form changes one or more storage parameters for the table. See &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done with &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.</source>
          <target state="translated">이 양식은 테이블에 대한 하나 이상의 저장 매개 변수를 변경합니다. 사용 가능한 매개 변수에 대한 자세한 내용 은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문서 의 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;저장소 매개 변수&lt;/a&gt; 를 참조하십시오 . 테이블 내용은이 명령으로 즉시 수정되지 않습니다. 매개 변수에 따라 원하는 효과를 얻기 위해 테이블을 다시 작성해야 할 수도 있습니다. 이는 &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt; , &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 또는 테이블 재 작성을 강제하는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식 중 하나로 수행 할 수 있습니다 . 플래너 관련 매개 변수의 경우 다음에 테이블이 잠길 때부터 변경 사항이 적용되므로 현재 실행중인 쿼리는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e83d3c0b4c77e2425087c239b0df05fcb0116826" translate="yes" xml:space="preserve">
          <source>This form changes the index's tablespace to the specified tablespace and moves the data file(s) associated with the index to the new tablespace. To change the tablespace of an index, you must own the index and have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new tablespace. All indexes in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all indexes to be moved and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move indexes owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs will not be moved by this command, use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER INDEX&lt;/code&gt; invocations instead if desired. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">이 양식은 인덱스의 테이블 스페이스를 지정된 테이블 스페이스로 변경하고 인덱스와 연관된 데이터 파일을 새 테이블 스페이스로 이동합니다. 인덱스의 테이블 스페이스를 변경하려면 인덱스를 소유 하고 새 테이블 스페이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한 이 있어야합니다 . &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; 양식 을 사용하여 테이블 공간에있는 현재 데이터베이스의 모든 인덱스를 이동할 수 있습니다. 그러면 모든 인덱스가 이동되어 각 인덱스가 이동됩니다. 이 형식은 또한 지정된 역할이 소유 한 인덱스 만 이동하는 &lt;code&gt;OWNED BY&lt;/code&gt; 를 지원 합니다. 는 IF &lt;code&gt;NOWAIT&lt;/code&gt; 의 옵션이 지정되는 즉시 필요한 잠금을 모두 취득 할 수없는 경우 명령이 실패합니다. 시스템 카탈로그는이 명령으로 이동되지 않으므로 &lt;code&gt;ALTER DATABASE&lt;/code&gt; 를 사용하십시오.또는 원하는 경우 명시적인 &lt;code&gt;ALTER INDEX&lt;/code&gt; 호출. &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c55be56dbc86b6d6779191aa5c394d5588fe660" translate="yes" xml:space="preserve">
          <source>This form changes the information which is written to the write-ahead log to identify rows which are updated or deleted. This option has no effect except when logical replication is in use. &lt;code&gt;DEFAULT&lt;/code&gt; (the default for non-system tables) records the old values of the columns of the primary key, if any. &lt;code&gt;USING INDEX&lt;/code&gt; records the old values of the columns covered by the named index, which must be unique, not partial, not deferrable, and include only columns marked &lt;code&gt;NOT NULL&lt;/code&gt;. &lt;code&gt;FULL&lt;/code&gt; records the old values of all columns in the row. &lt;code&gt;NOTHING&lt;/code&gt; records no information about the old row. (This is the default for system tables.) In all cases, no old values are logged unless at least one of the columns that would be logged differs between the old and new versions of the row.</source>
          <target state="translated">이 양식은 미리 쓰기 로그에 기록되는 정보를 변경하여 업데이트되거나 삭제 된 행을 식별합니다. 이 옵션은 논리적 복제가 사용중인 경우를 제외하고는 적용되지 않습니다. &lt;code&gt;DEFAULT&lt;/code&gt; (시스템이 아닌 테이블의 기본값)는 기본 키 열의 이전 값 (있는 경우)을 기록합니다. &lt;code&gt;USING INDEX&lt;/code&gt; 는 명명 된 인덱스가 포함하는 열의 이전 값을 기록합니다.이 값은 부분적이지 않고 지연 가능 &lt;code&gt;NOT NULL&lt;/code&gt; 로 표시된 열만 포함해야 합니다 . &lt;code&gt;FULL&lt;/code&gt; 은 행에있는 모든 열의 이전 값을 기록합니다. &lt;code&gt;NOTHING&lt;/code&gt; 이전 행에 대한 정보를 기록하지 않습니다. (이것은 시스템 테이블의 기본값입니다.) 모든 경우에, 기록 될 열 중 하나 이상이 이전 버전과 새 버전의 행 사이에 다른 경우가 아니면 이전 값은 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5fd7a415ae62d2432d673453426bcca0e434c22" translate="yes" xml:space="preserve">
          <source>This form changes the name of a constraint on a domain.</source>
          <target state="translated">이 양식은 도메인에 대한 제한 조건의 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="3a34d134067f8057fdc7eb4bd8e2afb5eac929d2" translate="yes" xml:space="preserve">
          <source>This form changes the name of the domain.</source>
          <target state="translated">이 양식은 도메인 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="bdaccc9f755620eea9c5a68106023cbc0c07f19d" translate="yes" xml:space="preserve">
          <source>This form changes the name of the type or the name of an individual attribute of a composite type.</source>
          <target state="translated">이 형식은 유형 이름 또는 복합 유형의 개별 속성 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8cfd4248390a30b80daebf0ff6ee06ccc365741e" translate="yes" xml:space="preserve">
          <source>This form changes the name of the type.</source>
          <target state="translated">이 양식은 유형의 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="33709234ccf296c21440f70a857148d5d605167b" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the domain to the specified user.</source>
          <target state="translated">이 양식은 도메인 소유자를 지정된 사용자로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="33c8412b485a6292103c360edb753fe679de7f49" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the foreign table to the specified user.</source>
          <target state="translated">이 양식은 외부 테이블의 소유자를 지정된 사용자로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="bdda20046cb686daa61e8bfb091f3201cdd5da85" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user.</source>
          <target state="translated">이 양식은 테이블, 시퀀스, 뷰, 구체화 된 뷰 또는 외부 테이블의 소유자를 지정된 사용자로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="367a0875855c27e375e704da43453b6a64108026" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the type.</source>
          <target state="translated">이 양식은 유형의 소유자를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="6515faf0d6c7bfb31358723522828dadb55476f0" translate="yes" xml:space="preserve">
          <source>This form changes the schema of the domain. Any constraints associated with the domain are moved into the new schema as well.</source>
          <target state="translated">이 양식은 도메인의 스키마를 변경합니다. 도메인과 관련된 모든 제약 조건도 새 스키마로 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="9ceb0679036b94c23ce3c3c3726ad7d1600fd754" translate="yes" xml:space="preserve">
          <source>This form changes the table from unlogged to logged or vice-versa (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt;&lt;code&gt;UNLOGGED&lt;/code&gt;&lt;/a&gt;). It cannot be applied to a temporary table.</source>
          <target state="translated">이 양식은 테이블을 기록되지 않은 상태에서 기록 된 상태로 또는 그 반대로 변경합니다 ( &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt; &lt;code&gt;UNLOGGED&lt;/code&gt; &lt;/a&gt; 참조 ). 임시 테이블에는 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b21eade6f7dd16e560cb3e285d036a4340eaa767" translate="yes" xml:space="preserve">
          <source>This form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional &lt;code&gt;SET TABLESPACE&lt;/code&gt; commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; will use that tablespace, unless overridden by a &lt;code&gt;TABLESPACE&lt;/code&gt; clause.</source>
          <target state="translated">이 양식은 테이블의 테이블 스페이스를 지정된 테이블 스페이스로 변경하고 테이블과 연관된 데이터 파일을 새 테이블 스페이스로 이동합니다. 테이블의 인덱스 (있는 경우)는 이동되지 않습니다. 그러나 추가 &lt;code&gt;SET TABLESPACE&lt;/code&gt; 명령을 사용 하여 별도로 이동할 수 있습니다 . 분할 된 테이블에 적용하면 아무것도 이동되지 않지만 나중에 &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; 로 생성 된 모든 분할 은 &lt;code&gt;TABLESPACE&lt;/code&gt; 절로 재정의되지 않는 한 해당 테이블 스페이스를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="413a825daa3f78a948f21b1ed732bd1afa98d9f3" translate="yes" xml:space="preserve">
          <source>This form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional &lt;code&gt;SET TABLESPACE&lt;/code&gt; commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; will use that tablespace, unless the &lt;code&gt;TABLESPACE&lt;/code&gt; clause is used to override it.</source>
          <target state="translated">이 양식은 테이블의 테이블 공간을 지정된 테이블 공간으로 변경하고 테이블과 연관된 데이터 파일을 새 테이블 공간으로 이동합니다. 테이블의 인덱스 (있는 경우)는 이동되지 않습니다. 추가 &lt;code&gt;SET TABLESPACE&lt;/code&gt; 명령을 사용 하여 별도로 이동할 수 있습니다 . 파티션 된 테이블에 적용되면 아무것도 이동되지 않지만, &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; 로 이후에 작성된 파티션 은 &lt;code&gt;TABLESPACE&lt;/code&gt; 절을 사용하여 테이블 스페이스 를 대체 하지 않는 한 해당 테이블 스페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d606494af7f67be03bcb787fb49d4fbd5e3725e9" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a foreign table. Again, this has no effect on any underlying storage: this action simply changes the type that PostgreSQL believes the column to have.</source>
          <target state="translated">이 형식은 외부 테이블의 열 유형을 변경합니다. 다시 말하지만 이는 기본 스토리지에는 영향을 미치지 않습니다.이 조치는 PostgreSQL이 열에 있다고 생각하는 유형을 변경하기 만합니다.</target>
        </trans-unit>
        <trans-unit id="ef90ca77493d55255faa9c05a6d21e673fa262d6" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a table. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optional &lt;code&gt;COLLATE&lt;/code&gt; clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional &lt;code&gt;USING&lt;/code&gt; clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. A &lt;code&gt;USING&lt;/code&gt; clause must be provided if there is no implicit or assignment cast from old to new type.</source>
          <target state="translated">이 형식은 테이블의 열 유형을 변경합니다. 열과 관련된 인덱스 및 간단한 테이블 제약 조건은 원래 제공된 식을 다시 구문 분석하여 새 열 유형을 사용하도록 자동으로 변환됩니다. 선택적 &lt;code&gt;COLLATE&lt;/code&gt; 절은 새 열의 데이터 정렬을 지정합니다. 생략하면 데이터 정렬이 새 열 유형의 기본값입니다. 선택적 &lt;code&gt;USING&lt;/code&gt; 절은 이전 항목에서 새 열 값을 계산하는 방법을 지정합니다. 생략하면 기본 변환은 이전 데이터 유형에서 새 유형으로 캐스트 된 지정과 동일합니다. &lt;code&gt;USING&lt;/code&gt; 새로운 유형으로 구에서 암시 적 또는 할당 캐스트가없는 경우 절을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f90f5c12001436438a106ce1bcbc9026c77d9b2f" translate="yes" xml:space="preserve">
          <source>This form changes the type of an attribute of a composite type.</source>
          <target state="translated">이 형식은 복합 유형의 속성 유형을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="c4194cb65228a21c483f32a1d7544636b626b6d4" translate="yes" xml:space="preserve">
          <source>This form detaches specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached.</source>
          <target state="translated">이 형식은 대상 테이블의 지정된 파티션을 분리합니다. 분리 된 파티션은 계속 독립형 테이블로 존재하지만 더 이상 분리 된 테이블과의 관계는 없습니다. 대상 테이블의 인덱스에 첨부 된 모든 인덱스가 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="e6073cfd81439f0b29a7e52096d2c9bbc8448ad6" translate="yes" xml:space="preserve">
          <source>This form detaches the specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached. Any triggers that were created as clones of those in the target table are removed.</source>
          <target state="translated">이 형식은 대상 테이블의 지정된 파티션을 분리합니다. 분리 된 파티션은 계속해서 독립형 테이블로 존재하지만 분리 된 테이블과 더 이상 연관이 없습니다. 대상 테이블의 인덱스에 첨부 된 모든 인덱스는 분리됩니다. 대상 테이블에있는 트리거의 복제본으로 생성 된 모든 트리거가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6f649e2a380d4d6a7844e29c8bec08b60d14e121" translate="yes" xml:space="preserve">
          <source>This form dissociates a typed table from its type.</source>
          <target state="translated">이 형식은 형식이 지정된 테이블을 형식에서 분리합니다.</target>
        </trans-unit>
        <trans-unit id="41af815da8671345e4d0830589af85c8c9d1f4f9" translate="yes" xml:space="preserve">
          <source>This form drops a column from a foreign table. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column; for example, views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">이 양식은 외부 테이블에서 열을 삭제합니다. 테이블 외부의 항목이 열에 의존하는 경우 &lt;code&gt;CASCADE&lt;/code&gt; 를 말해야 합니다. 예를 들어보기입니다. 경우 &lt;code&gt;IF EXISTS&lt;/code&gt; 지정되고 열이 존재하지 않는 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="132c35990a8f9ff6a2087c8c4db6bfe5bc0d3b7f" translate="yes" xml:space="preserve">
          <source>This form drops a column from a table. Indexes and table constraints involving the column will be automatically dropped as well. Multivariate statistics referencing the dropped column will also be removed if the removal of the column would cause the statistics to contain data for only a single column. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column, for example, foreign key references or views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">이 양식은 테이블에서 열을 삭제합니다. 열과 관련된 인덱스 및 테이블 제약 조건도 자동으로 삭제됩니다. 열을 제거하면 통계에 단일 열에 대한 데이터 만 포함되는 경우 삭제 된 열을 참조하는 다변량 통계도 제거됩니다. 테이블 외부의 항목이 외래 키 참조 또는 뷰와 같은 열에 의존하는 경우 &lt;code&gt;CASCADE&lt;/code&gt; 를 말해야 합니다. 경우 &lt;code&gt;IF EXISTS&lt;/code&gt; 지정되고 열이 존재하지 않는 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="630cbfc87f5704d127bcc228848ac6a6604a8fb0" translate="yes" xml:space="preserve">
          <source>This form drops an attribute from a composite type. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the attribute does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">이 형식은 복합 유형에서 속성을 삭제합니다. 경우 &lt;code&gt;IF EXISTS&lt;/code&gt; 지정되고 속성이 존재하지 않는 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="abbb33e28408b10284213af5010b6f9ed9616abd" translate="yes" xml:space="preserve">
          <source>This form drops constraints on a domain. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">이 양식은 도메인에 대한 제약 조건을 삭제합니다. 경우 &lt;code&gt;IF EXISTS&lt;/code&gt; 지정되고 제약 조건이 존재하지 않는 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="0562817256cba47f3678521e40341b9bb63428df" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a foreign table. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">이 형식은 외래 테이블에 지정된 제약 조건을 삭제합니다. 경우 &lt;code&gt;IF EXISTS&lt;/code&gt; 지정되고 제약 조건이 존재하지 않는 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="ef5c32eb106661dab4fdce48beeb3716d53be331" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a table, along with any index underlying the constraint. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">이 형식은 제약 조건의 기본이되는 인덱스와 함께 테이블에서 지정된 제약 조건을 삭제합니다. 경우 &lt;code&gt;IF EXISTS&lt;/code&gt; 지정되고 제약 조건이 존재하지 않는 오류가 발생하지 않습니다. 이 경우 대신 통지가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="d6075d1245dd08cd17ae12d300569e914c015d02" translate="yes" xml:space="preserve">
          <source>This form is not currently supported on partitioned tables.</source>
          <target state="translated">이 형식은 현재 파티션 된 테이블에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8b11f2ae6d44cb1444622b88c46b7122c4666b1" translate="yes" xml:space="preserve">
          <source>This form is only applicable to base types. It allows adjustment of a subset of the base-type properties that can be set in &lt;code&gt;CREATE TYPE&lt;/code&gt;. Specifically, these properties can be changed:</source>
          <target state="translated">이 양식은 기본 유형에만 적용됩니다. &lt;code&gt;CREATE TYPE&lt;/code&gt; 에서 설정할 수있는 기본 유형 속성의 하위 집합을 조정할 수 있습니다 . 특히 다음 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f77a1a6b3b2aecc7300bf71dbd0467e9777098c6" translate="yes" xml:space="preserve">
          <source>This form is only usable with composite types. It changes the name of an individual attribute of the type.</source>
          <target state="translated">이 양식은 복합 유형에서만 사용할 수 있습니다. 유형의 개별 속성 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="62fef7209d0ef0917314ea35bb80cd3a32ecadf7" translate="yes" xml:space="preserve">
          <source>This form links the table to a composite type as though &lt;code&gt;CREATE TABLE OF&lt;/code&gt; had formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure that &lt;code&gt;CREATE TABLE OF&lt;/code&gt; would permit an equivalent table definition.</source>
          <target state="translated">이 형식은 &lt;code&gt;CREATE TABLE OF&lt;/code&gt; 가 테이블 을 구성한 것처럼 테이블을 복합 유형에 연결 합니다. 테이블의 열 이름 및 유형 목록은 복합 유형과 정확히 일치해야합니다. 테이블은 다른 테이블에서 상속해서는 안됩니다. 이 제한 사항은 &lt;code&gt;CREATE TABLE OF&lt;/code&gt; 가 동등한 테이블 정의를 허용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="80c03819073116dcc932622328193f2e17ef52d2" translate="yes" xml:space="preserve">
          <source>This form marks as valid a constraint that was previously marked as &lt;code&gt;NOT VALID&lt;/code&gt;. No action is taken to verify the constraint, but future queries will assume that it holds.</source>
          <target state="translated">이 양식은 이전에 &lt;code&gt;NOT VALID&lt;/code&gt; 로 표시된 제한 조건을 유효한 것으로 표시 합니다. 제한 조건을 확인하기위한 조치는 수행되지 않지만 향후 쿼리는 제한 조건을 보유한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b14af7517538e421b68a1939c47cac2afc8ff879" translate="yes" xml:space="preserve">
          <source>This form marks the function as dependent on the extension, or no longer dependent on that extension if &lt;code&gt;NO&lt;/code&gt; is specified. A function that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="translated">이 양식은 기능이 확장에 종속 된 것으로 표시하거나 &lt;code&gt;NO&lt;/code&gt; 가 지정된 경우 더 이상 해당 확장에 종속되지 않음을 표시 합니다. 확장에 종속 된 것으로 표시된 함수는 확장이 삭제 될 때 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="058bcd5831cd602d111c74db2f7028e5e56ec71d" translate="yes" xml:space="preserve">
          <source>This form marks the index as dependent on the extension, or no longer dependent on that extension if &lt;code&gt;NO&lt;/code&gt; is specified. An index that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="translated">이 양식은 인덱스를 확장에 종속 된 것으로 표시하거나 &lt;code&gt;NO&lt;/code&gt; 가 지정된 경우 더 이상 해당 확장에 종속되지 않도록 표시 합니다. 확장에 종속 된 것으로 표시된 인덱스는 확장이 삭제 될 때 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="85cec438622a098483a45173b222a4d5cd019672" translate="yes" xml:space="preserve">
          <source>This form marks the index as dependent on the extension, such that if the extension is dropped, the index will automatically be dropped as well.</source>
          <target state="translated">이 양식은 확장에 종속 된 것으로 색인을 표시하여 확장을 삭제하면 색인도 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4faed3e54b7a44c7e7e8c551a8c0326f16df1512" translate="yes" xml:space="preserve">
          <source>This form moves the extension's objects into another schema. The extension has to be &lt;em&gt;relocatable&lt;/em&gt; for this command to succeed.</source>
          <target state="translated">이 형식은 확장의 개체를 다른 스키마로 이동합니다. 이 명령이 성공하려면 확장을 &lt;em&gt;재배치&lt;/em&gt; 할 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d44749fe236086787bbeb370c7b120c56a308916" translate="yes" xml:space="preserve">
          <source>This form moves the foreign table into another schema.</source>
          <target state="translated">이 양식은 외부 테이블을 다른 스키마로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="343fe32ad6664d950886e22df1f9e56f6f16399d" translate="yes" xml:space="preserve">
          <source>This form moves the table into another schema. Associated indexes, constraints, and sequences owned by table columns are moved as well.</source>
          <target state="translated">이 양식은 테이블을 다른 스키마로 이동합니다. 테이블 열이 소유 한 관련 인덱스, 제약 조건 및 시퀀스도 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="4a25f7c9422516454200b0986e93d0f9a7b1cd24" translate="yes" xml:space="preserve">
          <source>This form moves the type into another schema.</source>
          <target state="translated">이 양식은 유형을 다른 스키마로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="af28f23e1758f00a66bd13166257650c2c6c6e02" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; is a PostgreSQL extension. There is a &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; command in the SQL standard, but it is for adapting data types to client languages. That usage is not supported by PostgreSQL.</source>
          <target state="translated">이 형식의 &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; 은 PostgreSQL 확장입니다. SQL 표준 에는 &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; 명령이 있지만 데이터 유형을 클라이언트 언어에 맞게 조정하기위한 것입니다. 해당 사용법은 PostgreSQL에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ab065126927246d3956d5f89c1fdf1ac5a9c01c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;DROP TRANSFORM&lt;/code&gt; is a PostgreSQL extension. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for details.</source>
          <target state="translated">이 형식의 &lt;code&gt;DROP TRANSFORM&lt;/code&gt; 은 PostgreSQL 확장입니다. 자세한 내용은 &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="09d38af3e512e1a4bd2fd33c7735f8320af47f2b" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;json_object&lt;/code&gt; takes keys and values pairwise from separate text arrays. Otherwise it is identical to the one-argument form.</source>
          <target state="translated">이 형식의 &lt;code&gt;json_object&lt;/code&gt; 는 별도의 텍스트 배열에서 쌍으로 키와 값을 가져옵니다. 그렇지 않으면 단일 인수 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3ff5cb48fe56e9b363be562d91784fed1316defb" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;json_object&lt;/code&gt; takes keys and values pairwise from two separate arrays. In all other respects it is identical to the one-argument form.</source>
          <target state="translated">이 &lt;code&gt;json_object&lt;/code&gt; 형식은 두 개의 개별 배열에서 키와 값을 쌍으로 가져옵니다. 다른 모든 측면에서 이는 하나의 인수 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e130ed2324ecc47cb96bb25ee04c4b0d13167363" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; accepts a starting &lt;code&gt;query&lt;/code&gt; and a SQL &lt;code&gt;select&lt;/code&gt; command, which is given as a text string. The &lt;code&gt;select&lt;/code&gt; must yield two columns of &lt;code&gt;tsquery&lt;/code&gt; type. For each row of the &lt;code&gt;select&lt;/code&gt; result, occurrences of the first column value (the target) are replaced by the second column value (the substitute) within the current &lt;code&gt;query&lt;/code&gt; value. For example:</source>
          <target state="translated">이 형식의 &lt;code&gt;ts_rewrite&lt;/code&gt; 는 시작 &lt;code&gt;query&lt;/code&gt; 및 텍스트 문자열로 제공되는 SQL &lt;code&gt;select&lt;/code&gt; 명령을 승인 합니다. &lt;code&gt;select&lt;/code&gt; 두 개의 열을 양보해야 &lt;code&gt;tsquery&lt;/code&gt; 유형입니다. &lt;code&gt;select&lt;/code&gt; 결과 의 각 행에 대해 첫 번째 열 값 (대상)이 현재 &lt;code&gt;query&lt;/code&gt; 값 내에서 두 번째 열 값 (대체)으로 바뀝니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d013efd17243813d551b63d4312494e00c1c1a6c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; simply applies a single rewrite rule: &lt;code&gt;target&lt;/code&gt; is replaced by &lt;code&gt;substitute&lt;/code&gt; wherever it appears in &lt;code&gt;query&lt;/code&gt;. For example:</source>
          <target state="translated">이 형식의 &lt;code&gt;ts_rewrite&lt;/code&gt; 는 단일 재 작성 규칙을 간단히 적용합니다. &lt;code&gt;target&lt;/code&gt; 은 &lt;code&gt;query&lt;/code&gt; 에 표시 될 때마다 &lt;code&gt;substitute&lt;/code&gt; 대체됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb31fbf716a310edf9d2b4049a82ade012c42087" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language functions when the function name in the C language source code is not the same as the name of the SQL function. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C function, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the function's link symbol, that is, the name of the function in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL function being defined. The C names of all functions must be different, so you must give overloaded C functions different C names (for example, use the argument types as part of the C names).</source>
          <target state="translated">이 &lt;code&gt;AS&lt;/code&gt; 절 형식은 C 언어 소스 코드의 함수 이름이 SQL 함수의 이름과 동일하지 않은 경우 동적으로로드 가능한 C 언어 함수에 사용됩니다. 문자열 &lt;code&gt;obj_file&lt;/code&gt; 은 컴파일 된 C 함수를 포함하는 공유 라이브러리 파일의 이름이며 &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; 명령 과 같이 해석됩니다 . 문자열 &lt;code&gt;link_symbol&lt;/code&gt; 은 함수의 링크 심볼, 즉 C 언어 소스 코드의 함수 이름입니다. 링크 기호를 생략하면 정의중인 SQL 함수의 이름과 동일한 것으로 간주됩니다. 모든 함수의 C 이름은 달라야하므로 오버로드 된 C 함수에 다른 C 이름을 지정해야합니다 (예 : 인수 유형을 C 이름의 일부로 사용).</target>
        </trans-unit>
        <trans-unit id="2a04c3c78f722989a90da205ce8987d3f751510b" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language procedures when the procedure name in the C language source code is not the same as the name of the SQL procedure. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C procedure, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the procedure's link symbol, that is, the name of the procedure in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL procedure being defined.</source>
          <target state="translated">이 &lt;code&gt;AS&lt;/code&gt; 절 형식은 C 언어 소스 코드의 프로 시저 이름이 SQL 프로 시저 이름과 동일하지 않은 경우 동적으로로드 가능한 C 언어 프로 시저에 사용됩니다. 문자열 &lt;code&gt;obj_file&lt;/code&gt; 은 컴파일 된 C 프로 시저를 포함하는 공유 라이브러리 파일의 이름이며 &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; 명령 과 같이 해석됩니다 . 문자열 &lt;code&gt;link_symbol&lt;/code&gt; 은 프로 시저의 링크 기호, 즉 C 언어 소스 코드의 프로 시저 이름입니다. 링크 기호가 생략되면 정의중인 SQL 프로 시저의 이름과 동일한 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9d61def8f9ec3856b91d045805fea7f90a02d4de" translate="yes" xml:space="preserve">
          <source>This form of the command cannot be executed inside a transaction block.</source>
          <target state="translated">이 형식의 명령은 트랜잭션 블록 내에서 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="99f50353be2bb5b567c08b62d433e3835ac63124" translate="yes" xml:space="preserve">
          <source>This form only executes the function if column &lt;code&gt;balance&lt;/code&gt; has in fact changed value:</source>
          <target state="translated">이 형식은 열 &lt;code&gt;balance&lt;/code&gt; 이 실제로 값을 변경 한 경우에만 함수를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="f4473c42ad05dfd82fc106e9f90398e30bc2ce6b" translate="yes" xml:space="preserve">
          <source>This form removes a member object from the extension. This is mainly useful in extension update scripts. The object is not dropped, only disassociated from the extension.</source>
          <target state="translated">이 양식은 확장에서 구성원 개체를 제거합니다. 이것은 주로 확장 업데이트 스크립트에서 유용합니다. 개체는 삭제되지 않으며 확장 프로그램과 만 연결이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="eac856d748a6f647a905af09f04314ea23cd83c3" translate="yes" xml:space="preserve">
          <source>This form removes the most recently used &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; index specification from the table. This affects future cluster operations that don't specify an index.</source>
          <target state="translated">이 양식은 가장 최근에 사용 된 &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 색인 스펙을 테이블에서 제거 합니다. 이는 인덱스를 지정하지 않는 향후 클러스터 작업에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="b9adc8eb95719164761b79a5084426c7addf0749" translate="yes" xml:space="preserve">
          <source>This form removes the target foreign table from the list of children of the specified parent table.</source>
          <target state="translated">이 양식은 지정된 상위 테이블의 하위 목록에서 대상 외부 테이블을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9c78c98e24aa433ee20cbdef33df9ef970bae2bf" translate="yes" xml:space="preserve">
          <source>This form removes the target table from the list of children of the specified parent table. Queries against the parent table will no longer include records drawn from the target table.</source>
          <target state="translated">이 양식은 지정된 상위 테이블의 하위 목록에서 대상 테이블을 제거합니다. 상위 테이블에 대한 쿼리는 더 이상 대상 테이블에서 가져온 레코드를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c86659bd33298dbeea55e29cf320d1c3d50f459" translate="yes" xml:space="preserve">
          <source>This form renames a value of an enum type. The value's place in the enum's ordering is not affected. An error will occur if the specified value is not present or the new name is already present.</source>
          <target state="translated">이 형식은 열거 형 값의 이름을 바꿉니다. 열거 형 순서의 값 위치는 영향을받지 않습니다. 지정된 값이 없거나 새 이름이 이미 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d4bbf5050bebdaa653a528317e3e5511397a3bd9" translate="yes" xml:space="preserve">
          <source>This form resets one or more index-method-specific storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a &lt;code&gt;REINDEX&lt;/code&gt; might be needed to update the index entirely.</source>
          <target state="translated">이 형식은 하나 이상의 인덱스 방법 별 스토리지 매개 변수를 기본값으로 재설정합니다. 와 마찬가지로 &lt;code&gt;SET&lt;/code&gt; 하는 &lt;code&gt;REINDEX&lt;/code&gt; 는 전체 인덱스를 업데이트해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e49ca11d0f33e0a64657337a16309c7010218e7" translate="yes" xml:space="preserve">
          <source>This form resets one or more storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a table rewrite might be needed to update the table entirely.</source>
          <target state="translated">이 양식은 하나 이상의 스토리지 매개 변수를 기본값으로 재설정합니다. &lt;code&gt;SET&lt;/code&gt; 과 마찬가지로 테이블을 완전히 업데이트하려면 테이블을 다시 작성해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d66d6fd49dacdab7eaf9fc3512115d0797c065d" translate="yes" xml:space="preserve">
          <source>This form selects the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations. It does not actually re-cluster the table.</source>
          <target state="translated">이 양식은 향후 &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; 조작을 위한 기본 색인을 선택합니다 . 실제로 테이블을 다시 클러스터하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="518ddc9b662de15607142c00b06214f51c6fca69" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. Currently, the only defined per-attribute options are &lt;code&gt;n_distinct&lt;/code&gt; and &lt;code&gt;n_distinct_inherited&lt;/code&gt;, which override the number-of-distinct-values estimates made by subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. &lt;code&gt;n_distinct&lt;/code&gt; affects the statistics for the table itself, while &lt;code&gt;n_distinct_inherited&lt;/code&gt; affects the statistics gathered for the table plus its inheritance children. When set to a positive value, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the column contains exactly the specified number of distinct nonnull values. When set to a negative value, which must be greater than or equal to -1, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the number of distinct nonnull values in the column is linear in the size of the table; the exact count is to be computed by multiplying the estimated table size by the absolute value of the given number. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on the average. This can be useful when the size of the table changes over time, since the multiplication by the number of rows in the table is not performed until query planning time. Specify a value of 0 to revert to estimating the number of distinct values normally. For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">이 양식은 속성 별 옵션을 설정하거나 재설정합니다. 현재 정의 된 속성마다 유일하게 정의 된 옵션은 &lt;code&gt;n_distinct&lt;/code&gt; 및 &lt;code&gt;n_distinct_inherited&lt;/code&gt; 이며, 이는 후속 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 연산으로 작성된 고유 값 추정값을 대체합니다 . &lt;code&gt;n_distinct&lt;/code&gt; 는 테이블 자체 에 대한 통계에 영향을 미치며 &lt;code&gt;n_distinct_inherited&lt;/code&gt; 는 테이블에 대해 수집 된 통계와 상속 하위에 영향을줍니다. 양수 값으로 설정하면 &lt;code&gt;ANALYZE&lt;/code&gt; 는 열에 지정된 개수의 고유 한 널이 아닌 값이 정확하게 포함되어 있다고 가정합니다. 음수 값으로 설정된 경우 -1보다 크거나 같아야합니다. &lt;code&gt;ANALYZE&lt;/code&gt; 열의 고유 한 널이 아닌 값의 수가 테이블 크기에 선형이라고 가정합니다. 정확한 개수는 추정 된 테이블 크기에 주어진 숫자의 절대 값을 곱하여 계산됩니다. 예를 들어, -1 값은 열의 모든 값이 고유함을 의미하고 -0.5 값은 각 값이 평균에 두 번 나타남을 의미합니다. 쿼리 계획 시간까지 테이블의 행 수에 의한 곱셈이 수행되지 않으므로 시간이 지남에 따라 테이블 크기가 변경 될 때 유용 할 수 있습니다. 고유 값의 수를 정상적으로 추정하도록 되돌리려면 값 0을 지정하십시오. PostgreSQL 쿼리 플래너의 통계 사용에 대한 자세한 내용 &lt;a href=&quot;planner-stats&quot;&gt;은 14.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="895b894f198c38b8b568f74baad8144867fc06d4" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">이 양식은 속성 별 옵션을 설정하거나 재설정합니다. 비슷한 형태의 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE 참조&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="740f7c9cb8ed05218d4d039f1aa9f624d452a1af" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations, though can be used only on index columns that are defined as an expression. Since expressions lack a unique name, we refer to them using the ordinal number of the index column. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">이 형식은 후속 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 작업에 대한 열별 통계 수집 대상을 설정 하지만 식으로 정의 된 인덱스 열에서만 사용할 수 있습니다. 표현식에는 고유 한 이름이 없으므로 색인 열의 서수를 사용하여 참조합니다. 대상은 0 ~ 10000 범위에서 설정할 수 있습니다. 또는 시스템 기본 통계 대상 ( &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; ) 을 사용하여 되돌리려면 -1로 설정하십시오 . PostgreSQL 쿼리 플래너의 통계 사용에 대한 자세한 내용 &lt;a href=&quot;planner-stats&quot;&gt;은 14.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25d5f18188deb36d3de2faca967992d3efc2b40a" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">이 양식은 후속 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 조작에 대한 열별 통계 수집 목표를 설정 합니다. 자세한 내용은 유사한 형식의 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6332f7067a3fb1b7b86c9dc56f927e587c384e78" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">이 양식은 후속 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 조작에 대한 열별 통계 수집 목표를 설정 합니다. 대상은 0 ~ 10000 범위에서 설정할 수 있습니다. 또는 시스템 기본 통계 대상 ( &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; ) 을 사용하여 되돌리려면 -1로 설정하십시오 . PostgreSQL 쿼리 플래너의 통계 사용에 대한 자세한 내용 &lt;a href=&quot;planner-stats&quot;&gt;은 14.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4211581d9cac601dcf30af9c236c2e568347e8dc" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details. Note that the storage mode has no effect unless the table's foreign-data wrapper chooses to pay attention to it.</source>
          <target state="translated">이 양식은 열의 저장 모드를 설정합니다. 비슷한 형태의 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE 참조&lt;/a&gt; 을 참조하십시오. 스토리지 모드는 테이블의 외부 데이터 랩퍼가주의를 기울이지 않으면 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="647ec6a7abe325c2f43beddebcddae6af6d3e9e1" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. This controls whether this column is held inline or in a secondary TOAST table, and whether the data should be compressed or not. &lt;code&gt;PLAIN&lt;/code&gt; must be used for fixed-length values such as &lt;code&gt;integer&lt;/code&gt; and is inline, uncompressed. &lt;code&gt;MAIN&lt;/code&gt; is for inline, compressible data. &lt;code&gt;EXTERNAL&lt;/code&gt; is for external, uncompressed data, and &lt;code&gt;EXTENDED&lt;/code&gt; is for external, compressed data. &lt;code&gt;EXTENDED&lt;/code&gt; is the default for most data types that support non-&lt;code&gt;PLAIN&lt;/code&gt; storage. Use of &lt;code&gt;EXTERNAL&lt;/code&gt; will make substring operations on very large &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;bytea&lt;/code&gt; values run faster, at the penalty of increased storage space. Note that &lt;code&gt;SET STORAGE&lt;/code&gt; doesn't itself change anything in the table, it just sets the strategy to be pursued during future table updates. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">이 양식은 열의 저장 모드를 설정합니다. 이는이 열이 인라인으로 유지되는지 아니면 보조 TOAST 테이블로 유지되는지와 데이터를 압축해야하는지 여부를 제어합니다. &lt;code&gt;PLAIN&lt;/code&gt; 은 &lt;code&gt;integer&lt;/code&gt; 와 같은 고정 길이 값에 사용해야하며 압축되지 않은 인라인입니다. &lt;code&gt;MAIN&lt;/code&gt; 은 압축 가능한 인라인 데이터입니다. &lt;code&gt;EXTERNAL&lt;/code&gt; 은 압축되지 않은 외부 데이터를 위한 것이고 &lt;code&gt;EXTENDED&lt;/code&gt; 는 압축 된 외부 데이터를위한 것입니다. &lt;code&gt;EXTENDED&lt;/code&gt; 은 &lt;code&gt;PLAIN&lt;/code&gt; 스토리지 를 지원하는 대부분의 데이터 유형의 기본값입니다 . &lt;code&gt;EXTERNAL&lt;/code&gt; 을 사용하면 매우 큰 &lt;code&gt;text&lt;/code&gt; 에서 부분 문자열 연산을 수행 하고 &lt;code&gt;bytea&lt;/code&gt; 증가 된 저장 공간으로 인해 값이 더 빠르게 실행됩니다. 참고 &lt;code&gt;SET STORAGE&lt;/code&gt; 이 표에 아무 것도 변경하지 자체 않습니다, 그냥 미래 테이블 업데이트하는 동안 추구 할 수있는 전략을 설정합니다. 자세한 정보는 &lt;a href=&quot;storage-toast&quot;&gt;68.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec13ec4434f4e2b65ae05d1be4e2e6176c623511" translate="yes" xml:space="preserve">
          <source>This form specifies a transition that always happens during the same month and on the same day of the week. &lt;code&gt;m&lt;/code&gt; identifies the month, from 1 to 12. &lt;code&gt;n&lt;/code&gt; specifies the &lt;code&gt;n&lt;/code&gt;'th occurrence of the weekday identified by &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is a number between 1 and 4, or 5 meaning the last occurrence of that weekday in the month (which could be the fourth or the fifth). &lt;code&gt;d&lt;/code&gt; is a number between 0 and 6, with 0 indicating Sunday. For example, &lt;code&gt;M3.2.0&lt;/code&gt; means &amp;ldquo;the second Sunday in March&amp;rdquo;.</source>
          <target state="translated">이 양식은 항상 같은 달과 같은 요일에 발생하는 전환을 지정합니다. &lt;code&gt;m&lt;/code&gt; 은 1에서 12까지의 월을 식별합니다. &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;d&lt;/code&gt; 로 식별되는 요일 의 &lt;code&gt;n&lt;/code&gt; 번째 발생을 지정합니다 . &lt;code&gt;n&lt;/code&gt; 은 1에서 4 사이의 숫자이거나 5는 해당 월의 해당 요일의 마지막 발생을 의미합니다 (4 번째 또는 5 번째 일 수 있음). &lt;code&gt;d&lt;/code&gt; 는 0에서 6 사이의 숫자이며 0은 일요일을 나타냅니다. 예를 들어 &lt;code&gt;M3.2.0&lt;/code&gt; 은 &quot;3 월 두 번째 일요일&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="909f4c3b4cbf68b6bdfe371c2a727fe6e1f1cf31" translate="yes" xml:space="preserve">
          <source>This form turns a stored generated column into a normal base column. Existing data in the columns is retained, but future changes will no longer apply the generation expression.</source>
          <target state="translated">이 양식은 저장된 생성 열을 일반 기본 열로 변환합니다. 열의 기존 데이터는 유지되지만 향후 변경 사항은 더 이상 생성 표현식을 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79e59ee7d655fea5f293a39645cf958df6f59eaa" translate="yes" xml:space="preserve">
          <source>This form updates the extension to a newer version. The extension must supply a suitable update script (or series of scripts) that can modify the currently-installed version into the requested version.</source>
          <target state="translated">이 양식은 확장을 최신 버전으로 업데이트합니다. 확장은 현재 설치된 버전을 요청 된 버전으로 수정할 수있는 적합한 업데이트 스크립트 (또는 일련의 스크립트)를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="54be61b37045a65ad5af5b24265bf2d2fe56613b" translate="yes" xml:space="preserve">
          <source>This form validates a constraint previously added as &lt;code&gt;NOT VALID&lt;/code&gt;, that is, it verifies that all values in table columns of the domain type satisfy the specified constraint.</source>
          <target state="translated">이 양식은 이전에 &lt;code&gt;NOT VALID&lt;/code&gt; 로 추가 된 제한 조건의 유효성을 검증 합니다. 즉, 도메인 유형의 테이블 컬럼에있는 모든 값이 지정된 제한 조건을 만족하는지 검증합니다.</target>
        </trans-unit>
        <trans-unit id="7fae39d4d329b60aa027a709db925fb7a0b45aad" translate="yes" xml:space="preserve">
          <source>This form validates a foreign key or check constraint that was previously created as &lt;code&gt;NOT VALID&lt;/code&gt;, by scanning the table to ensure there are no rows for which the constraint is not satisfied. Nothing happens if the constraint is already marked valid. (See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for an explanation of the usefulness of this command.)</source>
          <target state="translated">이 양식 은 제한 조건이 충족되지 않는 행이 없는지 테이블을 스캔하여 이전에 &lt;code&gt;NOT VALID&lt;/code&gt; 로 작성된 외부 키 또는 점검 제한 조건의 유효성을 검증합니다 . 구속 조건이 이미 유효한 것으로 표시되면 아무 일도 일어나지 않습니다. 이 명령의 유용성에 대한 설명은 아래 &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;참고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d527b3923e336e8d7e873c75f29f0a2a678c450" translate="yes" xml:space="preserve">
          <source>This format option is used for importing and exporting the Comma Separated Value (&lt;code&gt;CSV&lt;/code&gt;) file format used by many other programs, such as spreadsheets. Instead of the escaping rules used by PostgreSQL's standard text format, it produces and recognizes the common CSV escaping mechanism.</source>
          <target state="translated">이 형식 옵션은 스프레드 시트와 같은 다른 많은 프로그램에서 사용하는 &lt;code&gt;CSV&lt;/code&gt; (Comma Separated Value ) 파일 형식 을 가져오고 내보내는 데 사용됩니다. PostgreSQL의 표준 텍스트 형식에서 사용되는 이스케이프 규칙 대신 일반적인 CSV 이스케이프 메커니즘을 생성하고 인식합니다.</target>
        </trans-unit>
        <trans-unit id="792a63854d692e136337a8efffc52744faba871f" translate="yes" xml:space="preserve">
          <source>This function accepts, but does not require, the VARIADIC keyword. It tolerates both integer and numeric arguments:</source>
          <target state="translated">이 함수는 VARIADIC 키워드를 허용하지만 필수는 아닙니다. 정수 및 숫자 인수를 모두 허용합니다.</target>
        </trans-unit>
        <trans-unit id="384addc1a1dba581b09ffbc6f99227a9381c9da3" translate="yes" xml:space="preserve">
          <source>This function applies the XSL stylesheet to the document and returns the transformed result. The &lt;code&gt;paramlist&lt;/code&gt; is a list of parameter assignments to be used in the transformation, specified in the form &lt;code&gt;a=1,b=2&lt;/code&gt;. Note that the parameter parsing is very simple-minded: parameter values cannot contain commas!</source>
          <target state="translated">이 함수는 XSL 스타일 시트를 문서에 적용하고 변환 된 결과를 리턴합니다. &lt;code&gt;paramlist&lt;/code&gt; 은 폼에서 지정된 변환에 사용되는 파라미터의 할당 목록이며, &lt;code&gt;a=1,b=2&lt;/code&gt; . 매개 변수 구문 분석은 매우 간단합니다. 매개 변수 값은 쉼표를 포함 할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="0ee207b4a33861c6094ba8a46213a951afdbd72c" translate="yes" xml:space="preserve">
          <source>This function calculates the Levenshtein distance between two strings:</source>
          <target state="translated">이 함수는 두 문자열 사이의 Levenshtein 거리를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c2569b9ec2f2f240b538364988cd2b660c7bc809" translate="yes" xml:space="preserve">
          <source>This function calculates the metaphone code of an input string:</source>
          <target state="translated">이 함수는 입력 문자열의 메타 폰 코드를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b833dadc47320ce5093b7875a4e223019bb7f287" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;cover density&lt;/em&gt; ranking for the given document vector and query, as described in Clarke, Cormack, and Tudhope's &quot;Relevance Ranking for One to Three Term Queries&quot; in the journal &quot;Information Processing and Management&quot;, 1999. Cover density is similar to &lt;code&gt;ts_rank&lt;/code&gt; ranking except that the proximity of matching lexemes to each other is taken into consideration.</source>
          <target state="translated">이 함수 는 Clarke, Cormack 및 Tudhope의 &quot;정보 처리 및 관리&quot;저널 1999 년의 Tudhope의 &quot;1 ~ 3 개의 용어 관련성 순위&quot;에 설명 된대로 지정된 문서 벡터 및 쿼리에 대한 &lt;em&gt;표지 밀도&lt;/em&gt; 순위를 계산합니다 . 표지 밀도는 유사합니다. 에 &lt;code&gt;ts_rank&lt;/code&gt; 것 이외에는 순위 서로 일치 어휘 근방 고려된다.</target>
        </trans-unit>
        <trans-unit id="83d7f3c8b4315f521db79931ac5b0419f7f02e44" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID but uses a random multicast MAC address instead of the real MAC address of the computer.</source>
          <target state="translated">이 기능은 버전 1 UUID를 생성하지만 컴퓨터의 실제 MAC 주소 대신 임의의 멀티 캐스트 MAC 주소를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0d47dfa9e9b8d5b7fbb04b1e480b39cea1dce637" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID. This involves the MAC address of the computer and a time stamp. Note that UUIDs of this kind reveal the identity of the computer that created the identifier and the time at which it did so, which might make it unsuitable for certain security-sensitive applications.</source>
          <target state="translated">이 함수는 버전 1 UUID를 생성합니다. 여기에는 컴퓨터의 MAC 주소와 타임 스탬프가 포함됩니다. 이러한 종류의 UUID는 식별자를 만든 컴퓨터의 ID와 식별자가 만들어진 시간을 나타내므로 특정 보안에 민감한 응용 프로그램에는 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0487e417e0c4d9dd43a18530572f4217e42f12de" translate="yes" xml:space="preserve">
          <source>This function generates a version 3 UUID in the given namespace using the specified input name. The namespace should be one of the special constants produced by the &lt;code&gt;uuid_ns_*()&lt;/code&gt; functions shown in &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Table F.33&lt;/a&gt;. (It could be any UUID in theory.) The name is an identifier in the selected namespace.</source>
          <target state="translated">이 함수는 지정된 입력 이름을 사용하여 지정된 네임 스페이스에서 버전 3 UUID를 생성합니다. 네임 스페이스는 &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;표 F.33에&lt;/a&gt; 표시된 &lt;code&gt;uuid_ns_*()&lt;/code&gt; 함수에 의해 생성 된 특수 상수 중 하나 여야합니다 . 이론상 UUID 일 수 있습니다. 이름은 선택한 네임 스페이스의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="815458cef4730e8a9276e3ff8e0d57eb7d786adf" translate="yes" xml:space="preserve">
          <source>This function generates a version 4 UUID, which is derived entirely from random numbers.</source>
          <target state="translated">이 함수는 버전 4 UUID를 생성하며, 이는 완전히 난수에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="70e04d40259f3b4e398eaecf4565ce5668726dbd" translate="yes" xml:space="preserve">
          <source>This function generates a version 5 UUID, which works like a version 3 UUID except that SHA-1 is used as a hashing method. Version 5 should be preferred over version 3 because SHA-1 is thought to be more secure than MD5.</source>
          <target state="translated">이 함수는 버전 5 UUID를 생성하며 SHA-1이 해싱 방법으로 사용된다는 점을 제외하고 버전 3 UUID처럼 작동합니다. SHA-1이 MD5보다 안전하다고 생각되기 때문에 버전 5는 버전 3보다 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e0a3bf72d056e543baff831854a2b9328ece5e35" translate="yes" xml:space="preserve">
          <source>This function is described in &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;Table 9.62&lt;/a&gt;.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;표 9.62에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9a6e7f01cec14b42f0b87924ed8025472ae1b3d" translate="yes" xml:space="preserve">
          <source>This function is really useful only if you have more than one trusted CA certificate in your server's certificate authority file, or if this CA has issued some intermediate certificate authority certificates.</source>
          <target state="translated">이 기능은 서버의 인증 기관 파일에 둘 이상의 신뢰할 수있는 CA 인증서가 있거나이 CA가 일부 중간 인증 기관 인증서를 발급 한 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="63ff3f7ccdd8e65ce06124599f3ab0770c0133c3" translate="yes" xml:space="preserve">
          <source>This function is restricted to superusers and members of the &lt;code&gt;pg_monitor&lt;/code&gt; role by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">이 기능은 기본적 으로 수퍼 유저 및 &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원으로 제한 되지만 다른 사용자에게 EXECUTE 권한을 부여하여 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e52438a2973580a90569d73e97b9438c5b2a81d3" translate="yes" xml:space="preserve">
          <source>This function is restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">이 기능은 기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE 권한을 부여하여 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09caa14af8239e8fd0fef2257c67a191f1fcb7c5" translate="yes" xml:space="preserve">
          <source>This function is used implicitly when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;json&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;hstore&lt;/code&gt; 값이 &lt;code&gt;json&lt;/code&gt; 으로 캐스트 될 때 암시 적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="07a9fbad99c6b946ee2810aa1613797169567ed3" translate="yes" xml:space="preserve">
          <source>This function is used implicitly when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;jsonb&lt;/code&gt;.</source>
          <target state="translated">때이 기능은 암시 적으로 사용되는 &lt;code&gt;hstore&lt;/code&gt; 의 값에 캐스팅 &lt;code&gt;jsonb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52b67ed61bf91babfe5b1fd62f929a40f3153129" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code id=&quot;update&quot;&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">이 함수에는 시퀀스에 대한 &lt;code id=&quot;update&quot;&gt;UPDATE&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c3bba3a33d3476c85ef64f965448f29b348576cf" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code id=&quot;usage&quot;&gt;USAGE&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">이 함수에는 시퀀스에 대한 &lt;code id=&quot;usage&quot;&gt;USAGE&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="5b1d41d04bdf06be2e37d1f0ae8845458954a418" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">이 함수에는 시퀀스에 대한 &lt;code&gt;UPDATE&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e39f1ca89945df262cf69293c102551266551425" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the last used sequence.</source>
          <target state="translated">이 기능을 &lt;code&gt;USAGE&lt;/code&gt; 하려면 마지막으로 사용한 시퀀스에서 USAGE 또는 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="9f01c920de003b371748d82ceb88ff4c45aff8e2" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">이 함수에는 시퀀스에 대한 &lt;code&gt;USAGE&lt;/code&gt; 또는 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="67164ea85a2954ef16cf5fcf220bb12c3b615043" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">이 함수에는 시퀀스에 대한 &lt;code&gt;USAGE&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7e54a0efd46907c22c610b8b23cccd57e0bcbc37" translate="yes" xml:space="preserve">
          <source>This function requires lexeme positional information to perform its calculation. Therefore, it ignores any &amp;ldquo;stripped&amp;rdquo; lexemes in the &lt;code&gt;tsvector&lt;/code&gt;. If there are no unstripped lexemes in the input, the result will be zero. (See &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; for more information about the &lt;code&gt;strip&lt;/code&gt; function and positional information in &lt;code&gt;tsvector&lt;/code&gt;s.)</source>
          <target state="translated">이 함수는 계산을 수행하기 위해 lexeme 위치 정보가 필요합니다. 따라서 &lt;code&gt;tsvector&lt;/code&gt; 의 &quot;스트립 된&quot; exemes를 무시합니다 . 입력에 스트렙되지 않은 룩 셈스가 없으면 결과는 0이됩니다. ( &lt;code&gt;tsvector&lt;/code&gt; 함수 의 &lt;code&gt;strip&lt;/code&gt; 기능 및 위치 정보에 대한 자세한 내용은 &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;12.4.1 단원을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="c1856db892a00b2e43b297b0dbc4109fce353620" translate="yes" xml:space="preserve">
          <source>This function returns a value that can be approximately understood as the greatest similarity between the first string and any substring of the second string. However, this function does not add padding to the boundaries of the extent. Thus, the number of additional characters present in the second string is not considered, except for the mismatched word boundaries.</source>
          <target state="translated">이 함수는 첫 번째 문자열과 두 번째 문자열의 하위 문자열 간의 유사성이 가장 큰 것으로 이해 될 수있는 값을 반환합니다. 그러나이 함수는 범위의 경계에 패딩을 추가하지 않습니다. 따라서 일치하지 않는 단어 경계를 제외하고 두 번째 문자열에 존재하는 추가 문자 수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0221605a1cce6baf0cb85c01f2888179ec394f70" translate="yes" xml:space="preserve">
          <source>This function returns a version 4 (random) UUID. This is the most commonly used type of UUID and is appropriate for most applications.</source>
          <target state="translated">이 함수는 버전 4 (무작위) UUID를 반환합니다. 이것은 가장 일반적으로 사용되는 UUID 유형이며 대부분의 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="45aa18780b259bc2744ab8ff0666ff85306321c0" translate="yes" xml:space="preserve">
          <source>This function returns multiple values separated by the specified separator, for example &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; if separator is &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">이 함수의 리턴 값이 여러 예를 들어, 지정된 분리에 의해 분리 &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; 세퍼레이터 인 경우 &lt;code&gt;,&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a92a46b380193cb9c54f2eb12d510b84b0bf579e" translate="yes" xml:space="preserve">
          <source>This function returns the value of the specified field in the certificate subject, or NULL if the field is not present. Field names are string constants that are converted into ASN1 object identifiers using the OpenSSL object database. The following values are acceptable:</source>
          <target state="translated">이 함수는 인증서 주체에서 지정된 필드의 값을 반환하거나 필드가 없으면 NULL을 반환합니다. 필드 이름은 OpenSSL 객체 데이터베이스를 사용하여 ASN1 객체 식별자로 변환되는 문자열 상수입니다. 다음 값이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="50cb6130584a2ccc2fd56083455360b1df842976" translate="yes" xml:space="preserve">
          <source>This function should be called with the same arguments as the return attributes of &lt;code&gt;heap_page_items&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;heap_page_items&lt;/code&gt; 의 반환 속성과 동일한 인수로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3bf22c93b0d832b9656f660c278a124c39df4dd9" translate="yes" xml:space="preserve">
          <source>This function terminates backup mode and performs an automatic switch to the next WAL segment. The reason for the switch is to arrange for the last WAL segment written during the backup interval to be ready to archive.</source>
          <target state="translated">이 기능은 백업 모드를 종료하고 다음 WAL 세그먼트로 자동 전환합니다. 스위치의 이유는 백업 간격 동안 기록 된 마지막 WAL 세그먼트를 아카이브 할 준비가되게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2aad428f96b8431576d3176be3a80d4e1c2a4447" translate="yes" xml:space="preserve">
          <source>This function will be called to initialize dynamic shared memory at the beginning of a parallel scan. &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; will point to at least the number of bytes previously returned by &lt;code&gt;amestimateparallelscan&lt;/code&gt;, and this function may use that amount of space to store whatever data it wishes.</source>
          <target state="translated">이 기능은 병렬 스캔을 시작할 때 동적 공유 메모리를 초기화하기 위해 호출됩니다. &lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt; 은 적어도 &lt;code&gt;amestimateparallelscan&lt;/code&gt; 이 반환 한 바이트 수를 가리키며이 함수는 원하는 양의 데이터를 저장하기 위해 해당 공간을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9031a619f108cfe873afc670225222a731f98ca3" translate="yes" xml:space="preserve">
          <source>This function's intention is to access a table &lt;code&gt;admin.pwds&lt;/code&gt;. But without the &lt;code&gt;SET&lt;/code&gt; clause, or with a &lt;code&gt;SET&lt;/code&gt; clause mentioning only &lt;code&gt;admin&lt;/code&gt;, the function could be subverted by creating a temporary table named &lt;code&gt;pwds&lt;/code&gt;.</source>
          <target state="translated">이 함수의 목적은 테이블 &lt;code&gt;admin.pwds&lt;/code&gt; 에 액세스하는 것 입니다. 그러나 &lt;code&gt;SET&lt;/code&gt; 절이 없거나 &lt;code&gt;admin&lt;/code&gt; 만 언급 하는 &lt;code&gt;SET&lt;/code&gt; 절이 &lt;code&gt;pwds&lt;/code&gt; 라는 임시 테이블을 작성하여 함수를 파괴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74eda98e312717a7e3761e1be3fed4cfe413013a" translate="yes" xml:space="preserve">
          <source>This function, if implemented, will be called when a parallel index scan must be restarted. It should reset any shared state set up by &lt;code&gt;aminitparallelscan&lt;/code&gt; such that the scan will be restarted from the beginning.</source>
          <target state="translated">병렬 인덱스 스캔을 다시 시작해야 할 경우이 기능이 구현되면 호출됩니다. 스캔이 처음부터 다시 시작되도록 &lt;code&gt;aminitparallelscan&lt;/code&gt; 에 의해 설정된 공유 상태를 재설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ba0d2d4c762ce91e9a46761e7e3115cef1d26dc7" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks, similarly to &lt;code&gt;psql&lt;/code&gt;'s &lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt;&lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt;&lt;/a&gt;. Conditional expressions are identical to those with &lt;code&gt;\set&lt;/code&gt;, with non-zero values interpreted as true.</source>
          <target state="translated">이 명령 그룹은 &lt;code&gt;psql&lt;/code&gt; 의 &lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt; &lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt; &lt;/a&gt; 과 유사하게 중첩 가능한 조건부 블록을 구현 합니다 . 조건식은 &lt;code&gt;\set&lt;/code&gt; 값과 동일하지만 0이 아닌 값은 true로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="a86a1c85779a67bdb4c07c083dc8d1a736ba45ad" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks. A conditional block must begin with an &lt;code&gt;\if&lt;/code&gt; and end with an &lt;code&gt;\endif&lt;/code&gt;. In between there may be any number of &lt;code&gt;\elif&lt;/code&gt; clauses, which may optionally be followed by a single &lt;code&gt;\else&lt;/code&gt; clause. Ordinary queries and other types of backslash commands may (and usually do) appear between the commands forming a conditional block.</source>
          <target state="translated">이 명령 그룹은 중첩 가능한 조건부 블록을 구현합니다. 조건부 블록은 &lt;code&gt;\if&lt;/code&gt; 시작 하고 &lt;code&gt;\endif&lt;/code&gt; 끝나야 합니다. 그 사이에는 여러 개의 &lt;code&gt;\elif&lt;/code&gt; 절이 있을 수 있으며 선택적으로 단일 &lt;code&gt;\else&lt;/code&gt; 절이 올 수 있습니다. 조건부 블록을 구성하는 명령 사이에 일반 쿼리 및 기타 유형의 백 슬래시 명령이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44140a36cc7df2f1c3a52fdc81c7272717604999" translate="yes" xml:space="preserve">
          <source>This happens because an hour was skipped due to a change in daylight saving time at &lt;code&gt;2005-04-03 02:00:00&lt;/code&gt; in time zone &lt;code&gt;America/Denver&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;America/Denver&lt;/code&gt; 시간대의 &lt;code&gt;2005-04-03 02:00:00&lt;/code&gt; 에 일광 절약 시간이 변경되어 한 시간을 건너 뛰었 기 때문에 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0b11efb2c7cb913b726605094c75fda2e8cad938" translate="yes" xml:space="preserve">
          <source>This happens because the system cannot decide which of the several possible &lt;code&gt;~&lt;/code&gt; operators should be preferred. We can help it out with an explicit cast:</source>
          <target state="translated">시스템이 몇 가지의 결정 수 없기 때문에이 문제가 발생합니다 &lt;code&gt;~&lt;/code&gt; 선호한다 운영자. 우리는 명백한 캐스트로 그것을 도울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1adefa35377cadd1c8a75aec2fb42a29f31a0dd0" translate="yes" xml:space="preserve">
          <source>This has the same effect as casting each expression to the array element type individually. For more on casting, see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt;.</source>
          <target state="translated">이는 각 표현식을 배열 요소 유형에 개별적으로 캐스트하는 것과 동일한 효과를 갖습니다. 캐스팅에 대한 자세한 내용 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;은 4.2.9 섹션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a60511ea52748a75870fb82ff05a5c564394ceb2" translate="yes" xml:space="preserve">
          <source>This heuristic can be overridden, forcing the server to use either generic or custom plans, by setting &lt;code&gt;plan_cache_mode&lt;/code&gt; to &lt;code&gt;force_generic_plan&lt;/code&gt; or &lt;code&gt;force_custom_plan&lt;/code&gt; respectively. This setting is primarily useful if the generic plan's cost estimate is badly off for some reason, allowing it to be chosen even though its actual cost is much more than that of a custom plan.</source>
          <target state="translated">&lt;code&gt;plan_cache_mode&lt;/code&gt; 를 설정하여 서버가 일반 계획 또는 사용자 정의 계획을 사용하도록이 휴리스틱을 대체 할 수 있습니다. 에 &lt;code&gt;force_generic_plan&lt;/code&gt; 또는 &lt;code&gt;force_custom_plan&lt;/code&gt; 을 각각. 이 설정은 어떤 이유로 일반 계획의 비용 산정이 잘못되어 실제 비용이 사용자 정의 계획의 비용보다 훨씬 많은 경우에도 선택 될 수있는 경우에 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3ceb81116f5e1034358e4c68c702f99fa463a7e9" translate="yes" xml:space="preserve">
          <source>This implies that if a table is not otherwise vacuumed, autovacuum will be invoked on it approximately once every &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; minus &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; transactions. For tables that are regularly vacuumed for space reclamation purposes, this is of little importance. However, for static tables (including tables that receive inserts, but no updates or deletes), there is no need to vacuum for space reclamation, so it can be useful to try to maximize the interval between forced autovacuums on very large static tables. Obviously one can do this either by increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; or decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt;.</source>
          <target state="translated">즉, 테이블을 달리 진공 청소기로 청소하지 않으면 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 에서 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 를 뺀 값 마다 약 한 번씩 autovacuum 이 호출됩니다. 트랜잭션을 . 공간 교정 목적으로 정기적으로 진공 청소기로 청소되는 테이블의 경우에는 그다지 중요하지 않습니다. 그러나 정적 테이블 (삽입은 수신하지만 업데이트 또는 삭제는받지 않는 테이블 포함)의 경우 공간 교정을 위해 진공 청소기로 청소할 필요가 없으므로 매우 큰 정적 테이블에서 강제 자동 진공 간격을 최대화하는 것이 유용 할 수 있습니다. &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 를 늘리 거나 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 를 줄이면 이 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="963c171b1310567729b0c667a3982a8159857c0a" translate="yes" xml:space="preserve">
          <source>This includes issues caused by the comparison rules of operating system collations changing. Comparisons of datums of a collatable type like &lt;code&gt;text&lt;/code&gt; must be immutable (just as all comparisons used for B-Tree index scans must be immutable), which implies that operating system collation rules must never change. Though rare, updates to operating system collation rules can cause these issues. More commonly, an inconsistency in the collation order between a master server and a standby server is implicated, possibly because the &lt;em&gt;major&lt;/em&gt; operating system version in use is inconsistent. Such inconsistencies will generally only arise on standby servers, and so can generally only be detected on standby servers.</source>
          <target state="translated">여기에는 운영 체제 데이터 정렬 변경 비교 규칙으로 인한 문제가 포함됩니다. 다음과 같은 접을 수있는 유형의 데이텀 비교 &lt;code&gt;text&lt;/code&gt; 변경할 수 없어야합니다 (B- 트리 인덱스 스캔에 사용 된 모든 비교가 변하지 않아야하는 ). 이는 운영 체제 데이터 정렬 규칙이 절대 변하지 않아야 함을 의미합니다. 드물지만 운영 체제 데이터 정렬 규칙을 업데이트하면 이러한 문제가 발생할 수 있습니다. 보다 일반적으로, 사용중인 &lt;em&gt;주요&lt;/em&gt; 운영 체제 버전이 일치하지 않기 때문에 마스터 서버와 대기 서버 간의 데이터 정렬 순서 가 일치하지 않습니다. 이러한 불일치는 일반적으로 대기 서버에서만 발생하므로 일반적으로 대기 서버에서만 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a867951badfb08df8a9bb92137e4c1059d9fe31b" translate="yes" xml:space="preserve">
          <source>This indicates that the &lt;code&gt;postgres&lt;/code&gt; process has been terminated due to memory pressure. Although existing database connections will continue to function normally, no new connections will be accepted. To recover, PostgreSQL will need to be restarted.</source>
          <target state="translated">이것은 &lt;code&gt;postgres&lt;/code&gt; 메모리 부족으로 인해 postgres 프로세스가 종료 . 기존 데이터베이스 연결은 계속 정상적으로 작동하지만 새 연결은 허용되지 않습니다. 복구하려면 PostgreSQL을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a372cfe5f8eb7d4853999840a603c1c28fd5394" translate="yes" xml:space="preserve">
          <source>This indicates that the most common combination of city and state is Washington in DC, with actual frequency (in the sample) about 0.35%. The base frequency of the combination (as computed from the simple per-column frequencies) is only 0.0027%, resulting in two orders of magnitude under-estimates.</source>
          <target state="translated">이는 도시와 주가 가장 일반적인 조합으로 DC에서 워싱턴이며 실제 주파수 (샘플에서)는 약 0.35 %임을 나타냅니다. 조합의 기본 주파수 (단순 열당 주파수로 계산)는 0.0027 %에 불과하므로 2 배의 과소 추정치가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8fe534ccbaaf548c2b11e2912002e72aef917fa" translate="yes" xml:space="preserve">
          <source>This indicates that there are three combinations of columns that have 33178 distinct values: ZIP code and state; ZIP code and city; and ZIP code, city and state (the fact that they are all equal is expected given that ZIP code alone is unique in this table). On the other hand, the combination of city and state has only 27435 distinct values.</source>
          <target state="translated">이는 33178 개의 고유 값을 갖는 세 가지 열 조합이 있음을 나타냅니다. 우편 번호 및 주; 우편 번호 및 도시; 우편 번호, 도시 및 주 (우편 번호가이 표에서 고유하다는 점에서 모두 동일하다는 사실이 예상됩니다). 반면에시와 주 조합은 27435 개의 고유 한 값만 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fc1f09ba473095924730f620c845acdb222d24ff" translate="yes" xml:space="preserve">
          <source>This involves changes in the backend function API, which is written in the C programming language. Such changes affect code that references backend functions deep inside the server.</source>
          <target state="translated">여기에는 C 프로그래밍 언어로 작성된 백엔드 함수 API의 변경이 포함됩니다. 이러한 변경 사항은 서버 내부의 백엔드 기능을 참조하는 코드에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d9a4686c9a5bfa4e42613a92f3eda7d13c48363f" translate="yes" xml:space="preserve">
          <source>This is OK because the subquery is an independent computation that computes its own aggregate separately from what is happening in the outer query.</source>
          <target state="translated">하위 쿼리는 외부 쿼리에서 발생하는 것과 별도로 자체 집계를 계산하는 독립 계산이기 때문에 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="14697b498878040181d5bdcab2a50bb95e660328" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;printf&lt;/code&gt;-style string that is output at the beginning of each log line. &lt;code&gt;%&lt;/code&gt; characters begin &amp;ldquo;escape sequences&amp;rdquo; that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes, and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files.</source>
          <target state="translated">이것은 각 로그 행의 시작 부분에 출력 되는 &lt;code&gt;printf&lt;/code&gt; 스타일 문자열입니다. &lt;code&gt;%&lt;/code&gt; 문자는 아래에 설명 된대로 상태 정보로 대체되는 &quot;이스케이프 시퀀스&quot;로 시작합니다. 인식 할 수없는 이스케이프는 무시됩니다. 다른 문자는 로그 라인에 바로 복사됩니다. 일부 이스케이프는 세션 프로세스에서만 인식되며 주 서버 프로세스와 같은 백그라운드 프로세스에서 비어있는 것으로 처리됩니다. % 뒤와 옵션 앞에 숫자 리터럴을 지정하여 상태 정보를 왼쪽 또는 오른쪽으로 정렬 할 수 있습니다. 음수 값은 최소 너비를 제공하기 위해 오른쪽이 공백으로 채워지고 양수 값은 왼쪽이 채워집니다. 패딩은 로그 파일에서 사람이 쉽게 읽을 수 있도록하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dcf869a044613b3ca0ecf7baf516a8c7193977f" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;printf&lt;/code&gt;-style string that is output at the beginning of each log line. &lt;code&gt;%&lt;/code&gt; characters begin &amp;ldquo;escape sequences&amp;rdquo; that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes, and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;'%m [%p] '&lt;/code&gt; which logs a time stamp and the process ID.</source>
          <target state="translated">각 로그 행의 시작 부분에 출력 되는 &lt;code&gt;printf&lt;/code&gt; 스타일 문자열입니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄에 있습니다. 기본값은 &lt;code&gt;'%m [%p] '&lt;/code&gt; 이며 타임 스탬프 및 프로세스 ID를 기록합니다. &lt;code&gt;%&lt;/code&gt; 문자는 아래에 설명 된대로 상태 정보로 대체되는 &quot;이스케이프 시퀀스&quot;를 시작합니다. 인식 할 수없는 이스케이프는 무시됩니다. 다른 문자는 로그 라인에 바로 복사됩니다. 일부 이스케이프는 세션 프로세스에서만 인식되며 기본 서버 프로세스와 같은 백그라운드 프로세스에 의해 비어있는 것으로 처리됩니다. % 다음과 옵션 앞에 숫자 리터럴을 지정하여 상태 정보를 왼쪽이나 오른쪽으로 정렬 할 수 있습니다. 값이 음수이면 상태 정보가 오른쪽에 공백으로 채워져 최소 너비가되고 양수 값은 왼쪽에 채워집니다. 패딩은 로그 파일에서 사람이 읽을 수 있도록 도움을 줄 수 있습니다. 이 매개 변수는</target>
        </trans-unit>
        <trans-unit id="8b34706e04777a657dce1a4607ff942e4ebc159f" translate="yes" xml:space="preserve">
          <source>This is a B-tree leaf page. All tuples that point to the table happen to be posting list tuples (all of which store a total of 100 6 byte TIDs). There is also a &amp;ldquo;high key&amp;rdquo; tuple at &lt;code&gt;itemoffset&lt;/code&gt; number 1. &lt;code&gt;ctid&lt;/code&gt; is used to store encoded information about each tuple in this example, though leaf page tuples often store a heap TID directly in the &lt;code&gt;ctid&lt;/code&gt; field instead. &lt;code&gt;tids&lt;/code&gt; is the list of TIDs stored as a posting list.</source>
          <target state="translated">이것은 B- 트리 리프 페이지입니다. 테이블을 가리키는 모든 튜플은 목록 튜플을 게시합니다 (모두 총 100 개의 6 바이트 TID를 저장함). 또한 &lt;code&gt;itemoffset&lt;/code&gt; 번호 1에 &quot;high key&quot;튜플이 있습니다 . &lt;code&gt;ctid&lt;/code&gt; 는이 예제에서 각 튜플에 대한 인코딩 된 정보를 저장하는 데 사용되지만 리프 페이지 튜플은 종종 &lt;code&gt;ctid&lt;/code&gt; 필드에 직접 힙 TID를 저장합니다 . &lt;code&gt;tids&lt;/code&gt; 는 게시 목록으로 저장된 TID 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c9227695178f5037e0a0e506aca137b88f68d780" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column should not be matched against the null string (that is, the table-level &lt;code&gt;null&lt;/code&gt; option). This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; option.</source>
          <target state="translated">부울 옵션입니다. true 인 경우 열 값이 널 문자열 (즉, 테이블 레벨 &lt;code&gt;null&lt;/code&gt; 옵션) 과 일치하지 않도록 지정합니다 . 이는 &lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; 옵션에 열을 나열하는 것과 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="bb0f72d78e70cfb965b94342147bb69a1649e537" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column which match the null string are returned as &lt;code&gt;NULL&lt;/code&gt; even if the value is quoted. Without this option, only unquoted values matching the null string are returned as &lt;code&gt;NULL&lt;/code&gt;. This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NULL&lt;/code&gt; option.</source>
          <target state="translated">부울 옵션입니다. true 인 경우, 값이 인용 되더라도 널 문자열과 일치하는 열의 값이 &lt;code&gt;NULL&lt;/code&gt; 로 리턴되도록 지정 합니다 . 이 옵션이 없으면 널 문자열과 일치하는 따옴표없는 값만 &lt;code&gt;NULL&lt;/code&gt; 로 리턴됩니다 . 이는 &lt;code&gt;COPY&lt;/code&gt; 의 &lt;code&gt;FORCE_NULL&lt;/code&gt; 옵션에 열을 나열하는 것과 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d9d802e79acd19a5807b524b5ff1cadf1072e9c9" translate="yes" xml:space="preserve">
          <source>This is a bad idea! Almost certainly, you'll be better off with a single non-partial index, declared like</source>
          <target state="translated">이것은 나쁜 생각입니다! 거의 확실하게 다음과 같이 선언 된 단일 비 부분 인덱스를 사용하는 것이 더 나을 것입니다.</target>
        </trans-unit>
        <trans-unit id="2458d33e53e769de251317cb73941c93deac0112" translate="yes" xml:space="preserve">
          <source>This is a deprecated alias for &lt;code id=&quot;6462&quot;&gt;@&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code id=&quot;6462&quot;&gt;@&amp;gt;&lt;/code&gt; 의 더 이상 사용되지 않는 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="e89be01ecc4c51c231fa86cb87027e9f7e872252" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code id=&quot;6464&quot;&gt;@@&lt;/code&gt;.</source>
          <target state="translated">&lt;code id=&quot;6464&quot;&gt;@@&lt;/code&gt; 의 더 이상 사용되지 않는 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="86fd356bbb6f1b1f6f6224d995b8d42e58695e06" translate="yes" xml:space="preserve">
          <source>This is a historical alias for &lt;code id=&quot;stddev_samp&quot;&gt;stddev_samp&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code id=&quot;stddev_samp&quot;&gt;stddev_samp&lt;/code&gt; 의 역사적 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="a9e5af4d8a94f39f1b76df48d0e7c72e55e60307" translate="yes" xml:space="preserve">
          <source>This is a historical alias for &lt;code id=&quot;var_samp&quot;&gt;var_samp&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code id=&quot;var_samp&quot;&gt;var_samp&lt;/code&gt; 의 역사적 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="952c5f2574e0ab3c7c85d004636983a1260b99d7" translate="yes" xml:space="preserve">
          <source>This is a list of acronyms commonly used in the PostgreSQL documentation and in discussions about PostgreSQL.</source>
          <target state="translated">이것은 PostgreSQL 문서와 PostgreSQL에 대한 토론에서 일반적으로 사용되는 약어의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cba6116424f9b26f41ff31a3536a10c997043100" translate="yes" xml:space="preserve">
          <source>This is a list of terms and their meaning in the context of PostgreSQL and relational database systems in general.</source>
          <target state="translated">이것은 일반적으로 PostgreSQL 및 관계형 데이터베이스 시스템의 맥락에서 용어 및 의미 목록입니다.</target>
        </trans-unit>
        <trans-unit id="64e0bd441cd585968a19e4596d1d9617026fbc74" translate="yes" xml:space="preserve">
          <source>This is a noise word.</source>
          <target state="translated">이것은 의미없는 단어입니다.</target>
        </trans-unit>
        <trans-unit id="e3f9d4c5c7e93766f0b892911d84b9660f77ff3e" translate="yes" xml:space="preserve">
          <source>This is a non-standard syntax for &lt;code&gt;trim()&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;trim()&lt;/code&gt; 대한 비표준 구문입니다 .</target>
        </trans-unit>
        <trans-unit id="022e58efea267ae2631d535b60729a755677e2e4" translate="yes" xml:space="preserve">
          <source>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones.</source>
          <target state="translated">성공적인 테스트가 거의없고 실패한 테스트가 많을 때 특히 효율적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9e8e468a2c09a5e3ff58be6bcf971fcb3102f2b3" translate="yes" xml:space="preserve">
          <source>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones. It is also possible to allow only one null in a column by creating a unique partial index with an &lt;code&gt;IS NULL&lt;/code&gt; restriction.</source>
          <target state="translated">이는 성공적인 테스트가 거의없고 실패한 테스트가 많을 때 특히 효율적인 접근 방식입니다. &lt;code&gt;IS NULL&lt;/code&gt; 제한이 있는 고유 한 부분 인덱스를 생성하여 열에 하나의 null 만 허용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5d2e6129737b2c23b111b25ce903c45a62a32f8" translate="yes" xml:space="preserve">
          <source>This is a sequence of three commands, one per line (although this is not required; more than one command can be on a line, and commands can usefully be split across lines).</source>
          <target state="translated">이것은 한 줄에 하나씩 세 개의 명령 시퀀스입니다 (필요하지는 않지만 한 명령을 한 줄에 둘 수 있으며 명령을 여러 줄로 나눌 수 있음).</target>
        </trans-unit>
        <trans-unit id="450f019da352d6f44183cb5a8fe197731201523e" translate="yes" xml:space="preserve">
          <source>This is a shortcut for setting &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; at once. If you specify this, you cannot specify either of those parameters.</source>
          <target state="translated">&lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 한 번 에 설정하기위한 바로 가기입니다 . 이를 지정하면 해당 매개 변수 중 하나를 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="768c3e272a14bb422425810cd204ed41f4ba6629" translate="yes" xml:space="preserve">
          <source>This is a wrapper for the above function that uses &lt;code&gt;,&lt;/code&gt; as the separator.</source>
          <target state="translated">이것은 상기 함수 그 용도에 대한 래퍼이며 &lt;code&gt;,&lt;/code&gt; 세퍼레이터로.</target>
        </trans-unit>
        <trans-unit id="b3c868d4182c583f463c71ff97e781747bf3a03c" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\dp&lt;/code&gt; (&amp;ldquo;display privileges&amp;rdquo;).</source>
          <target state="translated">이것은 &lt;code&gt;\dp&lt;/code&gt; ( &quot;디스플레이 권한&quot;) 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="a3bfb72cef070dc11f447b3386a7c2706bac36a5" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\lo_list&lt;/code&gt;, which shows a list of large objects.</source>
          <target state="translated">이것은 &lt;code&gt;\lo_list&lt;/code&gt; 의 별명 이며 큰 오브젝트 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e5418e1e26d985dcf636546c65d0611e01b93f2b" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;hash_murmur2&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;hash_murmur2&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="78ba8cae4388de88507eba2b7275ccd60b950613" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnatts&lt;/code&gt; values that indicate which table columns this index indexes. For example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the index entries. Key columns come before non-key (included) columns. A zero in this array indicates that the corresponding index attribute is an expression over the table columns, rather than a simple column reference.</source>
          <target state="translated">이것은 인덱스가 인덱스하는 테이블 열을 나타내는 &lt;code&gt;indnatts&lt;/code&gt; 값 의 배열입니다 . 예를 들어 값 &lt;code&gt;1 3&lt;/code&gt; 은 첫 번째 및 세 번째 테이블 열이 인덱스 항목을 구성 함을 의미합니다. 키 열은 키가 아닌 (포함 된) 열 앞에옵니다. 이 배열에서 0은 해당 인덱스 속성이 단순한 열 참조가 아니라 테이블 열에 대한 표현식임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f5ae302c90a19a0498f7df9c475b24d33cb673e7" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnkeyatts&lt;/code&gt; values that store per-column flag bits. The meaning of the bits is defined by the index's access method.</source>
          <target state="translated">&lt;code&gt;indnkeyatts&lt;/code&gt; 플래그 비트를 저장 하는 indnkeyatts 값 의 배열입니다 . 비트의 의미는 인덱스의 액세스 방법으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2fc49bd55fbc5bfa9dea1e28cd18c9a1ca88a7e4" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;partnatts&lt;/code&gt; values that indicate which table columns are part of the partition key. For example, a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the partition key. A zero in this array indicates that the corresponding partition key column is an expression, rather than a simple column reference.</source>
          <target state="translated">이것은 파티션 키의 일부인 테이블 열을 나타내는 &lt;code&gt;partnatts&lt;/code&gt; 값 의 배열입니다 . 예를 들어 값 &lt;code&gt;1 3&lt;/code&gt; 은 첫 번째와 세 번째 테이블 열이 파티션 키를 구성 함을 의미합니다. 이 배열에서 0은 해당 파티션 키 열이 단순한 열 참조가 아니라 식임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="85cb6ef5ec65368f349e99d1c5b167fcd51b032f" translate="yes" xml:space="preserve">
          <source>This is an example of creating a bloom index:</source>
          <target state="translated">다음은 블룸 인덱스를 생성하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="28e7b5364ece8bb74449b25a2f87fdcc6112556a" translate="yes" xml:space="preserve">
          <source>This is backward-compatible syntax for declaring a table &lt;code&gt;WITHOUT OIDS&lt;/code&gt;, creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">&lt;code&gt;WITHOUT OIDS&lt;/code&gt; 테이블을 선언하는 이전 버전과 호환되는 구문 이므로 &lt;code&gt;WITH OIDS&lt;/code&gt; 테이블을 만드는 작업은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f53c81b1fcb044c5d18d73e6543204df53f672fe" translate="yes" xml:space="preserve">
          <source>This is because a restriction placed in the &lt;code&gt;ON&lt;/code&gt; clause is processed &lt;em&gt;before&lt;/em&gt; the join, while a restriction placed in the &lt;code&gt;WHERE&lt;/code&gt; clause is processed &lt;em&gt;after&lt;/em&gt; the join. That does not matter with inner joins, but it matters a lot with outer joins.</source>
          <target state="translated">이렇게 배치 제한 때문이다 &lt;code&gt;ON&lt;/code&gt; 의 절 처리 &lt;em&gt;전에&lt;/em&gt; 조인 제한은 배치 동안 &lt;code&gt;WHERE&lt;/code&gt; 절 처리 &lt;em&gt;후&lt;/em&gt; 조인. 내부 조인에서는 중요하지 않지만 외부 조인에서는 중요합니다.</target>
        </trans-unit>
        <trans-unit id="40e68e5962e0de07dffd697e9417724fccc9d63d" translate="yes" xml:space="preserve">
          <source>This is because if A had executed before B, B would have computed the sum 330, not 300, and similarly the other order would have resulted in a different sum computed by A.</source>
          <target state="translated">A가 B보다 먼저 실행 된 경우, B는 300이 아닌 합계 330을 계산했을 것이고, 다른 순서는 A에 의해 계산 된 다른 합계를 가져 왔기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="75b15f8961b465e16b950c107a03d87b532671ad" translate="yes" xml:space="preserve">
          <source>This is commonly used for analysis over hierarchical data; e.g. total salary by department, division, and company-wide total.</source>
          <target state="translated">이것은 일반적으로 계층 적 데이터 분석에 사용됩니다. 예 : 부서, 부서 및 회사 전체의 총 급여.</target>
        </trans-unit>
        <trans-unit id="acf1e54fe7c52b1e02149d6df39362598d17e105" translate="yes" xml:space="preserve">
          <source>This is commonly used for analysis over hierarchical data; e.g., total salary by department, division, and company-wide total.</source>
          <target state="translated">이것은 일반적으로 계층 적 데이터에 대한 분석에 사용됩니다. 예 : 부서, 부서별 총 급여 및 회사 전체 합계.</target>
        </trans-unit>
        <trans-unit id="c19f8fd7239c9e470394caad32ebd804606ed7b1" translate="yes" xml:space="preserve">
          <source>This is effectively the same as setting the default to null. As a consequence, it is not an error to drop a default where one hadn't been defined, because the default is implicitly the null value.</source>
          <target state="translated">이것은 기본값을 null로 설정하는 것과 사실상 동일합니다. 결과적으로, 기본값은 암시 적으로 널값이므로 기본값이 정의되지 않은 기본값을 삭제하는 것은 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="41f2000975a0c863d9984d3c052ffa8b2b55e07d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code id=&quot;current_user&quot;&gt;current_user&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code id=&quot;current_user&quot;&gt;current_user&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="abbe5e4acccc682de9944cdbcde670be36b81565" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;current_user&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;current_user&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="5d31603eaa916aca8762159f8bda194ec5b5313c" translate="yes" xml:space="preserve">
          <source>This is equivalent to considering that the lower bound is &amp;ldquo;minus infinity&amp;rdquo;, or the upper bound is &amp;ldquo;plus infinity&amp;rdquo;, respectively. But note that these infinite values are never values of the range's element type, and can never be part of the range. (So there is no such thing as an inclusive infinite bound &amp;mdash; if you try to write one, it will automatically be converted to an exclusive bound.)</source>
          <target state="translated">이는 하한이 &quot;빼기 무한대&quot;이거나 상한이 &quot;플러스 무한대&quot;인 것을 고려하는 것과 같습니다. 그러나 이러한 무한 값은 범위 요소 유형의 값이 아니며 범위의 일부가 될 수 없습니다. (따라서 포함 무한대와 같은 것은 없습니다. 작성하려고하면 자동으로 배타적 경계로 변환됩니다.)</target>
        </trans-unit>
        <trans-unit id="32b4366f2bb306ae39f6ae123b6e52ebbaf45e22" translate="yes" xml:space="preserve">
          <source>This is false for internal languages (such as SQL) and true for user-defined languages. Currently, pg_dump still uses this to determine which languages need to be dumped, but this might be replaced by a different mechanism in the future.</source>
          <target state="translated">내부 언어 (예 : SQL)의 경우 false이고 사용자 정의 언어의 경우 true입니다. 현재 pg_dump는 여전히이 언어를 사용하여 덤프해야하는 언어를 결정하지만 향후 다른 메커니즘으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="909703c85505cd16ac2e43cb68b897cd4647ad6b" translate="yes" xml:space="preserve">
          <source>This is identical to &lt;code&gt;dow&lt;/code&gt; except for Sunday. This matches the ISO 8601 day of the week numbering.</source>
          <target state="translated">일요일을 제외하고 &lt;code&gt;dow&lt;/code&gt; 와 동일합니다 . 이것은 ISO 8601 요일 번호 매기기와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="774c866f144b866c3887ecc3ab9eba1546c6554f" translate="yes" xml:space="preserve">
          <source>This is more useful if the expressions in the select list return varying results. For example, you could call a function this way:</source>
          <target state="translated">선택 목록의 표현식이 다양한 결과를 리턴하는 경우 더 유용합니다. 예를 들어 다음과 같이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f2d8c3b689196c5d8ec8d4f5df566ae69faf2b" translate="yes" xml:space="preserve">
          <source>This is needed to avoid syntactic ambiguity. An example is:</source>
          <target state="translated">구문 상 모호성을 피하기 위해 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c677b482c1d51ad6809dd70f3013fed740bc81c" translate="yes" xml:space="preserve">
          <source>This is not as efficient as a partial index on the &lt;code&gt;amount&lt;/code&gt; column would be, since the system has to scan the entire index. Yet, if there are relatively few unbilled orders, using this partial index just to find the unbilled orders could be a win.</source>
          <target state="translated">시스템이 전체 색인을 스캔해야하기 때문에 &lt;code&gt;amount&lt;/code&gt; 열의 부분 색인만큼 효율적이지 않습니다 . 그러나 청구되지 않은 주문이 상대적으로 적은 경우,이 부분 지수를 사용하여 청구되지 않은 주문을 찾기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="30d2d55c459297e19ddd1f07d0c1ebe65fd3794d" translate="yes" xml:space="preserve">
          <source>This is not especially useful since it has exactly the same result as the more conventional</source>
          <target state="translated">이것은 더 전통적인 방법과 동일한 결과를 가지기 때문에 특히 유용하지 않습니다</target>
        </trans-unit>
        <trans-unit id="0322eac9bb3931b0da02327d4f96591febd87604" translate="yes" xml:space="preserve">
          <source>This is only a conceptual model. The join is usually performed in a more efficient manner than actually comparing each possible pair of rows, but this is invisible to the user.</source>
          <target state="translated">이것은 개념적 모델 일뿐입니다. 조인은 일반적으로 가능한 각 행 쌍을 실제로 비교하는 것보다 더 효율적인 방식으로 수행되지만 사용자에게는 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8169801d92724560db318d90118c63ada145ffc" translate="yes" xml:space="preserve">
          <source>This is quite a different problem: how to estimate the selectivity when the value is &lt;em&gt;not&lt;/em&gt; in the MCV list. The approach is to use the fact that the value is not in the list, combined with the knowledge of the frequencies for all of the MCVs:</source>
          <target state="translated">값이 MCV 목록에 &lt;em&gt;없을&lt;/em&gt; 때 선택성을 추정하는 방법과는 상당히 다른 문제 입니다. 모든 MCV의 주파수에 대한 지식과 함께 값이 목록에 없다는 사실을 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f0d520c606037b870becb6e588d6da7dff0960ba" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;digest()&lt;/code&gt; but the hash can only be recalculated knowing the key. This prevents the scenario of someone altering data and also changing the hash to match.</source>
          <target state="translated">이것은 &lt;code&gt;digest()&lt;/code&gt; 와 비슷 하지만 키를 알고 있으면 해시를 다시 계산할 수만 있습니다. 이것은 누군가가 데이터를 변경하고 일치하도록 해시를 변경하는 시나리오를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="53bd3331f309cfd6d8eeacec7a8068398ef70fcf" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Fast Shutdown&lt;/em&gt; mode. The server disallows new connections and sends all existing server processes SIGTERM, which will cause them to abort their current transactions and exit promptly. It then waits for all server processes to exit and finally shuts down. If the server is in online backup mode, backup mode will be terminated, rendering the backup useless.</source>
          <target state="translated">이것은이다 &lt;em&gt;빠른 종료&lt;/em&gt; 모드. 서버는 새 연결을 허용하지 않고 기존의 모든 서버 프로세스 SIGTERM을 전송하여 현재 트랜잭션을 중단하고 즉시 종료합니다. 그런 다음 모든 서버 프로세스가 종료 될 때까지 기다렸다가 마지막으로 종료됩니다. 서버가 온라인 백업 모드 인 경우 백업 모드가 종료되어 백업을 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="9519f8334dda9bed264446e6f4818cc6899e6c5a" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Immediate Shutdown&lt;/em&gt; mode. The server will send SIGQUIT to all child processes and wait for them to terminate. If any do not terminate within 5 seconds, they will be sent SIGKILL. The master server process exits as soon as all child processes have exited, without doing normal database shutdown processing. This will lead to recovery (by replaying the WAL log) upon next start-up. This is recommended only in emergencies.</source>
          <target state="translated">이것은 &lt;em&gt;즉시 종료&lt;/em&gt; 모드입니다. 서버는 모든 하위 프로세스에 SIGQUIT를 전송하고 종료 될 때까지 기다립니다. 5 초 내에 종료되지 않으면 SIGKILL이 전송됩니다. 정상적인 데이터베이스 종료 처리를 수행하지 않고 모든 하위 프로세스가 종료 되 자마자 마스터 서버 프로세스가 종료됩니다. 다음에 시작할 때 WAL 로그를 재생하여 복구 할 수 있습니다. 이것은 응급 상황에서만 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="64dec29096a90e2ac7b66bae5da2edc5f6e90310" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Smart Shutdown&lt;/em&gt; mode. After receiving SIGTERM, the server disallows new connections, but lets existing sessions end their work normally. It shuts down only after all of the sessions terminate. If the server is in online backup mode, it additionally waits until online backup mode is no longer active. While backup mode is active, new connections will still be allowed, but only to superusers (this exception allows a superuser to connect to terminate online backup mode). If the server is in recovery when a smart shutdown is requested, recovery and streaming replication will be stopped only after all regular sessions have terminated.</source>
          <target state="translated">이것은 &lt;em&gt;스마트 셧다운입니다&lt;/em&gt; 모드입니다. SIGTERM을 수신 한 후 서버는 새 연결을 허용하지 않지만 기존 세션이 정상적으로 종료되도록합니다. 모든 세션이 종료 된 후에 만 ​​종료됩니다. 서버가 온라인 백업 모드 인 경우 온라인 백업 모드가 더 이상 활성화되지 않을 때까지 추가로 대기합니다. 백업 모드가 활성화되어있는 동안에도 새 연결은 여전히 ​​허용되지만 수퍼 유저에게만 허용됩니다 (이 예외는 수퍼 유저가 온라인 백업 모드를 종료하기 위해 연결할 수 있음). 스마트 종료가 요청 될 때 서버가 복구중인 경우 모든 일반 세션이 종료 된 후에 만 ​​복구 및 스트리밍 복제가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="18b982c4dd6953b11d003392c392545d3b122dd7" translate="yes" xml:space="preserve">
          <source>This is the SQL standard's equivalent to &lt;code&gt;bool_and&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;bool_and&lt;/code&gt; 에 해당하는 SQL 표준 입니다.</target>
        </trans-unit>
        <trans-unit id="92dd6728f5fbf932d72131603602b0280b7afbb6" translate="yes" xml:space="preserve">
          <source>This is the amount of time to wait on a lock before checking to see if there is a deadlock condition. The check for deadlock is relatively expensive, so the server doesn't run it every time it waits for a lock. We optimistically assume that deadlocks are not common in production applications and just wait on the lock for a while before checking for a deadlock. Increasing this value reduces the amount of time wasted in needless deadlock checks, but slows down reporting of real deadlock errors. If this value is specified without units, it is taken as milliseconds. The default is one second (&lt;code&gt;1s&lt;/code&gt;), which is probably about the smallest value you would want in practice. On a heavily loaded server you might want to raise it. Ideally the setting should exceed your typical transaction time, so as to improve the odds that a lock will be released before the waiter decides to check for deadlock. Only superusers can change this setting.</source>
          <target state="translated">교착 상태가 있는지 확인하기 전에 잠금 대기 시간입니다. 교착 상태 점검은 상대적으로 비싸므로 서버는 잠금을 기다릴 때마다 실행하지 않습니다. 프로덕션 애플리케이션에서는 교착 상태가 일반적이지 않다고 가정하고 교착 상태를 확인하기 전에 잠시 동안 잠금을 기다립니다. 이 값을 늘리면 불필요한 교착 상태 확인에 낭비되는 시간이 줄어들지 만 실제 교착 상태 오류보고 속도는 느려집니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 1 초입니다 ( &lt;code&gt;1s&lt;/code&gt; )는 실제로 원하는 최소값에 관한 것입니다. 로드가 많은 서버에서는 서버를 높이고 싶을 수 있습니다. 웨이터가 교착 상태를 확인하기로 결정하기 전에 잠금이 해제 될 가능성을 높이려면 설정이 일반적인 트랜잭션 시간을 초과해야합니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66c8088759f9087b738e1b70d1cf37c8a1aae852" translate="yes" xml:space="preserve">
          <source>This is the default format.</source>
          <target state="translated">이것이 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="3ce226ef1a13e0c7b419788ac5e73819bf180bcb" translate="yes" xml:space="preserve">
          <source>This is the generic &amp;ldquo;I couldn't find a server to talk to&amp;rdquo; failure. It looks like the above when TCP/IP communication is attempted. A common mistake is to forget to configure the server to allow TCP/IP connections.</source>
          <target state="translated">이것은 일반적인 &quot;통신 할 서버를 찾을 수 없습니다&quot;오류입니다. TCP / IP 통신을 시도하면 위와 같습니다. 일반적인 실수는 TCP / IP 연결을 허용하도록 서버를 구성하는 것을 잊는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a73a092e455b0519a284ead127b2916ee3a2346" translate="yes" xml:space="preserve">
          <source>This is the interval between updates to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;. The default is 300 seconds. If set to 0, the file will not be dumped at regular intervals, but only when the server is shut down.</source>
          <target state="translated">이것은 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; 업데이트 간격 입니다. 기본값은 300 초입니다. 0으로 설정하면 파일이 정기적으로 덤프되지 않고 서버가 종료 된 경우에만 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="7a967763949218bdd201f81e3734208d5693135c" translate="yes" xml:space="preserve">
          <source>This is the most secure of the currently provided methods, but it is not supported by older client libraries.</source>
          <target state="translated">현재 제공되는 방법 중 가장 안전하지만 이전 클라이언트 라이브러리에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="281ee2a6d6b295f0c605c272cbd3a317a0476533" translate="yes" xml:space="preserve">
          <source>This is the price one pays for extensibility.</source>
          <target state="translated">이것은 확장 성을 위해 지불하는 가격입니다.</target>
        </trans-unit>
        <trans-unit id="e49d24e044b41980e036610f5fc7a5e4be7955e6" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pg_relpages(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">이것과 동일 &lt;code&gt;pg_relpages(regclass)&lt;/code&gt; 타겟 관계를 TEXT로 지정된 것을 제외. 이 기능은 지금까지 역 호환성으로 인해 유지되며 향후 릴리스에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64132a4b93c0dbcab91f77d1ac58e1693be7385b" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstatindex(regclass)&lt;/code&gt;, except that the target index is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">이것과 동일 &lt;code&gt;pgstatindex(regclass)&lt;/code&gt; 타겟 TEXT 인덱스로 지정되는 것을 제외하고,. 이 기능은 지금까지 역 호환성으로 인해 유지되며 향후 릴리스에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54441c2148265c644b6e2c6b5762a5242346cb3d" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstattuple(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">이것과 동일 &lt;code&gt;pgstattuple(regclass)&lt;/code&gt; 타겟 관계를 TEXT로 지정된 것을 제외. 이 기능은 지금까지 역 호환성으로 인해 유지되며 향후 릴리스에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ece1f9875ce6ffc21558f8024d23103c3c5eb710" translate="yes" xml:space="preserve">
          <source>This is the same example using normalized ranking:</source>
          <target state="translated">이것은 정규화 된 순위를 사용하는 동일한 예입니다.</target>
        </trans-unit>
        <trans-unit id="b095631465e3260d63a74afe0d97ae2d96edf684" translate="yes" xml:space="preserve">
          <source>This is the same query as above, but we added a &lt;code&gt;LIMIT&lt;/code&gt; so that not all the rows need be retrieved, and the planner changed its mind about what to do. Notice that the total cost and row count of the Index Scan node are shown as if it were run to completion. However, the Limit node is expected to stop after retrieving only a fifth of those rows, so its total cost is only a fifth as much, and that's the actual estimated cost of the query. This plan is preferred over adding a Limit node to the previous plan because the Limit could not avoid paying the startup cost of the bitmap scan, so the total cost would be something over 25 units with that approach.</source>
          <target state="translated">이것은 위와 동일한 쿼리이지만 &lt;code&gt;LIMIT&lt;/code&gt; 를 추가하여 모든 행을 검색 할 필요는 없으며 플래너는 수행 할 작업에 대한 생각을 바꿨습니다. 인덱스 스캔 노드의 총 비용 및 행 수는 마치 완료까지 실행 된 것처럼 표시됩니다. 그러나 해당 행의 5 분의 1 만 검색 한 후 한계 노드가 중지 될 것으로 예상되므로 총 비용은 5 분의 1에 불과하며 이는 쿼리의 실제 예상 비용입니다. 이 계획은 제한이 비트 맵 스캔의 시작 비용을 지불하는 것을 피할 수 없기 때문에 이전 계획에 제한 노드를 추가하는 것보다 선호되므로 총 비용은 해당 접근 방식을 사용하는 25 단위가 넘습니다.</target>
        </trans-unit>
        <trans-unit id="94cb90e2972cc12877867d7980fc980b09691ec3" translate="yes" xml:space="preserve">
          <source>This is transformed by the parser to effectively become:</source>
          <target state="translated">이것은 파서에 의해 효과적으로 변환됩니다 :</target>
        </trans-unit>
        <trans-unit id="a05aa8321906cf1c74f9a81ad06926d222bf1181" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a handler function.</source>
          <target state="translated">외부 데이터 랩퍼에 더 이상 핸들러 기능이 없어야 함을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0dd5b48b4b716a9453020ad47edd41a0fc5866a" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a validator function.</source>
          <target state="translated">외부 데이터 랩퍼에 더 이상 유효성 검증기 기능이 없어야 함을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d30d7211e06d7778bc4cd17adf8c8ca724a370e3" translate="yes" xml:space="preserve">
          <source>This is what you are most likely to get if you succeed in contacting the server, but it does not want to talk to you. As the message suggests, the server refused the connection request because it found no matching entry in its &lt;code&gt;pg_hba.conf&lt;/code&gt; configuration file.</source>
          <target state="translated">서버 연결에 성공하면 가장 많이 얻을 수 있지만 대화하고 싶지는 않습니다. 메시지에서 알 수 있듯이 서버는 &lt;code&gt;pg_hba.conf&lt;/code&gt; 구성 파일 에서 일치하는 항목을 찾지 못해 연결 요청을 거부했습니다 .</target>
        </trans-unit>
        <trans-unit id="fa56032fee9f040556b310dd23691f09946834cc" translate="yes" xml:space="preserve">
          <source>This is wrong since it is not clear which child table the key value 200 belongs in.</source>
          <target state="translated">키 값 200이 속한 하위 테이블이 확실하지 않기 때문에 이것은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="0515e31998ba6bb73d0ddae64599b98492334cc8" translate="yes" xml:space="preserve">
          <source>This is, subtract the null fraction from one for each of the relations, and divide by the maximum of the numbers of distinct values. The number of rows that the join is likely to emit is calculated as the cardinality of the Cartesian product of the two inputs, multiplied by the selectivity:</source>
          <target state="translated">이것은 각 관계에 대해 하나에서 널 분율을 빼고 고유 값의 최대 수로 나눕니다. 결합이 방출 할 가능성이있는 행 수는 두 입력의 카티 전 곱의 카디널리티로 선택성에 곱하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="1465b8af61e8c0e09acc4cea2d200fe28f10de58" translate="yes" xml:space="preserve">
          <source>This key is always present on the last line of the backup manifest file. The associated value is a SHA256 checksum of all the preceding lines. We use a fixed checksum method here to make it possible for clients to do incremental parsing of the manifest. While a SHA256 checksum is significantly more expensive than a CRC32C checksum, the manifest should normally be small enough that the extra computation won't matter very much.</source>
          <target state="translated">이 키는 항상 백업 매니페스트 파일의 마지막 줄에 있습니다. 연관된 값은 모든 이전 행의 SHA256 체크섬입니다. 클라이언트가 매니페스트의 증분 파싱을 수행 할 수 있도록 여기에서 고정 된 체크섬 방법을 사용합니다. SHA256 체크섬은 CRC32C 체크섬보다 훨씬 비싸지 만 매니페스트는 일반적으로 추가 계산이 그다지 중요하지 않을만큼 충분히 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="88f72ee86e21efe6631404a3bf422fe90ce0b7b5" translate="yes" xml:space="preserve">
          <source>This key word is ignored.</source>
          <target state="translated">이 키워드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ccf5892ae182b1129c89233a93f9d2dff22e3a50" translate="yes" xml:space="preserve">
          <source>This keyword immediately precedes the declaration of one or two relation names that provide access to the transition relations of the triggering statement.</source>
          <target state="translated">이 키워드는 트리거 명령문의 전이 관계에 대한 액세스를 제공하는 하나 또는 두 개의 관계 이름 선언 바로 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="e080950e112255fe2f612123624be96d15f65967" translate="yes" xml:space="preserve">
          <source>This latter equivalence does not hold exactly when more than two tables appear, because &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than comma. For example &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; is not the same as &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; because the &lt;code&gt;condition&lt;/code&gt; can reference &lt;code&gt;T1&lt;/code&gt; in the first case but not the second.</source>
          <target state="translated">&lt;code&gt;JOIN&lt;/code&gt; 이 쉼표보다 더 밀접하게 바인딩 되므로 두 개 이상의 테이블이 표시 될 때 후자의 동등성은 정확하게 유지되지 않습니다 . 예를 들어, &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; 과 동일하지 &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; 때문에 &lt;code&gt;condition&lt;/code&gt; 참조 할 &lt;code&gt;T1&lt;/code&gt; 을 제를 첫 번째 경우는 아니지만.</target>
        </trans-unit>
        <trans-unit id="4445598676898e3b5c713e7c5758010ce357bcd1" translate="yes" xml:space="preserve">
          <source>This level is different from Read Committed in that a query in a repeatable read transaction sees a snapshot as of the start of the first non-transaction-control statement in the &lt;em&gt;transaction&lt;/em&gt;, not as of the start of the current statement within the transaction. Thus, successive &lt;code&gt;SELECT&lt;/code&gt; commands within a &lt;em&gt;single&lt;/em&gt; transaction see the same data, i.e., they do not see changes made by other transactions that committed after their own transaction started.</source>
          <target state="translated">이 레벨은 반복 가능한 읽기 트랜잭션의 쿼리가 &lt;em&gt;트랜잭션&lt;/em&gt; 내의 현재 명령문의 시작이 아닌 트랜잭션의 첫 번째 비 트랜잭션 제어문의 시작으로 스냅 샷을 보는 점에서 커밋 된 읽기와 다릅니다 . 따라서 &lt;em&gt;단일&lt;/em&gt; 트랜잭션 내 에서 연속적인 &lt;code&gt;SELECT&lt;/code&gt; 명령 은 동일한 데이터를 봅니다. 즉, 자체 트랜잭션이 시작된 후 커밋 된 다른 트랜잭션에 의한 변경 사항이 표시되지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b43064679af2be0d9a41eca78e98514d704b879" translate="yes" xml:space="preserve">
          <source>This level of integrity protection using Serializable transactions does not yet extend to hot standby mode (&lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;). Because of that, those using hot standby may want to use Repeatable Read and explicit locking on the master.</source>
          <target state="translated">직렬화 가능 트랜잭션을 사용하는이 수준의 무결성 보호는 아직 핫 대기 모드로 확장되지 않습니다 ( &lt;a href=&quot;hot-standby&quot;&gt;섹션 26.5&lt;/a&gt; ). 이 때문에 핫 스탠바이를 사용하는 사용자는 마스터에서 반복 읽기 및 명시 적 잠금을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81dc2dc08c39c5d2f9e3dd37d41f417f52e2a9fc" translate="yes" xml:space="preserve">
          <source>This limits the usefulness of the &lt;code&gt;passwordcheck&lt;/code&gt; module, because in that case it can only try to guess the password. For this reason, &lt;code&gt;passwordcheck&lt;/code&gt; is not recommended if your security requirements are high. It is more secure to use an external authentication method such as GSSAPI (see &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) than to rely on passwords within the database.</source>
          <target state="translated">이 경우 &lt;code&gt;passwordcheck&lt;/code&gt; 모듈 의 유용성이 제한 됩니다.이 경우 비밀번호 추측 만 시도 할 수 있기 때문입니다. 따라서 보안 요구 사항이 높으면 &lt;code&gt;passwordcheck&lt;/code&gt; 권장하지 않습니다. 데이터베이스 내에서 비밀번호를 사용하는 것보다 GSSAPI ( &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 참조)와 같은 외부 인증 방법을 사용하는 것이 더 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="2789c3cbaef768ecab4d3f60f01f3d79af1c2ea9" translate="yes" xml:space="preserve">
          <source>This limits the usefulness of the &lt;code&gt;passwordcheck&lt;/code&gt; module, because in that case it can only try to guess the password. For this reason, &lt;code&gt;passwordcheck&lt;/code&gt; is not recommended if your security requirements are high. It is more secure to use an external authentication method such as GSSAPI (see &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) than to rely on passwords within the database.</source>
          <target state="translated">이것은 &lt;code&gt;passwordcheck&lt;/code&gt; 모듈 의 유용성을 제한합니다 .이 경우 암호를 추측 할 수만 있기 때문입니다. 따라서 보안 요구 사항이 높은 경우 에는 &lt;code&gt;passwordcheck&lt;/code&gt; 를 사용하지 않는 것이 좋습니다. GSSAPI ( &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;20 장&lt;/a&gt; 참조)와 같은 외부 인증 방법을 사용하는 것이 데이터베이스 내의 암호에 의존하는 것보다 더 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="1a5e3d694aabd0836b4470958df1839ef5142811" translate="yes" xml:space="preserve">
          <source>This may be more intuitive if you are using &lt;code&gt;pg_ctl&lt;/code&gt; for starting and stopping the server (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;), so that &lt;code&gt;pg_ctl&lt;/code&gt; would be the sole command you use for managing the database server instance.</source>
          <target state="translated">서버를 시작 및 중지하기 위해 &lt;code&gt;pg_ctl&lt;/code&gt; 을 사용하는 경우 ( &lt;a href=&quot;server-start&quot;&gt;18.3 절&lt;/a&gt; 참조 ) 이는 &lt;code&gt;pg_ctl&lt;/code&gt; 이 데이터베이스 서버 인스턴스 관리에 사용하는 유일한 명령 이되도록보다 직관적 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfa0eac4f1545a9ddc55a9ceb07c6c1edc0186f1" translate="yes" xml:space="preserve">
          <source>This means that the server was not started, or it was not started where &lt;code&gt;createdb&lt;/code&gt; expected it. Again, check the installation instructions or consult the administrator.</source>
          <target state="translated">이 수단은 서버가 시작되지 않았 음을, 또는 어디가 시작되지 않았습니다 &lt;code&gt;createdb&lt;/code&gt; 그것을 기대했다. 다시 설치 지침을 확인하거나 관리자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="ded18d2e27ab98a47b51417474a9c5eeb41e0e40" translate="yes" xml:space="preserve">
          <source>This mechanism prevents unencrypted data from being read from the drives if the drives or the entire computer is stolen. This does not protect against attacks while the file system is mounted, because when mounted, the operating system provides an unencrypted view of the data. However, to mount the file system, you need some way for the encryption key to be passed to the operating system, and sometimes the key is stored somewhere on the host that mounts the disk.</source>
          <target state="translated">이 메커니즘은 드라이브 나 전체 컴퓨터를 도난당한 경우 드라이브에서 암호화되지 않은 데이터를 읽을 수 없도록합니다. 파일 시스템이 마운트 된 동안에는 운영 체제가 암호화되지 않은 데이터보기를 제공하므로 파일 시스템이 마운트되는 동안 공격으로부터 보호되지 않습니다. 그러나 파일 시스템을 마운트하려면 암호화 키를 운영 체제로 전달할 수있는 방법이 필요하며 때로는 키가 디스크를 마운트하는 호스트의 어딘가에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4541818976374d79642c0f93c22dbb7a713f72ad" translate="yes" xml:space="preserve">
          <source>This method consolidates information in the tree. Given a set of entries, this function generates a new index entry that represents all the given entries.</source>
          <target state="translated">이 방법은 정보를 트리에 통합합니다. 항목 집합이 주어지면이 함수는 주어진 모든 항목을 나타내는 새 색인 항목을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bc385497c58aec7319cf4002de1bf0ca8c1d4cff" translate="yes" xml:space="preserve">
          <source>This method of upgrading can be performed using the built-in logical replication facilities as well as using external logical replication systems such as pglogical, Slony, Londiste, and Bucardo.</source>
          <target state="translated">이 업그레이드 방법은 내장 논리 복제 기능과 pglogical, Slony, Londiste 및 Bucardo와 같은 외부 논리 복제 시스템을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82b2800cab107f6d05df0ae989ccbd67016a0ee1" translate="yes" xml:space="preserve">
          <source>This might cause zero, one, or many rows to be updated. It is not an error to attempt an update that does not match any rows.</source>
          <target state="translated">이로 인해 0 개, 1 개 또는 많은 행이 업데이트 될 수 있습니다. 행과 일치하지 않는 업데이트를 시도하는 것은 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="264f830b811a6d6b8c58c36cb7fd806990f75f99" translate="yes" xml:space="preserve">
          <source>This might produce log output such as:</source>
          <target state="translated">다음과 같은 로그 출력이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b493978753faced6c574bfe3060740f6644ad55e" translate="yes" xml:space="preserve">
          <source>This mode is provided for those who insist on it, but you are not necessarily encouraged to use it. In particular, if you mix SQL and meta-commands on a line the order of execution might not always be clear to the inexperienced user.</source>
          <target state="translated">이 모드는 해당 모드를 주장하는 사용자에게 제공되지만 반드시 사용하도록 권장되는 것은 아닙니다. 특히 SQL과 메타 명령을 한 줄에 혼합하면 경험이없는 사용자에게는 실행 순서가 항상 명확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d9301bd35d933ed8044c02b82956382914754a7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;cube&lt;/code&gt; for representing multidimensional cubes.</source>
          <target state="translated">이 모듈 은 다차원 큐브를 나타내는 데이터 유형 &lt;code&gt;cube&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="f8e33606e025a4455156d4072de6e226ed4b94f7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;ltree&lt;/code&gt; for representing labels of data stored in a hierarchical tree-like structure. Extensive facilities for searching through label trees are provided.</source>
          <target state="translated">이 모듈 은 계층 적 트리 형 구조에 저장된 데이터의 레이블을 나타내는 데이터 유형 &lt;code&gt;ltree&lt;/code&gt; 를 구현합니다 . 라벨 트리를 통한 광범위한 검색 시설이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e72760dc721284c431bb3ba272b6dca3b540e0f1" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;seg&lt;/code&gt; for representing line segments, or floating point intervals. &lt;code&gt;seg&lt;/code&gt; can represent uncertainty in the interval endpoints, making it especially useful for representing laboratory measurements.</source>
          <target state="translated">이 모듈은 데이터 타입 구현 &lt;code&gt;seg&lt;/code&gt; 점 간격 선분을 나타내는 또는 부동한다. &lt;code&gt;seg&lt;/code&gt; 는 구간 끝점에서 불확실성을 나타낼 수 있으므로 실험실 측정을 나타내는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2dd33542f64474fba94a46e6b605e9b2299f1bab" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;hstore&lt;/code&gt; data type for storing sets of key/value pairs within a single PostgreSQL value. This can be useful in various scenarios, such as rows with many attributes that are rarely examined, or semi-structured data. Keys and values are simply text strings.</source>
          <target state="translated">이 모듈 은 단일 PostgreSQL 값 내에 키 / 값 쌍 세트를 저장하기 위해 &lt;code&gt;hstore&lt;/code&gt; 데이터 유형을 구현합니다 . 이것은 거의 조사되지 않는 많은 속성을 가진 행 또는 반 구조화 된 데이터와 같은 다양한 시나리오에서 유용 할 수 있습니다. 키와 값은 단순히 텍스트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="de0a2c458306a9179b18df224706a81701d0af82" translate="yes" xml:space="preserve">
          <source>This module integrates with SELinux to provide an additional layer of security checking above and beyond what is normally provided by PostgreSQL. From the perspective of SELinux, this module allows PostgreSQL to function as a user-space object manager. Each table or function access initiated by a DML query will be checked against the system security policy. This check is in addition to the usual SQL permissions checking performed by PostgreSQL.</source>
          <target state="translated">이 모듈은 SELinux와 통합되어 PostgreSQL에서 일반적으로 제공하는 것 이상의 추가 보안 검사 계층을 제공합니다. SELinux의 관점에서이 모듈을 사용하면 PostgreSQL을 사용자 공간 객체 관리자로 사용할 수 있습니다. DML 쿼리에 의해 시작된 각 테이블 또는 함수 액세스는 시스템 보안 정책에 따라 점검됩니다. 이 확인은 PostgreSQL에서 수행하는 일반적인 SQL 권한 확인에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f7043a9bb620afd5b48f848b5741b06bf97dc549" translate="yes" xml:space="preserve">
          <source>This module is considered &amp;ldquo;trusted&amp;rdquo;, that is, it can be installed by non-superusers who have &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database.</source>
          <target state="translated">이 모듈은 &quot;신뢰할 수있는&quot;모듈로 간주 됩니다. 즉, 현재 데이터베이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이있는 슈퍼 유저가 아닌 사용자가 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="269393947826c6d71fccaff13c4be9c80ca40682" translate="yes" xml:space="preserve">
          <source>This module is sponsored by Delta-Soft Ltd., Moscow, Russia.</source>
          <target state="translated">이 모듈은 러시아 모스크바의 Delta-Soft Ltd.가 후원합니다.</target>
        </trans-unit>
        <trans-unit id="4056f705daa3e3fdd49196fac6596ba7b2aa2807" translate="yes" xml:space="preserve">
          <source>This module was inspired by Garrett A. Wollman's &lt;code&gt;isbn_issn&lt;/code&gt; code.</source>
          <target state="translated">이 모듈은 Garrett A. Wollman의 &lt;code&gt;isbn_issn&lt;/code&gt; 코드 에서 영감을 받았습니다 .</target>
        </trans-unit>
        <trans-unit id="141bf6865546870a10c076189dfdbdeb9f73407a" translate="yes" xml:space="preserve">
          <source>This naming convention establishes a clear order in which these files will be loaded. This is important because only the last setting encountered for a particular parameter while the server is reading configuration files will be used. In this example, something set in &lt;code&gt;conf.d/02server.conf&lt;/code&gt; would override a value set in &lt;code&gt;conf.d/01memory.conf&lt;/code&gt;.</source>
          <target state="translated">이 명명 규칙은 이러한 파일이로드 될 명확한 순서를 설정합니다. 서버가 구성 파일을 읽는 동안 특정 매개 변수에 대해 마지막으로 발생한 설정 만 사용되므로 이는 중요합니다. 이 예에서 &lt;code&gt;conf.d/02server.conf&lt;/code&gt; 에 설정된 내용은 &lt;code&gt;conf.d/01memory.conf&lt;/code&gt; 에 설정된 값보다 우선합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
