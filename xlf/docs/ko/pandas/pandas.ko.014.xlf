<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="67f55947a3407f40ea29d802d9e21cc6c662d3cc" translate="yes" xml:space="preserve">
          <source>An array of values to be printed in, e.g. the Series repr</source>
          <target state="translated">인쇄 될 값의 배열, 예를 들어 Series repr</target>
        </trans-unit>
        <trans-unit id="a4dee4090deedf2711f4fd67e3156127ced095b4" translate="yes" xml:space="preserve">
          <source>An array suitable for factorization. This should maintain order and be a supported dtype (Float64, Int64, UInt64, String, Object). By default, the extension array is cast to object dtype.</source>
          <target state="translated">분해에 적합한 배열입니다. 순서를 유지하고 지원되는 dtype (Float64, Int64, UInt64, String, Object)이어야합니다. 기본적으로 확장 배열은 객체 dtype으로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="097e7ede4817318ab5b4cd1266acc311559067e1" translate="yes" xml:space="preserve">
          <source>An array-like containing the elements taken from the object.</source>
          <target state="translated">객체에서 가져온 요소를 포함하는 배열과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfed5139494c5d4e24452c1dffe39e1f3454a1d3" translate="yes" xml:space="preserve">
          <source>An array-like object representing the respective bin for each value of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3b93a374a21a89c8b42336f3e05092d94e1f9a" translate="yes" xml:space="preserve">
          <source>An array-like object representing the respective bin for each value of &lt;code&gt;x&lt;/code&gt;. The type depends on the value of &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 각 값에 대한 각 구간을 나타내는 배열과 같은 객체 입니다. 유형은 &lt;code&gt;labels&lt;/code&gt; 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="369f3c1a328c09e7a1c230d26280769b2cb27ce2" translate="yes" xml:space="preserve">
          <source>An axes of the current figure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e46fa4c633f561daea2cf188be81ccfb1fdb29" translate="yes" xml:space="preserve">
          <source>An empty CategoricalDtype with a specific dtype can be created by providing an empty index. As follows,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64078a9d289cfc61ae078d0baf4fb1f665b89e69" translate="yes" xml:space="preserve">
          <source>An equivalent &lt;a href=&quot;../reference/api/pandas.series.dropna#pandas.Series.dropna&quot;&gt;&lt;code&gt;dropna()&lt;/code&gt;&lt;/a&gt; is available for Series. DataFrame.dropna has considerably more options than Series.dropna, which can be examined &lt;a href=&quot;../reference/frame#api-dataframe-missing&quot;&gt;in the API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3314fcfba8e2f2c60fe01eaa33c8eb7e82a66dc6" translate="yes" xml:space="preserve">
          <source>An example of an actual empty DataFrame. Notice the index is empty:</source>
          <target state="translated">실제 빈 DataFrame의 예입니다. 색인이 비어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="48e7cc0068ffad01dbdccc5fa78772b552a5e4d3" translate="yes" xml:space="preserve">
          <source>An example of how holidays and holiday calendars are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc2df970445a0871f56ae75d87fda781efc92d2" translate="yes" xml:space="preserve">
          <source>An example where the category type is not preserved is if you take one single row: the resulting &lt;code&gt;Series&lt;/code&gt; is of dtype &lt;code&gt;object&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505929e337f583f52da37a04958fc64f74b14fe2" translate="yes" xml:space="preserve">
          <source>An example with subplots, so an array of axes is returned.</source>
          <target state="translated">서브 플롯이있는 예제이므로 축 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="34f6871b726eeea0244b8db488d4065c2c5178d8" translate="yes" xml:space="preserve">
          <source>An exception on this basic propagation rule are &lt;em&gt;reductions&lt;/em&gt; (such as the mean or the minimum), where pandas defaults to skipping missing values. See &lt;a href=&quot;#missing-data-calculations&quot;&gt;above&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ebc4aa24c788287486c5587f8e4f8dda1446a5" translate="yes" xml:space="preserve">
          <source>An expanding window yields the value of an aggregation statistic with all the data available up to that point in time. Since these calculations are a special case of rolling statistics, they are implemented in pandas such that the following two calls are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0242fdc195342aaa71b0edb5dd306570b29a2115" translate="yes" xml:space="preserve">
          <source>An exponentially weighted window is similar to an expanding window but with each prior point being exponentially weighted down relative to the current point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226454d30a9070403b645515633c958fb571aad3" translate="yes" xml:space="preserve">
          <source>An if-then on one column</source>
          <target state="translated">한 열의 if-then</target>
        </trans-unit>
        <trans-unit id="ec71265f99608c07b0017b838a24f938e5b92c3f" translate="yes" xml:space="preserve">
          <source>An if-then with assignment to 2 columns:</source>
          <target state="translated">2 개의 열에 할당 된 if-then :</target>
        </trans-unit>
        <trans-unit id="897727e58a510bbf3b5dec014490adf2865d8c94" translate="yes" xml:space="preserve">
          <source>An immutable container for datetimes.</source>
          <target state="translated">날짜 시간에 대한 불변 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="3b7291cb25fc5cf793f30b4e32ceadabe5a35c03" translate="yes" xml:space="preserve">
          <source>An indexer into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56cc23fff6754e9e9184319751d93350980feda6" translate="yes" xml:space="preserve">
          <source>An indexer into &lt;code&gt;self&lt;/code&gt; that specifies which values are used in the formatting process.</source>
          <target state="translated">서식 지정 프로세스에 사용되는 값을 지정 하는 인덱서 &lt;code&gt;self&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f6b4be800bb58881690a2f9195dc6115ce189e9" translate="yes" xml:space="preserve">
          <source>An indexer into the target of the values not found. These correspond to the -1 in the indexer array.</source>
          <target state="translated">찾을 수없는 값의 대상에 대한 인덱서입니다. 이들은 인덱서 배열의 -1에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="fd3728e55d62590bd20d4b70c4a0186859f72e80" translate="yes" xml:space="preserve">
          <source>An indicated for whether or not your array is being printed within a Series, DataFrame, or Index (True), or just by itself (False). This may be useful if you want scalar values to appear differently within a Series versus on its own (e.g. quoted or not).</source>
          <target state="translated">어레이가 Series, DataFrame 또는 Index (True) 내에서 인쇄되는지 또는 자체적으로 (False) 인쇄되는지 여부를 나타냅니다. 이는 스칼라 값이 Series와 다르게 표시되도록 (예를 들어 인용되거나 인용되지 않은 경우) 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48e84c268d911a19a465c9ca0d9df0f4df316ca6" translate="yes" xml:space="preserve">
          <source>An instance of &amp;lsquo;ExtensionDtype&amp;rsquo;.</source>
          <target state="translated">'ExtensionDtype'의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="1b823750dc87c78b9f72dbde378574755d0b86d5" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;CategoricalDtype&lt;/code&gt; to use for this categorical</source>
          <target state="translated">이 categorical 형에 사용 하는 &lt;code&gt;CategoricalDtype&lt;/code&gt; 인스턴스</target>
        </trans-unit>
        <trans-unit id="8da1392006266e99cc98d20d028e2e6bbac3aea4" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;CategoricalDtype&lt;/code&gt; to use for this categorical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf68fa4f030577ebc623df235e7d76bbcab774b5" translate="yes" xml:space="preserve">
          <source>An integer NumPy array that&amp;rsquo;s an indexer into the original ExtensionArray.</source>
          <target state="translated">원래 ExtensionArray에 대한 인덱서 인 정수 NumPy 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3cd8dd27fddbf105b49cbea3bca4904191d898c6" translate="yes" xml:space="preserve">
          <source>An integer array, where each integer points to a category in categories or dtype.categories, or else is -1 for NaN.</source>
          <target state="translated">각 정수가 categories 또는 dtype.categories의 범주를 가리 키거나 NaN의 경우 -1 인 정수 배열입니다.</target>
        </trans-unit>
        <trans-unit id="19ea293f39c29163e601fc4a6cd3035e33e4e4a6" translate="yes" xml:space="preserve">
          <source>An integer e.g. &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">정수는 예 &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67524ade1214f8c09adc58dabccd8b77c5503652" translate="yes" xml:space="preserve">
          <source>An integer ndarray that&amp;rsquo;s an indexer into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8cf5c5e6a565b6547a8a9c047785beebbc0e82" translate="yes" xml:space="preserve">
          <source>An integer ndarray that&amp;rsquo;s an indexer into &lt;code&gt;uniques&lt;/code&gt;. &lt;code&gt;uniques.take(labels)&lt;/code&gt; will have the same values as &lt;code&gt;values&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uniques&lt;/code&gt; 의 인덱서 인 정수 ndarray입니다 . &lt;code&gt;uniques.take(labels)&lt;/code&gt; 는 values와 동일한 값을 &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f4b0e493707a633f44b15109cc3f05d465e496c" translate="yes" xml:space="preserve">
          <source>An integer ndarray with the factorized values.</source>
          <target state="translated">인수 분해 된 값이있는 정수 ndarray입니다.</target>
        </trans-unit>
        <trans-unit id="f83f4368b934f5515e91954b47a7cf56c066614f" translate="yes" xml:space="preserve">
          <source>An integer, e.g. &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">정수는, 예 &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e44037454fba4531deeb47c52aea3cfdde9aa97e" translate="yes" xml:space="preserve">
          <source>An ndarray containing the non- &lt;code&gt;fill_value&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 가 아닌 값을 포함하는 ndarray .</target>
        </trans-unit>
        <trans-unit id="4009b73f727e2ff299e1c74f97b206fb8c97192c" translate="yes" xml:space="preserve">
          <source>An ndarray is returned with one &lt;a href=&quot;https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes&quot;&gt;&lt;code&gt;matplotlib.axes.Axes&lt;/code&gt;&lt;/a&gt; per column when &lt;code&gt;subplots=True&lt;/code&gt;.</source>
          <target state="translated">subplots &lt;code&gt;subplots=True&lt;/code&gt; 때 열당 하나의 &lt;a href=&quot;https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes&quot;&gt; &lt;code&gt;matplotlib.axes.Axes&lt;/code&gt; &lt;/a&gt; 와 함께 ndarray가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="98387f74c95263ee5465e0e9565177e28eedcb21" translate="yes" xml:space="preserve">
          <source>An ndarray that allows field access using attributes, analogous to typed columns in a spreadsheet.</source>
          <target state="translated">스프레드 시트의 입력 된 열과 유사한 속성을 사용하여 필드에 액세스 할 수있는 ndarray입니다.</target>
        </trans-unit>
        <trans-unit id="c7e3e0c62088399ff46868c6c90f294672bac3f0" translate="yes" xml:space="preserve">
          <source>An ndarray with int64 dtype.</source>
          <target state="translated">int64 dtype의 ndarray입니다.</target>
        </trans-unit>
        <trans-unit id="5c296d52b57abbdb7cf83c5f1ad8c702810e4abb" translate="yes" xml:space="preserve">
          <source>An object of same type as caller if inplace=False, None otherwise.</source>
          <target state="translated">inplace = False 인 경우 호출자와 동일한 유형의 객체, 그렇지 않은 경우 None</target>
        </trans-unit>
        <trans-unit id="5dea7de95a165275431f6c47303dee4b8deb91bb" translate="yes" xml:space="preserve">
          <source>An object of type DataFrame or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe513b607e08baa49759fbfbeaf3baafe0b60bab" translate="yes" xml:space="preserve">
          <source>An object of type Series or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51883ce3490bc76950586f85485f1278c50f498a" translate="yes" xml:space="preserve">
          <source>An object to iterate over namedtuples for each row in the DataFrame with the first field possibly being the index and following fields being the column values.</source>
          <target state="translated">DataFrame의 각 행에 대해 명명 된 튜플을 반복하는 객체로, 첫 번째 필드는 인덱스 일 수 있고 다음 필드는 열 값입니다.</target>
        </trans-unit>
        <trans-unit id="052502227b10596ea7bd7ff5a2b3a2aa47caedb4" translate="yes" xml:space="preserve">
          <source>An object-dtype &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; objects, each with the correct &lt;code&gt;tz&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a84d9d31e0102802ac91d90e60c0e56c4ceda5" translate="yes" xml:space="preserve">
          <source>An obvious example would be the &lt;code&gt;head()&lt;/code&gt; and &lt;code&gt;tail()&lt;/code&gt; methods. As &lt;code&gt;tail()&lt;/code&gt; does the equivalent as &lt;code&gt;head()&lt;/code&gt; but at the end of the &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt; instead of at the beginning, it is good to let the users know about it.</source>
          <target state="translated">명백한 예는 &lt;code&gt;head()&lt;/code&gt; 및 &lt;code&gt;tail()&lt;/code&gt; 메소드입니다. 로 &lt;code&gt;tail()&lt;/code&gt; 과 동등한 않는 &lt;code&gt;head()&lt;/code&gt; 하지만의 끝에서 &lt;code&gt;Series&lt;/code&gt; 또는 &lt;code&gt;DataFrame&lt;/code&gt; 대신의 시작 부분에서, 사용자가 그것에 대해 알려 좋다.</target>
        </trans-unit>
        <trans-unit id="a696766ba6d7491bfcf0381e2539f39a5dbc5820" translate="yes" xml:space="preserve">
          <source>An obvious one is aggregation via the &lt;a href=&quot;../reference/api/pandas.core.groupby.dataframegroupby.aggregate#pandas.core.groupby.DataFrameGroupBy.aggregate&quot;&gt;&lt;code&gt;aggregate()&lt;/code&gt;&lt;/a&gt; or equivalently &lt;code&gt;agg()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62b228def8925744d823ef2ffef963d52366efd" translate="yes" xml:space="preserve">
          <source>An offset timedelta added to the origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c7d0f96ed3a44693fa95fcadd9ff46eec98368" translate="yes" xml:space="preserve">
          <source>An ordered Categorical preserves the category ordering.</source>
          <target state="translated">정렬 된 범주는 범주 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e058f1934a0a020951f26d4bb40826e28044d225" translate="yes" xml:space="preserve">
          <source>An unordered Categorical will return categories in the order of appearance.</source>
          <target state="translated">순서가없는 범주 형은 범주를 모양 순서대로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1849e019365762d627f3781fc4bcb161d4985b3b" translate="yes" xml:space="preserve">
          <source>An upsample sample of the &lt;code&gt;DataFrame&lt;/code&gt; with replacement: Note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf50ebe3d358d4a0cb7c54e22cac343ba4920b60" translate="yes" xml:space="preserve">
          <source>An upsampled Series or DataFrame with &lt;code&gt;NaN&lt;/code&gt; values filled with their nearest value.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 값이 가장 가까운 값으로 채워진 업 샘플링 된 Series 또는 DataFrame입니다 .</target>
        </trans-unit>
        <trans-unit id="522d724913802d245374eb55c76e079a834e2728" translate="yes" xml:space="preserve">
          <source>An upsampled Series or DataFrame with backward filled NaN values.</source>
          <target state="translated">뒤로 채워진 NaN 값을 가진 업 샘플링 된 Series 또는 DataFrame입니다.</target>
        </trans-unit>
        <trans-unit id="0b9e7068c1dbb32f1132f5aa9937793c25daf246" translate="yes" xml:space="preserve">
          <source>An upsampled Series or DataFrame with missing values filled.</source>
          <target state="translated">누락 된 값이 채워진 업 샘플링 된 Series 또는 DataFrame</target>
        </trans-unit>
        <trans-unit id="c748a4f33b925ab2152a5b47a0a90bfe3acf1e05" translate="yes" xml:space="preserve">
          <source>An upsampled Series.</source>
          <target state="translated">업 샘플링 된 시리즈.</target>
        </trans-unit>
        <trans-unit id="fd590ef748561f10fd881dfd052c3aedf1bcfb18" translate="yes" xml:space="preserve">
          <source>Analogous function for DataFrame.</source>
          <target state="translated">DataFrame과 유사한 기능.</target>
        </trans-unit>
        <trans-unit id="547a3b4f2f0ecef974d0a9bb552ee6f3a31dc474" translate="yes" xml:space="preserve">
          <source>Analogous method for DataFrame.</source>
          <target state="translated">DataFrame과 유사한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="887ab48cf55e9cca52da3c27725e2eda36702966" translate="yes" xml:space="preserve">
          <source>Analogous, but less strict, relying on re.search instead of re.match.</source>
          <target state="translated">re.match 대신 re.search에 의존하는 유사하지만 덜 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="e85497ece22b07c717d81f1822015435311d6ee0" translate="yes" xml:space="preserve">
          <source>Analogous, but stricter, relying on re.match instead of re.search.</source>
          <target state="translated">re.search 대신 re.match에 의존하는 유사하지만 더 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="ec838aa4601a807389f44fb7f65bdd72acaf7034" translate="yes" xml:space="preserve">
          <source>Analogously, &lt;a href=&quot;../reference/api/pandas.dataframe.cov#pandas.DataFrame.cov&quot;&gt;&lt;code&gt;DataFrame.cov()&lt;/code&gt;&lt;/a&gt; to compute pairwise covariances among the series in the DataFrame, also excluding NA/null values.</source>
          <target state="translated">유사하게, &lt;a href=&quot;../reference/api/pandas.dataframe.cov#pandas.DataFrame.cov&quot;&gt; &lt;code&gt;DataFrame.cov()&lt;/code&gt; &lt;/a&gt; 는 NA / null 값을 제외하고 DataFrame의 계열간에 쌍별 공분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f233cc5bad729ac5e35594372ae3552091446193" translate="yes" xml:space="preserve">
          <source>Analogously, all columns in an existing &lt;code&gt;DataFrame&lt;/code&gt; can be batch converted using &lt;a href=&quot;../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype&quot;&gt;&lt;code&gt;DataFrame.astype()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e7fb0526878aaf979ce612466ab216c7ea021c" translate="yes" xml:space="preserve">
          <source>Analyzes both numeric and object series, as well as &lt;code&gt;DataFrame&lt;/code&gt; column sets of mixed data types. The output will vary depending on what is provided. Refer to the notes below for more detail.</source>
          <target state="translated">혼합 데이터 유형의 &lt;code&gt;DataFrame&lt;/code&gt; 열 세트 뿐만 아니라 숫자 및 오브젝트 시리즈를 모두 분석합니다 . 제공되는 내용에 따라 출력이 달라집니다. 자세한 내용은 아래 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3721206edca6d0bf891efcbfd1498e164a56fd21" translate="yes" xml:space="preserve">
          <source>Anchored offset semantics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ad3038577dec0f614176214f91d7903485271f" translate="yes" xml:space="preserve">
          <source>Anchored offsets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a8b1b862835a33c837de70caae292fe1ab7757" translate="yes" xml:space="preserve">
          <source>And also you can create string intervals</source>
          <target state="translated">또한 문자열 간격을 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="626ce01756bed8e7f919ab8dbc6250276ae353e3" translate="yes" xml:space="preserve">
          <source>And crucially the input and output shapes of &lt;code&gt;func&lt;/code&gt; must match. If &lt;code&gt;x&lt;/code&gt; is the input then &lt;code&gt;func(x).shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">그리고 결정적으로 &lt;code&gt;func&lt;/code&gt; 의 입력 및 출력 모양이 일치해야합니다. 경우 &lt;code&gt;x&lt;/code&gt; 다음 입력 &lt;code&gt;func(x).shape == x.shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8df9aa06083eae2dec150020929dac2e6f496afb" translate="yes" xml:space="preserve">
          <source>And now selection works as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c5cc84e004a3bd81ce765ec1f8f0c42e365e49" translate="yes" xml:space="preserve">
          <source>And now with the color determined by a column as well.</source>
          <target state="translated">이제 열에 따라 색상이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d05263930d64ce71f016b75882f2184c070183bb" translate="yes" xml:space="preserve">
          <source>And the dtypes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af088775c515e43d8f23ad06b9582bae5870862" translate="yes" xml:space="preserve">
          <source>And then import the data directly to a &lt;code&gt;DataFrame&lt;/code&gt; by calling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8064ecf537a6e821ad1ea7efc41aa58905083a" translate="yes" xml:space="preserve">
          <source>And then issue the following queries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99154e7cb4d1188b5f8cb786e79b215b3aca2ab2" translate="yes" xml:space="preserve">
          <source>And you can explicitly force columns to be parsed as dates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8bea05e29d34e04e5494ec156767bb1de2b028e" translate="yes" xml:space="preserve">
          <source>And you&amp;rsquo;ll have the satisfaction of seeing your new and improved documentation!</source>
          <target state="translated">그리고 새롭고 개선 된 문서를보고 만족할 것입니다!</target>
        </trans-unit>
        <trans-unit id="74f5701e26bba2500f2b2914d8a67e75c3f5461b" translate="yes" xml:space="preserve">
          <source>Andrews Curves</source>
          <target state="translated">앤드류스 커브</target>
        </trans-unit>
        <trans-unit id="7ef069fc7103eb2d0caa86e898d238c4d0b17c83" translate="yes" xml:space="preserve">
          <source>Andrews curves</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba237f0a79aa5d19454778b16d733f356f729ca4" translate="yes" xml:space="preserve">
          <source>Andrews curves allow one to plot multivariate data as a large number of curves that are created using the attributes of samples as coefficients for Fourier series, see the &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrews_plot&quot;&gt;Wikipedia entry&lt;/a&gt; for more information. By coloring these curves differently for each class it is possible to visualize data clustering. Curves belonging to samples of the same class will usually be closer together and form larger structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d55805f9339ee8baacbf8b6efb171e604e181d9" translate="yes" xml:space="preserve">
          <source>Andrews curves charts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ed6a5ee55288b217480846194be4d815051fd3" translate="yes" xml:space="preserve">
          <source>Andrews curves have the functional form:</source>
          <target state="translated">Andrews 곡선은 다음과 같은 기능적 형태를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e67b6ac8de83b9e7a56a1832f17ebb5f5b37126f" translate="yes" xml:space="preserve">
          <source>Annotate a time-series plot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25391dfd3db598e15c3fea71dae12d7d022c4400" translate="yes" xml:space="preserve">
          <source>Annotate a time-series plot #2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eecb4da37285619eb78112ef2dea0df8cf1a9a1" translate="yes" xml:space="preserve">
          <source>Another &lt;code&gt;DataFrame&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e4cf52e7f0ded798e994e5c852d6c9c54ade37" translate="yes" xml:space="preserve">
          <source>Another advantage to installing Anaconda is that you don&amp;rsquo;t need admin rights to install it. Anaconda can install in the user&amp;rsquo;s home directory, which makes it trivial to delete Anaconda if you decide (just delete that folder).</source>
          <target state="translated">Anaconda 설치의 또 다른 이점은 설치하기 위해 관리자 권한이 필요하지 않다는 것입니다. Anaconda는 사용자의 홈 디렉토리에 설치할 수 있으므로 결정하면 Anaconda를 삭제하는 것이 간단합니다 (해당 폴더 삭제).</target>
        </trans-unit>
        <trans-unit id="5422f9b350b9eef6814666bddd7bac38094d585f" translate="yes" xml:space="preserve">
          <source>Another aggregation example is to compute the number of unique values of each group. This is similar to the &lt;code&gt;value_counts&lt;/code&gt; function, except that it only counts unique values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3fd703384b38d541e5d30bf03acd7bfe2af6a3" translate="yes" xml:space="preserve">
          <source>Another aggregation we can do is calculate the frequency in which the columns and rows occur together a.k.a. &amp;ldquo;cross tabulation&amp;rdquo;. To do this, we can pass &lt;code&gt;size&lt;/code&gt; to the &lt;code&gt;aggfunc&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1e56b8a1d248a4b551860ed017ab54b979f4ce" translate="yes" xml:space="preserve">
          <source>Another common data transform is to replace missing data with the group mean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e187b9988e144e2ed5bc77c15bd2601cfa127b48" translate="yes" xml:space="preserve">
          <source>Another common dialect option is &lt;code&gt;skipinitialspace&lt;/code&gt;, to skip any whitespace after a delimiter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26082fd0dca13f4766b6c73783a141417c879c3a" translate="yes" xml:space="preserve">
          <source>Another common operation is the use of boolean vectors to filter the data. The operators are: &lt;code&gt;|&lt;/code&gt; for &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; for &lt;code&gt;and&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; for &lt;code&gt;not&lt;/code&gt;. These &lt;strong&gt;must&lt;/strong&gt; be grouped by using parentheses, since by default Python will evaluate an expression such as &lt;code&gt;df['A'] &amp;gt; 2 &amp;amp; df['B'] &amp;lt; 3&lt;/code&gt; as &lt;code&gt;df['A'] &amp;gt; (2 &amp;amp; df['B']) &amp;lt; 3&lt;/code&gt;, while the desired evaluation order is &lt;code&gt;(df['A'] &amp;gt; 2) &amp;amp; (df['B'] &amp;lt; 3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1638d3363efdfbe5466eef1db2d2342c31fe3e" translate="yes" xml:space="preserve">
          <source>Another example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb9168ffa746a34166862e29eef223cf6e7fc0d" translate="yes" xml:space="preserve">
          <source>Another example is parameterizing &lt;code&gt;YearEnd&lt;/code&gt; with the specific ending month:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf548e65fe08e2d9efb7d1570d115225047c55b" translate="yes" xml:space="preserve">
          <source>Another example that can be given is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f5725516ab9766afe5f216dacecbb152763c8d" translate="yes" xml:space="preserve">
          <source>Another example using integers for the index</source>
          <target state="translated">인덱스에 정수를 사용하는 또 다른 예</target>
        </trans-unit>
        <trans-unit id="0d2797e7ac958d47d961dafa9ad1fe9d0457edde" translate="yes" xml:space="preserve">
          <source>Another fairly common situation is to have two like-indexed (or similarly indexed) &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt; objects and wanting to &amp;ldquo;patch&amp;rdquo; values in one object from values for matching indices in the other. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fe3c1c43dd19c24179ec0234b139bf85b0926e" translate="yes" xml:space="preserve">
          <source>Another method to draw a box plot.</source>
          <target state="translated">상자 그림을 그리는 또 다른 방법.</target>
        </trans-unit>
        <trans-unit id="b7fb05f974d5e4f1dcdc574339cfabcbb4fee308" translate="yes" xml:space="preserve">
          <source>Another option is passing an &lt;code&gt;ax&lt;/code&gt; argument to &lt;a href=&quot;../reference/api/pandas.series.plot#pandas.Series.plot&quot;&gt;&lt;code&gt;Series.plot()&lt;/code&gt;&lt;/a&gt; to plot on a particular axis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60689527debf465f79166d475eed3a102986f80" translate="yes" xml:space="preserve">
          <source>Another option to join using the key columns is to use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6cbcf719f3b3ea4f2a3b7745ef11cb2d71916c" translate="yes" xml:space="preserve">
          <source>Another option to join using the key columns is to use the &lt;code&gt;on&lt;/code&gt; parameter. DataFrame.join always uses &lt;code&gt;other&lt;/code&gt;&amp;rsquo;s index but we can use any column in &lt;code&gt;df&lt;/code&gt;. This method preserves the original DataFrame&amp;rsquo;s index in the result.</source>
          <target state="translated">키 컬럼을 사용하여 결합하는 다른 옵션은 &lt;code&gt;on&lt;/code&gt; 매개 변수 를 사용하는 것 입니다 . DataFrame.join은 항상 &lt;code&gt;other&lt;/code&gt; 인덱스를 사용하지만 &lt;code&gt;df&lt;/code&gt; 의 모든 열을 사용할 수 있습니다 . 이 메서드는 결과에서 원래 DataFrame의 인덱스를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="de853957b004225a9e7c1703b6fa1c1a19d32eca" translate="yes" xml:space="preserve">
          <source>Another reason you might need to update your pull request is to solve conflicts with changes that have been merged into the master branch since you opened your pull request.</source>
          <target state="translated">풀 요청을 업데이트해야하는 또 다른 이유는 풀 요청을 연 후 마스터 브랜치에 병합 된 변경 사항과의 충돌을 해결하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a612150532c7fe6c342298ec87a6f999d68d4dd" translate="yes" xml:space="preserve">
          <source>Another simple aggregation example is to compute the size of each group. This is included in GroupBy as the &lt;code&gt;size&lt;/code&gt; method. It returns a Series whose index are the group names and whose values are the sizes of each group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8277eea9ba2a8fe2d43bdb517499c36e3429110" translate="yes" xml:space="preserve">
          <source>Another use case is interpolation at &lt;em&gt;new&lt;/em&gt; values. Suppose you have 100 observations from some distribution. And let&amp;rsquo;s suppose that you&amp;rsquo;re particularly interested in what&amp;rsquo;s happening around the middle. You can mix pandas&amp;rsquo; &lt;code&gt;reindex&lt;/code&gt; and &lt;code&gt;interpolate&lt;/code&gt; methods to interpolate at the new values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793e6f6278c39bc84b59b1fcf436f7d5e22f1873" translate="yes" xml:space="preserve">
          <source>Another useful feature is the ability to pass Series methods to carry out some Series operation on each column or row:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a29c570a68be05f73d6d67e782885abc906516" translate="yes" xml:space="preserve">
          <source>Another useful operation is filtering out elements that belong to groups with only a couple members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601a59d48b50313e6a0246d5a8b5d4cb039f22aa" translate="yes" xml:space="preserve">
          <source>Another way to transform is to use the &lt;a href=&quot;../reference/api/pandas.wide_to_long#pandas.wide_to_long&quot;&gt;&lt;code&gt;wide_to_long()&lt;/code&gt;&lt;/a&gt; panel data convenience function. It is less flexible than &lt;a href=&quot;../reference/api/pandas.melt#pandas.melt&quot;&gt;&lt;code&gt;melt()&lt;/code&gt;&lt;/a&gt;, but more user-friendly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace06966574dd2d3caf23eb77499be1418cc173c" translate="yes" xml:space="preserve">
          <source>Any &amp;ldquo;non-equality&amp;rdquo; comparisons of categorical data with a &lt;code&gt;Series&lt;/code&gt;, &lt;code&gt;np.array&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; or categorical data with different categories or ordering will raise a &lt;code&gt;TypeError&lt;/code&gt; because custom categories ordering could be interpreted in two ways: one with taking into account the ordering and one without.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761b8ef2d59333534847568e8f26ec4f38bfe4e6" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;Series&lt;/code&gt; passed will have their name attributes used unless row or column names for the cross-tabulation are specified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e120459c22f1dbb403235c4780f83dad81ca41f0" translate="yes" xml:space="preserve">
          <source>Any NA values will be NA in the result. Out of bounds values will be NA in the resulting Series or Categorical object.</source>
          <target state="translated">모든 NA 값은 결과에서 NA가됩니다. 범위를 벗어난 값은 결과 Series 또는 Categorical 형 개체에서 NA가됩니다.</target>
        </trans-unit>
        <trans-unit id="cc4653e0dec663c993e1b8bf2c31902d8dc2b037" translate="yes" xml:space="preserve">
          <source>Any Series passed will have their name attributes used unless row or column names for the cross-tabulation are specified.</source>
          <target state="translated">교차 분석에 행 또는 열 이름을 지정하지 않으면 전달 된 모든 계열의 이름 속성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5bd284889323e281cb4ecaaf6bfb79897b6487e" translate="yes" xml:space="preserve">
          <source>Any additional keyword arguments are passed through to &lt;code&gt;self.template.render&lt;/code&gt;. This is useful when you need to provide additional variables for a custom template.</source>
          <target state="translated">추가 키워드 인수는 &lt;code&gt;self.template.render&lt;/code&gt; 로 전달됩니다 . 사용자 지정 템플릿에 추가 변수를 제공해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4b58be4313ae8aa3d58d0729ff39b777f4e27fe6" translate="yes" xml:space="preserve">
          <source>Any additional kwargs are passed to pyarrow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89fec0f90fcdc7e46b4461a004174e6768d6604" translate="yes" xml:space="preserve">
          <source>Any additional kwargs are passed to the engine.</source>
          <target state="translated">추가 크워 그는 엔진으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="63a7c5909c41c22e6a438441ca3c0a3ea341dcd3" translate="yes" xml:space="preserve">
          <source>Any datetime values with time zone information parsed via the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ea0cb81de2fbda6f191b29e37d3346f0da2baa" translate="yes" xml:space="preserve">
          <source>Any datetime values with time zone information parsed via the &lt;code&gt;parse_dates&lt;/code&gt; parameter will be converted to UTC.</source>
          <target state="translated">&lt;code&gt;parse_dates&lt;/code&gt; 매개 변수 를 통해 구문 분석 된 시간대 정보가있는 모든 날짜 시간 값은 UTC로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="af00ae2cb03d25dd2517c645ac88a8875aadfaed" translate="yes" xml:space="preserve">
          <source>Any datetime values with time zone information will be converted to UTC.</source>
          <target state="translated">시간대 정보가있는 날짜 / 시간 값은 UTC로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea43faeb9100a22df9d3b18d94c6c6c5b6eb2404" translate="yes" xml:space="preserve">
          <source>Any expression that is a valid &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; expression is also a valid &lt;a href=&quot;../reference/api/pandas.dataframe.eval#pandas.DataFrame.eval&quot;&gt;&lt;code&gt;DataFrame.eval()&lt;/code&gt;&lt;/a&gt; expression, with the added benefit that you don&amp;rsquo;t have to prefix the name of the &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; to the column(s) you&amp;rsquo;re interested in evaluating.</source>
          <target state="translated">유효한 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 식인 모든 식도 유효한 DataFrame.eval () &lt;a href=&quot;../reference/api/pandas.dataframe.eval#pandas.DataFrame.eval&quot;&gt; &lt;code&gt;DataFrame.eval()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 이름 앞에 원하는 열을 추가 할 필요가 없다는 이점이 있습니다. 평가에서.</target>
        </trans-unit>
        <trans-unit id="1e663ab61febb52693bcac9468d4d94b81af4a99" translate="yes" xml:space="preserve">
          <source>Any function available via &lt;a href=&quot;groupby#groupby-dispatch&quot;&gt;dispatching&lt;/a&gt; is available as a method of the returned object, including &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;std&lt;/code&gt;, &lt;code&gt;sem&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;median&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;ohlc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5964cd2d7c79472697fe32851fce192640c6dbff" translate="yes" xml:space="preserve">
          <source>Any input passed containing Categorical data will have &lt;strong&gt;all&lt;/strong&gt; of its categories included in the cross-tabulation, even if the actual data does not contain any instances of a particular category.</source>
          <target state="translated">범주 형 데이터를 포함하여 전달 된 모든 입력 에는 실제 데이터에 특정 범주의 인스턴스가 포함되어 있지 않더라도 &lt;strong&gt;모든&lt;/strong&gt; 범주가 교차 분석에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ce16c259e759f906f8065019dbf4a811189652b6" translate="yes" xml:space="preserve">
          <source>Any nanosecond resolution will be lost.</source>
          <target state="translated">모든 나노초 해상도가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="88b3008b4cbde9632f08d1bcac656be7c8544ebc" translate="yes" xml:space="preserve">
          <source>Any non-pandas PyTables objects that are not a group will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdcac39271359c12810d669a283ca70d643d2e4" translate="yes" xml:space="preserve">
          <source>Any object column, also if it contains numerical values such as &lt;code&gt;Decimal&lt;/code&gt; objects, is considered as a &amp;ldquo;nuisance&amp;rdquo; columns. They are excluded from aggregate functions automatically in groupby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0fbb4621f7288331d98455b00a58d6031b42b4" translate="yes" xml:space="preserve">
          <source>Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the &lt;code&gt;split&lt;/code&gt; option as it uses ordered containers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ceb80800eb57e57ca5b1b17e4f4beb32b44748" translate="yes" xml:space="preserve">
          <source>Any other form of observational / statistical data sets. The data actually need not be labeled at all to be placed into a pandas data structure</source>
          <target state="translated">다른 형태의 관측 / 통계 데이터 세트 데이터를 판다 데이터 구조에 배치하기 위해 실제로 레이블을 지정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf00b212bf8aed69a4cf5a5c69e5692c7a383077" translate="yes" xml:space="preserve">
          <source>Any other module used in the examples must be explicitly imported, one per line (as recommended in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008#imports&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 8#imports&lt;/strong&gt;&lt;/a&gt;) and avoiding aliases. Avoid excessive imports, but if needed, imports from the standard library go first, followed by third-party libraries (like matplotlib).</source>
          <target state="translated">예제에 사용 된 다른 모든 모듈은 한 줄에 하나씩 명시 적으로 가져 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008#imports&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;오고 (PEP 8 # imports&lt;/strong&gt;&lt;/a&gt; 에서 권장 &lt;strong&gt;되는대로&lt;/strong&gt; ) 별칭을 피해야합니다. 과도한 가져 오기를 피하지만 필요한 경우 표준 라이브러리에서 가져 오기가 먼저 수행되고 그 다음에 타사 라이브러리 (예 : matplotlib)가 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3632ffd552cc1d333862f7fa1372c18be2ee605a" translate="yes" xml:space="preserve">
          <source>Any single or multiple element data structure, or list-like object.</source>
          <target state="translated">단일 또는 다중 요소 데이터 구조 또는 목록과 유사한 개체</target>
        </trans-unit>
        <trans-unit id="6ba937ed25eac91be6494338327246df991da190" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e954390c5f626600a8327f64c43b3441dffdc0fc" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;a href=&quot;file://localhost/path/to/table.csv&quot;&gt;file://localhost/path/to/table.csv&lt;/a&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;a href=&quot;file://localhost/path/to/table.csv&quot;&gt;file : //localhost/path/to/table.csv 일&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4548d91026734d1a3e360f967c361b2d835711d" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.csv&lt;/code&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;code&gt;file://localhost/path/to/table.csv&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3680aacea1c49425f4ba9338e259c5d070cb7046" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.dta&lt;/code&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;code&gt;file://localhost/path/to/table.dta&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9c7d7846c6e8605dcce2d8416166539c4565e50" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.feather&lt;/code&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;code&gt;file://localhost/path/to/table.feather&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3fb17dd2ac024ef5d7baf9a3e21d8f07096da15" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.h5&lt;/code&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;code&gt;file://localhost/path/to/table.h5&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b41054070a92e52620dfa7c505a3f87b483b55f" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.json&lt;/code&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;code&gt;file://localhost/path/to/table.json&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="813636175c3f3241b9e8c73750a187ce6a633ac3" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.orc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a1068aa62d158902d0259159b4c681158e327c" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.parquet&lt;/code&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;code&gt;file://localhost/path/to/table.parquet&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26bce3851691b4e1bdd4bed182b8228bda9df4d8" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.sas&lt;/code&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;code&gt;file://localhost/path/to/table.sas&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a4dbceac8f3bec865509b44937581123348753b" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.xlsx&lt;/code&gt;.</source>
          <target state="translated">유효한 문자열 경로가 허용됩니다. 문자열은 URL 일 수 있습니다. 유효한 URL 체계에는 http, ftp, s3 및 file이 포함됩니다. 파일 URL의 경우 호스트가 필요합니다. 로컬 파일은 &lt;code&gt;file://localhost/path/to/table.xlsx&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdd193f231be7ad0f1bb5337c5a29fa0d9772e04" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: &lt;a href=&quot;file://localhost/path/to/table.csv&quot;&gt;file://localhost/path/to/table.csv&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00366c6fc9a41635a5c8f6337e9046154e5b33dd" translate="yes" xml:space="preserve">
          <source>Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: &lt;code&gt;file://localhost/path/to/table.parquet&lt;/code&gt;. A file URL can also be a path to a directory that contains multiple partitioned parquet files. Both pyarrow and fastparquet support paths to directories as well as file URLs. A directory path could be: &lt;code&gt;file://localhost/path/to/tables&lt;/code&gt; or &lt;code&gt;s3://bucket/partition_dir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d34003e83d18cd0d53ef5b805c1eec2875fabf" translate="yes" xml:space="preserve">
          <source>Any value which falls outside all bins will be assigned a &lt;code&gt;NaN&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f51d463360f09f27480e4beb0e1a233b2405f0" translate="yes" xml:space="preserve">
          <source>Anywhere in the above &lt;code&gt;replace&lt;/code&gt; examples that you see a regular expression a compiled regular expression is valid as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8747f05b9c090689834e5b77ca26e52ec7fc5c" translate="yes" xml:space="preserve">
          <source>Apart from &lt;a href=&quot;../reference/api/pandas.series.min#pandas.Series.min&quot;&gt;&lt;code&gt;Series.min()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.series.max#pandas.Series.max&quot;&gt;&lt;code&gt;Series.max()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.mode#pandas.Series.mode&quot;&gt;&lt;code&gt;Series.mode()&lt;/code&gt;&lt;/a&gt;, the following operations are possible with categorical data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94d227677d6c608740abe99f043bc116a355178" translate="yes" xml:space="preserve">
          <source>Append a collection of Index options together.</source>
          <target state="translated">인덱스 옵션 모음을 함께 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cd01c0378f8b017bde9e68d3cdc3d5ad6cccb171" translate="yes" xml:space="preserve">
          <source>Append rows of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ae934ab327be0ffca6e997a261eff151fab1bb" translate="yes" xml:space="preserve">
          <source>Append rows of &lt;code&gt;other&lt;/code&gt; to the end of caller, returning a new object.</source>
          <target state="translated">호출자 끝에 &lt;code&gt;other&lt;/code&gt; 의 행을 추가 하여 새 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2429169c5b6bb3564a6fe243957a7d5368028bde" translate="yes" xml:space="preserve">
          <source>Append the input data to the existing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89016439f19acb30e6533070052e850ed50424b7" translate="yes" xml:space="preserve">
          <source>Append to Table in file.</source>
          <target state="translated">파일의 테이블에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e46f7c7ab05c305ed0b5626f1d3ac5dd0983902d" translate="yes" xml:space="preserve">
          <source>Append to Table in file. Node must already exist and be Table format.</source>
          <target state="translated">파일의 테이블에 추가하십시오. 노드가 이미 존재하고 테이블 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3501f4188136b9d085ce3a53d966aa6af4477b9e" translate="yes" xml:space="preserve">
          <source>Append two dataframes with overlapping index (emulate R rbind)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055084170214fcf77da5f3b5d798735046e029e5" translate="yes" xml:space="preserve">
          <source>Appending categories can be done by using the &lt;code&gt;add_categories()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8f2be7b7b368b9f0b3f8bf148b0cf0b16e4399" translate="yes" xml:space="preserve">
          <source>Appending new categories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d524f23186eee2587b4407d925996e831b953c" translate="yes" xml:space="preserve">
          <source>Appending rows to a DataFrame</source>
          <target state="translated">DataFrame에 행 추가</target>
        </trans-unit>
        <trans-unit id="dd4a773d9c99bbb0cd8cdd2ee9d1775422f2f11f" translate="yes" xml:space="preserve">
          <source>Appending to a store, while creating a unique index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0778fd8226275ca77d069fcb393563333d98ad2" translate="yes" xml:space="preserve">
          <source>Applied when &lt;code&gt;cond&lt;/code&gt; returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70eff610bf93a16ebd8f22247d1faff4a91c226" translate="yes" xml:space="preserve">
          <source>Applied when &lt;code&gt;cond&lt;/code&gt; returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfea419c3b4e8b02ee586e70a28bf846e44cdda4" translate="yes" xml:space="preserve">
          <source>Apply</source>
          <target state="translated">Apply</target>
        </trans-unit>
        <trans-unit id="9b6dbedb0e02feab044cae1916b238a63f4b6ff9" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;func(self, *args, **kwargs)&lt;/code&gt;, and return the result.</source>
          <target state="translated">적용 &lt;code&gt;func(self, *args, **kwargs)&lt;/code&gt; , 그 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a756249d2a30c9dcd0e53cb5e4774cfa97cd2969" translate="yes" xml:space="preserve">
          <source>Apply a function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94497a0a4ca7a575b2592eda0a7d365fe2cdb86c" translate="yes" xml:space="preserve">
          <source>Apply a function &lt;code&gt;func&lt;/code&gt; with arguments to this GroupBy object and return the function&amp;rsquo;s result.</source>
          <target state="translated">이 GroupBy 객체에 인수가 있는 함수 &lt;code&gt;func&lt;/code&gt; 를 적용 하고 함수의 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5143e9d4258b60419a7c7e5ffbf3fc7ca5ef63d1" translate="yes" xml:space="preserve">
          <source>Apply a function &lt;code&gt;func&lt;/code&gt; with arguments to this Resampler object and return the function&amp;rsquo;s result.</source>
          <target state="translated">이 Resampler 객체에 인수가 있는 함수 &lt;code&gt;func&lt;/code&gt; 를 적용하고 함수 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2300bda8dfb36de22262ab09601b8c2095beace7" translate="yes" xml:space="preserve">
          <source>Apply a function along an axis of the DataFrame.</source>
          <target state="translated">DataFrame의 축을 따라 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="bff7ddcf0f3f5f0835d4bd50c78c0e63b8bc94db" translate="yes" xml:space="preserve">
          <source>Apply a function along input axis of DataFrame.</source>
          <target state="translated">DataFrame의 입력 축을 따라 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c3c648ff2f278f5dd00aebf40bbd60c48c34da9" translate="yes" xml:space="preserve">
          <source>Apply a function column-wise, row-wise, or table-wise, updating the HTML representation with the result.</source>
          <target state="translated">HTML 표현을 결과로 업데이트하여 열, 행 또는 테이블 방식으로 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="5545374adb1207e36072c9374a8663b76e0a0ad9" translate="yes" xml:space="preserve">
          <source>Apply a function column-wise, row-wise, or table-wise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47a1d2e3202baba633d75d32f2bd208fc9a2251" translate="yes" xml:space="preserve">
          <source>Apply a function elementwise on a whole DataFrame.</source>
          <target state="translated">전체 DataFrame에 요소별로 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="1dba89c279b194e9feebdd7a247e60645e906873" translate="yes" xml:space="preserve">
          <source>Apply a function elementwise, updating the HTML representation with a style which is selected in accordance with the return value of a function.</source>
          <target state="translated">함수의 반환 값에 따라 선택된 스타일로 HTML 표현을 업데이트하여 요소별로 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="d19bce463ae6d687c3211a328de06346c0198ddd" translate="yes" xml:space="preserve">
          <source>Apply a function elementwise, updating the HTML representation with the result.</source>
          <target state="translated">HTML 표현을 결과로 업데이트하여 요소별로 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="0c762bd1f744460a2567e125fdc50f3bec2a54ca" translate="yes" xml:space="preserve">
          <source>Apply a function elementwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56808cf04a4b5d8c8a2a7723a37a700858224edb" translate="yes" xml:space="preserve">
          <source>Apply a function groupby to a Series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c4bba1dcb3f9de89516b647ace6d996d3dbaaf" translate="yes" xml:space="preserve">
          <source>Apply a function groupby to each row or column of a DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fc9721d30f4b68442c02bc34a966d1181acedf" translate="yes" xml:space="preserve">
          <source>Apply a function row-/column-wise.</source>
          <target state="translated">행 / 열 단위로 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2cfb8d5e20b73670b865ee96e6004e3d1273218" translate="yes" xml:space="preserve">
          <source>Apply a function row-wise, column-wise, or table-wise to modify the dataframe&amp;rsquo;s styling.</source>
          <target state="translated">데이터 프레임의 스타일을 수정하려면 함수를 행 방향, 열 방향 또는 테이블 방향으로 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="8590e597670d8ae719ff88bcc2427073dc1b4754" translate="yes" xml:space="preserve">
          <source>Apply a function to a Dataframe elementwise.</source>
          <target state="translated">데이터 프레임에 함수를 요소 단위로 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="e513e0471347ab4f6e2d08cba5597f1ea52478ae" translate="yes" xml:space="preserve">
          <source>Apply a function to a Series.</source>
          <target state="translated">시리즈에 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="3334bbea8770ad0831f1befb79be3cd156ba64bb" translate="yes" xml:space="preserve">
          <source>Apply a function to each row or column of a DataFrame.</source>
          <target state="translated">DataFrame의 각 행 또는 열에 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="77115550b5fd17c93f359d31ef6137b34d9d7cf3" translate="yes" xml:space="preserve">
          <source>Apply a function with arguments to a dataframe.</source>
          <target state="translated">데이터 프레임에 인수가있는 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="09b993fe836e3dd31282b3bd112d72ca026c4a15" translate="yes" xml:space="preserve">
          <source>Apply a function with arguments to a series.</source>
          <target state="translated">인수가있는 함수를 시리즈에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c9a51106ddced340df3f5843f71f58f9abd45f3" translate="yes" xml:space="preserve">
          <source>Apply a key function before sorting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa16d38d8218f1b1baf532dd1d351ef49f3f132" translate="yes" xml:space="preserve">
          <source>Apply a mapping correspondence on a &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 에 매핑 대응을 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="6c06b035a5935e9638f3dfb494ff727245c715bc" translate="yes" xml:space="preserve">
          <source>Apply a mapping correspondence on an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; 에&lt;/a&gt; 대응하는 매핑을 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="d01583cb8d2903e7fe2cd5193163018ea81e7e4c" translate="yes" xml:space="preserve">
          <source>Apply aggregate function to the GroupBy object.</source>
          <target state="translated">GroupBy 오브젝트에 집계 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="8ea3b2c3bc54183950189348a03fb84e06a7388c" translate="yes" xml:space="preserve">
          <source>Apply an arbitrary function to each expanding window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43b551c763d51d33cb1a4a45d132f0c9a3c811b" translate="yes" xml:space="preserve">
          <source>Apply an arbitrary function to each rolling window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5255708f120370968ac378ac76421f03e0d4da4" translate="yes" xml:space="preserve">
          <source>Apply func(self, *args, **kwargs).</source>
          <target state="translated">func (self, * args, ** kwargs)를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="73b1bf9047c0fbd7a438063a2360b7174bc32b5f" translate="yes" xml:space="preserve">
          <source>Apply function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975a062726ebd91c737ffbd4f9aff859e8879d00" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;func&lt;/code&gt; group-wise and combine the results together.</source>
          <target state="translated">함수 &lt;code&gt;func&lt;/code&gt; 를 그룹별로 적용 하고 결과를 함께 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="98b81f8e4ab1a47ad56803e26276ee21c2eb53ec" translate="yes" xml:space="preserve">
          <source>Apply function column-by-column to the GroupBy object.</source>
          <target state="translated">열별로 함수를 GroupBy 오브젝트에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="8d0ef4a774c2fd2bd037d0603074fe41267f7dfd" translate="yes" xml:space="preserve">
          <source>Apply function func group-wise and combine the results together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f176ab21606a6853ebdfa6d4ba690888f2ad592d" translate="yes" xml:space="preserve">
          <source>Apply function to each group instead of to the full GroupBy object.</source>
          <target state="translated">전체 GroupBy 오브젝트 대신 각 그룹에 기능을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="86f732af265db12b2eb102d6e6f9778389e9596e" translate="yes" xml:space="preserve">
          <source>Apply function to each group instead of to the full Resampler object.</source>
          <target state="translated">전체 리 샘플러 개체 대신 각 그룹에 기능을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="8ac449be0da05ed96379c1260bef7cae0d7fcaef" translate="yes" xml:space="preserve">
          <source>Apply function to the full GroupBy object instead of to each group.</source>
          <target state="translated">각 그룹 대신 전체 GroupBy 개체에 기능을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2dcac8637bce624d3a775a32300ec0de72a3d27" translate="yes" xml:space="preserve">
          <source>Apply more complex functions on a &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 에 더 복잡한 함수를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed84febd003c363f3e308dcc4d8477d2917ac1cd" translate="yes" xml:space="preserve">
          <source>Apply the &lt;code&gt;put&lt;/code&gt; method to its &lt;code&gt;values&lt;/code&gt; attribute if it has one.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 메소드가있는 경우 해당 &lt;code&gt;values&lt;/code&gt; 속성에 put 메소드를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="19b7bebe80dac33f5c083223006251e29f821169" translate="yes" xml:space="preserve">
          <source>Apply the key function to the values before sorting. This is similar to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a8fca6486fa595be085c18782acb08805b6607" translate="yes" xml:space="preserve">
          <source>Apply the specified dropna operation before counting which row is the nth row. Needs to be None, &amp;lsquo;any&amp;rsquo; or &amp;lsquo;all&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638c6d2a7587d8005ada60281c53477503956b39" translate="yes" xml:space="preserve">
          <source>Apply to different items in a group</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c4ae9633b374fe07ad68b5b15991c9ca593c74" translate="yes" xml:space="preserve">
          <source>Apply to each column (&lt;code&gt;axis=0&lt;/code&gt; or &lt;code&gt;'index'&lt;/code&gt;), to each row (&lt;code&gt;axis=1&lt;/code&gt; or &lt;code&gt;'columns'&lt;/code&gt;), or to the entire DataFrame at once with &lt;code&gt;axis=None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1f42a93170155651d27b44d07a7be5af4b1a70" translate="yes" xml:space="preserve">
          <source>Apply to each column (&lt;code&gt;axis=0&lt;/code&gt; or &lt;code&gt;'index'&lt;/code&gt;), to each row (&lt;code&gt;axis=1&lt;/code&gt; or &lt;code&gt;'columns'&lt;/code&gt;). Only used if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebefbbfcf57bbe83f0efc38d25cd9216a11ca34" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;BusinessHour.rollforward&lt;/code&gt; and &lt;code&gt;rollback&lt;/code&gt; to out of business hours results in the next business hour start or previous day&amp;rsquo;s end. Different from other offsets, &lt;code&gt;BusinessHour.rollforward&lt;/code&gt; may output different results from &lt;code&gt;apply&lt;/code&gt; by definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0841b3b37339b4be975df62f1184e1804028fd17" translate="yes" xml:space="preserve">
          <source>Applying different functions to DataFrame columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc8689c03474f05527e52c05baf7bcf96feb9a4" translate="yes" xml:space="preserve">
          <source>Applying elementwise functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37208e93f5dc27f9fc49dcc3c1491328d95af6a7" translate="yes" xml:space="preserve">
          <source>Applying functions to the data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f0b4738dc0459774c0beba3e8632ec8b5e1f7a" translate="yes" xml:space="preserve">
          <source>Applying multiple functions at once</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ebb32e0401490911a17ef2f8171e457ea4cd24" translate="yes" xml:space="preserve">
          <source>Arbitrary functions can be applied along the axes of a DataFrame using the &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; method, which, like the descriptive statistics methods, takes an optional &lt;code&gt;axis&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b90247298470303ce02272df923dc51603af1da" translate="yes" xml:space="preserve">
          <source>Arbitrary intervals can be represented as &lt;a href=&quot;api/pandas.interval#pandas.Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">임의의 간격은 &lt;a href=&quot;api/pandas.interval#pandas.Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; 개체 로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9136336b08be2ef8400d733db679b54eba6a1979" translate="yes" xml:space="preserve">
          <source>Arbitrary matrix data (homogeneously typed or heterogeneous) with row and column labels</source>
          <target state="translated">행 및 열 레이블이있는 임의의 행렬 데이터 (동종 유형 또는 이종)</target>
        </trans-unit>
        <trans-unit id="2745debaa64a20eedb49d9f14a0b807c87aa2d2a" translate="yes" xml:space="preserve">
          <source>Area</source>
          <target state="translated">Area</target>
        </trans-unit>
        <trans-unit id="3fe7d4b8402748ce4ead36ad9f491f45caf78b77" translate="yes" xml:space="preserve">
          <source>Area (cm^2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9271e9b58089fc598b037af141d3c853d91410d0" translate="yes" xml:space="preserve">
          <source>Area plot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8df98ea0a1a2b1cc7ea9fc6fe7f2ef81f17cdd" translate="yes" xml:space="preserve">
          <source>Area plot, or array of area plots if subplots is True.</source>
          <target state="translated">하위 플롯이 True 인 경우 영역 플롯 또는 영역 플롯의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="085dff8849960bf8f4f6b108e7bc653f8ecb6301" translate="yes" xml:space="preserve">
          <source>Area plots are stacked by default. Set to False to create a unstacked plot.</source>
          <target state="translated">면적 도표는 기본적으로 누적됩니다. 스택되지 않은 플롯을 만들려면 False로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9d19efa680eea3f3d4c11af936730565283f52fc" translate="yes" xml:space="preserve">
          <source>Area plots are stacked by default. To produce an unstacked plot, pass &lt;code&gt;stacked=False&lt;/code&gt;:</source>
          <target state="translated">면적 도표는 기본적으로 누적됩니다. 스택되지 않은 플롯을 생성하려면 &lt;code&gt;stacked=False&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ce062b6b439a641079f6aa78d1ebdc9f858f9f1" translate="yes" xml:space="preserve">
          <source>Argument &amp;lsquo;first&amp;rsquo; puts NaNs at the beginning, &amp;lsquo;last&amp;rsquo; puts NaNs at the end.</source>
          <target state="translated">인수 'first'는 NaN을 처음에, 'last'는 NaN을 끝에 놓습니다.</target>
        </trans-unit>
        <trans-unit id="1d7b7e7f81a20195a07a20cf7c92a2870acf2ccf" translate="yes" xml:space="preserve">
          <source>Argument to be converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7ec3385fe5b71b7b0948792155501c520c6606" translate="yes" xml:space="preserve">
          <source>Arguments and keyword arguments to be passed into func.</source>
          <target state="translated">func에 전달할 인수 및 키워드 인수</target>
        </trans-unit>
        <trans-unit id="c1d55cd20685e74a62915468a85e839eca4e41e3" translate="yes" xml:space="preserve">
          <source>Arguments passed to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fece9ebb467e36ae935eb7f9713ac9a4f47e841" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;func&lt;/code&gt; 에 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="74ab9b9b1ea4b2f27c0e988571bd9f7d90fe08a2" translate="yes" xml:space="preserve">
          <source>Arithmetic median of values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cf61da9c55f002d8350208d7a4be6efc2b4bf7" translate="yes" xml:space="preserve">
          <source>Arithmetic operations except for the left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;) and right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) operators, e.g., &lt;code&gt;df + 2 * pi / s ** 4 % 42 - the_golden_ratio&lt;/code&gt;</source>
          <target state="translated">왼쪽 시프트 ( &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ) 및 오른쪽 시프트 ( &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ) 연산자를 제외한 산술 연산 ( 예 : &lt;code&gt;df + 2 * pi / s ** 4 % 42 - the_golden_ratio&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="ee3ec50dc96a5f33e9baecc974b38ecc4a7e1f62" translate="yes" xml:space="preserve">
          <source>Array Class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238a5476b2b099dbf0d0f2fd0cf448d18972ec8a" translate="yes" xml:space="preserve">
          <source>Array Type</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="8f816a1bf75bc1f0e0c9343ec7dea6a99739fdc0" translate="yes" xml:space="preserve">
          <source>Array of 1D containing data with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ee63133fe93106d055fbf2b3c6b7f07d4b60c5" translate="yes" xml:space="preserve">
          <source>Array of 1D containing data with &lt;code&gt;datetime.timedelta&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;datetime.timedelta&lt;/code&gt; 유형의 데이터를 포함하는 1D 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="97f184768c169c289382d690a02f180ef372a498" translate="yes" xml:space="preserve">
          <source>Array of boolean (True/False) data with missing values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f91c450c43c0f85e2c3631ce43a8ff7eea347f" translate="yes" xml:space="preserve">
          <source>Array of booleans denoting where values in the original data are not NA.</source>
          <target state="translated">원래 데이터의 값이 NA가 아닌 위치를 나타내는 부울 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2914ff2a577fc90dfcce0c3436118d9930be510c" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;self&lt;/code&gt;. If NaN values are contained, NaN values are placed at the end.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 를 정렬하는 인덱스 배열 . NaN 값이 포함 된 경우 NaN 값이 끝에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="23c42fd58b9671c6cfb85ee65ff8c21c777b277c" translate="yes" xml:space="preserve">
          <source>Array of insertion points with the same shape as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d19e541771bdeca8f12189b199116e8c7fc52ee" translate="yes" xml:space="preserve">
          <source>Array of insertion points with the same shape as &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 와 모양이 같은 삽입 점 배열 .</target>
        </trans-unit>
        <trans-unit id="16d602ccc2c74f67094dbd18d07b323b210f86d4" translate="yes" xml:space="preserve">
          <source>Array of integer (optional missing) values.</source>
          <target state="translated">정수 (선택적 누락) 값의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="942a9c2dde1bb5b33c155be51bf12da3f140ad4f" translate="yes" xml:space="preserve">
          <source>Array of tuples</source>
          <target state="translated">튜플의 배열</target>
        </trans-unit>
        <trans-unit id="11bbb09fda8f5c46d25f90c6287f9f7ea1cd3445" translate="yes" xml:space="preserve">
          <source>Array of tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dedfdb628dade196c5ddb340bb8c452e1c4bca0" translate="yes" xml:space="preserve">
          <source>Array of values to aggregate according to the factors. Requires</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9998edca027b5a55687972ba225c84eec75d6d8d" translate="yes" xml:space="preserve">
          <source>Array of values to aggregate according to the factors. Requires &lt;code&gt;aggfunc&lt;/code&gt; be specified.</source>
          <target state="translated">요인에 따라 집계 할 값의 배열입니다. 필요 &lt;code&gt;aggfunc&lt;/code&gt; 지정.</target>
        </trans-unit>
        <trans-unit id="4994f8305c8ede2a4fbbef9d44d5fdff597cc221" translate="yes" xml:space="preserve">
          <source>Array or Index</source>
          <target state="translated">배열 또는 색인</target>
        </trans-unit>
        <trans-unit id="23e3b01214e4ea46c8073e7bdc0f1cac5885fd0f" translate="yes" xml:space="preserve">
          <source>Array scalar view of the timedelta in nanoseconds.</source>
          <target state="translated">나노초 단위의 타임 델타의 배열 스칼라 뷰.</target>
        </trans-unit>
        <trans-unit id="665e2045baa91524bccba85eff2de47df0ac5839" translate="yes" xml:space="preserve">
          <source>Array to compare to this Array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23767dc7557f5945cbb8ba4d30fca848cfd29d35" translate="yes" xml:space="preserve">
          <source>Array type for storing data that come from a fixed set of values.</source>
          <target state="translated">고정 된 값 집합에서 가져온 데이터를 저장하기위한 배열 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a42a6e7ac57209c5e1202eb4dc0c09c59154dc55" translate="yes" xml:space="preserve">
          <source>Array view compatibility.</source>
          <target state="translated">어레이 뷰 호환성.</target>
        </trans-unit>
        <trans-unit id="009502c447ec7d96528d2a280ce25c93db16dfcc" translate="yes" xml:space="preserve">
          <source>Array-like containing Interval objects from which to build the IntervalArray.</source>
          <target state="translated">IntervalArray를 빌드 할 Interval 오브젝트를 포함하는 배열과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="132b728c54772094b9970598280c64f833458c4c" translate="yes" xml:space="preserve">
          <source>Array-like containing Interval objects from which to build the IntervalIndex.</source>
          <target state="translated">IntervalIndex를 빌드 할 Interval 오브젝트를 포함하는 배열과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="c67c3cba1438a75ab4caaa8ea41aa48a5268e770" translate="yes" xml:space="preserve">
          <source>Array-like to check.</source>
          <target state="translated">배열과 같은 확인.</target>
        </trans-unit>
        <trans-unit id="e16351d17e8649d8f461b8778533016da6c36375" translate="yes" xml:space="preserve">
          <source>Array/Index converted to the specified time zone.</source>
          <target state="translated">지정된 시간대로 변환 된 배열 / 인덱스</target>
        </trans-unit>
        <trans-unit id="939b23db2d54a7a0d2e5d70a0277084f0eb7a9ed" translate="yes" xml:space="preserve">
          <source>As PEP-257 is quite open, and some other standards exist on top of it. In the case of pandas, the numpy docstring convention is followed. The conventions is explained in this document:</source>
          <target state="translated">PEP-257은 상당히 개방되어 있으며 그 위에 다른 표준이 있습니다. 팬더의 경우 numpy docstring 규칙이 따릅니다. 이 문서에서는 규칙에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1b3282e1902c4717606f860bffc659d0d608212e" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of errors with column names matching the &lt;code&gt;columns&lt;/code&gt; attribute of the plotting &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; or matching the &lt;code&gt;name&lt;/code&gt; attribute of the &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193cb6516b5800f45e558cf3abb639026193906c" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;str&lt;/code&gt; indicating which of the columns of plotting &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; contain the error values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb165dd4a7c021d82278dc00fa8bc1404690832" translate="yes" xml:space="preserve">
          <source>As a convenience, multiple assignments can be performed by using a multi-line string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af5116e0a8812adf301ca218365b9890a8a3771" translate="yes" xml:space="preserve">
          <source>As a convenience, there is a new function on DataFrame called &lt;a href=&quot;../reference/api/pandas.dataframe.reset_index#pandas.DataFrame.reset_index&quot;&gt;&lt;code&gt;reset_index()&lt;/code&gt;&lt;/a&gt; which transfers the index values into the DataFrame&amp;rsquo;s columns and sets a simple integer index. This is the inverse operation of &lt;a href=&quot;../reference/api/pandas.dataframe.set_index#pandas.DataFrame.set_index&quot;&gt;&lt;code&gt;set_index()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27d143ad19e97f7227c73adf01cdc2e7f8d4b30" translate="yes" xml:space="preserve">
          <source>As a convenience, you can pass a list of arrays directly into &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt; to construct a &lt;code&gt;MultiIndex&lt;/code&gt; automatically:</source>
          <target state="translated">편의상 배열 목록을 &lt;code&gt;Series&lt;/code&gt; 또는 &lt;code&gt;DataFrame&lt;/code&gt; 으로 직접 전달 하여 &lt;code&gt;MultiIndex&lt;/code&gt; 를 자동으로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40908edef1273fada9763b301bc2eba0152218c2" translate="yes" xml:space="preserve">
          <source>As a convenience, you can use the string &lt;code&gt;'category'&lt;/code&gt; in place of a &lt;code&gt;CategoricalDtype&lt;/code&gt; when you want the default behavior of the categories being unordered, and equal to the set values present in the array. In other words, &lt;code&gt;dtype='category'&lt;/code&gt; is equivalent to &lt;code&gt;dtype=CategoricalDtype()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda53a4c4e48eb257243eebaf80c6bd419c3f026" translate="yes" xml:space="preserve">
          <source>As a signal to other Python libraries that this column should be treated as a categorical variable (e.g. to use suitable statistical methods or plot types).</source>
          <target state="translated">다른 Python 라이브러리에 대한 신호로서이 열은 범주 형 변수로 취급되어야합니다 (예 : 적합한 통계 방법 또는 플롯 유형 사용).</target>
        </trans-unit>
        <trans-unit id="eeda04bd648e1a55f1c9e82a86bf94e6e9f814e9" translate="yes" xml:space="preserve">
          <source>As an alternative to converters, the type for an entire column can be specified using the &lt;code&gt;dtype&lt;/code&gt; keyword, which takes a dictionary mapping column names to types. To interpret data with no type inference, use the type &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24f12dc6c724e0240d3a4576966a3668efd7b9c" translate="yes" xml:space="preserve">
          <source>As an example of fully-formed metadata:</source>
          <target state="translated">완전한 형식의 메타 데이터의 예 :</target>
        </trans-unit>
        <trans-unit id="15b76b5fbc283dc7dd8bf4babf8457a89f16a027" translate="yes" xml:space="preserve">
          <source>As an example, imagine having a DataFrame with columns for stores, products, revenue and quantity sold. We&amp;rsquo;d like to do a groupwise calculation of &lt;em&gt;prices&lt;/em&gt; (i.e. revenue/quantity) per store and per product. We could do this in a multi-step operation, but expressing it in terms of piping can make the code more readable. First we set the data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1525ca7fe147c0715500fdfdfa1cd1a3bf35fb6" translate="yes" xml:space="preserve">
          <source>As an interesting example, let&amp;rsquo;s look at Egypt where a Friday-Saturday weekend is observed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9377f014c8844995e9b60ccba27bdb65175bc72" translate="yes" xml:space="preserve">
          <source>As data comes in many shapes and forms, pandas aims to be flexible with regard to handling missing data. While &lt;code&gt;NaN&lt;/code&gt; is the default missing value marker for reasons of computational speed and convenience, we need to be able to easily detect this value with data of different types: floating point, integer, boolean, and general object. In many cases, however, the Python &lt;code&gt;None&lt;/code&gt; will arise and we wish to also consider that &amp;ldquo;missing&amp;rdquo; or &amp;ldquo;not available&amp;rdquo; or &amp;ldquo;NA&amp;rdquo;.</source>
          <target state="translated">데이터는 다양한 형태와 형태로 제공되므로 팬더는 누락 된 데이터 처리와 관련하여 융통성을 추구합니다. &lt;code&gt;NaN&lt;/code&gt; 은 계산 속도와 편리 성으로 인해 기본 결 측값 표시 자 이지만 부동 소수점, 정수, 부울 및 일반 객체와 같은 다른 유형의 데이터를 사용하여이 값을 쉽게 감지 할 수 있어야합니다. 그러나 대부분의 경우 Python &lt;code&gt;None&lt;/code&gt; 이 발생하며&amp;ldquo;missing&amp;rdquo;또는&amp;ldquo;not available&amp;rdquo;또는&amp;ldquo;NA&amp;rdquo;도 고려하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="d8934ae536cd293f4bfa00f46820585f3d7d9f8a" translate="yes" xml:space="preserve">
          <source>As described above, &lt;a href=&quot;../reference/api/pandas.get_option#pandas.get_option&quot;&gt;&lt;code&gt;get_option()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.set_option#pandas.set_option&quot;&gt;&lt;code&gt;set_option()&lt;/code&gt;&lt;/a&gt; are available from the pandas namespace. To change an option, call &lt;code&gt;set_option('option regex', new_value)&lt;/code&gt;.</source>
          <target state="translated">위에서 설명한 것처럼, pandas 네임 스페이스에서 &lt;a href=&quot;../reference/api/pandas.get_option#pandas.get_option&quot;&gt; &lt;code&gt;get_option()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.set_option#pandas.set_option&quot;&gt; &lt;code&gt;set_option()&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다. 옵션을 변경하려면 &lt;code&gt;set_option('option regex', new_value)&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d2d0f96875dd7e0a34e1fcbf0c70ac95946026f" translate="yes" xml:space="preserve">
          <source>As discussed in previous section, indexing a &lt;code&gt;DatetimeIndex&lt;/code&gt; with a partial string depends on the &amp;ldquo;accuracy&amp;rdquo; of the period, in other words how specific the interval is in relation to the resolution of the index. In contrast, indexing with &lt;code&gt;Timestamp&lt;/code&gt; or &lt;code&gt;datetime&lt;/code&gt; objects is exact, because the objects have exact meaning. These also follow the semantics of &lt;em&gt;including both endpoints&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ec44a80f850f44f251d563c977905e8f27e176" translate="yes" xml:space="preserve">
          <source>As in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7defdfdc687af9373e54d8765f30c6fb017f90" translate="yes" xml:space="preserve">
          <source>As in the &lt;code&gt;asof&lt;/code&gt; function, if the label (a particular entry in &lt;code&gt;where&lt;/code&gt;) is not in the index, the latest index label upto the passed label is chosen and its index returned.</source>
          <target state="translated">&lt;code&gt;asof&lt;/code&gt; 함수 에서와 같이 레이블 ( &lt;code&gt;where&lt;/code&gt; 의 특정 항목 )이 색인에 없으면 전달 된 레이블까지 최신 색인 레이블이 선택되고 해당 색인이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e54ad809afc4f8c8c6c4e0c4e5c908300c5421" translate="yes" xml:space="preserve">
          <source>As is customary, we import pandas and NumPy as follows. This means that we can refer to the libraries as &lt;code&gt;pd&lt;/code&gt; and &lt;code&gt;np&lt;/code&gt;, respectively, for the rest of the document.</source>
          <target state="translated">관례대로 팬더와 NumPy를 다음과 같이 가져옵니다. 이것은 우리가 문서의 나머지 부분에 대해 라이브러리를 각각 &lt;code&gt;pd&lt;/code&gt; 및 &lt;code&gt;np&lt;/code&gt; 로 참조 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1d5f4fbf9647762a6718f8a6c10d79ebe7323f70" translate="yes" xml:space="preserve">
          <source>As is customary, we import pandas and NumPy as follows:</source>
          <target state="translated">관례대로 팬더와 NumPy를 다음과 같이 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cac08938600fdec91aea0cf394ecc8ce6bd8eb32" translate="yes" xml:space="preserve">
          <source>As matplotlib does not directly support colormaps for line-based plots, the colors are selected based on an even spacing determined by the number of columns in the &lt;code&gt;DataFrame&lt;/code&gt;. There is no consideration made for background color, so some colormaps will produce lines that are not easily visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e916c69474e2fde3529f2f0c8c2b405a2f5da589" translate="yes" xml:space="preserve">
          <source>As mentioned above, &lt;code&gt;stack&lt;/code&gt; can be called with a &lt;code&gt;level&lt;/code&gt; argument to select which level in the columns to stack:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17d1b1d55ae625081d9e9337da0a4b5f6833336" translate="yes" xml:space="preserve">
          <source>As mentioned in the &amp;ldquo;Notes&amp;rdquo; section, new extension types may be added in the future (by pandas or 3rd party libraries), causing the return value to no longer be a &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt;&lt;code&gt;arrays.PandasArray&lt;/code&gt;&lt;/a&gt;. Specify the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4614d5f6b2a0e164e0e308f8950233642be2895" translate="yes" xml:space="preserve">
          <source>As mentioned when introducing the data structures in the &lt;a href=&quot;../getting_started/basics#basics&quot;&gt;last section&lt;/a&gt;, the primary function of indexing with &lt;code&gt;[]&lt;/code&gt; (a.k.a. &lt;code&gt;__getitem__&lt;/code&gt; for those familiar with implementing class behavior in Python) is selecting out lower-dimensional slices. The following table shows return type values when indexing pandas objects with &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../getting_started/basics#basics&quot;&gt;마지막 섹션&lt;/a&gt; 에서 데이터 구조를 소개 할 때 언급했듯이 &lt;code&gt;[]&lt;/code&gt; ( 파이썬에서 클래스 동작 구현에 익숙한 사람들을 위해 &lt;code&gt;__getitem__&lt;/code&gt; ) 을 사용하여 인덱싱하는 주요 기능은 저 차원 슬라이스를 선택하는 것입니다. 다음 표는 &lt;code&gt;[]&lt;/code&gt; 로 팬더 객체를 색인 할 때 반환 유형 값을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="09c3041e49b3fceb88f511991f151b244d278c27" translate="yes" xml:space="preserve">
          <source>As mentioned when introducing the data structures in the &lt;a href=&quot;basics#basics&quot;&gt;last section&lt;/a&gt;, the primary function of indexing with &lt;code&gt;[]&lt;/code&gt; (a.k.a. &lt;code&gt;__getitem__&lt;/code&gt; for those familiar with implementing class behavior in Python) is selecting out lower-dimensional slices. The following table shows return type values when indexing pandas objects with &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3595e25caf68a6a4293add862067442573e5bc6a" translate="yes" xml:space="preserve">
          <source>As noted above, handling duplicates is an important feature when reading in raw data. That said, you may want to avoid introducing duplicates as part of a data processing pipeline (from methods like &lt;a href=&quot;../reference/api/pandas.concat#pandas.concat&quot;&gt;&lt;code&gt;pandas.concat()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;rename()&lt;/code&gt;, etc.). Both &lt;code&gt;Series&lt;/code&gt; and &lt;code&gt;DataFrame&lt;/code&gt;&lt;em&gt;disallow&lt;/em&gt; duplicate labels by calling &lt;code&gt;.set_flags(allows_duplicate_labels=False)&lt;/code&gt;. (the default is to allow them). If there are duplicate labels, an exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a5ab22ba872f49b30202589e89d2bdb75660ed" translate="yes" xml:space="preserve">
          <source>As noted above, some operations support specifying a window based on a time offset:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7899dce97ab31d004dc7480ccbd9a5ebae6e590d" translate="yes" xml:space="preserve">
          <source>As of Numba version 0.20, pandas objects cannot be passed directly to Numba-compiled functions. Instead, one must pass the NumPy array underlying the pandas object to the Numba-compiled function as demonstrated below.</source>
          <target state="translated">Numba 버전 0.20부터는 pandas 객체를 Numba 컴파일 함수에 직접 전달할 수 없습니다. 대신 아래에서 설명하는 것처럼 pandas 객체의 기본이되는 NumPy 배열을 Numba 컴파일 된 함수에 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f679e9628182b8712d03d77000ac9fe7f8682b9" translate="yes" xml:space="preserve">
          <source>As of pandas 0.11, pandas is not 100% thread safe. The known issues relate to the &lt;a href=&quot;../reference/api/pandas.dataframe.copy#pandas.DataFrame.copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; method. If you are doing a lot of copying of &lt;code&gt;DataFrame&lt;/code&gt; objects shared among threads, we recommend holding locks inside the threads where the data copying occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f440cbc24f45cddbef328860e8b7553ecf4431" translate="yes" xml:space="preserve">
          <source>As one might expect, the majority of the time is now spent in &lt;code&gt;apply_integrate_f&lt;/code&gt;, so if we wanted to make anymore efficiencies we must continue to concentrate our efforts here.</source>
          <target state="translated">예상대로, 대부분의 시간은 이제 &lt;code&gt;apply_integrate_f&lt;/code&gt; 에 소비 되므로 더 많은 효율성을 원한다면 여기에 계속 노력을 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="ca0de0cc1b26797dae23d82b46c6ba5c562b070d" translate="yes" xml:space="preserve">
          <source>As part of &lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; checks we run:</source>
          <target state="translated">&lt;a href=&quot;#contributing-ci&quot;&gt;연속 통합&lt;/a&gt; 검사의 일부로 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="faad7ef7c45cc09af88242e59189452288d712dc" translate="yes" xml:space="preserve">
          <source>As part of your implementation, we require that you defer to pandas when a pandas container (&lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;) is detected in &lt;code&gt;inputs&lt;/code&gt;. If any of those is present, you should return &lt;code&gt;NotImplemented&lt;/code&gt;. Pandas will take care of unboxing the array from the container and re-calling the ufunc with the unwrapped input.</source>
          <target state="translated">구현의 일부로, 팬더 컨테이너 ( &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; )가 &lt;code&gt;inputs&lt;/code&gt; 에서 감지되면 팬더를 연기해야합니다 . 이 중 하나라도 존재하면 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환해야합니다 . 팬더는 컨테이너에서 배열을 개봉하고 래핑되지 않은 입력으로 ufunc를 다시 호출합니다.</target>
        </trans-unit>
        <trans-unit id="20357f4f33a2c3c246cefd70f16aa9e7a93c86a5" translate="yes" xml:space="preserve">
          <source>As raw values (&lt;code&gt;list&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, or &lt;code&gt;np.ndarray&lt;/code&gt;). Must be the same length as the plotting &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9891a7d50cc6445908ee3ad03eb488b958d8c93d" translate="yes" xml:space="preserve">
          <source>As these methods apply only to one-dimensional arrays, lists or scalars; they cannot be used directly on multi-dimensional objects such as DataFrames. However, with &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt;, we can &amp;ldquo;apply&amp;rdquo; the function over each column efficiently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a89661b1f02acecf5ace3c9e152793213304c68" translate="yes" xml:space="preserve">
          <source>As this behaviour is separate from the core conversion to numeric values, any errors raised during the downcasting will be surfaced regardless of the value of the &amp;lsquo;errors&amp;rsquo; input.</source>
          <target state="translated">이 동작은 핵심 값에서 숫자 값으로 변환되는 것과 별개이므로 다운 캐스팅 중 발생하는 모든 오류는 '오류'입력 값에 관계없이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c4701ce9a1acd3d7c1d5bf5dbec9270fb933ea01" translate="yes" xml:space="preserve">
          <source>As usual, &lt;strong&gt;both sides&lt;/strong&gt; of the slicers are included as this is label indexing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcea0c6d8618ee7b25644d3114a0b483908e9abb" translate="yes" xml:space="preserve">
          <source>As usual, the union of the two indices is taken, and non-overlapping values are filled with missing values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68ab1ca368968313c1894f1d059a6dc785e7642" translate="yes" xml:space="preserve">
          <source>As we have seen previously, the alias and the offset instance are fungible in most functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb135afb35545b147907c44c27fb473436d8a127" translate="yes" xml:space="preserve">
          <source>As well as for the index:</source>
          <target state="translated">색인뿐만 아니라 :</target>
        </trans-unit>
        <trans-unit id="6fa7ae672fa74972c03f30e00aa1e8a2373228a2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;DatetimeIndex&lt;/code&gt;, the endpoints will be included in the result. The example below slices data starting from 10:00 to 11:59.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae2a25a300117c181923849e5e5189dd72537c4" translate="yes" xml:space="preserve">
          <source>As with other methods, passing &lt;code&gt;as_index=False&lt;/code&gt;, will achieve a filtration, which returns the grouped row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d201d604d8dbe0886bc1f92972296aa6b1f035" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;Series&lt;/code&gt; version, you can pass values for the &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;prefix_sep&lt;/code&gt;. By default the column name is used as the prefix, and &amp;lsquo;_&amp;rsquo; as the prefix separator. You can specify &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;prefix_sep&lt;/code&gt; in 3 ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe68f69ab8fa8237a092ab8977c826892318baa" translate="yes" xml:space="preserve">
          <source>As you can see (if you&amp;rsquo;ve read the rest of the documentation), the resulting object&amp;rsquo;s index has a &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchical index&lt;/a&gt;. This means that we can now select out each chunk by key:</source>
          <target state="translated">보시다시피 (나머지 문서를 읽은 경우) 결과 객체의 색인에는 &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;계층 색인이&lt;/a&gt; 있습니다. 이것은 이제 키로 각 ​​청크를 선택할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1801fc81bd7a149ea20b2ab1bb62370be6f1cdb5" translate="yes" xml:space="preserve">
          <source>As you can see, the columns &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt; are automatically tab completed. &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are there as well; the rest of the attributes have been truncated for brevity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618daa756c845f885d18abd41625a59d356e9bf8" translate="yes" xml:space="preserve">
          <source>As you can see, the columns &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt; are automatically tab completed. &lt;code&gt;E&lt;/code&gt; is there as well; the rest of the attributes have been truncated for brevity.</source>
          <target state="translated">보시다시피 열 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; 는 자동으로 탭 완성됩니다. &lt;code&gt;E&lt;/code&gt; 도 있습니다. 나머지 속성은 간결성을 위해 잘 렸습니다.</target>
        </trans-unit>
        <trans-unit id="4a626b65aa03b772e053a5bb2a0b5b426579d3a0" translate="yes" xml:space="preserve">
          <source>As you can see, the density (% of values that have not been &amp;ldquo;compressed&amp;rdquo;) is extremely low. This sparse object takes up much less memory on disk (pickled) and in the Python interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d921ba536b3e4afbcf9e3f5c85e3dcf4967c04c6" translate="yes" xml:space="preserve">
          <source>As you can see, the result of the aggregation will have the group names as the new index along the grouped axis. In the case of multiple keys, the result is a &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;MultiIndex&lt;/a&gt; by default, though this can be changed by using the &lt;code&gt;as_index&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc119df8143e9bdb4c41083085284e8d9a609e59" translate="yes" xml:space="preserve">
          <source>As you can see, this drops any rows where there was no match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b834a23499e8c15822cc934dd05176b29187712" translate="yes" xml:space="preserve">
          <source>Assembling a datetime from multiple columns of a DataFrame. The keys can be common abbreviations like [&amp;lsquo;year&amp;rsquo;, &amp;lsquo;month&amp;rsquo;, &amp;lsquo;day&amp;rsquo;, &amp;lsquo;minute&amp;rsquo;, &amp;lsquo;second&amp;rsquo;, &amp;lsquo;ms&amp;rsquo;, &amp;lsquo;us&amp;rsquo;, &amp;lsquo;ns&amp;rsquo;]) or plurals of the same</source>
          <target state="translated">DataFrame의 여러 열에서 날짜 시간을 조립합니다. 키는 [ 'year', 'month', 'day', 'minute', 'second', 'ms', 'us', 'ns']와 같은 일반적인 약어이거나 복수형 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94c7d85a69a3e7fd29d61e52773708ef1ee4078c" translate="yes" xml:space="preserve">
          <source>Assembling datetime from multiple DataFrame columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3292c12a856a02722a46d87471ff4e6faefa104" translate="yes" xml:space="preserve">
          <source>AssertionError</source>
          <target state="translated">AssertionError</target>
        </trans-unit>
        <trans-unit id="283f18394b73b039f6d3a20ab0fcc53c7eac4a11" translate="yes" xml:space="preserve">
          <source>Assign a color to each category. Example: [&amp;lsquo;blue&amp;rsquo;, &amp;lsquo;green&amp;rsquo;].</source>
          <target state="translated">각 카테고리에 색상을 지정하십시오. 예 : [ 'blue', 'green'].</target>
        </trans-unit>
        <trans-unit id="0b1e500e0a5afdc981828f55bcdcfad2c7d393f0" translate="yes" xml:space="preserve">
          <source>Assign desired index to given axis.</source>
          <target state="translated">주어진 축에 원하는 인덱스를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="a021f75ae7f14b71e657d6db0074fd6055230cdc" translate="yes" xml:space="preserve">
          <source>Assign new columns to a DataFrame.</source>
          <target state="translated">DataFrame에 새 열을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="c00b77f8a1e078f1116b30cd8725ae28b9c4a6c7" translate="yes" xml:space="preserve">
          <source>Assigning a &lt;code&gt;Categorical&lt;/code&gt; to parts of a column of other types will use the values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3b8d3cceb5ddcf3392fc04826930abcee54c4b" translate="yes" xml:space="preserve">
          <source>Assigning multiple columns within the same &lt;code&gt;assign&lt;/code&gt; is possible. For Python 3.6 and above, later items in &amp;lsquo;**kwargs&amp;rsquo; may refer to newly created or modified columns in &amp;lsquo;df&amp;rsquo;; items are computed and assigned into &amp;lsquo;df&amp;rsquo; in order. For Python 3.5 and below, the order of keyword arguments is not specified, you cannot refer to newly created or modified columns. All items are computed first, and then assigned in alphabetical order.</source>
          <target state="translated">동일한 &lt;code&gt;assign&lt;/code&gt; 내에서 여러 열을 할당 할 수 있습니다. Python 3.6 이상에서 '** kwargs'의 이후 항목은 'df'의 새로 작성되거나 수정 된 열을 나타낼 수 있습니다. 항목은 순서대로 계산되어 'df'에 할당됩니다. Python 3.5 이하의 경우 키워드 인수의 순서가 지정되지 않았으므로 새로 작성되거나 수정 된 열을 참조 할 수 없습니다. 모든 항목이 먼저 계산 된 다음 알파벳 순서로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="57239a199b05358cea86223cd3816d09d7e4a328" translate="yes" xml:space="preserve">
          <source>Assigning multiple columns within the same &lt;code&gt;assign&lt;/code&gt; is possible. Later items in &amp;lsquo;**kwargs&amp;rsquo; may refer to newly created or modified columns in &amp;lsquo;df&amp;rsquo;; items are computed and assigned into &amp;lsquo;df&amp;rsquo; in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7561aba73eafa16d356e069588ac020eca6d4660" translate="yes" xml:space="preserve">
          <source>Assigning new columns in method chains</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d78c42a1e18dcaee15c7fdfad010ce0e9454cf6" translate="yes" xml:space="preserve">
          <source>Assigning to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c262fde6cbb3acac8e59aff9dcebb16fbdf33e" translate="yes" xml:space="preserve">
          <source>Assigning to &lt;code&gt;categories&lt;/code&gt; is a inplace operation!</source>
          <target state="translated">&lt;code&gt;categories&lt;/code&gt; 할당하는 것은 적절한 작업입니다!</target>
        </trans-unit>
        <trans-unit id="9e6d4f35cb87d96ef8a4eab6ea9f2c53ae9904a9" translate="yes" xml:space="preserve">
          <source>Assigning to the &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;columns&lt;/code&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faea98a2a6fe70393f6626ce4e21abb41e5d1c17" translate="yes" xml:space="preserve">
          <source>Assignment is allowed though by default the original DataFrame is not modified.</source>
          <target state="translated">기본적으로 원래 DataFrame은 수정되지 않지만 할당이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a8074d78106ceedec166c0de30aa4dde93c6a85" translate="yes" xml:space="preserve">
          <source>Assigns values outside boundary to boundary values. Thresholds can be singular values or array like, and in the latter case the clipping is performed element-wise in the specified axis.</source>
          <target state="translated">경계 외부의 값을 경계 값에 할당합니다. 임계 값은 단일 값 또는 배열과 같을 수 있으며 후자의 경우 지정된 축에서 클리핑이 요소 단위로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="68035e390827bfef5b6a722908902bf830e33068" translate="yes" xml:space="preserve">
          <source>Assuming that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1b3b84c9b22507a5f24e22d734e960126f5aa6" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;self&lt;/code&gt; is sorted:</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 분류 되었다고 가정하면 :</target>
        </trans-unit>
        <trans-unit id="17a38dea37330e2a552db63fa600f01bcb06ac49" translate="yes" xml:space="preserve">
          <source>Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one is not in the index.</source>
          <target state="translated">인덱스가 정렬되어 있다고 가정하면, 전달 된 인덱스 레이블이 인덱스에 있으면 리턴하거나, 전달 된 레이블이 인덱스에 없으면 이전 인덱스 레이블을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="ff7d232f972b6ac60243634f7849c72c039db298" translate="yes" xml:space="preserve">
          <source>Assuming the following data is in a &lt;code&gt;DataFrame&lt;/code&gt;&lt;code&gt;data&lt;/code&gt;, we can insert it into the database using &lt;a href=&quot;../reference/api/pandas.dataframe.to_sql#pandas.DataFrame.to_sql&quot;&gt;&lt;code&gt;to_sql()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847e9227f6008bb57a50a373b97aedb9329f39e7" translate="yes" xml:space="preserve">
          <source>Assuming the missing data are missing at random this results in an estimate for the covariance matrix which is unbiased. However, for many applications this estimate may not be acceptable because the estimated covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimated correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="translated">결측 데이터가 무작위로 누락되었다고 가정하면, 이는 편향되지 않은 공분산 행렬에 대한 추정치가됩니다. 그러나 많은 응용 분야에서 추정 된 공분산 행렬이 양의 반정의 값을 보장하지 않기 때문에이 추정값은 허용되지 않을 수 있습니다. 이는 1보다 큰 절대 값 및 / 또는 비가역 공분산 행렬을 갖는 추정 된 상관을 야기 할 수있다. 자세한 내용 &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;은 공분산 행렬 추정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="62161c7dd9e9f6b51907a0d81672d31756daf1aa" translate="yes" xml:space="preserve">
          <source>Assuming the missing data are missing at random this results in an estimate for the covariance matrix which is unbiased. However, for many applications this estimate may not be acceptable because the estimated covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimated correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91294f5738999f135f72cf43572739567d1bb7e" translate="yes" xml:space="preserve">
          <source>Asymmetrical error bars are also supported, however raw error values must be provided in this case. For a &lt;code&gt;N&lt;/code&gt; length &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;2xN&lt;/code&gt; array should be provided indicating lower and upper (or left and right) errors. For a &lt;code&gt;MxN&lt;/code&gt;&lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;, asymmetrical errors should be in a &lt;code&gt;Mx2xN&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1096e85be1dda6b7f842b4c0a7fa3a4b79d6bea4" translate="yes" xml:space="preserve">
          <source>At that point, you get back the same thing you&amp;rsquo;d get with pandas, in this case a concrete pandas Series with the count of each &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8285d78da67fd75904fc813a6e40923d77fe6a15" translate="yes" xml:space="preserve">
          <source>At this point you should be able to import pandas from your locally built version:</source>
          <target state="translated">이 시점에서 로컬로 빌드 한 버전에서 팬더를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a0725a9db4327acc5ab4a8b0e28950a3af0804" translate="yes" xml:space="preserve">
          <source>Attempt to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point, useful for SQL result sets</source>
          <target state="translated">문자열이 아닌 숫자가 아닌 객체 (예 : 10 진수, 10 진수)의 값을 부동 소수점으로 변환하여 SQL 결과 세트에 유용</target>
        </trans-unit>
        <trans-unit id="3ee3af0ebb2a38402fd53e85cafa5fd36a8a970d" translate="yes" xml:space="preserve">
          <source>Attempt to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point, useful for SQL result sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99086bed7a57f1848cf039b09832b569d18bb7d" translate="yes" xml:space="preserve">
          <source>Attempt to infer better dtypes for object columns.</source>
          <target state="translated">객체 열에 대해 더 나은 dtype을 유추하려고합니다.</target>
        </trans-unit>
        <trans-unit id="9d60ed94e473dd535df1f10f852f3dd2c8dd3841" translate="yes" xml:space="preserve">
          <source>Attempting to use the the &lt;code&gt;xlwt&lt;/code&gt; engine will raise a &lt;code&gt;FutureWarning&lt;/code&gt; unless the option &lt;code&gt;io.excel.xls.writer&lt;/code&gt; is set to &lt;code&gt;&quot;xlwt&quot;&lt;/code&gt;. While this option is now deprecated and will also raise a &lt;code&gt;FutureWarning&lt;/code&gt;, it can be globally set and the warning suppressed. Users are recommended to write &lt;code&gt;.xlsx&lt;/code&gt; files using the &lt;code&gt;openpyxl&lt;/code&gt; engine instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5dc03079d44b34bb699f1394078a605fdcb2fd" translate="yes" xml:space="preserve">
          <source>Attempts soft conversion of object-dtyped columns, leaving non-object and unconvertible columns unchanged. The inference rules are the same as during normal Series/DataFrame construction.</source>
          <target state="translated">개체 유형이 지정된 열의 소프트 변환을 시도하여 개체가 아닌 열과 변환 불가능한 열은 변경하지 않습니다. 추론 규칙은 일반적인 Series / DataFrame 구성과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="dd95b409a19cffedeaa0c6241c16f85d21ca6316" translate="yes" xml:space="preserve">
          <source>Attempts to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point, useful for SQL result sets.</source>
          <target state="translated">문자열이 아닌 숫자가 아닌 객체 (예 : decimal.Decimal)의 값을 부동 소수점으로 변환하여 SQL 결과 세트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1e19388759ea8f1a1e341460fa22ad603047fa05" translate="yes" xml:space="preserve">
          <source>Attempts to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point. Can result in loss of Precision.</source>
          <target state="translated">문자열이 아닌 숫자가 아닌 객체 (10 진수, 10 진수 등)의 값을 부동 소수점으로 변환하려고합니다. 정밀도가 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91bce955e5463a031508f84438b6f67b9451abdf" translate="yes" xml:space="preserve">
          <source>Attempts to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point. Useful for SQL result sets.</source>
          <target state="translated">문자열이 아닌 숫자가 아닌 객체 (10 진수, 10 진수 등)의 값을 부동 소수점으로 변환하려고합니다. SQL 결과 세트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1d6277b8fc8c3dd96cfaf8b408a54965a2293ef" translate="yes" xml:space="preserve">
          <source>Attribute &amp;ldquo;dtype&amp;rdquo; are different [left]: int64 [right]: float64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575bb8290ede2b9667d8e92089409003fa80b2b9" translate="yes" xml:space="preserve">
          <source>Attribute access</source>
          <target state="translated">속성 액세스</target>
        </trans-unit>
        <trans-unit id="90385977bc9ea5c42c50a4e0b51d0d672bc1f6e6" translate="yes" xml:space="preserve">
          <source>Attribute access, e.g., &lt;code&gt;df.a&lt;/code&gt;</source>
          <target state="translated">속성 액세스 (예 : &lt;code&gt;df.a&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e30390c6b25519953f15954ce4132cba67fdd587" translate="yes" xml:space="preserve">
          <source>AttributeError</source>
          <target state="translated">AttributeError</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="cc3307fda48a46f4a297fa8558a9d4ff399cabe1" translate="yes" xml:space="preserve">
          <source>Attributes and underlying data</source>
          <target state="translated">속성 및 기본 데이터</target>
        </trans-unit>
        <trans-unit id="f2b28266f71d078ffe1d8d07fba6914597acac20" translate="yes" xml:space="preserve">
          <source>Attributes can be set in two ways</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fa36005fcbd9c2ea2fe9205f82f8e8f278ceaf" translate="yes" xml:space="preserve">
          <source>Autocorrelation Plot</source>
          <target state="translated">자기 상관도</target>
        </trans-unit>
        <trans-unit id="b8d7914c349946ce3d48b12a1455ed9bca5fcf71" translate="yes" xml:space="preserve">
          <source>Autocorrelation plot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028be73990bf81f759de9d600258cbd0dc48b3a4" translate="yes" xml:space="preserve">
          <source>Autocorrelation plot for time series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc919ceb03a7b8417436ebe51c0b46afd485fab" translate="yes" xml:space="preserve">
          <source>Autocorrelation plots are often used for checking randomness in time series. This is done by computing autocorrelations for data values at varying time lags. If time series is random, such autocorrelations should be near zero for any and all time-lag separations. If time series is non-random then one or more of the autocorrelations will be significantly non-zero. The horizontal lines displayed in the plot correspond to 95% and 99% confidence bands. The dashed line is 99% confidence band. See the &lt;a href=&quot;https://en.wikipedia.org/wiki/Correlogram&quot;&gt;Wikipedia entry&lt;/a&gt; for more about autocorrelation plots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a219b0276e739b8fdfb1dc1ab4123104c572aa" translate="yes" xml:space="preserve">
          <source>Automatic and explicit &lt;strong&gt;data alignment&lt;/strong&gt;: objects can be explicitly aligned to a set of labels, or the user can simply ignore the labels and let &lt;code&gt;Series&lt;/code&gt;, &lt;code&gt;DataFrame&lt;/code&gt;, etc. automatically align the data for you in computations</source>
          <target state="translated">자동 및 명시 적 &lt;strong&gt;데이터 정렬&lt;/strong&gt; : 개체를 레이블 집합에 명시 적으로 정렬하거나 사용자가 레이블을 무시하고 &lt;code&gt;Series&lt;/code&gt; , &lt;code&gt;DataFrame&lt;/code&gt; 등이 계산에서 자동으로 데이터를 정렬하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6622b5c394de57192d778bd3959c6342e89bf692" translate="yes" xml:space="preserve">
          <source>Automatic date tick adjustment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda78c3ec3fa94913c6e1080bfe2d58282df5d9d" translate="yes" xml:space="preserve">
          <source>Automatic exclusion of &amp;ldquo;nuisance&amp;rdquo; columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3dab8eb939ee8925ea50e11dc137e6027628645" translate="yes" xml:space="preserve">
          <source>Automatically &amp;ldquo;sniffing&amp;rdquo; the delimiter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad488fccb450082a4a1ac7a5822e9968a0e57780" translate="yes" xml:space="preserve">
          <source>Available EW functions: &lt;code&gt;mean()&lt;/code&gt;, &lt;code&gt;var()&lt;/code&gt;, &lt;code&gt;std()&lt;/code&gt;, &lt;code&gt;corr()&lt;/code&gt;, &lt;code&gt;cov()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2931a9a21b541225c024193258e14ebcd1821756" translate="yes" xml:space="preserve">
          <source>Available cases:</source>
          <target state="translated">사용 가능한 경우 :</target>
        </trans-unit>
        <trans-unit id="91791fb1c671bc50f26bfde0c65300d3feece464" translate="yes" xml:space="preserve">
          <source>Available kwargs: {days, seconds, microseconds, milliseconds, minutes, hours, weeks}. Values for construction in compat with datetime.timedelta. Numpy ints and floats will be coerced to python ints and floats.</source>
          <target state="translated">사용 가능한 kwargs : {일, 초, 마이크로 초, 밀리 초, 분, 시간, 주}. datetime.timedelta와 호환되는 구성 값입니다. Numpy int와 float는 python int와 float로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="48315d4da6f457296128d582ea2ac7a8107a6caa" translate="yes" xml:space="preserve">
          <source>Available options</source>
          <target state="translated">사용 가능한 옵션</target>
        </trans-unit>
        <trans-unit id="057b4b33c8569c09b413019743ff85bf2e11c330" translate="yes" xml:space="preserve">
          <source>Available options:</source>
          <target state="translated">사용 가능한 옵션 :</target>
        </trans-unit>
        <trans-unit id="b2501da01385df19f1d86b0bed04e38fd63de7a5" translate="yes" xml:space="preserve">
          <source>Avoiding inconsistencies when writing to a store from multiple processes/threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570d8f848f14577f6db35c538f58ded1b980df07" translate="yes" xml:space="preserve">
          <source>Axis along which the function is applied:</source>
          <target state="translated">기능이 적용되는 축 :</target>
        </trans-unit>
        <trans-unit id="38050eaac2584f2816c6699a4e03069bbf38db0d" translate="yes" xml:space="preserve">
          <source>Axis along which the level(s) is removed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04388f6c2b31d163b02edafe90363be434b40e5d" translate="yes" xml:space="preserve">
          <source>Axis along which to fill missing values.</source>
          <target state="translated">결 측값을 채울 축입니다.</target>
        </trans-unit>
        <trans-unit id="af3d9cf81d0ecd6ab4007608d578ff18fdd812f5" translate="yes" xml:space="preserve">
          <source>Axis for the function to be applied on.</source>
          <target state="translated">기능을 적용 할 축.</target>
        </trans-unit>
        <trans-unit id="558d7d6244767b206d2619baa97c003ee79bbeac" translate="yes" xml:space="preserve">
          <source>Axis grid lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58aad5359979285a40cbf75418420c255020489c" translate="yes" xml:space="preserve">
          <source>Axis labels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4459d9afa7679398ad4d66b0656daae6713bba0" translate="yes" xml:space="preserve">
          <source>Axis to be sorted.</source>
          <target state="translated">정렬 할 축입니다.</target>
        </trans-unit>
        <trans-unit id="db1906fbeee0195046920ed075d5b0c52d721b71" translate="yes" xml:space="preserve">
          <source>Axis to direct sorting. The value &amp;lsquo;index&amp;rsquo; is accepted for compatibility with DataFrame.sort_values.</source>
          <target state="translated">직접 정렬 축. 'index'값은 DataFrame.sort_values와의 호환성을 위해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="862ef98b62dba3b71ef4b57ec3dd6a3acf52b3c2" translate="yes" xml:space="preserve">
          <source>Axis to direct sorting. This can only be 0 for Series.</source>
          <target state="translated">직접 정렬 축. Series의 경우 0 만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="da437f06c43e7aa9897ec00d2ab29db84eeb9c7f" translate="yes" xml:space="preserve">
          <source>Axis to interpolate along.</source>
          <target state="translated">보간 할 축입니다.</target>
        </trans-unit>
        <trans-unit id="b9d77bb4e0a86d5d1f7eff95d4ee2e0930c4df3d" translate="yes" xml:space="preserve">
          <source>Axis to retrieve cross-section on.</source>
          <target state="translated">횡단면을 검색 할 축입니다.</target>
        </trans-unit>
        <trans-unit id="3809ca7a13f05d63ec4d467aacddf1c13864454b" translate="yes" xml:space="preserve">
          <source>Axis to sample. Accepts axis number or name. Default is stat axis for given data type (0 for Series and DataFrames).</source>
          <target state="translated">샘플링 할 축. 축 번호 또는 이름을 받아들입니다. 지정된 데이터 유형에 대한 기본값은 통계 축입니다 (시리즈 및 데이터 프레임의 경우 0).</target>
        </trans-unit>
        <trans-unit id="d2ae544f18e576798e0e3b3ba5c3c1bbae3a15b2" translate="yes" xml:space="preserve">
          <source>Axis to target with &lt;code&gt;mapper&lt;/code&gt;. Can be either the axis name (&amp;lsquo;index&amp;rsquo;, &amp;lsquo;columns&amp;rsquo;) or number (0, 1). The default is &amp;lsquo;index&amp;rsquo;.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 로 타겟팅 할 축 입니다. 축 이름 ( 'index', 'columns') 또는 숫자 (0, 1) 일 수 있습니다. 기본값은 'index'입니다.</target>
        </trans-unit>
        <trans-unit id="60eb28a9f49cf47b0a8cc1e32d75b6c5cf627ed5" translate="yes" xml:space="preserve">
          <source>Axis to target. Can be either the axis name (&amp;lsquo;index&amp;rsquo;, &amp;lsquo;columns&amp;rsquo;) or number (0, 1).</source>
          <target state="translated">타겟팅 할 축입니다. 축 이름 ( 'index', 'columns') 또는 숫자 (0, 1) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0361baee21e1b1202b20962818725f461d664b" translate="yes" xml:space="preserve">
          <source>Axis to truncate. Truncates the index (rows) by default.</source>
          <target state="translated">자를 축입니다. 기본적으로 인덱스 (행)를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="ae5166b5a6bf18ff941620e3302ff37b11786413" translate="yes" xml:space="preserve">
          <source>BA, BY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89533a386d3e90e8377368c7d33936c8671d8779" translate="yes" xml:space="preserve">
          <source>BAS, BYS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578a49fac35655f8a7cd81c0227ca8247bcee12c" translate="yes" xml:space="preserve">
          <source>BDay</source>
          <target state="translated">BDay</target>
        </trans-unit>
        <trans-unit id="70bcc0687642f6fc9c81360e6f3673a3778d04ea" translate="yes" xml:space="preserve">
          <source>BDay.apply()</source>
          <target state="translated">BDay.apply()</target>
        </trans-unit>
        <trans-unit id="38fb47316f1665a955e415da88e14cf8d35c0d5d" translate="yes" xml:space="preserve">
          <source>BDay.apply_index()</source>
          <target state="translated">BDay.apply_index()</target>
        </trans-unit>
        <trans-unit id="f668da582f90311e06eb85b4c863392d09ac0445" translate="yes" xml:space="preserve">
          <source>BDay.base</source>
          <target state="translated">BDay.base</target>
        </trans-unit>
        <trans-unit id="2e5b863d8240050f8f609a53d2573634a907b463" translate="yes" xml:space="preserve">
          <source>BDay.copy()</source>
          <target state="translated">BDay.copy()</target>
        </trans-unit>
        <trans-unit id="4aa6708ea2eed05450c22c6b1deb9009720040c2" translate="yes" xml:space="preserve">
          <source>BDay.freqstr</source>
          <target state="translated">BDay.freqstr</target>
        </trans-unit>
        <trans-unit id="4387a471f6aa72675640a612f972597e0ab2ef3a" translate="yes" xml:space="preserve">
          <source>BDay.isAnchored()</source>
          <target state="translated">BDay.isAnchored()</target>
        </trans-unit>
        <trans-unit id="e87c4a0f58c3cd8c92053e4c01058dd048960e93" translate="yes" xml:space="preserve">
          <source>BDay.kwds</source>
          <target state="translated">BDay.kwds</target>
        </trans-unit>
        <trans-unit id="371109edbd1e6fce60eb53f0e3d744a3486c4b54" translate="yes" xml:space="preserve">
          <source>BDay.name</source>
          <target state="translated">BDay.name</target>
        </trans-unit>
        <trans-unit id="42d2eb17788b1f93ff2bba8afe1564964febb8cc" translate="yes" xml:space="preserve">
          <source>BDay.nanos</source>
          <target state="translated">BDay.nanos</target>
        </trans-unit>
        <trans-unit id="56e71dfbe3149f5caa028d9ccdbf0499807b82fc" translate="yes" xml:space="preserve">
          <source>BDay.normalize</source>
          <target state="translated">BDay.normalize</target>
        </trans-unit>
        <trans-unit id="fde36cf02f1f883dd61753e8b8f46f384fd8a2c9" translate="yes" xml:space="preserve">
          <source>BDay.offset</source>
          <target state="translated">BDay.offset</target>
        </trans-unit>
        <trans-unit id="971b4a3e19d3ae8c701df3efd769b8f960ea8d7b" translate="yes" xml:space="preserve">
          <source>BDay.onOffset()</source>
          <target state="translated">BDay.onOffset()</target>
        </trans-unit>
        <trans-unit id="44cbb356f5795834d375c1ed778a95e2143e982e" translate="yes" xml:space="preserve">
          <source>BDay.rollback()</source>
          <target state="translated">BDay.rollback()</target>
        </trans-unit>
        <trans-unit id="c645b47c42f91be300f84a75327a4d7a92e7d3e1" translate="yes" xml:space="preserve">
          <source>BDay.rollforward()</source>
          <target state="translated">BDay.rollforward()</target>
        </trans-unit>
        <trans-unit id="4c136618fb56cf9ff4b6e161cde54e7fb0a4da32" translate="yes" xml:space="preserve">
          <source>BDay.rule_code</source>
          <target state="translated">BDay.rule_code</target>
        </trans-unit>
        <trans-unit id="2f0e7f3768f9d21ed94da9abe4f805dbad6e020e" translate="yes" xml:space="preserve">
          <source>BH</source>
          <target state="translated">BH</target>
        </trans-unit>
        <trans-unit id="1c50baa4b6f2c8346ae6645f25465fba26111845" translate="yes" xml:space="preserve">
          <source>BLD: Updates to the build process/scripts</source>
          <target state="translated">BLD : 빌드 프로세스 / 스크립트 업데이트</target>
        </trans-unit>
        <trans-unit id="377bcd643607c406052375855c4a9a36a305c8ce" translate="yes" xml:space="preserve">
          <source>BM</source>
          <target state="translated">BM</target>
        </trans-unit>
        <trans-unit id="45cb448ccda5ba5bd7b24c304ad43117f0f1545f" translate="yes" xml:space="preserve">
          <source>BMS</source>
          <target state="translated">BMS</target>
        </trans-unit>
        <trans-unit id="1ab6400027a24921db9bda1ea459e4ebedfab6b5" translate="yes" xml:space="preserve">
          <source>BMonthBegin</source>
          <target state="translated">BMonthBegin</target>
        </trans-unit>
        <trans-unit id="83504f89e36bc5bd4a061677b8f16854a7d10372" translate="yes" xml:space="preserve">
          <source>BMonthBegin.apply()</source>
          <target state="translated">BMonthBegin.apply()</target>
        </trans-unit>
        <trans-unit id="ad4226df114f26a1b3a5bcbf5051028d17657cd4" translate="yes" xml:space="preserve">
          <source>BMonthBegin.apply_index()</source>
          <target state="translated">BMonthBegin.apply_index()</target>
        </trans-unit>
        <trans-unit id="9a71ee36783e7271d13c3602e2cf13bf6c50443e" translate="yes" xml:space="preserve">
          <source>BMonthBegin.base</source>
          <target state="translated">BMonthBegin.base</target>
        </trans-unit>
        <trans-unit id="f19d3d1fca7c9f7816afa37df91d1a2136cacea2" translate="yes" xml:space="preserve">
          <source>BMonthBegin.copy()</source>
          <target state="translated">BMonthBegin.copy()</target>
        </trans-unit>
        <trans-unit id="b36894f2391084d0a4f570770f6b7d436244adb3" translate="yes" xml:space="preserve">
          <source>BMonthBegin.freqstr</source>
          <target state="translated">BMonthBegin.freqstr</target>
        </trans-unit>
        <trans-unit id="d51bfda2d5b9b32dde7585e767507c15df6fb017" translate="yes" xml:space="preserve">
          <source>BMonthBegin.isAnchored()</source>
          <target state="translated">BMonthBegin.isAnchored()</target>
        </trans-unit>
        <trans-unit id="ead9bc8f26ab6b516fad35f962f22d914c50baff" translate="yes" xml:space="preserve">
          <source>BMonthBegin.kwds</source>
          <target state="translated">BMonthBegin.kwds</target>
        </trans-unit>
        <trans-unit id="b4f602da183da0c4971db8be98f97ba0b05925e1" translate="yes" xml:space="preserve">
          <source>BMonthBegin.name</source>
          <target state="translated">BMonthBegin.name</target>
        </trans-unit>
        <trans-unit id="0752010aab7475242f703198fb7477d6fbe21bc6" translate="yes" xml:space="preserve">
          <source>BMonthBegin.nanos</source>
          <target state="translated">BMonthBegin.nanos</target>
        </trans-unit>
        <trans-unit id="87fbc048ce1c0eb56438b7470975cef09cc8b927" translate="yes" xml:space="preserve">
          <source>BMonthBegin.normalize</source>
          <target state="translated">BMonthBegin.normalize</target>
        </trans-unit>
        <trans-unit id="12fef1a5e6701c70a293f0cd2f492af3b39ac4e2" translate="yes" xml:space="preserve">
          <source>BMonthBegin.onOffset()</source>
          <target state="translated">BMonthBegin.onOffset()</target>
        </trans-unit>
        <trans-unit id="0be58f0e18ca5c503615b148117c6659591ef3b0" translate="yes" xml:space="preserve">
          <source>BMonthBegin.rollback()</source>
          <target state="translated">BMonthBegin.rollback()</target>
        </trans-unit>
        <trans-unit id="dc00734ff65de7e51275ba27bacff91566fab0d6" translate="yes" xml:space="preserve">
          <source>BMonthBegin.rollforward()</source>
          <target state="translated">BMonthBegin.rollforward()</target>
        </trans-unit>
        <trans-unit id="1882f2ee5bbb1e5811cce1472c56173928d38300" translate="yes" xml:space="preserve">
          <source>BMonthBegin.rule_code</source>
          <target state="translated">BMonthBegin.rule_code</target>
        </trans-unit>
        <trans-unit id="bafb7d6e6e395608f4698d7a436f64848984968d" translate="yes" xml:space="preserve">
          <source>BMonthEnd</source>
          <target state="translated">BMonthEnd</target>
        </trans-unit>
        <trans-unit id="93aef6426c2905e7e864abc1d05aec74d099decd" translate="yes" xml:space="preserve">
          <source>BMonthEnd.apply()</source>
          <target state="translated">BMonthEnd.apply()</target>
        </trans-unit>
        <trans-unit id="8d733aac78064da7356434e2f247eb43b036bf0d" translate="yes" xml:space="preserve">
          <source>BMonthEnd.apply_index()</source>
          <target state="translated">BMonthEnd.apply_index()</target>
        </trans-unit>
        <trans-unit id="588d1d94be691d2661c59a082780912d9975069a" translate="yes" xml:space="preserve">
          <source>BMonthEnd.base</source>
          <target state="translated">BMonthEnd.base</target>
        </trans-unit>
        <trans-unit id="aea40f3239eb0cafbf172cd005bd9874cb93f880" translate="yes" xml:space="preserve">
          <source>BMonthEnd.copy()</source>
          <target state="translated">BMonthEnd.copy()</target>
        </trans-unit>
        <trans-unit id="ec201850a96522b991d05792f69605047996e83e" translate="yes" xml:space="preserve">
          <source>BMonthEnd.freqstr</source>
          <target state="translated">BMonthEnd.freqstr</target>
        </trans-unit>
        <trans-unit id="2b9af9d9dcccf4ba44b9b6ed70d24c176b952540" translate="yes" xml:space="preserve">
          <source>BMonthEnd.isAnchored()</source>
          <target state="translated">BMonthEnd.isAnchored()</target>
        </trans-unit>
        <trans-unit id="20cf33775806497e9afa6187a3ce470c6b09f0f7" translate="yes" xml:space="preserve">
          <source>BMonthEnd.kwds</source>
          <target state="translated">BMonthEnd.kwds</target>
        </trans-unit>
        <trans-unit id="b4261373c0bfbe930942c9169dbc3817613f5884" translate="yes" xml:space="preserve">
          <source>BMonthEnd.name</source>
          <target state="translated">BMonthEnd.name</target>
        </trans-unit>
        <trans-unit id="d969126bdf278de74603044ec851c7d1958f23df" translate="yes" xml:space="preserve">
          <source>BMonthEnd.nanos</source>
          <target state="translated">BMonthEnd.nanos</target>
        </trans-unit>
        <trans-unit id="d82f7b361ac9331042f4c1154faba469bfc81b56" translate="yes" xml:space="preserve">
          <source>BMonthEnd.normalize</source>
          <target state="translated">BMonthEnd.normalize</target>
        </trans-unit>
        <trans-unit id="cdbf86eaa44e013b7f1c79124f2e78f5e51186d0" translate="yes" xml:space="preserve">
          <source>BMonthEnd.onOffset()</source>
          <target state="translated">BMonthEnd.onOffset()</target>
        </trans-unit>
        <trans-unit id="13ffb2d489edb5588207c4c97ee50f778980046a" translate="yes" xml:space="preserve">
          <source>BMonthEnd.rollback()</source>
          <target state="translated">BMonthEnd.rollback()</target>
        </trans-unit>
        <trans-unit id="29ab63ff3d4fbadca4689c3ccc9961c2c945bfb9" translate="yes" xml:space="preserve">
          <source>BMonthEnd.rollforward()</source>
          <target state="translated">BMonthEnd.rollforward()</target>
        </trans-unit>
        <trans-unit id="30af282c5b3bead78940770aa617b462b3218cb1" translate="yes" xml:space="preserve">
          <source>BMonthEnd.rule_code</source>
          <target state="translated">BMonthEnd.rule_code</target>
        </trans-unit>
        <trans-unit id="70c2d9e13b091ccb84173001d65d13439b24d742" translate="yes" xml:space="preserve">
          <source>BQ</source>
          <target state="translated">BQ</target>
        </trans-unit>
        <trans-unit id="d8472d79b6d657697336aae5d693ce6a7b8f51f3" translate="yes" xml:space="preserve">
          <source>BQS</source>
          <target state="translated">BQS</target>
        </trans-unit>
        <trans-unit id="2dd7fe2f0e111468c8fb06c625f031c4e26c89de" translate="yes" xml:space="preserve">
          <source>BQuarterBegin</source>
          <target state="translated">BQuarterBegin</target>
        </trans-unit>
        <trans-unit id="cc8503b057ed0b42b2223b3b02dd54edff04eb71" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.apply()</source>
          <target state="translated">BQuarterBegin.apply()</target>
        </trans-unit>
        <trans-unit id="03f0f88c9812bf0529c8995dc4e94b226540f03b" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.apply_index()</source>
          <target state="translated">BQuarterBegin.apply_index()</target>
        </trans-unit>
        <trans-unit id="9bc8203026f657cb0433fac8b25e7d77e2bcaeb7" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.base</source>
          <target state="translated">BQuarterBegin.base</target>
        </trans-unit>
        <trans-unit id="c6e78295cbf042fdb64088d9d795e2c38128eafb" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.copy()</source>
          <target state="translated">BQuarterBegin.copy()</target>
        </trans-unit>
        <trans-unit id="6810c49d1554576585c134cfb92b3800fcaae2ca" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.freqstr</source>
          <target state="translated">BQuarterBegin.freqstr</target>
        </trans-unit>
        <trans-unit id="ae785ff1caa5839c64e8192fcb2007f17811ac47" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.isAnchored()</source>
          <target state="translated">BQuarterBegin.isAnchored()</target>
        </trans-unit>
        <trans-unit id="b41a0ccd75c16e573b8fd7abfa2b0a537372c7d3" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.kwds</source>
          <target state="translated">BQuarterBegin.kwds</target>
        </trans-unit>
        <trans-unit id="3e3747ad39fc8dba0fdb8ff4df79320713cfa09e" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.name</source>
          <target state="translated">BQuarterBegin.name</target>
        </trans-unit>
        <trans-unit id="e699ff5bff2f2d7956dd59d327e24d2a38e6ae25" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.nanos</source>
          <target state="translated">BQuarterBegin.nanos</target>
        </trans-unit>
        <trans-unit id="6b68257de6cd776672e22f3f778599f900b1ca7b" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.normalize</source>
          <target state="translated">BQuarterBegin.normalize</target>
        </trans-unit>
        <trans-unit id="1541ddb731454b991bc452afbe4f6dbbb66338a4" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.onOffset()</source>
          <target state="translated">BQuarterBegin.onOffset()</target>
        </trans-unit>
        <trans-unit id="b473c14cd03bd8ca7f48223a01a37944f71058c8" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.rollback()</source>
          <target state="translated">BQuarterBegin.rollback()</target>
        </trans-unit>
        <trans-unit id="c3ca8ba0bb9894428417cef1549214e635ce71a0" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.rollforward()</source>
          <target state="translated">BQuarterBegin.rollforward()</target>
        </trans-unit>
        <trans-unit id="ae4229d9922ca2b4f573e09b52349dfd3ec80a9f" translate="yes" xml:space="preserve">
          <source>BQuarterBegin.rule_code</source>
          <target state="translated">BQuarterBegin.rule_code</target>
        </trans-unit>
        <trans-unit id="ee0f2f9fa29caae6fafd63c0f35120474440c449" translate="yes" xml:space="preserve">
          <source>BQuarterEnd</source>
          <target state="translated">BQuarterEnd</target>
        </trans-unit>
        <trans-unit id="884babd85f88a9c0ab97ddd7bd6db204d9a9d095" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.apply()</source>
          <target state="translated">BQuarterEnd.apply()</target>
        </trans-unit>
        <trans-unit id="c642bdc5749f8b1de6a52573d5949fe410fbcf0f" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.apply_index()</source>
          <target state="translated">BQuarterEnd.apply_index()</target>
        </trans-unit>
        <trans-unit id="1bc9be695a13e6d6d9e0c4f27054b33a2c04e54a" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.base</source>
          <target state="translated">BQuarterEnd.base</target>
        </trans-unit>
        <trans-unit id="f79d238f6b96a962ad40b42d3d1e9f07ff633611" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.copy()</source>
          <target state="translated">BQuarterEnd.copy()</target>
        </trans-unit>
        <trans-unit id="244da55f87b78e30b4932eb4742db8a3d04740fc" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.freqstr</source>
          <target state="translated">BQuarterEnd.freqstr</target>
        </trans-unit>
        <trans-unit id="913536e49ed4a9415ed76a805a49119117a20a1c" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.isAnchored()</source>
          <target state="translated">BQuarterEnd.isAnchored()</target>
        </trans-unit>
        <trans-unit id="6939bd82f0f3cfb62f4988da4e426e5691d7e3f3" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.kwds</source>
          <target state="translated">BQuarterEnd.kwds</target>
        </trans-unit>
        <trans-unit id="4b507a844b9ebef6fdf53eae5d1342e8649bf071" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.name</source>
          <target state="translated">BQuarterEnd.name</target>
        </trans-unit>
        <trans-unit id="46b29831cc18204f3a3ade3da7d143eff22fa80d" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.nanos</source>
          <target state="translated">BQuarterEnd.nanos</target>
        </trans-unit>
        <trans-unit id="ce503ae4e5774b2e18f6993579c3cadc2b725992" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.normalize</source>
          <target state="translated">BQuarterEnd.normalize</target>
        </trans-unit>
        <trans-unit id="756e2e9da7ae8c8417ecaaa6b8a6bc555675d615" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.onOffset()</source>
          <target state="translated">BQuarterEnd.onOffset()</target>
        </trans-unit>
        <trans-unit id="da564479ebcb31505d0126e5208e399e7a01fb71" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.rollback()</source>
          <target state="translated">BQuarterEnd.rollback()</target>
        </trans-unit>
        <trans-unit id="effb0e5231cc8e88af18d9b014de363dc8080b7f" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.rollforward()</source>
          <target state="translated">BQuarterEnd.rollforward()</target>
        </trans-unit>
        <trans-unit id="befeb1a429c920aef4ee786e08148eaa49161150" translate="yes" xml:space="preserve">
          <source>BQuarterEnd.rule_code</source>
          <target state="translated">BQuarterEnd.rule_code</target>
        </trans-unit>
        <trans-unit id="df0f11b1cbf0c94d3ead344a7108999434fbd8d6" translate="yes" xml:space="preserve">
          <source>BUG: Bug fix</source>
          <target state="translated">버그 : 버그 수정</target>
        </trans-unit>
        <trans-unit id="ed372d25ab983682c8e0930d23f3a73aacc97b35" translate="yes" xml:space="preserve">
          <source>BY-group</source>
          <target state="translated">BY-group</target>
        </trans-unit>
        <trans-unit id="9e238df64af90be60a1e9693d4b685f6adc2e5d3" translate="yes" xml:space="preserve">
          <source>BYearBegin</source>
          <target state="translated">BYearBegin</target>
        </trans-unit>
        <trans-unit id="3737eb090c31a022aef3b162fb65dc9146f66101" translate="yes" xml:space="preserve">
          <source>BYearBegin.apply()</source>
          <target state="translated">BYearBegin.apply()</target>
        </trans-unit>
        <trans-unit id="056d88a7f937cfa52ea9912267c76c32b05b5bab" translate="yes" xml:space="preserve">
          <source>BYearBegin.apply_index()</source>
          <target state="translated">BYearBegin.apply_index()</target>
        </trans-unit>
        <trans-unit id="8eca5628265a22d597e7175bc09a7374fb9e8962" translate="yes" xml:space="preserve">
          <source>BYearBegin.base</source>
          <target state="translated">BYearBegin.base</target>
        </trans-unit>
        <trans-unit id="e5d3ca32286baaa144a588892569a5882c4275ce" translate="yes" xml:space="preserve">
          <source>BYearBegin.copy()</source>
          <target state="translated">BYearBegin.copy()</target>
        </trans-unit>
        <trans-unit id="7c88fbf4ee1dd1bf09a7fc8bb2be41a4a0b28d74" translate="yes" xml:space="preserve">
          <source>BYearBegin.freqstr</source>
          <target state="translated">BYearBegin.freqstr</target>
        </trans-unit>
        <trans-unit id="8592bbbd135037082e34811ba6cb7b2eb80907e8" translate="yes" xml:space="preserve">
          <source>BYearBegin.isAnchored()</source>
          <target state="translated">BYearBegin.isAnchored()</target>
        </trans-unit>
        <trans-unit id="bcc29f0796faa0db5cb2889cdda532ed24543f0b" translate="yes" xml:space="preserve">
          <source>BYearBegin.kwds</source>
          <target state="translated">BYearBegin.kwds</target>
        </trans-unit>
        <trans-unit id="f18c10b0b65b62a24f3da35788798f1373c2f13e" translate="yes" xml:space="preserve">
          <source>BYearBegin.name</source>
          <target state="translated">BYearBegin.name</target>
        </trans-unit>
        <trans-unit id="b4008b8291953497057e362b2840686211d18b86" translate="yes" xml:space="preserve">
          <source>BYearBegin.nanos</source>
          <target state="translated">BYearBegin.nanos</target>
        </trans-unit>
        <trans-unit id="912edcb593d2d242c1e24036fb45a73b2340ac95" translate="yes" xml:space="preserve">
          <source>BYearBegin.normalize</source>
          <target state="translated">BYearBegin.normalize</target>
        </trans-unit>
        <trans-unit id="0561f36ce44a730da0ea82523eb85d8b43907660" translate="yes" xml:space="preserve">
          <source>BYearBegin.onOffset()</source>
          <target state="translated">BYearBegin.onOffset()</target>
        </trans-unit>
        <trans-unit id="5c7a415cc7bc462f27f221d91ea83b15aba21b3a" translate="yes" xml:space="preserve">
          <source>BYearBegin.rollback()</source>
          <target state="translated">BYearBegin.rollback()</target>
        </trans-unit>
        <trans-unit id="2b265f3a6898fccc0f486221bf0f80f2d00ff185" translate="yes" xml:space="preserve">
          <source>BYearBegin.rollforward()</source>
          <target state="translated">BYearBegin.rollforward()</target>
        </trans-unit>
        <trans-unit id="edd272205139e71992f6533b051a96dcd18604ae" translate="yes" xml:space="preserve">
          <source>BYearBegin.rule_code</source>
          <target state="translated">BYearBegin.rule_code</target>
        </trans-unit>
        <trans-unit id="0fee7b2de6fbfdf8d1fbf0a9827f8fd9de59e54a" translate="yes" xml:space="preserve">
          <source>BYearEnd</source>
          <target state="translated">BYearEnd</target>
        </trans-unit>
        <trans-unit id="f5b961e54d023617cb494b1e17dca4cf1b7c0d91" translate="yes" xml:space="preserve">
          <source>BYearEnd.apply()</source>
          <target state="translated">BYearEnd.apply()</target>
        </trans-unit>
        <trans-unit id="55e78526b23b55ce0f39ed6200ac4191490a3c92" translate="yes" xml:space="preserve">
          <source>BYearEnd.apply_index()</source>
          <target state="translated">BYearEnd.apply_index()</target>
        </trans-unit>
        <trans-unit id="54a12a12395792a986e490963229ed101d73564b" translate="yes" xml:space="preserve">
          <source>BYearEnd.base</source>
          <target state="translated">BYearEnd.base</target>
        </trans-unit>
        <trans-unit id="5673f38572ad306cf9cbd99e9c350987a4cb92c8" translate="yes" xml:space="preserve">
          <source>BYearEnd.copy()</source>
          <target state="translated">BYearEnd.copy()</target>
        </trans-unit>
        <trans-unit id="ecb8a3037ad6fafe19674392d990d26771ef3de5" translate="yes" xml:space="preserve">
          <source>BYearEnd.freqstr</source>
          <target state="translated">BYearEnd.freqstr</target>
        </trans-unit>
        <trans-unit id="3bff57e5980b415bc3e5fb02d67eaba48e39514a" translate="yes" xml:space="preserve">
          <source>BYearEnd.isAnchored()</source>
          <target state="translated">BYearEnd.isAnchored()</target>
        </trans-unit>
        <trans-unit id="0a8d7606a7d0240772827bfed1e64ced3f6d65ce" translate="yes" xml:space="preserve">
          <source>BYearEnd.kwds</source>
          <target state="translated">BYearEnd.kwds</target>
        </trans-unit>
        <trans-unit id="11ea2ac2ad5ae2896ab1d96734d876ba39c538e2" translate="yes" xml:space="preserve">
          <source>BYearEnd.name</source>
          <target state="translated">BYearEnd.name</target>
        </trans-unit>
        <trans-unit id="9f3bf5cc1560ee6ca82e6b24ab464e8c406c5f93" translate="yes" xml:space="preserve">
          <source>BYearEnd.nanos</source>
          <target state="translated">BYearEnd.nanos</target>
        </trans-unit>
        <trans-unit id="b01052f37fc5cb55e358f49ea906b98c0ffb3425" translate="yes" xml:space="preserve">
          <source>BYearEnd.normalize</source>
          <target state="translated">BYearEnd.normalize</target>
        </trans-unit>
        <trans-unit id="48236773e7957e81dc0e4ea078d79e27a8b750df" translate="yes" xml:space="preserve">
          <source>BYearEnd.onOffset()</source>
          <target state="translated">BYearEnd.onOffset()</target>
        </trans-unit>
        <trans-unit id="2deea8490be7443539a3e38a853b53c4dd7d062b" translate="yes" xml:space="preserve">
          <source>BYearEnd.rollback()</source>
          <target state="translated">BYearEnd.rollback()</target>
        </trans-unit>
        <trans-unit id="170da2f03679a6c64fda69c019a315934dc11f9e" translate="yes" xml:space="preserve">
          <source>BYearEnd.rollforward()</source>
          <target state="translated">BYearEnd.rollforward()</target>
        </trans-unit>
        <trans-unit id="c77eeb234cb6c64c47b69db5e41cd1adbee744cb" translate="yes" xml:space="preserve">
          <source>BYearEnd.rule_code</source>
          <target state="translated">BYearEnd.rule_code</target>
        </trans-unit>
        <trans-unit id="23cbbf32aabe4a968bfc7e9f60a162c44d971426" translate="yes" xml:space="preserve">
          <source>Back in an interactive IPython session:</source>
          <target state="translated">대화식 IPython 세션으로 돌아 가기 :</target>
        </trans-unit>
        <trans-unit id="851d73cd99fe3de27b85d1a02dff66cc9a30db63" translate="yes" xml:space="preserve">
          <source>Backend to use instead of the backend specified in the option &lt;code&gt;plotting.backend&lt;/code&gt;. For instance, &amp;lsquo;matplotlib&amp;rsquo;. Alternatively, to specify the &lt;code&gt;plotting.backend&lt;/code&gt; for the whole session, set &lt;code&gt;pd.options.plotting.backend&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9447b9237022e1638a61508ac8dd5ebf33ebb5fc" translate="yes" xml:space="preserve">
          <source>Backtick quoted variables are parsed as literal Python code and are converted internally to a Python valid identifier. This can lead to the following problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5626aa3cb28fff5db5e5281b96c5b8d6470607d" translate="yes" xml:space="preserve">
          <source>Backward fill NaN values in the resampled data.</source>
          <target state="translated">리샘플링 된 데이터에서 NaN 값을 뒤로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="8d7844c26cc0a288b277ef419f4ce63843d1d603" translate="yes" xml:space="preserve">
          <source>Backward fill the missing values in the dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b814d2b638f1f90a41d9bf5e81f2ea628507a0" translate="yes" xml:space="preserve">
          <source>Backward fill the new missing values in the resampled data.</source>
          <target state="translated">다시 샘플링 된 데이터에서 새로운 결 측값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="0d1b09014608f534feed5fe656d7bcd70b970daf" translate="yes" xml:space="preserve">
          <source>Backward fill the values.</source>
          <target state="translated">뒤로 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">이전 버전과의 호환성</target>
        </trans-unit>
        <trans-unit id="e496fd20136d4bb7828ebb0ab925b1bd977208e4" translate="yes" xml:space="preserve">
          <source>Bar</source>
          <target state="translated">Bar</target>
        </trans-unit>
        <trans-unit id="d8ba7250a3312316dd4dde33e404a17ad97e4564" translate="yes" xml:space="preserve">
          <source>Bar charts</source>
          <target state="translated">막대 차트</target>
        </trans-unit>
        <trans-unit id="60722378d992b90df959c8477ac087deff7fe316" translate="yes" xml:space="preserve">
          <source>Bar plots</source>
          <target state="translated">바 플롯</target>
        </trans-unit>
        <trans-unit id="d70189b4eaa35d4e593674bb9281eae7072ffc37" translate="yes" xml:space="preserve">
          <source>Base R</source>
          <target state="translated">베이스 R</target>
        </trans-unit>
        <trans-unit id="3c20df9d6f1d452d4a09b50a07faa412a80e661b" translate="yes" xml:space="preserve">
          <source>Base class for defining custom window boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c6d4b2ce34ea4512493ea7fb38dea3bf08d71d" translate="yes" xml:space="preserve">
          <source>Base class for window bounds calculations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972abc36d9bf845148d943cfd45af43b6a74318e" translate="yes" xml:space="preserve">
          <source>Based on the review you get on your pull request, you will probably need to make some changes to the code. In that case, you can make them in your branch, add a new commit to that branch, push it to GitHub, and the pull request will be automatically updated. Pushing them to GitHub again is done by:</source>
          <target state="translated">풀 요청에 대한 검토에 따라 코드를 약간 변경해야 할 수도 있습니다. 이 경우 브랜치에서 생성하고 해당 브랜치에 새로운 커밋을 추가하고 GitHub로 푸시하면 풀 요청이 자동으로 업데이트됩니다. 다시 GitHub로 푸시하는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa2c96dacf00c451ef465f6115a45a20bccf1256" translate="yes" xml:space="preserve">
          <source>Basic</source>
          <target state="translated">Basic</target>
        </trans-unit>
        <trans-unit id="b264c501851f381518b79889d8aaefcc6e03ff72" translate="yes" xml:space="preserve">
          <source>Basic MultiIndex slicing using slices, lists, and labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b19d89ef0aed3f2d4f1afed1d3f801c6b85aa5" translate="yes" xml:space="preserve">
          <source>Basic example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="b6c521d76dde722f0f0344b731691edeccd3c850" translate="yes" xml:space="preserve">
          <source>Basic grouping with apply</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd0833fe19e60899fd8edf27cbfb6d8289964d0" translate="yes" xml:space="preserve">
          <source>Basic indexing on axis with MultiIndex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79655c1e33cfbd6a7943e513b25ae898a2fd8e5" translate="yes" xml:space="preserve">
          <source>Basic plot.</source>
          <target state="translated">기본 줄거리.</target>
        </trans-unit>
        <trans-unit id="37e5fe27e7d9a3c22821ebd2278e8a145488792c" translate="yes" xml:space="preserve">
          <source>Basic plotting for DataFrame objects.</source>
          <target state="translated">DataFrame 객체에 대한 기본 플로팅.</target>
        </trans-unit>
        <trans-unit id="3f5e0ff768136b7c8c5659c035724307ecd5cb4e" translate="yes" xml:space="preserve">
          <source>Basic plotting for Series objects.</source>
          <target state="translated">Series 객체에 대한 기본 플로팅.</target>
        </trans-unit>
        <trans-unit id="64860fe1e7c29840fd05e60c7b76207877ef71fd" translate="yes" xml:space="preserve">
          <source>Basic plotting: &lt;code&gt;plot&lt;/code&gt;</source>
          <target state="translated">기본 플로팅 : &lt;code&gt;plot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f49ba3b7780cd7131e520eaf920dcc70d2912a5" translate="yes" xml:space="preserve">
          <source>Basic plotting: plot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="9379ee3df9ad3906a294879b1c55530c5dd7eafc" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;Categorical.set_categories()&lt;/code&gt; cannot know whether some category is omitted intentionally or because it is misspelled or (under Python3) due to a type difference (e.g., NumPy S1 dtype and Python strings). This can result in surprising behaviour!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34824a7d3d1e3f3fd68195b56986a80834a7369c" translate="yes" xml:space="preserve">
          <source>Be aware that a time zone definition across versions of time zone libraries may not be considered equal. This may cause problems when working with stored data that is localized using one version and operated on with a different version. See &lt;a href=&quot;io#io-hdf5-notes&quot;&gt;here&lt;/a&gt; for how to handle such a situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3e4d487288320037500217372859ddc7eb0235" translate="yes" xml:space="preserve">
          <source>Be aware that assigning new categories is an inplace operation, while most other operations under &lt;code&gt;Series.cat&lt;/code&gt; per default return a new &lt;code&gt;Series&lt;/code&gt; of dtype &lt;code&gt;category&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d172b920ebcb957dca08113a01cedfde898c35e" translate="yes" xml:space="preserve">
          <source>Be aware that assigning to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47705b59eb35418875a7da72261d664a2f0aca5b" translate="yes" xml:space="preserve">
          <source>Be aware that assigning to &lt;code&gt;categories&lt;/code&gt; is a inplace operation, while all methods return new categorical data per default (but can be called with &lt;code&gt;inplace=True&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;categories&lt;/code&gt; 할당하는 것은 적절한 작업이지만 모든 메서드는 기본적으로 새로운 범주 형 데이터를 반환하지만 &lt;code&gt;inplace=True&lt;/code&gt; 로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5e5f583f65ddeddaf91049851b5901a3f2ba9d7" translate="yes" xml:space="preserve">
          <source>Be aware that for times in the future, correct conversion between time zones (and UTC) cannot be guaranteed by any time zone library because a timezone&amp;rsquo;s offset from UTC may be changed by the respective government.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b7e70e200d0df4a10ee32a35a85a0962517159" translate="yes" xml:space="preserve">
          <source>Be aware that timezones (e.g., &lt;code&gt;pytz.timezone('US/Eastern')&lt;/code&gt;) are not necessarily equal across timezone versions. So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal. Either use the same version of timezone library or use &lt;code&gt;tz_convert&lt;/code&gt; with the updated timezone definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609055a6070911660e1dd562284d9588085eec44" translate="yes" xml:space="preserve">
          <source>Be careful with DST changes. When there is sequential data, pandas can infer the DST time:</source>
          <target state="translated">DST 변경에주의하십시오. 순차적 데이터가있는 경우 팬더는 DST 시간을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c11270c924855e413440f8e3b4609087308179b" translate="yes" xml:space="preserve">
          <source>Be careful with DST changes. When there is sequential data, pandas can infer the DST time: &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime(pd.Series([&amp;lsquo;2018-10-28 01:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2018-10-28 02:00:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2018-10-28 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2018-10-28 02:00:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2018-10-28 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2018-10-28 03:00:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2018-10-28 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;CET&amp;rsquo;, ambiguous=&amp;rsquo;infer&amp;rsquo;) 0 2018-10-28 01:30:00+02:00 1 2018-10-28 02:00:00+02:00 2 2018-10-28 02:30:00+02:00 3 2018-10-28 02:00:00+01:00 4 2018-10-28 02:30:00+01:00 5 2018-10-28 03:00:00+01:00 6 2018-10-28 03:30:00+01:00 dtype: datetime64[ns, CET]</source>
          <target state="translated">DST 변경에주의하십시오. 순차적 데이터가있는 경우 팬더는 DST 시간을 유추 할 수 있습니다. &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime (pd.Series ([ '2018-10-28 01:30:00',&amp;hellip; '2018-10-28 02:00 : 00 ',&amp;hellip;'2018-10-28 02:30:00 ',&amp;hellip;'2018-10-28 02:00:00 ',&amp;hellip;'2018-10-28 02:30:00 ',&amp;hellip;'2018- 10-28 03:00:00 ',&amp;hellip;'2018-10-28 03:30:00 '])) &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize ('CET ', ambiguous ='infer ') 0 2018-10- 28 01 : 30 : 00 + 02 : 00 1 2018-10-28 02 : 00 : 00 + 02 : 00 2 2018-10-28 02 : 30 : 00 + 02 : 00 3 2018-10-28 02:00 : 00 + 01 : 00 4 2018-10-28 02 : 30 : 00 + 01 : 00 5 2018-10-28 03 : 00 : 00 + 01 : 00 6 2018-10-28 03 : 30 : 00 + 01 : 00 dtype : datetime64 [ns, CET]</target>
        </trans-unit>
        <trans-unit id="58db1e11851338be7a4d027e56e98d5cc57c9067" translate="yes" xml:space="preserve">
          <source>Be wary of conversions between libraries. For some time zones, &lt;code&gt;pytz&lt;/code&gt; and &lt;code&gt;dateutil&lt;/code&gt; have different definitions of the zone. This is more of a problem for unusual time zones than for &amp;lsquo;standard&amp;rsquo; zones like &lt;code&gt;US/Eastern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a19905d915137043f272861c345d80f174c78e3" translate="yes" xml:space="preserve">
          <source>BeautifulSoup4</source>
          <target state="translated">BeautifulSoup4</target>
        </trans-unit>
        <trans-unit id="9f4662d87df2abc23a25c610f754172cf495d7ae" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows&quot;&gt;&lt;code&gt;iterrows()&lt;/code&gt;&lt;/a&gt; returns a Series for each row, it does &lt;strong&gt;not&lt;/strong&gt; preserve dtypes across the rows (dtypes are preserved across columns for DataFrames). For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1042dd4f767980dc1d002d91a41345fc47dbb7f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;NaN&lt;/code&gt; is a float, a column of integers with even one missing values is cast to floating-point dtype (see &lt;a href=&quot;gotchas#gotchas-intna&quot;&gt;Support for integer NA&lt;/a&gt; for more). pandas provides a nullable integer array, which can be used by explicitly requesting the dtype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c07225f14069f78c80dd8e6e480f98340b6213" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;iterrows&lt;/code&gt; returns a Series for each row, it does &lt;strong&gt;not&lt;/strong&gt; preserve dtypes across the rows (dtypes are preserved across columns for DataFrames). For example,</source>
          <target state="translated">때문에 &lt;code&gt;iterrows&lt;/code&gt; 은 각 행에 대한 시리즈를 반환, 그것은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 행 (dtypes이 DataFrames에 대한 열시 보존)에서 dtypes을 보존 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a4b8d32d305ca1701d9bf393afa8b228de7a11fb" translate="yes" xml:space="preserve">
          <source>Because ExtensionArrays are 1D-only, this is a no-op.</source>
          <target state="translated">ExtensionArray는 1D 전용이므로이 기능은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da34c08f88e8bb6d6dba825fee707cc3cc84528b" translate="yes" xml:space="preserve">
          <source>Because omitting the &lt;code&gt;dtype&lt;/code&gt; passes the data through to NumPy, a mixture of valid integers and NA will return a floating-point NumPy array.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 을 생략하면 데이터가 NumPy로 전달되므로 유효한 정수와 NA의 혼합은 부동 소수점 NumPy 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4e0bc695914dfd50c8501f182e22075a61d425d1" translate="yes" xml:space="preserve">
          <source>Because the data was transposed the original inference stored all columns as object, which &lt;code&gt;infer_objects&lt;/code&gt; will correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5077f353928aee605f29241e2959e3e7293833" translate="yes" xml:space="preserve">
          <source>Because the index is a DatetimeIndex containing only dates, we can specify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8529ce360e280e7510f8bfd6a73f0bc83ec8ae3" translate="yes" xml:space="preserve">
          <source>Because the index is a DatetimeIndex containing only dates, we can specify &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; as strings. They will be coerced to Timestamps before truncation.</source>
          <target state="translated">인덱스는 날짜 만 포함하는 DatetimeIndex이므로 &lt;code&gt;before&lt;/code&gt; 과 &lt;code&gt;after&lt;/code&gt; 를 문자열로 지정할 수 있습니다 . 잘라 내기 전에 타임 스탬프로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b01b17515dc52f74847508a603ccaec2dfadf041" translate="yes" xml:space="preserve">
          <source>Before diving into all of the details of &lt;code&gt;concat&lt;/code&gt; and what it can do, here is a simple example:</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 의 모든 세부 사항 과 수행 가능한 작업을 살펴보기 전에 간단한 예를 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="153a641c2542da7e48abc89edc3bd3e5063b15b3" translate="yes" xml:space="preserve">
          <source>Before pandas 1.0, &lt;code&gt;is_copy=False&lt;/code&gt; can be specified to ensure that the return value is an actual copy. Starting with pandas 1.0, &lt;code&gt;take&lt;/code&gt; always returns a copy, and the keyword is therefore deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1481b0cb125c9de57525bb947c3a764abdd36e" translate="yes" xml:space="preserve">
          <source>Before using this function you should read the &lt;a href=&quot;../../user_guide/io#io-html-gotchas&quot;&gt;gotchas about the HTML parsing libraries&lt;/a&gt;.</source>
          <target state="translated">이 함수를 사용하기 전에 &lt;a href=&quot;../../user_guide/io#io-html-gotchas&quot;&gt;HTML 구문 분석 라이브러리에 대한&lt;/a&gt; 문제를 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb2ac0d675c87749b474554bd1087435d5361ba9" translate="yes" xml:space="preserve">
          <source>Before v.0.25.0, the &lt;code&gt;.str&lt;/code&gt;-accessor did only the most rudimentary type checks. Starting with v.0.25.0, the type of the Series is inferred and the allowed types (i.e. strings) are enforced more rigorously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35f84fc6a9fcd04d72c7020c621717cf4019182" translate="yes" xml:space="preserve">
          <source>Before version 0.23, argument &lt;code&gt;expand&lt;/code&gt; of the &lt;code&gt;extract&lt;/code&gt; method defaulted to &lt;code&gt;False&lt;/code&gt;. When &lt;code&gt;expand=False&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt; returns a &lt;code&gt;Series&lt;/code&gt;, &lt;code&gt;Index&lt;/code&gt;, or &lt;code&gt;DataFrame&lt;/code&gt;, depending on the subject and regular expression pattern. When &lt;code&gt;expand=True&lt;/code&gt;, it always returns a &lt;code&gt;DataFrame&lt;/code&gt;, which is more consistent and less confusing from the perspective of a user. &lt;code&gt;expand=True&lt;/code&gt; has been the default since version 0.23.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf84f47df15deb65dcaafd22525ef7378d80e70" translate="yes" xml:space="preserve">
          <source>Behaves as: - If True, require an exact format match. - If False, allow the format to match anywhere in the target string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="82090dfb4fc1641294eee9c8ddecab5ba9801a25" translate="yes" xml:space="preserve">
          <source>Behavior differences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4c65748b6944dfc89514f39e7e98e06a479d32" translate="yes" xml:space="preserve">
          <source>Behavior when the destination table exists. Value can be one of:</source>
          <target state="translated">대상 테이블이 존재하는 경우의 동작 값은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6c851aee5fe7ddc9fd242b1d2822afd8878ea8a" translate="yes" xml:space="preserve">
          <source>Below example shows how to define &lt;code&gt;SubclassedSeries&lt;/code&gt; and &lt;code&gt;SubclassedDataFrame&lt;/code&gt; overriding constructor properties.</source>
          <target state="translated">아래 예제는 생성자 속성을 재정의 하는 &lt;code&gt;SubclassedSeries&lt;/code&gt; 및 &lt;code&gt;SubclassedDataFrame&lt;/code&gt; 을 정의하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="bc49f7d0108cf1fbe93126c806a7158f864eb3d6" translate="yes" xml:space="preserve">
          <source>Below is an example to define two original properties, &amp;ldquo;internal_cache&amp;rdquo; as a temporary property and &amp;ldquo;added_property&amp;rdquo; as a normal property</source>
          <target state="translated">아래는 두 개의 원래 속성 인 &quot;internal_cache&quot;를 임시 속성으로 정의하고 &quot;added_property&quot;를 일반 속성으로 정의하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="e208bacb95e673417dac4953f6472677a8a1353e" translate="yes" xml:space="preserve">
          <source>Below is how to check if any of the values are &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927f40673764a27aad14fdedb385b31e3b85f976" translate="yes" xml:space="preserve">
          <source>Benefits</source>
          <target state="translated">Benefits</target>
        </trans-unit>
        <trans-unit id="393380ba1b2d97ae4342d1060cbda9fbc5d3c930" translate="yes" xml:space="preserve">
          <source>Bessel-corrected sample standard deviation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f5e512689d17eec8a59585a209e27e15d5fa7a8" translate="yes" xml:space="preserve">
          <source>Between times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce35bc7834efceacada59a786825d7601c4db1b9" translate="yes" xml:space="preserve">
          <source>Bin values into discrete Intervals.</source>
          <target state="translated">값을 이산 간격으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="5fc72aee41d01d45074eb0aa2e60d41ee3b83f12" translate="yes" xml:space="preserve">
          <source>Bin values into discrete intervals.</source>
          <target state="translated">값을 불연속 간격으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="eb3efbb2538732c7feb15bf3f60103e13f5819df" translate="yes" xml:space="preserve">
          <source>Bin values into equal-sized Intervals based on rank or sample quantiles.</source>
          <target state="translated">순위 또는 샘플 Quantile을 기준으로 값을 동일한 크기의 간격으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="bf6c804967fb499c1c2a2b6edac39c7bfdb99cf2" translate="yes" xml:space="preserve">
          <source>Binary Excel (.xlsb) files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b158e20cafda564c944efe4e0262efb8cfc4b061" translate="yes" xml:space="preserve">
          <source>Binary files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3163bc413c6b649c8e32b9e7f1fb4a061ece9765" translate="yes" xml:space="preserve">
          <source>Binary operator functions</source>
          <target state="translated">이항 연산자 함수</target>
        </trans-unit>
        <trans-unit id="9cc1259e21c7e613999e790394c5c675e22538ae" translate="yes" xml:space="preserve">
          <source>Binary search is used to find the required insertion points.</source>
          <target state="translated">이진 검색은 필요한 삽입 점을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="731725be9a708f2dd8d88373e360244813375620" translate="yes" xml:space="preserve">
          <source>Binary window functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e1a09d406049febfd861d17f5097dda4f8c03b" translate="yes" xml:space="preserve">
          <source>Binning data with &lt;code&gt;cut&lt;/code&gt; and &lt;code&gt;qcut&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f1cd67b59bf69c00a10d87943ca16817ce1b09" translate="yes" xml:space="preserve">
          <source>Binning data with cut and qcut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bde31cfca8ba562bc619cff686e2f052166fa00" translate="yes" xml:space="preserve">
          <source>Bins can be useful for going from a continuous variable to a categorical variable; instead of counting unique apparitions of values, divide the index in the specified number of half-open bins.</source>
          <target state="translated">구간은 연속 변수에서 범주 형 변수로 이동하는 데 유용 할 수 있습니다. 고유 한 값의 값을 세는 대신 지정된 반 열림 수로 인덱스를 나눕니다.</target>
        </trans-unit>
        <trans-unit id="b5af53214ca580337a00a6300345b0638be77215" translate="yes" xml:space="preserve">
          <source>Bitwise boolean</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629e494c30e6f07e4716e2a084a5ec889bc9614e" translate="yes" xml:space="preserve">
          <source>Bitwise boolean operators like &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; return a boolean &lt;code&gt;Series&lt;/code&gt;, which is almost always what you want anyways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6f603187f9f3e8876cd6b02ae3fca1ecc04c02" translate="yes" xml:space="preserve">
          <source>Blank cells include &lt;code&gt;blank&lt;/code&gt;</source>
          <target state="translated">빈 셀은 &lt;code&gt;blank&lt;/code&gt; 포함</target>
        </trans-unit>
        <trans-unit id="7ff440de8d23dfe665747a8cf3c9d62a3d1cf5ab" translate="yes" xml:space="preserve">
          <source>Blaze</source>
          <target state="translated">Blaze</target>
        </trans-unit>
        <trans-unit id="f06b7ff8dcee65d80f8bbc09f77519581c47c993" translate="yes" xml:space="preserve">
          <source>Blaze provides a standard API for doing computations with various in-memory and on-disk backends: NumPy, Pandas, SQLAlchemy, MongoDB, PyTables, PySpark.</source>
          <target state="translated">Blaze는 NumPy, Pandas, SQLAlchemy, MongoDB, PyTables, PySpark 등 다양한 인 메모리 및 온 디스크 백엔드로 계산을 수행하기위한 표준 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="287774ec74cb6ddd4c419e7e15e9549f8e939989" translate="yes" xml:space="preserve">
          <source>Bokeh</source>
          <target state="translated">Bokeh</target>
        </trans-unit>
        <trans-unit id="80be675605bee4cb1ede9f567737e75867600672" translate="yes" xml:space="preserve">
          <source>Bokeh is a Python interactive visualization library for large datasets that natively uses the latest web technologies. Its goal is to provide elegant, concise construction of novel graphics in the style of Protovis/D3, while delivering high-performance interactivity over large data to thin clients.</source>
          <target state="translated">Bokeh는 최신 웹 기술을 기본적으로 사용하는 대규모 데이터 세트를위한 Python 대화 형 시각화 라이브러리입니다. 그 목표는 Protovis / D3 스타일의 새로운 그래픽을 우아하고 간결하게 구성하는 동시에 대용량 데이터를 통해 씬 클라이언트에 고성능 상호 작용을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1a388e5090762aabac29940c81a256956fabc28" translate="yes" xml:space="preserve">
          <source>Boolean (with NA)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc421fcf453e80e2d84d33be1e5cac7ba51a33b" translate="yes" xml:space="preserve">
          <source>Boolean array positionally indicating where an overlap occurs.</source>
          <target state="translated">오버랩이 발생하는 위치를 나타내는 부울 배열입니다.</target>
        </trans-unit>
        <trans-unit id="022b0ef129359bf4caefd05760bd350781ea6b2d" translate="yes" xml:space="preserve">
          <source>Boolean array to indicate which entries are not NA.</source>
          <target state="translated">NA가 아닌 항목을 나타내는 부울 배열입니다.</target>
        </trans-unit>
        <trans-unit id="230d00294c22689962b1eba4502cf89c2732588c" translate="yes" xml:space="preserve">
          <source>Boolean data with missing values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f3f11169411d53479639d67be61b5695cbb223" translate="yes" xml:space="preserve">
          <source>Boolean expressions consisting of only scalar values</source>
          <target state="translated">스칼라 값만으로 구성된 부울 식</target>
        </trans-unit>
        <trans-unit id="5c3a6c6f975fa74c13e061d4b56deac14c441f61" translate="yes" xml:space="preserve">
          <source>Boolean indexing</source>
          <target state="translated">부울 인덱싱</target>
        </trans-unit>
        <trans-unit id="dd9fff177f12842df4a793f24f32ba72815be25c" translate="yes" xml:space="preserve">
          <source>Boolean indicating if the IntervalIndex has overlapping intervals.</source>
          <target state="translated">IntervalIndex의 간격이 겹치는지를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="63f993a6d07b9658cc8fb2e02056076e92256399" translate="yes" xml:space="preserve">
          <source>Boolean indicator if the date belongs to a leap year.</source>
          <target state="translated">날짜가 윤년에 속하는 경우 부울 표시기입니다.</target>
        </trans-unit>
        <trans-unit id="9d3bf18ce8c74ccadc928fc2d17fa77a03e0d0f7" translate="yes" xml:space="preserve">
          <source>Boolean inverse of isna.</source>
          <target state="translated">isna의 부울 역.</target>
        </trans-unit>
        <trans-unit id="8638002de3c20d4f7f02ef7937511690e4972eaf" translate="yes" xml:space="preserve">
          <source>Boolean inverse of notna.</source>
          <target state="translated">notna의 부울 역수.</target>
        </trans-unit>
        <trans-unit id="16f1251288c90060da992539978775155b522ef0" translate="yes" xml:space="preserve">
          <source>Boolean inverse of pandas.isna.</source>
          <target state="translated">pandas.isna의 부울 역수.</target>
        </trans-unit>
        <trans-unit id="2c16ad7d9b91e2596bbc6b8ad524438b9b4c3961" translate="yes" xml:space="preserve">
          <source>Boolean inverse of pandas.notna.</source>
          <target state="translated">pandas.notna의 부울 역수.</target>
        </trans-unit>
        <trans-unit id="25e990b4649c2bc674f3ef76c7ea016d66a37722" translate="yes" xml:space="preserve">
          <source>Boolean list with the same length as the row axis</source>
          <target state="translated">행 축과 길이가 같은 부울 목록</target>
        </trans-unit>
        <trans-unit id="a54f3fd197821f35d7cc4ec8c59ac98fe9d5c879" translate="yes" xml:space="preserve">
          <source>Boolean operations, e.g., &lt;code&gt;df &amp;lt; df2 and df3 &amp;lt; df4 or not df_bool&lt;/code&gt;</source>
          <target state="translated">부울 연산, 예 : &lt;code&gt;df &amp;lt; df2 and df3 &amp;lt; df4 or not df_bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e25cb936a813ba1158c4bece9543c9832c1230c" translate="yes" xml:space="preserve">
          <source>Boolean operators work as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8da9fdbd15b51adf76743209e5552d483d7a70d" translate="yes" xml:space="preserve">
          <source>Boolean reductions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88eb78a78682585d0f6340eef365f08c7cda023" translate="yes" xml:space="preserve">
          <source>Boolean same-sized DataFrame showing places of NA elements.</source>
          <target state="translated">NA 요소의 위치를 ​​표시하는 동일한 크기의 부울 DataFrame입니다.</target>
        </trans-unit>
        <trans-unit id="228ee98f1665841fa8c54953f1a8a18247fd14e7" translate="yes" xml:space="preserve">
          <source>Boolean series for each duplicated rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7133f12719661511054ab5e011b7efd42eff73c9" translate="yes" xml:space="preserve">
          <source>Boolean values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76f02336bf20b6f10d78001acc5acd0c87c9a72" translate="yes" xml:space="preserve">
          <source>Boolean: &lt;code&gt;'bool'&lt;/code&gt;</source>
          <target state="translated">부울 : &lt;code&gt;'bool'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61a088b0a156000801673ebe9758a3bc5e658a93" translate="yes" xml:space="preserve">
          <source>BooleanArray</source>
          <target state="translated">BooleanArray</target>
        </trans-unit>
        <trans-unit id="05be1cb89b188dd2668d313dc51362c7f07a69a4" translate="yes" xml:space="preserve">
          <source>BooleanArray implements Kleene logic (sometimes called three-value logic) for logical operations. See &lt;a href=&quot;../../user_guide/boolean#boolean-kleene&quot;&gt;Kleene logical operations&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa24dfeb25a69f55e548d2d8a1d8b0fe1b9ed5b4" translate="yes" xml:space="preserve">
          <source>BooleanArray is considered experimental. The implementation and parts of the API may change without warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271e1728a4a5bbee1748a53bab0124ec76c5c451" translate="yes" xml:space="preserve">
          <source>BooleanDtype is considered experimental. The implementation and parts of the API may change without warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8612ea969d1680a44a840e85c8e565c3ef8c43" translate="yes" xml:space="preserve">
          <source>Booleans are valid because they are int subclass.</source>
          <target state="translated">부울은 int 서브 클래스이므로 유효합니다.</target>
        </trans-unit>
        <trans-unit id="5281b317ab6c3d15d836edf8a074eccb13a73c2b" translate="yes" xml:space="preserve">
          <source>Booleans indicating if dates belong to a leap year.</source>
          <target state="translated">날짜가 윤년에 속하는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="606e5cb4e58c7fa936ef9764e276cb734d04557e" translate="yes" xml:space="preserve">
          <source>Bootstrap Plot</source>
          <target state="translated">부트 스트랩 플롯</target>
        </trans-unit>
        <trans-unit id="edc4932a1f6f98b2ad009919062747c48d2e8738" translate="yes" xml:space="preserve">
          <source>Bootstrap plot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6577311d3635f544049b00b0211bbe161a25cb" translate="yes" xml:space="preserve">
          <source>Bootstrap plot on mean, median and mid-range statistics.</source>
          <target state="translated">평균, 중간 및 중간 범위 통계에 대한 부트 스트랩 플롯.</target>
        </trans-unit>
        <trans-unit id="51d7eabb0471ca5a5aa4668b09430d346cd8cda9" translate="yes" xml:space="preserve">
          <source>Bootstrap plots are used to visually assess the uncertainty of a statistic, such as mean, median, midrange, etc. A random subset of a specified size is selected from a data set, the statistic in question is computed for this subset and the process is repeated a specified number of times. Resulting plots and histograms are what constitutes the bootstrap plot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cfcb28f21f551a1d596a8c9a1fead955dc64ca" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Styler.apply&lt;/code&gt;, and &lt;code&gt;Styler.applymap&lt;/code&gt; accept a &lt;code&gt;subset&lt;/code&gt; keyword. This allows you to apply styles to specific rows or columns, without having to code that logic into your &lt;code&gt;style&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;Styler.apply&lt;/code&gt; 및 &lt;code&gt;Styler.applymap&lt;/code&gt; 모두 &lt;code&gt;subset&lt;/code&gt; 키워드를 허용합니다 . 이를 통해 해당 논리를 &lt;code&gt;style&lt;/code&gt; 함수 에 코딩하지 않고도 특정 행이나 열에 스타일을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cd3bdfe2b1dc36f3ce79debd7bbbf68aaa6c834" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;rename&lt;/code&gt; and &lt;code&gt;rename_axis&lt;/code&gt; support specifying a dictionary, &lt;code&gt;Series&lt;/code&gt; or a mapping function to map labels/names to new values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667f44ad700147f40dc1bb44b2965c5c43206240" translate="yes" xml:space="preserve">
          <source>Both DataFrames must be sorted by the key.</source>
          <target state="translated">두 DataFrame은 모두 키로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="66bb145eb5891dc142843d18eaca9d3ef1f32bb9" translate="yes" xml:space="preserve">
          <source>Both NA and null values are automatically excluded from the calculation. (See the note below about bias from missing values.) A threshold can be set for the minimum number of observations for each value created. Comparisons with observations below this threshold will be returned as &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">NA 및 null 값이 모두 계산에서 자동으로 제외됩니다. (결 측값의 바이어스에 대해서는 아래 참고를 참조하십시오.) 생성 된 각 값에 대한 최소 관측치 수에 대한 임계 값을 설정할 수 있습니다. 이 임계 값 미만의 관측치와 비교하면 &lt;code&gt;NaN&lt;/code&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb68bff5a80fa34bfffc6e32034333c4baa9edc6" translate="yes" xml:space="preserve">
          <source>Both Neg and Pos</source>
          <target state="translated">Neg와 Pos</target>
        </trans-unit>
        <trans-unit id="f2fa5830ecadde34b34fbf3e55d0efb29828f1f2" translate="yes" xml:space="preserve">
          <source>Both Series and DataFrame objects have &lt;a href=&quot;../reference/api/pandas.dataframe.interpolate#pandas.DataFrame.interpolate&quot;&gt;&lt;code&gt;interpolate()&lt;/code&gt;&lt;/a&gt; that, by default, performs linear interpolation at missing data points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21d8fbefafd41cf1c54d1572767377c17367ed7" translate="yes" xml:space="preserve">
          <source>Both of these &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; time zone information can be manipulated via the &lt;code&gt;.dt&lt;/code&gt; accessor, see &lt;a href=&quot;basics#basics-dt-accessors&quot;&gt;the dt accessor section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5564daf8202c5e95c5a63616639ee79fba95d94" translate="yes" xml:space="preserve">
          <source>Both of those methods take a function (and some other keyword arguments) and applies your function to the DataFrame in a certain way. &lt;code&gt;Styler.applymap&lt;/code&gt; works through the DataFrame elementwise. &lt;code&gt;Styler.apply&lt;/code&gt; passes each column or row into your DataFrame one-at-a-time or the entire table at once, depending on the &lt;code&gt;axis&lt;/code&gt; keyword argument. For columnwise use &lt;code&gt;axis=0&lt;/code&gt;, rowwise use &lt;code&gt;axis=1&lt;/code&gt;, and for the entire table at once use &lt;code&gt;axis=None&lt;/code&gt;.</source>
          <target state="translated">이 두 가지 방법 모두 함수 (및 다른 키워드 인수)를 사용하여 특정 방식으로 DataFrame에 함수를 적용합니다. &lt;code&gt;Styler.applymap&lt;/code&gt; 은 DataFrame 요소를 통해 작동합니다. &lt;code&gt;Styler.apply&lt;/code&gt; 는 &lt;code&gt;axis&lt;/code&gt; 키워드 인수 에 따라 각 열 또는 행을 한 번에 하나씩 또는 전체 테이블에 한 번에 DataFrame에 전달합니다 . 칼럼 용도 용 &lt;code&gt;axis=0&lt;/code&gt; , rowwise 사용 &lt;code&gt;axis=1&lt;/code&gt; , 사용 한번에 전체 테이블 &lt;code&gt;axis=None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="094ce0a835bcefce0415c862ffaf4ef5dc96b12f" translate="yes" xml:space="preserve">
          <source>Both outputs are &lt;code&gt;Int64&lt;/code&gt; dtype. Compare that with object-dtype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2296cefe9f0809fb53daac12fd608a8f64778f" translate="yes" xml:space="preserve">
          <source>Boundary values are included by default:</source>
          <target state="translated">경계 값은 기본적으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="239ca5767afac9641593464ce02bc454d6ac07a9" translate="yes" xml:space="preserve">
          <source>Box</source>
          <target state="translated">Box</target>
        </trans-unit>
        <trans-unit id="d28c42106d6177d86bc2d2d91b4a0ff246b514e9" translate="yes" xml:space="preserve">
          <source>Box plots</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3002a33c57607a53f08319e550edde845407d477" translate="yes" xml:space="preserve">
          <source>Boxplot can be colorized by passing &lt;code&gt;color&lt;/code&gt; keyword. You can pass a &lt;code&gt;dict&lt;/code&gt; whose keys are &lt;code&gt;boxes&lt;/code&gt;, &lt;code&gt;whiskers&lt;/code&gt;, &lt;code&gt;medians&lt;/code&gt; and &lt;code&gt;caps&lt;/code&gt;. If some keys are missing in the &lt;code&gt;dict&lt;/code&gt;, default colors are used for the corresponding artists. Also, boxplot has &lt;code&gt;sym&lt;/code&gt; keyword to specify fliers style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920fff947e3d237d1d68f0869033126af863a7f4" translate="yes" xml:space="preserve">
          <source>Boxplot can be drawn calling &lt;a href=&quot;../reference/api/pandas.series.plot.box#pandas.Series.plot.box&quot;&gt;&lt;code&gt;Series.plot.box()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe.plot.box#pandas.DataFrame.plot.box&quot;&gt;&lt;code&gt;DataFrame.plot.box()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../reference/api/pandas.dataframe.boxplot#pandas.DataFrame.boxplot&quot;&gt;&lt;code&gt;DataFrame.boxplot()&lt;/code&gt;&lt;/a&gt; to visualize the distribution of values within each column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7f4106e6dc74b912bc74594b8d321fda3eee18" translate="yes" xml:space="preserve">
          <source>Boxplot for each quartile of a stratifying variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb04674c1bc1045c67626e52198999ae63da9e0" translate="yes" xml:space="preserve">
          <source>Boxplots can be created for every column in the dataframe by &lt;code&gt;df.boxplot()&lt;/code&gt; or indicating the columns to be used:</source>
          <target state="translated">df.boxplot &lt;code&gt;df.boxplot()&lt;/code&gt; 데이터 프레임의 모든 열에 대해 상자 그림을 만들 거나 사용할 열을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8ffe321aef10292008ce1489645fe86a84dc1e" translate="yes" xml:space="preserve">
          <source>Boxplots of variables distributions grouped by the values of a third variable can be created using the option &lt;code&gt;by&lt;/code&gt;. For instance:</source>
          <target state="translated">세 번째 변수의 값으로 그룹화 된 변수 분포의 상자 그림은 by 옵션 &lt;code&gt;by&lt;/code&gt; 사용하여 만들 수 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="29bb000243f005695909b0543b224a3db4e225d3" translate="yes" xml:space="preserve">
          <source>Brief primer on merge methods (relational algebra)</source>
          <target state="translated">병합 방법에 대한 간단한 입문서 (관계형 대수)</target>
        </trans-unit>
        <trans-unit id="52308f11211dd1ac661d43cfae2dc5cd35a8edc8" translate="yes" xml:space="preserve">
          <source>Broadcast across a level, matching Index values on the passed MultiIndex level</source>
          <target state="translated">전달 된 다중 인덱스 수준의 인덱스 값과 일치하는 수준에서 브로드 캐스트</target>
        </trans-unit>
        <trans-unit id="6e9ffc843b10d93241eaefde5b3725754f1680e5" translate="yes" xml:space="preserve">
          <source>Broadcast across a level, matching Index values on the passed MultiIndex level.</source>
          <target state="translated">전달 된 다중 인덱스 수준의 인덱스 값과 일치하는 수준에서 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="47550322284ff870e2b13609f5cf42fa9c88240f" translate="yes" xml:space="preserve">
          <source>Broadcast result of the transformation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce9e4479d8cdea2aa38baf1a05a1b5769573c13" translate="yes" xml:space="preserve">
          <source>Broadcast values along this axis, if aligning two objects of different dimensions</source>
          <target state="translated">차원이 다른 두 객체를 정렬하는 경우이 축을 따라 값을 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="7a789df99e8663d910cb24e375f9d4e96df36574" translate="yes" xml:space="preserve">
          <source>Broadcast values along this axis, if aligning two objects of different dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2041dad0385130472aa38e9a5731188d130d6c64" translate="yes" xml:space="preserve">
          <source>Broadcasting behavior between higher- (e.g. DataFrame) and lower-dimensional (e.g. Series) objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a1d2a406525265da4b4a94b199835b01e2c242" translate="yes" xml:space="preserve">
          <source>Buffer to write to.</source>
          <target state="translated">쓸 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="df097c1839d8f2d1d0b45b61a1fad63542067dab" translate="yes" xml:space="preserve">
          <source>Buffer to write to. If None, the output is returned as a string.</source>
          <target state="translated">쓸 버퍼입니다. None이면 출력이 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="368d060d1a46cde86273301cc77625cef0c36051" translate="yes" xml:space="preserve">
          <source>Bug report function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35d94d9fb34f3e421990757c2e9c3f3810b2803" translate="yes" xml:space="preserve">
          <source>Bug reports and enhancement requests</source>
          <target state="translated">버그 보고서 및 개선 요청</target>
        </trans-unit>
        <trans-unit id="a4ab496194272dfc9dfa8b272a6e165f5f1e010c" translate="yes" xml:space="preserve">
          <source>Bug reports are an important part of making &lt;em&gt;pandas&lt;/em&gt; more stable. Having a complete bug report will allow others to reproduce the bug and provide insight into fixing. See &lt;a href=&quot;https://stackoverflow.com/help/mcve&quot;&gt;this stackoverflow article&lt;/a&gt; and &lt;a href=&quot;http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports&quot;&gt;this blogpost&lt;/a&gt; for tips on writing a good bug report.</source>
          <target state="translated">버그 보고서는 &lt;em&gt;팬더를&lt;/em&gt; 보다 안정적 으로 만드는 데 중요한 부분입니다 . 완전한 버그 보고서를 작성하면 다른 사람들이 버그를 재현하고 수정에 대한 통찰력을 제공 할 수 있습니다. 참조 &lt;a href=&quot;https://stackoverflow.com/help/mcve&quot;&gt;이 유래 기사&lt;/a&gt; 와 &lt;a href=&quot;http://matthewrocklin.com/blog/work/2018/02/28/minimal-bug-reports&quot;&gt;이 블로그 게시물&lt;/a&gt; 좋은 버그 리포트를 작성하는 팁을.</target>
        </trans-unit>
        <trans-unit id="d6ffb54583c93a5c37eed48b29b14791e00518de" translate="yes" xml:space="preserve">
          <source>Bug reports must:</source>
          <target state="translated">버그 리포트는 :</target>
        </trans-unit>
        <trans-unit id="6939921e7058714b7d7daabe0956cc9c18239021" translate="yes" xml:space="preserve">
          <source>Build and install pandas</source>
          <target state="translated">팬더 빌드 및 설치</target>
        </trans-unit>
        <trans-unit id="a83219ecb58983f691ff0da5e97811189739c34e" translate="yes" xml:space="preserve">
          <source>Building Styles Summary</source>
          <target state="translated">건물 스타일 요약</target>
        </trans-unit>
        <trans-unit id="777f0cff593e574750b2f25949f15eaad9886ef9" translate="yes" xml:space="preserve">
          <source>Building criteria</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233e4088744766fe25ce63da13f185d5e74832f9" translate="yes" xml:space="preserve">
          <source>Building master branch documentation</source>
          <target state="translated">마스터 지점 문서 작성</target>
        </trans-unit>
        <trans-unit id="0ce9c4f324a40b6546390a83b25a305089ac3db2" translate="yes" xml:space="preserve">
          <source>Building styles</source>
          <target state="translated">건물 스타일</target>
        </trans-unit>
        <trans-unit id="ac827cc13e078ada5ddfe46b0f806978b51bf586" translate="yes" xml:space="preserve">
          <source>Building the documentation</source>
          <target state="translated">문서 작성</target>
        </trans-unit>
        <trans-unit id="9bd4120957934bd2a1de97a101b5f591bc61c7ce" translate="yes" xml:space="preserve">
          <source>Builtin style functions: style functions that are methods on &lt;code&gt;Styler&lt;/code&gt;</source>
          <target state="translated">내장 스타일 함수 : &lt;code&gt;Styler&lt;/code&gt; 의 메소드 인 스타일 함수</target>
        </trans-unit>
        <trans-unit id="3d96d520546578343b9168251f31f50b6c392165" translate="yes" xml:space="preserve">
          <source>Builtin styles</source>
          <target state="translated">내장 스타일</target>
        </trans-unit>
        <trans-unit id="872e64e0d2d23fe2d59d73039387e3838ab9313c" translate="yes" xml:space="preserve">
          <source>Business hour</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935629b390eec3d2484049f90b0b65397dde0244" translate="yes" xml:space="preserve">
          <source>BusinessDay</source>
          <target state="translated">BusinessDay</target>
        </trans-unit>
        <trans-unit id="1783f25a9f385e15220ea7c4ec375b1b0b91a708" translate="yes" xml:space="preserve">
          <source>BusinessDay.apply()</source>
          <target state="translated">BusinessDay.apply()</target>
        </trans-unit>
        <trans-unit id="cc63930cda9d999809d2d02fa1a100e7f64a401d" translate="yes" xml:space="preserve">
          <source>BusinessDay.apply_index()</source>
          <target state="translated">BusinessDay.apply_index()</target>
        </trans-unit>
        <trans-unit id="0b89f384e1789d3fda45ddde884a48b6a7c6b4f8" translate="yes" xml:space="preserve">
          <source>BusinessDay.base</source>
          <target state="translated">BusinessDay.base</target>
        </trans-unit>
        <trans-unit id="ea3d018a7f06b4daa4abaa96b48ff750d2a7a3c9" translate="yes" xml:space="preserve">
          <source>BusinessDay.copy()</source>
          <target state="translated">BusinessDay.copy()</target>
        </trans-unit>
        <trans-unit id="5765617819c468117ed6b34269d06090100ed6ce" translate="yes" xml:space="preserve">
          <source>BusinessDay.freqstr</source>
          <target state="translated">BusinessDay.freqstr</target>
        </trans-unit>
        <trans-unit id="70dae1ab2ec500b06ab4ac87d9b906080e29be98" translate="yes" xml:space="preserve">
          <source>BusinessDay.isAnchored()</source>
          <target state="translated">BusinessDay.isAnchored()</target>
        </trans-unit>
        <trans-unit id="c9ec9551d3161fc8818424138a3c3853db6b919a" translate="yes" xml:space="preserve">
          <source>BusinessDay.kwds</source>
          <target state="translated">BusinessDay.kwds</target>
        </trans-unit>
        <trans-unit id="ab5f2d3898ff7d52d978faa9bb68d9c57fd241da" translate="yes" xml:space="preserve">
          <source>BusinessDay.name</source>
          <target state="translated">BusinessDay.name</target>
        </trans-unit>
        <trans-unit id="972d6b2a3fc2cd3c032fa77e87eba0600ee55ded" translate="yes" xml:space="preserve">
          <source>BusinessDay.nanos</source>
          <target state="translated">BusinessDay.nanos</target>
        </trans-unit>
        <trans-unit id="018f680e45fd8cf1a4dfea4c312a0f7fc74c16e3" translate="yes" xml:space="preserve">
          <source>BusinessDay.normalize</source>
          <target state="translated">BusinessDay.normalize</target>
        </trans-unit>
        <trans-unit id="b4f765db67f4c745d69c9bd9bb90f6c379da2c65" translate="yes" xml:space="preserve">
          <source>BusinessDay.offset</source>
          <target state="translated">BusinessDay.offset</target>
        </trans-unit>
        <trans-unit id="d7b74f817db5458b1da2962225177f049f99fc86" translate="yes" xml:space="preserve">
          <source>BusinessDay.onOffset()</source>
          <target state="translated">BusinessDay.onOffset()</target>
        </trans-unit>
        <trans-unit id="c422f7d85847a20433e9eadfb3eb320bac30cf97" translate="yes" xml:space="preserve">
          <source>BusinessDay.rollback()</source>
          <target state="translated">BusinessDay.rollback()</target>
        </trans-unit>
        <trans-unit id="296a6b2ab68578bebb7d1429c526b8600be1b0a0" translate="yes" xml:space="preserve">
          <source>BusinessDay.rollforward()</source>
          <target state="translated">BusinessDay.rollforward()</target>
        </trans-unit>
        <trans-unit id="c0f21ea00a491cde49e5ebdebbbf7f6bf52a3f9b" translate="yes" xml:space="preserve">
          <source>BusinessDay.rule_code</source>
          <target state="translated">BusinessDay.rule_code</target>
        </trans-unit>
        <trans-unit id="d79d814a814f9f2b1ec74ae659ddf0a5df6be0d2" translate="yes" xml:space="preserve">
          <source>BusinessHour</source>
          <target state="translated">BusinessHour</target>
        </trans-unit>
        <trans-unit id="667a05aa5fc944599927485cd4387b0f59cc03c3" translate="yes" xml:space="preserve">
          <source>BusinessHour.apply()</source>
          <target state="translated">BusinessHour.apply()</target>
        </trans-unit>
        <trans-unit id="8d4f38a4434c1baee272eddadec6f7da6db7126f" translate="yes" xml:space="preserve">
          <source>BusinessHour.apply_index()</source>
          <target state="translated">BusinessHour.apply_index()</target>
        </trans-unit>
        <trans-unit id="17b2c5e8ddf99e7fe071c97d9a8b82cd4378f43f" translate="yes" xml:space="preserve">
          <source>BusinessHour.base</source>
          <target state="translated">BusinessHour.base</target>
        </trans-unit>
        <trans-unit id="75dc37b0eb9341c041399e7eabe82b274c143127" translate="yes" xml:space="preserve">
          <source>BusinessHour.copy()</source>
          <target state="translated">BusinessHour.copy()</target>
        </trans-unit>
        <trans-unit id="d263183636d8500111d6d82cb40f081c391a5d47" translate="yes" xml:space="preserve">
          <source>BusinessHour.freqstr</source>
          <target state="translated">BusinessHour.freqstr</target>
        </trans-unit>
        <trans-unit id="ceca3248d259c3aee4d1db08d3afbe9bbb3e84f4" translate="yes" xml:space="preserve">
          <source>BusinessHour.isAnchored()</source>
          <target state="translated">BusinessHour.isAnchored()</target>
        </trans-unit>
        <trans-unit id="b0843b8f2c969b86ac6714add264e8e139894df0" translate="yes" xml:space="preserve">
          <source>BusinessHour.kwds</source>
          <target state="translated">BusinessHour.kwds</target>
        </trans-unit>
        <trans-unit id="093ae334e4d42821d51b95f3ba26b69f76d74d85" translate="yes" xml:space="preserve">
          <source>BusinessHour.name</source>
          <target state="translated">BusinessHour.name</target>
        </trans-unit>
        <trans-unit id="f9c4af650f260c9e9458b14a2a49f150f81fc298" translate="yes" xml:space="preserve">
          <source>BusinessHour.nanos</source>
          <target state="translated">BusinessHour.nanos</target>
        </trans-unit>
        <trans-unit id="e2e401e4adbb05da8c7578950c105fc77a0b99b9" translate="yes" xml:space="preserve">
          <source>BusinessHour.next_bday</source>
          <target state="translated">BusinessHour.next_bday</target>
        </trans-unit>
        <trans-unit id="2f7bd7b25d02e873d0680c78918511cd2440449f" translate="yes" xml:space="preserve">
          <source>BusinessHour.normalize</source>
          <target state="translated">BusinessHour.normalize</target>
        </trans-unit>
        <trans-unit id="55997971d70ddc97c5beeb830b001c9df21fa78d" translate="yes" xml:space="preserve">
          <source>BusinessHour.offset</source>
          <target state="translated">BusinessHour.offset</target>
        </trans-unit>
        <trans-unit id="dad6a169f51729e4958f03975d08350bf374cf02" translate="yes" xml:space="preserve">
          <source>BusinessHour.onOffset()</source>
          <target state="translated">BusinessHour.onOffset()</target>
        </trans-unit>
        <trans-unit id="0f1337fc2d214aaab0b2421a34cbc6ed4eaecc32" translate="yes" xml:space="preserve">
          <source>BusinessHour.rollback()</source>
          <target state="translated">BusinessHour.rollback()</target>
        </trans-unit>
        <trans-unit id="ad049355ce9c6e01cc3f8af0705ba5f89802a8c6" translate="yes" xml:space="preserve">
          <source>BusinessHour.rollforward()</source>
          <target state="translated">BusinessHour.rollforward()</target>
        </trans-unit>
        <trans-unit id="09ddcc1eebde9bcefd98f26f30a3e6bab8899bfb" translate="yes" xml:space="preserve">
          <source>BusinessHour.rule_code</source>
          <target state="translated">BusinessHour.rule_code</target>
        </trans-unit>
        <trans-unit id="ecc54d8554088c18ea99f68a14aaaa510e545301" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin</source>
          <target state="translated">BusinessMonthBegin</target>
        </trans-unit>
        <trans-unit id="3b04d4046eee0f4b086e00dfbfbedaf41630d8b4" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.apply()</source>
          <target state="translated">BusinessMonthBegin.apply()</target>
        </trans-unit>
        <trans-unit id="8310d740e1145f6b64d5b06f9d600ac6a35c3589" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.apply_index()</source>
          <target state="translated">BusinessMonthBegin.apply_index()</target>
        </trans-unit>
        <trans-unit id="6a0e5007f04cdd6aaa2ad0f4605653f092b83de1" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.base</source>
          <target state="translated">BusinessMonthBegin.base</target>
        </trans-unit>
        <trans-unit id="0f8685980c4542c63d7ef33b50c4941d0085c380" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.copy()</source>
          <target state="translated">BusinessMonthBegin.copy()</target>
        </trans-unit>
        <trans-unit id="8a3933d048ae7b49d7cbffdea703f91c8304719d" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.freqstr</source>
          <target state="translated">BusinessMonthBegin.freqstr</target>
        </trans-unit>
        <trans-unit id="eadc1660f6f37d65886533e8c836be0345125b10" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.isAnchored()</source>
          <target state="translated">BusinessMonthBegin.isAnchored()</target>
        </trans-unit>
        <trans-unit id="8f775117e3d2d9b3d1e3ab3cb3607da50368f87c" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.kwds</source>
          <target state="translated">BusinessMonthBegin.kwds</target>
        </trans-unit>
        <trans-unit id="25feedbaa46b83106de019a064167e6717edaf20" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.name</source>
          <target state="translated">BusinessMonthBegin.name</target>
        </trans-unit>
        <trans-unit id="c13fcc7606515cf41c6193d5f9268db2440aa587" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.nanos</source>
          <target state="translated">BusinessMonthBegin.nanos</target>
        </trans-unit>
        <trans-unit id="f3f6922e73906e42d265ad23d7be0fa10860cd24" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.normalize</source>
          <target state="translated">BusinessMonthBegin.normalize</target>
        </trans-unit>
        <trans-unit id="3123b8822fd6578b6c8951bd627b4a686193e386" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.onOffset()</source>
          <target state="translated">BusinessMonthBegin.onOffset()</target>
        </trans-unit>
        <trans-unit id="4249607ebda76c678b5831b4130b4518ea76e802" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.rollback()</source>
          <target state="translated">BusinessMonthBegin.rollback()</target>
        </trans-unit>
        <trans-unit id="83559ec26b3115ab310b5b7215ca3068027417ad" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.rollforward()</source>
          <target state="translated">BusinessMonthBegin.rollforward()</target>
        </trans-unit>
        <trans-unit id="c14d592ac07e12570c56e9e0a4bce9772e6b95ba" translate="yes" xml:space="preserve">
          <source>BusinessMonthBegin.rule_code</source>
          <target state="translated">BusinessMonthBegin.rule_code</target>
        </trans-unit>
        <trans-unit id="b4d94da0e612d53d740022f4e81348ce5cd9b4c6" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd</source>
          <target state="translated">BusinessMonthEnd</target>
        </trans-unit>
        <trans-unit id="f63220872722e4b907275af8521ee956d0edbcb2" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.apply()</source>
          <target state="translated">BusinessMonthEnd.apply()</target>
        </trans-unit>
        <trans-unit id="93ff73d790246ceaa8e543c66dcf1d8aff2484a5" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.apply_index()</source>
          <target state="translated">BusinessMonthEnd.apply_index()</target>
        </trans-unit>
        <trans-unit id="1e2d33720bff64f9ce5ace35511e6d55cabd833a" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.base</source>
          <target state="translated">BusinessMonthEnd.base</target>
        </trans-unit>
        <trans-unit id="c34e5f5118ecb11f5ac666d8aaf7487a2ef3cdb6" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.copy()</source>
          <target state="translated">BusinessMonthEnd.copy()</target>
        </trans-unit>
        <trans-unit id="cf0d854810094b551c1ba7a1b81f5a3deac4adf7" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.freqstr</source>
          <target state="translated">BusinessMonthEnd.freqstr</target>
        </trans-unit>
        <trans-unit id="2a1616dcf8cf64f9e012dd9fb6f5ba273076a5a8" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.isAnchored()</source>
          <target state="translated">BusinessMonthEnd.isAnchored()</target>
        </trans-unit>
        <trans-unit id="37659218f13b60ddced35090ed6d7dcbb1446f98" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.kwds</source>
          <target state="translated">BusinessMonthEnd.kwds</target>
        </trans-unit>
        <trans-unit id="5d24f45ad31d4820f7d8a7f34217052eed864d6d" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.name</source>
          <target state="translated">BusinessMonthEnd.name</target>
        </trans-unit>
        <trans-unit id="417c600d94038d028f88e414d494d823c8e9cbee" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.nanos</source>
          <target state="translated">BusinessMonthEnd.nanos</target>
        </trans-unit>
        <trans-unit id="30bd20fe9d2c9130d0aaa8fec3ef25fc6a4c6959" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.normalize</source>
          <target state="translated">BusinessMonthEnd.normalize</target>
        </trans-unit>
        <trans-unit id="b8c6ec6758dc12908db900138a9c8a03623b682d" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.onOffset()</source>
          <target state="translated">BusinessMonthEnd.onOffset()</target>
        </trans-unit>
        <trans-unit id="ee0c230238853c8292a8516de8210849afef9c4a" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.rollback()</source>
          <target state="translated">BusinessMonthEnd.rollback()</target>
        </trans-unit>
        <trans-unit id="71eb4f303d2a973a726a2a4a1cbe1cc2b6f5bb2d" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.rollforward()</source>
          <target state="translated">BusinessMonthEnd.rollforward()</target>
        </trans-unit>
        <trans-unit id="996e142c13feb8da325e4518c8e6af70549077a9" translate="yes" xml:space="preserve">
          <source>BusinessMonthEnd.rule_code</source>
          <target state="translated">BusinessMonthEnd.rule_code</target>
        </trans-unit>
        <trans-unit id="c697f9d39b1dadd1220f166ecf34f2aabcb19b19" translate="yes" xml:space="preserve">
          <source>But clearly this isn&amp;rsquo;t fast enough for us. Let&amp;rsquo;s take a look and see where the time is spent during this operation (limited to the most time consuming four calls) using the &lt;a href=&quot;http://ipython.org/ipython-doc/stable/api/generated/IPython.core.magics.execution.html#IPython.core.magics.execution.ExecutionMagics.prun&quot;&gt;prun ipython magic function&lt;/a&gt;:</source>
          <target state="translated">그러나 분명히 이것은 우리에게 충분하지 않습니다. &lt;a href=&quot;http://ipython.org/ipython-doc/stable/api/generated/IPython.core.magics.execution.html#IPython.core.magics.execution.ExecutionMagics.prun&quot;&gt;prun ipython magic 함수를&lt;/a&gt; 사용하여이 작업 중에 시간이 소비되는 위치 (네 번의 호출에 가장 많은 시간으로 제한됨)를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c48f096fe6bb21672f881921466be545807bd00c" translate="yes" xml:space="preserve">
          <source>But clearly this isn&amp;rsquo;t fast enough for us. Let&amp;rsquo;s take a look and see where the time is spent during this operation (limited to the most time consuming four calls) using the &lt;a href=&quot;https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-prun&quot;&gt;prun ipython magic function&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8ca831478a6df33d6c8ed3d365c2b9fb5fab2d" translate="yes" xml:space="preserve">
          <source>But first, it&amp;rsquo;s worth considering &lt;em&gt;not using pandas&lt;/em&gt;. pandas isn&amp;rsquo;t the right tool for all situations. If you&amp;rsquo;re working with very large datasets and a tool like PostgreSQL fits your needs, then you should probably be using that. Assuming you want or need the expressiveness and power of pandas, let&amp;rsquo;s carry on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515d260916cde6de73eb736d451faf9682456694" translate="yes" xml:space="preserve">
          <source>But it turns out that assigning to the product of chained indexing has inherently unpredictable results. To see this, think about how the Python interpreter executes this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ba631a49a65341531cbcdb54e0dc6f8abdacf9" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s better to avoid applymap in that case.</source>
          <target state="translated">그러나이 경우에는 applymap을 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="32938515c899eb3e4418b898186ca4a99f113a3d" translate="yes" xml:space="preserve">
          <source>But rather, use &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;Series.to_numpy()&lt;/code&gt;&lt;/a&gt; to get the underlying &lt;code&gt;ndarray&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;Series.to_numpy()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 기본 &lt;code&gt;ndarray&lt;/code&gt; 를 얻으십시오 .</target>
        </trans-unit>
        <trans-unit id="4558d1a4b86f04724ec8d5c6cf11cdc7aa298b9c" translate="yes" xml:space="preserve">
          <source>But slicing &lt;code&gt;'A'&lt;/code&gt; returns a &lt;code&gt;DataFrame&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a15cce834d743eabb2d51100ec2353785344643" translate="yes" xml:space="preserve">
          <source>But suppose we wish to do time series operations with the variables. A better representation would be where the &lt;code&gt;columns&lt;/code&gt; are the unique variables and an &lt;code&gt;index&lt;/code&gt; of dates identifies individual observations. To reshape the data into this form, we use the &lt;a href=&quot;../reference/api/pandas.dataframe.pivot#pandas.DataFrame.pivot&quot;&gt;&lt;code&gt;DataFrame.pivot()&lt;/code&gt;&lt;/a&gt; method (also implemented as a top level function &lt;a href=&quot;../reference/api/pandas.pivot#pandas.pivot&quot;&gt;&lt;code&gt;pivot()&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">그러나 변수를 사용하여 시계열 연산을 수행한다고 가정하십시오. &lt;code&gt;columns&lt;/code&gt; 이 고유 한 변수이고 날짜 &lt;code&gt;index&lt;/code&gt; 가 개별 관측치를 식별 하는 위치를 더 잘 표현할 수 있습니다 . 데이터를이 형식으로 재구성하려면 &lt;a href=&quot;../reference/api/pandas.dataframe.pivot#pandas.DataFrame.pivot&quot;&gt; &lt;code&gt;DataFrame.pivot()&lt;/code&gt; &lt;/a&gt; 메서드 (최상위 함수 &lt;a href=&quot;../reference/api/pandas.pivot#pandas.pivot&quot;&gt; &lt;code&gt;pivot()&lt;/code&gt; &lt;/a&gt; 으로도 구현 됨 )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a01152d94ee20841c94569c44053d7b5f2419fc2" translate="yes" xml:space="preserve">
          <source>But this code is handled differently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74231619a21f1c4733a38080ec29d5525701d7d" translate="yes" xml:space="preserve">
          <source>But, it&amp;rsquo;s rather verbose and can be untidy if you need to pass additional arguments. Using a bit of metaprogramming cleverness, GroupBy now has the ability to &amp;ldquo;dispatch&amp;rdquo; method calls to the groups:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3ad5d1ad065d8cbcaad955862729d89b418d02" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;group by&amp;rdquo; we are referring to a process involving one or more of the following steps:</source>
          <target state="translated">&quot;그룹화&quot;는 다음 단계 중 하나 이상을 포함하는 프로세스를 말합니다.</target>
        </trans-unit>
        <trans-unit id="a39e1e6dfd224e52ae9e307f2bc2e41b31af593c" translate="yes" xml:space="preserve">
          <source>By converting an existing &lt;code&gt;Series&lt;/code&gt; or column to a &lt;code&gt;category&lt;/code&gt; dtype:</source>
          <target state="translated">기존 &lt;code&gt;Series&lt;/code&gt; 또는 열을 &lt;code&gt;category&lt;/code&gt; dtype으로 변환하여 :</target>
        </trans-unit>
        <trans-unit id="e5838ce09c94d7654c93b358711beb0b899479d6" translate="yes" xml:space="preserve">
          <source>By converting to an object array of Timestamps, it preserves the time zone information. For example, when converting back to a Series:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01adc7e0359a60f85839ade2c482344c9e5154f2" translate="yes" xml:space="preserve">
          <source>By default (if you don&amp;rsquo;t specify &lt;code&gt;dtype&lt;/code&gt;), NumPy is used, and you&amp;rsquo;ll end up with a &lt;code&gt;float64&lt;/code&gt; dtype Series:</source>
          <target state="translated">기본적으로 ( &lt;code&gt;dtype&lt;/code&gt; 을 지정하지 않으면 ) NumPy가 사용되며 &lt;code&gt;float64&lt;/code&gt; dtype Series가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3c4439424daec8735287bf351da1049b4ef7cbb8" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;NA&lt;/code&gt; values are excluded from group keys during the &lt;code&gt;groupby&lt;/code&gt; operation. However, in case you want to include &lt;code&gt;NA&lt;/code&gt; values in group keys, you could pass &lt;code&gt;dropna=False&lt;/code&gt; to achieve it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aabacc286aafebfdf91bcb8e2955cf85e7c22cf5" translate="yes" xml:space="preserve">
          <source>By default NaNs are put at the end, but use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d06ecc791717f632c29fd787978c42dc76ae12" translate="yes" xml:space="preserve">
          <source>By default NaNs are put at the end, but use &lt;code&gt;na_position&lt;/code&gt; to place them at the beginning</source>
          <target state="translated">기본적으로 NaN은 끝에 배치 되지만 &lt;code&gt;na_position&lt;/code&gt; 을 사용 하여 시작에 배치합니다</target>
        </trans-unit>
        <trans-unit id="d931c676b175c2e8cf9c3de4403e8c715a39bbaa" translate="yes" xml:space="preserve">
          <source>By default a &lt;a href=&quot;../reference/api/pandas.float64index#pandas.Float64Index&quot;&gt;&lt;code&gt;Float64Index&lt;/code&gt;&lt;/a&gt; will be automatically created when passing floating, or mixed-integer-floating values in index creation. This enables a pure label-based slicing paradigm that makes &lt;code&gt;[],ix,loc&lt;/code&gt; for scalar indexing and slicing work exactly the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e897b82cbef804f4c65fda4cbb144b50dcb76763" translate="yes" xml:space="preserve">
          <source>By default integer types are &lt;code&gt;int64&lt;/code&gt; and float types are &lt;code&gt;float64&lt;/code&gt;, &lt;em&gt;regardless&lt;/em&gt; of platform (32-bit or 64-bit). The following will all result in &lt;code&gt;int64&lt;/code&gt; dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062f4f4967acf3f9b81bcd83c4905eaa47f6679e" translate="yes" xml:space="preserve">
          <source>By default new columns will have &lt;code&gt;np.uint8&lt;/code&gt; dtype. To choose another dtype, use the &lt;code&gt;dtype&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c70123161ac84535dccfbf668ca0b92c905eacd" translate="yes" xml:space="preserve">
          <source>By default the display option is set to &lt;code&gt;True&lt;/code&gt; but can be explicitly overridden by passing the &lt;code&gt;memory_usage&lt;/code&gt; argument when invoking &lt;code&gt;df.info()&lt;/code&gt;.</source>
          <target state="translated">기본적으로 표시 옵션은 &lt;code&gt;True&lt;/code&gt; 로 설정되어 있지만 &lt;code&gt;df.info()&lt;/code&gt; 호출 할 때 &lt;code&gt;memory_usage&lt;/code&gt; 인수 를 전달하여 명시 적으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa98df1fa88fb86a70e1129c2b42bc8712f4b1b7" translate="yes" xml:space="preserve">
          <source>By default the group keys are sorted during the &lt;code&gt;groupby&lt;/code&gt; operation. You may however pass &lt;code&gt;sort=False&lt;/code&gt; for potential speedups:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a1710309fea69365770112b6581fe169c63605" translate="yes" xml:space="preserve">
          <source>By default the keys of the dict become the DataFrame columns:</source>
          <target state="translated">기본적으로 dict의 키는 DataFrame 열이됩니다.</target>
        </trans-unit>
        <trans-unit id="b0adde66c844a2a2964f3ce00f26b208447445d7" translate="yes" xml:space="preserve">
          <source>By default the labels are set to the right edge of the window, but a &lt;code&gt;center&lt;/code&gt; keyword is available so the labels can be set at the center.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dec236557b8f06b4e564494bb4e1a63434f314d" translate="yes" xml:space="preserve">
          <source>By default the memory usage of the &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s index is shown in the returned &lt;code&gt;Series&lt;/code&gt;, the memory usage of the index can be suppressed by passing the &lt;code&gt;index=False&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce247952cb8711d7922f7360888deb042b50567e" translate="yes" xml:space="preserve">
          <source>By default the parser removes the component date columns, but you can choose to retain them via the &lt;code&gt;keep_date_col&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3309043dd87fc9cec057a0a1137b28733c920f79" translate="yes" xml:space="preserve">
          <source>By default we are taking the asof of the quotes</source>
          <target state="translated">기본적으로 우리는 따옴표를 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2d34bf7db8b99571959e34c842fede5fccb464de" translate="yes" xml:space="preserve">
          <source>By default we are taking the asof of the quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1340caad148f1baf3252d2bf2dd252131035cd24" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;BusinessHour&lt;/code&gt; uses 9:00 - 17:00 as business hours. Adding &lt;code&gt;BusinessHour&lt;/code&gt; will increment &lt;code&gt;Timestamp&lt;/code&gt; by hourly frequency. If target &lt;code&gt;Timestamp&lt;/code&gt; is out of business hours, move to the next business hour then increment it. If the result exceeds the business hours end, the remaining hours are added to the next business day.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08977435ad2d3323377d558af4046df6e0cc2e7a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;NaN&lt;/code&gt; values are filled in a &lt;code&gt;forward&lt;/code&gt; direction. Use &lt;code&gt;limit_direction&lt;/code&gt; parameter to fill &lt;code&gt;backward&lt;/code&gt; or from &lt;code&gt;both&lt;/code&gt; directions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daaf9dfe51d985994c78a78a6d1aed67ed0a5d4" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;NaN&lt;/code&gt; values are filled whether they are inside (surrounded by) existing valid values, or outside existing valid values. The &lt;code&gt;limit_area&lt;/code&gt; parameter restricts filling to either inside or outside values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b34e028283b0a0d6a01d13c796f6b27e33c513" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;convert_dtypes&lt;/code&gt; will attempt to convert a Series (or each Series in a DataFrame) to dtypes that support &lt;code&gt;pd.NA&lt;/code&gt;. By using the options &lt;code&gt;convert_string&lt;/code&gt;, &lt;code&gt;convert_integer&lt;/code&gt;, &lt;code&gt;convert_boolean&lt;/code&gt; and &lt;code&gt;convert_boolean&lt;/code&gt;, it is possible to turn off individual conversions to &lt;code&gt;StringDtype&lt;/code&gt;, the integer extension types, &lt;code&gt;BooleanDtype&lt;/code&gt; or floating extension types, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a4fa928a3e297e323b6cd143f237a1d5c0f0c6" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;dask.dataframe&lt;/code&gt; operations use a threadpool to do operations in parallel. We can also connect to a cluster to distribute the work on many machines. In this case we&amp;rsquo;ll connect to a local &amp;ldquo;cluster&amp;rdquo; made up of several processes on this single machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04d0a928bca2c90083138cbd998c3db569f61a8" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;read_csv&lt;/code&gt; uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e316e9976df4161ef7d97614a2f74833517fd1b2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;read_fwf&lt;/code&gt; will try to infer the file&amp;rsquo;s &lt;code&gt;colspecs&lt;/code&gt; by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided &lt;code&gt;delimiter&lt;/code&gt; (default delimiter is whitespace).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693e799ca877ea4e198db2f6c4c79704a7045d0e" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;sample&lt;/code&gt; will return each row at most once, but one can also sample with replacement using the &lt;code&gt;replace&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e3abc4ca3ee473e8fb372c7ec1cf7f1e564bef" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;where&lt;/code&gt; returns a modified copy of the data. There is an optional parameter &lt;code&gt;inplace&lt;/code&gt; so that the original data can be modified without creating a copy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6201125d9209238d2433714dcff1f4f6221a3bbb" translate="yes" xml:space="preserve">
          <source>By default, ExtensionArrays are not hashable. Immutable subclasses may override this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f8438416c9e7646bc0a30016edf1e39b53ee108" translate="yes" xml:space="preserve">
          <source>By default, NA values are ignored.</source>
          <target state="translated">기본적으로 NA 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7e64270efc9e1e6a3600f61cd03200247a11090d" translate="yes" xml:space="preserve">
          <source>By default, NA values in the Series are ignored. Using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12265640338ad9cf4267b696443e1a968ed6d2a" translate="yes" xml:space="preserve">
          <source>By default, NA values in the Series are ignored. Using &lt;code&gt;na_rep&lt;/code&gt;, they can be given a representation:</source>
          <target state="translated">기본적으로 Series의 NA 값은 무시됩니다. &lt;code&gt;na_rep&lt;/code&gt; 을 사용하면 다음과 같이 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="256e58f854131ef5c37b519e638c3542260c29f3" translate="yes" xml:space="preserve">
          <source>By default, a histogram of the counts around each &lt;code&gt;(x, y)&lt;/code&gt; point is computed. You can specify alternative aggregations by passing values to the &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;reduce_C_function&lt;/code&gt; arguments. &lt;code&gt;C&lt;/code&gt; specifies the value at each &lt;code&gt;(x, y)&lt;/code&gt; point and &lt;code&gt;reduce_C_function&lt;/code&gt; is a function of one argument that reduces all the values in a bin to a single number (e.g. &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;std&lt;/code&gt;). In this example the positions are given by columns &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, while the value is given by column &lt;code&gt;z&lt;/code&gt;. The bins are aggregated with NumPy&amp;rsquo;s &lt;code&gt;max&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a62362e9ff12c226e3b4e9925328c62e64637ef" translate="yes" xml:space="preserve">
          <source>By default, an &amp;ldquo;Ambiguous&amp;rdquo; character&amp;rsquo;s width, such as &amp;ldquo;&amp;iexcl;&amp;rdquo; (inverted exclamation) in the example below, is taken to be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7909d660888d2baa10b3a5ae7e4bee9c5966e9d6" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated object. If copy is set to False and internal requirements on dtype are satisfied, the original data is used to create a new Index or the original Index is returned.</source>
          <target state="translated">기본적으로 astype은 항상 새로 할당 된 객체를 반환합니다. copy가 False로 설정되고 dtype의 내부 요구 사항이 충족되면 원본 데이터를 사용하여 새 인덱스를 만들거나 원래 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a20003412b6c9cf02b25e1df4c7702704b92baf" translate="yes" xml:space="preserve">
          <source>By default, columns get inserted at the end. The &lt;code&gt;insert&lt;/code&gt; function is available to insert at a particular location in the columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e756a89cd949fe162e519ad9c13f140f9e1f8db9" translate="yes" xml:space="preserve">
          <source>By default, combining &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrames&lt;/code&gt; which contain the same categories results in &lt;code&gt;category&lt;/code&gt; dtype, otherwise results will depend on the dtype of the underlying categories. Merges that result in non-categorical dtypes will likely have higher memory usage. Use &lt;code&gt;.astype&lt;/code&gt; or &lt;code&gt;union_categoricals&lt;/code&gt; to ensure &lt;code&gt;category&lt;/code&gt; results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3dda3261727d8a3ccfff8795d3e7f0219ed5af" translate="yes" xml:space="preserve">
          <source>By default, each row has an equal probability of being selected, but if you want rows to have different probabilities, you can pass the &lt;code&gt;sample&lt;/code&gt; function sampling weights as &lt;code&gt;weights&lt;/code&gt;. These weights can be a list, a NumPy array, or a Series, but they must be of the same length as the object you are sampling. Missing values will be treated as a weight of zero, and inf values are not allowed. If weights do not sum to 1, they will be re-normalized by dividing all weights by the sum of the weights. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca53cd02ae5e6785460debb4d4e721d53e196cb" translate="yes" xml:space="preserve">
          <source>By default, equal values are assigned a rank that is the average of the ranks of those values.</source>
          <target state="translated">기본적으로 동일한 값에는 해당 값의 평균 순위 인 순위가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="3fdaa285fe423146b7e6b7f5beb4a32fafe70dee" translate="yes" xml:space="preserve">
          <source>By default, for each set of duplicated values, the first occurrence is set on False and all others on True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40571deae9486030a562d81e703e1f060e8aa2ec" translate="yes" xml:space="preserve">
          <source>By default, for each set of duplicated values, the first occurrence is set on False and all others on True:</source>
          <target state="translated">기본적으로 각 중복 값 세트에 대해 첫 번째 발생은 False로 설정되고 다른 모든 값은 True로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5d1dce940f1b44f893bdc84bf6ada06675ad9cca" translate="yes" xml:space="preserve">
          <source>By default, for each set of duplicated values, the first occurrence is set to False and all others to True:</source>
          <target state="translated">기본적으로 각 중복 값 세트에 대해 첫 번째 발생은 False로 설정되고 나머지는 모두 True로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cc78d782a98f40933a5748269b6f2dbe7d2fa892" translate="yes" xml:space="preserve">
          <source>By default, if two corresponding values are equal, they will be shown as &lt;code&gt;NaN&lt;/code&gt;. Furthermore, if all values in an entire row / column, the row / column will be omitted from the result. The remaining differences will be aligned on columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418bbaae1a86eb20c86f38b29c4f75943e2f17bf" translate="yes" xml:space="preserve">
          <source>By default, in the abstract class, just the name of the type is expected. But subclasses can overwrite this method to accept parameters.</source>
          <target state="translated">기본적으로 추상 클래스에서는 유형의 이름 만 예상됩니다. 그러나 서브 클래스는이 메소드를 덮어 쓰기하여 매개 변수를 승인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c76721d2dfff1f023f6a2c3795ca3d478e28f6f" translate="yes" xml:space="preserve">
          <source>By default, it removes duplicate rows based on all columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a19f2f1b6473c5c87cd7608ffd51dd19be2a8da" translate="yes" xml:space="preserve">
          <source>By default, it returns the index for the maximum value in each column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b888f151383ac8275e4601bc2315e2bf98f8f4" translate="yes" xml:space="preserve">
          <source>By default, it returns the index for the minimum value in each column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9347fd0b06678e66b3a79c417772aa720790ce7" translate="yes" xml:space="preserve">
          <source>By default, it sorts in ascending order, to sort in descending order, use &lt;code&gt;ascending=False&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0a73dc4ec5cad042a76c1dbba0ec1b82215198" translate="yes" xml:space="preserve">
          <source>By default, iterates over rows and finds the maximum in each column. This is equivalent to &lt;code&gt;axis=None&lt;/code&gt; or &lt;code&gt;axis='index'&lt;/code&gt;.</source>
          <target state="translated">기본적으로 행을 반복하고 각 열에서 최대 값을 찾습니다. 이것은 &lt;code&gt;axis=None&lt;/code&gt; 또는 &lt;code&gt;axis='index'&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a8a683de412412c0a4069a9b28f4f2d4f9007925" translate="yes" xml:space="preserve">
          <source>By default, iterates over rows and finds the minimum in each column. This is equivalent to &lt;code&gt;axis=None&lt;/code&gt; or &lt;code&gt;axis='index'&lt;/code&gt;.</source>
          <target state="translated">기본적으로 행을 반복하고 각 열에서 최소값을 찾습니다. 이것은 &lt;code&gt;axis=None&lt;/code&gt; 또는 &lt;code&gt;axis='index'&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1639c50c70632a374cb66254268072a2e44ecf3f" translate="yes" xml:space="preserve">
          <source>By default, iterates over rows and finds the product in each column. This is equivalent to &lt;code&gt;axis=None&lt;/code&gt; or &lt;code&gt;axis='index'&lt;/code&gt;.</source>
          <target state="translated">기본적으로 행을 반복하고 각 열에서 제품을 찾습니다. 이것은 &lt;code&gt;axis=None&lt;/code&gt; 또는 &lt;code&gt;axis='index'&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="21a746c0b49750d2cc1f0c89dbd88b786bd37c49" translate="yes" xml:space="preserve">
          <source>By default, iterates over rows and finds the sum in each column. This is equivalent to &lt;code&gt;axis=None&lt;/code&gt; or &lt;code&gt;axis='index'&lt;/code&gt;.</source>
          <target state="translated">기본적으로 행을 반복하고 각 열에서 합계를 찾습니다. 이것은 &lt;code&gt;axis=None&lt;/code&gt; 또는 &lt;code&gt;axis='index'&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="afd61ab61619ac5bd92d8d9fe230e9f2a8034365" translate="yes" xml:space="preserve">
          <source>By default, missing values are ignored. Using &lt;code&gt;na_rep&lt;/code&gt;, they can be given a representation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68248fa2c7586bf043b9284f194aa1d0478263df" translate="yes" xml:space="preserve">
          <source>By default, missing values are not considered, and the mode of wings are both 0 and 2. Because the resulting DataFrame has two rows, the second row of &lt;code&gt;species&lt;/code&gt; and &lt;code&gt;legs&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3c4f268b612e4471ac10cc8e294acd2a6a25b4" translate="yes" xml:space="preserve">
          <source>By default, missing values are not considered, and the mode of wings are both 0 and 2. The second row of species and legs contains &lt;code&gt;NaN&lt;/code&gt;, because they have only one mode, but the DataFrame has two rows.</source>
          <target state="translated">기본적으로 결 측값은 고려되지 않으며 날개 모드는 0과 2입니다. 종과 다리의 두 번째 행에는 하나의 모드 만 있기 때문에 &lt;code&gt;NaN&lt;/code&gt; 이 포함 되지만 DataFrame에는 두 개의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52b104770b85bbded0c2643fae88773a9bfd3e25" translate="yes" xml:space="preserve">
          <source>By default, numbers with a thousands separator will be parsed as strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e52d7c7e2f5d2c520080c806d06efc8cc199f24" translate="yes" xml:space="preserve">
          <source>By default, one of pandas CI workers will fail if any unhandled warnings are emitted.</source>
          <target state="translated">기본적으로 처리되지 않은 경고가 발생하면 팬더 CI 작업자 중 하나가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="737934007bfe3716034e084f87e08f29eacf7ecd" translate="yes" xml:space="preserve">
          <source>By default, pandas objects are time zone unaware:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960e23b908f80388807cdaa55b08c05bb824a74f" translate="yes" xml:space="preserve">
          <source>By default, pandas uses the &lt;a href=&quot;https://xlsxwriter.readthedocs.io&quot;&gt;XlsxWriter&lt;/a&gt; for &lt;code&gt;.xlsx&lt;/code&gt;, &lt;a href=&quot;https://openpyxl.readthedocs.io/&quot;&gt;openpyxl&lt;/a&gt; for &lt;code&gt;.xlsm&lt;/code&gt;, and &lt;a href=&quot;http://www.python-excel.org&quot;&gt;xlwt&lt;/a&gt; for &lt;code&gt;.xls&lt;/code&gt; files. If you have multiple engines installed, you can set the default engine through &lt;a href=&quot;options#options&quot;&gt;setting the config options&lt;/a&gt;&lt;code&gt;io.excel.xlsx.writer&lt;/code&gt; and &lt;code&gt;io.excel.xls.writer&lt;/code&gt;. pandas will fall back on &lt;a href=&quot;https://openpyxl.readthedocs.io/&quot;&gt;openpyxl&lt;/a&gt; for &lt;code&gt;.xlsx&lt;/code&gt; files if &lt;a href=&quot;https://xlsxwriter.readthedocs.io&quot;&gt;Xlsxwriter&lt;/a&gt; is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c9b91fa70430a08196d5ba84f8b25b9fc4bda6" translate="yes" xml:space="preserve">
          <source>By default, the dtype of the returned array will be the common NumPy dtype of all types in the DataFrame. For example, if the dtypes are &lt;code&gt;float16&lt;/code&gt; and &lt;code&gt;float32&lt;/code&gt;, the results dtype will be &lt;code&gt;float32&lt;/code&gt;. This may require copying data and coercing values, which may be expensive.</source>
          <target state="translated">기본적으로 반환 된 배열의 dtype은 DataFrame에있는 모든 유형의 공통 NumPy dtype입니다. 예를 들어, dtypes가 &lt;code&gt;float16&lt;/code&gt; 및 &lt;code&gt;float32&lt;/code&gt; 이면 결과 dtype은 &lt;code&gt;float32&lt;/code&gt; 가 됩니다. 이를 위해서는 데이터를 복사하고 값을 강제해야하므로 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89550d5570c0fcb7339f2f78614453db411e74fc" translate="yes" xml:space="preserve">
          <source>By default, the first observed row of a duplicate set is considered unique, but each method has a &lt;code&gt;keep&lt;/code&gt; parameter to specify targets to be kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce7d3e3969a0e089007f5e7eb85aa458579749e" translate="yes" xml:space="preserve">
          <source>By default, the median is always included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a664e0a2ad21f5c92d66ce1bbad60609f29dc8b2" translate="yes" xml:space="preserve">
          <source>By default, the original Index and original name is reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4344cd41a25db846a02c4310caf07c5e8513ef" translate="yes" xml:space="preserve">
          <source>By default, the original Index is reused. To enforce a new Index:</source>
          <target state="translated">기본적으로 원래 색인이 재사용됩니다. 새로운 색인을 시행하려면 :</target>
        </trans-unit>
        <trans-unit id="ce60b9647ac6ad38fbfd505b418b76b26ddbd9e7" translate="yes" xml:space="preserve">
          <source>By default, the parser includes the comments in the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47018e8a9cd3ef91ff4bfe5c9fcc40df02bc384c" translate="yes" xml:space="preserve">
          <source>By default, the product of an empty or all-NA Series is &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">기본적으로 비어 있거나 모든 NA 시리즈의 제품은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6807fba437e846fc2074f6114e49c4eb4f95dacc" translate="yes" xml:space="preserve">
          <source>By default, the result is set to the right edge of the window. This can be changed to the center of the window by setting &lt;code&gt;center=True&lt;/code&gt;.</source>
          <target state="translated">기본적으로 결과는 창의 오른쪽 가장자리로 설정됩니다. &lt;code&gt;center=True&lt;/code&gt; 를 설정하여 창의 중심으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0366bda9ea758a7ac62f36776d68fe488644ddd" translate="yes" xml:space="preserve">
          <source>By default, the resulting categories will be ordered as they appear in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4950f54276bc162c3b0ceabccf06b7f030b5a3dd" translate="yes" xml:space="preserve">
          <source>By default, the resulting categories will be ordered as they appear in the &lt;code&gt;categories&lt;/code&gt; of the data. If you want the categories to be lexsorted, use &lt;code&gt;sort_categories=True&lt;/code&gt; argument.</source>
          <target state="translated">기본적으로 결과 범주는 데이터 &lt;code&gt;categories&lt;/code&gt; 에 표시되는 순서대로 정렬됩니다 . 범주를 어휘 분류하려면 &lt;code&gt;sort_categories=True&lt;/code&gt; 인수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8840fd3291d97fdd8eb4b3ab46479bfc1066d1a6" translate="yes" xml:space="preserve">
          <source>By default, the resulting categories will be ordered as they appear in the data. If you want the categories to be lexsorted, use &lt;code&gt;sort_categories=True&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb5d0ef37688aa89a58a81d6fcbe6d7ffceb008" translate="yes" xml:space="preserve">
          <source>By default, the sum of an empty or all-NA Series is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">기본적으로 비어 있거나 모든 NA 시리즈의 합은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="783253e721567d41f884456e70eb7dede1bc10aa" translate="yes" xml:space="preserve">
          <source>By default, the value will be read from the pandas config module. Use a longtable environment instead of tabular. Requires adding a usepackage{longtable} to your LaTeX preamble.</source>
          <target state="translated">기본적으로이 값은 pandas 구성 모듈에서 읽습니다. 표 대신 긴 환경을 사용하십시오. LaTeX 프리앰블에 usepackage {longtable}을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="dfc677900402355f9692b17deb1174d6da56e2da" translate="yes" xml:space="preserve">
          <source>By default, the value will be read from the pandas config module. When set to False prevents from escaping latex special characters in column names.</source>
          <target state="translated">기본적으로이 값은 pandas 구성 모듈에서 읽습니다. False로 설정하면 열 이름에서 라텍스 특수 문자를 피할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7bf0086e76134d3690184f97f4373e0cfe1f064" translate="yes" xml:space="preserve">
          <source>By default, there are no operators defined for the class &lt;a href=&quot;../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray&quot;&gt;&lt;code&gt;ExtensionArray&lt;/code&gt;&lt;/a&gt;. There are two approaches for providing operator support for your ExtensionArray:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray&quot;&gt; &lt;code&gt;ExtensionArray&lt;/code&gt; &lt;/a&gt; 클래스에 대해 정의 된 연산자가 없습니다 . ExtensionArray에 대한 연산자 지원을 제공하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6952abece8099d0a47bebf623635c26a7f290c25" translate="yes" xml:space="preserve">
          <source>By far the majority of time is spend inside either &lt;code&gt;integrate_f&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt;, hence we&amp;rsquo;ll concentrate our efforts cythonizing these two functions.</source>
          <target state="translated">지금까지 대부분의 시간이 &lt;code&gt;integrate_f&lt;/code&gt; 또는 &lt;code&gt;f&lt;/code&gt; 내부에서 소비 되므로이 두 함수를 순환시키는 노력에 집중할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3a912186ad9c21062fef4ecd97b9e34b9ce0f92" translate="yes" xml:space="preserve">
          <source>By file-like object, we refer to objects with a &lt;code&gt;read()&lt;/code&gt; method, such as a file handle (e.g. via builtin &lt;code&gt;open&lt;/code&gt; function) or &lt;code&gt;StringIO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7e2e9fdd8dbfa250ca1faea5939438c265fce9" translate="yes" xml:space="preserve">
          <source>By file-like object, we refer to objects with a &lt;code&gt;read()&lt;/code&gt; method, such as a file handler (e.g. via builtin &lt;code&gt;open&lt;/code&gt; function) or &lt;code&gt;StringIO&lt;/code&gt;.</source>
          <target state="translated">파일과 같은 객체 로 파일 핸들러 (예 : 내장 된 &lt;code&gt;open&lt;/code&gt; 함수 를 통해 ) 또는 &lt;code&gt;StringIO&lt;/code&gt; 와 같은 &lt;code&gt;read()&lt;/code&gt; 메서드를 사용하여 객체를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="cb87061cb61c9dbe3608367c7bfb2df479657ca6" translate="yes" xml:space="preserve">
          <source>By index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ce708975e596182ba0d6ee75a08ace32225c46" translate="yes" xml:space="preserve">
          <source>By indexes and values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad0def3a03240bac4e5846554a381b6038d2161" translate="yes" xml:space="preserve">
          <source>By integer slices, acting similar to numpy/Python:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8974cae9313cca6647cdeac7256a03c1ba3d1d" translate="yes" xml:space="preserve">
          <source>By lists of integer position locations, similar to the NumPy/Python style:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da19fce9010d081ce71581b34437339d2cb1482" translate="yes" xml:space="preserve">
          <source>By passing a &lt;a href=&quot;../reference/api/pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;pandas.Categorical&lt;/code&gt;&lt;/a&gt; object to a &lt;code&gt;Series&lt;/code&gt; or assigning it to a &lt;code&gt;DataFrame&lt;/code&gt;.</source>
          <target state="translated">지나가는으로 &lt;a href=&quot;../reference/api/pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;pandas.Categorical&lt;/code&gt; &lt;/a&gt; A와 객체를 &lt;code&gt;Series&lt;/code&gt; 나에 할당 &lt;code&gt;DataFrame&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6bd38e50f03284e01072e47789f3204990de5d0" translate="yes" xml:space="preserve">
          <source>By passing a dict to &lt;code&gt;aggregate&lt;/code&gt; you can apply a different aggregation to the columns of a &lt;code&gt;DataFrame&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8766b012333be2df133cb12672f9028c7dd5745" translate="yes" xml:space="preserve">
          <source>By passing a dict to &lt;code&gt;aggregate&lt;/code&gt; you can apply a different aggregation to the columns of a DataFrame:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484bc1b8ece9e461bb4da908ce530988bbaad293" translate="yes" xml:space="preserve">
          <source>By providing an integer each column is rounded to the same number of decimal places</source>
          <target state="translated">정수를 제공함으로써 각 열은 같은 소수점 이하 자릿수로 반올림됩니다</target>
        </trans-unit>
        <trans-unit id="fc7a9f05f2f01788200acbdfda14d7674ab91e45" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;keep&lt;/code&gt; on False, all duplicates are True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0b56ec0e3cfa6b7e57d60c9bf585f543fb6126" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;start_time&lt;/code&gt; to be later than &lt;code&gt;end_time&lt;/code&gt;, you can get the times that are &lt;em&gt;not&lt;/em&gt; between the two times.</source>
          <target state="translated">&lt;code&gt;start_time&lt;/code&gt; 을 &lt;code&gt;end_time&lt;/code&gt; 보다 늦게 설정 하면 두 시간 사이 에 &lt;em&gt;없는&lt;/em&gt; 시간을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31cce3ac3bf5ce5bf0e24e43824e86a5c10c1b98" translate="yes" xml:space="preserve">
          <source>By setting keep on &lt;code&gt;False&lt;/code&gt;, all duplicates are True:</source>
          <target state="translated">keep on &lt;code&gt;False&lt;/code&gt; 를 설정 하면 모든 복제본이 True입니다.</target>
        </trans-unit>
        <trans-unit id="341df4957cd8cda1c372fdccf75df0f5637b0714" translate="yes" xml:space="preserve">
          <source>By setting the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7a7a8a99a4192f750a5d020df3f30613f2dafe" translate="yes" xml:space="preserve">
          <source>By setting the &lt;code&gt;index&lt;/code&gt; parameter to False we can remove the index as the first element of the tuple:</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 매개 변수를 False 로 설정 하면 튜플의 첫 번째 요소 인 인덱스를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07bdd506e2fa5925823a80c867753c32e8ce9b72" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;dtype=&quot;category&quot;&lt;/code&gt; when constructing a &lt;code&gt;Series&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; 를 생성 할 때 &lt;code&gt;dtype=&quot;category&quot;&lt;/code&gt; 를 지정 하면 :</target>
        </trans-unit>
        <trans-unit id="1ac8399f8229ba422815d58f476fc4120a9f6a1d" translate="yes" xml:space="preserve">
          <source>By specifying a &lt;code&gt;chunksize&lt;/code&gt; to &lt;code&gt;read_csv&lt;/code&gt;, the return value will be an iterable object of type &lt;code&gt;TextFileReader&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177264efac13fc8448c53c739e204ceb09863ab6" translate="yes" xml:space="preserve">
          <source>By specifying list of row locations for the &lt;code&gt;header&lt;/code&gt; argument, you can read in a &lt;code&gt;MultiIndex&lt;/code&gt; for the columns. Specifying non-consecutive rows will skip the intervening rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f3513544d9b024b8e345eecb0a4fa0d0edb050" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;names&lt;/code&gt; argument in conjunction with &lt;code&gt;header&lt;/code&gt; you can indicate other names to use and whether or not to throw away the header row (if any):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb61eed413b7571d1e2f7631856a427792958d1e" translate="yes" xml:space="preserve">
          <source>By using &amp;lsquo;last&amp;rsquo;, the last occurrence of each set of duplicated values is set on False and all others on True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72beadb893edbb6dbeabe25aa68f9aed772d4415" translate="yes" xml:space="preserve">
          <source>By using &amp;lsquo;last&amp;rsquo;, the last occurrence of each set of duplicated values is set on False and all others on True:</source>
          <target state="translated">'last'를 사용하면 복제 된 각 값 집합의 마지막 항목이 False로 설정되고 다른 모든 값은 True로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1292fb057cc0aedab8ef591dcf48d166e105aa63" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;ngroup()&lt;/code&gt;, we can extract information about the groups in a way similar to &lt;a href=&quot;../reference/api/pandas.factorize#pandas.factorize&quot;&gt;&lt;code&gt;factorize()&lt;/code&gt;&lt;/a&gt; (as described further in the &lt;a href=&quot;reshaping#reshaping-factorize&quot;&gt;reshaping API&lt;/a&gt;) but which applies naturally to multiple columns of mixed type and different sources. This can be useful as an intermediate categorical-like step in processing, when the relationships between the group rows are more important than their content, or as input to an algorithm which only accepts the integer encoding. (For more information about support in pandas for full categorical data, see the &lt;a href=&quot;categorical#categorical&quot;&gt;Categorical introduction&lt;/a&gt; and the &lt;a href=&quot;../reference/arrays#api-arrays-categorical&quot;&gt;API documentation&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe77e32b2efa939216c7aca9a6fdfa902b0ec8e" translate="yes" xml:space="preserve">
          <source>By using special functions, such as &lt;a href=&quot;../reference/api/pandas.cut#pandas.cut&quot;&gt;&lt;code&gt;cut()&lt;/code&gt;&lt;/a&gt;, which groups data into discrete bins. See the &lt;a href=&quot;reshaping#reshaping-tile-cut&quot;&gt;example on tiling&lt;/a&gt; in the docs.</source>
          <target state="translated">데이터를 이산 빈으로 그룹화하는 &lt;a href=&quot;../reference/api/pandas.cut#pandas.cut&quot;&gt; &lt;code&gt;cut()&lt;/code&gt; &lt;/a&gt; 과 같은 특수 함수를 사용 합니다. 문서 &lt;a href=&quot;reshaping#reshaping-tile-cut&quot;&gt;에서 타일링&lt;/a&gt; 에 대한 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b97704126311f378a2303c3a8a7b96aee5c49ed" translate="yes" xml:space="preserve">
          <source>By values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0bfe75dd4e4dfd97fc0ead3f533ab4a23d21e3" translate="yes" xml:space="preserve">
          <source>By-default copy the data, this is compat only and ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef860d8694959dcd3b3f5294cfe1a27b62827ecf" translate="yes" xml:space="preserve">
          <source>Byte-Ordering issues</source>
          <target state="translated">바이트 순서 문제</target>
        </trans-unit>
        <trans-unit id="3ba638c20786e72fa577a1972e832fde9043335e" translate="yes" xml:space="preserve">
          <source>Byte-ordering issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d804821e42ba00da4ea51832ca1627ebb8e32fc3" translate="yes" xml:space="preserve">
          <source>Bytes consumed by a DataFrame.</source>
          <target state="translated">DataFrame에서 소비 한 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="b22afd5ad83b4943ef7a149feb3d6a97ab68e319" translate="yes" xml:space="preserve">
          <source>Bytes consumed by a Series.</source>
          <target state="translated">Series가 소비 한 바이트.</target>
        </trans-unit>
        <trans-unit id="979cc06d8e05220bd40ab32450a5945bc1ca766b" translate="yes" xml:space="preserve">
          <source>Bytes of memory consumed.</source>
          <target state="translated">사용 된 바이트 메모리.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="d248e1897f1ef981f1dbf826833eb3bdd0f2002c" translate="yes" xml:space="preserve">
          <source>C (cpplint)</source>
          <target state="translated">C (cpplint)</target>
        </trans-unit>
        <trans-unit id="b91d0a73f174e5ad7105c342b7f6f26aba7dce48" translate="yes" xml:space="preserve">
          <source>CBM</source>
          <target state="translated">CBM</target>
        </trans-unit>
        <trans-unit id="962daff572e6227cf75119e27b8f12dd831ae7c5" translate="yes" xml:space="preserve">
          <source>CBMS</source>
          <target state="translated">CBMS</target>
        </trans-unit>
        <trans-unit id="bd50275cebf1e0d0a9a001828720ee71d19510c4" translate="yes" xml:space="preserve">
          <source>CBMonthBegin</source>
          <target state="translated">CBMonthBegin</target>
        </trans-unit>
        <trans-unit id="77314b7ad24fcacf554b1e85e13d43a0c742a765" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.apply()</source>
          <target state="translated">CBMonthBegin.apply()</target>
        </trans-unit>
        <trans-unit id="e52fa093754db7363a045cf724818a00c2ec3c04" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.apply_index()</source>
          <target state="translated">CBMonthBegin.apply_index()</target>
        </trans-unit>
        <trans-unit id="752361a98f257c5c4108068471fbfe972d25a065" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.base</source>
          <target state="translated">CBMonthBegin.base</target>
        </trans-unit>
        <trans-unit id="be5b06d5b3154c3b599013d5bec8a19738a1f743" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.cbday_roll</source>
          <target state="translated">CBMonthBegin.cbday_roll</target>
        </trans-unit>
        <trans-unit id="8df7ef3eb3c3c3a8aebb19bd5339cec8bb915337" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.copy()</source>
          <target state="translated">CBMonthBegin.copy()</target>
        </trans-unit>
        <trans-unit id="f4c935e3e78c344662e07b15a01f980ccaf1e206" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.freqstr</source>
          <target state="translated">CBMonthBegin.freqstr</target>
        </trans-unit>
        <trans-unit id="ff343ef3708d2f97f26ae07585aeafe61881b64f" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.isAnchored()</source>
          <target state="translated">CBMonthBegin.isAnchored()</target>
        </trans-unit>
        <trans-unit id="e5910e66d3cee3946eea76cefc4e785dd13f576d" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.kwds</source>
          <target state="translated">CBMonthBegin.kwds</target>
        </trans-unit>
        <trans-unit id="6dd50d5b382368371443c2ca16c45a6d040bcdae" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.m_offset</source>
          <target state="translated">CBMonthBegin.m_offset</target>
        </trans-unit>
        <trans-unit id="dfd80afbc6f7db3c8598695a4577fc2b2e0c28c5" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.month_roll</source>
          <target state="translated">CBMonthBegin.month_roll</target>
        </trans-unit>
        <trans-unit id="22bbca6df1edfbf8b14e4bf565d3656291920ae0" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.name</source>
          <target state="translated">CBMonthBegin.name</target>
        </trans-unit>
        <trans-unit id="d851c28bc711ea8cea5efd4d49c67e538c818d99" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.nanos</source>
          <target state="translated">CBMonthBegin.nanos</target>
        </trans-unit>
        <trans-unit id="79d6a8fc2610f5a0f8caa6e2708eeab049472494" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.normalize</source>
          <target state="translated">CBMonthBegin.normalize</target>
        </trans-unit>
        <trans-unit id="83cefe4ed97ac2c669974e9b5d9e8173c2ff173d" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.offset</source>
          <target state="translated">CBMonthBegin.offset</target>
        </trans-unit>
        <trans-unit id="4bffa90c943561b9c312b4cd2f433af248316007" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.onOffset()</source>
          <target state="translated">CBMonthBegin.onOffset()</target>
        </trans-unit>
        <trans-unit id="5bed58d831e7aa03d7d82698be8866f56235f6e6" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.rollback()</source>
          <target state="translated">CBMonthBegin.rollback()</target>
        </trans-unit>
        <trans-unit id="67f5f6845ba3e4340567c2a634e26197430e99ed" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.rollforward()</source>
          <target state="translated">CBMonthBegin.rollforward()</target>
        </trans-unit>
        <trans-unit id="6a3d7c64b56e8e6ab4a6090d16ff2537383f40ab" translate="yes" xml:space="preserve">
          <source>CBMonthBegin.rule_code</source>
          <target state="translated">CBMonthBegin.rule_code</target>
        </trans-unit>
        <trans-unit id="c77122e4538cdad5f41377ecb3b357d3fa3deb80" translate="yes" xml:space="preserve">
          <source>CBMonthEnd</source>
          <target state="translated">CBMonthEnd</target>
        </trans-unit>
        <trans-unit id="f39a686445564b8e2ff14986c41a57ae444ee4d9" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.apply()</source>
          <target state="translated">CBMonthEnd.apply()</target>
        </trans-unit>
        <trans-unit id="cb35aca995dec6219ccefb09aeb22860fa4f47ff" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.apply_index()</source>
          <target state="translated">CBMonthEnd.apply_index()</target>
        </trans-unit>
        <trans-unit id="a8359819693c2d617b5a724c8093e8fae6113356" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.base</source>
          <target state="translated">CBMonthEnd.base</target>
        </trans-unit>
        <trans-unit id="5a274c2c1cbc7f7a109212903746ed33d1e95e6e" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.cbday_roll</source>
          <target state="translated">CBMonthEnd.cbday_roll</target>
        </trans-unit>
        <trans-unit id="0fb5ac2e0c54cf424a331453140502196b892eed" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.copy()</source>
          <target state="translated">CBMonthEnd.copy()</target>
        </trans-unit>
        <trans-unit id="ae6ca3eab3b552d011c0f5e137fbf031af7f0437" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.freqstr</source>
          <target state="translated">CBMonthEnd.freqstr</target>
        </trans-unit>
        <trans-unit id="545421d28f711fdbf618dcd31af5946cfc0c39f2" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.isAnchored()</source>
          <target state="translated">CBMonthEnd.isAnchored()</target>
        </trans-unit>
        <trans-unit id="dd6522df4889a80b77691be240475aae857cd30f" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.kwds</source>
          <target state="translated">CBMonthEnd.kwds</target>
        </trans-unit>
        <trans-unit id="333b9de7045ba768c8bb1926fe74004ba86f3edc" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.m_offset</source>
          <target state="translated">CBMonthEnd.m_offset</target>
        </trans-unit>
        <trans-unit id="9b730695c3ba755a1b0e6570c1bf845615d918f3" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.month_roll</source>
          <target state="translated">CBMonthEnd.month_roll</target>
        </trans-unit>
        <trans-unit id="1b958f9e84e73d514cc92a78755a314816fc07e8" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.name</source>
          <target state="translated">CBMonthEnd.name</target>
        </trans-unit>
        <trans-unit id="0813e73972541105b10b8f6e7f0b8fa268431253" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.nanos</source>
          <target state="translated">CBMonthEnd.nanos</target>
        </trans-unit>
        <trans-unit id="197dda086a2ab80418236cb346b2470554272afc" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.normalize</source>
          <target state="translated">CBMonthEnd.normalize</target>
        </trans-unit>
        <trans-unit id="24249caa55e583123b6ef0891011c48c10cb5b43" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.offset</source>
          <target state="translated">CBMonthEnd.offset</target>
        </trans-unit>
        <trans-unit id="171753e7829a35df6ad9f764beca8f2076527339" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.onOffset()</source>
          <target state="translated">CBMonthEnd.onOffset()</target>
        </trans-unit>
        <trans-unit id="d0c5377e414fbd9eb91e7ed826182f7b477e3973" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.rollback()</source>
          <target state="translated">CBMonthEnd.rollback()</target>
        </trans-unit>
        <trans-unit id="34e1afaf180fc00524d731b74031f4289e65dae6" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.rollforward()</source>
          <target state="translated">CBMonthEnd.rollforward()</target>
        </trans-unit>
        <trans-unit id="3477bfa987be5737e96ecd908b6b32ea1833a3b8" translate="yes" xml:space="preserve">
          <source>CBMonthEnd.rule_code</source>
          <target state="translated">CBMonthEnd.rule_code</target>
        </trans-unit>
        <trans-unit id="0edd95404ab2003a5242069e0ba9233cc511db53" translate="yes" xml:space="preserve">
          <source>CDay</source>
          <target state="translated">CDay</target>
        </trans-unit>
        <trans-unit id="ccd03003c78be7580fefa52975897f8191ffcfca" translate="yes" xml:space="preserve">
          <source>CDay.apply()</source>
          <target state="translated">CDay.apply()</target>
        </trans-unit>
        <trans-unit id="b470978595d6e1c292c999dffa69b85b1d801534" translate="yes" xml:space="preserve">
          <source>CDay.apply_index()</source>
          <target state="translated">CDay.apply_index()</target>
        </trans-unit>
        <trans-unit id="251320c1201b002fa0c12c6f5761904f987e19da" translate="yes" xml:space="preserve">
          <source>CDay.base</source>
          <target state="translated">CDay.base</target>
        </trans-unit>
        <trans-unit id="909eaf36761b1da1e6183ebc68da39170364b6cc" translate="yes" xml:space="preserve">
          <source>CDay.copy()</source>
          <target state="translated">CDay.copy()</target>
        </trans-unit>
        <trans-unit id="4f1131cf3e0ce01669eb0b455907792764621989" translate="yes" xml:space="preserve">
          <source>CDay.freqstr</source>
          <target state="translated">CDay.freqstr</target>
        </trans-unit>
        <trans-unit id="b2a9682ba54c0f9c6b5b55638019aaeeaeec4f25" translate="yes" xml:space="preserve">
          <source>CDay.isAnchored()</source>
          <target state="translated">CDay.isAnchored()</target>
        </trans-unit>
        <trans-unit id="e547563390cac2bd9f0aeab25d109136678f5011" translate="yes" xml:space="preserve">
          <source>CDay.kwds</source>
          <target state="translated">CDay.kwds</target>
        </trans-unit>
        <trans-unit id="8a315575e630eb97654c6b2d472c351de06f9d18" translate="yes" xml:space="preserve">
          <source>CDay.name</source>
          <target state="translated">CDay.name</target>
        </trans-unit>
        <trans-unit id="7a90130b3ef5726c3fbbf57afac7dfbbb9643486" translate="yes" xml:space="preserve">
          <source>CDay.nanos</source>
          <target state="translated">CDay.nanos</target>
        </trans-unit>
        <trans-unit id="3d376ecf8b8df644741f59bd1fdedcd13568e628" translate="yes" xml:space="preserve">
          <source>CDay.normalize</source>
          <target state="translated">CDay.normalize</target>
        </trans-unit>
        <trans-unit id="242f378c192b8ba237d3682f7ce8e85a66300879" translate="yes" xml:space="preserve">
          <source>CDay.offset</source>
          <target state="translated">CDay.offset</target>
        </trans-unit>
        <trans-unit id="f801ef71ce0c88d51a58283222dbd727099d22b7" translate="yes" xml:space="preserve">
          <source>CDay.onOffset()</source>
          <target state="translated">CDay.onOffset()</target>
        </trans-unit>
        <trans-unit id="8b273063ddfeb00f3fbd6561dca6f8ed38547146" translate="yes" xml:space="preserve">
          <source>CDay.rollback()</source>
          <target state="translated">CDay.rollback()</target>
        </trans-unit>
        <trans-unit id="5c714e93c993d2b534ccf64051eb9749aef36a69" translate="yes" xml:space="preserve">
          <source>CDay.rollforward()</source>
          <target state="translated">CDay.rollforward()</target>
        </trans-unit>
        <trans-unit id="4a6a1ac178e6eb5cce7c58829139508d71d5d253" translate="yes" xml:space="preserve">
          <source>CDay.rule_code</source>
          <target state="translated">CDay.rule_code</target>
        </trans-unit>
        <trans-unit id="aac367e4df21201d2296d58ff096308fac8a2fb0" translate="yes" xml:space="preserve">
          <source>CLN: Code cleanup</source>
          <target state="translated">CLN : 코드 정리</target>
        </trans-unit>
        <trans-unit id="f2b08eccd5042e525d0e617f3a848548d4c3357c" translate="yes" xml:space="preserve">
          <source>CSS class(es) to apply to the resulting html table.</source>
          <target state="translated">결과 html 테이블에 적용 할 CSS 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="21444efa9494abd66434381371c755d1d31f0244" translate="yes" xml:space="preserve">
          <source>CSS classes</source>
          <target state="translated">CSS 클래스</target>
        </trans-unit>
        <trans-unit id="4142c31f9ade153d88101f69671f6996dd2f0036" translate="yes" xml:space="preserve">
          <source>CSS classes are attached to the generated HTML</source>
          <target state="translated">CSS 클래스는 생성 된 HTML에 첨부됩니다</target>
        </trans-unit>
        <trans-unit id="3281188351b89c8e2db28d6da7af4992d415de90" translate="yes" xml:space="preserve">
          <source>CSV</source>
          <target state="translated">CSV</target>
        </trans-unit>
        <trans-unit id="1cd2cecf23747420eb42a5ddd994b11118a8c1de" translate="yes" xml:space="preserve">
          <source>CSV &amp;amp; text files</source>
          <target state="translated">CSV 및 텍스트 파일</target>
        </trans-unit>
        <trans-unit id="08ac1a43bfb669a0baeea979968eae0d8a36bd81" translate="yes" xml:space="preserve">
          <source>Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified freq.</source>
          <target state="translated">지정된 주파수에서 인덱스 값과 PeriodArray로 변환 된 인덱스의 차이에 대한 TimedeltaArray를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7dec92724bea9c197938d6867a141e34292bb9ff" translate="yes" xml:space="preserve">
          <source>Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified freq. Used for vectorized offsets</source>
          <target state="translated">지정된 주파수에서 인덱스 값과 PeriodArray로 변환 된 인덱스의 차이에 대한 TimedeltaArray를 계산합니다. 벡터화 된 오프셋에 사용</target>
        </trans-unit>
        <trans-unit id="1200a2936b9146e16056c6538ec7c61d1d6de5c5" translate="yes" xml:space="preserve">
          <source>Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified freq. Used for vectorized offsets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde74733c1f31ddd656c1cde0448ed456d768ed4" translate="yes" xml:space="preserve">
          <source>Calculate expanding correlation.</source>
          <target state="translated">확장 상관 관계를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3af71107d6ea63e2dc273d016489e108b1b493b3" translate="yes" xml:space="preserve">
          <source>Calculate expanding standard deviation.</source>
          <target state="translated">확장 표준 편차를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="360cd8f64bc341187c26f909121fea2f8941bf9e" translate="yes" xml:space="preserve">
          <source>Calculate expanding sum of given DataFrame or Series.</source>
          <target state="translated">주어진 DataFrame 또는 Series의 확장 합계를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4fbfd75732f526f1460c8ce11d8b4958a0d20cd0" translate="yes" xml:space="preserve">
          <source>Calculate exponential power.</source>
          <target state="translated">지수 력을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fcfd95e8eecd4ead623d85fb6ced50f9877e17d6" translate="yes" xml:space="preserve">
          <source>Calculate its length</source>
          <target state="translated">길이 계산</target>
        </trans-unit>
        <trans-unit id="fa636e61add750ce57ec7f6c8748ec75f2d60b3a" translate="yes" xml:space="preserve">
          <source>Calculate modulo (remainder after division).</source>
          <target state="translated">모듈로 계산 (나눗셈 후 나머지).</target>
        </trans-unit>
        <trans-unit id="c32ca9f7650397fac2e8291af70409209eba6776" translate="yes" xml:space="preserve">
          <source>Calculate pairwise combinations of columns within a DataFrame. If</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300da0bcbdd41544d489526f5cac8618a2355bc7" translate="yes" xml:space="preserve">
          <source>Calculate pairwise combinations of columns within a DataFrame. If &lt;code&gt;other&lt;/code&gt; is not specified, defaults to &lt;code&gt;True&lt;/code&gt;, otherwise defaults to &lt;code&gt;False&lt;/code&gt;. Not relevant for &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">DataFrame 내에서 열을 쌍으로 조합하여 계산합니다. 경우 &lt;code&gt;other&lt;/code&gt; 지정되지 않은 경우 기본값은 &lt;code&gt;True&lt;/code&gt; 에, 그렇지 않으면 기본값은 &lt;code&gt;False&lt;/code&gt; . &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 와 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="840ddbfd478e8cf567a549418e380e3ddcc887e3" translate="yes" xml:space="preserve">
          <source>Calculate pct_change of each value to previous entry in group.</source>
          <target state="translated">각 값의 pct_change를 그룹의 이전 항목으로 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="36f62b2b16cb4b434c58dea980f12708c03f13e5" translate="yes" xml:space="preserve">
          <source>Calculate rolling correlation.</source>
          <target state="translated">롤링 상관 관계를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="850f20e99de1936bda32ceeff70170b6406276a1" translate="yes" xml:space="preserve">
          <source>Calculate rolling standard deviation.</source>
          <target state="translated">롤링 표준 편차를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="54f04ca990edc89de8494f94d3cb57d9fe234352" translate="yes" xml:space="preserve">
          <source>Calculate rolling sum of given DataFrame or Series.</source>
          <target state="translated">주어진 DataFrame 또는 Series의 롤링 합계를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="42c970e014af3ef2fbaa4a9f91c5c5a60993764d" translate="yes" xml:space="preserve">
          <source>Calculate slice bound that corresponds to given label.</source>
          <target state="translated">주어진 레이블에 해당하는 슬라이스 경계를 ​​계산합니다.</target>
        </trans-unit>
        <trans-unit id="897a0bcc51e675340eb8de452d794c61bbe86ad4" translate="yes" xml:space="preserve">
          <source>Calculate the absolute value element-wise.</source>
          <target state="translated">요소 별 절대 값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="4085961c15d89a811239e096d578fa42188f4fb1" translate="yes" xml:space="preserve">
          <source>Calculate the expanding maximum.</source>
          <target state="translated">확장 최대 값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="8a13032e0ec1e2ec55a47ef780f2a8d8a8b246c9" translate="yes" xml:space="preserve">
          <source>Calculate the expanding mean of the values.</source>
          <target state="translated">값의 확장 평균을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="8406bf60930113c031af4f23a867ce417712eee3" translate="yes" xml:space="preserve">
          <source>Calculate the expanding median.</source>
          <target state="translated">확장 중간 값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="f8c750dd6530f857067e77496ee393d943531bc6" translate="yes" xml:space="preserve">
          <source>Calculate the expanding minimum.</source>
          <target state="translated">확장 최소값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="18b74859926373a8c97237bf6ba4212f83b6bfdd" translate="yes" xml:space="preserve">
          <source>Calculate the expanding quantile.</source>
          <target state="translated">확장 분위수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="63c9a6f2667f67990f1ec55040b35c0ee42dbb4e" translate="yes" xml:space="preserve">
          <source>Calculate the expanding sample covariance.</source>
          <target state="translated">확장 샘플 공분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="86b7fe0db43c4dde98e144646b3830fc9aa7c6be" translate="yes" xml:space="preserve">
          <source>Calculate the first day of the month for each entry in a DatetimeIndex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb7c7f61b8473e791ed672a9771d92d89e9b853" translate="yes" xml:space="preserve">
          <source>Calculate the rolling maximum.</source>
          <target state="translated">롤링 최대 값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="56f887c8ccbd530c971b5a68cbae83b79086bd95" translate="yes" xml:space="preserve">
          <source>Calculate the rolling mean of the values.</source>
          <target state="translated">값의 롤링 평균을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="8e584dbbac651d0160592120f9ae199795f612ba" translate="yes" xml:space="preserve">
          <source>Calculate the rolling median.</source>
          <target state="translated">롤링 중앙값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a3d5f9af24012fcf43bbee8db6ac3031a2d5f0aa" translate="yes" xml:space="preserve">
          <source>Calculate the rolling minimum.</source>
          <target state="translated">롤링 최소값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="c00eabfef7ffbb75614ac3d3e272c17d70a5a64f" translate="yes" xml:space="preserve">
          <source>Calculate the rolling quantile.</source>
          <target state="translated">롤링 Quantile을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ef2658f86ca889438eede93a778ad39ed078d2de" translate="yes" xml:space="preserve">
          <source>Calculate the rolling sample covariance.</source>
          <target state="translated">롤링 샘플 공분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cad97d8d1c39809e78c3e237d0b6512d9b67a1cd" translate="yes" xml:space="preserve">
          <source>Calculate the window mean of the values.</source>
          <target state="translated">값의 창 평균을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="5a9d8c86d4c1d289a0acbebb41be6ce393f46d71" translate="yes" xml:space="preserve">
          <source>Calculate unbiased expanding kurtosis.</source>
          <target state="translated">편견없는 팽창 첨도를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="78fa4f8c9ad5717a24fc8615d7126266a8e4e0fe" translate="yes" xml:space="preserve">
          <source>Calculate unbiased expanding variance.</source>
          <target state="translated">편향되지 않은 확장 분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8772816555c47d2670666f6b36cd6cd7ebdfd55c" translate="yes" xml:space="preserve">
          <source>Calculate unbiased rolling kurtosis.</source>
          <target state="translated">바이어스되지 않은 롤링 첨도를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2c5a9dc3b40f3101ec8c2b35747025814d6a2665" translate="yes" xml:space="preserve">
          <source>Calculate unbiased rolling variance.</source>
          <target state="translated">바이어스되지 않은 롤링 분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9b8132c43c37d9c64f7ce4d1d12e63ceda728a88" translate="yes" xml:space="preserve">
          <source>Calculate unbiased window variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f3fa51d4804c0519adbb04b58d8b08a868110" translate="yes" xml:space="preserve">
          <source>Calculate window boundaries based on a non-fixed offset such as a BusinessDay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761048fb6f9fbb79430edd1287f1c862a4cba8d1" translate="yes" xml:space="preserve">
          <source>Calculate window standard deviation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee6592d4e67645efaff4667f77e78e210964e36" translate="yes" xml:space="preserve">
          <source>Calculate window sum of given DataFrame or Series.</source>
          <target state="translated">주어진 DataFrame 또는 Series의 창 합계를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5d4f0817d00f660a767de2d1e73b1708a0f418e8" translate="yes" xml:space="preserve">
          <source>Calculates the difference of a DataFrame element compared with another element in the DataFrame (default is the element in the same column of the previous row).</source>
          <target state="translated">DataFrame의 다른 요소와 비교하여 DataFrame 요소의 차이를 계산합니다 (기본값은 이전 행의 동일한 열에있는 요소 임).</target>
        </trans-unit>
        <trans-unit id="79bdeeb839dd5f5c1ec4e3fe7964d6d2696e3171" translate="yes" xml:space="preserve">
          <source>Calculates the difference of a Dataframe element compared with another element in the Dataframe (default is element in previous row).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f697e36345c82dbbb291b1235a7bcfab769bbb7" translate="yes" xml:space="preserve">
          <source>Calculates the difference of a Series element compared with another element in the Series (default is element in previous row).</source>
          <target state="translated">Series의 다른 요소와 비교하여 Series 요소의 차이를 계산합니다 (기본값은 이전 행의 요소 임).</target>
        </trans-unit>
        <trans-unit id="8cc60680c3d3b5d1cb926d911a592d51f9801006" translate="yes" xml:space="preserve">
          <source>Calculations with missing data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829008f6ad591390ea8eb6200bd65cb8bb7bf12e" translate="yes" xml:space="preserve">
          <source>Calendar to integrate.</source>
          <target state="translated">통합 할 캘린더입니다.</target>
        </trans-unit>
        <trans-unit id="64af04d5ab99c3aa23103e7a2cc0bb2ba2f5888d" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;func&lt;/code&gt; on self producing a DataFrame with transformed values and that has the same axis length as self.</source>
          <target state="translated">변환 된 값으로 self와 동일한 축 길이를 가진 DataFrame을 자체적으로 생성 할 때 &lt;code&gt;func&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="577e8d8f1be91acc70ee418e90120da3d5eee628" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;func&lt;/code&gt; on self producing a DataFrame with transformed values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec17e54a8e78ba4c5a96f25a2f55f7c4cc217ddc" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;func&lt;/code&gt; on self producing a Series with transformed values and that has the same axis length as self.</source>
          <target state="translated">변형 된 값을 가지며 자체와 동일한 축 길이를 가진 Series를 자체 생산할 때 &lt;code&gt;func&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="447a475eb8a61bd03099346762318ba0e6d1a380" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;func&lt;/code&gt; on self producing a Series with transformed values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1592bc17cab8932829b88b325d09cea84fba959" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;re.findall&lt;/code&gt; on each element, returning DataFrame with one row for each match and one column for each regex capture group</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da3e69182b46038202d54c61121ef6a2aa14f47" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;re.match&lt;/code&gt; on each element, returning matched groups as list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169a415683d699feaa71299ffba4ddf4c6a34115" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;re.search&lt;/code&gt; on each element, returning DataFrame with one row for each element and one column for each regex capture group</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00f1260e91882892b28121f785e3861bbd453b0" translate="yes" xml:space="preserve">
          <source>Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8499b64b7e76060d3a1b4ea5424d18b2ceca4c" translate="yes" xml:space="preserve">
          <source>Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb72433f4270083c8853ddb3da4a76c8207ea8f" translate="yes" xml:space="preserve">
          <source>Call function producing a like-indexed Series on each group and return a Series with the transformed values.</source>
          <target state="translated">각 그룹에서 같은 인덱스 시리즈를 생성하는 함수를 호출하고 변환 된 값을 가진 시리즈를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eef266f410d282365eeaef6f6541415ad4d67585" translate="yes" xml:space="preserve">
          <source>Call self as a function.</source>
          <target state="translated">자신을 함수라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="66e6f2e7fd9cfff2eadea78bb1e57630d5ca513c" translate="yes" xml:space="preserve">
          <source>Call with not arguments to get a listing for all registered options.</source>
          <target state="translated">등록 된 모든 옵션에 대한 목록을 얻으려면 인수없이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="e55d13fa69e7f82c84df44c8c823d6b406b57e51" translate="yes" xml:space="preserve">
          <source>Callable that returns a boolean Series</source>
          <target state="translated">부울 시리즈를 반환하는 호출 가능</target>
        </trans-unit>
        <trans-unit id="bdc9be9c9fa405052b15a51bb1a1ce89e7d70906" translate="yes" xml:space="preserve">
          <source>Callable[[Any], str]</source>
          <target state="translated">호출 가능 [[Any], str]</target>
        </trans-unit>
        <trans-unit id="2d31314d01bb388db9ebbd2aee0dad743991a939" translate="yes" xml:space="preserve">
          <source>Caller.</source>
          <target state="translated">Caller.</target>
        </trans-unit>
        <trans-unit id="d27c6a255a41f7f9dd1bdf3025adb912cab3da7c" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;.compute&lt;/code&gt; causes the full task graph to be executed. This includes reading the data, selecting the columns, and doing the &lt;code&gt;value_counts&lt;/code&gt;. The execution is done &lt;em&gt;in parallel&lt;/em&gt; where possible, and Dask tries to keep the overall memory footprint small. You can work with datasets that are much larger than memory, as long as each partition (a regular pandas DataFrame) fits in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747d0e40b4d16bb8039df11373ff262c1de48eec" translate="yes" xml:space="preserve">
          <source>Calling a DataFrame&amp;rsquo;s &lt;a href=&quot;../reference/api/pandas.dataframe.plot.bar#pandas.DataFrame.plot.bar&quot;&gt;&lt;code&gt;plot.bar()&lt;/code&gt;&lt;/a&gt; method produces a multiple bar plot:</source>
          <target state="translated">DataFrame의 &lt;a href=&quot;../reference/api/pandas.dataframe.plot.bar#pandas.DataFrame.plot.bar&quot;&gt; &lt;code&gt;plot.bar()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하면 여러 막대 플롯이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2f23426d9525ea2bddbfac92691f7afacf174b5a" translate="yes" xml:space="preserve">
          <source>Calling object with DataFrame data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4974f7b15c8997f459d81350abfb253b6a3d346b" translate="yes" xml:space="preserve">
          <source>Calling object with DataFrames.</source>
          <target state="translated">DataFrames를 사용하여 객체 호출</target>
        </trans-unit>
        <trans-unit id="1ee2e652b90c42a69eda5f79342a0b1a333e012b" translate="yes" xml:space="preserve">
          <source>Calling object with Series data.</source>
          <target state="translated">Series 데이터로 객체 호출</target>
        </trans-unit>
        <trans-unit id="bb4a54fa51f71d8e249d77ad8a0277a922b576da" translate="yes" xml:space="preserve">
          <source>Calling object with a DataFrame.</source>
          <target state="translated">DataFrame으로 객체 호출</target>
        </trans-unit>
        <trans-unit id="2f908f58ee504c24947256630c6c1dce6269da91" translate="yes" xml:space="preserve">
          <source>Calling object with a Series.</source>
          <target state="translated">Series를 사용하여 객체 호출</target>
        </trans-unit>
        <trans-unit id="bebb024ff35bea7821d88061d262e15bebf744bf" translate="yes" xml:space="preserve">
          <source>Calling object, as there is only one level in the Index.</source>
          <target state="translated">색인에 단 하나의 레벨 만 있으므로 호출 오브젝트.</target>
        </trans-unit>
        <trans-unit id="d590b1042b60e0970ad65e26a6699d8ebc936ed5" translate="yes" xml:space="preserve">
          <source>Calling on an &lt;code&gt;Index&lt;/code&gt; with a regex with exactly one capture group returns a &lt;code&gt;DataFrame&lt;/code&gt; with one column if &lt;code&gt;expand=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6a282d75ff920f4c4664dc3ac148fcd48f0941" translate="yes" xml:space="preserve">
          <source>Calling on an &lt;code&gt;Index&lt;/code&gt; with a regex with more than one capture group returns a &lt;code&gt;DataFrame&lt;/code&gt; if &lt;code&gt;expand=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab0de4c215386754c266357a84881160dda184f" translate="yes" xml:space="preserve">
          <source>Calling the DataFrame without the list of column names would display all columns (akin to SQL&amp;rsquo;s &lt;code&gt;*&lt;/code&gt;).</source>
          <target state="translated">열 이름 목록없이 DataFrame을 호출하면 모든 열이 표시됩니다 (SQL의 &lt;code&gt;*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a9b1820789105336d5540378d418f29fa2792f3" translate="yes" xml:space="preserve">
          <source>Calling the standard Python &lt;code&gt;len&lt;/code&gt; function on the GroupBy object just returns the length of the &lt;code&gt;groups&lt;/code&gt; dict, so it is largely just a convenience:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e074f4754f2dae3a164e7883eab76b93c18c9a" translate="yes" xml:space="preserve">
          <source>Calling this method does not change the ordering of the values.</source>
          <target state="translated">이 메소드를 호출해도 값의 순서는 바뀌지 않습니다.</target>
        </trans-unit>
        <trans-unit id="099d4c5b1d999ebde497cb7de984c1445edc8da6" translate="yes" xml:space="preserve">
          <source>Can also accept a Numba JIT function with &lt;code&gt;engine='numba'&lt;/code&gt; specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6ed607530b2cbedb74d85e10d900571348ec4f" translate="yes" xml:space="preserve">
          <source>Can also accept a Numba JIT function with &lt;code&gt;engine='numba'&lt;/code&gt; specified. Only passing a single function is supported with this engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d68a3863769d405d2d9edfaa0dde04b6102a30a" translate="yes" xml:space="preserve">
          <source>Can also add a layer of hierarchical indexing on the concatenation axis, which may be useful if the labels are the same (or overlapping) on the passed axis number.</source>
          <target state="translated">연결 축에 계층 적 인덱싱 계층을 추가 할 수도 있습니다. 레이블이 전달 된 축 번호에서 동일하거나 겹치는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0eaf587976d5bd06acf92837e4d9ecf0cea9c98" translate="yes" xml:space="preserve">
          <source>Can be &amp;ldquo;&amp;gt;&amp;rdquo;, &amp;ldquo;&amp;lt;&amp;rdquo;, &amp;ldquo;little&amp;rdquo;, or &amp;ldquo;big&amp;rdquo;. default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5919c621028ad19e82becc9a3bb5215ebce7eb4" translate="yes" xml:space="preserve">
          <source>Can be &amp;ldquo;&amp;gt;&amp;rdquo;, &amp;ldquo;&amp;lt;&amp;rdquo;, &amp;ldquo;little&amp;rdquo;, or &amp;ldquo;big&amp;rdquo;. default is &lt;code&gt;sys.byteorder&lt;/code&gt;.</source>
          <target state="translated">&quot;&amp;gt;&quot;, &quot;&amp;lt;&quot;, &quot;little&quot;또는 &quot;big&quot;일 수 있습니다. 기본값은 &lt;code&gt;sys.byteorder&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb3c9ad081211024fca4d3eb6a9219ec67535ab9" translate="yes" xml:space="preserve">
          <source>Can be any valid input to groupby</source>
          <target state="translated">groupby에 유효한 입력이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0b7bb8ebbe69455dedb0203673d5a093a8f33019" translate="yes" xml:space="preserve">
          <source>Can be any valid input to groupby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4283d456b8e46842ad260f227901d59c9c21e50" translate="yes" xml:space="preserve">
          <source>Can be applied to a second style with &lt;code&gt;Styler.use&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Styler.use&lt;/code&gt; 를 사용하여 두 번째 스타일에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4aca382222f840171413dec4e13d7f9683e7b728" translate="yes" xml:space="preserve">
          <source>Can be ufunc (a NumPy function that applies to the entire Series) or a Python function that only works on single values.</source>
          <target state="translated">ufunc (전체 시리즈에 적용되는 NumPy 함수) 또는 단일 값에서만 작동하는 Python 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a844d92fe4d043fa4adb5ec6a8fd4daeedba6f7" translate="yes" xml:space="preserve">
          <source>Can choose to replace values other than NA. Return True for values that should be updated.</source>
          <target state="translated">NA 이외의 값을 대체하도록 선택할 수 있습니다. 업데이트해야하는 값에 대해서는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77b464d81361cebd15b5a778a02ad6759080a317" translate="yes" xml:space="preserve">
          <source>Can evaluate an expression or function to create new values for a column.</source>
          <target state="translated">열에 대한 새 값을 작성하기 위해 표현식 또는 함수를 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892d52c41927e6a10480a6f220ef511fb4bb239d" translate="yes" xml:space="preserve">
          <source>Can only compare identically-labeled (i.e. same shape, identical row and column labels) DataFrames</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e345e095342b6afcb0ec105cc7a85b8ad1511f9" translate="yes" xml:space="preserve">
          <source>Cannot be set if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a38a967680be46b805ca59a37a68e56e0128428" translate="yes" xml:space="preserve">
          <source>Cannot be set if &lt;code&gt;pat&lt;/code&gt; is a compiled regex</source>
          <target state="translated">&lt;code&gt;pat&lt;/code&gt; 이 컴파일 된 정규식 인 경우 설정할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="91e9089813b34c7e6940e72b56c35b56fe3c19e9" translate="yes" xml:space="preserve">
          <source>Cannot be set to False if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18357ac154b52d09a4800eac362a21679c4a9c27" translate="yes" xml:space="preserve">
          <source>Cannot be set to False if &lt;code&gt;pat&lt;/code&gt; is a compiled regex or &lt;code&gt;repl&lt;/code&gt; is a callable.</source>
          <target state="translated">&lt;code&gt;pat&lt;/code&gt; 이 컴파일 된 정규식이거나 &lt;code&gt;repl&lt;/code&gt; 이 호출 가능한 경우 False로 설정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e2fbecc6c186b50d28c2ebcf72d3a73235b725fe" translate="yes" xml:space="preserve">
          <source>Caption to attach to the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1201f5be65e0b58542aaf0a90394b6f142fa1fdc" translate="yes" xml:space="preserve">
          <source>Captions</source>
          <target state="translated">Captions</target>
        </trans-unit>
        <trans-unit id="eaad57de04203ff12d8e6b908882f8cdb382e2bf" translate="yes" xml:space="preserve">
          <source>Capture group names are used for column names of the result.</source>
          <target state="translated">캡처 그룹 이름은 결과의 열 이름에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd48dc81ac51ede2775f66c3afe277ea32fa170f" translate="yes" xml:space="preserve">
          <source>Cast a numpy array to a specified type.</source>
          <target state="translated">numpy 배열을 지정된 유형으로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="3afe62d80f9ae3682ad4518813aa5e7b262d3ae9" translate="yes" xml:space="preserve">
          <source>Cast a pandas object to a specified dtype &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">팬더 객체를 지정된 dtype &lt;code&gt;dtype&lt;/code&gt; 으로 캐스팅 합니다.</target>
        </trans-unit>
        <trans-unit id="c78c90568308a9135347c4d827e900aa8183c86f" translate="yes" xml:space="preserve">
          <source>Cast all columns to int32:</source>
          <target state="translated">모든 열을 int32로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="90996126ba85ca200dc1a975fde0e43153df3134" translate="yes" xml:space="preserve">
          <source>Cast argument to a specified dtype.</source>
          <target state="translated">지정된 dtype에 인수를 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="3396252038d98a6a09fc0a5da74a8c2ca78fb94b" translate="yes" xml:space="preserve">
          <source>Cast col1 to int32 using a dictionary:</source>
          <target state="translated">사전을 사용하여 col1을 int32로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="f134c1795b16936f211817a0716ac33c86717fbd" translate="yes" xml:space="preserve">
          <source>Cast index labels to a different type:</source>
          <target state="translated">색인 레이블을 다른 유형으로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="8d6327b68c07c079752f6d880a38a051ff806038" translate="yes" xml:space="preserve">
          <source>Cast to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4955fa99651a21d032c65acbbb0b2d0d394eef" translate="yes" xml:space="preserve">
          <source>Cast to DatetimeArray/Index.</source>
          <target state="translated">DatetimeArray / Index로 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="5a35ea3e433645048284145bb0f9f063bec2576a" translate="yes" xml:space="preserve">
          <source>Cast to DatetimeIndex of Timestamps, at &lt;em&gt;beginning&lt;/em&gt; of period.</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 시간에 타임 스탬프의 DatetimeIndex로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="cb88a879f730800091a568064ba604663179f10f" translate="yes" xml:space="preserve">
          <source>Cast to DatetimeIndex of timestamps, at &lt;em&gt;beginning&lt;/em&gt; of period.</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 시간에 타임 스탬프의 DatetimeIndex로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="919bd6cbab254b7def740b5d6fbffb81a6d4c2bf" translate="yes" xml:space="preserve">
          <source>Cast to PeriodArray/Index at a particular frequency.</source>
          <target state="translated">특정 빈도로 PeriodArray / Index로 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="2540a54a523dac3fc5ab168d60f203efda48fb82" translate="yes" xml:space="preserve">
          <source>Cast to a NumPy array with &amp;lsquo;dtype&amp;rsquo;.</source>
          <target state="translated">'dtype'을 사용하여 NumPy 배열로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="8528ae94e2e148afb1dc7ce9973ecc62392671c1" translate="yes" xml:space="preserve">
          <source>Categorical</source>
          <target state="translated">Categorical</target>
        </trans-unit>
        <trans-unit id="b6c0e85b6e1038f0193aeaf324e427617c7aa526" translate="yes" xml:space="preserve">
          <source>Categorical : when the input is a Categorical dtype</source>
          <target state="translated">범주 : 입력이 범주 dtype 인 경우</target>
        </trans-unit>
        <trans-unit id="2db2cf1f98b2571e6cd3afec358ae7e56af5c5b4" translate="yes" xml:space="preserve">
          <source>Categorical &lt;code&gt;Series&lt;/code&gt; or columns in a &lt;code&gt;DataFrame&lt;/code&gt; can be created in several ways:</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 의 범주 &lt;code&gt;Series&lt;/code&gt; 또는 열 은 여러 가지 방법으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f551e258210d980d4f7d3ad8ad3ef24cbf7011aa" translate="yes" xml:space="preserve">
          <source>Categorical accessor</source>
          <target state="translated">범주 적 접근 자</target>
        </trans-unit>
        <trans-unit id="af1d455769f1a79e43b75ac1eff2ba880612d5f4" translate="yes" xml:space="preserve">
          <source>Categorical components</source>
          <target state="translated">카테고리 구성 요소</target>
        </trans-unit>
        <trans-unit id="65644ced85eb53271f5518bd55233d23dc99918f" translate="yes" xml:space="preserve">
          <source>Categorical data</source>
          <target state="translated">범주 형 데이터</target>
        </trans-unit>
        <trans-unit id="19d6cdafff3fc1da5d0931715fd4f855fa672756" translate="yes" xml:space="preserve">
          <source>Categorical data can be stored in a &lt;a href=&quot;api/pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;pandas.Categorical&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">카테고리 데이터는 &lt;a href=&quot;api/pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;pandas.Categorical&lt;/code&gt; &lt;/a&gt; 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdb8f01dbe0f362a09bb2b77d5049a54c88051aa" translate="yes" xml:space="preserve">
          <source>Categorical data has a &lt;code&gt;categories&lt;/code&gt; and a &lt;code&gt;ordered&lt;/code&gt; property, which list their possible values and whether the ordering matters or not. These properties are exposed as &lt;code&gt;s.cat.categories&lt;/code&gt; and &lt;code&gt;s.cat.ordered&lt;/code&gt;. If you don&amp;rsquo;t manually specify categories and ordering, they are inferred from the passed arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33c43d6eb71e2e4b34c3ec86e32d5202d00541c" translate="yes" xml:space="preserve">
          <source>Categorical data has a specific &lt;code&gt;category&lt;/code&gt;&lt;a href=&quot;../getting_started/basics#basics-dtypes&quot;&gt;dtype&lt;/a&gt;:</source>
          <target state="translated">범주 형 데이터에는 특정 &lt;code&gt;category&lt;/code&gt; &lt;a href=&quot;../getting_started/basics#basics-dtypes&quot;&gt;dtype이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f1d74df2e1dc7c3da3c014d263de5c7c0474518" translate="yes" xml:space="preserve">
          <source>Categorical data has a specific &lt;code&gt;category&lt;/code&gt;&lt;a href=&quot;basics#basics-dtypes&quot;&gt;dtype&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723414d82453ef0fa3d7a9edd6643a01c879b6e2" translate="yes" xml:space="preserve">
          <source>Categorical index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c2a4833dc02975a1de4ba06c33ead027af2d1f" translate="yes" xml:space="preserve">
          <source>Categorical is not a numpy array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491163921e6191ccb53eb4db02988471d04ad6ca" translate="yes" xml:space="preserve">
          <source>Categorical label contains more than 32,000 characters</source>
          <target state="translated">범주 레이블에 32,000 자 이상이 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="e6668b44f374a0f1d4ce2fd1406b90791d8fee77" translate="yes" xml:space="preserve">
          <source>Categorical or None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a92e20f74b258b0f3628d165ccda3f3a1e3cfb7" translate="yes" xml:space="preserve">
          <source>Categorical variables read through an iterator may not have the same categories and dtype. This occurs when a variable stored in a DTA file is associated to an incomplete set of value labels that only label a strict subset of the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9c358f5e731dc533e11b16b1323e1b27a2624f" translate="yes" xml:space="preserve">
          <source>Categorical variables represented as instance of pandas&amp;rsquo;s &lt;code&gt;Categorical&lt;/code&gt; class can be used as group keys. If so, the order of the levels will be preserved:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc52e9accb416b542a49ce50b0ebcd44071552f6" translate="yes" xml:space="preserve">
          <source>Categorical with new categories added or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa08bd63fb30e802a2ec632ea06635a8eba86d5" translate="yes" xml:space="preserve">
          <source>Categorical with removed categories or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd90a498e42dc2f0680e4bd847b44d1af00ce2b" translate="yes" xml:space="preserve">
          <source>Categorical with reordered categories or None if inplace.</source>
          <target state="translated">재정렬 된 범주가있는 범주 형 또는 적절한 경우 없음.</target>
        </trans-unit>
        <trans-unit id="4dfde3fdeea80e7c40dd5d23fcc06817d22febe4" translate="yes" xml:space="preserve">
          <source>Categorical with unused categories dropped or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7fc16052b6e3846ce87315fd3a672bfcb7f9b1" translate="yes" xml:space="preserve">
          <source>Categorical()</source>
          <target state="translated">Categorical()</target>
        </trans-unit>
        <trans-unit id="f0e818e7cb07757fb84ec5842fa6045c96ccb9bf" translate="yes" xml:space="preserve">
          <source>Categorical, CategoricalIndex, or Series with dtype=&amp;rsquo;category&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1394f5c3380caf0dd8d74771b41257faf3596ce1" translate="yes" xml:space="preserve">
          <source>Categorical-dtype specific methods and attributes are available under the &lt;code&gt;Series.cat&lt;/code&gt; accessor.</source>
          <target state="translated">범주 별 유형별 메소드 및 속성은 &lt;code&gt;Series.cat&lt;/code&gt; 접근 자에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a0d2f1a806c404f4d559514b89f48083f9d193d" translate="yes" xml:space="preserve">
          <source>Categorical.__array__()</source>
          <target state="translated">Categorical.__array__()</target>
        </trans-unit>
        <trans-unit id="e5bfe1ba592c8308c10b368c5366a52c1abbc641" translate="yes" xml:space="preserve">
          <source>Categorical.categories</source>
          <target state="translated">Categorical.categories</target>
        </trans-unit>
        <trans-unit id="65b67237a2d8a8dc5d769e16d4c1a18fa721763e" translate="yes" xml:space="preserve">
          <source>Categorical.codes</source>
          <target state="translated">Categorical.codes</target>
        </trans-unit>
        <trans-unit id="50d64782ecc617772b51a0f12a3a0bdcaabe17c1" translate="yes" xml:space="preserve">
          <source>Categorical.dtype</source>
          <target state="translated">Categorical.dtype</target>
        </trans-unit>
        <trans-unit id="696b10a3829c28bae2e28b2c055e4203f716754b" translate="yes" xml:space="preserve">
          <source>Categorical.from_codes()</source>
          <target state="translated">Categorical.from_codes()</target>
        </trans-unit>
        <trans-unit id="e86cdad0b5d5ce67f3ac07f2bb694ace1c428acd" translate="yes" xml:space="preserve">
          <source>Categorical.ordered</source>
          <target state="translated">Categorical.ordered</target>
        </trans-unit>
        <trans-unit id="7bf923a9b309df1570f3eae0d18eb6349ca22527" translate="yes" xml:space="preserve">
          <source>Categorical: &lt;code&gt;'categorical'&lt;/code&gt;</source>
          <target state="translated">범주 : &lt;code&gt;'categorical'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b70053f969e0425da037b442dcf24227286d85f" translate="yes" xml:space="preserve">
          <source>CategoricalDtype</source>
          <target state="translated">CategoricalDtype</target>
        </trans-unit>
        <trans-unit id="c4035a91edeb10313ddd45340ece7cd7954d76e0" translate="yes" xml:space="preserve">
          <source>CategoricalDtype()</source>
          <target state="translated">CategoricalDtype()</target>
        </trans-unit>
        <trans-unit id="c169a4bff5395ea24ffc600e37c2644bb8fc0508" translate="yes" xml:space="preserve">
          <source>CategoricalDtype.categories</source>
          <target state="translated">CategoricalDtype.categories</target>
        </trans-unit>
        <trans-unit id="f59c0d1c108467a32cbc26cc8dd83280810b949e" translate="yes" xml:space="preserve">
          <source>CategoricalDtype.ordered</source>
          <target state="translated">CategoricalDtype.ordered</target>
        </trans-unit>
        <trans-unit id="bfddf732e2e8da032626c8952317e320dfe0372f" translate="yes" xml:space="preserve">
          <source>CategoricalIndex</source>
          <target state="translated">CategoricalIndex</target>
        </trans-unit>
        <trans-unit id="962fee8c3e84b8294ce901be56be7c636081e66a" translate="yes" xml:space="preserve">
          <source>CategoricalIndex, like Categorical, can only take on a limited, and usually fixed, number of possible values (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bec1bea4e1a753bad82ce87a7c9c7a32ef767c" translate="yes" xml:space="preserve">
          <source>CategoricalIndex, like Categorical, can only take on a limited, and usually fixed, number of possible values (&lt;code&gt;categories&lt;/code&gt;). Also, like Categorical, it might have an order, but numerical operations (additions, divisions, &amp;hellip;) are not possible.</source>
          <target state="translated">Categorical과 마찬가지로 CategoricalIndex는 제한적이고 일반적으로 고정 된 가능한 수의 값 ( &lt;code&gt;categories&lt;/code&gt; ) 만 취할 수 있습니다 . 또한 Categorical과 마찬가지로 순서가있을 수 있지만 수치 연산 (더하기, 나누기 등)은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="38accf3e9af13df9f5a6bae403b50a85984e0470" translate="yes" xml:space="preserve">
          <source>CategoricalIndex.add_categories()</source>
          <target state="translated">CategoricalIndex.add_categories()</target>
        </trans-unit>
        <trans-unit id="cb65a60124086f38594e9292efeb5b732ef5ec90" translate="yes" xml:space="preserve">
          <source>CategoricalIndex.as_ordered()</source>
          <target state="translated">CategoricalIndex.as_ordered()</target>
        </trans-unit>
        <trans-unit id="512b6d0f45c49486470124cbeb418be60f404666" translate="yes" xml:space="preserve">
          <source>CategoricalIndex.as_unordered()</source>
          <target state="translated">CategoricalIndex.as_unordered()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
