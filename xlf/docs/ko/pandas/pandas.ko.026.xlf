<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="b7be2ff881fde47ae80054d53a95fa77faa2dc2b" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;sep&lt;/code&gt; in &lt;code&gt;pd.read_csv&lt;/code&gt; other than a single character:</source>
          <target state="translated">사용 &lt;code&gt;sep&lt;/code&gt; 에서 &lt;code&gt;pd.read_csv&lt;/code&gt; 단일 문자 이외 :</target>
        </trans-unit>
        <trans-unit id="2985de1355c95a632e6ab5117e662f510752ef1e" translate="yes" xml:space="preserve">
          <source>Using a DataFrame column as weights. Rows with larger value in the</source>
          <target state="translated">DataFrame 열을 가중치로 사용. 더 큰 값을 가진 행</target>
        </trans-unit>
        <trans-unit id="fb61aa0e018ee51347b43f0a7526bef1998377b2" translate="yes" xml:space="preserve">
          <source>Using a DataFrame column as weights. Rows with larger value in the &lt;code&gt;num_specimen_seen&lt;/code&gt; column are more likely to be sampled.</source>
          <target state="translated">DataFrame 열을 가중치로 사용 &lt;code&gt;num_specimen_seen&lt;/code&gt; 열 에서 더 큰 값을 가진 행 이 샘플링 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="e036228dc9018c68b843ce1cf9fe7c56a8527252" translate="yes" xml:space="preserve">
          <source>Using a Series, the number of places for specific columns can be specified with the column names as index and the number of decimal places as value</source>
          <target state="translated">Series를 사용하면 특정 열의 자리 수를 열 이름을 인덱스로, 소수 자릿수를 값으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbde4aec4e2c4cb4c3f5f97d6fe6f630d46652dc" translate="yes" xml:space="preserve">
          <source>Using a boolean indexer you can provide selection related to the &lt;em&gt;values&lt;/em&gt;.</source>
          <target state="translated">부울 인덱서를 사용하여 &lt;em&gt;값&lt;/em&gt; 과 관련된 선택을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="690fb85189088e793e265df99baf824d6ee8ed60" translate="yes" xml:space="preserve">
          <source>Using a boolean vector to index a Series works exactly as in a NumPy ndarray:</source>
          <target state="translated">부울 벡터를 사용하여 Series를 인덱싱하면 NumPy ndarray에서와 똑같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="15bbab47a1cc3d92a75b0d85e261c443f16ab3ec" translate="yes" xml:space="preserve">
          <source>Using a compiled regex with flags</source>
          <target state="translated">플래그와 함께 컴파일 된 정규식 사용</target>
        </trans-unit>
        <trans-unit id="d1988f6b35a867c033ef5e3a2788172bb0ba5289" translate="yes" xml:space="preserve">
          <source>Using a list to get multiple sheets:</source>
          <target state="translated">목록을 사용하여 여러 시트 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="c5b984dafbcc353db8249a7fe861d67dafaec72b" translate="yes" xml:space="preserve">
          <source>Using a non-unix epoch origin</source>
          <target state="translated">비 유닉스 신기원 사용</target>
        </trans-unit>
        <trans-unit id="d1865f3be016d0f7cef8155a68185f7e773d2df7" translate="yes" xml:space="preserve">
          <source>Using a numpy universal function (in this case the same as &lt;code&gt;np.sqrt(df)&lt;/code&gt;):</source>
          <target state="translated">numpy 범용 함수 사용 (이 경우 &lt;code&gt;np.sqrt(df)&lt;/code&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="8e787ebc732080f27a6ff292230b2e8190d437c0" translate="yes" xml:space="preserve">
          <source>Using a reducing function on either axis</source>
          <target state="translated">어느 축에서든 축소 기능 사용</target>
        </trans-unit>
        <trans-unit id="7179bec9805ec2715379a41e405fd85463a6b32d" translate="yes" xml:space="preserve">
          <source>Using a single column&amp;rsquo;s values to select data.</source>
          <target state="translated">단일 열의 값을 사용하여 데이터를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6a1c53ca562990050b1cf076e4cddd1fe7aa9e3d" translate="yes" xml:space="preserve">
          <source>Using a single function is equivalent to &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt;. You can also pass named methods as strings. These will return a &lt;code&gt;Series&lt;/code&gt; of the aggregated output:</source>
          <target state="translated">단일 함수를 사용하는 것은 &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 명명 된 메서드를 문자열로 전달할 수도 있습니다. 다음은 집계 된 출력 의 &lt;code&gt;Series&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f95f24fe8c83b7fbea16ce5e19f8035d946260c5" translate="yes" xml:space="preserve">
          <source>Using a special sentinel value, bit pattern, or set of sentinel values to denote &lt;code&gt;NA&lt;/code&gt; across the dtypes.</source>
          <target state="translated">특수 센티넬 값, 비트 패턴 또는 센티넬 값 집합을 사용 하여 dtypes에서 &lt;code&gt;NA&lt;/code&gt; 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="29cd74c2e5c6fa2aed948435e098c60374817533" translate="yes" xml:space="preserve">
          <source>Using a unix epoch time</source>
          <target state="translated">유닉스 시대 시간 사용</target>
        </trans-unit>
        <trans-unit id="93d453c0638ecc32078847231674c8731ff26d4c" translate="yes" xml:space="preserve">
          <source>Using all default values:</source>
          <target state="translated">모든 기본값 사용 :</target>
        </trans-unit>
        <trans-unit id="4ce70951e8980b2d37f36385c8b12ac294cce3c3" translate="yes" xml:space="preserve">
          <source>Using an explicit compression type:</source>
          <target state="translated">명시 적 압축 유형 사용 :</target>
        </trans-unit>
        <trans-unit id="c49b713b5e55028869df42d6cfa53b4dc2e08760" translate="yes" xml:space="preserve">
          <source>Using axis-style parameters</source>
          <target state="translated">축 스타일 파라미터 사용</target>
        </trans-unit>
        <trans-unit id="cf1eb8cfabb6ca34c34cd367c72a09b4d55a179a" translate="yes" xml:space="preserve">
          <source>Using axis-style parameters:</source>
          <target state="translated">축 스타일 매개 변수 사용 :</target>
        </trans-unit>
        <trans-unit id="b7e50c52717d028cb498c4678913cc759219c2d7" translate="yes" xml:space="preserve">
          <source>Using both row labels and value conditionals</source>
          <target state="translated">행 레이블과 값 조건을 모두 사용</target>
        </trans-unit>
        <trans-unit id="b6de15f86e007435cdece1c3e681b8fa40e9333c" translate="yes" xml:space="preserve">
          <source>Using explicit names, instead of the column names</source>
          <target state="translated">열 이름 대신 명시 적 이름 사용</target>
        </trans-unit>
        <trans-unit id="f0b7951778d900d5eb9b6679fa2a13d23b6e7b9c" translate="yes" xml:space="preserve">
          <source>Using get_group</source>
          <target state="translated">get_group 사용</target>
        </trans-unit>
        <trans-unit id="4933c0c3ab46bd51fd15adf913594af05a0df2c3" translate="yes" xml:space="preserve">
          <source>Using if/truth statements with pandas</source>
          <target state="translated">팬더와 함께 if / truth 문 사용</target>
        </trans-unit>
        <trans-unit id="56f3a31a20733b27cd9c92370ccf4d4a3059ff3d" translate="yes" xml:space="preserve">
          <source>Using indexer between time</source>
          <target state="translated">시간 사이에 인덱서 사용</target>
        </trans-unit>
        <trans-unit id="41ecb5c4bd331fb1e959489c5b02d87e1bdc8680" translate="yes" xml:space="preserve">
          <source>Using inverse operator (~) to take the complement of a mask</source>
          <target state="translated">역 연산자 (~)를 사용하여 마스크 보완</target>
        </trans-unit>
        <trans-unit id="62b1b5752da63a961e88249f02557ba4047e63c5" translate="yes" xml:space="preserve">
          <source>Using layout and targeting multiple axes</source>
          <target state="translated">레이아웃 사용 및 여러 축 타겟팅</target>
        </trans-unit>
        <trans-unit id="0b43fac916c33e1161b56e87a1683348f661e58b" translate="yes" xml:space="preserve">
          <source>Using ndarray</source>
          <target state="translated">ndarray 사용</target>
        </trans-unit>
        <trans-unit id="42f32f274be1bfdf6ab67e5a9efaaf16ef62d7c7" translate="yes" xml:space="preserve">
          <source>Using offsets with &lt;code&gt;Series&lt;/code&gt; / &lt;code&gt;DatetimeIndex&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; / &lt;code&gt;DatetimeIndex&lt;/code&gt; 에 오프셋 사용</target>
        </trans-unit>
        <trans-unit id="c7f84dcd4cadcf69050c4e48e0f82ccc484c7bfa" translate="yes" xml:space="preserve">
          <source>Using offsets with Series / DatetimeIndex</source>
          <target state="translated">Series / DatetimeIndex에 오프셋 사용</target>
        </trans-unit>
        <trans-unit id="c365bad2d4db0194276476a489e760e811540376" translate="yes" xml:space="preserve">
          <source>Using polynomial interpolation.</source>
          <target state="translated">다항식 보간 사용.</target>
        </trans-unit>
        <trans-unit id="50128dfc59f6d94a04a3589caed02b990ac36e55" translate="yes" xml:space="preserve">
          <source>Using ptrepack to create a completely-sorted-index on a store</source>
          <target state="translated">ptrepack을 사용하여 상점에서 완전히 정렬 된 인덱스 생성</target>
        </trans-unit>
        <trans-unit id="a3dc2ee823828f157a4cb1418c795a8c1b062601" translate="yes" xml:space="preserve">
          <source>Using regex groups (extract second group and swap case):</source>
          <target state="translated">정규식 그룹 사용 (두 번째 그룹 추출 및 교체 사례) :</target>
        </trans-unit>
        <trans-unit id="a3b0d0f09e28704612c1bc13af2adb30c3fe0808" translate="yes" xml:space="preserve">
          <source>Using replace with backrefs</source>
          <target state="translated">역 참조로 바꾸기 사용</target>
        </trans-unit>
        <trans-unit id="5971221d92e94783b5948dc72bade06ad3e441d4" translate="yes" xml:space="preserve">
          <source>Using searchsorted to merge based on values inside a range</source>
          <target state="translated">검색 정렬을 사용하여 범위 내의 값을 기반으로 병합</target>
        </trans-unit>
        <trans-unit id="49cdbb3847877637961bca525672bcf7d0c41e0a" translate="yes" xml:space="preserve">
          <source>Using slicers</source>
          <target state="translated">슬라이서 사용</target>
        </trans-unit>
        <trans-unit id="9434227c9813407591bcb9754e9c0285afc6b716" translate="yes" xml:space="preserve">
          <source>Using startup scripts for the Python/IPython environment to import pandas and set options makes working with pandas more efficient. To do this, create a .py or .ipy script in the startup directory of the desired profile. An example where the startup folder is in a default IPython profile can be found at:</source>
          <target state="translated">Python / IPython 환경 용 시작 스크립트를 사용하여 Pandas를 가져오고 옵션을 설정하면 Pandas 작업을보다 효율적으로 수행 할 수 있습니다. 이렇게하려면 원하는 프로필의 시작 디렉터리에 .py 또는 .ipy 스크립트를 만듭니다. 시작 폴더가 기본 IPython 프로필에있는 예는 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0179f68112bf19d206379f49e37f01fd8997226d" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;../reference/api/pandas.series.isin#pandas.Series.isin&quot;&gt;&lt;code&gt;isin()&lt;/code&gt;&lt;/a&gt; method for filtering:</source>
          <target state="translated">필터링에 &lt;a href=&quot;../reference/api/pandas.series.isin#pandas.Series.isin&quot;&gt; &lt;code&gt;isin()&lt;/code&gt; &lt;/a&gt; 메서드 사용 :</target>
        </trans-unit>
        <trans-unit id="15b53789a903c0dbd87524980d9f13a30416de1e" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://xlsxwriter.readthedocs.io&quot;&gt;Xlsxwriter&lt;/a&gt; engine provides many options for controlling the format of an Excel worksheet created with the &lt;code&gt;to_excel&lt;/code&gt; method. Excellent examples can be found in the &lt;a href=&quot;https://xlsxwriter.readthedocs.io&quot;&gt;Xlsxwriter&lt;/a&gt; documentation here: &lt;a href=&quot;https://xlsxwriter.readthedocs.io/working_with_pandas.html&quot;&gt;https://xlsxwriter.readthedocs.io/working_with_pandas.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://xlsxwriter.readthedocs.io&quot;&gt;Xlsxwriter&lt;/a&gt; 엔진을 사용하면 &lt;code&gt;to_excel&lt;/code&gt; 메서드로 만든 Excel 워크 시트의 형식을 제어하기위한 많은 옵션이 제공 됩니다. &lt;a href=&quot;https://xlsxwriter.readthedocs.io&quot;&gt;Xlsxwriter&lt;/a&gt; 문서 에서 훌륭한 예제를 찾을 수 있습니다 : &lt;a href=&quot;https://xlsxwriter.readthedocs.io/working_with_pandas.html&quot;&gt;https://xlsxwriter.readthedocs.io/working_with_pandas.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37b07337f73487138ce67f6038ad10c4107fc00f" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;'python'&lt;/code&gt; engine is generally &lt;em&gt;not&lt;/em&gt; useful, except for testing other evaluation engines against it. You will achieve &lt;strong&gt;no&lt;/strong&gt; performance benefits using &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;engine='python'&lt;/code&gt; and in fact may incur a performance hit.</source>
          <target state="translated">&lt;code&gt;'python'&lt;/code&gt; 엔진을 사용하는 것은 다른 평가 엔진을 테스트하는 것을 제외하고 는 일반적으로 유용 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;code&gt;engine='python'&lt;/code&gt; 과 함께 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 을 사용하면 성능상의 이점을 얻을 수 &lt;strong&gt;없으며&lt;/strong&gt; 실제로 성능 저하가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bc5efd6b8afc4e7cd63a6fc0b6f7ca1b0919f00" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;get&lt;/code&gt; method, a missing label will return None or specified default:</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 메서드를 사용하면 누락 된 레이블이 없음 또는 지정된 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f9ecf041c00e73da91e933f322f297654272ffc" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">사용 &lt;code&gt;in&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="5f1e80ffc530194f22b873fca2e85cca3feb2443" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;origin&lt;/code&gt; Parameter</source>
          <target state="translated">은 Using &lt;code&gt;origin&lt;/code&gt; 매개 변수를</target>
        </trans-unit>
        <trans-unit id="8124b7d952310109f284d60b3fc619d187a29699" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;origin&lt;/code&gt; parameter, one can specify an alternative starting point for creation of a &lt;code&gt;DatetimeIndex&lt;/code&gt;. For example, to use 1960-01-01 as the starting date:</source>
          <target state="translated">&lt;code&gt;origin&lt;/code&gt; 매개 변수를 사용하여 &lt;code&gt;DatetimeIndex&lt;/code&gt; 생성을위한 대체 시작점을 지정할 수 있습니다 . 예를 들어 1960-01-01을 시작 날짜로 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="fbca41c3f29b4ff1546b2ed705437726303ee6db" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;squeeze&lt;/code&gt; keyword, the parser will return output with a single column as a &lt;code&gt;Series&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;squeeze&lt;/code&gt; 키워드를 사용하면 파서가 단일 열이있는 출력을 &lt;code&gt;Series&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b20bfb454003962d52ec07dbade67b20c687af6c" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;x_compat&lt;/code&gt; parameter, you can suppress this behavior:</source>
          <target state="translated">&lt;code&gt;x_compat&lt;/code&gt; 매개 변수를 사용하면 이 동작을 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63e3d103b486e99681b49f5aded95795c27c7e41" translate="yes" xml:space="preserve">
          <source>Using the IndexSlice class for a more intuitive command:</source>
          <target state="translated">보다 직관적 인 명령을 위해 IndexSlice 클래스 사용</target>
        </trans-unit>
        <trans-unit id="657499f8b2d6e1960f1a43f1d2fafda88d39e041" translate="yes" xml:space="preserve">
          <source>Using the Python &lt;code&gt;in&lt;/code&gt; operator on a &lt;code&gt;Series&lt;/code&gt; tests for membership in the index, not membership among the values.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; &lt;code&gt;in&lt;/code&gt; Python in 연산자를 사용하면 값 간의 멤버쉽이 아닌 인덱스의 멤버쉽을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="11b116df55079ec334b0dc53c927f1d9dfff0717" translate="yes" xml:space="preserve">
          <source>Using the TimedeltaIndex</source>
          <target state="translated">TimedeltaIndex 사용</target>
        </trans-unit>
        <trans-unit id="ea90f137cd3d7772dca24b621e85197b36d0f9dd" translate="yes" xml:space="preserve">
          <source>Using the default slice command:</source>
          <target state="translated">기본 슬라이스 명령 사용 :</target>
        </trans-unit>
        <trans-unit id="e78e5f2765b1719435e3af843bcdf97f0579e786" translate="yes" xml:space="preserve">
          <source>Using the in operator</source>
          <target state="translated">in 연산자 사용</target>
        </trans-unit>
        <trans-unit id="e326fb4f24719766815edbad98b8e7fdf8e2a006" translate="yes" xml:space="preserve">
          <source>Using the origin Parameter</source>
          <target state="translated">원점 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="6aa326ae6dad6edab1a002da06593eaca191f657" translate="yes" xml:space="preserve">
          <source>Using the other two forms that mimic the API for &lt;code&gt;datetime.datetime&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;datetime.datetime&lt;/code&gt; 에 대한 API를 모방하는 다른 두 양식 사용 :</target>
        </trans-unit>
        <trans-unit id="e020a37525def4fc6292190ba6279847b0fe7771" translate="yes" xml:space="preserve">
          <source>Using the parameter &lt;code&gt;level&lt;/code&gt; in the &lt;a href=&quot;../reference/api/pandas.dataframe.reindex#pandas.DataFrame.reindex&quot;&gt;&lt;code&gt;reindex()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe.align#pandas.DataFrame.align&quot;&gt;&lt;code&gt;align()&lt;/code&gt;&lt;/a&gt; methods of pandas objects is useful to broadcast values across a level. For instance:</source>
          <target state="translated">pandas 객체 의 &lt;a href=&quot;../reference/api/pandas.dataframe.reindex#pandas.DataFrame.reindex&quot;&gt; &lt;code&gt;reindex()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.dataframe.align#pandas.DataFrame.align&quot;&gt; &lt;code&gt;align()&lt;/code&gt; &lt;/a&gt; 메서드 에서 매개 변수 &lt;code&gt;level&lt;/code&gt; 을 사용하면 수준 전체에 값을 브로드 캐스트하는 데 유용합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="13d69d33d9f21d84fb23b18de59c383a0a0266ed" translate="yes" xml:space="preserve">
          <source>Using the primary calling convention:</source>
          <target state="translated">기본 통화 규칙 사용 :</target>
        </trans-unit>
        <trans-unit id="85e8443298cf55064db37c9a422b197a93d62e16" translate="yes" xml:space="preserve">
          <source>Using the same filling arguments as &lt;a href=&quot;basics#basics-reindexing&quot;&gt;reindexing&lt;/a&gt;, we can propagate non-NA values forward or backward:</source>
          <target state="translated">&lt;a href=&quot;basics#basics-reindexing&quot;&gt;reindexing&lt;/a&gt; 과 동일한 채우기 인수를 사용하여 NA가 아닌 값을 앞뒤로 전파 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe70dcf1ef26c5581467dab95c1d961a2c53777c" translate="yes" xml:space="preserve">
          <source>Using the sheet index:</source>
          <target state="translated">시트 색인 사용 :</target>
        </trans-unit>
        <trans-unit id="04ecb32e647daa2f2336f5c016e2ca09e2897bae" translate="yes" xml:space="preserve">
          <source>Using the top-level &lt;code&gt;pd.to_timedelta&lt;/code&gt;, you can convert a scalar, array, list, or Series from a recognized timedelta format / value into a &lt;code&gt;Timedelta&lt;/code&gt; type. It will construct Series if the input is a Series, a scalar if the input is scalar-like, otherwise it will output a &lt;code&gt;TimedeltaIndex&lt;/code&gt;.</source>
          <target state="translated">최상위 &lt;code&gt;pd.to_timedelta&lt;/code&gt; 를 사용하여 스칼라, 배열, 목록 또는 시리즈를 인식 된 &lt;code&gt;Timedelta&lt;/code&gt; 형식 / 값에서 Timedelta 유형 으로 변환 할 수 있습니다 . 입력이 Series이면 Series를, 입력이 스칼라와 비슷하면 스칼라를 생성하고, 그렇지 않으면 &lt;code&gt;TimedeltaIndex&lt;/code&gt; 를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="c88f4b481929e8d70ab6e5d540bf7801106c09fe" translate="yes" xml:space="preserve">
          <source>Using these methods / indexers, you can chain data selection operations without using a temporary variable.</source>
          <target state="translated">이러한 메서드 / 인덱서를 사용하면 임시 변수를 사용하지 않고 데이터 선택 작업을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a8a7c18bcec45718db7daec0d89df610a99517" translate="yes" xml:space="preserve">
          <source>Using this calendar, creating an index or doing offset arithmetic skips weekends and holidays (i.e., Memorial Day/July 4th). For example, the below defines a custom business day offset using the &lt;code&gt;ExampleCalendar&lt;/code&gt;. Like any other offset, it can be used to create a &lt;code&gt;DatetimeIndex&lt;/code&gt; or added to &lt;code&gt;datetime&lt;/code&gt; or &lt;code&gt;Timestamp&lt;/code&gt; objects.</source>
          <target state="translated">이 달력을 사용하여 색인을 생성하거나 오프셋 산술을 수행하면 주말과 공휴일 (예 : 현충일 / 7 월 4 일)을 건너 뜁니다. 예를 들어, 아래는 &lt;code&gt;ExampleCalendar&lt;/code&gt; 를 사용하여 사용자 지정 영업일 오프셋을 정의합니다 . 다른 오프셋과 마찬가지로 &lt;code&gt;DatetimeIndex&lt;/code&gt; 를 생성 하거나 &lt;code&gt;datetime&lt;/code&gt; 또는 &lt;code&gt;Timestamp&lt;/code&gt; 객체에 추가 하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="313f920e77d9792980b38d6d9f91fd04d2647168" translate="yes" xml:space="preserve">
          <source>Using this parameter results in much faster parsing time and lower memory usage.</source>
          <target state="translated">이 매개 변수를 사용하면 구문 분석 시간이 훨씬 빨라지고 메모리 사용량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="de0e033f8a256bf6bbe7829a4f499deffbfbdbf3" translate="yes" xml:space="preserve">
          <source>Using timedeltas</source>
          <target state="translated">타임 델타 사용</target>
        </trans-unit>
        <trans-unit id="f8b8d7a59139089e92be8565e082a95af765430e" translate="yes" xml:space="preserve">
          <source>Vaex</source>
          <target state="translated">Vaex</target>
        </trans-unit>
        <trans-unit id="f71ed70a7b4c945e79c3c2dc5a7487a7c186a91a" translate="yes" xml:space="preserve">
          <source>Valid boolean expressions are combined with:</source>
          <target state="translated">유효한 부울 표현식은 다음과 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="9e3284c1651e9c1666fbe07a03bf2561d0217e3e" translate="yes" xml:space="preserve">
          <source>Valid comparison operators are:</source>
          <target state="translated">유효한 비교 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee73f4880aec9799ab92e6d70c5f15bb722d87ef" translate="yes" xml:space="preserve">
          <source>Valid frequency arguments to Grouper &lt;a href=&quot;timeseries#timeseries-offset-aliases&quot;&gt;Timeseries&lt;/a&gt;</source>
          <target state="translated">Grouper &lt;a href=&quot;timeseries#timeseries-offset-aliases&quot;&gt;Timeseries에&lt;/a&gt; 대한 유효한 빈도 인수</target>
        </trans-unit>
        <trans-unit id="c42e8d3980fddf7ed29754d8ebcbb02540c31477" translate="yes" xml:space="preserve">
          <source>Valid regular expression.</source>
          <target state="translated">유효한 정규식.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="da433f04f8b795f5b82c11defecd596bda4d771b" translate="yes" xml:space="preserve">
          <source>Value between 0 &amp;lt;= q &amp;lt;= 1, the quantile(s) to compute.</source>
          <target state="translated">0 &amp;lt;= q &amp;lt;= 1 사이의 값, 계산할 Quantile (s).</target>
        </trans-unit>
        <trans-unit id="d82d28281dc7cb7c550dbe194117ba12e2d9001b" translate="yes" xml:space="preserve">
          <source>Value counts (histogramming) / mode</source>
          <target state="translated">값 카운트 (히스토그램) / 모드</target>
        </trans-unit>
        <trans-unit id="28dfc1e3beae1ee2d9fdd9ceaebebf48b8dcf1b0" translate="yes" xml:space="preserve">
          <source>Value that is popped from series.</source>
          <target state="translated">시리즈에서 튀어 나온 값입니다.</target>
        </trans-unit>
        <trans-unit id="ffd6598e0be40e6fe4832421e93cc349c7e17880" translate="yes" xml:space="preserve">
          <source>Value to be converted to Timestamp.</source>
          <target state="translated">타임 스탬프로 변환 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="56b68add8862326b02ab0302406d276162fb4fbd" translate="yes" xml:space="preserve">
          <source>Value to mark &amp;ldquo;not found&amp;rdquo;.</source>
          <target state="translated">&quot;찾을 수 없음&quot;을 표시하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="9ffee2974fb37b4f22498c0fe6b103a434ad0b7f" translate="yes" xml:space="preserve">
          <source>Value to mark &amp;ldquo;not found&amp;rdquo;. If None, will not drop the NaN from the uniques of the values.</source>
          <target state="translated">&quot;찾을 수 없음&quot;을 표시 할 값입니다. None이면 값의 고유 항목에서 NaN을 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="580f7cd61f66dd5c9b96651713e7f210be76397e" translate="yes" xml:space="preserve">
          <source>Value to replace any values matching</source>
          <target state="translated">일치하는 값을 대체 할 값</target>
        </trans-unit>
        <trans-unit id="a879a00b6b3b8b106a33489a22d7895dd3dcbefc" translate="yes" xml:space="preserve">
          <source>Value to replace any values matching &lt;code&gt;to_replace&lt;/code&gt; with. For a DataFrame a dict of values can be used to specify which value to use for each column (columns not in the dict will not be filled). Regular expressions, strings and lists or dicts of such objects are also allowed.</source>
          <target state="translated">&lt;code&gt;to_replace&lt;/code&gt; 와 일치하는 값을 대체 할 값 입니다. DataFrame의 경우 값 dict를 사용하여 각 열에 사용할 값을 지정할 수 있습니다 (dict에없는 열은 채워지지 않음). 정규 표현식, 문자열 및 이러한 객체의 목록 또는 dict도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e1f2ee93406a328727d11de6676ad7331c179c" translate="yes" xml:space="preserve">
          <source>Value to replace missing values with</source>
          <target state="translated">결 측값을 대체 할 값</target>
        </trans-unit>
        <trans-unit id="8b9e34dd4b1f962a42b2b2e1c5c220edeeae3d71" translate="yes" xml:space="preserve">
          <source>Value to replace missing values with (in the resulting pivot table, after aggregation).</source>
          <target state="translated">결 측값을 대체 할 값 (집계 후 결과 피벗 테이블에서).</target>
        </trans-unit>
        <trans-unit id="90886ca717da9107e5198f6052cdc6d140f264b9" translate="yes" xml:space="preserve">
          <source>Value to set the axis name attribute.</source>
          <target state="translated">축 이름 속성을 설정하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="b348722020d6796c9a72b0320bd645c72988fd9f" translate="yes" xml:space="preserve">
          <source>Value to use for filling NaN values.</source>
          <target state="translated">NaN 값을 채우는 데 사용할 값입니다.</target>
        </trans-unit>
        <trans-unit id="fe1128c0895fca6559f64fb62e8dce8a4175b044" translate="yes" xml:space="preserve">
          <source>Value to use for missing values, applied during upsampling (note this does not fill NaNs that already were present).</source>
          <target state="translated">업 샘플링 중에 적용되는 결 측값에 사용할 값입니다 (이미 존재했던 NaN을 채우지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="416886e4c2d5fd9209d057bb1fc0a4a001901316" translate="yes" xml:space="preserve">
          <source>Value to use for missing values. Defaults to NaN, but can be any &amp;ldquo;compatible&amp;rdquo; value</source>
          <target state="translated">결 측값에 사용할 값입니다. 기본값은 NaN이지만 &quot;호환 가능한&quot;값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a560ca76cd09ad17375ac1ee8aa67bef91575585" translate="yes" xml:space="preserve">
          <source>Value to use for missing values. Defaults to NaN, but can be any &amp;ldquo;compatible&amp;rdquo; value.</source>
          <target state="translated">결 측값에 사용할 값입니다. 기본값은 NaN이지만 &quot;호환 가능한&quot;값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1680b3905366dcc32c1b5d4a171fed0508435577" translate="yes" xml:space="preserve">
          <source>Value to use in the</source>
          <target state="translated">사용하는 가치</target>
        </trans-unit>
        <trans-unit id="05da114e86006396d3ba2924fa1fe9bdbbebf386" translate="yes" xml:space="preserve">
          <source>Value to use in the &lt;code&gt;labels&lt;/code&gt; array to indicate missing values.</source>
          <target state="translated">누락 된 값을 나타 내기 위해 &lt;code&gt;labels&lt;/code&gt; 배열 에 사용할 값입니다.</target>
        </trans-unit>
        <trans-unit id="7534cf43291aed16fbd535a3c9b276f4255ef53d" translate="yes" xml:space="preserve">
          <source>Value to use to fill holes (e.g. 0), alternately a dict/Series/DataFrame of values specifying which value to use for each index (for a Series) or column (for a DataFrame). Values not in the dict/Series/DataFrame will not be filled. This value cannot be a list.</source>
          <target state="translated">홀을 채우는 데 사용할 값 (예 : 0), 각 인덱스 (시리즈) 또는 열 (DataFrame)에 사용할 값을 지정하는 dict / Series / DataFrame 값. dict / Series / DataFrame에없는 값은 채워지지 않습니다. 이 값은 목록이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="484267409aeaa186db069428bdd811d3c469865c" translate="yes" xml:space="preserve">
          <source>Value to use when replacing NaN values.</source>
          <target state="translated">NaN 값을 바꿀 때 사용할 값입니다.</target>
        </trans-unit>
        <trans-unit id="05f7d9da500b4abe7efbbe645623daa69b38fcca" translate="yes" xml:space="preserve">
          <source>Value(s) between 0 and 1 providing the quantile(s) to compute.</source>
          <target state="translated">계산할 Quantile (들)을 제공하는 0과 1 사이의 값.</target>
        </trans-unit>
        <trans-unit id="ca5e1888f7ff9f4679a3377b455596a48d014681" translate="yes" xml:space="preserve">
          <source>ValueError</source>
          <target state="translated">ValueError</target>
        </trans-unit>
        <trans-unit id="c2a73dc2e5622d27d837979a58687e470870d34a" translate="yes" xml:space="preserve">
          <source>ValueError :</source>
          <target state="translated">ValueError :</target>
        </trans-unit>
        <trans-unit id="4eddba8e8f61af78f809d3c36034ac10b3ba158b" translate="yes" xml:space="preserve">
          <source>ValueError if the</source>
          <target state="translated">ValueError</target>
        </trans-unit>
        <trans-unit id="6c8f3a50824c54f095adbdf6c5e3a029452a18f6" translate="yes" xml:space="preserve">
          <source>ValueError if the freq cannot be converted</source>
          <target state="translated">주파수를 변환 할 수없는 경우 ValueError</target>
        </trans-unit>
        <trans-unit id="a32bf3b72babb876baaa9601c6478aefd4f2c21c" translate="yes" xml:space="preserve">
          <source>ValueError if the freq cannot be converted.</source>
          <target state="translated">주파수를 변환 할 수없는 경우 ValueError.</target>
        </trans-unit>
        <trans-unit id="50e858dfb72147153569ebcd4e118b2589c4f6ce" translate="yes" xml:space="preserve">
          <source>ValueError:</source>
          <target state="translated">ValueError:</target>
        </trans-unit>
        <trans-unit id="d7613af2949341d5019f39fbbef6c4582c2a4442" translate="yes" xml:space="preserve">
          <source>Values at the specified freq.</source>
          <target state="translated">지정된 주파수에서의 값.</target>
        </trans-unit>
        <trans-unit id="56b2972cae6b8181eacad5736758d94b79349e23" translate="yes" xml:space="preserve">
          <source>Values can be set to NaT using np.nan, similar to datetime</source>
          <target state="translated">datetime과 유사한 np.nan을 사용하여 값을 NaT로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d7d3d56cfeee841ef72f807d9b086ab815db9bd" translate="yes" xml:space="preserve">
          <source>Values considered &amp;ldquo;missing&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;결측&amp;rdquo;으로 간주되는 값</target>
        </trans-unit>
        <trans-unit id="039594d9ec5a0ba9321a4b54e784342fa8c1ec78" translate="yes" xml:space="preserve">
          <source>Values is a level of this MultiIndex converted to a single &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; (or subclass thereof).</source>
          <target state="translated">값은이 MultiIndex의 수준으로 단일 &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; (또는 그 하위 클래스) 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="45a0815c898fc899883fb72f3594d89a17a8dc48" translate="yes" xml:space="preserve">
          <source>Values must be hashable and have the same length as</source>
          <target state="translated">값은 해시 가능해야하며 길이는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="d5ed4268ee72c1e662973fa7e5faf5230f346b03" translate="yes" xml:space="preserve">
          <source>Values must be hashable and have the same length as &lt;code&gt;data&lt;/code&gt;. Non-unique index values are allowed. Will default to RangeIndex (0, 1, 2, &amp;hellip;, n) if not provided. If both a dict and index sequence are used, the index will override the keys found in the dict.</source>
          <target state="translated">값은 해시 가능해야하며 data와 길이가 같아야 &lt;code&gt;data&lt;/code&gt; . 고유하지 않은 인덱스 값이 허용됩니다. 제공되지 않으면 기본적으로 RangeIndex (0, 1, 2,&amp;hellip;, n)로 설정됩니다. dict 및 색인 순서가 모두 사용되면 색인은 dict에서 찾은 키를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="598d68d07149fd77c855a3675dbefd3f3238bd09" translate="yes" xml:space="preserve">
          <source>Values of the DataFrame are replaced with other values dynamically. This differs from updating with &lt;code&gt;.loc&lt;/code&gt; or &lt;code&gt;.iloc&lt;/code&gt;, which require you to specify a location to update with some value.</source>
          <target state="translated">DataFrame의 값은 다른 값으로 동적으로 바뀝니다. 이는 &lt;code&gt;.loc&lt;/code&gt; 또는 &lt;code&gt;.iloc&lt;/code&gt; 으로 업데이트하는 것과 다릅니다 .이 경우 일부 값으로 업데이트 할 위치를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="89439b321846e12cbf2095e1202a5bccbb606a56" translate="yes" xml:space="preserve">
          <source>Values of the Series are replaced with other values dynamically. This differs from updating with &lt;code&gt;.loc&lt;/code&gt; or &lt;code&gt;.iloc&lt;/code&gt;, which require you to specify a location to update with some value.</source>
          <target state="translated">시리즈의 값은 다른 값으로 동적으로 대체됩니다. 이는 &lt;code&gt;.loc&lt;/code&gt; 또는 &lt;code&gt;.iloc&lt;/code&gt; 으로 업데이트하는 것과 다릅니다 .이 경우 일부 값으로 업데이트 할 위치를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd97615f4873fd997b552da4ee473f604ea0f8d6" translate="yes" xml:space="preserve">
          <source>Values should be arrays or Series.</source>
          <target state="translated">값은 배열 또는 계열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="339de0736a1f58b4e90f34d02f663272f8d1f2b2" translate="yes" xml:space="preserve">
          <source>Values to consider as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 로 간주 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="261212f0a0371aa40956d08be736598f88280e46" translate="yes" xml:space="preserve">
          <source>Values to consider as &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 간주 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="8782db389bad70efa4ab6b4035c0e33ea809d473" translate="yes" xml:space="preserve">
          <source>Values to consider as False.</source>
          <target state="translated">거짓으로 간주되는 값.</target>
        </trans-unit>
        <trans-unit id="464c7c5f88a20d0db456aa9b1c16c34cc782b8ef" translate="yes" xml:space="preserve">
          <source>Values to consider as True.</source>
          <target state="translated">True로 간주 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="e14fd14e48a03840922e0acb5e2dbf17dc807a53" translate="yes" xml:space="preserve">
          <source>Values to group by in the columns.</source>
          <target state="translated">열에서 그룹화 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="d9d28c6307aae0b65b95e2bf0cbb821fe8aad383" translate="yes" xml:space="preserve">
          <source>Values to group by in the rows.</source>
          <target state="translated">행에서 그룹화 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="97ae4051a0a299f71ea0ef95b00fdc57f644d8aa" translate="yes" xml:space="preserve">
          <source>Values to insert into</source>
          <target state="translated">삽입 할 값</target>
        </trans-unit>
        <trans-unit id="78ca406c0689b1cb7aa9242e838132006504254c" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 에 삽입 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="58a2515c03fce4f195ccb11e4edb23553ce94e16" translate="yes" xml:space="preserve">
          <source>Values to use for the xticks.</source>
          <target state="translated">xtick에 사용할 값입니다.</target>
        </trans-unit>
        <trans-unit id="02584311e54619a38f44a4bb4c13c68ec5079d63" translate="yes" xml:space="preserve">
          <source>Values to use for the yticks.</source>
          <target state="translated">yticks에 사용할 값입니다.</target>
        </trans-unit>
        <trans-unit id="3443eed9dae222352dd23ccae14ed45f7afe9f70" translate="yes" xml:space="preserve">
          <source>Values used to determine the groups.</source>
          <target state="translated">그룹을 결정하는 데 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="13749218a9adc080dd9bf04b5a83c2314bf719d9" translate="yes" xml:space="preserve">
          <source>Variance of values within each group.</source>
          <target state="translated">각 그룹 내 값의 차이</target>
        </trans-unit>
        <trans-unit id="d4d776382b460e3d2a801a43e2536b817717bb91" translate="yes" xml:space="preserve">
          <source>Various combinations of &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;periods&lt;/code&gt; can be used with &lt;code&gt;timedelta_range&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;periods&lt;/code&gt; 의 다양한 조합을 &lt;code&gt;timedelta_range&lt;/code&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eed586eefe864080b44edb04ae092d2677441a64" translate="yes" xml:space="preserve">
          <source>Various tutorials</source>
          <target state="translated">다양한 튜토리얼</target>
        </trans-unit>
        <trans-unit id="af8867db3c91034662bb83a07677cc2fd1e62025" translate="yes" xml:space="preserve">
          <source>Vectorize</source>
          <target state="translated">Vectorize</target>
        </trans-unit>
        <trans-unit id="93c390ad7ef542b32c9638bdc4964014d9ec4b94" translate="yes" xml:space="preserve">
          <source>Vectorized Lookup</source>
          <target state="translated">벡터화 된 조회</target>
        </trans-unit>
        <trans-unit id="ac1dedd01b5fad8bc873e09d5bfd4c0415da7889" translate="yes" xml:space="preserve">
          <source>Vectorized apply of DateOffset to DatetimeIndex, raises NotImplentedError for offsets without a vectorized implementation.</source>
          <target state="translated">DateTimeIndex에 DateOffset을 벡터화하여 적용하면 벡터화 된 구현없이 오프셋에 대해 NotImplentedError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0664f10a60abcd26fa100b2461e49b3c2ebcea60" translate="yes" xml:space="preserve">
          <source>Vectorized operations and label alignment with Series</source>
          <target state="translated">시리즈로 벡터화 된 작업 및 라벨 정렬</target>
        </trans-unit>
        <trans-unit id="5b653a89f6d55b210f26eab32aa9773026d7f00b" translate="yes" xml:space="preserve">
          <source>Vectorized string functions for Series and Index.</source>
          <target state="translated">시리즈 및 인덱스에 대한 벡터화 된 문자열 함수.</target>
        </trans-unit>
        <trans-unit id="06a6eaaabd40081567251c3f1e3eff13409f3dd2" translate="yes" xml:space="preserve">
          <source>Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python&amp;rsquo;s string methods, with some inspiration from R&amp;rsquo;s stringr package.</source>
          <target state="translated">시리즈 및 인덱스에 대한 벡터화 된 문자열 함수 NA는 특정 방법으로 달리 처리하지 않는 한 NA를 유지합니다. R의 stringr 패키지에서 영감을 받아 Python의 문자열 메소드를 따라 패턴 화되었습니다.</target>
        </trans-unit>
        <trans-unit id="7831e4b4a10a8f50a8af637a3ced1a704bd6dee1" translate="yes" xml:space="preserve">
          <source>Vectorized string methods</source>
          <target state="translated">벡터화 된 문자열 메서드</target>
        </trans-unit>
        <trans-unit id="bbfbd52ad095fe7fae949ed22a1925a3ea9265f8" translate="yes" xml:space="preserve">
          <source>Verify that the IntervalArray is valid.</source>
          <target state="translated">IntervalArray가 유효한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ca690ebe009f629b2ef7ce7c2119e0ccd65efe39" translate="yes" xml:space="preserve">
          <source>Verify that the IntervalIndex is valid.</source>
          <target state="translated">IntervalIndex가 유효한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d852921399d93bcb9229ed7093e5cd13284f22ab" translate="yes" xml:space="preserve">
          <source>Version 119 should usually only be used when the number of variables exceeds the capacity of dta format 118. Exporting smaller datasets in format 119 may have unintended consequences, and, as of November 2020, Stata SE cannot read version 119 files.</source>
          <target state="translated">버전 119는 일반적으로 변수 수가 dta 형식 118의 용량을 초과 할 때만 사용해야합니다. 작은 데이터 세트를 형식 119로 내 보내면 의도하지 않은 결과가 발생할 수 있으며 2020 년 11 월부터 Stata SE는 버전 119 파일을 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71ef3b0bdcedcf3fbea2d515d1b0ebbecfcaa900" translate="yes" xml:space="preserve">
          <source>Version control, Git, and GitHub</source>
          <target state="translated">버전 관리, Git 및 GitHub</target>
        </trans-unit>
        <trans-unit id="7a7b56d30f25c644c7188c5fb7535acb7aa2fb89" translate="yes" xml:space="preserve">
          <source>Version to use in the output dta file. Set to None to let pandas decide between 118 or 119 formats depending on the number of columns in the frame. Version 114 can be read by Stata 10 and later. Version 117 can be read by Stata 13 or later. Version 118 is supported in Stata 14 and later. Version 119 is supported in Stata 15 and later. Version 114 limits string variables to 244 characters or fewer while versions 117 and later allow strings with lengths up to 2,000,000 characters. Versions 118 and 119 support Unicode characters, and version 119 supports more than 32,767 variables.</source>
          <target state="translated">출력 dta 파일에서 사용할 버전입니다. pandas가 프레임의 열 수에 따라 118 또는 119 형식을 결정하도록하려면 없음으로 설정합니다. 버전 114는 Stata 10 이상에서 읽을 수 있습니다. 버전 117은 Stata 13 이상에서 읽을 수 있습니다. 버전 118은 Stata 14 이상에서 지원됩니다. 버전 119는 Stata 15 이상에서 지원됩니다. 버전 114는 문자열 변수를 244 자 이하로 제한하고 버전 117 이상에서는 최대 2,000,000 자 길이의 문자열을 허용합니다. 버전 118 및 119는 유니 코드 문자를 지원하고 버전 119는 32,767 개 이상의 변수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="29de7db8d5812e540e315bc3efa1e371e9df3d39" translate="yes" xml:space="preserve">
          <source>Version to use in the output dta file. Version 114 can be used read by Stata 10 and later. Version 117 can be read by Stata 13 or later. Version 114 limits string variables to 244 characters or fewer while 117 allows strings with lengths up to 2,000,000 characters.</source>
          <target state="translated">출력 dta 파일에서 사용할 버전입니다. 버전 114는 Stata 10 이상에서 읽을 수 있습니다. 버전 117은 Stata 13 이상에서 읽을 수 있습니다. 버전 114는 문자열 변수를 244 자 이하로 제한하는 반면 117은 최대 2,000,000 자 길이의 문자열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b1374fde18759eaa0fd694d2f9018fb37c97993f" translate="yes" xml:space="preserve">
          <source>Vertical bar plot.</source>
          <target state="translated">수직 막대 플롯.</target>
        </trans-unit>
        <trans-unit id="d85295bcca463212897322a96c33f1b6b9b69d07" translate="yes" xml:space="preserve">
          <source>Very large DataFrames will be truncated to display them in the console. You can also get a summary using &lt;a href=&quot;../reference/api/pandas.dataframe.info#pandas.DataFrame.info&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;. (Here I am reading a CSV version of the &lt;strong&gt;baseball&lt;/strong&gt; dataset from the &lt;strong&gt;plyr&lt;/strong&gt; R package):</source>
          <target state="translated">매우 큰 DataFrame은 잘려서 콘솔에 표시됩니다. &lt;a href=&quot;../reference/api/pandas.dataframe.info#pandas.DataFrame.info&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; 사용하여 요약을 얻을 수도 있습니다 . (여기서는 &lt;strong&gt;plyr&lt;/strong&gt; R 패키지 에서 &lt;strong&gt;야구&lt;/strong&gt; 데이터 세트 의 CSV 버전을 읽고 있습니다 ) :&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edaf87381353dc5103c9469450ddd93a9997ec00" translate="yes" xml:space="preserve">
          <source>Video tutorials</source>
          <target state="translated">비디오 자습서</target>
        </trans-unit>
        <trans-unit id="6a06e8495189132db418ae810fb661ffa7c56ba6" translate="yes" xml:space="preserve">
          <source>Viewing data</source>
          <target state="translated">데이터보기</target>
        </trans-unit>
        <trans-unit id="c19082998559bbf6a4efdc11bac454f59a89da6d" translate="yes" xml:space="preserve">
          <source>Viewing the first</source>
          <target state="translated">첫 번째보기</target>
        </trans-unit>
        <trans-unit id="3fb0214cbca096c30b3e1b6363cfdc4fffea8dc7" translate="yes" xml:space="preserve">
          <source>Viewing the first 5 lines</source>
          <target state="translated">처음 5 줄보기</target>
        </trans-unit>
        <trans-unit id="463eb436d42f4ede4837191a5786c727d132d5d6" translate="yes" xml:space="preserve">
          <source>Viewing the first &lt;code&gt;n&lt;/code&gt; lines (three in this case)</source>
          <target state="translated">처음 &lt;code&gt;n&lt;/code&gt; 줄 보기 (이 경우 3 줄)</target>
        </trans-unit>
        <trans-unit id="6b4d5e57f4d2959d3d0973ae23c2ac9a72150b42" translate="yes" xml:space="preserve">
          <source>Viewing the last</source>
          <target state="translated">마지막보기</target>
        </trans-unit>
        <trans-unit id="f86e126d0ee23eb31efc593bf9013dc73169413c" translate="yes" xml:space="preserve">
          <source>Viewing the last 5 lines</source>
          <target state="translated">마지막 5 줄보기</target>
        </trans-unit>
        <trans-unit id="ead17bf4f4e18d810e807eb0e7f35c49ac39da7d" translate="yes" xml:space="preserve">
          <source>Viewing the last &lt;code&gt;n&lt;/code&gt; lines (three in this case)</source>
          <target state="translated">마지막 &lt;code&gt;n&lt;/code&gt; 줄 보기 (이 경우 3 줄)</target>
        </trans-unit>
        <trans-unit id="d175985b87dd9f620aa960059c730b4a35e3bcb5" translate="yes" xml:space="preserve">
          <source>Visualization</source>
          <target state="translated">Visualization</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="d0185ac5e26dc3039f379fab71af88edef58c5df" translate="yes" xml:space="preserve">
          <source>W-FRI</source>
          <target state="translated">W-FRI</target>
        </trans-unit>
        <trans-unit id="fab74c2f00b8351224cdc949a417477b4242fb87" translate="yes" xml:space="preserve">
          <source>W-MON</source>
          <target state="translated">W-MON</target>
        </trans-unit>
        <trans-unit id="f88f4f559456924c9c3ba25eda3c218b6b9f6f3e" translate="yes" xml:space="preserve">
          <source>W-SAT</source>
          <target state="translated">W-SAT</target>
        </trans-unit>
        <trans-unit id="f23f67c6027c067e2c85341c78c16953d4c619b8" translate="yes" xml:space="preserve">
          <source>W-SUN</source>
          <target state="translated">W-SUN</target>
        </trans-unit>
        <trans-unit id="20eee65ad67282df9f6aeb20e1d2c3abc9943c6c" translate="yes" xml:space="preserve">
          <source>W-THU</source>
          <target state="translated">W-THU</target>
        </trans-unit>
        <trans-unit id="a02a5362762777f8ca2637958768ef9151f60e52" translate="yes" xml:space="preserve">
          <source>W-TUE</source>
          <target state="translated">W-TUE</target>
        </trans-unit>
        <trans-unit id="715a03b1a9317cf2d531aa85eefd0a2b6acccc87" translate="yes" xml:space="preserve">
          <source>W-WED</source>
          <target state="translated">W-WED</target>
        </trans-unit>
        <trans-unit id="1c255b91e71a2fddc2e75f8455387053d412a4c1" translate="yes" xml:space="preserve">
          <source>WHERE</source>
          <target state="translated">WHERE</target>
        </trans-unit>
        <trans-unit id="6828afe8852386b4788c39621501c1d447ab8e44" translate="yes" xml:space="preserve">
          <source>Walk the pytables group hierarchy for pandas objects</source>
          <target state="translated">팬더 객체에 대한 pytables 그룹 계층 구조를 걷습니다.</target>
        </trans-unit>
        <trans-unit id="8ccd7060dc01ce4fc1198fa1ed08b7bf5dccffe6" translate="yes" xml:space="preserve">
          <source>Walk the pytables group hierarchy for pandas objects.</source>
          <target state="translated">pandas 객체에 대한 pytables 그룹 계층을 살펴보세요.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="f54fb6564205106225f29a0276104f0da779aa78" translate="yes" xml:space="preserve">
          <source>Warning for attribute conflicts in accessor registration.</source>
          <target state="translated">접근 자 등록시 속성 충돌에 대한 경고입니다.</target>
        </trans-unit>
        <trans-unit id="30d6d7ccd9fe97a47017194dae5a70a5c0021832" translate="yes" xml:space="preserve">
          <source>Warning raised when reading a file that doesn&amp;rsquo;t use the default &amp;lsquo;c&amp;rsquo; parser.</source>
          <target state="translated">기본 'c'구문 분석기를 사용하지 않는 파일을 읽을 때 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0caaadb5d2e8fec36befa4dce65e6bd578408214" translate="yes" xml:space="preserve">
          <source>Warning raised when reading different dtypes in a column from a file.</source>
          <target state="translated">파일에서 열의 다른 dtype을 읽을 때 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b5e348be328d880004677a8cd21158198283f29e" translate="yes" xml:space="preserve">
          <source>Warning raised when there is a possible performance impact.</source>
          <target state="translated">성능에 영향을 줄 수있는 경우 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2229aba6da05b699c545f4ad976bbbac370b52e6" translate="yes" xml:space="preserve">
          <source>Warning: Starting in 0.20.0, the .ix indexer is deprecated, in favor of the more strict .iloc and .loc indexers.</source>
          <target state="translated">경고 : 0.20.0부터 .ix 인덱서는 더 엄격한 .iloc 및 .loc 인덱서를 위해 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f16aa3be99fc50d1603498ebbc66eb83c2de49d8" translate="yes" xml:space="preserve">
          <source>Warning: yearfirst=True is not strict, but will prefer to parse with year first (this is a known bug, based on dateutil behavior).</source>
          <target state="translated">경고 : yearfirst = True는 엄격하지는 않지만 연도 첫 번째 구문 분석을 선호합니다 (dateutil 동작에 따라 알려진 버그 임).</target>
        </trans-unit>
        <trans-unit id="63d2a494201c2d726c62af93601b975a9a95c61e" translate="yes" xml:space="preserve">
          <source>We &amp;ldquo;append&amp;rdquo; the parent docstring to the children docstrings, which are initially empty.</source>
          <target state="translated">우리는 부모 docstring을 자식 docstring에&amp;ldquo;추가&amp;rdquo;하는데, 처음에는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="40410b0638954666aa32914003df80b8c40b6382" translate="yes" xml:space="preserve">
          <source>We &lt;em&gt;highly&lt;/em&gt; recommend using keyword arguments to clarify your intent.</source>
          <target state="translated">우리는 &lt;em&gt;매우&lt;/em&gt; 당신의 의도를 명확히하기 위해 키워드 인수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2d172c75c602ef576472c1f2b67f190b3873415b" translate="yes" xml:space="preserve">
          <source>We &lt;strong&gt;highly encourage&lt;/strong&gt; you to read the &lt;a href=&quot;#io-html-gotchas&quot;&gt;HTML Table Parsing gotchas&lt;/a&gt; below regarding the issues surrounding the BeautifulSoup4/html5lib/lxml parsers.</source>
          <target state="translated">우리는 &lt;strong&gt;매우 장려&lt;/strong&gt; 읽기 할 &lt;a href=&quot;#io-html-gotchas&quot;&gt;HTML 표 구문 분석 개는&lt;/a&gt; BeautifulSoup4 / html5lib / LXML 파서를 둘러싼 문제에 관한 아래를.</target>
        </trans-unit>
        <trans-unit id="a8a186984f567f59ddc2d14c3debf4f75591758f" translate="yes" xml:space="preserve">
          <source>We achieve our result by using &lt;code&gt;apply&lt;/code&gt; (row-wise):</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; (row-wise) 를 사용하여 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="1ed1b9bd1cbf8047710697bbbcd03706363e983b" translate="yes" xml:space="preserve">
          <source>We aim to make operations like this natural and easy to express using pandas. We&amp;rsquo;ll address each area of GroupBy functionality then provide some non-trivial examples / use cases.</source>
          <target state="translated">우리는 팬더를 사용하여 이러한 자연스럽고 표현하기 쉬운 작업을 목표로합니다. 우리는 GroupBy 기능의 각 영역을 다루고 사소한 예제 / 사용 사례를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c6483f86bcee89a4e6655b5a3666ca4c64eaa582" translate="yes" xml:space="preserve">
          <source>We are able to preserve the join keys:</source>
          <target state="translated">조인 키를 보존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a373f8540c91612586e8267b03ce8fe608d074fa" translate="yes" xml:space="preserve">
          <source>We are now passing ndarrays into the Cython function, fortunately Cython plays very nicely with NumPy.</source>
          <target state="translated">우리는 이제 ndarray를 Cython 함수에 전달하고 있습니다. 운 좋게도 Cython은 NumPy와 매우 잘 어울립니다.</target>
        </trans-unit>
        <trans-unit id="88aa72652999c1e6b3a6cf6ea396b5b8a4b4ddc0" translate="yes" xml:space="preserve">
          <source>We are stopping on the included end-point as it is part of the index:</source>
          <target state="translated">인덱스의 일부이므로 포함 된 끝점에서 중지합니다.</target>
        </trans-unit>
        <trans-unit id="e346edd3152c787dac5fda7794ede708693d2428" translate="yes" xml:space="preserve">
          <source>We can &amp;lsquo;explode&amp;rsquo; the &lt;code&gt;values&lt;/code&gt; column, transforming each list-like to a separate row, by using &lt;a href=&quot;../reference/api/pandas.series.explode#pandas.Series.explode&quot;&gt;&lt;code&gt;explode()&lt;/code&gt;&lt;/a&gt;. This will replicate the index values from the original row:</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.series.explode#pandas.Series.explode&quot;&gt; &lt;code&gt;explode()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;values&lt;/code&gt; 열을 '폭발'하여 각 목록을 별도의 행으로 변환 할 수 있습니다 . 이렇게하면 원래 행의 인덱스 값이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="5ac7d534408b3cf6069d979fdc019f340f25aae8" translate="yes" xml:space="preserve">
          <source>We can add a new column using &lt;code&gt;pd.eval&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;pd.eval&lt;/code&gt; 을 사용하여 새 열을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3a106ee9ee5fc484d6459ef08e098101bb07f05" translate="yes" xml:space="preserve">
          <source>We can add another object to the same file:</source>
          <target state="translated">같은 파일에 다른 객체를 추가 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ac04ea9c6184cade333734d28f514a8f8fbb4dc6" translate="yes" xml:space="preserve">
          <source>We can also calculate multiple types of aggregations for any given value column.</source>
          <target state="translated">주어진 값 열에 대해 여러 유형의 집계를 계산할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="162470944ce5d0a98895112aefa8a7bca4e5796c" translate="yes" xml:space="preserve">
          <source>We can also choose to include</source>
          <target state="translated">포함하도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="93b80fa2d9a19374ec82c03c9255dcfe72c6c856" translate="yes" xml:space="preserve">
          <source>We can also choose to include NA in group keys or not by setting</source>
          <target state="translated">그룹 키에 NA를 포함할지 여부를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="200a6d0ec834fef8785a1f185e198285ecf02963" translate="yes" xml:space="preserve">
          <source>We can also do elementwise &lt;a href=&quot;https://docs.python.org/3/library/functions.html#divmod&quot;&gt;&lt;code&gt;divmod()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#divmod&quot;&gt; &lt;code&gt;divmod()&lt;/code&gt; &lt;/a&gt; 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9cbf1fe15ace34103263040c3a59538cd016472" translate="yes" xml:space="preserve">
          <source>We can also fill missing values using the</source>
          <target state="translated">또한 다음을 사용하여 누락 된 값을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87360ec2fd2fefde8583136215f4dc6c480752ae" translate="yes" xml:space="preserve">
          <source>We can also fill missing values using the &lt;code&gt;fill_value&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 매개 변수를 사용하여 결 측값을 채울 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8d2801be0ec72e0644b98f6e8a036fd113a9d96" translate="yes" xml:space="preserve">
          <source>We can also pass infinite values to define the bins:</source>
          <target state="translated">무한 값을 전달하여 빈을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="156fb36c789c309e5948d09d7a9667add0e2bd6b" translate="yes" xml:space="preserve">
          <source>We can also perform multiple aggregations. For example, to perform both a &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;mean&lt;/code&gt;, we can pass in a list to the &lt;code&gt;aggfunc&lt;/code&gt; argument.</source>
          <target state="translated">여러 집계를 수행 할 수도 있습니다. 예를 들어 &lt;code&gt;sum&lt;/code&gt; 과 &lt;code&gt;mean&lt;/code&gt; 을 모두 수행 하려면 목록을 &lt;code&gt;aggfunc&lt;/code&gt; 인수에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64aeda62d8005aa7d59f745caaa3e320b51c1126" translate="yes" xml:space="preserve">
          <source>We can also propagate non-null values forward or backward.</source>
          <target state="translated">널이 아닌 값을 앞뒤로 전파 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e094e1c0d9f69faaabb170a1191ebc8e9eec6c" translate="yes" xml:space="preserve">
          <source>We can also reindex the columns.</source>
          <target state="translated">열을 다시 색인 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b945ad4a57c65b50ac79b1b75b160ec81a2c785" translate="yes" xml:space="preserve">
          <source>We can also visually compare the original and transformed data sets.</source>
          <target state="translated">원본 데이터 세트와 변환 된 데이터 세트를 시각적으로 비교할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="39dc753a4128e81d76771121d4aa39a66028f5e9" translate="yes" xml:space="preserve">
          <source>We can convert it to a monthly frequency. Using the &lt;code&gt;how&lt;/code&gt; parameter, we can specify whether to return the starting or ending month:</source>
          <target state="translated">월간 빈도로 변환 할 수 있습니다. &lt;code&gt;how&lt;/code&gt; 매개 변수를 사용하여 시작 또는 종료 월을 반환할지 여부를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e870113b1e10863fae2281b438d078609f5cafe" translate="yes" xml:space="preserve">
          <source>We can easily visualize this with a boxplot:</source>
          <target state="translated">상자 그림으로 쉽게 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9241fe13d125c92fedc43f30dfef36a64e1f2d" translate="yes" xml:space="preserve">
          <source>We can fill in the missing values by passing a value to the keyword &lt;code&gt;fill_value&lt;/code&gt;. Because the index is not monotonically increasing or decreasing, we cannot use arguments to the keyword &lt;code&gt;method&lt;/code&gt; to fill the &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">키워드 &lt;code&gt;fill_value&lt;/code&gt; 에 값을 전달하여 누락 된 값을 채울 수 있습니다 . 인덱스가 단조 증가 또는 감소하지 않기 때문에 키워드 &lt;code&gt;method&lt;/code&gt; 에 인수를 사용 하여 &lt;code&gt;NaN&lt;/code&gt; 값 을 채울 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c422f38e7c3e278fa8c90e638b9bcc37685040a4" translate="yes" xml:space="preserve">
          <source>We can get around this using &lt;code&gt;dialect&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;dialect&lt;/code&gt; 사용하여이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="186b796ce34e3dd1de8daa9ce6b1f3821a58e367" translate="yes" xml:space="preserve">
          <source>We can go a bit further and downcast the numeric columns to their smallest types using &lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt;&lt;code&gt;pandas.to_numeric()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">조금 더 나아가 &lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt; &lt;code&gt;pandas.to_numeric()&lt;/code&gt; &lt;/a&gt; 사용하여 숫자 열을 가장 작은 유형으로 다운 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81d6371ce39c911936a574b3eabfccd647fda6c7" translate="yes" xml:space="preserve">
          <source>We can groupby different levels of a hierarchical index using the</source>
          <target state="translated">다음을 사용하여 계층 적 인덱스의 다른 수준으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b2db2a6808bec614370b1c7f957b27eab347d6e" translate="yes" xml:space="preserve">
          <source>We can groupby different levels of a hierarchical index using the &lt;code&gt;level&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 매개 변수를 사용하여 서로 다른 레벨의 계층 인덱스를 그룹화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d212416e72db7b3fe0816b066e7b1c01859e81a6" translate="yes" xml:space="preserve">
          <source>We can instead only resample those groups where we have points as follows:</source>
          <target state="translated">대신 다음과 같이 포인트가있는 그룹 만 리샘플링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="881823f4cc1b07ee904d3e65148bd383da7aa9bf" translate="yes" xml:space="preserve">
          <source>We can omit the index by passing the keyword</source>
          <target state="translated">키워드를 전달하여 색인을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea76065de2e7d6e780d0ab25da750642d1b5e388" translate="yes" xml:space="preserve">
          <source>We can omit the the index by passing the keyword &lt;code&gt;index&lt;/code&gt; and setting it to false.</source>
          <target state="translated">키워드 &lt;code&gt;index&lt;/code&gt; 를 전달하고 false로 설정 하여 인덱스를 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4216328b386bcfb0c23bf478ea718428f080dcf" translate="yes" xml:space="preserve">
          <source>We can produce pivot tables from this data very easily:</source>
          <target state="translated">이 데이터에서 매우 쉽게 피벗 테이블을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d315c0790d567f4b72deb7c384c646ba85207f5" translate="yes" xml:space="preserve">
          <source>We can see that we got the same content back, which we had earlier written to the clipboard.</source>
          <target state="translated">이전에 클립 보드에 기록했던 것과 동일한 콘텐츠가 다시 표시되는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9183e424a85b6833b88ee1f5e464cab84c6ee889" translate="yes" xml:space="preserve">
          <source>We can select a specific column or columns using standard getitem.</source>
          <target state="translated">표준 getitem을 사용하여 특정 열을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6300ac5ed71bdb6b9fdf83eebe383dd22cd32d7" translate="yes" xml:space="preserve">
          <source>We can specify colors for each column</source>
          <target state="translated">각 열에 색상을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89e36469b14c8152bb2da3b6f21e0d424344f32" translate="yes" xml:space="preserve">
          <source>We can suppress the comments using the &lt;code&gt;comment&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;comment&lt;/code&gt; 키워드를 사용하여 주석을 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ab7a1b9f6ba10e309dcf24b1adcf4590d1499b4" translate="yes" xml:space="preserve">
          <source>We can then group by one of the levels in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;s&lt;/code&gt; 의 수준 중 하나를 기준으로 그룹화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f498793430e40e734f6b029133f48e3818406fc1" translate="yes" xml:space="preserve">
          <source>We can use indexed DataFrames as well.</source>
          <target state="translated">인덱스 데이터 프레임도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1c005f23e75b1614c70640e3d107c2700002668" translate="yes" xml:space="preserve">
          <source>We can use the</source>
          <target state="translated">우리는</target>
        </trans-unit>
        <trans-unit id="bf6a0d5fe6e8e2306b0ef84dd3d8cb816cddd0d5" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;drop&lt;/code&gt; parameter to avoid the old index being added as a column:</source>
          <target state="translated">&lt;code&gt;drop&lt;/code&gt; 매개 변수를 사용하여 이전 색인이 열로 추가되지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94ca8f806251ba49636ef80b4aefb66402c3c9da" translate="yes" xml:space="preserve">
          <source>We can verify that the group means have not changed in the transformed data and that the transformed data contains no NAs.</source>
          <target state="translated">그룹 평균이 변환 된 데이터에서 변경되지 않았고 변환 된 데이터에 NA가 없는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b51bf72462c8fdc6b8ba3f51caf188ae2aa3565" translate="yes" xml:space="preserve">
          <source>We create a frame similar to the one used in the above sections.</source>
          <target state="translated">위 섹션에서 사용한 것과 유사한 프레임을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f9ec436c366e4e9876176a65085a94783330320f" translate="yes" xml:space="preserve">
          <source>We demonstrate how to use Numba to just-in-time compile our code. We simply take the plain Python code from above and annotate with the &lt;code&gt;@jit&lt;/code&gt; decorator.</source>
          <target state="translated">우리는 Numba를 사용하여 코드를 적시에 컴파일하는 방법을 보여줍니다. 위에서 간단한 파이썬 코드를 &lt;code&gt;@jit&lt;/code&gt; 데코레이터로 주석을 달았습니다 .</target>
        </trans-unit>
        <trans-unit id="208d18ee73d660cbd56f96d3fe8eb575be40e323" translate="yes" xml:space="preserve">
          <source>We distinguish the &lt;em&gt;display&lt;/em&gt; value from the &lt;em&gt;actual&lt;/em&gt; value in &lt;code&gt;Styler&lt;/code&gt;. To control the display value, the text is printed in each cell, use &lt;code&gt;Styler.format&lt;/code&gt;. Cells can be formatted according to a &lt;a href=&quot;https://docs.python.org/3/library/string.html#format-specification-mini-language&quot;&gt;format spec string&lt;/a&gt; or a callable that takes a single value and returns a string.</source>
          <target state="translated">&lt;code&gt;Styler&lt;/code&gt; 의 &lt;em&gt;디스플레이&lt;/em&gt; 값과 &lt;em&gt;실제&lt;/em&gt; 값을 구분합니다 . 표시 값을 제어하려면 텍스트가 각 셀에 인쇄됩니다 . &lt;code&gt;Styler.format&lt;/code&gt; 을 사용 하십시오 . 셀은 형식 지정 &lt;a href=&quot;https://docs.python.org/3/library/string.html#format-specification-mini-language&quot;&gt;문자열&lt;/a&gt; 또는 단일 값을 사용하고 문자열을 반환하는 호출 가능 항목 에 따라 형식을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53d95540e955064e56294b28dcea80af21767625" translate="yes" xml:space="preserve">
          <source>We encourage you to use method chains to build up a style piecewise, before finally rending at the end of the chain.</source>
          <target state="translated">체인의 끝에서 끝날 때까지 메소드 체인을 사용하여 스타일을 조각별로 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cc766c2cf7f07925f3683806db7fc0d4cd23b017" translate="yes" xml:space="preserve">
          <source>We get another huge improvement simply by providing type information:</source>
          <target state="translated">타입 정보를 제공하는 것만으로도 크게 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="bd2d7c462734bc530b7d66fddb1c1dd7279aa788" translate="yes" xml:space="preserve">
          <source>We have a &lt;code&gt;DataFrame&lt;/code&gt; to which we want to apply a function row-wise.</source>
          <target state="translated">우리는이 &lt;code&gt;DataFrame&lt;/code&gt; 우리가 함수가 행 방향으로 적용 할에 있습니다.</target>
        </trans-unit>
        <trans-unit id="284cfed2ea213bc690e73e682720d9dae4e35537" translate="yes" xml:space="preserve">
          <source>We have discussed &lt;code&gt;MultiIndex&lt;/code&gt; in the previous sections pretty extensively. Documentation about &lt;code&gt;DatetimeIndex&lt;/code&gt; and &lt;code&gt;PeriodIndex&lt;/code&gt; are shown &lt;a href=&quot;timeseries#timeseries-overview&quot;&gt;here&lt;/a&gt;, and documentation about &lt;code&gt;TimedeltaIndex&lt;/code&gt; is found &lt;a href=&quot;timedeltas#timedeltas-index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이전 섹션에서 &lt;code&gt;MultiIndex&lt;/code&gt; 에 대해 꽤 광범위하게 논의 했습니다. 에 대한 문서 &lt;code&gt;DatetimeIndex&lt;/code&gt; 및 &lt;code&gt;PeriodIndex&lt;/code&gt; 가 표시됩니다 &lt;a href=&quot;timeseries#timeseries-overview&quot;&gt;여기에&lt;/a&gt; , 약 설명서를 &lt;code&gt;TimedeltaIndex&lt;/code&gt; 이 발견 &lt;a href=&quot;timedeltas#timedeltas-index&quot;&gt;여기에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7773bd8987b3ee52919f22acbd1ad73808db05c1" translate="yes" xml:space="preserve">
          <source>We have duplicates in the columns. If we slice &lt;code&gt;'B'&lt;/code&gt;, we get back a &lt;code&gt;Series&lt;/code&gt;</source>
          <target state="translated">열에 중복이 있습니다. &lt;code&gt;'B'&lt;/code&gt; 를 슬라이스 하면 &lt;code&gt;Series&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2c8060afbf10ed1619ff7273a95c4e111fca22" translate="yes" xml:space="preserve">
          <source>We have two autosummary templates for classes.</source>
          <target state="translated">클래스에 대한 두 개의 자동 요약 템플릿이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf58221e02bb5a8b76e3928ba63b1b6ae799d7ae" translate="yes" xml:space="preserve">
          <source>We highly recommend validating the data in your accessor&amp;rsquo;s &lt;code&gt;__init__&lt;/code&gt;. In our &lt;code&gt;GeoAccessor&lt;/code&gt;, we validate that the data contains the expected columns, raising an &lt;code&gt;AttributeError&lt;/code&gt; when the validation fails. For a &lt;code&gt;Series&lt;/code&gt; accessor, you should validate the &lt;code&gt;dtype&lt;/code&gt; if the accessor applies only to certain dtypes.</source>
          <target state="translated">접근 자의 &lt;code&gt;__init__&lt;/code&gt; 데이터의 유효성을 검사하는 것이 좋습니다 . 우리에 &lt;code&gt;GeoAccessor&lt;/code&gt; , 우리는 데이터가 상승, 예상되는 열이 포함되어 있는지 확인 &lt;code&gt;AttributeError&lt;/code&gt; 를 검증이 실패 할 때. A의 &lt;code&gt;Series&lt;/code&gt; 접근, 당신은 확인해야합니다 &lt;code&gt;dtype&lt;/code&gt; 접근 특정 dtypes에만 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3ed7b82acd413bfcecfc36557b40cd808b80f708" translate="yes" xml:space="preserve">
          <source>We illustrate these fill methods on a simple Series:</source>
          <target state="translated">간단한 시리즈에서 이러한 채우기 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="478526087bc925570ad3f135531d1297bf8a5538" translate="yes" xml:space="preserve">
          <source>We may take elements using negative integers for positive indices, starting from the end of the object, just like with Python lists.</source>
          <target state="translated">파이썬 목록과 같이 객체의 끝부터 시작하여 양의 인덱스에 음의 정수를 사용하는 요소를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0848c3f923c126e1c7028e1a6a867079338b0f36" translate="yes" xml:space="preserve">
          <source>We only asof within 10ms between the quote time and the trade time and we exclude exact matches on time. However &lt;em&gt;prior&lt;/em&gt; data will propagate forward</source>
          <target state="translated">우리는 인용 시간과 거래 시간 사이에 10ms 이내에만 가능하며 정시에 정확한 경기를 배제합니다. 그러나 &lt;em&gt;이전&lt;/em&gt; 데이터는 앞으로 전파됩니다</target>
        </trans-unit>
        <trans-unit id="003b043e804ba30c987396676334e8461e16eb4d" translate="yes" xml:space="preserve">
          <source>We only asof within 2ms between the quote time and the trade time</source>
          <target state="translated">우리는 인용 시간과 거래 시간 사이에 2ms 이내에만 가능합니다</target>
        </trans-unit>
        <trans-unit id="d1c8046eb0eb9cd43e630571ca4fa874b5b55682" translate="yes" xml:space="preserve">
          <source>We only asof within &lt;code&gt;10ms&lt;/code&gt; between the quote time and the trade time and we exclude exact matches on time. Note that though we exclude the exact matches (of the quotes), prior quotes &lt;strong&gt;do&lt;/strong&gt; propagate to that point in time.</source>
          <target state="translated">우리 는 견적 시간과 거래 시간 사이에 &lt;code&gt;10ms&lt;/code&gt; 이내에만 확인 하고 정확한 일치를 제 시간에 제외합니다. 정확한 일치 (따옴표)를 제외하더라도 이전 따옴표 &lt;strong&gt;는&lt;/strong&gt; 해당 시점으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="474598673caf759e745b802fe481b161f8ddec6e" translate="yes" xml:space="preserve">
          <source>We only asof within &lt;code&gt;2ms&lt;/code&gt; between the quote time and the trade time.</source>
          <target state="translated">우리 는 견적 시간과 거래 시간 사이에 &lt;code&gt;2ms&lt;/code&gt; 이내에만 asof 합니다.</target>
        </trans-unit>
        <trans-unit id="5034f2430ad087894b302fc0f992003722338c04" translate="yes" xml:space="preserve">
          <source>We prefer this to the &lt;code&gt;pytest.warns&lt;/code&gt; context manager because ours checks that the warning&amp;rsquo;s stacklevel is set correctly. The stacklevel is what ensure the &lt;em&gt;user&amp;rsquo;s&lt;/em&gt; file name and line number is printed in the warning, rather than something internal to pandas. It represents the number of function calls from user code (e.g. &lt;code&gt;df.some_operation()&lt;/code&gt;) to the function that actually emits the warning. Our linter will fail the build if you use &lt;code&gt;pytest.warns&lt;/code&gt; in a test.</source>
          <target state="translated">경고의 스택 수준이 올바르게 설정되어 있는지 확인하기 때문에 &lt;code&gt;pytest.warns&lt;/code&gt; 컨텍스트 관리자 보다 선호 합니다. 스택 레벨은 팬더 내부가 아닌 &lt;em&gt;사용자의&lt;/em&gt; 파일 이름과 행 번호가 경고에 인쇄되도록하는 것입니다. 사용자 코드 (예 : &lt;code&gt;df.some_operation()&lt;/code&gt; )에서 실제로 경고를 발생시키는 함수 까지의 함수 호출 수를 나타냅니다 . 테스트에서 &lt;code&gt;pytest.warns&lt;/code&gt; 를 사용하면 빌드가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="a2a346cabec464372f5c364312efebce73c40713" translate="yes" xml:space="preserve">
          <source>We provide a test suite for ensuring that your extension arrays satisfy the expected behavior. To use the test suite, you must provide several pytest fixtures and inherit from the base test class. The required fixtures are found in &lt;a href=&quot;https://github.com/pandas-dev/pandas/blob/master/pandas/tests/extension/conftest.py&quot;&gt;https://github.com/pandas-dev/pandas/blob/master/pandas/tests/extension/conftest.py&lt;/a&gt;.</source>
          <target state="translated">확장 어레이가 예상되는 동작을 만족시킬 수 있도록 테스트 스위트를 제공합니다. 테스트 스위트를 사용하려면 여러 pytest 픽스쳐를 제공하고 기본 테스트 클래스에서 상속해야합니다. 필요한 고정물은 &lt;a href=&quot;https://github.com/pandas-dev/pandas/blob/master/pandas/tests/extension/conftest.py&quot;&gt;https://github.com/pandas-dev/pandas/blob/master/pandas/tests/extension/conftest.py에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ebc5add8747fa524d5294d47d6e0850ea2acfb" translate="yes" xml:space="preserve">
          <source>We provide the basics in pandas to easily create decent looking plots. See the &lt;a href=&quot;../ecosystem#ecosystem-visualization&quot;&gt;ecosystem&lt;/a&gt; section for visualization libraries that go beyond the basics documented here.</source>
          <target state="translated">팬더의 기본을 제공하여 괜찮은 모양의 플롯을 쉽게 만들 수 있습니다. 여기에 문서화 된 기본 사항 이상의 시각화 라이브러리에 대해서는 &lt;a href=&quot;../ecosystem#ecosystem-visualization&quot;&gt;에코 시스템&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5c6887aa3dd174e9af2942ea171ae7f476b15803" translate="yes" xml:space="preserve">
          <source>We provide the basics in pandas to easily create decent looking plots. See the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/ecosystem.html#ecosystem-visualization&quot;&gt;ecosystem&lt;/a&gt; section for visualization libraries that go beyond the basics documented here.</source>
          <target state="translated">pandas의 기본 사항을 제공하여보기 좋은 플롯을 쉽게 만들 수 있습니다. 여기에 설명 된 기본 사항을 뛰어 넘는 시각화 라이브러리에 대해서는 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/ecosystem.html#ecosystem-visualization&quot;&gt;에코 시스템&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="79d8b1f2d03c61b7488ecb7a4d65c26d8366e50e" translate="yes" xml:space="preserve">
          <source>We recommend explicitly providing the dtype to avoid confusion.</source>
          <target state="translated">혼동을 피하기 위해 명시 적으로 dtype을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="71471e8a73c3eac8bb244fd834a144b6be2e114f" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt;&lt;code&gt;StringDtype&lt;/code&gt;&lt;/a&gt; to store text data.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt; &lt;code&gt;StringDtype&lt;/code&gt; &lt;/a&gt; 을 사용하여 텍스트 데이터를 저장하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a69ceb5e57e445fd190ca4c6b1a5e68b0997ff79" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt;&lt;code&gt;DataFrame.to_numpy()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">대신 &lt;a href=&quot;pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt; &lt;code&gt;DataFrame.to_numpy()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="08dc82107227f4b06511ee512fd1de9e67e10e7a" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;pandas.index.array#pandas.Index.array&quot;&gt;&lt;code&gt;Index.array&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;pandas.index.to_numpy#pandas.Index.to_numpy&quot;&gt;&lt;code&gt;Index.to_numpy()&lt;/code&gt;&lt;/a&gt;, depending on whether you need a reference to the underlying data or a NumPy array.</source>
          <target state="translated">기본 데이터 또는 NumPy 배열에 대한 참조가 필요한지 여부에 따라 &lt;a href=&quot;pandas.index.array#pandas.Index.array&quot;&gt; &lt;code&gt;Index.array&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;pandas.index.to_numpy#pandas.Index.to_numpy&quot;&gt; &lt;code&gt;Index.to_numpy()&lt;/code&gt; &lt;/a&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0f363c695d7e2853e48d9b3e349263190ee6e414" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;pandas.series.array#pandas.Series.array&quot;&gt;&lt;code&gt;Series.array&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;Series.to_numpy()&lt;/code&gt;&lt;/a&gt;, depending on whether you need a reference to the underlying data or a NumPy array.</source>
          <target state="translated">기본 데이터 또는 NumPy 배열에 대한 참조가 필요한지 여부에 따라 &lt;a href=&quot;pandas.series.array#pandas.Series.array&quot;&gt; &lt;code&gt;Series.array&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;Series.to_numpy()&lt;/code&gt; &lt;/a&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="276dd17c9a587dd025fd8054ad2d688939f2a70a" translate="yes" xml:space="preserve">
          <source>We represent an IntegerArray with 2 numpy arrays:</source>
          <target state="translated">우리는 2 개의 numpy 배열을 가진 IntegerArray를 나타냅니다 :</target>
        </trans-unit>
        <trans-unit id="65b6958e7f96df637807ce07ff54fa299e5f56ea" translate="yes" xml:space="preserve">
          <source>We subtract the epoch (midnight at January 1, 1970 UTC) and then floor divide by the &amp;ldquo;unit&amp;rdquo; (1 second).</source>
          <target state="translated">에포크 (1970 년 1 월 1 일 자정 UTC)를 뺀 다음 플로어를 &quot;단위&quot;(1 초)로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="43ae22e64054eee4edde3abf3637ceadcd56f3de" translate="yes" xml:space="preserve">
          <source>We use the standard convention for referencing the matplotlib API:</source>
          <target state="translated">matplotlib API를 참조하기 위해 표준 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="653d09efadb6b3debd7657a04d60d9ed86346113" translate="yes" xml:space="preserve">
          <source>We will address array-based indexing like &lt;code&gt;s[[4, 3, 1]]&lt;/code&gt; in &lt;a href=&quot;indexing#indexing&quot;&gt;section&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;indexing#indexing&quot;&gt;섹션&lt;/a&gt; 에서 &lt;code&gt;s[[4, 3, 1]]&lt;/code&gt; 과 같은 배열 기반 인덱싱 을 다룰 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b0dbe01345f15c02b98a155e4e87733803a9b84a" translate="yes" xml:space="preserve">
          <source>We will demonstrate how to manage these issues independently, though they can be handled simultaneously.</source>
          <target state="translated">이러한 문제를 동시에 처리 할 수는 있지만 이러한 문제를 독립적으로 관리하는 방법을 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="c23edeb09cb6ac75ac0b40d6eb9dfcc02bcfaf09" translate="yes" xml:space="preserve">
          <source>We will demonstrate the basics, see the &lt;a href=&quot;cookbook#cookbook-plotting&quot;&gt;cookbook&lt;/a&gt; for some advanced strategies.</source>
          <target state="translated">우리는 기본 사항을 설명하고 고급 전략에 대한 &lt;a href=&quot;cookbook#cookbook-plotting&quot;&gt;요리 책&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="daf8c563868f44b0272e8d5cc7a778f770775082" translate="yes" xml:space="preserve">
          <source>We will use a similar starting frame from above:</source>
          <target state="translated">위와 비슷한 시작 프레임을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3f1f5f707fa252d49cc9bf0c53fb482c902ce099" translate="yes" xml:space="preserve">
          <source>We would expect the result to now have mean 0 and standard deviation 1 within each group, which we can easily check:</source>
          <target state="translated">이제 결과가 각 그룹 내에서 평균 0과 표준 편차 1을 가질 것으로 예상하며,이를 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06fbc6434257f2f77eecff50e5a1cd034e70b66f" translate="yes" xml:space="preserve">
          <source>We would name this file &lt;code&gt;test_cool_feature.py&lt;/code&gt; and put in an appropriate place in the &lt;code&gt;pandas/tests/&lt;/code&gt; structure.</source>
          <target state="translated">이 파일의 이름을 &lt;code&gt;test_cool_feature.py&lt;/code&gt; 로 지정하고 &lt;code&gt;pandas/tests/&lt;/code&gt; 구조 의 적절한 위치에 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="89ed8c16ecef55c94f5e4643f3e18e6dc2043d65" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d like to make it easier for users to find these projects, if you know of other substantial projects that you feel should be on this list, please let us know.</source>
          <target state="translated">이 목록에 있어야 할 다른 실질적인 프로젝트에 대해 알고 있다면 알려 주시기 바랍니다.</target>
        </trans-unit>
        <trans-unit id="1f0d4a40c311d765600587cc6f63c4e10e3eafe9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll give a brief intro to the data structures, then consider all of the broad categories of functionality and methods in separate sections.</source>
          <target state="translated">데이터 구조에 대해 간략하게 소개 한 다음 광범위한 범주의 기능 및 방법을 모두 별도의 섹션에서 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8496f6a9354dcb08493a2cb263beee263bcffbc2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll import &lt;code&gt;dask.dataframe&lt;/code&gt; and notice that the API feels similar to pandas. We can use Dask&amp;rsquo;s &lt;code&gt;read_parquet&lt;/code&gt; function, but provide a globstring of files to read in.</source>
          <target state="translated">&lt;code&gt;dask.dataframe&lt;/code&gt; 을 가져 오면 API가 pandas와 비슷하다는 것을 알 수 있습니다. Dask의 &lt;code&gt;read_parquet&lt;/code&gt; 함수를 사용할 수 있지만 읽을 파일의 globstring을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ae5eccc0c4a556e2b48bb680bd279db55b8dde2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll now kick off a three-step process:</source>
          <target state="translated">이제 3 단계 프로세스를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="10e6bd615616d3dd1d8b14add5672ae8746d449e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll rewrite our &lt;code&gt;highlight-max&lt;/code&gt; to handle either Series (from &lt;code&gt;.apply(axis=0 or 1)&lt;/code&gt;) or DataFrames (from &lt;code&gt;.apply(axis=None)&lt;/code&gt;). We&amp;rsquo;ll also allow the color to be adjustable, to demonstrate that &lt;code&gt;.apply&lt;/code&gt;, and &lt;code&gt;.applymap&lt;/code&gt; pass along keyword arguments.</source>
          <target state="translated">Series ( &lt;code&gt;.apply(axis=0 or 1)&lt;/code&gt; ) 또는 DataFrames ( &lt;code&gt;.apply(axis=None)&lt;/code&gt; ) 를 처리하기 위해 &lt;code&gt;highlight-max&lt;/code&gt; 를 다시 작성합니다 . 또한 &lt;code&gt;.apply&lt;/code&gt; 및 &lt;code&gt;.applymap&lt;/code&gt; 이 키워드 인수와 함께 전달됨 을 보여주기 위해 색상을 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="159d163fa57bcd0b14d3f4978b201602523dd7f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start off with a quick reference guide pairing some common R operations using &lt;a href=&quot;https://cran.r-project.org/package=dplyr&quot;&gt;dplyr&lt;/a&gt; with pandas equivalents.</source>
          <target state="translated">&lt;a href=&quot;https://cran.r-project.org/package=dplyr&quot;&gt;dplyr&lt;/a&gt; 을 사용 하여 팬더에 해당하는 몇 가지 일반적인 R 작업을 결합하는 빠른 참조 안내서부터 시작하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="0b6a81fdafac489ae42a2457199a41786380211d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start with a quick, non-comprehensive overview of the fundamental data structures in pandas to get you started. The fundamental behavior about data types, indexing, and axis labeling / alignment apply across all of the objects. To get started, import NumPy and load pandas into your namespace:</source>
          <target state="translated">시작하기 위해 팬더의 기본 데이터 구조에 대한 포괄적이고 포괄적 인 개요부터 시작하겠습니다. 데이터 유형, 인덱싱 및 축 레이블링 / 정렬에 대한 기본 동작은 모든 객체에 적용됩니다. 시작하려면 NumPy를 가져 와서 팬더를 네임 스페이스에로드하십시오.</target>
        </trans-unit>
        <trans-unit id="dee2dc2b4d8d869b4a335a6c5f4e8c9bf8cc7b1a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the following template:</source>
          <target state="translated">다음 템플릿을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="479e0c4d9672ed96a65156668baa33e6eb046994" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve &amp;ldquo;sparsified&amp;rdquo; the higher levels of the indexes to make the console output a bit easier on the eyes. Note that how the index is displayed can be controlled using the &lt;code&gt;multi_sparse&lt;/code&gt; option in &lt;code&gt;pandas.set_options()&lt;/code&gt;:</source>
          <target state="translated">콘솔 출력이 눈에 좀 더 쉽게 보이도록 더 높은 수준의 인덱스를 &quot;분할&quot;했습니다. 색인이 표시되는 방법은 &lt;code&gt;pandas.set_options()&lt;/code&gt; 의 &lt;code&gt;multi_sparse&lt;/code&gt; 옵션을 사용하여 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf5e0503af0c2facdb698cddfc9ea5b96d482f65" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve gotten another big improvement. Let&amp;rsquo;s check again where the time is spent:</source>
          <target state="translated">우리는 또 다른 큰 개선을 얻었습니다. 시간이 소비되는 곳을 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="fe3f61ddecbabd9df7b81c596b0e344f7a9a1ef0" translate="yes" xml:space="preserve">
          <source>Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.</source>
          <target state="translated">연도의 주 번호 (월요일의 첫 번째 요일)를 10 진수로 표시합니다 [00,53]. 첫 번째 월요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3aadb81eb1a1699671247b51c01b0cc44432b8bb" translate="yes" xml:space="preserve">
          <source>Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Sunday are considered to be in week 0.</source>
          <target state="translated">연도의 주 번호 (일요일의 첫 번째 요일)를 10 진수로 표시합니다 [00,53]. 첫 번째 일요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ae4d401c1a4f25ec8086ee891e99815d27c2ac1f" translate="yes" xml:space="preserve">
          <source>Week.apply()</source>
          <target state="translated">Week.apply()</target>
        </trans-unit>
        <trans-unit id="2ea63c38639d2f41feff58a8f5bee0c11f01d0ac" translate="yes" xml:space="preserve">
          <source>Week.apply_index()</source>
          <target state="translated">Week.apply_index()</target>
        </trans-unit>
        <trans-unit id="d399c7c8de3bbcd8117f8e6e94f590b4e71cd672" translate="yes" xml:space="preserve">
          <source>Week.base</source>
          <target state="translated">Week.base</target>
        </trans-unit>
        <trans-unit id="04afe26a45d8a8d73c09907bb58f218a67da3aab" translate="yes" xml:space="preserve">
          <source>Week.copy()</source>
          <target state="translated">Week.copy()</target>
        </trans-unit>
        <trans-unit id="fdb5f2fe37eb6fdfe12c399f6833723ea7e80e3b" translate="yes" xml:space="preserve">
          <source>Week.freqstr</source>
          <target state="translated">Week.freqstr</target>
        </trans-unit>
        <trans-unit id="ffcdf8f135e8a23ec919d4ff0f9f55c95927e0cf" translate="yes" xml:space="preserve">
          <source>Week.isAnchored()</source>
          <target state="translated">Week.isAnchored()</target>
        </trans-unit>
        <trans-unit id="555e5439462bfd854ceddaaec5090f41fede7156" translate="yes" xml:space="preserve">
          <source>Week.kwds</source>
          <target state="translated">Week.kwds</target>
        </trans-unit>
        <trans-unit id="0ddf2abd99bc8bdb3bea7c4e1e066cd7c4bbf73d" translate="yes" xml:space="preserve">
          <source>Week.name</source>
          <target state="translated">Week.name</target>
        </trans-unit>
        <trans-unit id="89c4cfc4854cb94d50e1dcb282025a4140533496" translate="yes" xml:space="preserve">
          <source>Week.nanos</source>
          <target state="translated">Week.nanos</target>
        </trans-unit>
        <trans-unit id="307856caed15c8ab0682d665f0cab83ee759b9f0" translate="yes" xml:space="preserve">
          <source>Week.normalize</source>
          <target state="translated">Week.normalize</target>
        </trans-unit>
        <trans-unit id="114acbc33fdd764b4598e5188dacb62dd85b046f" translate="yes" xml:space="preserve">
          <source>Week.onOffset()</source>
          <target state="translated">Week.onOffset()</target>
        </trans-unit>
        <trans-unit id="bd355446a8a25d6031315e7cff03557559f81ab6" translate="yes" xml:space="preserve">
          <source>Week.rollback()</source>
          <target state="translated">Week.rollback()</target>
        </trans-unit>
        <trans-unit id="1fc0235444db6e1e7b27c624996d23c22902bf3f" translate="yes" xml:space="preserve">
          <source>Week.rollforward()</source>
          <target state="translated">Week.rollforward()</target>
        </trans-unit>
        <trans-unit id="f6caa2d3180c67f24a3e9dad730b1489eb370da3" translate="yes" xml:space="preserve">
          <source>Week.rule_code</source>
          <target state="translated">Week.rule_code</target>
        </trans-unit>
        <trans-unit id="4479d9e9e60e5c4a660f52b0c3aa3ea36acec440" translate="yes" xml:space="preserve">
          <source>WeekOfMonth</source>
          <target state="translated">WeekOfMonth</target>
        </trans-unit>
        <trans-unit id="cf6568fc5ac2465f23e3b100948d004c7f69190f" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.apply()</source>
          <target state="translated">WeekOfMonth.apply()</target>
        </trans-unit>
        <trans-unit id="2ab406caef7053bcfa1ba04234139b92f4898a33" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.apply_index()</source>
          <target state="translated">WeekOfMonth.apply_index()</target>
        </trans-unit>
        <trans-unit id="98fa89d70c03074699d14f851176eb07a79c5b3a" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.base</source>
          <target state="translated">WeekOfMonth.base</target>
        </trans-unit>
        <trans-unit id="4b17d3716cffc78e73b163f0dd7bbf6711095053" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.copy()</source>
          <target state="translated">WeekOfMonth.copy()</target>
        </trans-unit>
        <trans-unit id="fa5d6058fe2a19d364efa47cfab2df8f25db82b4" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.freqstr</source>
          <target state="translated">WeekOfMonth.freqstr</target>
        </trans-unit>
        <trans-unit id="bba514c842f4011cf97d88bb6144ce2d96e81301" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.isAnchored()</source>
          <target state="translated">WeekOfMonth.isAnchored()</target>
        </trans-unit>
        <trans-unit id="9891edac55b553d1dd9064d890a2fad51759efdf" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.kwds</source>
          <target state="translated">WeekOfMonth.kwds</target>
        </trans-unit>
        <trans-unit id="ea7f176d18009039b337d9d9644e7655410a9dbb" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.name</source>
          <target state="translated">WeekOfMonth.name</target>
        </trans-unit>
        <trans-unit id="4223cc0f6d0434592aeeb0f219087e45612abdd1" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.nanos</source>
          <target state="translated">WeekOfMonth.nanos</target>
        </trans-unit>
        <trans-unit id="da712defeb66da6630af6d1f616c83b0816681e4" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.normalize</source>
          <target state="translated">WeekOfMonth.normalize</target>
        </trans-unit>
        <trans-unit id="d5324bd33937198e4319b5d916e32e9ebdf8f6a4" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.onOffset()</source>
          <target state="translated">WeekOfMonth.onOffset()</target>
        </trans-unit>
        <trans-unit id="f3f592d4d4858873ef2a71ade526f849dc97ed9c" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.rollback()</source>
          <target state="translated">WeekOfMonth.rollback()</target>
        </trans-unit>
        <trans-unit id="a237bcf97a357ae7a25d60524545bd3bb1c2542d" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.rollforward()</source>
          <target state="translated">WeekOfMonth.rollforward()</target>
        </trans-unit>
        <trans-unit id="472a35b2d03ca2226280c71e37437c6f2088f423" translate="yes" xml:space="preserve">
          <source>WeekOfMonth.rule_code</source>
          <target state="translated">WeekOfMonth.rule_code</target>
        </trans-unit>
        <trans-unit id="da94621ef8999a8ac972599f062234bc846d53f9" translate="yes" xml:space="preserve">
          <source>Weekday as a decimal number [0(Sunday),6].</source>
          <target state="translated">평일을 10 진수로 표시 [0 (일요일), 6].</target>
        </trans-unit>
        <trans-unit id="202222909e680eb046bb5844a287c34bdb3afdb7" translate="yes" xml:space="preserve">
          <source>Weekly offset.</source>
          <target state="translated">주간 오프셋.</target>
        </trans-unit>
        <trans-unit id="72d15f7d9a40b01277c4341044c04afdefd5876f" translate="yes" xml:space="preserve">
          <source>Weekmask of valid business days, passed to &lt;code&gt;numpy.busdaycalendar&lt;/code&gt;, only used when custom frequency strings are passed. The default value None is equivalent to &amp;lsquo;Mon Tue Wed Thu Fri&amp;rsquo;.</source>
          <target state="translated">에 전달 유효한 일의 Weekmask, &lt;code&gt;numpy.busdaycalendar&lt;/code&gt; 은 지정 주파수 문자열이 전달되는 경우에만 사용. 기본값 None은 'Mon Tue Wed Thu Fri'과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8374b24155b155d171fa90b81bc7996eccced804" translate="yes" xml:space="preserve">
          <source>Weekmask of valid business days, passed to &lt;code&gt;numpy.busdaycalendar&lt;/code&gt;.</source>
          <target state="translated">유효한 영업일의 주 &lt;code&gt;numpy.busdaycalendar&lt;/code&gt; 로 numpy.busdaycalendar로 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="407570959e478277dd88d698bf486d6ce9c098ce" translate="yes" xml:space="preserve">
          <source>Weighted window</source>
          <target state="translated">가중 창</target>
        </trans-unit>
        <trans-unit id="7267e2200141c5c35e4a02ad32ed906ebdbe57f1" translate="yes" xml:space="preserve">
          <source>Weighted window functions</source>
          <target state="translated">가중 창 기능</target>
        </trans-unit>
        <trans-unit id="906005ab0985da26c5c9fd94f77717f9c5a24f3f" translate="yes" xml:space="preserve">
          <source>Weighted window: Weighted, non-rectangular window supplied by the &lt;code&gt;scipy.signal&lt;/code&gt; library.</source>
          <target state="translated">가중 창 : &lt;code&gt;scipy.signal&lt;/code&gt; 라이브러리에서 제공하는 가중, 직사각형이 아닌 창 .</target>
        </trans-unit>
        <trans-unit id="897888bd5751f5716b4307fda3c9e3db66f3bf5a" translate="yes" xml:space="preserve">
          <source>Wes McKinney is the Benevolent Dictator for Life (BDFL).</source>
          <target state="translated">Wes McKinney는 생명의 자비로운 독재자 (BDFL)입니다.</target>
        </trans-unit>
        <trans-unit id="d8a152a201fdedd56c09dd4b18b7b017ea556352" translate="yes" xml:space="preserve">
          <source>Wes McKinney&amp;rsquo;s (pandas BDFL) blog</source>
          <target state="translated">웨스 맥키 니 (팬더 BDFL) 블로그</target>
        </trans-unit>
        <trans-unit id="664ec2b7c6626f568d548eafe9b484ca52d9e724" translate="yes" xml:space="preserve">
          <source>What if you wanted to highlight just the maximum value in the entire table? Use &lt;code&gt;.apply(function, axis=None)&lt;/code&gt; to indicate that your function wants the entire table, not one column or row at a time. Let&amp;rsquo;s try that next.</source>
          <target state="translated">전체 테이블에서 최대 값 만 강조 표시하려면 어떻게해야합니까? 사용 &lt;code&gt;.apply(function, axis=None)&lt;/code&gt; 함수는 전체 테이블을 한 번에없는 하나의 열 또는 행을 원한다는 것을 나타냅니다. 다음에 해봅시다.</target>
        </trans-unit>
        <trans-unit id="ffa869057c19e85dfdf68c5951ee65cecc28b902" translate="yes" xml:space="preserve">
          <source>What is actually happening here is that a function wrapper is being generated. When invoked, it takes any passed arguments and invokes the function with any arguments on each group (in the above example, the &lt;code&gt;std&lt;/code&gt; function). The results are then combined together much in the style of &lt;code&gt;agg&lt;/code&gt; and &lt;code&gt;transform&lt;/code&gt; (it actually uses &lt;code&gt;apply&lt;/code&gt; to infer the gluing, documented next). This enables some operations to be carried out rather succinctly:</source>
          <target state="translated">여기서 실제로 일어나는 것은 함수 래퍼가 생성되고 있다는 것입니다. 호출되면 전달 된 인수를 취하고 각 그룹의 인수와 함께 함수를 호출합니다 (위의 예에서 &lt;code&gt;std&lt;/code&gt; 함수). 결과는 다음 함께 많은 스타일의 결합 &lt;code&gt;agg&lt;/code&gt; 및 &lt;code&gt;transform&lt;/code&gt; (실제로 사용은 &lt;code&gt;apply&lt;/code&gt; 호부, 다음 기록을 추론하는). 이를 통해 일부 작업을 다소 간결하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fdb080faedd14c64ffe92326926270aa2b60f0e" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s new in 0.25.0 (July 18, 2019)</source>
          <target state="translated">0.25.0의 새로운 기능 (2019 년 7 월 18 일)</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="608abcddce87cd414e6565a3333be6bd01f5cac9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;adjust=False&lt;/code&gt; is specified, moving averages are calculated as</source>
          <target state="translated">경우 &lt;code&gt;adjust=False&lt;/code&gt; 지정되어, 이동 평균은 다음과 같이 계산된다</target>
        </trans-unit>
        <trans-unit id="b5a8c5c7ce1f2aad45a890656b995c4f814b5e59" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;adjust=False&lt;/code&gt;, the exponentially weighted function is calculated recursively:</source>
          <target state="translated">경우 &lt;code&gt;adjust=False&lt;/code&gt; 상기 지수 가중 함수를 반복적으로 계산된다 :</target>
        </trans-unit>
        <trans-unit id="f59154d9fc56f1d16c67656eeaa4dcb42547e725" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;adjust=True&lt;/code&gt; (default), the EW function is calculated using weights \(w_i = (1 - \alpha)^i\). For example, the EW moving average of the series [\(x_0, x_1, ..., x_t\)] would be:</source>
          <target state="translated">경우 &lt;code&gt;adjust=True&lt;/code&gt; (- \ 알파) ^ I \ w_i = (1)을 (기본값) EW 기능 \ 가중치를 이용하여 계산된다. 예를 들어, 계열 [\ (x_0, x_1, ..., x_t \)]의 EW 이동 평균은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84848e07e5f15a6368f1abcf75501f60407628f3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;arg&lt;/code&gt; is a dictionary, values in Series that are not in the dictionary (as keys) are converted to &lt;code&gt;NaN&lt;/code&gt;. However, if the dictionary is a &lt;code&gt;dict&lt;/code&gt; subclass that defines &lt;code&gt;__missing__&lt;/code&gt; (i.e. provides a method for default values), then this default is used rather than &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;arg&lt;/code&gt; 사전입니다 (키)을 사전에없는 시리즈의 값으로 변환됩니다 &lt;code&gt;NaN&lt;/code&gt; 가 . 그러나 사전이 &lt;code&gt;__missing__&lt;/code&gt; 을 정의 하는 (즉, 기본값에 대한 메소드를 제공 하는) &lt;code&gt;dict&lt;/code&gt; 서브 클래스 인 경우이 기본값이 &lt;code&gt;NaN&lt;/code&gt; 대신 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a629ca65ed3e2b53a2653af2fb6f28853869e52" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;data&lt;/code&gt; is a &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;, or &lt;code&gt;ExtensionArray&lt;/code&gt;, the &lt;code&gt;dtype&lt;/code&gt; will be taken from the data.</source>
          <target state="translated">때 &lt;code&gt;data&lt;/code&gt; A는 &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; , 또는 &lt;code&gt;ExtensionArray&lt;/code&gt; 의 &lt;code&gt;dtype&lt;/code&gt; 데이터에서 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b26451d772c37350185a221549cb3da766ba4e9c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;data&lt;/code&gt; is an Index or Series, the underlying array will be extracted from &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 인덱스 또는 일련의 기본 어레이로부터 추출 될 &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6f55025e139e1ea4a1d176fe427cb2547b40464" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;data&lt;/code&gt; is not 1-dimensional.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 1 차원 아니다.</target>
        </trans-unit>
        <trans-unit id="633c3b0fede651f5070f4b31c047a0ad941cb811" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;deep=False&lt;/code&gt;, a new object will be created without copying the calling object&amp;rsquo;s data or index (only references to the data and index are copied). Any changes to the data of the original will be reflected in the shallow copy (and vice versa).</source>
          <target state="translated">때 &lt;code&gt;deep=False&lt;/code&gt; 새로운 객체는 호출 개체의 데이터 또는 인덱스 (복사되는 데이터와 인덱스 만 참조)을 복사하지 않고 생성됩니다. 원본 데이터의 모든 변경 사항은 얕은 사본에 반영되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4dadf63d39355c7633e3ea16f95da962fa26660d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;deep=True&lt;/code&gt; (default), a new object will be created with a copy of the calling object&amp;rsquo;s data and indices. Modifications to the data or indices of the copy will not be reflected in the original object (see notes below).</source>
          <target state="translated">때 &lt;code&gt;deep=True&lt;/code&gt; (기본값), 새로운 객체가 호출하는 객체의 데이터와 인덱스의 사본이 생성됩니다. 사본의 데이터 또는 색인에 대한 수정 사항은 원본 객체에 반영되지 않습니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="c48822ec5ed372a1cbeccfb345545355a199ccad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;deep=True&lt;/code&gt;, data is copied but actual Python objects will not be copied recursively, only the reference to the object. This is in contrast to</source>
          <target state="translated">때 &lt;code&gt;deep=True&lt;/code&gt; , 데이터가 복사되어 있지만 실제 파이썬 객체는, 재귀 적 객체에 대한 참조 만 복사되지 않습니다. 이것은</target>
        </trans-unit>
        <trans-unit id="1412cce4a536a03dcf74a1e073acc5f38c7a66c3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;deep=True&lt;/code&gt;, data is copied but actual Python objects will not be copied recursively, only the reference to the object. This is in contrast to &lt;code&gt;copy.deepcopy&lt;/code&gt; in the Standard Library, which recursively copies object data (see examples below).</source>
          <target state="translated">때 &lt;code&gt;deep=True&lt;/code&gt; , 데이터가 복사되어 있지만 실제 파이썬 객체는, 재귀 적 객체에 대한 참조 만 복사되지 않습니다. 이는 표준 라이브러리의 &lt;code&gt;copy.deepcopy&lt;/code&gt; 와 대조적으로 객체 데이터를 재귀 적으로 복사합니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="698da391d0d8420164854ec7d7972344263ee78a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;drop&lt;/code&gt; is False (the default), a DataFrame is returned. The newly created columns will come first in the DataFrame, followed by the original Series values. When &lt;code&gt;drop&lt;/code&gt; is True, a &lt;code&gt;Series&lt;/code&gt; is returned. In either case, if &lt;code&gt;inplace=True&lt;/code&gt;, no value is returned.</source>
          <target state="translated">때 &lt;code&gt;drop&lt;/code&gt; (기본값) False입니다하는 DataFrame이 반환됩니다. 새로 생성 된 열은 DataFrame에서 먼저 나온 다음 원래 Series 값이 뒤 따릅니다. 때 &lt;code&gt;drop&lt;/code&gt; True 인하는 &lt;code&gt;Series&lt;/code&gt; 반환됩니다. 두 경우 모두 &lt;code&gt;inplace=True&lt;/code&gt; 이면 값이 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d95753a3c99a78bf757b75d4a33979b247f3240" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dtype&lt;/code&gt; is a &lt;code&gt;CategoricalDtype&lt;/code&gt; with homogeneous &lt;code&gt;categories&lt;/code&gt; ( all numeric, all datetimes, etc.), the conversion is done automatically.</source>
          <target state="translated">경우 &lt;code&gt;dtype&lt;/code&gt; A는 &lt;code&gt;CategoricalDtype&lt;/code&gt; 균질와 &lt;code&gt;categories&lt;/code&gt; (모든 숫자, 모든 날짜 시간 등)의 전환은 자동으로 수행된다.</target>
        </trans-unit>
        <trans-unit id="98bb210d512bead4e20db684ceb400531c53e5b0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;errors&lt;/code&gt; is not either &lt;code&gt;&amp;lsquo;ignore&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;raise&amp;rsquo;&lt;/code&gt;</source>
          <target state="translated">때 &lt;code&gt;errors&lt;/code&gt; 중 하나없는 &lt;code&gt;&amp;lsquo;ignore&amp;rsquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;lsquo;raise&amp;rsquo;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bd7bd661c270225216e4ff0bcf96cca3e999fee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;errors=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; and there&amp;rsquo;s overlapping non-NA data.</source>
          <target state="translated">경우 &lt;code&gt;errors=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; 와 거기에 중첩있어 비 NA 데이터.</target>
        </trans-unit>
        <trans-unit id="d7c6b4c4b301dcacae4cb36904290440316003e1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;freq&lt;/code&gt; is not passed, shift the index without realigning the data. If &lt;code&gt;freq&lt;/code&gt; is passed (in this case, the index must be date or datetime, or it will raise a &lt;code&gt;NotImplementedError&lt;/code&gt;), the index will be increased using the periods and the &lt;code&gt;freq&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;freq&lt;/code&gt; 전달되지 데이터를 재조정하지 않고 인덱스를 이동. &lt;code&gt;freq&lt;/code&gt; 가 전달 되면 (이 경우 인덱스는 날짜 또는 날짜 / 시간이거나 &lt;code&gt;NotImplementedError&lt;/code&gt; 가 발생 함 ) 기간 및 &lt;code&gt;freq&lt;/code&gt; 를 사용하여 인덱스가 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="2dbf3cd0890eeca70e7fb5bcec42a32e68ae5202" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;freq&lt;/code&gt; is specified, &lt;code&gt;shift&lt;/code&gt; method changes all the dates in the index rather than changing the alignment of the data and the index:</source>
          <target state="translated">경우 &lt;code&gt;freq&lt;/code&gt; 지정되어 &lt;code&gt;shift&lt;/code&gt; 방법 대신 데이터 및 인덱스의 정렬을 변경하는 대신 인덱스의 모든 날짜 변경 :</target>
        </trans-unit>
        <trans-unit id="98f361aad0ba1ea715cc235a3f1851f09cc260bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ignore_na=False&lt;/code&gt; (default), weights are based on absolute positions. For example, the weights of \(x_0\) and \(x_2\) used in calculating the final weighted average of [\(x_0\), None, \(x_2\)] are \((1-\alpha)^2\) and \(1\) if &lt;code&gt;adjust=True&lt;/code&gt;, and \((1-\alpha)^2\) and \(\alpha\) if &lt;code&gt;adjust=False&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;ignore_na=False&lt;/code&gt; (기본값), 무게는 절대 위치를 기반으로합니다. 예를 들어 [\ (x_0 \), None, \ (x_2 \)]의 최종 가중 평균을 계산하는 데 사용 된 \ (x_0 \) 및 \ (x_2 \)의 가중치는 \ ((1- \ alpha) ^입니다. 2 \) 및 \ (1 \) if &lt;code&gt;adjust=True&lt;/code&gt; , \ ((1- \ alpha) ^ 2 \) 및 \ (\ alpha \) if &lt;code&gt;adjust=False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae7383841fe8d5f29001211450c0c5becd8a52bd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ignore_na=True&lt;/code&gt; (reproducing pre-0.15.0 behavior), weights are based on relative positions. For example, the weights of \(x_0\) and \(x_2\) used in calculating the final weighted average of [\(x_0\), None, \(x_2\)] are \(1-\alpha\) and \(1\) if &lt;code&gt;adjust=True&lt;/code&gt;, and \(1-\alpha\) and \(\alpha\) if &lt;code&gt;adjust=False&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;ignore_na=True&lt;/code&gt; , 가중치는 상대적 위치를 기반으로 (사전 0.15.0 동작을 재현). 예를 들어 [\ (x_0 \), None, \ (x_2 \)]의 최종 가중 평균을 계산하는 데 사용 된 \ (x_0 \) 및 \ (x_2 \)의 가중치는 \ (1- \ alpha \)이고 \ (1 \) 경우 &lt;code&gt;adjust=True&lt;/code&gt; , 그리고 \ (1 \ 알파 \)와 \ (\ 알파 \)의 경우 &lt;code&gt;adjust=False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24cb26b7f4f6662f42d0db6c2c3521cac1d74beb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;indices&lt;/code&gt; contains negative values other than &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;allow_fill&lt;/code&gt; is True.</source>
          <target state="translated">경우 &lt;code&gt;indices&lt;/code&gt; 이외의 음의 값을 포함 &lt;code&gt;-1&lt;/code&gt; 및 &lt;code&gt;allow_fill&lt;/code&gt; 참이다.</target>
        </trans-unit>
        <trans-unit id="e5edaa84138910db9e7f22918782c0550972dc23" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;inplace&lt;/code&gt; is set to &lt;code&gt;False&lt;/code&gt;, a copy of the &lt;code&gt;DataFrame&lt;/code&gt; with the new or modified columns is returned and the original frame is unchanged.</source>
          <target state="translated">&lt;code&gt;inplace&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 로 설정 되면 새 열 또는 수정 된 열이 있는 &lt;code&gt;DataFrame&lt;/code&gt; 의 복사본 이 반환되고 원래 프레임은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c34f365247800a7955bf35ab0023ee0f50ffd99f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;inplace&lt;/code&gt; is set to &lt;code&gt;False&lt;/code&gt;, the default, a copy of the &lt;code&gt;DataFrame&lt;/code&gt; with the new or modified columns is returned and the original frame is unchanged.</source>
          <target state="translated">&lt;code&gt;inplace&lt;/code&gt; 가 기본값 인 &lt;code&gt;False&lt;/code&gt; 로 설정 되면 새 열 또는 수정 된 열이 있는 &lt;code&gt;DataFrame&lt;/code&gt; 의 복사본 이 반환되고 원래 프레임은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a2d134197e8c446b76ec8758a708383016cf5d6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;n&lt;/code&gt; is not 0, if the given date is not on an anchor point, it snapped to the next(previous) anchor point, and moved &lt;code&gt;|n|-1&lt;/code&gt; additional steps forwards or backwards.</source>
          <target state="translated">때 &lt;code&gt;n&lt;/code&gt; 은 주어진 날짜가 고정 점에서 사용하지 않을 경우 0이 아닌, 다음 (이전) 고정 점에 스냅하고, 이동 &lt;code&gt;|n|-1&lt;/code&gt; 추가 단계를 앞으로 또는 뒤로.</target>
        </trans-unit>
        <trans-unit id="a027af5fff689d5970cdac0acd9a9b2b525068f9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;other&lt;/code&gt; is a &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;, the columns of a DataFrame are aligned with the index of &lt;code&gt;other&lt;/code&gt; and broadcast:</source>
          <target state="translated">때 &lt;code&gt;other&lt;/code&gt; A는 &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 하는 DataFrame의 열을 인덱스로 정렬 &lt;code&gt;other&lt;/code&gt; 방송 :</target>
        </trans-unit>
        <trans-unit id="c84d437b4d44f816a605f14eb6a5c02f99005d16" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;other&lt;/code&gt; is not specified, the output will be self correlation (e.g. all 1&amp;rsquo;s), except for &lt;a href=&quot;pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; inputs with &lt;code&gt;pairwise&lt;/code&gt; set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;other&lt;/code&gt; 지정되지 않은, 출력을 제외하고 자기 상관 관계 (예 : 모두 1)이 될 것입니다 &lt;a href=&quot;pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 의&lt;/a&gt; 와 입력 &lt;code&gt;pairwise&lt;/code&gt; 로 설정 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="824d36d88f8257d693d442aab5aaf270c628119b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pairwise&lt;/code&gt; is set to &lt;code&gt;False&lt;/code&gt;, only matching columns between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;pairwise&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 로 설정 되면 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이의 일치하는 열만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6cb1a15c79f43bda18f8fbced4f9df0b3b6261fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pairwise&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;, the output will be a MultiIndex DataFrame with the original index on the first level, and the &lt;code&gt;other&lt;/code&gt; DataFrame columns on the second level.</source>
          <target state="translated">&lt;code&gt;pairwise&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 설정 되면 출력은 첫 번째 수준의 원래 인덱스와 두 번째 수준의 &lt;code&gt;other&lt;/code&gt; DataFrame 열이있는 MultiIndex DataFrame이됩니다.</target>
        </trans-unit>
        <trans-unit id="d3456064fa6892d968ebd4d898b3b0f918838107" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pat&lt;/code&gt; is a compiled regex, all flags should be included in the compiled regex. Use of &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;, or &lt;code&gt;regex=False&lt;/code&gt; with a compiled regex will raise an error.</source>
          <target state="translated">때 &lt;code&gt;pat&lt;/code&gt; 컴파일 된 정규식, 모든 플래그는 컴파일 된 정규식에 포함되어야한다. 컴파일 된 정규식 에 &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; 또는 &lt;code&gt;regex=False&lt;/code&gt; 를 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1f71c418df4d0713f3cb3305c6a2e45802016d6a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pat&lt;/code&gt; is a string and &lt;code&gt;regex&lt;/code&gt; is False, every &lt;code&gt;pat&lt;/code&gt; is replaced with &lt;code&gt;repl&lt;/code&gt; as with &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.replace&quot;&gt;&lt;code&gt;str.replace()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">때 &lt;code&gt;pat&lt;/code&gt; 문자열과 &lt;code&gt;regex&lt;/code&gt; 거짓이며, 모든 &lt;code&gt;pat&lt;/code&gt; 로 대체 &lt;code&gt;repl&lt;/code&gt; 에서와 같이 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.replace&quot;&gt; &lt;code&gt;str.replace()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3ae8a85fc80eb19330172a8575714f5dc174e73a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pat&lt;/code&gt; is a string and &lt;code&gt;regex&lt;/code&gt; is True (the default), the given &lt;code&gt;pat&lt;/code&gt; is compiled as a regex. When &lt;code&gt;repl&lt;/code&gt; is a string, it replaces matching regex patterns as with &lt;code&gt;re.sub()&lt;/code&gt;. NaN value(s) in the Series are left as is:</source>
          <target state="translated">때 &lt;code&gt;pat&lt;/code&gt; 문자열과 &lt;code&gt;regex&lt;/code&gt; true (디폴트), 주어진 &lt;code&gt;pat&lt;/code&gt; 정규식으로 컴파일됩니다. 경우 &lt;code&gt;repl&lt;/code&gt; 문자열이며, 그와 같이 일치하는 정규식 패턴을 대체 &lt;code&gt;re.sub()&lt;/code&gt; . 시리즈의 NaN 값은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a189ca0dd832e94427884b8ed84c8d3a5dfbe369" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;quotechar&lt;/code&gt; is specified and &lt;code&gt;quoting&lt;/code&gt; is not &lt;code&gt;QUOTE_NONE&lt;/code&gt;, indicate whether or not to interpret two consecutive &lt;code&gt;quotechar&lt;/code&gt; elements &lt;strong&gt;inside&lt;/strong&gt; a field as a single &lt;code&gt;quotechar&lt;/code&gt; element.</source>
          <target state="translated">때 &lt;code&gt;quotechar&lt;/code&gt; 가 지정되어 &lt;code&gt;quoting&lt;/code&gt; 아닌 &lt;code&gt;QUOTE_NONE&lt;/code&gt; , 두 개의 연속적인 해석할지 여부를 나타냅니다 &lt;code&gt;quotechar&lt;/code&gt; 의 요소 &lt;strong&gt;내부에&lt;/strong&gt; 단일로 필드를 &lt;code&gt;quotechar&lt;/code&gt; 의 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2480d3b5e08947ecb55308b072d091cb044453b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;repl&lt;/code&gt; is a callable, it is called on every &lt;code&gt;pat&lt;/code&gt; using &lt;a href=&quot;https://docs.python.org/3/library/re.html#re.sub&quot;&gt;&lt;code&gt;re.sub()&lt;/code&gt;&lt;/a&gt;. The callable should expect one positional argument (a regex object) and return a string.</source>
          <target state="translated">하면 &lt;code&gt;repl&lt;/code&gt; 호출 가능, 그것은마다 호출됩니다 &lt;code&gt;pat&lt;/code&gt; 사용 &lt;a href=&quot;https://docs.python.org/3/library/re.html#re.sub&quot;&gt; &lt;code&gt;re.sub()&lt;/code&gt; &lt;/a&gt; . 콜 러블은 하나의 위치 인수 (정규 객체)를 예상하고 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="30cbb0dfef31ecbfcfc4652e551efe57f9470dcb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;value=None&lt;/code&gt; and</source>
          <target state="translated">되면 &lt;code&gt;value=None&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="12a7b6833d6941a0a50247de3f6832a87c1cd54d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;value=None&lt;/code&gt; and &lt;code&gt;to_replace&lt;/code&gt; is a scalar, list or tuple, &lt;code&gt;replace&lt;/code&gt; uses the method parameter (default &amp;lsquo;pad&amp;rsquo;) to do the replacement. So this is why the &amp;lsquo;a&amp;rsquo; values are being replaced by 10 in rows 1 and 2 and &amp;lsquo;b&amp;rsquo; in row 4 in this case. The command &lt;code&gt;s.replace('a', None)&lt;/code&gt; is actually equivalent to &lt;code&gt;s.replace(to_replace='a', value=None, method='pad')&lt;/code&gt;:</source>
          <target state="translated">되면 &lt;code&gt;value=None&lt;/code&gt; 과 &lt;code&gt;to_replace&lt;/code&gt; 는 스칼라 목록 또는 튜플없고, &lt;code&gt;replace&lt;/code&gt; 사용을 대체 할 수있는 방법은 파라미터 (디폴트 '패드'). 따라서이 경우 'a'값이 1 행과 2 행에서 10으로, 4 행에서 'b'로 대체되는 이유입니다. &lt;code&gt;s.replace('a', None)&lt;/code&gt; 명령 은 실제로 &lt;code&gt;s.replace(to_replace='a', value=None, method='pad')&lt;/code&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b99fedab983a09a6b838160842c60e8f31cbcb2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;values&lt;/code&gt; is a Series or DataFrame the index and column must match. Note that &amp;lsquo;falcon&amp;rsquo; does not match based on the number of legs in df2.</source>
          <target state="translated">때 &lt;code&gt;values&lt;/code&gt; 시리즈 또는 DataFrame 인 인덱스 컬럼이 일치해야합니다. 'falcon'은 df2의 레그 수에 따라 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1e9f921168fdd4c6dc9434a6d701a2d2838dc75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;values&lt;/code&gt; is a dict, we can pass values to check for each column separately:</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 사전인가는, 우리는 개별적으로 각 열에 대해 체크 값을 전달할 수있다 :</target>
        </trans-unit>
        <trans-unit id="1b19dea60803386e3166721bc8e351ce113cc79b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;values&lt;/code&gt; is a list check whether every value in the DataFrame is present in the list (which animals have 0 or 2 legs or wings)</source>
          <target state="translated">되면 &lt;code&gt;values&lt;/code&gt; 리스트 체크 (이는 동물이 0 또는 2 다리 또는 측면)을 DataFrame마다 값리스트에 존재하는지이며</target>
        </trans-unit>
        <trans-unit id="4cd2f0de18968bbc4eb51419a563a52d16902251" translate="yes" xml:space="preserve">
          <source>When Dask knows the &lt;code&gt;divisions&lt;/code&gt; of a dataset, certain optimizations are possible. When reading parquet datasets written by dask, the divisions will be known automatically. In this case, since we created the parquet files manually, we need to supply the divisions manually.</source>
          <target state="translated">Dask가 데이터 세트 의 &lt;code&gt;divisions&lt;/code&gt; 을 알고 있으면 특정 최적화가 가능합니다. dask가 작성한 parquet 데이터 세트를 읽을 때 분할이 자동으로 알려집니다. 이 경우 수동으로 parquet 파일을 만들었으므로 분할을 수동으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="21d835d4b89bf52676d1f8a17042787fa90614d1" translate="yes" xml:space="preserve">
          <source>When DataFrames are merged on a string that matches an index level in both frames, the index level is preserved as an index level in the resulting DataFrame.</source>
          <target state="translated">DataFrames가 두 프레임의 인덱스 수준과 일치하는 문자열에서 병합 될 때 인덱스 수준은 결과 DataFrame에서 인덱스 수준으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="51149e95c58541aa45c0cb6626e887d5d7d7974e" translate="yes" xml:space="preserve">
          <source>When DataFrames are merged using only some of the levels of a &lt;code&gt;MultiIndex&lt;/code&gt;, the extra levels will be dropped from the resulting merge. In order to preserve those levels, use &lt;code&gt;reset_index&lt;/code&gt; on those level names to move those levels to columns prior to doing the merge.</source>
          <target state="translated">DataFrames이 단지의 수준을 일부 사용하여 병합 될 때 &lt;code&gt;MultiIndex&lt;/code&gt; 을 , 여분의 수준은 결과 병합에서 제외됩니다. 이러한 수준을 유지하려면 해당 수준 이름에 &lt;code&gt;reset_index&lt;/code&gt; 를 사용 하여 병합을 수행하기 전에 해당 수준을 열로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d8cb4370341f8ec9ed33e2a8ebfa15660ceb9701" translate="yes" xml:space="preserve">
          <source>When NA values are present, the output dtype is float64. Similarly for methods returning boolean values.</source>
          <target state="translated">NA 값이 있으면 출력 dtype은 float64입니다. 부울 값을 반환하는 메서드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="e99455464cb42aa5f2f519c4aa938bc094ce02e8" translate="yes" xml:space="preserve">
          <source>When True, IPython notebook will use html representation for pandas objects (if it is available).</source>
          <target state="translated">True이면 IPython 노트북은 pandas 객체 (사용 가능한 경우)에 html 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ba42384960d62dec50d2f07b5264b6777857a9cc" translate="yes" xml:space="preserve">
          <source>When True, IPython notebook will use html representation for pandas objects (if it is available). [default: True] [currently: True]</source>
          <target state="translated">True이면 IPython 노트북은 pandas 객체 (사용 가능한 경우)에 html 표현을 사용합니다. [기본값 : True] [현재 : True]</target>
        </trans-unit>
        <trans-unit id="69643037dc3a0791593193449f290ae1c9ed1688" translate="yes" xml:space="preserve">
          <source>When True, Jupyter notebook will process table contents using MathJax, rendering mathematical expressions enclosed by the dollar symbol.</source>
          <target state="translated">True 인 경우 Jupyter 노트북은 MathJax를 사용하여 테이블 콘텐츠를 처리하여 달러 기호로 묶인 수학 표현식을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="cbcdce0ebe05aa9e9fb04a8417ee7f526ccb68c5" translate="yes" xml:space="preserve">
          <source>When True, Jupyter notebook will process table contents using MathJax, rendering mathematical expressions enclosed by the dollar symbol. (default: True) [default: True] [currently: True]</source>
          <target state="translated">True 인 경우 Jupyter 노트북은 MathJax를 사용하여 테이블 콘텐츠를 처리하여 달러 기호로 묶인 수학 표현식을 렌더링합니다. (기본값 : True) [기본값 : True] [현재 : True]</target>
        </trans-unit>
        <trans-unit id="52a2f01ab1547a0df3b9a2d1a2b91b84657a2d16" translate="yes" xml:space="preserve">
          <source>When True, attempt to create a MultiIndex if possible</source>
          <target state="translated">True 인 경우 가능하면 MultiIndex를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="eb54d579c3e3648ec5173643470fbc22a7c48171" translate="yes" xml:space="preserve">
          <source>When True, attempt to create a MultiIndex if possible.</source>
          <target state="translated">True이면 가능하면 MultiIndex를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5be76dd3008dc237efc61bc5677dd0863c46f701" translate="yes" xml:space="preserve">
          <source>When True, prints and parses dates with the day first, eg 20/01/2005</source>
          <target state="translated">True이면 날짜를 먼저 인쇄하고 구문 분석합니다 (예 : 2005 년 1 월 20 일).</target>
        </trans-unit>
        <trans-unit id="62f20d5a5270deafc9af62b003dfd38314be0e0b" translate="yes" xml:space="preserve">
          <source>When True, prints and parses dates with the day first, eg 20/01/2005 [default: False] [currently: False]</source>
          <target state="translated">True 인 경우 날짜를 먼저 인쇄하고 구문 분석합니다. 예 : 2005 년 20 월 1 일 [기본값 : False] [현재 : False]</target>
        </trans-unit>
        <trans-unit id="50b1f5fad3b0ff7ed899b302ead186369b63be4a" translate="yes" xml:space="preserve">
          <source>When True, prints and parses dates with the year first, eg 2005/01/20</source>
          <target state="translated">True이면 연도가 먼저 인 날짜를 인쇄하고 구문 분석합니다 (예 : 2005/01/20).</target>
        </trans-unit>
        <trans-unit id="ee408bd8dc2d8010e5bde596b5428d67e6655848" translate="yes" xml:space="preserve">
          <source>When True, prints and parses dates with the year first, eg 2005/01/20 [default: False] [currently: False]</source>
          <target state="translated">True이면 연도가 먼저 인 날짜를 인쇄하고 구문 분석합니다. 예 : 2005/01/20 [기본값 : False] [현재 : False]</target>
        </trans-unit>
        <trans-unit id="912f80d917379172fb2dbc2354c59e54f95e199b" translate="yes" xml:space="preserve">
          <source>When a binary ufunc is applied to a &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;, the Series implementation takes precedence and a Series is returned.</source>
          <target state="translated">이진 ufunc가 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; 에&lt;/a&gt; 적용 되면 Series 구현이 우선하고 Series가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9b5461a2cabed78b09a952049b4214cbceb052ea" translate="yes" xml:space="preserve">
          <source>When a column contains only one level, it will be omitted in the result.</source>
          <target state="translated">열에 하나의 수준 만 포함 된 경우 결과에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="3253d170611f6314b1bb68684b9864884fb4fb10" translate="yes" xml:space="preserve">
          <source>When a date offset is created for a negative number of periods, the date is first rolled forward. The pseudo code is:</source>
          <target state="translated">음수의 기간 동안 날짜 오프셋이 작성되면 날짜가 먼저 롤 포워드됩니다. 의사 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fa8de6630b8024332b165ce20591b75d1f4f5e1" translate="yes" xml:space="preserve">
          <source>When a particular set of columns is passed along with a dict of data, the passed columns override the keys in the dict.</source>
          <target state="translated">특정 열 집합이 데이터 사전과 함께 전달되면 전달 된 열이 사전의 키를 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="f21d700ea0297f7c1d5f6f4809b333bb03aa1059" translate="yes" xml:space="preserve">
          <source>When a value is missing in only one of</source>
          <target state="translated">다음 중 하나에서만 값이 누락 된 경우</target>
        </trans-unit>
        <trans-unit id="9cdeaf55a6e46935668be63f419d531c51aa737f" translate="yes" xml:space="preserve">
          <source>When a value is missing in only one of &lt;code&gt;left&lt;/code&gt; or &lt;code&gt;right&lt;/code&gt;. When a value in &lt;code&gt;left&lt;/code&gt; is greater than the corresponding value in &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">값은 단 하나의 누락 된 경우 &lt;code&gt;left&lt;/code&gt; 또는 &lt;code&gt;right&lt;/code&gt; . 의 값이되면 &lt;code&gt;left&lt;/code&gt; 의 대응 값보다 큰 &lt;code&gt;right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3f3627274c6fdaa4d1296b656c8aebccf9cd751" translate="yes" xml:space="preserve">
          <source>When accessed, your accessor will be initialized with the pandas object the user is interacting with. So the signature must be</source>
          <target state="translated">액세스하면 접근자가 사용자와 상호 작용하는 팬더 객체로 초기화됩니다. 따라서 서명은</target>
        </trans-unit>
        <trans-unit id="4db4d1e1e93df05b8d7243099c9f7f28c34e2154" translate="yes" xml:space="preserve">
          <source>When adjust is False, weighted averages are calculated recursively as:</source>
          <target state="translated">adjust가 False이면 가중치 평균은 다음과 같이 재귀 적으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="40cb4157a2276c84be23e830b63695f1330e757d" translate="yes" xml:space="preserve">
          <source>When adjust is True (default), weighted averages are calculated using weights (1-alpha)**(n-1), (1-alpha)**(n-2), &amp;hellip;, 1-alpha, 1.</source>
          <target state="translated">adjust가 True (기본값) 인 경우 가중 평균은 가중치 (1-alpha) ** (n-1), (1-alpha) ** (n-2),&amp;hellip;, 1-alpha, 1을 사용하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="6300408ba3f27a018938865d08260d05cce52a54" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;NA&lt;/code&gt; is present in an operation, the output value is &lt;code&gt;NA&lt;/code&gt; only if the result cannot be determined solely based on the other input. For example, &lt;code&gt;True | NA&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, because both &lt;code&gt;True | True&lt;/code&gt; and &lt;code&gt;True | False&lt;/code&gt; are &lt;code&gt;True&lt;/code&gt;. In that case, we don&amp;rsquo;t actually need to consider the value of the &lt;code&gt;NA&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;NA&lt;/code&gt; 가 동작 중에 존재하고, 상기 출력 값은 &lt;code&gt;NA&lt;/code&gt; 결과 결정 타방의 입력에 기초 할 수없는 경우에만. 예를 들어, &lt;code&gt;True | NA&lt;/code&gt; 는 &lt;code&gt;True&lt;/code&gt; 입니다 . 둘 다 &lt;code&gt;True | True&lt;/code&gt; 과 &lt;code&gt;True | False&lt;/code&gt; 는 &lt;code&gt;True&lt;/code&gt; 입니다. 이 경우 실제로 &lt;code&gt;NA&lt;/code&gt; 값을 고려할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0612fe5d23166f6ef5fb9da735712d1b44ce0599" translate="yes" xml:space="preserve">
          <source>When applied to a DataFrame, you can use a column of the DataFrame as sampling weights (provided you are sampling rows and not columns) by simply passing the name of the column as a string.</source>
          <target state="translated">DataFrame에 적용 할 때 단순히 열 이름을 문자열로 전달하여 DataFrame의 열을 샘플링 가중치로 사용할 수 있습니다 (열이 아닌 행을 샘플링하는 경우).</target>
        </trans-unit>
        <trans-unit id="c1ada028e394d1059d5d625fce1aff8673015a1d" translate="yes" xml:space="preserve">
          <source>When calling apply, add group keys to index to identify pieces.</source>
          <target state="translated">apply를 호출 할 때 그룹 키를 추가하여 조각을 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="3bf3b17ed8190c81462c457693e28e4e0702232b" translate="yes" xml:space="preserve">
          <source>When calling the method, keywords arguments &lt;code&gt;head(n=3)&lt;/code&gt; are preferred to positional arguments &lt;code&gt;head(3)&lt;/code&gt;.</source>
          <target state="translated">메소드를 호출 할 때 키워드 인수 &lt;code&gt;head(n=3)&lt;/code&gt; 가 위치 인수 &lt;code&gt;head(3)&lt;/code&gt; 보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd3e39dfcc3c1b5efdb10b78b7a0c0437bcfbeb4" translate="yes" xml:space="preserve">
          <source>When checking a boolean mask, a boolean ndarray is returned when the arguments are all valid.</source>
          <target state="translated">부울 마스크를 확인할 때 인수가 모두 유효하면 부울 ndarray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed6bea224b90f2472a46b03791d9f3661c006cc1" translate="yes" xml:space="preserve">
          <source>When clocks moved backward due to DST, ambiguous times may arise. For example in Central European Time (UTC+01), when going from 03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC and at 01:30:00 UTC. In such a situation, the</source>
          <target state="translated">DST로 인해 시계가 뒤로 이동하면 모호한 시간이 발생할 수 있습니다. 예를 들어 중부 유럽 표준시 (UTC + 01)에서 03:00 DST에서 02:00 비 DST로 이동하는 경우 현지 시간은 00:30:00 UTC와 01:30:00에 모두 발생합니다. UTC. 이러한 상황에서</target>
        </trans-unit>
        <trans-unit id="1038b9555896e68c9d9d9a5aa3bbcefbc38a65d0" translate="yes" xml:space="preserve">
          <source>When clocks moved backward due to DST, ambiguous times may arise. For example in Central European Time (UTC+01), when going from 03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC and at 01:30:00 UTC. In such a situation, the &lt;code&gt;ambiguous&lt;/code&gt; parameter dictates how ambiguous times should be handled.</source>
          <target state="translated">DST로 인해 시계가 뒤로 이동하면 모호한 시간이 발생할 수 있습니다. 예를 들어 중부 유럽 표준시 (UTC + 01)에서 03:00 DST에서 02:00 DST가 아닌 02:00으로 갈 때 현지 시간은 UTC : 00:30:00 UTC와 01:30:00에 발생합니다. UTC. 이러한 상황에서 &lt;code&gt;ambiguous&lt;/code&gt; 매개 변수는 모호한 시간을 처리하는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dde291d8d81acba6907010e427a03754a0f319b2" translate="yes" xml:space="preserve">
          <source>When comparing to an arbitrary sequence, the number of columns must match the number elements in</source>
          <target state="translated">임의의 시퀀스와 비교할 때 열의 수는</target>
        </trans-unit>
        <trans-unit id="d7a6a3779a60543d34b1c7b51db13486c33aae0a" translate="yes" xml:space="preserve">
          <source>When comparing to an arbitrary sequence, the number of columns must match the number elements in &lt;code&gt;other&lt;/code&gt;:</source>
          <target state="translated">임의 순서와 비교할 때 열 수는 &lt;code&gt;other&lt;/code&gt; 의 숫자 요소와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dbb6a810cec96d01ab3e2ff73be4d764c28ee194" translate="yes" xml:space="preserve">
          <source>When comparing two numbers, if the first number has magnitude less than 1e-5, we compare the two numbers directly and check whether they are equivalent within the specified precision. Otherwise, we compare the &lt;strong&gt;ratio&lt;/strong&gt; of the second number to the first number and check whether it is equivalent to 1 within the specified precision.</source>
          <target state="translated">두 숫자를 비교할 때 첫 번째 숫자의 크기가 1e-5보다 작 으면 두 숫자를 직접 비교하여 지정된 정밀도 내에서 같은지 확인합니다. 그렇지 않으면 두 번째 숫자와 첫 번째 숫자 의 &lt;strong&gt;비율&lt;/strong&gt; 을 비교 하여 지정된 정밀도 내에서 1과 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="23ccf40aef286c149b7471c4a1e71cace6464be8" translate="yes" xml:space="preserve">
          <source>When concatenating DataFrames with named axes, pandas will attempt to preserve these index/column names whenever possible. In the case where all inputs share a common name, this name will be assigned to the result. When the input names do not all agree, the result will be unnamed. The same is true for &lt;a href=&quot;../reference/api/pandas.multiindex#pandas.MultiIndex&quot;&gt;&lt;code&gt;MultiIndex&lt;/code&gt;&lt;/a&gt;, but the logic is applied separately on a level-by-level basis.</source>
          <target state="translated">DataFrames를 명명 된 축과 연결할 때 Pandas는 가능할 때마다 이러한 인덱스 / 열 이름을 유지하려고합니다. 모든 입력이 공통 이름을 공유하는 경우이 이름이 결과에 할당됩니다. 입력 이름이 모두 일치하지 않으면 결과는 이름이 지정되지 않습니다. &lt;a href=&quot;../reference/api/pandas.multiindex#pandas.MultiIndex&quot;&gt; &lt;code&gt;MultiIndex&lt;/code&gt; &lt;/a&gt; 의 경우도 마찬가지 지만 로직은 수준별로 개별적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="637ced76108fad73d6872646d080c34db0fb927b" translate="yes" xml:space="preserve">
          <source>When concatenating all &lt;code&gt;Series&lt;/code&gt; along the index (axis=0), a &lt;code&gt;Series&lt;/code&gt; is returned. When &lt;code&gt;objs&lt;/code&gt; contains at least one &lt;code&gt;DataFrame&lt;/code&gt;, a &lt;code&gt;DataFrame&lt;/code&gt; is returned. When concatenating along the columns (axis=1), a &lt;code&gt;DataFrame&lt;/code&gt; is returned.</source>
          <target state="translated">인덱스를 따라 모든 &lt;code&gt;Series&lt;/code&gt; 를 연결하면 (축 = 0) &lt;code&gt;Series&lt;/code&gt; 가 반환됩니다. 때 &lt;code&gt;objs&lt;/code&gt; 적어도 하나 포함 &lt;code&gt;DataFrame&lt;/code&gt; 을 하는 &lt;code&gt;DataFrame&lt;/code&gt; 가 반환됩니다. 열을 따라 연결할 때 (axis = 1) &lt;code&gt;DataFrame&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f0db97e498bfb10687747cf4f4f999c1402f1f31" translate="yes" xml:space="preserve">
          <source>When converting a DatetimeArray/Index with non-regular values, so that a frequency cannot be inferred.</source>
          <target state="translated">비정규 값으로 DatetimeArray / Index를 변환 할 때 빈도를 유추 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1100386ed8ea6d9629a1a290dbb6310caefe32b9" translate="yes" xml:space="preserve">
          <source>When creating this branch, make sure your master branch is up to date with the latest upstream master version. To update your local master branch, you can do:</source>
          <target state="translated">이 분기를 만들 때 마스터 분기가 최신 업스트림 마스터 버전으로 최신 상태인지 확인하십시오. 로컬 마스터 브랜치를 업데이트하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c4c7dd9d9c3acf5623be8c1b8ef40c03661c86cf" translate="yes" xml:space="preserve">
          <source>When data with a &lt;code&gt;datetime64[ns]&lt;/code&gt; or &lt;code&gt;timedelta64[ns]&lt;/code&gt; dtype is passed, pandas will always return a &lt;code&gt;DatetimeArray&lt;/code&gt; or &lt;code&gt;TimedeltaArray&lt;/code&gt; rather than a &lt;code&gt;PandasArray&lt;/code&gt;. This is for symmetry with the case of timezone-aware data, which NumPy does not natively support.</source>
          <target state="translated">경우와 데이터 &lt;code&gt;datetime64[ns]&lt;/code&gt; 또는 &lt;code&gt;timedelta64[ns]&lt;/code&gt; DTYPE 전달, 팬더 항상 리턴 &lt;code&gt;DatetimeArray&lt;/code&gt; 또는 &lt;code&gt;TimedeltaArray&lt;/code&gt; 를 (A)보다 오히려 &lt;code&gt;PandasArray&lt;/code&gt; . 이는 NumPy가 기본적으로 지원하지 않는 시간대 인식 데이터의 경우와 대칭을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="21a675cd25d8dfd9f46b360f15e6842761ed6865" translate="yes" xml:space="preserve">
          <source>When dealing with remote storage systems, you might need extra configuration with environment variables or config files in special locations. For example, to access data in your S3 bucket, you will need to define credentials in one of the several ways listed in the &lt;a href=&quot;https://s3fs.readthedocs.io/en/latest/#credentials&quot;&gt;S3Fs documentation&lt;/a&gt;. The same is true for several of the storage backends, and you should follow the links at &lt;a href=&quot;https://filesystem-spec.readthedocs.io/en/latest/api.html#built-in-implementations&quot;&gt;fsimpl1&lt;/a&gt; for implementations built into &lt;code&gt;fsspec&lt;/code&gt; and &lt;a href=&quot;https://filesystem-spec.readthedocs.io/en/latest/api.html#other-known-implementations&quot;&gt;fsimpl2&lt;/a&gt; for those not included in the main &lt;code&gt;fsspec&lt;/code&gt; distribution.</source>
          <target state="translated">원격 스토리지 시스템을 다룰 때 특별한 위치에있는 환경 변수 또는 구성 파일을 사용하여 추가 구성이 필요할 수 있습니다. 예를 들어 S3 버킷의 데이터에 액세스하려면 &lt;a href=&quot;https://s3fs.readthedocs.io/en/latest/#credentials&quot;&gt;S3F 설명서에&lt;/a&gt; 나열된 여러 방법 중 하나로 자격 증명을 정의해야합니다 . 여러 스토리지 백엔드 에 &lt;code&gt;fsspec&lt;/code&gt; 이며, &lt;a href=&quot;https://filesystem-spec.readthedocs.io/en/latest/api.html#other-known-implementations&quot;&gt;fsspec&lt;/a&gt; 에 내장 된 구현의 경우 &lt;a href=&quot;https://filesystem-spec.readthedocs.io/en/latest/api.html#built-in-implementations&quot;&gt;fsimpl1&lt;/a&gt; 의 링크를 따르고 기본 &lt;code&gt;fsspec&lt;/code&gt; 배포에 포함되지 않은 구현의 경우 fsimpl2 를 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="feaf1730baf09043e523a84bb3a9f4637a606898" translate="yes" xml:space="preserve">
          <source>When deciding what is related, you should mainly use your common sense and think about what can be useful for the users reading the documentation, especially the less experienced ones.</source>
          <target state="translated">관련 내용을 결정할 때는 주로 상식을 사용하고 문서를 읽는 사용자, 특히 경험이 적은 문서를 읽는 사용자에게 유용한 것이 무엇인지 생각해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5c3bc0fd40147351cf0c049c779f4a06960d8af" translate="yes" xml:space="preserve">
          <source>When dict is used as the</source>
          <target state="translated">dict가 다음으로 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="b705982d8224621f64188a411430232a68f971e6" translate="yes" xml:space="preserve">
          <source>When dict is used as the &lt;code&gt;to_replace&lt;/code&gt; value, it is like key(s) in the dict are the to_replace part and value(s) in the dict are the value parameter.</source>
          <target state="translated">dict가 &lt;code&gt;to_replace&lt;/code&gt; 값 으로 사용될 때 dict의 키는 to_replace 부분이고 dict의 값은 value 매개 변수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd7b0838ec9a86d35682dae47beecfb14725b1e4" translate="yes" xml:space="preserve">
          <source>When doing a PR with a docstring update, it is good to post the output of the validation script in a comment on github.</source>
          <target state="translated">docstring 업데이트로 PR을 수행 할 때 github에 대한 주석에 유효성 검사 스크립트의 출력을 게시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e704803fdad0565ffe68b6d58e0e465376e589f" translate="yes" xml:space="preserve">
          <source>When doing an aggregation or transformation, you might just want to call an instance method on each data group. This is pretty easy to do by passing lambda functions:</source>
          <target state="translated">집계 또는 변환을 수행 할 때 각 데이터 그룹에서 인스턴스 메서드를 호출하기를 원할 수 있습니다. 람다 함수를 전달하면 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a73d4053a79dd6e7539d53518f9d66a7f2a021f9" translate="yes" xml:space="preserve">
          <source>When doing an operation between DataFrame and Series, the default behavior is to align the Series &lt;strong&gt;index&lt;/strong&gt; on the DataFrame &lt;strong&gt;columns&lt;/strong&gt;, thus &lt;a href=&quot;https://numpy.org/doc/stable/user/basics.broadcasting.html&quot;&gt;broadcasting&lt;/a&gt; row-wise. For example:</source>
          <target state="translated">DataFrame와 시리즈 사이의 작업을 수행 할 때, 기본 동작은 시리즈 정렬하는 &lt;strong&gt;인덱스를&lt;/strong&gt; DataFrame의에 &lt;strong&gt;열&lt;/strong&gt; 따라서, &lt;a href=&quot;https://numpy.org/doc/stable/user/basics.broadcasting.html&quot;&gt;방송&lt;/a&gt; 행 방향. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="886f0ef49bbe251b34a0018bfe1ed9541cd332e4" translate="yes" xml:space="preserve">
          <source>When each subject string in the Series has exactly one match,</source>
          <target state="translated">시리즈의 각 제목 문자열에 정확히 하나의 일치 항목이있는 경우</target>
        </trans-unit>
        <trans-unit id="36805fe980f0f47951bcaa93f77efeb76b128434" translate="yes" xml:space="preserve">
          <source>When gluing together multiple DataFrames, you have a choice of how to handle the other axes (other than the one being concatenated). This can be done in the following two ways:</source>
          <target state="translated">여러 DataFrame을 함께 붙일 때 다른 축 (연결된 축 제외)을 처리하는 방법을 선택할 수 있습니다. 다음 두 가지 방법으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="542684db958778c261342ddedd76fb90002eebac" translate="yes" xml:space="preserve">
          <source>When grouping with &lt;code&gt;by&lt;/code&gt;, a Series mapping columns to &lt;code&gt;return_type&lt;/code&gt; is returned:</source>
          <target state="translated">&lt;code&gt;by&lt;/code&gt; 로 그룹화하면 &lt;code&gt;return_type&lt;/code&gt; 에 대한 Series 맵핑 열 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7ff44a3a8f8005f1399441f3dc08c60258fc3946" translate="yes" xml:space="preserve">
          <source>When having a DataFrame with dates as index, this function can select the first few rows based on a date offset.</source>
          <target state="translated">날짜를 인덱스로 사용하는 DataFrame이있는 경우이 함수는 날짜 오프셋을 기반으로 처음 몇 개의 행을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba15db478ca9f2e446df3fa2d769e241b7b4ac49" translate="yes" xml:space="preserve">
          <source>When having a DataFrame with dates as index, this function can select the last few rows based on a date offset.</source>
          <target state="translated">날짜를 인덱스로 사용하는 DataFrame이있는 경우이 함수는 날짜 오프셋을 기반으로 마지막 몇 행을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17db09436383d41b5d603278ec30be4a5223d7f8" translate="yes" xml:space="preserve">
          <source>When ignore_na is False (default), weights are based on absolute positions. For example, the weights of x and y used in calculating the final weighted average of [x, None, y] are (1-alpha)**2 and 1 (if adjust is True), and (1-alpha)**2 and alpha (if adjust is False).</source>
          <target state="translated">ignore_na가 False (기본값) 인 경우 가중치는 절대 위치를 기준으로합니다. 예를 들어 [x, None, y]의 최종 가중 평균을 계산하는 데 사용되는 x 및 y의 가중치는 (1-alpha) ** 2 및 1 (adjust가 true 인 경우) 및 (1-alpha) **입니다. 2와 알파 (adjust가 False 인 경우).</target>
        </trans-unit>
        <trans-unit id="b7f965abc3a4138667124af03caf3a160dac0fe5" translate="yes" xml:space="preserve">
          <source>When ignore_na is True (reproducing pre-0.15.0 behavior), weights are based on relative positions. For example, the weights of x and y used in calculating the final weighted average of [x, None, y] are 1-alpha and 1 (if adjust is True), and 1-alpha and alpha (if adjust is False).</source>
          <target state="translated">ignore_na가 True 인 경우 (0.15.0 이전의 동작 재현) 가중치는 상대 위치를 기반으로합니다. 예를 들어, [x, None, y]의 최종 가중 평균을 계산하는 데 사용되는 x 및 y의 가중치는 1- 알파 및 1 (조정이 true 인 경우)이고 1- 알파 및 알파 (조정이 False 인 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="ce796429ced037639277ebc7f731943f6311abfc" translate="yes" xml:space="preserve">
          <source>When illustrating examples with a single &lt;code&gt;Series&lt;/code&gt; use the name &lt;code&gt;s&lt;/code&gt;, and if illustrating with a single &lt;code&gt;DataFrame&lt;/code&gt; use the name &lt;code&gt;df&lt;/code&gt;. For indices, &lt;code&gt;idx&lt;/code&gt; is the preferred name. If a set of homogeneous &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt; is used, name them &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt;&amp;hellip; or &lt;code&gt;df1&lt;/code&gt;, &lt;code&gt;df2&lt;/code&gt;, &lt;code&gt;df3&lt;/code&gt;&amp;hellip; If the data is not homogeneous, and more than one structure is needed, name them with something meaningful, for example &lt;code&gt;df_main&lt;/code&gt; and &lt;code&gt;df_to_join&lt;/code&gt;.</source>
          <target state="translated">단일 &lt;code&gt;Series&lt;/code&gt; 로 예제를 설명 할 때는 이름 &lt;code&gt;s&lt;/code&gt; 를 사용하고 단일 &lt;code&gt;DataFrame&lt;/code&gt; 으로 설명 할 경우 이름 &lt;code&gt;df&lt;/code&gt; 를 사용하십시오 . 색인의 경우 &lt;code&gt;idx&lt;/code&gt; 가 선호되는 이름입니다. 균일 한 세트의 경우 &lt;code&gt;Series&lt;/code&gt; 또는 &lt;code&gt;DataFrame&lt;/code&gt; 가 사용되며, 이름을 그들 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; , &lt;code&gt;s3&lt;/code&gt; ... 또는 &lt;code&gt;df1&lt;/code&gt; , &lt;code&gt;df2&lt;/code&gt; , &lt;code&gt;df3&lt;/code&gt; 데이터가 균일하지 않고, 하나 명 이상의 구조가 필요한 경우 ... 예를 들어 의미있는 뭔가로 이름을 &lt;code&gt;df_main&lt;/code&gt; 및 &lt;code&gt;df_to_join&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5dadc2fe65927d17bd3e9891d2299f6c3f96e5" translate="yes" xml:space="preserve">
          <source>When importing categorical data, the values of the variables in the &lt;em&gt;Stata&lt;/em&gt; data file are not preserved since &lt;code&gt;Categorical&lt;/code&gt; variables always use integer data types between &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;n-1&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of categories. If the original values in the &lt;em&gt;Stata&lt;/em&gt; data file are required, these can be imported by setting &lt;code&gt;convert_categoricals=False&lt;/code&gt;, which will import original data (but not the variable labels). The original values can be matched to the imported categorical data since there is a simple mapping between the original &lt;em&gt;Stata&lt;/em&gt; data values and the category codes of imported Categorical variables: missing values are assigned code &lt;code&gt;-1&lt;/code&gt;, and the smallest original value is assigned &lt;code&gt;0&lt;/code&gt;, the second smallest is assigned &lt;code&gt;1&lt;/code&gt; and so on until the largest original value is assigned the code &lt;code&gt;n-1&lt;/code&gt;.</source>
          <target state="translated">범주 형 데이터를 가져올 때 &lt;code&gt;Categorical&lt;/code&gt; 변수는 항상 &lt;code&gt;-1&lt;/code&gt; 과 &lt;code&gt;n-1&lt;/code&gt; 사이의 정수 데이터 유형을 사용 하므로 &lt;em&gt;Stata&lt;/em&gt; 데이터 파일 의 변수 값은 보존되지 않습니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 범주 수입니다. &lt;em&gt;Stata&lt;/em&gt; 데이터 파일 의 원래 값 이 필요한 경우 &lt;code&gt;convert_categoricals=False&lt;/code&gt; 를 설정하여 가져올 수 있습니다. 그러면 원래 데이터 (변수 레이블이 아님)를 가져옵니다. 원래 &lt;em&gt;Stata&lt;/em&gt; 데이터 값과 가져온 범주 형 변수의 범주 코드 간에 간단한 매핑이 있기 때문에 원래 값은 가져온 범주 형 데이터와 일치 할 수 있습니다 . 누락 된 값에는 코드가 할당됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;-1&lt;/code&gt; , 가장 작은 원의 값이 할당되는 &lt;code&gt;0&lt;/code&gt; 번째 최소 할당되고, &lt;code&gt;1&lt;/code&gt; 등 최대 값이 원래의 코드가 할당 될 때까지의 &lt;code&gt;n-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f1f0b7bfcf4c317abdc8abca7d7e7d604ff0b80" translate="yes" xml:space="preserve">
          <source>When improving a single function or method&amp;rsquo;s docstring, it is not necessarily needed to build the full documentation (see next section). However, there is a script that checks a docstring (for example for the &lt;code&gt;DataFrame.mean&lt;/code&gt; method):</source>
          <target state="translated">단일 함수 또는 메소드의 docstring을 개선 할 때 반드시 전체 문서를 작성할 필요는 없습니다 (다음 섹션 참조). 그러나 docstring을 확인하는 스크립트가 있습니다 (예 : &lt;code&gt;DataFrame.mean&lt;/code&gt; 메소드).</target>
        </trans-unit>
        <trans-unit id="b1baafd7b0e2292cfe8b312a9b3732901be94f52" translate="yes" xml:space="preserve">
          <source>When input data contains &lt;code&gt;NaN&lt;/code&gt;, it will be automatically filled by 0. If you want to drop or fill by different values, use &lt;code&gt;dataframe.dropna()&lt;/code&gt; or &lt;code&gt;dataframe.fillna()&lt;/code&gt; before calling &lt;code&gt;plot&lt;/code&gt;.</source>
          <target state="translated">입력 데이터에 &lt;code&gt;NaN&lt;/code&gt; 이 포함되면 자동으로 0으로 채워집니다. 다른 값으로 드롭하거나 채우려면 &lt;code&gt;plot&lt;/code&gt; 을 호출하기 전에 &lt;code&gt;dataframe.dropna()&lt;/code&gt; 또는 &lt;code&gt;dataframe.fillna()&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="66261ea96e888a776296757083b0b8ddc152d9c0" translate="yes" xml:space="preserve">
          <source>When inserting a Series that does not have the same index as the DataFrame, it will be conformed to the DataFrame&amp;rsquo;s index:</source>
          <target state="translated">DataFrame과 동일한 인덱스가없는 Series를 삽입하면 DataFrame의 인덱스를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="93d9398d658bdc75a504c5e01f15ac00d105afdb" translate="yes" xml:space="preserve">
          <source>When inserting a scalar value, it will naturally be propagated to fill the column:</source>
          <target state="translated">스칼라 값을 삽입하면 자연스럽게 전파되어 열을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b53bd16fbdd18fccb0d835e451b2bbc685238e87" translate="yes" xml:space="preserve">
          <source>When integer position is out of bounds</source>
          <target state="translated">정수 위치가 범위를 벗어난 경우</target>
        </trans-unit>
        <trans-unit id="1754bbafb7ed1ca2534182d1b27b9e0f7b1921f0" translate="yes" xml:space="preserve">
          <source>When integer position is out of bounds.</source>
          <target state="translated">정수 위치가 범위를 벗어난 경우.</target>
        </trans-unit>
        <trans-unit id="fd632773e5bdc256c4be9ba1bd3191feb20d94b5" translate="yes" xml:space="preserve">
          <source>When interpolating via a polynomial or spline approximation, you must also specify the degree or order of the approximation:</source>
          <target state="translated">다항식 또는 스플라인 근사치를 통해 보간하는 경우 근사치의 차수 또는 순서도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e82c024611e931ce1d293d4833f37f78a01ff40e" translate="yes" xml:space="preserve">
          <source>When introducing NAs into an existing &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt; via &lt;a href=&quot;../reference/api/pandas.series.reindex#pandas.Series.reindex&quot;&gt;&lt;code&gt;reindex()&lt;/code&gt;&lt;/a&gt; or some other means, boolean and integer types will be promoted to a different dtype in order to store the NAs. The promotions are summarized in this table:</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.series.reindex#pandas.Series.reindex&quot;&gt; &lt;code&gt;reindex()&lt;/code&gt; &lt;/a&gt; 또는 다른 수단을 통해 기존 &lt;code&gt;Series&lt;/code&gt; 또는 &lt;code&gt;DataFrame&lt;/code&gt; 에 NA를 도입 할 때 NA 를 저장하기 위해 부울 및 정수 유형이 다른 dtype으로 승격됩니다. 프로모션은 다음 표에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5658aad193c3c37a8452fd030a092a4b0597bd" translate="yes" xml:space="preserve">
          <source>When joining columns on columns (potentially a many-to-many join), any indexes on the passed &lt;code&gt;DataFrame&lt;/code&gt; objects &lt;strong&gt;will be discarded&lt;/strong&gt;.</source>
          <target state="translated">열의 열을 조인하면 (다수의 조인) 전달 된 &lt;code&gt;DataFrame&lt;/code&gt; 개체의 인덱스 &lt;strong&gt;가 삭제됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8e884992c2415bae6234519d66770f93bd61e840" translate="yes" xml:space="preserve">
          <source>When kind equals &amp;lsquo;pandas&amp;rsquo; return pandas objects. When kind equals &amp;lsquo;native&amp;rsquo; return native HDF5 Table objects.</source>
          <target state="translated">종류가 'pandas'와 같으면 pandas 객체를 반환합니다. 종류가 '네이티브'와 같으면 네이티브 HDF5 테이블 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="390078ce51ab1ece7bb4f8f7ba39b5511eb51838" translate="yes" xml:space="preserve">
          <source>When label does not exist in DataFrame</source>
          <target state="translated">DataFrame에 레이블이없는 경우</target>
        </trans-unit>
        <trans-unit id="b89f2944fb436da53e84258db1ff8007ca2968c3" translate="yes" xml:space="preserve">
          <source>When multiple axes are passed via the &lt;code&gt;ax&lt;/code&gt; keyword, &lt;code&gt;layout&lt;/code&gt;, &lt;code&gt;sharex&lt;/code&gt; and &lt;code&gt;sharey&lt;/code&gt; keywords don&amp;rsquo;t affect to the output. You should explicitly pass &lt;code&gt;sharex=False&lt;/code&gt; and &lt;code&gt;sharey=False&lt;/code&gt;, otherwise you will see a warning.</source>
          <target state="translated">여러 축이를 통해 전달되는 경우에는 &lt;code&gt;ax&lt;/code&gt; 키워드, &lt;code&gt;layout&lt;/code&gt; , &lt;code&gt;sharex&lt;/code&gt; 및 &lt;code&gt;sharey&lt;/code&gt; 키워드 출력에 영향을주지 않습니다. 명시 적으로 통과해야 &lt;code&gt;sharex=False&lt;/code&gt; 과 &lt;code&gt;sharey=False&lt;/code&gt; 그렇지 않으면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1ab73abf1652c55358aeb006f3e599b16dea541d" translate="yes" xml:space="preserve">
          <source>When not passing</source>
          <target state="translated">통과하지 못할 때</target>
        </trans-unit>
        <trans-unit id="2dda8007fb361e4e9b2052d13b012732628747db" translate="yes" xml:space="preserve">
          <source>When not passing &lt;code&gt;others&lt;/code&gt;, all values are concatenated into a single string:</source>
          <target state="translated">&lt;code&gt;others&lt;/code&gt; 값을 전달하지 않으면 모든 값이 단일 문자열로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="c34635cdc687f7be54f26017cfe4678602fdeae2" translate="yes" xml:space="preserve">
          <source>When one uses a dict as the</source>
          <target state="translated">dict를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="32c285eece6af8b9de24a06d9e4f702c78e2b2bf" translate="yes" xml:space="preserve">
          <source>When one uses a dict as the &lt;code&gt;to_replace&lt;/code&gt; value, it is like the value(s) in the dict are equal to the &lt;code&gt;value&lt;/code&gt; parameter. &lt;code&gt;s.replace({'a': None})&lt;/code&gt; is equivalent to &lt;code&gt;s.replace(to_replace={'a': None}, value=None, method=None)&lt;/code&gt;:</source>
          <target state="translated">dict를 &lt;code&gt;to_replace&lt;/code&gt; 값 으로 사용하면 dict 의 값이 &lt;code&gt;value&lt;/code&gt; 매개 변수와 같습니다. &lt;code&gt;s.replace({'a': None})&lt;/code&gt; 은 &lt;code&gt;s.replace(to_replace={'a': None}, value=None, method=None)&lt;/code&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b4389f55947089deac603c8be08fd1b8573a07e" translate="yes" xml:space="preserve">
          <source>When original &lt;code&gt;Series&lt;/code&gt; has &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt;&lt;code&gt;StringDtype&lt;/code&gt;&lt;/a&gt;, the output columns will all be &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt;&lt;code&gt;StringDtype&lt;/code&gt;&lt;/a&gt; as well.</source>
          <target state="translated">원래 &lt;code&gt;Series&lt;/code&gt; 에 &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt; &lt;code&gt;StringDtype&lt;/code&gt; &lt;/a&gt; 이 있으면 출력 열도 모두 &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt; &lt;code&gt;StringDtype&lt;/code&gt; 이&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2542b6dc043ad06d26cc93e476b1ca9be5d3b363" translate="yes" xml:space="preserve">
          <source>When performing &lt;a href=&quot;../reference/api/pandas.index.union#pandas.Index.union&quot;&gt;&lt;code&gt;Index.union()&lt;/code&gt;&lt;/a&gt; between indexes with different dtypes, the indexes must be cast to a common dtype. Typically, though not always, this is object dtype. The exception is when performing a union between integer and float data. In this case, the integer values are converted to float</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.index.union#pandas.Index.union&quot;&gt; &lt;code&gt;Index.union()&lt;/code&gt; &lt;/a&gt; 이 다른 인덱스간에 Index.union ()을 수행 할 때 인덱스는 공통 dtype으로 캐스트되어야합니다. 일반적으로 항상 그런 것은 아니지만 이것은 객체 dtype입니다. 예외는 정수와 부동 데이터 사이의 결합을 수행하는 경우입니다. 이 경우 정수 값은 부동 소수점으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b010006feec843216ec4aa7613303324adf1893" translate="yes" xml:space="preserve">
          <source>When presented with mixed dtypes that cannot aggregate, &lt;code&gt;.agg&lt;/code&gt; will only take the valid aggregations. This is similar to how &lt;code&gt;.groupby.agg&lt;/code&gt; works.</source>
          <target state="translated">집계 할 수없는 혼합 dtype이있는 경우 &lt;code&gt;.agg&lt;/code&gt; 는 유효한 집계 만 취합니다. 이것은 &lt;code&gt;.groupby.agg&lt;/code&gt; 가 작동 하는 방식과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="fa44113c25485bfda6d8f6bc3a045ef1dd675e1f" translate="yes" xml:space="preserve">
          <source>When pretty-printing a long sequence, no more then</source>
          <target state="translated">긴 시퀀스를 예쁘게 인쇄 할 때 더 이상</target>
        </trans-unit>
        <trans-unit id="28e3ff310a63023cfc0c7772844ac12840fb1e42" translate="yes" xml:space="preserve">
          <source>When processing raw, messy data you might initially read in the messy data (which potentially has duplicate labels), deduplicate, and then disallow duplicates going forward, to ensure that your data pipeline doesn&amp;rsquo;t introduce duplicates.</source>
          <target state="translated">원시의 지저분한 데이터를 처리 할 때 처음에는 지저분한 데이터 (잠재적으로 중복 된 레이블이 있음)를 읽고 중복을 제거한 다음 앞으로 중복을 허용하지 않아 데이터 파이프 라인에 중복이 발생하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de02d9232d5829a47b83b4cc08a5e72e59c5bace" translate="yes" xml:space="preserve">
          <source>When pull requests are merged into the &lt;em&gt;pandas&lt;/em&gt;&lt;code&gt;master&lt;/code&gt; branch, the main parts of the documentation are also built by Travis-CI. These docs are then hosted &lt;a href=&quot;https://dev.pandas.io&quot;&gt;here&lt;/a&gt;, see also the &lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; section.</source>
          <target state="translated">풀 요청이 &lt;em&gt;팬더 &lt;/em&gt; &lt;code&gt;master&lt;/code&gt; 브랜치에 병합 되면 설명서의 주요 부분도 Travis-CI에 의해 작성됩니다. 이 문서는 호스팅 &lt;a href=&quot;https://dev.pandas.io&quot;&gt;여기에&lt;/a&gt; , 또한 참조 &lt;a href=&quot;#contributing-ci&quot;&gt;연속 통합&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b44d74ec06335d73747996508562fdd7c4b7085e" translate="yes" xml:space="preserve">
          <source>When quotechar is specified and quoting is not &lt;code&gt;QUOTE_NONE&lt;/code&gt;, indicate whether or not to interpret two consecutive quotechar elements INSIDE a field as a single &lt;code&gt;quotechar&lt;/code&gt; element.</source>
          <target state="translated">quotechar이 지정되고 인용이 &lt;code&gt;QUOTE_NONE&lt;/code&gt; 이 아닌 경우 , 필드에서 두 개의 연속 인용 문자 요소를 단일 &lt;code&gt;quotechar&lt;/code&gt; 요소 로 해석할지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="071e858738ea12503c6305dd3d8251f2c2277962" translate="yes" xml:space="preserve">
          <source>When reading JSON data, automatic coercing into dtypes has some quirks:</source>
          <target state="translated">JSON 데이터를 읽을 때 dtypes로 자동 강제 변환에는 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="21b227a983010f6cbfe1156f4c0459559ab46cbb" translate="yes" xml:space="preserve">
          <source>When reading code, the contents of an &lt;code&gt;object&lt;/code&gt; dtype array is less clear than &lt;code&gt;'string'&lt;/code&gt;.</source>
          <target state="translated">코드를 읽을 때 &lt;code&gt;object&lt;/code&gt; dtype 배열 의 내용은 &lt;code&gt;'string'&lt;/code&gt; 보다 명확하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e2fa8beb816cb64a1dc17c4d711dbff01bc5b51" translate="yes" xml:space="preserve">
          <source>When reading, the top three functions in terms of speed are &lt;code&gt;test_feather_read&lt;/code&gt;, &lt;code&gt;test_pickle_read&lt;/code&gt; and &lt;code&gt;test_hdf_fixed_read&lt;/code&gt;.</source>
          <target state="translated">읽을 때 속도 측면에서 상위 3 개 함수는 &lt;code&gt;test_feather_read&lt;/code&gt; , &lt;code&gt;test_pickle_read&lt;/code&gt; 및 &lt;code&gt;test_hdf_fixed_read&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="872fd821127a903d4955e6044a083f92bcef47b6" translate="yes" xml:space="preserve">
          <source>When relating to other libraries (mainly &lt;code&gt;numpy&lt;/code&gt;), use the name of the module first (not an alias like &lt;code&gt;np&lt;/code&gt;). If the function is in a module which is not the main one, like &lt;code&gt;scipy.sparse&lt;/code&gt;, list the full module (e.g. &lt;code&gt;scipy.sparse.coo_matrix&lt;/code&gt;).</source>
          <target state="translated">다른 라이브러리 (주로 &lt;code&gt;numpy&lt;/code&gt; )와 관련이있는 경우 먼저 모듈 이름을 사용하십시오 ( &lt;code&gt;np&lt;/code&gt; 와 같은 별명이 아님 ). 함수가 &lt;code&gt;scipy.sparse&lt;/code&gt; 와 같이 기본이 아닌 모듈에있는 경우 전체 모듈을 나열하십시오 (예 : &lt;code&gt;scipy.sparse.coo_matrix&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1745010069de867dadb6869d887daf544b207782" translate="yes" xml:space="preserve">
          <source>When replacing multiple &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;datetime64&lt;/code&gt; objects and the arguments to</source>
          <target state="translated">여러 &lt;code&gt;bool&lt;/code&gt; 또는 &lt;code&gt;datetime64&lt;/code&gt; 객체와 인수를 대체 할 때</target>
        </trans-unit>
        <trans-unit id="411448cfc4df3ae34129aa0d3409c4fe277fed55" translate="yes" xml:space="preserve">
          <source>When replacing multiple &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;datetime64&lt;/code&gt; objects and the arguments to &lt;code&gt;to_replace&lt;/code&gt; does not match the type of the value being replaced</source>
          <target state="translated">여러 &lt;code&gt;bool&lt;/code&gt; 또는 &lt;code&gt;datetime64&lt;/code&gt; 객체를 교체 할 때 &lt;code&gt;to_replace&lt;/code&gt; 에 대한 인수 가 교체되는 값의 유형과 일치하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="08fa8f3dbb2a4966fec93dcf5d3983d04840cc85" translate="yes" xml:space="preserve">
          <source>When resampling data, missing values may appear (e.g., when the resampling frequency is higher than the original frequency). The</source>
          <target state="translated">데이터를 리샘플링 할 때 누락 된 값이 나타날 수 있습니다 (예 : 리샘플링 빈도가 원래 빈도보다 높은 경우). 그만큼</target>
        </trans-unit>
        <trans-unit id="be6b09af0c6aba65e5d516638dd8ae5612d7c120" translate="yes" xml:space="preserve">
          <source>When resampling data, missing values may appear (e.g., when the resampling frequency is higher than the original frequency). The &lt;code&gt;nearest&lt;/code&gt; method will replace &lt;code&gt;NaN&lt;/code&gt; values that appeared in the resampled data with the value from the nearest member of the sequence, based on the index value. Missing values that existed in the original data will not be modified. If &lt;code&gt;limit&lt;/code&gt; is given, fill only this many values in each direction for each of the original values.</source>
          <target state="translated">데이터를 리샘플링 할 때 결 측값이 나타날 수 있습니다 (예 : 리샘플링 주파수가 원래 주파수보다 높을 때). &lt;code&gt;nearest&lt;/code&gt; 방법을 대체 할 것이다 &lt;code&gt;NaN&lt;/code&gt; 인덱스 값에 기초하여 상기 시퀀스의 부재로부터 가까운 값으로 리샘플링 된 데이터에 나타난 값. 원래 데이터에 존재했던 결 측값은 수정되지 않습니다. 경우 &lt;code&gt;limit&lt;/code&gt; 주어, 원래 값의 각각에 대해 각 방향으로 만이 많은 값을 채운다.</target>
        </trans-unit>
        <trans-unit id="b51ca2e663037c6f6f0ddaa2678e57db7aadbef7" translate="yes" xml:space="preserve">
          <source>When setting values in a pandas object, care must be taken to avoid what is called &lt;code&gt;chained indexing&lt;/code&gt;. Here is an example.</source>
          <target state="translated">pandas 객체에서 값을 설정할 때 &lt;code&gt;chained indexing&lt;/code&gt; 이라는 것을 피하기 위해주의를 기울여야합니다 . 여기에 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f92b30c1e1a6c666818625e8fb24d7e1a0f101d9" translate="yes" xml:space="preserve">
          <source>When specifying the parameter types, Python built-in data types can be used directly (the Python type is preferred to the more verbose string, integer, boolean, etc):</source>
          <target state="translated">매개 변수 유형을 지정할 때 Python 내장 데이터 유형을 직접 사용할 수 있습니다 (Python 유형은 더 자세한 문자열, 정수, 부울 등을 선호합니다).</target>
        </trans-unit>
        <trans-unit id="1498ea3315578c53dcd1e3a9fbf7d0f90fcc35d6" translate="yes" xml:space="preserve">
          <source>When summing data, NA (missing) values will be treated as zero.</source>
          <target state="translated">데이터를 합산 할 때 NA (결 측값) 값은 0으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="efc38e64579ce0e1a56daa94f750b2b141c1614b" translate="yes" xml:space="preserve">
          <source>When the DataFrame has mixed dtypes, we get a transposed DataFrame with the</source>
          <target state="translated">DataFrame에 혼합 된 dtype이 있으면</target>
        </trans-unit>
        <trans-unit id="6b42f98d793e16e63d298298fecc50fa1fd9cb03" translate="yes" xml:space="preserve">
          <source>When the DataFrame has mixed dtypes, we get a transposed DataFrame with the &lt;code&gt;object&lt;/code&gt; dtype:</source>
          <target state="translated">DataFrame에 dtype이 혼합되면 dtype &lt;code&gt;object&lt;/code&gt; 와 조옮김 DataFrame이 나타 납니다.</target>
        </trans-unit>
        <trans-unit id="8d594a44c803cf8349726a569cc2460a60d793c2" translate="yes" xml:space="preserve">
          <source>When the Series or Index is backed by an &lt;a href=&quot;../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray&quot;&gt;&lt;code&gt;ExtensionArray&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;to_numpy()&lt;/code&gt;&lt;/a&gt; may involve copying data and coercing values. See &lt;a href=&quot;#basics-dtypes&quot;&gt;dtypes&lt;/a&gt; for more.</source>
          <target state="translated">시리즈 또는 인덱스가 뒷받침 될 때 &lt;a href=&quot;../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray&quot;&gt; &lt;code&gt;ExtensionArray&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;to_numpy()&lt;/code&gt; &lt;/a&gt; 데이터를 복사하고 값을 강요 포함될 수 있습니다. 자세한 내용은 &lt;a href=&quot;#basics-dtypes&quot;&gt;dtypes&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88fa70ab6f7a47d40ffc9d74ad35ab5b174d9aa2" translate="yes" xml:space="preserve">
          <source>When the calling object is a TimedeltaArray, the return type is ndarray. When the calling object is a TimedeltaIndex, the return type is a Float64Index. When the calling object is a Series, the return type is Series of type</source>
          <target state="translated">호출 객체가 TimedeltaArray 인 경우 반환 유형은 ndarray입니다. 호출 객체가 TimedeltaIndex 인 경우 반환 유형은 Float64Index입니다. 호출 객체가 Series 인 경우 반환 유형은 Series 유형입니다.</target>
        </trans-unit>
        <trans-unit id="986f0e3871a4ecfbf5b66d14050a24a4818420d7" translate="yes" xml:space="preserve">
          <source>When the calling object is a TimedeltaArray, the return type is ndarray. When the calling object is a TimedeltaIndex, the return type is a Float64Index. When the calling object is a Series, the return type is Series of type &lt;code&gt;float64&lt;/code&gt; whose index is the same as the original.</source>
          <target state="translated">호출 객체가 TimedeltaArray 인 경우 반환 유형은 ndarray입니다. 호출 객체가 TimedeltaIndex 인 경우 반환 유형은 Float64Index입니다. 호출 객체가 Series 인 경우 반환 유형은 &lt;code&gt;float64&lt;/code&gt; 유형의 Series이며 인덱스는 원본과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5a513223aa790ba72a92defda97b4b3c69165676" translate="yes" xml:space="preserve">
          <source>When the data is a dict, and &lt;code&gt;columns&lt;/code&gt; is not specified, the &lt;code&gt;DataFrame&lt;/code&gt; columns will be ordered by the dict&amp;rsquo;s insertion order, if you are using Python version &amp;gt;= 3.6 and pandas &amp;gt;= 0.23.</source>
          <target state="translated">데이터가 dict이고 &lt;code&gt;columns&lt;/code&gt; 이 지정되지 않은 경우 Python 버전&amp;gt; = 3.6 및 pandas&amp;gt; = 0.23을 사용하는 경우 &lt;code&gt;DataFrame&lt;/code&gt; 열은 dict의 삽입 순서에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="7ebb817283ab56e97accfcd90ee9331b434d4342" translate="yes" xml:space="preserve">
          <source>When the data is a dict, and an index is not passed, the &lt;code&gt;Series&lt;/code&gt; index will be ordered by the dict&amp;rsquo;s insertion order, if you&amp;rsquo;re using Python version &amp;gt;= 3.6 and pandas version &amp;gt;= 0.23.</source>
          <target state="translated">데이터가 dict이고 인덱스가 전달되지 않은 경우 Python 버전&amp;gt; = 3.6 및 pandas 버전&amp;gt; = 0.23을 사용하는 경우 &lt;code&gt;Series&lt;/code&gt; 인덱스는 dict의 삽입 순서에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="b54d3965f8d3f4ed20a2848da8c4c77dc0d1ac50" translate="yes" xml:space="preserve">
          <source>When the dtype is homogeneous in the original DataFrame, we get a transposed DataFrame with the same dtype:</source>
          <target state="translated">원래의 DataFrame에서 dtype이 동종인 경우 동일한 dtype으로 조옮김 DataFrame을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9e09c6d817a1d9056bdee9b170d121466345766e" translate="yes" xml:space="preserve">
          <source>When the index is inserted under another level, we can specify under which one with the parameter</source>
          <target state="translated">인덱스가 다른 레벨 아래에 삽입되면 매개 변수를 사용하여 어느 레벨 아래에 인덱스를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a829be98ffdbae5a526529860303301c9f5d9efe" translate="yes" xml:space="preserve">
          <source>When the index is inserted under another level, we can specify under which one with the parameter &lt;code&gt;col_fill&lt;/code&gt;:</source>
          <target state="translated">색인이 다른 레벨에 삽입되면 &lt;code&gt;col_fill&lt;/code&gt; 매개 변수를 사용하여 어느 레벨을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="137c1713cbb665fc14c73205eb74bab466a78d3a" translate="yes" xml:space="preserve">
          <source>When the indices are out of bounds for the array.</source>
          <target state="translated">인덱스가 배열의 범위를 벗어난 경우</target>
        </trans-unit>
        <trans-unit id="e158ff82a697fdc48768a4e9c2bde613ad9251a9" translate="yes" xml:space="preserve">
          <source>When the lengths don&amp;rsquo;t match.</source>
          <target state="translated">길이가 일치하지 않을 때.</target>
        </trans-unit>
        <trans-unit id="526871eca415ad4976ebe8dbeb8ce984ac55fb18" translate="yes" xml:space="preserve">
          <source>When the pattern matches more than one string in the Series, all matches are returned:</source>
          <target state="translated">Series에서 패턴이 둘 이상의 문자열과 일치하면 모든 일치 항목이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="67aaffd5e2428478ab54542297df50ed2edbed57" translate="yes" xml:space="preserve">
          <source>When the requested timezone cannot be found.</source>
          <target state="translated">요청한 시간대를 찾을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="56ed011eefa6344cc3ae6efd4ecd6a8164893bb4" translate="yes" xml:space="preserve">
          <source>When the table already exists and</source>
          <target state="translated">테이블이 이미 존재하고</target>
        </trans-unit>
        <trans-unit id="724465bcabdf5ad12d816f4256c012ab02eb69c0" translate="yes" xml:space="preserve">
          <source>When the table already exists and &lt;code&gt;if_exists&lt;/code&gt; is &amp;lsquo;fail&amp;rsquo; (the default).</source>
          <target state="translated">테이블이 이미 존재하고 &lt;code&gt;if_exists&lt;/code&gt; 가 'fail'(기본값) 인 경우</target>
        </trans-unit>
        <trans-unit id="36a8704604f0000668e4b3c1dfcc5013c42350e2" translate="yes" xml:space="preserve">
          <source>When the two DataFrames don&amp;rsquo;t have identical labels or shape.</source>
          <target state="translated">두 DataFrame에 동일한 레이블 또는 모양이없는 경우.</target>
        </trans-unit>
        <trans-unit id="db095f7dfbe0feda55b2d1a1e1be16b8062a363c" translate="yes" xml:space="preserve">
          <source>When there are any</source>
          <target state="translated">있을 때</target>
        </trans-unit>
        <trans-unit id="37c1c658d030353b69d980ed39918bbd37867599" translate="yes" xml:space="preserve">
          <source>When there are any &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;columns&lt;/code&gt; combinations with multiple values. &lt;code&gt;DataFrame.pivot_table&lt;/code&gt; when you need to aggregate.</source>
          <target state="translated">어떤이있는 경우 &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;columns&lt;/code&gt; 여러 값 조합. 집계해야 할 때 &lt;code&gt;DataFrame.pivot_table&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6273a7b1358591d7723a417588629a58e9ea0e86" translate="yes" xml:space="preserve">
          <source>When there are duplicate values that cannot all fit in a Series of</source>
          <target state="translated">시리즈에 모두 맞지 않는 중복 값이있는 경우</target>
        </trans-unit>
        <trans-unit id="c7dcf2b13d836d8e5cd84f648cf1b5c57f5c3bb2" translate="yes" xml:space="preserve">
          <source>When there are duplicate values that cannot all fit in a Series of &lt;code&gt;n&lt;/code&gt; elements:</source>
          <target state="translated">일련의 &lt;code&gt;n&lt;/code&gt; 요소 에 모두 적용 할 수없는 중복 값이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="2e66f6c388498a54f3d147af32185fcd4ff7ff89" translate="yes" xml:space="preserve">
          <source>When there are multiple rows (or columns) matching the minimum or maximum value, &lt;a href=&quot;../reference/api/pandas.dataframe.idxmin#pandas.DataFrame.idxmin&quot;&gt;&lt;code&gt;idxmin()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe.idxmax#pandas.DataFrame.idxmax&quot;&gt;&lt;code&gt;idxmax()&lt;/code&gt;&lt;/a&gt; return the first matching index:</source>
          <target state="translated">최소값 또는 최대 값과 일치하는 여러 행 (또는 열)이있는 경우 &lt;a href=&quot;../reference/api/pandas.dataframe.idxmin#pandas.DataFrame.idxmin&quot;&gt; &lt;code&gt;idxmin()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.dataframe.idxmax#pandas.DataFrame.idxmax&quot;&gt; &lt;code&gt;idxmax()&lt;/code&gt; &lt;/a&gt; 는 첫 번째 일치 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3eb2d4bc692a18f360a34d38c80867c42d1eaa36" translate="yes" xml:space="preserve">
          <source>When to switch from the verbose to the truncated output. If the DataFrame has more than</source>
          <target state="translated">상세 정보에서 잘린 출력으로 전환 할시기입니다. DataFrame에</target>
        </trans-unit>
        <trans-unit id="bce9c5cfde3159b7dee94853084aa241c34d7f69" translate="yes" xml:space="preserve">
          <source>When to switch from the verbose to the truncated output. If the DataFrame has more than &lt;code&gt;max_cols&lt;/code&gt; columns, the truncated output is used. By default, the setting in &lt;code&gt;pandas.options.display.max_info_columns&lt;/code&gt; is used.</source>
          <target state="translated">상세에서 잘린 출력으로 전환 할 때 DataFrame에 max_cols보다 &lt;code&gt;max_cols&lt;/code&gt; 열 이 있으면 잘린 출력이 사용됩니다. 기본적으로 &lt;code&gt;pandas.options.display.max_info_columns&lt;/code&gt; 의 설정 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e08aa2c6fb555cfd1b671c4ffc00c3f84ad5523c" translate="yes" xml:space="preserve">
          <source>When transforming a DataFrame using &lt;a href=&quot;../reference/api/pandas.melt#pandas.melt&quot;&gt;&lt;code&gt;melt()&lt;/code&gt;&lt;/a&gt;, the index will be ignored. The original index values can be kept around by setting the &lt;code&gt;ignore_index&lt;/code&gt; parameter to &lt;code&gt;False&lt;/code&gt; (default is &lt;code&gt;True&lt;/code&gt;). This will however duplicate them.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.melt#pandas.melt&quot;&gt; &lt;code&gt;melt()&lt;/code&gt; &lt;/a&gt; 사용하여 DataFrame을 변환 하면 인덱스가 무시됩니다. &lt;code&gt;ignore_index&lt;/code&gt; 매개 변수를 &lt;code&gt;False&lt;/code&gt; (기본값은 &lt;code&gt;True&lt;/code&gt; ) 로 설정하여 원래 색인 값을 유지할 수 있습니다 . 그러나 이것은 그것들을 복제합니다.</target>
        </trans-unit>
        <trans-unit id="ff836aa009a7378f4dd10667c320ed1f19d9e641" translate="yes" xml:space="preserve">
          <source>When trying to convert a subset of columns to a specified type using &lt;a href=&quot;../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype&quot;&gt;&lt;code&gt;astype()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe.loc#pandas.DataFrame.loc&quot;&gt;&lt;code&gt;loc()&lt;/code&gt;&lt;/a&gt;, upcasting occurs.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype&quot;&gt; &lt;code&gt;astype()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.dataframe.loc#pandas.DataFrame.loc&quot;&gt; &lt;code&gt;loc()&lt;/code&gt; &lt;/a&gt; 사용하여 열의 하위 집합을 지정된 유형으로 변환하려고하면 업 캐스팅이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="de60fbc56828b7965ebca8df9f7d8e3bc2e3589f" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../reference/api/pandas.dataframe.eval#pandas.DataFrame.eval&quot;&gt;&lt;code&gt;DataFrame.eval()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe.query#pandas.DataFrame.query&quot;&gt;&lt;code&gt;DataFrame.query()&lt;/code&gt;&lt;/a&gt;, this allows you to have a local variable and a &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; column with the same name in an expression.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../reference/api/pandas.dataframe.eval#pandas.DataFrame.eval&quot;&gt; &lt;code&gt;DataFrame.eval()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../reference/api/pandas.dataframe.query#pandas.DataFrame.query&quot;&gt; &lt;code&gt;DataFrame.query()&lt;/code&gt; &lt;/a&gt; , 이것은 당신이 지역 변수와 가질 수 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 의&lt;/a&gt; 표현에서 동일한 이름을 가진 열을.</target>
        </trans-unit>
        <trans-unit id="9e4d6bcf90cd726d6feeae5d065ab8b5176962c9" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;.loc&lt;/code&gt; with slices, if both the start and the stop labels are present in the index, then elements &lt;em&gt;located&lt;/em&gt; between the two (including them) are returned:</source>
          <target state="translated">사용시 &lt;code&gt;.loc&lt;/code&gt; 을 슬라이스 시작 및 정지 라벨 모두 인덱스에 존재하는 경우, 그 다음 요소 &lt;em&gt;위치&lt;/em&gt; (이를 포함) 두 리턴 사이 :</target>
        </trans-unit>
        <trans-unit id="b37a804e6e41127bfad29c4306b45de53e73b2df" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Styler.apply(func, axis=None)&lt;/code&gt;, the function must return a DataFrame with the same index and column labels.</source>
          <target state="translated">사용시 &lt;code&gt;Styler.apply(func, axis=None)&lt;/code&gt; , 함수는 동일한 인덱스 및 열 라벨와 DataFrame을 반환해야한다.</target>
        </trans-unit>
        <trans-unit id="bcaa0b01e3b1bee5c59b9a42ae4167ff2f9d8e37" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;dtype=CategoricalDtype&lt;/code&gt;, &amp;ldquo;unexpected&amp;rdquo; values outside of &lt;code&gt;dtype.categories&lt;/code&gt; are treated as missing values.</source>
          <target state="translated">사용시 &lt;code&gt;dtype=CategoricalDtype&lt;/code&gt; 의 &quot;예기치&quot;값 밖에 &lt;code&gt;dtype.categories&lt;/code&gt; 가 없는 값으로서 처리된다.</target>
        </trans-unit>
        <trans-unit id="b8c3c957ce77112a09cc4f71677079c570ff8c11" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;engine='numba'&lt;/code&gt;, there will be no &amp;ldquo;fall back&amp;rdquo; behavior internally. The group data and group index will be passed as NumPy arrays to the JITed user defined function, and no alternative execution attempts will be tried.</source>
          <target state="translated">&lt;code&gt;engine='numba'&lt;/code&gt; 를 사용할 때 내부적으로 &quot;대체 &quot;동작이 없습니다. 그룹 데이터 및 그룹 인덱스는 NumPy 배열로 JITed 사용자 정의 함수에 전달되며 대체 실행 시도는 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fad9aa4d15229776db11b654752c7d2fe1dc9c7" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;engine='numba'&lt;/code&gt;, there will be no &amp;ldquo;fall back&amp;rdquo; behavior internally. The group data and group index will be passed as numpy arrays to the JITed user defined function, and no alternative execution attempts will be tried.</source>
          <target state="translated">&lt;code&gt;engine='numba'&lt;/code&gt; 를 사용할 때 내부적으로 &quot;대체 &quot;동작이 없습니다. 그룹 데이터 및 그룹 인덱스는 JITed 사용자 정의 함수에 numpy 배열로 전달되며 대체 실행 시도는 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b5c9b8fc8e549b8e006268c40c0723ac834bff5" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;expand=True&lt;/code&gt;, the split elements will expand out into separate columns. If NaN is present, it is propagated throughout the columns during the split.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;expand=True&lt;/code&gt; , 분할 요소는 별도 열로 밖으로 확장됩니다. NaN이 있으면 분할하는 동안 열 전체에 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="4c5a9d0277936066be7d2f2843b04396898f8974" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;keep='all'&lt;/code&gt;, all duplicate items are maintained:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;keep='all'&lt;/code&gt; , 모든 중복 항목이 유지됩니다</target>
        </trans-unit>
        <trans-unit id="315c9ed7c20453242eee108cd70becf1f9dc30fc" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;keep='last'&lt;/code&gt;, ties are resolved in reverse order:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;keep='last'&lt;/code&gt; , 넥타이는 역순으로 해결 :</target>
        </trans-unit>
        <trans-unit id="29d24eb180dd53de2a3c5fb004e4844bcc2496e8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;pytz&lt;/code&gt; time zones, &lt;a href=&quot;../reference/api/pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt;&lt;code&gt;DatetimeIndex&lt;/code&gt;&lt;/a&gt; will construct a different time zone object than a &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; for the same time zone input. A &lt;a href=&quot;../reference/api/pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt;&lt;code&gt;DatetimeIndex&lt;/code&gt;&lt;/a&gt; can hold a collection of &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; objects that may have different UTC offsets and cannot be succinctly represented by one &lt;code&gt;pytz&lt;/code&gt; time zone instance while one &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; represents one point in time with a specific UTC offset.</source>
          <target state="translated">&lt;code&gt;pytz&lt;/code&gt; 시간대를 사용할 때 &lt;a href=&quot;../reference/api/pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt; &lt;code&gt;DatetimeIndex&lt;/code&gt; &lt;/a&gt; 는 동일한 시간대 입력에 대해 &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt; &lt;code&gt;Timestamp&lt;/code&gt; &lt;/a&gt; 와 다른 시간대 객체 를 생성합니다. &lt;a href=&quot;../reference/api/pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt; &lt;code&gt;DatetimeIndex&lt;/code&gt; 은&lt;/a&gt; 컬렉션 수납 할 수있는 &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt; &lt;code&gt;Timestamp&lt;/code&gt; &lt;/a&gt; 그 다른 UTC 오프셋을 가질 수있다 목적 및 간결 하나에 의해 표현할 수없는 &lt;code&gt;pytz&lt;/code&gt; 의 하나하면서 시간대 인스턴스 &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt; &lt;code&gt;Timestamp&lt;/code&gt; &lt;/a&gt; UTC는 특정 오프셋 시간의 한 지점을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="fb4d4ddda9ba8f9e52fd32308ea4212757485cc7" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;Categorical&lt;/code&gt; grouper (as a single grouper, or as part of multiple groupers), the &lt;code&gt;observed&lt;/code&gt; keyword controls whether to return a cartesian product of all possible groupers values (&lt;code&gt;observed=False&lt;/code&gt;) or only those that are observed groupers (&lt;code&gt;observed=True&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Categorical&lt;/code&gt; 그룹화를 사용하는 경우 (단일 그룹화 또는 여러 그룹화의 일부로) &lt;code&gt;observed&lt;/code&gt; 키워드는 가능한 모든 그룹화 값 ( &lt;code&gt;observed=False&lt;/code&gt; ) 의 데카르트 곱을 반환할지 아니면 관찰 된 그룹화 자만 반환할지 ( &lt;code&gt;observed=True&lt;/code&gt; ) 여부를 제어합니다. ).</target>
        </trans-unit>
        <trans-unit id="9c62a0bb8f084b2afc6c6cbd323d041ca2986055" translate="yes" xml:space="preserve">
          <source>When using a secondary_y axis, automatically mark the column labels with &amp;ldquo;(right)&amp;rdquo; in the legend.</source>
          <target state="translated">secondary_y 축을 사용하는 경우 범례에서 &quot;(오른쪽)&quot;으로 열 레이블을 자동으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c9fa8d4c0e1d57c3258b880b66b359610ba3955c" translate="yes" xml:space="preserve">
          <source>When using the &amp;lsquo;index&amp;rsquo; orientation, the column names can be specified manually:</source>
          <target state="translated">'색인'방향을 사용할 때 열 이름을 수동으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a5e9197895d77f2129e1594627201c9aaa9ce48" translate="yes" xml:space="preserve">
          <source>When we draw a dice 6000 times, we expect to get each value around 1000 times. But when we draw two dices and sum the result, the distribution is going to be quite different. A histogram illustrates those distributions.</source>
          <target state="translated">주사위를 6000 번 그릴 때 각 값은 약 1000 배가 될 것으로 예상됩니다. 그러나 우리가 두 개의 오지를 그리고 결과를 합하면 분포는 상당히 다를 것입니다. 히스토그램은 이러한 분포를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c56d3d43a87fc11354ce04fef9a3b040e787b284" translate="yes" xml:space="preserve">
          <source>When we reset the index, the old index is added as a column, and a new sequential index is used:</source>
          <target state="translated">인덱스를 재설정하면 이전 인덱스가 열로 추가되고 새로운 순차 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="81706afb3f08a0e7e3a20f7ec821561784a0db47" translate="yes" xml:space="preserve">
          <source>When working with an &lt;code&gt;Index&lt;/code&gt; object directly, rather than via a &lt;code&gt;DataFrame&lt;/code&gt;, &lt;a href=&quot;../reference/api/pandas.index.set_names#pandas.Index.set_names&quot;&gt;&lt;code&gt;Index.set_names()&lt;/code&gt;&lt;/a&gt; can be used to change the names.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 을 &lt;a href=&quot;../reference/api/pandas.index.set_names#pandas.Index.set_names&quot;&gt; &lt;code&gt;Index.set_names()&lt;/code&gt; &lt;/a&gt; 않고 &lt;code&gt;Index&lt;/code&gt; 객체로 직접 작업 할 때 Index.set_names () 를 사용하여 이름을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26002c60683058a453e93f25c10d001bc2332b6b" translate="yes" xml:space="preserve">
          <source>When working with heterogeneous data, the dtype of the resulting ndarray will be chosen to accommodate all of the data involved. For example, if strings are involved, the result will be of object dtype. If there are only floats and integers, the resulting array will be of float dtype.</source>
          <target state="translated">이기종 데이터로 작업 할 때 관련된 모든 데이터를 수용하기 위해 결과 ndarray의 dtype이 선택됩니다. 예를 들어 문자열이 포함 된 경우 결과는 개체 dtype이됩니다. 실수와 정수만있는 경우 결과 배열은 float dtype이됩니다.</target>
        </trans-unit>
        <trans-unit id="23bc68ad0906c3361052afcceab5f6fc5d41e775" translate="yes" xml:space="preserve">
          <source>When working with raw NumPy arrays, looping through value-by-value is usually not necessary. The same is true when working with Series in pandas. Series can also be passed into most NumPy methods expecting an ndarray.</source>
          <target state="translated">원시 NumPy 배열로 작업 할 때 일반적으로 값별로 반복 할 필요가 없습니다. pandas에서 Series로 작업 할 때도 마찬가지입니다. 시리즈는 ndarray를 예상하는 대부분의 NumPy 메소드로 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c23fff035bd0e8e2b359894dd34b0e36bb191bb2" translate="yes" xml:space="preserve">
          <source>When working with text data, where each valid element is a string or missing, we recommend using &lt;a href=&quot;api/pandas.stringdtype#pandas.StringDtype&quot;&gt;&lt;code&gt;StringDtype&lt;/code&gt;&lt;/a&gt; (with the alias &lt;code&gt;&quot;string&quot;&lt;/code&gt;).</source>
          <target state="translated">유효한 각 요소가 문자열이거나 누락 된 텍스트 데이터로 작업 할 때는 &lt;a href=&quot;api/pandas.stringdtype#pandas.StringDtype&quot;&gt; &lt;code&gt;StringDtype&lt;/code&gt; &lt;/a&gt; (별명 &lt;code&gt;&quot;string&quot;&lt;/code&gt; 사용 )을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bcf2469dbd87fb0a6fdf5cb5d01a8a6a47f96521" translate="yes" xml:space="preserve">
          <source>When writing performance-sensitive code, there is a good reason to spend some time becoming a reindexing ninja: &lt;strong&gt;many operations are faster on pre-aligned data&lt;/strong&gt;. Adding two unaligned DataFrames internally triggers a reindexing step. For exploratory analysis you will hardly notice the difference (because &lt;code&gt;reindex&lt;/code&gt; has been heavily optimized), but when CPU cycles matter sprinkling a few explicit &lt;code&gt;reindex&lt;/code&gt; calls here and there can have an impact.</source>
          <target state="translated">성능에 민감한 코드를 작성할 때 재색 인화 닌자가되는 데 시간을 할애해야하는 좋은 이유가 &lt;strong&gt;있습니다&lt;/strong&gt; . &lt;strong&gt;사전 정렬 된 데이터에서 많은 작업이 더 빠릅니다&lt;/strong&gt; . 두 개의 정렬되지 않은 DataFrame을 내부적으로 추가하면 재색 인화 단계가 트리거됩니다. 탐색 적 분석의 경우 (재 &lt;code&gt;reindex&lt;/code&gt; 이 고도로 최적화 되었기 때문에) 차이를 거의 알아 차리지 못하지만 CPU주기가 중요 할 때 여기에 명시적인 재 &lt;code&gt;reindex&lt;/code&gt; 호출을 몇 번 뿌려 영향을 미칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c32935bbda5fc841806edb88198852464f8e8cee" translate="yes" xml:space="preserve">
          <source>When writing style functions, you take care of producing the CSS attribute / value pairs you want. Pandas matches those up with the CSS classes that identify each cell.</source>
          <target state="translated">스타일 함수를 작성할 때 원하는 CSS 속성 / 값 쌍을 생성합니다. 팬더는 각 셀을 식별하는 CSS 클래스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ff2fb9d362d2757eb75d210d3858f958311caffa" translate="yes" xml:space="preserve">
          <source>When writing timezone aware data to databases that do not support timezones, the data will be written as timezone naive timestamps that are in local time with respect to the timezone.</source>
          <target state="translated">시간대를 지원하지 않는 데이터베이스에 시간대 인식 데이터를 쓸 때 데이터는 시간대와 관련하여 현지 시간에 해당하는 시간대 순진 타임 스탬프로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="97c526dd24e7a7890e1cd7b561affa8dff231182" translate="yes" xml:space="preserve">
          <source>When writing, the top three functions in terms of speed are &lt;code&gt;test_feather_write&lt;/code&gt;, &lt;code&gt;test_hdf_fixed_write&lt;/code&gt; and &lt;code&gt;test_hdf_fixed_write_compress&lt;/code&gt;.</source>
          <target state="translated">작성할 때 속도 측면에서 상위 3 개 함수는 &lt;code&gt;test_feather_write&lt;/code&gt; , &lt;code&gt;test_hdf_fixed_write&lt;/code&gt; 및 &lt;code&gt;test_hdf_fixed_write_compress&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1cad6d87f5cdc0a9faf3f52e6faeeb1d92e4d1e7" translate="yes" xml:space="preserve">
          <source>When you compare two unordered categoricals with the same categories, the order is not considered:</source>
          <target state="translated">두 개의 정렬되지 않은 범주를 동일한 범주와 비교할 때 순서는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e21f6c8427b4e8295b3f6c690fab15cf148ab52d" translate="yes" xml:space="preserve">
          <source>When you have a function that cannot work on the full DataFrame/Series at once, it is better to use &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; instead of iterating over the values. See the docs on &lt;a href=&quot;#basics-apply&quot;&gt;function application&lt;/a&gt;.</source>
          <target state="translated">한 번에 전체 DataFrame / Series에서 작동 할 수없는 함수가있는 경우 값을 반복하는 대신 &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 . &lt;a href=&quot;#basics-apply&quot;&gt;함수 애플리케이션&lt;/a&gt; 에 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8010f00f30a5775cb8f09ed714f8391fa4eb635" translate="yes" xml:space="preserve">
          <source>When you pass other type of arguments via &lt;code&gt;color&lt;/code&gt; keyword, it will be directly passed to matplotlib for all the &lt;code&gt;boxes&lt;/code&gt;, &lt;code&gt;whiskers&lt;/code&gt;, &lt;code&gt;medians&lt;/code&gt; and &lt;code&gt;caps&lt;/code&gt; colorization.</source>
          <target state="translated">&lt;code&gt;color&lt;/code&gt; 키워드 를 통해 다른 유형의 인수를 전달하면 모든 &lt;code&gt;boxes&lt;/code&gt; , &lt;code&gt;whiskers&lt;/code&gt; , &lt;code&gt;medians&lt;/code&gt; 및 &lt;code&gt;caps&lt;/code&gt; 색상 화에 대해 matplotlib에 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ee88fcbba77b00486dbd6359c5b5295924dbd3c" translate="yes" xml:space="preserve">
          <source>When you use chained indexing, the order and type of the indexing operation partially determine whether the result is a slice into the original object, or a copy of the slice.</source>
          <target state="translated">연결 인덱싱을 사용하는 경우 인덱싱 작업의 순서와 유형에 따라 결과가 원본 개체의 조각인지 또는 조각의 복사본인지 부분적으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="263278c083269b77285aa9571251f5635d9f8d70" translate="yes" xml:space="preserve">
          <source>When you want every pairing of the elements in two iterables, it can be easier to use the &lt;a href=&quot;../reference/api/pandas.multiindex.from_product#pandas.MultiIndex.from_product&quot;&gt;&lt;code&gt;MultiIndex.from_product()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">두 개의 iterable에서 요소의 모든 쌍을 원할 때 &lt;a href=&quot;../reference/api/pandas.multiindex.from_product#pandas.MultiIndex.from_product&quot;&gt; &lt;code&gt;MultiIndex.from_product()&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하는 것이 더 쉬울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="689df68b89aa82dfd47326209affc957ca044460" translate="yes" xml:space="preserve">
          <source>When you want to update the feature branch with changes in master after you created the branch, check the section on &lt;a href=&quot;#contributing-update-pr&quot;&gt;updating a PR&lt;/a&gt;.</source>
          <target state="translated">분기를 생성 한 후 master에서 변경 사항으로 기능 분기를 업데이트하려면 &lt;a href=&quot;#contributing-update-pr&quot;&gt;PR 업데이트&lt;/a&gt; 섹션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c3e06de33d3da280d127d0465fcb6057c3c87f3" translate="yes" xml:space="preserve">
          <source>When you want your changes to appear publicly on your GitHub page, push your forked feature branch&amp;rsquo;s commits:</source>
          <target state="translated">변경 사항을 GitHub 페이지에 공개적으로 표시하려면 분기 기능 분기의 커밋을 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="859279367089a6d96bcf1e5c6c122a62a6e0dcce" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to ask for a code review, file a pull request. Before you do, once again make sure that you have followed all the guidelines outlined in this document regarding code style, tests, performance tests, and documentation. You should also double check your branch changes against the branch it was based on:</source>
          <target state="translated">코드 검토를 요청할 준비가되면 풀 요청을 제출하십시오. 시작하기 전에 코드 스타일, 테스트, 성능 테스트 및 문서와 관련하여이 문서에 요약 된 모든 지침을 다시 한 번 확인하십시오. 또한 다음을 기반으로 한 지점과 지점 변경 사항을 다시 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="31f5e4a25df56f745c3f27a145932290c25e6147" translate="yes" xml:space="preserve">
          <source>When your DataFrame contains a mixture of data types, &lt;a href=&quot;../reference/api/pandas.dataframe.values#pandas.DataFrame.values&quot;&gt;&lt;code&gt;DataFrame.values&lt;/code&gt;&lt;/a&gt; may involve copying data and coercing values to a common dtype, a relatively expensive operation. &lt;a href=&quot;../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt;&lt;code&gt;DataFrame.to_numpy()&lt;/code&gt;&lt;/a&gt;, being a method, makes it clearer that the returned NumPy array may not be a view on the same data in the DataFrame.</source>
          <target state="translated">당신의 DataFrame 데이터 유형의 혼합물을 포함 할 때, &lt;a href=&quot;../reference/api/pandas.dataframe.values#pandas.DataFrame.values&quot;&gt; &lt;code&gt;DataFrame.values&lt;/code&gt; 은&lt;/a&gt; 데이터를 복사하고 공통 DTYPE, 상대적으로 비용이 많이 드는 작업에 값을 강요 포함될 수 있습니다. &lt;a href=&quot;../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt; &lt;code&gt;DataFrame.to_numpy()&lt;/code&gt; &lt;/a&gt; 는 반환 된 NumPy 배열이 DataFrame의 동일한 데이터에 대한 뷰가 아닐 수 있음을 더 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="50ba287d1b7cde6be4ebcedac63775f209f53211" translate="yes" xml:space="preserve">
          <source>When your Series contains an &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/development/extending.html#extending-extension-types&quot;&gt;extension type&lt;/a&gt;, it&amp;rsquo;s unclear whether &lt;a href=&quot;../reference/api/pandas.series.values#pandas.Series.values&quot;&gt;&lt;code&gt;Series.values&lt;/code&gt;&lt;/a&gt; returns a NumPy array or the extension array. &lt;a href=&quot;../reference/api/pandas.series.array#pandas.Series.array&quot;&gt;&lt;code&gt;Series.array&lt;/code&gt;&lt;/a&gt; will always return an &lt;a href=&quot;../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray&quot;&gt;&lt;code&gt;ExtensionArray&lt;/code&gt;&lt;/a&gt;, and will never copy data. &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;Series.to_numpy()&lt;/code&gt;&lt;/a&gt; will always return a NumPy array, potentially at the cost of copying / coercing values.</source>
          <target state="translated">Series에 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/development/extending.html#extending-extension-types&quot;&gt;확장 유형이&lt;/a&gt; 포함되어 있으면 &lt;a href=&quot;../reference/api/pandas.series.values#pandas.Series.values&quot;&gt; &lt;code&gt;Series.values&lt;/code&gt; &lt;/a&gt; 가 NumPy 배열 또는 확장 배열을 반환 하는지 여부가 명확하지 않습니다 . &lt;a href=&quot;../reference/api/pandas.series.array#pandas.Series.array&quot;&gt; &lt;code&gt;Series.array&lt;/code&gt; &lt;/a&gt; 는 항상 &lt;a href=&quot;../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray&quot;&gt; &lt;code&gt;ExtensionArray&lt;/code&gt; 를&lt;/a&gt; 반환하고 데이터를 복사하지 않습니다. &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;Series.to_numpy()&lt;/code&gt; &lt;/a&gt; 는 잠재적으로 값을 복사 / 강제하는 비용으로 항상 NumPy 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="907a50cdf0e404fa16d8ec46ed1cf8f7f4c436d4" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;cond&lt;/code&gt; is False, keep the original value. Where True, replace with corresponding value from &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;cond&lt;/code&gt; is callable, it is computed on the Series/DataFrame and should return boolean Series/DataFrame or array. The callable must not change input Series/DataFrame (though pandas doesn&amp;rsquo;t check it).</source>
          <target state="translated">어디 &lt;code&gt;cond&lt;/code&gt; 거짓이다, 원래 값을 유지한다. True 인 경우 &lt;code&gt;other&lt;/code&gt; 의 해당 값으로 바꾸십시오 . &lt;code&gt;cond&lt;/code&gt; 를 호출 할 수 있으면 Series / DataFrame에서 계산되며 부울 Series / DataFrame 또는 배열을 반환해야합니다. 콜 러블은 팬더가 확인하지 않아도 입력 시리즈 / 데이터 프레임을 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="074ea680722fd2f03880dd703ff27577e31f9bb9" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;cond&lt;/code&gt; is True, keep the original value. Where False, replace with corresponding value from &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;cond&lt;/code&gt; is callable, it is computed on the Series/DataFrame and should return boolean Series/DataFrame or array. The callable must not change input Series/DataFrame (though pandas doesn&amp;rsquo;t check it).</source>
          <target state="translated">어디 &lt;code&gt;cond&lt;/code&gt; True입니다, 원래 값을 유지한다. False 인 경우 &lt;code&gt;other&lt;/code&gt; 의 해당 값으로 바꾸십시오 . &lt;code&gt;cond&lt;/code&gt; 를 호출 할 수 있으면 Series / DataFrame에서 계산되며 부울 Series / DataFrame 또는 배열을 반환해야합니다. 콜 러블은 팬더가 확인하지 않아도 입력 시리즈 / 데이터 프레임을 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="820bdbe72a318fb8fe155407c66407511526f66f" translate="yes" xml:space="preserve">
          <source>Where can also accept &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;level&lt;/code&gt; parameters to align the input when performing the &lt;code&gt;where&lt;/code&gt;.</source>
          <target state="translated">where는 &lt;code&gt;where&lt;/code&gt; 를 수행 할 때 입력을 정렬하기 위해 &lt;code&gt;axis&lt;/code&gt; 및 &lt;code&gt;level&lt;/code&gt; 매개 변수를 허용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85187dfee2b32a0dddded298d29c48709fb97dd1" translate="yes" xml:space="preserve">
          <source>Where the value is a callable, evaluated on</source>
          <target state="translated">값이 콜 러블이면 다음에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="115729b31bfba27ceafd5b66785e295c64fdbe25" translate="yes" xml:space="preserve">
          <source>Where the value is a callable, evaluated on &lt;code&gt;df&lt;/code&gt;:</source>
          <target state="translated">값이 호출 가능한 경우 &lt;code&gt;df&lt;/code&gt; 에서 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9992f51fe4ba5d0709875d722d1f6c069802346" translate="yes" xml:space="preserve">
          <source>Where there are duplicate values:</source>
          <target state="translated">중복 값이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="155b8b8ce82236d8d4c14dc102d2a18531f1c8a5" translate="yes" xml:space="preserve">
          <source>Where to reorder levels.</source>
          <target state="translated">레벨을 재정렬 할 위치</target>
        </trans-unit>
        <trans-unit id="dbee33813cd8c18a476718c9787a8d500ee8f51b" translate="yes" xml:space="preserve">
          <source>Where to send the output. By default, the output is printed to sys.stdout. Pass a writable buffer if you need to further process the output.</source>
          <target state="translated">출력을 보낼 곳. 기본적으로 출력은 sys.stdout에 인쇄됩니다. 출력을 추가로 처리해야 할 경우 쓰기 가능한 버퍼를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="4af9617f74f3fb16e775a0d165421fe00441bc1b" translate="yes" xml:space="preserve">
          <source>Where to start?</source>
          <target state="translated">어디서 시작하나요?</target>
        </trans-unit>
        <trans-unit id="8c0be4d149f3b4fb1243671a27f9eb0e08a7fd3f" translate="yes" xml:space="preserve">
          <source>Where x coefficients correspond to the values of each dimension and t is linearly spaced between -pi and +pi. Each row of frame then corresponds to a single curve.</source>
          <target state="translated">여기서 x 계수는 각 차원의 값에 해당하고 t는 -pi와 + pi 사이에 선형으로 간격을두고 있습니다. 프레임의 각 행은 단일 곡선에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2731133172962687c88ca95164ea9d0b15fa2cc6" translate="yes" xml:space="preserve">
          <source>Whereas if &lt;code&gt;ignore_na=True&lt;/code&gt;, the weighted average would be calculated as</source>
          <target state="translated">반면 만약 &lt;code&gt;ignore_na=True&lt;/code&gt; , 가중 평균은 다음과 같이 계산 될</target>
        </trans-unit>
        <trans-unit id="20f2e9f1a3acb8b9ca1a14c8b2af3096ad26a527" translate="yes" xml:space="preserve">
          <source>Whether</source>
          <target state="translated">Whether</target>
        </trans-unit>
        <trans-unit id="b67ec6ea21c47c8522487bf095c6157e49ddc8eb" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;obj&lt;/code&gt; can be compiled as a regex pattern.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 를 정규식 패턴으로 컴파일 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="86e221cd05a39625ddfcbfa2be6370d460c8b0ea" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;obj&lt;/code&gt; has dict-like properties.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 dict-like 속성이 있는지 여부</target>
        </trans-unit>
        <trans-unit id="b54fda8c33339cb35d33701e66c3b8ec9c220bc2" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;obj&lt;/code&gt; has file-like properties.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 파일과 같은 속성이 있는지 여부</target>
        </trans-unit>
        <trans-unit id="a7ed8449cf7d0793d51602e9eef86dc25501d3b3" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;obj&lt;/code&gt; has list-like properties.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 목록과 유사한 속성이 있는지 여부</target>
        </trans-unit>
        <trans-unit id="9db5eddf72afca49f5b966f94392dc8e6944ebaa" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;obj&lt;/code&gt; is a named tuple.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 명명 된 튜플 인지 여부</target>
        </trans-unit>
        <trans-unit id="c64d7f907803c16c6e49c8f748ccccfa9b906318" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;obj&lt;/code&gt; is a number or not.</source>
          <target state="translated">여부 &lt;code&gt;obj&lt;/code&gt; 수 여부입니다.</target>
        </trans-unit>
        <trans-unit id="34cf150a8ca6f437db64563df8973f109a697e99" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;obj&lt;/code&gt; is a regex pattern.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 정규식 패턴 인지 여부</target>
        </trans-unit>
        <trans-unit id="bd5749eee622c804c8bc82797e6f33311cf5462b" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;obj&lt;/code&gt; is an iterator.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 반복자 인지 여부</target>
        </trans-unit>
        <trans-unit id="4bcd2b9d6e3db50df0f74ff54eba5b932a7e2c86" translate="yes" xml:space="preserve">
          <source>Whether a copy or a reference is returned for a setting operation may depend on the context. This is sometimes called &lt;code&gt;chained assignment&lt;/code&gt; and should be avoided. See &lt;a href=&quot;indexing#indexing-view-versus-copy&quot;&gt;Returning a View versus Copy&lt;/a&gt;.</source>
          <target state="translated">설정 조작을 위해 사본 또는 참조가 리턴되는지 여부는 컨텍스트에 따라 달라질 수 있습니다. 이를 &lt;code&gt;chained assignment&lt;/code&gt; 이라고도 하며 피해야합니다. &lt;a href=&quot;indexing#indexing-view-versus-copy&quot;&gt;보기와 복사 반환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cd5f8136312f916e2c889d78891edf83599ba90" translate="yes" xml:space="preserve">
          <source>Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called &lt;code&gt;chained assignment&lt;/code&gt; and should be avoided. See &lt;a href=&quot;#indexing-view-versus-copy&quot;&gt;Returning a View versus Copy&lt;/a&gt;.</source>
          <target state="translated">설정 조작을 위해 사본 또는 참조가 리턴되는지 여부는 컨텍스트에 따라 달라질 수 있습니다. 이를 &lt;code&gt;chained assignment&lt;/code&gt; 이라고도 하며 피해야합니다. &lt;a href=&quot;#indexing-view-versus-copy&quot;&gt;보기와 복사 반환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a33e7df555080b16ccf1f2b63f9343cd96dc1049" translate="yes" xml:space="preserve">
          <source>Whether each column contains at least one True element (the default).</source>
          <target state="translated">각 열에 하나 이상의 True 요소가 포함되는지 여부 (기본값)</target>
        </trans-unit>
        <trans-unit id="d211088a9d601f48a1f668dcaf97f6bf784cee44" translate="yes" xml:space="preserve">
          <source>Whether each element in the DataFrame is contained in values.</source>
          <target state="translated">DataFrame의 각 요소가 값에 포함되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="f8939ddd903709f0f73f01084f6eae98288a0427" translate="yes" xml:space="preserve">
          <source>Whether elements in Series are contained in</source>
          <target state="translated">시리즈의 요소가 포함되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="c7f0330178934acf893370d010d341574b01df37" translate="yes" xml:space="preserve">
          <source>Whether elements with &amp;ldquo;display: none&amp;rdquo; should be parsed</source>
          <target state="translated">&quot;display : none&quot;이있는 요소를 구문 분석해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="cce05533e525fc7c028f0dc8f94c458e55cf3154" translate="yes" xml:space="preserve">
          <source>Whether elements with &amp;ldquo;display: none&amp;rdquo; should be parsed.</source>
          <target state="translated">&quot;display : none&quot;이있는 요소를 구문 분석해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a55616cd839c86b081736604f31bd21cb3715714" translate="yes" xml:space="preserve">
          <source>Whether object dtypes should be converted to &lt;code&gt;BooleanDtypes()&lt;/code&gt;.</source>
          <target state="translated">객체 dtype을 &lt;code&gt;BooleanDtypes()&lt;/code&gt; 로 변환해야하는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="f75d88a6fbf77cf16c4c4fae67675baeefd8d50b" translate="yes" xml:space="preserve">
          <source>Whether object dtypes should be converted to &lt;code&gt;StringDtype()&lt;/code&gt;.</source>
          <target state="translated">객체 dtype을 &lt;code&gt;StringDtype()&lt;/code&gt; 으로 변환해야하는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="505612d56b2c38220749f7f059273b5d0197c5db" translate="yes" xml:space="preserve">
          <source>Whether object dtypes should be converted to the best possible types.</source>
          <target state="translated">개체 dtype을 가능한 최상의 형식으로 변환해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="388b81d45d66f9fc51387b252dd08226ab90cb7c" translate="yes" xml:space="preserve">
          <source>Whether or not the Index has duplicate values.</source>
          <target state="translated">인덱스에 중복 값이 ​​있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="4e41898cd1254b4eafe597289c49f9dbce5a0d8c" translate="yes" xml:space="preserve">
          <source>Whether or not the Index holds Interval objects.</source>
          <target state="translated">Index가 Interval 객체를 보유하는지 여부.</target>
        </trans-unit>
        <trans-unit id="46da58b4a0ac78421a7fbe26a7acd02378a69c30" translate="yes" xml:space="preserve">
          <source>Whether or not the Index holds data with mixed data types.</source>
          <target state="translated">인덱스가 혼합 데이터 유형의 데이터를 보유하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="89a1b4df6584252c6f8aa22e3ff1e301f974611a" translate="yes" xml:space="preserve">
          <source>Whether or not the Index is of the object dtype.</source>
          <target state="translated">Index가 개체 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="da394f60688506c1a85465065fc0347a13ff8665" translate="yes" xml:space="preserve">
          <source>Whether or not the Index only consists of booleans.</source>
          <target state="translated">인덱스가 부울로만 구성되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="4c3cecbcebbe96dd8dc76e6185ef487766559915" translate="yes" xml:space="preserve">
          <source>Whether or not the Index only consists of integers.</source>
          <target state="translated">인덱스가 정수로만 구성되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="69de1bac7c77b1329ba16e1b1b8ff458955d261a" translate="yes" xml:space="preserve">
          <source>Whether or not the Index only consists of numeric data.</source>
          <target state="translated">인덱스가 숫자 데이터로만 구성되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a32d876acd20a8be4a915ff5f9d2becc61ed7bfe" translate="yes" xml:space="preserve">
          <source>Whether or not the Index only consists of only consists of floats, NaNs, or a mix of floats, integers, or NaNs.</source>
          <target state="translated">인덱스 만 구성되는지 여부는 부동 소수점, NaN 또는 부동 소수점, 정수 또는 NaN의 혼합으로 만 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="22776b3b28f0c13d149788d783fd9c3ab3eee812" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of a boolean dtype.</source>
          <target state="translated">배열 또는 dtype이 부울 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="53db8fc094cc1cc97f1bf97cbe083085ee34e071" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of a complex dtype.</source>
          <target state="translated">배열 또는 dtype이 복잡한 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7c21199c933bdbdd7b8dc3a0541115e44f148500" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of a float dtype.</source>
          <target state="translated">배열 또는 dtype이 float dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="cd6dd72e71a3321a0db85699b6d193d5372ea446" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of a numeric dtype.</source>
          <target state="translated">배열 또는 dtype이 숫자 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a3429cd2e6e4c2e26b2d4302bbfd449abdc1301b" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of a signed integer dtype and not an instance of timedelta64.</source>
          <target state="translated">배열 또는 dtype이 timedelta64 인스턴스가 아닌 부호있는 정수 dtype인지 여부</target>
        </trans-unit>
        <trans-unit id="940b6df13ab4ccab12f141c3b704b36fc3ffbe4e" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of an integer dtype and not an instance of timedelta64.</source>
          <target state="translated">배열 또는 dtype이 정수 dtype인지 여부와 timedelta64 인스턴스가 아닌지 여부</target>
        </trans-unit>
        <trans-unit id="40c091440f319d97fb52c4a9c24fca04f3df7942" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of an unsigned integer dtype.</source>
          <target state="translated">배열 또는 dtype이 부호없는 정수 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a5ba3b5c819993a163d111fb07cee5ceb50803ac" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of the datetime64 dtype.</source>
          <target state="translated">배열 또는 dtype이 datetime64 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c894c79ede346e315a03b8c10cf686f5f6924ade" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of the datetime64[ns] dtype.</source>
          <target state="translated">배열 또는 dtype이 datetime64 [ns] dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="4b137d4adc74a6d1641de347eebb0c6b74a95171" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of the int64 dtype.</source>
          <target state="translated">배열 또는 dtype이 int64 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="9ac065439de9fc591ba644f0ac832c5f7751a4d5" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of the string dtype.</source>
          <target state="translated">배열 또는 dtype이 문자열 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c72ce182e5fe9c83684834808592f516c47fab39" translate="yes" xml:space="preserve">
          <source>Whether or not the array or dtype is of the timedelta64[ns] dtype.</source>
          <target state="translated">배열 또는 dtype이 timedelta64 [ns] dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a365b6d8116fa8fa1987026c6225c9eac8dbd333" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like is a datetime array-like with a timezone component in its dtype.</source>
          <target state="translated">dlike에 시간대 구성 요소가있는 배열이 날짜 시간 배열인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b5a80f9880539a0ac520fc4d7ce23b42cf218378" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like is a pandas sparse array.</source>
          <target state="translated">배열과 같은 것이 판다 스파 스 배열인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3900a48b1137ab24dec388430e1d4e924326abdc" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like is a periodical index.</source>
          <target state="translated">배열과 같은 것이주기적인 색인인지 여부.</target>
        </trans-unit>
        <trans-unit id="c3a710f4ed959c060d39be5dff8e4962f596542d" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like is of a Categorical instance.</source>
          <target state="translated">배열과 같은 것이 범주 형 인스턴스인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f809d324731060928d914f55f0a0eadfc72b5593" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like is of a pandas extension class instance.</source>
          <target state="translated">배열과 같은 것이 pandas 확장 클래스 인스턴스인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e95735a5f5ecf4c52d61bee7ccc101a9c724a3a6" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.</source>
          <target state="translated">배열 형 또는 dtype이 DatetimeTZDtype dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="47d9d3b4a779f209a34bc13fe9cd8ca6afe22de4" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like or dtype is of the Categorical dtype.</source>
          <target state="translated">배열 형 또는 dtype이 범주 형 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7158b97d2da253b4a9e4c28d7994cbfe409e7a8f" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like or dtype is of the Interval dtype.</source>
          <target state="translated">배열과 같은 또는 dtype이 간격 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7b9336a72c1cb249a8bf147d7e27ebe050b6a6a0" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like or dtype is of the Period dtype.</source>
          <target state="translated">배열 형 또는 dtype이 Period dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="acafae59a5ca0680733c7028502fe13aa53acf37" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like or dtype is of the datetime64 dtype.</source>
          <target state="translated">배열 형 또는 dtype이 datetime64 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0dd9ea660da9d2e9ab3d744f879956331247ba29" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like or dtype is of the object dtype.</source>
          <target state="translated">배열 형 또는 dtype이 객체 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="14853464945259cb0d8e591c090fdd9b5d66aacf" translate="yes" xml:space="preserve">
          <source>Whether or not the array-like or dtype is of the timedelta64 dtype.</source>
          <target state="translated">배열 형 또는 dtype이 timedelta64 dtype인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="25ad7ccc1ef77bde78c2fcef7af04718e5003467" translate="yes" xml:space="preserve">
          <source>Whether or not the categorical is treated as a ordered categorical. If not given, do not change the ordered information.</source>
          <target state="translated">범주 형이 순서 형 범주 형으로 취급되는지 여부 제공되지 않은 경우 주문 정보를 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e911bed13c87e76be6978f04e54d6475b9dcfaf6" translate="yes" xml:space="preserve">
          <source>Whether or not the elements should be ranked in ascending order.</source>
          <target state="translated">요소가 오름차순으로 정렬되어야하는지 여부</target>
        </trans-unit>
        <trans-unit id="a6e5bd75a6d1aa33eb114875f794270459d1ca97" translate="yes" xml:space="preserve">
          <source>Whether or not the index values only consist of dates.</source>
          <target state="translated">인덱스 값이 날짜로만 구성되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="47f285d4b910a88654633df2b85c61ded3fb361e" translate="yes" xml:space="preserve">
          <source>Whether or not the new_categories should be considered as a rename of the old categories or as reordered categories.</source>
          <target state="translated">new_categories가 이전 범주의 이름을 바꾸거나 재정렬 된 범주로 간주해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b1c2aacf05b8fb5482a78f5d16228f7f7c0db189" translate="yes" xml:space="preserve">
          <source>Whether or not there are quoted values in</source>
          <target state="translated">인용 된 값이 있는지 여부</target>
        </trans-unit>
        <trans-unit id="6085149711bcc6aa77ae2cd6cc60714feb74fa01" translate="yes" xml:space="preserve">
          <source>Whether or not there are quoted values in &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 인용 된 값이 있는지 여부</target>
        </trans-unit>
        <trans-unit id="67e1f022e3e654379610d50549dafc37b444baaa" translate="yes" xml:space="preserve">
          <source>Whether or not this categorical is treated as a ordered categorical. If True, the resulting categorical will be ordered. An ordered categorical respects, when sorted, the order of its</source>
          <target state="translated">이 범주가 정렬 된 범주로 처리되는지 여부입니다. True이면 결과 범주가 정렬됩니다. 정렬 된 범주는 정렬 될 때 그 순서를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e0953b28e960b5132ae06e6c50755a74a171fa93" translate="yes" xml:space="preserve">
          <source>Whether or not this categorical is treated as a ordered categorical. If True, the resulting categorical will be ordered. An ordered categorical respects, when sorted, the order of its &lt;code&gt;categories&lt;/code&gt; attribute (which in turn is the &lt;code&gt;categories&lt;/code&gt; argument, if provided).</source>
          <target state="translated">이 범주가 정렬 된 범주 형으로 취급되는지 여부 True 인 경우 결과 범주 형이 주문됩니다. 정렬 된 범주 형 범주는 정렬 될 때 &lt;code&gt;categories&lt;/code&gt; 속성 의 순서를 따릅니다 (차례로 제공된 경우 &lt;code&gt;categories&lt;/code&gt; 인수 임).</target>
        </trans-unit>
        <trans-unit id="98e221f932c6f5b3d2a4dafc673b072aeecf5d36" translate="yes" xml:space="preserve">
          <source>Whether or not this categorical is treated as a ordered categorical. None can be used to maintain the ordered value of existing categoricals when used in operations that combine categoricals, e.g. astype, and will resolve to False if there is no existing ordered to maintain.</source>
          <target state="translated">이 범주가 정렬 된 범주로 처리되는지 여부입니다. 범주 형 (예 : astype)을 결합하는 작업에 사용될 때 기존 범주 형의 정렬 된 값을 유지하는 데 사용할 수 없으며 유지 관리 할 기존 주문이없는 경우 False로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d5f41f381634d1343160aaf2d025509a887a284b" translate="yes" xml:space="preserve">
          <source>Whether or not this categorical is treated as an ordered categorical. If not given here or in</source>
          <target state="translated">이 범주가 정렬 된 범주로 처리되는지 여부입니다. 여기 또는 안에 주어지지 않은 경우</target>
        </trans-unit>
        <trans-unit id="f0e3117bb9b9850047dcaffe10ee037111938f59" translate="yes" xml:space="preserve">
          <source>Whether or not this categorical is treated as an ordered categorical. If not given here or in &lt;code&gt;dtype&lt;/code&gt;, the resulting categorical will be unordered.</source>
          <target state="translated">이 범주가 정렬 된 범주 형으로 취급되는지 여부 here 또는 &lt;code&gt;dtype&lt;/code&gt; 으로 지정되지 않으면 결과 범주가 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c886c11f08c3cf79796ad3859236bb2ebaf99261" translate="yes" xml:space="preserve">
          <source>Whether or not to add the categories inplace or return a copy of this categorical with added categories.</source>
          <target state="translated">카테고리를 추가하거나 카테고리를 추가하여이 카테고리의 사본을 리턴할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ae65567c4f49b1706573053f6df13a6bca942c7b" translate="yes" xml:space="preserve">
          <source>Whether or not to display the returned rankings in percentile form.</source>
          <target state="translated">반환 된 순위를 백분위 수 형식으로 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0932682dcfb8c61fb8c1d712ea0d3ecbac2f28a7" translate="yes" xml:space="preserve">
          <source>Whether or not to drop unused categories inplace or return a copy of this categorical with unused categories dropped.</source>
          <target state="translated">사용하지 않는 범주를 제자리에 버릴지 여부 또는 사용되지 않은 범주를 버린이 범주의 사본을 리턴할지 여부</target>
        </trans-unit>
        <trans-unit id="03509b09dc32fa400d63bf710de8af775530c07c" translate="yes" xml:space="preserve">
          <source>Whether or not to include the default NaN values when parsing the data. Depending on whether</source>
          <target state="translated">데이터를 구문 분석 할 때 기본 NaN 값을 포함할지 여부입니다. 여부에 따라</target>
        </trans-unit>
        <trans-unit id="60d0b46ba7814fe567d93ff178d253945b560041" translate="yes" xml:space="preserve">
          <source>Whether or not to include the default NaN values when parsing the data. Depending on whether &lt;code&gt;na_values&lt;/code&gt; is passed in, the behavior is as follows:</source>
          <target state="translated">데이터를 구문 분석 할 때 기본 NaN 값을 포함할지 여부입니다. &lt;code&gt;na_values&lt;/code&gt; 가 전달 되는지 여부에 따라 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7c3985ceb1c9341da1f2004466ddb9109bcebf2" translate="yes" xml:space="preserve">
          <source>Whether or not to remove the categories inplace or return a copy of this categorical with removed categories.</source>
          <target state="translated">카테고리를 제자리에서 제거할지 또는 제거 된 카테고리와 함께이 범주의 사본을 리턴할지 여부.</target>
        </trans-unit>
        <trans-unit id="102352f97f600fdcc02f3cd27e0caac2f2ebaac7" translate="yes" xml:space="preserve">
          <source>Whether or not to rename the categories inplace or return a copy of this categorical with renamed categories.</source>
          <target state="translated">카테고리의 이름을 변경하거나 이름이 바뀐 카테고리로이 범주의 사본을 리턴할지 여부.</target>
        </trans-unit>
        <trans-unit id="f6a4770058338b225bbfb54f535e8e7a5e026d92" translate="yes" xml:space="preserve">
          <source>Whether or not to reorder the categories in-place or return a copy of this categorical with reordered categories.</source>
          <target state="translated">범주를 제자리에서 재정렬할지 또는 재정렬 된 범주와 함께이 범주의 복사본을 반환할지 여부.</target>
        </trans-unit>
        <trans-unit id="c2bbeeb7dc01f1760cb5c9a522c695db925c7c3d" translate="yes" xml:space="preserve">
          <source>Whether or not to reorder the categories inplace or return a copy of this categorical with reordered categories.</source>
          <target state="translated">범주를 제자리에 다시 정렬할지 또는 재정렬 된 범주와 함께이 범주의 복사본을 반환할지 여부</target>
        </trans-unit>
        <trans-unit id="d4b36acbe27f2136c54ab7655a06cff1adf58b47" translate="yes" xml:space="preserve">
          <source>Whether or not to return a copy.</source>
          <target state="translated">사본을 반환할지 여부.</target>
        </trans-unit>
        <trans-unit id="d46237d36861d5cb4ff96d17161a29bb72f3be14" translate="yes" xml:space="preserve">
          <source>Whether or not to set the ordered attribute in-place or return a copy of this categorical with ordered set to False.</source>
          <target state="translated">정렬 된 속성을 제자리에 설정할지 또는 정렬하지 않고 정렬 된이 범주의 사본을 False로 리턴할지 여부</target>
        </trans-unit>
        <trans-unit id="cf76be43556fb1c1c180d537267fd15249eac9ba" translate="yes" xml:space="preserve">
          <source>Whether or not to set the ordered attribute in-place or return a copy of this categorical with ordered set to True.</source>
          <target state="translated">정렬 된 속성을 제자리에 설정할지 또는 정렬 된 순서를 가진이 범주의 사본을 True로 리턴할지 여부.</target>
        </trans-unit>
        <trans-unit id="cf1e4687c0d3d2d1dc253d21a37e498c8e5bdf91" translate="yes" xml:space="preserve">
          <source>Whether the</source>
          <target state="translated">여부</target>
        </trans-unit>
        <trans-unit id="879e7ad5a4a5f54e20b712af28f664358d342aab" translate="yes" xml:space="preserve">
          <source>Whether the &lt;code&gt;arr_or_dtype&lt;/code&gt; is an extension array type.</source>
          <target state="translated">&lt;code&gt;arr_or_dtype&lt;/code&gt; 이 확장 배열 유형 인지 여부</target>
        </trans-unit>
        <trans-unit id="b3206b667a358326819e39532e96d89ce560a840" translate="yes" xml:space="preserve">
          <source>Whether the arrays are equivalent.</source>
          <target state="translated">배열이 동일한 지 여부.</target>
        </trans-unit>
        <trans-unit id="23f890daf73cb275b7a44a01564d8732e2dcb51d" translate="yes" xml:space="preserve">
          <source>Whether the categories have an ordered relationship.</source>
          <target state="translated">카테고리의 순서 관계가 있는지 여부</target>
        </trans-unit>
        <trans-unit id="09c3d2427d684ae4fc5f673fb6c1adb55b009481" translate="yes" xml:space="preserve">
          <source>Whether the dummy-encoded columns should be backed by a &lt;a href=&quot;pandas.sparsearray#pandas.SparseArray&quot;&gt;&lt;code&gt;SparseArray&lt;/code&gt;&lt;/a&gt; (True) or a regular NumPy array (False).</source>
          <target state="translated">더미 인코딩 열이 &lt;a href=&quot;pandas.sparsearray#pandas.SparseArray&quot;&gt; &lt;code&gt;SparseArray&lt;/code&gt; &lt;/a&gt; (True) 또는 일반 NumPy 배열 (False)에 의해 백업되어야하는지 여부</target>
        </trans-unit>
        <trans-unit id="310831e409765d924f963a5e8cee5b2800cc0ffd" translate="yes" xml:space="preserve">
          <source>Whether the dummy-encoded columns should be backed by a &lt;code&gt;SparseArray&lt;/code&gt; (True) or a regular NumPy array (False).</source>
          <target state="translated">더미 인코딩 된 열이 &lt;code&gt;SparseArray&lt;/code&gt; (True) 또는 일반 NumPy 배열 (False)에 의해 지원되어야하는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="9e6505cfe2f87adc25bbb71652ccca730fe89c62" translate="yes" xml:space="preserve">
          <source>Whether the elements should be aligned to the end or start within pa period.</source>
          <target state="translated">요소를 끝까지 정렬해야하는지 아니면 pa 기간 내에서 시작해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c304ddc4dc1b562aff20382c92054f1d3c36d3ee" translate="yes" xml:space="preserve">
          <source>Whether the end time needs to be included in the result.</source>
          <target state="translated">결과에 종료 시간을 포함해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a7575c0b17a9b6e9510d93b5945c7ffe9c82ff33" translate="yes" xml:space="preserve">
          <source>Whether the first interval should be left-inclusive or not.</source>
          <target state="translated">첫 번째 간격을 포함해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8972b129def0820104e3c0936a8a2e65b2368f34" translate="yes" xml:space="preserve">
          <source>Whether the generated HTML is for IPython Notebook.</source>
          <target state="translated">생성 된 HTML이 IPython Notebook 용인지 여부</target>
        </trans-unit>
        <trans-unit id="7ecac6a9347cc2f745741986971bf2c6b5dec571" translate="yes" xml:space="preserve">
          <source>Whether the index type is compatible with the provided type.</source>
          <target state="translated">색인 유형이 제공된 유형과 호환되는지 여부</target>
        </trans-unit>
        <trans-unit id="a87bae20ecf50580f800f3c2eb7f007c57232176" translate="yes" xml:space="preserve">
          <source>Whether the indices should result in an ascending or descending sort.</source>
          <target state="translated">지수가 오름차순인지 내림차순인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2cac93871cf98f3351eb71d46d76b4f24eef2a5f" translate="yes" xml:space="preserve">
          <source>Whether the interval is closed on the left-side, right-side, both or neither</source>
          <target state="translated">간격이 왼쪽, 오른쪽 또는 양쪽에서 닫혔는지 여부</target>
        </trans-unit>
        <trans-unit id="77e858b3f9ae7c6b498675de22ef78cfff61182c" translate="yes" xml:space="preserve">
          <source>Whether the interval is closed on the left-side, right-side, both or neither.</source>
          <target state="translated">간격이 왼쪽, 오른쪽 또는 둘 다에서 닫히거나 둘 다 닫혀 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5512ae9872c22d606571477c180759a0cd24c0a3" translate="yes" xml:space="preserve">
          <source>Whether the interval is closed on the left-side, right-side, both or neither. See the Notes for more detailed explanation.</source>
          <target state="translated">간격이 왼쪽, 오른쪽 또는 둘 다에 닫혀 있는지 여부입니다. 자세한 설명은 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9132ca891de79caa48e65f5999e79f9f15525504" translate="yes" xml:space="preserve">
          <source>Whether the intervals are closed on the left-side, right-side, both or neither</source>
          <target state="translated">간격이 왼쪽, 오른쪽 또는 양쪽에서 닫혔는지 여부</target>
        </trans-unit>
        <trans-unit id="0bb928bdf06342a9ba750f6e31b9169f1b5c051b" translate="yes" xml:space="preserve">
          <source>Whether the intervals are closed on the left-side, right-side, both or neither.</source>
          <target state="translated">간격이 왼쪽, 오른쪽 또는 둘 다에 닫혀 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="64b530e863247be4d8bdbc2d94325764796f436e" translate="yes" xml:space="preserve">
          <source>Whether the labels are ordered or not. Applies to returned types Categorical and Series (with Categorical dtype). If True, the resulting categorical will be ordered. If False, the resulting categorical will be unordered (labels must be provided).</source>
          <target state="translated">라벨 주문 여부. 반환 된 유형 Categorical 및 Series (Categorical dtype 포함)에 적용됩니다. True이면 결과 범주가 정렬됩니다. False 인 경우 결과 범주는 순서가 지정되지 않습니다 (레이블을 제공해야 함).</target>
        </trans-unit>
        <trans-unit id="8ff13d02e8369a7390718dd434a1f82b6dd375f9" translate="yes" xml:space="preserve">
          <source>Whether the query should modify the data in place or return a modified copy.</source>
          <target state="translated">쿼리에서 데이터를 수정해야하는지 또는 수정 된 복사본을 반환해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="d117e27b499874282c102d09b19f2ab70823143a" translate="yes" xml:space="preserve">
          <source>Whether the returned object allows duplicate labels.</source>
          <target state="translated">반환 된 개체가 중복 레이블을 허용하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="57a7ab83a0597c87020596c983ae24b4d8afbad6" translate="yes" xml:space="preserve">
          <source>Whether the start time needs to be included in the result.</source>
          <target state="translated">결과에 시작 시간을 포함해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="9acff264a1aa51d46c1fdbb3d092b77b1d1a7002" translate="yes" xml:space="preserve">
          <source>Whether the type is an integer type.</source>
          <target state="translated">유형이 정수 유형인지 여부</target>
        </trans-unit>
        <trans-unit id="a1612d866dc41b1141c25e54ce86394ccc6dc46f" translate="yes" xml:space="preserve">
          <source>Whether this object allows duplicate labels.</source>
          <target state="translated">이 개체가 중복 레이블을 허용하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3466258dc8ceaf113da343fa6e99024e45724a6e" translate="yes" xml:space="preserve">
          <source>Whether to allow duplicate labels in this object. By default, duplicate labels are permitted. Setting this to &lt;code&gt;False&lt;/code&gt; will cause an &lt;a href=&quot;pandas.errors.duplicatelabelerror#pandas.errors.DuplicateLabelError&quot;&gt;&lt;code&gt;errors.DuplicateLabelError&lt;/code&gt;&lt;/a&gt; to be raised when</source>
          <target state="translated">이 개체에서 중복 레이블을 허용할지 여부입니다. 기본적으로 중복 레이블이 허용됩니다. 이 설정 &lt;code&gt;False&lt;/code&gt; 의 원인이됩니다 &lt;a href=&quot;pandas.errors.duplicatelabelerror#pandas.errors.DuplicateLabelError&quot;&gt; &lt;code&gt;errors.DuplicateLabelError&lt;/code&gt; 이&lt;/a&gt; 때 발생하는</target>
        </trans-unit>
        <trans-unit id="f61a168f35420da34626d22f17b841f30c8d82e0" translate="yes" xml:space="preserve">
          <source>Whether to append columns to existing index.</source>
          <target state="translated">기존 인덱스에 열을 추가할지 여부</target>
        </trans-unit>
        <trans-unit id="3657d5dcc58deace981fc5b0e06b0729f5912983" translate="yes" xml:space="preserve">
          <source>Whether to check if the ExtensionArray dtypes are identical.</source>
          <target state="translated">ExtensionArray dtype이 동일한 지 확인할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6a601dd574b808af22fa4f40dc264f3a67430253" translate="yes" xml:space="preserve">
          <source>Whether to check that the</source>
          <target state="translated">확인 여부</target>
        </trans-unit>
        <trans-unit id="f6769d95c60e48e4bcc65ec513d5e37e4380717b" translate="yes" xml:space="preserve">
          <source>Whether to check that the &lt;code&gt;names&lt;/code&gt; attribute for both the &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt; attributes of the DataFrame is identical, i.e.</source>
          <target state="translated">여부를 확인하기 위해 &lt;code&gt;names&lt;/code&gt; 양쪽에 대한 속성 &lt;code&gt;index&lt;/code&gt; 및 &lt;code&gt;column&lt;/code&gt; DataFrame의 속성 것은 동일하다, 즉</target>
        </trans-unit>
        <trans-unit id="312b94e467df0dfed120dc9d8c87be69601bfc3a" translate="yes" xml:space="preserve">
          <source>Whether to check the</source>
          <target state="translated">확인 여부</target>
        </trans-unit>
        <trans-unit id="6cf067a90d1bc28ee4c26ff4d5abf93a285170f9" translate="yes" xml:space="preserve">
          <source>Whether to check the DataFrame class is identical.</source>
          <target state="translated">DataFrame 클래스를 확인할지 여부는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="05303ae7b7bb50f921d15a561433db59c6d1bf3f" translate="yes" xml:space="preserve">
          <source>Whether to check the DataFrame dtype is identical.</source>
          <target state="translated">DataFrame dtype을 확인할지 여부는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="27c02e72b950f7d226b044103d4d231bd93a33dc" translate="yes" xml:space="preserve">
          <source>Whether to check the Index class, dtype and inferred_type are identical.</source>
          <target state="translated">인덱스 클래스를 확인할지 여부는 dtype과 inferred_type이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="951c14276d9425a34b3c81114cedd3ef1c8fbfa9" translate="yes" xml:space="preserve">
          <source>Whether to check the Index class, dtype and inferred_type are identical. If &amp;lsquo;equiv&amp;rsquo;, then RangeIndex can be substituted for Int64Index as well.</source>
          <target state="translated">인덱스 클래스를 확인할지 여부는 dtype과 inferred_type이 동일합니다. 'equiv'이면 RangeIndex를 Int64Index로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b694de03dadeefc42e768c2013e714c9a0c6f220" translate="yes" xml:space="preserve">
          <source>Whether to check the Series and Index names attribute.</source>
          <target state="translated">계열 및 색인 이름 속성을 확인할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="bd04c6faa103115280a90db9aad999654abf585b" translate="yes" xml:space="preserve">
          <source>Whether to check the Series class is identical.</source>
          <target state="translated">Series 클래스를 확인할지 여부는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2c65017bce594011e4ce33917945134a538310d0" translate="yes" xml:space="preserve">
          <source>Whether to check the Series dtype is identical.</source>
          <target state="translated">Series dtype을 확인할지 여부는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f9a6db4a35770f56402fb602b1faf306b042086b" translate="yes" xml:space="preserve">
          <source>Whether to check the columns class, dtype and inferred_type are identical. Is passed as the &lt;code&gt;exact&lt;/code&gt; argument of &lt;a href=&quot;pandas.testing.assert_index_equal#pandas.testing.assert_index_equal&quot;&gt;&lt;code&gt;assert_index_equal()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열 클래스를 확인할지 여부는 dtype과 inferred_type이 동일합니다. &lt;a href=&quot;pandas.testing.assert_index_equal#pandas.testing.assert_index_equal&quot;&gt; &lt;code&gt;assert_index_equal()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;exact&lt;/code&gt; 인수 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="12a946e17a2ab180e5591e60c352796eed2bf4ef" translate="yes" xml:space="preserve">
          <source>Whether to check the names attribute.</source>
          <target state="translated">이름 속성을 확인할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a125c78103daa434686dedaef5a5d5205e9da7a6" translate="yes" xml:space="preserve">
          <source>Whether to compare by the index (0 or &amp;lsquo;index&amp;rsquo;) or columns (1 or &amp;lsquo;columns&amp;rsquo;).</source>
          <target state="translated">인덱스 (0 또는 '인덱스') 또는 열 (1 또는 '열')로 비교할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="cc9bd59cb75ad10e0f499f270512e00841264439" translate="yes" xml:space="preserve">
          <source>Whether to compare by the index (0 or &amp;lsquo;index&amp;rsquo;) or columns (1 or &amp;lsquo;columns&amp;rsquo;). For Series input, axis to match Series index on.</source>
          <target state="translated">인덱스 (0 또는 '인덱스') 또는 열 (1 또는 '열')로 비교할지 여부입니다. 시리즈 입력의 경우 시리즈 인덱스와 일치하는 축입니다.</target>
        </trans-unit>
        <trans-unit id="403027463ffc3bcdfe810242a92e2ce3b57217e8" translate="yes" xml:space="preserve">
          <source>Whether to compare category order of internal Categoricals.</source>
          <target state="translated">내부 범주의 범주 순서를 비교할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="480b99dfbb949b6f6125888e54aa057965d8ace4" translate="yes" xml:space="preserve">
          <source>Whether to compare internal Categorical exactly.</source>
          <target state="translated">내부 범주를 정확하게 비교할지 여부</target>
        </trans-unit>
        <trans-unit id="20709e04c5f473b9f4439c69137d6a5a6df1ed35" translate="yes" xml:space="preserve">
          <source>Whether to compare number exactly.</source>
          <target state="translated">숫자를 정확하게 비교할지 여부.</target>
        </trans-unit>
        <trans-unit id="836c48cc8d3a326fa2d88d99a3ac9b91bf5534a1" translate="yes" xml:space="preserve">
          <source>Whether to compare the order of index entries as well as their values. If True, both indexes must contain the same elements, in the same order. If False, both indexes must contain the same elements, but in any order.</source>
          <target state="translated">인덱스 항목의 순서와 해당 값을 비교할지 여부입니다. True 인 경우 두 인덱스 모두 동일한 순서로 동일한 요소를 포함해야합니다. False 인 경우 두 인덱스 모두 순서에 관계없이 동일한 요소를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="32e33c0d0ff7eafc269438bf1d39439f7a2508c7" translate="yes" xml:space="preserve">
          <source>Whether to convert the index to datetime.datetime if it is a DatetimeIndex.</source>
          <target state="translated">DatetimeIndex 인 경우 인덱스를 datetime.datetime으로 변환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1233d5c8c85f13169fb1db8a90c4f35c729d7906" translate="yes" xml:space="preserve">
          <source>Whether to copy</source>
          <target state="translated">복사 여부</target>
        </trans-unit>
        <trans-unit id="e7118a64439700ad6ec9de5344c486bd16b7f4ef" translate="yes" xml:space="preserve">
          <source>Whether to copy &lt;code&gt;values&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; 을 복사할지 여부 .</target>
        </trans-unit>
        <trans-unit id="7cc11e062a1edabbd88c21d45d1aaa4932d9f500" translate="yes" xml:space="preserve">
          <source>Whether to copy the</source>
          <target state="translated">복사 여부</target>
        </trans-unit>
        <trans-unit id="614ea6914bf833ca099af1f6261d14722a8fa7ea" translate="yes" xml:space="preserve">
          <source>Whether to copy the &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">여부는 복사 &lt;code&gt;values&lt;/code&gt; 과 &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b645fcf8186740ce7070d1db577df326179a2e1c" translate="yes" xml:space="preserve">
          <source>Whether to copy the array of data.</source>
          <target state="translated">데이터 배열 복사 여부입니다.</target>
        </trans-unit>
        <trans-unit id="33d3ba170581142cf2beaef5b76977c1694b0fb6" translate="yes" xml:space="preserve">
          <source>Whether to copy the data after transposing, even for DataFrames with a single dtype.</source>
          <target state="translated">단일 dtype이있는 DataFrame의 경우에도 전치 후 데이터를 복사할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d3d60658da64a86a783db458cc921346f96922bc" translate="yes" xml:space="preserve">
          <source>Whether to copy the data, even if not necessary. Depending on the type of</source>
          <target state="translated">필요하지 않은 경우에도 데이터를 복사할지 여부입니다. 유형에 따라</target>
        </trans-unit>
        <trans-unit id="8bcddbb1a8af47e6a749d83020b6aa1006a50048" translate="yes" xml:space="preserve">
          <source>Whether to copy the data, even if not necessary. Depending on the type of &lt;code&gt;data&lt;/code&gt;, creating the new array may require copying data, even if &lt;code&gt;copy=False&lt;/code&gt;.</source>
          <target state="translated">필요하지 않더라도 데이터를 복사할지 여부 &lt;code&gt;data&lt;/code&gt; 유형에 따라 새 배열을 만들려면 &lt;code&gt;copy=False&lt;/code&gt; 인 경우에도 데이터를 복사해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb9a6945c9da5892ce7c61e5e95925a3023a5690" translate="yes" xml:space="preserve">
          <source>Whether to copy the data, even if not necessary. If False, a copy is made only if the old dtype does not match the new dtype.</source>
          <target state="translated">필요하지 않더라도 데이터를 복사할지 여부 False이면 이전 dtype이 새 dtype과 일치하지 않는 경우에만 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="8c89b0a0f2ca5318211b06dec99f00fd486155fb" translate="yes" xml:space="preserve">
          <source>Whether to copy the ordinals before storing.</source>
          <target state="translated">저장하기 전에 서수를 복사할지 여부.</target>
        </trans-unit>
        <trans-unit id="aa50ec90c48448b0d3d09b94bea451df9a5f8b7a" translate="yes" xml:space="preserve">
          <source>Whether to copy the underlying array of data.</source>
          <target state="translated">기본 데이터 배열을 복사할지 여부</target>
        </trans-unit>
        <trans-unit id="6760d93be483b04fef3f0b473318faf3f56f1920" translate="yes" xml:space="preserve">
          <source>Whether to copy the underlying array of values.</source>
          <target state="translated">기본 값 배열을 복사할지 여부</target>
        </trans-unit>
        <trans-unit id="3677ef46abbb6b5d638c4a4b47315208e079ce86" translate="yes" xml:space="preserve">
          <source>Whether to copy underlying data.</source>
          <target state="translated">기본 데이터를 복사할지 여부</target>
        </trans-unit>
        <trans-unit id="5a038186442240fa2a86e573c4a13d18e5636a5e" translate="yes" xml:space="preserve">
          <source>Whether to drop duplicates in place or to return a copy</source>
          <target state="translated">복제본을 제자리에 놓을 것인지 또는 사본을 반환 할 것인지</target>
        </trans-unit>
        <trans-unit id="c34f73f93ed481edb8870d910e634e22792acbbe" translate="yes" xml:space="preserve">
          <source>Whether to drop duplicates in place or to return a copy.</source>
          <target state="translated">중복을 제자리에 놓을 지 또는 복사본을 반환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="31cd45da2fc7226a28db113813d2938fe6318be0" translate="yes" xml:space="preserve">
          <source>Whether to drop labels from the index (0 or &amp;lsquo;index&amp;rsquo;) or columns (1 or &amp;lsquo;columns&amp;rsquo;).</source>
          <target state="translated">인덱스 (0 또는 '인덱스') 또는 열 (1 또는 '열')에서 레이블을 삭제할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f6dedee7ed871e07a59400dd539a064c75a0c4a9" translate="yes" xml:space="preserve">
          <source>Whether to drop rows in the resulting Frame/Series with missing values. Stacking a column level onto the index axis can create combinations of index and column values that are missing from the original dataframe. See Examples section.</source>
          <target state="translated">결 측값이있는 결과 프레임 / 시리즈에서 행을 삭제할지 여부. 열 수준을 인덱스 축에 쌓으면 원래 데이터 프레임에서 누락 된 인덱스와 열 값의 조합이 만들어 질 수 있습니다. 예제 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="79d2d140969e06e02bd9a0caca1cf50cde758978" translate="yes" xml:space="preserve">
          <source>Whether to ensure that the returned value is a not a view on another array. Note that &lt;code&gt;copy=False&lt;/code&gt; does not &lt;em&gt;ensure&lt;/em&gt; that &lt;code&gt;to_numpy()&lt;/code&gt; is no-copy. Rather, &lt;code&gt;copy=True&lt;/code&gt; ensure that a copy is made, even if not strictly necessary.</source>
          <target state="translated">반환 값이 다른 배열에 대한 뷰가 아닌지 확인합니다. 주 &lt;code&gt;copy=False&lt;/code&gt; 없는 &lt;em&gt;보장&lt;/em&gt; 이 &lt;code&gt;to_numpy()&lt;/code&gt; 더 복사하지 않습니다. 오히려 &lt;code&gt;copy=True&lt;/code&gt; 는 꼭 필요한 것은 아니지만 복사가 이루어 지도록합니다.</target>
        </trans-unit>
        <trans-unit id="bfd682825d1d0ef258be6cabd3334e1d8ca77316" translate="yes" xml:space="preserve">
          <source>Whether to ensure that the returned value is not a view on another array. Note that &lt;code&gt;copy=False&lt;/code&gt; does not &lt;em&gt;ensure&lt;/em&gt; that &lt;code&gt;to_numpy()&lt;/code&gt; is no-copy. Rather, &lt;code&gt;copy=True&lt;/code&gt; ensure that a copy is made, even if not strictly necessary.</source>
          <target state="translated">반환 된 값이 다른 배열의 뷰가 아닌지 확인합니다. 주 &lt;code&gt;copy=False&lt;/code&gt; 없는 &lt;em&gt;보장&lt;/em&gt; 이 &lt;code&gt;to_numpy()&lt;/code&gt; 더 복사하지 않습니다. 오히려 &lt;code&gt;copy=True&lt;/code&gt; 는 꼭 필요하지 않더라도 복사본이 만들어 졌는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a0123a3886b8304eadba8ff96e75fa846d1ed386" translate="yes" xml:space="preserve">
          <source>Whether to explicitly copy the incoming</source>
          <target state="translated">수신을 명시 적으로 복사할지 여부</target>
        </trans-unit>
        <trans-unit id="fbb32f7260db29ce2cac48eb28428250b5f132ef" translate="yes" xml:space="preserve">
          <source>Whether to explicitly copy the incoming &lt;code&gt;data&lt;/code&gt; array.</source>
          <target state="translated">들어오는 &lt;code&gt;data&lt;/code&gt; 배열 을 명시 적으로 복사할지 여부</target>
        </trans-unit>
        <trans-unit id="079d9c0583ffcad2bcae56f266aa6c47d83acdf9" translate="yes" xml:space="preserve">
          <source>Whether to first categorize object arrays before hashing. This is more efficient when the array contains duplicate values.</source>
          <target state="translated">해시하기 전에 먼저 객체 배열을 분류할지 여부입니다. 배열에 중복 값이 ​​포함되어 있으면 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="24341d975c84bd2cab533cb2cfadc7db8145ce70" translate="yes" xml:space="preserve">
          <source>Whether to get k-1 dummies out of k categorical levels by removing the first level.</source>
          <target state="translated">첫 번째 레벨을 제거하여 k 개의 범주 레벨에서 k-1 인형을 가져올 지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6d7de50e4e90d9f6c88aa5f73ef9892f2af23ced" translate="yes" xml:space="preserve">
          <source>Whether to ignore any NaT elements</source>
          <target state="translated">NaT 요소를 무시할지 여부</target>
        </trans-unit>
        <trans-unit id="5254a0a8dfaae2c0f84466fbca85be45508c9916" translate="yes" xml:space="preserve">
          <source>Whether to ignore any NaT elements.</source>
          <target state="translated">NaT 요소를 무시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="dfeef7b5704c336635f2f63faeefd4a0a954e47c" translate="yes" xml:space="preserve">
          <source>Whether to include &lt;code&gt;data.index&lt;/code&gt; in the schema.</source>
          <target state="translated">스키마에 &lt;code&gt;data.index&lt;/code&gt; 를 포함할지 여부</target>
        </trans-unit>
        <trans-unit id="584a2b973d40b4845d9c70764d17466af95b1462" translate="yes" xml:space="preserve">
          <source>Whether to include a field</source>
          <target state="translated">필드 포함 여부</target>
        </trans-unit>
        <trans-unit id="69f2dfb80e7c583b92e52aa432703a31f552336a" translate="yes" xml:space="preserve">
          <source>Whether to include a field &lt;code&gt;pandas_version&lt;/code&gt; with the version of pandas that generated the schema.</source>
          <target state="translated">스키마를 생성 한 pandas 버전에 &lt;code&gt;pandas_version&lt;/code&gt; 필드를 포함할지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="61e7cad09b74d9523bae74a46fed56525838019f" translate="yes" xml:space="preserve">
          <source>Whether to include the index values in the JSON string. Not including the index (&lt;code&gt;index=False&lt;/code&gt;) is only supported when orient is &amp;lsquo;split&amp;rsquo; or &amp;lsquo;table&amp;rsquo;.</source>
          <target state="translated">JSON 문자열에 색인 값을 포함할지 여부 orient가 'split'또는 'table'인 경우에만 색인 ( &lt;code&gt;index=False&lt;/code&gt; )을 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="091d45b0e0eeb15f8f3de813aed2863b28446190" translate="yes" xml:space="preserve">
          <source>Whether to interpret</source>
          <target state="translated">해석 여부</target>
        </trans-unit>
        <trans-unit id="829ccda7ff3ddf504640fb7bb1de63f5f742ff2e" translate="yes" xml:space="preserve">
          <source>Whether to interpret &lt;code&gt;to_replace&lt;/code&gt; and/or &lt;code&gt;value&lt;/code&gt; as regular expressions. If this is &lt;code&gt;True&lt;/code&gt; then &lt;code&gt;to_replace&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; be a string. Alternatively, this could be a regular expression or a list, dict, or array of regular expressions in which case &lt;code&gt;to_replace&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;to_replace&lt;/code&gt; 및 / 또는 &lt;code&gt;value&lt;/code&gt; 을 정규식 으로 해석할지 여부 입니다. 이것이 &lt;code&gt;True&lt;/code&gt; 이면 &lt;code&gt;to_replace&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; 문자열 &lt;em&gt;이어야&lt;/em&gt; 합니다. 또는 정규 표현식이거나 정규 표현식의 목록, dict 또는 배열 일 수 있으며,이 경우 &lt;code&gt;to_replace&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="059b670232ce9b96a4755e583fd1201d3892dfc6" translate="yes" xml:space="preserve">
          <source>Whether to parallelize reading using multiple threads.</source>
          <target state="translated">여러 스레드를 사용하여 읽기를 병렬화할지 여부</target>
        </trans-unit>
        <trans-unit id="9b1fc76deaa2fbdff899e0942b3064c1aaaff6ea" translate="yes" xml:space="preserve">
          <source>Whether to perform the operation in place on the data.</source>
          <target state="translated">데이터에서 작업을 수행할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="60c8e4b1fe4c082bfa2236fc1086c5b8274732d6" translate="yes" xml:space="preserve">
          <source>Whether to plot on the secondary y-axis if a list/tuple, which columns to plot on secondary y-axis.</source>
          <target state="translated">목록 / 튜플 인 경우 보조 y 축에 플로팅할지 여부, 보조 y 축에 플로팅 할 열입니다.</target>
        </trans-unit>
        <trans-unit id="e70de5a36e83d3eb8fa9cabc674a98ae76824d04" translate="yes" xml:space="preserve">
          <source>Whether to print column labels, default True.</source>
          <target state="translated">열 레이블을 인쇄할지 여부, 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="d4043c34d833aebb482be8b86bfcf54b13f6b518" translate="yes" xml:space="preserve">
          <source>Whether to print index (row) labels.</source>
          <target state="translated">색인 (행) 레이블을 인쇄할지 여부.</target>
        </trans-unit>
        <trans-unit id="e473e8cd557f78fb89bbf3cfc399837415bffeba" translate="yes" xml:space="preserve">
          <source>Whether to print out dimensions at the end of DataFrame repr. If &amp;lsquo;truncate&amp;rsquo; is specified, only print out the dimensions if the frame is truncated (e.g. not display all rows and/or columns)</source>
          <target state="translated">DataFrame repr의 끝에 치수를 인쇄할지 여부입니다. 'truncate'가 지정된 경우 프레임이 잘린 경우에만 치수를 인쇄합니다 (예 : 모든 행 및 / 또는 열을 표시하지 않음).</target>
        </trans-unit>
        <trans-unit id="defde4911d781feb3a03a8e3ff5f7b2e2330ecf2" translate="yes" xml:space="preserve">
          <source>Whether to print out dimensions at the end of DataFrame repr. If &amp;lsquo;truncate&amp;rsquo; is specified, only print out the dimensions if the frame is truncated (e.g. not display all rows and/or columns) [default: truncate] [currently: truncate]</source>
          <target state="translated">DataFrame repr의 끝에 치수를 인쇄할지 여부입니다. '자르기'가 지정된 경우 프레임이 잘린 경우에만 치수를 인쇄합니다 (예 : 모든 행 및 / 또는 열을 표시하지 않음) [기본값 : 자르기] [현재 : 자르기]</target>
        </trans-unit>
        <trans-unit id="36daa98a5e49b7b118bab4ec98545d2b0af61155" translate="yes" xml:space="preserve">
          <source>Whether to print out the full DataFrame repr for wide DataFrames across multiple lines,</source>
          <target state="translated">여러 줄에 걸쳐 넓은 DataFrames에 대한 전체 DataFrame repr을 인쇄할지 여부,</target>
        </trans-unit>
        <trans-unit id="b7bd9a145336d6da3be1171064740410db72c040" translate="yes" xml:space="preserve">
          <source>Whether to print out the full DataFrame repr for wide DataFrames across multiple lines, &lt;code&gt;max_columns&lt;/code&gt; is still respected, but the output will wrap-around across multiple &amp;ldquo;pages&amp;rdquo; if its width exceeds &lt;code&gt;display.width&lt;/code&gt;.</source>
          <target state="translated">여러 줄에 걸쳐 넓은 DataFrames에 대한 전체 DataFrame repr을 인쇄할지 여부에 관계없이 &lt;code&gt;max_columns&lt;/code&gt; 는 여전히 유지되지만 너비가 &lt;code&gt;display.width&lt;/code&gt; 를 초과하면 출력이 여러 &quot;페이지&quot;에 걸쳐 줄 바꿈됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac3786a830e519e431f4d22b3deccbde853cb7e5" translate="yes" xml:space="preserve">
          <source>Whether to print the full summary. By default, the setting in &lt;code&gt;pandas.options.display.max_info_columns&lt;/code&gt; is followed.</source>
          <target state="translated">전체 요약을 인쇄할지 여부 기본적으로 &lt;code&gt;pandas.options.display.max_info_columns&lt;/code&gt; 의 설정 이 따릅니다.</target>
        </trans-unit>
        <trans-unit id="657e1c9b877510928b9223cc991f5e0030844c1f" translate="yes" xml:space="preserve">
          <source>Whether to produce a latex DataFrame representation for Jupyter frontends that support it.</source>
          <target state="translated">지원하는 Jupyter 프런트 엔드에 대한 라텍스 DataFrame 표현을 생성할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c21e9fa41831f0cc460ed4ee322428393dd958a8" translate="yes" xml:space="preserve">
          <source>Whether to produce a latex DataFrame representation for jupyter environments that support it. (default: False) [default: False] [currently: False]</source>
          <target state="translated">지원하는 jupyter 환경에 대한 라텍스 DataFrame 표현을 생성할지 여부입니다. (기본값 : False) [기본값 : False] [현재 : False]</target>
        </trans-unit>
        <trans-unit id="a0220ca4c13bb756d39c93dd4fe7f6d32c047dc2" translate="yes" xml:space="preserve">
          <source>Whether to publish a Table Schema representation for frontends that support it.</source>
          <target state="translated">지원하는 프런트 엔드에 대한 테이블 스키마 표현을 게시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="15f97300df2876a7dde9d91735cb45adf8b5a647" translate="yes" xml:space="preserve">
          <source>Whether to publish a Table Schema representation for frontends that support it. (default: False) [default: False] [currently: False]</source>
          <target state="translated">지원하는 프런트 엔드에 대한 테이블 스키마 표현을 게시할지 여부입니다. (기본값 : False) [기본값 : False] [현재 : False]</target>
        </trans-unit>
        <trans-unit id="0236ba34b4b6059dd2e5bd9b24bdb5a57727eb35" translate="yes" xml:space="preserve">
          <source>Whether to register converters with matplotlib&amp;rsquo;s units registry for dates, times, datetimes, and Periods. Toggling to False will remove the converters, restoring any converters that pandas overwrote. [default: auto] [currently: auto]</source>
          <target state="translated">날짜, 시간, 날짜 시간 및 기간에 대해 matplotlib의 단위 레지스트리에 변환기를 등록할지 여부입니다. False로 전환하면 변환기가 제거되고 팬더가 덮어 쓴 변환기가 복원됩니다. [기본값 : 자동] [현재 : 자동]</target>
        </trans-unit>
        <trans-unit id="822960fd378361c92f866987bab14c6731788aad" translate="yes" xml:space="preserve">
          <source>Whether to reset output index to midnight</source>
          <target state="translated">출력 색인을 자정으로 재설정할지 여부</target>
        </trans-unit>
        <trans-unit id="47f46587bbc97bcc1408e64c36b5745d3fc71750" translate="yes" xml:space="preserve">
          <source>Whether to reset output index to midnight.</source>
          <target state="translated">출력 인덱스를 자정으로 재설정할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="463d414e3c929a36dadaf0dff7a3da1b86f42a26" translate="yes" xml:space="preserve">
          <source>Whether to return a copy of the original object or not.</source>
          <target state="translated">원본 객체의 사본을 반환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0d9ec3e7b77438b4723261e6a03fc44877ee790e" translate="yes" xml:space="preserve">
          <source>Whether to return a new %(klass)s instance.</source>
          <target state="translated">새 % (klass) 인스턴스를 반환할지 여부</target>
        </trans-unit>
        <trans-unit id="3334585f79a1e05bd5ead3050f09c79f6075fb92" translate="yes" xml:space="preserve">
          <source>Whether to return a new DataFrame instance.</source>
          <target state="translated">새 DataFrame 인스턴스를 반환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8d395e3bbd17854fbadd8ac7b179489b9e25ff57" translate="yes" xml:space="preserve">
          <source>Whether to return a new DataFrame. If True then value of copy is ignored.</source>
          <target state="translated">새 DataFrame을 반환할지 여부 True이면 복사 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8e2a75f244eeb458937d3418e33d612e1af7602a" translate="yes" xml:space="preserve">
          <source>Whether to return a new Series instance.</source>
          <target state="translated">새 Series 인스턴스를 반환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f70307c4c16aeae2c304f636a8a48db0df778b4d" translate="yes" xml:space="preserve">
          <source>Whether to return a new Series. If True then value of copy is ignored.</source>
          <target state="translated">새 시리즈를 반환할지 여부 True이면 복사 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c40f05d086533bc3f61b990c30d1eee76d14d5f1" translate="yes" xml:space="preserve">
          <source>Whether to return the (bins, labels) or not. Can be useful if bins is given as a scalar.</source>
          <target state="translated">(바인딩, 라벨)을 반환할지 여부. 빈이 스칼라로 제공되는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9a2325de6aaa3cd0b4ed39a825eff6977fff94d" translate="yes" xml:space="preserve">
          <source>Whether to return the bins or not. Useful when bins is provided as a scalar.</source>
          <target state="translated">출력 함 반환 여부. 구간이 스칼라로 제공 될 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5f6ec8c7097b0e808006d61b5467a63c05b98e29" translate="yes" xml:space="preserve">
          <source>Whether to round the result of a DateOffset addition down to the previous midnight.</source>
          <target state="translated">DateOffset 추가 결과를 이전 자정으로 내림할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f676621a7d6e94a1edcabb96ea81c3545d433e4d" translate="yes" xml:space="preserve">
          <source>Whether to search for prior, subsequent, or closest matches.</source>
          <target state="translated">이전, 이후 또는 가장 일치하는 항목을 검색할지 여부</target>
        </trans-unit>
        <trans-unit id="9a7f3ce1d34190884bad83912e5d23932d9f3944" translate="yes" xml:space="preserve">
          <source>Whether to show axis grid lines</source>
          <target state="translated">축 그리드 선 표시 여부</target>
        </trans-unit>
        <trans-unit id="0e570581777bb9a490c51ad5b32749939fac5299" translate="yes" xml:space="preserve">
          <source>Whether to show axis grid lines.</source>
          <target state="translated">축 그리드 선을 표시할지 여부</target>
        </trans-unit>
        <trans-unit id="db6a9f9db72f57fcd6883f16d0ca558c1a439605" translate="yes" xml:space="preserve">
          <source>Whether to show the legend.</source>
          <target state="translated">범례를 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c61d81696a16a9ed7eb9fded773a5fb7d3febb15" translate="yes" xml:space="preserve">
          <source>Whether to show the non-null counts. By default, this is shown only if the DataFrame is smaller than &lt;code&gt;pandas.options.display.max_info_rows&lt;/code&gt; and &lt;code&gt;pandas.options.display.max_info_columns&lt;/code&gt;. A value of True always shows the counts, and False never shows the counts.</source>
          <target state="translated">널이 아닌 수를 표시할지 여부입니다. 기본적으로 이는 DataFrame이 &lt;code&gt;pandas.options.display.max_info_rows&lt;/code&gt; 및 &lt;code&gt;pandas.options.display.max_info_columns&lt;/code&gt; 보다 작은 경우에만 표시됩니다 . True 값은 항상 개수를 표시하고 False 값은 개수를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb1aecfea707c5a6a0e267acf6cea372942182ba" translate="yes" xml:space="preserve">
          <source>Whether to show the non-null counts. By default, this is shown only if the frame is smaller than &lt;code&gt;pandas.options.display.max_info_rows&lt;/code&gt; and &lt;code&gt;pandas.options.display.max_info_columns&lt;/code&gt;. A value of True always shows the counts, and False never shows the counts.</source>
          <target state="translated">널이 아닌 수를 표시할지 여부. 기본적으로 프레임이 &lt;code&gt;pandas.options.display.max_info_rows&lt;/code&gt; 및 &lt;code&gt;pandas.options.display.max_info_columns&lt;/code&gt; 보다 작은 경우에만 표시됩니다 . True 값은 항상 카운트를 표시하고 False는 카운트를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bc899ddeb69b2996c5b038d8bd74fddeb7c33e0" translate="yes" xml:space="preserve">
          <source>Whether to simulate interactive mode for purposes of testing [default: False] [currently: False]</source>
          <target state="translated">테스트 목적으로 대화 형 모드를 시뮬레이션할지 여부 [기본값 : False] [현재 : False]</target>
        </trans-unit>
        <trans-unit id="54ed404410db5a52143355473b57f215c5cc7456" translate="yes" xml:space="preserve">
          <source>Whether to simulate interactive mode for purposes of testing.</source>
          <target state="translated">테스트 목적으로 대화 형 모드를 시뮬레이션할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="9423858ca0259300004040194ab4aaa0323abeb7" translate="yes" xml:space="preserve">
          <source>Whether to sort the resulting Index.</source>
          <target state="translated">결과 색인을 정렬할지 여부</target>
        </trans-unit>
        <trans-unit id="b32f8913fc7fd86d449faf14482864d16c081852" translate="yes" xml:space="preserve">
          <source>Whether to sort the resulting index.</source>
          <target state="translated">결과 색인을 정렬할지 여부</target>
        </trans-unit>
        <trans-unit id="a821e3ed2db995ff5f5e85efc8b38f97ac4e8779" translate="yes" xml:space="preserve">
          <source>Whether to sort the resulting index. By default, the values are attempted to be sorted, but any TypeError from incomparable elements is caught by pandas.</source>
          <target state="translated">결과 색인을 정렬할지 여부 기본적으로 값을 정렬하려고 시도하지만 비교할 수없는 요소의 TypeError는 팬더에 의해 잡 힙니다.</target>
        </trans-unit>
        <trans-unit id="33c048465728cbbfc61cbcdc5f64ee1e108195d5" translate="yes" xml:space="preserve">
          <source>Whether to sort the resulting labels.</source>
          <target state="translated">결과 레이블을 정렬할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8d4c18b1f2e5357a2ebaa3fd3b265a74ba4776cc" translate="yes" xml:space="preserve">
          <source>Whether to treat datetime dtypes as numeric. This affects statistics calculated for the column. For DataFrame input, this also controls whether datetime columns are included by default.</source>
          <target state="translated">datetime dtype을 숫자로 처리할지 여부입니다. 이는 열에 대해 계산 된 통계에 영향을줍니다. DataFrame 입력의 경우 이는 datetime 열이 기본적으로 포함되는지 여부도 제어합니다.</target>
        </trans-unit>
        <trans-unit id="8e0820bb28dd78148fc818c5e66e628f442bd55a" translate="yes" xml:space="preserve">
          <source>Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]</source>
          <target state="translated">유니 코드 동아시아 너비를 사용하여 표시 텍스트 너비를 계산할지 여부입니다. 이 기능을 활성화하면 성능에 영향을 미칠 수 있습니다 (기본값 : False) [기본값 : False] [현재 : False]</target>
        </trans-unit>
        <trans-unit id="98ada401a557fe46a5016af2e53df79b0635d645" translate="yes" xml:space="preserve">
          <source>Whether to use the start or end of the time period being converted.</source>
          <target state="translated">변환되는 기간의 시작 또는 끝을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="dde550efd70425ac91abbaca6d2f05764c9841e7" translate="yes" xml:space="preserve">
          <source>Whether to use true division, like in Python &amp;gt;= 3</source>
          <target state="translated">Python&amp;gt; = 3과 같이 진정한 나눗셈을 사용할지 여부</target>
        </trans-unit>
        <trans-unit id="f13ba422da1f5e9483fda1e900978f1315e4d9c4" translate="yes" xml:space="preserve">
          <source>Whether to use true division, like in Python &amp;gt;= 3.</source>
          <target state="translated">Python&amp;gt; = 3과 같이 진정한 나누기를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="409e30ae70ff87f67bcc9017ec1d6e35df75f10c" translate="yes" xml:space="preserve">
          <source>Whether x-axes will be shared among subplots</source>
          <target state="translated">하위 플롯간에 x 축을 공유할지 여부</target>
        </trans-unit>
        <trans-unit id="00340f2950d730b40c81c266b2a2cbc081390eda" translate="yes" xml:space="preserve">
          <source>Whether x-axes will be shared among subplots.</source>
          <target state="translated">x 축을 서브 플롯간에 공유할지 여부.</target>
        </trans-unit>
        <trans-unit id="0b92a72844c2f58921d71d168ff98abebab9ad7d" translate="yes" xml:space="preserve">
          <source>Whether y-axes will be shared among subplots</source>
          <target state="translated">서브 플로트간에 y 축을 공유할지 여부</target>
        </trans-unit>
        <trans-unit id="0e38e296c5ece407976f81c0ff17dd2db69414ee" translate="yes" xml:space="preserve">
          <source>Whether y-axes will be shared among subplots.</source>
          <target state="translated">Y 축을 서브 플롯간에 공유할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2275262cc00109df5f43760e7979e9e352672f93" translate="yes" xml:space="preserve">
          <source>Whether, if possible, conversion can be done to floating extension types. If</source>
          <target state="translated">가능한 경우 부동 확장 유형으로 변환 할 수 있는지 여부. 만약</target>
        </trans-unit>
        <trans-unit id="af020f329bea01ddcf82b6e15f368859cab5cf5b" translate="yes" xml:space="preserve">
          <source>Whether, if possible, conversion can be done to integer extension types.</source>
          <target state="translated">가능한 경우 정수 확장 유형으로 변환 할 수 있는지 여부.</target>
        </trans-unit>
        <trans-unit id="1b71be8eafa38c83c063aed738f0acb077fe9637" translate="yes" xml:space="preserve">
          <source>Which axis to use for up- or down-sampling. For</source>
          <target state="translated">업 샘플링 또는 다운 샘플링에 사용할 축입니다. 에 대한</target>
        </trans-unit>
        <trans-unit id="351a93741537e3b00c326e85d6bc8b864d324e73" translate="yes" xml:space="preserve">
          <source>Which axis to use for up- or down-sampling. For &lt;code&gt;Series&lt;/code&gt; this will default to 0, i.e. along the rows. Must be &lt;code&gt;DatetimeIndex&lt;/code&gt;, &lt;code&gt;TimedeltaIndex&lt;/code&gt; or &lt;code&gt;PeriodIndex&lt;/code&gt;.</source>
          <target state="translated">업 샘플링 또는 다운 샘플링에 사용할 축 들어 &lt;code&gt;Series&lt;/code&gt; 이것은 즉, 행에 따라 0으로 기본 설정됩니다. &lt;code&gt;DatetimeIndex&lt;/code&gt; , &lt;code&gt;TimedeltaIndex&lt;/code&gt; 또는 &lt;code&gt;PeriodIndex&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e14dfe26bdfe6299d3617c19bf5fc4c9ac5b873c" translate="yes" xml:space="preserve">
          <source>Which bin edge label to label bucket with. The default is &amp;lsquo;left&amp;rsquo; for all frequency offsets except for &amp;lsquo;M&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;Q&amp;rsquo;, &amp;lsquo;BM&amp;rsquo;, &amp;lsquo;BA&amp;rsquo;, &amp;lsquo;BQ&amp;rsquo;, and &amp;lsquo;W&amp;rsquo; which all have a default of &amp;lsquo;right&amp;rsquo;.</source>
          <target state="translated">버킷에 레이블을 지정할 빈 가장자리 레이블입니다. 기본값은 '오른쪽'인 'M', 'A', 'Q', 'BM', 'BA', 'BQ'및 'W'를 제외한 모든 주파수 오프셋에 대한 기본값은 '왼쪽'입니다.</target>
        </trans-unit>
        <trans-unit id="93265f02ace29b4637e323da25c38f7ad2a8b220" translate="yes" xml:space="preserve">
          <source>Which can be used as a boolean filter to drop duplicate rows.</source>
          <target state="translated">중복 행을 삭제하는 부울 필터로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3152a90cdf476aadde0e61e3e4ef5ddafc042fb8" translate="yes" xml:space="preserve">
          <source>Which is an integer/float number.</source>
          <target state="translated">정수 / 부동 수입니다.</target>
        </trans-unit>
        <trans-unit id="9ab9404f8905635ac93c012ec29d2d386dac81b4" translate="yes" xml:space="preserve">
          <source>Which side of bin interval is closed. The default is &amp;lsquo;left&amp;rsquo; for all frequency offsets except for &amp;lsquo;M&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;Q&amp;rsquo;, &amp;lsquo;BM&amp;rsquo;, &amp;lsquo;BA&amp;rsquo;, &amp;lsquo;BQ&amp;rsquo;, and &amp;lsquo;W&amp;rsquo; which all have a default of &amp;lsquo;right&amp;rsquo;.</source>
          <target state="translated">빈 간격의 어느 쪽이 닫혀 있습니까? 기본값은 '오른쪽'인 'M', 'A', 'Q', 'BM', 'BA', 'BQ'및 'W'를 제외한 모든 주파수 오프셋에 대한 기본값은 '왼쪽'입니다.</target>
        </trans-unit>
        <trans-unit id="1a2dc0fcb2d990edb0299a920c76feaa41d98a83" translate="yes" xml:space="preserve">
          <source>Which will create a MultiIndex:</source>
          <target state="translated">MultiIndex를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="b09f9a9b5958e071ea997eaba4ab19f5cf54b087" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../reference/api/pandas.dataframe.pivot#pandas.DataFrame.pivot&quot;&gt;&lt;code&gt;pivot()&lt;/code&gt;&lt;/a&gt; provides general purpose pivoting with various data types (strings, numerics, etc.), pandas also provides &lt;a href=&quot;../reference/api/pandas.pivot_table#pandas.pivot_table&quot;&gt;&lt;code&gt;pivot_table()&lt;/code&gt;&lt;/a&gt; for pivoting with aggregation of numeric data.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.dataframe.pivot#pandas.DataFrame.pivot&quot;&gt; &lt;code&gt;pivot()&lt;/code&gt; &lt;/a&gt; 는 다양한 데이터 유형 (문자열, 숫자 등)으로 범용 피벗을 제공 하지만 pandas는 숫자 데이터 집계로 피벗하기 위해 &lt;a href=&quot;../reference/api/pandas.pivot_table#pandas.pivot_table&quot;&gt; &lt;code&gt;pivot_table()&lt;/code&gt; &lt;/a&gt; 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f9ff63a50e922bef01c293633c11bc3472ada59f" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt; reads delimited data, the &lt;a href=&quot;../reference/api/pandas.read_fwf#pandas.read_fwf&quot;&gt;&lt;code&gt;read_fwf()&lt;/code&gt;&lt;/a&gt; function works with data files that have known and fixed column widths. The function parameters to &lt;code&gt;read_fwf&lt;/code&gt; are largely the same as &lt;code&gt;read_csv&lt;/code&gt; with two extra parameters, and a different usage of the &lt;code&gt;delimiter&lt;/code&gt; parameter:</source>
          <target state="translated">반면 &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;read_csv()&lt;/code&gt; &lt;/a&gt; 데이터의 읽기 구분 &lt;a href=&quot;../reference/api/pandas.read_fwf#pandas.read_fwf&quot;&gt; &lt;code&gt;read_fwf()&lt;/code&gt; &lt;/a&gt; 공지 된 고정 열 폭 한 데이터 파일과 기능이 작동한다. &lt;code&gt;read_fwf&lt;/code&gt; 에 대한 함수 매개 변수 는 두 개의 추가 매개 변수가있는 &lt;code&gt;read_csv&lt;/code&gt; 와 대체로 동일 하며 &lt;code&gt;delimiter&lt;/code&gt; 매개 변수의 사용법이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="406b790245ac7245ba8f7e04e8b262a4910d4241" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;Index&lt;/code&gt; objects are copied when &lt;code&gt;deep=True&lt;/code&gt;, the underlying numpy array is not copied for performance reasons. Since &lt;code&gt;Index&lt;/code&gt; is immutable, the underlying data can be safely shared and a copy is not needed.</source>
          <target state="translated">&lt;code&gt;deep=True&lt;/code&gt; 일 때 &lt;code&gt;Index&lt;/code&gt; 객체는 복사 되지만 성능상의 이유로 기본 numpy 배열은 복사되지 않습니다. 이후 &lt;code&gt;Index&lt;/code&gt; 불변이며, 기본 데이터를 안전하게 공유 할 수 있으며, 사본이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6650e6308a36a9b15d3ed97470102fe3537e1a6d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;apply&lt;/code&gt; is a very flexible method, its downside is that using it can be quite a bit slower than using more specific methods like &lt;code&gt;agg&lt;/code&gt; or &lt;code&gt;transform&lt;/code&gt;. Pandas offers a wide range of method that will be much faster than using &lt;code&gt;apply&lt;/code&gt; for their specific purposes, so try to use them before reaching for &lt;code&gt;apply&lt;/code&gt;.</source>
          <target state="translated">동안 &lt;code&gt;apply&lt;/code&gt; 매우 유연한 방법, 그 단점을 사용하는 방법 등을 구체적으로 사용하는 것보다 상당히 느릴 수 있다는 것이다 &lt;code&gt;agg&lt;/code&gt; 또는 &lt;code&gt;transform&lt;/code&gt; . Pandas는 특정 목적으로 &lt;code&gt;apply&lt;/code&gt; 를 사용하는 것보다 훨씬 빠른 방법을 제공 하므로 &lt;code&gt;apply&lt;/code&gt; 에 도달하기 전에 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5bbe2c17408bb49c828324c1f98172b94a840ce" translate="yes" xml:space="preserve">
          <source>While Series is ndarray-like, if you need an &lt;em&gt;actual&lt;/em&gt; ndarray, then use &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;Series.to_numpy()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Series는 ndarray와 비슷하지만 &lt;em&gt;실제&lt;/em&gt; ndarray 가 필요한 경우 &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;Series.to_numpy()&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1fa049851ad995498b9e8d69afc4d25a42e4e8e" translate="yes" xml:space="preserve">
          <source>While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a &lt;code&gt;dayfirst&lt;/code&gt; keyword is provided:</source>
          <target state="translated">미국 날짜 형식은 MM / DD / YYYY 인 경향이 있지만 많은 국제 형식은 대신 DD / MM / YYYY를 사용합니다. 편의를 위해 &lt;code&gt;dayfirst&lt;/code&gt; 키워드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="320526a6cf95fe7ae1d592828eedc71cd7770e18" translate="yes" xml:space="preserve">
          <source>While float dtypes are unchanged.</source>
          <target state="translated">float dtypes는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8951e325451a6dfb7f3a44fd79fe07ed7a1f43c5" translate="yes" xml:space="preserve">
          <source>While not especially efficient (since a new object must be created), you can append a single row to a &lt;code&gt;DataFrame&lt;/code&gt; by passing a &lt;code&gt;Series&lt;/code&gt; or dict to &lt;code&gt;append&lt;/code&gt;, which returns a new &lt;code&gt;DataFrame&lt;/code&gt; as above.</source>
          <target state="translated">특히 효율적이지 않지만 (새 객체를 만들어야하므로) &lt;code&gt;Series&lt;/code&gt; 또는 dict to &lt;code&gt;append&lt;/code&gt; 를 전달하여 단일 행을 &lt;code&gt;DataFrame&lt;/code&gt; 에 추가 하면 위와 같이 새 &lt;code&gt;DataFrame&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="489fd26b5954e3ab4d81431e3f5cdb131eb1e98f" translate="yes" xml:space="preserve">
          <source>While pandas does not force you to have a sorted date index, some of these methods may have unexpected or incorrect behavior if the dates are unsorted.</source>
          <target state="translated">Pandas는 날짜 인덱스를 정렬하도록 강제하지 않지만 날짜가 정렬되지 않은 경우 이러한 메서드 중 일부는 예상치 못한 또는 잘못된 동작을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84a9e79a81ff4f2e7be900e69d400bd8f96ac034" translate="yes" xml:space="preserve">
          <source>While pandas provides a rich set of methods, containers, and data types, your needs may not be fully satisfied. Pandas offers a few options for extending pandas.</source>
          <target state="translated">팬더는 다양한 메소드, 컨테이너 및 데이터 유형을 제공하지만 사용자의 요구가 완전히 충족되지 않을 수 있습니다. 팬더는 팬더 확장을위한 몇 가지 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a22d7485615c3482c2959b4b968a5ef3d5984e98" translate="yes" xml:space="preserve">
          <source>While pandas supports storing arrays of integer and boolean type, these types are not capable of storing missing data. Until we can switch to using a native NA type in NumPy, we&amp;rsquo;ve established some &amp;ldquo;casting rules&amp;rdquo;. When a reindexing operation introduces missing data, the Series will be cast according to the rules introduced in the table below.</source>
          <target state="translated">Pandas는 정수 및 부울 유형의 배열 저장을 지원하지만 이러한 유형은 누락 된 데이터를 저장할 수 없습니다. NumPy에서 네이티브 NA 유형을 사용하도록 전환 할 수있을 때까지 몇 가지 &quot;캐스팅 규칙&quot;을 설정했습니다. 재 인덱싱 작업으로 인해 누락 된 데이터가 발생하면 시리즈는 아래 표에 소개 된 규칙에 따라 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="12d47f8569701c8172c13038db4e088dcba1ae2e" translate="yes" xml:space="preserve">
          <source>While standard Python / Numpy expressions for selecting and setting are intuitive and come in handy for interactive work, for production code, we recommend the optimized pandas data access methods, &lt;code&gt;.at&lt;/code&gt;, &lt;code&gt;.iat&lt;/code&gt;, &lt;code&gt;.loc&lt;/code&gt; and &lt;code&gt;.iloc&lt;/code&gt;.</source>
          <target state="translated">선택 및 설정을위한 표준 Python / Numpy 표현식은 직관적이고 대화 형 작업에 유용하지만 프로덕션 코드의 경우 최적화 된 pandas 데이터 액세스 방법 인 &lt;code&gt;.at&lt;/code&gt; , &lt;code&gt;.iat&lt;/code&gt; , &lt;code&gt;.loc&lt;/code&gt; 및 &lt;code&gt;.iloc&lt;/code&gt; 을 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="4f4f0535fe84b7df413259e8e5f2078595bb140b" translate="yes" xml:space="preserve">
          <source>While the</source>
          <target state="translated">동안</target>
        </trans-unit>
        <trans-unit id="f434314ddb865cdc18e6752e27c11123cefa549c" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;slice_shift&lt;/code&gt; is faster than &lt;code&gt;shift&lt;/code&gt;, you may pay for it later during alignment.</source>
          <target state="translated">그동안 &lt;code&gt;slice_shift&lt;/code&gt; 이 빠르게보다 &lt;code&gt;shift&lt;/code&gt; , 나중에 정렬하는 동안 그것을 지불 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16cf6ccbd946735fb6200ccf89320e4fc83de333" translate="yes" xml:space="preserve">
          <source>While this may seem like a heavy trade-off, I have found very few cases where this is an issue in practice i.e. storing values greater than 2**53. Some explanation for the motivation is in the next section.</source>
          <target state="translated">이것은 큰 절충안처럼 보일 수 있지만 실제로 2 ** 53보다 큰 값을 저장하는 것과 같이 이것이 문제가되는 경우를 거의 발견하지 못했습니다. 동기에 대한 설명은 다음 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a0ce02454ffd2a3929921d53770df8a64c7602b" translate="yes" xml:space="preserve">
          <source>Why does assignment fail when using chained indexing?</source>
          <target state="translated">체인 인덱싱을 사용할 때 할당이 실패하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e77a6501b0d679dcb0cdc5dd1b078e7f9afc86e5" translate="yes" xml:space="preserve">
          <source>Why more than one data structure?</source>
          <target state="translated">왜 하나 이상의 데이터 구조입니까?</target>
        </trans-unit>
        <trans-unit id="0b983fa5617d58a7916aaa1f5ec356aa3b21fee1" translate="yes" xml:space="preserve">
          <source>Why not make NumPy like R?</source>
          <target state="translated">NumPy를 R처럼 만들지 않겠습니까?</target>
        </trans-unit>
        <trans-unit id="ece162266b40b39d17f56a4e6fb67a1cca4822d7" translate="yes" xml:space="preserve">
          <source>Wide DataFrames will be printed across multiple rows by default:</source>
          <target state="translated">Wide DataFrame은 기본적으로 여러 행에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="94fd44cb58ca1992a5db505e73d6e603a16d0efb" translate="yes" xml:space="preserve">
          <source>Wide panel to long format.</source>
          <target state="translated">와이드 패널에서 긴 형식으로.</target>
        </trans-unit>
        <trans-unit id="1c94b23591a4f27d60ceb9d65106d89f9f9151b3" translate="yes" xml:space="preserve">
          <source>Wide panel to long format. Less flexible but more user-friendly than melt.</source>
          <target state="translated">와이드 패널에서 긴 형식으로. 융통성보다는 유연성이 떨어지지 만 사용자에게 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="e70b498abefde286367d2d580a2454dd0993a292" translate="yes" xml:space="preserve">
          <source>Width of the display in characters. In case Python/IPython is running in a terminal this can be set to None and pandas will correctly auto-detect the width. Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to correctly detect the width.</source>
          <target state="translated">문자로 표시되는 너비입니다. Python / IPython이 터미널에서 실행중인 경우 None으로 설정하면 pandas가 너비를 올바르게 자동 감지합니다. IPython 노트북, IPython qtconsole 또는 IDLE은 터미널에서 실행되지 않으므로 너비를 올바르게 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b5785909f522cf82d4eca8280b2dadbe34795cd1" translate="yes" xml:space="preserve">
          <source>Width of the display in characters. In case python/IPython is running in a terminal this can be set to None and pandas will correctly auto-detect the width. Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to correctly detect the width. [default: 80] [currently: 80]</source>
          <target state="translated">문자로 표시되는 너비입니다. python / IPython이 터미널에서 실행중인 경우 None으로 설정하면 pandas가 너비를 올바르게 자동 감지합니다. IPython 노트북, IPython qtconsole 또는 IDLE은 터미널에서 실행되지 않으므로 너비를 올바르게 감지 할 수 없습니다. [기본값 : 80] [현재 : 80]</target>
        </trans-unit>
        <trans-unit id="411642ffcf8cc3e213979fd3c846c900cae28397" translate="yes" xml:space="preserve">
          <source>Width to wrap a line in characters.</source>
          <target state="translated">문자를 줄 바꿈하는 너비입니다.</target>
        </trans-unit>
        <trans-unit id="dbe740051d15e77cb5dfa2c8f7ae30bd51564eeb" translate="yes" xml:space="preserve">
          <source>Will be used for display in, e.g. &lt;code&gt;Series.dtype&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Series.dtype&lt;/code&gt; 과 같은 디스플레이에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="0a02911de9ac21d1fd885285092cc1a89b83f6bd" translate="yes" xml:space="preserve">
          <source>Window and resample operations</source>
          <target state="translated">윈도우 및 리샘플링 작업</target>
        </trans-unit>
        <trans-unit id="40988d0e192219e8e7d31b9f57fe7d9b37facdfd" translate="yes" xml:space="preserve">
          <source>Window indexer</source>
          <target state="translated">창 인덱서</target>
        </trans-unit>
        <trans-unit id="3727d7735dfdd39ce5a0dda33cc281ab814c1033" translate="yes" xml:space="preserve">
          <source>Windowing Operations</source>
          <target state="translated">윈도우 작업</target>
        </trans-unit>
        <trans-unit id="2059fa57b599fba9ff4c3dc650e698e20c59171d" translate="yes" xml:space="preserve">
          <source>Windowing functions</source>
          <target state="translated">윈도우 기능</target>
        </trans-unit>
        <trans-unit id="6850b7edb8639ed9738948852b5ff21fef6d7dc0" translate="yes" xml:space="preserve">
          <source>Windowing operations currently only support numeric data (integer and float) and will always return &lt;code&gt;float64&lt;/code&gt; values.</source>
          <target state="translated">윈도우 작업은 현재 숫자 데이터 (정수 및 부동 소수점) 만 지원하며 항상 &lt;code&gt;float64&lt;/code&gt; 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4d3c8daa3ebadd6963d2332eb9a3e18118a4e41c" translate="yes" xml:space="preserve">
          <source>Windows : none</source>
          <target state="translated">윈도우 : 없음</target>
        </trans-unit>
        <trans-unit id="09e62fb3d3d6dc636d99be2830e422ff68860e91" translate="yes" xml:space="preserve">
          <source>Windows does not support the &lt;code&gt;xargs&lt;/code&gt; command (unless installed for example via the &lt;a href=&quot;http://www.mingw.org/&quot;&gt;MinGW&lt;/a&gt; toolchain), but one can imitate the behaviour as follows:</source>
          <target state="translated">Windows는 &lt;code&gt;xargs&lt;/code&gt; 명령을 지원하지 않지만 (예 : &lt;a href=&quot;http://www.mingw.org/&quot;&gt;MinGW&lt;/a&gt; 툴체인을 통해 설치되지 않은 경우 ) 다음과 같이 동작을 모방 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="0c2c12d79ad4df987ae01aa982697d2ecdac140d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; you cannot use the &lt;code&gt;@&lt;/code&gt; prefix &lt;em&gt;at all&lt;/em&gt;, because it isn&amp;rsquo;t defined in that context. pandas will let you know this if you try to use &lt;code&gt;@&lt;/code&gt; in a top-level call to &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt;. For example,</source>
          <target state="translated">함께 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 당신은 사용할 수 없습니다 &lt;code&gt;@&lt;/code&gt; 의 접두사를 &lt;em&gt;전혀&lt;/em&gt; 이 그 문맥에 정의되어 있지 않기 때문에. &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 에 대한 최상위 호출에서 &lt;code&gt;@&lt;/code&gt; 를 사용하려고하면 pandas가이를 알려줍니다 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="1c6b8adcadb99b8a422f87b268a71c56db819006" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;pandas.read_csv()&lt;/code&gt;&lt;/a&gt;, you can specify &lt;code&gt;usecols&lt;/code&gt; to limit the columns read into memory. Not all file formats that can be read by pandas provide an option to read a subset of columns.</source>
          <target state="translated">함께 &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;pandas.read_csv()&lt;/code&gt; &lt;/a&gt; 을 지정할 수 있습니다 &lt;code&gt;usecols&lt;/code&gt; 을 메모리로 읽어 열을 제한 할 수 있습니다. Pandas에서 읽을 수있는 모든 파일 형식이 열의 하위 집합을 읽는 옵션을 제공하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="299947aa6e7eec9c70f912ac17089e95b6cdd17f" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchically-indexed data&lt;/a&gt;, it&amp;rsquo;s quite natural to group by one of the levels of the hierarchy.</source>
          <target state="translated">&lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;계층 적으로 인덱싱 된 데이터를&lt;/a&gt; 사용하면 계층 의 수준 중 하나를 기준으로 그룹화하는 것이 매우 자연 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="2666522b6fb0ba4fd910daeac02131c7fb5903de" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.agg()&lt;/code&gt; it is possible to easily create a custom describe function, similar to the built in &lt;a href=&quot;#basics-describe&quot;&gt;describe function&lt;/a&gt;.</source>
          <target state="translated">함께 &lt;code&gt;.agg()&lt;/code&gt; 쉽게 내장 유사한 맞춤 설명 함수 만들 수 &lt;a href=&quot;#basics-describe&quot;&gt;함수를 설명&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7591e74c17cf52feb4b291b5415b48fdd9166b77" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;dropna&lt;/code&gt; set to &lt;code&gt;False&lt;/code&gt; we can also see NaN index values.</source>
          <target state="translated">&lt;code&gt;dropna&lt;/code&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 설정 하면 NaN 인덱스 값도 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727721cfcca5c5980a635392fd3720995c9041a1" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;dtype='category'&lt;/code&gt;, the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the &lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt;&lt;code&gt;to_numeric()&lt;/code&gt;&lt;/a&gt; function, or as appropriate, another converter such as &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;to_datetime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">함께 &lt;code&gt;dtype='category'&lt;/code&gt; , 얻어지는 카테고리는 항상 캐릭터 (오브젝트 DTYPE)로서 해석 될 것이다. 범주가 숫자 인 경우 &lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt; &lt;code&gt;to_numeric()&lt;/code&gt; &lt;/a&gt; 함수를 사용하거나 적절한 경우 &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;to_datetime()&lt;/code&gt; &lt;/a&gt; 과 같은 다른 변환기를 사용하여 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3e5a58ba1474d074b0c855e98ceb62d98a6b4b6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_index&lt;/code&gt; set to True:</source>
          <target state="translated">와 &lt;code&gt;ignore_index&lt;/code&gt; 의 True로 설정 :</target>
        </trans-unit>
        <trans-unit id="e682613fb87e0cfba41cec598462761fc2a5c34c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inclusive&lt;/code&gt; set to &lt;code&gt;False&lt;/code&gt; boundary values are excluded:</source>
          <target state="translated">함께 &lt;code&gt;inclusive&lt;/code&gt; 으로 설정 &lt;code&gt;False&lt;/code&gt; 경계 값 제외 :</target>
        </trans-unit>
        <trans-unit id="d70ff7b3e9584094652332b3c586545145ccecc9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inplace=False&lt;/code&gt;, the new categorical is returned. With &lt;code&gt;inplace=True&lt;/code&gt;, there is no return value.</source>
          <target state="translated">으로 &lt;code&gt;inplace=False&lt;/code&gt; 새로운 범주가 반환됩니다. 로 &lt;code&gt;inplace=True&lt;/code&gt; , 더 리턴 값이 없다.</target>
        </trans-unit>
        <trans-unit id="f465bd5d6fc9f75666c775e3a994c5277d569d71" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;normalize&lt;/code&gt; set to &lt;code&gt;True&lt;/code&gt;, returns the relative frequency by dividing all values by the sum of values.</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정 하면 모든 값을 값의 합으로 나누어 상대 주파수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d03449a2d05c1719a27dd299dba590355941f9ff" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;slice&lt;/code&gt; objects.</source>
          <target state="translated">와 &lt;code&gt;slice&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="0d0fcec5ded27ccdeb3df3c586754f13483e0368" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;sort=True&lt;/code&gt;, the</source>
          <target state="translated">와 &lt;code&gt;sort=True&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="8a615de2f5e31705b273a5229ce30e65a9df020c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;sort=True&lt;/code&gt;, the &lt;code&gt;uniques&lt;/code&gt; will be sorted, and &lt;code&gt;labels&lt;/code&gt; will be shuffled so that the relationship is the maintained.</source>
          <target state="translated">로 &lt;code&gt;sort=True&lt;/code&gt; 의 &lt;code&gt;uniques&lt;/code&gt; 분류되며, &lt;code&gt;labels&lt;/code&gt; 의 관계가 유지되도록 단행 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb708201c30a58c25523a11436d7a28fa2fec92d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;verify_integrity&lt;/code&gt; set to True:</source>
          <target state="translated">와 &lt;code&gt;verify_integrity&lt;/code&gt; 의 True로 설정 :</target>
        </trans-unit>
        <trans-unit id="06bf3d77a57877710c2d9282f55ea70db9a7831c" translate="yes" xml:space="preserve">
          <source>With DataFrame, slicing inside of &lt;code&gt;[]&lt;/code&gt;&lt;strong&gt;slices the rows&lt;/strong&gt;. This is provided largely as a convenience since it is such a common operation.</source>
          <target state="translated">DataFrame을 사용하면 &lt;code&gt;[]&lt;/code&gt; 내부를 &lt;strong&gt;슬라이스하면 행이 슬라이스&lt;/strong&gt; 됩니다. 이것은 일반적인 작업이기 때문에 대부분 편의상 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c15e28aa8a76567795c188afa9b4449d0a92fd48" translate="yes" xml:space="preserve">
          <source>With NA/NaN filled.</source>
          <target state="translated">NA / NaN이 채워져 있습니다.</target>
        </trans-unit>
        <trans-unit id="2029d6b29e24e1026a739937239aab2e8df26feb" translate="yes" xml:space="preserve">
          <source>With Series, the syntax works exactly as with an ndarray, returning a slice of the values and the corresponding labels:</source>
          <target state="translated">Series를 사용하면 구문이 ndarray와 똑같이 작동하여 값의 조각과 해당 레이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="translated">와 함께</target>
        </trans-unit>
        <trans-unit id="bb99b16518db947d54df9a05abf535cf6b04a6c9" translate="yes" xml:space="preserve">
          <source>With a &amp;ldquo;stacked&amp;rdquo; &lt;code&gt;DataFrame&lt;/code&gt; or &lt;code&gt;Series&lt;/code&gt; (having a &lt;code&gt;MultiIndex&lt;/code&gt; as the &lt;code&gt;index&lt;/code&gt;), the inverse operation of &lt;code&gt;stack&lt;/code&gt; is &lt;code&gt;unstack&lt;/code&gt;, which by default unstacks the &lt;strong&gt;last level&lt;/strong&gt;:</source>
          <target state="translated">&quot;스택 된&quot; &lt;code&gt;DataFrame&lt;/code&gt; 또는 &lt;code&gt;Series&lt;/code&gt; ( &lt;code&gt;MultiIndex&lt;/code&gt; 를 &lt;code&gt;index&lt;/code&gt; )에서 &lt;code&gt;stack&lt;/code&gt; 의 역 연산 은 &lt;code&gt;unstack&lt;/code&gt; 이며 기본적으로 &lt;strong&gt;마지막 레벨을 &lt;/strong&gt;언 스택 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cce4a5edeafc2b61e5c8102db1026633d2beee7c" translate="yes" xml:space="preserve">
          <source>With a &amp;ldquo;stacked&amp;rdquo; DataFrame or Series (having a &lt;code&gt;MultiIndex&lt;/code&gt; as the &lt;code&gt;index&lt;/code&gt;), the inverse operation of &lt;a href=&quot;../reference/api/pandas.dataframe.stack#pandas.DataFrame.stack&quot;&gt;&lt;code&gt;stack()&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../reference/api/pandas.dataframe.unstack#pandas.DataFrame.unstack&quot;&gt;&lt;code&gt;unstack()&lt;/code&gt;&lt;/a&gt;, which by default unstacks the &lt;strong&gt;last level&lt;/strong&gt;:</source>
          <target state="translated">&quot;stacked&quot;DataFrame 또는 Series ( &lt;code&gt;index&lt;/code&gt; 로 &lt;code&gt;MultiIndex&lt;/code&gt; 가 있음 )를 사용하는 경우 &lt;a href=&quot;../reference/api/pandas.dataframe.stack#pandas.DataFrame.stack&quot;&gt; &lt;code&gt;stack()&lt;/code&gt; &lt;/a&gt; 의 역 연산 은 &lt;a href=&quot;../reference/api/pandas.dataframe.unstack#pandas.DataFrame.unstack&quot;&gt; &lt;code&gt;unstack()&lt;/code&gt; &lt;/a&gt; 이며 기본적으로 &lt;strong&gt;마지막 수준&lt;/strong&gt; 을 스택 해제합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5036c3e0f6df29704ffbb7dea300f0ccc4b3715" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;slice&lt;/code&gt; object.</source>
          <target state="translated">A를 &lt;code&gt;slice&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="cd3da76509f439069a308cb1ccc47ca321f81229" translate="yes" xml:space="preserve">
          <source>With a DataFrame, you can simultaneously reindex the index and columns:</source>
          <target state="translated">DataFrame을 사용하면 인덱스와 열을 동시에 다시 인덱싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6be40bf674dcabe97cdea6317c1d3bf73eff08" translate="yes" xml:space="preserve">
          <source>With a DataFrame:</source>
          <target state="translated">DataFrame 사용 :</target>
        </trans-unit>
        <trans-unit id="2d4c7416d6b7f49966873b83df87ef4f40cde0a0" translate="yes" xml:space="preserve">
          <source>With a MultiIndex</source>
          <target state="translated">MultiIndex 사용</target>
        </trans-unit>
        <trans-unit id="aee03e7a99a4d63fa88e911d144a4352efc42bc5" translate="yes" xml:space="preserve">
          <source>With a boolean array whose length matches the columns.</source>
          <target state="translated">길이가 열과 일치하는 부울 배열</target>
        </trans-unit>
        <trans-unit id="f237df6f9252a913e260ff3badedab7c154b4838" translate="yes" xml:space="preserve">
          <source>With a boolean mask the same length as the index.</source>
          <target state="translated">부울 마스크를 사용하면 색인과 길이가 같습니다.</target>
        </trans-unit>
        <trans-unit id="dda007944d63f089727eb70793373617b8767c3b" translate="yes" xml:space="preserve">
          <source>With a callable function that expects the Series or DataFrame.</source>
          <target state="translated">Series 또는 DataFrame을 기대하는 호출 가능한 함수</target>
        </trans-unit>
        <trans-unit id="8bed52cc7e4747c8bd937c60820a5759ef704acd" translate="yes" xml:space="preserve">
          <source>With a callable, useful in method chains. The</source>
          <target state="translated">호출 가능, 메서드 체인에서 유용합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="6e067c62142339d0717ea5379c5209d2b281445c" translate="yes" xml:space="preserve">
          <source>With a callable, useful in method chains. The &lt;code&gt;x&lt;/code&gt; passed to the &lt;code&gt;lambda&lt;/code&gt; is the DataFrame being sliced. This selects the rows whose index label even.</source>
          <target state="translated">메서드 체인에 유용한 호출 가능. &lt;code&gt;lambda&lt;/code&gt; 전달 된 &lt;code&gt;x&lt;/code&gt; 는 슬라이스되는 DataFrame입니다. 인덱스 레이블이 짝수 인 행을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e2de180789da94c610f8184e9c92bdb21f0dce87" translate="yes" xml:space="preserve">
          <source>With a dict, the number of places for specific columns can be specified with the column names as key and the number of decimal places as value</source>
          <target state="translated">dict를 사용하면 열 이름을 키로, 소수 자릿수를 값으로 사용하여 특정 열의 자리 수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="268f23e1685fb62dc26c58c66fd7c8a60b53482d" translate="yes" xml:space="preserve">
          <source>With a list of integers.</source>
          <target state="translated">정수 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3527efe8e362c867daba31b190d7b149dc553954" translate="yes" xml:space="preserve">
          <source>With a scalar integer.</source>
          <target state="translated">스칼라 정수</target>
        </trans-unit>
        <trans-unit id="b805e84a011c2b52a47f01f775ac4ab2749ba04e" translate="yes" xml:space="preserve">
          <source>With binary operations between pandas data structures, there are two key points of interest:</source>
          <target state="translated">pandas 데이터 구조 간의 이진 연산에는 두 가지 주요 관심 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c95681122f07594b1049e7bfd354d4259e6806e1" translate="yes" xml:space="preserve">
          <source>With grouped &lt;code&gt;Series&lt;/code&gt; you can also pass a list or dict of functions to do aggregation with, outputting a DataFrame:</source>
          <target state="translated">그룹화 된 &lt;code&gt;Series&lt;/code&gt; 를 사용하면 집계를 수행 할 함수 목록 또는 사전을 전달하여 DataFrame을 출력 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1e6b2f6e3dda068eaa62a89dabc1d44078675ab" translate="yes" xml:space="preserve">
          <source>With heterogeneous data, the lowest common type will have to be used.</source>
          <target state="translated">이기종 데이터의 경우 가장 낮은 공통 유형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2cee32768824581250b82cf3464754562a44f6c1" translate="yes" xml:space="preserve">
          <source>With heterogenous data, the lowest common type will have to be used.</source>
          <target state="translated">이종 데이터의 경우 가장 낮은 공통 유형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c581d3ffea66627b46a84ceeef011711972661cd" translate="yes" xml:space="preserve">
          <source>With lists of integers.</source>
          <target state="translated">정수 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c4a6baa2322a3867d7709ca97fff0f772c7fab" translate="yes" xml:space="preserve">
          <source>With more than one value:</source>
          <target state="translated">둘 이상의 값으로</target>
        </trans-unit>
        <trans-unit id="477a3a149f6d19ee116e6e2b6f7cb2d7f2b1eca7" translate="yes" xml:space="preserve">
          <source>With multiple id columns</source>
          <target state="translated">여러 ID 열</target>
        </trans-unit>
        <trans-unit id="4450db92c2b9a13323e169e8efcd96c925c780a3" translate="yes" xml:space="preserve">
          <source>With no defaults.</source>
          <target state="translated">기본값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f3e2f5f9dab013c6a7ef811944664945bf1be6f2" translate="yes" xml:space="preserve">
          <source>With pandas, column selection is done by passing a list of column names to your DataFrame:</source>
          <target state="translated">팬더를 사용하면 열 이름 목록을 DataFrame에 전달하여 열을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d1baf1779a1a9f61f8da771fa8410d352b782cbc" translate="yes" xml:space="preserve">
          <source>With scalar integers.</source>
          <target state="translated">스칼라 정수</target>
        </trans-unit>
        <trans-unit id="88da2dbf769c79cfd8b0bb4ed72ff7b00ea97291" translate="yes" xml:space="preserve">
          <source>With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the &lt;code&gt;chunksize&lt;/code&gt; parameter when calling &lt;code&gt;to_sql&lt;/code&gt;. For example, the following writes &lt;code&gt;data&lt;/code&gt; to the database in batches of 1000 rows at a time:</source>
          <target state="translated">일부 데이터베이스의 경우 큰 DataFrame을 작성하면 패킷 크기 제한 초과로 인해 오류가 발생할 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ &lt;code&gt;to_sql&lt;/code&gt; 을 호출 할 때 &lt;code&gt;chunksize&lt;/code&gt; 매개 변수 를 설정하면이를 방지 할 수 있습니다 . 예를 들어 다음은 한 번에 1000 개 행의 일괄 처리로 데이터베이스에 &lt;code&gt;data&lt;/code&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="8202dab7baa41c60012d05d28b30310e346910c0" translate="yes" xml:space="preserve">
          <source>With stubnames [&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;], this function expects to find one or more group of columns with format A-suffix1, A-suffix2,&amp;hellip;, B-suffix1, B-suffix2,&amp;hellip; You specify what you want to call this suffix in the resulting long format with</source>
          <target state="translated">스텁 이름 [ 'A', 'B']를 사용하면이 함수는 형식이 A-suffix1, A-suffix2,&amp;hellip;, B-suffix1, B-suffix2,&amp;hellip; 인 하나 이상의 열 그룹을 찾습니다. 원하는 것을 지정합니다. 결과적으로 긴 형식으로이 접미사를 다음과 같이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="676563e9aa16b37ee7bb915a3f1c275643187e50" translate="yes" xml:space="preserve">
          <source>With stubnames [&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;], this function expects to find one or more group of columns with format A-suffix1, A-suffix2,&amp;hellip;, B-suffix1, B-suffix2,&amp;hellip; You specify what you want to call this suffix in the resulting long format with &lt;code&gt;j&lt;/code&gt; (for example &lt;code&gt;j=&amp;rsquo;year&amp;rsquo;&lt;/code&gt;)</source>
          <target state="translated">stubnames [ 'A', 'B']를 사용하면이 함수는 A-suffix1, A-suffix2,&amp;hellip;, B-suffix1, B-suffix2 형식의 하나 이상의 열 그룹을 찾을 것으로 예상합니다. &lt;code&gt;j&lt;/code&gt; 를 사용 하여 긴 형식으로이 접미사를 호출하십시오 (예 : &lt;code&gt;j=&amp;rsquo;year&amp;rsquo;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d8a4b9d08d97e45adb4da87468c9bc15fb87e195" translate="yes" xml:space="preserve">
          <source>With the</source>
          <target state="translated">이랑</target>
        </trans-unit>
        <trans-unit id="88be41d156307a291564b940fe613fedb3dddf39" translate="yes" xml:space="preserve">
          <source>With the &amp;lsquo;keep&amp;rsquo; parameter, the selection behaviour of duplicated values can be changed. The value &amp;lsquo;first&amp;rsquo; keeps the first occurrence for each set of duplicated entries. The default value of keep is &amp;lsquo;first&amp;rsquo;.</source>
          <target state="translated">'keep'매개 변수를 사용하면 복제 된 값의 선택 동작을 변경할 수 있습니다. 'first'값은 각 중복 항목 세트에 대해 첫 번째 발생을 유지합니다. keep의 기본값은 'first'입니다.</target>
        </trans-unit>
        <trans-unit id="e8cff31ccb661d4a8245ac46d1bdb4b837a7fea4" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;Resampler&lt;/code&gt; object in hand, iterating through the grouped data is very natural and functions similarly to &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.groupby&quot;&gt;&lt;code&gt;itertools.groupby()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">으로 &lt;code&gt;Resampler&lt;/code&gt; 손 오브젝트 그룹화 된 데이터를 반복하는 것은 매우 유사하게 자연 함수이다 &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.groupby&quot;&gt; &lt;code&gt;itertools.groupby()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9ea41341cd10db335ab7af75a8790e97bc90c1d1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;name&lt;/code&gt; parameter set we set a custom name for the yielded namedtuples:</source>
          <target state="translated">으로 &lt;code&gt;name&lt;/code&gt; 매개 변수를 우리가 굴복 namedtuples에 대한 사용자 지정 이름을 설정 :</target>
        </trans-unit>
        <trans-unit id="f79a85a04e14f729d57a4e08aec072bead273225" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;tz&lt;/code&gt; parameter, we can change the DatetimeIndex to other time zones:</source>
          <target state="translated">으로 &lt;code&gt;tz&lt;/code&gt; 매개 변수, 우리는 다른 시간대에 DatetimeIndex을 변경할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="932fefd596d9b20b6c83c665a9e1d936ffcbfd62" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;tz=None&lt;/code&gt;, we can remove the time zone information while keeping the local time (not converted to UTC):</source>
          <target state="translated">&lt;code&gt;tz=None&lt;/code&gt; 을 사용하면 현지 시간을 유지하면서 시간대 정보를 제거 할 수 있습니다 (UTC로 변환되지 않음).</target>
        </trans-unit>
        <trans-unit id="141c115f799d02a71683c4d9b4567760b0b1e534" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;tz=None&lt;/code&gt;, we can remove the timezone (after converting to UTC if necessary):</source>
          <target state="translated">&lt;code&gt;tz=None&lt;/code&gt; 을 사용하면 시간대를 제거 할 수 있습니다 (필요한 경우 UTC로 변환 한 후).</target>
        </trans-unit>
        <trans-unit id="567bf3605bbc2143ba4c0f737a06b5792749b8c5" translate="yes" xml:space="preserve">
          <source>With the GroupBy object in hand, iterating through the grouped data is very natural and functions similarly to &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.groupby&quot;&gt;&lt;code&gt;itertools.groupby()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GroupBy 객체를 사용하면 그룹화 된 데이터를 반복하는 것은 매우 자연스럽고 &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.groupby&quot;&gt; &lt;code&gt;itertools.groupby()&lt;/code&gt; &lt;/a&gt; 와 유사한 기능을합니다 .</target>
        </trans-unit>
        <trans-unit id="6c63eb155632e5189d917b565a5cf87ff0f178cc" translate="yes" xml:space="preserve">
          <source>With the choice methods &lt;a href=&quot;#indexing-label&quot;&gt;Selection by Label&lt;/a&gt;, &lt;a href=&quot;#indexing-integer&quot;&gt;Selection by Position&lt;/a&gt;, and &lt;a href=&quot;advanced#advanced&quot;&gt;Advanced Indexing&lt;/a&gt; you may select along more than one axis using boolean vectors combined with other indexing expressions.</source>
          <target state="translated">선택 방법과 &lt;a href=&quot;#indexing-label&quot;&gt;라벨에 의해 선택&lt;/a&gt; , &lt;a href=&quot;#indexing-integer&quot;&gt;선택 위치에 의해&lt;/a&gt; , 그리고 &lt;a href=&quot;advanced#advanced&quot;&gt;고급 색인&lt;/a&gt; 하나가 다른 색인 표현과 함께 부울 벡터를 사용하여 축보다 더 많은 따라 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="947cfadad1758b850bbde75c2aec746aef4b51ba" translate="yes" xml:space="preserve">
          <source>With time series data, using pad/ffill is extremely common so that the &amp;ldquo;last known value&amp;rdquo; is available at every time point.</source>
          <target state="translated">시계열 데이터의 경우 채우기 / 채우기를 사용하는 것이 매우 일반적이므로 모든 시점에서 &quot;마지막으로 알려진 값&quot;을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df7a168ce7f24eda6bf5b05b717dda33bf878ad1" translate="yes" xml:space="preserve">
          <source>Without a little bit of context many of these arguments don&amp;rsquo;t make much sense. Let&amp;rsquo;s revisit the above example. Suppose we wanted to associate specific keys with each of the pieces of the chopped up DataFrame. We can do this using the &lt;code&gt;keys&lt;/code&gt; argument:</source>
          <target state="translated">약간의 맥락이 없다면 이러한 많은 논증은 의미가 없습니다. 위의 예를 다시 살펴 보겠습니다. 특정 키를 잘게 잘린 DataFrame의 각 조각과 연결하려고한다고 가정합니다. &lt;code&gt;keys&lt;/code&gt; 인수를 사용하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78afe455af4da05512804607872f0e31af62c9ae" translate="yes" xml:space="preserve">
          <source>Without filling the missing values you get:</source>
          <target state="translated">결 측값을 채우지 않으면 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcd7f12c4bc462949522eb537bad1134056dc70d" translate="yes" xml:space="preserve">
          <source>Without the</source>
          <target state="translated">없이</target>
        </trans-unit>
        <trans-unit id="de664ffc9468de3bcb32cfa2b4af8a8b29b4d78e" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;n&lt;/code&gt; parameter, the outputs of &lt;code&gt;rsplit&lt;/code&gt; and &lt;code&gt;split&lt;/code&gt; are identical.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 매개 변수가 없으면 &lt;code&gt;rsplit&lt;/code&gt; 및 &lt;code&gt;split&lt;/code&gt; 의 출력 이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="75bb90c9bc196df1aec374b3df0b2a84c13f3830" translate="yes" xml:space="preserve">
          <source>Working with categories</source>
          <target state="translated">카테고리 작업</target>
        </trans-unit>
        <trans-unit id="2e481cab17f2a48dbcb2e44baa39ed3a7aac4433" translate="yes" xml:space="preserve">
          <source>Working with missing data</source>
          <target state="translated">누락 된 데이터 작업</target>
        </trans-unit>
        <trans-unit id="7181810c540518b9158e4576133fc1536a22701c" translate="yes" xml:space="preserve">
          <source>Working with options</source>
          <target state="translated">옵션 작업</target>
        </trans-unit>
        <trans-unit id="4d89f171cd4b6a5e3b13a9c049cf45c6543b35fb" translate="yes" xml:space="preserve">
          <source>Working with text data</source>
          <target state="translated">텍스트 데이터 작업</target>
        </trans-unit>
        <trans-unit id="03aadeb23b8e7055c0a48ecf6eb50e8edddab538" translate="yes" xml:space="preserve">
          <source>Working with the code</source>
          <target state="translated">코드 작업</target>
        </trans-unit>
        <trans-unit id="4e8c1cbd3b0aba9c51aa1429902ef1f8f29e12e2" translate="yes" xml:space="preserve">
          <source>Working with time zones</source>
          <target state="translated">시간대 작업</target>
        </trans-unit>
        <trans-unit id="e356dc9e193234ce62e83e2251cfdb8ad56d79bc" translate="yes" xml:space="preserve">
          <source>Works exactly like relativedelta in terms of the keyword args you pass in, use of the keyword n is discouraged&amp;ndash; you would be better off specifying n in the keywords you use, but regardless it is there for you. n is needed for DateOffset subclasses.</source>
          <target state="translated">전달하는 키워드 인수 측면에서 relativedelta와 정확히 동일하게 작동하므로 키워드 n을 사용하지 않는 것이 좋습니다. 사용하는 키워드에 n을 지정하는 것이 좋습니다. DateOffset 서브 클래스에는 n이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cefcfa77bf60fa2f8dbef3c2547b747c7cd48520" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;Index.is_&lt;/code&gt; but also checks metadata.</source>
          <target state="translated">&lt;code&gt;Index.is_&lt;/code&gt; 처럼 작동 하지만 메타 데이터도 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e651ec94cff9276272e3a04d5e2ffd34208a5824" translate="yes" xml:space="preserve">
          <source>Works on different Index of types.</source>
          <target state="translated">다른 유형의 인덱스에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="30bffa03f8735cbc1234a62f7fd066d119a3d464" translate="yes" xml:space="preserve">
          <source>World Bank</source>
          <target state="translated">세계 은행</target>
        </trans-unit>
        <trans-unit id="c8d19d3de16186ed90608b4170c930f7a18b3c62" translate="yes" xml:space="preserve">
          <source>Wrap long strings in the Series/Index to be formatted in paragraphs with length less than a given width.</source>
          <target state="translated">주어진 너비보다 길이가 짧은 단락에서 서식을 지정하도록 시리즈 / 인덱스에 긴 문자열을 줄 바꿈하십시오.</target>
        </trans-unit>
        <trans-unit id="dbb63b193b1553a4ba3c2548032d46b816a42c85" translate="yes" xml:space="preserve">
          <source>Wrap strings in Series/Index at specified line width.</source>
          <target state="translated">시리즈 / 인덱스의 문자열을 지정된 선 너비로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="fe577c70c32775b33ccc2ffa6933ef8dd57c21ab" translate="yes" xml:space="preserve">
          <source>Wringing a little more performance out of &lt;code&gt;read_excel&lt;/code&gt; Internally, Excel stores all numeric data as floats. Because this can produce unexpected behavior when reading in data, pandas defaults to trying to convert integers to floats if it doesn&amp;rsquo;t lose information (&lt;code&gt;1.0 --&amp;gt;
1&lt;/code&gt;). You can pass &lt;code&gt;convert_float=False&lt;/code&gt; to disable this behavior, which may give a slight performance improvement.</source>
          <target state="translated">밖으로 조금 더 성능을 쥐어 짜기 &lt;code&gt;read_excel&lt;/code&gt; 내부적으로, 엑셀 저장 수레 모든 숫자 데이터를. 데이터를 읽을 때 예상치 못한 동작이 발생할 수 있기 때문에 Pandas는 기본적으로 정보를 잃지 않는 경우 정수를 부동 소수점으로 변환하려고 시도합니다 ( &lt;code&gt;1.0 --&amp;gt; 1&lt;/code&gt; ). &lt;code&gt;convert_float=False&lt;/code&gt; 를 전달 하여이 동작을 비활성화하면 약간의 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd42110e04fff470b7ec75ecdc92dc219432bd6" translate="yes" xml:space="preserve">
          <source>Write DataFrame index as a column. Uses</source>
          <target state="translated">DataFrame 인덱스를 열로 씁니다. 용도</target>
        </trans-unit>
        <trans-unit id="394425c10464dc8577445f01060182d0104c2181" translate="yes" xml:space="preserve">
          <source>Write DataFrame index as a column. Uses &lt;code&gt;index_label&lt;/code&gt; as the column name in the table.</source>
          <target state="translated">DataFrame 인덱스를 열로 작성하십시오. &lt;code&gt;index_label&lt;/code&gt; 을 테이블의 열 이름으로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="c164f66aede4d77e94cbf139d32c258bfdc1ae00" translate="yes" xml:space="preserve">
          <source>Write DataFrame to a SQL database.</source>
          <target state="translated">SQL 데이터베이스에 DataFrame을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6f2e27368add3b50a0ecf9ba34b4932f3c45fed9" translate="yes" xml:space="preserve">
          <source>Write DataFrame to a comma-separated values (csv) file.</source>
          <target state="translated">쉼표로 구분 된 값 (csv) 파일에 DataFrame을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="92d4292c33ad00372f279e5ab3be8c6bc620bd5d" translate="yes" xml:space="preserve">
          <source>Write DataFrame to an Excel file.</source>
          <target state="translated">DataFrame을 Excel 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="d40f6901eb637b818417c804b4b777c928e3b517" translate="yes" xml:space="preserve">
          <source>Write DataFrame to an HDF5 file.</source>
          <target state="translated">DataFrame을 HDF5 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="683955a691078d823568f49c7634935a3f07f3f4" translate="yes" xml:space="preserve">
          <source>Write MultiIndex and Hierarchical Rows as merged cells.</source>
          <target state="translated">다중 인덱스 및 계층 행을 병합 된 셀로 씁니다.</target>
        </trans-unit>
        <trans-unit id="3b27b95178c702f107b1f90d2a6695cb61861b96" translate="yes" xml:space="preserve">
          <source>Write Styler to an Excel sheet.</source>
          <target state="translated">스타일러를 Excel 시트에 씁니다.</target>
        </trans-unit>
        <trans-unit id="c1b3cff87dd1d9c51b928c32a4c2070d51a615f8" translate="yes" xml:space="preserve">
          <source>Write a DataFrame to Google BigQuery.</source>
          <target state="translated">Google BigQuery에 DataFrame을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b83334d4a758569938692544de7dc98076100bbb" translate="yes" xml:space="preserve">
          <source>Write a DataFrame to a Google BigQuery table.</source>
          <target state="translated">Google BigQuery 테이블에 DataFrame을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="264d8b4cb7c15325021244c380397e40b38bc3c8" translate="yes" xml:space="preserve">
          <source>Write a DataFrame to a comma-separated values (csv) file.</source>
          <target state="translated">쉼표로 구분 된 값 (csv) 파일에 DataFrame을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="99a7526998fbd634a7ab24da55f48fec95b8ead9" translate="yes" xml:space="preserve">
          <source>Write a DataFrame to the binary Feather format.</source>
          <target state="translated">이진 Feather 형식으로 DataFrame을 씁니다.</target>
        </trans-unit>
        <trans-unit id="a523402a24bfeeb314ecf21c86f23560c3abf482" translate="yes" xml:space="preserve">
          <source>Write a DataFrame to the binary parquet format.</source>
          <target state="translated">이진 마루 형식으로 DataFrame을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="eb96fbd75c944650b2892e1eedafd8292c8c2b5d" translate="yes" xml:space="preserve">
          <source>Write a HDF file from a DataFrame.</source>
          <target state="translated">DataFrame에서 HDF 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="adfd99572318beb377f0cb70269307883e59e692" translate="yes" xml:space="preserve">
          <source>Write a csv file.</source>
          <target state="translated">CSV 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cd97aa18da561ab532fce87a169854e944f45498" translate="yes" xml:space="preserve">
          <source>Write a description of your changes in the &lt;code&gt;Preview Discussion&lt;/code&gt; tab</source>
          <target state="translated">&lt;code&gt;Preview Discussion&lt;/code&gt; 탭 에서 변경 사항에 대한 설명을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="aa22dcf0c1a934fb32a6ccf79a810f1ea38bdf1a" translate="yes" xml:space="preserve">
          <source>Write a multi-row index CSV without writing duplicates</source>
          <target state="translated">중복을 작성하지 않고 다중 행 색인 CSV 작성</target>
        </trans-unit>
        <trans-unit id="99530cd9f65dbec1f783bd1b35af668db65927f0" translate="yes" xml:space="preserve">
          <source>Write a new test that asserts a warning is issued when calling with the deprecated argument</source>
          <target state="translated">더 이상 사용되지 않는 인수로 호출 할 때 경고가 표시되도록하는 새 테스트 작성</target>
        </trans-unit>
        <trans-unit id="6af60f969a23a9b1aebe377291ec8a0bad9311f1" translate="yes" xml:space="preserve">
          <source>Write a text representation of object to the system clipboard. This can be pasted into Excel, for example.</source>
          <target state="translated">객체의 텍스트 표현을 시스템 클립 보드에 씁니다. 예를 들어 Excel에 붙여 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc9ea651d8391f3377170ce9108678eea0fe4a93" translate="yes" xml:space="preserve">
          <source>Write as a PyTables Table structure which may perform worse but allow more flexible operations like searching / selecting subsets of the data</source>
          <target state="translated">PyTables Table 구조로 작성하면 성능이 저하 될 수 있지만 데이터 하위 집합 검색 / 선택과 같은보다 유연한 작업이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a75b07386bdff928c15327548914dd3f90837ad2" translate="yes" xml:space="preserve">
          <source>Write engine to use, &amp;lsquo;openpyxl&amp;rsquo; or &amp;lsquo;xlsxwriter&amp;rsquo;. You can also set this via the options &lt;code&gt;io.excel.xlsx.writer&lt;/code&gt;, &lt;code&gt;io.excel.xls.writer&lt;/code&gt;, and &lt;code&gt;io.excel.xlsm.writer&lt;/code&gt;.</source>
          <target state="translated">사용할 'openpyxl'또는 'xlsxwriter'엔진을 작성하십시오. &lt;code&gt;io.excel.xlsx.writer&lt;/code&gt; , &lt;code&gt;io.excel.xls.writer&lt;/code&gt; 및 &lt;code&gt;io.excel.xlsm.writer&lt;/code&gt; 옵션을 통해이를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42c9f77aa546749e5e409b9a021c5df5eaaf4681" translate="yes" xml:space="preserve">
          <source>Write object to a comma-separated values (csv) file.</source>
          <target state="translated">쉼표로 구분 된 값 (csv) 파일에 개체를 씁니다.</target>
        </trans-unit>
        <trans-unit id="adfe60fd5c0ee1f3f300dc2347df46c02c0aa7c5" translate="yes" xml:space="preserve">
          <source>Write object to an Excel sheet.</source>
          <target state="translated">Excel 시트에 개체를 씁니다.</target>
        </trans-unit>
        <trans-unit id="0901b93d2c7065602e706ec71296edd57110fe25" translate="yes" xml:space="preserve">
          <source>Write out feather-format for DataFrames.</source>
          <target state="translated">DataFrames의 깃털 형식을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9f1a0f0ecee27ddc45993d06d571c030c79d7e48" translate="yes" xml:space="preserve">
          <source>Write out the binary feather-format for DataFrames.</source>
          <target state="translated">DataFrames에 대한 바이너리 페더 형식을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c429dec21f3d07efe528c5818d5d0fa48b48796e" translate="yes" xml:space="preserve">
          <source>Write out the column names. If a list of string is given it is assumed to be aliases for the column names.</source>
          <target state="translated">열 이름을 작성하십시오. 문자열 목록이 제공되면 열 이름의 별명으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d2423909a29f087eb651dbb2cad4b8ed73036aa2" translate="yes" xml:space="preserve">
          <source>Write out the column names. If a list of strings is given it is assumed to be aliases for the column names.</source>
          <target state="translated">열 이름을 작성하십시오. 문자열 목록이 제공되면 열 이름의 별명으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fda48a754b1e3702b9516e31a3de2de6ff9df0b8" translate="yes" xml:space="preserve">
          <source>Write out the column names. If a list of strings is given, it is assumed to be aliases for the column names.</source>
          <target state="translated">열 이름을 작성하십시오. 문자열 목록이 제공되면 열 이름의 별명으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="873525b5438b1e02d7f69a4f6268bc115d2d0a25" translate="yes" xml:space="preserve">
          <source>Write out to a csv file.</source>
          <target state="translated">csv 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="aa6bc24af392de08d25642fd5dd308e8723e29b5" translate="yes" xml:space="preserve">
          <source>Write records stored in a DataFrame to a SQL database.</source>
          <target state="translated">DataFrame에 저장된 레코드를 SQL 데이터베이스에 씁니다.</target>
        </trans-unit>
        <trans-unit id="b9fd5810df30326ae7fde3ba95cab45fa3098e3d" translate="yes" xml:space="preserve">
          <source>Write row names (index).</source>
          <target state="translated">행 이름 (인덱스)을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="511426d26f200a023b7d5ad3fc99ff32bb2749b3" translate="yes" xml:space="preserve">
          <source>Write the contained data to an HDF5 file using HDFStore.</source>
          <target state="translated">HDFStore를 사용하여 포함 된 데이터를 HDF5 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="1f9d4e129d8d3fc01ca5bc5124c5580fb253c46c" translate="yes" xml:space="preserve">
          <source>Write the index to Stata dataset.</source>
          <target state="translated">Stata 데이터 세트에 색인을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="fd8c37a19e2d1b435c008352b2735a9a865f1ef6" translate="yes" xml:space="preserve">
          <source>Write to a feather file.</source>
          <target state="translated">페더 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="c743a4572e5d7dabf9b23844ccc5822e56715f8a" translate="yes" xml:space="preserve">
          <source>Write to a parquet file.</source>
          <target state="translated">마루 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="12f897a5ded22c1bef9f9106497f8bbd242b47cf" translate="yes" xml:space="preserve">
          <source>Write to a sql table.</source>
          <target state="translated">SQL 테이블에 씁니다.</target>
        </trans-unit>
        <trans-unit id="f5bab973a04bdb9274be05e67d70a26b25b02ee1" translate="yes" xml:space="preserve">
          <source>Write to hdf.</source>
          <target state="translated">hdf에 씁니다.</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="4b19fc4ef6b77bca2f9cb30932840328dcfca1a9" translate="yes" xml:space="preserve">
          <source>Writes the DataFrame to a Stata dataset file. &amp;ldquo;dta&amp;rdquo; files contain a Stata dataset.</source>
          <target state="translated">DataFrame을 Stata 데이터 세트 파일에 씁니다. &quot;dta&quot;파일에는 Stata 데이터 세트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b0c965c774cb2d7882fc5e24714700dbd950b37" translate="yes" xml:space="preserve">
          <source>Writing CSVs to binary file objects</source>
          <target state="translated">바이너리 파일 개체에 CSV 쓰기</target>
        </trans-unit>
        <trans-unit id="39a785f4cb191b395c3761f0577c1007b194b770" translate="yes" xml:space="preserve">
          <source>Writing DataFrames</source>
          <target state="translated">DataFrames 작성</target>
        </trans-unit>
        <trans-unit id="038ad078864d4839a5a34971e21d2f4a3a90bc0e" translate="yes" xml:space="preserve">
          <source>Writing Excel files</source>
          <target state="translated">Excel 파일 작성</target>
        </trans-unit>
        <trans-unit id="a81f01f6170276cd8fd5eb3b6f547a0e60b6fa3a" translate="yes" xml:space="preserve">
          <source>Writing Excel files to disk</source>
          <target state="translated">디스크에 Excel 파일 쓰기</target>
        </trans-unit>
        <trans-unit id="1706a98de4dc1369dbe22d0b76a45611dee2e5cc" translate="yes" xml:space="preserve">
          <source>Writing Excel files to memory</source>
          <target state="translated">메모리에 Excel 파일 쓰기</target>
        </trans-unit>
        <trans-unit id="6325f0c707862e703d2098d7c6e40317f78a06da" translate="yes" xml:space="preserve">
          <source>Writing JSON</source>
          <target state="translated">JSON 작성</target>
        </trans-unit>
        <trans-unit id="a92ea7d38a931f7a222a6472dce41648e41db131" translate="yes" xml:space="preserve">
          <source>Writing a docstring</source>
          <target state="translated">독 스트링 작성</target>
        </trans-unit>
        <trans-unit id="ae37b1da244ee0ea7eb1b0470b6959674d2e47ed" translate="yes" xml:space="preserve">
          <source>Writing a formatted string</source>
          <target state="translated">형식화 된 문자열 작성</target>
        </trans-unit>
        <trans-unit id="e914923daddf6518b20e2032c77cdef423d939ac" translate="yes" xml:space="preserve">
          <source>Writing good code is not just about what you write. It is also about &lt;em&gt;how&lt;/em&gt; you write it. During &lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; testing, several tools will be run to check your code for stylistic errors. Generating any warnings will cause the test to fail. Thus, good style is a requirement for submitting code to &lt;em&gt;pandas&lt;/em&gt;.</source>
          <target state="translated">좋은 코드를 작성하는 것은 단지 당신이 쓰는 것에 관한 것이 아닙니다. 또한 &lt;em&gt;어떻게 쓰는지&lt;/em&gt; 에 관한 것입니다. &lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; 테스트 중에 코드에 문체 오류가 있는지 확인하기 위해 여러 도구가 실행됩니다. 경고를 생성하면 테스트가 실패합니다. 따라서 &lt;em&gt;pandas에&lt;/em&gt; 코드를 제출하려면 좋은 스타일이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="73cc60c102e7d0131b75dbff4cd56a42253bef2b" translate="yes" xml:space="preserve">
          <source>Writing in ISO date format, with microseconds:</source>
          <target state="translated">마이크로 초를 사용하여 ISO 날짜 형식으로 작성 :</target>
        </trans-unit>
        <trans-unit id="a136ba6877def44d8efd8c4b549ad2fd4d9b11a8" translate="yes" xml:space="preserve">
          <source>Writing in ISO date format:</source>
          <target state="translated">ISO 날짜 형식으로 작성 :</target>
        </trans-unit>
        <trans-unit id="f9db9d774f58f42e59f48e04d187605127ac7f17" translate="yes" xml:space="preserve">
          <source>Writing out data</source>
          <target state="translated">데이터 쓰기</target>
        </trans-unit>
        <trans-unit id="ab2816d4bb9622be7220e5163963f6a9c487ee4d" translate="yes" xml:space="preserve">
          <source>Writing tests</source>
          <target state="translated">작문 시험</target>
        </trans-unit>
        <trans-unit id="b1462cd53af83623fa08a962b2adfb5223844c91" translate="yes" xml:space="preserve">
          <source>Writing to CSV format</source>
          <target state="translated">CSV 형식으로 쓰기</target>
        </trans-unit>
        <trans-unit id="5b5d2295e4bbf5c42863d0f996efb3275d853d29" translate="yes" xml:space="preserve">
          <source>Writing to HTML files</source>
          <target state="translated">HTML 파일에 쓰기</target>
        </trans-unit>
        <trans-unit id="b20c420a3af42b5824af0c4fbae26fa549d13d2b" translate="yes" xml:space="preserve">
          <source>Writing to a CSV file will convert the data, effectively removing any information about the categorical (categories and ordering). So if you read back the CSV file you have to convert the relevant columns back to &lt;code&gt;category&lt;/code&gt; and assign the right categories and categories ordering.</source>
          <target state="translated">CSV 파일에 쓰면 데이터가 변환되어 범주 (범주 및 순서)에 대한 모든 정보가 효과적으로 제거됩니다. 따라서 CSV 파일을 다시 읽으면 관련 열을 다시 &lt;code&gt;category&lt;/code&gt; 로 변환 하고 올바른 범주와 범주 순서를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4e516721dcc799de64209ced98b3069b0562724" translate="yes" xml:space="preserve">
          <source>Writing to a HDF5 Store.</source>
          <target state="translated">HDF5 스토어에 쓰기.</target>
        </trans-unit>
        <trans-unit id="916672152a5e71e3f4bc8f9d2fc5e50f642911ed" translate="yes" xml:space="preserve">
          <source>Writing to a csv file.</source>
          <target state="translated">csv 파일에 쓰는 중입니다.</target>
        </trans-unit>
        <trans-unit id="abad245a52604b4b9f1a52731e8d570939215a99" translate="yes" xml:space="preserve">
          <source>Writing to a file, with a date index and a date column:</source>
          <target state="translated">날짜 인덱스 및 날짜 열을 사용하여 파일에 쓰기 :</target>
        </trans-unit>
        <trans-unit id="03f4af03976102eebd9b46eed2633007e0e4c5ab" translate="yes" xml:space="preserve">
          <source>Writing to an excel file.</source>
          <target state="translated">엑셀 파일에 쓰기.</target>
        </trans-unit>
        <trans-unit id="c4fc5c06f1d16e12094e5865a5b81bb06b126c4a" translate="yes" xml:space="preserve">
          <source>Writing to stata format</source>
          <target state="translated">stata 형식으로 쓰기</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="71e81cf0fb90ea960486d9d80b22afe143323a01" translate="yes" xml:space="preserve">
          <source>X is a specific day of the week. Y is a certain month of the year</source>
          <target state="translated">X는 특정 요일입니다. Y는 연중 특정 달입니다</target>
        </trans-unit>
        <trans-unit id="a5510f6f11a8f7d32126db4ecd6f44bce6bcf456" translate="yes" xml:space="preserve">
          <source>XLsxWriter</source>
          <target state="translated">XLsxWriter</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="66aa7d2fcf0b755c5484df26686c8b66d30a9ac0" translate="yes" xml:space="preserve">
          <source>Year value of the period.</source>
          <target state="translated">기간의 연도 값입니다.</target>
        </trans-unit>
        <trans-unit id="b5b7f5d30699e5d4e15b4875dbd3728c364030a0" translate="yes" xml:space="preserve">
          <source>Year with century as a decimal number.</source>
          <target state="translated">십진수로 세기를 가진 년.</target>
        </trans-unit>
        <trans-unit id="c64879d90ccc2fc0d06f018314bfc95458d99f67" translate="yes" xml:space="preserve">
          <source>Year without century as a decimal number [00,99].</source>
          <target state="translated">세기가없는 연도 (10 진수) [00,99].</target>
        </trans-unit>
        <trans-unit id="1ac165ee16905744dd627392257b78d2b5789bc6" translate="yes" xml:space="preserve">
          <source>YearBegin</source>
          <target state="translated">YearBegin</target>
        </trans-unit>
        <trans-unit id="fdd77a631d0eb873f7d3b0dac6851d398444ab6c" translate="yes" xml:space="preserve">
          <source>YearBegin.apply()</source>
          <target state="translated">YearBegin.apply()</target>
        </trans-unit>
        <trans-unit id="672e0c9cdc1b071415ff684a724f92e4d420fade" translate="yes" xml:space="preserve">
          <source>YearBegin.apply_index()</source>
          <target state="translated">YearBegin.apply_index()</target>
        </trans-unit>
        <trans-unit id="5d524321f5fb37988d0d83f373cdeb8cd9a45737" translate="yes" xml:space="preserve">
          <source>YearBegin.base</source>
          <target state="translated">YearBegin.base</target>
        </trans-unit>
        <trans-unit id="850021a848b1fc34cc164d40576e5ba9edea00b8" translate="yes" xml:space="preserve">
          <source>YearBegin.copy()</source>
          <target state="translated">YearBegin.copy()</target>
        </trans-unit>
        <trans-unit id="73a6c9537c18476d419ef0fcb77ef08b25c31056" translate="yes" xml:space="preserve">
          <source>YearBegin.freqstr</source>
          <target state="translated">YearBegin.freqstr</target>
        </trans-unit>
        <trans-unit id="cc2599fd1415af77db1d6fe1086b987c11e32bb4" translate="yes" xml:space="preserve">
          <source>YearBegin.isAnchored()</source>
          <target state="translated">YearBegin.isAnchored()</target>
        </trans-unit>
        <trans-unit id="699be22356cb032aa21378a467cade3e8dc2df9b" translate="yes" xml:space="preserve">
          <source>YearBegin.kwds</source>
          <target state="translated">YearBegin.kwds</target>
        </trans-unit>
        <trans-unit id="e68325e106debc2cdea74e6cb896060354399b86" translate="yes" xml:space="preserve">
          <source>YearBegin.name</source>
          <target state="translated">YearBegin.name</target>
        </trans-unit>
        <trans-unit id="cdb7a9f727765eb6d04c675af79ee8ba31e95284" translate="yes" xml:space="preserve">
          <source>YearBegin.nanos</source>
          <target state="translated">YearBegin.nanos</target>
        </trans-unit>
        <trans-unit id="49944295085396d076ab76e727ffd1ebb6ab0503" translate="yes" xml:space="preserve">
          <source>YearBegin.normalize</source>
          <target state="translated">YearBegin.normalize</target>
        </trans-unit>
        <trans-unit id="97a411e08b2df85b21131a643a61b6c013513dd4" translate="yes" xml:space="preserve">
          <source>YearBegin.onOffset()</source>
          <target state="translated">YearBegin.onOffset()</target>
        </trans-unit>
        <trans-unit id="45e0c1689f38462c0f2d560229b934f25c901805" translate="yes" xml:space="preserve">
          <source>YearBegin.rollback()</source>
          <target state="translated">YearBegin.rollback()</target>
        </trans-unit>
        <trans-unit id="70e33f36e92a7135b43807223828e9514d5479ff" translate="yes" xml:space="preserve">
          <source>YearBegin.rollforward()</source>
          <target state="translated">YearBegin.rollforward()</target>
        </trans-unit>
        <trans-unit id="bb88e81513b6e329bf6cf17fee7a48f8bc4a934a" translate="yes" xml:space="preserve">
          <source>YearBegin.rule_code</source>
          <target state="translated">YearBegin.rule_code</target>
        </trans-unit>
        <trans-unit id="af4c7e983311e56413b0407da79b71ce0f3cddd5" translate="yes" xml:space="preserve">
          <source>YearEnd</source>
          <target state="translated">YearEnd</target>
        </trans-unit>
        <trans-unit id="dff72c415986f2a06b2fe20403d7616cd9ed15f9" translate="yes" xml:space="preserve">
          <source>YearEnd.apply()</source>
          <target state="translated">YearEnd.apply()</target>
        </trans-unit>
        <trans-unit id="49751f8e3f83951f0d9ef2a783ed86fbb8156c67" translate="yes" xml:space="preserve">
          <source>YearEnd.apply_index()</source>
          <target state="translated">YearEnd.apply_index()</target>
        </trans-unit>
        <trans-unit id="8cf6200a6413c48b5ad861746fdc009e4ef71c86" translate="yes" xml:space="preserve">
          <source>YearEnd.base</source>
          <target state="translated">YearEnd.base</target>
        </trans-unit>
        <trans-unit id="1336794d93bd406cae3ff76ef17d8bd61b043c67" translate="yes" xml:space="preserve">
          <source>YearEnd.copy()</source>
          <target state="translated">YearEnd.copy()</target>
        </trans-unit>
        <trans-unit id="5d6a62799b417202d2c595d55874af1dfb172245" translate="yes" xml:space="preserve">
          <source>YearEnd.freqstr</source>
          <target state="translated">YearEnd.freqstr</target>
        </trans-unit>
        <trans-unit id="327371506ca5103e7a0bdb7c0e1199013191736e" translate="yes" xml:space="preserve">
          <source>YearEnd.isAnchored()</source>
          <target state="translated">YearEnd.isAnchored()</target>
        </trans-unit>
        <trans-unit id="4049ad87a77bd7e5092b1c50e33a427059a1fe19" translate="yes" xml:space="preserve">
          <source>YearEnd.kwds</source>
          <target state="translated">YearEnd.kwds</target>
        </trans-unit>
        <trans-unit id="60111ed5e5fd4a1fb24155acfb40a4645ff3d734" translate="yes" xml:space="preserve">
          <source>YearEnd.name</source>
          <target state="translated">YearEnd.name</target>
        </trans-unit>
        <trans-unit id="eeb6cb64a863c1bfdab88227efcf78795aa58515" translate="yes" xml:space="preserve">
          <source>YearEnd.nanos</source>
          <target state="translated">YearEnd.nanos</target>
        </trans-unit>
        <trans-unit id="95cd3f53f2a8e489b3312b84824dca77474215e4" translate="yes" xml:space="preserve">
          <source>YearEnd.normalize</source>
          <target state="translated">YearEnd.normalize</target>
        </trans-unit>
        <trans-unit id="8c66764417acee91205d28eb1237bb244b3087ce" translate="yes" xml:space="preserve">
          <source>YearEnd.onOffset()</source>
          <target state="translated">YearEnd.onOffset()</target>
        </trans-unit>
        <trans-unit id="a04cce1ee1073cd84e81d04379fc214a88e96d9e" translate="yes" xml:space="preserve">
          <source>YearEnd.rollback()</source>
          <target state="translated">YearEnd.rollback()</target>
        </trans-unit>
        <trans-unit id="2083f051a8a5c69c23d8ae084b08643da4ccb340" translate="yes" xml:space="preserve">
          <source>YearEnd.rollforward()</source>
          <target state="translated">YearEnd.rollforward()</target>
        </trans-unit>
        <trans-unit id="916c51f4aded10974ec6a161d5e1b8a1a72c0633" translate="yes" xml:space="preserve">
          <source>YearEnd.rule_code</source>
          <target state="translated">YearEnd.rule_code</target>
        </trans-unit>
        <trans-unit id="385293fedd37db0c53eb1d1277411a52288a8243" translate="yes" xml:space="preserve">
          <source>YearOffset</source>
          <target state="translated">YearOffset</target>
        </trans-unit>
        <trans-unit id="c5aa0b8ef3a1a08f40903ebeb4d9f2c7099effb9" translate="yes" xml:space="preserve">
          <source>YearOffset.apply()</source>
          <target state="translated">YearOffset.apply()</target>
        </trans-unit>
        <trans-unit id="656961d5067d551adabb1a1c361921bb16776ad6" translate="yes" xml:space="preserve">
          <source>YearOffset.apply_index()</source>
          <target state="translated">YearOffset.apply_index()</target>
        </trans-unit>
        <trans-unit id="4a709facb8dfe39e2b7e85e918df9dc70a533400" translate="yes" xml:space="preserve">
          <source>YearOffset.base</source>
          <target state="translated">YearOffset.base</target>
        </trans-unit>
        <trans-unit id="392cff2f7aee0fcaa3458c72bc1427d581d6d46f" translate="yes" xml:space="preserve">
          <source>YearOffset.copy()</source>
          <target state="translated">YearOffset.copy()</target>
        </trans-unit>
        <trans-unit id="28f766af4926cc0a241e47df1b6f2ba0ece24488" translate="yes" xml:space="preserve">
          <source>YearOffset.freqstr</source>
          <target state="translated">YearOffset.freqstr</target>
        </trans-unit>
        <trans-unit id="d05aa244f37ad68a9a4dd1c51fa6abca6e6f2dc2" translate="yes" xml:space="preserve">
          <source>YearOffset.isAnchored()</source>
          <target state="translated">YearOffset.isAnchored()</target>
        </trans-unit>
        <trans-unit id="ba53ad5f93c4ed5da296eabd872e3b753b8335ca" translate="yes" xml:space="preserve">
          <source>YearOffset.kwds</source>
          <target state="translated">YearOffset.kwds</target>
        </trans-unit>
        <trans-unit id="85ce4ba997c816bdf238daea3962400267db30eb" translate="yes" xml:space="preserve">
          <source>YearOffset.name</source>
          <target state="translated">YearOffset.name</target>
        </trans-unit>
        <trans-unit id="d54e0c2c005751ca858beecaa4c2b283fdfa3644" translate="yes" xml:space="preserve">
          <source>YearOffset.nanos</source>
          <target state="translated">YearOffset.nanos</target>
        </trans-unit>
        <trans-unit id="1ad7af4431f6af4982a6562ce2f2da70d863e8b6" translate="yes" xml:space="preserve">
          <source>YearOffset.normalize</source>
          <target state="translated">YearOffset.normalize</target>
        </trans-unit>
        <trans-unit id="9cdc5dbf542a1ebc16f36eb9638445512dc4b34b" translate="yes" xml:space="preserve">
          <source>YearOffset.onOffset()</source>
          <target state="translated">YearOffset.onOffset()</target>
        </trans-unit>
        <trans-unit id="4ee811f1d7142855999fc4f39678a3ac46bef58b" translate="yes" xml:space="preserve">
          <source>YearOffset.rollback()</source>
          <target state="translated">YearOffset.rollback()</target>
        </trans-unit>
        <trans-unit id="92fd38da1fceabd1a6d9254b034ca68ea1a02b63" translate="yes" xml:space="preserve">
          <source>YearOffset.rollforward()</source>
          <target state="translated">YearOffset.rollforward()</target>
        </trans-unit>
        <trans-unit id="249ea2a40140c2a3029dafe5a15998ad3d5502b6" translate="yes" xml:space="preserve">
          <source>YearOffset.rule_code</source>
          <target state="translated">YearOffset.rule_code</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="43f832eaa266991082749790db492b9a4cc7f4de" translate="yes" xml:space="preserve">
          <source>Yes (as of version 1.2)</source>
          <target state="translated">예 (버전 1.2 기준)</target>
        </trans-unit>
        <trans-unit id="738a2b66281e5ca4973cbceebc923d1996e03dad" translate="yes" xml:space="preserve">
          <source>Yields</source>
          <target state="translated">Yields</target>
        </trans-unit>
        <trans-unit id="c970e3f1e790a2a4cd28b40401902501b9bc2d74" translate="yes" xml:space="preserve">
          <source>Yields:</source>
          <target state="translated">Yields:</target>
        </trans-unit>
        <trans-unit id="24efb8c794c828bb460929f14c7ed5e9b62e0c69" translate="yes" xml:space="preserve">
          <source>Yikes!</source>
          <target state="translated">Yikes!</target>
        </trans-unit>
        <trans-unit id="202587fd5a015c1da82c6ee193ce16da7c92c960" translate="yes" xml:space="preserve">
          <source>You are highly encouraged to install both libraries. See the section &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/getting_started/install.html#install-recommended-dependencies&quot;&gt;Recommended Dependencies&lt;/a&gt; for more installation info.</source>
          <target state="translated">두 라이브러리를 모두 설치하는 것이 좋습니다. 자세한 설치 정보는 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/getting_started/install.html#install-recommended-dependencies&quot;&gt;권장 종속성&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="731e015904379ec830640f3703bd01e3a51c8462" translate="yes" xml:space="preserve">
          <source>You are highly encouraged to install these libraries, as they provide speed improvements, especially when working with large data sets.</source>
          <target state="translated">이러한 라이브러리는 특히 대용량 데이터 세트 작업시 속도 향상을 제공하므로 이러한 라이브러리를 설치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="63a54d1261a5ad1fc50692dcfa178c28097d2721" translate="yes" xml:space="preserve">
          <source>You are highly encouraged to read &lt;a href=&quot;user_guide/io#io-html-gotchas&quot;&gt;HTML Table Parsing gotchas&lt;/a&gt;. It explains issues surrounding the installation and usage of the above three libraries.</source>
          <target state="translated">&lt;a href=&quot;user_guide/io#io-html-gotchas&quot;&gt;HTML Table Parsing gotchas&lt;/a&gt; 를 읽는 것이 좋습니다 . 위 세 라이브러리의 설치 및 사용과 관련된 문제에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="14a654306fee6edf7438333e1db79653827cf52f" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;not pass&lt;/strong&gt; a &lt;code&gt;Series&lt;/code&gt; directly as a &lt;code&gt;ndarray&lt;/code&gt; typed parameter to a Cython function. Instead pass the actual &lt;code&gt;ndarray&lt;/code&gt; using the &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;Series.to_numpy()&lt;/code&gt;&lt;/a&gt;. The reason is that the Cython definition is specific to an ndarray and not the passed &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">당신은 할 수 &lt;strong&gt;통과하지 &lt;/strong&gt; &lt;code&gt;Series&lt;/code&gt; A와 직접 &lt;code&gt;ndarray&lt;/code&gt; 사이 썬 함수에 입력 매개 변수입니다. 대신 &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;Series.to_numpy()&lt;/code&gt; &lt;/a&gt; 사용하여 실제 &lt;code&gt;ndarray&lt;/code&gt; 를 전달하십시오 . 그 이유는 Cython 정의가 전달 된 &lt;code&gt;Series&lt;/code&gt; 가 아닌 ndarray에만 해당하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="bb2630c47a99b651f7db3158474212f74d8756a2" translate="yes" xml:space="preserve">
          <source>You can access the value of the fields for a scalar &lt;code&gt;Timedelta&lt;/code&gt; directly.</source>
          <target state="translated">스칼라 &lt;code&gt;Timedelta&lt;/code&gt; 의 필드 값에 직접 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac481423304ae46a6e2d7c1d93390ee8876f86ec" translate="yes" xml:space="preserve">
          <source>You can access various components of the &lt;code&gt;Timedelta&lt;/code&gt; or &lt;code&gt;TimedeltaIndex&lt;/code&gt; directly using the attributes &lt;code&gt;days,seconds,microseconds,nanoseconds&lt;/code&gt;. These are identical to the values returned by &lt;code&gt;datetime.timedelta&lt;/code&gt;, in that, for example, the &lt;code&gt;.seconds&lt;/code&gt; attribute represents the number of seconds &amp;gt;= 0 and &amp;lt; 1 day. These are signed according to whether the &lt;code&gt;Timedelta&lt;/code&gt; is signed.</source>
          <target state="translated">&lt;code&gt;days,seconds,microseconds,nanoseconds&lt;/code&gt; 속성을 사용하여 &lt;code&gt;Timedelta&lt;/code&gt; 또는 &lt;code&gt;TimedeltaIndex&lt;/code&gt; 의 다양한 구성 요소에 직접 액세스 할 수 있습니다 . 이는 &lt;code&gt;datetime.timedelta&lt;/code&gt; 에서 반환 된 값과 동일합니다. 예를 들어 &lt;code&gt;.seconds&lt;/code&gt; 속성은 초&amp;gt; = 0 및 &amp;lt;1 일을 나타냅니다. &lt;code&gt;Timedelta&lt;/code&gt; 의 서명 여부에 따라 서명됩니다.</target>
        </trans-unit>
        <trans-unit id="ac1dd4c6e5df1886203c98db1f11023c7a1ccd97" translate="yes" xml:space="preserve">
          <source>You can accidentally store a &lt;em&gt;mixture&lt;/em&gt; of strings and non-strings in an &lt;code&gt;object&lt;/code&gt; dtype array. It&amp;rsquo;s better to have a dedicated dtype.</source>
          <target state="translated">실수로 &lt;code&gt;object&lt;/code&gt; dtype 배열 에 문자열과 비 문자열 의 &lt;em&gt;혼합&lt;/em&gt; 을 저장할 수 있습니다 . 전용 dtype을 갖는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="985760ba2900ffe94a575e677c3391295caf982d" translate="yes" xml:space="preserve">
          <source>You can adjust the max width of the individual columns by setting &lt;code&gt;display.max_colwidth&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;display.max_colwidth&lt;/code&gt; 를 설정하여 개별 열의 최대 너비를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="964182a98660c212cd70f5b139f3f83307b0dc4d" translate="yes" xml:space="preserve">
          <source>You can also append to an existing Excel file:</source>
          <target state="translated">기존 Excel 파일에 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a149a4e46279291652009027e1a25f3d5130a4a" translate="yes" xml:space="preserve">
          <source>You can also assign a &lt;code&gt;dict&lt;/code&gt; to a row of a &lt;code&gt;DataFrame&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 의 행에 &lt;code&gt;dict&lt;/code&gt; 를 할당 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7656a3db5de4a0c7d245c83209d953218f8d02b" translate="yes" xml:space="preserve">
          <source>You can also chain these types of operations:</source>
          <target state="translated">다음 유형의 작업을 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7596c3bc47b26e16034cae06d000d436dbae3f17" translate="yes" xml:space="preserve">
          <source>You can also construct a &lt;code&gt;MultiIndex&lt;/code&gt; from a &lt;code&gt;DataFrame&lt;/code&gt; directly, using the method &lt;a href=&quot;../reference/api/pandas.multiindex.from_frame#pandas.MultiIndex.from_frame&quot;&gt;&lt;code&gt;MultiIndex.from_frame()&lt;/code&gt;&lt;/a&gt;. This is a complementary method to &lt;a href=&quot;../reference/api/pandas.multiindex.to_frame#pandas.MultiIndex.to_frame&quot;&gt;&lt;code&gt;MultiIndex.to_frame()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.multiindex.from_frame#pandas.MultiIndex.from_frame&quot;&gt; &lt;code&gt;MultiIndex.from_frame()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;DataFrame&lt;/code&gt; 에서 직접 &lt;code&gt;MultiIndex&lt;/code&gt; 를 생성 할 수도 있습니다 . 이것은 &lt;a href=&quot;../reference/api/pandas.multiindex.to_frame#pandas.MultiIndex.to_frame&quot;&gt; &lt;code&gt;MultiIndex.to_frame()&lt;/code&gt; &lt;/a&gt; 의 보완적인 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="9d2527b9974c1de143367b83117b0aa017af18e4" translate="yes" xml:space="preserve">
          <source>You can also create a &lt;code&gt;table&lt;/code&gt; by passing &lt;code&gt;format='table'&lt;/code&gt; or &lt;code&gt;format='t'&lt;/code&gt; to a &lt;code&gt;put&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 작업에 &lt;code&gt;format='table'&lt;/code&gt; 또는 &lt;code&gt;format='t'&lt;/code&gt; 를 전달 하여 &lt;code&gt;table&lt;/code&gt; 을 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c0dbf88c2b603343a63495d28081346c0f3fde8" translate="yes" xml:space="preserve">
          <source>You can also create these other plots using the methods &lt;code&gt;DataFrame.plot.&amp;lt;kind&amp;gt;&lt;/code&gt; instead of providing the &lt;code&gt;kind&lt;/code&gt; keyword argument. This makes it easier to discover plot methods and the specific arguments they use:</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; 키워드 인수 를 제공하는 대신 &lt;code&gt;DataFrame.plot.&amp;lt;kind&amp;gt;&lt;/code&gt; 메소드를 사용하여 이러한 다른 플롯을 작성할 수도 있습니다 . 이를 통해 플롯 메소드와 이들이 사용하는 특정 인수를보다 쉽게 ​​발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25db529875043dcb4d51bdf95c8f114d1b5464c9" translate="yes" xml:space="preserve">
          <source>You can also disable this feature via the &lt;code&gt;expand_frame_repr&lt;/code&gt; option. This will print the table in one block.</source>
          <target state="translated">&lt;code&gt;expand_frame_repr&lt;/code&gt; 옵션을 통해이 기능을 비활성화 할 수도 있습니다. 이것은 하나의 블록에 테이블을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="765028382bd31c39ba69b6dafbe2d54d980bb2c2" translate="yes" xml:space="preserve">
          <source>You can also explode the column in the &lt;code&gt;DataFrame&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 에서 열을 분해 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74931b0a2474244fea23ff46cbb7c086d2c8c23d" translate="yes" xml:space="preserve">
          <source>You can also fillna using a dict or Series that is alignable. The labels of the dict or index of the Series must match the columns of the frame you wish to fill. The use case of this is to fill a DataFrame with the mean of that column.</source>
          <target state="translated">정렬 가능한 dict 또는 Series를 사용하여 fillna를 수행 할 수도 있습니다. Series의 dict 또는 index 레이블은 채우려는 프레임의 열과 일치해야합니다. 이 사용 사례는 해당 열의 평균으로 DataFrame을 채우는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a035f08ab728bb58dbe8d13f865d591391f7f4ac" translate="yes" xml:space="preserve">
          <source>You can also format datetime values as strings with &lt;a href=&quot;../reference/api/pandas.series.dt.strftime#pandas.Series.dt.strftime&quot;&gt;&lt;code&gt;Series.dt.strftime()&lt;/code&gt;&lt;/a&gt; which supports the same format as the standard &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt; 과 동일한 형식을 지원하는 &lt;a href=&quot;../reference/api/pandas.series.dt.strftime#pandas.Series.dt.strftime&quot;&gt; &lt;code&gt;Series.dt.strftime()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 datetime 값을 문자열로 형식화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c0cf02479a4964111d53fe1834d350f7725b04f" translate="yes" xml:space="preserve">
          <source>You can also interpolate with a DataFrame:</source>
          <target state="translated">DataFrame으로 보간 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf1de63688dc43b64f9ae34e3af66bd79324c559" translate="yes" xml:space="preserve">
          <source>You can also negate, multiply and use &lt;code&gt;abs&lt;/code&gt; on &lt;code&gt;Timedeltas&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Timedeltas&lt;/code&gt; 에서 &lt;code&gt;abs&lt;/code&gt; 를 부정, 곱하고 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="350fef33f981efc67e72a8e36ace807b86394a9e" translate="yes" xml:space="preserve">
          <source>You can also operate on the DataFrame in place:</source>
          <target state="translated">DataFrame에서 작업 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bfab5a20913548c5405db225c5093c041f6dda6" translate="yes" xml:space="preserve">
          <source>You can also pass a &lt;code&gt;DataFrame&lt;/code&gt; of integer or string columns to assemble into a &lt;code&gt;Series&lt;/code&gt; of &lt;code&gt;Timestamps&lt;/code&gt;.</source>
          <target state="translated">또한 정수 또는 문자열 열의 &lt;code&gt;DataFrame&lt;/code&gt; 을 전달 하여 &lt;code&gt;Series&lt;/code&gt; 의 &lt;code&gt;Timestamps&lt;/code&gt; 로 어셈블 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61411a308d7b3304ffc617803b9e9946de99ff12" translate="yes" xml:space="preserve">
          <source>You can also pass a &lt;code&gt;name&lt;/code&gt; to be stored in the index:</source>
          <target state="translated">색인에 저장할 &lt;code&gt;name&lt;/code&gt; 을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcf24abd0cd5fba8c1c3ec8de8adc41985fe9abb" translate="yes" xml:space="preserve">
          <source>You can also pass a dict to &lt;code&gt;concat&lt;/code&gt; in which case the dict keys will be used for the &lt;code&gt;keys&lt;/code&gt; argument (unless other keys are specified):</source>
          <target state="translated">dict를 &lt;code&gt;concat&lt;/code&gt; 에 전달 하면 dict 키가 &lt;code&gt;keys&lt;/code&gt; 인수에 사용됩니다 (다른 키가 지정되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="8971f5d06619f997c03e3252097d17143d01f29c" translate="yes" xml:space="preserve">
          <source>You can also pass a list of dicts or Series:</source>
          <target state="translated">dicts 또는 Series 목록을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2170fd30a147361387ee4ca96ed832c912d336e4" translate="yes" xml:space="preserve">
          <source>You can also pass a subset of columns to plot, as well as group by multiple columns:</source>
          <target state="translated">플로팅 할 열의 하위 집합을 전달하고 여러 열을 기준으로 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d69b1a054b726546b873e28e4fbf87addc2e1bf" translate="yes" xml:space="preserve">
          <source>You can also pass an &lt;code&gt;axis&lt;/code&gt; option to only align on the specified axis:</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 옵션을 전달 하여 지정된 축에만 정렬 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a745ed869c92150ab5a5cb2e497fe80b977638f3" translate="yes" xml:space="preserve">
          <source>You can also pass parameters directly to the backend driver. For example, if you do &lt;em&gt;not&lt;/em&gt; have S3 credentials, you can still access public data by specifying an anonymous connection, such as</source>
          <target state="translated">매개 변수를 백엔드 드라이버에 직접 전달할 수도 있습니다. 예를 들어 S3 자격 증명 이 &lt;em&gt;없는&lt;/em&gt; 경우에도 다음 과 같은 익명 연결을 지정하여 퍼블릭 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdada7fe196ffcdf573aeb79d198bcdf989afc76" translate="yes" xml:space="preserve">
          <source>You can also pass the list-like object to the &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; constructor with the dtype.</source>
          <target state="translated">dtype 을 사용하여 목록과 같은 객체를 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 생성자에 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c170feaaa396be1e47b1fae5e410e0507ed43c" translate="yes" xml:space="preserve">
          <source>You can also pass the name of a dtype in the &lt;a href=&quot;https://numpy.org/doc/stable/reference/arrays.scalars.html&quot;&gt;NumPy dtype hierarchy&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://numpy.org/doc/stable/reference/arrays.scalars.html&quot;&gt;NumPy dtype 계층&lt;/a&gt; 에서 dtype의 이름을 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07041883665b5d1c51288da324d06e2fe02cb1dc" translate="yes" xml:space="preserve">
          <source>You can also run a plain query without creating a &lt;code&gt;DataFrame&lt;/code&gt; with &lt;code&gt;execute()&lt;/code&gt;. This is useful for queries that don&amp;rsquo;t return values, such as INSERT. This is functionally equivalent to calling &lt;code&gt;execute&lt;/code&gt; on the SQLAlchemy engine or db connection object. Again, you must use the SQL syntax variant appropriate for your database.</source>
          <target state="translated">&lt;code&gt;execute()&lt;/code&gt; 하여 &lt;code&gt;DataFrame&lt;/code&gt; 을 만들지 않고도 일반 쿼리를 실행할 수도 있습니다 . 이는 INSERT와 같이 값을 반환하지 않는 쿼리에 유용합니다. 이것은 SQLAlchemy 엔진 또는 db 연결 개체에서 &lt;code&gt;execute&lt;/code&gt; 을 호출 하는 것과 기능적으로 동일 합니다. 다시 말하지만, 데이터베이스에 적합한 SQL 구문 변형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a0a4d28f631eaf577752967b06e63165c1ff9be" translate="yes" xml:space="preserve">
          <source>You can also run the benchmark suite using the version of &lt;code&gt;pandas&lt;/code&gt; already installed in your current Python environment. This can be useful if you do not have virtualenv or conda, or are using the &lt;code&gt;setup.py develop&lt;/code&gt; approach discussed above; for the in-place build you need to set &lt;code&gt;PYTHONPATH&lt;/code&gt;, e.g. &lt;code&gt;PYTHONPATH=&quot;$PWD/..&quot; asv [remaining arguments]&lt;/code&gt;. You can run benchmarks using an existing Python environment by:</source>
          <target state="translated">현재 Python 환경에 이미 설치된 &lt;code&gt;pandas&lt;/code&gt; 버전을 사용하여 벤치 마크 제품군을 실행할 수도 있습니다. virtualenv 나 conda가 없거나 위에서 설명한 &lt;code&gt;setup.py develop&lt;/code&gt; 접근 방식을 사용하는 경우 유용 할 수 있습니다 . 전체 빌드의 경우 &lt;code&gt;PYTHONPATH&lt;/code&gt; 를 설정해야합니다 ( 예 : &lt;code&gt;PYTHONPATH=&quot;$PWD/..&quot; asv [remaining arguments]&lt;/code&gt; . 다음과 같은 방법으로 기존 Python 환경을 사용하여 벤치 마크를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ecf6b4938bb797ed25a045ab4b5d1d61ac64325" translate="yes" xml:space="preserve">
          <source>You can also run this command on an entire directory if necessary:</source>
          <target state="translated">필요한 경우 전체 디렉토리에서이 명령을 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="45d4bcba3b39255146bf2d40f57c229b094a365a" translate="yes" xml:space="preserve">
          <source>You can also select multiple rows from each group by specifying multiple nth values as a list of ints.</source>
          <target state="translated">여러 n 번째 값을 정수 목록으로 지정하여 각 그룹에서 여러 행을 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1d7a6c063cafcb2d91b7b07f5b30042094961fc" translate="yes" xml:space="preserve">
          <source>You can also select on the columns with &lt;code&gt;xs&lt;/code&gt;, by providing the axis argument.</source>
          <target state="translated">축 인수를 제공하여 &lt;code&gt;xs&lt;/code&gt; 가 있는 열을 선택할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b90ace766710640132a3cf30878c83f6ba90ce3" translate="yes" xml:space="preserve">
          <source>You can also set using these same indexers.</source>
          <target state="translated">이러한 동일한 인덱서를 사용하여 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b352613034b4e2e4e1b3f505ad125a4b2cc1ce3" translate="yes" xml:space="preserve">
          <source>You can also specify &lt;code&gt;halflife&lt;/code&gt; in terms of a timedelta convertible unit to specify the amount of time it takes for an observation to decay to half its value when also specifying a sequence of &lt;code&gt;times&lt;/code&gt;.</source>
          <target state="translated">당신은 또한 지정할 수 있습니다 &lt;code&gt;halflife&lt;/code&gt; 또한 일련의 지정 때 절반 값으로 붕괴로 관찰 걸리는 시간 지정하기 위해 timedelta 변환 장치의 측면에서 &lt;code&gt;times&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30f6c6e5bb0be18375b32acf5ad4c52b73caf1ba" translate="yes" xml:space="preserve">
          <source>You can also specify &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; time by keywords. The argument must be a &lt;code&gt;str&lt;/code&gt; with an &lt;code&gt;hour:minute&lt;/code&gt; representation or a &lt;code&gt;datetime.time&lt;/code&gt; instance. Specifying seconds, microseconds and nanoseconds as business hour results in &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="translated">키워드로 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 시간을 지정할 수도 있습니다 . 인수는해야 &lt;code&gt;str&lt;/code&gt; 와 &lt;code&gt;hour:minute&lt;/code&gt; 표현 또는 &lt;code&gt;datetime.time&lt;/code&gt; 의 인스턴스입니다. 초, 마이크로 초 및 나노초를 업무 시간으로 지정하면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="0e936e0ae5e61d8324defc2eeb67d4d8d11f8ee3" translate="yes" xml:space="preserve">
          <source>You can also specify a mapping dict:</source>
          <target state="translated">매핑 사전을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb43dfe98c8bdbe241d972a3de16566c1c7ffcd" translate="yes" xml:space="preserve">
          <source>You can also specify the &lt;code&gt;axis&lt;/code&gt; argument to &lt;code&gt;.loc&lt;/code&gt; to interpret the passed slicers on a single axis.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 인수를 &lt;code&gt;.loc&lt;/code&gt; 에 지정하여 단일 축에서 전달 된 슬라이서를 해석 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="561e9aaa94d259af14791c84c1b35c96da8cec09" translate="yes" xml:space="preserve">
          <source>You can also specify the mapping type.</source>
          <target state="translated">매핑 유형을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab9673fcb927c0b60628083ed2ff7e061b1379b6" translate="yes" xml:space="preserve">
          <source>You can also specify the name of the column as the &lt;code&gt;DataFrame&lt;/code&gt; index, and specify a subset of columns to be read.</source>
          <target state="translated">열 이름을 &lt;code&gt;DataFrame&lt;/code&gt; 인덱스로 지정하고 읽을 열의 하위 집합을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="560afe50723f995759a6b440af21b9bad31fdeb0" translate="yes" xml:space="preserve">
          <source>You can also specify to use multiple cores to speed up the documentation build:</source>
          <target state="translated">여러 코어를 사용하여 문서 작성 속도를 높이도록 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7314e43d3cfeb21c3ad25dfa53d7b1ecf9770954" translate="yes" xml:space="preserve">
          <source>You can also supply a point inside an interval.</source>
          <target state="translated">간격 내에 점을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e1f607e17959929ad94f45e57a43e9b8188e915d" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt;&lt;code&gt;StringDtype&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;&quot;string&quot;&lt;/code&gt; as the dtype on non-string data and it will be converted to &lt;code&gt;string&lt;/code&gt; dtype:</source>
          <target state="translated">&lt;code&gt;&quot;string&quot;&lt;/code&gt; 아닌 데이터의 dtype으로 &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt; &lt;code&gt;StringDtype&lt;/code&gt; &lt;/a&gt; / &quot;string&quot; 을 사용할 수도 있으며 &lt;code&gt;string&lt;/code&gt; dtype 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1c351be28bc73a692bb6164718ff48ea21d775e" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;reset_index&lt;/code&gt; with &lt;code&gt;MultiIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reset_index&lt;/code&gt; 와 함께 &lt;code&gt;MultiIndex&lt;/code&gt; 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d116240750f2697372348accf49876380d36e953" translate="yes" xml:space="preserve">
          <source>You can also use a dict to specify custom name columns:</source>
          <target state="translated">dict를 사용하여 사용자 지정 이름 열을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e2183fe6eb847eba041964b3eb3cd4d751b4169" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;DatetimeIndex&lt;/code&gt; constructor directly:</source>
          <target state="translated">&lt;code&gt;DatetimeIndex&lt;/code&gt; 생성자를 직접 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="983b08125da677e05a5dee465432a626974129aa" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;^&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 연산자를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91ddaa78fedadb21852e63dd4c7880259f9f0363" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;usecols&lt;/code&gt; parameter to eliminate extraneous column data that appear in some lines but not others:</source>
          <target state="translated">&lt;code&gt;usecols&lt;/code&gt; 매개 변수를 사용하여 일부 행에는 표시되지만 다른 행에는 표시되지 않는 관련없는 열 데이터를 제거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8ba421758c060107e0df5766ca5eefa4062b640" translate="yes" xml:space="preserve">
          <source>You can also use the group of a regular expression match when replacing (dict of regex -&amp;gt; dict of regex), this works for lists as well.</source>
          <target state="translated">대체 할 때 정규식 일치 그룹을 사용할 수도 있습니다 (정규식의 dict-&amp;gt; 정규식의 dict). 이것은 목록에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="82003841c20821873de86672a8117353cdaf596e" translate="yes" xml:space="preserve">
          <source>You can also use the iterator with &lt;code&gt;read_hdf&lt;/code&gt; which will open, then automatically close the store when finished iterating.</source>
          <target state="translated">&lt;code&gt;read_hdf&lt;/code&gt; 와 함께 이터레이터를 사용할 수도 있습니다. 그러면 이터 레이션 이 완료되면 자동으로 스토어가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="96874a5cab7798453a982a44aac330aeec755660" translate="yes" xml:space="preserve">
          <source>You can also use the levels of a &lt;code&gt;DataFrame&lt;/code&gt; with a &lt;a href=&quot;../reference/api/pandas.multiindex#pandas.MultiIndex&quot;&gt;&lt;code&gt;MultiIndex&lt;/code&gt;&lt;/a&gt; as if they were columns in the frame:</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 가있는 &lt;a href=&quot;../reference/api/pandas.multiindex#pandas.MultiIndex&quot;&gt; &lt;code&gt;MultiIndex&lt;/code&gt; &lt;/a&gt; 의 수준을 프레임 의 열인 것처럼 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee55529ea3dc6d792793ca18fbb64e2e870a5d67" translate="yes" xml:space="preserve">
          <source>You can always override the default type by specifying the desired SQL type of any of the columns by using the &lt;code&gt;dtype&lt;/code&gt; argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy &lt;code&gt;String&lt;/code&gt; type instead of the default &lt;code&gt;Text&lt;/code&gt; type for string columns:</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 인수 를 사용하여 열의 원하는 SQL 유형을 지정하여 항상 기본 유형을 재정의 할 수 있습니다 . 이 인수에는 열 이름을 SQLAlchemy 유형 (또는 sqlite3 대체 모드의 경우 문자열)에 매핑하는 사전이 필요합니다. 예를 들어 문자열 열에 기본 &lt;code&gt;Text&lt;/code&gt; 유형 대신 sqlalchemy &lt;code&gt;String&lt;/code&gt; 유형 을 사용하도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="2e843b2c36994229001a1fc151226d9916da0c8a" translate="yes" xml:space="preserve">
          <source>You can apply &lt;strong&gt;conditional formatting&lt;/strong&gt;, the visual styling of a DataFrame depending on the data within, by using the &lt;code&gt;DataFrame.style&lt;/code&gt; property. This is a property that returns a &lt;code&gt;Styler&lt;/code&gt; object, which has useful methods for formatting and displaying DataFrames.</source>
          <target state="translated">&lt;code&gt;DataFrame.style&lt;/code&gt; 속성 을 사용하여 데이터에 따라 DataFrame의 시각적 스타일 인 &lt;strong&gt;조건부 서식을&lt;/strong&gt; 적용 할 수 있습니다 . 이것은 DataFrames를 형식화하고 표시하는 데 유용한 메소드가 있는 &lt;code&gt;Styler&lt;/code&gt; 오브젝트 를 리턴하는 특성입니다 .</target>
        </trans-unit>
        <trans-unit id="6e6687c5e7f1f725623400ad8815180508cc7f25" translate="yes" xml:space="preserve">
          <source>You can apply NumPy &lt;a href=&quot;https://numpy.org/doc/stable/reference/ufuncs.html&quot;&gt;ufuncs&lt;/a&gt; to &lt;code&gt;SparseArray&lt;/code&gt; and get a &lt;code&gt;SparseArray&lt;/code&gt; as a result.</source>
          <target state="translated">당신은 NumPy와의 적용 할 수 있습니다 &lt;a href=&quot;https://numpy.org/doc/stable/reference/ufuncs.html&quot;&gt;ufuncs을&lt;/a&gt; 에 &lt;code&gt;SparseArray&lt;/code&gt; 하고 얻을 &lt;code&gt;SparseArray&lt;/code&gt; 을 결과로.</target>
        </trans-unit>
        <trans-unit id="61c6426c3b6e48ae92dc2b28349aeabe42b3c04f" translate="yes" xml:space="preserve">
          <source>You can apply the reductions: &lt;a href=&quot;../reference/api/pandas.dataframe.empty#pandas.DataFrame.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.dataframe.any#pandas.DataFrame.any&quot;&gt;&lt;code&gt;any()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.dataframe.all#pandas.DataFrame.all&quot;&gt;&lt;code&gt;all()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../reference/api/pandas.dataframe.bool#pandas.DataFrame.bool&quot;&gt;&lt;code&gt;bool()&lt;/code&gt;&lt;/a&gt; to provide a way to summarize a boolean result.</source>
          <target state="translated">감소를 적용하여 &lt;a href=&quot;../reference/api/pandas.dataframe.empty#pandas.DataFrame.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.dataframe.any#pandas.DataFrame.any&quot;&gt; &lt;code&gt;any()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.dataframe.all#pandas.DataFrame.all&quot;&gt; &lt;code&gt;all()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.dataframe.bool#pandas.DataFrame.bool&quot;&gt; &lt;code&gt;bool()&lt;/code&gt; &lt;/a&gt; 을 적용하여 부울 결과를 요약하는 방법을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9906a098c6b1bb2b7e04621ebec3727224033702" translate="yes" xml:space="preserve">
          <source>You can automatically create a MultiIndexed frame by passing a tuples dictionary.</source>
          <target state="translated">튜플 사전을 전달하여 MultiIndexed 프레임을 자동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04a445ae3740b3811e3f5c9c9587b048125b801b" translate="yes" xml:space="preserve">
          <source>You can call transform on a GroupBy object:</source>
          <target state="translated">GroupBy 개체에서 변환을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2520f1b00474528e6a74c05ca4eeb7ce365ce66d" translate="yes" xml:space="preserve">
          <source>You can change how much to print on a single row by setting the &lt;code&gt;display.width&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;display.width&lt;/code&gt; 옵션 을 설정하여 단일 행에 인쇄 할 양을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="579c3ea1e6f3a827405458d2c91e1baa2576e67d" translate="yes" xml:space="preserve">
          <source>You can change the semantics of the expression by passing the keyword argument &lt;code&gt;parser='python'&lt;/code&gt;. This enforces the same semantics as evaluation in Python space. Likewise, you can pass &lt;code&gt;engine='python'&lt;/code&gt; to evaluate an expression using Python itself as a backend. This is not recommended as it is inefficient compared to using &lt;code&gt;numexpr&lt;/code&gt; as the engine.</source>
          <target state="translated">키워드 인수 &lt;code&gt;parser='python'&lt;/code&gt; 을 전달하여 표현식의 의미를 변경할 수 있습니다 . 이것은 파이썬 공간에서의 평가와 동일한 의미를 적용합니다. 마찬가지로 &lt;code&gt;engine='python'&lt;/code&gt; 을 전달 하여 파이썬 자체를 백엔드로 사용하여 표현식을 평가할 수 있습니다. &lt;code&gt;numexpr&lt;/code&gt; 을 엔진 으로 사용 하는 것과 비교할 때 비효율적이므로 권장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b2c4c9680d9d936b7721f6866777ca45d46fd51e" translate="yes" xml:space="preserve">
          <source>You can check if a table exists using &lt;code&gt;has_table()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;has_table()&lt;/code&gt; 사용하여 테이블이 존재하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e17920b8db95ff1d805877c58fa79f23d1a36af6" translate="yes" xml:space="preserve">
          <source>You can check if an element belongs to it</source>
          <target state="translated">요소가 속하는지 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="64830f634aa217cd7a53612432ef28e5316d89af" translate="yes" xml:space="preserve">
          <source>You can check whether an &lt;code&gt;Index&lt;/code&gt; (storing the row or column labels) is unique with &lt;code&gt;Index.is_unique&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Index.is_unique&lt;/code&gt; 를 사용 하여 &lt;code&gt;Index&lt;/code&gt; (행 또는 열 레이블 저장)가 고유 한지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a04715e9bbb67365a237b5950e13f951862546b" translate="yes" xml:space="preserve">
          <source>You can check whether elements contain a pattern:</source>
          <target state="translated">요소에 패턴이 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0573188ba9a4a695ddaa9567321e8f2c97c9797" translate="yes" xml:space="preserve">
          <source>You can combine SQLAlchemy expressions with parameters passed to &lt;a href=&quot;../reference/api/pandas.read_sql#pandas.read_sql&quot;&gt;&lt;code&gt;read_sql()&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;sqlalchemy.bindparam()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sqlalchemy.bindparam()&lt;/code&gt; 사용하여 &lt;a href=&quot;../reference/api/pandas.read_sql#pandas.read_sql&quot;&gt; &lt;code&gt;read_sql()&lt;/code&gt; &lt;/a&gt; 전달 된 매개 변수와 SQLAlchemy 표현식을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c05802667035d0ea5668e677bd44d86243e99b77" translate="yes" xml:space="preserve">
          <source>You can combine this with other expressions for very succinct queries:</source>
          <target state="translated">매우 간결한 쿼리를 위해 이것을 다른 표현식과 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3473594966425c3226e67cf52ac42f92cadcdbe" translate="yes" xml:space="preserve">
          <source>You can combine together day and intraday offsets:</source>
          <target state="translated">일 및 일중 오프셋을 함께 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d5d1d508c9e80225db867f1374c2ae9e233c1d4" translate="yes" xml:space="preserve">
          <source>You can concatenate a mix of &lt;code&gt;Series&lt;/code&gt; and &lt;code&gt;DataFrame&lt;/code&gt; objects. The &lt;code&gt;Series&lt;/code&gt; will be transformed to &lt;code&gt;DataFrame&lt;/code&gt; with the column name as the name of the &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; 와 &lt;code&gt;DataFrame&lt;/code&gt; 객체를 혼합하여 연결할 수 있습니다 . &lt;code&gt;Series&lt;/code&gt; 로 변환한다 &lt;code&gt;DataFrame&lt;/code&gt; 의 이름과 열 이름 &lt;code&gt;Series&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5a43a5b4087e627f547501c7c4e16ef74c43f90" translate="yes" xml:space="preserve">
          <source>You can construct a &lt;code&gt;Timedelta&lt;/code&gt; scalar through various arguments, including &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;ISO 8601 Duration&lt;/a&gt; strings.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;ISO 8601 기간&lt;/a&gt; 문자열을 포함하여 다양한 인수를 통해 &lt;code&gt;Timedelta&lt;/code&gt; 스칼라를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b42e93a9b2abfcd6b12c8ffb5f719579e077df8" translate="yes" xml:space="preserve">
          <source>You can construct a &lt;code&gt;Timedelta&lt;/code&gt; scalar through various arguments:</source>
          <target state="translated">다양한 인수를 통해 &lt;code&gt;Timedelta&lt;/code&gt; 스칼라를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b0433351dbbf00e6ec71c94b7123e6c2888aa79" translate="yes" xml:space="preserve">
          <source>You can control the default missing values representation for the entire table through &lt;code&gt;set_na_rep&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;set_na_rep&lt;/code&gt; 메소드를 통해 전체 테이블에 대한 기본 결 측값 표현을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="966843b4eadaeebb266ee800f515eaa11941188e" translate="yes" xml:space="preserve">
          <source>You can control the precision of floats using pandas&amp;rsquo; regular &lt;code&gt;display.precision&lt;/code&gt; option.</source>
          <target state="translated">팬더의 일반 &lt;code&gt;display.precision&lt;/code&gt; 옵션을 사용하여 부동 소수점의 정밀도를 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c59a6302b5c143aacb46d9202140b37a6bf5eff1" translate="yes" xml:space="preserve">
          <source>You can conveniently perform element-wise comparisons when comparing a pandas data structure with a scalar value:</source>
          <target state="translated">Pandas 데이터 구조를 스칼라 값과 비교할 때 요소 별 비교를 편리하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57fdf2ff7db765f62bff01b67bad6c18e83b6558" translate="yes" xml:space="preserve">
          <source>You can convert a &lt;code&gt;Timedelta&lt;/code&gt; to an &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;ISO 8601 Duration&lt;/a&gt; string with the &lt;code&gt;.isoformat&lt;/code&gt; method</source>
          <target state="translated">당신은 변환 할 수 있습니다 &lt;code&gt;Timedelta&lt;/code&gt; 를 에 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;ISO 8601 기간&lt;/a&gt; 와 문자열 &lt;code&gt;.isoformat&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="c049812aea37e7b42d961f0e5c515e8b51db49a4" translate="yes" xml:space="preserve">
          <source>You can create &amp;ldquo;heatmaps&amp;rdquo; with the &lt;code&gt;background_gradient&lt;/code&gt; method. These require matplotlib, and we&amp;rsquo;ll use &lt;a href=&quot;http://stanford.edu/~mwaskom/software/seaborn/&quot;&gt;Seaborn&lt;/a&gt; to get a nice colormap.</source>
          <target state="translated">다음과 같이&amp;ldquo;히트 맵&amp;rdquo;을 만들 수 있습니다 &lt;code&gt;background_gradient&lt;/code&gt; 메소드를 . 여기에는 matplotlib이 필요하며 &lt;a href=&quot;http://stanford.edu/~mwaskom/software/seaborn/&quot;&gt;Seaborn&lt;/a&gt; 을 사용 하여 멋진 컬러 맵을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a35ea4622d22c841b404dd162b919408242e5a4" translate="yes" xml:space="preserve">
          <source>You can create &amp;ldquo;heatmaps&amp;rdquo; with the &lt;code&gt;background_gradient&lt;/code&gt; method. These require matplotlib, and we&amp;rsquo;ll use &lt;a href=&quot;https://stanford.edu/~mwaskom/software/seaborn/&quot;&gt;Seaborn&lt;/a&gt; to get a nice colormap.</source>
          <target state="translated">&lt;code&gt;background_gradient&lt;/code&gt; 메서드를 사용하여 &quot;히트 맵&quot;을 만들 수 있습니다 . 여기에는 matplotlib가 필요하며 &lt;a href=&quot;https://stanford.edu/~mwaskom/software/seaborn/&quot;&gt;Seaborn&lt;/a&gt; 을 사용 하여 멋진 컬러 맵을 얻을 것입니다.</target>
        </trans-unit>
        <trans-unit id="27daec38e964bd3d9043f51a6c0160aece1b125f" translate="yes" xml:space="preserve">
          <source>You can create a pie plot with &lt;a href=&quot;../reference/api/pandas.dataframe.plot.pie#pandas.DataFrame.plot.pie&quot;&gt;&lt;code&gt;DataFrame.plot.pie()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.series.plot.pie#pandas.Series.plot.pie&quot;&gt;&lt;code&gt;Series.plot.pie()&lt;/code&gt;&lt;/a&gt;. If your data includes any &lt;code&gt;NaN&lt;/code&gt;, they will be automatically filled with 0. A &lt;code&gt;ValueError&lt;/code&gt; will be raised if there are any negative values in your data.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.dataframe.plot.pie#pandas.DataFrame.plot.pie&quot;&gt; &lt;code&gt;DataFrame.plot.pie()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/api/pandas.series.plot.pie#pandas.Series.plot.pie&quot;&gt; &lt;code&gt;Series.plot.pie()&lt;/code&gt; &lt;/a&gt; 사용하여 파이 플롯을 만들 수 있습니다 . 데이터에 &lt;code&gt;NaN&lt;/code&gt; 이 포함되어 있으면 자동으로 0으로 채워집니다 . 데이터에 음수 값이 있으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="13651ebbba8343d7cc19823db86a27676d8510f4" translate="yes" xml:space="preserve">
          <source>You can create a scatter plot matrix using the &lt;code&gt;scatter_matrix&lt;/code&gt; method in &lt;code&gt;pandas.plotting&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;pandas.plotting&lt;/code&gt; 에서 &lt;code&gt;scatter_matrix&lt;/code&gt; 메서드를 사용하여 산점도 행렬을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6680b25fd7b9918fa414ea5ba6f2459b0c51a582" translate="yes" xml:space="preserve">
          <source>You can create a stratified boxplot using the &lt;code&gt;by&lt;/code&gt; keyword argument to create groupings. For instance,</source>
          <target state="translated">&lt;code&gt;by&lt;/code&gt; 키워드 인수를 사용하여 그룹화를 생성 하여 계층화 된 상자 그림을 생성 할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="74d794e9bf9e1df567e0e1059a0b33f6084562b0" translate="yes" xml:space="preserve">
          <source>You can create area plots with &lt;a href=&quot;../reference/api/pandas.series.plot.area#pandas.Series.plot.area&quot;&gt;&lt;code&gt;Series.plot.area()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe.plot.area#pandas.DataFrame.plot.area&quot;&gt;&lt;code&gt;DataFrame.plot.area()&lt;/code&gt;&lt;/a&gt;. Area plots are stacked by default. To produce stacked area plot, each column must be either all positive or all negative values.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.series.plot.area#pandas.Series.plot.area&quot;&gt; &lt;code&gt;Series.plot.area()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.dataframe.plot.area#pandas.DataFrame.plot.area&quot;&gt; &lt;code&gt;DataFrame.plot.area()&lt;/code&gt; &lt;/a&gt; 사용하여 영역 플롯을 생성 할 수 있습니다 . 영역 플롯은 기본적으로 누적됩니다. 누적 영역 그림을 생성하려면 각 열이 모두 양수이거나 모두 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e6eb0a8bc36c56347a1c2d736e06cbe9ac264429" translate="yes" xml:space="preserve">
          <source>You can create boxplots for grouped data and show them as separate subplots:</source>
          <target state="translated">그룹화 된 데이터에 대한 상자 그림을 만들고 별도의 하위 그림으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="701294502cb54fcd2755d67bef020601b316e8a6" translate="yes" xml:space="preserve">
          <source>You can create connections like so:</source>
          <target state="translated">다음과 같이 연결을 만들 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
